<!DOCTYPE html>
<!--
  BLEND MULTIPLEXER - Emotive Engine 3D Demo

  Sequential blend mode layering for complex color grading effects.

  What you'll learn:
  - Drag-and-drop layer stacking
  - Sequential blend mode application
  - Real-time shader parameter control
  - Complex color grading workflows

  Complexity: ‚≠ê‚≠ê‚≠ê‚≠ê Expert 3D Shaders
  Features: Multi-layer blend modes, drag-drop reordering, live preview
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blend Multiplexer - Emotive Engine 3D</title>
    <meta name="description" content="Multi-layer blend mode system for advanced color grading on 3D blood moon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: white;
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        .left-menu,
        .right-menu {
            width: 18vw;
            min-width: 200px;
            max-width: 280px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1.5vw;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .left-menu {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .right-menu {
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }

        .center-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 0;
            padding: 2vmin;
        }

        .section {
            margin-bottom: clamp(15px, 2vw, 25px);
            padding-bottom: clamp(12px, 1.5vw, 20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section:last-child {
            border-bottom: none;
        }

        h2 {
            font-size: clamp(11px, 1vw, 13px);
            margin-bottom: clamp(8px, 1vw, 12px);
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 1.2px;
            font-weight: 600;
        }

        .current-phase {
            text-align: center;
            font-size: clamp(32px, 3vw, 42px);
            margin: clamp(10px, 1.2vw, 15px) 0;
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.5));
        }

        .current-name {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: clamp(11px, 1vw, 13px);
            margin-bottom: clamp(10px, 1.2vw, 15px);
        }

        .phase-grid,
        .emotion-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: clamp(5px, 0.6vw, 8px);
            margin-bottom: clamp(8px, 1vw, 12px);
        }

        button {
            padding: clamp(6px, 0.7vw, 10px) clamp(3px, 0.4vw, 6px);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: clamp(6px, 0.6vw, 8px);
            cursor: pointer;
            font-size: clamp(9px, 0.8vw, 11px);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(2px, 0.3vw, 4px);
            min-width: 0;
            width: 100%;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
        }

        .slider-control {
            margin-bottom: clamp(10px, 1.2vw, 15px);
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: clamp(4px, 0.5vw, 6px);
            font-size: clamp(10px, 0.9vw, 12px);
            color: rgba(255, 255, 255, 0.7);
        }

        .slider-value {
            color: #667eea;
            font-weight: 600;
        }

        .increment-controls {
            display: flex;
            gap: clamp(4px, 0.5vw, 6px);
            margin-bottom: clamp(6px, 0.7vw, 8px);
        }

        .increment-btn {
            flex: 1;
            padding: clamp(4px, 0.5vw, 6px);
            font-size: clamp(10px, 0.9vw, 12px);
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: clamp(12px, 1.2vw, 16px);
            height: clamp(12px, 1.2vw, 16px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: clamp(12px, 1.2vw, 16px);
            height: clamp(12px, 1.2vw, 16px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.5);
        }

        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: clamp(6px, 0.6vw, 8px);
            padding: clamp(10px, 1vw, 12px);
            font-size: clamp(10px, 0.85vw, 11px);
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }

        .info-box strong {
            color: #667eea;
        }

        /* Blend Layer Cards */
        .layer-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px;
            cursor: move;
            transition: all 0.2s ease;
        }

        .layer-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(102, 126, 234, 0.5);
        }

        .layer-card.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .layer-card.drag-over {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .layer-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #667eea;
        }

        .drag-handle {
            cursor: grab;
            font-size: 16px;
            user-select: none;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .layer-controls-header {
            display: flex;
            gap: 6px;
        }

        .toggle-btn, .delete-btn {
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
        }

        .toggle-btn {
            background: rgba(100, 200, 100, 0.3);
            border: 1px solid rgba(100, 200, 100, 0.5);
            color: white;
        }

        .toggle-btn.disabled {
            background: rgba(200, 100, 100, 0.3);
            border-color: rgba(200, 100, 100, 0.5);
            opacity: 0.6;
        }

        .delete-btn {
            background: rgba(200, 100, 100, 0.3);
            border: 1px solid rgba(200, 100, 100, 0.5);
            color: white;
        }

        .layer-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .layer-select {
            width: 100%;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-size: 12px;
        }

        .layer-select option {
            background: #1a1a2e;
            color: white;
        }

        #moon-container {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1;
            border-radius: clamp(12px, 1.5vw, 20px);
            background: radial-gradient(circle at center, rgba(100, 100, 255, 0.1), transparent);
            box-shadow: 0 0 100px rgba(100, 100, 255, 0.3);
        }

        #moon-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Mobile/Tablet Responsive */
        @media (max-width: 1000px) {
            body {
                flex-direction: column;
            }

            .left-menu,
            .right-menu {
                width: 100%;
                min-width: unset;
                max-width: unset;
                max-height: 35vh;
                border: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                padding: 15px;
            }

            .left-menu {
                order: 1;
            }

            .center-content {
                order: 2;
                flex: 1;
                min-height: 30vh;
            }

            .right-menu {
                order: 3;
                border-bottom: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }

            .phase-grid,
            .emotion-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .current-phase {
                font-size: clamp(28px, 6vw, 36px);
            }
        }

        @media (max-width: 600px) {
            .phase-grid,
            .emotion-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .left-menu,
            .right-menu {
                padding: 12px;
            }
        }

        /* Scrollbar styling */
        .left-menu::-webkit-scrollbar,
        .right-menu::-webkit-scrollbar {
            width: 6px;
        }

        .left-menu::-webkit-scrollbar-track,
        .right-menu::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        .left-menu::-webkit-scrollbar-thumb,
        .right-menu::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .left-menu::-webkit-scrollbar-thumb:hover,
        .right-menu::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="left-menu">
        <div class="section">
            <h2>ü©∏ Blood Moon Eclipse</h2>
            <div class="button-grid" style="margin-bottom: 15px;">
                <button class="phase-btn active" data-eclipse="off" style="background: rgba(100, 100, 100, 0.3);">Off</button>
                <button class="phase-btn" data-eclipse="total" style="background: rgba(200, 50, 50, 0.3);">ü©∏ Total</button>
            </div>

            <div class="slider-control">
                <div class="slider-label">
                    <span>Eclipse Progress</span>
                    <span class="slider-value" id="eclipse-progress-value">0.0</span>
                </div>
                <input type="range" id="eclipse-progress-slider" min="0" max="1" step="0.01" value="0.0">
            </div>

            <div class="slider-control">
                <div class="slider-label">
                    <span>Darkening Intensity</span>
                    <span class="slider-value" id="darkening-value">0.0</span>
                </div>
                <input type="range" id="darkening-slider" min="0" max="1" step="0.01" value="0.0">
            </div>

            <div class="slider-control">
                <div class="slider-label">
                    <span>Emissive Glow</span>
                    <span class="slider-value" id="emissive-value">0.3</span>
                </div>
                <input type="range" id="emissive-slider" min="0" max="1" step="0.01" value="0.3">
            </div>

            <div class="info-box" style="margin-top: 15px;">
                <strong>Blood Moon Effect</strong><br>
                Simulates Earth's shadow passing over the moon with Rayleigh scattering creating the characteristic reddish glow.
            </div>
        </div>
    </div>
    <div class="center-content">
        <div id="moon-container"></div>
    </div>
    <div class="right-menu">
        <div class="section">
            <h2 style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <span>üé® Blend Layers</span>
                <button id="add-layer-btn" style="padding: 4px 12px; font-size: 12px; background: rgba(100, 200, 100, 0.3); border: 1px solid rgba(100, 200, 100, 0.5); color: white; border-radius: 4px; cursor: pointer;">+ Add Layer</button>
            </h2>

            <div id="layer-stack" style="display: flex; flex-direction: column; gap: 10px; pointer-events: auto;">
                <!-- Layers will be dynamically inserted here -->
            </div>

            <div class="info-box" style="margin-top: 15px;">
                <strong>Drag to Reorder</strong><br>
                Layers apply sequentially from top to bottom.<br>
                Order matters: Multiply‚ÜíDodge ‚â† Dodge‚ÜíMultiply!
            </div>
        </div>

        <div class="section">
            <div class="info-box">
                <strong>How it works:</strong><br>
                Sequential blend mode layering allows complex color grading by applying multiple Photoshop-style blend modes in order, each with individual strength control.
            </div>
        </div>
    </div>

    <script type="module">
        // Updated: 2025-01-10 - Added particle toggle, disabled blinking/breathing by default
        import EmotiveMascot3D, { setMoonPhase, animateMoonPhase } from '../../dist/emotive-mascot-3d.js?t=1736871234';

        // Store current rotation values (declared early for use in initialization)
        // Calibrated to show classic "Man in the Moon" Earth-facing view
        let currentRotation = { x: 55.5, y: -85.0, z: -60.5 };

        const container = document.getElementById('moon-container');
        const mascot = new EmotiveMascot3D({
            canvasId: 'moon',
            coreGeometry: 'moon',
            materialVariant: 'multiplexer',  // Use blend multiplexer material
            enableParticles: true,
            enableControls: true,
            autoRotate: false,
            enableBlinking: false,
            enableBreathing: false,
            cameraDistance: 1.0  // Closer default zoom
        });

        mascot.init(container);
        mascot.start();

        // Disable particles on load (initialized but hidden)
        mascot.disableParticles();

        // Set to full moon on load
        if (mascot.core3D?.customMaterial?.uniforms?.shadowOffset) {
            mascot.core3D.customMaterial.uniforms.shadowOffset.value.x = 0;
            mascot.core3D.customMaterial.uniforms.shadowOffset.value.y = 0;
        }

        // Ensure auto-rotate is OFF for tidal locking (force disable)
        setTimeout(() => {
            console.log('üîç Checking mascot structure:', {
                hasMascot: !!mascot,
                hasCore3D: !!mascot.core3D,
                hasCalibrationRotation: !!mascot.core3D?.calibrationRotation,
                hasCoreMesh: !!mascot.core3D?.coreMesh,
                hasRenderer: !!mascot.core3D?.renderer,
                hasControls: !!mascot.core3D?.renderer?.controls
            });

            if (mascot.core3D?.renderer?.controls) {
                mascot.core3D.renderer.controls.autoRotate = false;
                console.log('üîí Moon tidally locked - autoRotate forcibly disabled');
            }

            // Calibration rotation is already initialized in Core3DManager
            // Just log the current values
            if (mascot.core3D?.calibrationRotation) {
                const radX = mascot.core3D.calibrationRotation[0];
                const radY = mascot.core3D.calibrationRotation[1];
                const radZ = mascot.core3D.calibrationRotation[2];
                const degX = (radX * 180 / Math.PI).toFixed(1);
                const degY = (radY * 180 / Math.PI).toFixed(1);
                const degZ = (radZ * 180 / Math.PI).toFixed(1);
                console.log(`üåô Initial calibration rotation: X=${degX}¬∞, Y=${degY}¬∞, Z=${degZ}¬∞`);
            } else {
                console.error('‚ùå calibrationRotation not found!');
            }
        }, 500);

        console.log('‚úÖ Blend Multiplexer demo initialized');

        // Blood Moon (Lunar Eclipse) controls
        document.querySelectorAll('[data-eclipse]').forEach(button => {
            button.addEventListener('click', () => {
                const eclipseType = button.dataset.eclipse;

                // Update button states
                document.querySelectorAll('[data-eclipse]').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                if (mascot.core3D?.customMaterial?.uniforms) {
                    // Update eclipse progress
                    const progress = eclipseType === 'total' ? 1.0 : 0.0;
                    mascot.core3D.customMaterial.uniforms.eclipseProgress.value = progress;

                    document.getElementById('eclipse-progress-slider').value = progress;
                    document.getElementById('eclipse-progress-value').textContent = progress.toFixed(2);

                    console.log(`ü©∏ Eclipse: ${eclipseType} (progress: ${progress})`);
                }
            });
        });

        // Eclipse progress slider
        const eclipseProgressSlider = document.getElementById('eclipse-progress-slider');
        eclipseProgressSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('eclipse-progress-value').textContent = value.toFixed(2);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseProgress.value = value;
            }
        });

        // Emissive and darkening controls
        const emissiveSlider = document.getElementById('emissive-slider');
        const darkeningSlider = document.getElementById('darkening-slider');

        emissiveSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('emissive-value').textContent = value.toFixed(2);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.emissiveStrength.value = value;
            }
        });

        darkeningSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('darkening-value').textContent = value.toFixed(2);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseIntensity.value = value;
            }
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BLEND LAYER MANAGEMENT SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const blendModeNames = [
            'Multiply',       // 0 - Darkening
            'Linear Burn',    // 1 - Darkening
            'Color Burn',     // 2 - Darkening (intense)
            'Color Dodge',    // 3 - Brightening (intense)
            'Screen',         // 4 - Brightening
            'Overlay',        // 5 - Contrast
            'Add',            // 6 - Brightening (glow)
            'Soft Light',     // 7 - Contrast (gentle)
            'Hard Light',     // 8 - Contrast (strong)
            'Vivid Light',    // 9 - Saturation boost
            'Linear Light',   // 10 - Linear saturation
            'Difference',     // 11 - Inversion
            'Exclusion',      // 12 - Soft inversion
            'Darken',         // 13 - Comparison (darker)
            'Lighten',        // 14 - Comparison (lighter)
            'Subtract',       // 15 - Deep shadows
            'Divide',         // 16 - Ethereal glow
            'Pin Light'       // 17 - Posterization
        ];
        const layerStack = document.getElementById('layer-stack');
        const addLayerBtn = document.getElementById('add-layer-btn');

        // Layer state (max 4 layers)
        let layers = [];
        let nextLayerId = 1;
        let draggedElement = null;

        /**
         * Create a layer card HTML element
         */
        function createLayerCard(layer) {
            const card = document.createElement('div');
            card.className = 'layer-card';
            card.dataset.layerId = layer.id;
            card.draggable = true;

            card.innerHTML = `
                <div class="layer-header">
                    <div class="layer-title">
                        <span class="drag-handle">‚ãÆ‚ãÆ</span>
                        <span>Layer ${layer.position}</span>
                    </div>
                    <div class="layer-controls-header">
                        <button class="toggle-btn ${layer.enabled ? '' : 'disabled'}" data-action="toggle">
                            ${layer.enabled ? 'ON' : 'OFF'}
                        </button>
                        <button class="delete-btn" data-action="delete">‚úï</button>
                    </div>
                </div>
                <div class="layer-controls">
                    <select class="layer-select" data-action="mode">
                        ${blendModeNames.map((name, idx) =>
                            `<option value="${idx}" ${layer.mode === idx ? 'selected' : ''}>${name}</option>`
                        ).join('')}
                    </select>
                    <div class="slider-control" style="margin: 0;">
                        <div class="slider-label">
                            <span style="font-size: 11px;">Strength</span>
                            <span class="slider-value" style="font-size: 11px;">${layer.strength.toFixed(1)}</span>
                        </div>
                        <input type="range" class="layer-strength-slider" data-action="strength"
                               min="0" max="5" step="0.1" value="${layer.strength}">
                    </div>
                </div>
            `;

            // Drag handle only
            const dragHandle = card.querySelector('.drag-handle');
            dragHandle.addEventListener('mousedown', () => {
                card.draggable = true;
            });

            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragend', handleDragEnd);
            card.addEventListener('dragover', handleDragOver);
            card.addEventListener('drop', handleDrop);

            // Prevent dragging when interacting with controls
            const interactiveElements = card.querySelectorAll('select, input, button:not(.drag-handle)');
            interactiveElements.forEach(el => {
                el.addEventListener('mousedown', (e) => {
                    card.draggable = false;
                    e.stopPropagation();
                });
                el.addEventListener('mouseup', () => {
                    card.draggable = true;
                });
            });

            // Toggle button
            card.querySelector('[data-action="toggle"]').addEventListener('click', () => {
                layer.enabled = !layer.enabled;
                updateLayerCard(card, layer);
                updateShaderLayers();
            });

            // Delete button
            card.querySelector('[data-action="delete"]').addEventListener('click', () => {
                deleteLayer(layer.id);
            });

            // Mode select
            card.querySelector('[data-action="mode"]').addEventListener('change', (e) => {
                const oldMode = layer.mode;
                layer.mode = parseInt(e.target.value);
                console.log(`üéõÔ∏è Layer ${layer.position} mode changed: ${oldMode} ‚Üí ${layer.mode}`);
                updateShaderLayers();
            });

            // Strength slider - update in real-time during drag
            const strengthSlider = card.querySelector('[data-action="strength"]');
            strengthSlider.addEventListener('input', (e) => {
                layer.strength = parseFloat(e.target.value);
                card.querySelector('.slider-value').textContent = layer.strength.toFixed(1);
                updateShaderLayers(); // Update shader in real-time
            });
            strengthSlider.addEventListener('change', (e) => {
                console.log(`üéõÔ∏è Layer ${layer.position} strength: ${layer.strength.toFixed(1)}`);
            });

            return card;
        }

        /**
         * Update layer card visuals
         */
        function updateLayerCard(card, layer) {
            const toggleBtn = card.querySelector('[data-action="toggle"]');
            toggleBtn.textContent = layer.enabled ? 'ON' : 'OFF';
            toggleBtn.className = `toggle-btn ${layer.enabled ? '' : 'disabled'}`;
            card.querySelector('.layer-title span:last-child').textContent = `Layer ${layer.position}`;
        }

        /**
         * Add a new layer
         */
        function addLayer() {
            if (layers.length >= 4) {
                console.warn('‚ö†Ô∏è Maximum 4 layers supported');
                return;
            }

            const layer = {
                id: nextLayerId++,
                position: layers.length + 1,
                mode: 0, // Multiply
                strength: 2.0,
                enabled: false
            };

            layers.push(layer);
            const card = createLayerCard(layer);
            layerStack.appendChild(card);
            updateShaderLayers();
            console.log('‚úÖ Added layer:', layer);
        }

        /**
         * Delete a layer
         */
        function deleteLayer(layerId) {
            const index = layers.findIndex(l => l.id === layerId);
            if (index === -1) return;

            layers.splice(index, 1);

            // Reposition remaining layers
            layers.forEach((layer, idx) => {
                layer.position = idx + 1;
            });

            // Rebuild UI
            renderLayers();
            updateShaderLayers();
            console.log('üóëÔ∏è Deleted layer:', layerId);
        }

        /**
         * Rebuild layer stack UI
         */
        function renderLayers() {
            layerStack.innerHTML = '';
            layers.forEach(layer => {
                const card = createLayerCard(layer);
                layerStack.appendChild(card);
            });
        }

        /**
         * Update shader uniforms with current layer state
         */
        function updateShaderLayers() {
            if (!mascot.core3D?.customMaterial?.uniforms) {
                console.warn('‚ö†Ô∏è Material not ready yet');
                return;
            }

            console.group('üé® Updating Blend Layers');

            // Update each layer (1-4)
            for (let i = 1; i <= 4; i++) {
                const layer = layers[i - 1];
                if (layer) {
                    console.log(`Layer ${i} ‚Üí Mode:${layer.mode} Strength:${layer.strength.toFixed(1)} Enabled:${layer.enabled}`);
                    mascot.core3D.setBlendLayer(i, {
                        mode: layer.mode,
                        strength: layer.strength,
                        enabled: layer.enabled
                    });

                    // Verify it was set
                    const uniforms = mascot.core3D.customMaterial.uniforms;
                    const actualMode = uniforms[`layer${i}Mode`]?.value;
                    const actualStrength = uniforms[`layer${i}Strength`]?.value;
                    const actualEnabled = uniforms[`layer${i}Enabled`]?.value;

                    if (actualMode !== layer.mode || actualStrength !== layer.strength || actualEnabled !== (layer.enabled ? 1.0 : 0.0)) {
                        console.error(`‚ùå Layer ${i} mismatch! Expected: mode=${layer.mode}, strength=${layer.strength}, enabled=${layer.enabled ? 1.0 : 0.0}`);
                        console.error(`   Actual: mode=${actualMode}, strength=${actualStrength}, enabled=${actualEnabled}`);
                    }
                } else {
                    // Disable unused layers
                    mascot.core3D.setBlendLayer(i, { enabled: false });
                }
            }

            console.groupEnd();
        }

        // Drag-and-drop handlers
        function handleDragStart(e) {
            draggedElement = e.currentTarget;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            draggedElement = null;

            // Remove all drag-over states
            document.querySelectorAll('.layer-card').forEach(card => {
                card.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            const afterElement = getDragAfterElement(layerStack, e.clientY);
            const draggable = document.querySelector('.dragging');

            if (afterElement == null) {
                layerStack.appendChild(draggable);
            } else {
                layerStack.insertBefore(draggable, afterElement);
            }

            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            // Rebuild layer positions based on DOM order
            const cards = Array.from(layerStack.querySelectorAll('.layer-card'));
            const newOrder = [];

            cards.forEach((card, index) => {
                const layerId = parseInt(card.dataset.layerId);
                const layer = layers.find(l => l.id === layerId);
                if (layer) {
                    layer.position = index + 1;
                    newOrder.push(layer);
                }
            });

            layers = newOrder;
            renderLayers(); // Rebuild to update position numbers
            updateShaderLayers();
            console.log('üîÑ Reordered layers:', layers);

            return false;
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.layer-card:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;

                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Add layer button
        addLayerBtn.addEventListener('click', addLayer);

        // Initialize with one default layer (after material is ready)
        setTimeout(() => {
            if (mascot.core3D?.customMaterial?.uniforms) {
                console.group('üîç Material Initialization Check');

                // Check material type
                const materialType = mascot.core3D.customMaterialType;
                console.log('Material Type:', materialType);

                // Check if layer uniforms exist
                const hasLayerUniforms = !!mascot.core3D.customMaterial.uniforms.layer1Mode;
                console.log('Has Layer Uniforms:', hasLayerUniforms);

                if (hasLayerUniforms) {
                    // Log initial uniform values
                    console.log('Initial Layer 1:', {
                        mode: mascot.core3D.customMaterial.uniforms.layer1Mode.value,
                        strength: mascot.core3D.customMaterial.uniforms.layer1Strength.value,
                        enabled: mascot.core3D.customMaterial.uniforms.layer1Enabled.value
                    });
                    console.log('Initial Layer 2:', {
                        mode: mascot.core3D.customMaterial.uniforms.layer2Mode.value,
                        strength: mascot.core3D.customMaterial.uniforms.layer2Strength.value,
                        enabled: mascot.core3D.customMaterial.uniforms.layer2Enabled.value
                    });
                } else {
                    console.error('‚ùå Layer uniforms not found! Wrong material type?');
                }

                console.groupEnd();

                addLayer(); // Add default Layer 1
                console.log('‚úÖ Layer system initialized with 1 layer');
            } else {
                console.error('‚ùå Material not ready for layer initialization');
            }
        }, 1000);
    </script>
</body>
</html>
