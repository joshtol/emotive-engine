<!DOCTYPE html>
<!--
  BLACK HOLE SHOWCASE - Emotive Engine 3D Demo

  A demonstration of NASA M87* Event Horizon Telescope black hole rendering.

  What you'll learn:
  - Black hole accretion disk with differential rotation
  - Gravitational particle accretion with spaghettification
  - Event horizon, photon ring, and ISCO physics
  - Doppler beaming and relativistic effects
  - Blend mode layer system for accretion disk appearance

  Complexity: â­â­â­ Advanced 3D + Physics + Shaders
  Features: Black hole geometry, gravitational accretion, blend layers, shader effects
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole Showcase - Emotive Engine 3D</title>
    <meta name="description" content="NASA M87* black hole demo with accretion disk and gravitational physics">

    <!-- Shared 3D example styles -->
    <link rel="stylesheet" href="../3d-example-style.css">

    <style>
        /* Theme: Orange cosmic */
        :root {
            --accent: #ff5500;
            --accent-rgb: 255, 85, 0;
        }

        body {
            background: url('../../assets/bg/star-bg-optimized.jpg') center/cover fixed,
                        linear-gradient(135deg, #000000 0%, #0a0010 50%, #000008 100%);
        }

        /* Override panel borders with orange */
        .left-menu {
            border-right: 1px solid rgba(255, 100, 0, 0.2);
        }

        .right-menu {
            border-left: 1px solid rgba(255, 100, 0, 0.2);
        }

        .section {
            border-bottom-color: rgba(255, 100, 0, 0.1);
        }

        /* Black hole container */
        #blackhole-container {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1;
            border-radius: clamp(12px, 1.5vw, 20px);
            background: url('../../assets/bg/star-bg-optimized.jpg') center/cover,
                        radial-gradient(circle at center, rgba(255, 100, 0, 0.1), transparent);
            box-shadow: 0 0 150px rgba(255, 100, 0, 0.3);
            touch-action: none;
        }

        #blackhole-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Custom scrollbar for orange theme */
        .left-menu::-webkit-scrollbar-thumb,
        .right-menu::-webkit-scrollbar-thumb {
            background: rgba(255, 100, 0, 0.3);
        }

        .left-menu::-webkit-scrollbar-thumb:hover,
        .right-menu::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 100, 0, 0.5);
        }
    </style>
</head>
<body>
    <!-- LEFT MENU: Black Hole Controls -->
    <div class="left-menu">
        <div class="section">
            <h2>Emotions (Auto-Derived Behavior)</h2>
            <div class="section-content">
                <div class="button-grid">
                    <button data-emotion="neutral">ğŸ˜ Neutral</button>
                    <button data-emotion="joy">ğŸ˜Š Joy</button>
                    <button data-emotion="fear" class="active">ğŸ˜¨ Fear</button>
                    <button data-emotion="anger">ğŸ˜  Anger</button>
                    <button data-emotion="sadness">ğŸ˜¢ Sad</button>
                    <button data-emotion="surprise">ğŸ˜² Surprise</button>
                </div>
                <div class="info-box" style="margin-top: 8px; font-size: clamp(8px, 0.75vw, 9px);">
                    Black hole adapts to emotion modifiers:<br>
                    â€¢ <strong>Speed</strong> â†’ disk rotation<br>
                    â€¢ <strong>Intensity</strong> â†’ turbulence<br>
                    â€¢ <strong>Smoothness</strong> â†’ chaos (inverse)
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">Relativistic Jets</h2>
            <div class="section-content collapsed">
                <button data-action="toggle-jets" class="active" style="width: 100%; margin-bottom: 10px">ğŸš€ Show Jets</button>
                <div id="jet-controls">
                    <div class="slider-control">
                        <div class="slider-label">
                            <span>Jet Intensity</span>
                            <span class="slider-value" id="jet-intensity-value">80%</span>
                        </div>
                        <input type="range" id="jet-intensity-slider" min="0" max="1" step="0.01" value="0.8">
                    </div>
                    <div style="margin-top: 10px">
                        <label style="font-size: 11px; color: rgba(255,255,255,0.7); margin-bottom: 4px; display: block">Blend Mode</label>
                        <select id="jet-blend-mode" style="width: 100%; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 4px">
                            <option value="5">Screen (Default)</option>
                            <option value="6">Linear Dodge</option>
                            <option value="7">Color Dodge</option>
                            <option value="8">Lighten</option>
                            <option value="9">Lighter Color</option>
                            <option value="10">Overlay</option>
                            <option value="11">Soft Light</option>
                            <option value="12">Hard Light</option>
                            <option value="0">Multiply</option>
                            <option value="16">Difference</option>
                            <option value="17">Exclusion</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">Hawking Radiation</h2>
            <div class="section-content collapsed">
                <button data-action="toggle-hawking" style="width: 100%; margin-bottom: 10px">âœ¨ Show Hawking Radiation</button>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Spawn Rate</span>
                        <span class="slider-value" id="hawking-rate-value">0.0/sec</span>
                    </div>
                    <input type="range" id="hawking-rate-slider" min="0" max="5" step="0.1" value="0">
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">Gravitational Lensing</h2>
            <div class="section-content collapsed">
                <button data-action="toggle-lensing" style="width: 100%; margin-bottom: 10px">ğŸŒ€ Show Einstein Ring</button>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Lensing Strength</span>
                        <span class="slider-value" id="lensing-strength-value">0%</span>
                    </div>
                    <input type="range" id="lensing-strength-slider" min="0" max="1" step="0.01" value="0">
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">Disk Rotation Speed</h2>
            <div class="section-content collapsed">
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Speed</span>
                        <span class="slider-value" id="rotation-speed-value">1.00x</span>
                    </div>
                    <input type="range" id="rotation-speed-slider" min="0" max="3" step="0.1" value="1.0">
                </div>
            </div>
        </div>

        <div class="section">
            <div class="info-box">
                <strong>M87* Black Hole:</strong><br>
                6.5 billion solar masses. Event horizon (black), accretion disk (orbiting plasma), photon ring (bright inner ring). Particles spiral inward and experience spaghettification near the event horizon.
            </div>
        </div>
    </div>

    <!-- CENTER: Black Hole Animation -->
    <div class="center-content">
        <div id="blackhole-container"></div>
    </div>

    <!-- RIGHT MENU: Visual Controls & Physics -->
    <div class="right-menu">
        <div class="section visual-controls">
            <h2 class="collapsed">Visual Controls</h2>
            <div class="section-content collapsed">
                <div class="button-grid">
                    <button data-action="toggle-particles">âœ¨ Particles</button>
                    <button data-action="toggle-glow" class="active">ğŸ’« Core Glow</button>
                    <button data-action="toggle-auto-rotate">ğŸ”„ Auto-Rotate</button>
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">ğŸ¨ Blend Layers</h2>
            <div class="section-content collapsed">
                <button class="add-layer-btn" id="add-layer-btn">+ Add Layer</button>
                <div id="layer-stack" class="layer-stack"></div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">NASA M87* Physics</h2>
            <div class="section-content collapsed">
                <div class="info-box">
                    <strong>Event Horizon:</strong> 2.0Ã— Schwarzschild<br>
                    Pure black sphere<br><br>

                    <strong>Photon Ring:</strong> 1.5Ã— Schwarzschild<br>
                    Light orbits here<br><br>

                    <strong>ISCO:</strong> 2.5Ã— Schwarzschild<br>
                    Inner edge of disk<br><br>

                    <strong>Disk:</strong> 2.5-8Ã— Schwarzschild<br>
                    Hot plasma, differential rotation
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">Particle Physics</h2>
            <div class="section-content collapsed">
                <div class="info-box">
                    <strong>Orbital Decay:</strong> Angular momentum loss<br><br>
                    <strong>Spaghettification:</strong> Tidal stretching near horizon<br><br>
                    <strong>Velocity:</strong> Increases as radius decreases
                </div>
            </div>
        </div>
    </div>

    <script>
        // Collapsible sections
        document.querySelectorAll('h2').forEach(h2 => {
            h2.addEventListener('click', () => {
                const content = h2.nextElementSibling;
                if (content && content.classList.contains('section-content')) {
                    h2.classList.toggle('collapsed');
                    content.classList.toggle('collapsed');
                }
            });
        });
    </script>

    <script type="module">
        import EmotiveMascot3D from '../../dist/emotive-mascot-3d.js';

        let mascot = null;

        // Initialize black hole
        (async () => {
            try {
                const container = document.getElementById('blackhole-container');
                mascot = new EmotiveMascot3D({
                    coreGeometry: 'blackHole',
                    materialVariant: 'multiplexer', // Use multiplexer shader with blend layers
                    enableParticles: false, // Start with particles OFF for comparison
                    enablePostProcessing: true,
                    enableShadows: false,
                    enableControls: true, // Enable camera controls by default
                    autoRotate: false, // Black hole doesn't rotate
                    enableBlinking: false,
                    enableBreathing: false,
                    cameraDistance: 2.0
                });

                mascot.init(container);
                mascot.start();

                // Set to a dark emotion to match black hole theme
                mascot.setEmotion('fear'); // Dark purple/black theme

                console.log('ğŸ•³ï¸ EmotiveMascot3D Black Hole initialized');

                // Log black hole material state
                if (mascot.core3D && mascot.core3D.coreMesh) {
                    console.log('ğŸ•³ï¸ Black hole mesh state:', {
                        hasCoreMesh: !!mascot.core3D.coreMesh,
                        isGroup: !!mascot.core3D.coreMesh.isGroup,
                        childCount: mascot.core3D.coreMesh.children ? mascot.core3D.coreMesh.children.length : 0,
                        hasDiskMaterial: !!(mascot.core3D.coreMesh.userData && mascot.core3D.coreMesh.userData.diskMesh && mascot.core3D.coreMesh.userData.diskMesh.material)
                    });
                }
            } catch (error) {
                console.error('âŒ Failed to initialize:', error);
            }
        })();

        // Event delegation for controls
        document.addEventListener('click', (e) => {
            // Emotion selector
            if (e.target.dataset.emotion) {
                const emotion = e.target.dataset.emotion;
                mascot.setEmotion(emotion);

                // Update active state
                document.querySelectorAll('[data-emotion]').forEach(btn => {
                    btn.classList.remove('active');
                });
                e.target.classList.add('active');

                console.log(`ğŸ­ Emotion changed to: ${emotion}`);
                return;
            }

            // Toggle particles
            if (e.target.dataset.action === 'toggle-particles') {
                if (mascot.particlesEnabled) {
                    mascot.disableParticles();
                    e.target.classList.remove('active');
                    console.log('ğŸš« Particles OFF');
                } else {
                    mascot.enableParticles();
                    e.target.classList.add('active');
                    console.log('âœ¨ Particles ON');
                }
                return;
            }

            // Toggle disk glow
            if (e.target.dataset.action === 'toggle-glow') {
                if (mascot.core3D?.coreGlowEnabled !== false) {
                    mascot.core3D.setCoreGlowEnabled(false);
                    e.target.classList.remove('active');
                    console.log('ğŸ’« Disk glow disabled');
                } else {
                    mascot.core3D.setCoreGlowEnabled(true);
                    e.target.classList.add('active');
                    console.log('ğŸ’« Disk glow enabled');
                }
                return;
            }

            // Toggle auto-rotate
            if (e.target.dataset.action === 'toggle-auto-rotate') {
                if (mascot.autoRotateEnabled) {
                    mascot.disableAutoRotate();
                    e.target.classList.remove('active');
                } else {
                    mascot.enableAutoRotate();
                    e.target.classList.add('active');
                }
                return;
            }

            // Toggle jets
            if (e.target.dataset.action === 'toggle-jets') {
                const topJetMesh = mascot?.core3D?.coreMesh?.userData?.topJetMesh;
                const bottomJetMesh = mascot?.core3D?.coreMesh?.userData?.bottomJetMesh;

                if (topJetMesh && bottomJetMesh && topJetMesh.material?.uniforms && bottomJetMesh.material?.uniforms) {
                    const currentIntensity = topJetMesh.material.uniforms.jetIntensity.value;
                    const newIntensity = currentIntensity > 0 ? 0 : 0.8;

                    topJetMesh.material.uniforms.jetIntensity.value = newIntensity;
                    bottomJetMesh.material.uniforms.jetIntensity.value = newIntensity;

                    document.getElementById('jet-intensity-slider').value = newIntensity;
                    document.getElementById('jet-intensity-value').textContent = `${Math.round(newIntensity * 100)}%`;

                    const jetControls = document.getElementById('jet-controls');
                    if (newIntensity > 0) {
                        e.target.classList.add('active');
                        jetControls.style.display = 'block';
                        console.log('ğŸš€ Relativistic jets ON');
                    } else {
                        e.target.classList.remove('active');
                        jetControls.style.display = 'none';
                        console.log('ğŸš€ Relativistic jets OFF');
                    }
                }
                return;
            }

            // Toggle Hawking radiation
            if (e.target.dataset.action === 'toggle-hawking') {
                const hawkingParticles = mascot?.core3D?.coreMesh?.userData?.hawkingParticles;

                if (hawkingParticles) {
                    const currentRate = hawkingParticles.userData.spawnRate;
                    const newRate = currentRate > 0 ? 0 : 2.0; // 2 particles/sec default

                    hawkingParticles.userData.spawnRate = newRate;

                    document.getElementById('hawking-rate-slider').value = newRate;
                    document.getElementById('hawking-rate-value').textContent = `${newRate.toFixed(1)}/sec`;

                    if (newRate > 0) {
                        e.target.classList.add('active');
                        console.log('âœ¨ Hawking radiation ON (quantum tunneling particles)');
                    } else {
                        e.target.classList.remove('active');
                        console.log('âœ¨ Hawking radiation OFF');
                    }
                }
                return;
            }

            // Toggle gravitational lensing
            if (e.target.dataset.action === 'toggle-lensing') {
                const lensingRingMesh = mascot?.core3D?.coreMesh?.userData?.lensingRingMesh;

                if (lensingRingMesh) {
                    const currentStrength = lensingRingMesh.material.uniforms.lensingStrength.value;
                    const newStrength = currentStrength > 0 ? 0 : 0.8; // 80% default

                    lensingRingMesh.material.uniforms.lensingStrength.value = newStrength;

                    document.getElementById('lensing-strength-slider').value = newStrength;
                    document.getElementById('lensing-strength-value').textContent = `${Math.round(newStrength * 100)}%`;

                    if (newStrength > 0) {
                        e.target.classList.add('active');
                        console.log('ğŸŒ€ Gravitational lensing ON (Einstein ring effect)');
                    } else {
                        e.target.classList.remove('active');
                        console.log('ğŸŒ€ Gravitational lensing OFF');
                    }
                }
                return;
            }
        });

        // Disk rotation speed slider
        const rotationSpeedSlider = document.getElementById('rotation-speed-slider');
        rotationSpeedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            document.getElementById('rotation-speed-value').textContent = `${speed.toFixed(2)}x`;

            // Update disk rotation speed in shader
            if (mascot?.core3D?.coreMesh?.userData?.diskMesh?.material?.uniforms?.diskRotationSpeed) {
                mascot.core3D.coreMesh.userData.diskMesh.material.uniforms.diskRotationSpeed.value = speed;
                console.log(`ğŸŒ€ Disk rotation speed: ${speed.toFixed(2)}x`);
            }
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BLEND LAYER MANAGEMENT SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const blendModes = [
            { name: 'Multiply', category: 'darken' },
            { name: 'Linear Burn', category: 'darken' },
            { name: 'Color Burn', category: 'darken' },
            { name: 'Color Dodge', category: 'lighten' },
            { name: 'Screen', category: 'lighten' },
            { name: 'Overlay', category: 'contrast' },
            { name: 'Add', category: 'lighten' },
            { name: 'Soft Light', category: 'contrast' },
            { name: 'Hard Light', category: 'contrast' },
            { name: 'Vivid Light', category: 'contrast' },
            { name: 'Linear Light', category: 'contrast' },
            { name: 'Difference', category: 'inversion' },
            { name: 'Exclusion', category: 'inversion' },
            { name: 'Darken', category: 'darken' },
            { name: 'Lighten', category: 'lighten' },
            { name: 'Subtract', category: 'darken' },
            { name: 'Divide', category: 'lighten' },
            { name: 'Pin Light', category: 'contrast' }
        ];

        const layerStack = document.getElementById('layer-stack');
        const addLayerBtn = document.getElementById('add-layer-btn');

        let layers = [];
        let nextLayerId = 1;
        let draggedElement = null;

        function getModeCategory(modeIndex) {
            return blendModes[modeIndex]?.category || 'contrast';
        }

        function createLayerCard(layer) {
            const card = document.createElement('div');
            card.className = `layer-card${layer.enabled ? '' : ' disabled'}`;
            card.dataset.layerId = layer.id;
            card.dataset.modeCategory = getModeCategory(layer.mode);
            card.draggable = true;

            const currentModeName = blendModes[layer.mode]?.name || 'Normal';

            card.innerHTML = `
                <div class="layer-header">
                    <div class="layer-title">
                        <span class="drag-handle">â‹®â‹®</span>
                        <span class="layer-name">Layer ${layer.position}</span>
                    </div>
                    <div class="layer-controls-header">
                        <button class="toggle-btn ${layer.enabled ? '' : 'disabled'}" data-action="toggle">
                            ${layer.enabled ? 'ON' : 'OFF'}
                        </button>
                        <button class="delete-btn" data-action="delete">âœ•</button>
                    </div>
                </div>
                <div class="layer-controls">
                    <div class="custom-select" data-action="mode">
                        <div class="custom-select-trigger">
                            <span class="custom-select-value">${currentModeName}</span>
                        </div>
                        <div class="custom-select-dropdown">
                            ${blendModes.map((mode, idx) =>
                                `<div class="custom-select-option${layer.mode === idx ? ' selected' : ''}" data-value="${idx}">${mode.name}</div>`
                            ).join('')}
                        </div>
                    </div>
                    <div class="strength-control">
                        <div class="strength-header">
                            <div class="precision-controls">
                                <span class="precision-label">Strength</span>
                                <div class="precision-toggle">
                                    <button class="precision-btn active" data-step="0.1">0.1</button>
                                    <button class="precision-btn" data-step="0.01">0.01</button>
                                    <button class="precision-btn" data-step="0.001">0.001</button>
                                </div>
                            </div>
                            <span class="strength-value">${layer.strength.toFixed(3)}</span>
                        </div>
                        <input type="range" class="layer-strength-slider" data-action="strength"
                               min="0" max="5" step="0.1" value="${layer.strength}">
                    </div>
                </div>
            `;

            // Drag events
            const dragHandle = card.querySelector('.drag-handle');
            dragHandle.addEventListener('mousedown', () => { card.draggable = true; });

            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragend', handleDragEnd);
            card.addEventListener('dragover', handleDragOver);
            card.addEventListener('drop', handleDrop);

            // Prevent dragging when interacting with controls
            const interactiveElements = card.querySelectorAll('select, input, button');
            interactiveElements.forEach(el => {
                el.addEventListener('mousedown', (e) => { card.draggable = false; e.stopPropagation(); });
                el.addEventListener('mouseup', () => { card.draggable = true; });
            });

            // Toggle button
            card.querySelector('[data-action="toggle"]').addEventListener('click', () => {
                layer.enabled = !layer.enabled;
                updateLayerCard(card, layer);
                updateShaderLayers();
            });

            // Delete button
            card.querySelector('[data-action="delete"]').addEventListener('click', () => {
                deleteLayer(layer.id);
            });

            // Custom select dropdown
            const customSelect = card.querySelector('[data-action="mode"]');
            const trigger = customSelect.querySelector('.custom-select-trigger');
            const dropdown = customSelect.querySelector('.custom-select-dropdown');
            const valueDisplay = customSelect.querySelector('.custom-select-value');
            const options = dropdown.querySelectorAll('.custom-select-option');
            let focusedIndex = -1;

            const updateFocus = (index, apply = true) => {
                options.forEach(o => o.classList.remove('focused'));
                if (index >= 0 && index < options.length) {
                    focusedIndex = index;
                    options[index].classList.add('focused');
                    options[index].scrollIntoView({ block: 'nearest' });
                    if (apply) {
                        // Apply blend mode immediately while navigating
                        const newMode = parseInt(options[index].dataset.value);
                        layer.mode = newMode;
                        card.dataset.modeCategory = getModeCategory(layer.mode);
                        valueDisplay.textContent = blendModes[newMode]?.name || 'Normal';
                        options.forEach(o => o.classList.remove('selected'));
                        options[index].classList.add('selected');
                        updateShaderLayers();
                    }
                }
            };

            const selectOption = (option) => {
                const newMode = parseInt(option.dataset.value);
                layer.mode = newMode;
                card.dataset.modeCategory = getModeCategory(layer.mode);
                valueDisplay.textContent = blendModes[newMode]?.name || 'Normal';
                options.forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                customSelect.classList.remove('open');
                updateShaderLayers();
            };

            trigger.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.custom-select.open').forEach(s => {
                    if (s !== customSelect) s.classList.remove('open');
                });
                customSelect.classList.toggle('open');
                if (customSelect.classList.contains('open')) {
                    const selectedIdx = Array.from(options).findIndex(o => o.classList.contains('selected'));
                    updateFocus(selectedIdx >= 0 ? selectedIdx : 0, false);
                }
            });

            trigger.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (!customSelect.classList.contains('open')) {
                        customSelect.classList.add('open');
                        const selectedIdx = Array.from(options).findIndex(o => o.classList.contains('selected'));
                        updateFocus(selectedIdx >= 0 ? selectedIdx : 0, false);
                    }
                }
            });

            customSelect.addEventListener('keydown', (e) => {
                // Allow arrow navigation even when closed
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (!customSelect.classList.contains('open')) {
                        customSelect.classList.add('open');
                    }
                    updateFocus(Math.min(focusedIndex + 1, options.length - 1));
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (!customSelect.classList.contains('open')) {
                        customSelect.classList.add('open');
                    }
                    updateFocus(Math.max(focusedIndex - 1, 0));
                } else if (e.key === 'Enter' || e.key === 'Escape') {
                    e.preventDefault();
                    customSelect.classList.remove('open');
                }
            });

            dropdown.addEventListener('click', (e) => {
                const option = e.target.closest('.custom-select-option');
                if (option) selectOption(option);
            });

            trigger.setAttribute('tabindex', '0');

            // Precision buttons
            const precisionButtons = card.querySelectorAll('.precision-btn');
            const strengthSlider = card.querySelector('[data-action="strength"]');
            precisionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    precisionButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    strengthSlider.step = btn.dataset.step;
                    const precision = btn.dataset.step === '0.1' ? 1 : (btn.dataset.step === '0.01' ? 2 : 3);
                    card.querySelector('.strength-value').textContent = layer.strength.toFixed(precision);
                });
            });

            // Strength slider
            strengthSlider.addEventListener('input', (e) => {
                layer.strength = parseFloat(e.target.value);
                const activeBtn = card.querySelector('.precision-btn.active');
                const step = activeBtn ? activeBtn.dataset.step : '0.1';
                const precision = step === '0.1' ? 1 : (step === '0.01' ? 2 : 3);
                card.querySelector('.strength-value').textContent = layer.strength.toFixed(precision);
                updateShaderLayers();
            });

            return card;
        }

        function updateLayerCard(card, layer) {
            const toggleBtn = card.querySelector('[data-action="toggle"]');
            toggleBtn.textContent = layer.enabled ? 'ON' : 'OFF';
            toggleBtn.className = `toggle-btn ${layer.enabled ? '' : 'disabled'}`;
            card.classList.toggle('disabled', !layer.enabled);
            card.querySelector('.layer-name').textContent = `Layer ${layer.position}`;
            card.dataset.modeCategory = getModeCategory(layer.mode);
        }

        function addLayer(mode = 0, strength = 1.0, enabled = true, skipShaderUpdate = false) {
            if (layers.length >= 4) return;

            const layer = { id: nextLayerId++, position: layers.length + 1, mode, strength, enabled };
            layers.push(layer);
            layerStack.appendChild(createLayerCard(layer));
            if (!skipShaderUpdate) updateShaderLayers();
        }

        function deleteLayer(layerId) {
            const index = layers.findIndex(l => l.id === layerId);
            if (index === -1) return;
            layers.splice(index, 1);
            layers.forEach((layer, idx) => { layer.position = idx + 1; });
            renderLayers();
            updateShaderLayers();
        }

        function renderLayers() {
            layerStack.innerHTML = '';
            layers.forEach(layer => { layerStack.appendChild(createLayerCard(layer)); });
        }

        function updateShaderLayers() {
            const diskMesh = mascot?.core3D?.coreMesh?.userData?.diskMesh;
            if (!diskMesh?.material?.uniforms) return;

            for (let i = 0; i < 4; i++) {
                const layerNum = i + 1;
                const uiLayer = layers[i];
                if (uiLayer) {
                    if (diskMesh.material.uniforms[`layer${layerNum}Mode`]) {
                        diskMesh.material.uniforms[`layer${layerNum}Mode`].value = uiLayer.mode;
                    }
                    if (diskMesh.material.uniforms[`layer${layerNum}Strength`]) {
                        diskMesh.material.uniforms[`layer${layerNum}Strength`].value = uiLayer.strength;
                    }
                    if (diskMesh.material.uniforms[`layer${layerNum}Enabled`]) {
                        diskMesh.material.uniforms[`layer${layerNum}Enabled`].value = uiLayer.enabled ? 1.0 : 0.0;
                    }
                } else {
                    if (diskMesh.material.uniforms[`layer${layerNum}Enabled`]) {
                        diskMesh.material.uniforms[`layer${layerNum}Enabled`].value = 0.0;
                    }
                }
            }
        }

        // Drag-and-drop handlers
        function handleDragStart(e) {
            draggedElement = e.currentTarget;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            draggedElement = null;
            document.querySelectorAll('.layer-card').forEach(card => { card.classList.remove('drag-over'); });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const afterElement = getDragAfterElement(layerStack, e.clientY);
            const draggable = document.querySelector('.dragging');
            if (afterElement == null) {
                layerStack.appendChild(draggable);
            } else {
                layerStack.insertBefore(draggable, afterElement);
            }
            return false;
        }

        function handleDrop(e) {
            e.stopPropagation();
            const cards = Array.from(layerStack.querySelectorAll('.layer-card'));
            const newOrder = [];
            cards.forEach((card, index) => {
                const layerId = parseInt(card.dataset.layerId);
                const layer = layers.find(l => l.id === layerId);
                if (layer) { layer.position = index + 1; newOrder.push(layer); }
            });
            layers = newOrder;
            renderLayers();
            updateShaderLayers();
            return false;
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.layer-card:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset, element: child };
                }
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        addLayerBtn.addEventListener('click', () => addLayer());

        // Close custom dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.custom-select')) {
                document.querySelectorAll('.custom-select.open').forEach(s => s.classList.remove('open'));
            }
        });

        // Initialize layers from shader defaults after mascot loads
        setTimeout(() => {
            const diskMesh = mascot?.core3D?.coreMesh?.userData?.diskMesh;
            if (diskMesh?.material?.uniforms) {
                for (let i = 1; i <= 4; i++) {
                    const enabledUniform = diskMesh.material.uniforms[`layer${i}Enabled`];
                    if (enabledUniform && enabledUniform.value > 0.5) {
                        const mode = Math.round(diskMesh.material.uniforms[`layer${i}Mode`]?.value || 0);
                        const strength = diskMesh.material.uniforms[`layer${i}Strength`]?.value || 1.0;
                        addLayer(mode, strength, true, true);
                    }
                }
                console.log(`ğŸ•³ï¸ Layer system initialized - ${layers.length} layers`);
            }
        }, 1500);

        // Jet intensity slider
        const jetIntensitySlider = document.getElementById('jet-intensity-slider');
        jetIntensitySlider.addEventListener('input', (e) => {
            const intensity = parseFloat(e.target.value);
            document.getElementById('jet-intensity-value').textContent = `${Math.round(intensity * 100)}%`;

            // Update jet intensity in shader uniforms
            const topJetMesh = mascot?.core3D?.coreMesh?.userData?.topJetMesh;
            const bottomJetMesh = mascot?.core3D?.coreMesh?.userData?.bottomJetMesh;

            if (topJetMesh?.material?.uniforms?.jetIntensity) {
                topJetMesh.material.uniforms.jetIntensity.value = intensity;
            }
            if (bottomJetMesh?.material?.uniforms?.jetIntensity) {
                bottomJetMesh.material.uniforms.jetIntensity.value = intensity;
            }

            // Update button active state
            const jetButton = document.querySelector('[data-action="toggle-jets"]');
            if (intensity > 0) {
                jetButton.classList.add('active');
            } else {
                jetButton.classList.remove('active');
            }

            console.log(`ğŸš€ Jet intensity: ${Math.round(intensity * 100)}%`);
        });

        // Jet blend mode selector
        const jetBlendModeSelect = document.getElementById('jet-blend-mode');
        jetBlendModeSelect.addEventListener('change', (e) => {
            const blendMode = parseInt(e.target.value);
            const topJetMesh = mascot?.core3D?.coreMesh?.userData?.topJetMesh;
            const bottomJetMesh = mascot?.core3D?.coreMesh?.userData?.bottomJetMesh;

            if (topJetMesh && bottomJetMesh && topJetMesh.material?.uniforms && bottomJetMesh.material?.uniforms) {
                topJetMesh.material.uniforms.jetBlendMode.value = blendMode;
                bottomJetMesh.material.uniforms.jetBlendMode.value = blendMode;

                const blendModeNames = ['Multiply', 'Linear Burn', 'Color Burn', 'Darken', 'Darker Color',
                    'Screen', 'Linear Dodge', 'Color Dodge', 'Lighten', 'Lighter Color',
                    'Overlay', 'Soft Light', 'Hard Light', 'Vivid Light', 'Linear Light', 'Pin Light',
                    'Difference', 'Exclusion', 'Subtract', 'Divide', 'Hue', 'Saturation'];
                console.log(`ğŸ¨ Jet blend mode: ${blendModeNames[blendMode]}`);
            }
        });

        // Hawking radiation spawn rate slider
        const hawkingRateSlider = document.getElementById('hawking-rate-slider');
        hawkingRateSlider.addEventListener('input', (e) => {
            const rate = parseFloat(e.target.value);
            document.getElementById('hawking-rate-value').textContent = `${rate.toFixed(1)}/sec`;

            // Update Hawking radiation spawn rate
            const hawkingParticles = mascot?.core3D?.coreMesh?.userData?.hawkingParticles;

            if (hawkingParticles) {
                hawkingParticles.userData.spawnRate = rate;
            }

            // Update button active state
            const hawkingButton = document.querySelector('[data-action="toggle-hawking"]');
            if (rate > 0) {
                hawkingButton.classList.add('active');
            } else {
                hawkingButton.classList.remove('active');
            }

            console.log(`âœ¨ Hawking radiation: ${rate.toFixed(1)} particles/sec`);
        });

        // Gravitational lensing strength slider
        const lensingStrengthSlider = document.getElementById('lensing-strength-slider');
        lensingStrengthSlider.addEventListener('input', (e) => {
            const strength = parseFloat(e.target.value);
            document.getElementById('lensing-strength-value').textContent = `${Math.round(strength * 100)}%`;

            // Update lensing strength in shader
            const lensingRingMesh = mascot?.core3D?.coreMesh?.userData?.lensingRingMesh;

            if (lensingRingMesh?.material?.uniforms?.lensingStrength) {
                lensingRingMesh.material.uniforms.lensingStrength.value = strength;
            }

            // Update button active state
            const lensingButton = document.querySelector('[data-action="toggle-lensing"]');
            if (strength > 0) {
                lensingButton.classList.add('active');
            } else {
                lensingButton.classList.remove('active');
            }

            console.log(`ğŸŒ€ Gravitational lensing: ${Math.round(strength * 100)}% (Einstein ring)`);
        });
    </script>
</body>
</html>
