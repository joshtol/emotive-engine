<!DOCTYPE html>
<!--
  BLOOD MOON ECLIPSE - Emotive Engine 3D Demo

  Realistic lunar eclipse simulation with Earth's shadow sweep and Rayleigh scattering.
  Features advanced color grading via sequential Photoshop-style blend mode layers.

  What you'll learn:
  - Lunar eclipse physics (umbra, penumbra, totality phases)
  - Shadow position-driven brightness modulation (logarithmic curves)
  - Real-time color grading with blend mode layers
  - Drag-and-drop layer stacking for complex effects
  - Blood moon atmospheric glow (red light refraction)

  Complexity: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Expert 3D Shaders + Physics
  Features: Shadow sweep animation, multi-layer blend modes, real-time color pickers, logarithmic progress curves
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blood Moon Eclipse - Emotive Engine 3D</title>
    <meta name="description" content="Realistic lunar eclipse with Earth's shadow sweep, atmospheric Rayleigh scattering, and multi-layer color grading">

    <!-- Shared 3D example styles -->
    <link rel="stylesheet" href="../3d-example-style.css">

    <style>
        /* Theme: Purple lunar */
        :root {
            --accent: #667eea;
            --accent-rgb: 102, 126, 234;
        }

        body {
            background: url('../../assets/bg/star-bg-optimized.jpg') center/cover fixed,
                        linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
        }

        /* Blood moon specific: current phase display */
        .current-phase {
            text-align: center;
            font-size: clamp(32px, 3vw, 42px);
            margin: clamp(10px, 1.2vw, 15px) 0;
            filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.5));
        }

        .current-name {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: clamp(11px, 1vw, 13px);
            margin-bottom: clamp(10px, 1.2vw, 15px);
        }

        /* Phase grid */
        .phase-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: clamp(5px, 0.6vw, 8px);
            margin-bottom: clamp(8px, 1vw, 12px);
        }

        /* Increment controls */
        .increment-controls {
            display: flex;
            gap: clamp(4px, 0.5vw, 6px);
            margin-bottom: clamp(6px, 0.7vw, 8px);
        }

        .increment-btn {
            flex: 1;
            padding: clamp(4px, 0.5vw, 6px);
            font-size: clamp(10px, 0.9vw, 12px);
        }

        /* Moon container */
        #moon-container {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1;
            border-radius: clamp(12px, 1.5vw, 20px);
            background: radial-gradient(circle at center, rgba(100, 100, 255, 0.1), transparent);
            box-shadow: 0 0 100px rgba(100, 100, 255, 0.3);
        }

        #moon-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Color grading section */
        .color-grading {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }

        .color-grading h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .color-grading label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .color-grading input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .color-value {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            margin-top: 3px;
        }

        /* Mobile responsive */
        @media (max-width: 1000px) {
            .phase-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .current-phase {
                font-size: clamp(28px, 6vw, 36px);
            }
        }

        @media (max-width: 600px) {
            .phase-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="left-menu">
        <div class="section">
            <h2>Eclipse Phase</h2>
            <div class="section-content">
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Shadow Position</span>
                        <span class="slider-value" id="shadow-pos-value">0.00</span>
                    </div>
                    <input type="range" id="shadow-pos-slider" min="-2" max="2" step="0.01" value="0">
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">Advanced Shadow</h2>
            <div class="section-content collapsed">
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Shadow Radius</span>
                        <span class="slider-value" id="shadow-radius-value">1.2</span>
                    </div>
                    <input type="range" id="shadow-radius-slider" min="0.5" max="2.5" step="0.05" value="1.2">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Eclipse Progress</span>
                        <span class="slider-value" id="eclipse-progress-value">0.0</span>
                    </div>
                    <input type="range" id="eclipse-progress-slider" min="0" max="1" step="0.01" value="0.0">
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">Lighting</h2>
            <div class="section-content collapsed">
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Emissive Glow</span>
                        <span class="slider-value" id="emissive-value">0.3</span>
                    </div>
                    <input type="range" id="emissive-slider" min="0" max="1" step="0.01" value="0.3">
                </div>

                <div class="slider-control">
                    <div class="slider-label">
                        <span>Shadow Darkness</span>
                        <span class="slider-value" id="shadow-darkness-value">1.00</span>
                    </div>
                    <input type="range" id="shadow-darkness-slider" min="0" max="1" step="0.01" value="1.0">
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">üé® Color Grading</h2>
            <div class="section-content collapsed">
                <div class="color-grading">
                    <div style="margin-bottom: 10px;">
                        <label>Shadows (Umbra Core)</label>
                        <input type="color" id="shadow-color" value="#ff9400">
                        <div class="color-value" id="shadow-color-value">RGB: 1.00, 0.58, 0.00</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label>Midtones (Main Body)</label>
                        <input type="color" id="midtone-color" value="#b56e08">
                        <div class="color-value" id="midtone-color-value">RGB: 0.71, 0.43, 0.03</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label>Highlights (Atmospheric Rim)</label>
                        <input type="color" id="highlight-color" value="#ff471a">
                        <div class="color-value" id="highlight-color-value">RGB: 1.00, 0.28, 0.10</div>
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label>Glow (Limb Rim)</label>
                        <input type="color" id="glow-color" value="#171717">
                        <div class="color-value" id="glow-color-value">RGB: 0.09, 0.09, 0.09</div>
                    </div>

                    <button id="reset-colors-btn" style="width: 100%; padding: 8px; background: rgba(100,100,100,0.5); border: 1px solid rgba(255,255,255,0.3); border-radius: 3px; color: white; cursor: pointer; font-size: 12px;">
                        Reset to Default
                    </button>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="info-box">
                <strong>Blood Moon Eclipse</strong><br>
                Earth's shadow sweeps across the moon with realistic Rayleigh scattering.
            </div>
        </div>
    </div>
    <div class="center-content">
        <div id="moon-container"></div>
    </div>
    <div class="right-menu">
        <div class="section visual-controls">
            <h2 class="collapsed">Visual Controls</h2>
            <div class="section-content collapsed">
                <div class="button-grid">
                    <button data-action="toggle-particles">‚ú® Particles</button>
                    <button data-action="toggle-glow" class="active">üí´ Core Glow</button>
                    <button data-action="toggle-auto-rotate">üîÑ Auto-Rotate</button>
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="collapsed">üé® Blend Layers</h2>
            <div class="section-content collapsed">
                <button id="add-layer-btn" class="add-layer-btn">+ Add Layer</button>
                <div id="layer-stack" class="layer-stack"></div>
            </div>
        </div>
    </div>

    <script>
        // Collapsible sections
        document.querySelectorAll('h2').forEach(h2 => {
            h2.addEventListener('click', () => {
                const content = h2.nextElementSibling;
                if (content && content.classList.contains('section-content')) {
                    h2.classList.toggle('collapsed');
                    content.classList.toggle('collapsed');
                }
            });
        });
    </script>

    <script type="module">
        // Updated: 2025-01-10 - Added particle toggle, disabled blinking/breathing by default
        import EmotiveMascot3D, { setMoonPhase, animateMoonPhase } from '../../dist/emotive-mascot-3d.js?t=1736871234';

        // Store current rotation values (declared early for use in initialization)
        // Calibrated to show classic "Man in the Moon" Earth-facing view
        let currentRotation = { x: 55.5, y: -85.0, z: -60.5 };

        const container = document.getElementById('moon-container');
        const mascot = new EmotiveMascot3D({
            canvasId: 'moon',
            coreGeometry: 'moon',
            materialVariant: 'multiplexer',  // Use blend multiplexer material
            enableParticles: true,
            enableControls: true,
            autoRotate: false,
            enableBlinking: false,
            enableBreathing: false,
            cameraDistance: 1.0  // Closer default zoom
        });

        mascot.init(container);
        mascot.start();

        // Disable particles on load (initialized but hidden)
        mascot.disableParticles();

        // Set to full moon on load
        if (mascot.core3D?.customMaterial?.uniforms?.shadowOffset) {
            mascot.core3D.customMaterial.uniforms.shadowOffset.value.x = 0;
            mascot.core3D.customMaterial.uniforms.shadowOffset.value.y = 0;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SHADOW POSITION SLIDER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        document.getElementById('shadow-pos-slider').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('shadow-pos-value').textContent = value.toFixed(2);
            if (mascot?.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseShadowPos.value[0] = value;
            }
        });

        // Initialize blood moon eclipse on load (Total Eclipse at center)
        setTimeout(() => {
            if (mascot.core3D?.customMaterial?.uniforms) {
                // Start at total eclipse (shadow at center)
                mascot.core3D.customMaterial.uniforms.eclipseShadowPos.value = [0.0, 0.0];
                mascot.core3D.customMaterial.uniforms.eclipseShadowRadius.value = 1.2;
                mascot.core3D.customMaterial.uniforms.eclipseProgress.value = 1.0;
                mascot.core3D.customMaterial.uniforms.emissiveStrength.value = 0.39;
                mascot.core3D.customMaterial.uniforms.shadowDarkness.value = 0.53;

                // Update UI sliders
                document.getElementById('eclipse-progress-slider').value = 1.0;
                document.getElementById('eclipse-progress-value').textContent = '1.00';
                document.getElementById('emissive-slider').value = 0.39;
                document.getElementById('emissive-value').textContent = '0.39';
                document.getElementById('shadow-darkness-slider').value = 0.53;
                document.getElementById('shadow-darkness-value').textContent = '0.53';

                console.log('Blood moon initialized at total eclipse');
            }
        }, 1200);

        // Ensure auto-rotate is OFF for tidal locking (force disable)
        setTimeout(() => {
            if (mascot.core3D?.renderer?.controls) {
                mascot.core3D.renderer.controls.autoRotate = false;
                console.log('üîí Moon tidally locked - autoRotate forcibly disabled');
            }
        }, 500);

        console.log('‚úÖ Blood Moon demo initialized');

        // Visual Controls event handlers
        document.querySelectorAll('[data-action]').forEach(button => {
            button.addEventListener('click', (e) => {
                const action = e.target.dataset.action;
                if (!action) return;

                switch (action) {
                    case 'toggle-particles':
                        if (mascot.particlesEnabled) {
                            mascot.disableParticles();
                            e.target.classList.remove('active');
                        } else {
                            mascot.enableParticles();
                            e.target.classList.add('active');
                        }
                        break;

                    case 'toggle-glow':
                        if (mascot.core3D?.coreGlowEnabled !== false) {
                            mascot.core3D.setCoreGlowEnabled(false);
                            e.target.classList.remove('active');
                        } else {
                            mascot.core3D.setCoreGlowEnabled(true);
                            e.target.classList.add('active');
                        }
                        break;

                    case 'toggle-auto-rotate':
                        if (mascot.autoRotateEnabled) {
                            mascot.disableAutoRotate();
                            e.target.classList.remove('active');
                        } else {
                            mascot.enableAutoRotate();
                            e.target.classList.add('active');
                        }
                        break;
                }
            });
        });

        // Eclipse progress slider (advanced control)
        const eclipseProgressSlider = document.getElementById('eclipse-progress-slider');
        eclipseProgressSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('eclipse-progress-value').textContent = value.toFixed(2);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseProgress.value = value;
                mascot.core3D.customMaterial.uniforms.eclipseIntensity.value = value;
            }
        });

        // Shadow radius slider
        const shadowRadiusSlider = document.getElementById('shadow-radius-slider');
        shadowRadiusSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('shadow-radius-value').textContent = value.toFixed(2);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseShadowRadius.value = value;
            }
        });

        // Eclipse Color Pickers
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255
            ] : [1.0, 1.0, 1.0];
        }

        const shadowColorPicker = document.getElementById('shadow-color');
        const midtoneColorPicker = document.getElementById('midtone-color');
        const highlightColorPicker = document.getElementById('highlight-color');
        const glowColorPicker = document.getElementById('glow-color');
        const resetColorsBtn = document.getElementById('reset-colors-btn');

        shadowColorPicker.addEventListener('input', (e) => {
            const rgb = hexToRgb(e.target.value);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseShadowColor.value = rgb;
                document.getElementById('shadow-color-value').textContent = `RGB: ${rgb[0].toFixed(2)}, ${rgb[1].toFixed(2)}, ${rgb[2].toFixed(2)}`;
            }
        });

        midtoneColorPicker.addEventListener('input', (e) => {
            const rgb = hexToRgb(e.target.value);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseMidtoneColor.value = rgb;
                document.getElementById('midtone-color-value').textContent = `RGB: ${rgb[0].toFixed(2)}, ${rgb[1].toFixed(2)}, ${rgb[2].toFixed(2)}`;
            }
        });

        highlightColorPicker.addEventListener('input', (e) => {
            const rgb = hexToRgb(e.target.value);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseHighlightColor.value = rgb;
                document.getElementById('highlight-color-value').textContent = `RGB: ${rgb[0].toFixed(2)}, ${rgb[1].toFixed(2)}, ${rgb[2].toFixed(2)}`;
            }
        });

        glowColorPicker.addEventListener('input', (e) => {
            const rgb = hexToRgb(e.target.value);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseGlowColor.value = rgb;
                document.getElementById('glow-color-value').textContent = `RGB: ${rgb[0].toFixed(2)}, ${rgb[1].toFixed(2)}, ${rgb[2].toFixed(2)}`;
            }
        });

        resetColorsBtn.addEventListener('click', () => {
            shadowColorPicker.value = '#ff9400';
            midtoneColorPicker.value = '#b56e08';
            highlightColorPicker.value = '#ff471a';
            glowColorPicker.value = '#171717';

            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.eclipseShadowColor.value = [1.00, 0.58, 0.00];
                mascot.core3D.customMaterial.uniforms.eclipseMidtoneColor.value = [0.71, 0.43, 0.03];
                mascot.core3D.customMaterial.uniforms.eclipseHighlightColor.value = [1.00, 0.28, 0.10];
                mascot.core3D.customMaterial.uniforms.eclipseGlowColor.value = [0.09, 0.09, 0.09];

                document.getElementById('shadow-color-value').textContent = 'RGB: 1.00, 0.58, 0.00';
                document.getElementById('midtone-color-value').textContent = 'RGB: 0.71, 0.43, 0.03';
                document.getElementById('highlight-color-value').textContent = 'RGB: 1.00, 0.28, 0.10';
                document.getElementById('glow-color-value').textContent = 'RGB: 0.09, 0.09, 0.09';
            }
        });

        // Emissive and shadow darkness controls
        const emissiveSlider = document.getElementById('emissive-slider');
        const shadowDarknessSlider = document.getElementById('shadow-darkness-slider');

        emissiveSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('emissive-value').textContent = value.toFixed(2);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.emissiveStrength.value = value;
            }
        });

        shadowDarknessSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('shadow-darkness-value').textContent = value.toFixed(2);
            if (mascot.core3D?.customMaterial?.uniforms) {
                mascot.core3D.customMaterial.uniforms.shadowDarkness.value = value;
            }
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BLEND LAYER MANAGEMENT SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Blend mode definitions with categories and icons
        const blendModes = [
            { name: 'Multiply', category: 'darken', icon: '√ó' },
            { name: 'Linear Burn', category: 'darken', icon: '‚ñº' },
            { name: 'Color Burn', category: 'darken', icon: '‚óÜ' },
            { name: 'Color Dodge', category: 'lighten', icon: '‚óá' },
            { name: 'Screen', category: 'lighten', icon: '‚ñ°' },
            { name: 'Overlay', category: 'contrast', icon: '‚óà' },
            { name: 'Add', category: 'lighten', icon: '+' },
            { name: 'Soft Light', category: 'contrast', icon: '‚óã' },
            { name: 'Hard Light', category: 'contrast', icon: '‚óè' },
            { name: 'Vivid Light', category: 'contrast', icon: '‚óâ' },
            { name: 'Linear Light', category: 'contrast', icon: '‚äï' },
            { name: 'Difference', category: 'inversion', icon: '‚â†' },
            { name: 'Exclusion', category: 'inversion', icon: '‚äò' },
            { name: 'Darken', category: 'darken', icon: '‚ñΩ' },
            { name: 'Lighten', category: 'lighten', icon: '‚ñ≥' },
            { name: 'Subtract', category: 'darken', icon: '‚àí' },
            { name: 'Divide', category: 'lighten', icon: '√∑' },
            { name: 'Pin Light', category: 'contrast', icon: '‚äô' },
            { name: 'Hue', category: 'component', icon: 'H' },
            { name: 'Saturation', category: 'component', icon: 'S' },
            { name: 'Color', category: 'component', icon: 'C' },
            { name: 'Luminosity', category: 'component', icon: 'L' }
        ];

        const layerStack = document.getElementById('layer-stack');
        const addLayerBtn = document.getElementById('add-layer-btn');

        let layers = [];
        let nextLayerId = 1;
        let draggedElement = null;

        // Get blend mode category for coloring
        function getModeCategory(modeIndex) {
            return blendModes[modeIndex]?.category || 'contrast';
        }

        // Generate select options grouped by category
        function generateModeOptions(selectedMode) {
            const categories = {
                darken: { label: 'üîª Darken', modes: [] },
                lighten: { label: 'üî∫ Lighten', modes: [] },
                contrast: { label: '‚óê Contrast', modes: [] },
                inversion: { label: '‚äò Inversion', modes: [] },
                component: { label: 'üé® Component', modes: [] }
            };

            blendModes.forEach((mode, idx) => {
                categories[mode.category].modes.push({ ...mode, index: idx });
            });

            let html = '';
            for (const [cat, data] of Object.entries(categories)) {
                html += `<optgroup label="${data.label}">`;
                data.modes.forEach(mode => {
                    html += `<option value="${mode.index}" ${mode.index === selectedMode ? 'selected' : ''}>${mode.icon} ${mode.name}</option>`;
                });
                html += '</optgroup>';
            }
            return html;
        }

        function createLayerCard(layer) {
            const card = document.createElement('div');
            card.className = `layer-card${layer.enabled ? '' : ' disabled'}`;
            card.dataset.layerId = layer.id;
            card.dataset.modeCategory = getModeCategory(layer.mode);
            card.draggable = true;

            const currentModeName = blendModes[layer.mode]?.name || 'Normal';

            card.innerHTML = `
                <div class="swipe-indicator left">üóëÔ∏è</div>
                <div class="swipe-indicator right">‚úì</div>
                <div class="layer-header">
                    <div class="layer-title">
                        <span class="drag-handle">‚ãÆ‚ãÆ</span>
                        <span class="layer-name">Layer ${layer.position}</span>
                    </div>
                    <div class="layer-controls-header">
                        <button class="toggle-btn ${layer.enabled ? '' : 'disabled'}" data-action="toggle">
                            ${layer.enabled ? 'ON' : 'OFF'}
                        </button>
                        <button class="delete-btn" data-action="delete">‚úï</button>
                    </div>
                </div>
                <div class="layer-controls">
                    <div class="custom-select" data-action="mode">
                        <div class="custom-select-trigger">
                            <span class="custom-select-value">${currentModeName}</span>
                        </div>
                        <div class="custom-select-dropdown">
                            ${blendModes.map((mode, idx) =>
                                `<div class="custom-select-option${layer.mode === idx ? ' selected' : ''}" data-value="${idx}">${mode.name}</div>`
                            ).join('')}
                        </div>
                    </div>
                    <div class="strength-control">
                        <div class="strength-header">
                            <div class="precision-controls">
                                <span class="precision-label">Strength</span>
                                <div class="precision-toggle">
                                    <button class="precision-btn active" data-step="0.1">0.1</button>
                                    <button class="precision-btn" data-step="0.01">0.01</button>
                                    <button class="precision-btn" data-step="0.001">0.001</button>
                                </div>
                            </div>
                            <span class="strength-value" data-action="edit-value">${layer.strength.toFixed(3)}</span>
                        </div>
                        <input type="range" class="layer-strength-slider" data-action="strength"
                               min="0" max="5" step="0.1" value="${layer.strength}">
                    </div>
                </div>
            `;

            // Collapse/expand on title click
            const layerTitle = card.querySelector('.layer-title');
            layerTitle.addEventListener('click', (e) => {
                if (e.target.classList.contains('drag-handle')) return;
                card.classList.toggle('collapsed');
            });

            // Drag handle
            const dragHandle = card.querySelector('.drag-handle');
            dragHandle.addEventListener('mousedown', () => { card.draggable = true; });

            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragend', handleDragEnd);
            card.addEventListener('dragover', handleDragOver);
            card.addEventListener('drop', handleDrop);

            // Prevent dragging when interacting with controls
            const interactiveElements = card.querySelectorAll('select, input, button:not(.drag-handle)');
            interactiveElements.forEach(el => {
                el.addEventListener('mousedown', (e) => { card.draggable = false; e.stopPropagation(); });
                el.addEventListener('mouseup', () => { card.draggable = true; });
            });

            // Toggle button
            card.querySelector('[data-action="toggle"]').addEventListener('click', () => {
                layer.enabled = !layer.enabled;
                updateLayerCard(card, layer);
                updateShaderLayers();
            });

            // Delete button
            card.querySelector('[data-action="delete"]').addEventListener('click', () => { deleteLayer(layer.id); });

            // Custom select dropdown
            const customSelect = card.querySelector('[data-action="mode"]');
            const trigger = customSelect.querySelector('.custom-select-trigger');
            const dropdown = customSelect.querySelector('.custom-select-dropdown');
            const valueDisplay = customSelect.querySelector('.custom-select-value');
            const options = dropdown.querySelectorAll('.custom-select-option');
            let focusedIndex = -1;

            const updateFocus = (index, apply = true) => {
                options.forEach(o => o.classList.remove('focused'));
                if (index >= 0 && index < options.length) {
                    focusedIndex = index;
                    options[index].classList.add('focused');
                    options[index].scrollIntoView({ block: 'nearest' });
                    if (apply) {
                        // Apply blend mode immediately while navigating
                        const newMode = parseInt(options[index].dataset.value);
                        layer.mode = newMode;
                        card.dataset.modeCategory = getModeCategory(layer.mode);
                        valueDisplay.textContent = blendModes[newMode]?.name || 'Normal';
                        options.forEach(o => o.classList.remove('selected'));
                        options[index].classList.add('selected');
                        updateShaderLayers();
                    }
                }
            };

            const selectOption = (option) => {
                const newMode = parseInt(option.dataset.value);
                layer.mode = newMode;
                card.dataset.modeCategory = getModeCategory(layer.mode);
                valueDisplay.textContent = blendModes[newMode]?.name || 'Normal';
                options.forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                customSelect.classList.remove('open');
                updateShaderLayers();
            };

            trigger.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.custom-select.open').forEach(s => {
                    if (s !== customSelect) s.classList.remove('open');
                });
                customSelect.classList.toggle('open');
                if (customSelect.classList.contains('open')) {
                    const selectedIdx = Array.from(options).findIndex(o => o.classList.contains('selected'));
                    updateFocus(selectedIdx >= 0 ? selectedIdx : 0, false);
                }
            });

            trigger.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (!customSelect.classList.contains('open')) {
                        customSelect.classList.add('open');
                        const selectedIdx = Array.from(options).findIndex(o => o.classList.contains('selected'));
                        updateFocus(selectedIdx >= 0 ? selectedIdx : 0, false);
                    }
                }
            });

            customSelect.addEventListener('keydown', (e) => {
                // Allow arrow navigation even when closed
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (!customSelect.classList.contains('open')) {
                        customSelect.classList.add('open');
                    }
                    updateFocus(Math.min(focusedIndex + 1, options.length - 1));
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (!customSelect.classList.contains('open')) {
                        customSelect.classList.add('open');
                    }
                    updateFocus(Math.max(focusedIndex - 1, 0));
                } else if (e.key === 'Enter' || e.key === 'Escape') {
                    e.preventDefault();
                    customSelect.classList.remove('open');
                }
            });

            dropdown.addEventListener('click', (e) => {
                const option = e.target.closest('.custom-select-option');
                if (option) selectOption(option);
            });

            trigger.setAttribute('tabindex', '0');

            // Precision buttons
            const precisionButtons = card.querySelectorAll('.precision-btn');
            const strengthSlider = card.querySelector('[data-action="strength"]');
            precisionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    precisionButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    strengthSlider.step = btn.dataset.step;
                    const precision = btn.dataset.step === '0.1' ? 1 : (btn.dataset.step === '0.01' ? 2 : 3);
                    card.querySelector('.strength-value').textContent = layer.strength.toFixed(precision);
                });
            });

            // Strength slider
            strengthSlider.addEventListener('input', (e) => {
                layer.strength = parseFloat(e.target.value);
                const activeBtn = card.querySelector('.precision-btn.active');
                const step = activeBtn ? activeBtn.dataset.step : '0.1';
                const precision = step === '0.1' ? 1 : (step === '0.01' ? 2 : 3);
                card.querySelector('.strength-value').textContent = layer.strength.toFixed(precision);
                updateShaderLayers();
            });

            // Double-tap value to edit directly
            const strengthValueEl = card.querySelector('.strength-value');
            strengthValueEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                const currentValue = layer.strength;
                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'strength-value-input';
                input.value = currentValue;
                input.min = 0;
                input.max = 5;
                input.step = 0.001;

                strengthValueEl.replaceWith(input);
                input.focus();
                input.select();

                const finishEdit = () => {
                    let newValue = parseFloat(input.value);
                    if (isNaN(newValue)) newValue = currentValue;
                    newValue = Math.max(0, Math.min(5, newValue));
                    layer.strength = newValue;
                    strengthSlider.value = newValue;

                    const newSpan = document.createElement('span');
                    newSpan.className = 'strength-value';
                    newSpan.dataset.action = 'edit-value';
                    const activeBtn = card.querySelector('.precision-btn.active');
                    const step = activeBtn ? activeBtn.dataset.step : '0.1';
                    const precision = step === '0.1' ? 1 : (step === '0.01' ? 2 : 3);
                    newSpan.textContent = layer.strength.toFixed(precision);

                    // Re-attach dblclick listener
                    newSpan.addEventListener('dblclick', arguments.callee);

                    input.replaceWith(newSpan);
                    updateShaderLayers();
                };

                input.addEventListener('blur', finishEdit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') finishEdit();
                    if (e.key === 'Escape') {
                        input.value = currentValue;
                        finishEdit();
                    }
                });
            });

            // Mobile swipe gestures
            let touchStartX = 0;
            let touchStartY = 0;
            let isSwiping = false;

            card.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                isSwiping = false;
            }, { passive: true });

            card.addEventListener('touchmove', (e) => {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;

                // Only trigger if horizontal swipe is dominant
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                    isSwiping = true;
                    card.classList.remove('swiping-left', 'swiping-right');
                    if (deltaX < -50) {
                        card.classList.add('swiping-left');
                    } else if (deltaX > 50) {
                        card.classList.add('swiping-right');
                    }
                }
            }, { passive: true });

            card.addEventListener('touchend', (e) => {
                if (isSwiping) {
                    if (card.classList.contains('swiping-left')) {
                        // Swipe left = delete
                        deleteLayer(layer.id);
                    } else if (card.classList.contains('swiping-right')) {
                        // Swipe right = toggle
                        layer.enabled = !layer.enabled;
                        updateLayerCard(card, layer);
                        updateShaderLayers();
                    }
                }
                card.classList.remove('swiping-left', 'swiping-right');
                isSwiping = false;
            });

            return card;
        }

        function updateLayerCard(card, layer) {
            const toggleBtn = card.querySelector('[data-action="toggle"]');
            toggleBtn.textContent = layer.enabled ? 'ON' : 'OFF';
            toggleBtn.className = `toggle-btn ${layer.enabled ? '' : 'disabled'}`;
            card.classList.toggle('disabled', !layer.enabled);
            card.querySelector('.layer-name').textContent = `Layer ${layer.position}`;
            card.dataset.modeCategory = getModeCategory(layer.mode);
        }

        function addLayer(mode = 0, strength = 2.0, enabled = false, skipShaderUpdate = false) {
            if (layers.length >= 4) return;

            const layer = { id: nextLayerId++, position: layers.length + 1, mode, strength, enabled };
            layers.push(layer);
            layerStack.appendChild(createLayerCard(layer));
            if (!skipShaderUpdate) updateShaderLayers();
        }

        function deleteLayer(layerId) {
            const index = layers.findIndex(l => l.id === layerId);
            if (index === -1) return;
            layers.splice(index, 1);
            layers.forEach((layer, idx) => { layer.position = idx + 1; });
            renderLayers();
            updateShaderLayers();
        }

        function renderLayers() {
            layerStack.innerHTML = '';
            layers.forEach(layer => { layerStack.appendChild(createLayerCard(layer)); });
        }

        function updateShaderLayers() {
            if (!mascot.core3D?.customMaterial?.uniforms) return;

            for (let i = 0; i < 4; i++) {
                const layerNum = i + 1;
                const uiLayer = layers[i];
                if (uiLayer) {
                    mascot.core3D.setBlendLayer(layerNum, { mode: uiLayer.mode, strength: uiLayer.strength, enabled: uiLayer.enabled });
                } else {
                    mascot.core3D.setBlendLayer(layerNum, { enabled: false });
                }
            }
        }

        // Drag-and-drop handlers
        function handleDragStart(e) {
            draggedElement = e.currentTarget;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            draggedElement = null;
            document.querySelectorAll('.layer-card').forEach(card => { card.classList.remove('drag-over'); });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const afterElement = getDragAfterElement(layerStack, e.clientY);
            const draggable = document.querySelector('.dragging');
            if (afterElement == null) {
                layerStack.appendChild(draggable);
            } else {
                layerStack.insertBefore(draggable, afterElement);
            }
            return false;
        }

        function handleDrop(e) {
            e.stopPropagation();
            const cards = Array.from(layerStack.querySelectorAll('.layer-card'));
            const newOrder = [];
            cards.forEach((card, index) => {
                const layerId = parseInt(card.dataset.layerId);
                const layer = layers.find(l => l.id === layerId);
                if (layer) { layer.position = index + 1; newOrder.push(layer); }
            });
            layers = newOrder;
            renderLayers();
            updateShaderLayers();
            return false;
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.layer-card:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset, element: child };
                }
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        addLayerBtn.addEventListener('click', () => addLayer());

        // Close custom dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.custom-select')) {
                document.querySelectorAll('.custom-select.open').forEach(s => s.classList.remove('open'));
            }
        });

        // Initialize layers from shader defaults
        setTimeout(() => {
            if (mascot.core3D?.customMaterial?.uniforms) {
                const hasLayerUniforms = !!mascot.core3D.customMaterial.uniforms.layer1Mode;
                if (hasLayerUniforms) {
                    for (let i = 1; i <= 4; i++) {
                        const enabledValue = mascot.core3D.customMaterial.uniforms[`layer${i}Enabled`].value;
                        if (enabledValue > 0.5) {
                            const mode = Math.round(mascot.core3D.customMaterial.uniforms[`layer${i}Mode`].value);
                            const strength = mascot.core3D.customMaterial.uniforms[`layer${i}Strength`].value;
                            addLayer(mode, strength, true, true);
                        }
                    }
                    console.log(`‚úÖ WYSIWYG layer system initialized - ${layers.length} layers created`);
                }
            }
        }, 1000);
    </script>
</body>
</html>
