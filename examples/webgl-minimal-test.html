<!DOCTYPE html>
<html>
<head>
    <title>WebGL Minimal Test</title>
    <style>
        body { margin: 0; background: #222; }
        canvas { border: 2px solid lime; display: block; margin: 20px auto; }
    </style>
</head>
<body>
    <h1 style="color: white; text-align: center;">WebGL Minimal Geometry Test</h1>
    <canvas id="c" width="400" height="400"></canvas>
    <div id="log" style="color: white; font-family: monospace; padding: 20px;"></div>

    <script type="module">
        const log = document.getElementById('log');
        function addLog(msg) {
            console.log(msg);
            log.innerHTML += msg + '<br>';
        }

        // Import just the geometries and renderer
        import { CORE_GEOMETRIES } from '../dist/emotive-mascot-3d.js';

        addLog('Imported CORE_GEOMETRIES: ' + Object.keys(CORE_GEOMETRIES).join(', '));

        const canvas = document.getElementById('c');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            addLog('ERROR: No WebGL2!');
        } else {
            addLog('WebGL2 context created');
        }

        // Simple shaders
        const vertShader = `#version 300 es
        in vec3 a_position;
        uniform mat4 u_matrix;
        void main() {
            gl_Position = u_matrix * vec4(a_position, 1.0);
        }`;

        const fragShader = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        void main() {
            fragColor = vec4(1.0, 1.0, 0.0, 1.0); // Yellow
        }`;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                addLog('Shader error: ' + gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vs = createShader(gl, gl.VERTEX_SHADER, vertShader);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fragShader);

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            addLog('Program error: ' + gl.getProgramInfoLog(program));
        } else {
            addLog('Shader program linked');
        }

        // Get sphere geometry
        const sphere = CORE_GEOMETRIES.sphere;
        addLog('Sphere vertices: ' + sphere.vertices.length / 3);
        addLog('Sphere indices: ' + sphere.indices.length);

        // Create buffers
        const posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, sphere.vertices, gl.STATIC_DRAW);

        const idxBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.indices, gl.STATIC_DRAW);

        addLog('Buffers created');

        // Simple perspective matrix
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function translate(x, y, z) {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ]);
        }

        function multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    let sum = 0;
                    for (let k = 0; k < 4; k++) {
                        sum += a[i * 4 + k] * b[k * 4 + j];
                    }
                    result[i * 4 + j] = sum;
                }
            }
            return result;
        }

        const proj = perspective(45 * Math.PI / 180, 1, 0.1, 100);
        const view = translate(0, 0, -3);
        const matrix = multiply(proj, view);

        // Render
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.1, 0.1, 0.2, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        gl.useProgram(program);

        const posLoc = gl.getAttribLocation(program, 'a_position');
        const matLoc = gl.getUniformLocation(program, 'u_matrix');

        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

        gl.uniformMatrix4fv(matLoc, false, matrix);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
        gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);

        addLog('Draw call issued');
        addLog('Check canvas - you should see a yellow sphere!');
    </script>
</body>
</html>
