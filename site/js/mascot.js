/*! Emotive Engine v2.4.0 | Proprietary License */
/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  CANVAS MANAGER  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Canvas Manager - High-DPI Rendering & Canvas Lifecycle
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module CanvasManager
 * @changelog 2.1.0 - Added resize callback system for visual resampling
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The FOUNDATION of visual rendering. Handles canvas setup, high-DPI scaling,       
 * ║ resize events, and provides optimized 2D context for smooth animations.           
 * ║ Ensures crisp rendering on Retina displays and manages canvas lifecycle.          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 CANVAS FEATURES                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Device Pixel Ratio (DPR) scaling for Retina displays                            
 * │ • Automatic resize handling with debouncing                                       
 * │ • Resize callback system for component notification                               
 * │ • Optimized 2D context settings for animations                                    
 * │ • Center point calculation for orb positioning                                    
 * │ • Clean canvas clearing with proper scaling                                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ CONTEXT OPTIMIZATIONS                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • alpha: true               - Enables transparency                                
 * │ • desynchronized: true      - Better animation performance                        
 * │ • willReadFrequently: false - We don't read pixels                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */
class CanvasManager {
    constructor(canvas) {
        this.canvas = canvas;
        // Get context with optimal settings for particle rendering
        this.ctx = canvas.getContext('2d', {
            alpha: true,
            desynchronized: true,  // Better performance for animations
            willReadFrequently: false  // We're not reading pixels
        });
        this.dpr = window.devicePixelRatio || 1;
        this.width = 0;
        this.height = 0;
        this.centerX = 0;
        this.centerY = 0;
        
        // Resize callbacks
        this.resizeCallbacks = [];
        
        // Bind resize handler
        this.handleResize = this.handleResize.bind(this);
        window.addEventListener('resize', this.handleResize);
        
        // Initial resize
        this.resize();
    }

    /**
     * Handles canvas resizing with proper high-DPI support
     */
    resize() {
        // Check if canvas has explicit width/height attributes
        const hasExplicitSize = this.canvas.hasAttribute('width') && this.canvas.hasAttribute('height');
        
        if (hasExplicitSize) {
            // Use the explicit canvas dimensions from attributes
            // This prevents the canvas from changing size when DevTools opens
            const attrWidth = parseInt(this.canvas.getAttribute('width'), 10);
            const attrHeight = parseInt(this.canvas.getAttribute('height'), 10);
            
            // Use attribute dimensions as base size
            this.width = attrWidth;
            this.height = attrHeight;
            
            // Set actual canvas buffer size (no DPR scaling for fixed-size canvases)
            this.canvas.width = attrWidth;
            this.canvas.height = attrHeight;
            
            // No DPR scaling needed for fixed-size canvases
            // The browser will handle the scaling automatically
        } else {
            // For responsive canvases, use the bounding rect
            const rect = this.canvas.getBoundingClientRect();
            
            // Set display size (CSS pixels)
            this.width = rect.width;
            this.height = rect.height;
            
            // Set actual size in memory (scaled for high-DPI)
            this.canvas.width = this.width * this.dpr;
            this.canvas.height = this.height * this.dpr;
            
            // Scale the drawing context for high-DPI
            this.ctx.scale(this.dpr, this.dpr);
        }
        
        // Update center coordinates
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        
        //     dpr: this.dpr,
        //     center: { x: this.centerX, y: this.centerY }
        // });
        
        // Trigger resize callbacks
        this.resizeCallbacks.forEach(callback => {
            try {
                callback(this.width, this.height, this.dpr);
            } catch (error) {
            }
        });
    }
    
    /**
     * Register a callback to be called on canvas resize
     * @param {Function} callback - Function to call with (width, height, dpr) parameters
     */
    onResize(callback) {
        if (typeof callback === 'function') {
            this.resizeCallbacks.push(callback);
        }
    }

    /**
     * Debounced resize handler to prevent excessive resize calls
     */
    handleResize() {
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = setTimeout(() => {
            this.resize();
        }, 100);
    }

    /**
     * Clears the entire canvas
     */
    clear() {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }

    /**
     * Gets the center coordinates of the canvas
     * @returns {Object} Object with x and y center coordinates
     */
    getCenter() {
        return {
            x: this.centerX,
            y: this.centerY
        };
    }

    /**
     * Sets transform for drawing operations
     * @param {number} x - X translation
     * @param {number} y - Y translation  
     * @param {number} scale - Scale factor
     * @param {number} rotation - Rotation in radians
     */
    setTransform(x = 0, y = 0, scale = 1, rotation = 0) {
        this.ctx.save();
        this.ctx.translate(x, y);
        this.ctx.rotate(rotation);
        this.ctx.scale(scale, scale);
    }

    /**
     * Restores the previous transform state
     */
    restoreTransform() {
        this.ctx.restore();
    }

    /**
     * Gets the 2D rendering context
     * @returns {CanvasRenderingContext2D} The canvas 2D context
     */
    getContext() {
        return this.ctx;
    }

    /**
     * Gets canvas dimensions
     * @returns {Object} Object with width and height
     */
    getDimensions() {
        return {
            width: this.width,
            height: this.height
        };
    }

    /**
     * Cleanup method to remove event listeners
     */
    destroy() {
        window.removeEventListener('resize', this.handleResize);
        clearTimeout(this.resizeTimeout);
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  ERROR BOUNDARY  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Error Boundary - Error Handling & Recovery System
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module ErrorBoundary
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The SAFETY NET of the Emotive Engine. Catches errors, provides fallbacks,         
 * ║ logs issues for debugging, and attempts recovery to keep the animation            
 * ║ running even when things go wrong. Never let the orb die!                         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🛡️ ERROR HANDLING FEATURES                                                        
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Try-catch wrapping for all critical functions                                   
 * │ • Safe default values for all emotional states                                    
 * │ • Error logging with context and timestamps                                       
 * │ • Automatic error suppression after threshold                                     
 * │ • Recovery attempts with exponential backoff                                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 FALLBACK VALUES                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • emotion       : 'neutral' (safe default state)                                  
 * │ • gesture       : null (no animation)                                             
 * │ • audioLevel    : 0 (silent)                                                      
 * │ • particleCount : 0 (no particles)                                                
 * │ • glowIntensity : 0.7 (moderate glow)                                             
 * │ • color         : '#B0B0B0' (neutral gray)                                        
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 VALIDATION LISTS                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ VALID EMOTIONS:                                                                   
 * │   neutral, joy, sadness, anger, fear, surprise, disgust, love,                    
 * │   suspicion, resting, connecting, thinking, speaking, zen, focused                
 * │                                                                                    
 * │ VALID UNDERTONES:                                                                 
 * │   nervous, confident, tired, intense, subdued                                     
 * │                                                                                    
 * │ VALID GESTURES:                                                                    
 * │   bounce, pulse, shake, spin, nod, tilt, expand, contract, flash,                 
 * │   drift, breathe, wave, slowBlink, jump, breathHold                               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚠️  ERROR THRESHOLDS                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Max errors in log      : 10 (then rotates)                                      
 * │ • Errors before suppress : 3 per context                                          
 * │ • Recovery max attempts  : 3                                                      
 * │ • Recovery backoff       : 100ms * 2^attempt                                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                           USING ERROR BOUNDARY                                    
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ // Wrap any risky function:                                                       
 * ║ const safeFunction = errorBoundary.wrap(riskyFunction, 'context', fallback);      
 * ║                                                                                    
 * ║ // Validate input:                                                                
 * ║ const validEmotion = errorBoundary.validateInput(input, 'emotion', 'neutral');    
 * ║                                                                                    
 * ║ // Attempt recovery:                                                              
 * ║ await errorBoundary.attemptRecovery('render', retryFn, 3);                        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */
class ErrorBoundary {
    constructor() {
        this.errors = [];
        this.maxErrors = 10;
        this.errorCounts = new Map();
        
        // Safe default values for various contexts
        this.defaults = {
            emotion: 'neutral',
            gesture: null,
            audioLevel: 0,
            particleCount: 0,
            glowIntensity: 0.7,
            coreSize: 1.0,
            breathRate: 1.0,
            color: '#B0B0B0'
        };
    }

    /**
     * Wraps a function with error handling
     * @param {Function} fn - Function to wrap
     * @param {string} context - Context description for error logging
     * @param {*} fallbackValue - Value to return on error
     * @returns {Function} Wrapped function
     */
    wrap(fn, context, fallbackValue = null) {
        return (...args) => {
            try {
                return fn(...args);
            } catch (error) {
                this.logError(error, context);
                return fallbackValue !== null ? fallbackValue : this.getDefault(context);
            }
        };
    }

    /**
     * Logs an error with context and timestamp
     * @param {Error} error - The error object
     * @param {string} context - Context where the error occurred
     */
    logError(error, context) {
        const timestamp = new Date().toISOString();
        const errorEntry = {
            timestamp,
            context,
            message: error.message,
            stack: error.stack
        };

        // Add to error log
        this.errors.push(errorEntry);
        
        // Maintain error count per context
        const count = this.errorCounts.get(context) || 0;
        this.errorCounts.set(context, count + 1);

        // Rotate error log if it gets too large
        if (this.errors.length > this.maxErrors) {
            this.errors.shift();
        }
    }

    /**
     * Gets a safe default value for a given context
     * @param {string} context - The context to get default for
     * @returns {*} Safe default value
     */
    getDefault(context) {
        // Context-specific defaults
        const contextDefaults = {
            'emotion-transition': this.defaults.emotion,
            'gesture-execution': this.defaults.gesture,
            'audio-processing': this.defaults.audioLevel,
            'particle-system': this.defaults.particleCount,
            'rendering': {
                glowIntensity: this.defaults.glowIntensity,
                coreSize: this.defaults.coreSize,
                color: this.defaults.color
            },
            'canvas-operations': null,
            'state-management': this.defaults.emotion
        };

        return contextDefaults.hasOwnProperty(context) ? contextDefaults[context] : null;
    }

    /**
     * Validates input parameters and returns safe values
     * @param {*} value - Value to validate
     * @param {string} type - Expected type
     * @param {*} defaultValue - Default value if validation fails
     * @returns {*} Validated value or default
     */
    validateInput(value, type, defaultValue) {
        try {
            switch (type) {
                case 'emotion':
                    const validEmotions = ['neutral', 'joy', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'love', 'euphoria'];
                    return validEmotions.includes(value) ? value : defaultValue;
                
                case 'undertone':
                    const validUndertones = ['nervous', 'confident', 'tired', 'intense', 'subdued'];
                    return value === null || validUndertones.includes(value) ? value : null;
                
                case 'gesture':
                    const validGestures = ['bounce', 'pulse', 'shake', 'spin', 'nod', 'tilt', 'expand', 'contract', 'flash', 'drift'];
                    return validGestures.includes(value) ? value : defaultValue;
                
                case 'number':
                    return typeof value === 'number' && !isNaN(value) ? value : defaultValue;
                
                case 'string':
                    return typeof value === 'string' ? value : defaultValue;
                
                case 'boolean':
                    return typeof value === 'boolean' ? value : defaultValue;
                
                default:
                    return value !== undefined && value !== null ? value : defaultValue;
            }
        } catch (error) {
            this.logError(error, 'input-validation');
            return defaultValue;
        }
    }

    /**
     * Checks if a context has exceeded error threshold
     * @param {string} context - Context to check
     * @param {number} threshold - Error threshold (default: 5)
     * @returns {boolean} True if threshold exceeded
     */
    hasExceededThreshold(context, threshold = 5) {
        return (this.errorCounts.get(context) || 0) >= threshold;
    }

    /**
     * Gets error statistics
     * @returns {Object} Error statistics
     */
    getErrorStats() {
        return {
            totalErrors: this.errors.length,
            errorsByContext: Object.fromEntries(this.errorCounts),
            recentErrors: this.errors.slice(-5)
        };
    }

    /**
     * Clears error history
     */
    clearErrors() {
        this.errors = [];
        this.errorCounts.clear();
    }

    /**
     * Attempts to recover from a failed operation
     * @param {string} operation - The operation that failed
     * @param {Function} retryFn - Function to retry
     * @param {number} maxRetries - Maximum retry attempts
     * @returns {Promise} Recovery attempt result
     */
    async attemptRecovery(operation, retryFn, maxRetries = 3) {
        let attempts = 0;
        
        while (attempts < maxRetries) {
            try {
                return await retryFn();
            } catch (error) {
                attempts++;
                this.logError(error, `recovery-${operation}-attempt-${attempts}`);
                
                if (attempts >= maxRetries) {
                    throw new Error(`Recovery failed for ${operation} after ${maxRetries} attempts`);
                }
                
                // Exponential backoff
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempts) * 100));
            }
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  COLOR UTILS  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Color Utils - Color Interpolation & Manipulation
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module ColorUtils
 * @changelog 2.1.0 - Added undertone saturation modifiers for dynamic depth
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The COLOR SCIENCE module of the engine. Provides smooth color transitions         
 * ║ between emotional states using HSL interpolation for perceptually uniform         
 * ║ transitions that feel natural and emotionally resonant.                           
 * ║                                                                                    
 * ║ NEW: Undertone saturation system creates dynamic depth by adjusting saturation    
 * ║ based on emotional undertones (intense → oversaturated, subdued → desaturated)    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 COLOR OPERATIONS                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Hex to RGB/HSL conversion                                                       
 * │ • RGB to Hex/HSL conversion                                                       
 * │ • HSL interpolation for smooth transitions                                        
 * │ • Color mixing and blending                                                       
 * │ • Luminance calculations                                                          
 * │ • Perceptually uniform color shifts                                               
 * │ • Undertone-based saturation adjustments                                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🌈 UNDERTONE SATURATION SYSTEM                                                    
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ Undertones dynamically adjust color saturation to create emotional depth:         
 * │                                                                                    
 * │ • INTENSE   : +60% saturation - Electric, vibrant, overwhelming                   
 * │ • CONFIDENT : +30% saturation - Bold, present, assertive                          
 * │ • NERVOUS   : +15% saturation - Slightly heightened, anxious energy               
 * │ • CLEAR     :   0% saturation - Normal midtone, balanced state                    
 * │ • TIRED     : -20% saturation - Washed out, fading, depleted                      
 * │ • SUBDUED   : -50% saturation - Ghostly, barely there, withdrawn                  
 * │                                                                                    
 * │ This creates a visual hierarchy where emotional intensity directly affects        
 * │ the vibrancy and presence of colors, making the mascot's state immediately        
 * │ readable through color alone.                                                     
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Converts hex color to RGB values
 * @param {string} hex - Hex color string (e.g., '#FF0000')
 * @returns {Object} RGB object with r, g, b properties
 */
function hexToRgb(hex) {
    // Remove # if present
    hex = hex.replace('#', '');
    
    // Handle 3-digit hex
    if (hex.length === 3) {
        hex = hex.split('').map(char => char + char).join('');
    }
    
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    return { r, g, b };
}

/**
 * Converts RGB values to hex color
 * @param {number} r - Red component (0-255)
 * @param {number} g - Green component (0-255)
 * @param {number} b - Blue component (0-255)
 * @returns {string} Hex color string
 */
function rgbToHex(r, g, b) {
    const toHex = (component) => {
        const hex = Math.round(Math.max(0, Math.min(255, component))).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    };
    
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

/**
 * Converts RGB to HSL color space
 * @param {number} r - Red component (0-255)
 * @param {number} g - Green component (0-255)
 * @param {number} b - Blue component (0-255)
 * @returns {Object} HSL object with h, s, l properties
 */
function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    
    if (max === min) {
        h = s = 0; // achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    
    return { h: h * 360, s: s * 100, l: l * 100 };
}

/**
 * Converts HSL to RGB color space
 * @param {number} h - Hue (0-360)
 * @param {number} s - Saturation (0-100)
 * @param {number} l - Lightness (0-100)
 * @returns {Object} RGB object with r, g, b properties
 */
function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;
    
    const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    };
    
    let r, g, b;
    
    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/**
 * Interpolates between two colors in HSL space (better for emotional transitions)
 * @param {string} color1 - Start color (hex)
 * @param {string} color2 - End color (hex)
 * @param {number} progress - Interpolation progress (0-1)
 * @returns {string} Interpolated color (hex)
 */
function interpolateHsl(color1, color2, progress) {
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    const hsl1 = rgbToHsl(rgb1.r, rgb1.g, rgb1.b);
    const hsl2 = rgbToHsl(rgb2.r, rgb2.g, rgb2.b);
    
    // Handle hue interpolation (shortest path around color wheel)
    let h1 = hsl1.h;
    let h2 = hsl2.h;
    let hDiff = h2 - h1;
    
    if (hDiff > 180) {
        h2 -= 360;
    } else if (hDiff < -180) {
        h2 += 360;
    }
    
    const h = h1 + (h2 - h1) * progress;
    const s = hsl1.s + (hsl2.s - hsl1.s) * progress;
    const l = hsl1.l + (hsl2.l - hsl1.l) * progress;
    
    // Normalize hue
    const normalizedH = ((h % 360) + 360) % 360;
    
    const rgb = hslToRgb(normalizedH, s, l);
    return rgbToHex(rgb.r, rgb.g, rgb.b);
}

/**
 * Adjusts the saturation of a color
 * @param {string} hex - Hex color
 * @param {number} factor - Saturation factor (0.5 = less saturated, 1.5 = more saturated)
 * @returns {string} Adjusted color (hex)
 */
function adjustSaturation(hex, factor) {
    const rgb = hexToRgb(hex);
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    
    hsl.s = Math.max(0, Math.min(100, hsl.s * factor));
    
    const adjustedRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return rgbToHex(adjustedRgb.r, adjustedRgb.g, adjustedRgb.b);
}

/**
 * Undertone saturation modifiers for dynamic emotional depth
 * Maps undertone names to saturation adjustment factors
 */
const UNDERTONE_SATURATION = {
    intense: 1.6,    // +60% saturation - Electric, overwhelming
    confident: 1.3,  // +30% saturation - Bold, present
    nervous: 1.15,   // +15% saturation - Slightly heightened
    clear: 1.0,      // No change - Normal midtone
    tired: 0.8,      // -20% saturation - Washed out, fading
    subdued: 0.5     // -50% saturation - Ghostly, barely there
};

/**
 * Applies undertone saturation adjustment to a color
 * @param {string} hex - Base color
 * @param {string} undertone - Undertone name (intense, confident, nervous, clear, tired, subdued)
 * @returns {string} Adjusted color with undertone saturation applied
 */
function applyUndertoneSaturation(hex, undertone) {
    if (!undertone || undertone === 'clear') {
        return hex; // No adjustment for clear or missing undertone
    }
    
    const factor = UNDERTONE_SATURATION[undertone.toLowerCase()];
    if (!factor || factor === 1.0) {
        return hex;
    }
    
    return adjustSaturation(hex, factor);
}

/**
 * Applies undertone saturation to an array of colors (for particle systems)
 * @param {Array} colors - Array of colors (can be strings or objects with color property)
 * @param {string} undertone - Undertone name
 * @returns {Array} Adjusted color array with undertone saturation applied
 */
function applyUndertoneSaturationToArray(colors, undertone) {
    if (!colors || !Array.isArray(colors)) return colors;
    if (!undertone || undertone === 'clear') return colors;
    
    return colors.map(colorItem => {
        if (typeof colorItem === 'string') {
            // Simple color string
            return applyUndertoneSaturation(colorItem, undertone);
        } else if (colorItem && typeof colorItem === 'object' && colorItem.color) {
            // Weighted color object
            return {
                ...colorItem,
                color: applyUndertoneSaturation(colorItem.color, undertone)
            };
        }
        return colorItem;
    });
}

/**
 * Emotional color palette for the mascot system
 */
const EMOTIONAL_COLORS = {
    neutral: '#B0B0B0',
    joy: '#FFD700',
    sadness: '#4169E1',
    anger: '#DC143C',
    fear: '#8B008B',
    surprise: '#FF8C00',
    disgust: '#9ACD32',
    love: '#FF69B4'
};

/**
 * Gets RGB values for emotional colors (for performance)
 */
Object.fromEntries(
    Object.entries(EMOTIONAL_COLORS).map(([emotion, hex]) => {
        const rgb = hexToRgb(hex);
        return [emotion, `${rgb.r}, ${rgb.g}, ${rgb.b}`];
    })
);

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  EASING  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Easing Functions - Smooth Animation Transitions
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module Easing
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The MOTION MATHEMATICS of the engine. Provides easing functions that create       
 * ║ natural, organic movement patterns for emotional transitions and gestures,         
 * ║ making the mascot feel alive and responsive rather than mechanical.               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎢 EASING CURVES                                                                  
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Linear: Constant speed, no acceleration                                         
 * │ • Quadratic: Gentle acceleration/deceleration                                     
 * │ • Cubic: Moderate acceleration/deceleration                                       
 * │ • Elastic: Spring-like overshoot and bounce                                       
 * │ • Bounce: Realistic bouncing effect                                               
 * │ • Custom: Apply any easing by name                                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Linear easing - no acceleration
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function linear(t) {
    return t;
}

/**
 * Ease out quadratic - decelerating to zero velocity
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutQuad(t) {
    return t * (2 - t);
}

/**
 * Ease in quadratic - accelerating from zero velocity
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInQuad(t) {
    return t * t;
}

/**
 * Ease in-out quadratic - acceleration until halfway, then deceleration
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

/**
 * Ease out cubic - decelerating to zero velocity (smoother than quad)
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
}

/**
 * Ease in cubic - accelerating from zero velocity
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInCubic(t) {
    return t * t * t;
}

/**
 * Ease in-out cubic - acceleration until halfway, then deceleration
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

/**
 * Ease out elastic - elastic snap effect
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutElastic(t) {
    const c4 = (2 * Math.PI) / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
}

/**
 * Ease out bounce - bouncing effect
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutBounce(t) {
    const n1 = 7.5625;
    const d1 = 2.75;

    if (t < 1 / d1) {
        return n1 * t * t;
    } else if (t < 2 / d1) {
        return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
        return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
        return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
}

/**
 * Ease in-out back - slight overshoot effect
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInOutBack(t) {
    const c1 = 1.70158;
    const c2 = c1 * 1.525;

    return t < 0.5
        ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
        : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
}

/**
 * Ease out sine - sinusoidal easing
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutSine(t) {
    return Math.sin((t * Math.PI) / 2);
}

/**
 * Ease in-out sine - sinusoidal easing with smooth start and end
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInOutSine(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
}

/**
 * Gets an easing function by name
 * @param {string} name - Name of the easing function
 * @returns {Function} Easing function
 */
function getEasingFunction(name) {
    const easingFunctions = {
        linear,
        easeOutQuad,
        easeInQuad,
        easeInOutQuad,
        easeOutCubic,
        easeInCubic,
        easeInOutCubic,
        easeOutElastic,
        easeOutBounce,
        easeInOutBack,
        easeOutSine,
        easeInOutSine
    };

    return easingFunctions[name] || linear;
}

/**
 * Applies easing to a value between start and end
 * @param {number} progress - Progress (0 to 1)
 * @param {number} start - Start value
 * @param {number} end - End value
 * @param {string|Function} easing - Easing function name or function
 * @returns {number} Eased value between start and end
 */
function applyEasing(progress, start, end, easing = 'linear') {
    const easingFn = typeof easing === 'string' ? getEasingFunction(easing) : easing;
    const easedProgress = easingFn(Math.max(0, Math.min(1, progress)));
    return start + (end - start) * easedProgress;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Emotion Plugin Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bridge between plugin system and emotion registry
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module emotions/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Adapter for dynamic emotion registration from plugins.                            
 * ║ • Maintains separate registry for plugin emotions                                 
 * ║ • Validates emotion definitions for required properties                           
 * ║ • Provides legacy format conversion for older plugins                             
 * ║ • Enables runtime registration and unregistration                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Plugin emotion registry
 */
const pluginEmotions = new Map();

/**
 * Register a plugin emotion
 * @param {string} name - Emotion name
 * @param {Object} emotionDef - Emotion definition object
 */
function registerPluginEmotion(name, emotionDef) {
    // Ensure emotion has required properties
    if (!emotionDef.color) {
        return false;
    }
    
    // Add name if not present
    if (!emotionDef.name) {
        emotionDef.name = name;
    }
    
    // Ensure visual and modifiers exist
    if (!emotionDef.visual) {
        emotionDef.visual = {
            primaryColor: emotionDef.color,
            particleCount: emotionDef.particleCount || 15,
            particleSize: emotionDef.particleSize || { min: 2, max: 6 }
        };
    }
    
    if (!emotionDef.modifiers) {
        emotionDef.modifiers = {
            speed: 1.0,
            amplitude: 1.0,
            intensity: 1.0
        };
    }
    
    pluginEmotions.set(name, emotionDef);
    
    return true;
}

/**
 * Unregister a plugin emotion
 * @param {string} name - Emotion name to remove
 */
function unregisterPluginEmotion(name) {
    if (pluginEmotions.has(name)) {
        pluginEmotions.delete(name);
        
        return true;
    }
    return false;
}

/**
 * Get a plugin emotion by name
 * @param {string} name - Emotion name
 * @returns {Object|null} Emotion object or null if not found
 */
function getPluginEmotion(name) {
    return pluginEmotions.get(name) || null;
}

/**
 * Get all plugin emotion names
 * @returns {Array<string>} Array of emotion names
 */
function getAllPluginEmotions() {
    return Array.from(pluginEmotions.keys());
}

/**
 * Clear all plugin emotions
 */
function clearPluginEmotions() {
    pluginEmotions.clear();
}

/**
 * Convert legacy plugin emotion format to new format
 * @param {Object} legacyEmotion - Old format emotion
 * @returns {Object} New format emotion
 */
function createLegacyAdapter$2(legacyEmotion) {
    return {
        name: legacyEmotion.name || 'unknown',
        emoji: legacyEmotion.emoji || '🔌',
        color: legacyEmotion.primaryColor || legacyEmotion.color || '#7B68EE',
        energy: legacyEmotion.energy || 'medium',
        
        visual: {
            primaryColor: legacyEmotion.primaryColor || legacyEmotion.color || '#7B68EE',
            secondaryColor: legacyEmotion.secondaryColor,
            particleCount: legacyEmotion.particleCount || legacyEmotion.particleRate || 15,
            particleSize: legacyEmotion.particleSize || { min: 2, max: 6 },
            glowIntensity: legacyEmotion.glowIntensity || 0.5,
            trailLength: legacyEmotion.trailLength || 5,
            pulseRate: legacyEmotion.pulseRate || legacyEmotion.breathRate || 1.0
        },
        
        particles: {
            behavior: legacyEmotion.particleBehavior || 'ambient',
            density: legacyEmotion.particleDensity || 'medium',
            speed: legacyEmotion.particleSpeed || 'normal'
        },
        
        modifiers: {
            speed: legacyEmotion.speedMultiplier || 1.0,
            amplitude: legacyEmotion.amplitudeMultiplier || 1.0,
            intensity: legacyEmotion.intensityMultiplier || 1.0,
            smoothness: legacyEmotion.smoothnessMultiplier || 1.0
        },
        
        gestures: legacyEmotion.gestures || [],
        transitions: legacyEmotion.transitions || {}
    };
}

// Export adapter interface
var pluginAdapter$2 = {
    registerPluginEmotion,
    unregisterPluginEmotion,
    getPluginEmotion,
    getAllPluginEmotions,
    clearPluginEmotions,
    createLegacyAdapter: createLegacyAdapter$2
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Neutral Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Neutral emotional state - calm baseline
 * @author Emotive Engine Team
 * @module emotions/states/neutral
 */

/**
 * Neutral emotion configuration
 * The default calm state, baseline for all other emotions
 */
var neutral = {
    name: 'neutral',
    emoji: '😐',
    description: 'Calm, balanced emotional state',
    
    // Visual properties
    visual: {
        glowColor: '#00BCD4',        // Cyan baseline (more modern)
        glowIntensity: 0.9,          // Slightly softer glow
        particleRate: 2,              // Minimal particle generation
        minParticles: 8,             // Baseline particle presence
        maxParticles: 10,            // Limited particle count
        particleBehavior: 'ambient', // Gentle floating behavior
        breathRate: 1.0,             // Normal, relaxed breathing
        breathDepth: 0.08,           // Subtle breath variation
        coreJitter: false,           // Stable, still core
        particleColors: [
            { color: '#00BCD4', weight: 25 },  // Primary cyan
            { color: '#00ACC1', weight: 20 },  // Darker cyan
            { color: '#26C6DA', weight: 15 },  // Light cyan
            { color: '#B2EBF2', weight: 15 },  // Pale cyan highlight
            { color: '#0097A7', weight: 10 },  // Deep cyan shadow
            { color: '#80DEEA', weight: 10 },  // Cyan light
            { color: '#E0F7FA', weight: 5 }    // Very pale cyan
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.0,        // Baseline movement speed
        amplitude: 1.0,    // Standard motion range
        intensity: 1.0,    // Default force level
        smoothness: 1.0,   // Natural motion flow
        regularity: 1.0    // Consistent patterns
    },
    
    // Typical gestures for this emotion
    typicalGestures: [
        'breathe',   // Calm breathing
        'float',     // Gentle floating
        'idle',      // Idle animation
        'blink'      // Occasional blinks
    ],
    
    // Transition hints
    transitions: {
        duration: 500,      // Standard transition duration
        easing: 'easeInOut', // Balanced transition curve
        priority: 0         // Baseline priority level
    },
    
    // Audio/sound associations (optional)
    audio: {
        ambientSound: null,     // No specific ambient sound
        transitionSound: null,  // No transition sound
        gestureSound: null      // No gesture sound
    },
    
    // Particle spawn patterns
    particleSpawn: {
        pattern: 'random',      // Random spawn positions
        frequency: 'steady',    // Steady spawn rate
        burstOnEntry: false,    // No burst when entering state
        fadeOnExit: true        // Fade particles when leaving
    },
    
    // Eye/core appearance
    coreAppearance: {
        pupilSize: 1.0,        // Standard pupil dilation
        irisPattern: 'default', // Basic iris pattern
        blinkRate: 'normal',    // Regular blink frequency
        lookDirection: 'center' // Centered, neutral gaze
    },
    
    /**
     * Get core rendering parameters
     * @param {Object} state - Current renderer state
     * @returns {Object} Core rendering configuration
     */
    getCoreParams: function(state) {
        return {
            scaleX: 1.0,
            scaleY: 1.0,
            eyeOpenness: 1.0,
            eyeExpression: 'neutral', // neutral, happy, sad, focused
            pupilOffset: { x: 0, y: 0 }
        };
    },
    
    /**
     * Optional: Custom core rendering
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @returns {boolean} True if custom rendering was done
     */
    renderCore: function(ctx, x, y, radius) {
        // Return false to use default rendering
        return false;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Joy Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Joy emotional state - playful happiness
 * @author Emotive Engine Team
 * @module emotions/states/joy
 */

/**
 * Joy emotion configuration
 * Playful happiness with popcorn popping particles
 */
var joy = {
    name: 'joy',
    emoji: '😊',
    description: 'Playful happiness and celebration',
    
    // Visual properties
    visual: {
        glowColor: '#FFEB3B',       // Bright yellow sunshine
        glowIntensity: 1.6,         // Stronger cheerful glow
        particleRate: 40,           // Abundant celebration particles
        minParticles: 0,            // Can start from stillness
        maxParticles: 40,           // Maximum joyful expression
        particleBehavior: 'popcorn', // Spontaneous popping effect
        breathRate: 1.5,            // Excited, happy breathing
        breathDepth: 0.10,          // Moderate breath variation
        coreJitter: false,          // Stable, confident happiness
        particleColors: [
            { color: '#FFEB3B', weight: 25 },  // Bright sunshine yellow
            { color: '#FFC107', weight: 20 },  // Amber joy
            { color: '#FFFF00', weight: 15 },  // Pure yellow burst
            { color: '#FFD700', weight: 15 },  // Gold celebration
            { color: '#FFF59D', weight: 10 },  // Pale yellow sparkle
            { color: '#FF9800', weight: 10 },  // Orange warmth
            { color: '#FFFDE7', weight: 5 }    // Light cream highlight
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.8,        // Energetic, lively pace
        amplitude: 1.9,    // Expansive, celebratory movements
        intensity: 1.1,    // Enhanced joyful energy
        smoothness: 1.0,   // Natural, flowing motion
        regularity: 0.9,   // Playful, varied rhythm
        addBounce: true    // Extra springiness effect
    },
    
    // Typical gestures for joy
    typicalGestures: [
        'bounce',    // Happy bouncing
        'spin',      // Joyful spinning
        'wave',      // Excited waving
        'expand',    // Expanding with joy
        'shake',     // Excited shaking (gentle)
        'float'      // Floating with happiness
    ],
    
    // Transition hints
    transitions: {
        duration: 400,         // Swift mood elevation
        easing: 'easeOutBack', // Bouncy, playful entrance
        priority: 5,           // Elevated positive priority
        burstOnEntry: true     // Celebratory particle burst
    },
    
    // Audio/sound associations
    audio: {
        ambientSound: 'cheerful_hum',    // Cheerful background
        transitionSound: 'pop',           // Pop sound on entry
        gestureSound: 'giggle'            // Giggle on gestures
    },
    
    // Particle spawn patterns
    particleSpawn: {
        pattern: 'fountain',     // Fountain-like spawn
        frequency: 'burst',      // Burst spawning
        burstOnEntry: true,      // Big burst on entry
        fadeOnExit: false,       // Particles pop away
        specialEffect: 'sparkle' // Sparkle effect
    },
    
    // Eye/core appearance
    coreAppearance: {
        pupilSize: 1.2,          // Dilated with excitement
        irisPattern: 'radiant',   // Radiant, sparkling iris
        blinkRate: 'frequent',    // Happy, frequent blinking
        lookDirection: 'up',      // Optimistic upward gaze
        specialEffect: 'twinkle'  // Sparkling eye effect
    },
    
    // Rhythm configuration - joy bounces to the beat
    rhythm: {
        enabled: true,
        
        // Particle emission celebrates on beat
        particleEmission: {
            syncMode: 'beat',
            burstSize: 8,           // Big celebration bursts
            offBeatRate: 0.6,       // Still happy between beats
            popcornSync: true       // Popcorn pops on beat
        },
        
        // Breathing syncs to happy tempo
        breathSync: {
            mode: 'beats',
            beatsPerBreath: 4,     // One breath per bar
            intensity: 1.2          // Deeper happy breaths
        },
        
        // Glow pulses with joy
        glowSync: {
            intensityRange: [1.2, 1.8],
            syncTo: 'beat',
            attack: 0.05,           // Quick brightening
            decay: 0.4              // Bouncy fade
        },
        
        // Pattern-specific joy expressions
        patternBehaviors: {
            'waltz': {
                // Elegant happy waltz
                particleEmission: { burstSize: 5 },
                breathSync: { beatsPerBreath: 3 }
            },
            'swing': {
                // Jazzy playful joy
                particleEmission: { 
                    syncMode: 'swing',
                    burstSize: 6
                },
                glowSync: { curve: 'bounce' }
            },
            'dubstep': {
                // Explosive joy on drops
                particleEmission: {
                    burstSize: 15,
                    dropMultiplier: 3.0
                }
            },
            'breakbeat': {
                // Chaotic happy energy
                particleEmission: {
                    syncMode: 'random',
                    burstRange: [3, 12]
                }
            }
        }
    },
    
    /**
     * Get core rendering parameters for joy
     */
    getCoreParams: function(state) {
        return {
            scaleX: 1.0,
            scaleY: 1.0,
            eyeOpenness: 1.0,
            eyeExpression: 'happy',  // ∪ shaped eyes
            pupilOffset: { x: 0, y: -0.1 },  // Looking slightly up
            sparkle: true  // Add sparkle effect
        };
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sadness Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sadness emotional state - melancholic sorrow
 * @author Emotive Engine Team
 * @module emotions/states/sadness
 */

var sadness = {
    name: 'sadness',
    emoji: '😢',
    description: 'Deep melancholic sorrow',
    
    // Visual properties
    visual: {
        glowColor: '#4169E1',       // Royal blue melancholy
        glowIntensity: 0.65,        // Dimmer, more subdued glow
        particleRate: 25,           // Steady tear-like emission
        minParticles: 0,            // Can fade to emptiness
        maxParticles: 25,           // Abundant sorrow display
        particleBehavior: 'falling', // Tears falling downward
        breathRate: 0.6,            // Slow, heavy breathing
        breathDepth: 0.12,          // Deep, sighing breaths
        coreJitter: false,          // Still, heavy core
        particleColors: [
            { color: '#4169E1', weight: 25 },  // Royal blue sorrow
            { color: '#1E90FF', weight: 20 },  // Dodger blue tears
            { color: '#6495ED', weight: 15 },  // Cornflower blue melancholy
            { color: '#B0C4DE', weight: 15 },  // Light steel blue mist
            { color: '#191970', weight: 10 },  // Midnight blue depth
            { color: '#87CEEB', weight: 10 },  // Sky blue glimmer
            { color: '#2F4F4F', weight: 5 }    // Dark slate gray shadow
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.7,         // Slowed, weary pace
        amplitude: 0.6,     // Diminished movement range
        intensity: 0.8,     // Weakened emotional force
        smoothness: 1.3,    // Smooth, flowing sorrow
        regularity: 1.1,    // Slightly monotonous patterns
        addGravity: true    // Downward, heavy feeling
    },
    
    // Typical gestures for sadness
    typicalGestures: [
        'droop',
        'sway',
        'contract',
        'drift',
        'sink'
    ],
    
    // Transition configuration
    transitions: {
        duration: 800,         // Gradual mood shift
        easing: 'easeInOut',  // Smooth emotional transition
        priority: 3           // Lower emotional priority
    },
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Anger Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Anger emotional state - intense rage
 * @author Emotive Engine Team
 * @module emotions/states/anger
 */

/**
 * Anger emotion configuration
 * Intense aggressive state with rapid, chaotic particles
 */
var anger = {
    name: 'anger',
    emoji: '😠',
    description: 'Intense rage and aggression',
    
    // Visual properties
    visual: {
        glowColor: '#DC143C',       // Crimson rage - more intense
        glowIntensity: 1.8,         // Stronger, burning aura
        particleRate: 20,           // More frequent particle generation for chaos
        minParticles: 3,            // Maintain constant agitation
        maxParticles: 10,           // More particles for intensity
        particleBehavior: 'aggressive', // Erratic, forceful particle movement
        breathRate: 2.2,            // Rapid, agitated breathing rhythm
        breathDepth: 0.15,          // Deep, forceful breath cycles
        coreJitter: true,           // Visual tremor from internal rage
        particleColors: [
            { color: '#DC143C', weight: 25 },  // Crimson rage
            { color: '#FF0000', weight: 20 },  // Pure red fury
            { color: '#B22222', weight: 15 },  // FireBrick intensity
            { color: '#FF4500', weight: 15 },  // OrangeRed flames
            { color: '#8B0000', weight: 10 },  // Dark red depth
            { color: '#FF6347', weight: 10 },  // Tomato heat
            { color: '#660000', weight: 5 }    // Nearly black ember
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.5,        // Accelerated motion for urgency
        amplitude: 1.4,    // Exaggerated movement range
        intensity: 1.3,    // Heightened force and impact
        smoothness: 0.3,   // Sharp, abrupt transitions
        regularity: 0.7,   // Erratic, unpredictable patterns
        addShake: true     // Tremor effect from rage
    },
    
    // Typical gestures for anger
    typicalGestures: [
        'shake',     // Violent shaking
        'vibrate',   // Angry vibration
        'expand',    // Explosive expansion
        'pulse',     // Angry pulsing
        'flicker',   // Rage flickering
        'strike'     // Strike motion
    ],
    
    // Transition hints
    transitions: {
        duration: 300,          // Swift state change
        easing: 'easeOutExpo',  // Explosive, sudden entrance
        priority: 8,            // High priority emotional state
        shakeOnEntry: true      // Trigger screen disturbance
    },
    
    // Audio/sound associations
    audio: {
        ambientSound: 'rumble',      // Low rumbling
        transitionSound: 'explosion', // Explosive sound
        gestureSound: 'growl'         // Growling sounds
    },
    
    // Particle spawn patterns
    particleSpawn: {
        pattern: 'explosive',    // Explosive spawn
        frequency: 'chaotic',    // Chaotic frequency
        burstOnEntry: true,      // Explosion on entry
        fadeOnExit: false,       // Particles dissipate violently
        specialEffect: 'flames'  // Flame-like effect
    },
    
    // Eye/core appearance
    coreAppearance: {
        pupilSize: 0.7,           // Constricted for focused intensity
        irisPattern: 'sharp',      // Angular, aggressive iris pattern
        blinkRate: 'rare',        // Unwavering, intense gaze
        lookDirection: 'forward',  // Direct, confrontational focus
        specialEffect: 'flames',   // Fire-like eye effects
        pulseRate: 'rapid'        // Quick, agitated pulsing
    },
    
    // Special anger properties
    special: {
        screenShake: true,         // Environmental disturbance effect
        particleTrails: 'fire',    // Incendiary particle trail style
        glowPulse: true,          // Rhythmic aura fluctuation
        temperatureEffect: 'hot'   // Warm spectrum color shifting
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fear Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var fear = {
    name: 'fear',
    emoji: '😨',
    description: 'Anxious state with fleeing particles',
    
    // Visual properties
    visual: {
        glowColor: '#8A2BE2',       // Dark violet (BlueViolet) - more ominous
        glowIntensity: 0.9,         // Slightly stronger, pulsing glow
        particleRate: 18,           // More rapid nervous emission
        minParticles: 4,            // Constant anxious presence
        maxParticles: 16,           // Scattered fearful display
        particleBehavior: 'scattering', // Particles flee outward
        breathRate: 2.5,            // Rapid, shallow breathing
        breathDepth: 0.06,          // Short, panicked breaths
        coreJitter: true,           // Trembling with anxiety
        particleColors: [
            { color: '#8A2BE2', weight: 25 },  // Dark violet base
            { color: '#4B0082', weight: 20 },  // Indigo dread
            { color: '#9400D3', weight: 15 },  // Dark violet panic
            { color: '#6B46C1', weight: 15 },  // Deep purple anxiety
            { color: '#9932CC', weight: 10 },  // Dark orchid fear
            { color: '#E6E6FA', weight: 8 },   // Pale lavender flash
            { color: '#301934', weight: 7 }    // Almost black shadow
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.4,        // Quick, reactive movements
        amplitude: 0.8,    // Restricted, defensive range
        intensity: 1.2,    // Heightened fight-or-flight response
        smoothness: 0.5,   // Jerky, startled transitions
        regularity: 0.5,   // Unpredictable panic patterns
        addJitter: true    // Nervous trembling overlay
    },
    
    // Typical gestures for fear
    typicalGestures: ['shake', 'vibrate', 'contract', 'flicker', 'retreat'],
    
    // Transition configuration
    transitions: { 
        duration: 400,       // Quick fear response
        easing: 'easeOut',  // Sudden onset
        priority: 7         // High alert priority
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Surprise Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var surprise = {
    name: 'surprise',
    emoji: '😲',
    description: 'Sudden shock with explosive particles',
    
    // Visual properties
    visual: {
        glowColor: '#FFD700',       // Bright gold (shining surprise)
        glowIntensity: 1.8,         // Very intense, sudden flash
        particleRate: 30,           // Rapid burst emission
        minParticles: 0,            // Can start from nothing
        maxParticles: 15,           // Burst of shocked particles
        particleBehavior: 'burst',  // Explosive outward motion
        breathRate: 0.3,            // Gasping, held breath
        breathDepth: 0.18,          // Large shocked inhale
        coreJitter: false,          // Frozen in surprise
        particleColors: [
            { color: '#FFD700', weight: 25 },  // Gold burst
            { color: '#FFA500', weight: 20 },  // Orange shock
            { color: '#FFFF00', weight: 15 },  // Yellow flash
            { color: '#FF6347', weight: 15 },  // Tomato red excitement
            { color: '#FFE4B5', weight: 10 },  // Moccasin highlight
            { color: '#FF4500', weight: 10 },  // OrangeRed pop
            { color: '#FFFACD', weight: 5 }    // LemonChiffon sparkle
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.6,         // Rapid, startled reactions
        amplitude: 1.5,     // Large, exaggerated movements
        intensity: 1.4,     // Strong shock force
        smoothness: 0.7,    // Abrupt, jerky motions
        regularity: 0.8,    // Erratic surprise patterns
        addPop: true        // Popping, explosive effect
    },
    
    // Typical gestures for surprise
    typicalGestures: ['expand', 'bounce', 'flash', 'pulse', 'pop'],
    
    // Transition configuration
    transitions: { 
        duration: 200,           // Instant shock response
        easing: 'easeOutBack',  // Snappy, elastic reaction
        priority: 6             // High interrupt priority
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Disgust Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var disgust = {
    name: 'disgust',
    emoji: '🤢',
    description: 'Revulsion with repelling particles',
    
    // Visual properties
    visual: {
        glowColor: '#9ACD32',       // Sickly yellow-green (YellowGreen)
        glowIntensity: 1.0,         // Stronger, toxic glow
        particleRate: 15,           // More particles for nauseating effect
        minParticles: 5,            // Maintain visible repulsion
        maxParticles: 12,           // Controlled rejection display
        particleBehavior: 'repelling', // Particles flee from center
        breathRate: 0.7,            // Slow, queasy breathing
        breathDepth: 0.04,          // Shallow, uncomfortable breaths
        coreJitter: false,          // Stable but uneasy core
        particleColors: [
            { color: '#9ACD32', weight: 25 },  // Yellow-green toxic
            { color: '#ADFF2F', weight: 20 },  // Bright acid green
            { color: '#7FFF00', weight: 15 },  // Chartreuse nausea
            { color: '#BDB76B', weight: 15 },  // Dark khaki sick
            { color: '#6B8E23', weight: 10 },  // Olive drab decay
            { color: '#CCFF00', weight: 8 },   // Fluorescent bile
            { color: '#556B2F', weight: 7 }    // Dark olive shadow
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.9,        // Slightly slowed movements
        amplitude: 0.7,    // Restricted, withdrawn motion
        intensity: 0.9,    // Controlled repulsion force
        smoothness: 0.8,   // Mostly smooth with discomfort
        regularity: 1.0,   // Consistent rejection pattern
        addRecoil: true    // Recoiling motion effect
    },
    
    // Typical gestures for disgust
    typicalGestures: ['contract', 'shake', 'recoil', 'wobble'],
    
    // Transition configuration
    transitions: { 
        duration: 600,       // Moderate transition speed
        easing: 'easeIn',   // Gradual onset of revulsion
        priority: 4         // Mid-level priority state
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Love Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var love = {
    name: 'love',
    emoji: '💕',
    description: 'Warm affection with orbiting particles',
    
    // Visual properties
    visual: {
        glowColor: '#FF1493',       // Deep passionate pink (DeepPink)
        glowIntensity: 1.8,         // Strong, radiant warmth
        particleRate: 25,           // Generous particle flow
        minParticles: 10,           // Constant loving presence
        maxParticles: 18,           // Abundant affection display
        particleBehavior: 'orbiting', // Particles orbit romantically
        breathRate: 0.75,           // Slow, content breathing
        breathDepth: 0.15,          // Deep, satisfied breaths
        coreJitter: false,          // Stable, secure feeling
        particleColors: [
            { color: '#FF1493', weight: 30 },  // Deep passionate pink
            { color: '#FF69B4', weight: 25 },  // Hot pink
            { color: '#FF007F', weight: 15 },  // Rose red
            { color: '#FFB6C1', weight: 10 },  // Light pink highlights
            { color: '#FF45A0', weight: 10 },  // Vibrant magenta
            { color: '#E91E63', weight: 5 },   // Material pink accent
            { color: '#FFC0CB', weight: 5 }    // Soft pink glow
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.9,         // Gentle, romantic pace
        amplitude: 1.1,     // Slightly expanded movements
        intensity: 1.2,     // Enhanced emotional depth
        smoothness: 1.4,    // Extra smooth, flowing motion
        regularity: 1.2,    // Consistent, rhythmic patterns
        addWarmth: true     // Warm, inviting quality
    },
    
    // Typical gestures for love
    typicalGestures: ['pulse', 'sway', 'orbit', 'glow', 'breathe', 'float'],
    
    // Transition configuration
    transitions: { 
        duration: 700,         // Gradual emotional shift
        easing: 'easeInOut',  // Smooth, gentle transition
        priority: 5           // Moderate emotional priority
    },
    
    // Rhythm configuration - how love emotion responds to musical timing
    rhythm: {
        enabled: true,
        
        // Particle emission syncs to rhythm
        particleEmission: {
            syncMode: 'beat',        // Emit bursts on beat
            burstSize: 3,            // Extra particles per beat
            offBeatRate: 0.7         // Reduced emission between beats
        },
        
        // Orbital motion rhythm
        orbitalSync: {
            speedMultiplier: {
                onBeat: 1.2,         // Speed up on beat
                offBeat: 0.9,        // Slow between beats
                curve: 'ease'        // Smooth speed changes
            },
            radiusSync: {
                enabled: true,
                subdivision: 'quarter',  // Pulse radius on quarters
                amount: 0.15            // 15% radius variation
            }
        },
        
        // Glow pulsing with rhythm
        glowSync: {
            intensityRange: [1.4, 2.0],  // Min/max glow intensity
            syncTo: 'beat',              // Pulse on beats
            attack: 0.1,                 // Quick brightening
            decay: 0.6                   // Gentle fade
        },
        
        // Breathing synced to bars
        breathSync: {
            mode: 'bars',
            barsPerBreath: 2,    // One breath every 2 bars
            intensity: 1.0        // Full sync strength
        },
        
        // Pattern-specific overrides
        patternBehaviors: {
            'waltz': {
                // 3/4 time creates romantic swaying
                orbitalSync: { 
                    radiusSync: { subdivision: 'bar', amount: 0.25 }
                },
                particleEmission: { syncMode: 'bar', burstSize: 5 }
            },
            'swing': {
                // Jazzy, playful love
                orbitalSync: {
                    speedMultiplier: { onBeat: 1.5, curve: 'bounce' }
                }
            }
        },
        
        // Intensity modulation
        intensityMapping: {
            low: { particleRate: 0.6, glowIntensity: 0.8 },
            medium: { particleRate: 1.0, glowIntensity: 1.0 },
            high: { particleRate: 1.4, glowIntensity: 1.3 }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Suspicion Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var suspicion = {
    name: 'suspicion',
    emoji: '🤨',
    description: 'Paranoid watchfulness with surveillance scanning',
    
    // Visual properties
    visual: {
        glowColor: '#6B46C1',       // Deep purple paranoia
        glowIntensity: 0.85,        // Watchful glow that intensifies with threat
        particleRate: 18,           // Increased surveillance particles
        minParticles: 6,            // More eyes watching
        maxParticles: 12,           // Heightened alert capacity
        particleBehavior: 'surveillance',  // NEW: Searchlight scanning behavior
        particleSpeed: 0.2,         // Base particle speed
        breathRate: 0.6,            // Slower, more deliberate breathing
        breathDepth: 0.04,          // Very shallow, tense breaths
        coreJitter: 0.02,           // Slight nervous tremor
        particleColors: [
            { color: '#6B46C1', weight: 30 },  // Deep purple paranoia
            { color: '#4A5568', weight: 25 },  // Shadowy slate gray
            { color: '#8B4789', weight: 20 },  // Dark magenta mystery
            { color: '#9F7AEA', weight: 15 },  // Alert purple highlights
            { color: '#2D3748', weight: 10 }   // Deep shadow lurking
        ],
        // Dynamic threat level properties
        threatLevel: 0,             // 0-1 scale, updated by gaze distance
        getGlowIntensity: function() {
            return 0.3 + (this.threatLevel * 0.7);
        },
        getParticleSpeed: function() {
            return 0.2 + (this.threatLevel * 0.8);
        },
        getGlowColor: function() {
            // Color shifts from purple to red as threat increases
            const baseColor = { r: 107, g: 70, b: 193 };  // #6B46C1
            const alertColor = { r: 220, g: 38, b: 127 }; // #DC267F (magenta-red)
            
            const t = this.threatLevel || 0;
            
            const r = Math.round(baseColor.r + (alertColor.r - baseColor.r) * t);
            const g = Math.round(baseColor.g + (alertColor.g - baseColor.g) * t);
            const b = Math.round(baseColor.b + (alertColor.b - baseColor.b) * t);
            
            // Convert to hex
            const toHex = (val) => val.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.4,         // Slower, more deliberate movements
        amplitude: 0.6,     // Smaller, controlled movements
        intensity: 1.2,     // Higher alertness
        smoothness: 0.3,    // Jerky, paranoid movements
        regularity: 0.2,    // Highly unpredictable patterns
        focus: 1.5,         // Hyper-focused attention
        addWobble: true     // Uncertain, questioning motion
    },
    
    // Typical gestures for suspicion
    typicalGestures: ['scan', 'twitch', 'peek', 'tilt', 'hold'],
    
    // Transition configuration
    transitions: { 
        duration: 500,       // Moderate alertness shift
        easing: 'linear',   // Steady, controlled transition
        priority: 4         // Mid-level alert priority
    },
    
    // Special suspicion properties
    special: {
        coreSquint: 0.6,        // More pronounced eye narrowing
        scanInterval: 2000,     // More frequent scans
        scanDuration: 1200,     // Longer, more thorough scanning
        scanAngle: 60,          // Wider scanning range
        twitchChance: 0.02,     // 2% chance per frame to twitch
        peekInterval: 4000,     // Time between peek gestures
        maxThreatDistance: 300, // Distance for threat calculation
        alertThreshold: 0.7     // Threat level for maximum alert
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Excited Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var excited = {
    name: 'excited',
    emoji: '🤩',
    description: 'High energy with rapid particles',
    
    // Visual properties
    visual: {
        glowColor: '#FF6B35',       // Vibrant orange-red energy
        glowIntensity: 1.5,         // Stronger energetic aura
        particleRate: 25,           // Increased emission frequency (was 15)
        minParticles: 8,            // More constant particles (was 5)
        maxParticles: 30,           // More maximum particles (was 20)
        particleBehavior: 'burst',  // Explosive particle behavior
        breathRate: 2.0,            // Quick, excited breathing
        breathDepth: 0.14,          // Deep, energized breaths
        coreJitter: true,           // Vibrating with enthusiasm
        particleColors: [
            { color: '#FF6B35', weight: 25 },  // Vibrant orange energy
            { color: '#FF1744', weight: 20 },  // Red accent excitement
            { color: '#FFC107', weight: 15 },  // Amber sparkle
            { color: '#FF9100', weight: 15 },  // Deep orange burst
            { color: '#FFEB3B', weight: 10 },  // Yellow flash
            { color: '#FF5722', weight: 10 },  // Deep orange-red
            { color: '#FFF59D', weight: 5 }    // Pale yellow highlight
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.4,         // Quickened, energetic pace
        amplitude: 1.3,     // Expansive, enthusiastic movements
        intensity: 1.3,     // Strong energetic force
        smoothness: 0.8,    // Smooth with energetic bursts
        regularity: 0.7,    // Spontaneous, varied patterns
        addVibration: true  // Buzzing with excitement
    },
    
    // Typical gestures for excitement
    typicalGestures: ['bounce', 'spin', 'vibrate', 'expand', 'shake', 'pulse'],
    
    // Transition configuration
    transitions: { 
        duration: 300,              // Quick state entry
        easing: 'easeOutElastic',  // Bouncy, elastic entrance
        priority: 6                // High-energy priority level
    },
    
    // Rhythm configuration - excited syncs energetically to beat
    rhythm: {
        enabled: true,
        
        // Particle emission doubles on beat
        particleEmission: {
            syncMode: 'beat',
            burstSize: 5,           // Big bursts on beat
            offBeatRate: 0.5        // Calmer between beats
        },
        
        // Core jitter syncs to subdivisions
        jitterSync: {
            subdivision: 'sixteenth',  // Rapid jitter on 16th notes
            intensity: 0.8,           // Strong rhythm influence
            onBeat: 1.5              // Extra jitter on beat
        },
        
        // Glow pulses rapidly with beat
        glowSync: {
            intensityRange: [1.0, 1.8],
            syncTo: 'eighth',         // Pulse on 8th notes
            attack: 0.05,            // Very quick attack
            decay: 0.2               // Quick decay
        },
        
        // Different patterns create different excitement
        patternBehaviors: {
            'dubstep': {
                // Heavy drops create explosion effects
                particleEmission: { 
                    syncMode: 'beat',
                    burstSize: 10,      // Huge bursts on drop
                    dropMultiplier: 2   // Double on beat 3
                }
            },
            'breakbeat': {
                // Broken beats create chaotic energy
                jitterSync: {
                    subdivision: 'random',
                    intensity: 1.0
                }
            }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Resting Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var resting$1 = {
    name: 'resting',
    emoji: '😴',
    description: 'Deep relaxation with slow drift',
    
    // Visual properties
    visual: {
        glowColor: '#9370DB',       // Sleepy purple twilight
        glowIntensity: 0.8,         // Dimmed, drowsy glow
        particleRate: 10,           // Lazy particle generation
        minParticles: 3,            // Minimal sleepy presence
        maxParticles: 5,            // Few drifting particles
        particleBehavior: 'resting', // Slow, floating behavior
        breathRate: 0.8,            // Deep, slow breathing
        breathDepth: 0.12,          // Pronounced rest breaths
        coreJitter: false,          // Perfectly still core
        particleColors: [
            { color: '#9370DB', weight: 30 },  // Primary sleepy purple
            { color: '#A591C4', weight: 20 },  // Soft lavender drift
            { color: '#B366FF', weight: 20 },  // Dreamy violet accent
            { color: '#B8A1E6', weight: 15 },  // Light drowsy highlights
            { color: '#674D9B', weight: 15 }   // Deep sleep shadows
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.5,         // Slowed, drowsy pace
        amplitude: 0.4,     // Minimal movement range
        intensity: 0.5,     // Reduced energy level
        smoothness: 1.4,    // Extra smooth drifting
        regularity: 0.9,    // Slightly irregular, natural rest
        addWeight: true     // Heavy, weighted feeling
    },
    
    // Typical gestures for resting
    typicalGestures: ['breathe', 'drift', 'sway', 'float'],
    
    // Transition configuration
    transitions: { 
        duration: 1000,         // Slow fade to rest
        easing: 'easeInOut',   // Gentle transition
        priority: 2            // Low priority state
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Euphoria Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var euphoria = {
    name: 'euphoria',
    emoji: '🌟',
    description: 'Radiant hope and new beginnings',
    
    // Visual properties
    visual: {
        glowColor: '#FFB6C1',       // Light pink euphoric glow
        glowIntensity: 2.0,         // Maximum transcendent radiance
        particleRate: 35,           // Abundant particle emission
        minParticles: 15,           // Abundant positive energy
        maxParticles: 30,           // Maximum radiant display
        particleBehavior: 'radiant', // Outward radiating particles
        breathRate: 1.3,            // Elevated, joyful breathing
        breathDepth: 0.25,          // Full, satisfied breaths
        coreJitter: false,          // Stable, confident core
        particleColors: [
            { color: '#FFB6C1', weight: 20 },  // Light pink bliss
            { color: '#FFD700', weight: 18 },  // Golden joy
            { color: '#87CEEB', weight: 15 },  // Sky blue serenity
            { color: '#DDA0DD', weight: 15 },  // Plum transcendence
            { color: '#98FB98', weight: 12 },  // Pale green harmony
            { color: '#FFA07A', weight: 10 },  // Light salmon warmth
            { color: '#E6E6FA', weight: 8 },   // Lavender dream
            { color: '#FFFFFF', weight: 2 }    // Pure white sparkle
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.4,         // Energized, flowing pace
        amplitude: 1.5,     // Expansive, reaching movements
        intensity: 1.6,     // Powerful positive force
        smoothness: 1.3,    // Extra fluid, graceful motion
        regularity: 0.8,    // Natural variation in rhythm
        addWarmth: true,    // Warm, inviting quality
        addLift: true       // Upward, elevating tendency
    },
    
    // Typical gestures for euphoria
    typicalGestures: ['expand', 'radiate', 'pulse', 'glow', 'float', 'bloom'],
    
    // Transition configuration
    transitions: { 
        duration: 600,           // Smooth emergence
        easing: 'easeOutExpo',  // Explosive, radiant entrance
        priority: 8             // High priority transcendent state
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Focused Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var focused = {
    name: 'focused',
    emoji: '🎯',
    description: 'Intense concentration with directed flow',
    
    // Visual properties
    visual: {
        glowColor: '#00CED1',       // Sharp cyan concentration
        glowIntensity: 1.2,         // Clear, defined aura
        particleRate: 10,           // Steady, controlled emission
        minParticles: 5,            // Consistent focus presence
        maxParticles: 12,           // Controlled attention display
        particleBehavior: 'directed', // Particles follow target
        breathRate: 1.2,            // Steady, measured breathing
        breathDepth: 0.08,          // Controlled, regular breaths
        coreJitter: true,           // Minimal tracking adjustments
        particleColors: [
            { color: '#00CED1', weight: 30 },  // Primary focused cyan
            { color: '#4A9FA0', weight: 20 },  // Muted concentration tone
            { color: '#00FFFF', weight: 20 },  // Bright attention burst
            { color: '#5FE5E7', weight: 15 },  // Light focus highlights
            { color: '#006B6D', weight: 15 }   // Deep concentration base
        ],
        eyeOpenness: 0.7,           // Narrowed for concentration
        microAdjustments: true      // Subtle tracking movements
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.0,         // Baseline, deliberate pace
        amplitude: 0.9,     // Controlled movement range
        intensity: 1.1,     // Enhanced focus strength
        smoothness: 1.1,    // Precise, smooth tracking
        regularity: 1.2,    // Consistent, predictable patterns
        addPrecision: true  // Enhanced accuracy mode
    },
    
    // Typical gestures for focus
    typicalGestures: ['track', 'lock', 'scan', 'pulse', 'vibrate'],
    
    // Transition configuration
    transitions: { 
        duration: 400,       // Moderate focus shift
        easing: 'easeIn',   // Gradual concentration
        priority: 5         // Mid-level attention priority
    },
    
    // Core appearance parameters
    getCoreParams: function(state) {
        return {
            scaleX: 1.1,              // Slightly widened awareness
            scaleY: 0.7,              // Narrowed for concentration
            eyeOpenness: 0.7,         // Focused gaze intensity
            eyeExpression: 'focused', // Concentrated expression
            pupilOffset: { x: 0, y: 0 }, // Centered attention
            microAdjustments: true    // Small tracking movements
        };
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glitch Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var glitch = {
    name: 'glitch',
    emoji: '⚡',
    description: 'Digital distortion with erratic particle stutters',
    
    // Visual properties
    visual: {
        primaryColor: '#00FFAA',    // Bright digital cyan-green
        glowColor: '#00FFAA',       // Bright digital cyan-green
        glowIntensity: 2.2,         // Intense, flickering energy
        particleRate: 30,           // High rate for glitchy effect
        minParticles: 12,           // Constant digital noise
        maxParticles: 20,           // Maximum chaos
        particleBehavior: 'glitchy', // New glitch behavior
        particleSpeed: 1.5,         // Fast, erratic speeds
        breathRate: 0.3,            // Rapid, stuttering breaths
        breathDepth: 0.08,          // Shallow, digital hiccups
        coreJitter: 0.04,           // Constant digital tremor
        coreSize: 1.1,              // Slightly enlarged core
        eyeOpenness: 1.0,           // Wide open eyes
        particleColors: [
            { color: '#00FFAA', weight: 25 },  // Bright cyan-green
            { color: '#FF00AA', weight: 20 },  // Hot magenta
            { color: '#00FF00', weight: 15 },  // Pure digital green
            { color: '#FF0099', weight: 15 },  // Neon pink
            { color: '#00FFFF', weight: 10 },  // Electric cyan
            { color: '#FFAA00', weight: 8 },   // Digital amber warning
            { color: '#FF00FF', weight: 5 },   // Pure magenta glitch
            { color: '#FFFFFF', weight: 2 }    // Rare white static
        ],
        // Glitch-specific properties
        glitchIntensity: 0.8,      // How intense the glitching is
        flickerChance: 0.05,       // 5% chance per frame to flicker
        rgbShift: true,            // Enable RGB channel separation
        digitalNoise: true,        // Add digital noise pattern
        getGlowIntensity: function() {
            // Random intensity flickers
            if (Math.random() < this.flickerChance) {
                return 0.2 + Math.random() * 2.5;
            }
            return this.glowIntensity;
        },
        getGlowColor: function() {
            // Occasionally shift to random glitch colors
            if (Math.random() < 0.02) {
                const glitchColors = ['#FF00AA', '#00FFFF', '#FF0099', '#00FFAA', '#FFAA00'];
                return glitchColors[Math.floor(Math.random() * glitchColors.length)];
            }
            return this.glowColor;
        }
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 2.0,         // Hyper-speed movements
        amplitude: 0.8,     // Constrained but erratic
        intensity: 1.8,     // High energy bursts
        smoothness: 0.1,    // Extremely jerky, stuttering motion
        regularity: 0.1,    // Completely unpredictable
        focus: 0.5,         // Scattered, unfocused
        addGlitch: true,    // Special glitch modifier
        addStutter: true    // Stuttering motion effect
    },
    
    // Typical gestures for glitch
    typicalGestures: ['twitch', 'jitter', 'breathe', 'pulse', 'shake', 'flicker'],
    
    // Transition configuration
    transitions: { 
        duration: 100,          // Instant, jarring transitions
        easing: 'linear',       // No smoothing - digital snap
        priority: 7,            // High priority disruption
        glitchIn: true          // Special glitch transition effect
    },
    
    // Special glitch properties
    special: {
        stutterInterval: 50,        // Stutter every 50ms
        stutterDuration: 20,        // Each stutter lasts 20ms
        rgbOffset: 3,               // Pixel offset for RGB separation
        scanlineEffect: true,       // Add CRT scanlines
        datamoshChance: 0.01,       // 1% chance to datamosh
        corruptionZones: 3,         // Number of corruption areas
        digitalTearHeight: 10       // Height of digital tears
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Calm Emotion
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Calm emotional state - serene and peaceful
 * @author Emotive Engine Team
 * @module emotions/states/calm
 */

/**
 * Calm emotion configuration
 * A state of deep tranquility and inner peace
 */
var calm = {
    name: 'calm',
    emoji: '😌',
    description: 'Serene, peaceful state with gentle movements',

    // Visual properties
    visual: {
        glowColor: '#66D9CC',        // Bright mint/turquoise (more distinct from neutral blue)
        glowIntensity: 0.6,          // Softer glow than neutral
        particleRate: 25,            // Steady, peaceful emission like sadness
        minParticles: 8,             // Keep some particles always
        maxParticles: 25,            // Allow more particles like sadness
        particleBehavior: 'zen',     // Zen orbital behavior
        breathRate: 0.4,             // Much slower breathing than neutral (1.0)
        breathDepth: 0.12,           // Deeper breaths than neutral (0.08)
        coreJitter: false,           // Perfectly still core
        particleColors: [
            { color: '#66D9CC', weight: 35 },  // Bright turquoise
            { color: '#99E6D9', weight: 25 },  // Light mint
            { color: '#40BFB3', weight: 20 },  // Medium teal
            { color: '#B3F2E6', weight: 15 },  // Pale mint
            { color: '#339980', weight: 5 }    // Deep teal shadow
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 0.5,         // Much slower than neutral (1.0)
        amplitude: 0.3,     // Significantly reduced motion range
        intensity: 0.4,     // Very gentle force level
        smoothness: 2.0,    // Much smoother than neutral
        regularity: 1.5,    // More consistent patterns
        addWeight: false,   // Light, floating feeling
        floatHeight: 0.2,   // Minimal floating height
        swayAmount: 0.15,   // Very minimal side-to-side sway
        duration: 1.5       // Extend gesture duration
    },

    // Typical gestures for this emotion
    typicalGestures: [
        'breathe',   // Deep, slow breathing
        'float',     // Gentle floating
        'drift',     // Slow drifting
        'idle'       // Peaceful idle state
    ],

    // Transition hints
    transitions: {
        duration: 800,           // Slower transition into calm
        easing: 'easeInOutSine', // Very smooth sine curve
        priority: 1              // Low-medium priority
    },

    // Audio/sound associations
    audio: {
        ambientSound: 'soft_waves',  // Gentle ambient sounds
        transitionSound: null,        // No harsh transition
        gestureSound: null,           // Silent gestures
        volumeModifier: 0.5           // Quieter overall
    },

    // Particle spawn patterns
    particleSpawn: {
        pattern: 'center_drift',  // Spawn from center, drift outward
        frequency: 'slow',        // Very slow spawn rate
        burstOnEntry: false,      // No burst when entering
        fadeOnExit: true,         // Gentle fade when leaving
        spawnRadius: 0.3,         // Spawn close to center
        driftSpeed: 0.2           // Very slow particle drift
    },

    // Eye/core appearance
    coreAppearance: {
        pupilSize: 0.9,           // Slightly relaxed pupils
        irisPattern: 'soft',       // Softer iris edges
        blinkRate: 'slow',        // Slower, relaxed blinking
        lookDirection: 'soft_center', // Soft focus, not sharp
        eyeOpenness: 0.85         // Slightly droopy, relaxed eyes
    },

    // Movement patterns
    movement: {
        floatPattern: 'sine_slow',     // Slow sine wave floating
        floatPeriod: 6000,              // 6 second float cycle
        floatAmplitude: 8,              // 8 pixel vertical range
        swayPattern: 'gentle',          // Gentle side sway
        swayPeriod: 8000,               // 8 second sway cycle
        swayAmplitude: 5,               // 5 pixel horizontal range
        microMovements: false           // No jittery movements
    },

    /**
     * Get core rendering parameters
     * @param {Object} state - Current renderer state
     * @returns {Object} Core rendering configuration
     */
    getCoreParams: function(state) {
        const time = state.time || Date.now();
        const breathPhase = Math.sin(time * 0.0006) * 0.5 + 0.5; // Very slow breathing

        return {
            scaleX: 1.0 - (breathPhase * 0.02),  // Very subtle breathing scale
            scaleY: 1.0 - (breathPhase * 0.02),
            eyeOpenness: 0.85,                   // Relaxed eyes
            eyeExpression: 'serene',             // New serene expression
            pupilOffset: {
                x: Math.sin(time * 0.0003) * 2,  // Slow, minimal eye movement
                y: Math.cos(time * 0.0004) * 1
            },
            glowPulse: 0.95 + (breathPhase * 0.05)  // Very subtle glow pulse
        };
    },

    /**
     * Optional: Custom particle behavior for calm state
     * @param {Object} particle - Particle to update
     * @param {number} deltaTime - Time since last update
     */
    updateParticle: function(particle, deltaTime) {
        // Super slow drift
        particle.x += Math.sin(particle.life * 0.001) * 0.1;
        particle.y -= deltaTime * 0.02; // Very slow rise

        // Gentle fade based on life
        particle.opacity = Math.sin(particle.life * 0.002) * 0.3 + 0.2;

        // Slow size pulse
        particle.size = particle.baseSize * (1 + Math.sin(particle.life * 0.001) * 0.2);
    },

    /**
     * Optional: Custom core rendering
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @returns {boolean} True if custom rendering was done
     */
    renderCore: function(ctx, x, y, radius) {
        // Return false to use default rendering with parameters
        return false;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Emotion Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central emotion registry with full plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module emotions
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Central registry for modular emotion system with plugin adapter integration.
 * ║ • Core emotions are loaded synchronously at startup
 * ║ • Plugin emotions can be registered dynamically via adapter
 * ║ • Each emotion is self-contained with visual, gesture, and transition data
 * ║ • Value-agnostic design allows easy tuning without code changes
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// Registry to store all registered emotions
const emotionRegistry = new Map();

// Emotion aliases for compatibility
const emotionAliases = {
    'happy': 'joy',
    'peaceful': 'calm',
    'curious': 'surprise',
    'frustrated': 'anger',
    'sad': 'sadness'
};

// Register all emotions SYNCHRONOUSLY
[neutral, joy, sadness, anger, fear, surprise, disgust,
 love, suspicion, excited, resting$1, euphoria, focused, glitch, calm].forEach(emotion => {
    if (emotion && emotion.name) {
        emotionRegistry.set(emotion.name, emotion);
    }
});

/**
 * Get emotion configuration by name (checks both core and plugin emotions)
 * @param {string} emotionName - Name of the emotion (or alias)
 * @returns {Object|null} The emotion configuration or null if not found
 */
function getEmotion(emotionName) {
    // Check aliases first
    const resolvedName = emotionAliases[emotionName] || emotionName;

    // Check core emotions
    const coreEmotion = emotionRegistry.get(resolvedName);
    if (coreEmotion) {
        return coreEmotion;
    }

    // Check plugin emotions
    const pluginEmotion = pluginAdapter$2.getPluginEmotion(resolvedName);
    if (pluginEmotion) {
        return pluginEmotion;
    }

    return null;
}

/**
 * Get emotion parameters (visual properties) with dynamic evaluation
 * @param {string} emotionName - Name of the emotion
 * @returns {Object} Visual parameters for the emotion
 */
function getEmotionVisualParams(emotionName) {
    const emotion = getEmotion(emotionName);
    if (!emotion) {
        return getEmotion('neutral').visual;
    }

    // Make sure visual exists
    if (!emotion.visual) {
        return {};
    }
    
    // Create a copy of visual properties, excluding functions
    const visual = emotion.visual;
    const params = {};
    
    // Copy non-function properties
    for (const key in visual) {
        if (typeof visual[key] !== 'function') {
            params[key] = visual[key];
        }
    }
    
    // Evaluate dynamic functions if they exist and override static values
    if (typeof visual.getGlowIntensity === 'function') {
        params.glowIntensity = visual.getGlowIntensity.call(visual);
    }
    
    if (typeof visual.getParticleSpeed === 'function') {
        params.particleSpeed = visual.getParticleSpeed.call(visual);
    }
    
    if (typeof visual.getParticleRate === 'function') {
        params.particleRate = visual.getParticleRate.call(visual);
    }
    
    if (typeof visual.getGlowColor === 'function') {
        params.glowColor = visual.getGlowColor.call(visual);
    }
    
    return params;
}

/**
 * Get emotion modifiers (gesture adjustments)
 * @param {string} emotionName - Name of the emotion
 * @returns {Object} Gesture modifiers for the emotion
 */
function getEmotionModifiers(emotionName) {
    const emotion = getEmotion(emotionName);
    if (!emotion) {
        return getEmotion('neutral').modifiers;
    }
    return emotion.modifiers;
}

/**
 * Get list of available emotions (core and plugin)
 * @returns {Array<string>} List of emotion names
 */
function listEmotions() {
    const coreEmotions = Array.from(emotionRegistry.keys());
    const pluginEmotions = pluginAdapter$2.getAllPluginEmotions();
    return [...coreEmotions, ...pluginEmotions];
}

/**
 * Check if an emotion exists (checks both core and plugin)
 * @param {string} emotionName - Name of the emotion to check
 * @returns {boolean} True if emotion exists
 */
function hasEmotion(emotionName) {
    const resolvedName = emotionAliases[emotionName] || emotionName;
    return emotionRegistry.has(resolvedName) || pluginAdapter$2.getPluginEmotion(resolvedName) !== null;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  STATE MACHINE CORE  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Emotive State Machine - Emotional State & Transition Management
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module EmotiveStateMachine
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The BRAIN of the Emotive Engine. Manages emotional states, transitions,           
 * ║ undertones, and gesture queues. This is where emotions become behavior.           
 * ║ Works with emotionMap.js for visuals but defines the LOGIC and TIMING.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🧠 CORE RESPONSIBILITIES                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Emotional state management (current, target, transitions)                       
 * │ • Undertone layering (nervous + happy, tired + angry, etc.)                      
 * │ • Gesture queue processing (sequential animation management)                      
 * │ • Smooth property interpolation during transitions                                
 * │ • Event emission for state changes                                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚠️  CRITICAL STATE PROPERTIES                                                     
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • emotion      : Current emotional state (must be valid emotion)                  
 * │ • undertone    : Optional modifier (null or valid undertone)                      
 * │ • gesture      : Currently playing gesture animation
 * │ • transitions  : Active transition data (progress, timing, easing)
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 TRANSITION SYSTEM                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Smooth blending between emotional states                                        
 * │ • Configurable transition duration (default 500ms)                                
 * │ • Easing functions for natural motion                                             
 * │ • Property interpolation (colors, sizes, speeds)                                  
 * │ • Prevents jarring visual changes                                                 
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ DO NOT MODIFY WITHOUT UNDERSTANDING                                            
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ State validation logic    → Breaks error handling                              
 * │ ✗ Transition timing        → Causes visual glitches                              
 * │ ✗ Event emission order     → Breaks dependent systems                            
 * │ ✗ Property interpolation   → Creates animation artifacts                         
 * │ ✗ Queue processing         → Causes gesture conflicts                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                          ADDING NEW EMOTIONAL STATES                              
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ 1. Define visual properties in emotionMap.js                                      
 * ║ 2. Add state definition in initializeEmotionalStates()                            
 * ║ 3. Add validation to ErrorBoundary.js                                             
 * ║ 4. Test transitions FROM and TO the new state                                     
 * ║ 5. Verify particle behavior and performance                                       
 * ║ 6. Document any special transition rules                                          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class EmotiveStateMachine {
    constructor(errorBoundary) {
        this.errorBoundary = errorBoundary;
        
        // Current state
        this.state = {
            emotion: 'neutral',
            undertone: null,
            gesture: null,
            speaking: false,
            audioLevel: 0
        };
        
        // Transition management
        this.transitions = {
            emotional: {
                current: 'neutral',
                target: null,
                progress: 0,
                duration: 500,
                startTime: 0,
                isActive: false
            },
            undertone: {
                current: null,
                target: null,
                progress: 0,
                duration: 300,  // Faster than emotion transitions
                startTime: 0,
                isActive: false,
                currentWeight: 0,  // 0-1 weight of current undertone
                targetWeight: 0    // 0-1 weight of target undertone
            }
        };
        
        // Cache for interpolation results
        this.interpolationCache = {
            lastUpdate: 0,
            cacheInterval: 100, // Cache for 100ms
            cachedProperties: null,
            cachedRenderState: null
        };
        
        // Initialize emotional state definitions
        this.initializeEmotionalStates();
        this.initializeUndertoneModifiers();
    }

    /**
     * Initialize all 8 emotional states with their visual properties
     */
    initializeEmotionalStates() {
        this.emotionalStates = {
            neutral: {
                primaryColor: '#B0B0B0',
                glowIntensity: 0.7,
                particleRate: 1,  // DECIMATED - minimal particles
                minParticles: 3,  // Always have at least 3 particles for gestures to affect
                maxParticles: 4,  // Max 4 particles
                particleBehavior: 'ambient',
                coreSize: 1.0,
                breathRate: 1.0,
                breathDepth: 0.1
            },
            joy: {
                primaryColor: '#FFD700',
                glowIntensity: 1.2,
                particleRate: 2,           // More frequent popping
                minParticles: 3,           // Always popping
                maxParticles: 8,           // Can have many kernels popping
                particleBehavior: 'popcorn', // Spontaneous popping effect
                coreSize: 1.1,
                breathRate: 1.3,
                breathDepth: 0.15
            },
            sadness: {
                primaryColor: '#4169E1',
                glowIntensity: 0.6,
                particleRate: 2,  // Halved from 3
                minParticles: 1,  // At least 1
                maxParticles: 3,  // Max 3 particles
                particleBehavior: 'falling',
                coreSize: 0.9,
                breathRate: 0.7,
                breathDepth: 0.08
            },
            anger: {
                primaryColor: '#DC143C',
                glowIntensity: 1.3,
                particleRate: 1,  // ~30% chance per frame
                minParticles: 3,  // Always show anger
                maxParticles: 8,  // Can get intense
                particleBehavior: 'aggressive',
                coreSize: 1.2,
                breathRate: 1.5,
                breathDepth: 0.2
            },
            fear: {
                primaryColor: '#8B008B',
                glowIntensity: 0.8,
                particleRate: 1,  // chance per frame
                minParticles: 2,  // Always visible
                maxParticles: 6,  // Moderate max
                particleBehavior: 'scattering',
                coreSize: 0.8,
                breathRate: 1.8,
                breathDepth: 0.12
            },
            surprise: {
                primaryColor: '#FF8C00',
                glowIntensity: 1.4,
                particleRate: 1,
                minParticles: 3,  // Burst effect
                maxParticles: 10,  // Can burst big
                particleBehavior: 'burst',
                coreSize: 1.3,
                breathRate: 2.0,
                breathDepth: 0.25
            },
            disgust: {
                primaryColor: '#9ACD32',
                glowIntensity: 0.9,
                particleRate: 2,
                minParticles: 2,  // Always show disgust
                maxParticles: 4,  // Limited particles
                particleBehavior: 'repelling',
                coreSize: 0.95,
                breathRate: 0.8,
                breathDepth: 0.06
            },
            love: {
                primaryColor: '#FF69B4',
                glowIntensity: 1.1,
                particleRate: 1,  // Halved from 9
                minParticles: 2,  // Always orbiting
                maxParticles: 5,  // Gentle max
                particleBehavior: 'orbiting',
                coreSize: 1.05,
                breathRate: 0.9,
                breathDepth: 0.18
            },
            excited: {
                primaryColor: '#FF00FF',  // Hot magenta
                glowIntensity: 1.2,  // Bright glow for excitement
                particleRate: 360,  // Double rate for more visible particles
                minParticles: 480,  // Double particles for denser effect
                maxParticles: 900,  // Double max particles
                particleBehavior: 'fizzy',
                coreSize: 0.85,  // Slightly smaller than neutral
                breathRate: 1.5,  // Excited breathing
                breathDepth: 0.08,  // Moderate breath
                eyeOpenness: 1.0  // Wide eyes
            },
            resting: {
                primaryColor: '#7C3AED',   // Soft purple for resting
                glowIntensity: 0.8,
                particleRate: 2,          // Moderate particles for visible effect
                minParticles: 3,  // Always 3-5 visible
                maxParticles: 5,  // Calm max
                particleBehavior: 'resting',
                coreSize: 1.0,
                breathRate: 0.8,           // 12-16 breaths per minute (resting human)
                breathDepth: 0.12          // Gentle, relaxed breathing
            },
            euphoria: {
                primaryColor: '#FFD700',   // Golden sunrise
                glowIntensity: 1.8,        // Radiant warm glow
                particleRate: 3,           // Abundant like sunbeams
                minParticles: 15,          // Always sparkling
                maxParticles: 30,          // Maximum celebration
                particleBehavior: 'radiant', // Radiating outward
                coreSize: 1.15,            // Expanded with joy
                breathRate: 1.3,           // Energized breathing
                breathDepth: 0.25,         // Deep refreshing breaths
            },
            focused: {
                primaryColor: '#00CED1',  // Bright cyan
                glowIntensity: 1.2,
                particleRate: 0.5,  // Frequent, like synapses
                minParticles: 2,
                maxParticles: 5,
                particleBehavior: 'directed',  // Fast, straight paths
                coreSize: 1.05,
                breathRate: 1.2,  // Alert breathing
                breathDepth: 0.08,
                eyeOpenness: 0.7,  // Narrowed for concentration
                microAdjustments: true  // Enable tiny shifts
            },
            suspicion: {
                primaryColor: '#708090',  // Slate gray
                glowIntensity: 0.9,
                particleRate: 20,  // Higher rate for continuous particles
                minParticles: 8,
                maxParticles: 15,  // More particles for better visibility
                particleBehavior: 'burst',  // Use burst like surprise but we'll modify it
                coreSize: 1.0,
                breathRate: 0.8,  // Controlled breathing
                breathDepth: 0.05,  // Shallow, alert breathing
                eyeOpenness: 0.5,  // Narrowed, skeptical eyes
                eyeArc: -0.2  // Slight frown
            }
        };
    }

    /**
     * Initialize undertone modifiers that affect base emotional properties
     */
    initializeUndertoneModifiers() {
        this.undertoneModifiers = {
            nervous: {
                jitterAmount: 0.3,
                breathRateMultiplier: 1.2,
                glowIntensityMultiplier: 0.9,
                particleRateMultiplier: 1.1
            },
            confident: {
                coreSizeMultiplier: 1.1,
                glowIntensityMultiplier: 1.2,
                breathRateMultiplier: 0.9,
                particleRateMultiplier: 1.0
            },
            tired: {
                breathRateMultiplier: 0.7,
                particleRateMultiplier: 0.5,
                glowIntensityMultiplier: 0.8,
                coreSizeMultiplier: 0.95
            },
            intense: {
                amplificationFactor: 1.3
            },
            subdued: {
                dampeningFactor: 0.7
            }
        };
    }

    /**
     * Sets the emotional state with optional undertone
     * @param {string} emotion - The emotion to set
     * @param {string|null} undertone - Optional undertone modifier
     * @param {number} duration - Transition duration in milliseconds
     * @returns {boolean} Success status
     */
    setEmotion(emotion, undertone = null, duration = 500) {
        return this.errorBoundary.wrap(() => {
            // Clear interpolation cache when emotion changes
            this.interpolationCache.cachedProperties = null;
            this.interpolationCache.cachedRenderState = null;
            
            // Validate emotion using modular system
            if (!hasEmotion(emotion) && !this.emotionalStates.hasOwnProperty(emotion)) {
                const validEmotions = [...Object.keys(this.emotionalStates), ...listEmotions()];
                const uniqueEmotions = [...new Set(validEmotions)];
                throw new Error(`Invalid emotion: ${emotion}. Valid emotions: ${uniqueEmotions.join(', ')}`);
            }

            // Validate undertone
            if (undertone !== null && !this.undertoneModifiers.hasOwnProperty(undertone)) {
                throw new Error(`Invalid undertone: ${undertone}. Valid undertones: ${Object.keys(this.undertoneModifiers).join(', ')}`);
            }

            // If already in this state, just update undertone
            if (this.state.emotion === emotion && this.state.undertone === undertone) {
                return true;
            }

            // Set up emotion transition if emotion is changing
            if (this.state.emotion !== emotion) {
                if (duration > 0) {
                    this.transitions.emotional = {
                        current: this.state.emotion,
                        target: emotion,
                        progress: 0,
                        duration: Math.max(100, duration),
                        startTime: performance.now(),
                        isActive: true
                    };
                    
                    // Reset simulated time for testing
                    if (this._simulatedTime !== undefined) {
                        this._simulatedTime = 0;
                    }
                } else {
                    // Immediate transition
                    this.transitions.emotional = {
                        current: emotion,
                        target: null,
                        progress: 1,
                        duration: 0,
                        startTime: performance.now(),
                        isActive: false
                    };
                }
                this.state.emotion = emotion;
            }
            
            // Set up undertone transition if undertone is changing
            if (this.state.undertone !== undertone) {
                this.transitions.undertone = {
                    current: this.state.undertone,
                    target: undertone,
                    progress: 0,
                    duration: 300,  // Always smooth undertone transitions
                    startTime: performance.now(),
                    isActive: true,
                    currentWeight: this.state.undertone ? 1 : 0,
                    targetWeight: undertone ? 1 : 0
                };
                this.state.undertone = undertone;
            }

            return true;
        }, 'emotion-setting', false)();
    }

    /**
     * Applies undertone modifiers to base emotional properties
     * @param {Object} baseProperties - Base emotional properties
     * @param {string|null} undertone - Undertone to apply
     * @returns {Object} Modified properties
     */
    applyUndertone(baseProperties, undertone) {
        if (!undertone || !this.undertoneModifiers.hasOwnProperty(undertone)) {
            return { ...baseProperties };
        }

        const modifier = this.undertoneModifiers[undertone];
        const modified = { ...baseProperties };

        // Apply specific modifiers
        if (modifier.glowIntensityMultiplier !== undefined) {
            modified.glowIntensity *= modifier.glowIntensityMultiplier;
        }
        if (modifier.breathRateMultiplier !== undefined) {
            modified.breathRate *= modifier.breathRateMultiplier;
        }
        if (modifier.particleRateMultiplier !== undefined) {
            modified.particleRate = Math.round(modified.particleRate * modifier.particleRateMultiplier);
        }
        if (modifier.coreSizeMultiplier !== undefined) {
            modified.coreSize *= modifier.coreSizeMultiplier;
        }

        // Apply amplification/dampening factors
        if (modifier.amplificationFactor !== undefined) {
            const factor = modifier.amplificationFactor;
            modified.glowIntensity *= factor;
            modified.breathRate *= factor;
            modified.particleRate = Math.round(modified.particleRate * factor);
            modified.coreSize *= factor;
        }
        if (modifier.dampeningFactor !== undefined) {
            const factor = modifier.dampeningFactor;
            modified.glowIntensity *= factor;
            modified.breathRate *= factor;
            modified.particleRate = Math.round(modified.particleRate * factor);
            modified.coreSize *= factor;
        }

        // Add special properties
        if (modifier.jitterAmount !== undefined) {
            modified.jitterAmount = modifier.jitterAmount;
        }

        return modified;
    }

    /**
     * Updates the state machine with delta time
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        this.errorBoundary.wrap(() => {
            // Update emotional transition
            if (this.transitions.emotional.isActive) {
                this.updateEmotionalTransition(deltaTime);
            }
            
            // Update undertone transition
            if (this.transitions.undertone.isActive) {
                this.updateUndertoneTransition(deltaTime);
            }
        }, 'state-machine-update')();
    }

    /**
     * Updates undertone transition progress
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateUndertoneTransition(deltaTime) {
        const transition = this.transitions.undertone;
        
        // Calculate elapsed time
        const elapsed = performance.now() - transition.startTime;
        const progress = Math.min(elapsed / transition.duration, 1);
        
        // Apply easing
        const easedProgress = easeInOutCubic(progress);
        
        // Update weights for smooth transition
        if (transition.current && transition.target) {
            // Transitioning between two undertones
            transition.currentWeight = 1 - easedProgress;
            transition.targetWeight = easedProgress;
        } else if (transition.current && !transition.target) {
            // Fading out current undertone
            transition.currentWeight = 1 - easedProgress;
            transition.targetWeight = 0;
        } else if (!transition.current && transition.target) {
            // Fading in new undertone
            transition.currentWeight = 0;
            transition.targetWeight = easedProgress;
        }
        
        transition.progress = progress;
        
        // Complete transition
        if (progress >= 1) {
            transition.isActive = false;
            transition.current = transition.target;
            transition.currentWeight = transition.target ? 1 : 0;
            transition.targetWeight = 0;
        }
    }
    
    /**
     * Updates emotional state transition progress
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateEmotionalTransition(deltaTime) {
        const transition = this.transitions.emotional;
        
        // Use either real elapsed time or simulated deltaTime for testing
        let elapsed;
        if (this._simulatedTime !== undefined) {
            // For testing - use accumulated simulated time
            this._simulatedTime += deltaTime;
            elapsed = this._simulatedTime;
        } else {
            // For real usage - use actual elapsed time
            elapsed = performance.now() - transition.startTime;
        }
        
        // Calculate progress (0 to 1)
        transition.progress = Math.min(1, elapsed / transition.duration);
        
        // Check if transition is complete
        if (transition.progress >= 1) {
            transition.isActive = false;
            transition.current = transition.target;
            transition.target = null;
            transition.progress = 1;
        }
    }

    /**
     * Gets the current interpolated emotional properties
     * @returns {Object} Current emotional properties with smooth transitions
     */
    getCurrentEmotionalProperties() {
        return this.errorBoundary.wrap(() => {
            const now = performance.now();
            
            // Use cached result if still valid
            if (this.interpolationCache.cachedProperties && 
                (now - this.interpolationCache.lastUpdate) < this.interpolationCache.cacheInterval) {
                return this.interpolationCache.cachedProperties;
            }
            
            const transition = this.transitions.emotional;
            let properties;

            if (transition.isActive && transition.target) {
                // Interpolate between current and target states
                properties = this.interpolateEmotionalProperties(
                    transition.current,
                    transition.target,
                    transition.progress
                );
            } else {
                // Use current state properties - fallback to neutral if emotion not found
                const emotionState = this.emotionalStates[this.state.emotion] || this.emotionalStates.neutral;
                properties = { ...emotionState };
            }

            // Apply undertone modifiers
            properties = this.applyUndertone(properties, this.state.undertone);
            
            // Cache the result
            this.interpolationCache.cachedProperties = properties;
            this.interpolationCache.lastUpdate = now;

            return properties;
        }, 'emotional-properties', () => this.emotionalStates.neutral)();
    }

    /**
     * Interpolates between two emotional states
     * @param {string} fromEmotion - Source emotion
     * @param {string} toEmotion - Target emotion
     * @param {number} progress - Interpolation progress (0-1)
     * @returns {Object} Interpolated properties
     */
    interpolateEmotionalProperties(fromEmotion, toEmotion, progress) {
        const fromProps = this.emotionalStates[fromEmotion] || this.emotionalStates.neutral;
        const toProps = this.emotionalStates[toEmotion] || this.emotionalStates.neutral;
        
        // Apply easing to progress
        const easedProgress = applyEasing(progress, 0, 1, 'easeOutCubic');

        return {
            // Interpolate color in HSL space for better transitions
            primaryColor: interpolateHsl(fromProps.primaryColor, toProps.primaryColor, easedProgress),
            
            // Interpolate numeric properties
            glowIntensity: fromProps.glowIntensity + (toProps.glowIntensity - fromProps.glowIntensity) * easedProgress,
            particleRate: Math.round(fromProps.particleRate + (toProps.particleRate - fromProps.particleRate) * easedProgress),
            coreSize: fromProps.coreSize + (toProps.coreSize - fromProps.coreSize) * easedProgress,
            breathRate: fromProps.breathRate + (toProps.breathRate - fromProps.breathRate) * easedProgress,
            breathDepth: fromProps.breathDepth + (toProps.breathDepth - fromProps.breathDepth) * easedProgress,
            
            // Use target behavior when transition is more than 50% complete
            particleBehavior: easedProgress > 0.5 ? toProps.particleBehavior : fromProps.particleBehavior
        };
    }

    /**
     * Gets the current state for external inspection
     * @returns {Object} Current state information
     */
    getCurrentState() {
        return {
            emotion: this.state.emotion,
            undertone: this.state.undertone,
            isTransitioning: this.transitions.emotional.isActive,
            transitionProgress: this.transitions.emotional.progress,
            properties: this.getCurrentEmotionalProperties()
        };
    }

    /**
     * Applies an undertone to the current emotional state
     * @param {string|null} undertone - Undertone to apply
     * @returns {boolean} Success status
     */
    applyUndertoneModifier(undertone) {
        return this.errorBoundary.wrap(() => {
            // Validate undertone
            if (undertone !== null && !this.undertoneModifiers.hasOwnProperty(undertone)) {
                throw new Error(`Invalid undertone: ${undertone}. Valid undertones: ${Object.keys(this.undertoneModifiers).join(', ')}`);
            }

            // Apply the undertone
            this.state.undertone = undertone;
            
            return true;
        }, 'undertone-application', false)();
    }

    /**
     * Clears the current undertone and resets to base emotional state
     */
    clearUndertone() {
        this.state.undertone = null;
    }

    /**
     * Gets the raw undertone modifier data for a specific undertone
     * @param {string} undertone - Undertone name
     * @returns {Object|null} Undertone modifier data or null if invalid
     */
    getUndertoneModifier(undertone) {
        return this.errorBoundary.wrap(() => {
            // Try to get from renderer first (comprehensive modifiers)
            if (this.renderer && this.renderer.undertoneModifiers && 
                this.renderer.undertoneModifiers[undertone]) {
                // Return the full modifier from renderer
                return { ...this.renderer.undertoneModifiers[undertone] };
            }
            
            // Fallback to local modifiers
            if (!undertone || !this.undertoneModifiers.hasOwnProperty(undertone)) {
                return null;
            }
            // Ensure essential properties exist in fallback
            const localMod = { ...this.undertoneModifiers[undertone] };
            if (!localMod.glowRadiusMult) {
                localMod.glowRadiusMult = 1.0; // Default value
            }
            return localMod;
        }, 'undertone-retrieval', null)();
    }
    
    /**
     * Gets weighted undertone modifiers based on current transition state
     * @returns {Object|null} Combined undertone modifiers with transition weights applied
     */
    getWeightedUndertoneModifiers() {
        const transition = this.transitions.undertone;
        
        // If no transition is active, return current undertone modifiers directly
        if (!transition.isActive) {
            if (this.state.undertone) {
                const mod = this.getUndertoneModifier(this.state.undertone);
                if (mod) {
                    // Return full modifier with weight of 1.0 (fully applied) and type
                    return { ...mod, weight: 1.0, type: this.state.undertone };
                }
            }
            return null;
        }
        
        // During transition, return the target modifier with interpolated weight
        if (transition.target) {
            const targetMod = this.getUndertoneModifier(transition.target);
            if (targetMod) {
                // Return target modifier with transition weight and type
                return { ...targetMod, weight: transition.targetWeight, type: transition.target };
            }
        }
        
        // Fading out - return current modifier with decreasing weight  
        if (transition.current && transition.currentWeight > 0) {
            const currentMod = this.getUndertoneModifier(transition.current);
            if (currentMod) {
                return { ...currentMod, weight: transition.currentWeight, type: transition.current };
            }
        }
        
        return null;
    }

    /**
     * Resets the state machine to neutral emotion
     * @param {number} duration - Transition duration in milliseconds
     */
    reset(duration = 500) {
        this.setEmotion('neutral', null, duration);
    }

    /**
     * Validates if an emotion is valid
     * @param {string} emotion - Emotion to validate
     * @returns {boolean} True if valid
     */
    isValidEmotion(emotion) {
        return this.emotionalStates.hasOwnProperty(emotion);
    }

    /**
     * Validates if an undertone is valid
     * @param {string} undertone - Undertone to validate
     * @returns {boolean} True if valid
     */
    isValidUndertone(undertone) {
        return undertone === null || this.undertoneModifiers.hasOwnProperty(undertone);
    }

    /**
     * Gets all available emotions
     * @returns {Array} Array of emotion names
     */
    getAvailableEmotions() {
        return Object.keys(this.emotionalStates);
    }

    /**
     * Gets all available undertones
     * @returns {Array} Array of undertone names
     */
    getAvailableUndertones() {
        return Object.keys(this.undertoneModifiers);
    }

    /**
     * Checks if a transition is currently active
     * @returns {boolean} True if transitioning
     */
    isTransitioning() {
        return this.transitions.emotional.isActive;
    }

    /**
     * Gets the current transition progress
     * @returns {number} Progress from 0 to 1, or 1 if not transitioning
     */
    getTransitionProgress() {
        return this.transitions.emotional.isActive ? this.transitions.emotional.progress : 1;
    }

    /**
     * Forces completion of current transition
     */
    completeTransition() {
        if (this.transitions.emotional.isActive) {
            this.transitions.emotional.progress = 1;
            this.transitions.emotional.isActive = false;
            this.transitions.emotional.current = this.transitions.emotional.target;
            this.transitions.emotional.target = null;
        }
    }

    /**
     * Gets interpolated property value with easing
     * @param {number} from - Start value
     * @param {number} to - End value  
     * @param {number} progress - Progress (0-1)
     * @param {string} easingType - Easing function name
     * @returns {number} Interpolated value
     */
    interpolateProperty(from, to, progress, easingType = 'easeOutCubic') {
        return from + (to - from) * applyEasing(progress, 0, 1, easingType);
    }

    /**
     * Enables simulated time for testing purposes
     * @param {boolean} enabled - Whether to use simulated time
     */
    enableSimulatedTime(enabled = true) {
        if (enabled) {
            this._simulatedTime = 0;
        } else {
            delete this._simulatedTime;
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Color Utilities
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Color selection and manipulation utilities for particles
 * @author Emotive Engine Team
 * @module particles/utils/colorUtils
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Handles weighted color selection for particles. Each emotion has a palette of     
 * ║ colors with different weights (probabilities). This creates visual variety        
 * ║ while maintaining the emotional theme.                                            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Select a color from an array with optional weights
 * 
 * EXAMPLE INPUT:
 * [
 *   { color: '#FF69B4', weight: 30 },  // 30% chance
 *   { color: '#FFB6C1', weight: 25 },  // 25% chance
 *   { color: '#FF1493', weight: 20 },  // 20% chance
 *   '#FFC0CB',                          // Remaining weight split evenly
 *   '#C71585'                           // between unweighted colors
 * ]
 * 
 * @param {Array} colors - Array of color strings or {color, weight} objects
 * @returns {string} Selected hex color
 */
function selectWeightedColor(colors) {
    if (!colors || colors.length === 0) return '#FFFFFF';
    
    // Parse colors and weights
    let totalExplicitWeight = 0;
    let unweightedCount = 0;
    const parsedColors = [];
    
    for (const item of colors) {
        if (typeof item === 'string') {
            // Simple string color - will get default weight
            parsedColors.push({ color: item, weight: null });
            unweightedCount++;
        } else if (item && typeof item === 'object' && item.color) {
            // Object with color and optional weight
            parsedColors.push({ color: item.color, weight: item.weight || null });
            if (item.weight) {
                totalExplicitWeight += item.weight;
            } else {
                unweightedCount++;
            }
        }
    }
    
    // Calculate weight for unweighted colors
    // If weights total 75, and there are 2 unweighted colors, each gets 12.5
    const remainingWeight = Math.max(0, 100 - totalExplicitWeight);
    const defaultWeight = unweightedCount > 0 ? remainingWeight / unweightedCount : 0;
    
    // Build cumulative probability table for efficient selection
    const probTable = [];
    let cumulative = 0;
    
    for (const item of parsedColors) {
        const weight = item.weight !== null ? item.weight : defaultWeight;
        cumulative += weight;
        probTable.push({ color: item.color, threshold: cumulative });
    }
    
    // Select based on random value
    const random = Math.random() * cumulative;
    for (const entry of probTable) {
        if (random <= entry.threshold) {
            return entry.color;
        }
    }
    
    // Fallback to last color (shouldn't happen but safety first)
    return parsedColors[parsedColors.length - 1].color;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Ambient Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Gentle upward drift behavior for neutral emotional state
 * @author Emotive Engine Team
 * @module particles/behaviors/ambient
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a calm, peaceful atmosphere with particles gently drifting upward         
 * ║ like smoke or steam. This is the default behavior for neutral emotional states.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑  ↑  ↑
 *       ·  ·  ·    ← particles drift straight up
 *      ·  ·  ·  
 *     ·  ⭐  ·     ← orb center
 *      ·  ·  ·
 *       ·  ·  ·
 * 
 * USED BY EMOTIONS:
 * - neutral (default calm state)
 * 
 * RECIPE TO MODIFY:
 * - Increase upwardSpeed for faster rising (more energy)
 * - Decrease friction for longer-lasting momentum
 * - Add waviness for side-to-side motion (currently disabled)
 */


/**
 * Initialize ambient behavior for a particle
 * Sets up initial velocities and behavior-specific data
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAmbient(particle) {
    // Start with gentle upward movement
    particle.vx = 0;  // NO horizontal drift
    particle.vy = -0.04 - Math.random() * 0.02;  // Slower upward movement
    particle.lifeDecay = 0.002;  // Even slower fade - particles last ~8 seconds
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Languid upward drift
        upwardSpeed: 0.0005,      // Very slow continuous upward drift
        waviness: 0,              // NO side-to-side (set to 0.5-2 for wave motion)
        friction: 0.998           // Even more gradual slowdown
    };
}

/**
 * Update ambient behavior each frame
 * Applies gentle upward drift with air resistance
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused but kept for consistency)
 * @param {number} centerY - Orb center Y (unused but kept for consistency)
 */
function updateAmbient(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Apply friction to y velocity only (frame-rate independent)
    // Use exponential decay: friction^dt where dt is normalized to 60fps
    particle.vy *= Math.pow(data.friction, dt);
    
    // Add continuous upward drift
    particle.vy -= data.upwardSpeed * dt;
    
    // NO horizontal movement or waviness (zen-like straight up)
    particle.vx = 0;
}

// Export behavior definition for registry
var ambient = {
    name: 'ambient',
    emoji: '☁️',
    description: 'Gentle upward drift like smoke',
    initialize: initializeAmbient,
    update: updateAmbient
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle Physics Configuration
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Physics constants for particle behavior
 * @author Emotive Engine Team
 * @module particles/config/physics
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Core physics values that control how particles move and interact with the world.  
 * ║ Modify these with caution as they affect all particle behaviors globally.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ PHYSICS CONSTANTS - Core physics values (modify with caution)
// └─────────────────────────────────────────────────────────────────────────────────────
const PHYSICS = {
    // Math constants
    TWO_PI: Math.PI * 2};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbiting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Romantic orbiting behavior for love emotional state
 * @author Emotive Engine Team
 * @module particles/behaviors/orbiting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a romantic atmosphere with particles orbiting the orb like fireflies      
 * ║ dancing at a valentine's day party. Features individual blinking and sparkles.    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ✨     ✨
 *      💕  ╭───╮  💕    ← particles orbit & sparkle
 *    ✨   │  ⭐  │   ✨   ← orb center
 *      💕  ╰───╯  💕
 *        ✨     ✨
 * 
 * USED BY EMOTIONS:
 * - love (romantic valentine vibes)
 * 
 * RECIPE TO MODIFY:
 * - Increase angularVelocity for faster spinning
 * - Increase floatAmount for more vertical movement
 * - Adjust blinkSpeed for different firefly effects
 * - Increase baseRadius for wider orbits
 */


/**
 * Initialize orbiting behavior for a particle
 * Creates valentine fireflies with individual timing
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeOrbiting(particle) {
    // Individual fade timing - each particle has its own lifespan
    particle.lifeDecay = 0.001 + Math.random() * 0.002;  // Variable decay (0.001-0.003)
    
    // Use emotion colors if provided - glittery valentine palette
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    // Check if this is a lighter/sparkle color (light pinks)
    particle.isSparkle = particle.color === '#FFE4E1' || 
                        particle.color === '#FFCCCB' || 
                        particle.color === '#FFC0CB';
    
    // Particles orbit at various distances for depth
    const orbRadius = (particle.scaleFactor || 1) * 40; // Approximate orb size
    const depthLayer = Math.random();
    const baseRadius = orbRadius * (1.3 + depthLayer * 0.9); // 1.3x to 2.2x orb radius
    
    // Glitter firefly properties - each with unique timing
    particle.blinkPhase = Math.random() * PHYSICS.TWO_PI; // Random starting phase
    particle.blinkSpeed = 0.3 + Math.random() * 1.2; // Varied blink speeds (0.3-1.5)
    particle.blinkIntensity = 0.6 + Math.random() * 0.4; // How bright the blink gets
    
    // Individual fade properties
    particle.fadePhase = Math.random() * PHYSICS.TWO_PI; // Random fade starting phase
    particle.fadeSpeed = 0.1 + Math.random() * 0.3; // Different fade speeds
    particle.minOpacity = 0.2 + Math.random() * 0.2; // Min brightness varies (0.2-0.4)
    particle.maxOpacity = 0.8 + Math.random() * 0.2; // Max brightness varies (0.8-1.0)
    
    // Sparkles have different properties
    if (particle.isSparkle) {
        particle.blinkSpeed *= 2; // Sparkles blink faster
        particle.blinkIntensity = 1.0; // Full intensity sparkles
        particle.minOpacity = 0; // Can fade to nothing
        particle.maxOpacity = 1.0; // Can be fully bright
    }
    
    particle.behaviorData = {
        angle: Math.random() * PHYSICS.TWO_PI,
        radius: baseRadius,
        baseRadius: baseRadius,
        angularVelocity: 0.0008 + Math.random() * 0.0017,  // Varied rotation speeds
        swayAmount: 3 + Math.random() * 7,  // Gentle floating sway
        swaySpeed: 0.2 + Math.random() * 0.5,  // Varied sway rhythm
        floatOffset: Math.random() * PHYSICS.TWO_PI,  // Random vertical float phase
        floatSpeed: 0.3 + Math.random() * 0.7,  // Varied vertical floating speed
        floatAmount: 2 + Math.random() * 6,  // How much they float up/down
        twinklePhase: Math.random() * PHYSICS.TWO_PI,  // Individual twinkle timing
        twinkleSpeed: 2 + Math.random() * 3  // Fast twinkle for glitter effect
    };
}

/**
 * Update orbiting behavior each frame
 * Creates romantic firefly dance with sparkles
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updateOrbiting(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;

    // Slow romantic rotation around the orb
    data.angle += data.angularVelocity * dt;

    // Gentle swaying motion
    const swayOffset = Math.sin(data.angle * data.swaySpeed) * data.swayAmount;

    // Radius changes for breathing effect
    const radiusPulse = Math.sin(data.angle * 1.5) * 6;

    // Use data.radius if it exists (can be modified by gestures), otherwise use baseRadius
    const currentRadius = (data.radius || data.baseRadius) + radiusPulse + swayOffset * 0.2;

    // Calculate desired orbital position
    const targetX = centerX + Math.cos(data.angle) * currentRadius;
    const targetY = centerY + Math.sin(data.angle) * currentRadius;

    // Add gentle vertical floating (like fireflies)
    data.floatOffset += data.floatSpeed * dt * 0.001;
    const verticalFloat = Math.sin(data.floatOffset) * data.floatAmount;

    // Smoothly move towards target position instead of directly setting it
    // This allows gestures to temporarily offset particles
    const smoothingFactor = 0.1; // How quickly particles return to orbit
    particle.vx = (targetX - particle.x) * smoothingFactor;
    particle.vy = (targetY + verticalFloat - particle.y) * smoothingFactor;
    
    // Update individual fade phase
    particle.fadePhase += particle.fadeSpeed * dt * 0.001;
    
    // Calculate individual particle fade (independent timing)
    const fadeValue = Math.sin(particle.fadePhase) * 0.5 + 0.5; // 0 to 1
    const fadeOpacity = particle.minOpacity + (particle.maxOpacity - particle.minOpacity) * fadeValue;
    
    // Firefly blinking effect
    particle.blinkPhase += particle.blinkSpeed * dt * 0.002;
    
    // Create a complex glitter blink with multiple harmonics
    let blinkValue;
    if (particle.isSparkle) {
        // Sparkles have sharp, dramatic twinkles
        data.twinklePhase += data.twinkleSpeed * dt * 0.001;
        const twinkle = Math.pow(Math.sin(data.twinklePhase), 16); // Sharp peaks
        const shimmer = Math.sin(particle.blinkPhase * 5) * 0.2;
        blinkValue = twinkle * 0.7 + shimmer + 0.1;
    } else {
        // Regular particles have smoother, firefly-like pulses
        blinkValue = Math.sin(particle.blinkPhase) * 0.4 + 
                    Math.sin(particle.blinkPhase * 3) * 0.3 +
                    Math.sin(particle.blinkPhase * 7) * 0.2 +
                    Math.sin(particle.blinkPhase * 11) * 0.1; // Added harmonic
    }
    
    // Map to 0-1 range with intensity control
    const normalizedBlink = (blinkValue + 1) * 0.5; // Convert from -1,1 to 0,1
    const blink = 0.2 + normalizedBlink * particle.blinkIntensity * 0.8;
    
    // Combine individual fade with blink effect
    particle.opacity = particle.baseOpacity * fadeOpacity * blink;
    
    // Sparkles pulse size more dramatically
    if (particle.isSparkle) {
        particle.size = particle.baseSize * (0.5 + normalizedBlink * 1.0); // 50-150% size
    } else {
        particle.size = particle.baseSize * (0.8 + normalizedBlink * 0.3); // 80-110% size
    }
    
    // Add subtle color shift for sparkles (shimmer effect)
    if (particle.isSparkle) {
        // Light pink sparkles can shift to white at peak brightness
        if (normalizedBlink > 0.85) {
            particle.tempColor = '#FFFFFF'; // Flash white at peak for extra sparkle
        } else {
            particle.tempColor = particle.color;
        }
    }
}

// Export behavior definition for registry
var orbiting = {
    name: 'orbiting',
    emoji: '💕',
    description: 'Romantic firefly dance around the orb',
    initialize: initializeOrbiting,
    update: updateOrbiting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rising Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Buoyant upward movement for joyful states
 * @author Emotive Engine Team
 * @module particles/behaviors/rising
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a buoyant, uplifting atmosphere with particles rising like bubbles        
 * ║ or balloons. Slight horizontal drift adds organic movement.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      ↗  ↑  ↖
 *     ·  ·  ·    ← particles rise with drift
 *    ·  ·  ·  
 *   ·  ⭐  ·     ← orb center
 *    ·  ·  ·
 *     ·  ·  ·
 * 
 * USED BY EMOTIONS:
 * - joy (subtle happiness)
 * - optimism
 * 
 * RECIPE TO MODIFY:
 * - Increase buoyancy for faster rising (like helium balloons)
 * - Increase driftAmount for more side-to-side movement
 * - Decrease air resistance for longer-lasting momentum
 */


/**
 * Initialize rising behavior for a particle
 * Sets up buoyant upward movement with gentle drift
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRising(particle) {
    particle.vx = (Math.random() - 0.5) * 0.02;  // Even slower horizontal drift
    particle.vy = -0.05 - Math.random() * 0.03;   // Much slower upward movement
    particle.lifeDecay = 0.002;                   // Very slow decay
    particle.baseOpacity = 0.7 + Math.random() * 0.3;  // More opaque (70-100%)
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        buoyancy: 0.001,      // Even gentler upward force
        driftAmount: 0.005    // Minimal drift
    };
}

/**
 * Update rising behavior each frame
 * Applies buoyancy and gentle drift
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateRising(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Add buoyancy (upward force)
    particle.vy -= data.buoyancy * dt;
    
    // Add horizontal drift
    particle.vx += (Math.random() - 0.5) * data.driftAmount * dt;
    
    // Apply air resistance (frame-independent)
    particle.vx *= Math.pow(0.995, dt);
    particle.vy *= Math.pow(0.998, dt);
}

// Export behavior definition for registry
var rising = {
    name: 'rising',
    emoji: '🎈',
    description: 'Buoyant upward movement like balloons',
    initialize: initializeRising,
    update: updateRising
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Falling Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Heavy downward drift for sad emotional states
 * @author Emotive Engine Team
 * @module particles/behaviors/falling
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a melancholic atmosphere with particles slowly falling like tears         
 * ║ or autumn leaves. Heavy, weighted movement conveys sadness.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     ·  ·  ·
 *    ·  ·  ·  
 *   ·  ⭐  ·     ← orb center
 *    ·  ·  ·
 *     ·  ·  ·    ← particles fall slowly
 *      ↓  ↓  ↓
 * 
 * USED BY EMOTIONS:
 * - sadness (melancholy, grief)
 * - disappointment
 * - tired
 * 
 * RECIPE TO MODIFY:
 * - Increase gravity for heavier falling (more weight)
 * - Decrease drag for faster falling (less air resistance)
 * - Add horizontal drift for leaf-like falling
 */


/**
 * Initialize falling behavior for a particle
 * Sets up slow, heavy downward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeFalling(particle) {
    particle.vx = (Math.random() - 0.5) * 0.03;   // MUCH slower horizontal drift
    particle.vy = 0.05 + Math.random() * 0.05;    // MUCH slower falling
    particle.lifeDecay = 0.002;                   // Very slow decay
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        gravity: 0.002,       // Very gentle gravity
        drag: 0.995           // High drag for slow fall
    };
}

/**
 * Update falling behavior each frame
 * Applies gravity with air resistance
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateFalling(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Apply gravity
    particle.vy += data.gravity * dt;
    
    // Apply drag (frame-independent)
    particle.vx *= Math.pow(data.drag, dt);
    particle.vy *= Math.pow(data.drag, dt);
    
    // Limit terminal velocity
    if (particle.vy > 2) {
        particle.vy = 2;
    }
}

// Export behavior definition for registry
var falling = {
    name: 'falling',
    emoji: '💧',
    description: 'Heavy downward drift like tears',
    initialize: initializeFalling,
    update: updateFalling
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Playground Configuration 🎮
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Safe values for experimentation and tweaking
 * @author Emotive Engine Team
 * @module particles/config/playground
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                            🎮 PLAYGROUND VALUES                                   
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ SAFE TO MODIFY! These values are designed for experimentation.                    
 * ║ Change them to create new visual effects and behaviors.                           
 * ║                                                                                    
 * ║ TIP: After changing values, refresh your browser to see the effects!              
 * ║ TIP: Set window.DEBUG_PARTICLES = true in console to visualize changes            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

const PLAYGROUND = {
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ POPCORN BEHAVIOR - Joy particles that pop!
    // └─────────────────────────────────────────────────────────────────────────────────
    popcorn: {
        POP_DELAY_MAX: 2000,   // 🎯 Slowest pop (ms) - Try: 1000-5000
        POP_FORCE_MIN: 3,      // 🎯 Weakest pop - Try: 1-5
        POP_FORCE_MAX: 8,      // 🎯 Strongest pop - Try: 5-15
        BOUNCE_HEIGHT: 0.7     // 🎯 Bounce energy retained - Try: 0.3-0.9
    }};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Popcorn Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Spontaneous popping with bounces for joyful celebration
 * @author Emotive Engine Team
 * @module particles/behaviors/popcorn
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a celebratory atmosphere with particles that wait, then POP! and bounce   
 * ║ around with gravity. Perfect for pure joy and celebration moments.                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Stage 1: Wait      Stage 2: POP!       Stage 3: Bounce
 *         ·                  💥 ↗             ↘ 
 *        ···                ↖ 💥 ↗              ↓
 *       ·⭐·                  💥                 🎊 ← bounce!
 *        ···                ↙ 💥 ↘              ↑
 *         ·                  💥 ↓               ↗
 * 
 * USED BY EMOTIONS:
 * - joy (celebration, happiness, excitement)
 * 
 * RECIPE TO MODIFY:
 * - Decrease popDelay for faster popping (more energetic)
 * - Increase popStrength for bigger pops
 * - Adjust gravity for different bounce physics
 * - Increase maxBounces for longer bouncing
 */


/**
 * Initialize popcorn behavior for a particle
 * Sets up kernel waiting to pop
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializePopcorn(particle) {
    // Start with little to no movement (kernel waiting to pop)
    particle.vx = (Math.random() - 0.5) * 0.1;
    particle.vy = (Math.random() - 0.5) * 0.1;
    // Faster, more varied decay for dynamic disappearing
    particle.lifeDecay = 0.008 + Math.random() * 0.012; // Random between 0.008-0.020
    
    // Use emotion colors if provided, otherwise default popcorn colors
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    } else {
        // Default popcorn colors (buttery whites and yellows)
        const colors = ['#FFFFFF', '#FFFACD', '#FFF8DC', '#FFFFE0', '#FAFAD2'];
        particle.color = selectWeightedColor(colors);
    }
    
    // Vary sizes more dramatically - some big fluffy pieces, some small
    particle.size = (Math.random() < 0.3) ? 
        (8 + Math.random() * 4) * particle.scaleFactor * particle.particleSizeMultiplier : // 30% big
        (2 + Math.random() * 4) * particle.scaleFactor * particle.particleSizeMultiplier;  // 70% small
    particle.baseSize = particle.size;
    
    // Less glow, more solid popcorn look
    particle.hasGlow = Math.random() < 0.2; // Only 20% have glow
    particle.glowSizeMultiplier = particle.hasGlow ? 1.2 : 0;
    
    particle.behaviorData = {
        // Popcorn popping mechanics
        popDelay: Math.random() * PLAYGROUND.popcorn.POP_DELAY_MAX,
        hasPopped: false,
        popStrength: PLAYGROUND.popcorn.POP_FORCE_MIN + 
                    Math.random() * (PLAYGROUND.popcorn.POP_FORCE_MAX - PLAYGROUND.popcorn.POP_FORCE_MIN),
        
        // Physics after popping
        gravity: 0.098,                    // Gravity strength
        bounceDamping: PLAYGROUND.popcorn.BOUNCE_HEIGHT,
        bounceCount: 0,
        maxBounces: 2 + Math.floor(Math.random() * 2), // 2-3 bounces
        
        // Visual flair
        spinRate: (Math.random() - 0.5) * 10, // Rotation speed (for future use)
        lifetime: 0                           // Track time since spawn
    };
}

/**
 * Update popcorn behavior each frame
 * Handles waiting, popping, and bouncing phases
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updatePopcorn(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    data.lifetime += dt * 16.67; // Convert to milliseconds
    
    // Check if it's time to pop
    if (!data.hasPopped && data.lifetime > data.popDelay) {
        // POP! Sudden burst of velocity in all directions for celebration
        data.hasPopped = true;
        const popAngle = Math.random() * Math.PI * 2; // Full 360 degree spread
        particle.vx = Math.cos(popAngle) * data.popStrength * 1.5; // Extra horizontal spread
        particle.vy = Math.sin(popAngle) * data.popStrength - 0.3; // Slight upward bias for joy
        
        // Expand size when popping for dramatic effect
        particle.size = particle.baseSize * 1.25;
    }
    
    if (data.hasPopped) {
        // Apply gravity
        particle.vy += data.gravity * dt;
        
        // Check for ground bounce
        const groundLevel = centerY + 100 * particle.scaleFactor; // Below the orb
        if (particle.y > groundLevel && data.bounceCount < data.maxBounces) {
            particle.y = groundLevel;
            particle.vy = -Math.abs(particle.vy) * data.bounceDamping; // Bounce up with damping
            particle.vx *= 0.9; // Reduce horizontal speed on bounce
            data.bounceCount++;
            
            // Shrink slightly with each bounce
            particle.size = particle.baseSize * (1.5 - data.bounceCount * 0.1);
        }
        
        // Fade dramatically after final bounce
        if (data.bounceCount >= data.maxBounces) {
            particle.lifeDecay = 0.03 + Math.random() * 0.02; // Very fast fade
            particle.size *= 0.95; // Also shrink rapidly
        }
        
        // Dynamic fading based on velocity - slower particles fade faster
        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (speed < 0.5) {
            particle.lifeDecay *= 1.5; // 50% faster fade when moving slowly
        }
    }
}

// Export behavior definition for registry
var popcorn = {
    name: 'popcorn',
    emoji: '🍿',
    description: 'Spontaneous popping with gravity and bounces',
    initialize: initializePopcorn,
    update: updatePopcorn
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Burst Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Explosive expansion for surprise and suspicion states
 * @author Emotive Engine Team
 * @module particles/behaviors/burst
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates dramatic expansion effects. For surprise: fast burst then sudden stop.    
 * ║ For suspicion: controlled, watchful expansion. Particles shoot out from center.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *   Surprise:                  Suspicion:
 *       💥→                        •→
 *     ↗ 💥 ↘                    ↗ • ↘
 *   ← ⭐ →    STOP!          ← ⭐ →    (controlled)
 *     ↙ 💥 ↖                    ↙ • ↖
 *       💥←                        •←
 * 
 * USED BY EMOTIONS:
 * - surprise (dramatic burst then stop)
 * - suspicion (controlled, watchful expansion)
 * 
 * RECIPE TO MODIFY:
 * - Increase speed for more dramatic burst
 * - Adjust friction for different deceleration
 * - Change stopTime for surprise effect timing
 */


/**
 * Initialize burst behavior for a particle
 * Sets up explosive outward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeBurst(particle) {
    // Check emotion type for behavior variation
    const isSuspicion = particle.emotion === 'suspicion';
    const isSurprise = particle.emotion === 'surprise';
    
    // Random direction for burst
    const angle = Math.random() * PHYSICS.TWO_PI;
    
    // Speed based on emotion
    const speed = isSuspicion ? 
        (1.0 + Math.random() * 0.8) :      // Controlled burst for suspicion (1-1.8)
        (isSurprise ? 
            (7.0 + Math.random() * 5.0) :  // Much faster burst for surprise (7-12)
            (3.5 + Math.random() * 2.5));  // Normal burst for others (3.5-6)
    
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    
    // Lifespan based on emotion
    particle.lifeDecay = isSuspicion ? 
        0.010 : 
        (isSurprise ? 0.006 + Math.random() * 0.008 : 0.015);
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    // Make suspicion particles more visible
    if (isSuspicion) {
        particle.size = (6 + Math.random() * 4) * 
                       (particle.scaleFactor || 1) * 
                       (particle.particleSizeMultiplier || 1);
        particle.baseSize = particle.size;
        particle.opacity = 1.0;  // Full opacity for visibility
        particle.baseOpacity = particle.opacity;
    }
    
    particle.behaviorData = {
        isSuspicion,
        isSurprise,
        age: 0,
        fadeStart: isSuspicion ? 0.3 : 0.2  // When to start fading
    };
}

/**
 * Update burst behavior each frame
 * Handles explosive expansion with emotion-specific variations
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateBurst(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Surprise particles: burst out then STOP suddenly
    if (data.isSurprise) {
        // Track age for timing the stop
        data.age += dt * 0.016; // Convert to seconds
        
        if (data.age < 0.15) {
            // First 0.15 seconds: maintain high speed
            const friction = 0.98;
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
        } else if (data.age < 0.25) {
            // 0.15-0.25 seconds: SUDDEN STOP!
            const friction = 0.85; // Heavy braking
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
        } else {
            // After stop: float gently
            const friction = 0.99;
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
            // Tiny random drift
            particle.vx += (Math.random() - 0.5) * 0.01 * dt;
            particle.vy += (Math.random() - 0.5) * 0.01 * dt;
        }
    } else {
        // Normal burst behavior for other emotions
        const friction = data.isSuspicion ? 0.99 : 0.95;
        particle.vx *= Math.pow(friction, dt);
        particle.vy *= Math.pow(friction, dt);
    }
    
    // For suspicion, add a subtle scanning motion
    if (data.isSuspicion) {
        // Add a very subtle side-to-side drift
        const time = Date.now() * 0.001;
        particle.vx += Math.sin(time * 2 + particle.id) * 0.01 * dt;
    }
}

// Export behavior definition for registry
var burst$1 = {
    name: 'burst',
    emoji: '💥',
    description: 'Explosive expansion from center',
    initialize: initializeBurst,
    update: updateBurst
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Aggressive Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sharp, chaotic movement for angry emotional states
 * @author Emotive Engine Team
 * @module particles/behaviors/aggressive
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an intense, volatile atmosphere with particles moving erratically.        
 * ║ Sharp jitters and sudden bursts of movement convey anger and frustration.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      ⚡→    ←⚡
 *        ↘  ↙       ← erratic, sharp movements
 *    ⚡← ⭐ →⚡      ← orb center (shaking)
 *        ↗  ↖
 *      ⚡←    →⚡
 * 
 * USED BY EMOTIONS:
 * - anger (rage, fury)
 * - frustration
 * - irritation
 * 
 * RECIPE TO MODIFY:
 * - Increase jitter for more chaotic movement
 * - Increase acceleration for more violent bursts
 * - Decrease speedDecay for longer-lasting energy
 */


/**
 * Initialize aggressive behavior for a particle
 * Sets up chaotic, sharp movement patterns
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAggressive(particle) {
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 1.5 + Math.random() * 2;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.015;
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        acceleration: 0.05,
        jitter: 0.3,
        speedDecay: 0.95
    };
}

/**
 * Update aggressive behavior each frame
 * Applies jitter and random acceleration bursts
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateAggressive(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Add jitter to movement
    particle.vx += (Math.random() - 0.5) * data.jitter * dt;
    particle.vy += (Math.random() - 0.5) * data.jitter * dt;
    
    // Apply speed decay (frame-independent)
    particle.vx *= Math.pow(data.speedDecay, dt);
    particle.vy *= Math.pow(data.speedDecay, dt);
    
    // Occasionally add burst of acceleration
    // Scale probability with frame time
    if (Math.random() < Math.min(0.05 * dt, 0.5)) {
        const angle = Math.random() * PHYSICS.TWO_PI;
        particle.vx += Math.cos(angle) * data.acceleration;
        particle.vy += Math.sin(angle) * data.acceleration;
    }
}

// Export behavior definition for registry
var aggressive = {
    name: 'aggressive',
    emoji: '⚡',
    description: 'Sharp, chaotic movement with violent bursts',
    initialize: initializeAggressive,
    update: updateAggressive
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Scattering Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles fleeing from center for fear states
 * @author Emotive Engine Team
 * @module particles/behaviors/scattering
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an anxious atmosphere with particles frantically fleeing from the center. 
 * ║ Conveys fear, panic, and the desire to escape.                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ← · · · →
 *    ↖       ↗       ← particles flee outward
 *  · · ⭐ · ·       ← orb center (source of fear)
 *    ↙       ↘
 *    ← · · · →
 * 
 * USED BY EMOTIONS:
 * - fear (panic, anxiety)
 * - startled
 * - nervous
 * 
 * RECIPE TO MODIFY:
 * - Increase fleeSpeed for more frantic escape
 * - Increase panicFactor for more erratic fleeing
 * - Add jitter for nervous shaking while fleeing
 */


/**
 * Initialize scattering behavior for a particle
 * Sets up fleeing movement away from center
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeScattering(particle) {
    // Will be set relative to center in update
    particle.vx = 0;
    particle.vy = 0;
    particle.lifeDecay = 0.008;  // Live longer to spread further
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        fleeSpeed: 2.0,     // Much faster fleeing
        panicFactor: 1.2,   // More panicked movement
        initialized: false
    };
}

/**
 * Update scattering behavior each frame
 * Particles flee away from center with panic
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updateScattering(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Initialize flee direction if not done
    if (!data.initialized) {
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            particle.vx = (dx / distance) * data.fleeSpeed;
            particle.vy = (dy / distance) * data.fleeSpeed;
        } else {
            // If at center, pick random direction
            const angle = Math.random() * PHYSICS.TWO_PI;
            particle.vx = Math.cos(angle) * data.fleeSpeed;
            particle.vy = Math.sin(angle) * data.fleeSpeed;
        }
        data.initialized = true;
    }
    
    // Continue fleeing with panic factor
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 0) {
        // Add acceleration away from center
        particle.vx += (dx / distance) * data.panicFactor * 0.01 * dt;
        particle.vy += (dy / distance) * data.panicFactor * 0.01 * dt;
    }
    
    // Add nervous jitter
    particle.vx += (Math.random() - 0.5) * 0.1 * dt;
    particle.vy += (Math.random() - 0.5) * 0.1 * dt;
    
    // Apply friction
    particle.vx *= Math.pow(0.98, dt);
    particle.vy *= Math.pow(0.98, dt);
}

// Export behavior definition for registry
var scattering = {
    name: 'scattering',
    emoji: '😨',
    description: 'Particles flee from center in panic',
    initialize: initializeScattering,
    update: updateScattering
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Repelling Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles pushed away from center for aversion states
 * @author Emotive Engine Team
 * @module particles/behaviors/repelling
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a space of rejection with particles being pushed away from the center,    
 * ║ maintaining a minimum distance. Conveys disgust, rejection, and boundaries.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ← - - - →
 *    ↖       ↗       ← particles pushed away
 *  - - (  ) - -      ← empty zone around center
 *    ↙       ↘       ← minimum distance maintained
 *    ← - - - →
 * 
 * USED BY EMOTIONS:
 * - disgust (keeping things at bay)
 * - contempt
 * - aversion
 * 
 * RECIPE TO MODIFY:
 * - Increase repelStrength for stronger push
 * - Increase minDistance for larger empty zone
 * - Adjust damping for smoother/rougher motion
 */


/**
 * Initialize repelling behavior for a particle
 * Sets up repulsion from center
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRepelling(particle) {
    particle.vx = 0;
    particle.vy = 0;
    particle.lifeDecay = 0.01; // Moderate life
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        repelStrength: 0.8,      // How strongly to push away
        minDistance: 50,         // Minimum distance from center
        initialized: false       // Track if initial repel has been applied
    };
}

/**
 * Update repelling behavior - particles maintain distance from center
 * 
 * Used for: DISGUST emotion (keeping unpleasant things away)
 * Visual effect: Particles are pushed away from center and maintain a 
 *                minimum distance, creating an empty zone
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateRepelling(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Calculate distance from center
    // dx/dy = distance from center to particle (can be negative)
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    // dist = straight-line distance using Pythagorean theorem
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // STEP 2: Apply repelling force if too close to center
    // This ensures particles maintain minimum distance
    if (!data.initialized || distance < data.minDistance) {
        if (distance > 0) {
            // Calculate repel force (stronger when closer)
            // Math.max(distance, 5) prevents division by very small numbers
            const repelForce = data.repelStrength / Math.max(distance, 5);
            
            // Apply force in direction away from center
            // dx/distance = unit vector component pointing away
            // Multiply by dt for frame-rate independence
            particle.vx += (dx / distance) * repelForce * dt;
            particle.vy += (dy / distance) * repelForce * dt;
        }
        data.initialized = true;
    }
    
    // STEP 3: Apply gentle damping to smooth motion
    // This prevents infinite acceleration and creates natural deceleration
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(0.99, dt);
    particle.vy *= Math.pow(0.99, dt);
}

// Export behavior definition for registry
var repelling = {
    name: 'repelling',
    emoji: '🚫',
    description: 'Particles pushed away from center, maintaining distance',
    initialize: initializeRepelling,
    update: updateRepelling
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Connecting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Chaotic particles drawn to center for social connection states
 * @author Emotive Engine Team
 * @module particles/behaviors/connecting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an energetic social atmosphere with particles moving chaotically but       
 * ║ staying connected to the center. Like a lively party or bustling community.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ↗↘ ↖↙ ↗↘
 *   ↙ ↗ ↘ ↖ ↙       ← chaotic but connected
 *  ↘ ↖ ⭐ ↗ ↙       ← drawn to center
 *   ↗ ↙ ↖ ↘ ↗       ← higher energy than ambient
 *    ↙↖ ↗↘ ↙↖
 * 
 * USED BY EMOTIONS:
 * - curiosity (social exploration)
 * - playfulness
 * - engagement
 * 
 * RECIPE TO MODIFY:
 * - Increase attractionForce for stronger pull to center
 * - Increase chaosFactor for more erratic movement
 * - Decrease friction for more energetic motion
 */


/**
 * Initialize connecting behavior for a particle
 * Sets up chaotic but connected movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeConnecting(particle) {
    // Original Emotive connecting: speed 2-7, higher chaos
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 2 + Math.random() * 5; // Faster than ambient
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.012; // Shorter life for more dynamic feel
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Higher attraction and chaos for connecting state
        attractionForce: 0.008,  // Stronger pull (original)
        chaosFactor: 1.0,        // Higher chaos (original)
        friction: 0.95          // Less friction than ambient
    };
}

/**
 * Update connecting behavior - chaotic movement with center attraction
 * 
 * Used for: CURIOSITY/SOCIAL emotions (engaged, exploring, connecting)
 * Visual effect: Particles move chaotically but are drawn back to center,
 *                creating a bustling, connected atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateConnecting(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Apply friction to slow particles gradually
    // This prevents infinite acceleration
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Apply attraction force towards center
    // (centerX - this.x) gives direction vector to center
    // Multiplied by attractionForce to control strength
    const attractX = (centerX - particle.x) * data.attractionForce;
    const attractY = (centerY - particle.y) * data.attractionForce;
    
    // STEP 3: Add chaos for erratic movement
    // (Math.random() - 0.5) gives random value between -0.5 and 0.5
    // Multiplied by chaosFactor for intensity
    const chaosX = (Math.random() - 0.5) * data.chaosFactor;
    const chaosY = (Math.random() - 0.5) * data.chaosFactor;
    
    // STEP 4: Combine forces
    // Attraction keeps particles connected to center
    // Chaos makes movement unpredictable and lively
    particle.vx += attractX + chaosX;
    particle.vy += attractY + chaosY;
}

// Export behavior definition for registry
var connecting = {
    name: 'connecting',
    emoji: '🔗',
    description: 'Chaotic movement with center attraction for social states',
    initialize: initializeConnecting,
    update: updateConnecting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Resting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Ultra-slow movement for deeply relaxed states
 * @author Emotive Engine Team
 * @module particles/behaviors/resting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an atmosphere of deep calm and rest. Particles barely move, creating      
 * ║ a meditative, peaceful environment. Like watching dust motes in sunlight.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ·
 *       · ·         ← barely moving
 *      · · ·        ← vertical drift only
 *     · ⭐ ·        ← no horizontal motion
 *      · · ·        
 *       · ·         
 *        ·
 * 
 * USED BY EMOTIONS:
 * - sleepy (deep rest)
 * - meditative
 * - tranquil
 * 
 * RECIPE TO MODIFY:
 * - Decrease upwardSpeed for even slower movement
 * - Increase lifeDecay for shorter-lived particles
 * - Add tiny horizontal drift for slight variation
 */


/**
 * Initialize resting behavior for a particle
 * Sets up minimal movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeResting(particle) {
    particle.vx = 0;  // NO horizontal movement
    particle.vy = -0.01;  // Tiniest upward drift
    particle.lifeDecay = 0.001;  // Very slow fade - particles last 10+ seconds
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        upwardSpeed: 0.00002,  // Barely perceptible upward drift
        friction: 0.999       // Almost no friction (preserve any motion)
    };
}

/**
 * Update resting behavior - ultra-slow vertical drift
 * 
 * Used for: SLEEPY/MEDITATIVE emotions (deep rest, tranquility)
 * Visual effect: Particles drift upward so slowly they appear almost still,
 *                creating a deeply peaceful atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateResting(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Apply friction to vertical velocity only
    // This creates a very gentle deceleration
    // Math.pow ensures frame-rate independence
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Add tiny continuous upward drift
    // Negative value because canvas Y increases downward
    // Multiplied by dt for frame-rate independence
    particle.vy -= data.upwardSpeed * dt;
    
    // STEP 3: Enforce NO horizontal movement
    // This creates the characteristic vertical-only drift
    // Essential for the peaceful, non-chaotic feel
    particle.vx = 0;
}

// Export behavior definition for registry
var resting = {
    name: 'resting',
    emoji: '😴',
    description: 'Ultra-slow vertical drift for deep rest states',
    initialize: initializeResting,
    update: updateResting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Radiant Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles radiating outward like sun rays for euphoric states
 * @author Emotive Engine Team
 * @module particles/behaviors/radiant
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a euphoric atmosphere with particles bursting outward like sunbeams,      
 * ║ with shimmering and twinkling effects. Perfect for moments of pure joy and hope.  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ☀️
 *    ✨  ↗  ✨       ← particles radiate outward
 *  ✨ ↖ ⭐ ↗ ✨     ← orb center (like the sun)
 *    ✨  ↘  ✨       ← with shimmer effect
 *        ☀️
 * 
 * USED BY EMOTIONS:
 * - euphoria (first day of spring, sunrise vibes)
 * - elation
 * - triumph
 * 
 * RECIPE TO MODIFY:
 * - Increase radialSpeed for faster radiation
 * - Increase shimmerSpeed for faster twinkling
 * - Adjust friction for longer/shorter rays
 */


/**
 * Initialize radiant behavior for a particle
 * Sets up sunburst radiation pattern
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRadiant(particle) {
    // Particles burst outward from center like sunbeams
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.8 + Math.random() * 0.4; // Moderate to fast speed
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.006; // Moderate life - last ~8-10 seconds
    
    // Use emotion colors if provided, otherwise default sunrise colors
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    } else {
        // Default golden sunrise colors
        const colors = ['#FFD700', '#FFB347', '#FFA500', '#FF69B4'];
        particle.color = selectWeightedColor(colors);
    }
    
    // More particles have glow for radiant effect
    particle.hasGlow = Math.random() < 0.7; // 70% chance of glow
    particle.glowSizeMultiplier = particle.hasGlow ? (1.5 + Math.random() * 0.5) : 0;
    
    particle.behaviorData = {
        // Continuous outward radiation
        radialSpeed: 0.02,        // Constant outward acceleration
        shimmer: Math.random() * PHYSICS.TWO_PI, // Initial shimmer phase
        shimmerSpeed: 0.1,        // Shimmer oscillation speed
        friction: 0.99            // Very light friction for long rays
    };
}

/**
 * Update radiant behavior - particles radiate outward like sun rays
 * 
 * Used for: EUPHORIA emotion (first day of spring, sunrise vibes)
 * Visual effect: Particles burst outward from center like sunbeams, with a 
 *                shimmering/twinkling effect as they travel
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateRadiant(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Calculate this particle's direction from the orb center
    // dx/dy = distance from center to particle (can be negative)
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    // dist = straight-line distance using Pythagorean theorem
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // STEP 2: Push particle outward from center (like sun rays)
    if (dist > 0) {
        // Convert dx/dy into a unit vector (length = 1) pointing away from center
        // This gives us pure direction without magnitude
        const dirX = dx / dist;
        const dirY = dy / dist;
        
        // Add velocity in the outward direction
        // radialSpeed controls how fast particles shoot outward
        // Multiply by dt to make movement frame-rate independent
        particle.vx += dirX * data.radialSpeed * dt;
        particle.vy += dirY * data.radialSpeed * dt;
    }
    
    // STEP 3: Create shimmering effect (particles twinkle as they radiate)
    // Increment shimmer phase over time (shimmerSpeed controls twinkle rate)
    data.shimmer += data.shimmerSpeed * dt;
    // Create sine wave oscillation (-1 to 1)
    const shimmerEffect = Math.sin(data.shimmer);
    // Make particle size pulse: baseSize ± 20%
    particle.size = particle.baseSize * (1 + shimmerEffect * 0.2);
    // Make particle opacity pulse: baseOpacity ± 30%
    particle.opacity = particle.baseOpacity * (1 + shimmerEffect * 0.3);
    
    // STEP 4: Apply friction to slow particles over time
    // This prevents infinite acceleration and creates natural deceleration
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
}

// Export behavior definition for registry
var radiant = {
    name: 'radiant',
    emoji: '☀️',
    description: 'Particles radiate outward like sunbeams',
    initialize: initializeRadiant,
    update: updateRadiant
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Ascending Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Slow, steady upward float for zen and meditative states
 * @author Emotive Engine Team
 * @module particles/behaviors/ascending
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a zen atmosphere with particles rising like incense smoke. Slow, steady,  
 * ║ and ethereal movement that gradually fades as particles ascend.                   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑
 *       ~~~        ← gentle wave motion
 *        ↑
 *       ~~~        ← like incense smoke
 *        ↑
 *      ⭐⭐⭐      ← orb center
 *        
 * 
 * USED BY EMOTIONS:
 * - zen (deep meditation)
 * - contemplative
 * - spiritual
 * 
 * RECIPE TO MODIFY:
 * - Decrease ascensionSpeed for slower rise
 * - Increase waveFactor for more horizontal drift
 * - Adjust fadeStartDistance to control when fade begins
 */


/**
 * Initialize ascending behavior for a particle
 * Sets up slow, steady upward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAscending(particle) {
    // Very slow, steady upward movement
    particle.vx = (Math.random() - 0.5) * 0.02;  // Minimal horizontal drift
    particle.vy = -0.03 - Math.random() * 0.02;  // Slow upward movement (0.03-0.05)
    particle.lifeDecay = 0.0008;  // Very long-lived particles (30+ seconds)
    
    // Larger, more ethereal particles for zen
    particle.size = (6 + Math.random() * 6) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1) * 
        1.33;  // 1.33x larger for zen (reduced from 2x)
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.2 + Math.random() * 0.2;  // Very translucent (20-40%)
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Continuous gentle upward drift
        ascensionSpeed: 0.0003,      // Very gentle continuous upward
        waveFactor: 0.5,             // Subtle horizontal wave motion
        waveFrequency: 0.001,        // Very slow wave oscillation
        friction: 0.998,             // Almost no slowdown
        fadeStartDistance: 100       // Start fading after rising 100px
    };
}

/**
 * Update ascending behavior - slow upward float like incense
 * 
 * Used for: ZEN/CONTEMPLATIVE emotions (meditation, spirituality)
 * Visual effect: Particles rise slowly and steadily with subtle wave motion,
 *                gradually fading as they ascend like incense smoke
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateAscending(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Validate data exists
    if (!data) {
        initializeAscending(particle);
        return;
    }
    
    // STEP 1: Apply friction to velocities
    // Very light friction to maintain smooth motion
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Add continuous upward ascension
    // Negative because canvas Y increases downward
    // Multiplied by dt for frame-rate independence
    particle.vy -= data.ascensionSpeed * dt;
    
    // STEP 3: Add subtle wave motion for organic feel
    // Creates the characteristic incense smoke waviness
    // Age gives us time-based oscillation
    const waveOffset = Math.sin(particle.age * data.waveFrequency * 1000) * data.waveFactor;
    particle.vx += waveOffset * 0.001 * dt;
    
    // STEP 4: Track initial Y position for fade calculation
    if (particle.initialY === undefined) {
        particle.initialY = particle.y;
    }
    
    // STEP 5: Calculate distance traveled upward
    const distanceTraveled = particle.initialY - particle.y;
    
    // STEP 6: Start fading after traveling fadeStartDistance pixels
    // This creates the incense smoke dissipation effect
    if (distanceTraveled > data.fadeStartDistance) {
        const fadeProgress = (distanceTraveled - data.fadeStartDistance) / 100;
        const fadeFactor = Math.max(0, 1 - fadeProgress);
        particle.baseOpacity *= 0.995;  // Gradual fade
        
        // Accelerate life decay as particle fades
        if (fadeFactor < 0.5) {
            particle.lifeDecay *= 1.02;
        }
    }
    
    // STEP 7: Dampen excessive horizontal movement
    // Keeps the ascension primarily vertical
    if (Math.abs(particle.vx) > 0.05) {
        particle.vx *= Math.pow(0.95, dt);
    }
    
    // STEP 8: Cap upward velocity for consistency
    // Prevents particles from accelerating too much
    if (particle.vy < -0.1) {
        particle.vy = -0.1;
    }
}

// Export behavior definition for registry
var ascending = {
    name: 'ascending',
    emoji: '🧘',
    description: 'Slow steady upward float like incense smoke',
    initialize: initializeAscending,
    update: updateAscending
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Erratic Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Nervous, jittery movement for anxious states
 * @author Emotive Engine Team
 * @module particles/behaviors/erratic
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a nervous, unstable atmosphere with particles jittering and changing       
 * ║ direction unpredictably. Conveys anxiety, nervousness, and instability.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ↗↙↖  ↘↗
 *   ↙ ↗↘  ↖↙       ← unpredictable changes
 *  ↘↖ ⭐ ↗↙        ← jittery movement
 *   ↗ ↙↖  ↘↗       ← nervous energy
 *    ↙↗↘  ↖↙
 * 
 * USED BY EMOTIONS:
 * - nervous (anxiety, jitters)
 * - unstable
 * - agitated
 * 
 * RECIPE TO MODIFY:
 * - Increase jitterStrength for more shaking
 * - Increase directionChangeRate for more frequent changes
 * - Increase speedVariation for more erratic speed changes
 */


/**
 * Initialize erratic behavior for a particle
 * Sets up nervous, jittery movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeErratic(particle) {
    // Random, chaotic initial direction
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.1 + Math.random() * 0.15;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.004;  // Shorter lived due to nervous energy
    
    particle.size = (2 + Math.random() * 4) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1);  // Varied sizes scaled
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.4 + Math.random() * 0.3;  // More visible
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        jitterStrength: 0.02,        // Random direction changes
        directionChangeRate: 0.1,    // How often to change direction
        speedVariation: 0.3,         // Speed changes randomly
        spinRate: 0.05 + Math.random() * 0.1  // Particles spin
    };
}

/**
 * Update erratic behavior - nervous, jittery movement
 * 
 * Used for: NERVOUS/ANXIOUS emotions (anxiety, instability, agitation)
 * Visual effect: Particles jitter nervously, changing direction and speed
 *                unpredictably, creating an unstable atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateErratic(particle, dt) {
    const data = particle.behaviorData;
    
    // STEP 1: Add constant jitter to movement
    // Creates the nervous shaking effect
    // (Math.random() - 0.5) gives values between -0.5 and 0.5
    // Multiplied by jitterStrength and dt for controlled chaos
    particle.vx += (Math.random() - 0.5) * data.jitterStrength * dt;
    particle.vy += (Math.random() - 0.5) * data.jitterStrength * dt;
    
    // STEP 2: Randomly change direction occasionally
    // Creates unpredictable movement patterns
    // Math.min ensures probability doesn't exceed reasonable bounds
    if (Math.random() < Math.min(data.directionChangeRate * dt, 0.5)) {
        // Pick new random direction
        const newAngle = Math.random() * PHYSICS.TWO_PI;
        const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        
        // Apply new direction while maintaining similar speed
        particle.vx = Math.cos(newAngle) * currentSpeed;
        particle.vy = Math.sin(newAngle) * currentSpeed;
    }
    
    // STEP 3: Vary the speed randomly
    // Creates erratic acceleration/deceleration
    const speedMultiplier = 1 + (Math.random() - 0.5) * data.speedVariation * dt;
    particle.vx *= speedMultiplier;
    particle.vy *= speedMultiplier;
    
    // STEP 4: Apply spin to particle size
    // Makes particles appear to rotate/vibrate
    const spinPhase = particle.age * data.spinRate * 1000;
    particle.size = particle.baseSize * (1 + Math.sin(spinPhase) * 0.2);
    
    // STEP 5: Fluctuate opacity nervously
    // Creates a flickering effect
    particle.opacity = particle.baseOpacity * (0.8 + Math.random() * 0.4);
    
    // STEP 6: Apply damping to prevent infinite acceleration
    // Keeps movement bounded
    particle.vx *= Math.pow(0.98, dt);
    particle.vy *= Math.pow(0.98, dt);
    
    // STEP 7: Cap maximum velocity
    // Prevents particles from moving too fast
    const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
    if (speed > 0.5) {
        particle.vx = (particle.vx / speed) * 0.5;
        particle.vy = (particle.vy / speed) * 0.5;
    }
}

// Export behavior definition for registry
var erratic = {
    name: 'erratic',
    emoji: '😰',
    description: 'Nervous jittery movement for anxious states',
    initialize: initializeErratic,
    update: updateErratic
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Cautious Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Slow, careful movement with pauses for suspicious states
 * @author Emotive Engine Team
 * @module particles/behaviors/cautious
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a watchful, suspicious atmosphere with particles moving slowly and         
 * ║ pausing frequently, as if carefully observing. Like being on guard.               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    · → · STOP
 *   STOP ← ·        ← move, then pause
 *    · ⭐ ·         ← watching center
 *   · STOP →        ← pause, then move
 *    STOP · ← ·
 * 
 * USED BY EMOTIONS:
 * - suspicion (watchful, guarded)
 * - uncertainty
 * - wariness
 * 
 * RECIPE TO MODIFY:
 * - Increase pauseDuration for longer stops
 * - Decrease moveDuration for shorter movements
 * - Adjust watchRadius to control patrol area
 */


/**
 * Initialize cautious behavior for a particle
 * Sets up slow, deliberate movement patterns
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeCautious(particle) {
    // Particles move very slowly and deliberately
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.02 + Math.random() * 0.03; // Very slow: 0.02-0.05 units/frame
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.001;  // Very long-lived for visibility
    particle.life = 1.0;  // Ensure full life
    
    particle.size = (4 + Math.random() * 4) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1);
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.8 + Math.random() * 0.2;  // Very visible (80-100%)
    particle.opacity = particle.baseOpacity;
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        pauseTimer: Math.random() * 2,      // Start with random pause offset
        pauseDuration: 0.5 + Math.random() * 0.5,  // Pause for 0.5-1s
        moveDuration: 1 + Math.random() * 0.5,     // Move for 1-1.5s
        isMoving: Math.random() > 0.5,             // Randomly start moving or paused
        moveTimer: 0,
        originalVx: particle.vx,
        originalVy: particle.vy,
        watchRadius: 50 + Math.random() * 30       // Stay within 50-80 units of core
    };
}

/**
 * Update cautious behavior - slow movement with frequent pauses
 * 
 * Used for: SUSPICION/UNCERTAINTY emotions (watchful, guarded, wary)
 * Visual effect: Particles move slowly and deliberately, pausing frequently
 *                as if carefully observing their surroundings
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center
 * @param {number} centerY - Y coordinate of the orb's center
 */
function updateCautious(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Update movement timer
    // Tracks how long we've been in current state (moving or paused)
    data.moveTimer += dt;
    
    // STEP 2: Switch between moving and pausing states
    if (data.isMoving) {
        // Currently moving - check if time to pause
        if (data.moveTimer > data.moveDuration) {
            data.isMoving = false;
            data.moveTimer = 0;
            // Stop movement during pause (watchful stillness)
            particle.vx = 0;
            particle.vy = 0;
        } else {
            // Continue moving at cautious speed
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
        }
    } else {
        // Currently paused - check if time to move
        if (data.moveTimer > data.pauseDuration) {
            data.isMoving = true;
            data.moveTimer = 0;
            // Pick a new careful direction
            const angle = Math.random() * PHYSICS.TWO_PI;
            const speed = 0.02 + Math.random() * 0.03;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
            // Store for next movement phase
            data.originalVx = particle.vx;
            data.originalVy = particle.vy;
        }
    }
    
    // STEP 3: Keep particles within watch radius of core
    // They're suspicious, so they don't stray too far
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > data.watchRadius) {
        // Pull back towards core slowly (maintaining caution)
        const pullStrength = 0.02;
        particle.vx -= (dx / dist) * pullStrength * dt;
        particle.vy -= (dy / dist) * pullStrength * dt;
    }
    
    // STEP 4: Apply very light damping
    // Keeps movement controlled and deliberate
    particle.vx *= Math.pow(0.995, dt);
    particle.vy *= Math.pow(0.995, dt);
    
    // STEP 5: Subtle opacity flicker during pauses
    // Creates a watchful "blinking" effect
    if (!data.isMoving) {
        particle.opacity = particle.baseOpacity * (0.9 + Math.sin(particle.age * 5) * 0.1);
    } else {
        particle.opacity = particle.baseOpacity;
    }
}

// Export behavior definition for registry
var cautious = {
    name: 'cautious',
    emoji: '🤨',
    description: 'Slow careful movement with watchful pauses',
    initialize: initializeCautious,
    update: updateCautious
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Surveillance Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Searchlight scanning behavior for suspicious/paranoid states
 * @author Emotive Engine Team
 * @module particles/behaviors/surveillance
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Particles act like searchlights or surveillance cameras, slowly scanning back     
 * ║ and forth in arcs, pausing at edges, occasionally darting to new positions.       
 * ║ Creates a paranoid, watchful atmosphere with deliberate, searching movements.     
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * BEHAVIOR PATTERN:
 * • Slow horizontal scanning arcs (like searchlights)
 * • Pause at scan extremes (checking corners)
 * • Occasional quick darts to new positions (alert response)
 * • Some particles patrol perimeter (edge surveillance)
 * • Random freezing in place (listening/watching)
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  VISUAL: Searchlight Scanning                                                    │
 * │                                                                                   │
 * │     ←─────────────→  (slow scan)                                                │
 * │    •               •                                                             │
 * │                                                                                   │
 * │   pause...     ...pause                                                         │
 * │                                                                                   │
 * │     DART! ──→ • (quick repositioning)                                          │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


var surveillance = {
    name: 'surveillance',
    emoji: '👁️',
    description: 'Searchlight scanning with paranoid watchfulness',
    
    /**
     * Initialize particle state for surveillance behavior
     */
    initialize: function(particle, config) {
        // Set particle color from emotion palette
        if (particle.emotionColors && particle.emotionColors.length > 0) {
            particle.color = selectWeightedColor(particle.emotionColors);
        }
        
        particle.behaviorState = {
            // Scanning properties
            scanAngle: Math.random() * Math.PI - Math.PI/2,  // Current scan angle
            scanDirection: Math.random() < 0.5 ? 1 : -1,      // Scan direction
            scanSpeed: 0.3 + Math.random() * 0.2,             // Individual scan rate
            scanRange: Math.PI/3 + Math.random() * Math.PI/4, // Scan arc size
            scanCenter: Math.random() * Math.PI * 2,          // Center of scan arc
            pauseTimer: 0,                                     // Pause at edges
            pauseDuration: 500 + Math.random() * 500,         // How long to pause
            
            // Movement states
            mode: 'scanning',  // 'scanning', 'darting', 'frozen', 'patrolling'
            modeTimer: 0,
            nextModeChange: 2000 + Math.random() * 3000,
            
            // Dart properties
            dartTarget: { x: 0, y: 0 },
            dartSpeed: 0,
            
            // Patrol properties
            patrolRadius: 150 + Math.random() * 100,
            patrolAngle: Math.random() * Math.PI * 2,
            
            // Threat response
            alertLevel: 0,
            lastPosition: { x: particle.x, y: particle.y }
        };
        
        // Assign roles: 70% scanners, 20% patrollers, 10% watchers
        const role = Math.random();
        if (role < 0.7) {
            particle.behaviorState.primaryRole = 'scanner';
        } else if (role < 0.9) {
            particle.behaviorState.primaryRole = 'patroller';
            particle.behaviorState.mode = 'patrolling';
        } else {
            particle.behaviorState.primaryRole = 'watcher';
            particle.behaviorState.mode = 'frozen';
        }
    },
    
    /**
     * Update particle physics for surveillance behavior
     */
    update: function(particle, dt, config) {
        const state = particle.behaviorState;
        if (!state) return;
        
        // Update mode timer
        state.modeTimer += dt * 16;
        
        // Check for mode changes
        if (state.modeTimer > state.nextModeChange) {
            this.changeMode(particle, state);
            state.modeTimer = 0;
            state.nextModeChange = 2000 + Math.random() * 4000;
        }
        
        // Update based on current mode
        switch(state.mode) {
            case 'scanning':
                this.updateScanning(particle, dt, state, config);
                break;
            case 'darting':
                this.updateDarting(particle, dt, state, config);
                break;
            case 'frozen':
                this.updateFrozen(particle, dt, state, config);
                break;
            case 'patrolling':
                this.updatePatrolling(particle, dt, state, config);
                break;
        }
        
        // Apply slight downward drift for weight
        particle.vy += 0.05 * dt;
        
        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Store last position
        state.lastPosition.x = particle.x;
        state.lastPosition.y = particle.y;
    },
    
    /**
     * Scanning mode - slow searchlight sweeps
     */
    updateScanning: function(particle, dt, state, config) {
        // Update scan angle
        if (state.pauseTimer > 0) {
            // Pausing at edge of scan
            state.pauseTimer -= dt * 16;
            particle.vx *= 0.9;  // Slow down during pause
            particle.vy *= 0.9;
        } else {
            // Active scanning
            state.scanAngle += state.scanDirection * state.scanSpeed * dt * 0.02;
            
            // Check scan limits and pause at edges
            if (Math.abs(state.scanAngle) > state.scanRange / 2) {
                state.scanDirection *= -1;
                state.pauseTimer = state.pauseDuration;
                state.scanAngle = Math.sign(state.scanAngle) * state.scanRange / 2;
            }
        }
        
        // Apply scanning motion
        const actualAngle = state.scanCenter + state.scanAngle;
        const speed = 0.8 + state.alertLevel * 0.5;
        particle.vx = Math.cos(actualAngle) * speed;
        particle.vy = Math.sin(actualAngle) * speed * 0.3;  // Less vertical movement
    },
    
    /**
     * Darting mode - quick repositioning
     */
    updateDarting: function(particle, dt, state, config) {
        const dx = state.dartTarget.x - particle.x;
        const dy = state.dartTarget.y - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
            // Move toward dart target quickly
            particle.vx = (dx / distance) * state.dartSpeed;
            particle.vy = (dy / distance) * state.dartSpeed;
        } else {
            // Reached target, switch back to scanning
            state.mode = 'scanning';
            state.modeTimer = 0;
        }
    },
    
    /**
     * Frozen mode - watchful stillness
     */
    updateFrozen: function(particle, dt, state, config) {
        // Almost no movement, just tiny vibrations
        particle.vx *= 0.95;
        particle.vy *= 0.95;
        
        // Occasional tiny twitch
        if (Math.random() < 0.01) {
            particle.vx += (Math.random() - 0.5) * 0.5;
            particle.vy += (Math.random() - 0.5) * 0.5;
        }
    },
    
    /**
     * Patrolling mode - edge surveillance
     */
    updatePatrolling: function(particle, dt, state, config) {
        // Patrol in a circle around the edge
        state.patrolAngle += 0.01 * dt;
        
        const targetX = Math.cos(state.patrolAngle) * state.patrolRadius;
        const targetY = Math.sin(state.patrolAngle) * state.patrolRadius;
        
        // Move toward patrol position
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;
        
        particle.vx = dx * 0.02;
        particle.vy = dy * 0.02;
    },
    
    /**
     * Change behavior mode
     */
    changeMode: function(particle, state) {
        const rand = Math.random();
        
        // Mode transition probabilities based on role
        if (state.primaryRole === 'scanner') {
            if (rand < 0.1) {
                // Dart to new position
                state.mode = 'darting';
                state.dartTarget = {
                    x: (Math.random() - 0.5) * 200,
                    y: (Math.random() - 0.5) * 200
                };
                state.dartSpeed = 3 + Math.random() * 2;
            } else if (rand < 0.2) {
                // Freeze and watch
                state.mode = 'frozen';
            } else {
                // Continue scanning
                state.mode = 'scanning';
            }
        } else if (state.primaryRole === 'patroller') {
            if (rand < 0.1) {
                state.mode = 'frozen';
            } else {
                state.mode = 'patrolling';
            }
        } else {
            // Watcher role
            if (rand < 0.3) {
                state.mode = 'scanning';
            } else {
                state.mode = 'frozen';
            }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glitchy Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Digital glitch behavior with stuttering orbits and corruption
 * @author Emotive Engine Team
 * @module particles/behaviors/glitchy
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Particles orbit like in love state but with digital glitches, stutters, and      
 * ║ corruption artifacts. Creates a captivating dubstep-like visual rhythm.           
 * ║ Combines smooth orbiting with sudden position jumps and digital artifacts.        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * BEHAVIOR PATTERN:
 * • Base orbiting motion (like love state)
 * • Random position jumps (teleportation glitches)
 * • Stuttering/freezing (frame drops)
 * • Trail duplication (ghosting artifacts)
 * • RGB channel separation
 * • Digital noise bursts
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  VISUAL: Glitched Orbiting                                                       │
 * │                                                                                   │
 * │       ░░▒▒▓▓█  ←─ Digital trail                                                 │
 * │     •  ┊  •                                                                      │
 * │   •┊  ⚡  ┊•  ←─ Glitch jump                                                    │
 * │     •  ┊  •                                                                      │
 * │       ░░▒▒▓▓█                                                                    │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


var glitchy = {
    name: 'glitchy',
    emoji: '⚡',
    description: 'Digital glitch with stuttering orbits and corruption',
    
    // Rhythm configuration for glitchy behavior
    rhythm: {
        enabled: true,
        
        // Glitch events sync to rhythm
        glitchTiming: {
            mode: 'subdivision',     // Glitch on subdivisions
            subdivision: 'sixteenth', // 16th notes for rapid glitches
            probability: 0.3,        // 30% chance on each 16th
            intensityOnBeat: 2.0,    // Stronger glitches on beat
            intensityOffBeat: 0.5    // Weaker between beats
        },
        
        // Stutter/freeze timing
        stutterSync: {
            mode: 'pattern',         // Based on rhythm pattern
            patterns: {
                'dubstep': {
                    freezeOnDrop: true,  // Freeze on the drop (beat 3)
                    dropDuration: 100    // Freeze for 100ms
                },
                'breakbeat': {
                    randomFreeze: 0.1,   // 10% chance per beat
                    duration: 50         // Short 50ms freezes
                }
            }
        },
        
        // Orbital speed modulation
        orbitRhythm: {
            baseSpeed: 'tempo',      // Speed scales with BPM
            wobbleSync: 'eighth',    // Wobble on 8th notes
            beatAcceleration: 1.5,   // Speed boost on beat
            barReset: true           // Reset orbit angle each bar
        },
        
        // RGB split effect rhythm
        rgbSync: {
            enabled: true,
            amount: 'intensity',     // Split based on musical intensity
            direction: 'beat',        // Change split direction on beat
            maxSplit: 10             // Maximum pixel split
        },
        
        // Digital noise bursts
        noiseRhythm: {
            trigger: 'accent',       // Noise on accented beats
            duration: 50,            // 50ms noise bursts
            intensity: 'drop'        // Scale with drop intensity
        }
    },
    
    /**
     * Initialize particle state for glitchy behavior
     */
    initialize: function(particle, config, centerX, centerY) {
        // Set particle color from emotion palette
        if (particle.emotionColors && particle.emotionColors.length > 0) {
            particle.color = selectWeightedColor(particle.emotionColors);
        }
        
        particle.behaviorState = {
            // Orbital properties (tighter orbit to stay centered)
            orbitAngle: Math.random() * Math.PI * 2,
            orbitRadius: 30 + Math.random() * 40,  // Reduced from 40-120 to 30-70
            orbitSpeed: 0.01 + Math.random() * 0.02,
            
            // Glitch properties
            glitchTimer: 0,
            nextGlitch: Math.random() * 500 + 100,
            isGlitching: false,
            glitchDuration: 0,
            glitchOffset: { x: 0, y: 0 },
            
            // Stutter properties
            stutterTimer: 0,
            nextStutter: Math.random() * 200 + 50,
            isFrozen: false,
            frozenPosition: { x: 0, y: 0 },
            frozenVelocity: { x: 0, y: 0 },
            
            // Trail ghost properties
            hasGhost: Math.random() < 0.3,
            ghostOffset: Math.random() * 20 + 10,
            ghostAngle: Math.random() * Math.PI * 2,
            
            // RGB separation
            rgbSplit: Math.random() < 0.4,
            rgbPhase: Math.random() * Math.PI * 2,
            
            // Digital noise
            noiseLevel: 0,
            noiseBurst: false,
            
            // Dubstep rhythm sync
            beatPhase: Math.random() * Math.PI * 2,
            beatFrequency: 0.05 + Math.random() * 0.03,
            dropIntensity: 0
        };
        
        // Special properties for glitch
        particle.lifeDecay = 0.0015; // Slower decay for trails
        particle.hasGlow = Math.random() < 0.5; // More glow for digital effect
        if (particle.hasGlow) {
            particle.glowSizeMultiplier = 2.0 + Math.random(); // Bigger glows
        }
    },
    
    /**
     * Update particle physics for glitchy behavior
     */
    update: function(particle, dt, centerX, centerY) {
        const state = particle.behaviorState;
        if (!state) return;
        
        // centerX and centerY are passed correctly from updateBehavior
        // No need for fallbacks - they should always be provided
        
        // Update timers
        state.glitchTimer += dt * 16;
        state.stutterTimer += dt * 16;
        
        // Check for stutter/freeze
        if (state.stutterTimer > state.nextStutter) {
            if (!state.isFrozen) {
                // Start freeze
                state.isFrozen = true;
                state.frozenPosition = { x: particle.x, y: particle.y };
                state.frozenVelocity = { x: particle.vx, y: particle.vy };
                state.stutterTimer = 0;
                state.nextStutter = 20 + Math.random() * 40; // Short freeze
            } else {
                // End freeze
                state.isFrozen = false;
                state.stutterTimer = 0;
                state.nextStutter = 100 + Math.random() * 300;
                
                // Sometimes jump on unfreeze (smaller jumps to stay centered)
                if (Math.random() < 0.3) {
                    particle.x += (Math.random() - 0.5) * 20;  // Reduced from 50
                    particle.y += (Math.random() - 0.5) * 20;  // Reduced from 50
                }
            }
        }
        
        // Check for glitch events
        if (state.glitchTimer > state.nextGlitch && !state.isGlitching) {
            state.isGlitching = true;
            state.glitchDuration = 50 + Math.random() * 100;
            state.glitchOffset = {
                x: (Math.random() - 0.5) * 30,  // Reduced from 100 to keep particles closer
                y: (Math.random() - 0.5) * 30   // Reduced from 100 to keep particles closer
            };
            state.glitchTimer = 0;
            
            // Change color during glitch
            if (Math.random() < 0.5 && particle.emotionColors) {
                particle.color = selectWeightedColor(particle.emotionColors);
            }
        }
        
        // End glitch
        if (state.isGlitching && state.glitchTimer > state.glitchDuration) {
            state.isGlitching = false;
            state.glitchTimer = 0;
            state.nextGlitch = 200 + Math.random() * 800;
            state.glitchOffset = { x: 0, y: 0 };
        }
        
        // Update beat phase for dubstep rhythm
        state.beatPhase += state.beatFrequency * dt;
        const beatIntensity = Math.sin(state.beatPhase) * 0.5 + 0.5;
        
        // Calculate drop intensity (periodic bass drops)
        const dropCycle = state.beatPhase % (Math.PI * 4);
        if (dropCycle < Math.PI * 0.5) {
            state.dropIntensity = Math.min(1, state.dropIntensity + dt * 0.1);
        } else {
            state.dropIntensity = Math.max(0, state.dropIntensity - dt * 0.05);
        }
        
        if (!state.isFrozen) {
            // Update orbital position with beat modulation
            state.orbitAngle += state.orbitSpeed * dt * (1 + beatIntensity * 0.5);
            
            // Add drop wobble
            const wobbleRadius = state.orbitRadius * (1 + state.dropIntensity * 0.3 * Math.sin(state.beatPhase * 4));
            
            // Calculate target position relative to center
            let targetX = centerX + Math.cos(state.orbitAngle) * wobbleRadius;
            let targetY = centerY + Math.sin(state.orbitAngle) * wobbleRadius * 0.6; // Elliptical
            
            // Apply glitch offset (smaller random factor to stay closer)
            if (state.isGlitching) {
                targetX += state.glitchOffset.x * Math.random() * 0.5;  // Reduced effect
                targetY += state.glitchOffset.y * Math.random() * 0.5;  // Reduced effect
            }
            
            // RGB split effect
            if (state.rgbSplit) {
                const splitAmount = 3 * (1 + state.dropIntensity);
                targetX += Math.sin(state.rgbPhase) * splitAmount;
                targetY += Math.cos(state.rgbPhase) * splitAmount;
                state.rgbPhase += 0.1 * dt;
            }
            
            // Digital noise bursts on drops (smaller to stay centered)
            if (state.dropIntensity > 0.8 && Math.random() < 0.1) {
                targetX += (Math.random() - 0.5) * 10;  // Reduced from 20
                targetY += (Math.random() - 0.5) * 10;  // Reduced from 20
            }
            
            // Stronger pull to center to prevent wandering
            const smoothing = state.isGlitching ? 0.05 : 0.08;  // Increased from 0.02/0.05
            particle.vx = (targetX - particle.x) * smoothing;
            particle.vy = (targetY - particle.y) * smoothing;
            
            // Add jitter based on beat
            particle.vx += (Math.random() - 0.5) * beatIntensity * 2;
            particle.vy += (Math.random() - 0.5) * beatIntensity * 2;
            
        } else {
            // Frozen - vibrate in place
            particle.vx = (Math.random() - 0.5) * 0.5;
            particle.vy = (Math.random() - 0.5) * 0.5;
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Flicker opacity for digital effect
        if (Math.random() < 0.02) {
            particle.opacity = 0.1 + Math.random() * 0.9;
        }
        
        // Size pulsing with beat
        particle.size = particle.baseSize * (1 + beatIntensity * 0.3 + state.dropIntensity * 0.5);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Directed Particle Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Directed behavior - particles move in focused, straight paths
 * @author Emotive Engine Team
 * @module particles/behaviors/directed
 */

/**
 * DIRECTED BEHAVIOR - FOCUSED STRAIGHT PATHS
 * Used by: focused emotion
 * 
 * Particles move in deliberate, straight lines toward a target or direction,
 * representing intense concentration and focus.
 */
var directed = {
    name: 'directed',
    emoji: '🎯',
    description: 'Focused, straight-line movement toward target',
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ CONFIGURATION
    // └─────────────────────────────────────────────────────────────────────────────────
    config: {
        speed: 3.0,              // Fast movement
        acceleration: 0.15,      // Quick acceleration
        focusStrength: 0.8,      // Strong pull toward target
        randomness: 0.1,         // Minimal deviation
        edgeBuffer: 50           // Buffer from canvas edges
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ INITIALIZATION
    // └─────────────────────────────────────────────────────────────────────────────────
    initialize(particle, centerX, centerY, canvasWidth, canvasHeight) {
        // Set initial direction toward center
        const dx = centerX - particle.x;
        const dy = centerY - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            particle.vx = (dx / distance) * this.config.speed;
            particle.vy = (dy / distance) * this.config.speed;
        } else {
            // Random initial direction if at center
            const angle = Math.random() * Math.PI * 2;
            particle.vx = Math.cos(angle) * this.config.speed;
            particle.vy = Math.sin(angle) * this.config.speed;
        }
        
        // Store target position
        particle.targetX = centerX;
        particle.targetY = centerY;
        particle.directedPhase = 0;
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ UPDATE LOOP
    // └─────────────────────────────────────────────────────────────────────────────────
    update(particle, dt, centerX, centerY, canvasWidth, canvasHeight) {
        // Update phase for variation
        particle.directedPhase += dt * 0.05;
        
        // Calculate direction to target
        const dx = particle.targetX - particle.x;
        const dy = particle.targetY - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 10) {
            // Move toward target with focus strength
            const targetVx = (dx / distance) * this.config.speed;
            const targetVy = (dy / distance) * this.config.speed;
            
            // Apply acceleration toward target velocity
            particle.vx += (targetVx - particle.vx) * this.config.acceleration * dt;
            particle.vy += (targetVy - particle.vy) * this.config.acceleration * dt;
            
            // Add minimal randomness for organic feel
            particle.vx += (Math.random() - 0.5) * this.config.randomness;
            particle.vy += (Math.random() - 0.5) * this.config.randomness;
        } else {
            // Near target, pick new target
            const angle = Math.random() * Math.PI * 2;
            const radius = 100 + Math.random() * 200;
            particle.targetX = centerX + Math.cos(angle) * radius;
            particle.targetY = centerY + Math.sin(angle) * radius;
            
            // Keep within canvas bounds
            particle.targetX = Math.max(this.config.edgeBuffer, 
                              Math.min(canvasWidth - this.config.edgeBuffer, particle.targetX));
            particle.targetY = Math.max(this.config.edgeBuffer, 
                              Math.min(canvasHeight - this.config.edgeBuffer, particle.targetY));
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Edge bouncing with dampening
        if (particle.x <= 0 || particle.x >= canvasWidth) {
            particle.vx *= -0.8;
            particle.x = Math.max(0, Math.min(canvasWidth, particle.x));
            // Pick new target after bounce
            particle.targetX = centerX + (Math.random() - 0.5) * 300;
        }
        if (particle.y <= 0 || particle.y >= canvasHeight) {
            particle.vy *= -0.8;
            particle.y = Math.max(0, Math.min(canvasHeight, particle.y));
            // Pick new target after bounce
            particle.targetY = centerY + (Math.random() - 0.5) * 300;
        }
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ VISUAL CHARACTERISTICS
    // └─────────────────────────────────────────────────────────────────────────────────
    visuals: {
        trailLength: 'medium',      // Medium trail for motion clarity
        opacity: 0.9,               // High opacity for focus
        sizeMultiplier: 1.0,        // Standard size
        blurAmount: 0.2             // Sharp, focused appearance
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fizzy Particle Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Fizzy behavior - bubbly, effervescent particle movement
 * @author Emotive Engine Team
 * @module particles/behaviors/fizzy
 */

/**
 * FIZZY BEHAVIOR - BUBBLY EFFERVESCENCE
 * Used by: excited emotion
 * 
 * Particles bubble upward with random pops and fizz, like carbonation in soda.
 * Creates an energetic, celebratory atmosphere.
 */
var fizzy = {
    name: 'fizzy',
    emoji: '🫧',
    description: 'Bubbly, effervescent movement like carbonation',
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ CONFIGURATION
    // └─────────────────────────────────────────────────────────────────────────────────
    config: {
        baseRiseSpeed: 2.5,      // Base upward velocity
        wobbleAmplitude: 30,     // Horizontal wobble range
        wobbleFrequency: 0.15,   // Wobble oscillation speed
        popChance: 0.002,        // Chance to "pop" per frame
        popForce: 8,             // Force of pop burst
        fizziness: 0.3,          // Random velocity variation
        gravity: -0.05           // Slight upward bias
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ INITIALIZATION
    // └─────────────────────────────────────────────────────────────────────────────────
    initialize(particle, centerX, centerY, canvasWidth, canvasHeight) {
        // Start with upward velocity
        particle.vx = (Math.random() - 0.5) * 2;
        particle.vy = -this.config.baseRiseSpeed - Math.random() * 2;
        
        // Fizzy properties
        particle.wobblePhase = Math.random() * Math.PI * 2;
        particle.wobbleSpeed = this.config.wobbleFrequency * (0.8 + Math.random() * 0.4);
        particle.bubbleSize = 0.5 + Math.random() * 0.5;
        particle.popTimer = 0;
        particle.isFizzing = true;
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ UPDATE LOOP
    // └─────────────────────────────────────────────────────────────────────────────────
    update(particle, dt, centerX, centerY, canvasWidth, canvasHeight) {
        // Update wobble phase
        particle.wobblePhase += particle.wobbleSpeed * dt;
        
        // Apply wobble to horizontal movement
        const wobble = Math.sin(particle.wobblePhase) * this.config.wobbleAmplitude;
        particle.vx = wobble * 0.05 + (Math.random() - 0.5) * this.config.fizziness;
        
        // Apply upward force with variation
        particle.vy += this.config.gravity * dt;
        particle.vy += (Math.random() - 0.5) * this.config.fizziness;
        
        // Random "pop" events
        if (Math.random() < this.config.popChance) {
            // Pop! Send particle in random direction
            const popAngle = Math.random() * Math.PI * 2;
            particle.vx = Math.cos(popAngle) * this.config.popForce;
            particle.vy = Math.sin(popAngle) * this.config.popForce * 0.7; // Slightly favor horizontal
            particle.popTimer = 1; // Visual feedback timer
            
            // Resize on pop
            particle.bubbleSize = 0.3 + Math.random() * 0.7;
        }
        
        // Decay pop effect
        if (particle.popTimer > 0) {
            particle.popTimer -= dt * 0.05;
            // Slow down after pop
            particle.vx *= 0.95;
            particle.vy *= 0.95;
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Wrap around vertically (bubbles rise and restart)
        if (particle.y < -50) {
            particle.y = canvasHeight + 50;
            particle.x = centerX + (Math.random() - 0.5) * 300;
            particle.vy = -this.config.baseRiseSpeed - Math.random() * 2;
            particle.bubbleSize = 0.5 + Math.random() * 0.5;
        }
        
        // Horizontal bounds with soft bounce
        if (particle.x <= 0 || particle.x >= canvasWidth) {
            particle.vx *= -0.5;
            particle.x = Math.max(0, Math.min(canvasWidth, particle.x));
        }
        
        // Bottom boundary (bubbles can spawn from bottom)
        if (particle.y > canvasHeight + 50) {
            particle.y = canvasHeight;
            particle.vy = -this.config.baseRiseSpeed * 1.5;
        }
        
        // Update size based on bubble properties
        particle.size = particle.baseSize * particle.bubbleSize * 
                       (1 + Math.sin(particle.wobblePhase * 2) * 0.1);
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ VISUAL CHARACTERISTICS
    // └─────────────────────────────────────────────────────────────────────────────────
    visuals: {
        trailLength: 'short',       // Short trails for bubbly feel
        opacity: 0.6,               // Semi-transparent like bubbles
        sizeMultiplier: 1.2,        // Slightly larger for bubble effect
        blurAmount: 0.5,            // Soft, bubble-like appearance
        sparkle: true               // Occasional sparkle effect
    }
};

/**
 * Calm Particle Behavior
 * Particles drift peacefully with minimal, smooth movement
 */


// Behavior configuration
const config = {
    breathingPeriod: 8000};

/**
 * Initialize a particle with calm properties
 * @param {Object} particle - The particle to initialize
 */
function initializeCalm(particle) {
    // Start with faster initial burst movement
    particle.vx = (Math.random() - 0.5) * 0.5;  // Increased 5x from 0.1
    particle.vy = (Math.random() - 0.5) * 0.5;  // Increased 5x from 0.1
    particle.lifeDecay = 0.003;  // Moderate fade (particles last ~5-6 seconds)

    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }

    // Calm-specific behavior data
    particle.behaviorData = {
        orbitAngle: Math.random() * Math.PI * 2,  // Starting angle around center
        orbitRadius: 40 + Math.random() * 60,      // Distance from center (40-100 pixels)
        orbitSpeed: 0.0008 + Math.random() * 0.0006, // Faster orbit speed (4x)
        floatOffset: Math.random() * Math.PI * 2,
        breathingOffset: Math.random() * Math.PI * 2,
        lifetime: 0
    };
}

/**
 * Update calm behavior each frame
 * @param {Object} particle - The particle to update
 * @param {number} dt - Delta time
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 */
function updateCalm(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    if (!data) return;

    data.lifetime += dt;

    // Breathing effect (very subtle size change)
    const breathPhase = (data.lifetime + data.breathingOffset * config.breathingPeriod) / config.breathingPeriod;
    const breathIntensity = Math.sin(breathPhase * Math.PI * 2) * 0.5 + 0.5;

    // Apply subtle size pulsing
    particle.size = particle.baseSize * (0.95 + breathIntensity * 0.05);

    // Slow orbital movement around the mascot
    data.orbitAngle += data.orbitSpeed * dt;

    // Vary the orbit radius slightly over time for organic movement
    const radiusVariation = Math.sin(data.lifetime * 0.0001 + data.floatOffset) * 10;
    const currentRadius = data.orbitRadius + radiusVariation;

    // Calculate target position in orbit
    const targetX = centerX + Math.cos(data.orbitAngle) * currentRadius;
    const targetY = centerY + Math.sin(data.orbitAngle) * currentRadius;

    // Add vertical floating motion
    const floatY = Math.sin(data.lifetime * 0.0003 + data.breathingOffset) * 15;

    // Smoothly move toward orbital position
    const dx = targetX - particle.x;
    const dy = (targetY + floatY) - particle.y;

    // Faster movement toward target position
    particle.vx = dx * 0.03;  // Faster following (3x)
    particle.vy = dy * 0.03;  // Faster following (3x)

    // Add more random drift for organic feel
    particle.vx += (Math.random() - 0.5) * 0.02;  // More drift
    particle.vy += (Math.random() - 0.5) * 0.02;  // More drift

    // Apply very light friction
    particle.vx *= 0.98;
    particle.vy *= 0.98;
}

// Export behavior definition for registry
var zen = {
    name: 'zen',
    emoji: '☯️',
    description: 'Peaceful orbital movement like a hovering aura',
    initialize: initializeCalm,
    update: updateCalm
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Plugin Behavior Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Adapter for plugin-defined particle behaviors
 * @author Emotive Engine Team
 * @module particles/behaviors/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Bridges the gap between the plugin system and modular particle behaviors.         
 * ║ Allows plugins to register custom particle behaviors that integrate seamlessly    
 * ║ with the modular particle system.                                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// Registry for plugin-defined behaviors
const pluginBehaviors = new Map();

/**
 * Register a custom particle behavior from a plugin
 * @param {string} name - Unique name for the behavior
 * @param {Object} behaviorDef - Behavior definition object
 * @returns {boolean} Success status
 */
function registerPluginBehavior(name, behaviorDef) {
    if (pluginBehaviors.has(name)) ;
    
    // Validate behavior definition
    if (!behaviorDef.initialize || typeof behaviorDef.initialize !== 'function') {
        return false;
    }
    
    if (!behaviorDef.update || typeof behaviorDef.update !== 'function') {
        return false;
    }
    
    // Store the behavior
    pluginBehaviors.set(name, {
        name,
        emoji: behaviorDef.emoji || '🔌',
        description: behaviorDef.description || `Plugin behavior: ${name}`,
        initialize: behaviorDef.initialize,
        update: behaviorDef.update,
        isPlugin: true
    });
    
    return true;
}

/**
 * Unregister a plugin behavior
 * @param {string} name - Name of the behavior to remove
 * @returns {boolean} Success status
 */
function unregisterPluginBehavior(name) {
    if (pluginBehaviors.has(name)) {
        pluginBehaviors.delete(name);
        return true;
    }
    return false;
}

/**
 * Get a plugin behavior by name
 * @param {string} name - Name of the behavior
 * @returns {Object|null} Behavior definition or null
 */
function getPluginBehavior(name) {
    return pluginBehaviors.get(name) || null;
}

/**
 * Get all registered plugin behaviors
 * @returns {Array} Array of behavior names
 */
function getAllPluginBehaviors() {
    return Array.from(pluginBehaviors.keys());
}

/**
 * Create a behavior wrapper for legacy plugin particle effects
 * Converts old-style particle definitions to modular behavior format
 * @param {Object} legacyBehavior - Legacy behavior configuration
 * @returns {Object} Modular behavior definition
 */
function createLegacyAdapter$1(legacyBehavior) {
    return {
        name: legacyBehavior.name || 'legacy',
        emoji: '🔄',
        description: legacyBehavior.description || 'Legacy plugin behavior',
        
        initialize: function(particle) {
            // Apply legacy configuration
            if (legacyBehavior.size) {
                particle.size = typeof legacyBehavior.size === 'object' ?
                    legacyBehavior.size.min + Math.random() * (legacyBehavior.size.max - legacyBehavior.size.min) :
                    legacyBehavior.size;
                particle.baseSize = particle.size;
            }
            
            if (legacyBehavior.speed) {
                const speed = typeof legacyBehavior.speed === 'object' ?
                    legacyBehavior.speed.min + Math.random() * (legacyBehavior.speed.max - legacyBehavior.speed.min) :
                    legacyBehavior.speed;
                const angle = Math.random() * Math.PI * 2;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
            }
            
            if (legacyBehavior.lifespan) {
                const lifespan = typeof legacyBehavior.lifespan === 'object' ?
                    legacyBehavior.lifespan.min + Math.random() * (legacyBehavior.lifespan.max - legacyBehavior.lifespan.min) :
                    legacyBehavior.lifespan;
                particle.lifeDecay = 1000 / lifespan; // Convert ms to decay rate
            }
            
            if (legacyBehavior.color) {
                particle.color = Array.isArray(legacyBehavior.color) ?
                    selectWeightedColor(legacyBehavior.color) :
                    legacyBehavior.color;
            }
            
            if (legacyBehavior.opacity) {
                particle.life = typeof legacyBehavior.opacity === 'object' ?
                    legacyBehavior.opacity.min + Math.random() * (legacyBehavior.opacity.max - legacyBehavior.opacity.min) :
                    legacyBehavior.opacity;
            }
            
            // Store legacy-specific data
            particle.behaviorData = {
                movementType: legacyBehavior.movementType || 'linear',
                turbulence: legacyBehavior.turbulence || 0,
                drift: legacyBehavior.drift || 0,
                acceleration: legacyBehavior.acceleration || 0,
                ...legacyBehavior.customData
            };
        },
        
        update: function(particle, dt, centerX, centerY) {
            const data = particle.behaviorData;
            
            // Apply movement based on type
            switch (data.movementType) {
                case 'wander':
                    // Random wandering
                    particle.vx += (Math.random() - 0.5) * data.turbulence * dt;
                    particle.vy += (Math.random() - 0.5) * data.turbulence * dt;
                    break;
                    
                case 'fall':
                    // Falling with drift
                    particle.vy += 0.1 * dt; // Gravity
                    particle.vx += (Math.random() - 0.5) * data.drift * dt;
                    break;
                    
                case 'rain':
                    // Digital rain effect
                    particle.vy += data.acceleration * dt;
                    break;
                    
                case 'orbit':
                    // Orbital motion
                    const dx = particle.x - centerX;
                    const dy = particle.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        const angle = Math.atan2(dy, dx) + 0.02 * dt;
                        particle.x = centerX + Math.cos(angle) * dist;
                        particle.y = centerY + Math.sin(angle) * dist;
                    }
                    break;
            }
            
            // Call custom update if provided
            if (legacyBehavior.customUpdate) {
                legacyBehavior.customUpdate(particle, dt, centerX, centerY);
            }
        }
    };
}

// Export adapter functions for plugin system integration
var pluginAdapter$1 = {
    registerPluginBehavior,
    unregisterPluginBehavior,
    getPluginBehavior,
    getAllPluginBehaviors,
    createLegacyAdapter: createLegacyAdapter$1
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Behavior Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central registry for all particle behaviors with plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module particles/behaviors
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Control center for particle behaviors with plugin adapter integration.            
 * ║ • Each behavior defines unique particle physics and movement patterns             
 * ║ • Core behaviors loaded synchronously at startup                                  
 * ║ • Plugin behaviors registered dynamically via adapter                             
 * ║ • Value-agnostic design for easy physics tuning                                   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ BEHAVIOR COLLECTION
// └─────────────────────────────────────────────────────────────────────────────────────
const BEHAVIORS = [
    ambient,
    directed,
    fizzy,
    orbiting,
    rising,
    falling,
    popcorn,
    burst$1,
    aggressive,
    scattering,
    repelling,
    connecting,
    resting,
    radiant,
    ascending,
    erratic,
    cautious,
    surveillance,
    glitchy,
    zen
];

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ BEHAVIOR REGISTRY - Fast lookup by name
// └─────────────────────────────────────────────────────────────────────────────────────
const BEHAVIOR_REGISTRY = {};

// Build the registry from the behaviors array - SYNCHRONOUSLY
BEHAVIORS.forEach(behavior => {
    BEHAVIOR_REGISTRY[behavior.name] = behavior;
});

/**
 * Get a behavior by name (checks both core and plugin behaviors)
 * @param {string} name - Behavior name (e.g., 'ambient', 'orbiting')
 * @returns {Object|null} Behavior object or null if not found
 */
function getBehavior(name) {
    // Check core behaviors first
    if (BEHAVIOR_REGISTRY[name]) {
        return BEHAVIOR_REGISTRY[name];
    }
    // Check plugin behaviors
    const pluginBehavior = pluginAdapter$1.getPluginBehavior(name);
    if (pluginBehavior) {
        return pluginBehavior;
    }
    return null;
}

/**
 * Initialize a particle with a specific behavior
 * @param {Particle} particle - The particle to initialize
 * @param {string} behaviorName - Name of the behavior to apply
 * @returns {boolean} True if behavior was found and applied
 */
function initializeBehavior(particle, behaviorName) {
    const behavior = getBehavior(behaviorName);
    if (behavior && behavior.initialize) {
        behavior.initialize(particle);
        return true;
    }
    // Fallback to ambient if behavior not found
    if (behaviorName !== 'ambient') {
        return initializeBehavior(particle, 'ambient');
    }
    return false;
}

/**
 * Update a particle's behavior
 * @param {Particle} particle - The particle to update
 * @param {string} behaviorName - Name of the behavior
 * @param {number} dt - Delta time
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 * @returns {boolean} True if behavior was found and updated
 */
function updateBehavior(particle, behaviorName, dt, centerX, centerY) {
    const behavior = getBehavior(behaviorName);
    if (behavior && behavior.update) {
        behavior.update(particle, dt, centerX, centerY);
        return true;
    }
    return false;
}

/**
 * Get list of all available behaviors (core and plugin)
 * @returns {Array} Array of behavior names and descriptions
 */
function listBehaviors() {
    // Get core behaviors
    const coreBehaviors = Object.values(BEHAVIOR_REGISTRY).map(behavior => ({
        name: behavior.name,
        emoji: behavior.emoji || '🎯',
        description: behavior.description || 'No description',
        type: 'core'
    }));
    
    // Get plugin behaviors
    const pluginBehaviorNames = pluginAdapter$1.getAllPluginBehaviors();
    const pluginBehaviors = pluginBehaviorNames.map(name => {
        const behavior = pluginAdapter$1.getPluginBehavior(name);
        return {
            name: behavior.name,
            emoji: behavior.emoji || '🔌',
            description: behavior.description || 'Plugin behavior',
            type: 'plugin'
        };
    });
    
    return [...coreBehaviors, ...pluginBehaviors];
}

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ DEBUG UTILITIES
// └─────────────────────────────────────────────────────────────────────────────────────
if (typeof window !== 'undefined' && window.DEBUG_PARTICLES) {
    window.ParticleBehaviors = {
        registry: BEHAVIOR_REGISTRY,
        list: listBehaviors,
        get: getBehavior
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Gesture Plugin Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bridge between plugin system and gesture registry
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module gestures/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Adapter for dynamic gesture registration from plugins.                            
 * ║ • Maintains separate registry for plugin gestures                                 
 * ║ • Validates gesture definitions for required apply() function                     
 * ║ • Provides legacy format conversion for older plugins                             
 * ║ • Enables runtime registration and unregistration                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Plugin gesture registry
 */
const pluginGestures = new Map();

/**
 * Register a plugin gesture
 * @param {string} name - Gesture name
 * @param {Object} gestureDef - Gesture definition object
 */
function registerPluginGesture(name, gestureDef) {
    // Ensure gesture has required properties
    if (!gestureDef.apply && !gestureDef.type) {
        return false;
    }
    
    // Add name if not present
    if (!gestureDef.name) {
        gestureDef.name = name;
    }
    
    // Set default type if not specified
    if (!gestureDef.type) {
        gestureDef.type = 'blending';
    }
    
    pluginGestures.set(name, gestureDef);
    
    return true;
}

/**
 * Unregister a plugin gesture
 * @param {string} name - Gesture name to remove
 */
function unregisterPluginGesture(name) {
    if (pluginGestures.has(name)) {
        pluginGestures.delete(name);
        
        return true;
    }
    return false;
}

/**
 * Get a plugin gesture by name
 * @param {string} name - Gesture name
 * @returns {Object|null} Gesture object or null if not found
 */
function getPluginGesture(name) {
    return pluginGestures.get(name) || null;
}

/**
 * Get all plugin gesture names
 * @returns {Array<string>} Array of gesture names
 */
function getAllPluginGestures() {
    return Array.from(pluginGestures.keys());
}

/**
 * Clear all plugin gestures
 */
function clearPluginGestures() {
    pluginGestures.clear();
}

/**
 * Convert legacy plugin gesture format to new format
 * @param {Object} legacyGesture - Old format gesture
 * @returns {Object} New format gesture
 */
function createLegacyAdapter(legacyGesture) {
    return {
        name: legacyGesture.name || 'unknown',
        type: legacyGesture.type || 'blending',
        emoji: legacyGesture.emoji || '🔌',
        description: legacyGesture.description || 'Plugin gesture',
        config: legacyGesture.config || {},
        
        apply: function(particle, progress, motion, dt, centerX, centerY) {
            // Adapt old plugin format to new format
            if (legacyGesture.animate) {
                // Old plugins might use 'animate' instead of 'apply'
                legacyGesture.animate(particle, progress, motion, dt, centerX, centerY);
            } else if (legacyGesture.apply) {
                legacyGesture.apply(particle, progress, motion, dt, centerX, centerY);
            }
        },
        
        cleanup: legacyGesture.cleanup || function(particle) {
            // Default cleanup
            if (particle.gestureData && particle.gestureData[this.name]) {
                delete particle.gestureData[this.name];
            }
        }
    };
}

// Export adapter interface
var pluginAdapter = {
    registerPluginGesture,
    unregisterPluginGesture,
    getPluginGesture,
    getAllPluginGestures,
    clearPluginGestures,
    createLegacyAdapter
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Bounce Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bounce gesture - vertical oscillation motion
 * @author Emotive Engine Team
 * @module gestures/motions/bounce
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a bouncing motion with particles oscillating vertically.                  
 * ║ This is a BLENDING gesture that adds to existing particle motion.                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑
 *       ⭐      <- peak
 *      ↗ ↘
 *     ↗   ↘
 *    ⭐     ⭐   <- midpoint
 *   ↗       ↘
 *  ↗         ↘
 * ⭐           ⭐ <- trough
 * 
 * USED BY:
 * - Joy emotions (playful bouncing)
 * - Excited states (energetic movement)
 * - Celebration gestures
 */

/**
 * Bounce gesture configuration and implementation
 */
var bounce = {
    name: 'bounce',
    emoji: '⬆️',
    type: 'blending', // Adds to existing motion
    description: 'Vertical oscillation with smooth easing',
    
    // Default configuration
    config: {
        duration: 800,      // Legacy fallback
        musicalDuration: { musical: true, beats: 2 }, // 2 beats
        amplitude: 30,      // Bounce height range
        frequency: 2,       // Number of oscillations
        axis: 'vertical',   // Movement axis: 'vertical' or 'horizontal'
        damping: true,      // Enable amplitude reduction over time
        easing: 'sine',     // Animation curve type
        strength: 0.6,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'bounce',
            axis: 'vertical',   // Oscillation direction
            strength: 0.6,      // Particle bounce strength
            frequency: 2        // Particle oscillation count
        }
    },
    
    // Rhythm configuration - bounce syncs perfectly to beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Each bounce lands on a beat
        timingSync: 'nextBeat',     // Start on next beat
        interruptible: true,         // Can interrupt mid-bounce
        priority: 3,                 // Lower priority
        blendable: true,             // Can blend with other effects
        crossfadePoint: 'anyBeat',   // Can transition out on any beat
        
        // Bounce height syncs to beat intensity
        amplitudeSync: {
            onBeat: 1.8,      // Higher bounce on beat
            offBeat: 0.6,     // Lower between beats
            curve: 'bounce'   // Natural bounce curve
        },
        
        // Frequency can sync to tempo
        frequencySync: {
            mode: 'tempo',    // Bounces per beat scale with BPM
            multiplier: 1.0   // 1 bounce per beat
        },
        
        // Duration syncs to musical time
        durationSync: {
            mode: 'beats',    // Duration in beats
            beats: 4          // Bounce for 4 beats (1 bar in 4/4)
        },
        
        // Accent response for stronger downbeats
        accentResponse: {
            enabled: true,
            multiplier: 1.5   // 50% higher on accented beats
        },
        
        // Pattern-specific bouncing styles
        patternOverrides: {
            'waltz': {
                // 3/4 time creates elegant triple bounce
                frequencySync: { multiplier: 0.75 },
                durationSync: { beats: 3 }
            },
            'swing': {
                // Jazzy swing bounce with syncopation
                amplitudeSync: { onBeat: 2.0, offBeat: 0.4, curve: 'ease' }
            },
            'dubstep': {
                // Heavy drop on beat 3
                amplitudeSync: { 
                    onBeat: 1.5,
                    dropBeat: 3.0,  // Massive bounce on the drop
                    curve: 'pulse'
                }
            },
            'breakbeat': {
                // Chaotic broken rhythm bouncing
                frequencySync: { multiplier: 1.5 },
                amplitudeSync: { onBeat: 2.2, offBeat: 0.3 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * Called once when gesture starts
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize: function(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.bounce = {
            startY: particle.y,
            startX: particle.x,
            startVx: particle.vx,
            startVy: particle.vy,
            initialized: true
        };
    },
    
    /**
     * Apply bounce motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.bounce?.initialized) {
            this.initialize(particle, motion);
        }
        
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutCubic(progress);
        
        // Calculate oscillation
        let frequency = config.frequency;
        const phase = motion.phase || 0;
        
        // Apply rhythm modulation if present
        let amplitude = config.amplitude * strength * particle.scaleFactor;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            // Frequency modulation for tempo sync
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const oscillation = Math.sin((easeProgress + phase) * Math.PI * 2 * frequency);
        if (config.damping && progress > 0.7) {
            // Reduce amplitude toward end of animation
            const dampProgress = (progress - 0.7) / 0.3;
            amplitude *= (1 - dampProgress * 0.8);
        }
        
        // Apply motion based on axis
        if (config.axis === 'vertical') {
            particle.vy += oscillation * amplitude * 0.01 * dt;
            
            // Dampen horizontal movement slightly for stability
            if (progress > 0.9) {
                particle.vx *= 0.98;
            }
        } else if (config.axis === 'horizontal') {
            particle.vx += oscillation * amplitude * 0.01 * dt;
            
            // Dampen vertical movement slightly for stability
            if (progress > 0.9) {
                particle.vy *= 0.98;
            }
        }
        
        // Smooth ending - gradually reduce velocity modifications
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vx = particle.vx * (0.95 + endFactor * 0.05);
            particle.vy = particle.vy * (0.95 + endFactor * 0.05);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.bounce) {
            delete particle.gestureData.bounce;
        }
    },
    
    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic: function(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Pulse Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Pulse gesture - radial expansion and contraction
 * @author Emotive Engine Team
 * @module gestures/motions/pulse
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a breathing/heartbeat effect with particles expanding and contracting      
 * ║ radially from the center. This is a BLENDING gesture that modifies positions.     
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Expand          Contract         Expand
 *    ← · · · →         → ⭐ ←         ← · · · →
 *    ↖ · · ↗           ↘ ↓ ↙           ↖ · · ↗
 *    · · ⭐ · ·   →    · ⭐ ·     →   · · ⭐ · ·
 *    ↙ · · ↘           ↗ ↑ ↖           ↙ · · ↘
 *    ← · · · →         → ⭐ ←         ← · · · →
 * 
 * USED BY:
 * - Love emotions (heartbeat rhythm)
 * - Breathing/calm states
 * - Emphasis gestures
 */

/**
 * Pulse gesture configuration and implementation
 */
var pulse = {
    name: 'pulse',
    emoji: '💗',
    type: 'blending', // Adds to existing motion
    description: 'Radial expansion and contraction from center',
    
    // Default configuration
    config: {
        duration: 600,      // Animation duration
        amplitude: 30,      // Expansion distance
        frequency: 1,       // Number of pulses
        holdPeak: 0.1,      // Peak expansion hold time
        easing: 'sine',     // Animation curve type
        scaleAmount: 0.2,   // Orb scale variation
        glowAmount: 0.3,    // Orb glow intensity change
        strength: 0.15,     // Particle motion strength
        direction: 'outward', // Radial direction
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 0.15,
            direction: 'outward',
            frequency: 1
        }
    },
    
    // Rhythm configuration - pulse as heartbeat synced to music
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Heartbeat on every beat
        
        // Pulse strength syncs to beat
        amplitudeSync: {
            onBeat: 1.6,      // Strong expansion on beat
            offBeat: 0.8,     // Gentle contraction off beat
            curve: 'pulse'    // Sharp attack, gradual release
        },
        
        // Frequency locks to tempo
        frequencySync: {
            mode: 'locked',   // One pulse per beat
            subdivision: 'quarter'  // Pulse on quarter notes
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 1          // One pulse per beat
        },
        
        // Stronger pulse on downbeats
        accentResponse: {
            enabled: true,
            multiplier: 2.0   // Double strength on accent
        },
        
        // Pattern-specific pulse styles
        patternOverrides: {
            'waltz': {
                // Elegant 3/4 heartbeat
                amplitudeSync: { onBeat: 2.0, offBeat: 0.5 },
                durationSync: { beats: 3 }
            },
            'swing': {
                // Syncopated jazz pulse
                amplitudeSync: { onBeat: 1.8, offBeat: 0.6, curve: 'ease' },
                frequencySync: { subdivision: 'swing' }
            },
            'dubstep': {
                // Deep bass pulse on drop
                amplitudeSync: {
                    onBeat: 1.2,
                    dropBeat: 4.0,  // Massive pulse on beat 3
                    curve: 'pulse'
                }
            },
            'breakbeat': {
                // Erratic heartbeat
                frequencySync: { mode: 'random', range: [0.5, 2.0] },
                amplitudeSync: { onBeat: 2.5, offBeat: 0.3 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial distance and angle from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        particle.gestureData.pulse = {
            baseDistance: distance,
            angle: angle,
            startX: particle.x,
            startY: particle.y,
            initialized: true
        };
    },
    
    /**
     * Apply pulse motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.pulse?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.pulse;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutSine(progress);
        
        // Calculate pulse with optional peak hold
        let pulseValue;
        let frequency = config.frequency;
        let amplitude = config.amplitude;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const rawPulse = (easeProgress * frequency * 2) % 2;
        
        if (config.holdPeak > 0 && rawPulse > (1 - config.holdPeak) && rawPulse < (1 + config.holdPeak)) {
            // Hold at peak
            pulseValue = 1;
        } else {
            // Normal sine wave
            pulseValue = Math.sin(easeProgress * Math.PI * 2 * frequency);
        }
        
        // Calculate expansion amount
        const expansion = pulseValue * amplitude * strength * particle.scaleFactor;
        
        // Calculate target position
        const targetDistance = data.baseDistance + expansion;
        const targetX = centerX + Math.cos(data.angle) * targetDistance;
        const targetY = centerY + Math.sin(data.angle) * targetDistance;
        
        // Smoothly move toward target
        const moveSpeed = 0.15 * dt;
        particle.vx += (targetX - particle.x) * moveSpeed * 0.1;
        particle.vy += (targetY - particle.y) * moveSpeed * 0.1;
        
        // Fade effect at the end
        if (progress > 0.9) {
            const fadeFactor = 1 - ((progress - 0.9) * 10);
            particle.vx *= (0.9 + fadeFactor * 0.1);
            particle.vy *= (0.9 + fadeFactor * 0.1);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.pulse) {
            delete particle.gestureData.pulse;
        }
    },
    
    /**
     * Sine easing for smooth breathing motion
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine: function(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Shake Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Shake gesture - random jitter motion
 * @author Emotive Engine Team
 * @module gestures/motions/shake
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a shaking/vibrating effect with random jitter. Perfect for expressing     
 * ║ nervousness, excitement, or impact effects. This is a BLENDING gesture.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Frame 1        Frame 2        Frame 3
 *        ⭐      →    ⭐       →      ⭐
 *       ↙↗↘↖         ↖↘↗↙          ↗↖↙↘
 *    (random)      (random)       (random)
 * 
 * USED BY:
 * - Nervous/anxious states
 * - Anger (trembling with rage)
 * - Cold/shivering effects
 * - Impact reactions
 */

/**
 * Shake gesture configuration and implementation
 */
var shake = {
    name: 'shake',
    emoji: '🫨',
    type: 'blending', // Adds to existing motion
    description: 'Random jitter movement for vibration effects',
    
    // Default configuration
    config: {
        duration: 400,      // Animation duration
        amplitude: 15,      // Shake movement range
        frequency: 15,      // Oscillation speed
        decay: 0.9,         // Intensity reduction over time
        smoothing: 0.1,     // Motion smoothness factor
        axes: 'both',       // Affected axes: 'both', 'horizontal', 'vertical'
        easing: 'linear',   // Animation curve type
        strength: 3.0,      // Overall shake intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'shake',
            strength: 3.0,      // Particle shake strength
            frequency: 15,      // Particle oscillation rate
            decay: false        // Maintain consistent intensity
        }
    },
    
    // Rhythm configuration - shake intensifies with tempo
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',  // Shake on subdivisions
        
        // Shake intensity modulation
        amplitudeSync: {
            subdivision: 'sixteenth',  // Shake on 16th notes
            onBeat: 2.5,              // Violent shake on beat
            offBeat: 0.7,             // Gentler between beats
            curve: 'pulse'            // Sharp attack
        },
        
        // Frequency scales with tempo
        frequencySync: {
            mode: 'tempo',
            baseFrequency: 15,        // Base at 120 BPM
            scaling: 'linear'         // Linear scaling with BPM
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 2                  // Shake for 2 beats
        },
        
        // Pattern-specific shake styles
        patternOverrides: {
            'breakbeat': {
                // Chaotic broken shake
                amplitudeSync: { onBeat: 3.0, offBeat: 0.2 },
                frequencySync: { mode: 'random', range: [8, 20] }
            },
            'dubstep': {
                // Bass wobble shake
                amplitudeSync: {
                    subdivision: 'eighth',
                    onBeat: 4.0,
                    dropBeat: 6.0,  // Massive shake on drop
                    curve: 'pulse'
                }
            },
            'swing': {
                // Jazzy shimmy shake
                amplitudeSync: { onBeat: 1.8, offBeat: 1.0, curve: 'ease' }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize: function(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.shake = {
            originalX: particle.x,  // Store original position
            originalY: particle.y,  // Store original position
            randomAngle: Math.random() * Math.PI * 2, // Random shake direction per particle
            initialized: true
        };
    },
    
    /**
     * Apply shake motion to particle
     * Creates synchronized vibration effect matching orb shake
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.shake?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.shake;
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply rhythm modulation if present
        let amplitude = config.amplitude;
        let frequency = config.frequency;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        // Match orb shake logic for synchronized movement
        // Apply decay if enabled to reduce intensity over time
        const decay = config.decay ? (1 - progress) : 1;
        const shake = Math.sin(progress * Math.PI * frequency) * amplitude * decay * strength * particle.scaleFactor;
        
        // Calculate directional offset using particle's random angle
        const offsetX = shake * Math.cos(data.randomAngle);
        const offsetY = shake * Math.sin(data.randomAngle);
        
        // Set particle position directly for perfect synchronization
        // Particles shake in unison with the orb
        particle.x = data.originalX + offsetX;
        particle.y = data.originalY + offsetY;
    },
    
    /**
     * Generate pseudo-random number from seed
     * @param {number} seed - Seed value
     * @returns {number} Pseudo-random value between 0 and 1
     */
    pseudoRandom: function(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.shake) {
            // Restore original position
            particle.x = particle.gestureData.shake.originalX;
            particle.y = particle.gestureData.shake.originalY;
            delete particle.gestureData.shake;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Nod Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Nod gesture - vertical agreement motion
 * @author Emotive Engine Team
 * @module gestures/motions/nod
 */

var nod = {
    name: 'nod',
    emoji: '🙂',
    type: 'blending',
    description: 'Vertical nodding motion',
    
    // Default configuration
    config: {
        duration: 500,      // Animation duration
        amplitude: 15,      // Vertical movement range
        frequency: 2,       // Number of nod cycles
        easing: 'sine',     // Animation curve type
        strength: 0.4,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'bounce',
            axis: 'vertical',   // Movement direction
            strength: 0.4,      // Particle nod strength
            frequency: 2,       // Particle nod count
            phase: 0           // Synchronization with orb
        }
    },
    
    // Rhythm configuration - nod as agreement to the beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',     // Wait for next beat to start
        interruptible: false,        // Must complete the nod
        priority: 5,                 // Medium priority
        blendable: false,            // Don't blend with other motions
        minDuration: 'halfBar',      // Minimum time before interrupt
        
        // Nod frequency locks to beat
        frequencySync: {
            mode: 'subdivision',
            subdivision: 'half',  // Nod on half notes
            multiplier: 1.0
        },
        
        // Amplitude stronger on downbeats
        amplitudeSync: {
            onBeat: 1.4,
            offBeat: 0.8,
            curve: 'ease'
        },
        
        // Duration in beats
        durationSync: {
            mode: 'beats',
            beats: 2  // Nod for 2 beats
        },
        
        // Pattern-specific nodding
        patternOverrides: {
            'waltz': {
                // Graceful 3/4 nod
                frequencySync: { subdivision: 'quarter' },
                amplitudeSync: { onBeat: 1.6, curve: 'ease' }
            },
            'swing': {
                // Jazzy syncopated nod
                amplitudeSync: { onBeat: 1.5, offBeat: 0.9 }
            },
            'dubstep': {
                // Heavy head-bang on drop
                amplitudeSync: {
                    onBeat: 1.2,
                    dropBeat: 3.0,
                    curve: 'pulse'
                }
            }
        }
    },
    
    initialize: function(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.nod = {
            startY: particle.y,
            initialized: true
        };
    },
    
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.nod?.initialized) {
            this.initialize(particle, motion);
        }
        
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        let frequency = config.frequency;
        let amplitude = config.amplitude;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const oscillation = Math.sin(progress * Math.PI * 2 * frequency);
        amplitude = amplitude * strength * particle.scaleFactor;
        
        // Apply vertical nodding motion
        particle.vy += oscillation * amplitude * 0.01 * dt;
        
        // Dampen at the end
        if (progress > 0.9) {
            particle.vy *= 0.95;
        }
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.nod) {
            delete particle.gestureData.nod;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Vibrate Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Vibrate gesture - high frequency micro-shake
 * @author Emotive Engine Team
 * @module gestures/motions/vibrate
 */

var vibrate = {
    name: 'vibrate',
    emoji: '📳',
    type: 'blending',
    description: 'High frequency vibration',
    
    // Default configuration
    config: {
        duration: 500,      // Animation duration
        frequency: 20,      // Vibration frequency
        amplitude: 8,       // Vibration amplitude
        easing: 'linear',   // Animation curve type
        strength: 2.0,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'shake',
            strength: 2.0,
            frequency: 20,
            amplitude: 8
        }
    },
    
    // Rhythm configuration - vibrate as tremolo effect
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',
        
        // Vibration frequency syncs to tempo
        frequencySync: {
            subdivision: 'thirty-second',  // Very fast subdivisions
            baseFrequency: 20,
            tempoScaling: true  // Scale with BPM
        },
        
        // Amplitude pulses with beat
        amplitudeSync: {
            onBeat: 1.5,
            offBeat: 0.8,
            curve: 'pulse'
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 1  // Vibrate for 1 beat
        },
        
        // Pattern-specific vibration
        patternOverrides: {
            'dubstep': {
                // Bass wobble vibration
                frequencySync: { subdivision: 'sixteenth' },
                amplitudeSync: { onBeat: 2.0, dropBeat: 3.0 }
            },
            'breakbeat': {
                // Chaotic vibration
                frequencySync: { mode: 'random', range: [15, 30] }
            }
        }
    },
    
    initialize: function(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.vibrate = {
            timer: 0,
            seed: Math.random() * 1000,
            initialized: true
        };
    },
    
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.vibrate?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.vibrate;
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply rhythm modulation if present
        let amplitude = config.amplitude;
        let frequency = config.frequency;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        // Update timer
        data.timer += dt * frequency;
        
        // High frequency vibration
        const vibrateX = (Math.random() - 0.5) * amplitude * strength;
        const vibrateY = (Math.random() - 0.5) * amplitude * strength;
        
        // Apply rapid vibration movements
        particle.vx += vibrateX * 0.5 * dt;
        particle.vy += vibrateY * 0.5 * dt;
        
        // Apply damping for control
        particle.vx *= 0.9;
        particle.vy *= 0.9;
        
        // Fade out at the end
        if (progress > 0.8) {
            const fadeFactor = 1 - ((progress - 0.8) * 5);
            particle.vx *= fadeFactor;
            particle.vy *= fadeFactor;
        }
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.vibrate) {
            delete particle.gestureData.vibrate;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbit Gesture Motion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview 3D orbital motion where particles circle around the orb
 * @author Emotive Engine Team
 * @module gestures/motions/orbit
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a mesmerizing 3D orbit effect where particles circle around the orb,      
 * ║ dynamically transitioning between foreground and background layers using the      
 * ║ z-coordinate system. Like planets orbiting a star or a hula-hoop in motion.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM (Top View):
 *     · → · → ·
 *   ↓           ↑
 *   ·    ⭐    ·   ← particles orbit around center
 *   ↑           ↓  
 *     · ← · ← ·
 * 
 * VISUAL DIAGRAM (Side View):
 *   front  ·····   back
 *         /     \
 *        ·   ⭐  ·  ← z-coordinate changes as particles orbit
 *         \     /
 *   back   ·····   front
 */

/**
 * Apply orbital motion to a particle
 * Particles orbit around the center with dynamic z-depth changes
 * 
 * @param {Object} particle - The particle to animate
 * @param {Object} gestureData - Persistent data for this particle's gesture
 * @param {Object} config - Gesture configuration
 * @param {number} progress - Gesture progress (0-1)
 * @param {number} strength - Gesture strength multiplier
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 */
function applyOrbit(particle, gestureData, config, progress, strength, centerX, centerY) {
    // Initialize gesture data if needed
    if (!gestureData.initialized) {
        // Store original position and velocity
        gestureData.originalX = particle.x;
        gestureData.originalY = particle.y;
        gestureData.originalZ = particle.z || 0;
        gestureData.originalVx = particle.vx || 0;
        gestureData.originalVy = particle.vy || 0;
        
        // Calculate initial angle and radius from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        gestureData.radius = Math.sqrt(dx * dx + dy * dy);
        
        // Ensure minimum radius to prevent clustering at center
        if (gestureData.radius < 50) {
            gestureData.radius = 50 + Math.random() * 100;
        }
        
        gestureData.initialAngle = Math.atan2(dy, dx);
        
        // Random orbit parameters for variety
        gestureData.orbitSpeed = config.speed * (0.8 + Math.random() * 0.4); // Speed variation
        gestureData.orbitTilt = Math.random() * 0.3; // Slight tilt for realism
        
        gestureData.initialized = true;
    }
    
    // Apply rhythm modulation if present
    let rotations = config.rotations;
    let radiusPulseAmount = 0.05;
    if (config.rhythmModulation) {
        if (config.rhythmModulation.speedMultiplier) {
            gestureData.orbitSpeed *= config.rhythmModulation.speedMultiplier;
        }
        if (config.rhythmModulation.rotationMultiplier) {
            rotations *= config.rhythmModulation.rotationMultiplier;
        }
        if (config.rhythmModulation.radiusPulse) {
            radiusPulseAmount = config.rhythmModulation.radiusPulse;
        }
    }
    
    // Smooth entry/exit transitions
    let transitionFactor = 1.0;
    let velocityTransition = 1.0;
    
    if (progress < 0.15) {
        // Smooth entry (first 15%)
        transitionFactor = progress / 0.15;
        transitionFactor = transitionFactor * transitionFactor * (3 - 2 * transitionFactor); // Smooth step
        velocityTransition = transitionFactor;
    } else if (progress > 0.85) {
        // Smooth exit (last 15%)
        transitionFactor = (1 - progress) / 0.15;
        transitionFactor = transitionFactor * transitionFactor * (3 - 2 * transitionFactor); // Smooth step
        velocityTransition = transitionFactor;
    }
    
    // Calculate current angle based on progress with smooth acceleration
    const angle = gestureData.initialAngle + (progress * Math.PI * 2 * rotations * transitionFactor);
    
    // Calculate orbital radius (can pulse slightly) with transition
    const radiusPulse = 1 + Math.sin(progress * Math.PI * 4) * radiusPulseAmount * transitionFactor;
    const currentRadius = gestureData.radius * strength * radiusPulse * transitionFactor;
    
    // Calculate new position in orbit
    const targetX = centerX + Math.cos(angle) * currentRadius;
    const targetY = centerY + Math.sin(angle) * currentRadius;
    
    // CRITICAL: Update z-coordinate for 3D effect with smooth transition
    // Particles in front (positive z) when at top of orbit, behind (negative z) at bottom
    const zAngle = angle * config.zRotations; // Can rotate in z-plane at different rate
    particle.z = Math.sin(zAngle) * 0.8 * transitionFactor + gestureData.originalZ * (1 - transitionFactor);
    
    // During entry, smoothly transition from original position
    if (progress < 0.15) {
        const entryLerp = transitionFactor * 0.3; // Slower entry
        particle.x = gestureData.originalX + (targetX - gestureData.originalX) * entryLerp;
        particle.y = gestureData.originalY + (targetY - gestureData.originalY) * entryLerp;
        
        // Smooth velocity transition
        const orbitalVx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        const orbitalVy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vx = gestureData.originalVx + (orbitalVx - gestureData.originalVx) * velocityTransition;
        particle.vy = gestureData.originalVy + (orbitalVy - gestureData.originalVy) * velocityTransition;
    } 
    // During exit, smoothly return to original
    else if (progress > 0.85) {
        particle.x = targetX + (gestureData.originalX - targetX) * (1 - transitionFactor);
        particle.y = targetY + (gestureData.originalY - targetY) * (1 - transitionFactor);
        
        // Smooth velocity transition back
        const orbitalVx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        const orbitalVy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vx = orbitalVx * velocityTransition + gestureData.originalVx * (1 - velocityTransition);
        particle.vy = orbitalVy * velocityTransition + gestureData.originalVy * (1 - velocityTransition);
    }
    // Normal orbit
    else {
        // Add vertical oscillation for hula-hoop effect if enabled
        if (config.verticalOscillation > 0) {
            const verticalOffset = Math.sin(angle * 2) * config.verticalOscillation * strength;
            particle.y = targetY + verticalOffset;
            particle.x = targetX;
        } else {
            // Smooth interpolation to target position
            const lerpFactor = config.smoothness || 0.1;
            particle.x += (targetX - particle.x) * lerpFactor;
            particle.y += (targetY - particle.y) * lerpFactor;
        }
        
        // Set orbital velocity
        particle.vx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
    }
    
    // Apply centripetal acContinceleration effect (particles speed up when closer)
    if (config.centripetal) {
        const speed = 1 + (1 - Math.abs(particle.z)) * 0.3; // Speed varies with z-position
        const speedAngle = gestureData.initialAngle + (progress * Math.PI * 2 * config.rotations * speed);
        particle.x = centerX + Math.cos(speedAngle) * currentRadius;
        particle.y = centerY + Math.sin(speedAngle) * currentRadius;
    }
}

// Export gesture configuration
var orbit = {
    name: 'orbit',
    emoji: '🪐',
    description: '3D orbital motion around center',
    type: 'override', // Takes full control of particle position
    
    // Default configuration
    config: {
        speed: 1.0,              // Base orbital speed
        rotations: 1,            // Number of full rotations per gesture
        zRotations: 1,           // Z-plane rotation ratio (1 = same as xy, 2 = twice as fast)
        smoothness: 0.15,        // Position interpolation factor
        verticalOscillation: 0,  // Hula-hoop vertical movement (0 = flat orbit)
        centripetal: false,      // Enable speed variation based on position
    },
    
    // Rhythm configuration - orbital motion syncs to musical cycles
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Complete orbit per bar
        
        // Orbital speed syncs to tempo
        speedSync: {
            mode: 'tempo',
            baseSpeed: 1.0,
            scaling: 'linear'  // Speed scales with BPM
        },
        
        // Rotations per musical period
        rotationSync: {
            mode: 'bars',
            rotationsPerBar: 1,  // One full orbit per bar
            zSync: true  // Z-rotation also syncs
        },
        
        // Radius pulses with beat
        radiusSync: {
            subdivision: 'quarter',
            pulsAmount: 0.1,  // 10% radius variation
            curve: 'ease'
        },
        
        // Pattern-specific orbital styles
        patternOverrides: {
            'waltz': {
                // Elegant 3-step orbit
                rotationSync: { rotationsPerBar: 0.75 },
                radiusSync: { pulsAmount: 0.15 }
            },
            'swing': {
                // Jazzy elliptical orbit
                speedSync: { mode: 'swing', ratio: 0.67 },
                verticalOscillation: 0.2
            },
            'dubstep': {
                // Wobbling orbit with drops
                radiusSync: { 
                    subdivision: 'eighth',
                    pulsAmount: 0.3,
                    dropMultiplier: 2.0
                }
            },
            'breakbeat': {
                // Chaotic orbital patterns
                speedSync: { mode: 'random', range: [0.5, 2.0] },
                centripetal: true
            }
        }
    },
    
    // Apply function
    apply: applyOrbit,
    
    // Supported emotions (great for mystical/energetic states)
    emotions: ['zen', 'love', 'excited', 'surprise'],
    
    // Gesture-specific features
    features: {
        uses3D: true,           // Uses z-coordinate system
        smooth: true,           // Smooth continuous motion
        looping: true,          // Natural looping animation
        dramatic: true          // Visually impressive effect
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Twitch Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Paranoid twitching motion for suspicious/nervous states
 * @author Emotive Engine Team
 * @module gestures/motions/twitch
 * 
 * GESTURE TYPE:
 * type: 'blending' - Adds to existing particle motion
 * 
 * VISUAL EFFECT:
 * Random, sudden jerky movements that blend with existing behavior.
 * Creates a nervous, paranoid feeling with unpredictable micro-movements.
 */

var twitch = {
    name: 'twitch',
    emoji: '⚡',
    type: 'blending',
    description: 'Nervous, paranoid twitching',
    
    // Default configuration
    config: {
        intensity: 8,           // Twitch strength
        frequency: 0.08,        // Chance of twitching per frame
        duration: 100,          // How long each twitch lasts (ms)
        recovery: 200,          // Recovery time between twitches
        maxOffset: 15,          // Maximum twitch distance
        sharpness: 0.9         // How sudden the movements are
    },
    
    // Rhythm configuration - twitch syncs to nervous subdivisions
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',
        
        // Twitch probability increases on beat
        probabilitySync: {
            subdivision: 'sixteenth',
            onBeat: 0.3,        // 30% chance on beat
            offBeat: 0.05,      // 5% chance off beat
            accentBoost: 2.0    // Double on accents
        },
        
        // Intensity follows rhythm
        intensitySync: {
            onBeat: 2.0,
            offBeat: 0.8,
            curve: 'pulse'      // Sharp, sudden
        },
        
        // Pattern-specific twitching
        patternOverrides: {
            'breakbeat': {
                // Erratic broken twitches
                probabilitySync: { onBeat: 0.5, offBeat: 0.1 },
                intensitySync: { onBeat: 3.0, offBeat: 0.5 }
            },
            'dubstep': {
                // Heavy twitch on drop
                intensitySync: {
                    onBeat: 1.5,
                    dropBeat: 5.0,
                    curve: 'pulse'
                }
            }
        }
    },
    
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize twitch data if needed
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        if (!particle.gestureData.twitch) {
            particle.gestureData.twitch = {
                twitchOffset: { x: 0, y: 0 },
                targetOffset: { x: 0, y: 0 },
                isTwitching: false,
                twitchTimer: 0,
                cooldownTimer: 0,
                lastTwitch: 0
            };
        }
        
        const data = particle.gestureData.twitch;
        const config = this.config;
        let intensity = motion.intensity || config.intensity;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            intensity *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            intensity *= (motion.rhythmModulation.accentMultiplier || 1);
        }
        
        // Update timers
        const currentTime = Date.now();
        
        // Check for new twitch
        if (!data.isTwitching && data.cooldownTimer <= 0) {
            if (Math.random() < (motion.frequency || config.frequency)) {
                // Start a new twitch
                data.isTwitching = true;
                data.twitchTimer = config.duration;
                data.cooldownTimer = config.recovery;
                
                // Random twitch direction and distance
                const angle = Math.random() * Math.PI * 2;
                const distance = (config.maxOffset * 0.5) + Math.random() * (config.maxOffset * 0.5);
                
                data.targetOffset = {
                    x: Math.cos(angle) * distance * intensity / 8,
                    y: Math.sin(angle) * distance * intensity / 8
                };
                
                data.lastTwitch = currentTime;
            }
        }
        
        // Update cooldown
        if (data.cooldownTimer > 0) {
            data.cooldownTimer -= dt * 16;
        }
        
        // Apply twitch motion
        if (data.isTwitching) {
            data.twitchTimer -= dt * 16;
            
            if (data.twitchTimer > 0) {
                // Sharp movement toward target
                const sharpness = config.sharpness;
                data.twitchOffset.x += (data.targetOffset.x - data.twitchOffset.x) * sharpness;
                data.twitchOffset.y += (data.targetOffset.y - data.twitchOffset.y) * sharpness;
            } else {
                // Twitch complete, start returning
                data.isTwitching = false;
            }
        } else {
            // Return to normal position
            data.twitchOffset.x *= 0.85;
            data.twitchOffset.y *= 0.85;
        }
        
        // Apply the twitch offset to velocity (blending mode)
        particle.vx += data.twitchOffset.x * dt * 0.5;
        particle.vy += data.twitchOffset.y * dt * 0.5;
        
        // Add micro-jitter for constant nervousness
        if (Math.random() < 0.1) {
            particle.vx += (Math.random() - 0.5) * intensity * 0.3;
            particle.vy += (Math.random() - 0.5) * intensity * 0.3;
        }
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.twitch) {
            delete particle.gestureData.twitch;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sway Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var sway = {
    name: 'sway',
    type: 'blending',
    emoji: '🌊',
    description: 'Gentle side-to-side swaying motion',
    
    config: {
        duration: 2000,
        amplitude: 20,
        frequency: 1,
        strength: 0.5
    },
    
    // Rhythm configuration - sway naturally follows the beat
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Sway completes one cycle per bar
        
        // Amplitude increases on downbeats
        amplitudeSync: {
            onBeat: 1.2,
            offBeat: 0.9,
            curve: 'ease'  // Smooth transitions
        },
        
        // Duration syncs to bars for natural rhythm
        durationSync: {
            mode: 'bars',
            bars: 1  // One full sway per bar
        },
        
        // Pattern-specific swaying
        patternOverrides: {
            'waltz': {
                // 3/4 time creates elegant waltz sway
                durationSync: { bars: 1 },
                amplitudeSync: { onBeat: 1.5, curve: 'ease' }
            },
            'swing': {
                // Jazzy swing sway
                amplitudeSync: { onBeat: 1.3, offBeat: 0.7, curve: 'bounce' }
            }
        }
    },
    
    /**
     * Apply sway motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        const config = { ...this.config, ...motion };
        const amplitude = config.amplitude || this.config.amplitude;
        const frequency = config.frequency || this.config.frequency;
        const strength = config.strength || this.config.strength;
        
        // Smooth side-to-side motion
        const sway = Math.sin(progress * Math.PI * 2 * frequency) * amplitude;
        
        // Apply horizontal sway
        particle.vx += sway * 0.01 * dt * strength;
        
        // Slight vertical drift for natural feel
        particle.vy += Math.cos(progress * Math.PI * 4) * 0.5 * dt * strength;
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        // No cleanup needed for sway
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Float Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var float = {
    name: 'float',
    type: 'blending',
    emoji: '🎈',
    description: 'Gentle floating upward motion',
    
    config: {
        duration: 2000,
        amplitude: 80,  // Increased for more visible effect
        wobbleAmount: 20,  // More wobble
        strength: 1.0  // Full strength
    },
    
    // Rhythm configuration - defines how this gesture responds to musical timing
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // 'beat', 'bar', 'continuous', or 'none'
        
        // How amplitude changes with beat
        amplitudeSync: {
            onBeat: 1.5,      // Multiply amplitude on beat
            offBeat: 0.8,     // Reduce amplitude off beat
            curve: 'bounce'   // Animation curve: 'linear', 'ease', 'bounce', 'pulse'
        },
        
        // How wobble syncs to subdivisions
        wobbleSync: {
            subdivision: 'eighth',  // Sync to 8th notes
            intensity: 0.7          // How much rhythm affects wobble
        },
        
        // Duration can sync to musical time
        durationSync: {
            mode: 'bars',     // Duration in bars instead of milliseconds
            bars: 2           // Float for 2 bars
        },
        
        // Response to musical accents
        accentResponse: {
            enabled: true,
            multiplier: 1.3   // Boost effect on accented beats
        },
        
        // Optional: Different behavior for different patterns
        patternOverrides: {
            'waltz': {
                wobbleSync: { subdivision: 'quarter', intensity: 0.9 }
            },
            'dubstep': {
                amplitudeSync: { onBeat: 2.0, curve: 'pulse' }
            }
        }
    },
    
    /**
     * Apply float motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Store original values on first frame
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        if (!particle.gestureData.float) {
            particle.gestureData.float = {
                originalSize: particle.size,
                originalOpacity: particle.opacity || 1
            };
        }
        
        const config = { ...this.config, ...motion };
        let amplitude = config.amplitude || this.config.amplitude;
        let wobbleAmount = config.wobbleAmount || this.config.wobbleAmount;
        const strength = config.strength || this.config.strength;
        
        // Apply rhythm modulation if present (passed from GestureMotion.js)
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            wobbleAmount *= (motion.rhythmModulation.wobbleMultiplier || 1);
        }
        
        // Upward floating with slight wobble
        const wobble = Math.sin(progress * Math.PI * 4) * wobbleAmount;
        
        // Apply upward force and wobble
        particle.vy -= amplitude * 0.01 * dt * strength * (1 - progress * 0.5);
        particle.vx += wobble * 0.01 * dt * strength;
        
        // Slight size variation for depth effect
        particle.size = particle.baseSize * (1 + progress * 0.1);
        
        // Fade slightly as it floats up
        particle.opacity = 1 - progress * 0.3;
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        // Reset to original values
        if (particle.gestureData?.float) {
            particle.opacity = particle.gestureData.float.originalOpacity;
            particle.size = particle.gestureData.float.originalSize;
            delete particle.gestureData.float;
        } else {
            // Fallback if no data stored
            particle.opacity = 1;
            particle.size = particle.baseSize;
        }
        
        // Dampen velocity to help particle settle
        particle.vx *= 0.5;
        particle.vy *= 0.5;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Jitter Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var jitter = {
    name: 'jitter',
    type: 'blending',
    emoji: '🫨',
    description: 'Nervous jittery movement',
    
    config: {
        duration: 1000,
        intensity: 15,  // Increased for more visible jitter
        frequency: 30,  // Higher frequency
        strength: 1.0  // Full strength
    },
    
    // Rhythm configuration - jitter intensifies on beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        
        // Jitter intensity syncs to beat
        amplitudeSync: {
            onBeat: 2.0,      // Double jitter on beat
            offBeat: 0.5,     // Calmer between beats
            curve: 'pulse'    // Sharp attack
        },
        
        // Different patterns create different nervousness
        patternOverrides: {
            'breakbeat': {
                // Chaotic jitter for breakbeat
                amplitudeSync: { onBeat: 3.0, offBeat: 0.3 }
            },
            'dubstep': {
                // Freeze then explode
                amplitudeSync: { onBeat: 5.0, offBeat: 0.1, curve: 'pulse' }
            }
        }
    },
    
    /**
     * Apply jitter motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Store original values on first frame
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        if (!particle.gestureData.jitter) {
            particle.gestureData.jitter = {
                originalSize: particle.size
            };
        }
        
        const config = { ...this.config, ...motion };
        let intensity = config.intensity || this.config.intensity;
        const strength = config.strength || this.config.strength;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            intensity *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            intensity *= (motion.rhythmModulation.accentMultiplier || 1);
        }
        
        // Random jitter in both directions
        const jitterX = (Math.random() - 0.5) * intensity * strength;
        const jitterY = (Math.random() - 0.5) * intensity * strength;
        
        // Apply jitter with decreasing intensity over time
        const fadeOut = 1 - progress * 0.5;
        particle.vx += jitterX * 0.1 * dt * fadeOut;
        particle.vy += jitterY * 0.1 * dt * fadeOut;
        
        // Slight size variation for nervous effect
        particle.size = particle.baseSize * (1 + (Math.random() - 0.5) * 0.1);
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        // Reset to original values
        if (particle.gestureData?.jitter) {
            particle.size = particle.gestureData.jitter.originalSize;
            delete particle.gestureData.jitter;
        } else {
            particle.size = particle.baseSize;
        }
        
        // Dampen velocity to help particle settle
        particle.vx *= 0.7;
        particle.vy *= 0.7;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Spin Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Spin gesture - orbital rotation around center
 * @author Emotive Engine Team
 * @module gestures/transforms/spin
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a spinning vortex effect with particles orbiting around the center.       
 * ║ This is an OVERRIDE gesture that completely replaces particle motion.             
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↻ Clockwise rotation
 *      · → ·
 *     ↓     ↑
 *    · ← ⭐ → ·
 *     ↑     ↓  
 *      · ← ·
 * 
 * USED BY:
 * - Dizzy/confused states
 * - Celebration spins
 * - Whirlwind effects
 * - Portal/vortex animations
 */

/**
 * Spin gesture configuration and implementation
 */
var spin = {
    name: 'spin',
    emoji: '🌀',
    type: 'override', // Completely replaces motion
    description: 'Orbital rotation around center point',
    
    // Default configuration
    config: {
        duration: 600,          // Legacy fallback
        musicalDuration: { musical: true, beats: 1 }, // 1 beat (quarter note)
        rotations: 1,           // Number of full rotations
        direction: 'random',    // 'clockwise', 'counter-clockwise', or 'random'
        radiusMultiplier: 1.0,  // Orbital radius multiplier
        spiralOut: false,       // Spiral outward while spinning
        accelerate: true,       // Speed up then slow down
        maintainDistance: true, // Keep relative distance from center
        scaleAmount: 0.1,       // Scale change during spin
        easing: 'linear',       // Animation curve type
        strength: 0.7,          // Particle motion strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'spin',
            strength: 0.7,
            rotations: 1,
            radius: 1.0
        }
    },
    
    // Rhythm configuration - spin as a dance move
    rhythm: {
        enabled: true,
        syncMode: 'bar',
        
        // Rotations sync to musical time
        rotationSync: {
            mode: 'bars',
            rotationsPerBar: 1,  // One spin per bar
            accelerateOnBeat: true  // Speed up on downbeats
        },
        
        // Radius changes with beat
        radiusSync: {
            subdivision: 'quarter',
            expandOnBeat: 1.2,
            contractOffBeat: 0.9,
            curve: 'bounce'
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 4  // Spin for 4 beats (1 bar)
        },
        
        // Pattern-specific spins
        patternOverrides: {
            'waltz': {
                // Elegant waltz spin
                rotationSync: { rotationsPerBar: 0.75 },
                radiusSync: { curve: 'ease' }
            },
            'swing': {
                // Jazzy swing spin
                rotationSync: { accelerateOnBeat: false },
                direction: 'alternating'  // Change direction each bar
            },
            'dubstep': {
                // Aggressive spin with wobble
                radiusSync: {
                    subdivision: 'eighth',
                    expandOnBeat: 1.5,
                    dropMultiplier: 2.0
                },
                spiralOut: true
            },
            'breakbeat': {
                // Chaotic spin patterns
                rotationSync: { mode: 'random', range: [0.5, 2] },
                direction: 'random'
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate starting position relative to center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        // Determine spin direction
        let direction = motion.direction || this.config.direction;
        if (direction === 'random') {
            direction = Math.random() < 0.5 ? 'clockwise' : 'counter-clockwise';
        }
        
        particle.gestureData.spin = {
            startAngle: Math.atan2(dy, dx),
            startRadius: Math.sqrt(dx * dx + dy * dy) || 30, // Min radius if at center
            originalX: particle.x,
            originalY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            direction: direction, // Store chosen direction
            initialized: true
        };
    },
    
    /**
     * Apply spin motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.spin?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.spin;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply rhythm modulation if present
        let rotations = config.rotations;
        let radiusMultiplier = config.radiusMultiplier;
        if (motion.rhythmModulation) {
            if (motion.rhythmModulation.rotationMultiplier) {
                rotations *= motion.rhythmModulation.rotationMultiplier;
            }
            if (motion.rhythmModulation.radiusMultiplier) {
                radiusMultiplier *= motion.rhythmModulation.radiusMultiplier;
            }
        }
        
        // Apply acceleration curve if enabled
        let speedProgress = progress;
        if (config.accelerate) {
            // Speed up for first half, slow down for second half
            if (progress < 0.5) {
                speedProgress = this.easeInQuad(progress * 2) * 0.5;
            } else {
                speedProgress = 0.5 + this.easeOutQuad((progress - 0.5) * 2) * 0.5;
            }
        }
        
        // Calculate rotation angle using stored direction
        const rotationAmount = rotations * Math.PI * 2 * strength;
        const direction = data.direction === 'counter-clockwise' ? -1 : 1;
        const currentAngle = data.startAngle + (rotationAmount * speedProgress * direction);
        
        // Calculate radius (with optional spiral)
        let currentRadius = data.startRadius;
        if (config.spiralOut) {
            currentRadius *= (1 + progress * 0.5); // Expand outward during spin
        }
        if (radiusMultiplier !== 1) {
            // Apply radius multiplier with smooth curve
            const radiusCurve = Math.sin(progress * Math.PI); // Peak at middle
            currentRadius *= (1 + (radiusMultiplier - 1) * radiusCurve);
        }
        
        // Calculate target position
        const targetX = centerX + Math.cos(currentAngle) * currentRadius;
        const targetY = centerY + Math.sin(currentAngle) * currentRadius;
        
        // For override gesture, directly set position with smooth interpolation
        const moveSpeed = 0.25; // Adjust for smoothness
        particle.x += (targetX - particle.x) * moveSpeed;
        particle.y += (targetY - particle.y) * moveSpeed;
        
        // Set velocity to match movement (for trail effects)
        particle.vx = (targetX - particle.x) * 0.5;
        particle.vy = (targetY - particle.y) * 0.5;
        
        // Smooth ending - return to original velocities
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.spin) {
            // Restore original velocities
            const data = particle.gestureData.spin;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.spin;
        }
    },
    
    /**
     * Easing function for acceleration
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInQuad: function(t) {
        return t * t;
    },
    
    /**
     * Easing function for deceleration
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeOutQuad: function(t) {
        return t * (2 - t);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Jump Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Jump gesture - squash, leap, and land animation
 * @author Emotive Engine Team
 * @module gestures/transforms/jump
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a classic jump animation with squash & stretch principles. Particles       
 * ║ compress before jumping, stretch during flight, and squash on landing.            
 * ║ This is an OVERRIDE gesture that completely controls particle motion.             
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Phase 1: Squash    Phase 2: Jump      Phase 3: Land
 *         ⭐              ↗ ⭐ ↘              ⭐
 *         ___            /     \             ___
 *     (compressed)     (stretched)       (squashed)
 * 
 * USED BY:
 * - Joy/excitement expressions
 * - Surprise reactions
 * - Celebration animations
 * - Playful interactions
 */

/**
 * Jump gesture configuration and implementation
 */
var jump = {
    name: 'jump',
    emoji: '🦘',
    type: 'override', // Completely replaces motion
    description: 'Squash, leap, and land with classic animation principles',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        jumpHeight: 60,        // Maximum vertical leap distance
        squashAmount: 0.8,     // Compression ratio during squash
        stretchAmount: 1.2,    // Extension ratio during stretch
        anticipation: 0.2,     // Pre-jump preparation duration ratio
        hangTime: 0.1,         // Pause duration at jump peak
        landingImpact: true,   // Enable landing squash effect
        driftOutward: true,    // Particles spread during jump
        easing: 'quad',        // Animation curve type
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'jump',
            strength: 0.9,         // Jump motion intensity
            jumpHeight: 60,        // Particle jump height
            squash: 0.8,          // Particle compression amount
            stretch: 1.2          // Particle extension amount
        }
    },
    
    // Rhythm configuration - jump lands on beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Jump timing syncs to beat
        
        // Jump phases sync to rhythm
        phaseSync: {
            anticipation: 'eighth',    // Squash on 8th note before beat
            jump: 'beat',              // Launch on the beat
            landing: 'sixteenth'       // Land on 16th after beat
        },
        
        // Jump height modulation
        heightSync: {
            onBeat: 1.5,              // Higher jumps on strong beats
            offBeat: 0.8,             // Lower jumps on weak beats
            accent: 2.0,              // Extra high on accented beats
            curve: 'exponential'      // Sharp takeoff
        },
        
        // Squash and stretch intensity
        deformationSync: {
            squashOnBeat: 0.6,        // More squash on beat
            stretchOnBeat: 1.4,       // More stretch on beat
            timing: 'anticipatory'    // Deform before beat hits
        },
        
        // Hang time varies with tempo
        hangTimeSync: {
            mode: 'tempo',
            baseDuration: 0.1,        // Base hang at 120 BPM
            scaling: 'inverse'        // Slower tempo = longer hang
        },
        
        // Musical dynamics
        dynamics: {
            forte: { jumpHeight: 80, stretch: 1.3 },   // Big jumps on loud
            piano: { jumpHeight: 30, stretch: 1.1 }    // Small hops on soft
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.jump = {
            startX: particle.x,
            startY: particle.y,
            startSize: particle.size,
            originalVx: particle.vx,
            originalVy: particle.vy,
            driftDirection: (particle.x - centerX) * 0.1, // Drift away from center
            initialized: true
        };
    },
    
    /**
     * Apply jump motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.jump?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.jump;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        const jumpHeight = config.jumpHeight * strength * particle.scaleFactor;
        const squash = config.squashAmount;
        const stretch = config.stretchAmount;
        
        // Define phase breakpoints
        const anticipationEnd = config.anticipation;
        const jumpEnd = 1 - config.anticipation * 0.5; // Leave time for landing
        
        if (progress < anticipationEnd) {
            // PHASE 1: Anticipation (squash down)
            const squashProgress = progress / anticipationEnd;
            const easedSquash = this.easeOutQuad(squashProgress);
            
            // Squash size
            particle.size = data.startSize * (1 - (1 - squash) * easedSquash);
            
            // Slightly lower position (crouch)
            particle.y = data.startY + easedSquash * 5 * particle.scaleFactor;
            
            // Stop horizontal movement during anticipation
            particle.vx = 0;
            particle.vy = 0;
            
        } else if (progress < jumpEnd) {
            // PHASE 2: Jump (arc motion with stretch)
            const jumpProgress = (progress - anticipationEnd) / (jumpEnd - anticipationEnd);
            
            // Use sine curve for smooth arc
            let jumpCurve = Math.sin(jumpProgress * Math.PI);
            
            // Add hang time at peak
            if (config.hangTime > 0 && jumpProgress > 0.4 && jumpProgress < 0.6) {
                const hangProgress = (jumpProgress - 0.4) / 0.2;
                const hangCurve = this.easeInOutCubic(hangProgress);
                jumpCurve = 0.95 + hangCurve * 0.05; // Flatten at peak
            }
            
            // Vertical position
            particle.y = data.startY - jumpCurve * jumpHeight;
            
            // Horizontal drift if enabled
            if (config.driftOutward) {
                particle.x = data.startX + jumpCurve * data.driftDirection;
            }
            
            // Stretch/squash based on velocity
            if (jumpProgress < 0.5) {
                // Going up - stretch
                const stretchProgress = jumpProgress * 2;
                particle.size = data.startSize * (squash + (stretch - squash) * stretchProgress);
            } else {
                // Coming down - return to normal then squash slightly
                const fallProgress = (jumpProgress - 0.5) * 2;
                particle.size = data.startSize * (stretch - (stretch - 1) * fallProgress * 0.8);
            }
            
            // Set velocity for motion blur/trails
            particle.vx = data.driftDirection * 0.5;
            particle.vy = -Math.cos(jumpProgress * Math.PI) * jumpHeight * 0.1;
            
        } else {
            // PHASE 3: Landing (impact squash)
            const landProgress = (progress - jumpEnd) / (1 - jumpEnd);
            const easedLand = this.easeOutBounce(landProgress);
            
            // Return to ground with bounce
            particle.y = data.startY;
            
            if (config.landingImpact) {
                // Landing squash effect
                if (landProgress < 0.3) {
                    const impactProgress = landProgress / 0.3;
                    particle.size = data.startSize * (1 - (1 - squash * 0.8) * (1 - impactProgress));
                } else {
                    // Recover from squash
                    const recoverProgress = (landProgress - 0.3) / 0.7;
                    particle.size = data.startSize * (squash * 0.8 + (1 - squash * 0.8) * recoverProgress);
                }
            } else {
                // Simple size recovery
                particle.size = data.startSize * (squash + (1 - squash) * easedLand);
            }
            
            // Gradually stop motion
            particle.vx = data.originalVx * easedLand;
            particle.vy = data.originalVy * easedLand;
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.jump) {
            const data = particle.gestureData.jump;
            // Restore original properties
            particle.size = data.startSize;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.jump;
        }
    },
    
    /**
     * Easing functions
     */
    easeOutQuad: function(t) {
        return t * (2 - t);
    },
    
    easeInOutCubic: function(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeOutBounce: function(t) {
        const n1 = 7.5625;
        const d1 = 2.75;
        
        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Morph Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Morph gesture - form geometric patterns
 * @author Emotive Engine Team
 * @module gestures/transforms/morph
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Transforms the particle cloud into geometric shapes like circles, stars,          
 * ║ hearts, or other patterns. This is an OVERRIDE gesture that moves particles       
 * ║ to specific positions to form recognizable shapes.                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Random Cloud      →      Star Pattern      →      Heart Pattern
 *      · · ·                    ★                         ♥♥
 *     · · · ·          →      ·   ·           →         ♥   ♥
 *      · · ·                ·   ★   ·                  ♥     ♥
 *                             ·   ·                      ♥   ♥
 *                               ★                          ♥
 * 
 * USED BY:
 * - Love emotions (heart shape)
 * - Magic/special effects (star patterns)
 * - Achievement celebrations (trophy/medal shapes)
 * - Transitions between states
 */

/**
 * Morph gesture configuration and implementation
 */
var morph = {
    name: 'morph',
    emoji: '✨',
    type: 'override', // Completely replaces motion
    description: 'Form geometric patterns and shapes',
    
    // Default configuration
    config: {
        // Musical duration - morph over 2 beats
        musicalDuration: {
            musical: true,
            beats: 2,          // Default to half a bar
            minBeats: 1,       // Minimum quarter note
            maxBeats: 8        // Maximum 2 bars
        },
        
        // Musical phases of the morph
        phases: [
            { name: 'gather', beats: 0.25 },    // Particles gather
            { name: 'form', beats: 0.75 },      // Form the shape
            { name: 'hold', beats: 0.5 },       // Hold the shape
            { name: 'dissolve', beats: 0.5 }    // Dissolve back
        ],
        
        morphType: 'fluid',     // Type of morph animation
        pattern: 'star',        // Shape to morph into
        points: 5,              // Number of points (for star/polygon)
        innerRadius: 0.4,       // Inner radius ratio (for star)
        size: 80,               // Base size of the pattern
        amplitude: 20,          // Motion amplitude
        rotation: 0,            // Rotation angle in degrees
        smooth: true,           // Smooth movement to positions
        randomizeOrder: false,  // Randomize which particles go where
        easing: 'sine',         // Animation curve type
        strength: 1.2,          // Formation strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'morph',
            pattern: 'star',
            strength: 1.2,
            smooth: true,
            points: 5
        }
    },
    
    // Rhythm configuration - morphs on musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Morph on musical phrases
        
        // Pattern changes with musical structure
        patternSync: {
            verse: 'circle',          // Simple shape for verse
            chorus: 'star',           // Complex shape for chorus
            bridge: 'heart',          // Special shape for bridge
            drop: 'explosion'         // Dramatic for drops
        },
        
        // Morph timing syncs to measures
        timingSync: {
            formationBeat: 1,         // Start forming on beat 1
            holdBeats: 2,             // Hold shape for 2 beats
            dissolveBeat: 4,          // Dissolve on beat 4
            curve: 'anticipatory'     // Ease into formation
        },
        
        // Size pulses with rhythm
        sizeSync: {
            onBeat: 1.2,              // Expand on beat
            offBeat: 0.95,            // Contract off beat
            subdivision: 'quarter',    // Pulse every quarter note
            curve: 'elastic'          // Bouncy expansion
        },
        
        // Rotation syncs to bars
        rotationSync: {
            mode: 'continuous',       // Continuous rotation
            degreesPerBar: 90,        // Rotate 90° per bar
            direction: 'clockwise'    // Rotation direction
        },
        
        // Musical dynamics affect complexity
        dynamics: {
            forte: { points: 8, size: 100 },    // Complex shapes when loud
            piano: { points: 3, size: 60 }      // Simple shapes when soft
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     * @param {EmotiveMascot} mascot - The mascot instance for core morphing
     */
    initialize: function(particle, motion, centerX, centerY, mascot) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const config = { ...this.config, ...motion };
        
        // Store original position
        const startX = particle.x;
        const startY = particle.y;
        
        // Calculate angle from center for position assignment
        const angle = Math.atan2(particle.y - centerY, particle.x - centerX);
        
        // Random rotation direction for the pattern
        const rotationDirection = Math.random() < 0.5 ? 1 : -1;
        
        // Calculate target position based on pattern
        let targetX, targetY;
        const size = config.size * particle.scaleFactor;
        const rotation = ((config.rotation || 0) * Math.PI / 180) * rotationDirection;
        
        switch (config.pattern) {
            case 'star':
                targetX = centerX;
                targetY = centerY;
                this.calculateStarPosition(particle, angle, size, config.points, config.innerRadius, rotation, centerX, centerY);
                break;
                
            case 'heart':
                this.calculateHeartPosition(particle, angle, size, rotation, centerX, centerY);
                break;
                
            case 'square':
                this.calculateSquarePosition(particle, angle, size, rotation, centerX, centerY);
                break;
                
            case 'triangle':
                this.calculateTrianglePosition(particle, angle, size, rotation, centerX, centerY);
                break;
                
            case 'circle':
            default:
                // Simple circle pattern
                const targetRadius = size;
                targetX = centerX + Math.cos(angle + rotation) * targetRadius;
                targetY = centerY + Math.sin(angle + rotation) * targetRadius;
                break;
        }
        
        particle.gestureData.morph = {
            startX: startX,
            startY: startY,
            targetX: particle.gestureData.morphTargetX || targetX,
            targetY: particle.gestureData.morphTargetY || targetY,
            originalVx: particle.vx,
            originalVy: particle.vy,
            rotationDirection: rotationDirection, // Store random rotation direction
            initialized: true
        };
    },
    
    /**
     * Calculate star pattern position
     */
    calculateStarPosition: function(particle, angle, size, points, innerRadius, rotation, centerX, centerY) {
        const armAngle = (Math.PI * 2) / points;
        const armIndex = Math.round(angle / armAngle) % points;
        const isOuter = Math.random() > 0.5; // Distribute between inner and outer points
        
        let radius;
        let targetAngle;
        
        if (isOuter) {
            // Outer point of star
            radius = size;
            targetAngle = armIndex * armAngle + rotation;
        } else {
            // Inner point of star (between arms)
            radius = size * innerRadius;
            targetAngle = armIndex * armAngle + armAngle * 0.5 + rotation;
        }
        
        particle.gestureData.morphTargetX = centerX + Math.cos(targetAngle) * radius;
        particle.gestureData.morphTargetY = centerY + Math.sin(targetAngle) * radius;
    },
    
    /**
     * Calculate heart pattern position
     */
    calculateHeartPosition: function(particle, angle, size, rotation, centerX, centerY) {
        // Map angle to heart curve parameter
        const t = (angle + Math.PI) / (Math.PI * 2);
        
        // Heart parametric equations
        const scale = size * 0.05;
        let x = 16 * Math.pow(Math.sin(t * Math.PI * 2), 3);
        let y = -(13 * Math.cos(t * Math.PI * 2) - 5 * Math.cos(2 * t * Math.PI * 2) - 
                  2 * Math.cos(3 * t * Math.PI * 2) - Math.cos(4 * t * Math.PI * 2));
        
        // Scale and rotate
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX * scale;
        particle.gestureData.morphTargetY = centerY + rotY * scale;
    },
    
    /**
     * Calculate square pattern position
     */
    calculateSquarePosition: function(particle, angle, size, rotation, centerX, centerY) {
        // Determine which edge the particle should go to
        const rotatedAngle = angle + rotation;
        const normalizedAngle = ((rotatedAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
        
        let x, y;
        const halfSize = size;
        
        // Map to square edges
        if (normalizedAngle < Math.PI / 4 || normalizedAngle >= 7 * Math.PI / 4) {
            // Right edge
            x = halfSize;
            y = halfSize * Math.tan(normalizedAngle);
        } else if (normalizedAngle < 3 * Math.PI / 4) {
            // Top edge
            x = halfSize / Math.tan(normalizedAngle);
            y = halfSize;
        } else if (normalizedAngle < 5 * Math.PI / 4) {
            // Left edge
            x = -halfSize;
            y = -halfSize * Math.tan(normalizedAngle);
        } else {
            // Bottom edge
            x = -halfSize / Math.tan(normalizedAngle);
            y = -halfSize;
        }
        
        // Apply rotation
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX;
        particle.gestureData.morphTargetY = centerY + rotY;
    },
    
    /**
     * Calculate triangle pattern position
     */
    calculateTrianglePosition: function(particle, angle, size, rotation, centerX, centerY) {
        // Three vertices of equilateral triangle
        const vertices = [
            { x: 0, y: -size },                    // Top
            { x: -size * 0.866, y: size * 0.5 },   // Bottom left
            { x: size * 0.866, y: size * 0.5 }     // Bottom right
        ];
        
        // Determine which edge the particle should go to
        const edgeIndex = Math.floor(((angle + Math.PI) / (Math.PI * 2)) * 3) % 3;
        const nextIndex = (edgeIndex + 1) % 3;
        
        // Position along the edge
        const edgeProgress = Math.random();
        const x = vertices[edgeIndex].x + (vertices[nextIndex].x - vertices[edgeIndex].x) * edgeProgress;
        const y = vertices[edgeIndex].y + (vertices[nextIndex].y - vertices[edgeIndex].y) * edgeProgress;
        
        // Apply rotation
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX;
        particle.gestureData.morphTargetY = centerY + rotY;
    },
    
    /**
     * Apply morph motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.morph?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.morph;
        const config = { ...this.config, ...motion };
        
        // Calculate eased progress
        let morphProgress = progress;
        
        // Add hold time at the shape
        if (config.holdTime > 0) {
            const holdStart = 0.5 - config.holdTime / 2;
            const holdEnd = 0.5 + config.holdTime / 2;
            
            if (progress < holdStart) {
                morphProgress = progress / holdStart * 0.5;
            } else if (progress < holdEnd) {
                morphProgress = 0.5; // Hold at shape
            } else {
                morphProgress = 0.5 + (progress - holdEnd) / (1 - holdEnd) * 0.5;
            }
        }
        
        this.easeInOutCubic(morphProgress);
        
        // Calculate interpolated position
        let targetX, targetY;
        
        if (morphProgress <= 0.5) {
            // Moving to shape
            const moveProgress = morphProgress * 2;
            targetX = data.startX + (data.targetX - data.startX) * this.easeOutQuad(moveProgress);
            targetY = data.startY + (data.targetY - data.startY) * this.easeOutQuad(moveProgress);
        } else {
            // Returning from shape
            const returnProgress = (morphProgress - 0.5) * 2;
            targetX = data.targetX + (data.startX - data.targetX) * this.easeInQuad(returnProgress);
            targetY = data.targetY + (data.startY - data.targetY) * this.easeInQuad(returnProgress);
        }
        
        // Apply position
        if (config.smooth) {
            // Smooth movement
            const moveSpeed = 0.2;
            particle.x += (targetX - particle.x) * moveSpeed;
            particle.y += (targetY - particle.y) * moveSpeed;
        } else {
            // Direct positioning
            particle.x = targetX;
            particle.y = targetY;
        }
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.5;
        particle.vy = (targetY - particle.y) * 0.5;
        
        // Restore original velocities at the end
        if (progress > 0.9) {
            const blendFactor = (1 - progress) * 10;
            particle.vx = particle.vx * blendFactor + data.originalVx * (1 - blendFactor);
            particle.vy = particle.vy * blendFactor + data.originalVy * (1 - blendFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.morph) {
            const data = particle.gestureData.morph;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.morph;
            delete particle.gestureData.morphTargetX;
            delete particle.gestureData.morphTargetY;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic: function(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeOutQuad: function(t) {
        return t * (2 - t);
    },
    
    easeInQuad: function(t) {
        return t * t;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Stretch Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Stretch gesture - scale particles along axes
 * @author Emotive Engine Team
 * @module gestures/transforms/stretch
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Stretches or squashes the particle cloud along X and Y axes independently.        
 * ║ This is an OVERRIDE gesture that directly controls particle positions to          
 * ║ create elastic deformation effects.                                               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Normal          Stretch X         Stretch Y        Squash
 *      ⭐             ← ⭐ →             ↑               ___
 *     ·⭐·           · · ⭐ · ·          ⭐              ·⭐·
 *      ⭐                                ·               ‾‾‾
 *                                        ·
 *                                        ↓
 * 
 * USED BY:
 * - Elastic animations
 * - Impact effects (squash on hit)
 * - Breathing/pulsing variations
 * - Transition effects
 */

/**
 * Stretch gesture configuration and implementation
 */
var stretch = {
    name: 'stretch',
    emoji: '↔️',
    type: 'override', // Completely replaces motion
    description: 'Scale particles along X and Y axes',
    
    // Default configuration
    config: {
        duration: 2000,        // Animation duration
        scaleX: 1.3,           // Horizontal scale factor
        scaleY: 0.9,           // Vertical scale factor
        alternate: false,      // Alternate between X and Y stretch
        elastic: true,         // Add elastic overshoot
        overshoot: 0.1,        // Elastic overshoot amount
        frequency: 1,          // Number of stretches
        easing: 'sine',        // Animation curve type
        strength: 1.0,         // Motion strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'stretch',
            scaleX: 1.8,       // Particle horizontal scale
            scaleY: 0.6,       // Particle vertical scale
            strength: 1.0
        },
        centerBased: true,     // Scale from center vs. origin
        preserveArea: false    // Keep total area constant
    },
    
    // Rhythm configuration - stretch pulses with rhythm
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Stretch on beats
        
        // Scale modulation with rhythm
        scaleSync: {
            onBeat: { x: 1.5, y: 0.7 },     // Stretch wide on beat
            offBeat: { x: 0.8, y: 1.3 },     // Stretch tall off beat
            subdivision: 'eighth',            // Change every 8th note
            curve: 'elastic'                 // Bouncy stretch
        },
        
        // Alternation pattern
        alternateSync: {
            pattern: 'XYXY',                 // X stretch, Y stretch pattern
            beatsPerChange: 1,               // Change axis each beat
            overlap: 0.1                      // Slight overlap in transitions
        },
        
        // Elastic overshoot on accents
        overshootSync: {
            normal: 0.1,                     // Standard overshoot
            accent: 0.3,                     // Big overshoot on accent
            downbeat: 0.2,                   // Medium on downbeat
            curve: 'spring'                  // Spring-like motion
        },
        
        // Area preservation modes
        preservationSync: {
            verse: true,                     // Maintain area in verse
            chorus: false,                   // Free deformation in chorus
            bridge: true                     // Back to preservation
        },
        
        // Musical dynamics
        dynamics: {
            forte: { scaleX: 2.0, scaleY: 0.5, overshoot: 0.4 },
            piano: { scaleX: 1.1, scaleY: 0.95, overshoot: 0.05 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate offset from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        particle.gestureData.stretch = {
            offsetX: dx,
            offsetY: dy,
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            initialized: true
        };
    },
    
    /**
     * Apply stretch motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.stretch?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.stretch;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Calculate scale factors
        let scaleX = config.scaleX;
        let scaleY = config.scaleY;
        
        // Apply area preservation if enabled
        if (config.preserveArea && scaleX !== 1 && scaleY !== 1) {
            // Adjust scales to maintain area
            const targetArea = scaleX * scaleY;
            const factor = Math.sqrt(1 / targetArea);
            scaleX *= factor;
            scaleY *= factor;
        }
        
        // Handle alternating stretch
        if (config.alternate) {
            // First half: stretch X
            // Second half: stretch Y
            if (progress < 0.5) {
                const altProgress = progress * 2;
                scaleX = 1 + (scaleX - 1) * this.getElasticProgress(altProgress, config);
                scaleY = 1 + (1 / scaleX - 1) * (config.preserveArea ? 1 : 0); // Area compensation
            } else {
                const altProgress = (progress - 0.5) * 2;
                scaleX = scaleX + (1 - scaleX) * this.getElasticProgress(altProgress, config);
                scaleY = 1 + (scaleY - 1) * this.getElasticProgress(altProgress, config);
            }
        } else {
            // Apply both scales simultaneously
            const easeProgress = this.getElasticProgress(progress, config);
            scaleX = 1 + (scaleX - 1) * easeProgress * strength;
            scaleY = 1 + (scaleY - 1) * easeProgress * strength;
        }
        
        // Calculate target position
        let targetX, targetY;
        
        if (config.centerBased) {
            // Scale from center point
            targetX = centerX + data.offsetX * scaleX;
            targetY = centerY + data.offsetY * scaleY;
        } else {
            // Scale from original position
            targetX = data.startX * scaleX;
            targetY = data.startY * scaleY;
        }
        
        // Apply position
        particle.x = targetX;
        particle.y = targetY;
        
        // Set velocity based on stretch direction
        particle.vx = data.offsetX * (scaleX - 1) * strength * 0.1;
        particle.vy = data.offsetY * (scaleY - 1) * strength * 0.1;
        
        // Smooth ending
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Calculate progress with optional elastic overshoot
     * @param {number} progress - Raw progress (0-1)
     * @param {Object} config - Configuration with elastic settings
     * @returns {number} Modified progress value
     */
    getElasticProgress: function(progress, config) {
        if (!config.elastic) {
            return this.easeInOutCubic(progress);
        }
        
        // Elastic easing with overshoot
        if (progress === 0) return 0;
        if (progress === 1) return 1;
        
        const overshoot = config.overshoot || 0.1;
        
        if (progress < 0.5) {
            // Ease in with slight pull back
            const t = progress * 2;
            return 0.5 * this.easeInElastic(t, overshoot);
        } else {
            // Ease out with overshoot
            const t = (progress - 0.5) * 2;
            return 0.5 + 0.5 * this.easeOutElastic(t, overshoot);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.stretch) {
            const data = particle.gestureData.stretch;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.stretch;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic: function(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeInElastic: function(t, overshoot) {
        if (t === 0) return 0;
        if (t === 1) return 1;
        const p = 0.3;
        const s = p / 4;
        return -(Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - s) * (2 * Math.PI) / p)) * (1 + overshoot);
    },
    
    easeOutElastic: function(t, overshoot) {
        if (t === 0) return 0;
        if (t === 1) return 1;
        const p = 0.3;
        const s = p / 4;
        return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) * (1 + overshoot) + 1;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Tilt Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Tilt gesture - particles gather and sway together
 * @author Emotive Engine Team
 * @module gestures/transforms/tilt
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a cohesive tilting motion where particles first gather toward the center, 
 * ║ then tilt and sway as a unified group. Perfect for curious or questioning         
 * ║ expressions, like a head tilt.                                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Phase 1: Gather    Phase 2: Tilt Left    Phase 3: Tilt Right
 *      · · ·               ↖ ⭐                    ⭐ ↗
 *     · · · ·      →      ↖ ⭐ ⭐        →      ⭐ ⭐ ↗
 *      · · ·               ↖ ⭐                    ⭐ ↗
 *    (scattered)         (tilted left)         (tilted right)
 * 
 * USED BY:
 * - Curiosity/questioning states
 * - Contemplation animations
 * - Playful head-tilt effects
 * - Character personality expressions
 */

/**
 * Tilt gesture configuration and implementation
 */
var tilt = {
    name: 'tilt',
    emoji: '🤔',
    type: 'override', // Completely replaces motion
    description: 'Gather particles then tilt as unified group',
    
    // Default configuration
    config: {
        duration: 500,         // Animation duration
        gatherPhase: 0.2,      // Gathering phase ratio
        tiltAngle: 45,         // Maximum tilt angle in degrees
        swayAmount: 80,        // Horizontal sway distance
        liftAmount: 60,        // Vertical lift distance during tilt
        frequency: 3,          // Number of tilt cycles
        homeRadius: 20,        // Gathering radius from center
        easing: 'sine',        // Animation curve type
        strength: 2.5,         // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'tilt',
            strength: 2.5,
            frequency: 3,
            swayAmount: 80,
            liftAmount: 60
        },
        smoothness: 0.25       // Movement smoothing factor
    },
    
    // Rhythm configuration - tilts sync to swing rhythm
    rhythm: {
        enabled: true,
        syncMode: 'swing',  // Tilt with swing feel
        
        // Tilt angle syncs to beat pattern
        angleSync: {
            onBeat: 45,                      // Full tilt on beat
            offBeat: -30,                    // Counter-tilt off beat
            swing: 15,                       // Extra tilt on swing beats
            subdivision: 'triplet',          // Triplet feel for smooth sway
            curve: 'ease-in-out'            // Smooth tilt transitions
        },
        
        // Gathering phase timing
        gatherSync: {
            beatsBefore: 0.5,                // Gather half beat before tilt
            releaseAfter: 0.25,              // Release quarter beat after
            intensity: 'dynamic'             // Gather speed varies with tempo
        },
        
        // Sway amount modulation
        swaySync: {
            verse: 60,                       // Gentle sway in verse
            chorus: 100,                     // Big sway in chorus
            bridge: 80,                      // Medium in bridge
            syncopated: true                 // Off-beat emphasis
        },
        
        // Lift coordination
        liftSync: {
            upOnTilt: true,                  // Lift when tilting
            heightOnAccent: 80,              // Higher lift on accents
            normalHeight: 40,                // Standard lift height
            curve: 'bounce'                  // Bouncy lift motion
        },
        
        // Musical expression
        dynamics: {
            forte: { tiltAngle: 60, swayAmount: 120, frequency: 4 },
            piano: { tiltAngle: 20, swayAmount: 40, frequency: 2 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial position and angle
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const angle = Math.atan2(dy, dx);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Assign a role for variation (some particles lag slightly)
        const role = Math.random();
        
        // Calculate home position (where particle gathers to)
        const config = { ...this.config, ...motion };
        const homeRadius = (config.homeRadius + Math.random() * 20) * particle.scaleFactor;
        
        particle.gestureData.tilt = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            angle: angle,
            distance: distance,
            homeRadius: homeRadius,
            homeX: centerX + Math.cos(angle) * homeRadius,
            homeY: centerY + Math.sin(angle) * homeRadius,
            role: role, // Variation factor for timing and smoothness
            initialized: true
        };
    },
    
    /**
     * Apply tilt motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.tilt?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.tilt;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        let targetX, targetY;
        
        if (progress < config.gatherPhase) {
            // PHASE 1: Gather toward center
            const gatherProgress = progress / config.gatherPhase;
            const easedGather = this.easeInOutCubic(gatherProgress);
            
            // Interpolate from start to home position
            targetX = data.startX + (data.homeX - data.startX) * easedGather;
            targetY = data.startY + (data.homeY - data.startY) * easedGather;
            
            // Apply gathering motion
            const speed = 0.6;  // Gathering speed factor
            particle.x += (targetX - particle.x) * speed;
            particle.y += (targetY - particle.y) * speed;
            
        } else {
            // PHASE 2: Tilting motion
            const tiltPhase = (progress - config.gatherPhase) / (1 - config.gatherPhase);
            const t = tiltPhase * Math.PI * config.frequency;
            const tiltProgress = Math.sin(t);
            
            // Convert tilt angle to radians
            const maxTiltRad = (config.tiltAngle * Math.PI / 180) * strength;
            
            // Calculate sway angle (oscillates left and right)
            const swayAngle = data.angle + (tiltProgress * maxTiltRad);
            
            // Add lift effect (particles rise slightly during tilt)
            const liftAmount = Math.abs(tiltProgress) * config.liftAmount * particle.scaleFactor;
            const currentRadius = data.homeRadius + liftAmount;
            
            // Calculate target position with tilt
            targetX = centerX + Math.cos(swayAngle) * currentRadius;
            targetY = centerY + Math.sin(swayAngle) * currentRadius - liftAmount * 0.3; // Add upward bias
            
            // Apply role-based variation (some particles lag)
            const smoothness = config.smoothness + data.role * 0.1;
            
            // Smooth movement to target
            particle.x += (targetX - particle.x) * smoothness;
            particle.y += (targetY - particle.y) * smoothness;
            
            // Add subtle rotation feel with velocity
            const tangentX = -Math.sin(swayAngle);
            const tangentY = Math.cos(swayAngle);
            particle.vx = tangentX * tiltProgress * 2;
            particle.vy = tangentY * tiltProgress * 2;
        }
        
        // Store current velocity for trails
        if (progress < config.gatherPhase) {
            particle.vx = (targetX - particle.x) * 0.25;
            particle.vy = (targetY - particle.y) * 0.25;
        }
        
        // Smooth ending - return to original velocities
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            const returnX = data.startX + (particle.x - data.startX) * endFactor;
            const returnY = data.startY + (particle.y - data.startY) * endFactor;
            
            particle.x = returnX;
            particle.y = returnY;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.tilt) {
            const data = particle.gestureData.tilt;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.tilt;
        }
    },
    
    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic: function(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbital Gesture with 3D Depth
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview 3D orbital gesture - particles orbit with dynamic z-depth changes
 * @author Emotive Engine Team
 * @module gestures/transforms/orbital
 * 
 * GESTURE TYPE:
 * type: 'override' - Takes complete control of particle motion
 * 
 * ACCEPTABLE TYPES:
 * - 'blending' : Adds motion to existing particle behavior (used in motions/)
 * - 'override' : Replaces particle motion completely (used in transforms/)
 * - 'effect'   : Visual effects without changing position (used in effects/)
 * 
 * VISUAL EFFECT:
 * Particles orbit around the center while transitioning between foreground and
 * background layers, creating a true 3D effect where particles pass behind and
 * in front of the orb.
 */

var orbital = {
    name: 'orbital',
    emoji: '🪐',
    type: 'override',
    description: 'Orbital motion around center',
    
    // Default configuration
    config: {
        speed: 0.02,              // Orbital rotation speed
        maintainRadius: true,     // Keep constant orbit radius
        elliptical: false,        // Use circular orbit
        use3D: true,              // Enable z-coordinate animation
        zPhaseOffset: 0,          // Phase offset for z-oscillation
        verticalOscillation: 0,   // Vertical movement for hula-hoop effect
        duration: 3000,           // Animation duration
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'orbital',
            strength: 1.0
        }
    },
    
    // Rhythm configuration - orbital paths sync to harmony
    rhythm: {
        enabled: true,
        syncMode: 'harmonic',  // Orbit follows harmonic intervals
        
        // Speed based on harmonic ratios
        speedSync: {
            tonic: 0.02,              // Base orbit speed
            fifth: 0.03,              // 3:2 ratio (perfect fifth)
            octave: 0.04,             // 2:1 ratio (octave)
            third: 0.025,             // 5:4 ratio (major third)
            curve: 'smooth'           // Smooth transitions
        },
        
        // Orbital layers by pitch
        radiusSync: {
            bass: 150,                // Outer orbit for low notes
            mid: 100,                 // Middle orbit for mids
            treble: 50,               // Inner orbit for highs
            scaling: 'logarithmic'    // Natural pitch scaling
        },
        
        // 3D depth syncs to chord progression
        depthSync: {
            major: { z: 1.0, phase: 0 },        // Front-facing for major
            minor: { z: -1, phase: Math.PI }, // Back-facing for minor
            diminished: { z: 0.5, phase: Math.PI/2 }, // Side angle
            augmented: { z: 0.8, phase: -Math.PI/2 }  // Other side
        },
        
        // Phase relationships
        phaseSync: {
            mode: 'harmonic',         // Particles phase-lock harmonically
            intervals: [1, 1.5, 2],   // Unison, fifth, octave
            drift: 0.05               // Slight phase drift for organic feel
        },
        
        // Musical dynamics
        dynamics: {
            forte: { speed: 0.04, maintainRadius: false }, // Chaotic orbits
            piano: { speed: 0.01, maintainRadius: true }   // Stable orbits
        }
    },
    
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const calculatedRadius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for orbit
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        // Set minimum radius to prevent center clustering - 3x larger spread
        const MIN_RADIUS = 100;
        const radius = Math.max(calculatedRadius, MIN_RADIUS + Math.random() * 180); // At least 180-360 pixels
        
        particle.gestureData.orbital = {
            radius: radius,
            targetRadius: radius, // Store target for smooth transitions
            angle: calculatedRadius < 5 ? Math.random() * Math.PI * 2 : Math.atan2(dy, dx), // Random angle if at center
            originalVx: particle.vx,
            originalVy: particle.vy,
            originalZ: particle.z || 0,  // Store original z-coordinate
            zPhase: Math.random() * Math.PI * 2,  // Random phase for variety
            direction: direction  // Random orbit direction
        };
    },
    
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.orbital) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.orbital;
        const speed = (motion.speed || this.config.speed) * (motion.strength || 1);
        
        // Update angle with direction (dt is already normalized to 60fps)
        data.angle += speed * dt * data.direction;
        
        // Use the stored radius (which has minimum enforced)
        let radius = data.radius;
        
        if (!motion.maintainRadius) {
            // Allow radius to vary slightly for organic motion
            radius = data.radius * (1 + Math.sin(progress * Math.PI * 2) * 0.1);
        }
        
        particle.x = centerX + Math.cos(data.angle) * radius;
        particle.y = centerY + Math.sin(data.angle) * radius;
        
        // 3D DEPTH: Animate z-coordinate for particles passing behind/in front
        if (motion.use3D !== false) {  // Default to true
            // Z oscillates as particle orbits, creating 3D effect
            // When angle is 0/2π (right side), z is positive (front)
            // When angle is π (left side), z is negative (back)
            const zAngle = data.angle + data.zPhase + (motion.zPhaseOffset || 0);
            particle.z = Math.sin(zAngle) * 0.8; // Z-depth range for layering
            
            // Add vertical oscillation for hula-hoop effect
            if (motion.verticalOscillation) {
                const verticalOffset = Math.cos(zAngle) * motion.verticalOscillation * radius * 0.1;
                particle.y += verticalOffset;
            }
        }
        
        // Set velocity to match motion
        particle.vx = -Math.sin(data.angle) * radius * speed;
        particle.vy = Math.cos(data.angle) * radius * speed;
        
        // Restore original velocity at end
        if (progress > 0.9) {
            const blendFactor = (1 - progress) * 10;
            particle.vx = particle.vx * blendFactor + data.originalVx * (1 - blendFactor);
            particle.vy = particle.vy * blendFactor + data.originalVy * (1 - blendFactor);
        }
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.orbital) {
            const data = particle.gestureData.orbital;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.z = data.originalZ;  // Restore original z-coordinate
            delete particle.gestureData.orbital;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Hula-Hoop Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Hula-hoop variation of orbital with vertical oscillation
 * @author Emotive Engine Team
 * @module gestures/transforms/hula
 * 
 * VISUAL EFFECT:
 * Like a hula-hoop spinning around the orb - particles orbit horizontally while
 * oscillating vertically, creating a tilted ring effect with 3D depth.
 */

var hula = {
    name: 'hula',
    emoji: '🌀',
    type: 'override',
    description: 'Hula-hoop motion with vertical waves',
    
    // Default configuration
    config: {
        speed: 0.015,             // Rotation speed
        maintainRadius: false,     // Allow radius variation for organic feel
        elliptical: true,          // Elliptical orbit shape
        use3D: true,               // Enable 3D depth effect
        zPhaseOffset: Math.PI / 4, // Ring tilt angle
        verticalOscillation: 0.3,  // Vertical wave amount
        wobbleAmount: 0.15,        // Ring wobble intensity
        duration: 2500,            // Animation duration
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'hula',
            strength: 1.0,
            verticalOscillation: 0.3
        }
    },
    
    // Rhythm configuration - hula syncs to groove
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Full rotation per bar
        
        // Speed syncs to tempo for consistent rotation
        speedSync: {
            mode: 'tempo',
            baseSpeed: 0.015,      // Base speed at 120 BPM
            scaling: 'proportional' // Speed scales with BPM
        },
        
        // Wobble syncs to beat for rhythmic variation
        wobbleSync: {
            onBeat: 0.25,          // More wobble on beat
            offBeat: 0.1,          // Less wobble off beat
            curve: 'sine'          // Smooth transitions
        },
        
        // Vertical oscillation creates wave patterns
        verticalSync: {
            subdivision: 'quarter', // Wave every quarter note
            amplitude: 0.4,        // Wave height on beat
            phase: 'sequential'    // Waves follow rotation
        },
        
        // Musical expression
        dynamics: {
            forte: { wobbleAmount: 0.3, speed: 1.2 },  // Wilder on loud
            piano: { wobbleAmount: 0.05, speed: 0.8 }  // Gentler on soft
        }
    },
    
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const calculatedRadius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for hula-hoop
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        // Set minimum radius to prevent center clustering - 3x larger spread
        const MIN_RADIUS = 100; // Slightly larger for hula effect
        const radius = Math.max(calculatedRadius, MIN_RADIUS + Math.random() * 180); // At least 210-390 pixels
        
        particle.gestureData.hula = {
            radius: radius,
            angle: calculatedRadius < 5 ? Math.random() * Math.PI * 2 : Math.atan2(dy, dx), // Random angle if at center
            originalVx: particle.vx,
            originalVy: particle.vy,
            originalZ: particle.z || 0,
            zPhase: Math.random() * Math.PI * 2,
            wobblePhase: Math.random() * Math.PI * 2,
            direction: direction  // Random hula direction
        };
    },
    
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.hula) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.hula;
        const speed = (motion.speed || this.config.speed) * (motion.strength || 1);
        
        // Smooth entry/exit transitions
        let transitionFactor = 1.0;
        if (progress < 0.1) {
            // Smooth entry (first 10%)
            transitionFactor = progress / 0.1;
            transitionFactor = Math.sin(transitionFactor * Math.PI * 0.5); // Smooth ease-in
        } else if (progress > 0.9) {
            // Smooth exit (last 10%)
            transitionFactor = (1 - progress) / 0.1;
            transitionFactor = Math.sin(transitionFactor * Math.PI * 0.5); // Smooth ease-out
        }
        
        // Update angle with direction (dt is already normalized to 60fps)
        data.angle += speed * dt * data.direction * transitionFactor;
        
        // Wobble effect - the hoop wobbles as it spins
        const wobble = Math.sin(data.angle * 2 + data.wobblePhase) * (motion.wobbleAmount || this.config.wobbleAmount) * transitionFactor;
        
        // Calculate elliptical radius with wobble and transition
        let radiusX = data.radius * (1 + wobble) * transitionFactor;
        let radiusY = data.radius * (0.7 + wobble) * transitionFactor; // Elliptical shape factor
        
        // Smoothly transition from original position to orbit position
        const targetX = centerX + Math.cos(data.angle) * radiusX;
        const targetY = centerY + Math.sin(data.angle) * radiusY;
        
        if (progress < 0.1) {
            // During entry, lerp from original position
            const dx = particle.x - centerX;
            const dy = particle.y - centerY;
            const currentRadius = Math.sqrt(dx * dx + dy * dy);
            if (currentRadius < 50) {
                // If particle is at center, move it out smoothly
                particle.x = centerX + Math.cos(data.angle) * radiusX;
                particle.y = centerY + Math.sin(data.angle) * radiusY;
            } else {
                particle.x = particle.x + (targetX - particle.x) * transitionFactor * 0.5;
                particle.y = particle.y + (targetY - particle.y) * transitionFactor * 0.5;
            }
        } else {
            particle.x = targetX;
            particle.y = targetY;
        }
        
        // 3D DEPTH with strong vertical oscillation
        const zAngle = data.angle + data.zPhase + (motion.zPhaseOffset || this.config.zPhaseOffset);
        
        // Z-coordinate for depth (behind/in front) with transition
        particle.z = Math.sin(zAngle) * 0.9 * transitionFactor;
        
        // Vertical oscillation synchronized with z-depth
        const verticalAmount = motion.verticalOscillation || this.config.verticalOscillation;
        const verticalOffset = Math.cos(zAngle * 2) * verticalAmount * data.radius * 0.2 * transitionFactor;
        particle.y += verticalOffset;
        
        // Tilt effect - particles higher when in front, lower when behind
        const tiltOffset = particle.z * data.radius * 0.1;
        particle.y -= tiltOffset;
        
        // Set velocity to match motion with smooth transitions
        const targetVx = -Math.sin(data.angle) * radiusX * speed;
        const targetVy = Math.cos(data.angle) * radiusY * speed;
        
        if (progress < 0.1) {
            // Smooth velocity transition during entry
            particle.vx = data.originalVx + (targetVx - data.originalVx) * transitionFactor;
            particle.vy = data.originalVy + (targetVy - data.originalVy) * transitionFactor;
        } else if (progress > 0.9) {
            // Smooth velocity transition during exit
            particle.vx = targetVx * transitionFactor + data.originalVx * (1 - transitionFactor);
            particle.vy = targetVy * transitionFactor + data.originalVy * (1 - transitionFactor);
            particle.z = particle.z * transitionFactor + data.originalZ * (1 - transitionFactor);
        } else {
            particle.vx = targetVx;
            particle.vy = targetVy;
        }
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.hula) {
            const data = particle.gestureData.hula;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.z = data.originalZ;
            delete particle.gestureData.hula;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Scan Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Searchlight scanning gesture for suspicious states
 * @author Emotive Engine Team
 * @module gestures/transforms/scan
 * 
 * GESTURE TYPE:
 * type: 'override' - Takes complete control of particle motion
 * 
 * VISUAL EFFECT:
 * Particles sweep back and forth in a searchlight pattern, pausing at edges
 * to simulate surveillance scanning or paranoid checking behavior.
 */

var scan = {
    name: 'scan',
    emoji: '🔍',
    type: 'override',
    description: 'Searchlight scanning motion',
    
    // Default configuration
    config: {
        scanSpeed: 0.008,         // Slow, deliberate scanning
        scanWidth: 120,           // Width of scan arc in pixels
        pauseDuration: 300,       // Pause at edges in ms
        scanHeight: 40,           // Vertical variation
        layers: 3,                // Number of scan layers
        duration: 3000            // Total animation duration
    },
    
    // Rhythm configuration - scanning syncs to measures
    rhythm: {
        enabled: true,
        syncMode: 'measure',  // Scan sweeps align with measures
        
        // Scan timing to musical structure
        sweepSync: {
            beatsPerSweep: 4,         // One sweep per measure
            pauseOnDownbeat: true,    // Pause at measure start
            reverseOnBar: true,       // Change direction each bar
            curve: 'linear'           // Steady scan motion
        },
        
        // Layer activation by dynamics
        layerSync: {
            quiet: 1,                 // Single layer when quiet
            moderate: 2,              // Two layers at medium
            loud: 3,                  // All layers when loud
            stagger: 'sequential'     // Layers activate in order
        },
        
        // Pause duration on beats
        pauseSync: {
            onBeat: 500,              // Longer pause on beat
            offBeat: 100,             // Quick pause off beat
            accent: 800,              // Extra pause on accent
            subdivision: 'quarter'    // Check every quarter note
        },
        
        // Width modulation
        widthSync: {
            verse: 80,                // Narrow scan in verse
            chorus: 140,              // Wide scan in chorus
            bridge: 100,              // Medium in bridge
            transition: 'smooth'      // Smooth width changes
        },
        
        // Musical tension mapping
        dynamics: {
            forte: { scanSpeed: 0.012, layers: 4 },    // Frantic scanning
            piano: { scanSpeed: 0.004, layers: 1 }     // Slow, single beam
        }
    },
    
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Assign particles to different scan layers
        const layer = Math.floor(Math.random() * this.config.layers);
        
        particle.gestureData.scan = {
            layer: layer,
            phase: Math.random() * Math.PI * 2,  // Random starting phase
            direction: Math.random() < 0.5 ? 1 : -1,  // Start direction
            pauseTimer: 0,
            isPaused: false,
            originalX: particle.x,
            originalY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            scanOffset: (Math.random() - 0.5) * 20,  // Individual variation
            verticalOffset: layer * 30 - 30,  // Layer separation
            initialized: true,
            startTime: Date.now()
        };
    },
    
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.scan) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.scan;
        const speed = motion.scanSpeed || this.config.scanSpeed;
        const width = motion.scanWidth || this.config.scanWidth;
        const pauseDuration = motion.pauseDuration || this.config.pauseDuration;
        
        // Handle pause at edges
        if (data.isPaused) {
            data.pauseTimer -= dt * 16;
            if (data.pauseTimer <= 0) {
                data.isPaused = false;
                data.direction *= -1;  // Reverse direction after pause
            }
        } else {
            // Update scan phase
            data.phase += speed * data.direction * dt;
            
            // Check for edge reached
            const scanPosition = Math.sin(data.phase);
            if (Math.abs(scanPosition) > 0.95) {
                data.isPaused = true;
                data.pauseTimer = pauseDuration;
            }
        }
        
        // Calculate position
        const scanX = Math.sin(data.phase) * width;
        const scanY = Math.cos(data.phase * 0.5) * (this.config.scanHeight / 2);
        
        // Smooth entry transition (first 15% of animation)
        let transitionFactor = 1.0;
        if (progress < 0.15) {
            transitionFactor = progress / 0.15;
            transitionFactor = transitionFactor * transitionFactor; // Ease in
        }
        // Smooth exit transition (last 15% of animation)
        else if (progress > 0.85) {
            transitionFactor = (1 - progress) / 0.15;
            transitionFactor = transitionFactor * transitionFactor; // Ease out
        }
        
        // Apply layer-specific positioning with smooth transitions
        const targetX = centerX + scanX + data.scanOffset;
        const targetY = centerY + scanY + data.verticalOffset;
        
        particle.x = data.originalX + (targetX - data.originalX) * transitionFactor;
        particle.y = data.originalY + (targetY - data.originalY) * transitionFactor;
        
        // Slow down during pauses for more realistic scanning
        if (data.isPaused) {
            particle.vx *= 0.85;
            particle.vy *= 0.85;
        } else {
            // Set velocity based on scan motion
            particle.vx = -Math.cos(data.phase) * width * speed * 60;
            particle.vy = -Math.sin(data.phase * 0.5) * this.config.scanHeight * speed * 30;
        }
        
        // Add slight jitter for realism
        if (Math.random() < 0.02) {
            particle.vx += (Math.random() - 0.5) * 2;
            particle.vy += (Math.random() - 0.5) * 2;
        }
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.scan) {
            const data = particle.gestureData.scan;
            // Restore original velocities for smooth exit
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.scan;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Twist Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Twist gesture - alternating rotational dance motion
 * @author Emotive Engine Team
 * @module gestures/transforms/twist
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a twisting dance motion with alternating rotation and contraction.
 * ║ This is an OVERRIDE gesture that replaces existing particle motion.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     ↻ ⭐ ↺      <- twist left/right
 *    ╱     ╲
 *   ⭐       ⭐    <- particles contract
 *    ╲     ╱
 *     ↺ ⭐ ↻      <- twist opposite
 *
 * USED BY:
 * - Dance gestures
 * - Playful emotions
 * - Music synchronization
 */

/**
 * Twist gesture configuration and implementation
 */
var twist = {
    name: 'twist',
    emoji: '🌀',
    type: 'override', // Replaces existing motion
    description: 'Twisting dance motion with alternating rotation',

    // Default configuration
    config: {
        duration: 1200,      // Animation duration
        rotationAngle: 45,   // Max rotation angle in degrees
        contractionFactor: 0.8, // How much to contract during twist
        twistFrequency: 2,   // Number of twist cycles
        easing: 'smooth',    // Animation curve type
        strength: 0.8,       // Overall motion intensity
        // Particle motion configuration
        particleMotion: {
            type: 'twist',
            rotationAngle: 45,
            contractionFactor: 0.8,
            twistFrequency: 2
        }
    },

    // Rhythm configuration - twist syncs to beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',
        interruptible: true,
        priority: 4,
        blendable: false,  // Override gesture, no blending
        crossfadePoint: 'anyBeat',

        // Twist intensity syncs to beat
        amplitudeSync: {
            onBeat: 1.5,      // Stronger twist on beat
            offBeat: 0.7,     // Lighter between beats
            curve: 'elastic'  // Bouncy twist motion
        },

        // Pattern-specific twisting styles
        patternOverrides: {
            'funk': {
                // Funky twist with more rotation
                rotationAngle: 60,
                contractionFactor: 0.7
            },
            'disco': {
                // Classic disco twist
                twistFrequency: 3,
                rotationAngle: 50
            },
            'latin': {
                // Latin-style hip twist
                rotationAngle: 35,
                contractionFactor: 0.85,
                twistFrequency: 2.5
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     */
    initialize: function(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        particle.gestureData.twist = {
            startX: particle.x,
            startY: particle.y,
            startAngle: Math.atan2(particle.y - motion.centerY, particle.x - motion.centerX),
            startDistance: Math.sqrt(
                Math.pow(particle.x - motion.centerX, 2) +
                Math.pow(particle.y - motion.centerY, 2)
            ),
            initialized: true
        };
    },

    /**
     * Apply twist motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.twist?.initialized) {
            this.initialize(particle, { ...motion, centerX, centerY });
        }

        const config = { ...this.config, ...motion };
        const data = particle.gestureData.twist;
        const strength = config.strength || this.config.strength || 1.0;

        // Calculate twist oscillation
        const twistProgress = progress * config.twistFrequency * Math.PI * 2;
        const twistAmount = Math.sin(twistProgress) * strength;

        // Apply rhythm modulation if present
        let rotationAngle = config.rotationAngle;
        let contractionFactor = config.contractionFactor;

        if (motion.rhythmModulation) {
            rotationAngle *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            contractionFactor = 1 - ((1 - contractionFactor) * (motion.rhythmModulation.amplitudeMultiplier || 1));
        }

        // Convert rotation to radians
        const rotationRad = (rotationAngle * Math.PI / 180) * twistAmount;

        // Calculate contraction (pull particles closer during twist)
        const currentContraction = 1 - ((1 - contractionFactor) * Math.abs(twistAmount));

        // Apply twist transformation
        const newAngle = data.startAngle + rotationRad;
        const newDistance = data.startDistance * currentContraction;

        // Calculate new position
        const targetX = centerX + Math.cos(newAngle) * newDistance;
        const targetY = centerY + Math.sin(newAngle) * newDistance;

        // Smoothly move to target position
        const moveStrength = 0.15 * strength;
        particle.x += (targetX - particle.x) * moveStrength;
        particle.y += (targetY - particle.y) * moveStrength;

        // Add some velocity for fluid motion
        particle.vx = (targetX - particle.x) * 0.05;
        particle.vy = (targetY - particle.y) * 0.05;

        // Add slight vertical bounce for more dynamic feel
        const bounceAmount = Math.sin(progress * Math.PI * 4) * 5 * strength;
        particle.y += bounceAmount * 0.1;

        // Smooth ending
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vx *= endFactor;
            particle.vy *= endFactor;
        }

    },

    /**
     * Clean up gesture data when complete
     */
    cleanup: function(particle) {
        if (particle.gestureData?.twist) {
            delete particle.gestureData.twist;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Wave Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Wave gesture - infinity pattern flow
 * @author Emotive Engine Team
 * @module gestures/effects/wave
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a flowing wave motion with particles moving in an infinity (∞) pattern.   
 * ║ This is an OVERRIDE gesture that creates smooth, hypnotic figure-8 movements.     
 * ║ Particles phase in and out for a dreamlike effect.                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ∞ Infinity Pattern
 *      ↗ → ↘     ↙ ← ↖
 *     ⭐     ⭐ ⭐     ⭐
 *      ↖ ← ↙     ↘ → ↗
 *         (continuous flow)
 * 
 * USED BY:
 * - Hypnotic/mesmerizing effects
 * - Dreamy transitions
 * - Magical gestures
 * - Flow states
 */

/**
 * Wave gesture configuration and implementation
 */
var wave = {
    name: 'wave',
    emoji: '🌊',
    type: 'override', // Completely replaces motion
    description: 'Infinity pattern flow with phasing',
    
    // Default configuration
    config: {
        // Musical duration - wave flows for exactly 1 bar
        musicalDuration: {
            musical: true,
            bars: 1,           // Default to 1 bar of wave motion
            minBeats: 4,       // Minimum 1 bar
            maxBeats: 16       // Maximum 4 bars
        },
        
        // Musical phases of the wave gesture
        phases: [
            { name: 'gather', beats: 0.5 },     // Particles gather
            { name: 'rise', beats: 0.5 },       // Begin rising motion
            { name: 'waveLeft', beats: 1 },     // Wave to the left
            { name: 'waveRight', beats: 1 },    // Wave to the right
            { name: 'settle', beats: 1 }        // Settle back to center
        ],
        
        amplitude: 40,         // Infinity pattern width
        frequency: 1,          // Complete cycle count
        phaseShift: 0.3,       // Particle timing offset
        liftHeight: 20,        // Vertical movement range
        fadeInOut: true,       // Enable opacity transitions
        smoothness: 0.1,       // Motion fluidity factor
        easing: 'sine',        // Animation curve type
        strength: 1.0,         // Overall effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'wave',
            strength: 1.0,     // Wave motion strength
            amplitude: 50      // Pattern size
        }
    },
    
    // Rhythm configuration - flowing wave patterns synchronized to musical waves and phrases
    rhythm: {
        enabled: true,
        syncMode: 'wave',    // Flow with musical wave patterns and melodic contours
        
        // Amplitude responds to musical dynamics and melodic range
        amplitudeSync: {
            onWave: 65,           // Large waves during musical waves
            onStatic: 25,         // Small waves during static sections
            curve: 'flowing'      // Smooth, continuous transitions
        },
        
        // Frequency matches musical phrase rhythm
        frequencySync: {
            mode: 'phrase',
            slow: 0.7,            // Slower waves for slow phrases
            fast: 1.8,            // Faster waves for quick phrases
            curve: 'melodic'      // Follows melodic contour
        },
        
        // Duration automatically syncs to bars via musicalDuration config
        durationSync: {
            mode: 'bars',         // Uses bars from musicalDuration
            adaptToPhrase: true,  // Extend to complete musical phrases
            sustain: true         // Maintain wave through phrase
        },
        
        // Phase shift creates ensemble wave effects
        phaseSync: {
            enabled: true,
            multiplier: 0.5,      // Moderate phase variation
            type: 'ensemble'      // Creates group wave patterns
        },
        
        // Response to melodic contour
        melodicResponse: {
            enabled: true,
            multiplier: 1.4,      // Wave amplitude follows melody
            type: 'amplitude'     // Affects wave size
        },
        
        // Style variations for different music types
        patternOverrides: {
            'ambient': {
                // Slow, hypnotic waves
                amplitudeSync: { onWave: 80, onStatic: 40, curve: 'hypnotic' },
                frequencySync: { slow: 0.5, fast: 1.2 },
                durationSync: { minBeats: 16, maxBeats: 64 }
            },
            'ocean': {
                // Natural, oceanic wave patterns
                amplitudeSync: { onWave: 90, onStatic: 20, curve: 'natural' },
                phaseSync: { multiplier: 0.8 },
                melodicResponse: { multiplier: 1.8 }
            },
            'electronic': {
                // Precise, digital wave forms
                amplitudeSync: { onWave: 70, onStatic: 30, curve: 'digital' },
                frequencySync: { slow: 0.8, fast: 2.5, curve: 'precise' }
            },
            'orchestral': {
                // Rich, complex wave interactions
                amplitudeSync: { onWave: 75, onStatic: 35 },
                phaseSync: { multiplier: 0.7 },
                melodicResponse: { multiplier: 2.0 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Powerful, sweeping waves
                amplitudeSync: { 
                    onWave: { multiplier: 1.8 },
                    onStatic: { multiplier: 1.4 }
                },
                frequencySync: { multiplier: 1.3 },
                melodicResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, subtle waves
                amplitudeSync: { 
                    onWave: { multiplier: 0.6 },
                    onStatic: { multiplier: 0.4 }
                },
                frequencySync: { multiplier: 0.7 },
                melodicResponse: { multiplier: 1.1 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial position relative to center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const angle = Math.atan2(dy, dx);
        const radius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for wave motion
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        particle.gestureData.wave = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            baseOpacity: particle.opacity || particle.life || 1,
            angle: angle,
            radius: radius,
            offset: Math.random() * Math.PI * 2, // Random phase offset
            role: Math.random(), // 0-1 for variation
            direction: direction, // Random wave direction
            initialized: true
        };
    },
    
    /**
     * Apply wave motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.wave?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.wave;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing to progress
        const easeProgress = this.easeInOutSine(progress);
        
        // Add phase shift based on particle role (creates wave effect)
        const phaseShift = data.role * config.phaseShift;
        const adjustedPhase = Math.max(0, easeProgress - phaseShift);
        
        // Calculate infinity pattern (lemniscate) with direction
        const t = adjustedPhase * Math.PI * 2 * config.frequency * data.direction + data.offset;
        
        // Scale amplitude based on distance from center
        const radiusFactor = 0.5 + (data.radius / 100) * 0.5;
        const amplitude = config.amplitude * radiusFactor * strength * particle.scaleFactor;
        
        // Infinity pattern equations
        const infinityX = Math.sin(t) * amplitude;
        const infinityY = Math.sin(t * 2) * amplitude * 0.3; // Smaller vertical component
        
        // Add vertical lift effect
        const lift = -Math.abs(Math.sin(easeProgress * Math.PI)) * config.liftHeight * particle.scaleFactor;
        
        // Calculate target position
        const targetX = centerX + infinityX;
        const targetY = centerY + infinityY + lift;
        
        // Smooth movement with role-based variation
        const smoothness = config.smoothness + data.role * 0.12;
        
        // Apply position with smoothing
        particle.x += (targetX - particle.x) * smoothness;
        particle.y += (targetY - particle.y) * smoothness;
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.3;
        particle.vy = (targetY - particle.y) * 0.3;
        
        // Apply fade effect if enabled
        if (config.fadeInOut) {
            let fadeFactor;
            
            if (adjustedPhase < 0.1) {
                // Fade in
                fadeFactor = adjustedPhase / 0.1;
            } else if (adjustedPhase > 0.9) {
                // Fade out
                fadeFactor = (1 - adjustedPhase) / 0.1;
            } else {
                // Full opacity with sine variation
                fadeFactor = 0.5 + Math.sin(adjustedPhase * Math.PI) * 0.5;
            }
            
            particle.opacity = data.baseOpacity * (0.3 + fadeFactor * 0.7);
            
            // Update life for particles that use it instead of opacity
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
        }
        
        // Smooth ending
        if (progress >= 0.95) {
            const endFactor = (1 - progress) * 20;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
            
            // Restore opacity
            if (config.fadeInOut) {
                particle.opacity = data.baseOpacity * endFactor;
                if (particle.life !== undefined) {
                    particle.life = particle.opacity;
                }
            }
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.wave) {
            const data = particle.gestureData.wave;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.opacity = data.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.wave;
        }
    },
    
    /**
     * Sine easing for smooth wave motion
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine: function(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Drift Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Drift gesture - controlled floating motion
 * @author Emotive Engine Team
 * @module gestures/effects/drift
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a dreamy drifting effect where particles float outward then return home.  
 * ║ This is an OVERRIDE gesture with smooth, controlled movement and fading effects.  
 * ║ Perfect for transitions, sleepy states, or ethereal moments.                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Start         Drift Out        Hold         Return
 *      ⭐           · · ⭐           · · ·          ⭐
 *     ⭐⭐    →    · ⭐ · ⭐    →   · · · ·    →   ⭐⭐
 *      ⭐           ⭐ · ·           · · ·          ⭐
 *   (grouped)     (spread)        (faded)      (regrouped)
 * 
 * USED BY:
 * - Sleepy/drowsy states
 * - Dreamy transitions
 * - Dispersal effects
 * - Meditation/calm states
 */

/**
 * Drift gesture configuration and implementation
 */
var drift = {
    name: 'drift',
    emoji: '☁️',
    type: 'override', // Completely replaces motion
    description: 'Controlled floating with fade effects',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        distance: 50,          // Maximum drift distance
        angle: 45,             // Primary drift direction
        returnToOrigin: true,  // Return to starting position
        fadeOut: false,        // Apply fade effect during drift (disabled to prevent disappearing)
        holdTime: 0.2,         // Pause duration at drift peak
        turbulence: 0.1,       // Random movement variation amount
        angleSpread: 45,       // Directional spread range
        smoothness: 0.08,      // Movement fluidity factor
        easing: 'ease',        // Animation curve type
        strength: 1.0,         // Overall drift intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'drift',
            strength: 1.0,     // Drift motion strength
            distance: 60       // Maximum drift distance
        }
    },
    
    // Rhythm configuration - ethereal drift following ambient musical textures
    rhythm: {
        enabled: true,
        syncMode: 'ambient',  // Sync to ambient musical textures
        
        // Distance varies with musical dynamics
        distanceSync: {
            quiet: 30,            // Small drift in quiet sections
            loud: 80,             // Large drift in loud sections
            crescendo: 'expand',  // Expand drift on crescendos
            diminuendo: 'contract' // Contract drift on diminuendos
        },
        
        // Angle follows harmonic progression
        angleSync: {
            major: 45,            // Upward drift in major keys
            minor: 225,           // Downward drift in minor keys
            modulation: 'smooth', // Smooth angle changes
            cadence: 'return'     // Return to center on cadences
        },
        
        // Hold time syncs to phrase length
        holdSync: {
            shortPhrase: 0.1,     // Brief hold for short phrases
            longPhrase: 0.4,      // Extended hold for long phrases
            fermata: 'sustain'    // Sustain hold on fermatas
        },
        
        // Gentle accent response
        accentResponse: {
            enabled: true,
            multiplier: 1.3,      // Subtle drift increase on accents
            type: 'distance'      // Accent affects drift distance
        },
        
        // Pattern-specific drift styles
        patternOverrides: {
            'ambient': {
                // Slow, ethereal drifting
                distanceSync: { quiet: 40, loud: 100 },
                holdSync: { shortPhrase: 0.3, longPhrase: 0.6 }
            },
            'classical': {
                // Elegant, controlled drifting
                angleSync: { major: 30, minor: 210 },
                distanceSync: { quiet: 25, loud: 60 }
            },
            'jazz': {
                // Syncopated, unpredictable drifting
                angleSync: { 
                    major: 60, 
                    minor: 240,
                    swing: true,
                    syncopated: true
                }
            },
            'new_age': {
                // Meditative, flowing drift
                distanceSync: { quiet: 35, loud: 70 },
                holdSync: { shortPhrase: 0.4, longPhrase: 0.8 },
                angleSync: { modulation: 'gradual' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Expansive, bold drifting
                distanceSync: { 
                    quiet: { multiplier: 1.5 },
                    loud: { multiplier: 1.8 }
                },
                holdSync: { multiplier: 1.2 },
                accentResponse: { multiplier: 1.6 }
            },
            piano: {
                // Delicate, subtle drifting
                distanceSync: { 
                    quiet: { multiplier: 0.6 },
                    loud: { multiplier: 0.8 }
                },
                holdSync: { multiplier: 0.8 },
                accentResponse: { multiplier: 1.1 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate drift direction
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        let driftAngle = Math.atan2(dy, dx);
        
        // Add some spread to the drift angle
        const config = { ...this.config, ...motion };
        const spreadRad = (config.angleSpread * Math.PI / 180);
        const angleOffset = (Math.random() - 0.5) * spreadRad;
        driftAngle += angleOffset;
        
        // Determine home position (closer to center)
        const homeRadius = 30 + Math.random() * 30;
        
        particle.gestureData.drift = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            baseOpacity: particle.opacity || particle.life || 1,
            driftAngle: driftAngle,
            angleOffset: angleOffset,
            homeRadius: homeRadius * particle.scaleFactor,
            homeX: centerX + Math.cos(driftAngle) * homeRadius,
            homeY: centerY + Math.sin(driftAngle) * homeRadius,
            role: Math.random(), // 0-1 for timing variation
            turbulencePhase: Math.random() * Math.PI * 2,
            initialized: true
        };
    },
    
    /**
     * Apply drift motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.drift?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.drift;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutCubic(progress);
        
        // Add role-based phase shift for staggered movement
        const adjustedPhase = Math.max(0, easeProgress - data.role * 0.1);
        
        let targetX, targetY;
        let currentRadius;
        
        // Determine phase of drift
        if (!config.returnToOrigin) {
            // Simple outward drift
            const driftProgress = adjustedPhase;
            currentRadius = data.homeRadius + driftProgress * config.distance * strength * particle.scaleFactor;
            
        } else if (adjustedPhase < 0.4) {
            // Phase 1: Move to home position
            const homeProgress = adjustedPhase / 0.4;
            const easedHome = this.easeOutQuad(homeProgress);
            targetX = data.startX + (data.homeX - data.startX) * easedHome;
            targetY = data.startY + (data.homeY - data.startY) * easedHome;
            
        } else if (adjustedPhase < 0.6 + config.holdTime) {
            // Phase 2: Drift outward
            const driftPhase = (adjustedPhase - 0.4) / (0.2 + config.holdTime);
            currentRadius = data.homeRadius + 
                Math.sin(driftPhase * Math.PI * 0.5) * config.distance * strength * particle.scaleFactor;
            
        } else {
            // Phase 3: Return to origin
            const returnPhase = (adjustedPhase - 0.6 - config.holdTime) / (0.4 - config.holdTime);
            currentRadius = data.homeRadius + 
                Math.cos(returnPhase * Math.PI * 0.5) * config.distance * strength * particle.scaleFactor;
        }
        
        // Calculate position with turbulence
        if (currentRadius !== undefined) {
            // Add turbulence
            data.turbulencePhase += config.turbulence * dt;
            const turbulenceX = Math.sin(data.turbulencePhase) * config.turbulence * 10;
            const turbulenceY = Math.cos(data.turbulencePhase * 1.3) * config.turbulence * 10;
            
            const angle = data.driftAngle + data.angleOffset;
            targetX = centerX + Math.cos(angle) * currentRadius + turbulenceX;
            targetY = centerY + Math.sin(angle) * currentRadius + turbulenceY;
        }
        
        // Smooth movement with role variation
        const smoothness = config.smoothness + data.role * 0.08;
        particle.x += (targetX - particle.x) * smoothness;
        particle.y += (targetY - particle.y) * smoothness;
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.25;
        particle.vy = (targetY - particle.y) * 0.25;
        
        // Apply fade effect
        if (config.fadeOut) {
            let fadeFactor;
            
            if (progress < 0.25) {
                // Fade in
                fadeFactor = 0.3 + (progress / 0.25) * 0.7;
            } else if (progress < 0.75) {
                // Main phase with sine variation
                fadeFactor = 0.7 + Math.sin((progress - 0.25) * Math.PI / 0.5) * 0.3;
            } else {
                // Fade back
                fadeFactor = (1 - progress) * 4;
            }
            
            particle.opacity = data.baseOpacity * fadeFactor;
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
        }
        
        // Clean ending
        if (progress >= 0.99) {
            particle.vx = data.originalVx * 0.1;
            particle.vy = data.originalVy * 0.1;
            
            if (config.fadeOut) {
                particle.opacity = data.baseOpacity;
                if (particle.life !== undefined) {
                    particle.life = data.baseOpacity;
                }
            }
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.drift) {
            const data = particle.gestureData.drift;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.opacity = data.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.drift;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic: function(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeOutQuad: function(t) {
        return t * (2 - t);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Flicker Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Flicker gesture - opacity and motion variation
 * @author Emotive Engine Team
 * @module gestures/effects/flicker
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a flickering effect with rapid opacity changes and subtle motion jitter.  
 * ║ This is a BLENDING gesture that adds visual instability, perfect for glitches,   
 * ║ electrical effects, or nervous energy.                                            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Frame 1      Frame 2      Frame 3      Frame 4
 *      ⭐          ·⭐·         ⭐⭐⭐         ·⭐
 *    (100%)       (30%)        (120%)        (50%)
 *    normal       dimmed       bright        partial
 * 
 * USED BY:
 * - Glitch/digital effects
 * - Electrical sparks
 * - Nervous/unstable states
 * - Teleportation effects
 * - Broken/malfunctioning states
 */

/**
 * Flicker gesture configuration and implementation
 */
var flicker = {
    name: 'flicker',
    emoji: '⚡',
    type: 'blending', // Adds to existing motion
    description: 'Rapid opacity changes with motion jitter',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        flickerRate: 15,       // Flicker speed
        frequency: 6,          // Flicker count
        minOpacity: 0.3,       // Minimum visibility
        maxOpacity: 1.0,       // Maximum visibility
        jitterAmount: 2,       // Position wobble range
        colorShift: false,     // Enable hue variation
        strobe: false,         // Regular vs random pattern
        pulseMode: false,      // Smooth vs sharp transitions
        groupFlicker: 0.3,     // Group synchronization probability
        easing: 'linear',      // Animation curve type
        strength: 0.7,         // Overall effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'flicker',
            strength: 0.7,     // Particle flicker strength
            frequency: 6       // Particle flicker rate
        }
    },
    
    // Rhythm configuration - flicker syncs to subdivisions
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',  // Flicker on subdivisions
        
        // Flicker rate syncs to tempo
        rateSync: {
            subdivision: 'sixteenth',  // Flicker on 16th notes
            onBeat: 30,               // Rapid flicker on beat
            offBeat: 10,              // Slower between beats
            triplet: 20,              // Medium on triplets
            curve: 'step'             // Instant changes
        },
        
        // Opacity patterns with rhythm
        opacitySync: {
            pattern: 'HLMH',          // High-Low-Medium-High
            subdivision: 'eighth',     // Pattern rate
            onAccent: 0.1,           // Nearly off on accent (dramatic)
            regular: 0.5              // Medium normally
        },
        
        // Jitter amount varies
        jitterSync: {
            onBeat: 5,                // Big jitter on beat
            offBeat: 1,               // Minimal between
            accent: 10,               // Extreme on accent
            curve: 'random'           // Chaotic motion
        },
        
        // Strobe modes
        strobeSync: {
            verse: false,             // No strobe in verse
            chorus: true,             // Strobe in chorus
            drop: 'intense',          // Intense strobe on drop
            pattern: 'XOXO'          // Strobe pattern
        },
        
        // Musical dynamics
        dynamics: {
            forte: { flickerRate: 25, jitterAmount: 5, minOpacity: 0.1 },
            piano: { flickerRate: 8, jitterAmount: 1, minOpacity: 0.5 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize: function(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const config = { ...this.config, ...motion };
        
        // Determine if this particle is part of a synchronized group
        const isGrouped = Math.random() < config.groupFlicker;
        
        particle.gestureData.flicker = {
            baseOpacity: particle.opacity || particle.life || 1,
            baseColor: particle.color,
            baseX: particle.x,
            baseY: particle.y,
            flickerTimer: 0,
            lastFlicker: 0,
            flickerState: true,
            isGrouped: isGrouped,
            groupId: isGrouped ? Math.floor(Math.random() * 3) : -1, // Assign to flicker group
            phase: Math.random() * Math.PI * 2,  // Random phase offset
            colorHue: 0,
            initialized: true
        };
    },
    
    /**
     * Apply flicker effect to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.flicker?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.flicker;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Update flicker timer
        data.flickerTimer += dt * config.flickerRate;
        
        // Calculate opacity based on mode
        let opacityMultiplier;
        
        if (config.strobe) {
            // Strobe pattern - regular on/off
            const strobePhase = (data.flickerTimer + data.phase) % 1;
            opacityMultiplier = strobePhase < 0.5 ? 1 : config.minOpacity;
            
        } else if (config.pulseMode) {
            // Smooth pulsing
            const pulsePhase = data.flickerTimer + data.phase;
            opacityMultiplier = config.minOpacity + 
                (config.maxOpacity - config.minOpacity) * (Math.sin(pulsePhase) * 0.5 + 0.5);
            
        } else {
            // Random flicker
            if (data.flickerTimer - data.lastFlicker > 1) {
                data.lastFlicker = data.flickerTimer;
                
                // Group flicker logic
                if (data.isGrouped) {
                    // Flicker based on group timing
                    const groupPhase = Math.floor(data.flickerTimer) % 3;
                    data.flickerState = groupPhase === data.groupId;
                } else {
                    // Individual random flicker
                    data.flickerState = Math.random() > 0.3;
                }
            }
            
            // Calculate target opacity
            const targetOpacity = data.flickerState ? 
                config.maxOpacity : 
                config.minOpacity + Math.random() * 0.3;
            
            // Smooth transition for less harsh flicker
            const currentOpacity = particle.opacity / data.baseOpacity;
            opacityMultiplier = currentOpacity + (targetOpacity - currentOpacity) * 0.3;
        }
        
        // Apply opacity with strength
        const finalOpacity = data.baseOpacity * (1 + (opacityMultiplier - 1) * strength);
        particle.opacity = Math.max(0, Math.min(1, finalOpacity)); // Clamp to 0-1
        
        // Update life if used instead of opacity
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
        
        // Apply position jitter
        if (config.jitterAmount > 0 && opacityMultiplier > config.minOpacity) {
            const jitter = config.jitterAmount * strength * particle.scaleFactor;
            const jitterX = (Math.random() - 0.5) * jitter * opacityMultiplier;
            const jitterY = (Math.random() - 0.5) * jitter * opacityMultiplier;
            
            particle.vx += jitterX * 0.1 * dt;
            particle.vy += jitterY * 0.1 * dt;
        }
        
        // Apply color shift if enabled
        if (config.colorShift && particle.color) {
            data.colorHue += 0.01 * dt;
            const hueShift = Math.sin(data.colorHue) * 30; // ±30 degree hue shift
            particle.color = this.shiftHue(data.baseColor, hueShift * strength);
        }
        
        // Smooth fade in/out at gesture boundaries
        let fadeFactor = 1;
        if (progress < 0.1) {
            fadeFactor = progress / 0.1;  // Fade in
        } else if (progress > 0.9) {
            fadeFactor = (1 - progress) / 0.1;  // Fade out
        }
        
        particle.opacity *= fadeFactor;
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
        
        // Dampen velocity slightly for stability
        if (progress > 0.8) {
            particle.vx *= 0.95;
            particle.vy *= 0.95;
        }
    },
    
    /**
     * Shift the hue of a color
     * @param {string} color - Hex color string
     * @param {number} degrees - Degrees to shift hue
     * @returns {string} New hex color
     */
    shiftHue: function(color, degrees) {
        // Simple hue shift implementation
        // In production, use a proper color library
        if (!color || !color.startsWith('#')) return color;
        
        // Convert hex to RGB
        const hex = color.slice(1);
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;
        
        // Simple hue rotation (approximate)
        const hueRad = degrees * Math.PI / 180;
        const cos = Math.cos(hueRad);
        const sin = Math.sin(hueRad);
        
        // Rotate around luminance axis (simplified)
        const newR = r * cos - g * sin;
        const newG = r * sin + g * cos;
        const newB = b;
        
        // Convert back to hex
        const toHex = (n) => {
            const val = Math.max(0, Math.min(255, Math.round(n * 255)));
            return val.toString(16).padStart(2, '0');
        };
        
        return '#' + toHex(newR) + toHex(newG) + toHex(newB);
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.flicker) {
            const data = particle.gestureData.flicker;
            particle.opacity = data.baseOpacity;
            particle.color = data.baseColor;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.flicker;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Burst Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Burst gesture - explosive outward motion
 * @author Emotive Engine Team
 * @module gestures/effects/burst
 */

var burst = {
    name: 'burst',
    emoji: '💥',
    type: 'blending',
    description: 'Explosive outward burst from center',
    
    // Default configuration
    config: {
        decay: 0.5,      // Force reduction over time
        strength: 2.0    // Initial explosion intensity
    },
    
    // Rhythm configuration - explosive bursts on strong beats
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Burst on strong beats and accents
        
        // Strength syncs to beat intensity
        strengthSync: {
            onBeat: 3.5,          // Powerful burst on beats
            offBeat: 1.0,         // Gentle burst off-beat
            curve: 'explosion'    // Sharp attack, rapid decay
        },
        
        // Decay rate responds to tempo
        decaySync: {
            mode: 'tempo',
            fast: 0.8,            // Quick decay for fast songs
            slow: 0.3,            // Slow decay for slow songs
            curve: 'exponential'
        },
        
        // Duration matches beat timing
        durationSync: {
            mode: 'beats',
            beats: 0.5,           // Half-beat burst duration
            sustain: false        // No sustain, pure burst
        },
        
        // Strong response to accents
        accentResponse: {
            enabled: true,
            multiplier: 2.5,      // Massive burst on accents
            type: 'strength'      // Accent affects burst power
        },
        
        // Pattern-specific burst styles
        patternOverrides: {
            'rock': {
                // Heavy, aggressive bursts
                strengthSync: { onBeat: 4.0, offBeat: 1.5 },
                decaySync: { fast: 0.6, slow: 0.4 }
            },
            'electronic': {
                // Sharp, precise bursts
                strengthSync: { onBeat: 3.8, offBeat: 0.8, curve: 'sharp' },
                decaySync: { fast: 0.9, slow: 0.7 }
            },
            'jazz': {
                // Syncopated, varied bursts
                strengthSync: { 
                    onBeat: 2.8, 
                    offBeat: 1.8,  // Strong off-beat emphasis
                    swing: true 
                },
                decaySync: { fast: 0.5, slow: 0.2 }
            },
            'orchestral': {
                // Dynamic, expressive bursts
                strengthSync: { onBeat: 3.2, offBeat: 0.5 },
                accentResponse: { multiplier: 3.0 }  // Very responsive to dynamics
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Explosive, powerful bursts
                strengthSync: { 
                    onBeat: { multiplier: 2.0 },
                    offBeat: { multiplier: 1.5 }
                },
                decaySync: { multiplier: 0.7 },  // Slower decay for impact
                accentResponse: { multiplier: 3.5 }
            },
            piano: {
                // Subtle, gentle bursts
                strengthSync: { 
                    onBeat: { multiplier: 0.6 },
                    offBeat: { multiplier: 0.3 }
                },
                decaySync: { multiplier: 1.3 },  // Faster decay for gentleness
                accentResponse: { multiplier: 1.8 }
            }
        }
    },
    
    /**
     * Apply explosive burst motion to particle
     * Pushes particles radially outward with decaying force
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Calculate force decay over gesture duration
        const decay = motion.decay || this.config.decay;
        const strength = (motion.strength || this.config.strength) * (1 - progress * decay);
        
        // Calculate direction from center to particle
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Apply outward force if particle isn't at center
        if (distance > 1) {
            // Normalize direction and apply explosive force
            particle.vx += (dx / distance) * strength * 2 * dt;
            particle.vy += (dy / distance) * strength * 2 * dt;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Directional Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Directional gesture - move particles in specific direction
 * @author Emotive Engine Team
 * @module gestures/effects/directional
 */

var directional = {
    name: 'directional',
    emoji: '➡️',
    type: 'blending',
    description: 'Move particles in a specific direction',
    
    // Default configuration
    config: {
        angle: 0,                // Movement direction in degrees
        returnToOrigin: false,   // Whether particles return to start
        strength: 1.0           // Force intensity
    },
    
    // Rhythm configuration - directional movement following musical flow
    rhythm: {
        enabled: true,
        syncMode: 'flow',  // Follow musical flow and direction
        
        // Direction changes with musical progression
        angleSync: {
            verse: 0,             // Right movement in verses
            chorus: 90,           // Upward movement in choruses  
            bridge: 180,          // Left movement in bridges
            outro: 270,           // Downward movement in outros
            transition: 'smooth'  // Smooth direction changes
        },
        
        // Strength pulses with rhythm
        strengthSync: {
            onBeat: 1.8,          // Strong push on beats
            offBeat: 0.6,         // Gentle drift off-beat
            curve: 'wave'         // Wave-like motion curve
        },
        
        // Return motion syncs to musical sections
        returnSync: {
            enabled: true,
            onSectionChange: true, // Return on section changes
            duration: 'transition', // Use transition timing
            strength: 1.2
        },
        
        // Accent response affects direction
        accentResponse: {
            enabled: true,
            multiplier: 2.0,      // Sharp directional push on accents
            type: 'strength'      // Accent affects movement force
        },
        
        // Pattern-specific directional styles
        patternOverrides: {
            'march': {
                // Military-style directional movement
                angleSync: { verse: 0, chorus: 0 }, // Always forward
                strengthSync: { onBeat: 2.5, offBeat: 1.0 }
            },
            'waltz': {
                // Flowing, circular directional movement
                angleSync: { 
                    verse: 45, 
                    chorus: 135,
                    bridge: 225,
                    outro: 315,
                    transition: 'circular'
                }
            },
            'swing': {
                // Syncopated directional swaying
                strengthSync: { 
                    onBeat: 1.6, 
                    offBeat: 1.4,  // Strong off-beat emphasis
                    swing: true 
                }
            },
            'electronic': {
                // Sharp, precise directional cuts
                angleSync: { transition: 'instant' },
                strengthSync: { onBeat: 2.2, offBeat: 0.4, curve: 'sharp' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, decisive direction changes
                strengthSync: { 
                    onBeat: { multiplier: 1.6 },
                    offBeat: { multiplier: 1.2 }
                },
                angleSync: { transition: 'sharp' },
                accentResponse: { multiplier: 2.5 }
            },
            piano: {
                // Gentle, subtle directional drift
                strengthSync: { 
                    onBeat: { multiplier: 0.7 },
                    offBeat: { multiplier: 0.8 }
                },
                angleSync: { transition: 'gradual' },
                accentResponse: { multiplier: 1.4 }
            }
        }
    },
    
    /**
     * Initialize directional movement data
     * Stores particle's starting position for return motion
     */
    initialize: function(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.directional = {
            initialX: particle.x,
            initialY: particle.y
        };
    },
    
    /**
     * Apply directional force to particle
     * Pushes particles in specified direction with optional return
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.directional) {
            this.initialize(particle);
        }
        
        // Convert angle to radians for calculation
        const angle = (motion.angle || this.config.angle) * Math.PI / 180;
        const strength = motion.strength || this.config.strength;
        
        // Apply directional force
        particle.vx += Math.cos(angle) * strength * 0.3 * dt;
        particle.vy += Math.sin(angle) * strength * 0.3 * dt;
        
        // Optional return motion in second half of gesture
        if (motion.returnToOrigin && progress > 0.5) {
            const returnProgress = (progress - 0.5) * 2;
            const data = particle.gestureData.directional;
            // Calculate return force toward initial position
            const dx = data.initialX - particle.x;
            const dy = data.initialY - particle.y;
            particle.vx += dx * returnProgress * 0.02 * dt;
            particle.vy += dy * returnProgress * 0.02 * dt;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Settle Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Settle gesture - gradually reduce velocity
 * @author Emotive Engine Team
 * @module gestures/effects/settle
 */

var settle = {
    name: 'settle',
    emoji: '🍃',
    type: 'blending',
    description: 'Gradually settle particles to rest',
    
    // Default configuration
    config: {
        damping: 0.02,     // Velocity reduction rate
        threshold: 0.01    // Minimum velocity before stop
    },
    
    // Rhythm configuration - gradual settling synchronized to musical resolution
    rhythm: {
        enabled: true,
        syncMode: 'resolution', // Settle during chord resolutions and phrase endings
        
        // Damping rate responds to musical tension/release
        dampingSync: {
            onResolution: 0.035,    // Faster settling on resolution
            onTension: 0.015,       // Slower settling during tension
            curve: 'gradual'        // Smooth, natural decay
        },
        
        // Threshold adapts to dynamic level
        thresholdSync: {
            mode: 'dynamics',
            forte: 0.02,            // Higher threshold for loud music
            piano: 0.005,           // Lower threshold for quiet music
            curve: 'exponential'
        },
        
        // Duration follows musical phrase structure
        durationSync: {
            mode: 'phrase',
            minBeats: 2,            // Minimum 2-beat settling
            maxBeats: 12,           // Maximum phrase-length settling
            sustain: true           // Maintain settling through resolution
        },
        
        // Response to cadential movements
        cadenceResponse: {
            enabled: true,
            multiplier: 1.6,        // Enhanced settling on cadences
            type: 'damping'         // Affects settling rate
        },
        
        // Style variations for different music types
        patternOverrides: {
            'ambient': {
                // Slow, atmospheric settling
                dampingSync: { onResolution: 0.025, onTension: 0.008, curve: 'atmospheric' },
                durationSync: { minBeats: 8, maxBeats: 32 }
            },
            'jazz': {
                // Smooth settling with swing feel
                dampingSync: { onResolution: 0.040, onTension: 0.020 },
                cadenceResponse: { multiplier: 1.8 }
            },
            'classical': {
                // Expressive settling following harmonic rhythm
                dampingSync: { onResolution: 0.045, onTension: 0.012, curve: 'expressive' },
                cadenceResponse: { multiplier: 2.0 }
            },
            'minimalist': {
                // Very gradual, meditative settling
                dampingSync: { onResolution: 0.020, onTension: 0.005 },
                durationSync: { minBeats: 16, maxBeats: 64 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Decisive, clear settling
                dampingSync: { 
                    onResolution: { multiplier: 1.4 },
                    onTension: { multiplier: 0.8 }
                },
                thresholdSync: { multiplier: 2.0 },
                cadenceResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, soft settling
                dampingSync: { 
                    onResolution: { multiplier: 0.7 },
                    onTension: { multiplier: 1.2 }
                },
                thresholdSync: { multiplier: 0.5 },
                cadenceResponse: { multiplier: 1.3 }
            }
        }
    },
    
    /**
     * Apply settling effect to particle
     * Gradually reduces velocity until particles come to rest
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        const damping = motion.damping || this.config.damping;
        const threshold = motion.threshold || this.config.threshold;
        
        // Apply exponential velocity damping
        particle.vx *= Math.max(0, 1 - damping * dt * 60);
        particle.vy *= Math.max(0, 1 - damping * dt * 60);
        
        // Stop completely when velocity falls below threshold
        if (Math.abs(particle.vx) < threshold) particle.vx = 0;
        if (Math.abs(particle.vy) < threshold) particle.vy = 0;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fade Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Fade gesture - opacity fade effect
 * @author Emotive Engine Team
 * @module gestures/effects/fade
 */

var fade = {
    name: 'fade',
    emoji: '👻',
    type: 'blending',
    description: 'Fade particle opacity',
    
    // Default configuration
    config: {
        fadeIn: false,      // Enable fade in effect
        fadeOut: true,      // Enable fade out effect
        minOpacity: 0,      // Minimum opacity level
        maxOpacity: 1       // Maximum opacity level
    },
    
    // Rhythm configuration - fades sync to musical dynamics
    rhythm: {
        enabled: true,
        syncMode: 'dynamic',  // Fade with volume/intensity changes
        
        // Opacity modulation with beat
        opacitySync: {
            onBeat: 0.9,              // Nearly visible on beat
            offBeat: 0.3,             // Ghostly between beats
            subdivision: 'eighth',     // Check every 8th note
            curve: 'exponential'      // Sharp opacity changes
        },
        
        // Fade timing with musical structure
        fadePhaseSync: {
            verse: { fadeIn: true, fadeOut: false },    // Build in verse
            chorus: { fadeIn: false, fadeOut: false },  // Full visibility
            bridge: { fadeIn: true, fadeOut: true },    // In and out
            outro: { fadeIn: false, fadeOut: true }     // Fade to end
        },
        
        // Pulse with rhythm
        pulseSync: {
            enabled: true,
            frequency: 'quarter',     // Pulse every quarter note
            intensity: 0.2,           // Pulse depth
            onAccent: 0.4            // Deeper pulse on accents
        },
        
        // Musical dynamics
        dynamics: {
            forte: { minOpacity: 0.5, maxOpacity: 1.0 },    // More visible when loud
            piano: { minOpacity: 0.0, maxOpacity: 0.4 }     // Ghostly when quiet
        }
    },
    
    /**
     * Initialize fade data
     * Stores particle's original opacity
     */
    initialize: function(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.fade = {
            baseOpacity: particle.opacity || particle.life || 1
        };
    },
    
    /**
     * Apply fade effect to particle
     * Smoothly transitions opacity based on configuration
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.fade) {
            this.initialize(particle);
        }
        
        const data = particle.gestureData.fade;
        const config = { ...this.config, ...motion };
        
        let targetOpacity;
        if (config.fadeIn && !config.fadeOut) {
            // Fade in only - opacity increases over time
            targetOpacity = config.minOpacity + (config.maxOpacity - config.minOpacity) * progress;
        } else if (config.fadeOut && !config.fadeIn) {
            // Fade out only - opacity decreases over time
            targetOpacity = config.maxOpacity - (config.maxOpacity - config.minOpacity) * progress;
        } else {
            // Fade in then out - peak opacity at midpoint
            if (progress < 0.5) {
                targetOpacity = config.minOpacity + (config.maxOpacity - config.minOpacity) * (progress * 2);
            } else {
                targetOpacity = config.maxOpacity - (config.maxOpacity - config.minOpacity) * ((progress - 0.5) * 2);
            }
        }
        
        // Apply calculated opacity
        particle.opacity = data.baseOpacity * targetOpacity;
        // Also update life property for particles that use it
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
    },
    
    /**
     * Clean up fade effect
     * Restores original opacity values
     */
    cleanup: function(particle) {
        if (particle.gestureData?.fade) {
            particle.opacity = particle.gestureData.fade.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
            delete particle.gestureData.fade;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Hold Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Hold gesture - freeze particles in place
 * @author Emotive Engine Team
 * @module gestures/effects/hold
 */

var hold = {
    name: 'hold',
    emoji: '⏸️',
    type: 'override',
    description: 'Hold particles in current position',
    
    // Default configuration
    config: {
        holdStrength: 0.95,  // Position retention strength
        allowDrift: false    // Enable slight movement
    },
    
    // Rhythm configuration - synchronized pause effects following musical structure
    rhythm: {
        enabled: true,
        syncMode: 'rest',    // Hold particles during musical rests and pauses
        
        // Hold strength responds to musical silence
        holdSync: {
            onRest: 0.98,         // Very strong hold during rests
            onSound: 0.80,        // Looser hold when music plays
            curve: 'immediate'    // Instant response to silence/sound
        },
        
        // Duration matches rest length
        durationSync: {
            mode: 'rests',
            minBeats: 0.5,        // Minimum half-beat hold
            maxBeats: 8,          // Maximum 8-beat hold
            sustain: true         // Maintain hold through entire rest
        },
        
        // Response to fermatas and caesuras
        pauseResponse: {
            enabled: true,
            multiplier: 1.5,      // Stronger hold during marked pauses
            type: 'strength'      // Affects hold strength
        },
        
        // Style variations for different music types
        patternOverrides: {
            'classical': {
                // Expressive holds for dramatic pauses
                holdSync: { onRest: 0.99, onSound: 0.75, curve: 'dramatic' },
                pauseResponse: { multiplier: 2.0 }
            },
            'minimal': {
                // Extended, meditative holds
                holdSync: { onRest: 0.95, onSound: 0.85 },
                durationSync: { minBeats: 2, maxBeats: 16 }
            },
            'jazz': {
                // Subtle holds that allow for swing
                holdSync: { onRest: 0.90, onSound: 0.70 },
                allowDrift: true  // Enable slight movement for swing feel
            },
            'electronic': {
                // Precise, digital-style holds
                holdSync: { onRest: 0.99, onSound: 0.60, curve: 'digital' },
                pauseResponse: { multiplier: 1.2 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Strong, definitive holds
                holdSync: { 
                    onRest: { multiplier: 1.02 },
                    onSound: { multiplier: 0.9 }
                },
                pauseResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, floating holds
                holdSync: { 
                    onRest: { multiplier: 0.97 },
                    onSound: { multiplier: 0.85 }
                },
                pauseResponse: { multiplier: 1.3 }
            }
        }
    },
    
    initialize: function(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.hold = {
            holdX: particle.x,
            holdY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy
        };
    },
    
    /**
     * Apply hold effect to particle
     * Freezes or slows particle movement based on configuration
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.hold) {
            this.initialize(particle);
        }
        
        const data = particle.gestureData.hold;
        const holdStrength = motion.holdStrength || this.config.holdStrength;
        
        if (motion.allowDrift) {
            // Allow slight drift with velocity damping
            particle.vx *= holdStrength;
            particle.vy *= holdStrength;
        } else {
            // Hard hold - lock to position
            particle.x += (data.holdX - particle.x) * (1 - holdStrength);
            particle.y += (data.holdY - particle.y) * (1 - holdStrength);
            particle.vx = 0;
            particle.vy = 0;
        }
        
        // Gradually restore velocity near end
        if (progress > 0.9) {
            const restoreFactor = (progress - 0.9) * 10;
            particle.vx = particle.vx * (1 - restoreFactor) + data.originalVx * restoreFactor;
            particle.vy = particle.vy * (1 - restoreFactor) + data.originalVy * restoreFactor;
        }
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.hold) {
            const data = particle.gestureData.hold;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.hold;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Breathe Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Breathe gesture - inhale/exhale particle motion
 * @author Emotive Engine Team
 * @module gestures/effects/breathe
 */

var breathe = {
    name: 'breathe',
    emoji: '🫁',
    type: 'blending',
    description: 'Breathing rhythm with inhale and exhale',
    
    // Default configuration
    config: {
        // Musical duration - one full breath per bar
        musicalDuration: {
            musical: true,
            bars: 1,           // Default to 1 bar breathing cycle
            minBeats: 2,       // Minimum half bar
            maxBeats: 16       // Maximum 4 bars for slow breathing
        },
        
        // Musical phases of breathing
        phases: [
            { name: 'inhale', beats: 1.5 },     // Inhale phase
            { name: 'hold_in', beats: 0.5 },    // Hold at peak
            { name: 'exhale', beats: 1.5 },     // Exhale phase
            { name: 'hold_out', beats: 0.5 }    // Hold at rest
        ],
        
        inhaleRadius: 1.5,     // Maximum expansion distance
        exhaleRadius: 0.3,     // Minimum contraction distance
        breathRate: 0.3,       // Breathing rhythm speed
        spiralStrength: 0.002, // Subtle spiral motion intensity
        scaleAmount: 0.25,     // Core size variation amount
        glowAmount: 0.4,       // Glow intensity variation
        frequency: 1,          // Number of breath cycles
        easing: 'sine',        // Smooth, natural curve type
        strength: 0.8,         // Overall motion influence
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'breathe',
            strength: 0.8,         // Particle response strength
            inhaleRadius: 1.5,     // Particle expansion limit
            exhaleRadius: 0.3      // Particle contraction limit
        }
    },
    
    // Rhythm configuration - breathing synced to musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Long breathing cycles across musical phrases
        
        // Breath rate syncs to musical tempo
        breathRateSync: {
            mode: 'tempo',
            bpm: 'auto',          // Match song tempo
            subdivision: 'whole', // Full breaths on whole notes
            curve: 'sine'         // Natural breathing curve
        },
        
        // Inhale/exhale expansion syncs to dynamics
        radiusSync: {
            inhale: {
                onUpbeat: 1.8,    // Deeper inhale on upbeats
                onDownbeat: 1.4,  // Standard inhale on downbeats
                curve: 'ease-in'
            },
            exhale: {
                onUpbeat: 0.2,    // Complete exhale on upbeats
                onDownbeat: 0.4,  // Gentle exhale on downbeats
                curve: 'ease-out'
            }
        },
        
        // Duration matches musical phrasing
        durationSync: {
            mode: 'phrases',
            phrases: 2,           // Breathe across 2 musical phrases
            hold: 'fermata'       // Hold breath on fermatas
        },
        
        // Respond to musical accents
        accentResponse: {
            enabled: true,
            multiplier: 1.5,      // Deeper breath on accents
            type: 'expansion'     // Accent affects radius expansion
        },
        
        // Pattern-specific breathing styles
        patternOverrides: {
            'ballad': {
                // Slow, deep breathing for emotional ballads
                breathRateSync: { subdivision: 'double-whole' },
                radiusSync: { 
                    inhale: { onUpbeat: 2.2, onDownbeat: 1.8 },
                    exhale: { onUpbeat: 0.1, onDownbeat: 0.2 }
                }
            },
            'uptempo': {
                // Quick, energetic breathing
                breathRateSync: { subdivision: 'half' },
                radiusSync: { 
                    inhale: { onUpbeat: 1.4, onDownbeat: 1.2 },
                    exhale: { onUpbeat: 0.3, onDownbeat: 0.4 }
                }
            },
            'ambient': {
                // Ethereal, floating breathing
                breathRateSync: { subdivision: 'whole', curve: 'ease' },
                radiusSync: { 
                    inhale: { onUpbeat: 1.6, onDownbeat: 1.6 },
                    exhale: { onUpbeat: 0.2, onDownbeat: 0.2 }
                }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, deep breathing
                radiusSync: { 
                    inhale: { multiplier: 1.8 },
                    exhale: { multiplier: 0.5 }
                },
                spiralStrength: 0.004,  // More spiral motion
                scaleAmount: 0.4
            },
            piano: {
                // Gentle, subtle breathing
                radiusSync: { 
                    inhale: { multiplier: 1.2 },
                    exhale: { multiplier: 0.8 }
                },
                spiralStrength: 0.001,  // Minimal spiral
                scaleAmount: 0.1
            }
        }
    },
    
    /**
     * Initialize breathing data for a particle
     * Stores particle's starting position and relationship to center
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate particle's position relative to orb center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        particle.gestureData.breathe = {
            startX: particle.x,                        // Original X position
            startY: particle.y,                        // Original Y position
            angle: Math.atan2(dy, dx),                // Direction from center
            baseRadius: Math.sqrt(dx * dx + dy * dy), // Distance from center
            phaseOffset: Math.random() * 0.2 - 0.1    // Slight timing variation for organic feel
        };
    },
    
    /**
     * Apply breathing motion to particle
     * Creates expansion/contraction movement synchronized with breath rhythm
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize particle data if needed
        if (!particle.gestureData?.breathe) {
            this.initialize(particle, motion, centerX, centerY);
        }
        const config = { ...this.config, ...motion };
        
        // Calculate breath phase - creates smooth sine wave between exhale and inhale
        // Result oscillates smoothly between 0 (exhale) and 1 (inhale)
        const breathPhase = (Math.sin(progress * Math.PI * 2 * config.breathRate) + 1) / 2;
        
        // Define breathing boundaries relative to orb size
        // Scale boundaries based on particle's size factor for consistent appearance
        const referenceRadius = 100 * (particle.scaleFactor || 1);
        const inhaleRadius = config.inhaleRadius * referenceRadius;
        const exhaleRadius = config.exhaleRadius * referenceRadius;
        
        // Interpolate target position between exhale and inhale boundaries
        const targetRadius = exhaleRadius + (inhaleRadius - exhaleRadius) * breathPhase;
        
        // Calculate particle's current distance from center
        const currentDx = particle.x - centerX;
        const currentDy = particle.y - centerY;
        const currentRadius = Math.sqrt(currentDx * currentDx + currentDy * currentDy);
        
        // Calculate radial movement needed to reach target breathing position
        const radiusDiff = targetRadius - currentRadius;
        const moveStrength = (motion.strength || 0.8) * 0.05 * dt;
        
        // Apply radial motion (move in/out from center)
        if (currentRadius > 0) {
            // Normalize direction and apply movement
            const moveX = (currentDx / currentRadius) * radiusDiff * moveStrength;
            const moveY = (currentDy / currentRadius) * radiusDiff * moveStrength;
            
            particle.vx += moveX;
            particle.vy += moveY;
            
            // Add organic spiral motion for more natural breathing feel
            // Creates slight circular drift during expansion/contraction
            const spiralStrength = config.spiralStrength * dt * (motion.strength || 1);
            const tangentX = -currentDy / currentRadius;  // Perpendicular to radial direction
            const tangentY = currentDx / currentRadius;
            
            // Spiral motion stronger during inhale, creating expanding spiral
            particle.vx += tangentX * spiralStrength * breathPhase;
            particle.vy += tangentY * spiralStrength * breathPhase;
        }
        
        // Apply velocity damping for smooth, controlled motion
        // Prevents particles from overshooting or oscillating
        particle.vx *= 0.98;
        particle.vy *= 0.98;
    },
    
    /**
     * Clean up breathing data when gesture completes
     * Removes stored data to free memory
     */
    cleanup: function(particle) {
        if (particle.gestureData?.breathe) {
            delete particle.gestureData.breathe;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Expand Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Expand gesture - particles move outward from center
 * @author Emotive Engine Team
 * @module gestures/effects/expand
 */

var expand = {
    name: 'expand',
    emoji: '💫',
    type: 'blending',
    description: 'Radial expansion from center',
    
    // Default configuration
    config: {
        duration: 600,        // Gesture duration
        scaleAmount: 3.0,     // Core scale expansion amount
        scaleTarget: 3.0,     // Target expansion distance ratio
        glowAmount: 0.5,      // Glow intensity increase
        easing: 'back',       // Overshoot animation curve
        strength: 3.0,        // Outward push force intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 3.0,        // Particle push strength
            direction: 'outward', // Movement away from center
            persist: true         // Maintain expanded position
        }
    },
    
    // Rhythm configuration - expansive growth synced to musical crescendos
    rhythm: {
        enabled: true,
        syncMode: 'crescendo',  // Expand during musical crescendos
        
        // Expansion strength follows dynamics
        strengthSync: {
            pianissimo: 1.5,      // Gentle expansion in quiet sections
            fortissimo: 5.0,      // Massive expansion in loud sections
            crescendo: 'build',   // Gradual build during crescendos
            sforzando: 'burst'    // Sudden expansion on sforzandos
        },
        
        // Scale target responds to musical intensity
        scaleTargetSync: {
            verse: 2.0,           // Moderate expansion in verses
            chorus: 4.5,          // Large expansion in choruses
            climax: 6.0,          // Maximum expansion at climax
            curve: 'exponential'  // Exponential growth curve
        },
        
        // Duration matches musical phrasing
        durationSync: {
            mode: 'phrases',
            build: 1.2,           // Extended duration during builds
            release: 0.8,         // Quick expansion on releases
            sustain: 'hold'       // Hold expansion during sustains
        },
        
        // Strong accent response
        accentResponse: {
            enabled: true,
            multiplier: 2.8,      // Massive expansion on accents
            type: 'strength'      // Accent affects expansion force
        },
        
        // Pattern-specific expansion styles
        patternOverrides: {
            'orchestral': {
                // Epic, cinematic expansion
                strengthSync: { 
                    pianissimo: 2.0, 
                    fortissimo: 6.5,
                    crescendo: 'dramatic'
                },
                scaleTargetSync: { climax: 8.0 }
            },
            'rock': {
                // Aggressive, powerful expansion
                strengthSync: { 
                    pianissimo: 1.8, 
                    fortissimo: 5.5,
                    curve: 'power'
                },
                accentResponse: { multiplier: 3.2 }
            },
            'ambient': {
                // Gentle, organic expansion
                strengthSync: { 
                    pianissimo: 1.2, 
                    fortissimo: 3.5,
                    crescendo: 'organic'
                },
                durationSync: { build: 1.8, release: 1.2 }
            },
            'electronic': {
                // Sharp, controlled expansion
                strengthSync: { 
                    pianissimo: 1.6, 
                    fortissimo: 4.8,
                    curve: 'digital'
                },
                scaleTargetSync: { curve: 'linear' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, overwhelming expansion
                strengthSync: { 
                    pianissimo: { multiplier: 1.4 },
                    fortissimo: { multiplier: 1.8 }
                },
                scaleTargetSync: { multiplier: 1.6 },
                accentResponse: { multiplier: 3.5 }
            },
            piano: {
                // Delicate, controlled expansion
                strengthSync: { 
                    pianissimo: { multiplier: 0.8 },
                    fortissimo: { multiplier: 1.2 }
                },
                scaleTargetSync: { multiplier: 0.7 },
                accentResponse: { multiplier: 2.0 }
            }
        }
    },
    
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        particle.gestureData.expand = {
            startX: particle.x,
            startY: particle.y,
            angle: Math.atan2(dy, dx),
            baseRadius: Math.sqrt(dx * dx + dy * dy),
            initialized: true
        };
    },
    
    /**
     * Apply expansion motion to particle
     * Pushes particles outward from center with explosive force
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.expand?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.expand;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate expansion amount based on progress
        const expandFactor = 1 + (config.scaleTarget - 1) * progress * strength;
        const targetRadius = data.baseRadius * expandFactor;
        
        // Calculate target position farther from center
        const targetX = centerX + Math.cos(data.angle) * targetRadius;
        const targetY = centerY + Math.sin(data.angle) * targetRadius;
        
        // Apply strong outward push forces
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;
        particle.vx += dx * 0.8 * dt;  // Strong explosive push
        particle.vy += dy * 0.8 * dt;  // Strong explosive push
        
        // Apply velocity damping for controlled motion
        particle.vx *= 0.95;
        particle.vy *= 0.95;
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.expand) {
            delete particle.gestureData.expand;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Contract Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Contract gesture - particles move inward toward center
 * @author Emotive Engine Team
 * @module gestures/effects/contract
 */

var contract = {
    name: 'contract',
    emoji: '🌀',
    type: 'blending',
    description: 'Radial contraction toward center',
    
    // Default configuration
    config: {
        duration: 600,        // Gesture duration
        scaleAmount: 0.2,     // Core scale reduction amount
        scaleTarget: 0.2,     // Target contraction distance ratio
        glowAmount: -0.2,     // Glow intensity reduction
        easing: 'cubic',      // Smooth acceleration curve
        strength: 2.5,        // Inward pull force intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 2.5,        // Particle pull strength
            direction: 'inward',  // Movement toward center
            persist: true         // Effect continues after gesture
        }
    },
    
    // Rhythm configuration - magnetic contraction synced to musical tension
    rhythm: {
        enabled: true,
        syncMode: 'tension',  // Contract during musical tension builds
        
        // Contraction strength responds to musical intensity
        strengthSync: {
            onTension: 4.0,       // Strong pull during tension
            onRelease: 1.5,       // Gentle pull during release
            curve: 'magnetic'     // Smooth magnetic pull curve
        },
        
        // Scale target changes with dynamics
        scaleTargetSync: {
            forte: 0.1,           // Tight contraction for loud sections
            piano: 0.4,           // Gentle contraction for soft sections
            crescendo: 'gradual', // Gradual tightening on crescendos
            diminuendo: 'ease'    // Easy relaxation on diminuendos
        },
        
        // Duration responds to phrase length
        durationSync: {
            mode: 'phrases',
            shortPhrase: 0.8,     // Quick contraction for short phrases  
            longPhrase: 1.5,      // Extended contraction for long phrases
            hold: 'sustain'       // Maintain contraction during holds
        },
        
        // Strong accent response
        accentResponse: {
            enabled: true,
            multiplier: 2.2,      // Sharp contraction on accents
            type: 'strength'      // Accent affects pull force
        },
        
        // Pattern-specific contraction styles
        patternOverrides: {
            'classical': {
                // Elegant, controlled contraction
                strengthSync: { onTension: 3.5, onRelease: 1.8 },
                scaleTargetSync: { forte: 0.15, piano: 0.35 }
            },
            'metal': {
                // Aggressive, tight contraction
                strengthSync: { onTension: 5.0, onRelease: 2.0, curve: 'sharp' },
                scaleTargetSync: { forte: 0.05, piano: 0.25 }
            },
            'ambient': {
                // Slow, atmospheric contraction
                strengthSync: { onTension: 2.8, onRelease: 1.2, curve: 'ease' },
                durationSync: { shortPhrase: 1.2, longPhrase: 2.0 }
            },
            'trap': {
                // Sudden, rhythmic contraction on drops
                strengthSync: { 
                    onTension: 4.5, 
                    onRelease: 1.0,
                    dropBeat: 6.0   // Massive contraction on trap drops
                },
                scaleTargetSync: { forte: 0.08, piano: 0.3 }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, crushing contraction
                strengthSync: { 
                    onTension: { multiplier: 1.8 },
                    onRelease: { multiplier: 1.4 }
                },
                scaleTargetSync: { multiplier: 0.6 },  // Tighter contraction
                accentResponse: { multiplier: 2.8 }
            },
            piano: {
                // Gentle, subtle contraction
                strengthSync: { 
                    onTension: { multiplier: 0.7 },
                    onRelease: { multiplier: 0.8 }
                },
                scaleTargetSync: { multiplier: 1.4 },  // Looser contraction
                accentResponse: { multiplier: 1.6 }
            }
        }
    },
    
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        particle.gestureData.contract = {
            startX: particle.x,
            startY: particle.y,
            angle: Math.atan2(dy, dx),
            baseRadius: Math.sqrt(dx * dx + dy * dy),
            initialized: true
        };
    },
    
    /**
     * Apply contraction motion to particle
     * Pulls particles toward center with magnetic-like force
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.contract?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.contract;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate contraction amount based on progress
        const contractFactor = 1 - (1 - config.scaleTarget) * progress * strength;
        const targetRadius = data.baseRadius * contractFactor;
        
        // Calculate target position closer to center
        const targetX = centerX + Math.cos(data.angle) * targetRadius;
        const targetY = centerY + Math.sin(data.angle) * targetRadius;
        
        // Apply strong inward pull forces
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;
        particle.vx += dx * 0.5 * dt;  // Strong magnetic pull
        particle.vy += dy * 0.5 * dt;  // Strong magnetic pull
        
        // Apply velocity damping for controlled motion
        particle.vx *= 0.95;
        particle.vy *= 0.95;
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.contract) {
            delete particle.gestureData.contract;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Flash Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Flash gesture - bright burst effect
 * @author Emotive Engine Team
 * @module gestures/effects/flash
 */

var flash = {
    name: 'flash',
    emoji: '⚡',
    type: 'blending',
    description: 'Bright flash burst effect',
    
    // Default configuration
    config: {
        duration: 400,       // Animation duration
        glowAmount: 2.5,     // Overall brightness increase
        glowPeak: 3.0,       // Maximum intensity level
        scalePeak: 1.1,      // Size expansion at peak
        easing: 'cubic',     // Animation curve type
        strength: 1.0,       // Effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'burst',
            strength: 1.0,   // Burst force intensity
            decay: 0.3       // Force reduction rate
        }
    },
    
    // Rhythm configuration - flash on beats and accents
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Flash on beats
        timingSync: 'immediate',    // Flash immediately (for impact)
        interruptible: true,         // Can interrupt
        priority: 8,                 // High priority
        blendable: true,             // Can layer over other effects
        
        // Flash intensity syncs to beat strength
        intensitySync: {
            onBeat: 3.5,              // Bright flash on beat
            offBeat: 1.0,             // Dim between beats
            accent: 5.0,              // Blinding on accent
            subdivision: 'quarter',    // Flash every quarter note
            curve: 'exponential'      // Sharp flash attack
        },
        
        // Duration varies with tempo
        durationSync: {
            mode: 'tempo',
            baseDuration: 400,        // Base at 120 BPM
            scaling: 'inverse'        // Faster tempo = shorter flash
        },
        
        // Scale pulse with flash
        scaleSync: {
            onBeat: 1.2,              // Expand on beat
            offBeat: 1.0,             // Normal size off beat
            accent: 1.4,              // Big expansion on accent
            curve: 'elastic'          // Bouncy scale
        },
        
        // Strobe patterns
        strobeSync: {
            enabled: false,           // Enable for strobe effect
            pattern: 'XXOX',          // X=flash, O=dark
            subdivision: 'sixteenth'  // Strobe rate
        },
        
        // Musical dynamics
        dynamics: {
            forte: { glowPeak: 4.0, scalePeak: 1.3, duration: 300 },
            piano: { glowPeak: 2.0, scalePeak: 1.05, duration: 500 }
        }
    },
    
    initialize: function(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.flash = {
            originalOpacity: particle.opacity,
            originalSize: particle.size,
            initialized: true
        };
    },
    
    /**
     * Apply flash effect to particle
     * Creates bright burst with size expansion and outward motion
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.flash?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.flash;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate flash intensity curve
        let flashIntensity;
        if (progress < 0.3) {
            // Quick rise to peak brightness
            flashIntensity = (progress / 0.3) * config.glowPeak;
        } else {
            // Gradual fade from peak
            flashIntensity = config.glowPeak * (1 - (progress - 0.3) / 0.7);
        }
        
        // Apply brightness and size changes
        particle.opacity = Math.min(1, data.originalOpacity * (1 + flashIntensity * strength));
        particle.size = data.originalSize * (1 + (config.scalePeak - 1) * flashIntensity * strength * 0.1);
        
        // Initial burst motion - particles briefly explode outward
        if (progress < 0.2) {
            const burstStrength = (1 - progress / 0.2) * strength;
            const angle = Math.atan2(particle.y - centerY, particle.x - centerX);
            particle.vx += Math.cos(angle) * burstStrength * 2 * dt;
            particle.vy += Math.sin(angle) * burstStrength * 2 * dt;
        }

        // Apply velocity decay for natural deceleration
        particle.vx *= (1 - config.particleMotion.decay * 0.1);
        particle.vy *= (1 - config.particleMotion.decay * 0.1);
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.flash) {
            particle.opacity = particle.gestureData.flash.originalOpacity;
            particle.size = particle.gestureData.flash.originalSize;
            delete particle.gestureData.flash;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glow Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Glow gesture - based on pulse but focused on luminosity without movement
 * @author Emotive Engine Team
 * @module gestures/effects/glow
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a pure luminous glow effect without particle movement.
 * ║ This is a BLENDING gesture that only modifies brightness/glow.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      Dim            Bright           Dim
 *    · · · ·         ✨ ✨ ✨         · · · ·
 *    · · ⭐ · ·   →  ✨ 🌟 ✨    →   · · ⭐ · ·
 *    · · · ·         ✨ ✨ ✨         · · · ·
 *
 * USED BY:
 * - Emphasis effects
 * - Magic/mystical states
 * - Energy charging
 */

/**
 * Glow gesture configuration and implementation
 */
var glow = {
    name: 'glow',
    emoji: '✨',
    type: 'blending', // Adds to existing motion
    description: 'Pure luminous glow without movement',

    // Default configuration
    config: {
        duration: 1500,      // Animation duration (longer than pulse for sustained glow)
        amplitude: 0,        // NO expansion distance (removed from pulse)
        frequency: 1,        // Number of glow pulses
        holdPeak: 0.3,       // Peak glow hold time (longer for sustained effect)
        easing: 'sine',      // Animation curve type
        scaleAmount: 0.1,    // Very subtle orb scale variation (reduced from pulse)
        glowAmount: 0.8,     // Strong orb glow intensity change (increased from pulse)
        strength: 0,         // NO particle motion strength (removed from pulse)
        direction: 'none',   // No movement direction
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'glow',
            strength: 0,     // No particle movement
            direction: 'none',
            frequency: 1
        }
    },

    // Rhythm configuration - glow pulses with musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Glow on musical phrases

        // Glow strength syncs to dynamics
        amplitudeSync: {
            onBeat: 2.0,      // Strong glow on beat
            offBeat: 1.2,     // Sustained glow off beat
            curve: 'smooth'   // Smooth transitions
        },

        // Frequency locks to phrase length
        frequencySync: {
            mode: 'phrase',
            subdivision: 'bar'
        },

        // Duration in musical time
        durationSync: {
            mode: 'bars',
            bars: 2           // Glow over 2 bars
        },

        // Stronger glow on accents
        accentResponse: {
            enabled: true,
            multiplier: 2.5   // Bright glow on accent
        },

        // Pattern-specific glow styles
        patternOverrides: {
            'ambient': {
                // Ethereal sustained glow
                amplitudeSync: { onBeat: 2.5, offBeat: 1.8 },
                durationSync: { bars: 4 }
            },
            'electronic': {
                // Pulsing neon glow
                amplitudeSync: { onBeat: 3.0, offBeat: 0.5, curve: 'sharp' },
                frequencySync: { subdivision: 'quarter' }
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize: function(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        // Store initial state (no position data needed for glow)
        particle.gestureData.glow = {
            startOpacity: particle.opacity,
            startGlow: particle.glowSizeMultiplier || 0,
            initialized: true
        };
    },

    /**
     * Apply glow effect to particle (no motion, just luminosity)
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.glow?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        const config = { ...this.config, ...motion };

        // Apply easing
        const easeProgress = this.easeInOutSine(progress);

        // Calculate glow pulse with peak hold
        let glowValue;
        let frequency = config.frequency;
        let glowAmount = config.glowAmount;

        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            glowAmount *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            glowAmount *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }

        const rawPulse = (easeProgress * frequency * 2) % 2;

        if (config.holdPeak > 0 && rawPulse > (1 - config.holdPeak) && rawPulse < (1 + config.holdPeak)) {
            // Hold at peak glow
            glowValue = 1;
        } else {
            // Normal sine wave for glow
            glowValue = Math.sin(easeProgress * Math.PI * 2 * frequency);
        }

        // NO PARTICLE MOVEMENT - just glow effects
        // Unlike pulse, we don't calculate target positions or apply velocity

        // Apply glow fade effect at the end
        let glowMultiplier = 1;
        if (progress > 0.9) {
            const fadeFactor = 1 - ((progress - 0.9) * 10);
            glowMultiplier = (0.5 + fadeFactor * 0.5);
        }

        // Modify particle glow properties (if your system supports it)
        // This is where the actual glow effect happens
        // Note: The actual visual implementation depends on your renderer
        // Set glow intensity directly, don't multiply to prevent accumulation
        particle.glowIntensity = 1 + glowValue * glowAmount * glowMultiplier;
    },

    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup: function(particle) {
        if (particle.gestureData?.glow) {
            // Reset any glow properties
            particle.glowIntensity = 1;
            delete particle.gestureData.glow;
        }
    },

    /**
     * Sine easing for smooth glow transitions
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine: function(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Peek Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Quick peek/hide motion for suspicious checking behavior
 * @author Emotive Engine Team
 * @module gestures/effects/peek
 * 
 * GESTURE TYPE:
 * type: 'effect' - Visual effect without changing core position
 * 
 * VISUAL EFFECT:
 * Particles quickly expand outward (peeking) then contract back (hiding),
 * like peeking around a corner or quickly checking surroundings.
 */

var peek = {
    name: 'peek',
    emoji: '👀',
    type: 'effect',
    description: 'Quick peek and hide motion',
    
    // Default configuration
    config: {
        peekDistance: 40,       // How far to peek out
        peekSpeed: 0.15,        // Speed of peek motion
        holdDuration: 200,      // How long to hold peek position (ms)
        hideSpeed: 0.25,        // Speed of hiding (faster than peeking)
        stagger: true,          // Stagger particle peeks
        duration: 1500          // Total animation duration
    },
    
    // Rhythm configuration - quick glimpse movements synchronized to rhythmic accents
    rhythm: {
        enabled: true,
        syncMode: 'accent',  // Peek on rhythmic accents and syncopation
        
        // Peek distance responds to accent strength
        distanceSync: {
            onAccent: 60,         // Far peek on accents
            offAccent: 25,        // Short peek off-accent
            curve: 'quick'        // Sharp, sudden movement
        },
        
        // Speed adapts to musical tempo
        speedSync: {
            mode: 'tempo',
            fast: 0.25,           // Quick peeks for fast music
            slow: 0.10,           // Slower peeks for slow music
            hideMultiplier: 1.8   // Hide speed relative to peek speed
        },
        
        // Duration matches rhythmic subdivisions
        durationSync: {
            mode: 'subdivision',
            beats: 0.25,          // Quarter-beat peek duration
            staggerBeats: 0.125,  // Eighth-beat stagger delay
            sustain: false        // No sustain, quick action
        },
        
        // Strong response to syncopated rhythms
        syncopationResponse: {
            enabled: true,
            multiplier: 1.8,      // More dramatic peek on syncopation
            type: 'distance'      // Affects peek distance
        },
        
        // Style variations for different music types
        patternOverrides: {
            'funk': {
                // Sharp, syncopated peeks
                distanceSync: { onAccent: 70, offAccent: 35, curve: 'funky' },
                syncopationResponse: { multiplier: 2.2 }
            },
            'latin': {
                // Rhythmic, dance-like peeks
                speedSync: { fast: 0.30, slow: 0.12 },
                durationSync: { beats: 0.5, staggerBeats: 0.25 }
            },
            'breakbeat': {
                // Erratic, complex peek patterns
                distanceSync: { onAccent: 55, offAccent: 40 },
                syncopationResponse: { multiplier: 2.5 }
            },
            'classical': {
                // Subtle, expressive peeks
                distanceSync: { onAccent: 45, offAccent: 20, curve: 'elegant' },
                speedSync: { fast: 0.18, slow: 0.08 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Bold, assertive peeks
                distanceSync: { 
                    onAccent: { multiplier: 1.6 },
                    offAccent: { multiplier: 1.3 }
                },
                speedSync: { multiplier: 1.4 },
                syncopationResponse: { multiplier: 2.8 }
            },
            piano: {
                // Cautious, subtle peeks
                distanceSync: { 
                    onAccent: { multiplier: 0.6 },
                    offAccent: { multiplier: 0.4 }
                },
                speedSync: { multiplier: 0.7 },
                syncopationResponse: { multiplier: 1.2 }
            }
        }
    },
    
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Initialize peek data if needed
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        if (!particle.gestureData.peek) {
            const dx = particle.x - centerX;
            const dy = particle.y - centerY;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            particle.gestureData.peek = {
                originalX: particle.x,
                originalY: particle.y,
                peekAngle: angle,
                originalDistance: distance,
                staggerDelay: this.config.stagger ? Math.random() * 0.3 : 0,
                phase: 'waiting',  // 'waiting', 'peeking', 'holding', 'hiding'
                phaseTimer: 0,
                peekOffset: { x: 0, y: 0 }
            };
        }
        
        const data = particle.gestureData.peek;
        const config = this.config;
        
        // Adjust progress for stagger
        const adjustedProgress = Math.max(0, Math.min(1, (progress - data.staggerDelay) / (1 - data.staggerDelay)));
        
        // Determine phase based on progress
        if (adjustedProgress === 0) {
            data.phase = 'waiting';
        } else if (adjustedProgress < 0.3) {
            data.phase = 'peeking';
        } else if (adjustedProgress < 0.6) {
            data.phase = 'holding';
        } else if (adjustedProgress < 1) {
            data.phase = 'hiding';
        }
        
        // Calculate peek offset based on phase
        let targetOffset = 0;
        
        switch (data.phase) {
            case 'peeking':
                // Smooth peek out
                const peekProgress = adjustedProgress / 0.3;
                targetOffset = this.easeOutCubic(peekProgress) * config.peekDistance;
                break;
                
            case 'holding':
                // Hold at peek position
                targetOffset = config.peekDistance;
                // Add slight tremor while holding
                if (Math.random() < 0.1) {
                    data.peekOffset.x += (Math.random() - 0.5) * 2;
                    data.peekOffset.y += (Math.random() - 0.5) * 2;
                }
                break;
                
            case 'hiding':
                // Quick hide back
                const hideProgress = (adjustedProgress - 0.6) / 0.4;
                targetOffset = (1 - this.easeInCubic(hideProgress)) * config.peekDistance;
                break;
        }
        
        // Apply the peek offset
        if (data.phase !== 'waiting') {
            const peekX = Math.cos(data.peekAngle) * targetOffset;
            const peekY = Math.sin(data.peekAngle) * targetOffset;
            
            // Smooth transition to target position
            data.peekOffset.x += (peekX - data.peekOffset.x) * config.peekSpeed;
            data.peekOffset.y += (peekY - data.peekOffset.y) * config.peekSpeed;
            
            // Apply offset to particle
            particle.x = data.originalX + data.peekOffset.x;
            particle.y = data.originalY + data.peekOffset.y;
        }
        
        // Add opacity effect - slightly fade during peek
        if (particle.alpha !== undefined) {
            if (data.phase === 'peeking' || data.phase === 'holding') {
                particle.alpha = 0.7 + Math.random() * 0.3;  // Flickering visibility
            } else {
                particle.alpha = 1.0;
            }
        }
    },
    
    // Easing functions
    easeOutCubic: function(t) {
        return 1 - Math.pow(1 - t, 3);
    },
    
    easeInCubic: function(t) {
        return t * t * t;
    },
    
    cleanup: function(particle) {
        if (particle.gestureData?.peek) {
            // Restore original position
            particle.x = particle.gestureData.peek.originalX;
            particle.y = particle.gestureData.peek.originalY;
            if (particle.alpha !== undefined) {
                particle.alpha = 1.0;
            }
            delete particle.gestureData.peek;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Running Man Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Running Man gesture - hip-hop shuffle dance move
 * @author Emotive Engine Team
 * @module gestures/effects/runningman
 */

var runningman = {
    name: 'runningman',
    emoji: '🏃',
    type: 'effect',
    description: 'Hip-hop running man shuffle',
    
    // Default configuration
    config: {
        duration: 2000,        // Animation duration
        slideDistance: 30,     // Horizontal slide distance
        stepHeight: 15,        // Vertical step height
        speed: 1.2,            // Animation speed multiplier
        strength: 0.8,         // Overall effect intensity
        // Particle motion configuration
        particleMotion: {
            type: 'runningman',
            strength: 0.7
        }
    },
    
    // Rhythm configuration - synchronized to beat
    rhythm: {
        enabled: true,
        syncToBeat: true,      // Snap to beat grid
        beatMultiplier: 1,     // Steps per beat
        accentBeats: [1, 3]    // Emphasized steps
    },
    
    /**
     * Apply running man motion - handled by GestureAnimator
     * This is a placeholder for the gesture system
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Motion is handled by GestureAnimator.applyRunningMan()
        return false;
    },
    
    /**
     * Blend with existing motion
     */
    blend: function(particle, progress, motion) {
        // Allow blending with other gestures
        return false;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Charleston Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Charleston gesture - classic hip-hop shuffle with modern twist
 * @author Emotive Engine Team
 * @module gestures/effects/charleston
 */

var charleston = {
    name: 'charleston',
    emoji: '🕺',
    type: 'effect',
    description: 'Hip-hop Charleston shuffle with crisscross',
    
    // Default configuration
    config: {
        duration: 2500,        // Animation duration
        kickDistance: 35,      // Kick extension distance
        swivelRange: 40,       // Hip swivel range
        bounceHeight: 12,      // Vertical bounce
        strength: 0.9,         // Overall effect intensity
        // Particle motion configuration
        particleMotion: {
            type: 'charleston',
            strength: 0.8
        }
    },
    
    // Rhythm configuration - tight sync with beat
    rhythm: {
        enabled: true,
        syncToBeat: true,      // Lock to beat grid
        beatMultiplier: 2,     // Double-time feel
        accentBeats: [1, 2.5, 3, 4.5]  // Syncopated accents
    },
    
    /**
     * Apply charleston motion - handled by GestureAnimator
     * This is a placeholder for the gesture system
     */
    apply: function(particle, progress, motion, dt, centerX, centerY) {
        // Motion is handled by GestureAnimator.applyCharleston()
        return false;
    },
    
    /**
     * Blend with existing motion
     */
    blend: function(particle, progress, motion) {
        // Allow blending with other gestures
        return false;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Gesture Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central registry for all gesture animations with plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module gestures
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Control center for all gestures with full plugin adapter integration.             
 * ║ • Three gesture types: blending (motions), override (transforms), effects        
 * ║ • Core gestures loaded synchronously at startup                                   
 * ║ • Plugin gestures registered dynamically via adapter                              
 * ║ • Value-agnostic configurations for easy tuning                                   
 * ║                                                                                    
 * ║ TO ADD A PLUGIN GESTURE:                                                          
 * ║ Use pluginAdapter.registerPluginGesture() from your plugin                        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ PLACEHOLDER GESTURES FOR NEW ANIMATIONS
// └─────────────────────────────────────────────────────────────────────────────────────
// These are handled by GestureAnimator but need registry entries for rhythm system
const createPlaceholderGesture = (name, emoji = '✨') => ({
    name,
    emoji,
    type: 'blending', // Use blending type so they don't interfere
    description: `${name} animation`,
    config: {
        duration: 1000, // Legacy fallback only
        musicalDuration: { musical: true, beats: 2 } // Default: 2 beats
    },
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',
        durationSync: { mode: 'beats', beats: 2 }, // Musical duration
        interruptible: true,
        priority: 3,
        blendable: true,
        crossfadePoint: 'anyBeat',
        maxQueue: 3
    },
    apply: (particle, progress, params) => {
        // No-op - handled by GestureAnimator
        return false;
    },
    blend: (particle, progress, params) => {
        // No-op - handled by GestureAnimator
        return false;
    }
});

const sparkle = createPlaceholderGesture('sparkle', '✨');

// Shimmer gesture - makes particles shimmer with wave effect
const shimmer = {
    name: 'shimmer',
    emoji: '🌟',
    type: 'particle',  // Particle type to affect particle behavior
    description: 'Shimmer effect with sparkling particles',
    config: {
        duration: 2000,  // Legacy fallback
        musicalDuration: { musical: true, bars: 1 }, // 1 bar (4 beats)
        particleMotion: 'radiant'  // Use radiant behavior for shimmering effect
    },
    rhythm: {
        enabled: true,
        syncType: 'beat',
        durationSync: { mode: 'bars', bars: 1 }, // Musical: 1 bar
        intensity: 0.8
    },
    override: (particle, progress, params) => {
        // Shimmer makes particles sparkle with wave effect
        particle.shimmerEffect = true;
        particle.shimmerProgress = progress;
        return true;
    },
    blend: (particle, progress, params) => {
        // Blend with other gestures
        return false;
    }
};
const wiggle = createPlaceholderGesture('wiggle', '〰️');
const groove = createPlaceholderGesture('groove', '🎵');
const point = createPlaceholderGesture('point', '👉');
const lean = createPlaceholderGesture('lean', '↗️');
const reach = createPlaceholderGesture('reach', '🤚');
const headBob = createPlaceholderGesture('headBob', '🎧');

// Rain gesture - applies doppler effect to particles
const rain = {
    name: 'rain',
    emoji: '🌧️',
    type: 'particle',  // Particle type to affect particle behavior
    description: 'Rain effect with falling particles',
    config: {
        duration: 3000,  // Legacy fallback
        musicalDuration: { musical: true, bars: 2 }, // 2 bars (8 beats)
        particleMotion: 'falling'  // Use the falling particle behavior
    },
    rhythm: {
        enabled: true,
        syncType: 'off-beat',
        durationSync: { mode: 'bars', bars: 2 }, // Musical: 2 bars
        intensity: 0.8
    },
    apply: (particle, progress, params) => {
        // The doppler behavior is handled by the particle system
        // This just marks particles as being affected by rain
        particle.rainEffect = true;
        particle.rainProgress = progress;
        return true;
    },
    blend: (particle, progress, params) => {
        // Blend with other gestures
        return false;
    }
};

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ GESTURE COLLECTIONS
// └─────────────────────────────────────────────────────────────────────────────────────
const MOTION_GESTURES = [
    bounce,
    pulse,
    shake,
    nod,
    vibrate,
    orbit,
    twitch,
    sway,
    float,
    jitter,
    // New gestures
    sparkle,
    shimmer,
    wiggle,
    groove,
    point,
    lean,
    reach,
    headBob,
    rain
];

const TRANSFORM_GESTURES = [
    spin,
    jump,
    morph,
    stretch,
    tilt,
    orbital,
    hula,
    scan,
    twist
];

const EFFECT_GESTURES = [
    wave,
    drift,
    flicker,
    burst,
    directional,
    settle,
    fade,
    hold,
    breathe,
    expand,
    contract,
    flash,
    glow,
    peek,
    runningman,
    charleston
];

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ GESTURE REGISTRY - Fast lookup by name
// └─────────────────────────────────────────────────────────────────────────────────────
const GESTURE_REGISTRY = {};

// Build the registry from all gesture arrays - SYNCHRONOUSLY
[...MOTION_GESTURES, ...TRANSFORM_GESTURES, ...EFFECT_GESTURES].forEach(gesture => {
    GESTURE_REGISTRY[gesture.name] = gesture;
});

/**
 * Get a gesture by name (checks both core and plugin gestures)
 * @param {string} name - Gesture name (e.g., 'bounce', 'spin')
 * @returns {Object|null} Gesture object or null if not found
 */
function getGesture(name) {
    // Check core gestures first
    if (GESTURE_REGISTRY[name]) {
        return GESTURE_REGISTRY[name];
    }
    
    // Check plugin gestures
    const pluginGesture = pluginAdapter.getPluginGesture(name);
    if (pluginGesture) {
        return pluginGesture;
    }
    
    return null;
}

/**
 * Check if a gesture is an override type
 * @param {string} name - Gesture name
 * @returns {boolean} True if gesture overrides existing motion
 */
function isOverrideGesture(name) {
    const gesture = getGesture(name);
    return gesture ? gesture.type === 'override' : false;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rhythm Core
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 * 
 * @fileoverview Core rhythm timing engine for musical synchronization
 * @author Emotive Engine Team
 * @module core/rhythm
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Central timing engine that provides musical time references to all subsystems.    
 * ║ Does NOT dictate what animations do - only provides timing information.           
 * ║ Each subsystem maintains its own rhythm configuration in its files.              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * ARCHITECTURE:
 * • Provides beat events and musical time references
 * • Supports multiple time signatures and tempo changes
 * • Enables audio synchronization from external sources
 * • Each gesture/emotion/behavior defines its own rhythm response
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  TIMING FLOW                                                                      │
 * │                                                                                   │
 * │  Audio Input ──┐                                                                 │
 * │                ↓                                                                  │
 * │  [Rhythm Engine] ← Internal Clock                                                │
 * │        ↓                                                                          │
 * │   Beat Events → Subsystems (each with own rhythm config)                        │
 * │                                                                                   │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */

class RhythmEngine {
    constructor() {
        // Core timing properties
        this.bpm = 120;                    // Default BPM (beats per minute)
        this.timeSignature = [4, 4];       // Default 4/4 time
        this.isPlaying = false;            // Whether rhythm is active
        
        // Musical time tracking
        this.startTime = 0;                // When rhythm started
        this.currentBeat = 0;              // Current beat number
        this.currentBar = 0;               // Current bar/measure number
        this.beatProgress = 0;             // Progress within current beat (0-1)
        this.barProgress = 0;              // Progress within current bar (0-1)
        
        // Timing calculations
        this.beatDuration = 60000 / this.bpm;  // Milliseconds per beat
        this.barDuration = this.beatDuration * this.timeSignature[0];
        this.lastBeatTime = 0;             // Timestamp of last beat
        this.nextBeatTime = 0;             // Timestamp of next beat
        
        // Event listeners
        this.listeners = new Map();        // Event type -> Set of callbacks
        this.beatCallbacks = new Set();    // Callbacks for every beat
        this.barCallbacks = new Set();     // Callbacks for every bar
        
        // Subdivisions for finer timing
        this.subdivisions = {
            sixteenth: 0,    // 16th note position
            eighth: 0,       // 8th note position
            triplet: 0,      // Triplet position
            swing: 0         // Swing timing offset
        };
        
        // Sync state
        this.audioSync = null;             // External audio sync source
        this.syncOffset = 0;               // Timing offset for sync
        this.autoSync = false;             // Auto-detect tempo from audio
        
        // Musical dynamics
        this.intensity = 1.0;              // Current musical intensity (0-1)
        this.groove = 0;                   // Groove/swing amount (0-1)
        this.humanize = 0.05;              // Timing humanization factor
        
        // Pattern tracking
        this.patterns = new Map();         // Named rhythm patterns
        this.currentPattern = null;        // Active rhythm pattern
        
        // Initialize default patterns
        this.initializePatterns();
    }
    
    /**
     * Initialize default rhythm patterns
     */
    initializePatterns() {
        // Basic patterns - these are just timing references
        // Actual animations define their own responses to these patterns
        
        // Common time signatures
        this.patterns.set('4/4', {
            name: '4/4',
            description: 'Common time - 4 beats per bar',
            timeSignature: [4, 4],
            groove: 0,
            accents: [1, 0.5, 0.7, 0.5]  // Beat emphasis pattern
        });
        
        this.patterns.set('straight', {
            name: 'straight',
            description: 'Straight, even timing',
            groove: 0,
            accents: [1, 0.5, 0.7, 0.5]  // Beat emphasis pattern
        });
        
        this.patterns.set('swing', {
            name: 'swing',
            description: 'Swing/shuffle timing',
            groove: 0.67,  // 2:1 swing ratio
            accents: [1, 0.3, 0.8, 0.3]
        });
        
        this.patterns.set('3/4', {
            name: '3/4',
            description: 'Waltz time - 3 beats per bar',
            timeSignature: [3, 4],
            accents: [1, 0.5, 0.5]
        });
        
        this.patterns.set('waltz', {
            name: 'waltz',
            description: '3/4 waltz timing',
            timeSignature: [3, 4],
            accents: [1, 0.5, 0.5]
        });
        
        this.patterns.set('6/8', {
            name: '6/8',
            description: 'Compound duple time',
            timeSignature: [6, 8],
            accents: [1, 0.3, 0.3, 0.7, 0.3, 0.3]
        });
        
        this.patterns.set('5/4', {
            name: '5/4',
            description: 'Complex meter - 5 beats per bar',
            timeSignature: [5, 4],
            accents: [1, 0.5, 0.6, 0.5, 0.7]
        });
        
        this.patterns.set('7/8', {
            name: '7/8',
            description: 'Irregular meter',
            timeSignature: [7, 8],
            accents: [1, 0.5, 0.5, 0.7, 0.5, 0.5, 0.6]
        });
        
        this.patterns.set('dubstep', {
            name: 'dubstep',
            description: 'Dubstep half-time feel',
            accents: [0.2, 0.2, 1, 0.2],  // Heavy on beat 3
            subdivisions: { wobble: true }
        });
        
        this.patterns.set('breakbeat', {
            name: 'breakbeat',
            description: 'Broken beat pattern',
            accents: [1, 0.2, 0.7, 0.9, 0.2, 0.8, 0.4, 0.2]
        });
    }
    
    /**
     * Start the rhythm engine
     */
    start() {
        if (this.isPlaying) return;

        this.isPlaying = true;
        this.isRunning = true; // Add explicit running flag
        this.startTime = performance.now();
        this.lastBeatTime = this.startTime;
        this.nextBeatTime = this.startTime + this.beatDuration;
        this.currentBeat = 0;
        this.currentBar = 0;

        // Emit start event
        this.emit('start', {
            bpm: this.bpm,
            timeSignature: this.timeSignature,
            pattern: this.currentPattern
        });

        // Start update loop
        this.update();
    }
    
    /**
     * Stop the rhythm engine
     */
    stop() {
        if (!this.isPlaying) return;
        
        this.isPlaying = false;
        this.emit('stop', {
            totalBeats: this.currentBeat,
            totalBars: this.currentBar
        });
    }
    
    /**
     * Main update loop
     */
    update() {
        if (!this.isPlaying) return;
        
        const now = performance.now();
        const elapsed = now - this.startTime;
        
        // Calculate musical time positions
        const beatsSinceStart = elapsed / this.beatDuration;
        const newBeat = Math.floor(beatsSinceStart);
        this.beatProgress = beatsSinceStart % 1;
        
        // Check for beat change
        if (newBeat > this.currentBeat) {
            this.onBeat(newBeat);
        }
        
        // Calculate bar position
        const newBar = Math.floor(newBeat / this.timeSignature[0]);
        if (newBar > this.currentBar) {
            this.onBar(newBar);
        }
        
        this.currentBeat = newBeat;
        this.currentBar = newBar;
        this.barProgress = (newBeat % this.timeSignature[0]) / this.timeSignature[0];
        
        // Calculate subdivisions
        this.updateSubdivisions();
        
        // Emit continuous update
        this.emit('update', this.getTimeInfo());
        
        // Continue loop only if still playing
        if (this.isPlaying) {
            requestAnimationFrame(() => this.update());
        }
    }
    
    /**
     * Handle beat event
     */
    onBeat(beatNumber) {
        const beatInBar = beatNumber % this.timeSignature[0];
        const accent = this.getAccent(beatInBar);
        
        // Add humanization
        const humanTiming = this.humanize * (Math.random() - 0.5) * this.beatDuration;
        
        const beatInfo = {
            beat: beatNumber,
            beatInBar: beatInBar,
            bar: this.currentBar,
            accent: accent,
            intensity: this.intensity * accent,
            humanTiming: humanTiming,
            timestamp: performance.now()
        };
        
        // Emit beat event
        this.emit('beat', beatInfo);
        
        // Call beat callbacks
        this.beatCallbacks.forEach(callback => callback(beatInfo));
        
        // Update timing
        this.lastBeatTime = performance.now();
        this.nextBeatTime = this.lastBeatTime + this.beatDuration;
    }
    
    /**
     * Handle bar event
     */
    onBar(barNumber) {
        const barInfo = {
            bar: barNumber,
            timeSignature: this.timeSignature,
            pattern: this.currentPattern,
            timestamp: performance.now()
        };
        
        // Emit bar event
        this.emit('bar', barInfo);
        
        // Call bar callbacks
        this.barCallbacks.forEach(callback => callback(barInfo));
    }
    
    /**
     * Update subdivision timings
     */
    updateSubdivisions() {
        // Calculate subdivision positions within beat
        this.subdivisions.sixteenth = (this.beatProgress * 4) % 1;
        this.subdivisions.eighth = (this.beatProgress * 2) % 1;
        this.subdivisions.triplet = (this.beatProgress * 3) % 1;
        
        // Apply swing/groove
        if (this.groove > 0) {
            const swingRatio = 0.5 + this.groove * 0.17; // Max 67% swing
            if (this.subdivisions.eighth < 0.5) {
                this.subdivisions.swing = this.subdivisions.eighth / swingRatio;
            } else {
                this.subdivisions.swing = 0.5 + (this.subdivisions.eighth - 0.5) / (1 - swingRatio);
            }
        } else {
            this.subdivisions.swing = this.subdivisions.eighth;
        }
    }
    
    /**
     * Get accent level for beat position
     */
    getAccent(beatInBar) {
        if (this.currentPattern && this.patterns.has(this.currentPattern)) {
            const pattern = this.patterns.get(this.currentPattern);
            if (pattern.accents && pattern.accents[beatInBar] !== undefined) {
                return pattern.accents[beatInBar];
            }
        }
        
        // Default accent pattern (strong on 1, medium on 3 in 4/4)
        if (beatInBar === 0) return 1.0;
        if (beatInBar === 2 && this.timeSignature[0] === 4) return 0.7;
        return 0.5;
    }
    
    /**
     * Get current time information
     */
    getTimeInfo() {
        return {
            // Absolute time
            elapsed: performance.now() - this.startTime,
            
            // Musical time
            beat: this.currentBeat,
            bar: this.currentBar,
            beatInBar: this.currentBeat % this.timeSignature[0],
            
            // Progress values (0-1)
            beatProgress: this.beatProgress,
            barProgress: this.barProgress,
            
            // Subdivisions
            subdivisions: { ...this.subdivisions },
            
            // Timing info
            bpm: this.bpm,
            beatDuration: this.beatDuration,
            timeSignature: [...this.timeSignature],
            
            // Musical properties
            intensity: this.intensity,
            groove: this.groove,
            pattern: this.currentPattern,
            
            // Next beat timing
            nextBeatIn: this.nextBeatTime - performance.now(),
            
            // Accent for current beat
            accent: this.getAccent(this.currentBeat % this.timeSignature[0])
        };
    }
    
    /**
     * Set BPM (beats per minute)
     */
    setBPM(bpm) {
        this.bpm = Math.max(20, Math.min(360, bpm));
        this.beatDuration = 60000 / this.bpm;
        this.barDuration = this.beatDuration * this.timeSignature[0];
        
        this.emit('tempoChange', { bpm: this.bpm });
    }
    
    /**
     * Set time signature
     */
    setTimeSignature(numerator, denominator) {
        this.timeSignature = [numerator, denominator];
        this.barDuration = this.beatDuration * numerator;
        
        this.emit('timeSignatureChange', { 
            timeSignature: this.timeSignature 
        });
    }
    
    /**
     * Set rhythm pattern
     */
    setPattern(patternName) {
        if (!this.patterns.has(patternName)) {
            return;
        }
        
        const pattern = this.patterns.get(patternName);
        this.currentPattern = patternName;
        
        // Apply pattern settings
        if (pattern.timeSignature) {
            this.setTimeSignature(...pattern.timeSignature);
        }
        if (pattern.groove !== undefined) {
            this.groove = pattern.groove;
        }
        
        this.emit('patternChange', { pattern: patternName });
    }
    
    /**
     * Register for beat events
     */
    onBeatCallback(callback) {
        this.beatCallbacks.add(callback);
        return () => this.beatCallbacks.delete(callback);
    }
    
    /**
     * Register for bar events
     */
    onBarCallback(callback) {
        this.barCallbacks.add(callback);
        return () => this.barCallbacks.delete(callback);
    }
    
    /**
     * Emit event to listeners
     */
    emit(event, data) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).forEach(callback => callback(data));
        }
    }
    
    /**
     * Listen for events
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event).add(callback);
        
        // Return unsubscribe function
        return () => {
            if (this.listeners.has(event)) {
                this.listeners.get(event).delete(callback);
            }
        };
    }
    
    /**
     * Sync to audio source (stub for future implementation)
     */
    syncToAudio(audioContext, audioSource) {
        this.audioSync = { context: audioContext, source: audioSource };
        // Future: Implement beat detection and tempo extraction
    }
    
    /**
     * Get rhythm adapter for subsystems
     * Returns timing info and utilities for rhythm-aware animations
     */
    getAdapter() {
        return {
            // Current time info
            getTimeInfo: () => this.getTimeInfo(),
            
            // Check if on beat (with tolerance)
            isOnBeat: (tolerance = 0.1) => {
                return this.beatProgress < tolerance || this.beatProgress > (1 - tolerance);
            },
            
            // Check if on specific subdivision
            isOnSubdivision: (subdivision, tolerance = 0.1) => {
                const value = this.subdivisions[subdivision] || 0;
                return value < tolerance || value > (1 - tolerance);
            },
            
            // Get interpolated value synced to beat
            getBeatSync: (min = 0, max = 1, curve = 'linear') => {
                let progress = this.beatProgress;
                
                // Apply curve
                switch(curve) {
                    case 'ease':
                        progress = 0.5 - Math.cos(progress * Math.PI) / 2;
                        break;
                    case 'bounce':
                        progress = Math.abs(Math.sin(progress * Math.PI));
                        break;
                    case 'pulse':
                        progress = Math.pow(Math.sin(progress * Math.PI), 2);
                        break;
                }
                
                return min + (max - min) * progress;
            },
            
            // Get value with musical accent
            getAccentedValue: (baseValue, accentMultiplier = 2) => {
                const accent = this.getAccent(this.currentBeat % this.timeSignature[0]);
                return baseValue * (1 + (accent - 0.5) * accentMultiplier);
            },
            
            // Subscribe to beat events
            onBeat: (callback) => this.onBeatCallback(callback),
            onBar: (callback) => this.onBarCallback(callback),
            
            // Musical time utilities
            beatsToMs: (beats) => beats * this.beatDuration,
            msToBeats: (ms) => ms / this.beatDuration,
            
            // Current musical state
            isPlaying: () => this.isPlaying,
            getBPM: () => this.bpm,
            getPattern: () => this.currentPattern
        };
    }
}

// Create singleton instance
const rhythmEngine = new RhythmEngine();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rhythm Integration Module
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 * 
 * @fileoverview Integration layer between rhythm engine and existing subsystems
 * @author Emotive Engine Team
 * @module core/rhythmIntegration
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This module connects the rhythm engine to existing subsystems without modifying   
 * ║ their core behavior. It reads rhythm configurations from individual files and     
 * ║ applies timing modulations based on musical events.                              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * INTEGRATION POINTS:
 * • Particle System - Emission timing, behavior modulation
 * • Gesture System - Animation sync, duration adjustment
 * • Emotion System - Intensity mapping, transition timing
 * • Renderer - Glow pulsing, visual effects sync
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  MODULAR RHYTHM FLOW                                                             │
 * │                                                                                   │
 * │  gesture.js ──┐                                                                  │
 * │  emotion.js ──┼→ [Integration] ← [Rhythm Engine]                                │
 * │  behavior.js ─┘         ↓                                                        │
 * │                   Apply Timing                                                   │
 * │                                                                                   │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


class RhythmIntegration {
    constructor() {
        this.enabled = false;
        this.adapter = null;
        this.subsystemConfigs = new Map();
        this.activeModulations = new Map();
    }
    
    /**
     * Initialize rhythm integration
     */
    initialize() {
        this.adapter = rhythmEngine.getAdapter();
        this.enabled = true;
        
        // Subscribe to rhythm events
        this.adapter.onBeat(this.handleBeat.bind(this));
        this.adapter.onBar(this.handleBar.bind(this));
        
    }
    
    /**
     * Update BPM from detected audio
     * @param {number} newBPM - Detected BPM from audio analysis
     */
    updateBPM(newBPM) {
        if (newBPM >= 60 && newBPM <= 220) {
            // Check if rhythm was manually stopped
            if (window.rhythmManuallyStoppedForCurrentAudio) {
                return; // Don't auto-update if manually stopped
            }

            // Auto-start rhythm engine if not running
            if (!rhythmEngine.isRunning) {

                // Auto-start the rhythm engine for gesture sync
                this.start(newBPM, 'straight');

                // Trigger the rhythm sync visualizer to show BPM
                if (window.rhythmSyncVisualizer && !window.rhythmSyncVisualizer.state.active) {
                    console.log('RhythmIntegration: Auto-starting rhythm sync visualizer with BPM:', newBPM);
                    window.rhythmSyncVisualizer.start();
                }

                return;
            }
            
            // If running, always update BPM regardless of whether it changed
            // This ensures new tracks get their correct BPM
            rhythmEngine.setBPM(newBPM);
            
            // BPM is now shown visually through the beat histogram bars
        }
    }
    
    /**
     * Register a subsystem's rhythm configuration
     * Called when loading gestures, emotions, behaviors, etc.
     */
    registerConfig(type, name, config) {
        if (!config.rhythm || !config.rhythm.enabled) return;
        
        const key = `${type}:${name}`;
        this.subsystemConfigs.set(key, {
            type,
            name,
            rhythmConfig: config.rhythm,
            originalConfig: config
        });
        
    }
    
    /**
     * Apply rhythm modulation to a gesture
     */
    applyGestureRhythm(gesture, particle, progress, dt) {
        if (!this.enabled || !gesture.rhythm?.enabled) return {};
        
        this.adapter.getTimeInfo();
        const rhythmConfig = gesture.rhythm;
        const modulation = {};
        
        // Apply amplitude sync
        if (rhythmConfig.amplitudeSync) {
            const sync = rhythmConfig.amplitudeSync;
            const beatSync = this.adapter.getBeatSync(
                sync.offBeat || 0.8,
                sync.onBeat || 1.5,
                sync.curve || 'linear'
            );
            modulation.amplitudeMultiplier = beatSync;
        }
        
        // Apply wobble sync
        if (rhythmConfig.wobbleSync) {
            const sync = rhythmConfig.wobbleSync;
            if (this.adapter.isOnSubdivision(sync.subdivision, 0.1)) {
                modulation.wobbleMultiplier = 1 + sync.intensity;
            } else {
                modulation.wobbleMultiplier = 1;
            }
        }
        
        // Apply accent response
        if (rhythmConfig.accentResponse?.enabled) {
            const accentedValue = this.adapter.getAccentedValue(
                1,
                rhythmConfig.accentResponse.multiplier || 1.5
            );
            modulation.accentMultiplier = accentedValue;
        }
        
        // Apply pattern overrides
        const currentPattern = this.adapter.getPattern();
        if (currentPattern && rhythmConfig.patternOverrides?.[currentPattern]) {
            Object.assign(modulation, rhythmConfig.patternOverrides[currentPattern]);
        }
        
        return modulation;
    }
    
    /**
     * Apply rhythm modulation to particle emission
     */
    applyParticleRhythm(emotionState, particleSystem) {
        if (!this.enabled || !emotionState.rhythm?.enabled) return {};
        
        const timeInfo = this.adapter.getTimeInfo();
        const rhythmConfig = emotionState.rhythm;
        const modulation = {};
        
        // Particle emission sync
        if (rhythmConfig.particleEmission) {
            const emission = rhythmConfig.particleEmission;
            
            if (emission.syncMode === 'beat' && this.adapter.isOnBeat(0.1)) {
                // Emit burst on beat
                modulation.emitBurst = emission.burstSize || 3;
            } else if (emission.offBeatRate !== undefined) {
                // Reduce emission between beats
                modulation.emissionRate = emission.offBeatRate;
            }
        }
        
        // Glow sync
        if (rhythmConfig.glowSync) {
            const glow = rhythmConfig.glowSync;
            const glowIntensity = this.adapter.getBeatSync(
                glow.intensityRange[0] || 1.0,
                glow.intensityRange[1] || 2.0,
                'pulse'
            );
            modulation.glowIntensity = glowIntensity;
        }
        
        // Breathing sync
        if (rhythmConfig.breathSync?.mode === 'bars') {
            const breath = rhythmConfig.breathSync;
            const barsElapsed = timeInfo.bar % breath.barsPerBreath;
            const breathProgress = barsElapsed / breath.barsPerBreath;
            modulation.breathPhase = breathProgress * Math.PI * 2;
        }
        
        return modulation;
    }
    
    /**
     * Apply rhythm to particle behavior
     */
    applyBehaviorRhythm(behavior, particle, dt) {
        if (!this.enabled || !behavior.rhythm?.enabled) return {};
        
        const timeInfo = this.adapter.getTimeInfo();
        const rhythmConfig = behavior.rhythm;
        const modulation = {};
        
        // Glitch timing for glitchy behavior
        if (rhythmConfig.glitchTiming) {
            const glitch = rhythmConfig.glitchTiming;
            const isOnSubdivision = this.adapter.isOnSubdivision(glitch.subdivision, 0.05);
            
            if (isOnSubdivision && Math.random() < glitch.probability) {
                const intensity = this.adapter.isOnBeat() 
                    ? glitch.intensityOnBeat 
                    : glitch.intensityOffBeat;
                modulation.triggerGlitch = true;
                modulation.glitchIntensity = intensity;
            }
        }
        
        // Orbital rhythm
        if (rhythmConfig.orbitRhythm) {
            const orbit = rhythmConfig.orbitRhythm;
            
            if (orbit.baseSpeed === 'tempo') {
                modulation.speedMultiplier = this.adapter.getBPM() / 120; // Normalize to 120 BPM
            }
            
            if (orbit.beatAcceleration && this.adapter.isOnBeat(0.1)) {
                modulation.speedBoost = orbit.beatAcceleration;
            }
            
            if (orbit.barReset && timeInfo.beatInBar === 0) {
                modulation.resetOrbit = true;
            }
        }
        
        // Stutter sync
        if (rhythmConfig.stutterSync) {
            const stutter = rhythmConfig.stutterSync;
            const pattern = this.adapter.getPattern();
            
            if (pattern && stutter.patterns?.[pattern]) {
                const patternConfig = stutter.patterns[pattern];
                
                if (patternConfig.freezeOnDrop && timeInfo.beatInBar === 2) {
                    modulation.freeze = true;
                    modulation.freezeDuration = patternConfig.dropDuration;
                } else if (patternConfig.randomFreeze && Math.random() < patternConfig.randomFreeze) {
                    modulation.freeze = true;
                    modulation.freezeDuration = patternConfig.duration;
                }
            }
        }
        
        return modulation;
    }
    
    /**
     * Handle beat event
     */
    handleBeat(beatInfo) {
        // Store beat info for subsystems to access
        this.lastBeatInfo = beatInfo;
        
        // Could trigger specific effects here if needed
        // But mainly subsystems will query rhythm state during their update
    }
    
    /**
     * Handle bar event
     */
    handleBar(barInfo) {
        // Store bar info for subsystems to access
        this.lastBarInfo = barInfo;
    }
    
    /**
     * Get duration adjusted for musical time
     */
    getMusicalDuration(rhythmConfig, originalDuration) {
        if (!this.enabled || !rhythmConfig?.durationSync) return originalDuration;
        
        const sync = rhythmConfig.durationSync;
        
        if (sync.mode === 'bars') {
            return this.adapter.beatsToMs(sync.bars * 4); // Assuming 4/4 time
        } else if (sync.mode === 'beats') {
            return this.adapter.beatsToMs(sync.beats);
        }
        
        return originalDuration;
    }
    
    /**
     * Check if rhythm is enabled globally
     */
    isEnabled() {
        return this.enabled && this.adapter.isPlaying();
    }
    
    /**
     * Start rhythm playback
     */
    start(bpm = 120, pattern = 'straight') {
        if (bpm) rhythmEngine.setBPM(bpm);
        if (pattern) rhythmEngine.setPattern(pattern);
        rhythmEngine.start();
        this.enabled = true;
    }
    
    /**
     * Stop rhythm playback
     */
    stop() {
        rhythmEngine.stop();
        this.enabled = false;
        // Unlock BPM when stopping
        this.bpmLocked = false;
        this.lockedBPM = null;
    }
    
    /**
     * Set rhythm pattern
     */
    setPattern(pattern) {
        rhythmEngine.setPattern(pattern);
    }
    
    /**
     * Set BPM
     */
    setBPM(bpm) {
        rhythmEngine.setBPM(bpm);
        // Update the locked BPM if manually changed
        if (this.bpmLocked) {
            this.lockedBPM = bpm;
            console.log('🔒 BPM manually updated to:', bpm);
        }
    }
    
    /**
     * Resample BPM - unlocks detection for one update
     */
    resampleBPM() {
        console.log('🔓 Unlocking BPM for resampling');
        this.bpmLocked = false;
        this.lockedBPM = null;
    }
    
    /**
     * Set time signature from detected pattern
     */
    setTimeSignature(signature) {
        this.timeSignature = signature;
        
        // Update UI if available
        const timeSigDisplay = document.getElementById('time-sig-display');
        if (timeSigDisplay) {
            timeSigDisplay.textContent = signature;
        }
        
        // Could update rhythm patterns based on time signature here
        // For example, switch to waltz pattern for 3/4
        if (signature === '3/4' && rhythmEngine.getPattern() !== 'waltz') ;
    }
    
    /**
     * Sync to external audio
     */
    syncToAudio(audioContext, audioSource) {
        rhythmEngine.syncToAudio(audioContext, audioSource);
    }
}

// Create singleton instance
const rhythmIntegration = new RhythmIntegration();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Gesture Motion Orchestrator
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Orchestrator for modular gesture system - replaces monolithic switch
 * @author Emotive Engine Team
 * @module gestures/GestureMotion
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This orchestrator manages gesture application using the modular gesture system.   
 * ║ It replaces the old 538-line switch statement with clean, modular lookups.        
 * ║ Drop-in replacement for the old applyGestureMotion function.                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * Apply gesture motion to a particle using the modular system
 * This is a drop-in replacement for the old applyGestureMotion function
 * 
 * @param {Particle} particle - The particle to animate
 * @param {number} dt - Delta time (normalized to 60fps)
 * @param {Object} motion - Gesture motion configuration
 * @param {number} progress - Gesture progress (0-1)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function applyGestureMotion(particle, dt, motion, progress, centerX, centerY) {
    // Validate inputs
    if (!motion || !motion.type || progress >= 1) {
        return;
    }
    
    // Initialize gesture data if needed
    if (!particle.gestureData) {
        particle.gestureData = {
            originalVx: particle.vx,
            originalVy: particle.vy,
            initialX: particle.x,
            initialY: particle.y,
            // For compatibility with gestures that expect these
            startAngle: Math.atan2(particle.y - centerY, particle.x - centerX),
            startRadius: Math.sqrt(Math.pow(particle.x - centerX, 2) + Math.pow(particle.y - centerY, 2))
        };
    }
    
    // Look up the gesture from registry
    const gesture = getGesture(motion.type);
    
    if (!gesture) {
        return;
    }
    
    // Apply rhythm modulation if enabled
    let rhythmModifiedMotion = motion;
    if (rhythmIntegration.isEnabled() && gesture.rhythm?.enabled) {
        const modulation = rhythmIntegration.applyGestureRhythm(gesture, particle, progress, dt);
        
        // Create modified motion with rhythm adjustments
        rhythmModifiedMotion = {
            ...motion,
            amplitude: (motion.amplitude || 1) * (modulation.amplitudeMultiplier || 1) * (modulation.accentMultiplier || 1),
            wobbleAmount: (motion.wobbleAmount || 0) * (modulation.wobbleMultiplier || 1),
            // Allow rhythm to affect other parameters as needed
            rhythmModulation: modulation
        };
    }
    
    // Apply the gesture using its modular implementation
    if (gesture.apply) {
        gesture.apply(particle, progress, rhythmModifiedMotion, dt, centerX, centerY);
    }
    
    // Handle cleanup when gesture completes
    if (progress >= 0.99 && gesture.cleanup) {
        gesture.cleanup(particle);
        // Reset gesture data for next gesture
        particle.gestureData = null;
    }
}

/**
 * Helper function to check if a gesture should override particle behavior
 * Used by Particle.js to determine update flow
 * 
 * @param {string} gestureType - The gesture type name
 * @returns {boolean} True if gesture completely overrides particle motion
 */
function isGestureOverriding(gestureType) {
    return isOverrideGesture(gestureType);
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Modular Particle System with 3D Depth
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Orchestrator for the modular particle system with z-coordinate depth
 * @author Emotive Engine Team
 * @module core/Particle-modular
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                               MODULAR ARCHITECTURE                                
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This is a drop-in replacement for the original Particle.js                        
 * ║ Same API, but with modular architecture for easier maintenance                    
 * ║                                                                                    
 * ║ STRUCTURE:                                                                         
 * ║ - Particle class (this file) - orchestrates everything                            
 * ║ - particles/behaviors/* - behavior modules                                     
 * ║ - particles/config/* - configuration constants                                    
 * ║ - particles/utils/* - utility functions                                           
 * ║ - gestures/* - modular gesture system                                             
 * ║                                                                                    
 * ║ 3D DEPTH SYSTEM:                                                                   
 * ║ - Z-coordinate ranges from -1 (behind orb) to +1 (in front)                       
 * ║ - 1/13 particles spawn in foreground, 12/13 in background                         
 * ║ - Depth affects visual size (20% scaling based on z)                              
 * ║ - Foreground particles spawn with offset to prevent stacking                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * Particle class - Individual particle with behavior and rendering
 * 
 * LIFECYCLE:
 * 1. Created by ParticleSystem with position and behavior
 * 2. Initialized with behavior-specific properties
 * 3. Updated each frame (position, behavior, lifecycle)
 * 4. Rendered to canvas
 * 5. Removed when life reaches 0
 */
class Particle {
    /**
     * Creates a new particle with specific behavior and appearance
     * 
     * @param {number} x - Starting X position on canvas
     * @param {number} y - Starting Y position on canvas
     * @param {string} behavior - Behavior type (ambient, rising, falling, etc.)
     * @param {number} scaleFactor - Global scale multiplier (affects size/distance)
     * @param {number} particleSizeMultiplier - Additional size multiplier
     * @param {Array} emotionColors - Array of color options with weights
     */
    constructor(x, y, behavior = 'ambient', scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null) {
        // Position and movement (now with z-coordinate for depth)
        // 1/13 chance of being in front (z > 0), 12/13 chance of being behind (z < 0)
        const zRoll = Math.random();
        this.z = zRoll < (1/13) ? 0.5 + Math.random() * 0.5 : -1 + Math.random() * 0.9;
        
        // Add spawn offset to prevent stacking
        // Much larger offset for foreground particles to completely avoid visual stacking
        const spawnRadius = this.z > 0 ? (20 + Math.random() * 20) * scaleFactor : 3 * scaleFactor;
        const angle = Math.random() * Math.PI * 2;
        this.x = x + Math.cos(angle) * spawnRadius;
        this.y = y + Math.sin(angle) * spawnRadius;
        this.vx = 0;
        this.vy = 0;
        this.vz = 0; // For future 3D motion effects
        
        // Lifecycle
        this.life = 0.0; // Start at 0 for fade-in
        this.maxLife = 1.0;
        this.lifeDecay = 0.01; // Life lost per frame
        this.fadeInTime = 0.15; // 15% of life for fade-in
        this.fadeOutTime = 0.3; // Last 30% of life for fade-out
        this.isFadingOut = false; // Track if particle is in fade-out phase
        this.age = 0; // Track particle age for smooth fading
        
        // Visual properties - matching original Emotive scale
        this.scaleFactor = scaleFactor;
        this.particleSizeMultiplier = particleSizeMultiplier;
        this.size = (4 + Math.random() * 6) * scaleFactor * particleSizeMultiplier; // 4-10 pixels scaled
        this.baseSize = this.size;
        this.emotionColors = emotionColors; // Store emotion colors for use in behaviors
        this.color = '#ffffff';
        this.opacity = 1.0;
        
        // Glow properties - 1/3 of particles have glow with varying sizes
        this.hasGlow = Math.random() < 0.333;  // 1/3 chance of glow
        this.glowSizeMultiplier = this.hasGlow ? (1.33 + Math.random() * 0.33) : 0;  // 1.33x to 1.66x particle size
        
        // Cell shading - 1/3 of particles are cell shaded (cartoon style)
        this.isCellShaded = Math.random() < 0.333;  // 1/3 chance of cell shading
        
        // Make particles more ephemeral
        this.baseOpacity = 0.3 + Math.random() * 0.4;  // 30-70% max opacity for ethereal look
        
        // Color caching for performance
        this.cachedColors = new Map(); // Cache RGBA strings
        this.lastColor = null;
        this.lastOpacity = -1;
        
        // Behavior properties
        this.behavior = behavior;
        this.behaviorData = {}; // Behavior-specific data
        
        // Gesture properties for motion system
        this.gestureData = {
            initialX: x,
            initialY: y
        };
        
        // Initialize behavior-specific properties
        initializeBehavior(this, behavior);
    }

    /**
     * Updates particle position and behavior
     * @param {number} deltaTime - Time since last update in milliseconds
     * @param {number} centerX - Center X coordinate for behavior calculations
     * @param {number} centerY - Center Y coordinate for behavior calculations
     * @param {Object} undertoneModifier - Optional undertone modifications
     * @param {Object} gestureMotion - Optional gesture motion to apply
     * @param {number} gestureProgress - Progress of the gesture (0-1)
     */
    update(deltaTime, centerX, centerY, undertoneModifier = null, gestureMotion = null, gestureProgress = 0) {
        // Cap deltaTime to prevent huge jumps
        const cappedDeltaTime = Math.min(deltaTime, 50);
        // Normalize to 60 FPS equivalent for consistent physics
        const dt = cappedDeltaTime / 16.67; // 16.67ms = 60 FPS frame time
        
        // Universal law: Gestures override state behavior based on their motion type
        // Use the modular gesture system to determine gesture behavior
        const gestureIsOverriding = gestureMotion && gestureMotion.type && gestureProgress > 0 && 
            isGestureOverriding(gestureMotion.type);
        
        if (gestureIsOverriding) {
            // Gesture completely controls particle - skip normal behavior
            this.applyGestureMotion(gestureMotion, gestureProgress, dt, centerX, centerY);
        } else if (this.gestureBehavior === 'falling') {
            // Rain gesture is active - use falling behavior instead of normal behavior
            updateBehavior(this, 'falling', dt, centerX, centerY);
        } else if (this.gestureBehavior === 'radiant') {
            // Shimmer gesture is active - use radiant behavior for shimmering effect
            updateBehavior(this, 'radiant', dt, centerX, centerY);
        } else {
            // Normal behavior update
            updateBehavior(this, this.behavior, dt, centerX, centerY);
            
            // Don't apply undertone modifications to particle motion
            // Undertones only affect color saturation and core behaviors
            
            // Apply non-overriding gesture motion if present
            if (gestureMotion && gestureProgress > 0) {
                this.applyGestureMotion(gestureMotion, gestureProgress, dt, centerX, centerY);
            }
        }
        
        // Apply velocity to position (unless gesture is directly controlling position)
        if (!gestureIsOverriding) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
        }
        
        // HARD BOUNDARY CONSTRAINTS - particles NEVER leave canvas
        const canvasWidth = centerX * 2;
        const canvasHeight = centerY * 2;
        const margin = 20;
        
        // Bounce off boundaries
        if (this.x - this.size < margin) {
            this.x = margin + this.size;
            this.vx = Math.abs(this.vx) * 0.5;
        } else if (this.x + this.size > canvasWidth - margin) {
            this.x = canvasWidth - margin - this.size;
            this.vx = -Math.abs(this.vx) * 0.5;
        }
        
        if (this.y - this.size < margin) {
            this.y = margin + this.size;
            this.vy = Math.abs(this.vy) * 0.5;
        } else if (this.y + this.size > canvasHeight - margin) {
            this.y = canvasHeight - margin - this.size;
            this.vy = -Math.abs(this.vy) * 0.5;
        }
        
        // Update age and life (EXACT COPY FROM ORIGINAL)
        this.age += this.lifeDecay * dt;
        
        // Smooth fade-in at birth
        if (this.age < this.fadeInTime) {
            this.life = this.age / this.fadeInTime;
        }
        // Full opacity in middle of life
        else if (this.age < (1.0 - this.fadeOutTime)) {
            this.life = 1.0;
        }
        // Smooth fade-out at death
        else {
            this.life = (1.0 - this.age) / this.fadeOutTime;
            this.isFadingOut = true;
            
            // Dynamic size reduction for popcorn during fade-out
            if (this.behavior === 'popcorn') {
                this.size = this.baseSize * (0.5 + 0.5 * this.life);
            }
        }
        
        this.life = Math.max(0, Math.min(1, this.life));
        
        // Update opacity with easing for extra smoothness
        this.opacity = this.easeInOutCubic(this.life);
        
        // Update size based on life for some behaviors
        if (this.behavior === 'burst' && this.behaviorData && this.life < this.behaviorData.fadeStart) {
            this.size = this.baseSize * (this.life / this.behaviorData.fadeStart);
        }
    }


    /**
     * DEPRECATED - Undertones no longer affect particle motion
     * Kept for compatibility but does nothing
     * @param {number} dt - Normalized delta time
     * @param {Object} modifier - Undertone modifier settings
     */
    applyUndertoneModifier(dt, modifier) {
        // Undertones no longer affect particles
        // They only affect color saturation and core behaviors
        return;
    }

    /**
     * Apply gesture motion to particle
     * @param {Object} motion - Gesture motion configuration
     * @param {number} progress - Gesture progress (0-1)
     * @param {number} dt - Normalized delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    applyGestureMotion(motion, progress, dt, centerX, centerY) {
        // Use the full gesture system from the original
        applyGestureMotion(this, dt, motion, progress, centerX, centerY);
    }

    /**
     * Check if particle is out of bounds
     * @param {number} width - Canvas width
     * @param {number} height - Canvas height
     * @returns {boolean} True if particle is out of bounds
     */
    isOutOfBounds(width, height) {
        const margin = 50; // Allow some margin for particles to re-enter
        return this.x < -margin || this.x > width + margin || 
               this.y < -margin || this.y > height + margin;
    }

    /**
     * Check if particle is still alive
     * @returns {boolean} True if particle life > 0
     */
    isAlive() {
        return this.life > 0;
    }

    /**
     * Set outward velocity for gesture effects
     * @param {number} angle - Direction angle in radians
     */
    setOutwardVelocity(angle) {
        if (this.behaviorData && this.behaviorData.outwardSpeed !== undefined) {
            const speed = this.behaviorData.outwardSpeed;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed + (this.behaviorData.upwardBias || 0);
        }
    }

    /**
     * Get depth-adjusted size for 3D effect
     * Particles farther away (negative z) appear smaller for depth perception
     * 
     * @returns {number} Adjusted size based on z-depth
     * 
     * DEPTH SCALING:
     * - z = -1.0: 80% size (farthest back)
     * - z =  0.0: 100% size (orb plane)
     * - z = +1.0: 120% size (closest to viewer)
     */
    getDepthAdjustedSize() {
        // Map z from [-1, 1] to scale [0.8, 1.2]
        // Negative z (behind) = smaller, positive z (front) = larger
        const depthScale = 1 + (this.z * 0.2);
        return this.size * depthScale;
    }
    
    /**
     * Get particle state for debugging
     * @returns {Object} Current particle state
     */
    getState() {
        return {
            position: { x: this.x, y: this.y, z: this.z },
            velocity: { x: this.vx, y: this.vy, z: this.vz },
            life: this.life,
            behavior: this.behavior,
            size: this.size,
            opacity: this.opacity
        };
    }


    /**
     * Reset particle for reuse from pool
     * @param {number} x - New X position
     * @param {number} y - New Y position
     * @param {string} behavior - New behavior type
     * @param {number} scaleFactor - Scale factor
     * @param {number} particleSizeMultiplier - Size multiplier
     * @param {Array} emotionColors - Emotion colors
     */
    reset(x, y, behavior = 'ambient', scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null) {
        // 1/13 chance of being in front (z > 0), 12/13 chance of being behind (z < 0)
        const zRoll = Math.random();
        this.z = zRoll < (1/13) ? 0.5 + Math.random() * 0.5 : -1 + Math.random() * 0.9;
        
        // Add spawn offset to prevent stacking
        // Much larger offset for foreground particles to completely avoid visual stacking
        const spawnRadius = this.z > 0 ? (20 + Math.random() * 20) * scaleFactor : 3 * scaleFactor;
        const angle = Math.random() * Math.PI * 2;
        this.x = x + Math.cos(angle) * spawnRadius;
        this.y = y + Math.sin(angle) * spawnRadius;
        this.vx = 0;
        this.vy = 0;
        this.vz = 0;
        this.life = 0.0;  // Start at 0 for fade-in
        this.age = 0;  // Reset age
        this.scaleFactor = scaleFactor;
        this.particleSizeMultiplier = particleSizeMultiplier;
        this.size = (4 + Math.random() * 6) * scaleFactor * particleSizeMultiplier;  // Scaled size
        this.baseSize = this.size;
        this.emotionColors = emotionColors;  // Store emotion colors
        
        // Clear cached colors for reuse
        this.cachedColors.clear();
        this.opacity = 0.0;  // Start invisible
        this.isFadingOut = false;
        this.baseOpacity = 0.3 + Math.random() * 0.4;  // Reset base opacity
        this.color = '#ffffff';  // Reset color to white before reinitializing
        this.behavior = behavior;
        
        // Clear gesture data if it exists
        this.gestureData = null;
        
        // Reset behavior data
        if (!this.behaviorData) {
            this.behaviorData = {};
        } else {
            // Clear existing properties
            for (let key in this.behaviorData) {
                delete this.behaviorData[key];
            }
        }
        
        // Reinitialize behavior
        initializeBehavior(this, behavior);
    }

    /**
     * Get cached color string for performance
     * @param {string} hexColor - Hex color code
     * @param {number} opacity - Opacity value (0-1)
     * @returns {string} RGBA color string
     */
    getCachedColor(hexColor, opacity) {
        // Round opacity to reduce cache entries
        const roundedOpacity = Math.round(opacity * 100) / 100;
        const cacheKey = `${hexColor}_${roundedOpacity}`;
        
        if (!this.cachedColors.has(cacheKey)) {
            this.cachedColors.set(cacheKey, this.hexToRgba(hexColor, roundedOpacity));
        }
        
        return this.cachedColors.get(cacheKey);
    }

    /**
     * Convert hex color to RGBA string
     * @param {string} hex - Hex color code
     * @param {number} alpha - Alpha value (0-1)
     * @returns {string} RGBA color string
     */
    hexToRgba(hex, alpha) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!result) return `rgba(255, 255, 255, ${alpha})`;
        
        return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha})`;
    }

    /**
     * Cubic ease in/out function for smooth animations
     * @param {number} t - Progress value (0-1)
     * @returns {number} Eased value (0-1)
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Render the particle to canvas
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {string} emotionColor - Color to use for rendering
     */
    render(ctx, emotionColor = '#ffffff') {
        if (this.life <= 0) return;
        
        // Validate position values to prevent rendering errors
        if (!isFinite(this.x) || !isFinite(this.y)) {
            return;
        }
        
        // Use sub-pixel accurate coordinates for smooth rendering
        const renderX = this.x;
        const renderY = this.y;
        
        // Ensure size is never negative
        const safeSize = Math.max(0.1, this.size);
        
        // Use the particle's own color if set, otherwise fall back to emotion color
        const particleColor = this.tempColor || this.color || emotionColor;
        
        ctx.save();
        
        if (this.isCellShaded) {
            // Cell shaded style - hard edges, no gradients
            
            // Draw outline (darker color)
            ctx.strokeStyle = this.getCachedColor(particleColor, this.opacity * 0.9);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(renderX, renderY, safeSize, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw flat color fill with discrete opacity levels
            const discreteOpacity = Math.floor(this.opacity * 3) / 3;
            ctx.fillStyle = this.getCachedColor(particleColor, discreteOpacity * (this.baseOpacity || 0.5) * 0.5);
            ctx.beginPath();
            ctx.arc(renderX, renderY, Math.max(0.1, safeSize - 1), 0, Math.PI * 2);
            ctx.fill();
            
            // Add hard-edged highlight
            if (discreteOpacity > 0.5) {
                ctx.fillStyle = this.getCachedColor('#FFFFFF', 0.3);
                ctx.beginPath();
                ctx.arc(renderX - safeSize * 0.3, renderY - safeSize * 0.3, safeSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        } else {
            // Standard gradient style
            
            // Create radial gradient for soft particle
            const gradient = ctx.createRadialGradient(renderX, renderY, 0, renderX, renderY, safeSize);
            
            // Core is full opacity with base opacity applied
            gradient.addColorStop(0, this.getCachedColor(particleColor, this.opacity * (this.baseOpacity || 0.5)));
            // Mid fade
            gradient.addColorStop(0.5, this.getCachedColor(particleColor, this.opacity * (this.baseOpacity || 0.5) * 0.5));
            // Edge is transparent
            gradient.addColorStop(1, this.getCachedColor(particleColor, 0));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(renderX, renderY, safeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Add glow effect if enabled
            if (this.hasGlow && this.glowSizeMultiplier > 0) {
                const glowSize = safeSize * this.glowSizeMultiplier;
                const glowGradient = ctx.createRadialGradient(renderX, renderY, safeSize * 0.5, renderX, renderY, glowSize);

                // Make glow visible even when particles are subdued
                // Use a minimum opacity for glow to ensure visibility
                const minGlowOpacity = 0.3; // Minimum glow visibility
                const particleOpacity = Math.max(minGlowOpacity, this.opacity);

                // Scale glow intensity based on glowSizeMultiplier
                // Higher multiplier = more intense glow (especially for gesture effects)
                const glowIntensity = Math.min(1.0, this.glowSizeMultiplier / 3); // More aggressive scaling

                // Create bright, visible glow with minimum opacity thresholds
                glowGradient.addColorStop(0, this.getCachedColor(particleColor, Math.max(0.5, particleOpacity * 0.8) * glowIntensity));
                glowGradient.addColorStop(0.25, this.getCachedColor(particleColor, Math.max(0.3, particleOpacity * 0.6) * glowIntensity));
                glowGradient.addColorStop(0.5, this.getCachedColor(particleColor, Math.max(0.2, particleOpacity * 0.4) * glowIntensity));
                glowGradient.addColorStop(0.75, this.getCachedColor(particleColor, Math.max(0.1, particleOpacity * 0.2) * glowIntensity));
                glowGradient.addColorStop(1, this.getCachedColor(particleColor, 0));

                // Use additive blending for brighter glow effect
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(renderX, renderY, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        ctx.restore();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  PARTICLE SYSTEM  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particle System - Orchestrator of Emotional Atmosphere with 3D Depth
 * @author Emotive Engine Team
 * @version 2.4.0
 * @module ParticleSystem
 * @changelog 2.4.0 - Added z-coordinate depth system with split rendering layers
 * @changelog 2.3.0 - Batch rendering optimization for reduced state changes
 * @changelog 2.2.0 - Added undertone saturation system for dynamic particle depth
 * @changelog 2.1.0 - Added support for passing emotion colors to individual particles
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The CONDUCTOR of particle chaos. Manages the lifecycle, behavior, and             
 * ║ performance of all particles. Uses object pooling to prevent memory leaks         
 * ║ and coordinates particles to create emotional atmospheres around the orb.         
 * ║                                                                                    
 * ║ NEW: Undertone saturation dynamically adjusts particle colors based on emotional  
 * ║ intensity, creating visual depth through saturation levels.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 SYSTEM FEATURES                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Object pooling for performance (reuse dead particles)                           
 * │ • Time-based spawning with accumulator                                            
 * │ • Automatic cleanup every 5 seconds                                               
 * │ • Memory leak detection and prevention                                            
 * │ • Dynamic particle limits based on emotion                                        
 * │ • 13 different particle behaviors                                                 
 * │ • Undertone-based saturation adjustments for particle colors                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 OBJECT POOL STRATEGY                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Lazy initialization (create as needed)                                          
 * │ • Max pool size: 50 particles                                                     
 * │ • Reuse dead particles before creating new                                        
 * │ • Track pool hits/misses for optimization                                         
 * │ • Absolute max: 2x configured limit (prevents runaway)                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 PERFORMANCE LIMITS                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Default max particles  : 50                                                     
 * │ • Absolute max particles : 100 (2x default)                                       
 * │ • Pool size             : Min(maxParticles, 50)                                  
 * │ • Cleanup interval      : 5000ms                                                 
 * │ • Spawn rate            : Based on emotion config                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                              MEMORY MANAGEMENT                                    
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Critical for preventing memory leaks:                                             
 * ║ 1. Reuse particles from pool when available                                       
 * ║ 2. Clear references when returning to pool                                        
 * ║ 3. Periodic cleanup of excess particles                                           
 * ║ 4. Track creation/destruction for leak detection                                  
 * ║ 5. Hard limits prevent runaway particle creation                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class ParticleSystem {
    constructor(maxParticles = 50, errorBoundary = null) {
        this.errorBoundary = errorBoundary;
        this.maxParticles = maxParticles;
        this.absoluteMaxParticles = maxParticles * 2; // Hard limit to prevent leaks
        
        // Active particles
        this.particles = [];
        
        // Object pool for performance - reduced to prevent memory buildup
        this.pool = [];
        this.poolSize = Math.min(maxParticles, 50); // Limit pool to max 50 particles
        
        // Memory leak detection
        this.totalParticlesCreated = 0;
        this.totalParticlesDestroyed = 0;
        this.stateChangeCount = 0;
        this.lastMemoryCheck = Date.now();
        this.lastLeakedCount = 0;
        
        // TIME-BASED spawning using accumulation for smooth, consistent particle creation
        this.spawnAccumulator = 0; // Accumulates time to spawn particles
        
        // Performance tracking
        this.particleCount = 0;
        this.poolHits = 0;
        this.poolMisses = 0;
        
        // Cleanup timer to prevent memory buildup
        this.cleanupTimer = 0;
        this.cleanupInterval = 5000; // Clean up every 5 seconds
        
        // Initialize object pool
        this.initializePool();
        
        // ParticleSystem initialized
    }

    /**
     * Initialize the object pool with pre-created particles
     */
    initializePool() {
        // Don't pre-create particles - create them lazily as needed
        // This prevents memory buildup on initialization
        this.pool = [];
    }

    /**
     * Gets a particle from the pool or creates a new one
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} behavior - Particle behavior type
     * @returns {Particle} Particle instance
     */
    getParticleFromPool(x, y, behavior) {
        let particle;
        
        if (this.pool.length > 0) {
            // Reuse from pool
            particle = this.pool.pop();
            particle.reset(x, y, behavior, this.scaleFactor || 1, this.particleSizeMultiplier || 1, this.currentEmotionColors);
            this.poolHits++;
        } else {
            // Create new particle
            particle = new Particle(x, y, behavior, this.scaleFactor || 1, this.particleSizeMultiplier || 1, this.currentEmotionColors);
            this.poolMisses++;
            this.totalParticlesCreated++;
        }
        
        // Set the emotion for behavior customization
        particle.emotion = this.currentEmotion;
        
        // Apply gesture behavior if active (e.g., doppler for rain)
        if (this.gestureBehavior) {
            particle.gestureBehavior = this.gestureBehavior;
        }
        
        return particle;
    }

    /**
     * Returns a particle to the pool for reuse
     * @param {Particle} particle - Particle to return to pool
     */
    returnParticleToPool(particle) {
        if (this.pool.length < this.poolSize) {
            // Clear references before pooling
            particle.cachedGradient = null;
            particle.cachedGradientKey = null;
            // Clear behaviorData properties but keep the object
            if (particle.behaviorData) {
                for (let key in particle.behaviorData) {
                    delete particle.behaviorData[key];
                }
            }
            this.pool.push(particle);
        } else {
            // If pool is full, count as destroyed since it will be GC'd
            this.totalParticlesDestroyed++;
        }
    }

    /**
     * Spawns particles based on emotional state and particle rate
     * NEW APPROACH: Fixed timestep - only spawn at specific intervals
     * 
     * @param {string} behavior - Particle behavior type (ambient, rising, falling, etc.)
     * @param {string} emotion - Current emotional state
     * @param {number} particleRate - Rate of particle spawning (particles per second at 60fps)
     * @param {number} centerX - X coordinate of spawn center
     * @param {number} centerY - Y coordinate of spawn center
     * @param {number} deltaTime - Time since last frame in milliseconds
     * @param {number|null} count - Force spawn this many particles (null for rate-based)
     * @param {number} minParticles - Minimum particles to maintain
     * @param {number} maxParticles - Maximum particles allowed
     * @param {number} scaleFactor - Scale multiplier for particle sizes
     * @param {number} particleSizeMultiplier - Additional size multiplier
     * @param {Array|null} emotionColors - Array of color strings or weighted color objects
     * @param {string|null} undertone - Emotional undertone for saturation adjustment
     *                                   (intense, confident, nervous, clear, tired, subdued)
     *                                   Affects particle color saturation to create depth
     */
    spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count = null, minParticles = 0, maxParticles = 10, scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null, undertone = null) {
        this.scaleFactor = scaleFactor; // Store for particle creation
        this.particleSizeMultiplier = particleSizeMultiplier; // Store for particle sizing
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles, maxParticles, emotionColors, undertone);
            }, 'particle-spawn')();
        } else {
            this._spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles, maxParticles, emotionColors, undertone);
        }
    }
    
    /**
     * Resets the spawn accumulator (for tab switches)
     */
    resetAccumulator() {
        this.spawnAccumulator = 0;
    }

    /**
     * Internal spawn implementation - TIME-BASED accumulation for smooth spawning
     * 
     * Applies undertone saturation adjustments to particle colors before spawning.
     * The saturation system creates visual depth:
     * - Intense/Confident: Oversaturated colors appear to pop forward
     * - Clear: Normal midtone colors sit in the middle ground  
     * - Tired/Subdued: Desaturated colors recede into background
     * 
     * This creates a natural transition as particles cycle through their lifecycle,
     * with new particles spawning with current undertone saturation while existing
     * particles maintain their original colors until expiration.
     */
    _spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles = 0, maxParticles = 10, emotionColors = null, undertone = null) {
        // Store emotion for particle initialization
        this.currentEmotion = emotion;
        
        // Debug logging for excited emotion
        if (emotion === 'excited' && !this._excitedDebugLogged) {
            console.log('[ParticleSystem] Excited emotion spawn:', {
                behavior,
                emotion,
                particleRate,
                minParticles,
                maxParticles,
                emotionColors,
                currentParticleCount: this.particles.length
            });
            this._excitedDebugLogged = true;
            setTimeout(() => { this._excitedDebugLogged = false; }, 5000); // Reset after 5 seconds
        }
        
        // Store base colors and undertone separately to ensure consistent application
        this.baseEmotionColors = emotionColors;
        this.currentUndertone = undertone;
        
        // Apply undertone saturation to emotion colors for all particles
        // This adjustment persists for the lifetime of each particle, creating
        // smooth visual transitions as particles naturally cycle
        this.currentEmotionColors = emotionColors && undertone ? 
            applyUndertoneSaturationToArray(emotionColors, undertone) : 
            emotionColors;
        
        // Apply rhythm modulation if enabled
        let rhythmModulatedRate = particleRate;
        if (rhythmIntegration.isEnabled()) {
            const emotionConfig = getEmotion(emotion);
            if (emotionConfig) {
                const modulation = rhythmIntegration.applyParticleRhythm(emotionConfig, this);
                
                // Apply emission burst on beat
                if (modulation.emitBurst) {
                    for (let i = 0; i < modulation.emitBurst && this.particles.length < maxParticles; i++) {
                        this.spawnSingleParticle(behavior, centerX, centerY);
                    }
                }
                
                // Modulate emission rate
                if (modulation.emissionRate !== undefined) {
                    rhythmModulatedRate *= modulation.emissionRate;
                }
            }
        }
        
        
        // If specific count is provided, spawn that many
        if (count !== null) {
            for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                this.spawnSingleParticle(behavior, centerX, centerY);
            }
            return;
        }
        
        // Skip spawning if frame rate is too low (performance optimization)
        if (this.skipSpawnThisFrame) {
            return;
        }
        
        // Always maintain minimum particles
        while (this.particles.length < minParticles && this.particles.length < this.maxParticles) {
            this.spawnSingleParticle(behavior, centerX, centerY);
        }
        
        // If we're at or above max for this emotion, don't spawn more
        if (this.particles.length >= maxParticles) {
            return;
        }
        
        // Don't spawn if rate is 0
        if (rhythmModulatedRate <= 0) return;
        
        // TIME-BASED SPAWNING using accumulation
        // rhythmModulatedRate represents desired particles at 60 FPS
        // So rate of 1 = 1 particle per 60 frames = 1 particle per second at 60fps
        // Cap deltaTime to prevent huge accumulation spikes
        const cappedDeltaTime = Math.min(deltaTime, 50);
        const particlesPerSecond = rhythmModulatedRate; // Direct mapping: rate = particles/second
        const particlesPerMs = particlesPerSecond / 1000;
        
        // Accumulate spawn time with capped delta
        this.spawnAccumulator += particlesPerMs * cappedDeltaTime;
        
        // Cap accumulator to prevent excessive spawning after long pauses
        this.spawnAccumulator = Math.min(this.spawnAccumulator, 3.0);
        
        // Spawn accumulated particles smoothly
        while (this.spawnAccumulator >= 1.0 && this.particles.length < maxParticles) {
            this.spawnSingleParticle(behavior, centerX, centerY);
            this.spawnAccumulator -= 1.0;
        }
    }

    /**
     * Spawns a single particle with the specified behavior
     * @param {string} behavior - Particle behavior type
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    spawnSingleParticle(behavior, centerX, centerY) {
        // Hard limit check to prevent memory leaks
        if (this.particles.length >= this.absoluteMaxParticles) {
            return;
        }
        
        // Calculate spawn position based on behavior
        let spawnPos = this.getSpawnPosition(behavior, centerX, centerY);
        
        // CLAMP spawn position to canvas boundaries
        const clampedPos = this.clampToCanvas(spawnPos.x, spawnPos.y, centerX, centerY);
        spawnPos.x = clampedPos.x;
        spawnPos.y = clampedPos.y;
        
        // Get particle from pool
        const particle = this.getParticleFromPool(spawnPos.x, spawnPos.y, behavior);
        
        // Pass additional data for meditation_swirl
        if (behavior === 'meditation_swirl' && spawnPos.palmCenter) {
            particle.palmCenter = spawnPos.palmCenter;
            particle.swirlAngle = spawnPos.swirlAngle;
        }
        
        // Add to active particles
        this.particles.push(particle);
        this.particleCount++;
        
        // Debug logging disabled to prevent console spam
        // Only uncomment for debugging particle spawning issues
        // if (this.particleCount <= 3) {
        // }
    }

    /**
     * Calculates spawn position based on behavior type
     * @param {string} behavior - Particle behavior type
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     * @returns {Object} Spawn position {x, y}
     */
    getSpawnPosition(behavior, centerX, centerY) {
        // Calculate orb radius based on canvas size (matching EmotiveRenderer)
        const canvasSize = Math.min(centerX * 2, centerY * 2);
        const orbRadius = canvasSize / 12;  // Core radius
        const glowRadius = orbRadius * 2.5; // Glow extends this far
        const margin = 30; // Keep spawns away from edges
        
        // Spawn particles outside the glow radius so they're visible
        const minSpawnRadius = glowRadius * 1.1; // 10% beyond glow edge
        const maxSpawnRadius = Math.min(glowRadius * 1.5, 
            centerX - margin, centerY - margin); // Constrain to canvas
        
        switch (behavior) {
            case 'ambient':
            case 'resting':
                // Spawn at edge of glow where particles become visible
                // They'll move outward to create "emanating from center" effect
                const ambientAngle = Math.random() * Math.PI * 2;
                const ambientRadius = glowRadius * 0.9; // Just at glow edge
                return {
                    x: centerX + Math.cos(ambientAngle) * ambientRadius,
                    y: centerY + Math.sin(ambientAngle) * ambientRadius,
                    angle: ambientAngle  // Pass angle for outward velocity
                };
                
            case 'rising':
            case 'falling':
                // These can spawn from outside for visibility
                const angle = Math.random() * Math.PI * 2;
                const radius = minSpawnRadius + Math.random() * (maxSpawnRadius - minSpawnRadius);
                return {
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                };
                
            case 'aggressive':
                // Spawn just outside the glow for aggressive burst effect
                const aggressiveAngle = Math.random() * Math.PI * 2;
                const aggressiveRadius = glowRadius + Math.random() * orbRadius;
                return {
                    x: centerX + Math.cos(aggressiveAngle) * aggressiveRadius,
                    y: centerY + Math.sin(aggressiveAngle) * aggressiveRadius
                };
                
            case 'scattering':
                // Spawn at center for outward movement (scattering needs this)
                return { x: centerX, y: centerY };
                
            case 'burst':
                // Spawn at edge of orb so particles are visible
                const burstAngle = Math.random() * Math.PI * 2;
                if (this.currentEmotion === 'suspicion') {
                    const burstRadius = orbRadius * 1.5; // Further outside for suspicion
                    return {
                        x: centerX + Math.cos(burstAngle) * burstRadius,
                        y: centerY + Math.sin(burstAngle) * burstRadius
                    };
                } else if (this.currentEmotion === 'surprise') {
                    // Surprise spawns around the orb edge for visibility
                    const burstRadius = orbRadius * 1.2; // Just outside the orb
                    return {
                        x: centerX + Math.cos(burstAngle) * burstRadius,
                        y: centerY + Math.sin(burstAngle) * burstRadius
                    };
                } else {
                    // Other emotions spawn at center
                    return { x: centerX, y: centerY };
                }
                
            case 'repelling':
                // Spawn at edge of glow so particles are visible
                const repelAngle = Math.random() * Math.PI * 2;
                const repelRadius = glowRadius * 0.9; // Just at glow edge
                return {
                    x: centerX + Math.cos(repelAngle) * repelRadius,
                    y: centerY + Math.sin(repelAngle) * repelRadius
                };
                
            case 'orbiting':
                // Spawn at orbital distance outside the glow
                const orbitAngle = Math.random() * Math.PI * 2;
                const orbitRadius = glowRadius * 1.2 + Math.random() * glowRadius * 0.5;
                return {
                    x: centerX + Math.cos(orbitAngle) * orbitRadius,
                    y: centerY + Math.sin(orbitAngle) * orbitRadius
                };
                
            default:
                return { x: centerX, y: centerY };
        }
    }
    
    /**
     * Clamps a position to stay within canvas boundaries
     */
    clampToCanvas(x, y, centerX, centerY, margin = 30) {
        const canvasWidth = centerX * 2;
        const canvasHeight = centerY * 2;
        return {
            x: Math.max(margin, Math.min(canvasWidth - margin, x)),
            y: Math.max(margin, Math.min(canvasHeight - margin, y))
        };
    }

    /**
     * Updates all particles and manages lifecycle
     * @param {number} deltaTime - Time since last update in milliseconds
     * @param {number} centerX - Center X coordinate for behavior calculations
     * @param {number} centerY - Center Y coordinate for behavior calculations
     * @param {Object} gestureMotion - Optional gesture motion to apply
     * @param {number} gestureProgress - Progress of gesture (0-1)
     * @param {Object} undertoneModifier - Optional undertone modifications
     */
    update(deltaTime, centerX, centerY, gestureMotion = null, gestureProgress = 0, undertoneModifier = null) {
        if (this.errorBoundary) {
            const wrappedUpdate = this.errorBoundary.wrap(
                (dt, cx, cy, gm, gp, um) => this._update(dt, cx, cy, gm, gp, um), 
                'particle-update'
            );
            return wrappedUpdate(deltaTime, centerX, centerY, gestureMotion, gestureProgress, undertoneModifier);
        } else {
            this._update(deltaTime, centerX, centerY, gestureMotion, gestureProgress, undertoneModifier);
        }
    }

    /**
     * Internal update implementation
     */
    _update(deltaTime, centerX, centerY, gestureMotion = null, gestureProgress = 0, undertoneModifier = null) {
        // Update cleanup timer
        this.cleanupTimer += deltaTime;
        
        // Periodic cleanup to prevent memory buildup
        if (this.cleanupTimer >= this.cleanupInterval) { // Clean up every 5 seconds
            this.performCleanup();
            this.cleanupTimer = 0;
        }
        
        // Memory leak detection - log every 30 seconds (reduced frequency)
        if (Date.now() - this.lastMemoryCheck > 30000) {
            const leaked = this.totalParticlesCreated - this.totalParticlesDestroyed;
            // Only warn if leak is significant and growing
            if (leaked > 200 && leaked > this.lastLeakedCount + 50) {
                this.lastLeakedCount = leaked;
            }
            this.lastMemoryCheck = Date.now();
        }
        
        // Update all particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            
            // Update particle with gesture motion and undertone modifier
            particle.update(deltaTime, centerX, centerY, undertoneModifier, gestureMotion, gestureProgress);
            
            // Remove dead particles
            if (!particle.isAlive()) {
                this.removeParticle(i);
            }
        }
        
        // Enforce particle limit by removing oldest if necessary
        while (this.particles.length > this.maxParticles) {
            this.removeParticle(0); // Remove oldest (first in array)
        }
    }

    /**
     * Set a temporary gesture behavior for particles
     * @param {string} behaviorName - Name of the behavior (e.g., 'doppler')
     * @param {boolean} active - Whether the behavior is active
     */
    setGestureBehavior(behaviorName, active) {
        this.gestureBehavior = active ? behaviorName : null;
        
        // Apply gesture behavior to existing particles
        if (active) {
            this.particles.forEach(particle => {
                particle.gestureBehavior = behaviorName;
            });
        } else {
            // Clear gesture behavior from particles
            this.particles.forEach(particle => {
                particle.gestureBehavior = null;
            });
        }
    }

    /**
     * Removes a particle at the specified index
     * @param {number} index - Index of particle to remove
     */
    removeParticle(index) {
        if (index >= 0 && index < this.particles.length) {
            const particle = this.particles.splice(index, 1)[0];
            // Clear any cached data before returning to pool
            particle.cachedGradient = null;
            particle.cachedGradientKey = null;
            // Don't set behaviorData to null - let reset handle it properly
            this.returnParticleToPool(particle);
            this.particleCount = Math.max(0, this.particleCount - 1);
        }
    }

    /**
     * Renders all particles to the canvas context
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * @param {Object} gestureTransform - Optional gesture transform data
     */
    render(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._render(ctx, emotionColor, gestureTransform);
            }, 'particle-render')();
        } else {
            this._render(ctx, emotionColor, gestureTransform);
        }
    }
    
    /**
     * Renders particles in the background layer (behind orb)
     * Particles with z < 0 are rendered, appearing smaller based on depth
     * 
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * 
     * LAYER DISTRIBUTION:
     * - ~92% of particles render in background (z < 0)
     * - Particles scale from 80% to 100% size based on z-depth
     */
    renderBackground(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._renderLayer(ctx, emotionColor, false, gestureTransform); // false = background (z < 0)
            }, 'particle-render-bg')();
        } else {
            this._renderLayer(ctx, emotionColor, false, gestureTransform);
        }
    }
    
    /**
     * Renders particles in the foreground layer (in front of orb)
     * Particles with z >= 0 are rendered, appearing larger based on depth
     * 
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * 
     * LAYER DISTRIBUTION:
     * - ~8% of particles render in foreground (z >= 0) 
     * - Particles scale from 100% to 120% size based on z-depth
     * - Spawn with offset to prevent visual stacking
     */
    renderForeground(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._renderLayer(ctx, emotionColor, true, gestureTransform); // true = foreground (z >= 0)
            }, 'particle-render-fg')();
        } else {
            this._renderLayer(ctx, emotionColor, true, gestureTransform);
        }
    }

    /**
     * Internal render implementation for a specific layer
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * @param {boolean} isForeground - true for foreground (z >= 0), false for background (z < 0)
     */
    _renderLayer(ctx, emotionColor, isForeground, gestureTransform = null) {
        // Sort particles by rendering properties to minimize state changes
        const visibleParticles = [];
        
        // First pass: cull off-screen, dead, and wrong-layer particles
        const margin = 50;
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        
        for (const particle of this.particles) {
            // Filter by z-layer
            const particleInForeground = particle.z >= 0;
            if (particleInForeground !== isForeground) {
                continue; // Skip particles in wrong layer
            }
            
            // Skip off-screen particles (culling)
            if (particle.x < -margin || particle.x > canvasWidth + margin ||
                particle.y < -margin || particle.y > canvasHeight + margin) {
                continue;
            }
            
            // Skip dead particles
            if (particle.life <= 0) continue;
            
            visibleParticles.push(particle);
        }
        
        // Sort by render type to minimize state changes
        visibleParticles.sort((a, b) => {
            if (a.isCellShaded !== b.isCellShaded) {
                return a.isCellShaded ? -1 : 1;
            }
            if (a.hasGlow !== b.hasGlow) {
                return a.hasGlow ? -1 : 1;
            }
            return 0;
        });
        
        // Actually render the particles
        this._renderParticles(ctx, visibleParticles, emotionColor, gestureTransform);
    }
    
    /**
     * Internal render implementation - batch optimized rendering (legacy, renders all)
     */
    _render(ctx, emotionColor, gestureTransform = null) {
        // Sort particles by rendering properties to minimize state changes
        const visibleParticles = [];
        
        // First pass: cull off-screen and dead particles
        const margin = 50;
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        
        for (const particle of this.particles) {
            // Skip off-screen particles (culling)
            if (particle.x < -margin || particle.x > canvasWidth + margin ||
                particle.y < -margin || particle.y > canvasHeight + margin) {
                continue;
            }
            
            // Skip dead particles
            if (particle.life <= 0) continue;
            
            visibleParticles.push(particle);
        }
        
        // Sort by render type to minimize state changes
        // Group: cellShaded first, then by hasGlow, then by color
        visibleParticles.sort((a, b) => {
            if (a.isCellShaded !== b.isCellShaded) {
                return a.isCellShaded ? -1 : 1;
            }
            if (a.hasGlow !== b.hasGlow) {
                return a.hasGlow ? -1 : 1;
            }
            // Group by color to reduce fillStyle changes
            const colorA = a.color || emotionColor;
            const colorB = b.color || emotionColor;
            if (colorA !== colorB) {
                return colorA < colorB ? -1 : 1;
            }
            return 0;
        });
        
        // Actually render the particles
        this._renderParticles(ctx, visibleParticles, emotionColor, gestureTransform);
    }
    
    /**
     * Render a list of particles with batch optimization
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {Array} visibleParticles - Array of particles to render
     * @param {string} emotionColor - Color to use for particle rendering
     * @param {Object} gestureTransform - Optional gesture transform data
     */
    _renderParticles(ctx, visibleParticles, emotionColor, gestureTransform = null) {
        // Batch render with minimized state changes
        ctx.save();
        let lastFillStyle = null;

        for (const particle of visibleParticles) {
            // For cell-shaded, use original render (they need complex stroke/fill combos)
            if (particle.isCellShaded) {
                particle.render(ctx, emotionColor);
                // Reset cached values since particle.render may have changed them
                lastFillStyle = null;
            } else {
                // Batch-optimized rendering for regular particles
                const particleColor = particle.color || emotionColor;
                
                // Only set fillStyle if it changed
                if (particleColor !== lastFillStyle) {
                    ctx.fillStyle = particleColor;
                    lastFillStyle = particleColor;
                }
                
                // Validate position once
                if (!isFinite(particle.x) || !isFinite(particle.y)) continue;
                
                // Use depth-adjusted size if particle has the method
                const depthSize = particle.getDepthAdjustedSize ? particle.getDepthAdjustedSize() : particle.size;
                const safeSize = Math.max(0.1, depthSize);
                
                // Apply firefly effect if sparkle gesture is active
                let fireflyGlow = 1.0;
                if (gestureTransform && gestureTransform.fireflyEffect) {
                    // Each particle gets unique phase for async firefly blinking
                    const particlePhase = (particle.x * 0.01 + particle.y * 0.01 + particle.size * 0.1) % (Math.PI * 2);
                    const time = gestureTransform.fireflyTime || (Date.now() * 0.001);
                    const intensity = gestureTransform.particleGlow || 2.0;
                    
                    // Create firefly pulse pattern
                    fireflyGlow = 0.3 + Math.max(0, Math.sin(time * 3 + particlePhase)) * intensity;
                }
                
                // Apply flicker effect if flicker gesture is active (now does particle shimmer)
                if (gestureTransform && gestureTransform.flickerEffect) {
                    // Each particle shimmers with a wave pattern
                    const particlePhase = (particle.x * 0.02 + particle.y * 0.02) % (Math.PI * 2);
                    const time = gestureTransform.flickerTime || (Date.now() * 0.001);
                    const intensity = gestureTransform.particleGlow || 2.0;
                    
                    // Create shimmer wave pattern - faster oscillation
                    fireflyGlow = 0.5 + Math.sin(time * 12 + particlePhase) * intensity * 0.5;
                }
                
                // Apply shimmer effect if shimmer gesture is active (subtle glow)
                if (gestureTransform && gestureTransform.shimmerEffect) {
                    // Each particle gets a subtle brightness variation based on distance from center
                    const dx = particle.x - (ctx.canvas.width / 2);
                    const dy = particle.y - (ctx.canvas.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const normalizedDistance = distance / 200; // Normalize to reasonable range
                    
                    const time = gestureTransform.shimmerTime || (Date.now() * 0.001);
                    const wave = gestureTransform.shimmerWave || 0;
                    const intensity = gestureTransform.particleGlow || 1.2;
                    
                    // Subtle traveling wave from center outward
                    const travelingWave = Math.sin(time * 3 - normalizedDistance + wave);
                    
                    // Very subtle glow modulation
                    fireflyGlow = 1 + travelingWave * 0.15 * intensity;
                }
                
                // Apply glow effect if glow gesture is active (radiant burst)
                if (gestureTransform && gestureTransform.glowEffect) {
                    const progress = gestureTransform.glowProgress || 0;
                    const intensity = gestureTransform.particleGlow || 2.0;

                    // Particles brighten based on distance - closer particles glow first
                    const dx = particle.x - (ctx.canvas.width / 2);
                    const dy = particle.y - (ctx.canvas.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const normalizedDistance = distance / 300;

                    // Glow radiates outward
                    const radiateDelay = Math.min(normalizedDistance * 0.3, 0.5);
                    const localProgress = Math.max(0, (progress - radiateDelay) / (1 - radiateDelay));
                    const localEnvelope = Math.sin(localProgress * Math.PI);

                    // ACTUALLY MAKE PARTICLES GLOW by temporarily setting glow properties
                    // Store original values if not already stored
                    if (!particle._originalGlow) {
                        particle._originalGlow = {
                            hasGlow: particle.hasGlow,
                            glowSizeMultiplier: particle.glowSizeMultiplier || 0
                        };
                    }

                    // Enable glow and set a large multiplier for visibility
                    particle.hasGlow = true;
                    particle.glowSizeMultiplier = Math.max(3.0, particle._originalGlow.glowSizeMultiplier) + localEnvelope * intensity * 3;

                    // Also boost particle size slightly
                    const glowSizeBoost = 1 + localEnvelope * 0.3;
                    safeSize = safeSize * glowSizeBoost;

                    // Cleanup flag - restore original values when effect ends
                    if (progress >= 0.99 && particle._originalGlow) {
                        particle.hasGlow = particle._originalGlow.hasGlow;
                        particle.glowSizeMultiplier = particle._originalGlow.glowSizeMultiplier;
                        delete particle._originalGlow;
                    }
                }
                
                // Draw glow layers if needed
                if (particle.hasGlow || fireflyGlow > 1.0) {
                    const glowRadius = Math.max(0.1, safeSize * (particle.glowSizeMultiplier || 1.5) * fireflyGlow);
                    
                    // Outer glow (enhanced by firefly effect)
                    ctx.globalAlpha = particle.opacity * 0.15 * fireflyGlow;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner glow (enhanced by firefly effect)
                    ctx.globalAlpha = particle.opacity * 0.25 * fireflyGlow;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, glowRadius * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw core (also brightened by firefly effect)
                ctx.globalAlpha = particle.opacity * (particle.baseOpacity || 0.5) * 0.6 * Math.min(2.0, fireflyGlow);
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, safeSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }

    /**
     * Clears all particles and returns them to the pool
     */
    clear() {
        this.stateChangeCount++;
        
        // Return all particles to pool but avoid duplicates
        while (this.particles.length > 0) {
            const particle = this.particles.pop();
            // Clear cached data before returning
            if (particle.cachedColors) {
                particle.cachedColors.clear();
            }
            // Clear behaviorData properties but keep the object
            if (particle.behaviorData) {
                for (let key in particle.behaviorData) {
                    delete particle.behaviorData[key];
                }
            }
            // Only add to pool if it's not already there and pool has space
            if (this.pool.length < this.poolSize && !this.pool.includes(particle)) {
                this.pool.push(particle);
            }
        }
        
        this.particles.length = 0;
        this.particleCount = 0;
        this.spawnAccumulator = 0; // Reset accumulator when clearing
        
        // Trim pool if it's grown too large
        if (this.pool.length > this.poolSize) {
            // Actually remove excess particles from pool
            const excess = this.pool.length - this.poolSize;
            this.pool.splice(this.poolSize, excess);
        }
        
    }

    /**
     * Triggers a burst of particles for gesture effects
     * @param {number} count - Number of particles to burst
     * @param {string} behavior - Behavior type for burst particles
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    burst(count, behavior, centerX, centerY) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._burst(count, behavior, centerX, centerY);
            }, 'particle-burst')();
        } else {
            this._burst(count, behavior, centerX, centerY);
        }
    }

    /**
     * Internal burst implementation
     */
    _burst(count, behavior, centerX, centerY) {
        const actualCount = Math.min(count, this.maxParticles - this.particles.length);
        
        for (let i = 0; i < actualCount; i++) {
            this.spawnSingleParticle(behavior, centerX, centerY);
        }
    }

    /**
     * Performs periodic cleanup to prevent memory buildup
     */
    performCleanup() {
        // Trim pool if it's grown too large
        if (this.pool.length > this.poolSize) {
            // Clear excess particles from pool
            const excess = this.pool.length - this.poolSize;
            for (let i = 0; i < excess; i++) {
                const particle = this.pool.pop();
                // Ensure all references are cleared
                if (particle) {
                    particle.cachedGradient = null;
                    particle.cachedGradientKey = null;
                    particle.behaviorData = null;
                }
            }
        }
        
        // Clear any cached data from active particles
        for (const particle of this.particles) {
            if (particle.cachedGradient && particle.life < 0.5) {
                // Clear gradient cache for fading particles
                particle.cachedGradient = null;
                particle.cachedGradientKey = null;
            }
        }
    }
    
    /**
     * Gets current particle system statistics
     * @returns {Object} Performance and state information
     */
    getStats() {
        return {
            activeParticles: this.particles.length,
            maxParticles: this.maxParticles,
            poolSize: this.pool.length,
            poolHits: this.poolHits,
            poolMisses: this.poolMisses,
            poolEfficiency: this.poolHits / Math.max(1, this.poolHits + this.poolMisses),
            spawnAccumulator: this.spawnAccumulator
        };
    }

    /**
     * Sets the maximum number of particles
     * @param {number} maxParticles - New maximum particle count
     */
    setMaxParticles(maxParticles) {
        this.originalMaxParticles = this.originalMaxParticles || this.maxParticles;
        this.maxParticles = Math.max(1, maxParticles);
        
        // Remove excess particles if new limit is lower
        while (this.particles.length > this.maxParticles) {
            this.removeParticle(0);
        }
    }
    
    /**
     * Cleans up dead particles and optimizes the pool
     */
    cleanupDeadParticles() {
        // Remove any dead particles that shouldn't be there
        const beforeCount = this.particles.length;
        this.particles = this.particles.filter(particle => particle.isAlive());
        const removed = beforeCount - this.particles.length;
        
        // Clear excess items from the pool to free memory
        if (this.pool.length > 20) {
            this.pool.length = 20;
        }
        
        return removed;
    }

    /**
     * Gets particles by behavior type for debugging
     * @param {string} behavior - Behavior type to filter by
     * @returns {Array} Particles with matching behavior
     */
    getParticlesByBehavior(behavior) {
        return this.particles.filter(particle => particle.behavior === behavior);
    }

    /**
     * Validates that all particles are in valid state
     * @returns {boolean} True if all particles are valid
     */
    validateParticles() {
        for (const particle of this.particles) {
            if (!particle.isAlive() || particle.life < 0 || particle.life > 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * Forces cleanup of dead particles (for testing)
     */
    cleanup() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            if (!this.particles[i].isAlive()) {
                this.removeParticle(i);
            }
        }
    }

    /**
     * Destroys the particle system and cleans up resources
     */
    destroy() {
        this.clear();
        this.pool.length = 0;
        this.poolHits = 0;
        this.poolMisses = 0;
        // ParticleSystem destroyed
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  UNDERTONE MODIFIERS  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Undertone Modifiers - Subtle Emotion Variations
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module UndertoneModifiers
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Undertones add NUANCE to emotions - like being "nervously happy" or              
 * ║ "confidently angry". These modifiers STACK on top of emotion modifiers            
 * ║ to create more complex, realistic emotional expressions.                          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 MULTIPLIER EFFECTS (Applied to Base Gesture)                                   
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • speed        : Animation speed (0.5=half speed, 2.0=double speed)               
 * │ • amplitude    : Movement size (0.5=smaller, 2.0=bigger)                          
 * │ • intensity    : Effect strength (0.5=subtle, 2.0=extreme)                        
 * │ • smoothness   : Animation smoothing (0.5=jerky, 1.5=very smooth)                 
 * │ • regularity   : Pattern consistency (0.5=chaotic, 1.0=regular)                   
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ SPECIAL EFFECTS (Boolean Flags)                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • addFlutter      : Butterfly-like motion (nervous)                               
 * │ • addMicroShake   : Tiny trembling (nervous, tired)                               
 * │ • addPower        : Strong, decisive motion (confident)                           
 * │ • addDrag         : Sluggish, heavy motion (tired)                                
 * │ • addTension      : Tight, controlled motion (intense)                            
 * │ • addSoftness     : Gentle, flowing motion (subdued)                              
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ DO NOT ADD HERE (Belongs in Other Files)                                       
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ Base gesture definitions   → use gestureConfig.js                              
 * │ ✗ Emotion modifiers         → use emotionModifiers.js                            
 * │ ✗ Visual properties         → use emotionMap.js                                  
 * │ ✗ Particle behaviors        → use Particle.js                                    
 * │ ✗ State logic              → use EmotiveStateMachine.js                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                           ADDING NEW UNDERTONES                                   
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ 1. Create new undertone object with all base multipliers (default to 1.0)         
 * ║ 2. Add special effect flags as needed (addXXX properties)                         
 * ║ 3. Test combinations with ALL emotions for unexpected interactions                
 * ║ 4. Document the intended "feel" and use cases                                     
 * ║ 5. Add to valid undertones in ErrorBoundary.js                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

const UNDERTONE_MODIFIERS = {
    // No undertone - neutral multipliers
    none: {
        speed: 1.0,
        amplitude: 1.0,
        intensity: 1.0,
        smoothness: 1.0,
        regularity: 1.0
    },
    
    nervous: {
        speed: 1.2,        // 20% faster
        amplitude: 0.9,    // 10% smaller (contained)
        intensity: 1.1,    // 10% more intense
        smoothness: 0.7,   // 30% less smooth (fluttery)
        regularity: 0.6,   // Irregular (butterflies)
        addFlutter: true,  // Butterfly-like flutter
        addMicroShake: true // Subtle tremor
    },
    
    confident: {
        speed: 0.9,        // 10% slower (deliberate)
        amplitude: 1.3,    // 30% bigger (bold)
        intensity: 1.2,    // 20% more intense
        smoothness: 1.1,   // 10% smoother (controlled)
        regularity: 1.2,   // Very regular (assured)
        addPower: true,    // Strong, decisive motion
        addHold: true      // Brief pause at peaks
    },
    
    tired: {
        speed: 0.7,        // 30% slower
        amplitude: 0.7,    // 30% smaller
        intensity: 0.8,    // 20% less intense
        smoothness: 1.3,   // 30% smoother (sluggish)
        regularity: 0.8,   // Slightly irregular (drowsy)
        addDroop: true,    // Downward tendency
        addPause: true     // Occasional hesitation
    },
    
    intense: {
        speed: 1.3,        // 30% faster
        amplitude: 1.2,    // 20% bigger
        intensity: 1.4,    // 40% more intense
        smoothness: 0.6,   // 40% less smooth (sharp)
        regularity: 0.9,   // Slightly irregular
        addPulse: true,    // Pulsing intensity
        addFocus: true     // Concentrated motion
    },
    
    subdued: {
        speed: 0.8,        // 20% slower
        amplitude: 0.8,    // 20% smaller
        intensity: 0.7,    // 30% less intense
        smoothness: 1.2,   // 20% smoother
        regularity: 1.1,   // Regular (restrained)
        addSoftness: true, // Gentle, muted motion
        addFade: true      // Fading at edges
    }
};

/**
 * Get undertone modifier
 * @param {string} undertone - Name of the undertone
 * @returns {Object} Modifier object with default values if undertone not found
 */
function getUndertoneModifier(undertone) {
    if (!undertone || undertone === '') {
        return UNDERTONE_MODIFIERS.none;
    }
    return UNDERTONE_MODIFIERS[undertone] || UNDERTONE_MODIFIERS.none;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                   ◐ ◑ ◒ ◓  GESTURE COMPOSITOR  ◓ ◒ ◑ ◐                   
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Gesture Compositor - Emotion-Modified Animation Synthesis
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module GestureCompositor
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The ANIMATOR'S MIXER. Takes base gestures (bounce, pulse, etc.) and blends        
 * ║ them with emotional modifiers and undertones to create nuanced animations.        
 * ║ A happy bounce is different from a sad bounce - this is where that happens!       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 COMPOSITION FORMULA                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ Final Animation = Base Gesture × Emotion Modifier × Undertone Modifier            
 * │                                                                                    
 * │ Example: Bounce + Joy + Confident                                                 
 * │   = Fast, big, springy bounce with extra confidence                               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔗 DEPENDENCIES                                                                    
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • gestures/index.js     : Modular gesture system with base configs                
 * │ • emotionModifiers.js   : How emotions affect movement                            
 * │ • undertoneModifiers.js : Subtle variations in expression                         
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class GestureCompositor {
    constructor() {
        // Cache for computed parameters
        this.cache = new Map();
        
        // Pre-calculate common easing curves for performance
        this.easingCache = new Map();
        this.preCalculateEasingCurves();
    }
    
    /**
     * Pre-calculate common easing curves to avoid repeated calculations
     */
    preCalculateEasingCurves() {
        const steps = 100;
        const easingTypes = ['linear', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'];
        
        for (const type of easingTypes) {
            const curve = new Float32Array(steps + 1);
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                curve[i] = this.calculateEasing(t, type);
            }
            this.easingCache.set(type, curve);
        }
    }
    
    /**
     * Calculate easing value
     */
    calculateEasing(t, type) {
        switch(type) {
            case 'ease-in':
                return t * t;
            case 'ease-out':
                return t * (2 - t);
            case 'ease-in-out':
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            case 'bounce':
                if (t < 0.363636) return 7.5625 * t * t;
                if (t < 0.727272) return 7.5625 * (t -= 0.545454) * t + 0.75;
                if (t < 0.909090) return 7.5625 * (t -= 0.818181) * t + 0.9375;
                return 7.5625 * (t -= 0.954545) * t + 0.984375;
            default:
                return t; // linear
        }
    }
    
    /**
     * Get easing value from cache
     */
    getEasingValue(progress, type) {
        const curve = this.easingCache.get(type);
        if (!curve) return progress; // Fallback to linear
        
        const index = Math.min(Math.floor(progress * 100), 100);
        return curve[index];
    }
    
    /**
     * Compose final gesture parameters
     * @param {string} gesture - Name of the gesture
     * @param {string} emotion - Current emotion state
     * @param {string} undertone - Current undertone (optional)
     * @returns {Object} Final composed parameters for the gesture
     */
    compose(gesture, emotion, undertone = null) {
        // Check cache first
        const cacheKey = `${gesture}-${emotion}-${undertone || 'none'}`;
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        
        // Get base configuration from modular gesture system
        const gestureModule = getGesture(gesture);
        const base = gestureModule ? gestureModule.config : {
            duration: 500,
            amplitude: 20,
            easing: 'sine'
        };
        const emotionMod = getEmotionModifiers(emotion);
        const undertoneMod = getUndertoneModifier(undertone);
        
        // Compose the final parameters
        const composed = this.applyModifiers(base, emotionMod, undertoneMod, gesture);
        
        // Cache the result with size limit
        if (this.cache.size > 100) {
            // Clear cache if it gets too large
            this.cache.clear();
        }
        this.cache.set(cacheKey, composed);
        
        return composed;
    }
    
    /**
     * Apply modifiers to base parameters
     * @param {Object} base - Base gesture configuration
     * @param {Object} emotionMod - Emotion modifiers
     * @param {Object} undertoneMod - Undertone modifiers
     * @param {string} gesture - Gesture name for special handling
     * @returns {Object} Modified parameters
     */
    applyModifiers(base, emotionMod, undertoneMod, gesture) {
        const result = { ...base };
        
        // Apply speed modifiers (affects duration inversely)
        const speedMultiplier = emotionMod.speed * undertoneMod.speed;
        result.duration = Math.round(base.duration / speedMultiplier);
        
        // Apply amplitude modifiers
        if (result.amplitude !== undefined) {
            result.amplitude = base.amplitude * emotionMod.amplitude * undertoneMod.amplitude;
        }
        
        // Apply scale modifiers
        if (result.scaleAmount !== undefined) {
            result.scaleAmount = base.scaleAmount * emotionMod.intensity * undertoneMod.intensity;
        }
        if (result.scaleTarget !== undefined) {
            const scaleModifier = emotionMod.amplitude * undertoneMod.amplitude;
            result.scaleTarget = 1 + (base.scaleTarget - 1) * scaleModifier;
        }
        
        // Apply glow modifiers
        if (result.glowAmount !== undefined) {
            result.glowAmount = base.glowAmount * emotionMod.intensity * undertoneMod.intensity;
        }
        if (result.glowPeak !== undefined) {
            result.glowPeak = 1 + (base.glowPeak - 1) * emotionMod.intensity * undertoneMod.intensity;
        }
        
        // Apply rotation modifiers
        if (result.rotations !== undefined) {
            result.rotations = base.rotations * emotionMod.amplitude * undertoneMod.amplitude;
        }
        if (result.angle !== undefined) {
            result.angle = base.angle * emotionMod.amplitude * undertoneMod.amplitude;
        }
        
        // Apply distance modifiers (for drift)
        if (result.distance !== undefined) {
            result.distance = base.distance * emotionMod.amplitude * undertoneMod.amplitude;
        }
        
        // Apply smoothness (affects easing)
        const smoothness = emotionMod.smoothness * undertoneMod.smoothness;
        result.smoothness = smoothness;
        result.easing = this.selectEasing(base.easing, smoothness);
        
        // Apply regularity (affects patterns)
        result.regularity = emotionMod.regularity * undertoneMod.regularity;
        
        // Add special effects based on emotion
        result.effects = [];
        if (emotionMod.addBounce) result.effects.push('bounce');
        if (emotionMod.addGravity) result.effects.push('gravity');
        if (emotionMod.addShake) result.effects.push('shake');
        if (emotionMod.addJitter) result.effects.push('shake');
        if (emotionMod.addPop) result.effects.push('pop');
        if (emotionMod.addRecoil) result.effects.push('recoil');
        if (emotionMod.addWarmth) result.effects.push('warmth');
        if (emotionMod.addFlow) result.effects.push('flow');
        if (emotionMod.addWobble) result.effects.push('wobble');
        if (emotionMod.addVibration) result.effects.push('vibration');
        if (emotionMod.addDrag) result.effects.push('drag');
        if (emotionMod.addWeight) result.effects.push('weight');
        if (emotionMod.addTension) result.effects.push('tension');
        if (emotionMod.addPrecision) result.effects.push('precision');
        
        // Add undertone effects
        if (undertoneMod.addFlutter) result.effects.push('flutter');
        if (undertoneMod.addMicroShake) result.effects.push('microShake');
        if (undertoneMod.addPower) result.effects.push('power');
        if (undertoneMod.addHold) result.effects.push('hold');
        if (undertoneMod.addDroop) result.effects.push('droop');
        if (undertoneMod.addPause) result.effects.push('pause');
        if (undertoneMod.addPulse) result.effects.push('pulse');
        if (undertoneMod.addFocus) result.effects.push('focus');
        if (undertoneMod.addSoftness) result.effects.push('softness');
        if (undertoneMod.addFade) result.effects.push('fade');
        
        // Apply gesture-specific modifications
        this.applyGestureSpecificMods(result, gesture, emotionMod, undertoneMod);
        
        // Include particleMotion if it exists in base config
        if (base.particleMotion) {
            result.particleMotion = { ...base.particleMotion };
            
            // Apply modifiers to particle motion strength
            if (result.particleMotion.strength !== undefined) {
                result.particleMotion.strength *= emotionMod.intensity * undertoneMod.intensity;
            }
            
            // Apply speed modifiers to particle motion frequency
            if (result.particleMotion.frequency !== undefined) {
                result.particleMotion.frequency *= speedMultiplier;
            }
            
            // Apply amplitude modifiers to particle motion amplitude
            if (result.particleMotion.amplitude !== undefined) {
                result.particleMotion.amplitude *= emotionMod.amplitude * undertoneMod.amplitude;
            }
        }
        
        return result;
    }
    
    /**
     * Select easing function based on smoothness
     * @param {string} baseEasing - Base easing type
     * @param {number} smoothness - Smoothness multiplier
     * @returns {string} Selected easing function
     */
    selectEasing(baseEasing, smoothness) {
        if (smoothness < 0.5) {
            return 'linear'; // Very sharp
        } else if (smoothness < 0.8) {
            return 'quad'; // Somewhat sharp
        } else if (smoothness < 1.2) {
            return baseEasing; // Normal
        } else if (smoothness < 1.5) {
            return 'cubic'; // Smooth
        } else {
            return 'sine'; // Very smooth
        }
    }
    
    /**
     * Apply gesture-specific modifications
     * @param {Object} result - Current parameters
     * @param {string} gesture - Gesture name
     * @param {Object} emotionMod - Emotion modifiers
     * @param {Object} undertoneMod - Undertone modifiers
     */
    applyGestureSpecificMods(result, gesture, emotionMod, undertoneMod) {
        switch(gesture) {
            case 'bounce':
                // Angry bounce is more violent
                if (emotionMod.addShake) {
                    result.frequency = Math.floor(result.frequency * 1.5);
                }
                // Sad bounce barely leaves ground
                if (emotionMod.addGravity) {
                    result.amplitude *= 0.6;
                    result.frequency = 1;
                }
                break;
                
            case 'pulse':
                // Love pulse is like a heartbeat
                if (emotionMod.addWarmth) {
                    result.frequency = 2; // Double beat
                    result.glowAmount *= 1.5;
                }
                // Nervous pulse is irregular
                if (undertoneMod.addFlutter) {
                    result.irregular = true;
                }
                break;
                
            case 'shake':
                // Fear shake is more intense
                if (emotionMod.addJitter) {
                    result.frequency *= 1.5;
                    result.amplitude *= 1.2;
                }
                // Anger shake is violent
                if (emotionMod.addShake) {
                    result.amplitude *= 1.5;
                    result.decay = false; // Sustained shaking
                }
                break;
                
            case 'spin':
                // Joy spin has extra rotations
                if (emotionMod.addBounce) {
                    result.rotations *= 1.5;
                }
                // Confused spin reverses direction
                if (emotionMod.addWobble) {
                    result.wobble = true;
                }
                break;
                
            // Add more gesture-specific modifications as needed
        }
    }
    
    /**
     * Clear the cache (useful when configs change)
     */
    clearCache() {
        this.cache.clear();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Zen Vortex Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Zen meditation vortex visual effect
 * @author Emotive Engine Team
 * @module effects/zen-vortex
 */

var zenVortex = {
    name: 'zen-vortex',
    emoji: '🌀',
    description: 'Swirling meditation vortex effect',
    
    // Configuration
    config: {
        vortexSpeed: 0.02,
        spiralTightness: 0.15,
        maxRadius: 1.5,
        lineWidth: 2,
        segments: 50,
        arms: 3,
        fadeStart: 0.7,
        baseOpacity: 0.3,
        pulseSpeed: 0.01
    },
    
    // State for animation
    state: {
        rotation: 0,
        pulsePhase: 0,
        intensity: 0
    },
    
    /**
     * Check if effect should be active
     * @param {Object} state - Renderer state
     * @returns {boolean}
     */
    shouldActivate: function(state) {
        return state.emotion === 'zen' || state.zenTransition?.active;
    },
    
    /**
     * Apply the zen vortex effect
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Object} params - Effect parameters
     */
    apply: function(ctx, params) {
        const { x, y, radius, intensity = 1.0, deltaTime = 16.67 } = params;
        
        // Update animation state
        this.state.rotation += this.config.vortexSpeed * (deltaTime / 16.67);
        this.state.pulsePhase += this.config.pulseSpeed * (deltaTime / 16.67);
        this.state.intensity = intensity;
        
        ctx.save();
        
        // Draw multiple spiral arms
        for (let arm = 0; arm < this.config.arms; arm++) {
            const armOffset = (Math.PI * 2 / this.config.arms) * arm;
            this.drawSpiralArm(ctx, x, y, radius, armOffset);
        }
        
        // Draw meditation circle (∩∩ shape)
        this.drawMeditationEyes(ctx, x, y, radius * 0.6, intensity);
        
        ctx.restore();
    },
    
    /**
     * Draw a single spiral arm
     */
    drawSpiralArm: function(ctx, centerX, centerY, baseRadius, offset) {
        ctx.beginPath();
        
        const pulseMod = 1 + Math.sin(this.state.pulsePhase) * 0.1;
        
        for (let i = 0; i <= this.config.segments; i++) {
            const t = i / this.config.segments;
            const angle = this.state.rotation + offset + t * Math.PI * 4;
            const spiralRadius = t * baseRadius * this.config.maxRadius * pulseMod;
            
            // Spiral equation
            const x = centerX + Math.cos(angle) * spiralRadius;
            const y = centerY + Math.sin(angle) * spiralRadius;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        // Create gradient for fade effect
        const gradient = ctx.createLinearGradient(
            centerX - baseRadius, centerY,
            centerX + baseRadius, centerY
        );
        
        const opacity = this.config.baseOpacity * this.state.intensity;
        gradient.addColorStop(0, `rgba(147, 112, 219, 0)`);
        gradient.addColorStop(0.3, `rgba(147, 112, 219, ${opacity * 0.5})`);
        gradient.addColorStop(this.config.fadeStart, `rgba(147, 112, 219, ${opacity})`);
        gradient.addColorStop(1, `rgba(147, 112, 219, 0)`);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = this.config.lineWidth;
        ctx.stroke();
    },
    
    /**
     * Draw meditation eyes (∩∩)
     */
    drawMeditationEyes: function(ctx, x, y, radius, intensity) {
        ctx.save();
        
        const eyeWidth = radius * 0.4;
        const eyeSpacing = radius * 0.3;
        
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * intensity})`;
        ctx.lineWidth = 2;
        
        // Left eye (∩)
        ctx.beginPath();
        ctx.arc(x - eyeSpacing, y, eyeWidth, Math.PI, 0, true);
        ctx.stroke();
        
        // Right eye (∩)
        ctx.beginPath();
        ctx.arc(x + eyeSpacing, y, eyeWidth, Math.PI, 0, true);
        ctx.stroke();
        
        ctx.restore();
    },
    
    /**
     * Reset the effect state
     */
    reset: function() {
        this.state.rotation = 0;
        this.state.pulsePhase = 0;
        this.state.intensity = 0;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Recording Glow Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Pulsating red glow for recording state
 * @author Emotive Engine Team
 * @module effects/recording-glow
 */

var recordingGlow = {
    name: 'recording-glow',
    emoji: '🔴',
    description: 'Pulsating red recording indicator',
    
    // Configuration
    config: {
        color: '#FF0000',
        pulseSpeed: 0.08,
        minIntensity: 0.6,
        maxIntensity: 1.0,
        radiusMultiplier: 2.0,
        gradientStops: [
            { position: 0, opacity: 1.0 },
            { position: 0.3, opacity: 0.7 },
            { position: 0.6, opacity: 0.4 },
            { position: 0.85, opacity: 0.2 },
            { position: 1, opacity: 0 }
        ]
    },
    
    // State for animation
    state: {
        pulsePhase: 0,
        intensity: 0.8  // Start with visible intensity
    },
    
    /**
     * Check if effect should be active
     * @param {Object} state - Renderer state
     * @returns {boolean}
     */
    shouldActivate: function(state) {
        return state.recording === true;
    },
    
    /**
     * Apply the recording glow effect
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Object} params - Effect parameters
     */
    apply: function(ctx, params) {
        const { deltaTime = 16.67 } = params;
        
        // Update pulse animation for the indicator only
        this.state.pulsePhase += this.config.pulseSpeed * (deltaTime / 16.67);
        
        // Calculate pulsating intensity
        const pulse = (Math.sin(this.state.pulsePhase) + 1) / 2;
        this.state.intensity = this.config.minIntensity + 
            (this.config.maxIntensity - this.config.minIntensity) * pulse;
        
        // Don't draw any glow on the mascot - only update the animation state
        // The REC indicator will be drawn separately in drawRecordingIndicator
        return true; // Return true to indicate effect was applied
    },
    
    /**
     * Draw recording indicator text only
     */
    drawRecordingIndicator: function(ctx, canvasWidth, canvasHeight) {
        ctx.save();
        
        // Dynamic text size
        const baseSize = Math.min(canvasWidth, canvasHeight);
        const textSize = Math.floor(baseSize * 0.08);  // 8% of smallest dimension (bigger)
        
        // Position in upper-left corner with padding
        const x = textSize * 1.5;
        const y = textSize * 1.5;
        
        // Draw red recording dot
        const dotRadius = textSize * 0.3;
        ctx.fillStyle = this.hexToRgba('#FF0000', this.state.intensity);
        ctx.beginPath();
        ctx.arc(x - textSize, y, dotRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add white outline for visibility
        ctx.strokeStyle = this.hexToRgba('#FFFFFF', this.state.intensity * 0.8);
        ctx.lineWidth = 3;
        ctx.font = `bold ${textSize}px 'Arial', sans-serif`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.strokeText('REC', x, y);
        
        // Draw "REC" text on top
        ctx.fillStyle = this.hexToRgba('#FF0000', this.state.intensity);
        ctx.fillText('REC', x, y);
        
        ctx.restore();
    },
    
    /**
     * Convert hex to rgba
     */
    hexToRgba: function(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    },
    
    /**
     * Reset the effect state
     */
    reset: function() {
        this.state.pulsePhase = 0;
        this.state.intensity = 0;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Speaking Pulse Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var speakingPulse = {
    name: 'speaking-pulse',
    emoji: '🗣️',
    description: 'Audio-reactive pulse when speaking',
    
    config: {
        scaleMultiplier: 0.15,  // Max scale increase when speaking
        smoothing: 0.1,         // Smoothing factor for audio levels
        minPulse: 0.02,         // Minimum pulse even when quiet
        colorShift: true,       // Shift glow color when speaking
        ringEffect: true        // Show expanding rings
    },
    
    state: {
        audioLevel: 0,
        smoothedLevel: 0,
        rings: []  // Array of expanding rings
    },
    
    shouldActivate: function(state) {
        return state.speaking === true;
    },
    
    apply: function(ctx, params) {
        const { x, y, radius, audioLevel = 0, deltaTime = 16.67 } = params;
        
        // Smooth audio level
        this.state.smoothedLevel += (audioLevel - this.state.smoothedLevel) * this.config.smoothing;
        
        // Create expanding rings on audio peaks
        if (audioLevel > 0.5 && this.state.audioLevel <= 0.5) {
            this.state.rings.push({
                radius: radius,
                opacity: 0.5,
                speed: 2
            });
        }
        
        // Update and draw rings
        if (this.config.ringEffect) {
            this.drawRings(ctx, x, y, deltaTime);
        }
        
        // Store for next frame
        this.state.audioLevel = audioLevel;
    },
    
    drawRings: function(ctx, x, y, deltaTime) {
        ctx.save();
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
        ctx.lineWidth = 2;
        
        // Update and draw each ring
        for (let i = this.state.rings.length - 1; i >= 0; i--) {
            const ring = this.state.rings[i];
            
            // Update ring
            ring.radius += ring.speed * (deltaTime / 16.67);
            ring.opacity -= 0.02 * (deltaTime / 16.67);
            
            // Remove if faded
            if (ring.opacity <= 0) {
                this.state.rings.splice(i, 1);
                continue;
            }
            
            // Draw ring
            ctx.globalAlpha = ring.opacity;
            ctx.beginPath();
            ctx.arc(x, y, ring.radius, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    },
    
    getScaleModifier: function() {
        return 1 + (this.state.smoothedLevel * this.config.scaleMultiplier);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sleeping Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var sleepingEffect = {
    name: 'sleeping',
    emoji: '😴',
    description: 'Sleeping with closed eyes and Z particles',
    
    config: {
        eyeClosedScale: 0.1,    // How closed the eyes are (0.1 = 90% closed)
        breathingDepth: 0.15,    // Deeper breathing when sleeping
        breathingRate: 0.8,      // Slower breathing
        zParticleInterval: 2000, // Spawn Z every 2 seconds
        zDriftSpeed: 1,          // Speed of Z particles floating up
        zFadeSpeed: 0.01,        // How fast Z's fade out
        orbDimming: 0.3,         // Dim orb to 30% brightness when sleeping
        glowDimming: 0.2         // Dim glow even more (20% brightness)
    },
    
    state: {
        lastZSpawn: 0,
        zParticles: []
    },
    
    shouldActivate: function(state) {
        return state.sleeping === true || state.emotion === 'resting';
    },
    
    apply: function(ctx, params) {
        const { x, y, radius, deltaTime = 16.67 } = params;
        const now = Date.now();
        
        // Spawn new Z particle
        if (now - this.state.lastZSpawn > this.config.zParticleInterval) {
            // Random Poppins font weights: 100-900
            const weights = [100, 200, 300, 400, 500, 600, 700, 800, 900];
            const randomWeight = weights[Math.floor(Math.random() * weights.length)];
            
            this.state.zParticles.push({
                x: x + radius,
                y: y - radius,
                opacity: 1.0,
                size: 12 + Math.random() * 8, // Random size 12-20px
                drift: Math.random() * 0.5 - 0.25, // Slight random drift
                weight: randomWeight, // Random font weight
                rotation: Math.random() * 30 - 15 // Random rotation -15 to 15 degrees
            });
            this.state.lastZSpawn = now;
        }
        
        // Update and draw Z particles
        this.drawZParticles(ctx, deltaTime);
    },
    
    drawZParticles: function(ctx, deltaTime) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (let i = this.state.zParticles.length - 1; i >= 0; i--) {
            const z = this.state.zParticles[i];
            
            // Update position
            z.y -= this.config.zDriftSpeed * (deltaTime / 16.67);
            z.x += z.drift * (deltaTime / 16.67);
            z.opacity -= this.config.zFadeSpeed * (deltaTime / 16.67);
            z.rotation += 0.5 * (deltaTime / 16.67); // Slow rotation
            
            // Remove if faded
            if (z.opacity <= 0) {
                this.state.zParticles.splice(i, 1);
                continue;
            }
            
            // Draw Z with random Poppins weight
            ctx.save();
            ctx.translate(z.x, z.y);
            ctx.rotate(z.rotation * Math.PI / 180);
            ctx.globalAlpha = z.opacity * 0.7; // Slightly transparent
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = `${z.weight} ${z.size}px 'Poppins', sans-serif`;
            ctx.fillText('Z', 0, 0);
            
            // Add a subtle shadow for depth
            ctx.shadowBlur = 3;
            ctx.shadowColor = 'rgba(147, 112, 219, 0.5)'; // Purple shadow for dreamy effect
            ctx.fillText('Z', 0, 0);
            ctx.restore();
        }
        
        ctx.restore();
    },
    
    getEyeOpenness: function() {
        return this.config.eyeClosedScale;
    },
    
    getBreathingModifiers: function() {
        return {
            rate: this.config.breathingRate,
            depth: this.config.breathingDepth
        };
    },
    
    getDimmingValues: function() {
        return {
            orbDimming: this.config.orbDimming,
            glowDimming: this.config.glowDimming
        };
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Suspicion Scan Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var suspicionScan = {
    name: 'suspicion-scan',
    emoji: '🔍',
    description: 'Suspicious scanning and squinting',
    
    config: {
        squintAmount: 0.4,      // 40% eye narrowing
        scanInterval: 5000,     // Scan every 5 seconds
        scanDuration: 800,      // Each scan takes 800ms
        scanAngle: 45,          // Degrees to look left/right
        squintSpeed: 0.02,      // Animation speed for squinting
        pupilShift: 0.3         // How much the pupil shifts when scanning
    },
    
    state: {
        currentSquint: 0,
        targetSquint: 0,
        lastScanTime: 0,
        scanPhase: 0,  // 0 = center, -1 = left, 1 = right
        scanning: false
    },
    
    shouldActivate: function(state) {
        return state.emotion === 'suspicion' || state.suspicious === true;
    },
    
    apply: function(ctx, params) {
        const { deltaTime = 16.67 } = params;
        const now = Date.now();
        
        // Update squint amount
        this.updateSquint(deltaTime);
        
        // Handle scanning motion
        if (now - this.state.lastScanTime > this.config.scanInterval) {
            this.startScan();
            this.state.lastScanTime = now;
        }
        
        if (this.state.scanning) {
            this.updateScan(now, deltaTime);
        }
    },
    
    updateSquint: function(deltaTime) {
        // Set target squint when suspicious
        this.state.targetSquint = this.config.squintAmount;
        
        // Animate toward target
        const diff = this.state.targetSquint - this.state.currentSquint;
        if (Math.abs(diff) > 0.01) {
            this.state.currentSquint += diff * this.config.squintSpeed * (deltaTime / 16.67);
        } else {
            this.state.currentSquint = this.state.targetSquint;
        }
    },
    
    startScan: function() {
        this.state.scanning = true;
        this.state.scanStartTime = Date.now();
        this.state.scanPhase = -1; // Start by looking left
    },
    
    updateScan: function(now, deltaTime) {
        const elapsed = now - this.state.scanStartTime;
        const progress = elapsed / this.config.scanDuration;
        
        if (progress < 0.33) {
            // Look left
            this.state.scanPhase = -1;
        } else if (progress < 0.66) {
            // Look right
            this.state.scanPhase = 1;
        } else if (progress < 1) {
            // Return to center
            this.state.scanPhase = 0;
        } else {
            // Scan complete
            this.state.scanning = false;
            this.state.scanPhase = 0;
        }
    },
    
    getEyeModifiers: function() {
        return {
            scaleY: 1 - this.state.currentSquint,  // Narrow vertically
            scaleX: 1 + this.state.currentSquint * 0.3,  // Widen horizontally slightly
            offsetX: this.state.scanPhase * this.config.pupilShift
        };
    },
    
    drawScanLines: function(ctx, x, y, radius) {
        if (!this.state.scanning) return;
        
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 165, 0, 0.3)'; // Orange scan lines
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        
        // Draw scanning beam
        const angle = this.state.scanPhase * (this.config.scanAngle * Math.PI / 180);
        const endX = x + Math.cos(angle) * radius * 2;
        const endY = y + Math.sin(angle) * radius * 0.5;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        ctx.restore();
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Gaze Narrowing Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var gazeNarrowing = {
    name: 'gaze-narrowing',
    emoji: '👁️',
    description: 'Eye narrowing based on gaze proximity',
    
    config: {
        maxHorizontalScale: 1.3,  // Max horizontal widening (30%)
        maxVerticalScale: 0.5,    // Max vertical narrowing (50%)
        smoothing: 0.1,           // Smoothing factor for transitions
        focusThreshold: 0.3       // Intensity threshold to start narrowing
    },
    
    state: {
        currentScaleX: 1,
        currentScaleY: 1,
        targetScaleX: 1,
        targetScaleY: 1
    },
    
    shouldActivate: function(state) {
        return state.gazeIntensity > 0 || state.gazeLocked;
    },
    
    apply: function(ctx, params) {
        const { gazeIntensity = 0, deltaTime = 16.67 } = params;
        
        // Calculate target scales based on gaze intensity
        if (gazeIntensity > this.config.focusThreshold) {
            const narrowFactor = (gazeIntensity - this.config.focusThreshold) / 
                                (1 - this.config.focusThreshold);
            
            this.state.targetScaleX = 1 + (this.config.maxHorizontalScale - 1) * narrowFactor;
            this.state.targetScaleY = 1 - (1 - this.config.maxVerticalScale) * narrowFactor;
        } else {
            this.state.targetScaleX = 1;
            this.state.targetScaleY = 1;
        }
        
        // Smooth transitions
        this.animateScales(deltaTime);
    },
    
    animateScales: function(deltaTime) {
        const speed = this.config.smoothing * (deltaTime / 16.67);
        
        // Animate X scale
        const diffX = this.state.targetScaleX - this.state.currentScaleX;
        if (Math.abs(diffX) > 0.001) {
            this.state.currentScaleX += diffX * speed;
        }
        
        // Animate Y scale
        const diffY = this.state.targetScaleY - this.state.currentScaleY;
        if (Math.abs(diffY) > 0.001) {
            this.state.currentScaleY += diffY * speed;
        }
    },
    
    getEyeScales: function() {
        return {
            scaleX: this.state.currentScaleX,
            scaleY: this.state.currentScaleY
        };
    },
    
    drawFocusIndicator: function(ctx, x, y, radius, intensity) {
        if (intensity < this.config.focusThreshold) return;
        
        ctx.save();
        
        // Draw focus lines converging on target
        const alpha = (intensity - this.config.focusThreshold) * 0.5;
        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        
        // Draw converging lines
        const angles = [0, 60, 120, 180, 240, 300];
        for (const angle of angles) {
            const rad = angle * Math.PI / 180;
            const startDist = radius * 2;
            const endDist = radius * 1.2;
            
            ctx.beginPath();
            ctx.moveTo(
                x + Math.cos(rad) * startDist,
                y + Math.sin(rad) * startDist
            );
            ctx.lineTo(
                x + Math.cos(rad) * endDist,
                y + Math.sin(rad) * endDist
            );
            ctx.stroke();
        }
        
        ctx.restore();
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fingerprint Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Biometric fingerprint pattern effect
 * @author Emotive Engine Team
 * @module effects/fingerprint
 * 
 * Created from a happy accident in the resting state that produced
 * concentric circles resembling a fingerprint pattern!
 */

var fingerprint = {
    name: 'fingerprint',
    emoji: '👆',
    description: 'Biometric fingerprint pattern for authentication UI',
    
    // Configuration
    config: {
        rings: 8,                  // Number of concentric rings
        ringSpacing: 15,           // Pixels between rings
        lineWidth: 1.5,           // Width of fingerprint lines
        rotationSpeed: 0.001,     // Slow rotation for scanning effect
        pulseSpeed: 0.02,         // Breathing/pulse speed
        waveAmplitude: 3,         // Waviness of lines (realistic fingerprint)
        waveFrequency: 8,         // How many waves per ring
        breakPoints: 5,           // Random breaks in lines (like real fingerprints)
        opacity: 0.4,             // Base opacity
        scanLineSpeed: 0.01,      // Speed of scanning line
        scanLineWidth: 3,         // Width of scanning beam
        color: '#00CED1',         // Cyan for tech/biometric feel
        glowColor: '#00FFFF',     // Bright cyan for scan
        successColor: '#00FF00',  // Green for successful scan
        failColor: '#FF0000'      // Red for failed scan
    },
    
    // State for animation
    state: {
        rotation: 0,
        pulsePhase: 0,
        scanPosition: 0,
        scanDirection: 1,
        isScanning: false,
        scanResult: null,  // 'success', 'fail', or null
        breaks: [],        // Random break positions in rings
        whorls: []         // Whorl patterns for realism
    },
    
    /**
     * Check if effect should be active
     * @param {Object} state - Renderer state
     * @returns {boolean}
     */
    shouldActivate: function(state) {
        return state.biometric === true || state.fingerprint === true || state.authenticating === true;
    },
    
    /**
     * Initialize fingerprint pattern
     */
    initialize: function() {
        // Generate random breaks for each ring
        this.state.breaks = [];
        for (let i = 0; i < this.config.rings; i++) {
            const ringBreaks = [];
            for (let j = 0; j < this.config.breakPoints; j++) {
                ringBreaks.push(Math.random() * Math.PI * 2);
            }
            this.state.breaks.push(ringBreaks);
        }
        
        // Generate whorl centers for realistic pattern
        this.state.whorls = [
            { x: 0.2, y: -0.1, strength: 0.3 },
            { x: -0.15, y: 0.2, strength: 0.25 },
            { x: 0, y: 0, strength: 0.5 }  // Central whorl
        ];
    },
    
    /**
     * Apply the fingerprint effect
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Object} params - Effect parameters
     */
    apply: function(ctx, params) {
        const { x, y, radius, deltaTime = 16.67, scanning = false, authResult = null } = params;
        
        // Initialize on first run
        if (this.state.breaks.length === 0) {
            this.initialize();
        }
        
        // Update animation state
        this.state.rotation += this.config.rotationSpeed * (deltaTime / 16.67);
        this.state.pulsePhase += this.config.pulseSpeed * (deltaTime / 16.67);
        
        // Update scan position
        if (scanning || this.state.isScanning) {
            this.state.isScanning = true;
            this.state.scanPosition += this.config.scanLineSpeed * this.state.scanDirection * (deltaTime / 16.67);
            
            // Reverse at bounds
            if (this.state.scanPosition > 1) {
                this.state.scanPosition = 1;
                this.state.scanDirection = -1;
            } else if (this.state.scanPosition < -1) {
                this.state.scanPosition = -1;
                this.state.scanDirection = 1;
            }
        }
        
        ctx.save();
        
        // Draw fingerprint rings
        this.drawFingerprintPattern(ctx, x, y, radius);
        
        // Draw scanning line if active
        if (this.state.isScanning) {
            this.drawScanLine(ctx, x, y, radius);
        }
        
        // Show auth result
        if (authResult) {
            this.showAuthResult(ctx, x, y, radius, authResult);
        }
        
        ctx.restore();
    },
    
    /**
     * Draw the fingerprint pattern
     */
    drawFingerprintPattern: function(ctx, centerX, centerY, baseRadius) {
        const pulse = Math.sin(this.state.pulsePhase) * 0.1 + 1;
        
        for (let ring = 0; ring < this.config.rings; ring++) {
            const ringRadius = (ring + 1) * this.config.ringSpacing * pulse;
            
            // Skip if ring is outside visible area
            if (ringRadius > baseRadius * 2) continue;
            
            ctx.beginPath();
            ctx.strokeStyle = this.config.color;
            ctx.lineWidth = this.config.lineWidth;
            ctx.globalAlpha = this.config.opacity * (1 - ring / this.config.rings * 0.5);
            
            // Draw ring with breaks and distortions
            for (let angle = 0; angle < Math.PI * 2; angle += 0.05) {
                // Check for breaks
                let shouldBreak = false;
                for (const breakAngle of this.state.breaks[ring] || []) {
                    if (Math.abs(angle - breakAngle) < 0.1) {
                        shouldBreak = true;
                        break;
                    }
                }
                
                if (shouldBreak) {
                    ctx.stroke();
                    ctx.beginPath();
                    continue;
                }
                
                // Apply whorl distortions
                let distortedRadius = ringRadius;
                let distortedAngle = angle + this.state.rotation;
                
                for (const whorl of this.state.whorls) {
                    const whorldX = centerX + whorl.x * baseRadius;
                    const whorldY = centerY + whorl.y * baseRadius;
                    const pointX = centerX + Math.cos(distortedAngle) * distortedRadius;
                    const pointY = centerY + Math.sin(distortedAngle) * distortedRadius;
                    
                    const distance = Math.sqrt(
                        Math.pow(pointX - whorldX, 2) + 
                        Math.pow(pointY - whorldY, 2)
                    );
                    
                    const influence = Math.exp(-distance / (baseRadius * 0.5)) * whorl.strength;
                    distortedAngle += influence * 0.5;
                }
                
                // Add wave pattern
                const wave = Math.sin(angle * this.config.waveFrequency) * this.config.waveAmplitude;
                distortedRadius += wave;
                
                // Draw point
                const px = centerX + Math.cos(distortedAngle) * distortedRadius;
                const py = centerY + Math.sin(distortedAngle) * distortedRadius;
                
                if (angle === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            
            ctx.stroke();
        }
    },
    
    /**
     * Draw scanning line
     */
    drawScanLine: function(ctx, x, y, radius) {
        const scanY = y + this.state.scanPosition * radius;
        
        // Create gradient for scan line
        const gradient = ctx.createLinearGradient(x - radius, scanY, x + radius, scanY);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0)');
        gradient.addColorStop(0.5, this.config.glowColor);
        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = this.config.scanLineWidth;
        ctx.globalAlpha = 0.8;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.config.glowColor;
        
        ctx.beginPath();
        ctx.moveTo(x - radius, scanY);
        ctx.lineTo(x + radius, scanY);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
    },
    
    /**
     * Show authentication result
     */
    showAuthResult: function(ctx, x, y, radius, result) {
        const color = result === 'success' ? this.config.successColor : this.config.failColor;
        const text = result === 'success' ? '✓ AUTHENTICATED' : '✗ ACCESS DENIED';
        
        ctx.fillStyle = color;
        ctx.font = `bold ${radius * 0.15}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.9;
        
        ctx.fillText(text, x, y + radius * 1.3);
        
        // Draw result ring
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.1, 0, Math.PI * 2);
        ctx.stroke();
    },
    
    /**
     * Start authentication scan
     */
    startScan: function() {
        this.state.isScanning = true;
        this.state.scanPosition = -1;
        this.state.scanDirection = 1;
        this.state.scanResult = null;
    },
    
    /**
     * Complete authentication scan
     */
    completeScan: function(success = true) {
        this.state.isScanning = false;
        this.state.scanResult = success ? 'success' : 'fail';
        
        // Clear result after 2 seconds
        setTimeout(() => {
            this.state.scanResult = null;
        }, 2000);
    },
    
    /**
     * Reset the effect state
     */
    reset: function() {
        this.state.rotation = 0;
        this.state.pulsePhase = 0;
        this.state.scanPosition = 0;
        this.state.scanDirection = 1;
        this.state.isScanning = false;
        this.state.scanResult = null;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Visual Effects Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central registry for visual effects like zen vortex, recording glow, etc.
 * @author Emotive Engine Team
 * @module effects
 */


// Registry to store all visual effects
const effectRegistry = new Map();

/**
 * Register a visual effect module
 * @param {Object} effectModule - The effect module to register
 */
function registerEffect(effectModule) {
    if (!effectModule.name) {
        return;
    }
    effectRegistry.set(effectModule.name, effectModule);
}

/**
 * Get effect by name
 * @param {string} effectName - Name of the effect
 * @returns {Object|null} The effect module or null
 */
function getEffect(effectName) {
    return effectRegistry.get(effectName) || null;
}

/**
 * Apply a visual effect
 * @param {string} effectName - Name of the effect to apply
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} params - Effect parameters
 * @returns {boolean} True if effect was applied
 */
function applyEffect(effectName, ctx, params) {
    const effect = getEffect(effectName);
    if (!effect) {
        return false;
    }
    
    if (effect.apply) {
        effect.apply(ctx, params);
        return true;
    }
    
    return false;
}

/**
 * Check if effect should be active
 * @param {string} effectName - Name of the effect
 * @param {Object} state - Current state
 * @returns {boolean} True if effect should be active
 */
function isEffectActive(effectName, state) {
    const effect = getEffect(effectName);
    if (!effect || !effect.shouldActivate) {
        return false;
    }
    return effect.shouldActivate(state);
}

// Register all built-in effects
registerEffect(zenVortex);
registerEffect(recordingGlow);
registerEffect(speakingPulse);
registerEffect(sleepingEffect);
registerEffect(suspicionScan);
registerEffect(gazeNarrowing);
registerEffect(fingerprint);

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Musical Duration System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Musical time calculation for tempo-aware gesture durations
 * @author Emotive Engine Team
 * @module core/MusicalDuration
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Converts between musical time (beats/bars) and clock time (milliseconds).        
 * ║ Ensures all gesture durations are perfect subdivisions of the beat, making        
 * ║ animations musically coherent at any tempo.                                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class MusicalDuration {
    constructor() {
        // Standard note durations in beats (4/4 time)
        this.noteDurations = {
            'whole': 4,
            'half': 2,
            'quarter': 1,
            'eighth': 0.5,
            'sixteenth': 0.25,
            'triplet': 0.333,
            'dotted-quarter': 1.5,
            'dotted-half': 3
        };
        
        // Cache for performance
        this.cache = new Map();
        this.lastBPM = 0;
        
        // Pre-warm cache with common BPMs and durations
        this.prewarmCache();
    }
    
    /**
     * Pre-calculate common durations to prevent first-run lag
     */
    prewarmCache() {
        const commonBPMs = [60, 90, 120, 140, 160, 180];
        const commonDurations = [
            { musical: true, beats: 1 },      // 1 beat
            { musical: true, bars: 1 },       // 1 bar
            { musical: true, beats: 0.5 },    // Half beat
            { musical: true, beats: 2 }       // 2 beats
        ];
        
        commonBPMs.forEach(bpm => {
            commonDurations.forEach(duration => {
                const key = `${bpm}_${JSON.stringify(duration)}`;
                const ms = this.toMilliseconds(duration, bpm);
                this.cache.set(key, ms);
            });
        });
    }
    
    /**
     * Convert musical duration to milliseconds
     * @param {Object} duration - Musical duration config
     * @param {number} [bpm] - Optional BPM override
     * @returns {number} Duration in milliseconds
     */
    toMilliseconds(duration, bpm = null) {
        const currentBPM = bpm || rhythmEngine.bpm || 120;
        
        // Handle different duration formats
        if (typeof duration === 'number') {
            // Already in milliseconds
            return duration;
        }
        
        if (typeof duration === 'object' && duration.musical) {
            const beatDuration = 60000 / currentBPM;
            
            if (duration.beats !== undefined) {
                // Specified in beats
                return duration.beats * beatDuration;
            } else if (duration.bars !== undefined) {
                // Specified in bars (assume 4/4)
                const timeSignature = rhythmEngine.timeSignature || [4, 4];
                return duration.bars * timeSignature[0] * beatDuration;
            } else if (duration.subdivision !== undefined) {
                // Specified as note value
                const beats = this.noteDurations[duration.subdivision] || 1;
                return beats * beatDuration;
            }
        }
        
        // Default fallback
        return 1000;
    }
    
    /**
     * Convert milliseconds to musical duration
     * @param {number} ms - Duration in milliseconds
     * @param {number} [bpm] - Optional BPM override
     * @returns {Object} Musical duration
     */
    toMusical(ms, bpm = null) {
        const currentBPM = bpm || rhythmEngine.bpm || 120;
        const beatDuration = 60000 / currentBPM;
        const beats = ms / beatDuration;
        
        // Find closest standard duration
        let closestNote = 'quarter';
        let closestDiff = Math.abs(beats - 1);
        
        for (const [note, duration] of Object.entries(this.noteDurations)) {
            const diff = Math.abs(beats - duration);
            if (diff < closestDiff) {
                closestDiff = diff;
                closestNote = note;
            }
        }
        
        return {
            musical: true,
            beats: beats,
            bars: beats / 4,
            closestSubdivision: closestNote,
            exact: closestDiff < 0.01
        };
    }
    
    /**
     * Calculate gesture phases with musical timing
     * @param {Array} phases - Array of phase configurations
     * @param {number} totalBeats - Total duration in beats
     * @returns {Array} Phases with calculated timings
     */
    calculatePhases(phases, totalBeats) {
        if (!phases || phases.length === 0) {
            return [{ name: 'main', beats: totalBeats, start: 0, end: 1 }];
        }
        
        // Calculate total beats from phases
        const phaseBeats = phases.reduce((sum, phase) => sum + (phase.beats || 1), 0);
        const scaleFactor = totalBeats / phaseBeats;
        
        let cumulativeBeats = 0;
        return phases.map(phase => {
            const beats = (phase.beats || 1) * scaleFactor;
            const start = cumulativeBeats / totalBeats;
            cumulativeBeats += beats;
            const end = cumulativeBeats / totalBeats;
            
            return {
                name: phase.name,
                beats: beats,
                start: start,
                end: end,
                duration: this.toMilliseconds({ musical: true, beats })
            };
        });
    }
    
    /**
     * Get progress through current beat
     * @returns {number} Progress 0-1 through current beat
     */
    getBeatProgress() {
        const timeInfo = rhythmEngine.getTimeInfo();
        return timeInfo ? timeInfo.beatProgress : 0;
    }
    
    /**
     * Get progress through current bar
     * @returns {number} Progress 0-1 through current bar
     */
    getBarProgress() {
        const timeInfo = rhythmEngine.getTimeInfo();
        return timeInfo ? timeInfo.barProgress : 0;
    }
    
    /**
     * Calculate when next musical boundary occurs
     * @param {string} boundary - 'beat', 'bar', 'phrase'
     * @returns {number} Milliseconds until boundary
     */
    timeToNextBoundary(boundary = 'beat') {
        const timeInfo = rhythmEngine.getTimeInfo();
        if (!timeInfo) return 100;
        
        switch (boundary) {
            case 'beat':
                return timeInfo.nextBeatIn;
            case 'bar':
                const beatsInBar = timeInfo.timeSignature[0];
                const beatsToBar = beatsInBar - timeInfo.beatInBar;
                return beatsToBar * timeInfo.beatDuration;
            case 'phrase':
                // Assume 4-bar phrases
                const barsInPhrase = 4;
                const currentBar = timeInfo.bar || 0;
                const barsToPhrase = barsInPhrase - (currentBar % barsInPhrase);
                return barsToPhrase * beatsInBar * timeInfo.beatDuration;
            default:
                return timeInfo.nextBeatIn;
        }
    }
    
    /**
     * Quantize a duration to nearest musical subdivision
     * @param {number} ms - Duration in milliseconds
     * @param {string} subdivision - Target subdivision
     * @returns {number} Quantized duration in ms
     */
    quantize(ms, subdivision = 'eighth') {
        const bpm = rhythmEngine.bpm || 120;
        const beatDuration = 60000 / bpm;
        const targetBeats = this.noteDurations[subdivision] || 1;
        const targetMs = targetBeats * beatDuration;
        
        // Round to nearest multiple of target
        const multiple = Math.round(ms / targetMs);
        return multiple * targetMs;
    }
    
    /**
     * Check if we're on a musical boundary
     * @param {string} boundary - 'beat', 'bar', 'phrase'
     * @param {number} tolerance - Tolerance in ms
     * @returns {boolean}
     */
    isOnBoundary(boundary = 'beat', tolerance = 50) {
        const timeToNext = this.timeToNextBoundary(boundary);
        const timeInfo = rhythmEngine.getTimeInfo();
        
        if (!timeInfo) return false;
        
        // Check if we just passed or are about to hit boundary
        return timeToNext < tolerance || 
               (timeInfo.beatDuration - timeToNext) < tolerance;
    }
    
    /**
     * Get tempo-adaptive animation parameters
     * @param {number} baseTempo - Reference tempo
     * @returns {Object} Animation adjustment factors
     */
    getTempoAdaptation(baseTempo = 120) {
        const currentTempo = rhythmEngine.bpm || 120;
        const tempoRatio = currentTempo / baseTempo;
        
        return {
            speed: tempoRatio,
            energy: Math.min(2, Math.max(0.5, tempoRatio)),
            smoothness: tempoRatio < 0.8 ? 1.2 : tempoRatio > 1.5 ? 0.8 : 1,
            intensity: tempoRatio > 1.3 ? 1.2 : tempoRatio < 0.7 ? 0.8 : 1
        };
    }
}

// Create singleton instance
const musicalDuration = new MusicalDuration();

/**
 * GestureAnimator - Handles all gesture animations for EmotiveRenderer
 * @module core/renderer/GestureAnimator
 */


class GestureAnimator {
    constructor(renderer) {
        this.renderer = renderer;
        this.activeGestures = new Map();
        this.scaleFactor = renderer.scaleFactor || 1;
        
        // Gesture animations state
        this.gestureAnimations = {
            bounce: { active: false, progress: 0, params: {} },
            pulse: { active: false, progress: 0, params: {} },
            shake: { active: false, progress: 0, params: {} },
            spin: { active: false, progress: 0, params: {} },
            nod: { active: false, progress: 0, params: {} },
            tilt: { active: false, progress: 0, params: {} },
            expand: { active: false, progress: 0, params: {} },
            contract: { active: false, progress: 0, params: {} },
            flash: { active: false, progress: 0, params: {} },
            drift: { active: false, progress: 0, params: {} },
            stretch: { active: false, progress: 0, params: {} },
            glow: { active: false, progress: 0, params: {} },
            flicker: { active: false, progress: 0, params: {} },
            vibrate: { active: false, progress: 0, params: {} },
            orbital: { active: false, progress: 0, params: {} },  // ADDED
            hula: { active: false, progress: 0, params: {} },     // ADDED
            wave: { active: false, progress: 0, params: {} },
            breathe: { active: false, progress: 0, params: {} },
            morph: { active: false, progress: 0, params: {} },
            slowBlink: { active: false, progress: 0, params: {} },
            look: { active: false, progress: 0, params: {} },
            settle: { active: false, progress: 0, params: {} },
            breathIn: { active: false, progress: 0, params: {} },
            breathOut: { active: false, progress: 0, params: {} },
            breathHold: { active: false, progress: 0, params: {} },
            breathHoldEmpty: { active: false, progress: 0, params: {} },
            jump: { active: false, progress: 0, params: {} },
            sway: { active: false, progress: 0, params: {} },
            float: { active: false, progress: 0, params: {} },
            sparkle: { active: false, progress: 0, params: {} },
            shimmer: { active: false, progress: 0, params: {} },
            wiggle: { active: false, progress: 0, params: {} },
            groove: { active: false, progress: 0, params: {} },
            point: { active: false, progress: 0, params: {} },
            lean: { active: false, progress: 0, params: {} },
            reach: { active: false, progress: 0, params: {} },
            headBob: { active: false, progress: 0, params: {} },
            orbit: { active: false, progress: 0, params: {} },
            rain: { active: false, progress: 0, params: {} },
            runningman: { active: false, progress: 0, params: {} },
            charleston: { active: false, progress: 0, params: {} }
        };
    }

    /**
     * Start a gesture animation
     * @param {string} gestureName - Name of the gesture to start
     */
    startGesture(gestureName) {
        
        // Get the gesture configuration
        const gesture = getGesture(gestureName);
        
        // Trigger chromatic aberration for impact gestures
        const impactGestures = ['bounce', 'shake', 'pulse', 'flash', 'jump', 'slam', 'spin', 'flicker'];
        if (impactGestures.includes(gestureName) && this.renderer.specialEffects) {
            // Vary intensity based on gesture - all high for testing
            const intensities = {
                'flash': 1.0,
                'jump': 1.0,
                'shake': 0.9,
                'bounce': 0.8,
                'pulse': 0.7,
                'slam': 1.0,
                'spin': 0.8,
                'flicker': 1.0
            };
            const intensity = intensities[gestureName] || 0.8;
            this.renderer.specialEffects.triggerChromaticAberration(intensity);
            console.log(`[Chromatic Aberration] Triggered for ${gestureName} with intensity ${intensity}`);
        }
        
        // Get composed parameters based on current emotion and undertone
        // Use the renderer's gestureCompositor if available
        let params;
        if (this.renderer.gestureCompositor) {
            params = this.renderer.gestureCompositor.compose(
                gestureName,
                this.renderer.state.emotion,
                this.renderer.currentUndertone
            );
        } else {
            // Fallback to gesture's default config if no compositor
            params = gesture?.config || {
                amplitude: 20,
                frequency: 2,
                duration: 1000,
                scaleAmount: 0.2,
                glowAmount: 0.3,
                rotations: 1,
                distance: 50,
                angle: 15,
                scaleTarget: 1.5,
                glowPeak: 2.0,
                scalePeak: 1.1,
                scaleX: 1.2,
                scaleY: 0.8,
                maxOpacity: 1,
                minOpacity: 0.5,
                lookDirection: 'random',
                lookDistance: 1,
                wobbleFreq: 4,
                squashAmount: 0.8,
                stretchAmount: 1.2,
                jumpHeight: 100,
                decay: true,
                easing: 'sine',
                effects: []
            };
        }
        
        // Calculate duration from gesture config
        let duration = 1000; // Default fallback
        if (gesture && gesture.config) {
            if (gesture.config.musicalDuration) {
                // Use musical duration system
                duration = musicalDuration.toMilliseconds(gesture.config.musicalDuration);
            } else if (gesture.config.duration) {
                // Use fixed duration
                duration = gesture.config.duration;
            }
        }
        
        // Set up the animation
        const anim = this.gestureAnimations[gestureName];
        if (anim) {
            anim.active = true;
            anim.startTime = performance.now();
            anim.progress = 0;
            anim.params = params;
            anim.duration = duration; // Store calculated duration
            
            // Reset random values for gestures that use them
            if (gestureName === 'shake') {
                anim.randomAngle = undefined; // Will be regenerated
            } else if (gestureName === 'drift') {
                anim.startX = undefined;
                anim.startY = undefined;
                anim.currentDriftAngle = undefined; // Reset the angle for new random direction
            } else if (gestureName === 'tilt') {
                anim.tiltDirection = undefined; // Reset for new random direction
            } else if (gestureName === 'vibrate') {
                anim.vibrateAngles = undefined;
            }
            
        }
    }

    /**
     * Apply all active gesture animations
     * @returns {Object} Combined transformation values
     */
    applyGestureAnimations() {
        const now = performance.now();
        const transform = {
            offsetX: 0,
            offsetY: 0,
            scale: 1,
            rotation: 0,
            glow: 1
        };
        
        // Process each gesture animation
        for (const [gestureName, anim] of Object.entries(this.gestureAnimations)) {
            if (!anim.active) continue;
            
            const elapsed = now - anim.startTime;
            // Use stored duration or fallback to params duration
            const duration = anim.duration || (anim.params ? anim.params.duration : 1000);
            anim.progress = Math.min(elapsed / duration, 1);
            
            // Apply easing
            const easedProgress = this.applyEasing(anim.progress, anim.params.easing);
            
            // Apply gesture-specific transformations
            let gestureTransform = {};
            switch (gestureName) {
                case 'bounce':
                    gestureTransform = this.applyBounce(anim, easedProgress);
                    break;
                case 'pulse':
                    gestureTransform = this.applyPulse(anim, easedProgress);
                    break;
                case 'shake':
                    gestureTransform = this.applyShake(anim, easedProgress);
                    break;
                case 'spin':
                    gestureTransform = this.applySpin(anim, easedProgress);
                    break;
                case 'nod':
                    gestureTransform = this.applyNod(anim, easedProgress);
                    break;
                case 'tilt':
                    gestureTransform = this.applyTilt(anim, easedProgress);
                    break;
                case 'expand':
                    gestureTransform = this.applyExpand(anim, easedProgress);
                    break;
                case 'contract':
                    gestureTransform = this.applyContract(anim, easedProgress);
                    break;
                case 'flash':
                    gestureTransform = this.applyFlash(anim, easedProgress);
                    break;
                case 'drift':
                    gestureTransform = this.applyDrift(anim, easedProgress);
                    break;
                case 'stretch':
                    gestureTransform = this.applyStretch(anim, easedProgress);
                    break;
                case 'glow':
                    gestureTransform = this.applyGlow(anim, easedProgress);
                    break;
                case 'flicker':
                    gestureTransform = this.applyFlicker(anim, easedProgress);
                    break;
                case 'vibrate':
                    gestureTransform = this.applyVibrate(anim, easedProgress);
                    break;
                case 'orbital':
                    gestureTransform = this.applyOrbital(anim, easedProgress);
                    break;
                case 'hula':
                    gestureTransform = this.applyHula(anim, easedProgress);
                    break;
                case 'wave':
                    gestureTransform = this.applyWave(anim, easedProgress);
                    break;
                case 'breathe':
                    gestureTransform = this.applyBreathe(anim, easedProgress);
                    break;
                case 'morph':
                    gestureTransform = this.applyMorph(anim, easedProgress);
                    break;
                case 'slowBlink':
                    gestureTransform = this.applySlowBlink(anim, easedProgress);
                    break;
                case 'look':
                    gestureTransform = this.applyLook(anim, easedProgress);
                    break;
                case 'settle':
                    gestureTransform = this.applySettle(anim, easedProgress);
                    break;
                case 'breathIn':
                    gestureTransform = this.applyBreathIn(anim, easedProgress);
                    break;
                case 'breathOut':
                    gestureTransform = this.applyBreathOut(anim, easedProgress);
                    break;
                case 'breathHold':
                    gestureTransform = this.applyBreathHold(anim, easedProgress);
                    break;
                case 'breathHoldEmpty':
                    gestureTransform = this.applyBreathHoldEmpty(anim, easedProgress);
                    break;
                case 'jump':
                    gestureTransform = this.applyJump(anim, easedProgress);
                    break;
                case 'sway':
                    gestureTransform = this.applySway(anim, easedProgress);
                    break;
                case 'float':
                    gestureTransform = this.applyFloat(anim, easedProgress);
                    break;
                case 'rain':
                    gestureTransform = this.applyRain(anim, easedProgress);
                    break;
                case 'runningman':
                    gestureTransform = this.applyRunningMan(anim, easedProgress);
                    break;
                case 'charleston':
                    gestureTransform = this.applyCharleston(anim, easedProgress);
                    break;
                case 'sparkle':
                    gestureTransform = this.applySparkle(anim, easedProgress);
                    break;
                case 'shimmer':
                    gestureTransform = this.applyShimmer(anim, easedProgress);
                    break;
                case 'wiggle':
                    gestureTransform = this.applyWiggle(anim, easedProgress);
                    break;
                case 'groove':
                    gestureTransform = this.applyGroove(anim, easedProgress);
                    break;
                case 'point':
                    gestureTransform = this.applyPoint(anim, easedProgress);
                    break;
                case 'lean':
                    gestureTransform = this.applyLean(anim, easedProgress);
                    break;
                case 'reach':
                    gestureTransform = this.applyReach(anim, easedProgress);
                    break;
                case 'headBob':
                    gestureTransform = this.applyHeadBob(anim, easedProgress);
                    break;
                case 'orbit':
                    gestureTransform = this.applyOrbit(anim, easedProgress);
                    break;
            }
            
            // Combine transforms
            transform.offsetX += gestureTransform.offsetX || 0;
            transform.offsetY += gestureTransform.offsetY || 0;
            transform.scale *= gestureTransform.scale || 1;
            transform.rotation += gestureTransform.rotation || 0;
            // Use MAX for glow instead of multiplying to prevent accumulation
            transform.glow = Math.max(transform.glow, gestureTransform.glow || 1);
            
            // Pass flash wave data if present
            if (gestureTransform.flashWave) {
                transform.flashWave = gestureTransform.flashWave;
            }
            
            // Pass firefly effect data if present (for sparkle gesture)
            if (gestureTransform.fireflyEffect) {
                transform.fireflyEffect = gestureTransform.fireflyEffect;
                transform.particleGlow = gestureTransform.particleGlow;
                transform.fireflyTime = gestureTransform.fireflyTime;
            }
            
            // Pass flicker effect data if present (for flicker gesture - now does particle shimmer)
            if (gestureTransform.flickerEffect) {
                transform.flickerEffect = gestureTransform.flickerEffect;
                transform.particleGlow = gestureTransform.particleGlow;
                transform.flickerTime = gestureTransform.flickerTime;
            }
            
            // Pass shimmer effect data if present (for shimmer gesture - subtle glow)
            if (gestureTransform.shimmerEffect) {
                transform.shimmerEffect = gestureTransform.shimmerEffect;
                transform.particleGlow = gestureTransform.particleGlow;
                transform.shimmerTime = gestureTransform.shimmerTime;
                transform.shimmerWave = gestureTransform.shimmerWave;
            }
            
            // Pass glow effect data if present (for glow gesture)
            if (gestureTransform.glowEffect) {
                transform.glowEffect = gestureTransform.glowEffect;
                transform.particleGlow = gestureTransform.particleGlow;
                transform.glowTime = gestureTransform.glowTime;
                transform.glowProgress = gestureTransform.glowProgress;
                transform.glowEnvelope = gestureTransform.glowEnvelope;
            }
            
            // Check if animation is complete
            if (anim.progress >= 1) {
                anim.active = false;
                anim.progress = 0;
                anim.startTime = 0;
                // Clean up flash wave data
                if (gestureName === 'flash') {
                    anim.flashWave = null;
                    anim.flashWaveData = null;
                }
            }
        }
        
        return transform;
    }

    /**
     * Update active gestures
     * @param {number} deltaTime - Time since last frame
     */
    update(deltaTime) {
        // Update logic moved to applyGestureAnimations
        return this.applyGestureAnimations();
    }

    /**
     * Stop all active gestures
     */
    stopAllGestures() {
        // Reset all gesture animations
        Object.keys(this.gestureAnimations).forEach(key => {
            this.gestureAnimations[key].active = false;
            this.gestureAnimations[key].startTime = 0;
            this.gestureAnimations[key].progress = 0;
            this.gestureAnimations[key].params = null;
        });
        this.activeGestures.clear();
    }
    
    /**
     * Get current active gesture information for particle system
     * @returns {Object|null} Current gesture with particleMotion and progress, or null
     */
    getCurrentGesture() {
        // Priority: Find override gestures first (like orbital, hula), then other gestures
        const overrideGestures = ['orbital', 'hula', 'wave', 'spin'];
        
        // Check override gestures first
        for (const gestureName of overrideGestures) {
            const anim = this.gestureAnimations[gestureName];
            if (anim && anim.active) {
                // Get the actual gesture configuration
                const gesture = getGesture(gestureName);
                
                // Use the gesture's config for particleMotion, or create one from gesture type
                const particleMotion = gesture?.config?.particleMotion || {
                    type: gestureName,  // This ensures the modular gesture system will find it
                    strength: anim.params?.strength || 1.0
                };
                
                const gestureInfo = {
                    name: gestureName,
                    particleMotion: particleMotion,
                    progress: anim.progress || 0,
                    params: anim.params
                };
                
                return gestureInfo;
            }
        }
        
        // Then check all other gestures
        for (const [gestureName, anim] of Object.entries(this.gestureAnimations)) {
            if (anim.active) {
                // Get the actual gesture configuration
                const gesture = getGesture(gestureName);
                
                // Use the gesture's config for particleMotion, or params if available
                const particleMotion = gesture?.config?.particleMotion || 
                                      anim.params?.particleMotion || 
                                      { type: gestureName, strength: anim.params?.strength || 1.0 };
                
                const gestureInfo = {
                    name: gestureName,
                    particleMotion: particleMotion,
                    progress: anim.progress || 0,
                    params: anim.params
                };
                
                // Include breathPhase for breathe gesture
                if (gestureName === 'breathe' && anim.breathPhase !== undefined) {
                    gestureInfo.breathPhase = anim.breathPhase;
                }
                
                return gestureInfo;
            }
        }
        return null;
    }
    
    /**
     * Apply easing function to progress
     */
    applyEasing(progress, easing) {
        switch (easing) {
            case 'linear':
                return progress;
            case 'quad':
                return progress * progress;
            case 'cubic':
                return progress * progress * progress;
            case 'sine':
                return Math.sin(progress * Math.PI / 2);
            case 'back':
                return progress * progress * (2.7 * progress - 1.7);
            default:
                return progress;
        }
    }
    
    // Individual gesture application methods
    applyBounce(anim, progress) {
        const bounce = Math.abs(Math.sin(progress * Math.PI * anim.params.frequency)) * anim.params.amplitude * this.scaleFactor;
        // Apply effects
        const multiplier = anim.params.effects && anim.params.effects.includes('gravity') ? 0.6 : 1;
        return { offsetY: -bounce * multiplier };
    }
    
    applyPulse(anim, progress) {
        const pulse = Math.sin(progress * Math.PI * anim.params.frequency);
        return {
            scale: 1 + pulse * anim.params.scaleAmount,
            glow: 1 + pulse * anim.params.glowAmount
        };
    }
    
    applyShake(anim, progress) {
        // Initialize random direction for this shake if not set
        if (!anim.randomAngle) {
            anim.randomAngle = Math.random() * Math.PI * 2; // Random angle in radians
        }
        const decay = anim.params.decay ? (1 - progress) : 1;
        const shake = Math.sin(progress * Math.PI * anim.params.frequency) * anim.params.amplitude * decay * this.scaleFactor;
        return {
            offsetX: shake * Math.cos(anim.randomAngle),
            offsetY: shake * Math.sin(anim.randomAngle)
        };
    }
    
    applySpin(anim, progress) {
        // Ensure full rotation even if progress doesn't quite reach 1.0
        const actualProgress = Math.min(progress * 1.05, 1.0); // Slight overshoot to ensure completion
        return {
            rotation: actualProgress * anim.params.rotations * 360,
            scale: 1 + Math.sin(progress * Math.PI) * anim.params.scaleAmount
        };
    }
    
    applyNod(anim, progress) {
        const nod = Math.sin(progress * Math.PI * anim.params.frequency) * anim.params.amplitude * this.scaleFactor;
        return { offsetY: nod };
    }
    
    applyTilt(anim, progress) {
        if (!anim.tiltDirection) {
            // Randomly choose left (-1) or right (1) tilt
            anim.tiltDirection = Math.random() < 0.5 ? -1 : 1;
        }
        const frequency = anim.params.frequency || 2;
        const angle = (anim.params.angle || 15) * Math.PI / 180; // Convert to radians
        const tiltProgress = Math.sin(progress * Math.PI * frequency) * anim.tiltDirection;
        
        // Apply both rotation and skew to make tilt visible on circular orb
        return { 
            rotation: tiltProgress * angle,
            // Skew the orb slightly to show tilt motion
            scaleX: 1 + Math.abs(tiltProgress) * 0.1,  // Widen when tilted
            scaleY: 1 - Math.abs(tiltProgress) * 0.05, // Compress slightly
            // Move slightly with tilt
            offsetX: tiltProgress * 10,
            offsetY: Math.abs(tiltProgress) * -5  // Lift slightly when tilted
        };
    }
    
    applyExpand(anim, progress) {
        // Use scaleAmount or scaleTarget (handle both config formats)
        // Make sure we're expanding, not contracting
        const targetScale = Math.max(anim.params.scaleAmount || anim.params.scaleTarget || 1.5, 1.0);
        const easedProgress = Math.sin(progress * Math.PI / 2); // Smooth ease-out
        const scale = 1 + (targetScale - 1) * easedProgress;
        return {
            scale: scale,
            glow: 1 + Math.abs(anim.params.glowAmount || 0.2) * easedProgress
        };
    }
    
    applyContract(anim, progress) {
        // Use scaleAmount or scaleTarget (handle both config formats)
        const targetScale = anim.params.scaleAmount || anim.params.scaleTarget || 0.7;
        const easedProgress = Math.sin(progress * Math.PI / 2); // Smooth ease-out
        const scale = 1 + (targetScale - 1) * easedProgress;
        return {
            scale: scale,
            glow: 1 + (anim.params.glowAmount || -0.2) * easedProgress
        };
    }
    
    applyFlash(anim, progress) {
        const flash = Math.sin(progress * Math.PI); // Quick up and down
        const glowPeak = anim.params.glowPeak || 2.0;  // Default if not defined
        const scalePeak = anim.params.scalePeak || 1.1; // Default if not defined
        return {
            glow: 1 + (glowPeak - 1) * flash,
            scale: 1 + (scalePeak - 1) * flash
        };
    }
    
    applyDrift(anim, progress) {
        // Initialize drift angle when starting (progress near 0)
        if (progress <= 0.01 && !anim.currentDriftAngle) {
            // Always pick a random angle for drift
            anim.currentDriftAngle = Math.random() * Math.PI * 2; // Random direction in radians
        }
        
        const distance = anim.params.distance * Math.sin(progress * Math.PI) * this.scaleFactor;
        const angle = anim.currentDriftAngle || 0;
        
        // Clear the angle when animation completes
        if (progress >= 0.99) {
            anim.currentDriftAngle = null;
        }
        
        return {
            offsetX: Math.cos(angle) * distance,
            offsetY: Math.sin(angle) * distance
        };
    }
    
    applyStretch(anim, progress) {
        const stretch = Math.sin(progress * Math.PI * anim.params.frequency);
        // Note: We'd need to handle scaleX/scaleY separately for proper stretch
        // For now, average them
        const avgScale = (anim.params.scaleX + anim.params.scaleY) / 2;
        return { scale: 1 + (avgScale - 1) * stretch };
    }
    
    applyGlow(anim, progress) {
        // Glow effect - pure luminosity like pulse but without movement
        // Copy of pulse logic but focused only on glow

        const glowPulse = Math.sin(progress * Math.PI * anim.params.frequency);

        return {
            scale: 1 + glowPulse * (anim.params.scaleAmount || 0.1), // Very subtle scale like new glow config
            glow: 1 + glowPulse * (anim.params.glowAmount || 0.8)    // Strong glow like new glow config
        };
    }
    
    applyFlash(anim, progress) {
        // Wave-like flash that emanates outward
        // Store wave state in the animation object
        if (!anim.flashWave) {
            anim.flashWave = {
                innerRadius: 0,
                outerRadius: 0,
                maxRadius: 3.0 // How far the wave travels (relative to core)
            };
        }
        
        // Update wave radius based on progress
        anim.flashWave.outerRadius = progress * anim.flashWave.maxRadius;
        anim.flashWave.innerRadius = Math.max(0, (progress - 0.1) * anim.flashWave.maxRadius);
        
        // Fade intensity as wave travels outward
        const waveIntensity = Math.max(0, 1 - progress * 0.7);
        
        // Store wave data for renderer to use
        anim.flashWaveData = {
            innerRadius: anim.flashWave.innerRadius,
            outerRadius: anim.flashWave.outerRadius,
            intensity: waveIntensity
        };
        
        // Return a very subtle glow increase at the core
        return {
            glow: 1 + waveIntensity * 0.3, // Very subtle core glow
            flashWave: anim.flashWaveData // Pass wave data to renderer
        };
    }
    
    applyFlicker(anim, progress) {
        // Flicker effect - particles shimmer with wave-like pulsing
        const intensity = anim.params?.intensity || 2.0;
        const shimmerSpeed = anim.params?.speed || 3;
        
        // Smooth sine wave for shimmer
        const glow = 1 + Math.sin(progress * Math.PI * 2 * shimmerSpeed) * intensity * 0.3;
        
        // Slight horizontal wave motion
        const waveX = Math.sin(progress * Math.PI * 4) * 5 * this.scaleFactor;
        
        // Create time-based shimmer for particles
        const time = Date.now() * 0.001; // Convert to seconds
        
        // Main shimmer pulse
        const mainPulse = Math.sin(progress * Math.PI * shimmerSpeed * 2) * 0.5 + 0.5;
        
        return {
            offsetX: waveX,
            glow: glow,
            particleGlow: intensity * mainPulse, // Intensity for particles
            flickerTime: time, // Pass time for particle calculations
            flickerEffect: true // Flag to enable flicker effect on particles (shimmer-like)
        };
    }
    
    applyVibrate(anim, progress) {
        // Initialize random vibration pattern if not set
        if (!anim.vibrateAngles) {
            anim.vibrateAngles = {
                x: Math.random() * 2 - 1, // Random factor between -1 and 1
                y: Math.random() * 2 - 1
            };
            // Normalize to unit vector
            const mag = Math.sqrt(anim.vibrateAngles.x ** 2 + anim.vibrateAngles.y ** 2);
            anim.vibrateAngles.x /= mag;
            anim.vibrateAngles.y /= mag;
        }
        const vibration = Math.sin(progress * Math.PI * 2 * anim.params.frequency) * anim.params.amplitude * this.scaleFactor;
        return {
            offsetX: vibration * anim.vibrateAngles.x,
            offsetY: vibration * anim.vibrateAngles.y
        };
    }
    
    applyWave(anim, progress) {
        // Completely rewritten wave - a graceful, flowing infinity symbol motion
        const amp = (anim.params.amplitude || 40) * this.scaleFactor;
        
        // Create a smooth infinity symbol (∞) pattern
        // This feels more like a natural greeting wave
        const t = progress * Math.PI * 2;
        
        // Infinity symbol parametric equations
        // X: figure-8 horizontal motion
        const infinityX = Math.sin(t) * amp;
        
        // Y: gentle vertical bob that rises during the wave
        // Creates a "lifting" feeling like a real wave hello
        const liftAmount = -Math.sin(progress * Math.PI) * amp * 0.3; // Lift up during wave
        const infinityY = Math.sin(t * 2) * amp * 0.2 + liftAmount;
        
        // Add a subtle tilt that follows the wave direction
        // Makes the orb "lean into" the wave
        const tilt = Math.sin(t) * 5; // ±5 degrees of tilt
        
        // Gentle scale pulse for emphasis
        const scalePulse = 1 + Math.sin(progress * Math.PI * 2) * 0.05; // 5% scale variation
        
        // Glow brightens slightly during wave
        const glowPulse = 1 + Math.sin(progress * Math.PI) * 0.2; // 20% glow increase
        
        return {
            offsetX: infinityX,
            offsetY: infinityY,
            rotation: tilt,
            scale: scalePulse,
            glow: glowPulse
        };
    }
    
    applyBreathe(anim, progress) {
        // Deliberate, mindful breathing animation
        const params = anim.params;
        const holdPercent = params.particleMotion?.holdPercent || 0.1;
        
        // Create a breathing curve with holds at peaks
        let breathPhase;
        if (progress < 0.4) {
            // Inhale phase (0-40%)
            breathPhase = Math.sin((progress / 0.4) * Math.PI / 2);
        } else if (progress < 0.4 + holdPercent) {
            // Hold at full inhale
            breathPhase = 1.0;
        } else if (progress < 0.9) {
            // Exhale phase  
            const exhaleProgress = (progress - 0.4 - holdPercent) / (0.5 - holdPercent);
            breathPhase = Math.cos(exhaleProgress * Math.PI / 2);
        } else {
            // Hold at full exhale
            breathPhase = 0;
        }
        
        // Apply scale changes - expand on inhale
        const scaleAmount = params.scaleAmount || 0.25;
        const scale = 1 + breathPhase * scaleAmount;
        
        // Apply glow changes - brighten on inhale
        const glowAmount = params.glowAmount || 0.4;
        const glow = 1 + breathPhase * glowAmount;
        
        // Store breath phase for particle system
        anim.breathPhase = breathPhase;
        
        return {
            scale: scale,
            glow: glow,
            breathPhase: breathPhase // Pass to particles for synchronized motion
        };
    }
    
    applyMorph(anim, progress) {
        // Fluid morphing effect
        const morph = Math.sin(progress * Math.PI * 2);
        return {
            scale: 1 + morph * 0.1,
            rotation: morph * 10
        };
    }
    
    applySlowBlink(anim, progress) {
        // Simulate blinking by scaling vertically
        let scaleY = 1;
        if (progress < 0.3) {
            // Closing
            scaleY = 1 - (progress / 0.3);
        } else if (progress < 0.5) {
            // Closed
            scaleY = 0;
        } else if (progress < 0.8) {
            // Opening
            scaleY = (progress - 0.5) / 0.3;
        } else {
            // Open
            scaleY = 1;
        }
        
        // Since we can't do scaleY separately, dim the orb instead
        return {
            glow: scaleY
        };
    }
    
    applyLook(anim, progress) {
        // Initialize target position if not set
        if (!anim.targetX) {
            const direction = anim.params.lookDirection;
            const distance = anim.params.lookDistance * 50 * this.scaleFactor; // Convert to pixels and scale
            
            switch(direction) {
                case 'left':
                    anim.targetX = -distance;
                    anim.targetY = 0;
                    break;
                case 'right':
                    anim.targetX = distance;
                    anim.targetY = 0;
                    break;
                case 'up':
                    anim.targetX = 0;
                    anim.targetY = -distance;
                    break;
                case 'down':
                    anim.targetX = 0;
                    anim.targetY = distance;
                    break;
                default: // random
                    const angle = Math.random() * Math.PI * 2;
                    anim.targetX = Math.cos(angle) * distance;
                    anim.targetY = Math.sin(angle) * distance;
            }
        }
        
        // Smooth look with hold
        let lookProgress = progress;
        if (progress < 0.3) {
            // Move to target
            lookProgress = progress / 0.3;
        } else if (progress < 0.7) {
            // Hold
            lookProgress = 1;
        } else {
            // Return
            lookProgress = 1 - (progress - 0.7) / 0.3;
        }
        
        return {
            offsetX: anim.targetX * lookProgress,
            offsetY: anim.targetY * lookProgress
        };
    }
    
    applySettle(anim, progress) {
        // Damped oscillation
        const wobble = Math.sin(progress * Math.PI * anim.params.wobbleFreq) * 
                      Math.exp(-progress * 3) * 20 * this.scaleFactor;
        return {
            offsetY: wobble,
            scale: 1 + wobble * 0.01
        };
    }
    
    applyBreathIn(anim, progress) {
        const breathScale = 1 + (anim.params.scaleAmount - 1) * Math.sin(progress * Math.PI / 2);
        return {
            scale: breathScale
        };
    }
    
    applyBreathOut(anim, progress) {
        const breathScale = 1 - (1 - anim.params.scaleAmount) * Math.sin(progress * Math.PI / 2);
        return {
            scale: breathScale
        };
    }
    
    applyBreathHold(anim, progress) {
        // Hold at expanded state
        return {
            scale: anim.params.scaleAmount
        };
    }
    
    applyBreathHoldEmpty(anim, progress) {
        // Hold at contracted state
        return {
            scale: anim.params.scaleAmount
        };
    }
    
    applyJump(anim, progress) {
        let yOffset = 0;
        let scale = 1;
        
        if (progress < 0.2) {
            // Squash phase
            const squashProgress = progress / 0.2;
            scale = 1 - (1 - anim.params.squashAmount) * squashProgress;
        } else if (progress < 0.7) {
            // Jump phase
            const jumpProgress = (progress - 0.2) / 0.5;
            const jumpCurve = Math.sin(jumpProgress * Math.PI);
            yOffset = -anim.params.jumpHeight * jumpCurve * this.scaleFactor;
            scale = anim.params.squashAmount + 
                   (anim.params.stretchAmount - anim.params.squashAmount) * jumpCurve;
        } else {
            // Landing phase
            const landProgress = (progress - 0.7) / 0.3;
            scale = anim.params.stretchAmount - 
                   (anim.params.stretchAmount - 1) * landProgress;
        }
        
        return {
            offsetY: yOffset,
            scale: scale
        };
    }
    
    applySway(anim, progress) {
        // Gentle pendulum-like swaying motion for the core
        const swayAmplitude = (anim.params?.amplitude || 30) * this.scaleFactor;
        const swayFrequency = anim.params?.frequency || 1;
        
        // Sway side to side with a gentle ease
        const swayX = Math.sin(progress * Math.PI * 2 * swayFrequency) * swayAmplitude;
        
        // Slight vertical bob for realism
        const bobY = Math.sin(progress * Math.PI * 4 * swayFrequency) * swayAmplitude * 0.1;
        
        // Slight rotation to match the sway
        const rotation = Math.sin(progress * Math.PI * 2 * swayFrequency) * 5; // 5 degrees max
        
        return {
            offsetX: swayX,
            offsetY: bobY,
            rotation: rotation
        };
    }
    
    applyRain(anim, progress) {
        // Rain effect - triggers falling particle behavior
        // The actual particle motion is handled by the particle system
        // This just adds a subtle downward drift to the core
        
        const rainIntensity = anim.params?.intensity || 1.0;
        
        // Gentle downward drift
        const driftY = progress * 10 * this.scaleFactor * rainIntensity;
        
        // Slight sway as if affected by wind
        const swayX = Math.sin(progress * Math.PI * 4) * 5 * this.scaleFactor;
        
        // Trigger particle falling effect through the renderer
        if (this.renderer && this.renderer.particleSystem) {
            // Enable falling behavior for particles during rain
            this.renderer.particleSystem.setGestureBehavior('falling', progress > 0 && progress < 1);
        }
        
        return {
            offsetX: swayX,
            offsetY: driftY,
            particleEffect: 'falling'  // Signal to particle system
        };
    }
    
    applyFloat(anim, progress) {
        // Ethereal floating motion with both vertical and horizontal drift
        const floatAmplitude = (anim.params?.amplitude || 20) * this.scaleFactor;
        const floatSpeed = anim.params?.speed || 1;
        
        // Primary vertical float with sine wave
        const floatY = Math.sin(progress * Math.PI * 2 * floatSpeed) * floatAmplitude;
        
        // Secondary horizontal drift for natural movement
        const driftX = Math.sin(progress * Math.PI * 3 * floatSpeed) * floatAmplitude * 0.3;
        
        // Slight scale pulsation for breathing effect
        const scalePulse = 1 + Math.sin(progress * Math.PI * 4 * floatSpeed) * 0.02;
        
        return {
            offsetX: driftX,
            offsetY: floatY,
            scale: scalePulse
        };
    }
    
    applyOrbital(anim, progress) {
        // Orbital motion - particles orbit around core, core stays still
        // This gesture is for particle motion only, not core movement
        return {
            // No core movement - orbital is a particle-only effect
            offsetX: 0,
            offsetY: 0
        };
    }
    
    applyHula(anim, progress) {
        // Hula motion - horizontal figure-8 pattern
        const amplitude = (anim.params?.amplitude || 40) * this.scaleFactor;
        const t = progress * Math.PI * 2;
        
        // Figure-8 parametric equations
        const x = Math.sin(t) * amplitude;
        const y = Math.sin(t * 2) * amplitude * 0.5;
        
        return {
            offsetX: x,
            offsetY: y
        };
    }
    
    applySparkle(anim, progress) {
        // Sparkle effect - make particles glow like fireflies
        // Each particle gets its own random phase for async blinking
        const intensity = anim.params?.intensity || 2.0;
        
        // Create firefly-like glow pattern for particles
        // Using time-based phase shifting for each particle
        const time = Date.now() * 0.001; // Convert to seconds
        
        // Main glow pulse for the effect
        const mainPulse = Math.sin(progress * Math.PI * 4) * 0.3 + 0.7;
        
        // This will be used by particles to create firefly effect
        // Each particle will add its own random offset to this
        return {
            particleGlow: intensity, // Intensity for individual particles
            glow: mainPulse, // Gentle overall glow
            fireflyTime: time, // Pass time for particle calculations
            fireflyEffect: true // Flag to enable firefly effect on particles
        };
    }
    
    applyShimmer(anim, progress) {
        // Shimmer effect - subtle, ethereal glow that travels across surface
        // Like moonlight on calm water
        
        const time = Date.now() * 0.001; // Current time in seconds
        const intensity = anim.params?.intensity || 0.3; // Very subtle
        
        // Single slow wave for gentle shimmer
        const wave = Math.sin(time * 2 + progress * Math.PI * 2);
        
        // Very subtle glow variation
        const glowEffect = 1 + wave * intensity;
        
        // Tiny breathing effect
        const scaleEffect = 1 + wave * 0.01; // Just 1% variation
        
        return {
            offsetX: 0, // No movement
            offsetY: 0, // No movement
            glow: glowEffect,
            scale: scaleEffect,
            // Particle-specific data
            particleGlow: 1 + wave * 0.2, // Very subtle particle effect
            shimmerTime: time,
            shimmerWave: wave,
            shimmerEffect: true // Flag to enable shimmer effect on particles
        };
    }
    
    applyWiggle(anim, progress) {
        // Hip-hop wiggle - 4 phase: center -> side -> opposite -> side -> center
        const amplitude = (anim.params?.amplitude || 15) * this.scaleFactor;
        
        // Random starting direction (1 for right, -1 for left)
        if (anim.wiggleDirection === undefined) {
            anim.wiggleDirection = Math.random() < 0.5 ? 1 : -1;
        }
        const direction = anim.wiggleDirection;
        
        // 4-phase movement pattern
        let wiggleX = 0;
        let rotation = 0;
        
        if (progress < 0.25) {
            // Phase 1: Center to first side (0-25%)
            const phase = progress / 0.25;
            wiggleX = amplitude * direction * phase;
            rotation = 3 * direction * phase;
        } else if (progress < 0.5) {
            // Phase 2: First side to opposite side (25-50%)
            const phase = (progress - 0.25) / 0.25;
            wiggleX = amplitude * direction * (1 - 2 * phase);
            rotation = 3 * direction * (1 - 2 * phase);
        } else if (progress < 0.75) {
            // Phase 3: Opposite side back to first side (50-75%)
            const phase = (progress - 0.5) / 0.25;
            wiggleX = amplitude * -direction * (1 - 2 * phase);
            rotation = 3 * -direction * (1 - 2 * phase);
        } else {
            // Phase 4: First side back to center (75-100%)
            const phase = (progress - 0.75) / 0.25;
            wiggleX = amplitude * direction * (1 - phase);
            rotation = 3 * direction * (1 - phase);
        }
        
        // Subtle bounce synced with movement
        const bounceY = Math.abs(Math.sin(progress * Math.PI * 4)) * amplitude * 0.15;
        
        return {
            offsetX: wiggleX,
            offsetY: -bounceY,
            rotation: rotation
        };
    }
    
    applyGroove(anim, progress) {
        // Groove motion - smooth, flowing dance movement
        const amplitude = (anim.params?.amplitude || 25) * this.scaleFactor;
        
        // Smoother wave pattern with organic flow
        const wave1 = Math.sin(progress * Math.PI * 2) * amplitude;
        const wave2 = Math.sin(progress * Math.PI * 3 + 0.5) * amplitude * 0.4;
        const grooveX = wave1 + wave2;
        
        // Gentle vertical bob with offset timing
        const grooveY = Math.sin(progress * Math.PI * 4 + 0.3) * amplitude * 0.25;
        
        // Subtle pulse that breathes naturally
        const scale = 1 + Math.sin(progress * Math.PI * 3 + 0.7) * 0.03;
        
        // Slight rotation for more natural movement
        const rotation = Math.sin(progress * Math.PI * 2 + 0.2) * 8;
        
        return {
            offsetX: grooveX,
            offsetY: grooveY,
            scale: scale,
            rotation: rotation
        };
    }
    
    applyPoint(anim, progress) {
        // Point gesture - directional lean/stretch with return to center
        
        // Random direction if not specified - only left or right
        if (anim.pointDirection === undefined) {
            // Randomly choose left (1) or right (-1)
            anim.pointDirection = Math.random() < 0.5 ? -1 : 1;
        }
        
        const direction = anim.params?.direction !== undefined ? anim.params.direction : anim.pointDirection;
        const distance = (anim.params?.distance || 40) * this.scaleFactor;
        
        // Three-phase animation:
        // 0.0-0.4: Move to point position
        // 0.4-0.6: Hold at point
        // 0.6-1.0: Return to center
        let motionProgress;
        let scaleProgress;
        
        if (progress < 0.4) {
            // Phase 1: Move to point (ease out)
            motionProgress = 1 - Math.pow(1 - (progress / 0.4), 3);
            scaleProgress = motionProgress;
        } else if (progress < 0.6) {
            // Phase 2: Hold at point
            motionProgress = 1.0;
            scaleProgress = 1.0;
        } else {
            // Phase 3: Return to center (ease in)
            motionProgress = Math.pow(1 - ((progress - 0.6) / 0.4), 3);
            scaleProgress = motionProgress;
        }
        
        // Move in direction (direction is -1 for left, 1 for right)
        const offsetX = direction * distance * motionProgress;
        const offsetY = -Math.abs(distance * 0.15 * motionProgress); // Slight upward movement when pointing
        
        // Stretch effect in pointing direction
        const scale = 1 + 0.15 * scaleProgress; // 15% stretch
        
        // Add slight tilt when pointing
        const rotation = direction * 5 * scaleProgress; // Tilt 5 degrees in pointing direction
        
        return {
            offsetX: offsetX,
            offsetY: offsetY,
            scale: scale,
            rotation: rotation
        };
    }
    
    applyLean(anim, progress) {
        // Lean gesture - tilt to one side
        const angle = anim.params?.angle || 15; // Degrees
        const side = anim.params?.side || 1; // 1 for right, -1 for left
        
        // Smooth ease in-out
        const easedProgress = Math.sin(progress * Math.PI);
        
        // Apply rotation and slight offset
        const rotation = angle * side * easedProgress;
        const offsetX = side * 10 * this.scaleFactor * easedProgress;
        
        return {
            offsetX: offsetX,
            rotation: rotation
        };
    }
    
    applyReach(anim, progress) {
        // Reach gesture - stretch upward or outward
        const direction = anim.params?.direction || -Math.PI/2; // Default upward
        const distance = (anim.params?.distance || 40) * this.scaleFactor;
        
        // Two-phase motion: reach out, then return
        let motionProgress;
        if (progress < 0.4) {
            // Reaching phase
            motionProgress = progress / 0.4;
        } else if (progress < 0.6) {
            // Hold phase
            motionProgress = 1;
        } else {
            // Return phase
            motionProgress = 1 - (progress - 0.6) / 0.4;
        }
        
        // Apply easing
        motionProgress = motionProgress * motionProgress * (3 - 2 * motionProgress);
        
        const offsetX = Math.cos(direction) * distance * motionProgress;
        const offsetY = Math.sin(direction) * distance * motionProgress;
        
        // Stretch slightly when reaching
        const scale = 1 + motionProgress * 0.15;
        
        return {
            offsetX: offsetX,
            offsetY: offsetY,
            scale: scale
        };
    }
    
    applyHeadBob(anim, progress) {
        // Head bob motion - rhythmic vertical movement
        const amplitude = (anim.params?.amplitude || 20) * this.scaleFactor;
        const frequency = anim.params?.frequency || 2;
        
        // Vertical bob with sharp down, smooth up
        const bobPhase = (progress * frequency) % 1;
        let bobY;
        if (bobPhase < 0.3) {
            // Quick down
            bobY = -amplitude * (bobPhase / 0.3);
        } else {
            // Smooth up
            bobY = -amplitude * (1 - (bobPhase - 0.3) / 0.7);
        }
        
        // Slight forward tilt on the down beat
        const rotation = bobPhase < 0.3 ? -3 : 0;
        
        return {
            offsetY: bobY,
            rotation: rotation
        };
    }
    
    applyOrbit(anim, progress) {
        // Orbit motion - circular path around center
        const radius = (anim.params?.radius || 30) * this.scaleFactor;
        const speed = anim.params?.speed || 1;
        
        // Circular motion
        const angle = progress * Math.PI * 2 * speed;
        const offsetX = Math.cos(angle) * radius;
        const offsetY = Math.sin(angle) * radius;
        
        return {
            offsetX: offsetX,
            offsetY: offsetY
        };
    }

    // Individual gesture methods - these will be moved from EmotiveRenderer
    startBounce() { this.startGesture('bounce'); }
    startPulse() { this.startGesture('pulse'); }
    startShake() { this.startGesture('shake'); }
    startSpin() { this.startGesture('spin'); }
    startNod() { this.startGesture('nod'); }
    startTilt() { this.startGesture('tilt'); }
    startExpand() { this.startGesture('expand'); }
    startContract() { this.startGesture('contract'); }
    startFlash() { this.startGesture('flash'); }
    startDrift() { this.startGesture('drift'); }
    startStretch() { this.startGesture('stretch'); }
    startGlow() { this.startGesture('glow'); }
    startFlicker() { this.startGesture('flicker'); }
    startVibrate() { this.startGesture('vibrate'); }
    startOrbital() { this.startGesture('orbital'); }
    startHula() { this.startGesture('hula'); }
    startWave() { this.startGesture('wave'); }
    startBreathe() { this.startGesture('breathe'); }
    startMorph() { this.startGesture('morph'); }
    startSlowBlink() { this.startGesture('slowBlink'); }
    startLook() { this.startGesture('look'); }
    startSettle() { this.startGesture('settle'); }
    startBreathIn() { this.startGesture('breathIn'); }
    startBreathOut() { this.startGesture('breathOut'); }
    startBreathHold() { this.startGesture('breathHold'); }
    startBreathHoldEmpty() { this.startGesture('breathHoldEmpty'); }
    startJump() { this.startGesture('jump'); }
    startSway() { this.startGesture('sway'); }
    startFloat() { this.startGesture('float'); }
    startRain() { this.startGesture('rain'); }
    startRunningMan() { this.startGesture('runningman'); }
    startCharleston() { this.startGesture('charleston'); }
    startSparkle() { this.startGesture('sparkle'); }
    startShimmer() { this.startGesture('shimmer'); }
    startWiggle() { this.startGesture('wiggle'); }
    startGroove() { this.startGesture('groove'); }
    startPoint() { this.startGesture('point'); }
    startLean() { this.startGesture('lean'); }
    startReach() { this.startGesture('reach'); }
    startHeadBob() { this.startGesture('headBob'); }
    startOrbit() { this.startGesture('orbit'); }
    
    applyRunningMan(anim, progress) {
        // Simple running shuffle - quick slide and step
        const slide = Math.sin(progress * Math.PI * 4) * 20 * this.scaleFactor;
        const step = -Math.abs(Math.sin(progress * Math.PI * 8)) * 10 * this.scaleFactor;
        
        return {
            offsetX: slide,
            offsetY: step,
            rotation: slide * 0.3,
            scaleY: 1 - Math.abs(Math.sin(progress * Math.PI * 8)) * 0.05
        };
    }
    
    applyCharleston(anim, progress) {
        // Charleston - crisscross kicks
        const kick = Math.sin(progress * Math.PI * 8) * 25 * this.scaleFactor;
        const hop = -Math.abs(Math.sin(progress * Math.PI * 8)) * 10 * this.scaleFactor;
        
        return {
            offsetX: kick,
            offsetY: hop,
            rotation: kick * 0.6,
            scaleY: 1 - Math.abs(Math.sin(progress * Math.PI * 8)) * 0.06
        };
    }
    
    startRunningMan() { this.startGesture('runningman'); }
    startCharleston() { this.startGesture('charleston'); }

    /**
     * Pause current animation (called on tab switch)
     */
    pauseCurrentAnimation() {
        // Store pause time for all active animations
        const now = performance.now();
        for (const [type, anim] of Object.entries(this.gestureAnimations)) {
            if (anim.active) {
                anim.pausedAt = now;
                anim.pausedProgress = anim.progress;
            }
        }
        this.isPaused = true;
    }

    /**
     * Resume animations after pause
     */
    resumeAnimation() {
        if (!this.isPaused) return;

        const now = performance.now();
        for (const [type, anim] of Object.entries(this.gestureAnimations)) {
            if (anim.active && anim.pausedAt) {
                // Adjust start time to account for pause
                const pauseDuration = now - anim.pausedAt;
                if (anim.startTime) {
                    anim.startTime += pauseDuration;
                }
                // Clear pause state
                delete anim.pausedAt;
                delete anim.pausedProgress;
            }
        }
        this.isPaused = false;
    }

    /**
     * Reset all gesture animations
     */
    reset() {
        // Clear all active animations
        for (const [type, anim] of Object.entries(this.gestureAnimations)) {
            anim.active = false;
            anim.progress = 0;
            anim.params = {};
            delete anim.startTime;
            delete anim.pausedAt;
            delete anim.pausedProgress;
        }
        this.activeGestures.clear();
        this.isPaused = false;
    }
}

/**
 * ColorUtilities - Color manipulation and transition utilities for EmotiveRenderer
 * @module core/renderer/ColorUtilities
 */

class ColorUtilities {
    constructor() {
        this.colorTransition = null;
    }

    /**
     * Apply undertone modifiers to current visual properties
     * Will be moved from EmotiveRenderer
     */
    applyUndertoneModifiers(undertone, visualProperties) {
        // Implementation will be moved here
        return visualProperties;
    }

    /**
     * Apply undertone to a color
     * @param {string} baseColor - Base hex color
     * @param {string|Object} undertone - Undertone modifier or weighted object
     * @returns {string} Modified hex color
     */
    applyUndertoneToColor(baseColor, undertone) {
        // Handle weighted modifier for smooth transitions
        if (undertone && typeof undertone === 'object' && undertone.weight !== undefined) {
            const weight = undertone.weight;
            const undertoneType = undertone.type || 'clear';
            
            if (undertoneType === 'clear' || weight === 0) {
                return baseColor;
            }
            
            // Get full saturation adjustment for this undertone
            const fullySaturated = this.applyUndertoneSaturation(baseColor, undertoneType);
            
            // Interpolate between base and fully saturated based on weight
            const rgb1 = this.hexToRgb(baseColor);
            const rgb2 = this.hexToRgb(fullySaturated);
            
            const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * weight);
            const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * weight);
            const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * weight);
            
            return this.rgbToHex(r, g, b);
        }
        
        // Direct string-based undertone - use saturation system
        if (!undertone || undertone === 'clear') return baseColor;
        
        return this.applyUndertoneSaturation(baseColor, undertone);
    }

    /**
     * Convert hex color to RGB
     * @param {string} hex - Hex color string
     * @returns {Object} RGB values
     */
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    /**
     * Convert RGB to HSL
     */
    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                case g: h = ((b - r) / d + 2) / 6; break;
                case b: h = ((r - g) / d + 4) / 6; break;
            }
        }

        return { h: h * 360, s: s * 100, l: l * 100 }; // Convert s and l to percentages
    }

    /**
     * Convert HSL to hex color
     */
    hslToHex(h, s, l) {
        h = h / 360;
        s = s / 100;
        l = l / 100;

        let r, g, b;

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        const toHex = x => {
            const hex = Math.round(x * 255).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };

        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Apply undertone saturation adjustment
     */
    applyUndertoneSaturation(baseColor, undertone) {
        const rgb = this.hexToRgb(baseColor);
        const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
        
        // Saturation adjustments by undertone
        const saturationModifiers = {
            // Positive undertones (higher saturation)
            'intense': 1.5,      // +50% saturation (very vivid)
            'confident': 1.3,    // +30% saturation (bold)
            'energetic': 1.2,    // +20% saturation (vibrant)
            'upbeat': 1.2,       // +20% saturation
            // Neutral/slightly nervous
            'nervous': 1.15,     // +15% saturation (slightly heightened)
            // Negative undertones (lower saturation)
            'mellow': 0.8,       // -20% saturation  
            'tired': 0.8,        // -20% saturation (washed out)
            'subdued': 0.5       // -50% saturation (ghostly)
        };
        
        const modifier = saturationModifiers[undertone] || 1.0;
        hsl.s = Math.min(100, hsl.s * modifier);
        
        return this.hslToHex(hsl.h, hsl.s, hsl.l);
    }
    
    /**
     * Convert RGB values to hex
     */
    rgbToHex(r, g, b) {
        const toHex = x => {
            const hex = Math.round(x).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    
    /**
     * Start a color transition
     */
    startColorTransition(targetColor, targetIntensity, duration = 1500) {
        // Don't start a new transition if we're already at the target
        if (this.currentColor === targetColor && 
            this.currentIntensity === targetIntensity) {
            return;
        }
        
        this.colorTransition = {
            active: true,
            fromColor: this.currentColor || '#ffffff',
            toColor: targetColor,
            fromIntensity: this.currentIntensity || 1.0,
            toIntensity: targetIntensity,
            progress: 0,
            startTime: performance.now(),
            duration: duration
        };
    }

    /**
     * Update color transition
     */
    updateColorTransition(deltaTime) {
        if (!this.colorTransition || !this.colorTransition.active) return null;
        
        const elapsed = performance.now() - this.colorTransition.startTime;
        const progress = Math.min(elapsed / this.colorTransition.duration, 1);
        
        // Use ease-out-quad for smooth deceleration
        const eased = 1 - Math.pow(1 - progress, 2);
        
        // Interpolate color
        const from = this.hexToRgb(this.colorTransition.fromColor);
        const to = this.hexToRgb(this.colorTransition.toColor);
        
        const r = Math.round(from.r + (to.r - from.r) * eased);
        const g = Math.round(from.g + (to.g - from.g) * eased);
        const b = Math.round(from.b + (to.b - from.b) * eased);
        
        const currentColor = this.rgbToHex(r, g, b);
        const currentIntensity = this.colorTransition.fromIntensity + 
            (this.colorTransition.toIntensity - this.colorTransition.fromIntensity) * eased;
        
        // Store current values
        this.currentColor = currentColor;
        this.currentIntensity = currentIntensity;
        
        // Complete transition if done
        if (progress >= 1) {
            this.colorTransition.active = false;
        }
        
        return {
            color: currentColor,
            intensity: currentIntensity
        };
    }
}

/**
 * SpecialEffects - Special visual effects for EmotiveRenderer
 * @module core/renderer/SpecialEffects
 */

class SpecialEffects {
    constructor(renderer) {
        this.renderer = renderer;
        this.ctx = renderer.ctx;
        this.canvas = renderer.canvasManager?.canvas || renderer.canvas;
        
        // Effect states
        this.recordingActive = false;
        this.sleepMode = false;
        this.speakingActive = false;
        this.zenModeActive = false;
        
        // Speaking rings
        this.speakingRings = [];
        this.ringSpawnTimer = 0;
        this.ringSpawnInterval = 300;
        this.maxRings = 3;
        
        // Sleep Z's
        this.sleepZ = [];
        
        // Sparkle particles
        this.sparkles = [];
        
        // Chromatic aberration effect
        this.chromaticAberration = {
            active: false,
            intensity: 0,
            targetIntensity: 0,
            fadeSpeed: 0.01, // Very slow fade for testing
            maxOffset: 30 // Much larger offset for testing
        };
        
        // Helper method references
        this.scaleValue = (value) => renderer.scaleValue(value);
        this.hexToRgba = (hex, alpha) => renderer.hexToRgba(hex, alpha);
    }

    /**
     * Render recording glow effect
     */
    renderRecordingGlow(x, y, radius, intensity) {
        const ctx = this.ctx;
        const glowSize = radius * 2.5;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
        
        gradient.addColorStop(0, `rgba(255, 0, 0, ${0.3 * intensity})`);
        gradient.addColorStop(0.5, `rgba(255, 0, 0, ${0.15 * intensity})`);
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = gradient;
        ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        ctx.restore();
    }

    /**
     * Render recording indicator
     */
    renderRecordingIndicator(x, y) {
        const time = Date.now() / 1000;
        const pulse = 0.8 + Math.sin(time * 2) * 0.2;
        
        this.ctx.save();
        this.ctx.translate(x, y);
        
        // Outer glow for text
        this.ctx.shadowBlur = this.scaleValue(15);
        this.ctx.shadowColor = `rgba(255, 0, 0, ${pulse * 0.8})`;
        
        // Main REC text
        const recSize = this.scaleValue(80);
        this.ctx.font = `italic 900 ${recSize}px "Poppins", sans-serif`;
        this.ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText('REC', 0, 0);
        
        // Inner highlight
        this.ctx.shadowBlur = 0;
        this.ctx.font = `italic 900 ${recSize - 1}px "Poppins", sans-serif`;
        this.ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.3})`;
        this.ctx.fillText('REC', -0.5, -0.5);
        
        this.ctx.restore();
    }

    /**
     * Render sleep indicator with Z's
     */
    renderSleepIndicator(x, y, deltaTime) {
        // Spawn new Z periodically
        this.ringSpawnTimer += deltaTime;
        if (this.ringSpawnTimer >= 2000 && this.sleepZ.length < 3) {
            const weights = ['300', '500', '700', '900'];
            const randomWeight = weights[Math.floor(Math.random() * weights.length)];
            const randomCase = Math.random() > 0.5 ? 'Z' : 'z';
            
            this.sleepZ.push({
                x: x + Math.random() * this.scaleValue(30) - this.scaleValue(15),
                y: y + this.scaleValue(80),
                size: this.scaleValue((24 + Math.random() * 8) * 3),
                opacity: 1.0,
                speed: -0.025,
                drift: Math.random() * this.scaleValue(20) - this.scaleValue(10),
                lifetime: 0,
                rotation: Math.random() * 30 - 15,
                text: randomCase,
                weight: randomWeight
            });
            this.ringSpawnTimer = 0;
        }
        
        // Update and render Z's
        this.sleepZ = this.sleepZ.filter(z => {
            z.lifetime += deltaTime;
            z.y += z.speed * deltaTime;
            z.x += Math.sin(z.lifetime * 0.0008) * z.drift * 0.008;
            z.rotation += deltaTime * 0.01;
            
            // Gradient fade out
            const fadeStart = 2000;
            const fadeEnd = 4000;
            if (z.lifetime < fadeStart) {
                z.opacity = 1.0;
            } else if (z.lifetime < fadeEnd) {
                z.opacity = 1.0 - ((z.lifetime - fadeStart) / (fadeEnd - fadeStart));
            } else {
                z.opacity = 0;
            }
            
            if (z.opacity > 0.01) {
                this.ctx.save();
                this.ctx.translate(z.x, z.y);
                this.ctx.rotate(z.rotation * Math.PI / 180);
                
                const baseColor = this.renderer.state.glowColor || '#4a90e2';
                
                // Outer glow
                this.ctx.shadowBlur = this.scaleValue(15);
                this.ctx.shadowColor = this.hexToRgba(baseColor, z.opacity * 0.5);
                
                // Main Z with gradient
                const gradient = this.ctx.createLinearGradient(-z.size/2, -z.size/2, z.size/2, z.size/2);
                gradient.addColorStop(0, this.hexToRgba(baseColor, z.opacity));
                gradient.addColorStop(0.5, this.hexToRgba('#ffffff', z.opacity * 0.9));
                gradient.addColorStop(1, this.hexToRgba(baseColor, z.opacity * 0.7));
                
                this.ctx.font = `italic ${z.weight || '900'} ${z.size}px 'Poppins', sans-serif`;
                this.ctx.fillStyle = gradient;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(z.text || 'Z', 0, 0);
                
                // Inner highlight
                this.ctx.shadowBlur = 0;
                this.ctx.font = `italic ${z.weight || '900'} ${z.size * 0.9}px 'Poppins', sans-serif`;
                this.ctx.fillStyle = this.hexToRgba('#ffffff', z.opacity * 0.3);
                this.ctx.fillText(z.text || 'Z', -1, -1);
                
                this.ctx.restore();
                return true;
            }
            return false;
        });
    }

    /**
     * Render speaking rings effect
     */
    renderSpeakingRings(centerX, centerY, coreRadius, deltaTime) {
        // Spawn new rings periodically
        this.ringSpawnTimer += deltaTime;
        if (this.ringSpawnTimer >= this.ringSpawnInterval && this.speakingRings.length < this.maxRings) {
            this.speakingRings.push({
                radius: coreRadius,
                opacity: 0.8,
                speed: 0.15
            });
            this.ringSpawnTimer = 0;
        }
        
        // Update and render existing rings
        this.speakingRings = this.speakingRings.filter(ring => {
            ring.radius += ring.speed * deltaTime;
            ring.opacity = Math.max(0, 0.8 * (1 - (ring.radius - coreRadius) / (coreRadius * 2)));
            
            if (ring.opacity > 0.01) {
                this.ctx.strokeStyle = this.hexToRgba(this.renderer.state.glowColor, ring.opacity);
                this.ctx.lineWidth = this.scaleValue(2);
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, ring.radius, 0, Math.PI * 2);
                this.ctx.stroke();
                return true;
            }
            return false;
        });
    }

    /**
     * Render zen core effect
     */
    renderZenCore(x, y, radius, time) {
        const ctx = this.ctx;
        const breathPhase = Math.sin(time * 0.001) * 0.5 + 0.5;
        const zenRadius = radius * (0.9 + breathPhase * 0.1);
        
        // Inner glow
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, zenRadius);
        gradient.addColorStop(0, 'rgba(147, 112, 219, 0.8)');
        gradient.addColorStop(0.7, 'rgba(147, 112, 219, 0.3)');
        gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, zenRadius * 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    /**
     * Start recording effect
     */
    startRecording() {
        this.recordingActive = true;
    }

    /**
     * Stop recording effect
     */
    stopRecording() {
        this.recordingActive = false;
    }

    /**
     * Enter sleep mode
     */
    enterSleepMode() {
        this.sleepMode = true;
    }

    /**
     * Wake up from sleep
     */
    wakeUp() {
        this.sleepMode = false;
    }

    /**
     * Start speaking effect
     */
    startSpeaking() {
        this.speakingActive = true;
    }

    /**
     * Stop speaking effect
     */
    stopSpeaking() {
        this.speakingActive = false;
    }

    /**
     * Create a sparkle particle
     */
    createSparkle(x, y, options = {}) {
        this.sparkles.push({
            x,
            y,
            vx: options.velocity?.x || 0,
            vy: options.velocity?.y || 0,
            size: options.size || 3,
            color: options.color || 'hsl(50, 100%, 70%)',
            lifetime: options.lifetime || 1000,
            maxLifetime: options.lifetime || 1000,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.2
        });
    }
    
    /**
     * Render all sparkles
     */
    renderSparkles() {
        const ctx = this.ctx;
        
        this.sparkles.forEach(sparkle => {
            const progress = 1 - (sparkle.lifetime / sparkle.maxLifetime);
            const opacity = 1 - progress; // Fade out over time
            
            ctx.save();
            ctx.translate(sparkle.x, sparkle.y);
            ctx.rotate(sparkle.rotation);
            
            // Draw sparkle as a star shape
            const size = this.scaleValue(sparkle.size * (1 - progress * 0.5));
            
            // Draw a 5-pointed star with smoother interior angles
            ctx.beginPath();
            const points = 5;
            const outerRadius = size;
            const innerRadius = size * 0.38; // Golden ratio-ish for smoother interior angles
            
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI / points) - Math.PI / 2; // Start from top
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                
                if (i === 0) {
                    ctx.moveTo(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius
                    );
                } else {
                    ctx.lineTo(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius
                    );
                }
            }
            ctx.closePath();
            
            // Add glow effect
            ctx.shadowBlur = this.scaleValue(10);
            ctx.shadowColor = sparkle.color;
            
            ctx.fillStyle = sparkle.color.replace('70%', `${70 + progress * 30}%`).replace(')', `, ${opacity})`).replace('hsl', 'hsla');
            ctx.fill();
            
            ctx.restore();
        });
    }
    
    /**
     * Trigger chromatic aberration effect
     * @param {number} intensity - Effect intensity (0-1)
     */
    triggerChromaticAberration(intensity = 0.8) {
        this.chromaticAberration.active = true;
        this.chromaticAberration.targetIntensity = Math.min(1, intensity);
        this.chromaticAberration.intensity = this.chromaticAberration.targetIntensity;
        
        // Get the actual visible canvas from the document
        const visibleCanvas = document.getElementById('emotive-canvas') || 
                            document.querySelector('canvas') || 
                            this.canvas;
        
        console.log('[Chromatic] Visible canvas element:', visibleCanvas);
        console.log('[Chromatic] Canvas ID:', visibleCanvas?.id);
        
        if (visibleCanvas) {
            // Remove any existing animation
            visibleCanvas.style.animation = 'none';
            
            // Add CSS styles if not already present
            if (!document.getElementById('chromatic-styles')) {
                const style = document.createElement('style');
                style.id = 'chromatic-styles';
                style.textContent = `
                    @keyframes chromaticGlitch {
                        0% {
                            filter: none;
                            transform: translateX(0);
                        }
                        15% {
                            filter: drop-shadow(-2px 0 0 rgba(255,0,0,0.7)) drop-shadow(2px 0 0 rgba(0,255,255,0.7));
                            transform: translateX(-0.5px);
                        }
                        30% {
                            filter: drop-shadow(-3px 0 0 rgba(255,0,0,0.8)) drop-shadow(3px 0 0 rgba(0,255,255,0.8));
                            transform: translateX(0.5px);
                        }
                        45% {
                            filter: drop-shadow(-2px 0 0 rgba(255,0,0,0.6)) drop-shadow(2px 0 0 rgba(0,255,255,0.6));
                            transform: translateX(-0.3px);
                        }
                        60% {
                            filter: drop-shadow(-1px 0 0 rgba(255,0,0,0.4)) drop-shadow(1px 0 0 rgba(0,255,255,0.4));
                            transform: translateX(0.2px);
                        }
                        100% {
                            filter: none;
                            transform: translateX(0);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Apply animation - shorter duration (300-500ms based on intensity)
            visibleCanvas.style.animation = `chromaticGlitch ${300 + 200 * intensity}ms ease-out`;
        }
    }
    
    /**
     * Apply chromatic aberration effect to canvas
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {HTMLCanvasElement} sourceCanvas - Source canvas to apply effect to
     */
    applyChromaticAberration(ctx, sourceCanvas) {
        if (!this.chromaticAberration.active || this.chromaticAberration.intensity <= 0) {
            return;
        }
        
        const intensity = this.chromaticAberration.intensity;
        const offset = this.scaleValue(this.chromaticAberration.maxOffset * intensity);
        
        // Store current composite operation
        const prevComposite = ctx.globalCompositeOperation;
        
        // Clear the canvas first
        ctx.save();
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        // Draw red channel (shifted left)
        ctx.globalCompositeOperation = 'source-over';
        ctx.filter = 'url(#red-channel)'; // Will use CSS filter fallback
        ctx.drawImage(sourceCanvas, -offset, 0);
        
        // Draw green channel (center)
        ctx.globalCompositeOperation = 'screen';
        ctx.filter = 'url(#green-channel)';
        ctx.drawImage(sourceCanvas, 0, 0);
        
        // Draw blue channel (shifted right)
        ctx.globalCompositeOperation = 'screen';
        ctx.filter = 'url(#blue-channel)';
        ctx.drawImage(sourceCanvas, offset, 0);
        
        // Reset
        ctx.filter = 'none';
        ctx.globalCompositeOperation = prevComposite;
        ctx.restore();
    }
    
    /**
     * Simple chromatic aberration using multiple draws
     * (Fallback method that doesn't require filters)
     */
    applyChromaticAberrationSimple(ctx, centerX, centerY, radius, drawFunction) {
        if (!this.chromaticAberration.active || this.chromaticAberration.intensity <= 0) {
            drawFunction();
            return;
        }
        
        const intensity = this.chromaticAberration.intensity;
        const offset = this.scaleValue(this.chromaticAberration.maxOffset * intensity);
        
        ctx.save();
        
        // Draw red channel (shifted left)
        ctx.globalCompositeOperation = 'source-over';
        ctx.translate(-offset, 0);
        ctx.globalAlpha = 0.33;
        ctx.fillStyle = '#ff0000';
        ctx.filter = 'brightness(3)';
        drawFunction();
        ctx.translate(offset, 0);
        
        // Draw green channel (center)
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.33;
        ctx.fillStyle = '#00ff00';
        drawFunction();
        
        // Draw blue channel (shifted right)
        ctx.translate(offset, 0);
        ctx.globalAlpha = 0.33;
        ctx.fillStyle = '#0000ff';
        drawFunction();
        
        ctx.restore();
    }
    
    /**
     * Update all active effects
     */
    update(deltaTime) {
        // Update sparkles
        this.sparkles = this.sparkles.filter(sparkle => {
            sparkle.x += sparkle.vx;
            sparkle.y += sparkle.vy;
            sparkle.rotation += sparkle.rotationSpeed;
            sparkle.lifetime -= deltaTime;
            sparkle.vy += 0.1; // Gravity
            
            return sparkle.lifetime > 0;
        });
        
        // Update chromatic aberration fade
        if (this.chromaticAberration.active) {
            // Fade out the effect
            this.chromaticAberration.intensity -= this.chromaticAberration.fadeSpeed;
            
            if (this.chromaticAberration.intensity <= 0) {
                this.chromaticAberration.intensity = 0;
                this.chromaticAberration.active = false;
                this.chromaticAberration.targetIntensity = 0;
                console.log('[CSS Chromatic] Effect completed');
            }
        }
    }
}

/**
 * EyeRenderer - Handles eye expressions and blinking for EmotiveRenderer
 * @module core/renderer/EyeRenderer
 */

class EyeRenderer {
    constructor(renderer) {
        this.renderer = renderer;
        this.ctx = renderer.ctx;
        this.canvas = renderer.canvas;
        
        // Eye state
        this.blinking = false;
        this.blinkingEnabled = true;
        this.blinkTimer = 0;
        this.nextBlinkTime = this.getRandomBlinkTime();
        
        // Eye parameters
        this.squintAmount = 0;
        this.eyeClose = null;
        this.eyeOpen = null;
        
        // Helper method references
        this.scaleValue = (value) => renderer.scaleValue(value);
        this.hexToRgba = (hex, alpha) => renderer.hexToRgba(hex, alpha);
    }

    /**
     * Update blinking and eye animations
     * @param {number} deltaTime - Time since last frame
     */
    update(deltaTime) {
        // Update blink timer
        if (this.blinking) {
            this.blinkTimer += deltaTime;
            if (this.blinkTimer >= 150) {
                this.blinking = false;
                this.blinkTimer = 0;
                this.nextBlinkTime = Date.now() + this.getRandomBlinkTime();
            }
        }
        
        // Check for natural blink
        if (this.blinkingEnabled && !this.blinking && Date.now() >= this.nextBlinkTime) {
            this.startBlink();
        }
    }

    /**
     * Start a blink animation
     */
    startBlink() {
        if (!this.blinkingEnabled) return;
        this.blinking = true;
        this.blinkTimer = 0;
    }

    /**
     * Get random time until next blink (3-7 seconds)
     * @returns {number} Time in milliseconds
     */
    getRandomBlinkTime() {
        return 3000 + Math.random() * 4000;
    }

    /**
     * Calculate blink scale for core
     * @returns {number} Scale factor for blinking
     */
    getBlinkScale() {
        if (!this.blinking) return 1;
        
        const blinkProgress = Math.min(this.blinkTimer / 150, 1);
        const blinkCurve = Math.sin(blinkProgress * Math.PI);
        return 1 - blinkCurve * 0.7; // Squish vertically by 70%
    }

    /**
     * Draw eye expression
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {string} emotion - Current emotion
     * @param {Object} params - Eye parameters
     */
    drawEyes(x, y, radius, emotion, params = {}) {
        const ctx = this.ctx;
        
        // Get eye parameters
        const eyeOpenness = params.eyeOpenness || 1;
        const eyeExpression = params.eyeExpression || 'neutral';
        
        // Don't draw eyes for certain states
        if (emotion === 'zen' || emotion === 'neutral' || eyeOpenness <= 0) {
            return;
        }
        
        ctx.save();
        
        // Eye color (slightly darker than core)
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = this.scaleValue(2);
        ctx.lineCap = 'round';
        
        // Calculate eye positions
        const eyeSpacing = radius * 0.4;
        const eyeY = y - radius * 0.1;
        const eyeSize = radius * 0.25;
        
        // Draw based on expression
        switch (eyeExpression) {
            case 'happy':
                this.drawHappyEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
                break;
            case 'sad':
                this.drawSadEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
                break;
            case 'angry':
                this.drawAngryEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
                break;
            case 'surprised':
                this.drawSurprisedEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
                break;
            case 'focused':
                this.drawFocusedEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
                break;
            case 'sleepy':
                this.drawSleepyEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
                break;
            case 'suspicious':
                this.drawSuspiciousEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
                break;
        }
        
        ctx.restore();
    }

    /**
     * Draw happy eyes (upward curves)
     */
    drawHappyEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.arc(x - spacing, y, size, Math.PI * 0.2, Math.PI * 0.8, false);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(x + spacing, y, size, Math.PI * 0.2, Math.PI * 0.8, false);
        ctx.stroke();
    }

    /**
     * Draw sad eyes (downward curves)
     */
    drawSadEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.arc(x - spacing, y + size * 0.5, size, Math.PI * 1.2, Math.PI * 1.8, false);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(x + spacing, y + size * 0.5, size, Math.PI * 1.2, Math.PI * 1.8, false);
        ctx.stroke();
    }

    /**
     * Draw angry eyes (angled lines)
     */
    drawAngryEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.moveTo(x - spacing - size, y - size * 0.3);
        ctx.lineTo(x - spacing + size * 0.5, y + size * 0.3);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.moveTo(x + spacing + size, y - size * 0.3);
        ctx.lineTo(x + spacing - size * 0.5, y + size * 0.3);
        ctx.stroke();
    }

    /**
     * Draw surprised eyes (wide circles)
     */
    drawSurprisedEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.arc(x - spacing, y, size * 1.2, 0, Math.PI * 2);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(x + spacing, y, size * 1.2, 0, Math.PI * 2);
        ctx.stroke();
    }

    /**
     * Draw focused eyes (dots)
     */
    drawFocusedEyes(ctx, x, y, spacing, size, openness) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        
        // Left eye
        ctx.beginPath();
        ctx.arc(x - spacing, y, size * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(x + spacing, y, size * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * Draw sleepy eyes (half-closed)
     */
    drawSleepyEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.moveTo(x - spacing - size, y);
        ctx.lineTo(x - spacing + size, y);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.moveTo(x + spacing - size, y);
        ctx.lineTo(x + spacing + size, y);
        ctx.stroke();
    }

    /**
     * Draw suspicious eyes (narrowed)
     */
    drawSuspiciousEyes(ctx, x, y, spacing, size, openness) {
        // Left eye - narrowed
        ctx.beginPath();
        ctx.moveTo(x - spacing - size, y);
        ctx.lineTo(x - spacing + size * 0.7, y);
        ctx.stroke();
        
        // Right eye - more open
        ctx.beginPath();
        ctx.arc(x + spacing, y, size * 0.8, Math.PI * 0.1, Math.PI * 0.9, false);
        ctx.stroke();
    }

    /**
     * Enable or disable blinking
     * @param {boolean} enabled - Whether blinking is enabled
     */
    setBlinkingEnabled(enabled) {
        this.blinkingEnabled = enabled;
        if (!enabled) {
            this.blinking = false;
            this.blinkTimer = 0;
        }
    }

    /**
     * Set squint amount for eye narrowing
     * @param {number} amount - Squint amount (0-1)
     */
    setSquintAmount(amount) {
        this.squintAmount = Math.max(0, Math.min(1, amount));
    }

    /**
     * Force a blink
     */
    forceBlink() {
        this.startBlink();
    }
}

/**
 * BreathingAnimator - Handles breathing animations for EmotiveRenderer
 * @module core/renderer/BreathingAnimator
 */

class BreathingAnimator {
    constructor(renderer) {
        this.renderer = renderer;
        
        // Breathing configuration
        this.breathingSpeed = 0.42; // 16 breaths/min (0.42 rad/s = 4 sec/cycle = 15-16 bpm)
        this.breathingDepth = 0.08; // 8% size variation for visible breathing
        
        // Breathing state
        this.breathingPhase = 0;
        this.breathRate = 1.0;
        this.breathDepth = this.breathingDepth;
        this.breathRateMult = 1.0;
        this.breathDepthMult = 1.0;
        this.breathIrregular = false;
        
        // Custom scale override
        this.customScale = null;
        
        // Emotion-specific breathing patterns
        this.emotionBreathPatterns = {
            happy: { rate: 1.1, depth: 1.2 },
            sad: { rate: 0.8, depth: 0.7 },
            angry: { rate: 1.4, depth: 1.3 },
            calm: { rate: 0.7, depth: 0.9 },
            excited: { rate: 1.5, depth: 1.4 },
            focused: { rate: 0.9, depth: 0.6 },
            neutral: { rate: 1.0, depth: 1.0 },
            love: { rate: 1.2, depth: 1.3 },
            surprised: { rate: 1.3, depth: 1.1 },
            confused: { rate: 1.1, depth: 0.9 },
            amused: { rate: 1.2, depth: 1.1 },
            bored: { rate: 0.6, depth: 0.8 },
            tired: { rate: 0.5, depth: 1.2 },
            anxious: { rate: 1.6, depth: 0.9 },
            determined: { rate: 1.1, depth: 1.0 },
            proud: { rate: 0.9, depth: 1.3 },
            content: { rate: 0.8, depth: 1.0 },
            hopeful: { rate: 1.0, depth: 1.1 },
            zen: { rate: 0.4, depth: 1.5 },
            intrigued: { rate: 1.1, depth: 0.8 },
            embarrassed: { rate: 1.3, depth: 0.7 },
            grateful: { rate: 0.9, depth: 1.1 },
            inspired: { rate: 1.0, depth: 1.3 },
            silly: { rate: 1.4, depth: 1.2 },
            sleepy: { rate: 0.3, depth: 1.4 }
        };
    }

    /**
     * Update breathing animation
     * @param {number} deltaTime - Time since last frame in ms
     * @param {string} emotion - Current emotion
     * @param {Object} undertone - Current undertone modifiers
     */
    update(deltaTime, emotion, undertone = {}) {
        // Ensure undertone is not null
        undertone = undertone || {};
        
        // Apply emotion-specific breathing pattern
        const pattern = this.emotionBreathPatterns[emotion] || { rate: 1.0, depth: 1.0 };
        
        // Apply undertone modifiers (safe access with null check)
        const undertoneRateMult = undertone?.breathRateMult || 1.0;
        const undertoneDepthMult = undertone?.breathDepthMult || 1.0;
        
        // Calculate final breathing parameters
        this.breathRate = pattern.rate * this.breathRateMult * undertoneRateMult;
        this.breathDepth = this.breathingDepth * pattern.depth * this.breathDepthMult * undertoneDepthMult;
        
        // Add irregularity if needed
        let phaseIncrement = this.breathingSpeed * this.breathRate * (deltaTime / 1000);
        if (this.breathIrregular && undertone?.breathIrregular) {
            phaseIncrement *= 0.8 + Math.sin(Date.now() * 0.0003) * 0.4;
        }
        
        // Update breathing phase
        this.breathingPhase += phaseIncrement;
        if (this.breathingPhase > Math.PI * 2) {
            this.breathingPhase -= Math.PI * 2;
        }
    }

    /**
     * Get current breathing scale
     * @returns {number} Scale factor for breathing
     */
    getBreathingScale() {
        // Return custom scale if set
        if (this.customScale !== null) {
            return this.customScale;
        }
        
        // Calculate breathing scale
        const breathAmount = Math.sin(this.breathingPhase);
        return 1 + breathAmount * this.breathDepth;
    }

    /**
     * Set custom breathing scale (overrides normal breathing)
     * @param {number} scale - Custom scale value, or null to use normal breathing
     */
    setCustomScale(scale) {
        this.customScale = scale;
    }

    /**
     * Set breathing speed
     * @param {number} speed - Breathing speed in radians per second
     */
    setBreathingSpeed(speed) {
        this.breathingSpeed = speed;
    }

    /**
     * Set breathing depth
     * @param {number} depth - Breathing depth as percentage (0-1)
     */
    setBreathingDepth(depth) {
        this.breathingDepth = Math.max(0, Math.min(1, depth));
    }

    /**
     * Set breathing rate multiplier
     * @param {number} mult - Rate multiplier
     */
    setBreathRateMultiplier(mult) {
        this.breathRateMult = mult;
    }

    /**
     * Set breathing depth multiplier
     * @param {number} mult - Depth multiplier
     */
    setBreathDepthMultiplier(mult) {
        this.breathDepthMult = mult;
    }

    /**
     * Enable/disable irregular breathing
     * @param {boolean} irregular - Whether breathing should be irregular
     */
    setIrregularBreathing(irregular) {
        this.breathIrregular = irregular;
    }

    /**
     * Reset breathing to default state
     */
    reset() {
        this.breathingPhase = 0;
        this.breathRate = 1.0;
        this.breathDepth = this.breathingDepth;
        this.breathRateMult = 1.0;
        this.breathDepthMult = 1.0;
        this.breathIrregular = false;
        this.customScale = null;
    }

    /**
     * Apply breath hold effect
     * @param {boolean} empty - Whether lungs are empty (true) or full (false)
     */
    holdBreath(empty = false) {
        // Set custom scale based on breath hold type
        this.customScale = empty ? 0.92 : 1.08;
    }

    /**
     * Release breath hold
     */
    releaseBreath() {
        this.customScale = null;
    }

    /**
     * Get breathing info for debugging
     * @returns {Object} Breathing state info
     */
    getBreathingInfo() {
        return {
            phase: this.breathingPhase,
            rate: this.breathRate,
            depth: this.breathDepth,
            scale: this.getBreathingScale(),
            isCustom: this.customScale !== null,
            isIrregular: this.breathIrregular
        };
    }
}

/**
 * Gradient Cache System
 * Caches canvas gradients to avoid recreating them every frame
 *
 * @module core/renderer/GradientCache
 * @version 1.0.0
 */

/**
 * Cache for canvas gradients to improve rendering performance
 */
class GradientCache {
    constructor() {
        // Cache storage with Map for efficient lookups
        this.cache = new Map();

        // Stats for monitoring
        this.stats = {
            hits: 0,
            misses: 0,
            evictions: 0
        };

        // Cache configuration
        this.maxSize = 100; // Maximum number of cached gradients
        this.ttl = 60000; // Time to live in milliseconds (1 minute)

        // LRU tracking
        this.accessOrder = [];
    }

    /**
     * Generate a unique key for gradient parameters
     * @private
     */
    generateKey(type, params) {
        if (type === 'radial') {
            const { x0, y0, r0, x1, y1, r1, stops } = params;
            const stopKey = stops.map(s => `${s.offset}:${s.color}`).join('|');
            return `radial:${x0},${y0},${r0},${x1},${y1},${r1}:${stopKey}`;
        } else if (type === 'linear') {
            const { x0, y0, x1, y1, stops } = params;
            const stopKey = stops.map(s => `${s.offset}:${s.color}`).join('|');
            return `linear:${x0},${y0},${x1},${y1}:${stopKey}`;
        }
        return null;
    }

    /**
     * Get or create a radial gradient
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x0 - Start circle center x
     * @param {number} y0 - Start circle center y
     * @param {number} r0 - Start circle radius
     * @param {number} x1 - End circle center x
     * @param {number} y1 - End circle center y
     * @param {number} r1 - End circle radius
     * @param {Array} stops - Color stops [{offset, color}]
     * @returns {CanvasGradient} Cached or new gradient
     */
    getRadialGradient(ctx, x0, y0, r0, x1, y1, r1, stops) {
        const key = this.generateKey('radial', { x0, y0, r0, x1, y1, r1, stops });

        // Check cache
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.ttl) {
            this.stats.hits++;
            this.updateAccessOrder(key);
            return cached.gradient;
        }

        // Create new gradient
        this.stats.misses++;
        const gradient = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);

        // Add color stops
        stops.forEach(stop => {
            gradient.addColorStop(stop.offset, stop.color);
        });

        // Cache it
        this.set(key, gradient);

        return gradient;
    }

    /**
     * Get or create a linear gradient
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x0 - Start point x
     * @param {number} y0 - Start point y
     * @param {number} x1 - End point x
     * @param {number} y1 - End point y
     * @param {Array} stops - Color stops [{offset, color}]
     * @returns {CanvasGradient} Cached or new gradient
     */
    getLinearGradient(ctx, x0, y0, x1, y1, stops) {
        const key = this.generateKey('linear', { x0, y0, x1, y1, stops });

        // Check cache
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.ttl) {
            this.stats.hits++;
            this.updateAccessOrder(key);
            return cached.gradient;
        }

        // Create new gradient
        this.stats.misses++;
        const gradient = ctx.createLinearGradient(x0, y0, x1, y1);

        // Add color stops
        stops.forEach(stop => {
            gradient.addColorStop(stop.offset, stop.color);
        });

        // Cache it
        this.set(key, gradient);

        return gradient;
    }

    /**
     * Store gradient in cache with LRU eviction
     * @private
     */
    set(key, gradient) {
        // Check if we need to evict
        if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
            this.evictLRU();
        }

        // Store with timestamp
        this.cache.set(key, {
            gradient,
            timestamp: Date.now()
        });

        this.updateAccessOrder(key);
    }

    /**
     * Update access order for LRU tracking
     * @private
     */
    updateAccessOrder(key) {
        // Remove from current position
        const index = this.accessOrder.indexOf(key);
        if (index > -1) {
            this.accessOrder.splice(index, 1);
        }
        // Add to end (most recently used)
        this.accessOrder.push(key);
    }

    /**
     * Evict least recently used item
     * @private
     */
    evictLRU() {
        if (this.accessOrder.length > 0) {
            const keyToEvict = this.accessOrder.shift();
            this.cache.delete(keyToEvict);
            this.stats.evictions++;
        }
    }

    /**
     * Clear all cached gradients
     */
    clear() {
        this.cache.clear();
        this.accessOrder = [];
    }

    /**
     * Clear expired entries
     */
    clearExpired() {
        const now = Date.now();
        const keysToDelete = [];

        for (const [key, value] of this.cache.entries()) {
            if (now - value.timestamp >= this.ttl) {
                keysToDelete.push(key);
            }
        }

        keysToDelete.forEach(key => {
            this.cache.delete(key);
            const index = this.accessOrder.indexOf(key);
            if (index > -1) {
                this.accessOrder.splice(index, 1);
            }
        });
    }

    /**
     * Get cache statistics
     * @returns {Object} Cache stats
     */
    getStats() {
        const hitRate = this.stats.hits + this.stats.misses > 0
            ? (this.stats.hits / (this.stats.hits + this.stats.misses) * 100).toFixed(2)
            : 0;

        return {
            size: this.cache.size,
            maxSize: this.maxSize,
            hits: this.stats.hits,
            misses: this.stats.misses,
            evictions: this.stats.evictions,
            hitRate: `${hitRate}%`
        };
    }

    /**
     * Create a gradient helper that automatically caches
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @returns {Object} Helper object with gradient methods
     */
    createHelper(ctx) {
        return {
            radial: (x0, y0, r0, x1, y1, r1, stops) =>
                this.getRadialGradient(ctx, x0, y0, r0, x1, y1, r1, stops),
            linear: (x0, y0, x1, y1, stops) =>
                this.getLinearGradient(ctx, x0, y0, x1, y1, stops)
        };
    }
}

// Create singleton instance
const gradientCache = new GradientCache();

/**
 * GlowRenderer - Handles glow effects rendering for EmotiveRenderer
 * @module core/renderer/GlowRenderer
 */


class GlowRenderer {
    constructor(renderer) {
        this.renderer = renderer;
        this.ctx = renderer.ctx;
        this.canvas = renderer.canvas;
        
        // Glow state
        this.glowIntensity = 1.0;
        this.glowColor = '#4a90e2';
        this.targetGlowColor = '#4a90e2';
        this.glowColorTransition = 0;
        this.glowColorTransitionSpeed = 0.05;
        
        // Offscreen canvas for caching glow gradients
        this.offscreenCanvas = null;
        this.offscreenCtx = null;
        this.cachedGlowColor = null;
        this.cachedGlowRadius = 0;
        
        // Helper method references
        this.scaleValue = (value) => renderer.scaleValue(value);
        this.hexToRgba = (hex, alpha) => renderer.hexToRgba(hex, alpha);
        
        this.initOffscreenCanvas();
    }

    /**
     * Initialize offscreen canvas for gradient caching
     */
    initOffscreenCanvas() {
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
    }

    /**
     * Update offscreen canvas size
     * @param {number} size - Size for the offscreen canvas
     */
    updateOffscreenSize(size) {
        if (this.offscreenCanvas.width !== size || this.offscreenCanvas.height !== size) {
            this.offscreenCanvas.width = size;
            this.offscreenCanvas.height = size;
            this.cachedGlowColor = null; // Invalidate cache
        }
    }

    /**
     * Render main glow effect
     * @param {number} x - Center X position
     * @param {number} y - Center Y position
     * @param {number} radius - Core radius
     * @param {Object} params - Additional parameters
     */
    renderGlow(x, y, radius, params = {}) {
        const ctx = this.ctx;
        const color = params.color || this.glowColor;
        const intensity = params.intensity !== undefined ? params.intensity : this.glowIntensity;
        
        // Skip if intensity is too low
        if (intensity < 0.01) return;
        
        // Outer glow size
        this.scaleValue(200);
        
        // Always use direct rendering for consistent brightness
        this.renderGlowDirect(ctx, x, y, radius, color, intensity);
        return;
    }

    /**
     * Cache glow gradient to offscreen canvas
     * @param {string} color - Glow color
     * @param {number} size - Glow size
     */
    cacheGlowGradient(color, size) {
        const offCtx = this.offscreenCtx;
        const center = size;
        
        // Update offscreen canvas size
        this.updateOffscreenSize(size * 2);
        
        // Clear offscreen canvas
        offCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
        
        // Use cached gradient - higher opacity to match original brightness
        const gradient = gradientCache.getRadialGradient(
            offCtx, center, center, 0, center, center, size,
            [
                { offset: 0, color: this.hexToRgba(color, 0.4) },
                { offset: 0.3, color: this.hexToRgba(color, 0.2) },
                { offset: 0.6, color: this.hexToRgba(color, 0.1) },
                { offset: 1, color: this.hexToRgba(color, 0) }
            ]
        );

        // Draw gradient to offscreen canvas
        offCtx.fillStyle = gradient;
        offCtx.fillRect(0, 0, size * 2, size * 2);
        
        // Update cache info
        this.cachedGlowColor = color;
        this.cachedGlowRadius = size;
    }

    /**
     * Direct glow rendering (fallback)
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {string} color - Glow color
     * @param {number} intensity - Glow intensity
     */
    renderGlowDirect(ctx, x, y, radius, color, intensity) {
        // Use the EXACT original formula for consistent brightness
        ctx.save();
        
        // Build gradient stops array
        const stops = 20;
        const gradientStops = [];
        for (let i = 0; i <= stops; i++) {
            const position = i / stops;
            const baseOpacity = 0.6 * Math.pow(1 - position, 2.2);
            const opacity = baseOpacity * intensity;
            gradientStops.push({ offset: position, color: this.hexToRgba(color, opacity) });
        }

        // Use cached gradient
        const gradient = gradientCache.getRadialGradient(
            ctx, x, y, 0, x, y, radius, gradientStops
        );
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    /**
     * Render recording glow effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {number} intensity - Glow intensity
     */
    renderRecordingGlow(x, y, radius, intensity) {
        const ctx = this.ctx;
        const glowSize = radius * 2.5;
        const gradient = gradientCache.getRadialGradient(
            ctx, x, y, 0, x, y, glowSize,
            [
                { offset: 0, color: `rgba(255, 0, 0, ${0.3 * intensity})` },
                { offset: 0.5, color: `rgba(255, 0, 0, ${0.15 * intensity})` },
                { offset: 1, color: 'rgba(255, 0, 0, 0)' }
            ]
        );
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = gradient;
        ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        ctx.restore();
    }

    /**
     * Render zen glow effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {number} time - Current time for animation
     */
    renderZenGlow(x, y, radius, time) {
        const ctx = this.ctx;
        const breathPhase = Math.sin(time * 0.001) * 0.5 + 0.5;
        const zenRadius = radius * (0.9 + breathPhase * 0.1);
        
        // Inner glow
        const gradient = gradientCache.getRadialGradient(
            ctx, x, y, 0, x, y, zenRadius,
            [
                { offset: 0, color: 'rgba(147, 112, 219, 0.8)' },
                { offset: 0.7, color: 'rgba(147, 112, 219, 0.3)' },
                { offset: 1, color: 'rgba(147, 112, 219, 0)' }
            ]
        );
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, zenRadius * 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    /**
     * Update glow color with transition
     * @param {string} targetColor - Target glow color
     * @param {number} deltaTime - Time since last frame
     */
    updateGlowColor(targetColor, deltaTime) {
        if (this.targetGlowColor !== targetColor) {
            this.targetGlowColor = targetColor;
            this.glowColorTransition = 0;
        }
        
        // Animate color transition
        if (this.glowColorTransition < 1) {
            this.glowColorTransition = Math.min(1, this.glowColorTransition + this.glowColorTransitionSpeed);
            this.glowColor = this.lerpColor(this.glowColor, this.targetGlowColor, this.glowColorTransition);
        }
    }

    /**
     * Lerp between two colors
     * @param {string} color1 - Start color
     * @param {string} color2 - End color
     * @param {number} t - Interpolation value (0-1)
     * @returns {string} Interpolated color
     */
    lerpColor(color1, color2, t) {
        // Convert hex to RGB
        const rgb1 = this.hexToRgb(color1);
        const rgb2 = this.hexToRgb(color2);
        
        // Interpolate
        const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);
        const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);
        const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);
        
        // Convert back to hex
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    /**
     * Convert hex color to RGB
     * @param {string} hex - Hex color
     * @returns {Object} RGB values
     */
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
    }

    /**
     * Set glow intensity
     * @param {number} intensity - Glow intensity (0-1)
     */
    setGlowIntensity(intensity) {
        this.glowIntensity = Math.max(0, Math.min(1, intensity));
    }

    /**
     * Set glow color instantly
     * @param {string} color - Glow color
     */
    setGlowColor(color) {
        this.glowColor = color;
        this.targetGlowColor = color;
        this.glowColorTransition = 1;
    }

    /**
     * Clean up resources
     */
    destroy() {
        this.offscreenCanvas = null;
        this.offscreenCtx = null;
        this.cachedGlowColor = null;
    }
}

/**
 * CoreRenderer - Handles core shape rendering for EmotiveRenderer
 * @module core/renderer/CoreRenderer
 */


class CoreRenderer {
    constructor(renderer) {
        this.renderer = renderer;
        this.ctx = renderer.ctx;
        this.canvas = renderer.canvas;
        
        // Core appearance
        this.coreColor = '#FFFFFF';
        this.coreOpacity = 1.0;
        this.coreBorderWidth = 0;
        this.coreBorderColor = null;
        
        // Shape state
        this.shapePoints = null;
        this.isMorphing = false;
        
        // Helper method references
        this.scaleValue = (value) => renderer.scaleValue(value);
        this.hexToRgba = (hex, alpha) => renderer.hexToRgba(hex, alpha);
    }

    /**
     * Render the main core shape
     * @param {number} x - Center X position
     * @param {number} y - Center Y position
     * @param {number} radius - Core radius
     * @param {Object} params - Rendering parameters
     */
    renderCore(x, y, radius, params = {}) {
        const ctx = this.ctx;
        
        // Extract parameters
        const scaleX = params.scaleX || 1;
        const scaleY = params.scaleY || 1;
        const rotation = params.rotation || 0;
        const opacity = params.opacity !== undefined ? params.opacity : this.coreOpacity;
        const color = params.color || this.coreColor;
        const shapePoints = params.shapePoints || this.shapePoints;
        
        ctx.save();
        
        // Apply transformations
        ctx.translate(x, y);
        if (rotation !== 0) {
            ctx.rotate(rotation);
        }
        ctx.scale(scaleX, scaleY);
        
        // Set core style
        ctx.fillStyle = this.hexToRgba(color, opacity);
        
        // Draw shape based on points or default circle
        if (shapePoints && shapePoints.length > 0) {
            this.drawMorphedShape(ctx, shapePoints, radius);
        } else {
            this.drawCircle(ctx, radius);
        }
        
        // Draw border if needed
        if (this.coreBorderWidth > 0 && this.coreBorderColor) {
            ctx.strokeStyle = this.coreBorderColor;
            ctx.lineWidth = this.scaleValue(this.coreBorderWidth);
            ctx.stroke();
        }
        
        ctx.restore();
    }

    /**
     * Draw drop shadow for depth
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} radius - Shape radius
     * @param {Array} shapePoints - Shape points
     */
    drawDropShadow(ctx, radius, shapePoints) {
        ctx.save();
        
        const shadowOffset = this.scaleValue(2);
        ctx.translate(0, shadowOffset);
        
        // Use simpler shadow for complex deformed shapes
        if (shapePoints && shapePoints.length > 32) {
            // Simple dark circle shadow when shape is complex
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.05, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Shadow gradient - dark center fading to transparent
            const shadowGradient = gradientCache.getRadialGradient(
                ctx, 0, 0, radius * 0.7, 0, 0, radius * 1.2,
                [
                    { offset: 0, color: 'rgba(0, 0, 0, 0.2)' },
                    { offset: 0.8, color: 'rgba(0, 0, 0, 0.1)' },
                    { offset: 1, color: 'rgba(0, 0, 0, 0)' }
                ]
            );

            ctx.fillStyle = shadowGradient;
            ctx.beginPath();
            if (shapePoints) {
                // Scale points for shadow
                const scale = 1.1;
                const step = shapePoints.length > 20 ? 2 : 1;
                ctx.moveTo(shapePoints[0].x * scale, shapePoints[0].y * scale);
                for (let i = step; i < shapePoints.length; i += step) {
                    ctx.lineTo(shapePoints[i].x * scale, shapePoints[i].y * scale);
                }
                ctx.closePath();
            } else {
                ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
            }
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    /**
     * Draw a simple circle
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} radius - Circle radius
     */
    drawCircle(ctx, radius) {
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * Draw a morphed shape from points
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Array} points - Shape points
     * @param {number} baseRadius - Base radius for scaling
     */
    drawMorphedShape(ctx, points, baseRadius) {
        if (!points || points.length < 3) {
            // Fallback to circle if not enough points
            this.drawCircle(ctx, baseRadius);
            return;
        }
        
        ctx.beginPath();
        
        // Points from getCanvasPoints are already in canvas coordinates
        // relative to the center (0,0) after translation
        points.forEach((point, i) => {
            if (i === 0) {
                ctx.moveTo(point.x, point.y);
            } else {
                ctx.lineTo(point.x, point.y);
            }
        });
        
        ctx.closePath();
        ctx.fill();
    }

    /**
     * Render zen core effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {number} time - Current time for animation
     */
    renderZenCore(x, y, radius, time) {
        const ctx = this.ctx;
        
        // Zen breathing effect
        const breathPhase = Math.sin(time * 0.001) * 0.5 + 0.5;
        const zenRadius = radius * (0.95 + breathPhase * 0.05);
        
        // Draw zen core with subtle inner glow
        ctx.save();
        
        // Inner shadow for depth
        ctx.shadowBlur = this.scaleValue(10);
        ctx.shadowColor = 'rgba(147, 112, 219, 0.3)';
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Main core
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(x, y, zenRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner ring
        ctx.strokeStyle = 'rgba(147, 112, 219, 0.2)';
        ctx.lineWidth = this.scaleValue(1);
        ctx.beginPath();
        ctx.arc(x, y, zenRadius * 0.9, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
    }

    /**
     * Render sleepy core effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     */
    renderSleepyCore(x, y, radius) {
        const ctx = this.ctx;
        
        // Slightly squished for sleepy look
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1, 0.85);
        
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    /**
     * Render glitched core effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {number} glitchIntensity - Glitch intensity (0-1)
     */
    renderGlitchedCore(x, y, radius, glitchIntensity) {
        const ctx = this.ctx;
        
        // Draw multiple offset cores for glitch effect
        const offsets = [
            { x: -2, y: 0, alpha: 0.3 },
            { x: 2, y: 0, alpha: 0.3 },
            { x: 0, y: -1, alpha: 0.2 }
        ];
        
        ctx.save();
        
        offsets.forEach(offset => {
            ctx.fillStyle = this.hexToRgba('#FFFFFF', offset.alpha * glitchIntensity);
            ctx.beginPath();
            ctx.arc(
                x + offset.x * glitchIntensity * this.scaleValue(5),
                y + offset.y * glitchIntensity * this.scaleValue(5),
                radius,
                0,
                Math.PI * 2
            );
            ctx.fill();
        });
        
        // Main core
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    /**
     * Set shape points for morphing
     * @param {Array} points - Array of normalized points
     */
    setShapePoints(points) {
        this.shapePoints = points;
        this.isMorphing = points && points.length > 0;
    }

    /**
     * Clear shape points (return to circle)
     */
    clearShapePoints() {
        this.shapePoints = null;
        this.isMorphing = false;
    }

    /**
     * Set core color
     * @param {string} color - Core color
     */
    setCoreColor(color) {
        this.coreColor = color;
    }

    /**
     * Set core opacity
     * @param {number} opacity - Core opacity (0-1)
     */
    setCoreOpacity(opacity) {
        this.coreOpacity = Math.max(0, Math.min(1, opacity));
    }

    /**
     * Set core border
     * @param {number} width - Border width
     * @param {string} color - Border color
     */
    setCoreBorder(width, color) {
        this.coreBorderWidth = width;
        this.coreBorderColor = color;
    }

    /**
     * Get core rendering info
     * @returns {Object} Core state info
     */
    getCoreInfo() {
        return {
            color: this.coreColor,
            opacity: this.coreOpacity,
            hasBorder: this.coreBorderWidth > 0,
            isMorphing: this.isMorphing,
            shapePointCount: this.shapePoints ? this.shapePoints.length : 0
        };
    }
}

/**
 * RotationBrake - Simple braking system using DEGREES like the working demo
 * @module core/animation/RotationBrake
 */

class RotationBrake {
    constructor(renderer) {
        this.renderer = renderer;

        // Braking state - EXACTLY like the demo
        this.brakeStartTime = null;
        this.brakeDuration = 2500; // Will be calculated dynamically
        this.brakeStartRotation = 0;
        this.brakeTargetRotation = 0;
        this.brakeStartVelocity = 0;

        // Callbacks
        this.onComplete = null;
        this.onProgress = null;

        // Constants
        this.DURATION_FACTOR = 14; // Tuned for natural deceleration feel
    }

    /**
     * Brake to upright position (0 degrees)
     * @param {Object} options - Brake options
     * @returns {Promise} Resolves when braking complete
     */
    brakeToUpright(options = {}) {
        return this.brakeToTarget(0, options);
    }

    /**
     * Brake to nearest multiple of given angle
     * @param {number} angleStep - Angle step in DEGREES (e.g., 90 for 90°)
     * @param {Object} options - Brake options
     * @returns {Promise} Resolves when braking complete
     */
    brakeToNearest(angleStep, options = {}) {
        const currentAngle = this.renderer.state.manualRotation || 0;
        const steps = Math.round(currentAngle / angleStep);
        const targetAngle = steps * angleStep;
        return this.brakeToTarget(targetAngle, options);
    }

    /**
     * Brake to specific target angle
     * @param {number} targetAngle - Target angle in DEGREES (0 = upright)
     * @param {Object} options - Brake options
     * @returns {Promise} Resolves when braking complete
     */
    brakeToTarget(targetAngle, options = {}) {
        return new Promise((resolve) => {
            const {
                onProgress = null,
                onComplete = null
            } = options;

            this.onProgress = onProgress;
            this.onComplete = onComplete;

            // Get current state - ALL IN DEGREES
            const currentVelocity = this.renderer.state.rotationSpeed || 0;
            const rotation = this.renderer.state.manualRotation || 0;

            // Do nothing if not moving or already braking
            if (currentVelocity === 0 || this.brakeStartTime) {
                resolve();
                return;
            }

            // Initialize braking state
            this.brakeStartTime = performance.now();
            this.brakeStartRotation = rotation;
            this.brakeStartVelocity = currentVelocity;

            // Calculate the nearest upright target rotation
            if (targetAngle === 0) {
                // Special case for upright
                if (currentVelocity > 0) { // Spinning clockwise
                    this.brakeTargetRotation = (Math.floor(rotation / 360) + 1) * 360;
                } else { // Spinning counter-clockwise
                    this.brakeTargetRotation = Math.floor(rotation / 360) * 360;
                }
            } else {
                // General case
                const normalizedTarget = targetAngle % 360;
                const baseCycles = Math.floor(rotation / 360);

                if (currentVelocity > 0) {
                    if (normalizedTarget > (rotation % 360)) {
                        this.brakeTargetRotation = baseCycles * 360 + normalizedTarget;
                    } else {
                        this.brakeTargetRotation = (baseCycles + 1) * 360 + normalizedTarget;
                    }
                } else {
                    if (normalizedTarget < (rotation % 360)) {
                        this.brakeTargetRotation = baseCycles * 360 + normalizedTarget;
                    } else {
                        this.brakeTargetRotation = (baseCycles - 1) * 360 + normalizedTarget;
                    }
                }
            }

            // DYNAMIC DURATION CALCULATION - EXACTLY like the demo
            const angleToTravel = Math.abs(this.brakeTargetRotation - this.brakeStartRotation);
            this.brakeDuration = Math.max(500, (angleToTravel / Math.abs(currentVelocity)) * this.DURATION_FACTOR * 5);

            console.log('Brake started:', {
                from: rotation.toFixed(1) + '°',
                to: this.brakeTargetRotation.toFixed(1) + '°',
                velocity: currentVelocity,
                duration: this.brakeDuration.toFixed(0) + 'ms'
            });

            // Stop adding velocity immediately
            this.renderer.setRotationSpeed(0);

            this.resolvePromise = resolve;
        });
    }

    /**
     * Update brake state - called by renderer each frame
     * @param {number} currentTime - Current timestamp from requestAnimationFrame
     * @returns {Object|null} - Rotation update or null if not braking
     */
    updateBrake(currentTime) {
        if (!this.brakeStartTime) {
            return null; // Not braking
        }

        const elapsed = currentTime - this.brakeStartTime;
        const progress = Math.min(elapsed / this.brakeDuration, 1);

        // Ease-out quartic for smooth deceleration (starts fast, ends slow)
        const easedProgress = 1 - Math.pow(1 - progress, 4);

        // Calculate new rotation based on eased progress
        const rotation = this.brakeStartRotation +
            (this.brakeTargetRotation - this.brakeStartRotation) * easedProgress;

        // Calculate virtual speed for UI (decreases with progress)
        const virtualSpeed = this.brakeStartVelocity * Math.pow(1 - easedProgress, 2);

        // Progress callback
        if (this.onProgress) {
            this.onProgress(easedProgress, virtualSpeed, rotation);
        }

        if (progress >= 1) {
            // Stop the animation when braking is complete
            this.brakeStartTime = null;

            console.log('Brake complete:', {
                target: this.brakeTargetRotation.toFixed(1) + '°',
                duration: elapsed.toFixed(0) + 'ms'
            });

            this.complete();

            // Return final position
            return {
                rotation: this.brakeTargetRotation,
                speed: 0,
                complete: true
            };
        }

        // Continue braking
        return {
            rotation: rotation,
            speed: virtualSpeed,
            complete: false
        };
    }

    /**
     * Stop any active braking
     */
    stop() {
        this.brakeStartTime = null;
    }

    /**
     * Complete the braking operation
     * @private
     */
    complete() {
        if (this.onComplete) {
            this.onComplete();
        }

        if (this.resolvePromise) {
            this.resolvePromise();
            this.resolvePromise = null;
        }
    }

    /**
     * Check if currently braking
     * @returns {boolean}
     */
    isBraking() {
        return this.brakeStartTime !== null;
    }

    /**
     * Emergency stop - immediately halt rotation
     */
    emergencyStop() {
        this.stop();
        this.renderer.setRotationSpeed(0);
        this.complete();
    }

    /**
     * Get current brake progress
     * @returns {number} Progress from 0 to 1
     */
    getProgress() {
        if (!this.brakeStartTime) return 0;
        const elapsed = performance.now() - this.brakeStartTime;
        return Math.min(elapsed / this.brakeDuration, 1);
    }
}

/**
 * AmbientDanceAnimator - Connects ambient dance gestures to the renderer
 * Bridges the GestureBlender output with the actual rendering system
 */

class AmbientDanceAnimator {
    constructor(renderer) {
        this.renderer = renderer;

        // Animation states for ambient gestures
        this.animations = {
            grooveSway: null,
            grooveBob: null,
            grooveFlow: null,
            groovePulse: null,
            grooveStep: null
        };

        // Current active animation
        this.activeAnimation = null;

        // Blend state from GestureBlender
        this.blendState = {
            x: 0,
            y: 0,
            rotation: 0,
            scale: 1,
            opacity: 1
        };
    }

    /**
     * Start an ambient dance animation
     * @param {string} animationName - Name of the ambient gesture
     * @param {Object} options - Animation options
     */
    startAmbientAnimation(animationName, options = {}) {
        // Stop previous animation
        if (this.activeAnimation && this.activeAnimation !== animationName) {
            this.stopAmbientAnimation(this.activeAnimation);
        }

        this.activeAnimation = animationName;
        this.animations[animationName] = {
            startTime: Date.now(),
            intensity: options.intensity || 1.0,
            frequency: options.frequency || 1.0,
            options: options
        };
    }

    /**
     * Stop an ambient animation
     */
    stopAmbientAnimation(animationName) {
        if (this.animations[animationName]) {
            this.animations[animationName] = null;
        }
        if (this.activeAnimation === animationName) {
            this.activeAnimation = null;
        }
    }

    /**
     * Update blend state from GestureBlender
     */
    updateBlendState(blendState) {
        if (!blendState) return;

        // Smooth interpolation
        const lerpFactor = 0.2;
        this.blendState.x = this.lerp(this.blendState.x, blendState.x || 0, lerpFactor);
        this.blendState.y = this.lerp(this.blendState.y, blendState.y || 0, lerpFactor);
        this.blendState.rotation = this.lerp(this.blendState.rotation, blendState.rotation || 0, lerpFactor);
        this.blendState.scale = this.lerp(this.blendState.scale, blendState.scale || 1, lerpFactor);
        this.blendState.opacity = this.lerp(this.blendState.opacity, blendState.opacity || 1, lerpFactor);
    }

    /**
     * Get current animation transform
     */
    getTransform(deltaTime) {
        const transform = {
            x: this.blendState.x,
            y: this.blendState.y,
            rotation: this.blendState.rotation,
            scale: this.blendState.scale,
            opacity: this.blendState.opacity
        };

        // Apply active animation on top
        if (this.activeAnimation) {
            const animation = this.animations[this.activeAnimation];
            if (animation) {
                const elapsed = Date.now() - animation.startTime;

                switch (this.activeAnimation) {
                    case 'grooveSway':
                        transform.x += Math.sin(elapsed / 500 * animation.frequency) * 15 * animation.intensity;
                        transform.rotation += Math.sin(elapsed / 500 * animation.frequency + Math.PI/4) * 5 * animation.intensity;
                        break;

                    case 'grooveBob':
                        transform.y += Math.sin(elapsed / 400 * animation.frequency) * 10 * animation.intensity;
                        transform.scale *= 1 + Math.sin(elapsed / 400 * animation.frequency) * 0.03 * animation.intensity;
                        break;

                    case 'grooveFlow':
                        const t = elapsed / 1000 * animation.frequency;
                        transform.x += Math.sin(t) * Math.cos(t * 2) * 20 * animation.intensity;
                        transform.y += Math.cos(t) * Math.sin(t * 2) * 10 * animation.intensity;
                        transform.rotation += Math.sin(t * 2) * 8 * animation.intensity;
                        break;

                    case 'groovePulse':
                        transform.scale *= 1 + Math.sin(elapsed / 250 * animation.frequency) * 0.05 * animation.intensity;
                        transform.opacity *= 0.9 + Math.sin(elapsed / 250 * animation.frequency) * 0.1 * animation.intensity;
                        break;

                    case 'grooveStep':
                        const stepPhase = Math.floor(elapsed / 500 * animation.frequency) % 4;
                        const stepProgress = (elapsed / 500 * animation.frequency) % 1;
                        const smoothStep = this.smoothStep(stepProgress);

                        if (stepPhase === 0) transform.x += smoothStep * 25 * animation.intensity;
                        else if (stepPhase === 2) transform.x -= smoothStep * 25 * animation.intensity;

                        transform.y += Math.abs(Math.sin(elapsed / 250 * animation.frequency)) * 5 * animation.intensity;
                        break;
                }
            }
        }

        return transform;
    }

    /**
     * Linear interpolation
     */
    lerp(a, b, t) {
        return a + (b - a) * t;
    }

    /**
     * Smooth step function
     */
    smoothStep(t) {
        return t * t * (3 - 2 * t);
    }
}

/**
 * Animation Loop Manager
 * Consolidates all requestAnimationFrame calls into a single, efficient loop
 *
 * @module core/AnimationLoopManager
 * @version 1.0.0
 */

/**
 * Priority levels for animations
 * @enum {number}
 */
const AnimationPriority = {
    CRITICAL: 0,    // Must run every frame (e.g., main render)
    HIGH: 1,        // Should run every frame if possible
    MEDIUM: 2,      // Can skip frames if needed
    LOW: 3,         // Background tasks, can be throttled
    IDLE: 4         // Only run when idle
};

/**
 * Centralized animation loop manager
 * Replaces multiple requestAnimationFrame calls with a single, optimized loop
 */
class AnimationLoopManager {
    constructor() {
        // Animation callbacks organized by priority
        this.callbacks = new Map();
        this.callbackIdCounter = 0;

        // Frame timing
        this.frameId = null;
        this.isRunning = false;
        this.lastFrameTime = 0;
        this.deltaTime = 0;
        this.fps = 60;
        this.frameCount = 0;

        // Performance
        this.targetFPS = 60;
        this.targetFrameTime = 1000 / this.targetFPS;
        this.frameBudget = 16.67; // ms

        // Frame skipping for low priority
        this.prioritySkipCounters = {
            [AnimationPriority.MEDIUM]: 0,
            [AnimationPriority.LOW]: 0,
            [AnimationPriority.IDLE]: 0
        };

        // Performance monitoring
        this.performanceMonitor = null;
        this.frameTimeHistory = [];
        this.maxHistorySize = 60;

        // Bind methods
        this.loop = this.loop.bind(this);
    }

    /**
     * Register an animation callback
     * @param {Function} callback - Function to call each frame (receives deltaTime, timestamp)
     * @param {number} priority - Priority level from AnimationPriority enum
     * @param {Object} context - Optional context for callback
     * @returns {number} Callback ID for later removal
     */
    register(callback, priority = AnimationPriority.MEDIUM, context = null) {
        if (typeof callback !== 'function') {
            throw new Error('Callback must be a function');
        }

        const id = ++this.callbackIdCounter;

        // Store callback with metadata
        this.callbacks.set(id, {
            callback,
            priority,
            context,
            lastRun: 0,
            runCount: 0,
            totalTime: 0,
            enabled: true
        });

        // Auto-start if this is the first callback
        if (this.callbacks.size === 1 && !this.isRunning) {
            this.start();
        }

        return id;
    }

    /**
     * Unregister an animation callback
     * @param {number} id - Callback ID returned from register()
     */
    unregister(id) {
        this.callbacks.delete(id);

        // Auto-stop if no callbacks remain
        if (this.callbacks.size === 0 && this.isRunning) {
            this.stop();
        }
    }

    /**
     * Enable/disable a callback without removing it
     * @param {number} id - Callback ID
     * @param {boolean} enabled - Whether to enable or disable
     */
    setEnabled(id, enabled) {
        const callback = this.callbacks.get(id);
        if (callback) {
            callback.enabled = enabled;
        }
    }

    /**
     * Start the animation loop
     */
    start() {
        if (this.isRunning) return;

        this.isRunning = true;
        this.lastFrameTime = performance.now();
        this.frameId = requestAnimationFrame(this.loop);
    }

    /**
     * Stop the animation loop
     */
    stop() {
        if (!this.isRunning) return;

        this.isRunning = false;
        if (this.frameId) {
            cancelAnimationFrame(this.frameId);
            this.frameId = null;
        }
    }

    /**
     * Main animation loop
     * @param {number} timestamp - Current timestamp from requestAnimationFrame
     */
    loop(timestamp) {
        if (!this.isRunning) return;

        // Calculate delta time
        this.deltaTime = timestamp - this.lastFrameTime;
        this.lastFrameTime = timestamp;

        // Update FPS
        this.frameCount++;
        if (this.frameCount % 60 === 0) {
            this.fps = Math.round(1000 / (this.deltaTime || 16.67));
        }

        // Track frame time
        this.frameTimeHistory.push(this.deltaTime);
        if (this.frameTimeHistory.length > this.maxHistorySize) {
            this.frameTimeHistory.shift();
        }

        // Performance marker start
        const frameStartTime = performance.now();

        // Group callbacks by priority
        const callbacksByPriority = this.groupCallbacksByPriority();

        // Execute callbacks by priority
        let timeSpent = 0;

        for (const priority of [
            AnimationPriority.CRITICAL,
            AnimationPriority.HIGH,
            AnimationPriority.MEDIUM,
            AnimationPriority.LOW,
            AnimationPriority.IDLE
        ]) {
            // Check frame budget (except for CRITICAL)
            if (priority > AnimationPriority.CRITICAL && timeSpent > this.frameBudget * 0.8) {
                break; // Skip lower priorities if running out of time
            }

            // Check if we should skip this priority level
            if (this.shouldSkipPriority(priority)) {
                continue;
            }

            // Execute callbacks at this priority
            const callbacks = callbacksByPriority.get(priority) || [];

            for (const callbackData of callbacks) {
                if (!callbackData.enabled) continue;

                const callbackStart = performance.now();

                try {
                    // Call with context if provided
                    if (callbackData.context) {
                        callbackData.callback.call(callbackData.context, this.deltaTime, timestamp);
                    } else {
                        callbackData.callback(this.deltaTime, timestamp);
                    }

                    // Track performance
                    const callbackTime = performance.now() - callbackStart;
                    callbackData.totalTime += callbackTime;
                    callbackData.runCount++;
                    callbackData.lastRun = timestamp;
                    timeSpent += callbackTime;

                } catch (error) {
                    console.error('Animation callback error:', error);
                    // Disable problematic callbacks
                    if (callbackData.runCount > 0 && callbackData.totalTime / callbackData.runCount > 10) {
                        console.warn('Disabling slow callback');
                        callbackData.enabled = false;
                    }
                }

                // Break if spending too much time
                if (timeSpent > this.frameBudget) {
                    break;
                }
            }
        }

        // Performance marker end
        const frameTime = performance.now() - frameStartTime;

        // Warn if frame took too long
        if (frameTime > this.frameBudget * 1.5) {
            console.warn(`Frame took ${frameTime.toFixed(2)}ms (target: ${this.frameBudget}ms)`);
        }

        // Schedule next frame
        this.frameId = requestAnimationFrame(this.loop);
    }

    /**
     * Group callbacks by priority for efficient execution
     * @returns {Map} Map of priority to callback arrays
     */
    groupCallbacksByPriority() {
        const groups = new Map();

        for (const [id, callbackData] of this.callbacks) {
            const priority = callbackData.priority;

            if (!groups.has(priority)) {
                groups.set(priority, []);
            }

            groups.get(priority).push(callbackData);
        }

        return groups;
    }

    /**
     * Determine if we should skip a priority level this frame
     * @param {number} priority - Priority level to check
     * @returns {boolean} True if should skip
     */
    shouldSkipPriority(priority) {
        // Never skip critical
        if (priority === AnimationPriority.CRITICAL) return false;

        // Skip based on frame rate
        if (this.fps < 30 && priority >= AnimationPriority.LOW) return true;
        if (this.fps < 45 && priority === AnimationPriority.IDLE) return true;

        // Frame skipping for lower priorities
        if (priority === AnimationPriority.MEDIUM) {
            // Run every 2nd frame if FPS is low
            if (this.fps < 50) {
                this.prioritySkipCounters[priority]++;
                if (this.prioritySkipCounters[priority] % 2 !== 0) return true;
            }
        } else if (priority === AnimationPriority.LOW) {
            // Run every 3rd frame if FPS is low
            if (this.fps < 50) {
                this.prioritySkipCounters[priority]++;
                if (this.prioritySkipCounters[priority] % 3 !== 0) return true;
            }
        } else if (priority === AnimationPriority.IDLE) {
            // Run every 5th frame
            this.prioritySkipCounters[priority]++;
            if (this.prioritySkipCounters[priority] % 5 !== 0) return true;
        }

        return false;
    }

    /**
     * Get performance statistics
     * @returns {Object} Performance stats
     */
    getStats() {
        const stats = {
            fps: this.fps,
            frameCount: this.frameCount,
            callbackCount: this.callbacks.size,
            averageFrameTime: 0,
            maxFrameTime: 0,
            minFrameTime: Infinity
        };

        // Calculate frame time stats
        if (this.frameTimeHistory.length > 0) {
            let total = 0;
            for (const time of this.frameTimeHistory) {
                total += time;
                stats.maxFrameTime = Math.max(stats.maxFrameTime, time);
                stats.minFrameTime = Math.min(stats.minFrameTime, time);
            }
            stats.averageFrameTime = total / this.frameTimeHistory.length;
        }

        // Get callback stats by priority
        stats.callbacksByPriority = {};
        for (const [id, callback] of this.callbacks) {
            const priority = callback.priority;
            if (!stats.callbacksByPriority[priority]) {
                stats.callbacksByPriority[priority] = {
                    count: 0,
                    totalTime: 0,
                    enabled: 0
                };
            }
            stats.callbacksByPriority[priority].count++;
            stats.callbacksByPriority[priority].totalTime += callback.totalTime;
            if (callback.enabled) stats.callbacksByPriority[priority].enabled++;
        }

        return stats;
    }

    /**
     * Set target FPS
     * @param {number} fps - Target frames per second
     */
    setTargetFPS(fps) {
        this.targetFPS = Math.max(15, Math.min(120, fps));
        this.targetFrameTime = 1000 / this.targetFPS;
        this.frameBudget = this.targetFrameTime;
    }

    /**
     * Set performance monitor
     * @param {PerformanceMonitor} monitor - Performance monitor instance
     */
    setPerformanceMonitor(monitor) {
        this.performanceMonitor = monitor;
    }

    /**
     * Destroy and cleanup
     */
    destroy() {
        this.stop();
        this.callbacks.clear();
        this.frameTimeHistory = [];
    }
}

// Create singleton instance
const animationLoopManager = new AnimationLoopManager();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  EMOTIVE RENDERER  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Emotive Renderer - Visual Rendering Engine
 * @author Emotive Engine Team
 * @version 2.4.0
 * @module EmotiveRenderer
 * @changelog 2.4.0 - Added offscreen canvas caching for glow gradients
 * @changelog 2.3.0 - Optimized color transitions to use main render loop
 * @changelog 2.2.0 - Dynamic visual resampling on resize for consistent quality
 * @changelog 2.1.0 - Implemented undertone saturation system for glow colors
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The VISUAL ARTIST of the Emotive Engine. Renders the iconic orb with its          
 * ║ glowing core, breathing animation, eye expressions, and gesture animations.       
 * ║ Creates the minimalist yet expressive visual that defines Emotive.                
 * ║                                                                                    
 * ║ NEW: Undertone saturation creates visual depth by adjusting glow color            
 * ║ saturation based on emotional intensity (intense→electric, subdued→ghostly)       
 * ║ NEW: Dynamic visual resampling ensures consistent quality at any canvas size      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 VISUAL COMPONENTS                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • White Core      : The solid center orb (#FFFFFF)                                
 * │ • Colored Glow    : Emotional aura surrounding the core                           
 * │ • Eye Shape       : Arc-based expressions (happiness, sadness, focus)             
 * │ • Breathing       : Subtle size pulsation for life-like quality                   
 * │ • Gesture Motion  : Position, scale, and rotation animations                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 RENDERING PIPELINE                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ 1. Clear canvas or apply motion blur                                              
 * │ 2. Calculate breathing scale factor                                               
 * │ 3. Apply gesture transformations (position, scale, rotation)                      
 * │ 4. Draw colored glow layers (3 gradient circles)                                  
 * │ 5. Draw white core circle                                                         
 * │ 6. Draw eye expression if not neutral                                             
 * │ 7. Apply special effects (jitter, zen morph, etc.)                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚙️  CONFIGURABLE PROPERTIES                                                       
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • coreSizeDivisor  : Orb size relative to canvas (default: 12)                    
 * │ • glowMultiplier   : Glow radius vs core (default: 2.5x)                          
 * │ • breathingSpeed   : Breaths per minute (default: 16)                             
 * │ • breathingDepth   : Scale variation % (default: 8%)                              
 * │ • renderingStyle   : 'classic' | 'soft' | 'sharp'                                 
 * │ • referenceSize    : Reference canvas size for scaling (default: 400)             
 * │ • baseScale        : Global scale multiplier (default: 1.0)                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 👁️ EYE EXPRESSION SYSTEM                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Openness    : 0.0 (closed) to 1.0 (fully open)                                  
 * │ • Arc         : -1.0 (sad ∩) to 1.0 (happy ∪)                                    
 * │ • Asymmetry   : Different shapes for left/right eyes                              
 * │ • Blinking    : Smooth open/close animations                                      
 * │ • Zen Morph   : Special ∩∩ shape for meditation                                   
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ PERFORMANCE CRITICAL                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ Gradient caching     → Recreating gradients kills FPS                          
 * │ ✗ Canvas save/restore  → Excessive use causes slowdown                           
 * │ ✗ Clear rect timing    → Motion blur depends on this                             
 * │ ✗ Animation frame IDs  → Must track to prevent memory leaks                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class EmotiveRenderer {
    constructor(canvasManager, options = {}) {
        this.canvasManager = canvasManager;
        this.ctx = canvasManager.getContext();
        
        // Gesture compositor for emotion/undertone modulation
        this.gestureCompositor = new GestureCompositor();
        
        // Initialize current undertone
        this.currentUndertone = null;
        
        // Initialize modular components
        this.gestureAnimator = new GestureAnimator(this);
        this.colorUtilities = new ColorUtilities();
        this.specialEffects = new SpecialEffects(this);
        this.eyeRenderer = new EyeRenderer(this);
        this.breathingAnimator = new BreathingAnimator(this);
        this.glowRenderer = new GlowRenderer(this);
        this.coreRenderer = new CoreRenderer(this);
        this.rotationBrake = new RotationBrake(this);
        this.ambientDanceAnimator = new AmbientDanceAnimator(this);

        // Configuration - matching original Emotive proportions
        this.config = {
            coreColor: options.coreColor || '#FFFFFF',
            coreSizeDivisor: options.coreSizeDivisor || 12,  // Core radius = min(width,height) / 12
            glowMultiplier: options.glowMultiplier || 2.5,   // Glow radius = core radius * 2.5
            defaultGlowColor: options.defaultGlowColor || '#14B8A6',  // Teal
            breathingSpeed: options.breathingSpeed || 0.42,  // 16 breaths/min (0.42 rad/s = 4 sec/cycle = 15-16 bpm)
            breathingDepth: options.breathingDepth || 0.08,  // 8% size variation for visible breathing
            renderingStyle: options.renderingStyle || 'classic',
            baseScale: options.baseScale || 1.0,  // Global scale multiplier for entire system
            referenceSize: 400,  // Reference canvas size for scale calculations
            topOffset: options.topOffset || 0  // Vertical offset to align with layout
        };
        
        // Initialize scaleFactor based on current canvas size
        const canvasSize = Math.min(
            this.canvasManager.width || 400, 
            this.canvasManager.height || 400
        );
        this.scaleFactor = (canvasSize / this.config.referenceSize) * this.config.baseScale;
        
        // State
        this.state = {
            emotion: 'neutral',
            glowColor: this.config.defaultGlowColor,
            glowIntensity: 1.0,
            breathRate: 1.0,
            breathDepth: this.config.breathingDepth,
            coreJitter: false,
            speaking: false,
            recording: false,
            sleeping: false,
            blinking: false,
            blinkingEnabled: true,  // Add flag to control blinking
            gazeOffset: { x: 0, y: 0 },
            gazeIntensity: 0,
            gazeLocked: false,
            gazeTrackingEnabled: false,  // Whether to track mouse/touch
            gazeTarget: { x: 0, y: 0 },  // Target position for gaze (-1 to 1)
            zenVortexIntensity: 1.0,  // Adjustable whirlpool intensity for zen
            // Suspicion state
            squintAmount: 0,         // 0-1, how much the eye is narrowed
            targetSquintAmount: 0,   // Target squint amount to animate to
            scanPhase: 0,            // Current phase of scanning animation
            lastScanTime: 0,         // Last time we did a scan
            isSuspicious: false,     // Track if we're in suspicion mode
            // Custom scale for breathing
            customScale: null,       // When set, overrides normal breathing scale
            // Undertone modifiers - initialize with defaults
            sizeMultiplier: 1.0,
            jitterAmount: 0,
            episodicFlutter: false,
            glowRadiusMult: 1.0,
            breathRateMult: 1.0,
            breathDepthMult: 1.0,
            breathIrregular: false,
            particleRateMult: 1.0,
            // Manual rotation control (not BPM-locked)
            manualRotation: 0,        // Current rotation angle in DEGREES
            rotationSpeed: 0,         // Rotation speed in DEGREES per frame (like velocity in demo)
            lastRotationUpdate: performance.now()
        };
        
        // Animation state (now delegated to modules)
        // Breathing is handled by BreathingAnimator
        // Blinking is handled by EyeRenderer
        
        // Track animation frame IDs to prevent memory leaks
        this.animationFrameIds = {
            colorTransition: null,
            eyeClose: null,
            eyeOpen: null,
            zenEnter: null,
            zenExit: null
        };

        // Track loop manager callback IDs
        this.loopCallbackIds = {
            eyeClose: null,
            eyeOpen: null,
            zenEnter: null,
            zenExit: null
        };
        
        // Offscreen canvas for double buffering
        this.offscreenCanvas = null;
        this.offscreenCtx = null;
        this.initOffscreenCanvas();

        // Store canvas reference for gaze tracking
        this.canvas = canvasManager.canvas;
        
        // Cache for expensive gradients
        this.glowCache = new Map();
        this.maxCacheSize = 10;
        
        // Gesture animations
        this.gestureAnimations = {
            bounce: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            pulse: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            shake: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            spin: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            nod: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            tilt: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            expand: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            contract: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            flash: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            drift: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null,
                startX: 0,
                startY: 0
            },
            stretch: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            glow: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            flicker: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            vibrate: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            wave: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathe: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            morph: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            slowBlink: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            look: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null,
                targetX: 0,
                targetY: 0
            },
            settle: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathIn: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathOut: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathHold: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathHoldEmpty: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            jump: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            orbital: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            hula: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            }
        };
        
        // Episodic effects for undertones
        this.episodicEffects = {
            nervous: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 3000 + Math.random() * 2000 // 3-5 seconds
            },
            confident: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 4000 + Math.random() * 2000 // 4-6 seconds
            },
            tired: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 5000 + Math.random() * 2000 // 5-7 seconds
            },
            intense: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 3000 + Math.random() * 3000 // 3-6 seconds
            },
            subdued: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 4000 + Math.random() * 3000 // 4-7 seconds
            }
        };
        
        // Speaking animation
        this.speakingRings = [];
        this.maxRings = 5;
        this.ringSpawnTimer = 0;
        this.ringSpawnInterval = 200; // ms between rings
        
        // Recording animation (rings move inward)
        this.recordingRings = [];
        this.recordingPulse = 0;
        
        // Sleep state - consolidated here for visualization
        this.sleepZ = [];
        
        // Zen state animation
        this.zenTransition = {
            active: false,
            phase: null, // 'entering', 'in', 'exiting'
            startTime: 0,
            previousEmotion: null,
            targetEmotion: null,
            scaleX: 1.0,
            scaleY: 1.0,
            arcHeight: 0,
            lotusMorph: 0, // 0 = circle, 1 = full lotus
            petalSpread: 0, // 0 = closed, 1 = fully open
            smileCurve: 0  // 0 = straight, 1 = full smile
        };
        
        // Standardized color transition system
        this.colorTransition = {
            active: false,
            fromColor: this.state.glowColor,
            toColor: this.state.glowColor,
            fromIntensity: this.state.glowIntensity,
            toIntensity: this.state.glowIntensity,
            progress: 0,
            startTime: 0,
            duration: 1500  // Default 1.5s
        };
        
        // Comprehensive undertone modifiers
        this.undertoneModifiers = {
            nervous: {
                // Color - subtle shimmer, no major shift
                hueShift: 0,          // No hue change
                saturationMult: 1.05, // Tiny bit more vivid
                brightnessMult: 1.0,  // Normal brightness
                brightnessFlicker: 0.05, // 5% brightness variation
                // Visual
                sizeMultiplier: 1.0,  // Normal size
                jitterAmount: 0,      // No constant jitter - handled by episodic flutter
                episodicFlutter: true, // Occasional butterfly moments
                glowRadiusMult: 1.0,  // Normal glow
                glowPulse: 0.05,      // 5% subtle heartbeat pulse
                // Breathing
                breathRateMult: 1.1,  // Slightly faster
                breathDepthMult: 0.9, // Slightly shallower
                breathIrregular: true, // Occasional catch in rhythm
            },
            confident: {
                // Color - warmer, vibrant
                hueShift: 15,         // Warmer but not overwhelming
                saturationMult: 1.2,  // More vibrant
                brightnessMult: 1.1,  // Slightly brighter
                // Visual
                sizeMultiplier: 1.0,  // Normal size until episodes
                jitterAmount: 0,      // Rock solid
                episodicPowerPose: true, // Occasional chest puffs
                glowRadiusMult: 1.15, // Slightly expanded glow
                // Breathing
                breathRateMult: 0.95, // Slightly slower, controlled
                breathDepthMult: 1.1, // Fuller breaths
                breathIrregular: false,
            },
            tired: {
                // Color - slightly cooler, less saturated
                hueShift: -5,         // Slightly cooler
                saturationMult: 0.7,  // Less vibrant
                brightnessMult: 0.85, // Slightly darker
                // Visual
                sizeMultiplier: 0.95, // Slightly smaller
                jitterAmount: 0,
                episodicMicroSleep: true, // Occasional drowsy sags
                glowRadiusMult: 0.9,  // Slightly reduced glow
                // Breathing
                breathRateMult: 0.8,  // Slower
                breathDepthMult: 1.2, // Deeper breaths
                breathIrregular: false,
            },
            intense: {
                // Color - high contrast, saturated
                hueShift: 5,          // Very slightly warmer
                saturationMult: 1.3,  // More saturated
                brightnessMult: 1.15, // Brighter
                // Visual
                sizeMultiplier: 1.0,  // Normal until focus moments
                jitterAmount: 0,      // Still, focused
                episodicLaserFocus: true, // Brief concentration moments
                glowRadiusMult: 1.2,  // Expanded glow
                // Breathing
                breathRateMult: 1.2,  // Faster but controlled
                breathDepthMult: 0.9, // Shallower, focused breaths
                breathIrregular: false,
            },
            subdued: {
                // Color - slightly muted
                hueShift: -10,        // Slightly cooler
                saturationMult: 0.75, // Somewhat muted
                brightnessMult: 0.9,  // Slightly dimmed
                // Visual
                sizeMultiplier: 0.95, // Slightly smaller
                jitterAmount: 0,
                episodicWithdrawal: true, // Brief inward pulls
                glowRadiusMult: 0.85, // Slightly reduced glow
                // Breathing
                breathRateMult: 0.9,  // Slightly slower
                breathDepthMult: 0.9, // Slightly shallow
                breathIrregular: false,
            }
        };
        
        // Performance
        this.lastFrameTime = 0;
        
    }
    
    /**
     * Scale a value based on current canvas size vs reference size
     * Used to scale hard-coded values like shadowBlur, lineWidth, etc.
     * @param {number} value - The base value to scale
     * @returns {number} The scaled value
     */
    scaleValue(value) {
        return value * this.scaleFactor;
    }
    
    /**
     * Initialize offscreen canvas for double buffering
     */
    initOffscreenCanvas() {
        // Create offscreen canvas
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d', {
            alpha: true,
            desynchronized: true,  // Reduces latency
            willReadFrequently: false
        });
        
        // Match dimensions
        this.updateOffscreenSize();
    }
    
    /**
     * Update offscreen canvas size to match main canvas
     */
    updateOffscreenSize() {
        if (this.offscreenCanvas && this.canvasManager) {
            const width = this.canvasManager.canvas.width;
            const height = this.canvasManager.canvas.height;
            
            if (this.offscreenCanvas.width !== width || this.offscreenCanvas.height !== height) {
                this.offscreenCanvas.width = width;
                this.offscreenCanvas.height = height;
            }
        }
    }
    
    /**
     * Main render method
     */
    render(state, deltaTime, gestureTransform = null) {
        // Performance marker: Frame start
        if (this.performanceMonitor) {
            this.performanceMonitor.markFrameStart();
        }
        const frameStartTime = performance.now();

        // Handle forced clean render after tab switch
        if (this.forceCleanRender) {
            this.forceCleanRender = false;
            // Clear any rendering artifacts
            if (this.canvas && this.ctx) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // Get ambient dance transform and merge with gesture transform
        const ambientTransform = this.ambientDanceAnimator.getTransform(deltaTime);
        if (gestureTransform) {
            // Merge transforms
            gestureTransform.x = (gestureTransform.x || 0) + (ambientTransform.x || 0);
            gestureTransform.y = (gestureTransform.y || 0) + (ambientTransform.y || 0);
            gestureTransform.rotation = (gestureTransform.rotation || 0) + (ambientTransform.rotation || 0);
            gestureTransform.scale = (gestureTransform.scale || 1) * (ambientTransform.scale || 1);
        } else {
            gestureTransform = ambientTransform;
        }

        // Store gestureTransform for use in other methods
        this.gestureTransform = gestureTransform;

        // Update offscreen canvas size if needed
        this.updateOffscreenSize();
        
        // Get logical dimensions from canvasManager (not scaled by DPR)
        const logicalWidth = this.canvasManager.width || this.canvas.width || 400;
        const logicalHeight = this.canvasManager.height || this.canvas.height || 400;
        
        // Store original context and switch to offscreen for double buffering
        const originalCtx = this.ctx;
        this.ctx = this.offscreenCtx;
        
        // Clear offscreen canvas for fresh render
        this.ctx.clearRect(0, 0, logicalWidth, logicalHeight);
        
        // Update undertone modifiers every frame during transitions
        if (this.stateMachine && this.stateMachine.getWeightedUndertoneModifiers) {
            const weightedModifier = this.stateMachine.getWeightedUndertoneModifiers();
            if (weightedModifier) {
                this.applyUndertoneModifiers(weightedModifier);
            } else {
                // Reset to defaults when no undertone
                this.applyUndertoneModifiers(null);
            }
        }
        
        // Update color transition (if active)
        if (this.colorTransition && this.colorTransition.active) {
            this.updateColorTransition(deltaTime);
        }
        
        // Update animation timers
        this.updateTimers(deltaTime);
        
        // Update gaze offset
        if (this.state.gazeTrackingEnabled) {
            // When gaze tracking is enabled, follow mouse/touch
            const smoothing = 0.15;
            const maxOffset = 50; // Maximum pixels the orb can move
            this.state.gazeOffset.x += (this.state.gazeTarget.x * maxOffset - this.state.gazeOffset.x) * smoothing;
            this.state.gazeOffset.y += (this.state.gazeTarget.y * maxOffset - this.state.gazeOffset.y) * smoothing;
        } else {
            // When gaze tracking is disabled, return to center
            const smoothing = 0.1;
            this.state.gazeOffset.x += (0 - this.state.gazeOffset.x) * smoothing;
            this.state.gazeOffset.y += (0 - this.state.gazeOffset.y) * smoothing;
        }
        
        // Calculate dimensions - using logical size for proper scaling
        const canvasSize = Math.min(logicalWidth, logicalHeight);
        let centerX = logicalWidth / 2;
        let centerY = logicalHeight / 2 - this.config.topOffset;
        
        // Apply vertical offset for certain emotions (like excited for exclamation mark)
        if (state.properties && state.properties.verticalOffset) {
            centerY = (logicalHeight / 2 - this.config.topOffset) + (logicalHeight * state.properties.verticalOffset);
        }
        
        // Calculate global scale factor based on canvas size and baseScale config
        this.scaleFactor = (canvasSize / this.config.referenceSize) * this.config.baseScale;
        
        // Apply gesture transform if present
        let scaleMultiplier = 1;
        let rotationAngle = 0;
        let glowMultiplier = 1;
        
        if (gestureTransform) {
            centerX += gestureTransform.x || 0;
            centerY += gestureTransform.y || 0;
            scaleMultiplier = gestureTransform.scale || 1;
            rotationAngle = (gestureTransform.rotation || 0) * Math.PI / 180;
            glowMultiplier = gestureTransform.glowIntensity || 1;
        }

        // Apply gesture animations (delegate to GestureAnimator)
        const gestureTransforms = this.gestureAnimator.applyGestureAnimations();
        if (gestureTransforms) {
            centerX += gestureTransforms.offsetX || 0;
            centerY += gestureTransforms.offsetY || 0;
            scaleMultiplier *= gestureTransforms.scale || 1;
            rotationAngle += (gestureTransforms.rotation || 0) * Math.PI / 180;
            // DON'T MULTIPLY - just use the glow value directly to prevent accumulation
            glowMultiplier = gestureTransforms.glow || 1;
        }
        
        // Apply zen levitation - lazy floating when in zen state
        if (this.state.emotion === 'zen' && this.zenTransition.phase === 'in') {
            const time = Date.now() / 1000;
            // Lazy vertical float - slow sine wave
            const floatY = Math.sin(time * 0.3) * 15 * this.scaleFactor; // Very slow, 15px amplitude
            // Gentle horizontal sway - even slower
            const swayX = Math.sin(time * 0.2) * 8 * this.scaleFactor; // Subtle 8px sway
            // Small rotation for ethereal effect
            const floatRotation = Math.sin(time * 0.25) * 0.05; // ±3 degrees
            
            centerY += floatY;
            centerX += swayX;
            rotationAngle += floatRotation;
        }
        
        // Apply sleep state modifications (with animated dimming)
        let sleepOpacityMod = 1;
        let sleepScaleMod = 1;
        let glowOpacityMod = 1;
        if (this.state.sleeping || this.state.emotion === 'resting' || isEffectActive('sleeping', this.state)) {
            const sleepEffect = getEffect('sleeping');
            if (sleepEffect) {
                const dimming = sleepEffect.getDimmingValues();
                // Use effect's dimming values
                sleepOpacityMod = this.state.sleepDimness !== undefined ? this.state.sleepDimness : dimming.orbDimming;
                glowOpacityMod = dimming.glowDimming; // Dim glow even more
                sleepScaleMod = this.state.sleepScale !== undefined ? this.state.sleepScale : 0.9;
            } else {
                // Fallback values
                sleepOpacityMod = this.state.sleepDimness !== undefined ? this.state.sleepDimness : 0.3;
                glowOpacityMod = 0.2;
                sleepScaleMod = this.state.sleepScale !== undefined ? this.state.sleepScale : 0.9;
            }
            this.state.breathRate = 0.5;  // Slower breathing
            this.state.breathDepth = 0.15; // Deeper breaths
        }
        
        // Calculate breathing factors - INVERSE for core and glow
        // Use custom scale if set (for breathing exercises), otherwise use normal breathing
        let coreBreathFactor, glowBreathFactor;
        
        if (this.state.customScale !== null) {
            // Use custom scale directly for breathing exercises
            coreBreathFactor = this.state.customScale;
            glowBreathFactor = 1 + (this.state.customScale - 1) * 0.5; // Glow follows at half intensity
        } else {
            // Get breathing scale from BreathingAnimator
            const breathingScale = this.breathingAnimator.getBreathingScale();
            coreBreathFactor = breathingScale;
            glowBreathFactor = 1 - (breathingScale - 1) * 0.5; // Glow breathes opposite, less pronounced
        }
        
        // Add nervous glow pulse if needed
        if (this.state.undertone === 'nervous' && this.undertoneModifiers.nervous.glowPulse) {
            const nervousPulse = Math.sin(Date.now() / 200) * this.undertoneModifiers.nervous.glowPulse; // Fast subtle pulse
            glowBreathFactor *= (1 + nervousPulse);
        }
        
        // Calculate core dimensions - using unified scale factor
        const baseRadius = (this.config.referenceSize / this.config.coreSizeDivisor) * this.scaleFactor;
        
        // Apply emotion core size from state properties
        const emotionSizeMult = (state.properties && state.properties.coreSize) ? state.properties.coreSize : 1.0;
        
        // Apply undertone size multiplier
        const undertoneSizeMult = this.state.sizeMultiplier || 1.0;
        
        let coreRadius = baseRadius * emotionSizeMult * coreBreathFactor * scaleMultiplier * sleepScaleMod * undertoneSizeMult;
        let glowRadius = baseRadius * this.config.glowMultiplier * glowBreathFactor * this.state.glowIntensity * scaleMultiplier * sleepScaleMod * undertoneSizeMult * glowMultiplier;  // Apply gesture glow multiplier

        // Use state glow intensity directly multiplied by gesture glow
        const effectiveGlowIntensity = this.state.glowIntensity * glowMultiplier;
        
        
        // Apply blinking (only when not sleeping or zen)
        if (!this.state.sleeping && this.state.emotion !== 'zen') {
            const blinkScale = this.eyeRenderer.getBlinkScale();
            coreRadius *= blinkScale; // Apply blink squish
        }
        
        // Apply jitter if needed (anger, fear, or undertone jitter)
        let jitterX = 0, jitterY = 0;
        const jitterAmount = this.state.jitterAmount || 0;
        
        // Handle episodic effects for undertones
        if (this.currentUndertone && this.episodicEffects[this.currentUndertone]) {
            const episode = this.episodicEffects[this.currentUndertone];
            const now = performance.now();
            
            // Check if it's time to trigger a new episode
            if (!episode.active && now >= episode.nextTrigger) {
                episode.active = true;
                episode.startTime = now;
                
                // Set episode parameters based on undertone type
                switch(this.currentUndertone) {
                    case 'nervous':
                        episode.duration = 500 + Math.random() * 500; // 0.5-1 second
                        episode.intensity = 2 + Math.random(); // 2-3px flutter
                        episode.nextTrigger = now + 3000 + Math.random() * 2000; // 3-5 seconds
                        break;
                    case 'confident':
                        episode.duration = 1000 + Math.random() * 1000; // 1-2 seconds
                        episode.intensity = 0.15; // 15% size expansion
                        episode.nextTrigger = now + 4000 + Math.random() * 2000; // 4-6 seconds
                        break;
                    case 'tired':
                        episode.duration = 1000 + Math.random() * 2000; // 1-3 seconds
                        episode.intensity = 0.2; // 20% size reduction
                        episode.nextTrigger = now + 5000 + Math.random() * 2000; // 5-7 seconds
                        break;
                    case 'intense':
                        episode.duration = 500 + Math.random() * 500; // 0.5-1 second
                        episode.intensity = 0.5; // 50% glow boost, 5% size shrink
                        episode.nextTrigger = now + 3000 + Math.random() * 3000; // 3-6 seconds
                        break;
                    case 'subdued':
                        episode.duration = 2000 + Math.random() * 1000; // 2-3 seconds
                        episode.intensity = 0.3; // 30% glow dim, 10% size shrink
                        episode.nextTrigger = now + 4000 + Math.random() * 3000; // 4-7 seconds
                        break;
                }
            }
            
            // Apply episode effects if active
            if (episode.active) {
                const elapsed = now - episode.startTime;
                
                if (elapsed < episode.duration) {
                    const progress = elapsed / episode.duration;
                    
                    // Apply different effects based on undertone
                    switch(this.currentUndertone) {
                        case 'nervous':
                            // Quick shiver that settles
                            const damping = 1 - progress;
                            const frequency = 15;
                            const flutter = Math.sin(progress * Math.PI * frequency) * damping;
                            jitterX = flutter * episode.intensity;
                            jitterY = flutter * episode.intensity * 0.7;
                            break;
                            
                        case 'confident':
                            // Smooth chest puff that settles
                            const puffCurve = Math.sin(progress * Math.PI); // Smooth rise and fall
                            coreRadius *= (1 + episode.intensity * puffCurve);
                            glowRadius *= (1 + episode.intensity * 0.5 * puffCurve);
                            break;
                            
                        case 'tired':
                            // Drowsy sag with slow recovery
                            const sagCurve = Math.sin(progress * Math.PI * 0.5); // Slow droop
                            coreRadius *= (1 - episode.intensity * sagCurve);
                            // Also affect vertical position slightly
                            jitterY += sagCurve * 5; // Slight downward sag
                            break;
                            
                        case 'intense':
                            // Sharp contraction with glow surge
                            const focusCurve = 1 - Math.cos(progress * Math.PI); // Quick in-out
                            coreRadius *= (1 - 0.05 * focusCurve); // 5% shrink
                            glowRadius *= (1 + episode.intensity * focusCurve); // 50% glow boost
                            break;
                            
                        case 'subdued':
                            // Gentle inward pull
                            const withdrawCurve = Math.sin(progress * Math.PI * 0.5); // Slow pull
                            coreRadius *= (1 - 0.1 * withdrawCurve); // 10% shrink
                            glowRadius *= (1 - episode.intensity * withdrawCurve); // 30% glow dim
                            break;
                    }
                } else {
                    // Episode finished
                    episode.active = false;
                }
            }
        } else if (this.state.coreJitter || jitterAmount > 0) {
            // Regular jitter for other emotions
            const jitterStrength = Math.max(jitterAmount, this.state.coreJitter ? this.scaleValue(2) : 0);
            jitterX = (Math.random() - 0.5) * jitterStrength;
            jitterY = (Math.random() - 0.5) * jitterStrength;
        }
        
        // Calculate positions with gaze offset
        const coreX = centerX + this.state.gazeOffset.x + jitterX;
        const coreY = centerY + this.state.gazeOffset.y + jitterY;
        
        // Check if brake is active and update rotation accordingly
        const now = performance.now();

        if (this.rotationBrake && this.rotationBrake.isBraking()) {
            // Brake is active - let it control rotation
            const brakeUpdate = this.rotationBrake.updateBrake(now);
            if (brakeUpdate) {
                this.state.manualRotation = brakeUpdate.rotation;
                this.state.rotationSpeed = brakeUpdate.complete ? 0 : brakeUpdate.speed;
            }
        } else if (this.state.rotationSpeed !== 0) {
            // Normal rotation update - just add velocity each frame (DEGREES)
            this.state.manualRotation += this.state.rotationSpeed;
        }

        // Calculate total rotation (gestures + manual rotation)
        // Convert manual rotation from degrees to radians for rendering
        const totalRotation = rotationAngle + (this.state.manualRotation * Math.PI / 180);

        // Apply rotation if present
        if (totalRotation !== 0) {
            this.ctx.save();
            this.ctx.translate(coreX, coreY);
            this.ctx.rotate(totalRotation);
            this.ctx.translate(-coreX, -coreY);
        }
        
        // Render glow with visual effects
        if (isEffectActive('recording-glow', this.state)) {
            // Recording takes precedence over normal glow
            applyEffect('recording-glow', this.ctx, {
                x: coreX,
                y: coreY,
                radius: glowRadius,
                deltaTime
            });
        } else if (isEffectActive('zen-vortex', this.state)) ; else {
            // Normal glow with sleep dimming
            if (this.state.sleeping || this.state.emotion === 'resting' || isEffectActive('sleeping', this.state)) {
                this.ctx.save();
                this.ctx.globalAlpha = glowOpacityMod;
                this.glowRenderer.renderGlow(coreX, coreY, glowRadius, { intensity: effectiveGlowIntensity });
                this.ctx.restore();
            } else {
                this.glowRenderer.renderGlow(coreX, coreY, glowRadius, { intensity: effectiveGlowIntensity });
            }
        }
        
        // Render flash wave if present
        if (gestureTransforms && gestureTransforms.flashWave) {
            const wave = gestureTransforms.flashWave;
            const ctx = this.ctx;
            
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            // Create a ring gradient for the wave
            const innerR = coreRadius * wave.innerRadius;
            const outerR = coreRadius * wave.outerRadius;
            
            if (outerR > innerR) {
                // Use cached gradient for flash wave
                const gradient = gradientCache.getRadialGradient(
                    ctx, coreX, coreY, innerR, coreX, coreY, outerR,
                    [
                        { offset: 0, color: 'rgba(255, 255, 255, 0)' },
                        { offset: 0.2, color: `rgba(255, 255, 255, ${wave.intensity * 0.15})` },
                        { offset: 0.5, color: `rgba(255, 255, 255, ${wave.intensity * 0.25})` }, // Peak in center
                        { offset: 0.8, color: `rgba(255, 255, 255, ${wave.intensity * 0.15})` },
                        { offset: 1, color: 'rgba(255, 255, 255, 0)' }
                    ]
                );

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(coreX, coreY, outerR, 0, Math.PI * 2);
                ctx.arc(coreX, coreY, Math.max(0, innerR), 0, Math.PI * 2, true);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Apply speaking pulse effect
        if (isEffectActive('speaking-pulse', this.state)) {
            applyEffect('speaking-pulse', this.ctx, {
                x: coreX,
                y: coreY,
                radius: coreRadius,
                audioLevel: this.state.audioLevel || 0,
                deltaTime
            });
        }
        
        // Recording indicator will be drawn after all transforms are restored
        
        // Apply sleep opacity to core
        if (this.state.sleeping || this.state.emotion === 'resting') {
            this.ctx.globalAlpha = sleepOpacityMod;
        }
        
        // Render core (will cover REC if they overlap)
        // Delegate core rendering to CoreRenderer
        // First update the shape morpher if available
        let shapePoints = null;
        let currentShadow = null;
        if (this.shapeMorpher) {
            this.shapeMorpher.update();
            // Get the canvas points relative to center (0,0) since CoreRenderer will translate
            shapePoints = this.shapeMorpher.getCanvasPoints(0, 0, coreRadius);
            currentShadow = this.shapeMorpher.getCurrentShadow();
        }
        
        // Render sun effects BEFORE core (so they appear behind)
        let renderingSunEffects = false;
        if (currentShadow && (currentShadow.type === 'sun' || currentShadow.type === 'solar-hybrid')) {
            this.renderSunEffects(coreX, coreY, coreRadius, currentShadow);
            renderingSunEffects = true;
        }
        
        // Drop shadow removed - was causing dimming
        
        // Update core rotation based on BPM (like a record player)
        // Only rotate if BPM is greater than 0 (rhythm is active)
        // Shapes that should NOT rotate: moon, heart
        
        // Render the core shape with rotation
        // Note: We already applied rotation to the canvas, but CoreRenderer does its own transform
        // So we need to pass the rotation value to it
        this.coreRenderer.renderCore(coreX, coreY, coreRadius, {
            scaleX: 1,
            scaleY: 1,
            rotation: totalRotation,
            shapePoints: shapePoints
        });
        
        // Update and render sparkles BEFORE moon shadow so they don't cover it
        if (this.specialEffects) {
            this.specialEffects.update(deltaTime);
            this.specialEffects.renderSparkles();
        }
        
        // Check if we're dealing with solar transitions
        const currentShape = this.shapeMorpher ? this.shapeMorpher.currentShape : null;
        const targetShape = this.shapeMorpher ? this.shapeMorpher.targetShape : null;
        const isTransitioningToSolar = this.shapeMorpher && targetShape === 'solar' && this.shapeMorpher.isTransitioning;
        const isTransitioningFromSolar = this.shapeMorpher && currentShape === 'solar' && this.shapeMorpher.isTransitioning;
        const isAtSolar = currentShadow && currentShadow.type === 'solar-hybrid';
        
        // Check specific transition directions
        const isSolarToMoon = this.shapeMorpher && this.shapeMorpher.isTransitioning &&
            currentShape === 'solar' && targetShape === 'moon';
        const isMoonToSolar = this.shapeMorpher && this.shapeMorpher.isTransitioning &&
            currentShape === 'moon' && targetShape === 'solar';
        
        // Render moon/lunar shadows AFTER core AND sparkles (as top overlay)
        // Always render moon shadow EXCEPT when transitioning FROM moon TO solar
        if (currentShadow && (currentShadow.type === 'crescent' || currentShadow.type === 'lunar') && 
            !isMoonToSolar) {
            // Shadow is rendered in the already-rotated coordinate space
            this.renderMoonShadow(coreX, coreY, coreRadius, currentShadow, shapePoints, false, 0);
        }
        
        // For solar-hybrid, render lunar overlay on top of sun
        // Skip when transitioning FROM solar TO moon (let moon's shadow handle it)
        if (((isAtSolar && currentShadow.lunarOverlay) || isTransitioningToSolar || isTransitioningFromSolar) && 
            !isSolarToMoon) {
            // Use the lunar overlay from solar definition
            const lunarShadow = (isAtSolar && currentShadow.lunarOverlay) ? currentShadow.lunarOverlay : {
                type: 'lunar',
                coverage: 1.0,
                color: 'rgba(0, 0, 0, 1.0)',
                progression: 'center'
            };
            
            // Calculate shadow offset for Bailey's Beads
            let shadowOffsetX = 0;
            let shadowOffsetY = 0;
            let morphProgress = 0;
            
            if (this.shapeMorpher) {
                morphProgress = this.shapeMorpher.getProgress();
                
                const slideDistance = coreRadius * 2.5;
                
                if (isTransitioningToSolar && morphProgress < 1) {
                    // Shadow sliding in from bottom-left
                    shadowOffsetX = -slideDistance * (1 - morphProgress);
                    shadowOffsetY = slideDistance * (1 - morphProgress);
                } else if (isTransitioningFromSolar && morphProgress < 1) {
                    // Shadow sliding out to top-right
                    shadowOffsetX = slideDistance * morphProgress;
                    shadowOffsetY = -slideDistance * morphProgress;
                }
            }
            
            // Render the shadow
            this.renderMoonShadow(coreX, coreY, coreRadius, lunarShadow, shapePoints, true);
            
            // Render Bailey's Beads during transitions
            // Show beads when transitioning TO solar (which will have rays) or FROM solar (which had rays)
            // But only if we're actually rendering or about to render sun effects
            const willHaveSunEffects = isTransitioningToSolar || renderingSunEffects;
            
            if ((isTransitioningToSolar || isTransitioningFromSolar) && willHaveSunEffects) {
                this.renderBaileysBeads(coreX, coreY, coreRadius, shadowOffsetX, shadowOffsetY, morphProgress, isTransitioningToSolar, true);
                
                // Trigger chromatic aberration when shadow is near center
                const shadowNearCenter = Math.abs(shadowOffsetX) < 30 && Math.abs(shadowOffsetY) < 30;
                if (shadowNearCenter && this.specialEffects) {
                    // Stronger aberration as shadow gets closer to center
                    const distance = Math.sqrt(shadowOffsetX * shadowOffsetX + shadowOffsetY * shadowOffsetY);
                    const intensity = Math.max(0.1, 0.5 * (1 - distance / 30));
                    this.specialEffects.triggerChromaticAberration(intensity);
                }
            }
        }
        
        // Reset alpha
        if (this.state.sleeping || this.state.emotion === 'resting') {
            this.ctx.globalAlpha = 1;
        }
        
        // Restore context if rotated
        if (totalRotation !== 0) {
            this.ctx.restore();
        }
        
        // Recording indicator is now handled by the recording-glow effect module
        // which draws a small indicator in the corner
        
        // Add sleep indicator if sleeping
        if (this.state.sleeping) {
            this.renderSleepIndicator(centerX, centerY - glowRadius - this.scaleValue(20), deltaTime);
        }
        
        // Restore original context AFTER all rendering is done
        this.ctx = originalCtx;
        
        // Simple blit - chromatic aberration is now handled via CSS filters
        originalCtx.drawImage(this.offscreenCanvas, 0, 0);
        
        // Draw recording indicator on TOP of everything, with no transforms
        if (isEffectActive('recording-glow', this.state)) {
            const recordingEffect = getEffect('recording-glow');
            if (recordingEffect && recordingEffect.drawRecordingIndicator) {
                // Use original context to draw on top of the blitted image
                recordingEffect.drawRecordingIndicator(originalCtx, this.canvas.width, this.canvas.height);
            }
        }

        // Performance marker: Frame end
        const frameEndTime = performance.now();
        const frameTime = frameEndTime - frameStartTime;
        if (this.performanceMonitor) {
            this.performanceMonitor.markFrameEnd();
            this.performanceMonitor.recordFrameTime(frameTime);
        }
    }
    
    // renderGlow method removed - now handled by GlowRenderer module
    
    // getCachedGlow method removed - now handled by GlowRenderer module
    
    /**
     * Render recording glow (pulsating red)
     */
    renderRecordingGlow(x, y, radius, intensity) {
        // Get canvas dimensions with fallbacks
        const canvasWidth = this.canvas?.width || 600;
        const canvasHeight = this.canvas?.height || 600;
        
        // Limit radius to prevent clipping at canvas boundaries
        const maxRadius = Math.min(radius, 
            x - 10,  // Distance to left edge
            y - 10,  // Distance to top edge
            canvasWidth - x - 10,  // Distance to right edge
            canvasHeight - y - 10  // Distance to bottom edge
        );
        const safeRadius = Math.max(50, maxRadius); // Ensure minimum radius
        
        // Use cached gradient for the recording glow
        const gradient = gradientCache.getRadialGradient(
            this.ctx, x, y, 0, x, y, safeRadius,
            [
                { offset: 0, color: this.hexToRgba('#FF0000', 0.7 * intensity) },
                { offset: 0.3, color: this.hexToRgba('#FF0000', 0.5 * intensity) },
                { offset: 0.6, color: this.hexToRgba('#FF0000', 0.3 * intensity) },
                { offset: 0.85, color: this.hexToRgba('#FF0000', 0.1 * intensity) }, // Fade earlier
                { offset: 1, color: this.hexToRgba('#FF0000', 0) }
            ]
        );
        
        // Draw the recording glow
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y, safeRadius, 0, Math.PI * 2);
        this.ctx.fill();
    }
    

    /**
     * Render drop shadow for depth
     */
    renderDropShadow(x, y, radius, shapePoints) {
        const ctx = this.ctx;
        
        // Skip shadow during rapid animations for better performance
        const isAnimating = this.shapeMorpher && this.shapeMorpher.isTransitioning;
        const hasAudioDeformation = this.shapeMorpher && 
                                   (this.shapeMorpher.audioDeformation > 0.1 || 
                                    this.shapeMorpher.vocalEnergy > 0.1);
        
        if (!hasAudioDeformation && (!isAnimating || this.shapeMorpher.morphProgress > 0.8)) {
            ctx.save();
            ctx.translate(x, y);
            
            const shadowOffset = this.scaleValue(2);
            ctx.translate(0, shadowOffset);
            
            // Use simpler shadow for complex deformed shapes
            if (shapePoints && shapePoints.length > 32) {
                // Simple dark circle shadow when shape is complex
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.arc(0, 0, radius * 1.05, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Shadow gradient - dark center fading to transparent
                const shadowGradient = ctx.createRadialGradient(0, 0, radius * 0.7, 0, 0, radius * 1.2);
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)');
                shadowGradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.1)');
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = shadowGradient;
                ctx.beginPath();
                if (shapePoints) {
                    // Scale points for shadow
                    const scale = 1.1;
                    const step = shapePoints.length > 20 ? 2 : 1; // Skip points for performance
                    ctx.moveTo(shapePoints[0].x * scale, shapePoints[0].y * scale);
                    for (let i = step; i < shapePoints.length; i += step) {
                        ctx.lineTo(shapePoints[i].x * scale, shapePoints[i].y * scale);
                    }
                    ctx.closePath();
                } else {
                    ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
                }
                ctx.fill();
            }
            ctx.restore();
        }
    }
    
    /**
     * Render sun effects (corona, rays, etc)
     */
    renderSunEffects(x, y, radius, shadow) {
        const ctx = this.ctx;
        const time = Date.now() / 100;
        
        ctx.save();
        ctx.translate(x, y);
        
        // 1. Surface texture - turbulent plasma
        if (shadow.texture && (shadow.textureOpacity === undefined || shadow.textureOpacity > 0)) {
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = shadow.textureOpacity !== undefined ? shadow.textureOpacity : 1;
            
            const offset = time * 0.05 * (shadow.turbulence || 0.3) / 0.3;
            const textureGradient = ctx.createRadialGradient(
                Math.sin(offset) * radius * 0.15,
                Math.cos(offset * 0.7) * radius * 0.15,
                radius * 0.2,
                0, 0, radius
            );
            textureGradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
            textureGradient.addColorStop(0.4, 'rgba(255, 200, 100, 0.1)');
            textureGradient.addColorStop(0.7, 'rgba(255, 150, 50, 0.08)');
            textureGradient.addColorStop(1, 'rgba(255, 100, 30, 0.05)');
            
            ctx.fillStyle = textureGradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // 2. Bright corona layers
        const coronaOpacity = shadow.coronaOpacity !== undefined ? shadow.coronaOpacity : 1;
        if (coronaOpacity > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Inner bright glow
            const innerGlow = ctx.createRadialGradient(0, 0, radius * 0.5, 0, 0, radius * 1.1);
            innerGlow.addColorStop(0, `rgba(255, 255, 255, ${0.8 * coronaOpacity})`);
            innerGlow.addColorStop(0.3, `rgba(255, 250, 200, ${0.6 * coronaOpacity})`);
            innerGlow.addColorStop(0.5, `rgba(255, 200, 100, ${0.4 * coronaOpacity})`);
            innerGlow.addColorStop(0.7, `rgba(255, 150, 50, ${0.2 * coronaOpacity})`);
            innerGlow.addColorStop(1, 'rgba(255, 100, 20, 0)');
            
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
            ctx.fill();
            
            // Outer corona with animation
            for (let i = 0; i < 2; i++) {
                const scale = 1.3 + i * 0.4;
                const opacity = (0.35 - i * 0.15) * coronaOpacity;
                const wobble = Math.sin(time * 0.1 + i) * 0.05;
                
                const coronaGradient = ctx.createRadialGradient(
                    0, 0, radius * (0.9 + wobble), 
                    0, 0, radius * (scale + wobble)
                );
                coronaGradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
                coronaGradient.addColorStop(0.4, `rgba(255, 200, 100, ${opacity * 0.5})`);
                coronaGradient.addColorStop(0.7, `rgba(255, 150, 50, ${opacity})`);
                coronaGradient.addColorStop(0.9, `rgba(255, 100, 30, ${opacity * 0.5})`);
                coronaGradient.addColorStop(1, 'rgba(255, 50, 10, 0)');
                
                ctx.fillStyle = coronaGradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius * (scale + wobble), 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // 3. Optimized ethereal flame pennants - TONS of rays
        if (shadow.flares) {
            ctx.save();
            
            // Pre-calculate common values
            const wave1 = Math.sin(time * 0.08);
            const wave2 = Math.sin(time * 0.12);
            const wave3 = Math.sin(time * 0.16);
            
            // Create single gradient for all flames
            const grad = ctx.createLinearGradient(0, -radius, 0, -radius * 3);
            grad.addColorStop(0, 'rgba(255, 255, 230, 0.4)');
            grad.addColorStop(0.2, 'rgba(255, 220, 150, 0.25)');
            grad.addColorStop(0.5, 'rgba(255, 180, 80, 0.15)');
            grad.addColorStop(0.8, 'rgba(255, 120, 40, 0.08)');
            grad.addColorStop(1, 'rgba(255, 60, 20, 0)');
            
            ctx.fillStyle = grad;
            ctx.globalCompositeOperation = 'screen';
            
            // Single path for ALL flames
            ctx.beginPath();
            
            // Helper function for flame shape
            const addFlame = (angle, length, width, wave) => {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const baseX = cos * radius;
                const baseY = sin * radius;
                const tipX = cos * (radius + length);
                const tipY = sin * (radius + length);
                const perpX = -sin * width * 0.5;
                const perpY = cos * width * 0.5;
                const waveOffset = wave * width * 0.3;
                
                // Simple triangle with slight curve
                ctx.moveTo(baseX - perpX, baseY - perpY);
                ctx.quadraticCurveTo(
                    (baseX + tipX) * 0.5 + perpX * waveOffset,
                    (baseY + tipY) * 0.5 + perpY * waveOffset,
                    tipX, tipY
                );
                ctx.quadraticCurveTo(
                    (baseX + tipX) * 0.5 - perpX * waveOffset,
                    (baseY + tipY) * 0.5 - perpY * waveOffset,
                    baseX + perpX, baseY + perpY
                );
            };
            
            // Layer 1: Long primary rays (8)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + wave1 * 0.1;
                const length = radius * (1.8 + Math.sin(time * 0.1 + i * 0.5) * 0.4);
                const width = radius * 0.18;
                const wave = Math.sin(time * 0.15 + i);
                addFlame(angle, length, width, wave);
            }
            
            // Layer 2: Medium rays between primaries (12)
            for (let i = 0; i < 12; i++) {
                const angle = ((i + 0.5) / 12) * Math.PI * 2 + wave2 * 0.08;
                const length = radius * (1.2 + Math.sin(time * 0.13 + i * 0.7) * 0.3);
                const width = radius * 0.12;
                const wave = Math.sin(time * 0.18 + i * 1.2);
                addFlame(angle, length, width, wave);
            }
            
            // Layer 3: Short rays filling gaps (15)
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2 + wave3 * 0.05;
                const length = radius * (0.7 + Math.sin(time * 0.17 + i * 0.9) * 0.25);
                const width = radius * 0.08;
                const wave = Math.sin(time * 0.2 + i * 1.5);
                addFlame(angle, length, width, wave);
            }
            
            // Layer 4: Tiny rays for density (15)
            for (let i = 0; i < 15; i++) {
                const angle = ((i + 0.25) / 15) * Math.PI * 2;
                const length = radius * (0.4 + Math.sin(time * 0.22 + i) * 0.2);
                const width = radius * 0.06;
                // Simple triangles for tiny rays
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const baseX = cos * radius;
                const baseY = sin * radius;
                const tipX = cos * (radius + length);
                const tipY = sin * (radius + length);
                const perpX = -sin * width * 0.5;
                const perpY = cos * width * 0.5;
                
                ctx.moveTo(baseX - perpX, baseY - perpY);
                ctx.lineTo(tipX, tipY);
                ctx.lineTo(baseX + perpX, baseY + perpY);
            }
            
            // Single fill operation for all rays!
            ctx.fill();
            ctx.restore();
        }
        
        // 4. Bright rim lighting
        const rimGradient = ctx.createRadialGradient(0, 0, radius * 0.95, 0, 0, radius * 1.05);
        rimGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
        rimGradient.addColorStop(0.7, 'rgba(255, 255, 200, 0.2)');
        rimGradient.addColorStop(0.9, 'rgba(255, 200, 100, 0.5)');
        rimGradient.addColorStop(1, 'rgba(255, 150, 50, 0.3)');
        
        ctx.fillStyle = rimGradient;
        ctx.beginPath();
        ctx.arc(0, 0, radius * 1.05, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    /**
     * Render Bailey's Beads for solar eclipse
     */
    renderBaileysBeads(x, y, radius, shadowOffsetX, shadowOffsetY, morphProgress, isTransitioningToSolar, hasSunRays) {
        const ctx = this.ctx;
        
        // NEVER show beads if there are no sun rays visible
        if (!hasSunRays) {
            this._beadStartTime = null;
            return;
        }
        
        // Check if this is a lunar-solar transition (shadow stays centered)
        const isLunarSolarTransition = Math.abs(shadowOffsetX) < 1 && Math.abs(shadowOffsetY) < 1;
        
        // Show beads when shadow is approaching center OR for lunar-solar transitions
        // Different thresholds for entering vs leaving
        const threshold = isTransitioningToSolar ? 30 : 15; // Disappear faster when leaving
        const shadowNearCenter = Math.abs(shadowOffsetX) < threshold && Math.abs(shadowOffsetY) < threshold;
        
        if (!shadowNearCenter && !isLunarSolarTransition) {
            // Reset when not near center (unless it's lunar-solar)
            this._beadStartTime = null;
            return;
        }
        
        // Check if we need to generate new beads (first time shadow centers for this transition)
        if (!this._beadStartTime) {
            const beadCount = Math.floor(Math.random() * 4) + 1; // 1-4 beads
            
            this._currentBeads = [];
            
            // Create beads with random order
            const angles = [];
            for (let i = 0; i < beadCount; i++) {
                angles.push(Math.random() * Math.PI * 2);
            }
            
            // Shuffle the order they'll appear
            const order = Array.from({length: beadCount}, (_, i) => i);
            for (let i = order.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [order[i], order[j]] = [order[j], order[i]];
            }
            
            for (let i = 0; i < beadCount; i++) {
                this._currentBeads.push({
                    angle: angles[i],
                    size: 3 + Math.random() * 5, // Random size 3-8
                    order: order[i], // Order in sequence
                    delay: order[i] * 200 // 200ms between each bead
                });
            }
            
            this._beadStartTime = Date.now();
        }
        
        const elapsedTime = Date.now() - this._beadStartTime;
        
        // Render the beads as chromatic lens flares (one at a time)
        const beads = this._currentBeads || [];
        
        beads.forEach(bead => {
            // Check if this bead should be visible yet
            if (elapsedTime < bead.delay) return;
            
            // Calculate fade in (300ms fade)
            const beadAge = elapsedTime - bead.delay;
            const fadeInDuration = 300;
            const opacity = Math.min(1, beadAge / fadeInDuration);
            
            // Calculate bead position on the edge of the sun (not shadow)
            const beadX = x + Math.cos(bead.angle) * radius;
            const beadY = y + Math.sin(bead.angle) * radius;
            
            ctx.save();
            ctx.translate(beadX, beadY);
            ctx.globalAlpha = opacity;
            
            // Draw chromatic aberration lens flare
            const size = this.scaleValue(bead.size);
            
            // Chromatic layers - RGB separated for aberration effect
            const colors = [
                { color: `rgba(255, 100, 100, ${0.6 * opacity})`, offset: -2 },  // Red
                { color: `rgba(100, 255, 100, ${0.6 * opacity})`, offset: 0 },   // Green  
                { color: `rgba(100, 100, 255, ${0.6 * opacity})`, offset: 2 }    // Blue
            ];
            
            ctx.globalCompositeOperation = 'screen';
            
            colors.forEach(({ color, offset }) => {
                // Create radial gradient for each color channel
                const gradient = ctx.createRadialGradient(
                    offset, offset, 0,
                    offset, offset, size * 2
                );
                
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.2, color.replace(`${0.6 * opacity}`, `${0.4 * opacity}`));
                gradient.addColorStop(0.5, color.replace(`${0.6 * opacity}`, `${0.2 * opacity}`));
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(offset, offset, size * 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Add bright white core
            ctx.globalCompositeOperation = 'lighter';
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            coreGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
            coreGradient.addColorStop(0.3, `rgba(255, 255, 255, ${0.5 * opacity})`);
            coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        });
    }
    
    /**
     * Render moon/lunar shadow overlay
     * @param {boolean} isSolarOverlay - True if this is being called for solar eclipse effect
     * @param {number} rotation - Rotation angle to apply
     */
    renderMoonShadow(x, y, radius, shadow, shapePoints, isSolarOverlay = false, rotation = 0) {
        const ctx = this.ctx;
        
        ctx.save();
        ctx.translate(x, y);
        
        // Don't apply rotation - we're already in rotated coordinate space
        
        if (shadow.type === 'crescent') {
            // Crescent moon - smooth shadow without pixelation
            
            // Get morph progress to animate the shadow sliding in
            let shadowProgress = 1.0; // Default to fully visible
            let animatedOffset = shadow.offset || 0.7; // Default to the shadow's offset
            
            if (this.shapeMorpher) {
                const morphProgress = this.shapeMorpher.getProgress();
                const targetShape = this.shapeMorpher.targetShape;
                
                // Animate shadow sliding in when morphing TO moon (and shadow.offset is not being controlled)
                if (targetShape === 'moon' && morphProgress !== undefined && morphProgress < 1 && !shadow.shadowX) {
                    // Shadow slides in from the left
                    shadowProgress = morphProgress;
                    const baseOffset = 0.7;
                    // Animate the offset - starts far left (-2) and slides to final position
                    animatedOffset = -2 + (baseOffset + 2) * shadowProgress;
                }
                // FROM MOON TO ANY SHAPE - ShapeMorpher is already controlling via shadow.offset
                // so we just use whatever offset is provided in the shadow object
            }
            // Calculate shadow offset - shadow rotates with the moon
            const angleRad = (shadow.angle || -30) * Math.PI / 180;
            const offsetX = Math.cos(angleRad) * radius * animatedOffset;
            const offsetY = Math.sin(angleRad) * radius * animatedOffset;
            
            // Enable high quality rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Clip to the moon shape
            ctx.beginPath();
            if (shapePoints) {
                ctx.moveTo(shapePoints[0].x, shapePoints[0].y);
                for (let i = 1; i < shapePoints.length; i++) {
                    ctx.lineTo(shapePoints[i].x, shapePoints[i].y);
                }
                ctx.closePath();
            } else {
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
            }
            ctx.clip();
            
            // Use a single smooth gradient for the entire shadow
            const shadowGradient = ctx.createRadialGradient(
                offsetX, offsetY, radius * 0.9,
                offsetX, offsetY, radius * 1.1
            );
            
            // More gradient stops for smoother transition
            // Also fade opacity based on shadowProgress for smoother appearance
            const baseCoverage = shadow.coverage !== undefined ? shadow.coverage : 0.85;
            const shadowOpacity = Math.min(1, shadowProgress * 1.2) * (baseCoverage / 0.85);
            shadowGradient.addColorStop(0, `rgba(0, 0, 0, ${1 * shadowOpacity})`);
            shadowGradient.addColorStop(0.80, `rgba(0, 0, 0, ${1 * shadowOpacity})`);
            shadowGradient.addColorStop(0.88, `rgba(0, 0, 0, ${0.98 * shadowOpacity})`);
            shadowGradient.addColorStop(0.91, `rgba(0, 0, 0, ${0.95 * shadowOpacity})`);
            shadowGradient.addColorStop(0.93, `rgba(0, 0, 0, ${0.9 * shadowOpacity})`);
            shadowGradient.addColorStop(0.95, `rgba(0, 0, 0, ${0.8 * shadowOpacity})`);
            shadowGradient.addColorStop(0.96, `rgba(0, 0, 0, ${0.65 * shadowOpacity})`);
            shadowGradient.addColorStop(0.97, `rgba(0, 0, 0, ${0.45 * shadowOpacity})`);
            shadowGradient.addColorStop(0.98, `rgba(0, 0, 0, ${0.25 * shadowOpacity})`);
            shadowGradient.addColorStop(0.99, `rgba(0, 0, 0, ${0.1 * shadowOpacity})`);
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = shadowGradient;
            ctx.beginPath();
            // Always use a circular shadow - crescent effect only works with circles
            ctx.arc(offsetX, offsetY, radius * 1.1, 0, Math.PI * 2);
            ctx.fill();
            
        } else if (shadow.type === 'lunar') {
            // Lunar eclipse - diffuse reddish shadow
            const diffusion = shadow.diffusion !== undefined ? shadow.diffusion : 1;
            const sharpness = 1 - diffusion;
            
            // Get morph progress to animate the shadow sliding in for solar
            let shadowOffsetX = 0;
            let shadowOffsetY = 0;
            
            if (this.shapeMorpher) {
                const morphProgress = this.shapeMorpher.getProgress();
                const currentShape = this.shapeMorpher.currentShape;
                const targetShape = this.shapeMorpher.targetShape;
                
                // Don't skip animation for moon-solar transitions anymore
                
                // Animate shadow sliding in when morphing TO solar (for solar overlay)
                if (isSolarOverlay && targetShape === 'solar' && morphProgress !== undefined && morphProgress < 1) {
                    // Shadow slides in from bottom-left
                    const slideDistance = radius * 2.5;
                    // Start from bottom-left, move to center
                    shadowOffsetX = -slideDistance * (1 - morphProgress);
                    shadowOffsetY = slideDistance * (1 - morphProgress);
                }
                // Animate shadow sliding out when morphing FROM solar
                else if (isSolarOverlay && currentShape === 'solar' && targetShape !== 'solar' && targetShape !== null && morphProgress !== undefined && morphProgress < 1) {
                    // Shadow slides out to top-right
                    const slideDistance = radius * 2.5;
                    // Move from center to top-right
                    shadowOffsetX = slideDistance * morphProgress;
                    shadowOffsetY = -slideDistance * morphProgress;
                }
            }
            
            // Apply translation for shadow animation
            ctx.translate(shadowOffsetX, shadowOffsetY);
            
            // For solar overlay, clip to the sun's core area only (not the corona)
            if (isSolarOverlay) {
                // Clip to a circle at the shadow's position that only covers the core
                ctx.save();
                ctx.beginPath();
                // Create a clipping region that's the intersection of the sun and the shadow
                ctx.arc(-shadowOffsetX, -shadowOffsetY, radius, 0, Math.PI * 2); // Sun position (inverse of shadow offset)
                ctx.clip();
            } else {
                // Regular lunar clipping
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.clip();
            }
            
            // Penumbra (diffuse outer shadow) - MUCH DARKER
            const penumbraRadius = radius * (1.8 - sharpness * 0.5);
            const penumbraGradient = ctx.createRadialGradient(
                0, 0, radius * 0.2,
                0, 0, penumbraRadius
            );
            
            const baseOpacity = shadow.coverage || 0.9;
            
            // Use custom color if specified (for solar eclipse), otherwise use default lunar red
            if (shadow.color && shadow.color.includes('0, 0, 0')) {
                // Black shadow for solar eclipse
                penumbraGradient.addColorStop(0, `rgba(0, 0, 0, ${baseOpacity})`);
                penumbraGradient.addColorStop(0.3 + sharpness * 0.2, `rgba(0, 0, 0, ${baseOpacity * 0.95})`);
                penumbraGradient.addColorStop(0.6 + sharpness * 0.2, `rgba(0, 0, 0, ${baseOpacity * 0.8})`);
                penumbraGradient.addColorStop(0.85, `rgba(0, 0, 0, ${baseOpacity * 0.4})`);
                penumbraGradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
            } else {
                // Default reddish lunar eclipse colors
                penumbraGradient.addColorStop(0, `rgba(10, 2, 0, ${baseOpacity})`);
                penumbraGradient.addColorStop(0.3 + sharpness * 0.2, `rgba(20, 5, 0, ${baseOpacity * 0.95})`);
                penumbraGradient.addColorStop(0.6 + sharpness * 0.2, `rgba(40, 10, 5, ${baseOpacity * 0.8})`);
                penumbraGradient.addColorStop(0.85, `rgba(60, 15, 10, ${baseOpacity * 0.4})`);
                penumbraGradient.addColorStop(1, `rgba(80, 20, 15, 0)`);
            }
            
            ctx.fillStyle = penumbraGradient;
            ctx.beginPath();
            ctx.arc(0, 0, penumbraRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Umbra (sharp inner shadow) - only when sharp
            if (sharpness > 0.3) {
                const umbraRadius = radius * (0.8 + sharpness * 0.3);
                const umbraGradient = ctx.createRadialGradient(
                    0, 0, 0,
                    0, 0, umbraRadius
                );
                
                // Use black for solar eclipse, reddish for lunar
                if (shadow.color && shadow.color.includes('0, 0, 0')) {
                    umbraGradient.addColorStop(0, `rgba(0, 0, 0, ${baseOpacity})`);
                    umbraGradient.addColorStop(0.5, `rgba(0, 0, 0, ${baseOpacity * 0.9})`);
                    umbraGradient.addColorStop(0.8, `rgba(0, 0, 0, ${baseOpacity * 0.5})`);
                    umbraGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                } else {
                    umbraGradient.addColorStop(0, `rgba(0, 0, 0, ${baseOpacity})`);
                    umbraGradient.addColorStop(0.5, `rgba(10, 2, 0, ${baseOpacity * 0.9})`);
                    umbraGradient.addColorStop(0.8, `rgba(20, 5, 0, ${baseOpacity * 0.5})`);
                    umbraGradient.addColorStop(1, 'rgba(30, 8, 5, 0)');
                }
                
                ctx.fillStyle = umbraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, umbraRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Restore extra save for solar overlay clipping
        if (isSolarOverlay) {
            ctx.restore();
        }
        
        ctx.restore();
    }
    
    /**
     * Render zen meditation core with arc shape
     */
    renderZenCore(x, y, radius) {
        this.ctx.save();
        
        // Apply shake offset if in awakening phase
        if (this.state.shakeOffset) {
            x += this.state.shakeOffset;
        }
        
        // Apply drift Y if in awakening phase
        if (this.state.driftY) {
            y += this.state.driftY;
        }
        
        this.ctx.translate(x, y);
        
        // Apply gesture rotation if present (for spin gesture)
        if (this.gestureTransform && this.gestureTransform.rotation !== undefined) {
            this.ctx.rotate(this.gestureTransform.rotation * Math.PI / 180);
        }
        
        // Calculate zen energy pulsation (slow breathing effect)
        const time = Date.now() / 1000; // Time in seconds
        const basePulse = Math.sin(time * 0.5) * 0.5 + 1.5; // Base pulsation
        
        // Scale glow intensity based on transition phase
        // Very dim during bloom/retract, bright when fully in zen
        let glowIntensity = 0.1; // Start very dim
        if (this.zenTransition.phase === 'in') {
            // Full brightness when fully in zen
            glowIntensity = 1.0;
        } else if (this.zenTransition.phase === 'entering') {
            // Gradually brighten only after lotus is mostly formed
            glowIntensity = Math.max(0.1, (this.zenTransition.lotusMorph - 0.7) * 3.3); // Stay dim until 70% bloomed
        } else if (this.zenTransition.phase === 'exiting') {
            // Quickly dim when exiting
            glowIntensity = Math.max(0.1, this.zenTransition.lotusMorph * 0.5);
        }
        const zenPulse = basePulse * glowIntensity; // Apply intensity scaling
        
        // Apply glow when lotus is morphing or fully formed
        if (this.zenTransition.lotusMorph > 0) {
            // Single smooth shadow glow 
            this.ctx.shadowBlur = this.scaleValue(100) * zenPulse;
            this.ctx.shadowColor = `rgba(255, 223, 0, ${0.5 * zenPulse})`;
            
            // INNER RADIANCE GRADIENT - Much darker during transitions
            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 4);
            
            // During transitions, use much darker colors to see lotus
            if (this.zenTransition.phase !== 'in') {
                // Dark golden during transition - lotus will show as even darker cutout
                gradient.addColorStop(0, `rgba(184, 134, 11, ${0.8})`); // Dark goldenrod core
                gradient.addColorStop(0.3, `rgba(153, 101, 21, ${0.6})`); // Darker gold
                gradient.addColorStop(0.6, `rgba(139, 69, 19, ${0.4})`); // Saddle brown
                gradient.addColorStop(1, `rgba(101, 67, 33, 0)`); // Dark brown edge
            } else {
                // Full brightness only when fully in zen
                gradient.addColorStop(0, `rgba(255, 255, 255, ${1.0 * zenPulse})`); // Pure white core
                gradient.addColorStop(0.1, `rgba(255, 255, 240, ${1.0 * zenPulse})`); // Bright cream
                gradient.addColorStop(0.2, `rgba(255, 250, 205, ${0.95 * zenPulse})`); // Warm light
                gradient.addColorStop(0.35, `rgba(255, 240, 150, ${0.85 * zenPulse})`); // Bright gold
                gradient.addColorStop(0.5, `rgba(255, 223, 0, ${0.7 * zenPulse})`); // Vibrant gold
                gradient.addColorStop(0.65, `rgba(255, 215, 0, ${0.5 * zenPulse})`); // Fading gold
                gradient.addColorStop(0.8, `rgba(255, 215, 0, ${0.3 * zenPulse})`); // Softer edge
                gradient.addColorStop(0.9, `rgba(255, 215, 0, ${0.15 * zenPulse})`); // Very soft
                gradient.addColorStop(0.95, `rgba(255, 215, 0, ${0.05 * zenPulse})`); // Almost gone
                gradient.addColorStop(1, `rgba(255, 215, 0, 0)`); // Fully transparent edge
            }
            
            this.ctx.fillStyle = gradient;
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.3})`; // Dimmer edge during transition
            this.ctx.lineWidth = this.scaleValue(2);
            
            // STEP 1: Draw a circle with lotus cutout using evenodd fill rule
            this.ctx.beginPath();
            
            // Draw outer circle (clockwise)
            this.ctx.arc(0, 0, radius, 0, Math.PI * 2, false);
            
            // MORPHING LOTUS PETALS - animated based on lotusMorph value
            const morph = this.zenTransition.lotusMorph;
            const spread = this.zenTransition.petalSpread;
            const smile = this.zenTransition.smileCurve;
            
            // Center/Top petal - morphs from small circle to full petal
            // Only draw lotus if morph is significant (avoid tiny artifacts)
            if (morph > 0.1) {
                const centerPetalBase = radius * (0.05 + 0.15 * morph);
                this.ctx.moveTo(0, centerPetalBase); // Start at base center
                this.ctx.bezierCurveTo(
                    -radius * (0.05 + 0.25 * morph * spread), radius * 0.1,    // Left control
                    -radius * (0.05 + 0.3 * morph * spread), -radius * (0.1 + 0.4 * morph),  // Left control up
                    0, -radius * (0.2 + 0.65 * morph)                // Top point
                );
                this.ctx.bezierCurveTo(
                    radius * (0.05 + 0.3 * morph * spread), -radius * (0.1 + 0.4 * morph),   // Right control up
                    radius * (0.05 + 0.25 * morph * spread), radius * 0.1,     // Right control
                    0, centerPetalBase                 // Back to base
                );
                
                if (morph > 0.3) { // Only show side petals after some morphing
                const sidePetalAlpha = (morph - 0.3) / 0.7; // Fade in from 30% to 100%
                
                // Left petal - fades in and spreads
                this.ctx.moveTo(-radius * 0.1 * sidePetalAlpha, radius * 0.2); 
                this.ctx.bezierCurveTo(
                    -radius * (0.1 + 0.4 * sidePetalAlpha * spread), radius * 0.1,    
                    -radius * (0.2 + 0.5 * sidePetalAlpha * spread), -radius * (0.1 + 0.2 * sidePetalAlpha),   
                    -radius * (0.1 + 0.4 * sidePetalAlpha * spread), -radius * (0.2 + 0.45 * sidePetalAlpha)   
                );
                this.ctx.bezierCurveTo(
                    -radius * (0.05 + 0.15 * sidePetalAlpha), -radius * (0.1 + 0.4 * sidePetalAlpha),   
                    -radius * 0.05 * sidePetalAlpha, radius * 0.1,   
                    -radius * 0.1 * sidePetalAlpha, radius * 0.2     
                );
                
                // Right petal - fades in and spreads
                this.ctx.moveTo(radius * 0.1 * sidePetalAlpha, radius * 0.2); 
                this.ctx.bezierCurveTo(
                    radius * (0.1 + 0.4 * sidePetalAlpha * spread), radius * 0.1,     
                    radius * (0.2 + 0.5 * sidePetalAlpha * spread), -radius * (0.1 + 0.2 * sidePetalAlpha),    
                    radius * (0.1 + 0.4 * sidePetalAlpha * spread), -radius * (0.2 + 0.45 * sidePetalAlpha)    
                );
                this.ctx.bezierCurveTo(
                    radius * (0.05 + 0.15 * sidePetalAlpha), -radius * (0.1 + 0.4 * sidePetalAlpha),    
                    radius * 0.05 * sidePetalAlpha, radius * 0.1,    
                    radius * 0.1 * sidePetalAlpha, radius * 0.2      
                );
            }
            
            // Bottom smile - morphs from straight to curved smile
            if (smile > 0) {
                this.ctx.moveTo(-radius * 0.6, radius * (0.5 - 0.1 * smile));   // Corners rise with smile
                this.ctx.quadraticCurveTo(
                    0, radius * (0.5 + 0.1 * smile),     // Center dips for smile
                    radius * 0.6, radius * (0.5 - 0.1 * smile)  // Right corner rises
                );
                }
            }
            
            this.ctx.closePath();
            
            // Fill with gradient using evenodd rule to create the lotus cutout
            this.ctx.fill('evenodd');
            // Don't stroke the lotus cutout, only the outer circle
            this.ctx.beginPath();
            this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Only add additional glow layers when fully in zen, not during transitions
            if (this.zenTransition.phase === 'in') {
                // Additional EXPANSIVE glow layers for inner radiance
                // Layer 1: BRILLIANT lotus core intensifier - from lower quarter
                const lotusRadius = radius * 2.0; // Larger radius for more expansion
                const arcHeight = this.zenTransition.arcHeight * radius; // Get arc height from transition state
                const glowOriginY = radius * 0.5; // Lower quarter origin
                const lotusGlow = this.ctx.createRadialGradient(0, glowOriginY, 0, 0, glowOriginY, lotusRadius * 1.2);
                lotusGlow.addColorStop(0, `rgba(255, 255, 255, ${1.0 * zenPulse})`);
                lotusGlow.addColorStop(0.25, `rgba(255, 252, 240, ${0.8 * zenPulse})`);
                lotusGlow.addColorStop(0.5, `rgba(255, 245, 200, ${0.6 * zenPulse})`);
                lotusGlow.addColorStop(0.75, `rgba(255, 235, 150, ${0.4 * zenPulse})`);
                lotusGlow.addColorStop(1, 'rgba(255, 223, 0, 0)');
                this.ctx.fillStyle = lotusGlow;
                this.ctx.fill();
                
                // Layer 2: GAUSSIAN outer halo for smooth falloff
                const outerHalo = this.ctx.createRadialGradient(0, -arcHeight/2, radius * 0.5, 0, -arcHeight/2, radius * 5);
                outerHalo.addColorStop(0, 'rgba(255, 223, 0, 0)');
                outerHalo.addColorStop(0.1, `rgba(255, 223, 0, ${0.25 * zenPulse})`);
                outerHalo.addColorStop(0.2, `rgba(255, 220, 0, ${0.2 * zenPulse})`);
                outerHalo.addColorStop(0.35, `rgba(255, 215, 0, ${0.15 * zenPulse})`);
                outerHalo.addColorStop(0.5, `rgba(255, 215, 0, ${0.1 * zenPulse})`);
                outerHalo.addColorStop(0.65, `rgba(255, 215, 0, ${0.06 * zenPulse})`);
                outerHalo.addColorStop(0.8, `rgba(255, 215, 0, ${0.03 * zenPulse})`);
                outerHalo.addColorStop(0.9, `rgba(255, 215, 0, ${0.01 * zenPulse})`);
                outerHalo.addColorStop(1, 'rgba(255, 215, 0, 0)');
                this.ctx.fillStyle = outerHalo;
                this.ctx.fill();
            }
        } else {
            // Draw horizontal line or circle during transition
            // Start with very dim golden color that brightens with lotus
            
            // No glow during transition to prevent flash
            this.ctx.shadowBlur = 0;
            this.ctx.shadowColor = 'transparent';
            
            // Use very dim golden color during transition
            const dimIntensity = 0.3; // Keep consistently dim during transition
            this.ctx.fillStyle = `rgba(255, 215, 0, ${dimIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Very subtle gradient during transition to see lotus clearly
            const coreGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            coreGradient.addColorStop(0, `rgba(255, 255, 255, 0.2)`);
            coreGradient.addColorStop(0.5, `rgba(255, 250, 230, 0.1)`);
            coreGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            this.ctx.fillStyle = coreGradient;
            this.ctx.fill();
        }
        
        this.ctx.restore();
    }
    
    /**
     * Render speaking animation rings
     */
    renderSpeakingRings(centerX, centerY, coreRadius, deltaTime) {
        return this.specialEffects.renderSpeakingRings(centerX, centerY, coreRadius, deltaTime);
    }
    
    
    // Recording rings method removed - now using pulsating glow instead
    
    /**
     * Render recording indicator - stylized REC text only
     */
    renderRecordingIndicator(x, y) {
        return this.specialEffects.renderRecordingIndicator(x, y);
    }
    
    
    /**
     * Render sleep indicator (Z's) with cell-shaded style and gradient fade
     */
    renderSleepIndicator(x, y, deltaTime) {
        return this.specialEffects.renderSleepIndicator(x, y, deltaTime);
    }
    
    
    /**
     * Update animation timers
     */
    updateTimers(deltaTime) {
        // Update breathing animation via BreathingAnimator
        this.breathingAnimator.update(deltaTime, this.state.emotion, this.currentUndertone);
        
        // Update special breathing modifiers
        if (this.state.emotion === 'zen') {
            this.breathingAnimator.setBreathRateMultiplier(0.15);
            this.breathingAnimator.setBreathDepthMultiplier(2.5);
        } else if (this.state.sleeping) {
            this.breathingAnimator.setBreathRateMultiplier(0.5);
            this.breathingAnimator.setBreathDepthMultiplier(1.2);
        } else {
            this.breathingAnimator.setBreathRateMultiplier(1.0);
            this.breathingAnimator.setBreathDepthMultiplier(1.0);
        }
        
        // Apply irregular breathing for nervous/tired
        this.breathingAnimator.setIrregularBreathing(this.state.breathIrregular);
        
        // Update blinking via EyeRenderer
        this.eyeRenderer.setBlinkingEnabled(this.state.blinkingEnabled && !this.state.sleeping && this.state.emotion !== 'zen');
        this.eyeRenderer.update(deltaTime);
        
        // Sync blinking state back to our state for compatibility
        this.state.blinking = this.eyeRenderer.blinking;
        
        // Note: Idle detection is handled by IdleBehavior.js, not here
    }
    
    /**
     * Apply all undertone modifiers to current state
     * @param {string|null|Object} undertone - Undertone name or weighted modifier object
     */
    applyUndertoneModifiers(undertone) {
        // Handle weighted modifier from state machine
        if (undertone && typeof undertone === 'object' && undertone.weight !== undefined) {
            const weight = undertone.weight;
            
            // Apply weighted modifiers for smooth transitions
            // Use default value of 1.0 if property is undefined
            this.state.sizeMultiplier = 1.0 + ((undertone.sizeMultiplier || 1.0) - 1.0) * weight;
            this.state.jitterAmount = (undertone.jitterAmount || 0) * weight;
            this.state.episodicFlutter = weight > 0.5 ? (undertone.episodicFlutter || false) : false;
            this.state.glowRadiusMult = 1.0 + ((undertone.glowRadiusMult || 1.0) - 1.0) * weight;
            this.state.breathRateMult = 1.0 + ((undertone.breathRateMult || 1.0) - 1.0) * weight;
            this.state.breathDepthMult = 1.0 + ((undertone.breathDepthMult || 1.0) - 1.0) * weight;
            this.state.breathIrregular = weight > 0.5 ? (undertone.breathIrregular || false) : false;
            this.state.particleRateMult = 1.0;
            return;
        }
        
        // String-based undertone handling
        if (!undertone || !this.undertoneModifiers[undertone]) {
            // Reset to defaults if no undertone
            this.state.sizeMultiplier = 1.0;
            this.state.jitterAmount = 0;
            this.state.episodicFlutter = false;
            this.state.glowRadiusMult = 1.0;
            this.state.breathRateMult = 1.0;
            this.state.breathDepthMult = 1.0;
            this.state.breathIrregular = false;
            this.state.particleRateMult = 1.0;
            return;
        }
        
        const modifier = this.undertoneModifiers[undertone];
        
        // Apply all modifiers directly
        this.state.sizeMultiplier = modifier.sizeMultiplier;
        this.state.jitterAmount = modifier.jitterAmount || 0;
        this.state.episodicFlutter = modifier.episodicFlutter || false;
        this.state.glowRadiusMult = modifier.glowRadiusMult;
        this.state.breathRateMult = modifier.breathRateMult;
        this.state.breathDepthMult = modifier.breathDepthMult;
        this.state.breathIrregular = modifier.breathIrregular || false;
        this.state.particleRateMult = 1.0;
    }
    
    /**
     * Apply undertone shifts to a color using saturation-based depth
     * @param {string} baseColor - Base hex color
     * @param {string|null|Object} undertone - Undertone name or weighted modifier object
     * @returns {string} Modified hex color
     * 
     * Undertone saturation creates visual depth:
     * - INTENSE   : +60% saturation (electric, overwhelming)
     * - CONFIDENT : +30% saturation (bold, present) 
     * - NERVOUS   : +15% saturation (slightly heightened)
     * - CLEAR     :   0% saturation (normal midtone)
     * - TIRED     : -20% saturation (washed out, fading)
     * - SUBDUED   : -50% saturation (ghostly, withdrawn)
     */
    applyUndertoneToColor(baseColor, undertone) {
        return this.colorUtilities.applyUndertoneToColor(baseColor, undertone);
    }
    
    hexToRgb(hex) {
        return this.colorUtilities.hexToRgb(hex);
    }
    
    rgbToHsl(r, g, b) {
        return this.colorUtilities.rgbToHsl(r, g, b);
    }
    
    hslToHex(h, s, l) {
        return this.colorUtilities.hslToHex(h, s, l);
    }
    
    hexToRgba(hex, alpha = 1) {
        const rgb = this.hexToRgb(hex);
        if (!rgb) return `rgba(255, 255, 255, ${alpha})`;
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    }
    
    startColorTransition(targetColor, targetIntensity, duration = 1500) {
        this.colorUtilities.currentColor = this.state.glowColor;
        this.colorUtilities.currentIntensity = this.state.glowIntensity;
        this.colorUtilities.startColorTransition(targetColor, targetIntensity, duration);
        this.colorTransition = this.colorUtilities.colorTransition;
    }
    
    updateColorTransition(deltaTime) {
        const result = this.colorUtilities.updateColorTransition(deltaTime);
        if (result) {
            this.state.glowColor = result.color;
            this.state.glowIntensity = result.intensity;
            this.colorTransition = this.colorUtilities.colorTransition;
        }
    }
    
    /**
     * Update just the undertone without resetting emotion
     */
    updateUndertone(undertone) {
        // Clear glow cache when undertone changes (colors will change)
        if (this.state.undertone !== undertone) {
            this.glowCache.clear();
        }
        
        // Store undertone for color processing
        this.state.undertone = undertone;
        this.currentUndertone = undertone;
        
        // Get weighted undertone modifier from state machine if available
        const weightedModifier = this.stateMachine && this.stateMachine.getWeightedUndertoneModifiers ? 
                                this.stateMachine.getWeightedUndertoneModifiers() : null;
        
        // Apply all undertone modifiers (visual, breathing only - no particles)
        this.applyUndertoneModifiers(weightedModifier || undertone);
        
        // Update colors with the new undertone
        if (this.state.emotion) {
            const emotionConfig = getEmotion(this.state.emotion);
            if (emotionConfig) {
                const baseColor = emotionConfig.glowColor || this.config.defaultGlowColor;
                const targetColor = this.applyUndertoneToColor(baseColor, weightedModifier || undertone);
                
                // Start color transition to new undertone color (faster for responsiveness)
                this.startColorTransition(targetColor, 200); // 200ms transition
            }
        }
    }
    
    /**
     * Set emotional state
     */
    setEmotionalState(emotion, properties, undertone = null) {
        
        // Clear glow cache when emotion or undertone changes (colors will change)
        if (this.state.emotion !== emotion || this.state.undertone !== undertone) {
            this.glowCache.clear();
        }
        
        // Store undertone for color processing
        this.state.undertone = undertone;
        this.currentUndertone = undertone;
        
        // Get weighted undertone modifier from state machine if available
        const weightedModifier = this.stateMachine && this.stateMachine.getWeightedUndertoneModifiers ? 
                                this.stateMachine.getWeightedUndertoneModifiers() : null;
        
        // Apply all undertone modifiers (visual, breathing, particles)
        this.applyUndertoneModifiers(weightedModifier || undertone);
        
        // Get base color and apply undertone shifts
        const baseColor = properties.glowColor || this.config.defaultGlowColor;
        
        // Get target color - for suspicion, use the dynamic color directly
        let targetColor;
        if (emotion === 'suspicion') {
            // Use the dynamic color from properties (includes threat level)
            targetColor = properties.glowColor || baseColor;
        } else {
            targetColor = this.applyUndertoneToColor(baseColor, weightedModifier || undertone);
        }
        
        // Apply intensity modifier from undertone
        const modifier = weightedModifier || (undertone ? this.undertoneModifiers[undertone] : null);
        const baseIntensity = properties.glowIntensity || 1.0;
        
        // Get the glow multiplier - check for glowRadiusMult or use default of 1.0
        let glowMult = 1.0;
        if (modifier) {
            if (weightedModifier) {
                // For weighted modifiers, check if glowRadiusMult exists
                // Check for NaN in weight calculation
                const weight = modifier.weight || 0;
                if (modifier.glowRadiusMult !== undefined && isFinite(modifier.glowRadiusMult) && isFinite(weight)) {
                    glowMult = 1.0 + (modifier.glowRadiusMult - 1.0) * weight;
                } else {
                    glowMult = 1.0;
                }
            } else {
                // For non-weighted modifiers, use glowRadiusMult if it exists
                glowMult = modifier.glowRadiusMult !== undefined ? modifier.glowRadiusMult : 1.0;
            }
        }
        
        const targetIntensity = baseIntensity * glowMult;
        
        // Determine transition duration based on emotion
        let duration = 1500; // Default 1.5s
        if (emotion === 'anger' || emotion === 'fear') {
            duration = 800; // Quick transitions for urgent emotions
        } else if (emotion === 'sadness' || emotion === 'resting') {
            duration = 2000; // Slower for calming emotions
        } else if (emotion === 'zen') {
            duration = 2000; // Zen gets special timing during lotus bloom
        }
        
        // Update emotion state BEFORE handling transitions to avoid timing issues
        const previousEmotion = this.state.emotion;
        this.state.emotion = emotion;
        
        // Handle suspicion state
        if (emotion === 'suspicion') {
            this.state.isSuspicious = true;
            // Store target squint amount, we'll animate to it
            this.state.targetSquintAmount = properties && properties.coreSquint ? properties.coreSquint : 0.4;
            if (this.state.squintAmount === undefined) {
                this.state.squintAmount = 0; // Start from no squint
            }
            this.state.lastScanTime = Date.now();
            this.state.scanPhase = 0;
        } else {
            this.state.isSuspicious = false;
            this.state.targetSquintAmount = 0;
            if (this.state.squintAmount === undefined) {
                this.state.squintAmount = 0;
            }
        }
        
        // Handle zen state transitions specially
        if (emotion === 'zen' && previousEmotion !== 'zen') {
            // Entering zen - will handle its own color transition during lotus bloom
            this.enterZenMode(targetColor, targetIntensity);
        } else if (previousEmotion === 'zen' && emotion !== 'zen') {
            // Exiting zen - will handle its own color transition during lotus close
            this.exitZenMode(emotion, targetColor, targetIntensity);
        } else {
            // Standard color transition for all other state changes
            this.startColorTransition(targetColor, targetIntensity, duration);
        }
        
        // Apply breathing with undertone modifiers
        const baseBreathRate = properties.breathRate || 1.0;
        const baseBreathDepth = properties.breathDepth || this.config.breathingDepth;
        this.state.breathRate = modifier ? baseBreathRate * modifier.breathRateMult : baseBreathRate;
        this.state.breathDepth = modifier ? baseBreathDepth * modifier.breathDepthMult : baseBreathDepth;
        
        // Jitter combines emotion jitter with undertone jitter
        this.state.coreJitter = properties.coreJitter || (modifier && modifier.jitterAmount > 0);
        this.state.emotionEyeOpenness = properties.eyeOpenness;
        this.state.emotionEyeArc = properties.eyeArc;
    }
    
    /**
     * Set BPM for rhythm features
     * @param {number} bpm - Beats per minute
     */
    setBPM(bpm) {
        // BPM-locked rotation has been removed
        // This method is kept for other rhythm-related features
    }

    /**
     * Set manual rotation speed
     * @param {number} speed - Rotation speed in degrees per frame (like velocity)
     */
    setRotationSpeed(speed) {
        // Direct degrees per frame, no conversion needed
        this.state.rotationSpeed = speed;
    }

    /**
     * Set manual rotation angle directly (for scratching)
     * @param {number} angle - Rotation angle in DEGREES
     */
    setRotationAngle(angle) {
        this.state.manualRotation = angle;
    }
    
    /**
     * Set gaze data from GazeTracker
     * @param {Object} gazeData - Contains offset, proximity, and lock status
     */
    setGazeOffset(gazeData) {
        // Handle both old format (just offset) and new format (full data)
        if (typeof gazeData === 'object' && gazeData !== null) {
            if (gazeData.hasOwnProperty('x') && gazeData.hasOwnProperty('y')) {
                // Old format - just offset
                this.state.gazeOffset = gazeData;
            } else {
                // New format - full gaze data
                this.state.gazeOffset = gazeData.offset || { x: 0, y: 0 };
                this.state.gazeIntensity = gazeData.proximity || 0;
                this.state.gazeLocked = gazeData.isLocked || false;
            }
        }
        
        // Reset idle timer on interaction
        this.idleTimer = 0;
        if (this.isAsleep) {
            this.wakeUp();
        }
    }
    
    /**
     * Get current orb position (center + gaze offset)
     */
    getCurrentOrbPosition() {
        const logicalWidth = this.canvasManager.width;
        const logicalHeight = this.canvasManager.height;
        const centerX = logicalWidth / 2;
        const centerY = logicalHeight / 2 - this.config.topOffset;
        
        return {
            x: centerX + this.state.gazeOffset.x,
            y: centerY + this.state.gazeOffset.y
        };
    }
    
    /**
     * Sets a custom scale for the orb (used for breathing exercises)
     * @param {number} scale - Scale factor (1.0 = normal)
     */
    setCustomScale(scale) {
        this.state.customScale = scale;
    }
    
    /**
     * Start speaking animation
     */
    startSpeaking() {
        this.state.speaking = true;
        this.speakingRings = [];
        this.ringSpawnTimer = 0;
    }
    
    /**
     * Stop speaking animation
     */
    stopSpeaking() {
        this.state.speaking = false;
        this.speakingRings = [];
    }
    
    /**
     * Enter sleep mode with animation
     */
    enterSleepMode() {
        this.state.sleeping = true;
        this.sleepZ = []; // Reset Z's
        this.state.eyeOpenness = 1.0; // Start with eyes open
        
        // Initialize dimming values (start at full brightness)
        this.state.sleepDimness = 1.0;
        this.state.sleepScale = 1.0;
        
        // Force end any active blink
        this.state.blinking = false;
        
        // Animate eye closing, then dimming
        this.animateEyeClose();
        
    }
    
    /**
     * Animate eye closing for sleep, then dim
     */
    animateEyeClose() {
        // Cancel any existing eye animations
        if (this.loopCallbackIds.eyeClose) {
            animationLoopManager.unregister(this.loopCallbackIds.eyeClose);
            this.loopCallbackIds.eyeClose = null;
        }
        if (this.loopCallbackIds.eyeOpen) {
            animationLoopManager.unregister(this.loopCallbackIds.eyeOpen);
            this.loopCallbackIds.eyeOpen = null;
        }
        
        const startTime = performance.now();
        const eyeCloseDuration = 2000; // 2 seconds to close eyes
        const dimDuration = 1000; // 1 second to dim after eyes close
        
        const animate = () => {
            if (!this.state.sleeping) {
                // Clean up loop callback ID
                this.loopCallbackIds.eyeClose = null;
                return; // Stop if woken up
            }
            
            const elapsed = performance.now() - startTime;
            
            if (elapsed < eyeCloseDuration) {
                // Phase 1: Close eyes
                const progress = elapsed / eyeCloseDuration;
                const eased = 1 - Math.pow(progress, 2);
                this.state.eyeOpenness = 0.1 + eased * 0.9; // Close to 0.1 (nearly closed)
                
                // Keep full brightness during eye closing
                this.state.sleepDimness = 1.0;
                this.state.sleepScale = 1.0;
                
                // Continue animation on next frame
            } else if (elapsed < eyeCloseDuration + dimDuration) {
                // Phase 2: Dim the orb
                const dimProgress = (elapsed - eyeCloseDuration) / dimDuration;
                const dimEased = 1 - Math.pow(1 - dimProgress, 3); // Ease out cubic
                
                // Keep eyes closed
                this.state.eyeOpenness = 0.1;
                
                // Animate dimming and scaling
                this.state.sleepDimness = 1.0 - (dimEased * 0.4); // Dim to 0.6
                this.state.sleepScale = 1.0 - (dimEased * 0.1); // Scale to 0.9
                
                // Continue animation on next frame
            } else {
                // Final state
                this.state.eyeOpenness = 0.1;
                this.state.sleepDimness = 0.6;
                this.state.sleepScale = 0.9;
                // Clean up loop callback ID
                this.loopCallbackIds.eyeClose = null;
            }
        };

        // Register with AnimationLoopManager
        this.loopCallbackIds.eyeClose = animationLoopManager.register(
            animate,
            AnimationPriority.HIGH, // Eye animations are high priority
            this
        );
    }
    
    /**
     * Wake up from sleep with animation
     */
    wakeUp() {
        if (!this.state.sleeping) return;
        
        this.state.sleeping = false;
        this.state.breathRate = 1.0;
        this.state.breathDepth = this.config.breathingDepth;
        this.sleepZ = []; // Clear Z's
        
        // Reset blinking state
        this.state.blinking = false;
        // Blinking now handled by EyeRenderer
        this.eyeRenderer.blinking = false;
        this.eyeRenderer.blinkTimer = 0;
        
        // Animate eye opening
        this.animateEyeOpen();
        
        // Quick shake animation
        this.state.coreJitter = true;
        setTimeout(() => {
            this.state.coreJitter = false;
        }, 200);
        
    }
    
    /**
     * Animate eye opening after wake - brighten first, then open eyes
     */
    animateEyeOpen() {
        // Cancel any existing eye animations
        if (this.loopCallbackIds.eyeOpen) {
            animationLoopManager.unregister(this.loopCallbackIds.eyeOpen);
            this.loopCallbackIds.eyeOpen = null;
        }
        if (this.loopCallbackIds.eyeClose) {
            animationLoopManager.unregister(this.loopCallbackIds.eyeClose);
            this.loopCallbackIds.eyeClose = null;
        }
        
        const startTime = performance.now();
        const brightenDuration = 500; // 0.5 seconds to brighten
        const eyeOpenDuration = 1000; // 1 second to open eyes
        
        const animate = () => {
            const elapsed = performance.now() - startTime;
            
            if (elapsed < brightenDuration) {
                // Phase 1: Brighten the orb
                const progress = elapsed / brightenDuration;
                const eased = Math.sin(progress * Math.PI / 2); // Smooth acceleration
                
                // Animate brightening and scaling back
                this.state.sleepDimness = 0.6 + (eased * 0.4); // Brighten from 0.6 to 1.0
                this.state.sleepScale = 0.9 + (eased * 0.1); // Scale from 0.9 to 1.0
                
                // Keep eyes closed during brightening
                this.state.eyeOpenness = 0.1;
                
                // Continue animation on next frame
            } else if (elapsed < brightenDuration + eyeOpenDuration) {
                // Phase 2: Open eyes
                const eyeProgress = (elapsed - brightenDuration) / eyeOpenDuration;
                const eyeEased = Math.sin(eyeProgress * Math.PI / 2); // Smooth acceleration
                
                // Keep full brightness
                this.state.sleepDimness = 1.0;
                this.state.sleepScale = 1.0;
                
                // Animate eye opening
                this.state.eyeOpenness = 0.1 + eyeEased * 0.9; // Open from 0.1 to 1.0
                
                // Continue animation on next frame
            } else {
                // Final state
                this.state.eyeOpenness = 1.0;
                this.state.sleepDimness = 1.0;
                this.state.sleepScale = 1.0;
                // Clean up loop callback ID
                this.loopCallbackIds.eyeOpen = null;
            }
        };

        // Register with AnimationLoopManager
        this.loopCallbackIds.eyeOpen = animationLoopManager.register(
            animate,
            AnimationPriority.HIGH, // Eye animations are high priority
            this
        );
    }
    
    /**
     * Enter zen meditation mode with animation
     */
    enterZenMode(targetColor, targetIntensity) {
        // Cancel any existing zen animations
        if (this.animationFrameIds.zenEnter) {
            cancelAnimationFrame(this.animationFrameIds.zenEnter);
            this.animationFrameIds.zenEnter = null;
        }
        if (this.animationFrameIds.zenExit) {
            cancelAnimationFrame(this.animationFrameIds.zenExit);
            this.animationFrameIds.zenExit = null;
        }
        
        // Set to zen color with target intensity
        this.state.glowColor = targetColor;
        this.state.glowIntensity = targetIntensity; // Keep the glow
        
        // Cancel any active color transition
        this.colorTransition.active = false;
        
        this.zenTransition = {
            active: true,
            phase: 'entering',
            startTime: performance.now(),
            previousEmotion: this.state.emotion,
            targetEmotion: null,
            scaleX: 1.0,
            scaleY: 1.0,
            arcHeight: 0,
            lotusMorph: 0,     // 0 = no lotus, 1 = full lotus
            petalSpread: 0,    // 0 = closed petals, 1 = full spread
            smileCurve: 0      // 0 = no smile, 1 = full smile
        };
        
        const animate = () => {
            if (!this.zenTransition.active || this.zenTransition.phase !== 'entering') {
                // Clean up loop callback ID
                this.loopCallbackIds.zenEnter = null;
                return;
            }
            
            const elapsed = performance.now() - this.zenTransition.startTime;
            const lotusMorphDuration = 400; // 0.4s for lotus to bloom - smooth transition
            
            if (elapsed < lotusMorphDuration) {
                // Direct lotus blooming - no intro animation
                const lotusProgress = elapsed / lotusMorphDuration;
                const lotusEased = 1 - Math.pow(1 - lotusProgress, 2); // Ease out quad
                
                // Direct lotus bloom without arc or narrowing
                this.zenTransition.scaleX = 1.0;
                this.zenTransition.scaleY = 1.0;  // Full size
                this.zenTransition.arcHeight = 0;  // No arc
                
                // Morph the lotus shape directly
                this.zenTransition.lotusMorph = lotusEased; // 0 to 100%
                this.zenTransition.petalSpread = lotusEased;
                
                // Smile appears gradually
                this.zenTransition.smileCurve = Math.sin(lotusProgress * Math.PI / 2); // Smooth ease
                
                // Register with AnimationLoopManager
        this.loopCallbackIds.zenEnter = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
            } else {
                // Final state - in meditation with full lotus, then start floating
                this.zenTransition.phase = 'in';
                this.zenTransition.scaleX = 1.0;
                this.zenTransition.scaleY = 1.0;  // Full size
                this.zenTransition.arcHeight = 0;  // No arc
                this.zenTransition.lotusMorph = 1.0;
                this.zenTransition.petalSpread = 1.0;
                this.zenTransition.smileCurve = 1.0;
                
                // Set gentle vortex for zen state
                this.state.zenVortexIntensity = 1.0;  // Can be adjusted: 0.5 = very gentle, 2.0 = strong
                // Clean up loop callback ID
                this.loopCallbackIds.zenEnter = null;
            }
        };
        
        // Register with AnimationLoopManager
        this.loopCallbackIds.zenEnter = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
    }
    
    /**
     * Exit zen meditation mode with awakening animation
     */
    exitZenMode(targetEmotion, targetColor, targetIntensity) {
        if (!this.zenTransition.active || this.zenTransition.phase !== 'in') return;
        
        // Cancel any existing zen animations
        if (this.animationFrameIds.zenEnter) {
            cancelAnimationFrame(this.animationFrameIds.zenEnter);
            this.animationFrameIds.zenEnter = null;
        }
        if (this.animationFrameIds.zenExit) {
            cancelAnimationFrame(this.animationFrameIds.zenExit);
            this.animationFrameIds.zenExit = null;
        }
        
        this.zenTransition.phase = 'exiting';
        this.zenTransition.startTime = performance.now();
        this.zenTransition.targetEmotion = targetEmotion;
        
        const animate = () => {
            if (!this.zenTransition.active || this.zenTransition.phase !== 'exiting') {
                // Clean up loop callback ID
                this.loopCallbackIds.zenExit = null;
                return;
            }
            
            const elapsed = performance.now() - this.zenTransition.startTime;
            const straightenDuration = 150; // 0.15s to straighten arc - FAST
            const awakeDuration = 200; // 0.2s for awakening gestures - FAST
            const expandDuration = 200; // 0.2s to expand back - FAST
            const settleDuration = 100; // 0.1s for final settle - FAST
            
            if (elapsed < straightenDuration) {
                // Phase 1: Lotus closing and arc straightening - start color transition
                const progress = elapsed / straightenDuration;
                const eased = 1 - Math.pow(1 - progress, 2);
                
                // Start color transition at beginning of exit
                if (progress === 0 || !this.colorTransition.active) {
                    this.startColorTransition(targetColor, targetIntensity, straightenDuration);
                }
                
                this.zenTransition.arcHeight = 1.5 * (1 - eased); // Flatten arc from full height
                
                // Close lotus petals quickly
                this.zenTransition.smileCurve = 1.0 * (1 - eased); // Smile fades first
                if (progress > 0.3) {
                    const petalProgress = (progress - 0.3) / 0.7;
                    this.zenTransition.petalSpread = 1.0 * (1 - petalProgress); // Petals close
                }
                if (progress > 0.5) {
                    const morphProgress = (progress - 0.5) / 0.5;
                    this.zenTransition.lotusMorph = 1.0 * (1 - morphProgress); // Lotus disappears
                }
                
                // Register with AnimationLoopManager
        this.loopCallbackIds.zenExit = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
            } else if (elapsed < straightenDuration + awakeDuration) {
                // Phase 2: Awakening gestures
                const awakeProgress = (elapsed - straightenDuration) / awakeDuration;
                
                // Lotus is fully closed by now
                this.zenTransition.lotusMorph = 0;
                this.zenTransition.petalSpread = 0;
                this.zenTransition.smileCurve = 0;
                
                // Slow blink (0-0.3)
                if (awakeProgress < 0.2) {
                    const blinkProg = awakeProgress / 0.2;
                    this.zenTransition.scaleY = 1.0 - (Math.sin(blinkProg * Math.PI) * 0.8);
                }
                // Gentle shake (0.3-0.6)
                else if (awakeProgress < 0.6) {
                    const shakeProg = (awakeProgress - 0.2) / 0.4;
                    this.zenTransition.scaleY = 1.0;
                    // Add small X offset for shake (will be applied in render)
                    this.state.shakeOffset = Math.sin(shakeProg * Math.PI * 4) * 3;
                }
                // Upward drift with brighten (0.6-1.0)
                else {
                    const driftProg = (awakeProgress - 0.6) / 0.4;
                    this.state.driftY = -10 * driftProg;
                    this.state.glowIntensity = 1.0 + (0.5 * driftProg); // Brighten
                }
                
                // Register with AnimationLoopManager
        this.loopCallbackIds.zenExit = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
            } else if (elapsed < straightenDuration + awakeDuration + expandDuration) {
                // Phase 3: Horizontal expansion (sunrise)
                const expandProgress = (elapsed - straightenDuration - awakeDuration) / expandDuration;
                const expandEased = Math.sin(expandProgress * Math.PI / 2);
                
                this.zenTransition.scaleX = 1.0;
                this.zenTransition.scaleY = 0.2 + (expandEased * 0.8); // Expand vertically back to 1.0 (sunrise)
                this.state.driftY = -10 * (1 - expandProgress); // Return to center
                this.state.glowIntensity = 1.5 - (0.5 * expandProgress); // Normal glow
                
                // Register with AnimationLoopManager
        this.loopCallbackIds.zenExit = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
            } else if (elapsed < straightenDuration + awakeDuration + expandDuration + settleDuration) {
                // Phase 4: Final settle pulse
                const settleProgress = (elapsed - straightenDuration - awakeDuration - expandDuration) / settleDuration;
                const pulse = Math.sin(settleProgress * Math.PI);
                
                this.zenTransition.scaleX = 1.0 + (pulse * 0.05);
                this.zenTransition.scaleY = 1.0 + (pulse * 0.05);
                
                // Register with AnimationLoopManager
        this.loopCallbackIds.zenExit = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
            } else {
                // Complete - reset to normal
                this.zenTransition.active = false;
                this.zenTransition.phase = null;
                this.zenTransition.scaleX = 1.0;
                this.zenTransition.scaleY = 1.0;
                this.zenTransition.arcHeight = 0;
                this.zenTransition.lotusMorph = 0;
                this.zenTransition.petalSpread = 0;
                this.zenTransition.smileCurve = 0;
                this.state.shakeOffset = 0;
                this.state.driftY = 0;
                // Clean up loop callback ID
                this.loopCallbackIds.zenExit = null;
            }
        };
        
        // Register with AnimationLoopManager
        this.loopCallbackIds.zenExit = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
    }
    
    /**
     * Start recording mode
     */
    startRecording() {
        this.state.recording = true;
    }
    
    /**
     * Stop recording mode
     */
    stopRecording() {
        this.state.recording = false;
    }
    
    /**
     * Get random blink time (2-6 seconds)
     */
    
    /**
     * Set whether blinking is enabled
     * @param {boolean} enabled - Whether blinking should be enabled
     */
    setBlinkingEnabled(enabled) {
        this.state.blinkingEnabled = enabled;
        if (!enabled) {
            // If disabling blinking, immediately stop any current blink
            this.state.blinking = false;
            // Reset blinking via EyeRenderer
            this.eyeRenderer.blinking = false;
            this.eyeRenderer.blinkTimer = 0;
        }
    }

    /**
     * Set gaze tracking enabled state
     * @param {boolean} enabled - Whether gaze tracking should be enabled
     */
    setGazeTracking(enabled) {
        this.state.gazeTrackingEnabled = enabled;
        if (enabled) {
            // Start tracking mouse/touch position
            if (!this.gazeTrackingInitialized) {
                this.initGazeTracking();
            }
        } else {
            // Reset gaze to center when disabled
            this.state.gazeTarget = { x: 0, y: 0 };
        }
    }

    /**
     * Initialize gaze tracking event listeners
     */
    initGazeTracking() {
        // Always set up listeners once
        if (this.gazeTrackingInitialized) return;

        this.handleMouseMove = (e) => {
            if (!this.state.gazeTrackingEnabled) return;

            const rect = this.canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const x = e.clientX - rect.left - centerX;
            const y = e.clientY - rect.top - centerY;

            // Normalize to -1 to 1 range
            this.state.gazeTarget = {
                x: x / centerX,
                y: y / centerY
            };
        };

        this.handleTouchMove = (e) => {
            if (!this.state.gazeTrackingEnabled) return;

            if (e.touches.length > 0) {
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                const x = touch.clientX - rect.left - centerX;
                const y = touch.clientY - rect.top - centerY;

                // Normalize to -1 to 1 range
                this.state.gazeTarget = {
                    x: x / centerX,
                    y: y / centerY
                };
            }
        };

        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('touchmove', this.handleTouchMove);
        this.gazeTrackingInitialized = true;
    }

    /**
     * Clean up gaze tracking event listeners
     */
    cleanupGazeTracking() {
        if (!this.gazeTrackingInitialized) return;

        if (this.handleMouseMove) {
            document.removeEventListener('mousemove', this.handleMouseMove);
        }
        if (this.handleTouchMove) {
            document.removeEventListener('touchmove', this.handleTouchMove);
        }
        this.gazeTrackingInitialized = false;
    }

    /**
     * Reset canvas context to fix rendering artifacts after tab switch
     */
    resetCanvasContext() {
        if (!this.canvas || !this.ctx) return;

        // Save current dimensions
        const width = this.canvas.width;
        const height = this.canvas.height;

        // Reset all canvas state
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.globalAlpha = 1;
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';

        // Clear the entire canvas
        this.ctx.clearRect(0, 0, width, height);

        // Also reset offscreen canvas if it exists
        if (this.offscreenCanvas && this.offscreenCtx) {
            this.offscreenCtx.setTransform(1, 0, 0, 1, 0, 0);
            this.offscreenCtx.globalAlpha = 1;
            this.offscreenCtx.globalCompositeOperation = 'source-over';
            this.offscreenCtx.imageSmoothingEnabled = true;
            this.offscreenCtx.imageSmoothingQuality = 'high';
            this.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
        }

        // Reset context state manager if it exists
        if (this.contextStateManager) {
            this.contextStateManager.reset();
        }

        // Force a clean render on next frame
        this.forceCleanRender = true;
    }

    /**
     * Convert hex to rgba
     */
    hexToRgba(hex, alpha = 1) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
            return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha})`;
        }
        return `rgba(0, 0, 0, ${alpha})`;
    }
    
    /**
     * Set quality level for degradation manager compatibility
     * @param {number} quality - Quality level (0-1)
     */
    setQualityLevel(quality) {
        this.qualityLevel = Math.max(0, Math.min(1, quality));
        
        // Adjust rendering parameters based on quality
        if (this.qualityLevel < 0.5) {
            // Low quality mode
            this.ctx.imageSmoothingEnabled = false;
            this.state.breathDepth *= 0.5; // Reduce animation complexity
        } else if (this.qualityLevel < 0.8) {
            // Medium quality
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'medium';
        } else {
            // High quality
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'high';
        }
    }
    
    /**
     * Set quality reduction (for degradation manager)
     * @param {boolean} enabled - Whether quality reduction is enabled
     */
    setQualityReduction(enabled) {
        if (enabled) {
            this.setQualityLevel(0.5);
        } else {
            this.setQualityLevel(1.0);
        }
    }
    
    /**
     * Handle canvas context recovery
     * @param {CanvasRenderingContext2D} newContext - New context after recovery
     */
    handleContextRecovery(newContext) {
        this.ctx = newContext;
    }
    
    /**
     * Get the current undertone modifier for particle system
     * @returns {Object|null} Current undertone modifier or null
     */
    getUndertoneModifier() {
        // Use the new weighted method from state machine if available
        if (this.stateMachine && this.stateMachine.getWeightedUndertoneModifiers) {
            return this.stateMachine.getWeightedUndertoneModifiers();
        }
        
        // Fallback to old method
        if (!this.currentUndertone || !this.undertoneModifiers[this.currentUndertone]) {
            return null;
        }
        return this.undertoneModifiers[this.currentUndertone];
    }
    
    /**
     * Apply all active gesture animations
     * Returns combined transform object
     */
    // Gesture animations moved to GestureAnimator module
    applyGestureAnimations() {
        return this.gestureAnimator.applyGestureAnimations();
    }
      
    /**
     * Start a gesture animation - delegates to GestureAnimator
     */
    startGesture(gestureName) {
        // Simply delegate to GestureAnimator
        return this.gestureAnimator.startGesture(gestureName);
    }
    
    /**
     * Get current active gesture information for particle system
     * @returns {Object|null} Current gesture with particleMotion and progress, or null
     */
    getCurrentGesture() {
        // Delegate to GestureAnimator to get current gesture
        return this.gestureAnimator.getCurrentGesture();
    }
    
    // Individual start methods for each gesture - delegate to GestureAnimator
    startBounce() { this.gestureAnimator.startBounce(); }
    startPulse() { this.gestureAnimator.startPulse(); }
    startShake() { this.gestureAnimator.startShake(); }
    startSpin() { this.gestureAnimator.startSpin(); }
    startNod() { this.gestureAnimator.startNod(); }
    startTilt() { this.gestureAnimator.startTilt(); }
    startExpand() { this.gestureAnimator.startExpand(); }
    startContract() { this.gestureAnimator.startContract(); }
    startFlash() { this.gestureAnimator.startFlash(); }
    startDrift() { this.gestureAnimator.startDrift(); }
    startStretch() { this.gestureAnimator.startStretch(); }
    startGlow() { this.gestureAnimator.startGlow(); }
    startFlicker() { this.gestureAnimator.startFlicker(); }
    startVibrate() { this.gestureAnimator.startVibrate(); }
    startOrbital() { this.gestureAnimator.startOrbital(); }
    startHula() { this.gestureAnimator.startHula(); }
    startWave() { this.gestureAnimator.startWave(); }
    startBreathe() { this.gestureAnimator.startBreathe(); }
    startMorph() { this.gestureAnimator.startMorph(); }
    startSlowBlink() { this.gestureAnimator.startSlowBlink(); }
    startLook() { this.gestureAnimator.startLook(); }
    startSettle() { this.gestureAnimator.startSettle(); }
    startBreathIn() { this.gestureAnimator.startBreathIn(); }
    startBreathOut() { this.gestureAnimator.startBreathOut(); }
    startBreathHold() { this.gestureAnimator.startBreathHold(); }
    startBreathHoldEmpty() { this.gestureAnimator.startBreathHoldEmpty(); }
    startJump() { this.gestureAnimator.startJump(); }
    startSway() { this.gestureAnimator.startSway(); }
    startFloat() { this.gestureAnimator.startFloat(); }
    startRain() { this.gestureAnimator.startRain(); }
    startRunningMan() { this.gestureAnimator.startRunningMan(); }
    startCharleston() { this.gestureAnimator.startCharleston(); }

    // Ambient dance animations
    startGrooveSway(options) { this.ambientDanceAnimator.startAmbientAnimation('grooveSway', options); }
    startGrooveBob(options) { this.ambientDanceAnimator.startAmbientAnimation('grooveBob', options); }
    startGrooveFlow(options) { this.ambientDanceAnimator.startAmbientAnimation('grooveFlow', options); }
    startGroovePulse(options) { this.ambientDanceAnimator.startAmbientAnimation('groovePulse', options); }
    startGrooveStep(options) { this.ambientDanceAnimator.startAmbientAnimation('grooveStep', options); }
    startSparkle() { this.gestureAnimator.startSparkle(); }
    startShimmer() { this.gestureAnimator.startShimmer(); }
    startWiggle() { this.gestureAnimator.startWiggle(); }
    startGroove() { this.gestureAnimator.startGroove(); }
    startPoint() { this.gestureAnimator.startPoint(); }
    startLean() { this.gestureAnimator.startLean(); }
    startReach() { this.gestureAnimator.startReach(); }
    startHeadBob() { this.gestureAnimator.startHeadBob(); }
    startOrbit() { this.gestureAnimator.startOrbit(); }
    
    /**
     * Stop all active gestures - delegates to GestureAnimator
     */
    stopAllGestures() {
        this.gestureAnimator.stopAllGestures();
        this.currentGesture = null;
    }
    
    /**
     * Check if any gesture is active - delegates to GestureAnimator
     */
    isGestureActive() {
        return Object.values(this.gestureAnimator.gestureAnimations).some(anim => anim.active);
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        // Cancel all animation frames to prevent memory leaks
        for (const key in this.animationFrameIds) {
            if (this.animationFrameIds[key]) {
                cancelAnimationFrame(this.animationFrameIds[key]);
                this.animationFrameIds[key] = null;
            }
        }
        
        // Clear animation states
        this.colorTransition.active = false;
        if (this.zenTransition) {
            this.zenTransition.active = false;
        }
        
        // Clear other resources
        this.speakingRings = [];
        
        // Clear gesture compositor cache
        if (this.gestureCompositor) {
            this.gestureCompositor.clearCache();
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  GAZE TRACKER  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Gaze Tracker - Interactive Eye Following & Cursor Awareness
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module GazeTracker
 * @changelog 2.1.0 - Cached canvas rect to eliminate reflows on mouse/touch moves
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Brings the orb to LIFE by making it aware of your cursor. Creates natural         
 * ║ eye-following behavior with smooth interpolation. When you move close,            
 * ║ the orb "looks" at you. Move away, and it relaxes back to center.                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 👁️ GAZE BEHAVIORS                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Smooth following with linear interpolation (lerp)                               
 * │ • Proximity-based engagement (closer = more response)                             
 * │ • Center lock when cursor is very close                                           
 * │ • Boundary constraints to keep pupils inside orb                                  
 * │ • Touch and mouse support                                                         
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎮 CONFIGURATION                                                                   
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • smoothing       : 0.1 (lerp factor, 0.05-0.15 recommended)                      
 * │ • maxOffset       : 0.3 (max gaze offset as % of core radius)                     
 * │ • lockDistance    : 30px (distance to trigger center lock)                        
 * │ • boundaryPadding : 0.8 (keep gaze within 80% of core)                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class GazeTracker {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        
        // Configuration
        this.config = {
            smoothing: options.smoothing || 0.1,  // Lerp factor (0.05-0.15 recommended)
            maxOffset: options.maxOffset || 0.3,  // Max gaze offset (30% of core radius)
            lockDistance: options.lockDistance || 30,  // Pixels from center to trigger lock
            enabled: options.enabled !== false,
            boundaryPadding: options.boundaryPadding || 0.8  // Keep gaze within 80% of core
        };
        
        // State
        this.canvasCenter = { x: 0, y: 0 };
        this.mousePos = { x: 0, y: 0 };  // Will be initialized to center after updateCanvasCenter
        this.targetGaze = { x: 0, y: 0 };
        this.currentGaze = { x: 0, y: 0 };
        this.isLocked = false;
        this.proximity = 0;  // 0-1 value for how close cursor is
        
        // Cache canvas rect to avoid reflows
        this.cachedRect = null;
        
        // Touch state
        this.touches = new Map();
        this.primaryTouch = null;
        
        // Bind event handlers
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseLeave = this.handleMouseLeave.bind(this);
        this.handleTouchStart = this.handleTouchStart.bind(this);
        this.handleTouchMove = this.handleTouchMove.bind(this);
        this.handleTouchEnd = this.handleTouchEnd.bind(this);
        
        // Interaction callback
        this.onInteraction = null;
        
        // Initialize
        this.updateCanvasCenter();
        this.attachEventListeners();
        
        // Handle canvas resize
        this.resizeObserver = new ResizeObserver(() => {
            this.updateCanvasCenter();
        });
        this.resizeObserver.observe(this.canvas);
    }
    
    /**
     * Update canvas center point
     */
    updateCanvasCenter() {
        // Cache the rect to avoid repeated reflows
        this.cachedRect = this.canvas.getBoundingClientRect();
        this.canvasCenter = {
            x: this.cachedRect.width / 2,
            y: this.cachedRect.height / 2
        };
        // Initialize mouse position to center if not set
        if (this.mousePos.x === 0 && this.mousePos.y === 0) {
            this.mousePos = { x: this.canvasCenter.x, y: this.canvasCenter.y };
        }
    }
    
    /**
     * Attach event listeners
     */
    attachEventListeners() {
        if (!this.config.enabled) return;
        
        // Mouse events
        this.canvas.addEventListener('mousemove', this.handleMouseMove);
        this.canvas.addEventListener('mouseleave', this.handleMouseLeave);
        
        // Touch events
        this.canvas.addEventListener('touchstart', this.handleTouchStart, { passive: true });
        this.canvas.addEventListener('touchmove', this.handleTouchMove, { passive: true });
        this.canvas.addEventListener('touchend', this.handleTouchEnd, { passive: true });
        this.canvas.addEventListener('touchcancel', this.handleTouchEnd, { passive: true });
    }
    
    /**
     * Handle mouse movement
     */
    handleMouseMove(event) {
        // Use cached rect to avoid reflow on every mouse move
        const rect = this.cachedRect || this.canvas.getBoundingClientRect();
        this.mousePos = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };
        this.updateTargetGaze();
        
        // Notify of interaction
        if (this.onInteraction) {
            this.onInteraction('mouse');
        }
    }
    
    /**
     * Handle mouse leave
     */
    handleMouseLeave() {
        // Return gaze to center when mouse leaves
        this.targetGaze = { x: 0, y: 0 };
        this.isLocked = false;
        this.proximity = 0;
        // Reset mouse position to center when leaving
        this.mousePos = { x: this.canvasCenter.x, y: this.canvasCenter.y };
    }
    
    /**
     * Handle touch start
     */
    handleTouchStart(event) {
        for (const touch of event.changedTouches) {
            this.touches.set(touch.identifier, {
                x: touch.clientX,
                y: touch.clientY
            });
            
            // Set first touch as primary
            if (!this.primaryTouch && this.touches.size === 1) {
                this.primaryTouch = touch.identifier;
            }
        }
        
        if (this.primaryTouch !== null) {
            this.updateTouchPosition(event.touches);
        }
    }
    
    /**
     * Handle touch move
     */
    handleTouchMove(event) {
        for (const touch of event.changedTouches) {
            if (this.touches.has(touch.identifier)) {
                this.touches.set(touch.identifier, {
                    x: touch.clientX,
                    y: touch.clientY
                });
            }
        }
        
        if (this.primaryTouch !== null) {
            this.updateTouchPosition(event.touches);
            
            // Notify of interaction
            if (this.onInteraction) {
                this.onInteraction('touch');
            }
        }
    }
    
    /**
     * Handle touch end
     */
    handleTouchEnd(event) {
        for (const touch of event.changedTouches) {
            this.touches.delete(touch.identifier);
            
            // Reset primary touch if it ended
            if (touch.identifier === this.primaryTouch) {
                this.primaryTouch = null;
                
                // Select new primary touch if available
                if (this.touches.size > 0) {
                    this.primaryTouch = this.touches.keys().next().value;
                } else {
                    // No touches left, return to center
                    this.handleMouseLeave();
                }
            }
        }
    }
    
    /**
     * Update position from touch
     */
    updateTouchPosition(touches) {
        for (const touch of touches) {
            if (touch.identifier === this.primaryTouch) {
                // Use cached rect to avoid reflow on every touch move
                const rect = this.cachedRect || this.canvas.getBoundingClientRect();
                this.mousePos = {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
                this.updateTargetGaze();
                break;
            }
        }
    }
    
    /**
     * Calculate target gaze position based on mouse/touch position
     */
    updateTargetGaze() {
        // Calculate vector from center to mouse
        const dx = this.mousePos.x - this.canvasCenter.x;
        const dy = this.mousePos.y - this.canvasCenter.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate proximity (0-1, closer = higher)
        const maxDistance = Math.min(this.canvasCenter.x, this.canvasCenter.y);
        this.proximity = Math.max(0, 1 - (distance / maxDistance));
        
        // Check for gaze lock (very close to center)
        this.isLocked = distance < this.config.lockDistance;
        
        if (this.isLocked) {
            // When locked, gaze moves more dramatically
            this.targetGaze = {
                x: dx * this.config.maxOffset * 2,
                y: dy * this.config.maxOffset * 2
            };
        } else {
            // Normal gaze following with boundary constraints
            const maxOffset = Math.min(this.canvasCenter.x, this.canvasCenter.y) * this.config.maxOffset;
            
            if (distance > 0) {
                // Normalize and apply max offset
                const factor = Math.min(1, distance / maxDistance);
                this.targetGaze = {
                    x: (dx / distance) * maxOffset * factor * this.config.boundaryPadding,
                    y: (dy / distance) * maxOffset * factor * this.config.boundaryPadding
                };
            } else {
                this.targetGaze = { x: 0, y: 0 };
            }
        }
    }
    
    /**
     * Update gaze position with smooth interpolation
     * @param {number} deltaTime - Time since last update in ms
     */
    update(deltaTime) {
        if (!this.config.enabled) return;
        
        // Smooth interpolation towards target
        const smoothing = 1 - Math.pow(1 - this.config.smoothing, deltaTime / 16.67); // Normalize to 60fps
        
        this.currentGaze.x += (this.targetGaze.x - this.currentGaze.x) * smoothing;
        this.currentGaze.y += (this.targetGaze.y - this.currentGaze.y) * smoothing;
        
        // Add micro jitter when locked for liveliness
        if (this.isLocked) {
            const jitter = 0.5;
            this.currentGaze.x += (Math.random() - 0.5) * jitter;
            this.currentGaze.y += (Math.random() - 0.5) * jitter;
        }
    }
    
    /**
     * Get current gaze offset for rendering
     * @param {number} coreRadius - The radius of the core
     * @returns {Object} Gaze offset {x, y}
     */
    getGazeOffset(coreRadius) {
        return {
            x: this.currentGaze.x,
            y: this.currentGaze.y
        };
    }
    
    /**
     * Get current state
     * @returns {Object} Current gaze state
     */
    getState() {
        return {
            gaze: { ...this.currentGaze },
            target: { ...this.targetGaze },
            proximity: this.proximity,
            isLocked: this.isLocked,
            isActive: this.config.enabled
        };
    }
    
    /**
     * Enable gaze tracking
     */
    enable() {
        if (!this.config.enabled) {
            this.config.enabled = true;
            this.attachEventListeners();
        }
    }
    
    /**
     * Disable gaze tracking
     */
    disable() {
        if (this.config.enabled) {
            this.config.enabled = false;
            this.detachEventListeners();
            this.targetGaze = { x: 0, y: 0 };
        }
    }
    
    /**
     * Detach event listeners
     */
    detachEventListeners() {
        this.canvas.removeEventListener('mousemove', this.handleMouseMove);
        this.canvas.removeEventListener('mouseleave', this.handleMouseLeave);
        this.canvas.removeEventListener('touchstart', this.handleTouchStart);
        this.canvas.removeEventListener('touchmove', this.handleTouchMove);
        this.canvas.removeEventListener('touchend', this.handleTouchEnd);
        this.canvas.removeEventListener('touchcancel', this.handleTouchEnd);
    }
    
    /**
     * Set interaction callback
     * @param {Function} callback - Function to call on interaction
     */
    setInteractionCallback(callback) {
        this.onInteraction = callback;
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        this.detachEventListeners();
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
        this.touches.clear();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  IDLE BEHAVIOR  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Idle Behavior - Organic Life Through Subtle Animations
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module IdleBehavior
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Makes the orb feel ALIVE even when you're not interacting. Random blinks,         
 * ║ subtle swaying, gentle breathing - all the little unconscious movements           
 * ║ that make something feel like it has a soul rather than just code.                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 😴 IDLE ANIMATIONS                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Blinking     : Random intervals (3-7 seconds)                                   
 * │ • Swaying      : Subtle drift (20-40 second intervals)                            
 * │ • Breathing    : Continuous gentle pulsing                                        
 * │ • Sleep Mode   : After timeout (default: never)                                   
 * │ • Weight Shift : Occasional position adjustments                                  
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⏱️ TIMING CONFIGURATION                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ BEHAVIOR       MIN TIME    MAX TIME    DURATION                                  
 * │ Blinking       3000ms      7000ms      150ms                                     
 * │ Swaying        20000ms     40000ms     4000ms                                    
 * │ Sleep          Infinity    -            -                                        
 * │ Breathing      continuous  -            0.25 rad/s                               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class IdleBehavior {
    constructor(options = {}) {
        // Configuration
        this.config = {
            blinkInterval: options.blinkInterval || { min: 3000, max: 7000 }, // ms - less frequent
            blinkDuration: options.blinkDuration || 150, // ms
            swayInterval: options.swayInterval || { min: 20000, max: 40000 }, // ms - very infrequent weight shifts
            swayDuration: options.swayDuration || 4000, // ms - very slow, smooth transition
            swayIntensity: options.swayIntensity || 1.5, // pixels - extremely subtle drift
            sleepTimeout: options.sleepTimeout !== undefined ? options.sleepTimeout : Infinity, // Default: never auto-sleep
            breathingSpeed: options.breathingSpeed || 0.25, // radians per second
            breathingDepth: options.breathingDepth || 0.1, // 10% size variation
            enabled: options.enabled !== false
        };
        
        // State
        this.state = {
            isBlinking: false,
            isSwaying: false,
            isAsleep: false,
            breathingPhase: 0,
            breathRate: 1.0,
            breathDepth: this.config.breathingDepth
        };
        
        // Timers
        this.timers = {
            idle: 0,
            blink: 0,
            sway: 0,
            swayProgress: 0,  // 0 to 1 progress through sway animation
            nextBlink: this.getRandomInterval('blink'),
            nextSway: this.getRandomInterval('sway')
        };
        
        // Sway state - smooth weight shift
        this.swayOffset = { x: 0, y: 0 };
        this.swayTarget = { x: 0, y: 0 };
        this.swayStart = { x: 0, y: 0 };
        
        // Callbacks
        this.callbacks = {
            onBlink: null,
            onSway: null,
            onSleep: null,
            onWake: null
        };
        
    }
    
    /**
     * Update idle behaviors
     * @param {number} deltaTime - Time since last update in ms
     */
    update(deltaTime) {
        if (!this.config.enabled) return;
        
        // Update breathing
        this.updateBreathing(deltaTime);
        
        // Update idle timer
        this.timers.idle += deltaTime;
        
        // Check for sleep
        if (!this.state.isAsleep && this.timers.idle >= this.config.sleepTimeout) {
            this.enterSleep();
        }
        
        // Update blinking (only when awake)
        if (!this.state.isAsleep) {
            this.updateBlinking(deltaTime);
        }
        
        // Update swaying (only when awake)
        if (!this.state.isAsleep) {
            this.updateSwaying(deltaTime);
        }
    }
    
    /**
     * Update breathing animation
     */
    updateBreathing(deltaTime) {
        const speed = this.config.breathingSpeed * this.state.breathRate;
        this.state.breathingPhase += (speed * deltaTime) / 1000;
        
        // Keep phase in reasonable range
        if (this.state.breathingPhase > Math.PI * 2) {
            this.state.breathingPhase -= Math.PI * 2;
        }
    }
    
    /**
     * Update blinking behavior
     */
    updateBlinking(deltaTime) {
        // Check if blinking is disabled
        if (!this.isBlinkingEnabled()) {
            return;
        }
        
        if (!this.state.isBlinking) {
            // Wait for next blink
            this.timers.blink += deltaTime;
            if (this.timers.blink >= this.timers.nextBlink) {
                this.startBlink();
            }
        } else {
            // Currently blinking
            this.timers.blink += deltaTime;
            if (this.timers.blink >= this.config.blinkDuration) {
                this.endBlink();
            }
        }
    }
    
    /**
     * Update swaying behavior (smooth weight shift)
     */
    updateSwaying(deltaTime) {
        if (!this.state.isSwaying) {
            // Wait for next sway
            this.timers.sway += deltaTime;
            if (this.timers.sway >= this.timers.nextSway) {
                this.startSway();
            }
        } else {
            // Currently swaying - smooth interpolation
            this.timers.sway += deltaTime;
            const progress = Math.min(this.timers.sway / this.config.swayDuration, 1);
            
            // Use sine wave for smooth in-out easing
            const easedProgress = (Math.sin((progress - 0.5) * Math.PI) + 1) / 2;
            
            // Interpolate between start and target positions
            this.swayOffset.x = this.swayStart.x + (this.swayTarget.x - this.swayStart.x) * easedProgress;
            this.swayOffset.y = this.swayStart.y + (this.swayTarget.y - this.swayStart.y) * easedProgress;
            
            if (progress >= 1) {
                this.endSway();
            }
        }
    }
    
    /**
     * Start a blink
     */
    startBlink() {
        this.state.isBlinking = true;
        this.timers.blink = 0;
        
        if (this.callbacks.onBlink) {
            this.callbacks.onBlink({ phase: 'start' });
        }
    }
    
    /**
     * End a blink
     */
    endBlink() {
        this.state.isBlinking = false;
        this.timers.blink = 0;
        this.timers.nextBlink = this.getRandomInterval('blink');
        
        if (this.callbacks.onBlink) {
            this.callbacks.onBlink({ phase: 'end' });
        }
    }
    
    /**
     * Start a sway (smooth weight shift)
     */
    startSway() {
        this.state.isSwaying = true;
        this.timers.sway = 0;
        
        // Save current position as start
        this.swayStart = { ...this.swayOffset };
        
        // Generate subtle target offset - like shifting weight
        // Favor horizontal movement (side to side weight shift)
        const angle = Math.random() * Math.PI * 2;
        const distance = this.config.swayIntensity * (0.5 + Math.random() * 0.5);
        this.swayTarget = {
            x: Math.cos(angle) * distance * 1.5,  // Slightly more horizontal
            y: Math.sin(angle) * distance * 0.5   // Less vertical
        };
        
        if (this.callbacks.onSway) {
            this.callbacks.onSway({ 
                phase: 'start',
                offset: this.swayOffset
            });
        }
    }
    
    /**
     * End a sway
     */
    endSway() {
        this.state.isSwaying = false;
        this.timers.sway = 0;
        this.timers.nextSway = this.getRandomInterval('sway');
        
        // Start position for next sway is current position
        this.swayStart = { ...this.swayOffset };
        
        if (this.callbacks.onSway) {
            this.callbacks.onSway({ 
                phase: 'end',
                offset: this.swayOffset
            });
        }
    }
    
    /**
     * Enter sleep mode
     */
    enterSleep() {
        this.state.isAsleep = true;
        this.state.breathRate = 0.5; // Slower breathing
        this.state.breathDepth = 0.15; // Deeper breaths
        
        // Force end any active blink
        if (this.state.isBlinking) {
            this.state.isBlinking = false;
            this.timers.blink = 0;
            if (this.callbacks.onBlink) {
                this.callbacks.onBlink({ phase: 'end' });
            }
        }
        
        
        if (this.callbacks.onSleep) {
            this.callbacks.onSleep();
        }
    }
    
    /**
     * Wake up from sleep
     */
    wakeUp() {
        if (!this.state.isAsleep) return;
        
        this.state.isAsleep = false;
        this.state.breathRate = 1.0;
        this.state.breathDepth = this.config.breathingDepth;
        this.timers.idle = 0; // Reset idle timer
        
        
        // Trigger a shake animation
        if (this.callbacks.onWake) {
            this.callbacks.onWake();
        }
        
        // Quick twitch series for wake animation
        this.performWakeAnimation();
    }
    
    /**
     * Perform wake-up animation
     */
    performWakeAnimation() {
        // Gentle stretch animation when waking
        const stretchOffset = {
            x: this.config.swayIntensity * 0.5,
            y: -this.config.swayIntensity  // Slight upward stretch
        };
        
        // Animate from current position to stretch and back
        this.swayStart = { ...this.swayOffset };
        this.swayTarget = stretchOffset;
        this.state.isSwaying = true;
        this.timers.sway = 0;
        
        if (this.callbacks.onSway) {
            this.callbacks.onSway({ 
                phase: 'wake',
                offset: this.swayOffset
            });
        }
        
        // Return to neutral after stretch
        setTimeout(() => {
            this.swayStart = { ...this.swayOffset };
            this.swayTarget = { x: 0, y: 0 };
            this.timers.sway = 0;
        }, 1000);
    }
    
    /**
     * Reset idle timer (called on user interaction)
     */
    resetIdleTimer() {
        this.timers.idle = 0;
        if (this.state.isAsleep) {
            this.wakeUp();
        }
    }
    
    /**
     * Enable or disable blinking
     * @param {boolean} enabled - Whether blinking should be enabled
     */
    setBlinkingEnabled(enabled) {
        this.config.blinkingEnabled = enabled;
        if (!enabled && this.state.isBlinking) {
            // If currently blinking, finish the blink
            this.endBlink();
        }
    }
    
    /**
     * Check if blinking is enabled
     * @returns {boolean} Whether blinking is enabled
     */
    isBlinkingEnabled() {
        return this.config.blinkingEnabled !== false;
    }
    
    /**
     * Get breathing factor for current phase
     * @returns {number} Breathing factor (0.9 - 1.1 typically)
     */
    getBreathingFactor() {
        return 1 + Math.sin(this.state.breathingPhase) * this.state.breathDepth * this.state.breathRate;
    }
    
    /**
     * Get blink progress (0-1)
     * @returns {number} Blink progress
     */
    getBlinkProgress() {
        if (!this.state.isBlinking) return 0;
        return Math.min(this.timers.blink / this.config.blinkDuration, 1);
    }
    
    /**
     * Get current sway offset
     * @returns {Object} Sway offset {x, y}
     */
    getSwayOffset() {
        return this.swayOffset || { x: 0, y: 0 };
    }
    
    /**
     * Get random interval for behavior
     */
    getRandomInterval(type) {
        const interval = this.config[`${type}Interval`];
        return interval.min + Math.random() * (interval.max - interval.min);
    }
    
    /**
     * Set callback for behavior events
     */
    setCallback(event, callback) {
        if (this.callbacks.hasOwnProperty(event)) {
            this.callbacks[event] = callback;
        }
    }
    
    /**
     * Get current state
     */
    getState() {
        return {
            ...this.state,
            breathingFactor: this.getBreathingFactor(),
            blinkProgress: this.getBlinkProgress(),
            swayOffset: this.getSwayOffset()
        };
    }
    
    /**
     * Enable idle behaviors
     */
    enable() {
        this.config.enabled = true;
    }
    
    /**
     * Disable idle behaviors
     */
    disable() {
        this.config.enabled = false;
        this.state.isBlinking = false;
        this.state.isSwaying = false;
        this.swayOffset = { x: 0, y: 0 };
    }
    
    /**
     * Clean up
     */
    destroy() {
        this.callbacks = {
            onBlink: null,
            onSway: null,
            onSleep: null,
            onWake: null
        };
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ♪ ♫ ♬ ♭  MUSIC THEORY SYSTEM  ♭ ♬ ♫ ♪                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Music Theory System - Musical Intelligence & Harmonic Generation
 * @author Emotive Engine Team
 * @version 1.0.0
 * @module MusicTheory
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The MUSICAL BRAIN of the system. Provides comprehensive music theory utilities    
 * ║ for generating scales, chords, progressions, and harmonic relationships that      
 * ║ respond to emotional states and user interactions.                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎼 MUSIC THEORY FEATURES                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Note frequency calculation (Equal Temperament)                                  
 * │ • Scale generation (Major, Minor, Modal, Exotic)                                  
 * │ • Chord construction (Triads, 7ths, Extensions)                                   
 * │ • Circle of Fifths navigation                                                     
 * │ • Interval relationships                                                          
 * │ • Chord progression generation                                                    
 * │ • Key signature management                                                        
 * │ • Emotion-to-mode mapping                                                         
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class MusicTheory {
    constructor() {
        // A4 = 440Hz standard tuning
        this.A4_FREQUENCY = 440;
        
        // Note names in chromatic scale
        this.NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Interval definitions (in semitones)
        this.INTERVALS = {
            unison: 0,
            minorSecond: 1,
            majorSecond: 2,
            minorThird: 3,
            majorThird: 4,
            perfectFourth: 5,
            tritone: 6,
            perfectFifth: 7,
            minorSixth: 8,
            majorSixth: 9,
            minorSeventh: 10,
            majorSeventh: 11,
            octave: 12
        };
        
        // Scale patterns (in semitones from root)
        this.SCALES = {
            // Traditional scales
            major: [0, 2, 4, 5, 7, 9, 11],
            naturalMinor: [0, 2, 3, 5, 7, 8, 10],
            harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
            melodicMinor: [0, 2, 3, 5, 7, 9, 11],
            
            // Modes
            ionian: [0, 2, 4, 5, 7, 9, 11],      // Major
            dorian: [0, 2, 3, 5, 7, 9, 10],      // Minor with raised 6th
            phrygian: [0, 1, 3, 5, 7, 8, 10],    // Spanish/Flamenco feel
            lydian: [0, 2, 4, 6, 7, 9, 11],      // Dreamy, ethereal
            mixolydian: [0, 2, 4, 5, 7, 9, 10],  // Bluesy major
            aeolian: [0, 2, 3, 5, 7, 8, 10],     // Natural minor
            locrian: [0, 1, 3, 5, 6, 8, 10],     // Diminished, unstable
            
            // Pentatonic scales
            majorPentatonic: [0, 2, 4, 7, 9],
            minorPentatonic: [0, 3, 5, 7, 10],
            
            // Exotic scales
            blues: [0, 3, 5, 6, 7, 10],
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
            wholeHalfDiminished: [0, 2, 3, 5, 6, 8, 9, 11],
            arabic: [0, 1, 4, 5, 7, 8, 11],       // Hijaz scale
            japanese: [0, 1, 5, 7, 8],            // Hirajoshi scale
            hungarian: [0, 2, 3, 6, 7, 8, 11],    // Hungarian minor
            bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11] // Jazz bebop
        };
        
        // Chord patterns (intervals from root)
        this.CHORDS = {
            // Triads
            major: [0, 4, 7],
            minor: [0, 3, 7],
            diminished: [0, 3, 6],
            augmented: [0, 4, 8],
            sus2: [0, 2, 7],
            sus4: [0, 5, 7],
            
            // Seventh chords
            maj7: [0, 4, 7, 11],
            min7: [0, 3, 7, 10],
            dom7: [0, 4, 7, 10],
            min7b5: [0, 3, 6, 10],
            dim7: [0, 3, 6, 9],
            
            // Extended chords
            maj9: [0, 4, 7, 11, 14],
            min9: [0, 3, 7, 10, 14],
            dom9: [0, 4, 7, 10, 14],
            add9: [0, 4, 7, 14],
            maj11: [0, 4, 7, 11, 14, 17],
            min11: [0, 3, 7, 10, 14, 17],
            maj13: [0, 4, 7, 11, 14, 17, 21],
            min13: [0, 3, 7, 10, 14, 17, 21]
        };
        
        // Emotion to musical mode mapping
        this.EMOTION_MODES = {
            excited: {
                scale: 'lydian',
                tempo: 140,
                dynamics: 'forte',
                articulation: 'staccato'
            },
            calm: {
                scale: 'major',
                tempo: 60,
                dynamics: 'piano',
                articulation: 'legato'
            },
            curious: {
                scale: 'mixolydian',
                tempo: 100,
                dynamics: 'mezzoForte',
                articulation: 'tenuto'
            },
            sleepy: {
                scale: 'aeolian',
                tempo: 50,
                dynamics: 'pianissimo',
                articulation: 'legato'
            },
            alert: {
                scale: 'dorian',
                tempo: 120,
                dynamics: 'forte',
                articulation: 'marcato'
            },
            pleased: {
                scale: 'majorPentatonic',
                tempo: 90,
                dynamics: 'mezzoForte',
                articulation: 'legato'
            },
            confused: {
                scale: 'wholeHalfDiminished',
                tempo: 80,
                dynamics: 'mezzoPiano',
                articulation: 'rubato'
            },
            energetic: {
                scale: 'bebopMajor',
                tempo: 160,
                dynamics: 'fortissimo',
                articulation: 'staccato'
            },
            melancholy: {
                scale: 'harmonicMinor',
                tempo: 70,
                dynamics: 'mezzoPiano',
                articulation: 'legato'
            },
            playful: {
                scale: 'blues',
                tempo: 110,
                dynamics: 'mezzoForte',
                articulation: 'swing'
            }
        };
        
        // Common chord progressions
        this.PROGRESSIONS = {
            // Pop/Rock progressions
            I_V_vi_IV: [1, 5, 6, 4],           // Most common pop progression
            I_IV_V: [1, 4, 5],                 // Classic rock/blues
            ii_V_I: [2, 5, 1],                 // Jazz standard
            I_vi_IV_V: [1, 6, 4, 5],           // 50s doo-wop
            vi_IV_I_V: [6, 4, 1, 5],           // Alternative pop
            
            // Jazz progressions
            I_VI_ii_V: [1, 6, 2, 5],           // Rhythm changes A
            iii_vi_ii_V: [3, 6, 2, 5],         // Turnaround
            I_ii_iii_IV: [1, 2, 3, 4],         // Modal jazz
            
            // Blues progressions
            I_I_I_I_IV_IV_I_I_V_IV_I_V: [1, 1, 1, 1, 4, 4, 1, 1, 5, 4, 1, 5], // 12-bar blues
            
            // Modal progressions
            i_VII_VI_VII: [1, 7, 6, 7],        // Aeolian vamp
            I_II_IV_I: [1, 2, 4, 1],           // Lydian progression
        };
    }
    
    /**
     * Convert note name to MIDI note number
     * @param {string} note - Note name (e.g., 'C4', 'A#3')
     * @returns {number} MIDI note number
     */
    noteToMidi(note) {
        const noteName = note.slice(0, -1);
        const octave = parseInt(note.slice(-1));
        const noteIndex = this.NOTES.indexOf(noteName);
        
        if (noteIndex === -1) {
            throw new Error(`Invalid note: ${note}`);
        }
        
        // C4 = MIDI 60
        return (octave + 1) * 12 + noteIndex;
    }
    
    /**
     * Convert MIDI note number to frequency
     * @param {number} midiNote - MIDI note number
     * @returns {number} Frequency in Hz
     */
    midiToFrequency(midiNote) {
        // f = 440 * 2^((n - 69) / 12)
        return this.A4_FREQUENCY * Math.pow(2, (midiNote - 69) / 12);
    }
    
    /**
     * Convert note name to frequency
     * @param {string} note - Note name (e.g., 'C4', 'A#3')
     * @returns {number} Frequency in Hz
     */
    noteToFrequency(note) {
        return this.midiToFrequency(this.noteToMidi(note));
    }
    
    /**
     * Generate a scale from a root note
     * @param {string} root - Root note (e.g., 'C4')
     * @param {string} scaleType - Scale type from SCALES
     * @returns {Array} Array of frequencies
     */
    generateScale(root, scaleType = 'major') {
        const scale = this.SCALES[scaleType];
        if (!scale) {
            throw new Error(`Unknown scale type: ${scaleType}`);
        }
        
        const rootMidi = this.noteToMidi(root);
        return scale.map(interval => this.midiToFrequency(rootMidi + interval));
    }
    
    /**
     * Generate a chord from a root note
     * @param {string} root - Root note (e.g., 'C4')
     * @param {string} chordType - Chord type from CHORDS
     * @returns {Array} Array of frequencies
     */
    generateChord(root, chordType = 'major') {
        const chord = this.CHORDS[chordType];
        if (!chord) {
            throw new Error(`Unknown chord type: ${chordType}`);
        }
        
        const rootMidi = this.noteToMidi(root);
        return chord.map(interval => this.midiToFrequency(rootMidi + interval));
    }
    
    /**
     * Generate a chord progression
     * @param {string} key - Key center (e.g., 'C4')
     * @param {string} scaleType - Scale type for the key
     * @param {Array} progression - Array of scale degrees
     * @returns {Array} Array of chord arrays
     */
    generateProgression(key, scaleType = 'major', progression = this.PROGRESSIONS.I_V_vi_IV) {
        const scale = this.generateScale(key, scaleType);
        const chords = [];
        
        for (const degree of progression) {
            const chordRoot = scale[(degree - 1) % scale.length];
            
            // Determine chord quality based on scale degree
            let chordType = 'major';
            if (scaleType === 'major') {
                if (degree === 2 || degree === 3 || degree === 6) {
                    chordType = 'minor';
                } else if (degree === 7) {
                    chordType = 'diminished';
                }
            } else if (scaleType === 'naturalMinor') {
                if (degree === 1 || degree === 4 || degree === 5) {
                    chordType = 'minor';
                } else if (degree === 2) {
                    chordType = 'diminished';
                } else {
                    chordType = 'major';
                }
            }
            
            // Convert frequency back to note for chord generation
            const midiNote = Math.round(12 * Math.log2(chordRoot / this.A4_FREQUENCY) + 69);
            const octave = Math.floor(midiNote / 12) - 1;
            const noteIndex = midiNote % 12;
            const noteName = this.NOTES[noteIndex] + octave;
            
            chords.push({
                degree,
                root: chordRoot,
                frequencies: this.generateChord(noteName, chordType),
                type: chordType
            });
        }
        
        return chords;
    }
    
    /**
     * Get musical parameters for an emotion
     * @param {string} emotion - Emotion name
     * @returns {Object} Musical parameters
     */
    getEmotionMusic(emotion) {
        return this.EMOTION_MODES[emotion] || this.EMOTION_MODES.calm;
    }
    
    /**
     * Generate Circle of Fifths progression
     * @param {string} startNote - Starting note
     * @param {number} steps - Number of steps around the circle
     * @param {boolean} clockwise - Direction (true = sharps, false = flats)
     * @returns {Array} Array of note names
     */
    circleOfFifths(startNote = 'C', steps = 12, clockwise = true) {
        const noteBase = startNote.replace(/\d/, '');
        let currentIndex = this.NOTES.indexOf(noteBase);
        const notes = [startNote];
        
        for (let i = 1; i < steps; i++) {
            // Perfect fifth = 7 semitones (clockwise) or 5 semitones (counter-clockwise)
            currentIndex = clockwise ? 
                (currentIndex + 7) % 12 : 
                (currentIndex + 5) % 12;
            
            notes.push(this.NOTES[currentIndex]);
        }
        
        return notes;
    }
    
    /**
     * Analyze interval between two notes
     * @param {string} note1 - First note
     * @param {string} note2 - Second note
     * @returns {Object} Interval information
     */
    analyzeInterval(note1, note2) {
        const midi1 = this.noteToMidi(note1);
        const midi2 = this.noteToMidi(note2);
        const semitones = Math.abs(midi2 - midi1);
        
        // Find interval name
        let intervalName = 'unknown';
        for (const [name, value] of Object.entries(this.INTERVALS)) {
            if (value === semitones % 12) {
                intervalName = name;
                break;
            }
        }
        
        return {
            semitones,
            intervalName,
            octaves: Math.floor(semitones / 12),
            consonant: [0, 3, 4, 5, 7, 8, 9, 12].includes(semitones % 12),
            ratio: this.getIntervalRatio(semitones % 12)
        };
    }
    
    /**
     * Get frequency ratio for an interval
     * @param {number} semitones - Number of semitones
     * @returns {string} Simplified ratio
     */
    getIntervalRatio(semitones) {
        const ratios = {
            0: '1:1',    // Unison
            1: '16:15',  // Minor second
            2: '9:8',    // Major second
            3: '6:5',    // Minor third
            4: '5:4',    // Major third
            5: '4:3',    // Perfect fourth
            6: '45:32',  // Tritone
            7: '3:2',    // Perfect fifth
            8: '8:5',    // Minor sixth
            9: '5:3',    // Major sixth
            10: '16:9',  // Minor seventh
            11: '15:8',  // Major seventh
            12: '2:1'    // Octave
        };
        
        return ratios[semitones] || 'complex';
    }
    
    /**
     * Generate a melody based on parameters
     * @param {Object} params - Melody parameters
     * @returns {Array} Array of note objects with timing
     */
    generateMelody(params = {}) {
        const {
            key = 'C4',
            scale = 'major',
            length = 8,
            stepProbability = 0.7,  // Probability of stepwise motion
            restProbability = 0.1    // Probability of rest
        } = params;
        
        const scaleNotes = this.generateScale(key, scale);
        const melody = [];
        let currentIndex = 0;
        
        for (let i = 0; i < length; i++) {
            // Decide if this is a rest
            if (Math.random() < restProbability) {
                melody.push({ frequency: 0, duration: 0.25, isRest: true });
                continue;
            }
            
            // Decide step size
            let nextIndex;
            if (Math.random() < stepProbability) {
                // Stepwise motion
                const direction = Math.random() < 0.5 ? -1 : 1;
                nextIndex = Math.max(0, Math.min(scaleNotes.length - 1, currentIndex + direction));
            } else {
                // Leap
                const leap = Math.floor(Math.random() * 3) + 2; // 2-4 scale degrees
                const direction = Math.random() < 0.5 ? -1 : 1;
                nextIndex = Math.max(0, Math.min(scaleNotes.length - 1, currentIndex + (leap * direction)));
            }
            
            currentIndex = nextIndex;
            
            // Random duration
            const durations = [0.25, 0.5, 0.75, 1];
            const duration = durations[Math.floor(Math.random() * durations.length)];
            
            melody.push({
                frequency: scaleNotes[currentIndex],
                duration,
                isRest: false
            });
        }
        
        return melody;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ♬ ♭ ♮ ♯  HARMONIC SYSTEM  ♯ ♮ ♭ ♬                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Harmonic System - Real-time Musical Intelligence
 * @author Emotive Engine Team
 * @version 1.0.0
 * @module HarmonicSystem
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The CONDUCTOR of musical experiences. Orchestrates the music theory system with   
 * ║ the sound engine to create emotionally-responsive, harmonically-rich audio that   
 * ║ adapts in real-time to mascot states and user interactions.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 HARMONIC FEATURES                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Real-time harmonic generation                                                   
 * │ • Emotion-driven key modulation                                                   
 * │ • Adaptive tempo and dynamics                                                     
 * │ • Gesture-to-chord mapping                                                        
 * │ • Harmonic tension and release                                                    
 * │ • Polyrhythmic patterns                                                           
 * │ • Voice leading and smooth transitions                                            
 * │ • Ambient pad generation                                                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class HarmonicSystem {
    constructor(audioContext) {
        this.audioContext = audioContext;
        this.musicTheory = new MusicTheory();
        
        // Current musical state
        this.currentKey = 'C4';
        this.currentScale = 'major';
        this.currentTempo = 120; // BPM
        this.currentEmotion = 'calm';
        
        // Active voices (oscillators and gains)
        this.voices = new Map();
        
        // Harmonic layers
        this.layers = {
            bass: { active: false, gain: 0.3 },
            chord: { active: false, gain: 0.2 },
            melody: { active: false, gain: 0.4 },
            pad: { active: false, gain: 0.15 }
        };
        
        // Master output
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.audioContext.destination);
        
        // Effects chain
        this.reverb = this.createReverb();
        this.delay = this.createDelay();
        this.filter = this.createFilter();
        
        // Connect effects
        this.filter.connect(this.delay);
        this.delay.connect(this.reverb);
        this.reverb.connect(this.masterGain);
        
        // Dry signal path
        this.dryGain = this.audioContext.createGain();
        this.dryGain.gain.value = 0.7;
        this.dryGain.connect(this.masterGain);
        
        // Wet signal path
        this.wetGain = this.audioContext.createGain();
        this.wetGain.gain.value = 0.3;
        this.wetGain.connect(this.filter);
        
        // Rhythm tracking
        this.nextNoteTime = 0;
        this.noteResolution = 0; // 0 = 16th, 1 = 8th, 2 = quarter
        this.noteLength = 0.05; // Length of "beep" (staccato)
        
        // Sequence tracking
        this.currentChordIndex = 0;
        this.currentMelodyNote = 0;
        this.progression = null;
        
        // Performance optimization
        this.isPlaying = false;
        this.lookahead = 25.0; // How frequently to call scheduling function (ms)
        this.scheduleAheadTime = 0.1; // How far ahead to schedule audio (sec)
    }
    
    /**
     * Create reverb effect using convolver
     */
    createReverb() {
        const convolver = this.audioContext.createConvolver();
        const length = this.audioContext.sampleRate * 2; // 2 second reverb
        const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                // Exponential decay
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }
        }
        
        convolver.buffer = impulse;
        return convolver;
    }
    
    /**
     * Create delay effect
     */
    createDelay() {
        const delay = this.audioContext.createDelay(1.0);
        delay.delayTime.value = 0.15; // 150ms delay
        
        const feedback = this.audioContext.createGain();
        feedback.gain.value = 0.3;
        
        delay.connect(feedback);
        feedback.connect(delay);
        
        return delay;
    }
    
    /**
     * Create filter for tone shaping
     */
    createFilter() {
        const filter = this.audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000;
        filter.Q.value = 1;
        return filter;
    }
    
    /**
     * Update emotion and adapt musical parameters
     */
    setEmotion(emotion) {
        this.currentEmotion = emotion;
        const musicParams = this.musicTheory.getEmotionMusic(emotion);
        
        // Update scale and tempo
        this.currentScale = musicParams.scale;
        this.currentTempo = musicParams.tempo;
        
        // Adapt filter based on emotion
        const filterSettings = {
            excited: { freq: 4000, Q: 2 },
            calm: { freq: 1500, Q: 0.7 },
            curious: { freq: 2500, Q: 1.5 },
            sleepy: { freq: 800, Q: 0.5 },
            alert: { freq: 3000, Q: 1.8 },
            energetic: { freq: 5000, Q: 2.5 }
        };
        
        const settings = filterSettings[emotion] || { freq: 2000, Q: 1 };
        this.filter.frequency.exponentialRampToValueAtTime(
            settings.freq,
            this.audioContext.currentTime + 0.5
        );
        this.filter.Q.linearRampToValueAtTime(
            settings.Q,
            this.audioContext.currentTime + 0.5
        );
        
        // Generate new progression for this emotion
        this.generateEmotionProgression();
    }
    
    /**
     * Generate chord progression based on current emotion
     */
    generateEmotionProgression() {
        const progressionMap = {
            excited: 'I_V_vi_IV',
            calm: 'I_vi_IV_V',
            curious: 'ii_V_I',
            sleepy: 'vi_IV_I_V',
            alert: 'I_IV_V',
            energetic: 'I_V_vi_IV'
        };
        
        const progressionType = progressionMap[this.currentEmotion] || 'I_V_vi_IV';
        this.progression = this.musicTheory.generateProgression(
            this.currentKey,
            this.currentScale,
            this.musicTheory.PROGRESSIONS[progressionType]
        );
    }
    
    /**
     * Play a chord with voice leading
     */
    playChord(frequencies, duration = 1.0, attack = 0.01) {
        const startTime = this.audioContext.currentTime;
        const chordGain = this.audioContext.createGain();
        
        // ADSR envelope
        chordGain.gain.setValueAtTime(0, startTime);
        chordGain.gain.linearRampToValueAtTime(this.layers.chord.gain, startTime + attack);
        chordGain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
        
        // Connect to wet/dry mix
        chordGain.connect(this.dryGain);
        chordGain.connect(this.wetGain);
        
        // Create oscillators for each note
        const oscillators = frequencies.map((freq, index) => {
            const osc = this.audioContext.createOscillator();
            osc.frequency.value = freq;
            
            // Different waveforms for different voices
            if (index === 0) osc.type = 'sine';        // Root
            else if (index === 1) osc.type = 'triangle'; // Third
            else osc.type = 'sawtooth';                // Fifth and extensions
            
            // Slight detuning for richness
            osc.detune.value = (Math.random() - 0.5) * 10;
            
            osc.connect(chordGain);
            osc.start(startTime);
            osc.stop(startTime + duration);
            
            return osc;
        });
        
        // Store for potential manipulation
        const chordId = `chord_${Date.now()}`;
        this.voices.set(chordId, { oscillators, gain: chordGain });
        
        // Cleanup
        setTimeout(() => {
            this.voices.delete(chordId);
        }, (duration + 0.1) * 1000);
    }
    
    /**
     * Play a melodic sequence
     */
    playMelody(notes, baseTime = 0) {
        const startTime = baseTime || this.audioContext.currentTime;
        let currentTime = startTime;
        
        notes.forEach((note, index) => {
            if (note.isRest) {
                currentTime += note.duration;
                return;
            }
            
            const osc = this.audioContext.createOscillator();
            const noteGain = this.audioContext.createGain();
            
            osc.frequency.value = note.frequency;
            osc.type = 'sine';
            
            // Vibrato for expressiveness
            const vibrato = this.audioContext.createOscillator();
            const vibratoGain = this.audioContext.createGain();
            vibrato.frequency.value = 5; // 5 Hz vibrato
            vibratoGain.gain.value = 5; // 5 cents depth
            
            vibrato.connect(vibratoGain);
            vibratoGain.connect(osc.frequency);
            
            // Note envelope
            noteGain.gain.setValueAtTime(0, currentTime);
            noteGain.gain.linearRampToValueAtTime(this.layers.melody.gain, currentTime + 0.01);
            noteGain.gain.exponentialRampToValueAtTime(0.01, currentTime + note.duration * 0.9);
            
            osc.connect(noteGain);
            noteGain.connect(this.dryGain);
            noteGain.connect(this.wetGain);
            
            osc.start(currentTime);
            osc.stop(currentTime + note.duration);
            vibrato.start(currentTime);
            vibrato.stop(currentTime + note.duration);
            
            currentTime += note.duration;
        });
    }
    
    /**
     * Create ambient pad layer
     */
    createPad(frequency, duration = 4.0) {
        const startTime = this.audioContext.currentTime;
        const voices = 4; // Number of detuned voices
        const padGain = this.audioContext.createGain();
        
        // Slow attack and release for pad
        padGain.gain.setValueAtTime(0, startTime);
        padGain.gain.linearRampToValueAtTime(this.layers.pad.gain, startTime + 1.0);
        padGain.gain.linearRampToValueAtTime(this.layers.pad.gain, startTime + duration - 1.0);
        padGain.gain.linearRampToValueAtTime(0, startTime + duration);
        
        padGain.connect(this.wetGain); // Pads sound better with effects
        
        for (let i = 0; i < voices; i++) {
            const osc = this.audioContext.createOscillator();
            osc.frequency.value = frequency;
            osc.type = 'sawtooth';
            
            // Detune each voice
            osc.detune.value = (i - voices / 2) * 15;
            
            // Individual voice gain for stereo spread
            const voiceGain = this.audioContext.createGain();
            voiceGain.gain.value = 1 / voices;
            
            // Add slow LFO for movement
            const lfo = this.audioContext.createOscillator();
            const lfoGain = this.audioContext.createGain();
            lfo.frequency.value = 0.2 + (i * 0.1); // Slightly different LFO rates
            lfoGain.gain.value = 10; // Subtle pitch modulation
            
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            
            osc.connect(voiceGain);
            voiceGain.connect(padGain);
            
            osc.start(startTime);
            osc.stop(startTime + duration);
            lfo.start(startTime);
            lfo.stop(startTime + duration);
        }
    }
    
    /**
     * Map gesture to musical response
     */
    playGestureSound(gesture) {
        const gestureMap = {
            breathe: () => {
                // Breathing creates slow, expanding chords
                const chord = this.musicTheory.generateChord(this.currentKey, 'maj7');
                this.playChord(chord, 2.0, 0.5);
                this.createPad(chord[0] / 2, 3.0); // Sub bass pad
            },
            
            excited: () => {
                // Excited creates ascending arpeggios
                const scale = this.musicTheory.generateScale(this.currentKey, 'lydian');
                const arpeggio = scale.map((freq, i) => ({
                    frequency: freq,
                    duration: 0.1,
                    isRest: false
                }));
                this.playMelody(arpeggio);
            },
            
            wave: () => {
                // Wave creates a glissando effect
                const startFreq = this.musicTheory.noteToFrequency(this.currentKey);
                const endFreq = startFreq * 2; // Octave up
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.frequency.setValueAtTime(startFreq, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(endFreq, this.audioContext.currentTime + 0.5);
                osc.frequency.exponentialRampToValueAtTime(startFreq, this.audioContext.currentTime + 1.0);
                
                gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.1);
                gain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.9);
                gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 1.0);
                
                osc.connect(gain);
                gain.connect(this.wetGain);
                
                osc.start();
                osc.stop(this.audioContext.currentTime + 1.0);
            },
            
            morph: () => {
                // Morph creates harmonic morphing between chords
                const chord1 = this.musicTheory.generateChord(this.currentKey, 'minor');
                const chord2 = this.musicTheory.generateChord(this.currentKey, 'major');
                
                // Play first chord
                this.playChord(chord1, 0.5);
                
                // Morph to second chord
                setTimeout(() => {
                    this.playChord(chord2, 1.0);
                }, 400);
            },
            
            jump: () => {
                // Jump creates staccato chord stabs
                const chord = this.musicTheory.generateChord(this.currentKey, 'dom7');
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        this.playChord(chord.map(f => f * Math.pow(2, i/12)), 0.1, 0.001);
                    }, i * 100);
                }
            },
            
            curious: () => {
                // Curious creates questioning melodic phrases
                const melody = this.musicTheory.generateMelody({
                    key: this.currentKey,
                    scale: 'mixolydian',
                    length: 5,
                    stepProbability: 0.3
                });
                this.playMelody(melody);
            }
        };
        
        const soundFunction = gestureMap[gesture];
        if (soundFunction) {
            soundFunction();
        }
    }
    
    /**
     * Start background harmony generation
     */
    startHarmony() {
        if (this.isPlaying) return;
        
        this.isPlaying = true;
        this.currentChordIndex = 0;
        this.nextNoteTime = this.audioContext.currentTime;
        
        // Generate initial progression
        this.generateEmotionProgression();
        
        // Start the scheduling loop
        this.scheduleHarmony();
    }
    
    /**
     * Schedule harmony playback
     */
    scheduleHarmony() {
        if (!this.isPlaying) return;
        
        // Schedule notes that need to play in the next interval
        while (this.nextNoteTime < this.audioContext.currentTime + this.scheduleAheadTime) {
            // Play current chord in progression
            if (this.progression && this.layers.chord.active) {
                const chord = this.progression[this.currentChordIndex];
                this.playChord(chord.frequencies, 0.5);
                
                // Advance to next chord
                this.currentChordIndex = (this.currentChordIndex + 1) % this.progression.length;
            }
            
            // Generate and play bass line
            if (this.layers.bass.active && this.progression) {
                const bassNote = this.progression[this.currentChordIndex].frequencies[0] / 2;
                this.playBassNote(bassNote, 0.25);
            }
            
            // Advance time based on tempo
            const secondsPerBeat = 60.0 / this.currentTempo;
            this.nextNoteTime += 0.25 * secondsPerBeat; // 16th notes
        }
        
        // Continue scheduling
        setTimeout(() => this.scheduleHarmony(), this.lookahead);
    }
    
    /**
     * Play a bass note
     */
    playBassNote(frequency, duration) {
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.frequency.value = frequency;
        osc.type = 'sine';
        
        gain.gain.setValueAtTime(0, this.audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(this.layers.bass.gain, this.audioContext.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.dryGain);
        
        osc.start();
        osc.stop(this.audioContext.currentTime + duration);
    }
    
    /**
     * Stop harmony generation
     */
    stopHarmony() {
        this.isPlaying = false;
    }
    
    /**
     * Set layer active state
     */
    setLayerActive(layer, active) {
        if (this.layers[layer]) {
            this.layers[layer].active = active;
        }
    }
    
    /**
     * Set master volume
     */
    setMasterVolume(volume) {
        this.masterGain.gain.exponentialRampToValueAtTime(
            Math.max(0.01, volume),
            this.audioContext.currentTime + 0.1
        );
    }
    
    /**
     * Set wet/dry mix for effects
     */
    setEffectsMix(wetness) {
        const dry = 1 - wetness;
        this.dryGain.gain.linearRampToValueAtTime(dry, this.audioContext.currentTime + 0.1);
        this.wetGain.gain.linearRampToValueAtTime(wetness, this.audioContext.currentTime + 0.1);
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  SOUND SYSTEM  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sound System - Web Audio API Integration for Emotional Audio
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module SoundSystem
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Adds the VOICE of emotion through sound. Generates ambient tones that match       
 * ║ emotional states and plays gesture sound effects. Uses Web Audio API for          
 * ║ programmatic sound generation - no external audio files needed!                   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎵 AUDIO FEATURES                                                                  
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Emotional ambient tones (frequency based on emotion)                            
 * │ • Gesture sound effects (pops, sweeps, chimes)                                    
 * │ • Volume control with fade in/out                                                 
 * │ • Warning throttling to reduce console spam                                       
 * │ • Graceful degradation if Web Audio unavailable                                   
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎼 EMOTIONAL TONE MAPPING                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ EMOTION        FREQUENCY    WAVEFORM    VOLUME                                   
 * │ neutral        220Hz        sine        0.1                                      
 * │ joy            440Hz        sine        0.15                                     
 * │ sadness        110Hz        sine        0.08                                     
 * │ anger          330Hz        sawtooth    0.2                                      
 * │ fear           550Hz        square      0.12                                     
 * │ love           262Hz        sine        0.12                                     
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class SoundSystem {
  constructor() {
    this.context = null;
    this.isEnabled = false;
    this.isInitialized = false;
    
    // Audio nodes
    this.nodes = {
      master: null,      // Master gain node
      ambient: null,     // Ambient oscillator for emotional tones
      effects: null      // Effects gain node for gesture sounds
    };
    
    // Harmonic system for musical intelligence
    this.harmonicSystem = null;
    this.useHarmonicSystem = false; // Toggle between old and new system
    
    // Track warning frequency to reduce spam
    this.warningTimestamps = {};
    this.warningThrottle = 5000; // Only show same warning every 5 seconds
    
    // Current ambient oscillator
    this.currentOscillator = null;
    this.currentGain = null;
    
    // Default settings
    this.masterVolume = 0.5;
    this.ambientVolume = 0.1;
    
    // Emotional tone mappings
    this.emotionalTones = new Map([
      ['neutral', { frequency: 220, waveform: 'sine', volume: 0.1 }],
      ['joy', { frequency: 440, waveform: 'triangle', volume: 0.15 }],
      ['sadness', { frequency: 165, waveform: 'sine', volume: 0.08 }],
      ['anger', { frequency: 330, waveform: 'sawtooth', volume: 0.12 }],
      ['fear', { frequency: 880, waveform: 'square', volume: 0.09 }],
      ['surprise', { frequency: 660, waveform: 'triangle', volume: 0.13 }],
      ['disgust', { frequency: 110, waveform: 'sawtooth', volume: 0.07 }],
      ['love', { frequency: 528, waveform: 'sine', volume: 0.11 }]
    ]);
  }

  /**
   * Initialize Web Audio API and create node architecture
   * @returns {boolean} Success status
   */
  async initialize() {
    try {
      // Check for Web Audio API support
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextClass) {
        // SoundSystem: Web Audio API not supported, continuing without audio
        return false;
      }

      // Create audio context
      this.context = new AudioContextClass();
      
      // Initialize harmonic system
      this.harmonicSystem = new HarmonicSystem(this.context);

      // Create master gain node with default volume
      this.nodes.master = this.context.createGain();
      this.nodes.master.gain.setValueAtTime(this.masterVolume, this.context.currentTime);
      this.nodes.master.connect(this.context.destination);

      // Create effects gain node for gesture sounds
      this.nodes.effects = this.context.createGain();
      this.nodes.effects.gain.setValueAtTime(1.0, this.context.currentTime);
      this.nodes.effects.connect(this.nodes.master);

      this.isEnabled = true;
      this.isInitialized = true;
      
      // SoundSystem: Successfully initialized Web Audio API
      return true;

    } catch (error) {
      // SoundSystem: Failed to initialize Web Audio API
      this.isEnabled = false;
      return false;
    }
  }

  /**
   * Resume audio context if suspended (call on user interaction)
   */
  async resumeContext() {
    if (this.context && this.context.state === 'suspended') {
      try {
        await this.context.resume();
        // Silently resume without logging
      } catch (error) {
        // Silently fail - this is expected before user interaction
      }
    }
  }

  /**
   * Set master volume for all audio output
   * @param {number} volume - Volume level (0.0 to 1.0)
   * @param {string} currentEmotion - Current emotion for ambient tone volume update
   */
  setMasterVolume(volume, currentEmotion = null) {
    this.masterVolume = Math.max(0, Math.min(1, volume));
    
    if (this.isEnabled && this.nodes.master) {
      this.nodes.master.gain.setValueAtTime(
        this.masterVolume, 
        this.context.currentTime
      );

      // Update ambient tone volume if active
      if (currentEmotion) {
        this.updateAmbientVolume(currentEmotion);
      }
    }
  }

  /**
   * Get current master volume
   * @returns {number} Current master volume
   */
  getMasterVolume() {
    return this.masterVolume;
  }

  /**
   * Check if sound system is available and enabled
   * @returns {boolean} Availability status
   */
  isAvailable() {
    return this.isEnabled && this.isInitialized;
  }
  
  /**
   * Enable or disable the harmonic music system
   * @param {boolean} enabled - Whether to enable harmonic system
   */
  setHarmonicMode(enabled) {
    this.useHarmonicSystem = enabled;
    
    if (enabled && this.harmonicSystem) {
      // Stop simple ambient tone when switching to harmonic mode
      this.stopAmbientTone();
      // SoundSystem: Switched to harmonic music mode
    } else if (!enabled && this.harmonicSystem) {
      // Stop harmonic system when switching back
      this.harmonicSystem.stopHarmony();
      // SoundSystem: Switched to simple sound mode
    }
  }
  
  /**
   * Start harmonic background music
   */
  startHarmony() {
    if (this.harmonicSystem && this.useHarmonicSystem && this.isAvailable()) {
      this.harmonicSystem.startHarmony();
    }
  }
  
  /**
   * Stop harmonic background music
   */
  stopHarmony() {
    if (this.harmonicSystem) {
      this.harmonicSystem.stopHarmony();
    }
  }
  
  /**
   * Set harmonic layer active state
   * @param {string} layer - Layer name (bass, chord, melody, pad)
   * @param {boolean} active - Whether layer should be active
   */
  setHarmonicLayer(layer, active) {
    if (this.harmonicSystem) {
      this.harmonicSystem.setLayerActive(layer, active);
    }
  }
  
  /**
   * Set harmonic effects mix
   * @param {number} wetness - Wet/dry mix (0-1)
   */
  setHarmonicEffects(wetness) {
    if (this.harmonicSystem) {
      this.harmonicSystem.setEffectsMix(wetness);
    }
  }

  /**
   * Clean up audio resources
   */
  cleanup() {
    try {
      // Stop current ambient oscillator
      if (this.currentOscillator) {
        this.currentOscillator.stop();
        this.currentOscillator = null;
      }
      
      if (this.currentGain) {
        this.currentGain = null;
      }

      // Close audio context
      if (this.context && this.context.state !== 'closed') {
        this.context.close();
      }

      // SoundSystem: Cleaned up audio resources
    } catch (error) {
      // SoundSystem: Error during cleanup
    } finally {
      // Always reset state regardless of errors
      this.context = null;
      this.nodes = { master: null, ambient: null, effects: null };
      this.currentOscillator = null;
      this.currentGain = null;
      this.isEnabled = false;
      this.isInitialized = false;
    }
  }

  /**
   * Get emotional tone configuration for given emotion
   * @param {string} emotion - Emotion name
   * @returns {Object|null} Tone configuration or null if not found
   */
  getEmotionalTone(emotion) {
    return this.emotionalTones.get(emotion) || null;
  }

  /**
   * Start ambient emotional tone for given emotion
   * @param {string} emotion - Emotion name
   * @param {number} transitionDuration - Transition duration in milliseconds (default: 500)
   */
  setAmbientTone(emotion, transitionDuration = 500) {
    if (!this.isAvailable()) {
      return;
    }

    // Use harmonic system if enabled
    if (this.useHarmonicSystem && this.harmonicSystem) {
      this.harmonicSystem.setEmotion(emotion);
      return;
    }

    const toneConfig = this.getEmotionalTone(emotion);
    if (!toneConfig) {
      // SoundSystem: Unknown emotion, cannot set ambient tone
      return;
    }

    try {
      // Resume context if suspended
      this.resumeContext();

      const currentTime = this.context.currentTime;
      const transitionTime = transitionDuration / 1000; // Convert to seconds

      // Stop current oscillator with fade out
      if (this.currentOscillator && this.currentGain) {
        this.currentGain.gain.exponentialRampToValueAtTime(0.001, currentTime + transitionTime * 0.5);
        this.currentOscillator.stop(currentTime + transitionTime * 0.5);
      }

      // Create new oscillator and gain for the new tone
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();

      // Configure oscillator
      oscillator.type = toneConfig.waveform;
      oscillator.frequency.setValueAtTime(toneConfig.frequency, currentTime);

      // Configure gain with smooth transition
      const targetVolume = toneConfig.volume * this.masterVolume;
      gainNode.gain.setValueAtTime(0.001, currentTime); // Start silent
      gainNode.gain.exponentialRampToValueAtTime(targetVolume, currentTime + transitionTime);

      // Connect nodes
      oscillator.connect(gainNode);
      gainNode.connect(this.nodes.master);

      // Start oscillator
      oscillator.start(currentTime);

      // Store references
      this.currentOscillator = oscillator;
      this.currentGain = gainNode;

      // SoundSystem: Started ambient tone

    } catch (error) {
      // SoundSystem: Failed to set ambient tone
    }
  }

  /**
   * Stop current ambient tone
   * @param {number} fadeOutDuration - Fade out duration in milliseconds (default: 500)
   */
  stopAmbientTone(fadeOutDuration = 500) {
    if (!this.isAvailable() || !this.currentOscillator) {
      return;
    }

    try {
      const currentTime = this.context.currentTime;
      const fadeTime = fadeOutDuration / 1000; // Convert to seconds

      // Fade out current tone
      if (this.currentGain) {
        this.currentGain.gain.exponentialRampToValueAtTime(0.001, currentTime + fadeTime);
      }

      // Stop oscillator after fade
      this.currentOscillator.stop(currentTime + fadeTime);

      // Clear references
      this.currentOscillator = null;
      this.currentGain = null;

      // SoundSystem: Stopped ambient tone

    } catch (error) {
      // SoundSystem: Failed to stop ambient tone
    }
  }

  /**
   * Update ambient tone volume based on master volume changes
   * @param {string} currentEmotion - Current emotion for volume calculation
   */
  updateAmbientVolume(currentEmotion) {
    if (!this.isAvailable() || !this.currentGain || !currentEmotion) {
      return;
    }

    const toneConfig = this.getEmotionalTone(currentEmotion);
    if (!toneConfig) {
      return;
    }

    try {
      const targetVolume = toneConfig.volume * this.masterVolume;
      const currentTime = this.context.currentTime;
      
      this.currentGain.gain.exponentialRampToValueAtTime(targetVolume, currentTime + 0.1);
    } catch (error) {
      // SoundSystem: Failed to update ambient volume
    }
  }

  /**
   * Play gesture sound effect with frequency envelope
   * @param {string} gestureId - Gesture identifier
   * @param {string} emotionalContext - Current emotion for intensity modifiers
   */
  playGestureSound(gestureId, emotionalContext = 'neutral') {
    if (!this.isAvailable()) {
      return;
    }

    // Use harmonic system if enabled
    if (this.useHarmonicSystem && this.harmonicSystem) {
      this.harmonicSystem.playGestureSound(gestureId);
      return;
    }

    const soundConfig = this.getGestureSoundConfig(gestureId);
    if (!soundConfig) {
      // Throttled warning for unknown gestures
      this.throttledWarn(`Unknown gesture "${gestureId}", cannot play sound`, `gesture_${gestureId}`);
      return;
    }

    try {
      // Resume context if suspended
      this.resumeContext();

      const currentTime = this.context.currentTime;
      const duration = soundConfig.duration / 1000; // Convert to seconds

      // Apply emotional modifiers
      const modifiers = this.getEmotionalModifiers(emotionalContext);
      const baseVolume = soundConfig.volume * this.masterVolume * modifiers.intensity;

      // Create oscillator and gain for the effect
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();

      // Configure oscillator
      oscillator.type = soundConfig.waveform;

      // Apply frequency envelope
      this.applyFrequencyEnvelope(oscillator, soundConfig.frequencyEnvelope, currentTime, duration);

      // Apply volume envelope
      this.applyVolumeEnvelope(gainNode, soundConfig.volumeEnvelope, currentTime, duration, baseVolume);

      // Connect nodes
      oscillator.connect(gainNode);
      gainNode.connect(this.nodes.effects);

      // Start and stop oscillator
      oscillator.start(currentTime);
      oscillator.stop(currentTime + duration);

      // SoundSystem: Playing gesture sound

    } catch (error) {
      // SoundSystem: Failed to play gesture sound
    }
  }

  /**
   * Get gesture sound configuration
   * @param {string} gestureId - Gesture identifier
   * @returns {Object|null} Sound configuration or null if not found
   */
  getGestureSoundConfig(gestureId) {
    const gestureSounds = new Map([
      ['bounce', {
        duration: 100,
        waveform: 'triangle',
        volume: 0.3,
        frequencyEnvelope: [
          { time: 0, frequency: 200 },
          { time: 0.5, frequency: 400 },
          { time: 1, frequency: 300 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 1.0 },
          { time: 0.1, volume: 0.8 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['pulse', {
        duration: 300,
        waveform: 'sine',
        volume: 0.25,
        frequencyEnvelope: [
          { time: 0, frequency: 300 },
          { time: 0.5, frequency: 450 },
          { time: 1, frequency: 300 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.3, volume: 1.0 },
          { time: 0.7, volume: 1.0 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['shake', {
        duration: 200,
        waveform: 'sawtooth',
        volume: 0.2,
        frequencyEnvelope: [
          { time: 0, frequency: 150 },
          { time: 0.25, frequency: 200 },
          { time: 0.5, frequency: 150 },
          { time: 0.75, frequency: 200 },
          { time: 1, frequency: 150 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.8 },
          { time: 0.5, volume: 1.0 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['spin', {
        duration: 600,
        waveform: 'triangle',
        volume: 0.35,
        frequencyEnvelope: [
          { time: 0, frequency: 220 },
          { time: 0.3, frequency: 440 },
          { time: 0.7, frequency: 660 },
          { time: 1, frequency: 330 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.2, volume: 1.0 },
          { time: 0.8, volume: 0.8 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['nod', {
        duration: 150,
        waveform: 'sine',
        volume: 0.15,
        frequencyEnvelope: [
          { time: 0, frequency: 180 },
          { time: 0.5, frequency: 220 },
          { time: 1, frequency: 180 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.5 },
          { time: 0.3, volume: 1.0 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['tilt', {
        duration: 200,
        waveform: 'triangle',
        volume: 0.18,
        frequencyEnvelope: [
          { time: 0, frequency: 250 },
          { time: 0.6, frequency: 350 },
          { time: 1, frequency: 280 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.4, volume: 1.0 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['expand', {
        duration: 500,
        waveform: 'sine',
        volume: 0.4,
        frequencyEnvelope: [
          { time: 0, frequency: 200 },
          { time: 0.7, frequency: 500 },
          { time: 1, frequency: 400 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.3, volume: 1.0 },
          { time: 0.9, volume: 0.8 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['contract', {
        duration: 400,
        waveform: 'triangle',
        volume: 0.22,
        frequencyEnvelope: [
          { time: 0, frequency: 400 },
          { time: 0.8, frequency: 200 },
          { time: 1, frequency: 180 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 1.0 },
          { time: 0.6, volume: 0.8 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['flash', {
        duration: 200,
        waveform: 'square',
        volume: 0.3,
        frequencyEnvelope: [
          { time: 0, frequency: 800 },
          { time: 0.1, frequency: 1200 },
          { time: 0.2, frequency: 800 },
          { time: 1, frequency: 600 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.05, volume: 1.0 },
          { time: 0.15, volume: 0.3 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['wave', {
        duration: 400,
        waveform: 'sine',
        volume: 0.25,
        frequencyEnvelope: [
          { time: 0, frequency: 300 },
          { time: 0.3, frequency: 500 },
          { time: 0.6, frequency: 400 },
          { time: 1, frequency: 350 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.2, volume: 0.8 },
          { time: 0.7, volume: 0.6 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['breathe', {
        duration: 800,  // Slightly shorter for more impact
        waveform: 'triangle',  // Changed from sine for more harmonics
        volume: 0.6,  // Much louder
        frequencyEnvelope: [
          { time: 0, frequency: 300 },
          { time: 0.3, frequency: 500 },
          { time: 0.5, frequency: 600 },
          { time: 0.7, frequency: 400 },
          { time: 1, frequency: 250 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.2 },  // Start with some volume
          { time: 0.2, volume: 1.0 }, // Quick attack
          { time: 0.5, volume: 0.9 }, // Strong sustain
          { time: 0.8, volume: 0.7 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['morph', {
        duration: 600,
        waveform: 'triangle',
        volume: 0.3,
        frequencyEnvelope: [
          { time: 0, frequency: 100 },
          { time: 0.2, frequency: 300 },
          { time: 0.5, frequency: 600 },
          { time: 0.8, frequency: 400 },
          { time: 1, frequency: 200 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.5 },
          { time: 0.3, volume: 1.0 },
          { time: 0.7, volume: 0.8 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['jump', {
        duration: 250,
        waveform: 'square',
        volume: 0.35,
        frequencyEnvelope: [
          { time: 0, frequency: 200 },
          { time: 0.2, frequency: 600 },
          { time: 0.4, frequency: 800 },
          { time: 0.8, frequency: 400 },
          { time: 1, frequency: 100 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.8 },
          { time: 0.1, volume: 1.0 },
          { time: 0.3, volume: 0.6 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['drift', {
        duration: 800,
        waveform: 'sine',
        volume: 0.12,
        frequencyEnvelope: [
          { time: 0, frequency: 160 },
          { time: 0.4, frequency: 240 },
          { time: 0.8, frequency: 200 },
          { time: 1, frequency: 180 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.2, volume: 1.0 },
          { time: 0.8, volume: 0.8 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['wave', {
        duration: 400,
        waveform: 'sine',
        volume: 0.25,
        frequencyEnvelope: [
          { time: 0, frequency: 200 },
          { time: 0.25, frequency: 300 },
          { time: 0.5, frequency: 250 },
          { time: 0.75, frequency: 280 },
          { time: 1, frequency: 200 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.2, volume: 0.8 },
          { time: 0.8, volume: 0.8 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['breathe', {
        duration: 3500,  // Match gesture duration
        waveform: 'sine',
        volume: 0.2,
        // Deep, calming breath sound - low frequencies
        frequencyEnvelope: [
          { time: 0, frequency: 80 },    // Start low (exhale)
          { time: 0.4, frequency: 150 },  // Rise during inhale
          { time: 0.5, frequency: 160 },  // Peak at full inhale
          { time: 0.9, frequency: 100 },  // Fall during exhale
          { time: 1, frequency: 80 }      // Back to low
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.3 },     // Quiet start
          { time: 0.4, volume: 0.8 },   // Louder inhale
          { time: 0.5, volume: 0.7 },   // Hold
          { time: 0.9, volume: 0.6 },   // Quieter exhale
          { time: 1, volume: 0.2 }      // Fade out
        ]
      }],
      ['flicker', {
        duration: 300,
        waveform: 'square',
        volume: 0.2,
        frequencyEnvelope: [
          { time: 0, frequency: 600 },
          { time: 0.1, frequency: 400 },
          { time: 0.2, frequency: 800 },
          { time: 0.3, frequency: 300 },
          { time: 0.5, frequency: 700 },
          { time: 1, frequency: 500 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 1.0 },
          { time: 0.1, volume: 0.2 },
          { time: 0.2, volume: 0.9 },
          { time: 0.3, volume: 0.3 },
          { time: 0.5, volume: 0.8 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['vibrate', {
        duration: 250,
        waveform: 'sawtooth',
        volume: 0.3,
        frequencyEnvelope: [
          { time: 0, frequency: 100 },
          { time: 0.1, frequency: 150 },
          { time: 0.2, frequency: 100 },
          { time: 0.3, frequency: 150 },
          { time: 0.4, frequency: 100 },
          { time: 0.5, frequency: 150 },
          { time: 0.6, frequency: 100 },
          { time: 0.7, frequency: 150 },
          { time: 1, frequency: 80 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 1.0 },
          { time: 0.8, volume: 1.0 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['glow', {
        duration: 600,
        waveform: 'sine',
        volume: 0.15,
        frequencyEnvelope: [
          { time: 0, frequency: 300 },
          { time: 0.5, frequency: 500 },
          { time: 1, frequency: 400 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.0 },
          { time: 0.3, volume: 1.0 },
          { time: 0.7, volume: 1.0 },
          { time: 1, volume: 0.0 }
        ]
      }],
      ['stretch', {
        duration: 450,
        waveform: 'triangle',
        volume: 0.2,
        frequencyEnvelope: [
          { time: 0, frequency: 250 },
          { time: 0.3, frequency: 180 },
          { time: 0.7, frequency: 320 },
          { time: 1, frequency: 250 }
        ],
        volumeEnvelope: [
          { time: 0, volume: 0.6 },
          { time: 0.2, volume: 1.0 },
          { time: 0.8, volume: 0.9 },
          { time: 1, volume: 0.0 }
        ]
      }]
    ]);

    return gestureSounds.get(gestureId) || null;
  }

  /**
   * Apply frequency envelope to oscillator
   * @param {OscillatorNode} oscillator - Web Audio oscillator
   * @param {Array} envelope - Frequency envelope points
   * @param {number} startTime - Start time in audio context
   * @param {number} duration - Total duration in seconds
   */
  applyFrequencyEnvelope(oscillator, envelope, startTime, duration) {
    envelope.forEach(point => {
      const time = startTime + (point.time * duration);
      oscillator.frequency.linearRampToValueAtTime(point.frequency, time);
    });
  }

  /**
   * Apply volume envelope to gain node
   * @param {GainNode} gainNode - Web Audio gain node
   * @param {Array} envelope - Volume envelope points
   * @param {number} startTime - Start time in audio context
   * @param {number} duration - Total duration in seconds
   * @param {number} baseVolume - Base volume level
   */
  applyVolumeEnvelope(gainNode, envelope, startTime, duration, baseVolume) {
    envelope.forEach((point, index) => {
      const time = startTime + (point.time * duration);
      const volume = point.volume * baseVolume;
      
      if (index === 0) {
        gainNode.gain.setValueAtTime(volume, time);
      } else {
        gainNode.gain.linearRampToValueAtTime(volume, time);
      }
    });
  }

  /**
   * Get emotional modifiers for gesture sounds
   * @param {string} emotion - Current emotion
   * @returns {Object} Modifier values
   */
  getEmotionalModifiers(emotion) {
    const modifiers = new Map([
      ['neutral', { intensity: 1.0, speed: 1.0 }],
      ['joy', { intensity: 1.3, speed: 1.2 }],
      ['sadness', { intensity: 0.6, speed: 0.8 }],
      ['anger', { intensity: 1.5, speed: 1.4 }],
      ['fear', { intensity: 0.8, speed: 1.3 }],
      ['surprise', { intensity: 1.4, speed: 1.5 }],
      ['disgust', { intensity: 0.7, speed: 0.9 }],
      ['love', { intensity: 1.1, speed: 0.9 }]
    ]);

    return modifiers.get(emotion) || modifiers.get('neutral');
  }

  /**
   * Enable/disable quality reduction for performance
   * @param {boolean} enabled - Whether to reduce quality
   */
  setQualityReduction(enabled) {
    this.qualityReduction = enabled;
    
    if (enabled && this.audioContext) {
      // Reduce active oscillators
      this.maxOscillators = 2;
    } else {
      // Restore full quality
      this.maxOscillators = 4;
    }
  }
  
  /**
   * Check if Web Audio API is supported in current browser
   * @returns {boolean} Support status
   */
  static isSupported() {
    return !!(window.AudioContext || window.webkitAudioContext);
  }
  
  /**
   * Throttled warning to reduce console spam
   * @param {string} message - Warning message
   * @param {string} key - Unique key for this warning type
   */
  throttledWarn(message, key) {
    const now = Date.now();
    const lastWarning = this.warningTimestamps[key] || 0;
    
    if (now - lastWarning > this.warningThrottle) {
      // SoundSystem warning
      this.warningTimestamps[key] = now;
    }
  }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  SIMPLE FPS COUNTER  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Simple FPS Counter - Accurate Frame Rate Measurement
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module SimpleFPSCounter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The SPEEDOMETER of the engine. Accurately measures frames per second using        
 * ║ a rolling timestamp array. Shows exactly how smooth the animation is running.     
 * ║ Critical for performance monitoring and automatic quality degradation.            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 FPS CALCULATION METHOD                                                         
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Stores timestamps from the last second                                          
 * │ • Counts frames within 1000ms window                                              
 * │ • More accurate than delta time averaging                                         
 * │ • Updates every frame for real-time monitoring                                    
 * │ • Based on 2025 best practices for JavaScript FPS                                 
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ PERFORMANCE TARGETS                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • 60 FPS   : Smooth animation (16.67ms per frame)                                 
 * │ • 30 FPS   : Acceptable minimum (33.33ms per frame)                               
 * │ • < 30 FPS : Triggers quality degradation                                         
 * │ • < 15 FPS : Critical performance issues                                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ═══════════════════════════════════════════════════════════════════════════════════
 */
class SimpleFPSCounter {
    constructor() {
        // Array to store timestamps from the last second
        this.timestamps = [];
        
        // Current FPS value
        this.fps = 0;
        
        // Smoothed FPS for display (to reduce jitter)
        this.smoothedFPS = 0;
        this.smoothingFactor = 0.9; // Higher = more smoothing
        
        // Frame time tracking
        this.lastFrameTime = 0;
        this.frameTime = 0;
        
        // Average frame time over last N frames
        this.frameTimes = [];
        this.maxFrameTimeSamples = 10;
        this.averageFrameTime = 0;
    }
    
    /**
     * Update FPS calculation with new frame
     * Call this in your animation loop with the timestamp from requestAnimationFrame
     * @param {number} timestamp - High resolution timestamp from requestAnimationFrame
     */
    update(timestamp) {
        // Remove timestamps older than 1 second
        while (this.timestamps.length > 0 && this.timestamps[0] <= timestamp - 1000) {
            this.timestamps.shift();
        }
        
        // Add current timestamp
        this.timestamps.push(timestamp);
        
        // FPS is the number of frames in the last second
        this.fps = this.timestamps.length;
        
        // Apply smoothing to reduce display jitter
        if (this.smoothedFPS === 0) {
            this.smoothedFPS = this.fps;
        } else {
            this.smoothedFPS = this.smoothedFPS * this.smoothingFactor + 
                               this.fps * (1 - this.smoothingFactor);
        }
        
        // Calculate frame time
        if (this.lastFrameTime > 0) {
            this.frameTime = timestamp - this.lastFrameTime;
            
            // Track frame times for averaging
            this.frameTimes.push(this.frameTime);
            if (this.frameTimes.length > this.maxFrameTimeSamples) {
                this.frameTimes.shift();
            }
            
            // Calculate average frame time
            if (this.frameTimes.length > 0) {
                const sum = this.frameTimes.reduce((a, b) => a + b, 0);
                this.averageFrameTime = sum / this.frameTimes.length;
            }
        }
        this.lastFrameTime = timestamp;
    }
    
    /**
     * Get current FPS
     * @returns {number} Current FPS (integer)
     */
    getFPS() {
        return Math.round(this.fps);
    }
    
    /**
     * Get smoothed FPS for display
     * @returns {number} Smoothed FPS (integer)
     */
    getSmoothedFPS() {
        return Math.round(this.smoothedFPS);
    }
    
    /**
     * Get last frame time in milliseconds
     * @returns {number} Frame time in ms
     */
    getFrameTime() {
        return this.frameTime;
    }
    
    /**
     * Get average frame time over recent frames
     * @returns {number} Average frame time in ms
     */
    getAverageFrameTime() {
        return this.averageFrameTime;
    }
    
    /**
     * Reset the FPS counter
     */
    reset() {
        this.timestamps = [];
        this.fps = 0;
        this.smoothedFPS = 0;
        this.lastFrameTime = 0;
        this.frameTime = 0;
        this.frameTimes = [];
        this.averageFrameTime = 0;
    }
    
    /**
     * Get all metrics
     * @returns {Object} Object containing all FPS metrics
     */
    getMetrics() {
        return {
            fps: this.getFPS(),
            smoothedFPS: this.getSmoothedFPS(),
            frameTime: this.getFrameTime(),
            averageFrameTime: this.getAverageFrameTime(),
            // Performance status based on FPS
            status: this.fps >= 55 ? 'good' : this.fps >= 30 ? 'okay' : 'poor'
        };
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝
 *                    ◐ ◑ ◒ ◓  ANIMATION CONTROLLER  ◓ ◒ ◑ ◐
 *
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Animation Controller - Main Loop & Performance Management
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module AnimationController
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The HEARTBEAT of the Emotive Engine. Manages the main animation loop,             
 * ║ coordinates all subsystems, monitors performance, and ensures smooth              
 * ║ frame rates through adaptive quality control.                                     
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎬 CORE RESPONSIBILITIES                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Main requestAnimationFrame loop management                                      
 * │ • Frame timing and deltaTime calculation                                          
 * │ • Performance monitoring and FPS tracking                                         
 * │ • Adaptive quality degradation when performance drops                             
 * │ • Subsystem update coordination (render, particles, state)                        
 * │ • Visibility and pause state handling                                             
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ PERFORMANCE FEATURES                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Dynamic FPS targeting (15, 30, 45, 60 FPS)                                      
 * │ • Frame skipping for consistent timing                                            
 * │ • Automatic quality reduction when FPS drops                                      
 * │ • Recovery system when performance improves                                       
 * │ • Memory leak detection and prevention                                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔧 CONFIGURATION OPTIONS                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • targetFPS         : Desired frame rate (default: 60)                            
 * │ • enableDegradation : Allow quality reduction (default: true)                     
 * │ • performanceMode   : 'adaptive' | 'fixed' | 'maximum'                           
 * │ • monitoringInterval: Performance check frequency (default: 1000ms)               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ CRITICAL - DO NOT MODIFY                                                       
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ Frame timing logic       → Breaks animation smoothness                         
 * │ ✗ Update order            → Causes render/state desync                           
 * │ ✗ Performance thresholds   → May cause excessive degradation                     
 * │ ✗ Memory cleanup          → Creates memory leaks                                 
 * │ ✗ RAF loop management     → Breaks entire animation system                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                          SUBSYSTEM UPDATE ORDER                                   
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ 1. Performance monitoring (FPS calculation)                                       
 * ║ 2. State machine update (emotions, transitions)                                   
 * ║ 3. Gesture processing (animation progress)                                        
 * ║ 4. Particle system update (movement, spawning)                                    
 * ║ 5. Renderer update (draw orb and particles)                                       
 * ║ 6. Cleanup and memory management                                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class AnimationController {
    constructor(errorBoundary, config = {}) {
        this.errorBoundary = errorBoundary;
        this.config = config;
        this.config.targetFPS = config.targetFPS || 60;
        
        // Animation state
        this.isRunning = false;
        this.animationFrameId = null;
        this.loopCallbackId = null; // For AnimationLoopManager
        this.lastFrameTime = 0;
        this.deltaTime = 0;
        this.isPaused = false;
        
        // Set up visibility change and window focus handling
        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
        this.handleWindowBlur = this.handleWindowBlur.bind(this);
        this.handleWindowFocus = this.handleWindowFocus.bind(this);

        if (typeof document !== 'undefined') {
            document.addEventListener('visibilitychange', this.handleVisibilityChange);
            window.addEventListener('blur', this.handleWindowBlur);
            window.addEventListener('focus', this.handleWindowFocus);
        }
        
        // PerformanceMonitor DISABLED - no FPS interference
        this.performanceMonitor = null;
        /* 
        this.performanceMonitor = new PerformanceMonitor(config);
        this.performanceMonitor.setEventCallback((event, data) => {
            this.emit(event, data);
        });
        */
        
        // Simple FPS counter for accurate display
        this.fpsCounter = new SimpleFPSCounter();
        
        // Subsystem references (injected via setSubsystems)
        this.subsystems = {};
        
        // Event callback for external integration
        this.eventCallback = null;
        
        // Reference to parent EmotiveMascot for audio level updates
        this.parentMascot = null;
        
    }

    /**
     * Injects subsystem dependencies
     * @param {Object} subsystems - Object containing all required subsystems
     */
    setSubsystems(subsystems) {
        this.subsystems = {
            stateMachine: subsystems.stateMachine,
            particleSystem: subsystems.particleSystem,
            renderer: subsystems.renderer,
            soundSystem: subsystems.soundSystem,
            canvasManager: subsystems.canvasManager
        };
        
        // Validate required subsystems
        const required = ['stateMachine', 'particleSystem', 'renderer'];
        for (const system of required) {
            if (!this.subsystems[system]) {
                throw new Error(`Required subsystem '${system}' not provided`);
            }
        }
        
        // PerformanceMonitor disabled
        if (this.performanceMonitor) {
            this.performanceMonitor.setSubsystems(this.subsystems);
        }
        
    }

    /**
     * Sets the event callback for external integration
     * @param {Function} callback - Function to call for event emission
     */
    setEventCallback(callback) {
        if (typeof callback !== 'function') {
            throw new Error('Event callback must be a function');
        }
        this.eventCallback = callback;
    }

    /**
     * Sets the parent EmotiveMascot reference for audio level updates
     * @param {EmotiveMascot} mascot - Parent mascot instance
     */
    setParentMascot(mascot) {
        this.parentMascot = mascot;
    }

    /**
     * Emits an event through the callback if available
     * @param {string} event - Event name
     * @param {*} data - Event data
     */
    emit(event, data = null) {
        if (this.eventCallback) {
            this.eventCallback(event, data);
        }
    }

    /**
     * Starts the animation loop
     * @returns {boolean} Success status
     */
    start() {
        return this.errorBoundary.wrap(() => {
            if (this.isRunning) {
                return false;
            }

            if (!this.subsystems.stateMachine) {
                throw new Error('Cannot start animation without subsystems configured');
            }
            
            // Initialize animation state
            this.isRunning = true;
            this.lastFrameTime = performance.now();
            
            // Resume audio context if available
            if (this.subsystems.soundSystem && this.subsystems.soundSystem.isAvailable()) {
                this.subsystems.soundSystem.resumeContext();
            }

            // Register with AnimationLoopManager instead of direct RAF
            this.loopCallbackId = animationLoopManager.register(
                (deltaTime, timestamp) => this.animate(deltaTime, timestamp),
                AnimationPriority.CRITICAL, // Main render loop is critical priority
                this
            );

            // Emit start event
            this.emit('animationStarted', { targetFPS: this.targetFPS });
            
            return true;
        }, 'animation-start')();
    }

    /**
     * Stops the animation loop
     * @returns {boolean} Success status
     */
    stop() {
        return this.errorBoundary.wrap(() => {
            if (!this.isRunning) {
                return false;
            }
            
            // Stop animation loop
            this.isRunning = false;

            // Unregister from AnimationLoopManager
            if (this.loopCallbackId) {
                animationLoopManager.unregister(this.loopCallbackId);
                this.loopCallbackId = null;
            }

            // Clean up old RAF if it exists (for backwards compatibility)
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }


            
            // Stop all active gestures
            if (this.subsystems.renderer && this.subsystems.renderer.stopAllGestures) {
                this.subsystems.renderer.stopAllGestures();
            }
            
            // Stop ambient audio
            if (this.subsystems.soundSystem && this.subsystems.soundSystem.isAvailable()) {
                this.subsystems.soundSystem.stopAmbientTone();
            }
            
            // Clear particles
            if (this.subsystems.particleSystem) {
                this.subsystems.particleSystem.clear();
            }
            
            // Emit stop event
            this.emit('animationStopped');
            
            return true;
        }, 'animation-stop')();
    }

    /**
     * Handles window blur event
     */
    handleWindowBlur() {
        // Use same logic as visibility change
        if (!document.hidden) {
            // Only pause if document isn't already hidden (avoid double-pause)
            this.handleVisibilityChange();
        }
    }

    /**
     * Handles window focus event
     */
    handleWindowFocus() {
        // Force a resume check
        if (!document.hidden && this.isPaused) {
            // Simulate visibility change to visible
            this.handleVisibilityChange();
        }
    }

    /**
     * Handles document visibility changes to pause/resume animation
     */
    handleVisibilityChange() {
        if (document.hidden) {
            // Tab became hidden - pause animation
            this.wasRunning = this.isRunning;
            this.isPaused = true;

            // Store current time to calculate gap when resuming
            this.pauseTime = performance.now();

            // Stop all active systems
            if (this.subsystems?.particleSystem) {
                // Clear spawn accumulator to prevent burst on resume
                this.subsystems.particleSystem.resetAccumulator();
                // Store particle count for debugging
                this.pausedParticleCount = this.subsystems.particleSystem.particles?.length || 0;
            }

            // Pause gesture animations if any are active
            if (this.subsystems?.renderer?.gestureAnimator) {
                this.subsystems.renderer.gestureAnimator.pauseCurrentAnimation?.();
            }

            // Notify parent mascot to pause
            if (this.parentMascot?.pause) {
                this.parentMascot.pause();
            }
        } else {
            // Tab became visible - resume animation smoothly
            if (this.isPaused && this.wasRunning) {
                // Calculate time gap
                const resumeTime = performance.now();
                const gap = resumeTime - this.pauseTime;

                // Reset timing to prevent huge deltaTime spike
                this.lastFrameTime = resumeTime;
                this.frameTimeAccumulator = 0;

                // Clear and reset all systems
                if (this.subsystems?.particleSystem) {
                    // Clear accumulator again to be safe
                    this.subsystems.particleSystem.resetAccumulator();
                    // Clear any stuck particles if gap was too long
                    if (gap > 5000) { // More than 5 seconds
                        this.subsystems.particleSystem.particles = [];
                    }
                }

                // Reset canvas context to fix any rendering artifacts
                if (this.renderer) {
                    this.renderer.resetCanvasContext();

                    // Reset any active animations
                    if (this.renderer.gestureAnimator) {
                        this.renderer.gestureAnimator.resumeAnimation?.();
                    }

                    // Force a clean frame
                    this.renderer.forceCleanRender = true;
                }

                // Reset state machine timing
                if (this.subsystems?.stateMachine) {
                    // Update state machine's last update time
                    this.subsystems.stateMachine.lastUpdateTime = resumeTime;
                }

                // Notify parent mascot to resume
                if (this.parentMascot?.resume) {
                    this.parentMascot.resume();
                }

                // Finally unpause
                this.isPaused = false;

                // Log for debugging
                if (this.performanceMonitor) {
                    console.log(`Resumed after ${(gap/1000).toFixed(1)}s pause. Cleared particles: ${this.pausedParticleCount || 0}`);
                }
            }
        }
    }
    
    /**
     * Main animation loop with deltaTime calculation and performance monitoring
     * Now called by AnimationLoopManager with centralized frame timing
     * @param {number} deltaTime - Time since last frame from loop manager
     * @param {number} timestamp - Current timestamp from loop manager
     */
    animate(deltaTime, timestamp) {
        if (!this.isRunning || this.isPaused) return;

        this.errorBoundary.wrap(() => {
            // Use deltaTime from AnimationLoopManager if provided, else calculate
            const currentTime = timestamp || performance.now();
            this.deltaTime = deltaTime || (currentTime - this.lastFrameTime);
            
            // Cap deltaTime to prevent physics instability
            // Use a consistent cap of 50ms (20 FPS minimum)
            const skipParticleSpawn = this.deltaTime > 33; // Skip spawning if under 30fps
            
            if (this.deltaTime > 50) {
                // Large gap detected - cap and reset accumulator
                this.deltaTime = 50;
                // Reset the accumulator to prevent burst spawning
                if (this.subsystems?.particleSystem) {
                    this.subsystems.particleSystem.resetAccumulator();
                }
            }
            
            // Store skip flag for particle system
            if (this.subsystems?.particleSystem) {
                this.subsystems.particleSystem.skipSpawnThisFrame = skipParticleSpawn;
            }
            
            this.lastFrameTime = currentTime;
            
            // PerformanceMonitor disabled
            if (this.performanceMonitor) {
                this.performanceMonitor.startFrame(currentTime);
            }
            
            // Update simple FPS counter
            this.fpsCounter.update(currentTime);
            
            // Update all subsystems with integrated deltaTime
            this.update(this.deltaTime);
            
            // Render the current frame
            this.render();
            
            // PerformanceMonitor disabled
            if (this.performanceMonitor) {
                this.performanceMonitor.endFrame(performance.now());
            }

            // AnimationLoopManager now handles the loop scheduling
            // No need to call requestAnimationFrame here

        }, 'animation-loop')();
    }

    /**
     * Updates all subsystems
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    update(deltaTime) {
        this.errorBoundary.wrap(() => {
            performance.now();
            
            // Update state machine
            if (this.subsystems.stateMachine) {
                this.subsystems.stateMachine.update(deltaTime);
            }
            
            // Gesture updates now handled by renderer
            
            // Update parent mascot for audio level monitoring
            if (this.parentMascot && typeof this.parentMascot.update === 'function') {
                this.parentMascot.update(deltaTime);
            }
            
            // Only handle particles here if NOT in classic rendering mode
            // Classic mode handles its own particles in EmotiveMascot.render()
            const isClassicMode = this.parentMascot?.config?.renderingStyle === 'classic';
            
            if (!isClassicMode) {
                // Get current emotional properties and center for particle system (advanced mode only)
                if (this.subsystems.particleSystem && this.subsystems.stateMachine && this.subsystems.canvasManager) {
                    const emotionalProps = this.subsystems.stateMachine.getCurrentEmotionalProperties();
                    const center = this.subsystems.canvasManager.getCenter();
                    
                    // Get current gesture info from renderer if available
                    let gestureMotion = null;
                    let gestureProgress = 0;
                    
                    if (this.subsystems.renderer && this.subsystems.renderer.getCurrentGesture) {
                        const currentGesture = this.subsystems.renderer.getCurrentGesture();
                        if (currentGesture && currentGesture.particleMotion) {
                            gestureMotion = currentGesture.particleMotion;
                            gestureProgress = currentGesture.progress || 0;
                        }
                    }
                    
                    // Update particle system with current emotional context
                    this.subsystems.particleSystem.spawn(
                        emotionalProps.particleBehavior,
                        this.subsystems.stateMachine.getCurrentState().emotion,
                        emotionalProps.particleRate,
                        center.x,
                        center.y,
                        deltaTime
                    );
                    
                    // Update particles with gesture motion if available
                    this.subsystems.particleSystem.update(deltaTime, center.x, center.y, gestureMotion, gestureProgress);
                }
            }
            
            // PerformanceMonitor disabled
            if (this.performanceMonitor) {
                this.performanceMonitor.updateMetrics({
                    particleCount: this.subsystems.particleSystem?.getActiveParticleCount?.() || 0,
                    audioLatency: this.subsystems.soundSystem?.getLatency?.() || 0
                });
            }
            
        }, 'subsystem-update')();
    }

    /**
     * Renders the current frame
     */
    render() {
        this.errorBoundary.wrap(() => {
            // Call parent mascot's render method if available
            if (this.parentMascot && typeof this.parentMascot.render === 'function') {
                this.parentMascot.render();
            } else if (this.subsystems.renderer) {
                // Fallback to direct renderer call
                this.subsystems.renderer.render();
            }
        }, 'frame-render')();
    }



    /**
     * Gets current performance metrics (delegated to PerformanceMonitor)
     * @returns {Object} Performance data
     */
    getPerformanceMetrics() {
        // PerformanceMonitor disabled - use simple FPS counter only
        const fpsMetrics = this.fpsCounter ? this.fpsCounter.getMetrics() : {};
        return {
            fps: fpsMetrics.fps || 60,
            instantFps: fpsMetrics.smoothedFPS || 60,
            frameTime: fpsMetrics.frameTime || 16.67,
            averageFrameTime: fpsMetrics.averageFrameTime || 16.67,
            isRunning: this.isRunning,
            deltaTime: this.deltaTime
        };
    }

    /**
     * Sets the target FPS (delegated to PerformanceMonitor)
     * @param {number} fps - Target FPS value
     */
    setTargetFPS(fps) {
        // DISABLED - no FPS changes allowed
        return;
    }

    /**
     * Gets the target FPS
     * @returns {number} Target FPS value
     */
    get targetFPS() {
        return this.config.targetFPS || 60;
    }

    /**
     * Checks if the animation is currently running
     * @returns {boolean} Running status
     */
    isAnimating() {
        return this.isRunning;
    }

    /**
     * Destroys the animation controller and cleans up resources
     */
    destroy() {
        this.stop();
        
        // Remove visibility change and focus listeners
        if (typeof document !== 'undefined') {
            document.removeEventListener('visibilitychange', this.handleVisibilityChange);
            window.removeEventListener('blur', this.handleWindowBlur);
            window.removeEventListener('focus', this.handleWindowFocus);
        }
        
        // Destroy performance monitor
        if (this.performanceMonitor) {
            this.performanceMonitor.destroy();
            this.performanceMonitor = null;
        }
        
        // Clear subsystem references
        this.subsystems = {};
        this.eventCallback = null;
        
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                   ◐ ◑ ◒ ◓  AUDIO LEVEL PROCESSOR  ◓ ◒ ◑ ◐                   
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Audio Level Processor - Real-time Audio Analysis & Reactivity
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module AudioLevelProcessor
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Analyzes real-time audio input to make the mascot react to speech and sound.      
 * ║ Detects volume spikes, tracks audio history, and triggers emotional responses      
 * ║ based on audio levels. Makes the orb "listen" and respond to your voice!          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎤 AUDIO ANALYSIS FEATURES                                                        
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Real-time RMS level calculation                                                 
 * │ • Volume spike detection with cooldown                                            
 * │ • Audio level history tracking                                                    
 * │ • Frequency analysis via FFT                                                      
 * │ • Smooth level transitions                                                        
 * │ • Microphone permission handling                                                  
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 PROCESSING PIPELINE                                                            
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ 1. Microphone → getUserMedia()                                                    
 * │ 2. MediaStream → AudioContext                                                     
 * │ 3. AudioContext → AnalyserNode                                                    
 * │ 4. AnalyserNode → Frequency Data (FFT)                                            
 * │ 5. Frequency Data → RMS Calculation                                               
 * │ 6. RMS → Spike Detection & Level Events                                           
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ SPIKE DETECTION                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Threshold: Current level > average * spikeThreshold                            
 * │ • Cooldown: Minimum interval between spikes (default: 1000ms)                    
 * │ • Triggers: "nod" gesture for speech acknowledgment                              
 * │ • Sensitivity: Configurable via spikeThreshold (1.5 = 50% above average)         
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔧 CONFIGURATION                                                                   
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ PARAMETER              DEFAULT    DESCRIPTION                                     
 * │ spikeThreshold         1.5        Multiplier for spike detection                  
 * │ minimumSpikeLevel      0.1        Minimum level to trigger spike                  
 * │ spikeMinInterval       1000       Cooldown between spikes (ms)                   
 * │ historySize            10         Audio level history buffer size                 
 * │ smoothingTimeConstant  0.8        FFT smoothing (0=none, 1=max)                  
 * │ fftSize                256        FFT bin size for frequency analysis             
 * │ levelUpdateThrottle    100        Throttle for level update events (ms)          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📡 EVENTS                                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • levelUpdate  : Emitted when audio level changes (throttled)                     
 * │ • volumeSpike  : Emitted when spike detected (with cooldown)                      
 * │ • error        : Emitted on processing errors                                     
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                USAGE EXAMPLE                                      
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ const processor = new AudioLevelProcessor({                                       
 * ║     spikeThreshold: 1.5,                                                          
 * ║     spikeMinInterval: 500                                                         
 * ║ });                                                                                
 * ║                                                                                    
 * ║ processor.on('volumeSpike', (level) => {                                          
 * ║     mascot.triggerGesture('nod');  // React to speech                            
 * ║ });                                                                                
 * ║                                                                                    
 * ║ processor.on('levelUpdate', (level) => {                                          
 * ║     mascot.setAudioLevel(level);   // Smooth breathing with speech               
 * ║ });                                                                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */
class AudioLevelProcessor {
    constructor(config = {}) {
        // Configuration with defaults
        this.config = {
            spikeThreshold: config.spikeThreshold || 1.5,
            minimumSpikeLevel: config.minimumSpikeLevel || 0.1,
            spikeMinInterval: config.spikeMinInterval || 1000, // ms between spikes
            historySize: config.historySize || 10,
            smoothingTimeConstant: config.smoothingTimeConstant || 0.8,
            fftSize: config.fftSize || 256,
            levelUpdateThrottle: config.levelUpdateThrottle || 100, // ms
            ...config
        };
        
        // Audio context and analysis
        this.audioContext = null;
        this.analyser = null;
        this.dataArray = null;
        
        // Audio level state
        this.currentLevel = 0;
        this.levelHistory = [];
        this.isActive = false;
        
        // Spike detection state
        this.lastVolumeSpike = 0;
        
        // Event throttling
        this.lastLevelEmit = 0;
        
        // Event callbacks
        this.callbacks = {
            levelUpdate: null,
            volumeSpike: null,
            error: null
        };
    }

    /**
     * Initialize audio level processing with provided audio context
     * @param {AudioContext} audioContext - Web Audio API context
     * @returns {boolean} Success status
     */
    initialize(audioContext) {
        try {
            if (!audioContext) {
                throw new Error('AudioContext is required for audio level processing');
            }
            
            // Validate AudioContext
            if (typeof audioContext.createAnalyser !== 'function') {
                throw new Error('Invalid AudioContext provided');
            }
            
            // Store audio context
            this.audioContext = audioContext;
            
            // Create audio analyser for level monitoring
            this.analyser = audioContext.createAnalyser();
            this.analyser.fftSize = this.config.fftSize;
            this.analyser.smoothingTimeConstant = this.config.smoothingTimeConstant;
            
            // Create data array for frequency analysis
            this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
            
            // Initialize state
            this.currentLevel = 0;
            this.levelHistory = [];
            this.lastVolumeSpike = 0;
            this.isActive = true;
            
            // Resume audio context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(error => {
                    this.emitError('Failed to resume AudioContext', error);
                });
            }
            
            return true;
            
        } catch (error) {
            this.emitError('Failed to initialize AudioLevelProcessor', error);
            return false;
        }
    }

    /**
     * Clean up audio level processing resources
     */
    cleanup() {
        try {
            // Reset state
            this.isActive = false;
            this.currentLevel = 0;
            this.levelHistory = [];
            this.lastVolumeSpike = 0;
            this.lastLevelEmit = 0;
            
            // Clear references
            this.audioContext = null;
            this.analyser = null;
            this.dataArray = null;
            
            
        } catch (error) {
            this.emitError('Error during AudioLevelProcessor cleanup', error);
        }
    }

    /**
     * Update audio level from analyser (called each frame)
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    updateAudioLevel(deltaTime = 16) {
        if (!this.isActive || !this.analyser || !this.dataArray) {
            return;
        }
        
        try {
            // Get frequency data from analyser
            this.analyser.getByteFrequencyData(this.dataArray);
            
            // Calculate RMS (Root Mean Square) for accurate level detection
            const rms = this.calculateRMS();
            
            // Update current level with normalization and amplification
            this.currentLevel = Math.min(1, rms * 2); // Amplify for better sensitivity
            
            // Update audio level history for spike detection
            this.updateLevelHistory();
            
            // Check for volume spikes and trigger events
            this.detectVolumeSpikes();
            
            // Emit throttled level update events
            this.emitLevelUpdate();
            
        } catch (error) {
            this.emitError('Error updating audio level', error);
            this.currentLevel = 0;
        }
    }

    /**
     * Calculate RMS (Root Mean Square) from frequency data
     * @returns {number} RMS value normalized to 0-1 range
     */
    calculateRMS() {
        if (!this.dataArray || this.dataArray.length === 0) {
            return 0;
        }
        
        let sumSquares = 0;
        
        // Calculate sum of squares for all frequency bins
        for (let i = 0; i < this.dataArray.length; i++) {
            const normalized = this.dataArray[i] / 255; // Normalize to 0-1
            sumSquares += normalized * normalized;
        }
        
        // Return RMS value
        return Math.sqrt(sumSquares / this.dataArray.length);
    }

    /**
     * Update audio level history for spike detection analysis
     */
    updateLevelHistory() {
        // Add current level to history
        this.levelHistory.push(this.currentLevel);
        
        // Maintain history size limit
        if (this.levelHistory.length > this.config.historySize) {
            this.levelHistory.shift();
        }
    }

    /**
     * Detect volume spikes and emit events for gesture triggering
     */
    detectVolumeSpikes() {
        // Need sufficient history for spike detection
        if (this.levelHistory.length < 5) {
            return;
        }
        
        const currentTime = performance.now();
        
        // Prevent too frequent spike detection
        if (currentTime - this.lastVolumeSpike < this.config.spikeMinInterval) {
            return;
        }
        
        // Calculate average of previous levels (excluding current)
        const previousLevels = this.levelHistory.slice(0, -1);
        const averagePrevious = previousLevels.reduce((sum, level) => sum + level, 0) / previousLevels.length;
        
        // Check for volume spike conditions
        const isSpike = this.currentLevel >= averagePrevious * this.config.spikeThreshold &&
                       averagePrevious >= this.config.minimumSpikeLevel &&
                       this.currentLevel >= this.config.minimumSpikeLevel * 2;
        
        if (isSpike) {
            this.lastVolumeSpike = currentTime;
            
            // Emit volume spike event with detailed information
            this.emitVolumeSpike({
                level: this.currentLevel,
                previousAverage: averagePrevious,
                spikeRatio: this.currentLevel / averagePrevious,
                timestamp: currentTime,
                threshold: this.config.spikeThreshold,
                minimumLevel: this.config.minimumSpikeLevel
            });
            
        }
    }

    /**
     * Clear audio level history
     */
    clearHistory() {
        this.levelHistory = [];
    }

    /**
     * Get current audio level
     * @returns {number} Current audio level (0-1)
     */
    getCurrentLevel() {
        return this.currentLevel;
    }

    /**
     * Get audio level history
     * @returns {Array<number>} Array of recent audio levels
     */
    getLevelHistory() {
        return [...this.levelHistory]; // Return copy to prevent external modification
    }

    /**
     * Get analyser node for external audio source connection
     * @returns {AnalyserNode|null} Web Audio analyser node
     */
    getAnalyser() {
        return this.analyser;
    }

    /**
     * Get current frequency data as array
     * @returns {Uint8Array|null} Frequency data array
     */
    getFrequencyData() {
        if (!this.dataArray) {
            return null;
        }
        
        // Return copy of current frequency data
        return new Uint8Array(this.dataArray);
    }

    /**
     * Check if audio level processing is active
     * @returns {boolean} Active status
     */
    isProcessingActive() {
        return this.isActive;
    }

    /**
     * Set callback for audio level updates
     * @param {Function} callback - Callback function receiving level data
     */
    onLevelUpdate(callback) {
        if (typeof callback === 'function') {
            this.callbacks.levelUpdate = callback;
        } else {
            throw new Error('Level update callback must be a function');
        }
    }

    /**
     * Set callback for volume spike events
     * @param {Function} callback - Callback function receiving spike data
     */
    onVolumeSpike(callback) {
        if (typeof callback === 'function') {
            this.callbacks.volumeSpike = callback;
        } else {
            throw new Error('Volume spike callback must be a function');
        }
    }

    /**
     * Set callback for error events
     * @param {Function} callback - Callback function receiving error data
     */
    onError(callback) {
        if (typeof callback === 'function') {
            this.callbacks.error = callback;
        } else {
            throw new Error('Error callback must be a function');
        }
    }

    /**
     * Remove all event callbacks
     */
    removeAllCallbacks() {
        this.callbacks = {
            levelUpdate: null,
            volumeSpike: null,
            error: null
        };
    }

    /**
     * Update configuration settings
     * @param {Object} newConfig - New configuration options
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        
        // Update analyser settings if active
        if (this.analyser) {
            if (newConfig.fftSize) {
                this.analyser.fftSize = this.config.fftSize;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
            }
            
            if (newConfig.smoothingTimeConstant !== undefined) {
                this.analyser.smoothingTimeConstant = this.config.smoothingTimeConstant;
            }
        }
        
    }

    /**
     * Get current configuration
     * @returns {Object} Current configuration object
     */
    getConfig() {
        return { ...this.config }; // Return copy to prevent external modification
    }

    /**
     * Get processing statistics
     * @returns {Object} Statistics object
     */
    getStats() {
        return {
            isActive: this.isActive,
            currentLevel: this.currentLevel,
            historySize: this.levelHistory.length,
            maxHistorySize: this.config.historySize,
            lastSpikeTime: this.lastVolumeSpike,
            timeSinceLastSpike: this.lastVolumeSpike > 0 ? performance.now() - this.lastVolumeSpike : 0,
            averageLevel: this.levelHistory.length > 0 ? 
                this.levelHistory.reduce((sum, level) => sum + level, 0) / this.levelHistory.length : 0
        };
    }

    /**
     * Emit throttled audio level update event
     */
    emitLevelUpdate() {
        const currentTime = performance.now();
        
        // Throttle level update events
        if (currentTime - this.lastLevelEmit < this.config.levelUpdateThrottle) {
            return;
        }
        
        this.lastLevelEmit = currentTime;
        
        if (this.callbacks.levelUpdate) {
            try {
                this.callbacks.levelUpdate({
                    level: this.currentLevel,
                    rawData: this.getFrequencyData(),
                    timestamp: currentTime,
                    history: this.getLevelHistory()
                });
            } catch (error) {
            }
        }
    }

    /**
     * Emit volume spike event
     * @param {Object} spikeData - Spike detection data
     */
    emitVolumeSpike(spikeData) {
        if (this.callbacks.volumeSpike) {
            try {
                this.callbacks.volumeSpike(spikeData);
            } catch (error) {
            }
        }
    }

    /**
     * Emit error event
     * @param {string} message - Error message
     * @param {Error} error - Original error object
     */
    emitError(message, error) {
        
        if (this.callbacks.error) {
            try {
                this.callbacks.error({
                    message,
                    error,
                    timestamp: performance.now()
                });
            } catch (callbackError) {
            }
        }
    }

    /**
     * Check if Web Audio API is supported
     * @returns {boolean} Support status
     */
    static isSupported() {
        return !!(window.AudioContext || window.webkitAudioContext);
    }
}

/**
 * Event Manager
 * Centralized event listener management to prevent memory leaks
 *
 * @module core/EventManager
 * @version 1.0.0
 */

/**
 * Manages all event listeners to ensure proper cleanup
 */
class EventManager {
    constructor() {
        // Track all registered listeners
        this.listeners = new Map();

        // Track listener groups for batch operations
        this.groups = new Map();

        // Auto-cleanup on page unload
        // Removed unload handler - not needed and causes violations

        // Stats
        this.stats = {
            registered: 0,
            removed: 0,
            active: 0
        };
    }

    /**
     * Register an event listener
     * @param {EventTarget} target - Event target (element, window, document, etc.)
     * @param {string} eventType - Event type (click, resize, etc.)
     * @param {Function} handler - Event handler function
     * @param {Object} options - addEventListener options
     * @param {string} group - Optional group name for batch operations
     * @returns {string} Listener ID for later removal
     */
    addEventListener(target, eventType, handler, options = {}, group = 'default') {
        // Generate unique ID
        const id = this.generateId();

        // Create listener info
        const listenerInfo = {
            id,
            target,
            eventType,
            handler,
            options,
            group,
            active: true
        };

        // Store listener
        this.listeners.set(id, listenerInfo);

        // Add to group
        if (!this.groups.has(group)) {
            this.groups.set(group, new Set());
        }
        this.groups.get(group).add(id);

        // Actually add the listener
        target.addEventListener(eventType, handler, options);

        // Update stats
        this.stats.registered++;
        this.stats.active++;

        return id;
    }

    /**
     * Remove an event listener by ID
     * @param {string} id - Listener ID
     * @returns {boolean} Success status
     */
    removeEventListener(id) {
        const listenerInfo = this.listeners.get(id);

        if (!listenerInfo || !listenerInfo.active) {
            return false;
        }

        // Remove the actual listener
        listenerInfo.target.removeEventListener(
            listenerInfo.eventType,
            listenerInfo.handler,
            listenerInfo.options
        );

        // Mark as inactive
        listenerInfo.active = false;

        // Remove from group
        const group = this.groups.get(listenerInfo.group);
        if (group) {
            group.delete(id);
            if (group.size === 0) {
                this.groups.delete(listenerInfo.group);
            }
        }

        // Remove from listeners map
        this.listeners.delete(id);

        // Update stats
        this.stats.removed++;
        this.stats.active--;

        return true;
    }

    /**
     * Remove all listeners in a group
     * @param {string} group - Group name
     * @returns {number} Number of listeners removed
     */
    removeGroup(group) {
        const groupSet = this.groups.get(group);

        if (!groupSet) {
            return 0;
        }

        let removed = 0;

        for (const id of groupSet) {
            if (this.removeEventListener(id)) {
                removed++;
            }
        }

        return removed;
    }

    /**
     * Remove all listeners for a specific target
     * @param {EventTarget} target - Event target
     * @returns {number} Number of listeners removed
     */
    removeAllForTarget(target) {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.target === target && info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Remove all listeners of a specific type
     * @param {string} eventType - Event type
     * @returns {number} Number of listeners removed
     */
    removeAllOfType(eventType) {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.eventType === eventType && info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Remove all listeners
     * @returns {number} Number of listeners removed
     */
    removeAll() {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Create a bound listener that auto-removes
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {Object} options - Options
     * @returns {Object} Controller with remove method
     */
    createAutoRemove(target, eventType, handler, options = {}) {
        const id = this.addEventListener(target, eventType, handler, options);

        return {
            id,
            remove: () => this.removeEventListener(id)
        };
    }

    /**
     * Add listener that fires only once
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    once(target, eventType, handler, options = {}) {
        const wrappedHandler = (event) => {
            handler(event);
            this.removeEventListener(id);
        };

        const id = this.addEventListener(target, eventType, wrappedHandler, options);

        return id;
    }

    /**
     * Debounced event listener
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {number} delay - Debounce delay in ms
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    debounced(target, eventType, handler, delay = 250, options = {}) {
        let timeoutId;

        const debouncedHandler = (event) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => handler(event), delay);
        };

        return this.addEventListener(target, eventType, debouncedHandler, options);
    }

    /**
     * Throttled event listener
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {number} limit - Throttle limit in ms
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    throttled(target, eventType, handler, limit = 100, options = {}) {
        let inThrottle = false;

        const throttledHandler = (event) => {
            if (!inThrottle) {
                handler(event);
                inThrottle = true;
                setTimeout(() => {
                    inThrottle = false;
                }, limit);
            }
        };

        return this.addEventListener(target, eventType, throttledHandler, options);
    }

    // Removed setupUnloadHandler - causes permission violations
    // Browser automatically cleans up event listeners on unload

    /**
     * Generate unique ID
     * @private
     * @returns {string} Unique ID
     */
    generateId() {
        return `listener_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Get statistics
     * @returns {Object} Statistics
     */
    getStats() {
        return {
            ...this.stats,
            groups: this.groups.size,
            listeners: this.listeners.size
        };
    }

    /**
     * Get active listeners for debugging
     * @returns {Array} Active listener info
     */
    getActiveListeners() {
        const active = [];

        for (const [id, info] of this.listeners.entries()) {
            if (info.active) {
                active.push({
                    id,
                    eventType: info.eventType,
                    group: info.group,
                    target: info.target.constructor.name
                });
            }
        }

        return active;
    }

    /**
     * Check for potential memory leaks
     * @returns {Object} Leak analysis
     */
    analyzeLeaks() {
        const analysis = {
            totalListeners: this.listeners.size,
            activeListeners: this.stats.active,
            inactiveButNotRemoved: 0,
            byTarget: new Map(),
            byType: new Map(),
            potentialLeaks: []
        };

        for (const [id, info] of this.listeners.entries()) {
            // Count by target
            const targetName = info.target.constructor.name;
            analysis.byTarget.set(
                targetName,
                (analysis.byTarget.get(targetName) || 0) + 1
            );

            // Count by type
            analysis.byType.set(
                info.eventType,
                (analysis.byType.get(info.eventType) || 0) + 1
            );

            // Check for inactive but not removed
            if (!info.active) {
                analysis.inactiveButNotRemoved++;
                analysis.potentialLeaks.push({
                    id,
                    eventType: info.eventType,
                    target: targetName
                });
            }
        }

        // Convert maps to objects for easier reading
        analysis.byTarget = Object.fromEntries(analysis.byTarget);
        analysis.byType = Object.fromEntries(analysis.byType);

        return analysis;
    }

    /**
     * Clean up inactive listeners
     * @returns {number} Number cleaned
     */
    cleanup() {
        let cleaned = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (!info.active) {
                this.listeners.delete(id);
                cleaned++;
            }
        }

        return cleaned;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                   ◐ ◑ ◒ ◓  ACCESSIBILITY MANAGER  ◓ ◒ ◑ ◐                   
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Accessibility Manager - Inclusive Design & A11y Support
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module AccessibilityManager
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Makes the Emotive Engine accessible to EVERYONE. Handles reduced motion,          
 * ║ screen readers, keyboard navigation, color blindness, and more.                   
 * ║ Because emotional expression should be universal.                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ♿ ACCESSIBILITY FEATURES                                                         
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Reduced Motion     : Respects prefers-reduced-motion                            
 * │ • High Contrast      : Enhanced visibility mode                                   
 * │ • Screen Readers     : ARIA labels and live announcements                         
 * │ • Keyboard Nav       : Full keyboard control support                              
 * │ • Focus Indicators   : Clear visual focus states                                  
 * │ • Color Blind Modes  : Protanopia, Deuteranopia, Tritanopia                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 COLOR BLIND MODES                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • none         : Standard colors                                                  
 * │ • protanopia   : Red-blind friendly palette                                       
 * │ • deuteranopia : Green-blind friendly palette                                     
 * │ • tritanopia   : Blue-blind friendly palette                                      
 * │ • highContrast : Maximum contrast (black/white/yellow)                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⌨️ KEYBOARD CONTROLS                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Tab/Shift+Tab : Navigate between elements                                      
 * │ • Enter/Space   : Activate focused element                                        
 * │ • Arrow Keys    : Directional navigation                                          
 * │ • Escape        : Cancel/close operations                                         
 * │ • Numbers 1-9   : Quick emotion selection                                         
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📢 SCREEN READER SUPPORT                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • ARIA Labels      : Descriptive labels for all elements                          
 * │ • Live Regions     : Real-time state announcements                                
 * │ • Role Attributes  : Semantic HTML roles                                          
 * │ • State Changes    : Announced through live region                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔧 CONFIGURATION OPTIONS                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • enableReducedMotion      : Honor system preference (default: true)              
 * │ • enableHighContrast       : Allow high contrast mode (default: true)             
 * │ • enableScreenReaderSupport: ARIA and announcements (default: true)               
 * │ • enableKeyboardNavigation : Keyboard controls (default: true)                    
 * │ • announceStateChanges     : Announce emotion changes (default: true)             
 * │ • colorBlindMode          : Color adjustment mode (default: 'none')              
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚠️  IMPORTANT CONSIDERATIONS                                                      
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Always test with screen readers (NVDA, JAWS, VoiceOver)                         
 * │ • Validate color contrasts meet WCAG 2.1 AA standards                             
 * │ • Ensure all interactive elements are keyboard accessible                         
 * │ • Provide alternative text for visual-only information                            
 * │ • Test with browser zoom at 200% and 400%                                        
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                         IMPLEMENTING ACCESSIBILITY                                
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ const a11y = new AccessibilityManager({                                           
 * ║     colorBlindMode: 'protanopia',                                                 
 * ║     announceStateChanges: true                                                    
 * ║ });                                                                                
 * ║                                                                                    
 * ║ // Announce emotion change                                                        
 * ║ a11y.announceStateChange('Emotion changed to joy');                               
 * ║                                                                                    
 * ║ // Apply reduced motion                                                           
 * ║ if (a11y.shouldReduceMotion()) {                                                  
 * ║     // Use simpler animations                                                     
 * ║ }                                                                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class AccessibilityManager {
    constructor(config = {}) {
        this.config = {
            enableReducedMotion: config.enableReducedMotion !== false,
            enableHighContrast: config.enableHighContrast !== false,
            enableScreenReaderSupport: config.enableScreenReaderSupport !== false,
            enableKeyboardNavigation: config.enableKeyboardNavigation !== false,
            enableFocusIndicators: config.enableFocusIndicators !== false,
            announceStateChanges: config.announceStateChanges !== false,
            colorBlindMode: config.colorBlindMode || 'none', // none, protanopia, deuteranopia, tritanopia
            ...config
        };
        
        // Accessibility state
        this.reducedMotionPreferred = false;
        this.highContrastEnabled = false;
        this.screenReaderActive = false;
        this.keyboardNavigationActive = false;
        this.currentColorBlindMode = this.config.colorBlindMode;
        
        // Focus management
        this.focusableElements = new Map();
        this.currentFocusIndex = -1;
        this.focusHistory = [];
        
        // ARIA live region for announcements
        this.liveRegion = null;
        this.announcementQueue = [];
        
        // Color schemes for different accessibility needs
        this.colorSchemes = {
            normal: null, // Will be set from current colors
            highContrast: {
                primary: '#FFFFFF',
                secondary: '#000000',
                accent: '#FFFF00',
                background: '#000000',
                particles: '#FFFFFF'
            },
            protanopia: { // Red-blind
                primary: '#0066CC',
                secondary: '#FFCC00',
                accent: '#00CCFF',
                background: '#1A1A1A',
                particles: '#66CCFF'
            },
            deuteranopia: { // Green-blind
                primary: '#0099FF',
                secondary: '#FF9900',
                accent: '#FF00FF',
                background: '#1A1A1A',
                particles: '#9966FF'
            },
            tritanopia: { // Blue-blind
                primary: '#FF0066',
                secondary: '#00FF66',
                accent: '#FF6600',
                background: '#1A1A1A',
                particles: '#FFCC00'
            }
        };
        
        // Pattern overlays for color-blind modes
        this.patterns = {
            dots: 'dots',
            stripes: 'stripes',
            crosshatch: 'crosshatch',
            solid: 'solid'
        };
        
        // Emotional state patterns for color-blind users
        this.statePatterns = {
            idle: this.patterns.solid,
            happy: this.patterns.dots,
            excited: this.patterns.stripes,
            calm: this.patterns.solid,
            curious: this.patterns.crosshatch,
            frustrated: this.patterns.stripes,
            sad: this.patterns.dots,
            neutral: this.patterns.solid
        };
        
        // Initialize accessibility features
        this.initialize();
    }
    
    /**
     * Initialize accessibility features
     */
    initialize() {
        // Detect user preferences
        this.detectUserPreferences();
        
        // Set up ARIA live region
        this.setupLiveRegion();
        
        // Set up keyboard navigation if enabled
        if (this.config.enableKeyboardNavigation) {
            this.setupKeyboardNavigation();
        }
        
        // Listen for preference changes
        this.setupPreferenceListeners();
        
    }
    
    /**
     * Detect user accessibility preferences
     */
    detectUserPreferences() {
        // Detect reduced motion preference
        if (this.config.enableReducedMotion && window.matchMedia) {
            const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
            this.reducedMotionPreferred = motionQuery.matches;
        }
        
        // Detect high contrast preference
        if (this.config.enableHighContrast && window.matchMedia) {
            const contrastQuery = window.matchMedia('(prefers-contrast: high)');
            this.highContrastEnabled = contrastQuery.matches;
            
            // Also check for Windows high contrast mode
            if (!this.highContrastEnabled) {
                const windowsHCQuery = window.matchMedia('(-ms-high-contrast: active)');
                this.highContrastEnabled = windowsHCQuery.matches;
            }
        }
        
        // Detect screen reader (heuristic approach)
        this.detectScreenReader();
    }
    
    /**
     * Detect if a screen reader is likely active
     */
    detectScreenReader() {
        // Check for ARIA attributes being actively used
        const hasAriaLive = document.querySelector('[aria-live]');
        const hasAriaAtomic = document.querySelector('[aria-atomic]');
        
        // Check for screen reader specific attributes
        const hasRole = document.querySelector('[role="application"]');
        
        // Check user agent for assistive technology hints
        const userAgent = navigator.userAgent.toLowerCase();
        const hasATHints = userAgent.includes('nvda') || 
                          userAgent.includes('jaws') || 
                          userAgent.includes('voiceover');
        
        this.screenReaderActive = !!(hasAriaLive || hasAriaAtomic || hasRole || hasATHints);
    }
    
    /**
     * Set up ARIA live region for announcements
     */
    setupLiveRegion() {
        if (!this.config.enableScreenReaderSupport) return;
        
        // Create live region if it doesn't exist
        this.liveRegion = document.getElementById('mascot-announcements');
        if (!this.liveRegion) {
            this.liveRegion = document.createElement('div');
            this.liveRegion.id = 'mascot-announcements';
            this.liveRegion.setAttribute('aria-live', 'polite');
            this.liveRegion.setAttribute('aria-atomic', 'true');
            this.liveRegion.style.position = 'absolute';
            this.liveRegion.style.left = '-10000px';
            this.liveRegion.style.width = '1px';
            this.liveRegion.style.height = '1px';
            this.liveRegion.style.overflow = 'hidden';
            document.body.appendChild(this.liveRegion);
        }
    }
    
    /**
     * Set up keyboard navigation
     */
    setupKeyboardNavigation() {
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
    }
    
    /**
     * Set up listeners for preference changes
     */
    setupPreferenceListeners() {
        if (window.matchMedia) {
            // Listen for reduced motion changes
            const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
            motionQuery.addListener((e) => {
                this.reducedMotionPreferred = e.matches;
                this.onPreferenceChange('reducedMotion', e.matches);
            });
            
            // Listen for high contrast changes
            const contrastQuery = window.matchMedia('(prefers-contrast: high)');
            contrastQuery.addListener((e) => {
                this.highContrastEnabled = e.matches;
                this.onPreferenceChange('highContrast', e.matches);
            });
        }
    }
    
    /**
     * Handle keyboard navigation
     * @param {KeyboardEvent} event - Keyboard event
     */
    handleKeyDown(event) {
        if (!this.config.enableKeyboardNavigation) return;
        
        switch (event.key) {
            case 'Tab':
                event.preventDefault();
                this.navigateFocus(event.shiftKey ? -1 : 1);
                break;
            case 'Enter':
            case ' ':
                this.activateCurrentFocus();
                break;
            case 'Escape':
                this.clearFocus();
                break;
            case 'ArrowLeft':
            case 'ArrowRight':
            case 'ArrowUp':
            case 'ArrowDown':
                this.handleArrowNavigation(event.key);
                break;
        }
        
        this.keyboardNavigationActive = true;
    }
    
    /**
     * Handle key up events
     * @param {KeyboardEvent} event - Keyboard event
     */
    handleKeyUp(event) {
        // Could be used for specific key release actions
    }
    
    /**
     * Navigate focus between elements
     * @param {number} direction - Direction to navigate (1 or -1)
     */
    navigateFocus(direction) {
        const focusableArray = Array.from(this.focusableElements.values());
        if (focusableArray.length === 0) return;
        
        this.currentFocusIndex += direction;
        
        // Wrap around
        if (this.currentFocusIndex < 0) {
            this.currentFocusIndex = focusableArray.length - 1;
        } else if (this.currentFocusIndex >= focusableArray.length) {
            this.currentFocusIndex = 0;
        }
        
        const element = focusableArray[this.currentFocusIndex];
        this.setFocus(element);
        
        // Announce focus change
        if (element.label) {
            this.announce(`Focused on ${element.label}`);
        }
    }
    
    /**
     * Handle arrow key navigation
     * @param {string} key - Arrow key pressed
     */
    handleArrowNavigation(key) {
        // This would be implemented based on spatial navigation needs
        const directions = {
            'ArrowLeft': { x: -1, y: 0 },
            'ArrowRight': { x: 1, y: 0 },
            'ArrowUp': { x: 0, y: -1 },
            'ArrowDown': { x: 0, y: 1 }
        };
        
        const direction = directions[key];
        if (direction && this.onArrowNavigation) {
            this.onArrowNavigation(direction);
        }
    }
    
    /**
     * Register a focusable element
     * @param {string} id - Element identifier
     * @param {Object} element - Element properties
     */
    registerFocusableElement(id, element) {
        this.focusableElements.set(id, {
            id,
            label: element.label || id,
            bounds: element.bounds || null,
            action: element.action || null,
            type: element.type || 'button'
        });
    }
    
    /**
     * Unregister a focusable element
     * @param {string} id - Element identifier
     */
    unregisterFocusableElement(id) {
        this.focusableElements.delete(id);
    }
    
    /**
     * Set focus on an element
     * @param {Object} element - Element to focus
     */
    setFocus(element) {
        if (this.onFocusChange) {
            this.onFocusChange(element);
        }
        
        this.focusHistory.push(element.id);
        if (this.focusHistory.length > 10) {
            this.focusHistory.shift();
        }
    }
    
    /**
     * Clear current focus
     */
    clearFocus() {
        this.currentFocusIndex = -1;
        if (this.onFocusChange) {
            this.onFocusChange(null);
        }
        
        this.announce('Focus cleared');
    }
    
    /**
     * Activate the currently focused element
     */
    activateCurrentFocus() {
        const focusableArray = Array.from(this.focusableElements.values());
        if (this.currentFocusIndex >= 0 && this.currentFocusIndex < focusableArray.length) {
            const element = focusableArray[this.currentFocusIndex];
            if (element.action) {
                element.action();
                this.announce(`Activated ${element.label}`);
            }
        }
    }
    
    /**
     * Announce a message to screen readers
     * @param {string} message - Message to announce
     * @param {string} priority - Priority level (polite, assertive)
     */
    announce(message, priority = 'polite') {
        if (!this.config.enableScreenReaderSupport || !this.liveRegion) return;
        
        // Queue the announcement
        this.announcementQueue.push({ message, priority });
        
        // Process queue
        this.processAnnouncementQueue();
    }
    
    /**
     * Process announcement queue
     */
    processAnnouncementQueue() {
        if (this.announcementQueue.length === 0) return;
        
        const { message, priority } = this.announcementQueue.shift();
        
        // Update live region
        this.liveRegion.setAttribute('aria-live', priority);
        this.liveRegion.textContent = message;
        
        // Clear after a delay to allow screen reader to announce
        setTimeout(() => {
            if (this.liveRegion) {
                this.liveRegion.textContent = '';
            }
            
            // Process next announcement if any
            if (this.announcementQueue.length > 0) {
                this.processAnnouncementQueue();
            }
        }, 100);
    }
    
    /**
     * Get adjusted animation settings based on accessibility preferences
     * @param {Object} originalSettings - Original animation settings
     * @returns {Object} Adjusted settings
     */
    getAnimationSettings(originalSettings = {}) {
        if (!this.reducedMotionPreferred) {
            return originalSettings;
        }
        
        // Reduce or disable animations for users who prefer reduced motion
        return {
            ...originalSettings,
            duration: originalSettings.duration ? originalSettings.duration * 0.5 : 0,
            iterations: 1,
            easing: 'linear',
            particlesEnabled: false,
            complexAnimations: false,
            autoPlay: false
        };
    }
    
    /**
     * Get adjusted color scheme based on accessibility preferences
     * @param {Object} originalColors - Original color scheme
     * @returns {Object} Adjusted colors
     */
    getColorScheme(originalColors = {}) {
        // Store original colors if not set
        if (!this.colorSchemes.normal) {
            this.colorSchemes.normal = { ...originalColors };
        }
        
        // Apply high contrast if needed
        if (this.highContrastEnabled) {
            return this.colorSchemes.highContrast;
        }
        
        // Apply color blind mode if set
        if (this.currentColorBlindMode !== 'none' && this.colorSchemes[this.currentColorBlindMode]) {
            return this.colorSchemes[this.currentColorBlindMode];
        }
        
        return originalColors;
    }
    
    /**
     * Get pattern for current state (for color blind users)
     * @param {string} state - Current emotional state
     * @returns {string} Pattern identifier
     */
    getStatePattern(state) {
        if (this.currentColorBlindMode === 'none') {
            return this.patterns.solid;
        }
        
        return this.statePatterns[state] || this.patterns.solid;
    }
    
    /**
     * Apply pattern overlay to canvas
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {string} pattern - Pattern type
     * @param {Object} bounds - Area to apply pattern
     */
    applyPatternOverlay(ctx, pattern, bounds) {
        if (pattern === this.patterns.solid) return;
        
        ctx.save();
        
        const patternCanvas = document.createElement('canvas');
        const patternCtx = patternCanvas.getContext('2d');
        
        switch (pattern) {
            case this.patterns.dots:
                this.createDotPattern(patternCtx, patternCanvas);
                break;
            case this.patterns.stripes:
                this.createStripePattern(patternCtx, patternCanvas);
                break;
            case this.patterns.crosshatch:
                this.createCrosshatchPattern(patternCtx, patternCanvas);
                break;
        }
        
        const canvasPattern = ctx.createPattern(patternCanvas, 'repeat');
        ctx.fillStyle = canvasPattern;
        ctx.globalAlpha = 0.3; // Semi-transparent overlay
        ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
        
        ctx.restore();
    }
    
    /**
     * Create dot pattern
     * @param {CanvasRenderingContext2D} ctx - Pattern canvas context
     * @param {HTMLCanvasElement} canvas - Pattern canvas
     */
    createDotPattern(ctx, canvas) {
        canvas.width = 10;
        canvas.height = 10;
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(5, 5, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    /**
     * Create stripe pattern
     * @param {CanvasRenderingContext2D} ctx - Pattern canvas context
     * @param {HTMLCanvasElement} canvas - Pattern canvas
     */
    createStripePattern(ctx, canvas) {
        canvas.width = 10;
        canvas.height = 10;
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 10);
        ctx.lineTo(10, 0);
        ctx.stroke();
    }
    
    /**
     * Create crosshatch pattern
     * @param {CanvasRenderingContext2D} ctx - Pattern canvas context
     * @param {HTMLCanvasElement} canvas - Pattern canvas
     */
    createCrosshatchPattern(ctx, canvas) {
        canvas.width = 10;
        canvas.height = 10;
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        
        // Diagonal lines
        ctx.beginPath();
        ctx.moveTo(0, 10);
        ctx.lineTo(10, 0);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(10, 10);
        ctx.stroke();
    }
    
    /**
     * Set color blind mode
     * @param {string} mode - Color blind mode
     */
    setColorBlindMode(mode) {
        const validModes = ['none', 'protanopia', 'deuteranopia', 'tritanopia'];
        if (!validModes.includes(mode)) {
            return;
        }
        
        this.currentColorBlindMode = mode;
        this.announce(`Color blind mode set to ${mode}`);
        
        if (this.onColorSchemeChange) {
            this.onColorSchemeChange(this.getColorScheme());
        }
    }
    
    /**
     * Get accessibility status report
     * @returns {Object} Accessibility status
     */
    getStatus() {
        return {
            reducedMotion: this.reducedMotionPreferred,
            highContrast: this.highContrastEnabled,
            screenReader: this.screenReaderActive,
            keyboardNavigation: this.keyboardNavigationActive,
            colorBlindMode: this.currentColorBlindMode,
            focusedElement: this.currentFocusIndex >= 0 ? 
                Array.from(this.focusableElements.values())[this.currentFocusIndex] : null,
            registeredElements: this.focusableElements.size
        };
    }
    
    /**
     * Handle preference change
     * @param {string} preference - Preference that changed
     * @param {*} value - New value
     */
    onPreferenceChange(preference, value) {
        
        // Notify about the change
        this.announce(`${preference} is now ${value ? 'enabled' : 'disabled'}`);
        
        // Trigger callbacks if set
        if (preference === 'reducedMotion' && this.onReducedMotionChange) {
            this.onReducedMotionChange(value);
        }
        
        if (preference === 'highContrast' && this.onHighContrastChange) {
            this.onHighContrastChange(value);
        }
    }
    
    /**
     * Create ARIA description for mascot state
     * @param {Object} state - Current mascot state
     * @returns {string} ARIA description
     */
    createStateDescription(state) {
        const descriptions = {
            idle: 'Mascot is idle and gently breathing',
            happy: 'Mascot is happy and bouncing',
            excited: 'Mascot is excited with particles flying',
            calm: 'Mascot is calm and peaceful',
            curious: 'Mascot is curious and looking around',
            frustrated: 'Mascot is frustrated and shaking',
            sad: 'Mascot is sad and drooping',
            neutral: 'Mascot is in a neutral state'
        };
        
        return descriptions[state.emotional] || 'Mascot is active';
    }
    
    /**
     * Destroy accessibility manager
     */
    destroy() {
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyDown);
        document.removeEventListener('keyup', this.handleKeyUp);
        
        // Remove live region
        if (this.liveRegion && this.liveRegion.parentNode) {
            this.liveRegion.parentNode.removeChild(this.liveRegion);
        }
        
        // Clear data
        this.focusableElements.clear();
        this.announcementQueue = [];
        this.focusHistory = [];
        
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                  ◐ ◑ ◒ ◓  MOBILE OPTIMIZATION  ◓ ◒ ◑ ◐                  
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Mobile Optimization - Touch & Mobile Device Support
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module MobileOptimization
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Makes the orb TOUCHABLE and mobile-friendly. Handles all the quirks of           
 * ║ mobile browsers, touch events, viewport changes, and battery optimization.        
 * ║ Ensures smooth performance even on low-end phones.                               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📱 MOBILE FEATURES                                                                 
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Touch event handling (tap, swipe, pinch)                                        
 * │ • Viewport resize handling                                                        
 * │ • Orientation change detection                                                    
 * │ • Battery-aware performance                                                       
 * │ • Reduced particle count on mobile                                                
 * │ • Touch-friendly interaction zones                                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class MobileOptimization {
    constructor(config = {}) {
        this.config = {
            enableTouchOptimization: config.enableTouchOptimization !== false,
            enableViewportHandling: config.enableViewportHandling !== false,
            enableBatteryOptimization: config.enableBatteryOptimization !== false,
            enableOrientationSupport: config.enableOrientationSupport !== false,
            enableResponsiveScaling: config.enableResponsiveScaling !== false,
            touchSensitivity: config.touchSensitivity || 1.0,
            doubleTapDelay: config.doubleTapDelay || 300,
            swipeThreshold: config.swipeThreshold || 50,
            pinchThreshold: config.pinchThreshold || 0.1,
            ...config
        };
        
        // Device detection
        this.isMobile = this.detectMobile();
        this.isTablet = this.detectTablet();
        this.isTouchDevice = this.detectTouch();
        this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        this.isAndroid = /Android/.test(navigator.userAgent);
        
        // Touch state
        this.touches = new Map();
        this.lastTouchTime = 0;
        this.lastTapTime = 0;
        this.tapCount = 0;
        this.touchStartPosition = null;
        this.isPinching = false;
        this.isRotating = false;
        this.lastPinchDistance = 0;
        this.lastRotation = 0;
        
        // Gesture recognition
        this.currentGesture = null;
        this.gestureStartTime = 0;
        this.gestureHistory = [];
        
        // Viewport state
        this.viewportSize = { width: window.innerWidth, height: window.innerHeight };
        this.orientation = this.getOrientation();
        this.pixelRatio = window.devicePixelRatio || 1;
        this.lastViewportChange = 0;
        
        // Battery state
        this.batteryLevel = 1.0;
        this.isCharging = true;
        this.lowPowerMode = false;
        
        // Performance adjustments for mobile
        this.mobilePerformanceSettings = {
            reducedParticles: this.isMobile,
            simplifiedAnimations: this.isMobile,
            lowerFrameRate: this.isMobile,
            reducedEffects: this.isMobile || this.isTablet,
            targetFPS: this.isMobile ? 30 : 60,
            maxParticles: this.isMobile ? 20 : 50
        };
        
        // Canvas optimization
        this.canvasScale = 1.0;
        this.useOffscreenCanvas = this.supportsOffscreenCanvas();
        
        // Event handlers bound to this
        this.handleTouchStart = this.handleTouchStart.bind(this);
        this.handleTouchMove = this.handleTouchMove.bind(this);
        this.handleTouchEnd = this.handleTouchEnd.bind(this);
        this.handleTouchCancel = this.handleTouchCancel.bind(this);
        this.handleOrientationChange = this.handleOrientationChange.bind(this);
        this.handleViewportChange = this.handleViewportChange.bind(this);
        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
        
        // Initialize
        this.initialize();
    }
    
    /**
     * Initialize mobile optimization
     */
    initialize() {
        if (this.config.enableTouchOptimization && this.isTouchDevice) {
            this.setupTouchHandlers();
        }
        
        if (this.config.enableViewportHandling) {
            this.setupViewportHandlers();
        }
        
        if (this.config.enableBatteryOptimization) {
            this.setupBatteryMonitoring();
        }
        
        if (this.config.enableOrientationSupport) {
            this.setupOrientationHandlers();
        }
        
        // Apply initial optimizations
        this.applyMobileOptimizations();
    }
    
    /**
     * Detect if device is mobile
     * @returns {boolean} True if mobile device
     */
    detectMobile() {
        const userAgent = navigator.userAgent.toLowerCase();
        const mobileKeywords = ['android', 'iphone', 'ipod', 'windows phone', 'blackberry'];
        
        // Check user agent
        const isMobileUA = mobileKeywords.some(keyword => userAgent.includes(keyword));
        
        // Check screen size
        const isMobileSize = window.innerWidth <= 768;
        
        // Check for touch and small screen
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        return isMobileUA || (isMobileSize && hasTouch);
    }
    
    /**
     * Detect if device is tablet
     * @returns {boolean} True if tablet device
     */
    detectTablet() {
        const userAgent = navigator.userAgent.toLowerCase();
        const isIPad = /ipad/.test(userAgent);
        const isAndroidTablet = /android/.test(userAgent) && !/mobile/.test(userAgent);
        const isWindowsTablet = /windows/.test(userAgent) && /touch/.test(userAgent);
        
        // Check screen size for tablet range
        const isTabletSize = window.innerWidth > 768 && window.innerWidth <= 1024;
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        return isIPad || isAndroidTablet || isWindowsTablet || (isTabletSize && hasTouch);
    }
    
    /**
     * Detect touch support
     * @returns {boolean} True if touch is supported
     */
    detectTouch() {
        return 'ontouchstart' in window || 
               navigator.maxTouchPoints > 0 || 
               navigator.msMaxTouchPoints > 0;
    }
    
    /**
     * Check if offscreen canvas is supported
     * @returns {boolean} True if OffscreenCanvas is supported
     */
    supportsOffscreenCanvas() {
        return typeof OffscreenCanvas !== 'undefined';
    }
    
    /**
     * Set up touch event handlers
     */
    setupTouchHandlers() {
        const canvas = this.getCanvas();
        if (!canvas) return;
        
        // Prevent default touch behaviors
        canvas.style.touchAction = 'none';
        canvas.style.userSelect = 'none';
        canvas.style.webkitUserSelect = 'none';
        
        // Add touch event listeners
        canvas.addEventListener('touchstart', this.handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', this.handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', this.handleTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', this.handleTouchCancel, { passive: false });
        
        // Prevent context menu on long press
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    }
    
    /**
     * Set up viewport change handlers
     */
    setupViewportHandlers() {
        window.addEventListener('resize', this.handleViewportChange);
        window.addEventListener('orientationchange', this.handleOrientationChange);
        
        // Handle visibility changes for battery optimization
        document.addEventListener('visibilitychange', this.handleVisibilityChange);
        
        // Handle viewport meta changes
        this.setupViewportMeta();
    }
    
    /**
     * Set up viewport meta tag for mobile
     */
    setupViewportMeta() {
        let viewportMeta = document.querySelector('meta[name="viewport"]');
        
        if (!viewportMeta) {
            viewportMeta = document.createElement('meta');
            viewportMeta.name = 'viewport';
            document.head.appendChild(viewportMeta);
        }
        
        // Set optimal viewport for mobile
        viewportMeta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
    }
    
    /**
     * Set up battery monitoring
     */
    async setupBatteryMonitoring() {
        if (!navigator.getBattery) return;
        
        try {
            const battery = await navigator.getBattery();
            
            this.batteryLevel = battery.level;
            this.isCharging = battery.charging;
            
            // Listen for battery changes
            battery.addEventListener('levelchange', () => {
                this.batteryLevel = battery.level;
                this.onBatteryChange();
            });
            
            battery.addEventListener('chargingchange', () => {
                this.isCharging = battery.charging;
                this.onBatteryChange();
            });
            
            // Initial battery optimization
            this.onBatteryChange();
        } catch (error) {
        }
    }
    
    /**
     * Set up orientation change handlers
     */
    setupOrientationHandlers() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (event) => {
                this.handleDeviceOrientation(event);
            });
        }
    }
    
    /**
     * Handle touch start
     * @param {TouchEvent} event - Touch event
     */
    handleTouchStart(event) {
        event.preventDefault();
        
        const now = Date.now();
        this.gestureStartTime = now;
        
        // Store all touches
        for (const touch of event.touches) {
            this.touches.set(touch.identifier, {
                id: touch.identifier,
                startX: touch.clientX,
                startY: touch.clientY,
                currentX: touch.clientX,
                currentY: touch.clientY,
                startTime: now
            });
        }
        
        // Handle different touch counts
        if (event.touches.length === 1) {
            this.handleSingleTouchStart(event.touches[0]);
        } else if (event.touches.length === 2) {
            this.handleMultiTouchStart(event.touches);
        }
        
        // Emit touch event
        this.emitTouchEvent('touchStart', {
            touches: Array.from(this.touches.values()),
            timestamp: now
        });
    }
    
    /**
     * Handle single touch start
     * @param {Touch} touch - Touch object
     */
    handleSingleTouchStart(touch) {
        const now = Date.now();
        
        // Check for double tap
        if (now - this.lastTapTime < this.config.doubleTapDelay) {
            this.tapCount++;
        } else {
            this.tapCount = 1;
        }
        
        this.lastTapTime = now;
        this.touchStartPosition = { x: touch.clientX, y: touch.clientY };
    }
    
    /**
     * Handle multi-touch start
     * @param {TouchList} touches - Touch list
     */
    handleMultiTouchStart(touches) {
        if (touches.length === 2) {
            // Initialize pinch/rotate
            const touch1 = touches[0];
            const touch2 = touches[1];
            
            this.lastPinchDistance = this.getDistance(
                touch1.clientX, touch1.clientY,
                touch2.clientX, touch2.clientY
            );
            
            this.lastRotation = this.getAngle(
                touch1.clientX, touch1.clientY,
                touch2.clientX, touch2.clientY
            );
            
            this.isPinching = true;
        }
    }
    
    /**
     * Handle touch move
     * @param {TouchEvent} event - Touch event
     */
    handleTouchMove(event) {
        event.preventDefault();
        
        // Update touch positions
        for (const touch of event.touches) {
            const storedTouch = this.touches.get(touch.identifier);
            if (storedTouch) {
                storedTouch.currentX = touch.clientX;
                storedTouch.currentY = touch.clientY;
            }
        }
        
        // Handle gestures based on touch count
        if (event.touches.length === 1) {
            this.handleSingleTouchMove(event.touches[0]);
        } else if (event.touches.length === 2) {
            this.handleMultiTouchMove(event.touches);
        }
        
        // Emit touch event
        this.emitTouchEvent('touchMove', {
            touches: Array.from(this.touches.values()),
            gesture: this.currentGesture
        });
    }
    
    /**
     * Handle single touch move
     * @param {Touch} touch - Touch object
     */
    handleSingleTouchMove(touch) {
        const storedTouch = this.touches.get(touch.identifier);
        if (!storedTouch) return;
        
        const deltaX = touch.clientX - storedTouch.startX;
        const deltaY = touch.clientY - storedTouch.startY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // Detect swipe gesture
        if (distance > this.config.swipeThreshold) {
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                this.currentGesture = deltaX > 0 ? 'swipeRight' : 'swipeLeft';
            } else {
                this.currentGesture = deltaY > 0 ? 'swipeDown' : 'swipeUp';
            }
        } else {
            this.currentGesture = 'pan';
        }
    }
    
    /**
     * Handle multi-touch move
     * @param {TouchList} touches - Touch list
     */
    handleMultiTouchMove(touches) {
        if (touches.length !== 2) return;
        
        const touch1 = touches[0];
        const touch2 = touches[1];
        
        // Calculate pinch
        const currentDistance = this.getDistance(
            touch1.clientX, touch1.clientY,
            touch2.clientX, touch2.clientY
        );
        
        const pinchDelta = currentDistance - this.lastPinchDistance;
        const pinchRatio = currentDistance / this.lastPinchDistance;
        
        if (Math.abs(pinchDelta) > this.config.pinchThreshold) {
            this.currentGesture = pinchRatio > 1 ? 'pinchOut' : 'pinchIn';
            
            // Emit pinch event
            this.emitTouchEvent('pinch', {
                scale: pinchRatio,
                delta: pinchDelta
            });
        }
        
        // Calculate rotation
        const currentRotation = this.getAngle(
            touch1.clientX, touch1.clientY,
            touch2.clientX, touch2.clientY
        );
        
        const rotationDelta = currentRotation - this.lastRotation;
        
        if (Math.abs(rotationDelta) > 5) { // 5 degree threshold
            this.currentGesture = 'rotate';
            
            // Emit rotation event
            this.emitTouchEvent('rotate', {
                angle: currentRotation,
                delta: rotationDelta
            });
        }
        
        this.lastPinchDistance = currentDistance;
        this.lastRotation = currentRotation;
    }
    
    /**
     * Handle touch end
     * @param {TouchEvent} event - Touch event
     */
    handleTouchEnd(event) {
        event.preventDefault();
        
        const now = Date.now();
        
        // Process ended touches
        for (const touch of event.changedTouches) {
            const storedTouch = this.touches.get(touch.identifier);
            
            if (storedTouch) {
                const duration = now - storedTouch.startTime;
                const deltaX = storedTouch.currentX - storedTouch.startX;
                const deltaY = storedTouch.currentY - storedTouch.startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Detect tap
                if (duration < 300 && distance < 10) {
                    if (this.tapCount === 2) {
                        this.emitTouchEvent('doubleTap', {
                            x: storedTouch.currentX,
                            y: storedTouch.currentY
                        });
                        this.tapCount = 0;
                    } else {
                        this.emitTouchEvent('tap', {
                            x: storedTouch.currentX,
                            y: storedTouch.currentY
                        });
                    }
                }
                
                // Detect long press
                if (duration > 500 && distance < 10) {
                    this.emitTouchEvent('longPress', {
                        x: storedTouch.currentX,
                        y: storedTouch.currentY
                    });
                }
                
                this.touches.delete(touch.identifier);
            }
        }
        
        // Reset gesture state
        if (event.touches.length === 0) {
            this.currentGesture = null;
            this.isPinching = false;
            this.isRotating = false;
        }
        
        // Emit touch end event
        this.emitTouchEvent('touchEnd', {
            gesture: this.currentGesture,
            duration: now - this.gestureStartTime
        });
    }
    
    /**
     * Handle touch cancel
     * @param {TouchEvent} event - Touch event
     */
    handleTouchCancel(event) {
        // Clear all touches
        this.touches.clear();
        this.currentGesture = null;
        this.isPinching = false;
        this.isRotating = false;
        
        this.emitTouchEvent('touchCancel', {});
    }
    
    /**
     * Handle orientation change
     * @param {Event} event - Orientation change event
     */
    handleOrientationChange(event) {
        this.orientation = this.getOrientation();
        
        // Emit orientation change event
        this.emitTouchEvent('orientationChange', {
            orientation: this.orientation,
            angle: window.orientation || 0
        });
        
        // Apply orientation-specific optimizations
        this.applyOrientationOptimizations();
    }
    
    /**
     * Handle device orientation
     * @param {DeviceOrientationEvent} event - Device orientation event
     */
    handleDeviceOrientation(event) {
        // Could be used for gyroscope-based interactions
        const { alpha, beta, gamma } = event;
        
        this.emitTouchEvent('deviceOrientation', {
            alpha, // Z axis rotation
            beta,  // X axis rotation
            gamma  // Y axis rotation
        });
    }
    
    /**
     * Handle viewport change
     * @param {Event} event - Resize event
     */
    handleViewportChange(event) {
        const now = Date.now();
        
        // Debounce viewport changes
        if (now - this.lastViewportChange < 100) return;
        
        this.lastViewportChange = now;
        this.viewportSize = {
            width: window.innerWidth,
            height: window.innerHeight
        };
        
        // Update pixel ratio
        this.pixelRatio = window.devicePixelRatio || 1;
        
        // Emit viewport change event
        this.emitTouchEvent('viewportChange', {
            size: this.viewportSize,
            pixelRatio: this.pixelRatio,
            orientation: this.getOrientation()
        });
        
        // Apply responsive scaling
        if (this.config.enableResponsiveScaling) {
            this.applyResponsiveScaling();
        }
    }
    
    /**
     * Handle visibility change
     * @param {Event} event - Visibility change event
     */
    handleVisibilityChange(event) {
        const isVisible = !document.hidden;
        
        this.emitTouchEvent('visibilityChange', {
            visible: isVisible
        });
        
        // Apply optimizations based on visibility
        if (!isVisible && this.config.enableBatteryOptimization) {
            // Reduce performance when app is in background
            this.applyBackgroundOptimizations();
        } else {
            // Restore performance when app is visible
            this.restorePerformance();
        }
    }
    
    /**
     * Get current orientation
     * @returns {string} Orientation (portrait or landscape)
     */
    getOrientation() {
        return window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
    }
    
    /**
     * Get distance between two points
     * @param {number} x1 - First X coordinate
     * @param {number} y1 - First Y coordinate
     * @param {number} x2 - Second X coordinate
     * @param {number} y2 - Second Y coordinate
     * @returns {number} Distance
     */
    getDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Get angle between two points
     * @param {number} x1 - First X coordinate
     * @param {number} y1 - First Y coordinate
     * @param {number} x2 - Second X coordinate
     * @param {number} y2 - Second Y coordinate
     * @returns {number} Angle in degrees
     */
    getAngle(x1, y1, x2, y2) {
        return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
    }
    
    /**
     * Apply mobile optimizations
     */
    applyMobileOptimizations() {
        if (!this.isMobile && !this.isTablet) return;
        
        const optimizations = {
            ...this.mobilePerformanceSettings,
            canvasScale: this.calculateOptimalCanvasScale(),
            useWebGL: false, // Disable WebGL on mobile for battery
            useOffscreenCanvas: this.useOffscreenCanvas
        };
        
        // Emit optimization settings
        this.emitTouchEvent('mobileOptimizations', optimizations);
        
        return optimizations;
    }
    
    /**
     * Apply orientation-specific optimizations
     */
    applyOrientationOptimizations() {
        const isLandscape = this.orientation === 'landscape';
        
        const optimizations = {
            layoutMode: isLandscape ? 'horizontal' : 'vertical',
            particleDirection: isLandscape ? 'horizontal' : 'vertical',
            uiScale: isLandscape ? 0.8 : 1.0
        };
        
        this.emitTouchEvent('orientationOptimizations', optimizations);
        
        return optimizations;
    }
    
    /**
     * Apply responsive scaling
     */
    applyResponsiveScaling() {
        const baseWidth = 375; // iPhone 6/7/8 width as base
        const scaleFactor = Math.min(
            this.viewportSize.width / baseWidth,
            2.0 // Max scale factor
        );
        
        this.canvasScale = scaleFactor;
        
        this.emitTouchEvent('responsiveScale', {
            scale: this.canvasScale,
            viewport: this.viewportSize
        });
        
        return this.canvasScale;
    }
    
    /**
     * Apply background optimizations for battery saving
     */
    applyBackgroundOptimizations() {
        const optimizations = {
            targetFPS: 5, // Very low FPS in background
            particlesEnabled: false,
            animationsEnabled: false,
            audioEnabled: false
        };
        
        this.emitTouchEvent('backgroundOptimizations', optimizations);
        
        return optimizations;
    }
    
    /**
     * Restore performance settings
     */
    restorePerformance() {
        const settings = this.applyMobileOptimizations();
        
        this.emitTouchEvent('performanceRestore', settings);
        
        return settings;
    }
    
    /**
     * Handle battery change
     */
    onBatteryChange() {
        this.lowPowerMode = this.batteryLevel < 0.2 && !this.isCharging;
        
        if (this.lowPowerMode) {
            // Apply low power optimizations
            const optimizations = {
                targetFPS: 15,
                maxParticles: 5,
                reducedEffects: true,
                audioEnabled: false
            };
            
            this.emitTouchEvent('lowPowerMode', {
                batteryLevel: this.batteryLevel,
                isCharging: this.isCharging,
                optimizations
            });
        }
    }
    
    /**
     * Calculate optimal canvas scale for device
     * @returns {number} Scale factor
     */
    calculateOptimalCanvasScale() {
        // Balance between quality and performance
        if (this.isMobile) {
            return Math.min(this.pixelRatio, 2); // Cap at 2x for mobile
        } else if (this.isTablet) {
            return Math.min(this.pixelRatio, 2.5); // Slightly higher for tablets
        }
        
        return this.pixelRatio; // Full resolution for desktop
    }
    
    /**
     * Get canvas element
     * @returns {HTMLCanvasElement} Canvas element
     */
    getCanvas() {
        // This would be set by the main application
        return this.canvas || document.querySelector('canvas');
    }
    
    /**
     * Set canvas element
     * @param {HTMLCanvasElement} canvas - Canvas element
     */
    setCanvas(canvas) {
        this.canvas = canvas;
        
        if (this.config.enableTouchOptimization && this.isTouchDevice) {
            this.setupTouchHandlers();
        }
    }
    
    /**
     * Emit touch event
     * @param {string} eventType - Event type
     * @param {Object} data - Event data
     */
    emitTouchEvent(eventType, data) {
        if (this.onTouchEvent) {
            this.onTouchEvent(eventType, data);
        }
    }
    
    /**
     * Get mobile optimization status
     * @returns {Object} Status report
     */
    getStatus() {
        return {
            device: {
                isMobile: this.isMobile,
                isTablet: this.isTablet,
                isTouchDevice: this.isTouchDevice,
                isIOS: this.isIOS,
                isAndroid: this.isAndroid
            },
            viewport: {
                size: this.viewportSize,
                orientation: this.orientation,
                pixelRatio: this.pixelRatio,
                canvasScale: this.canvasScale
            },
            battery: {
                level: this.batteryLevel,
                isCharging: this.isCharging,
                lowPowerMode: this.lowPowerMode
            },
            touch: {
                activeTouches: this.touches.size,
                currentGesture: this.currentGesture,
                isPinching: this.isPinching,
                isRotating: this.isRotating
            },
            performance: this.mobilePerformanceSettings
        };
    }
    
    /**
     * Destroy mobile optimization
     */
    destroy() {
        const canvas = this.getCanvas();
        
        if (canvas) {
            canvas.removeEventListener('touchstart', this.handleTouchStart);
            canvas.removeEventListener('touchmove', this.handleTouchMove);
            canvas.removeEventListener('touchend', this.handleTouchEnd);
            canvas.removeEventListener('touchcancel', this.handleTouchCancel);
        }
        
        window.removeEventListener('resize', this.handleViewportChange);
        window.removeEventListener('orientationchange', this.handleOrientationChange);
        document.removeEventListener('visibilitychange', this.handleVisibilityChange);
        
        this.touches.clear();
        this.gestureHistory = [];
        
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  PLUGIN SYSTEM  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Plugin System - Extensible Architecture for Custom Behaviors
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module PluginSystem
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The EXPANSION SLOT for creativity. Allows developers to extend the mascot         
 * ║ with custom emotions, gestures, particles, and behaviors without modifying        
 * ║ core code. Build your own emotional expressions!                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔌 PLUGIN TYPES                                                                    
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • emotion  : Add custom emotional states                                          
 * │ • gesture  : Define new gesture animations                                        
 * │ • particle : Create custom particle behaviors                                     
 * │ • audio    : Add sound effects and tones                                          
 * │ • renderer : Modify rendering pipeline                                            
 * │ • behavior : Add complex behavioral patterns                                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎯 LIFECYCLE HOOKS                                                                 
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • init()     : Called when plugin is registered                                   
 * │ • update()   : Called every frame                                                 
 * │ • render()   : Called during render phase                                         
 * │ • destroy()  : Called when plugin is unregistered                                 
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class PluginSystem {
    constructor(config = {}) {
        this.config = {
            enablePlugins: config.enablePlugins !== false,
            validatePlugins: config.validatePlugins !== false,
            sandboxPlugins: config.sandboxPlugins !== false,
            maxPlugins: config.maxPlugins || 50,
            pluginTimeout: config.pluginTimeout || 5000,
            allowOverrides: config.allowOverrides !== false,
            ...config
        };
        
        // Plugin registry
        this.plugins = new Map();
        this.pluginTypes = ['emotion', 'gesture', 'particle', 'audio', 'renderer', 'animation'];
        this.pluginsByType = new Map(this.pluginTypes.map(type => [type, new Set()]));
        
        // Plugin dependencies
        this.dependencies = new Map();
        this.dependencyGraph = new Map();
        
        // Plugin lifecycle states
        this.pluginStates = new Map();
        this.loadingPlugins = new Set();
        this.activePlugins = new Set();
        
        // Plugin hooks
        this.hooks = new Map([
            ['beforeInit', new Set()],
            ['afterInit', new Set()],
            ['beforeUpdate', new Set()],
            ['afterUpdate', new Set()],
            ['beforeRender', new Set()],
            ['afterRender', new Set()],
            ['beforeDestroy', new Set()],
            ['afterDestroy', new Set()]
        ]);
        
        // Plugin API exposed to plugins
        this.pluginAPI = this.createPluginAPI();
        
        // Conflict resolution
        this.conflicts = new Map();
        this.resolutionStrategies = {
            'override': this.overrideConflict.bind(this),
            'merge': this.mergeConflict.bind(this),
            'reject': this.rejectConflict.bind(this),
            'queue': this.queueConflict.bind(this)
        };
        
        // Plugin validation schemas
        this.validationSchemas = this.createValidationSchemas();
        
        // Sandbox environment for plugins
        this.sandbox = null;
        if (this.config.sandboxPlugins) {
            this.sandbox = this.createSandbox();
        }
        
        // PluginSystem initialized
    }
    
    /**
     * Create plugin API exposed to plugins
     * @returns {Object} Plugin API
     */
    createPluginAPI() {
        return {
            // Core functionality
            registerHook: this.registerHook.bind(this),
            emit: this.emitPluginEvent.bind(this),
            on: this.onPluginEvent.bind(this),
            
            // Access to other plugins
            getPlugin: this.getPlugin.bind(this),
            hasPlugin: this.hasPlugin.bind(this),
            
            // Utilities
            log: this.logFromPlugin.bind(this),
            error: this.errorFromPlugin.bind(this),
            
            // State management
            setState: this.setPluginState.bind(this),
            getState: this.getPluginState.bind(this),
            
            // Configuration
            getConfig: () => ({ ...this.config }),
            
            // Version info
            version: '1.0.0'
        };
    }
    
    /**
     * Create validation schemas for different plugin types
     * @returns {Map} Validation schemas
     */
    createValidationSchemas() {
        const schemas = new Map();
        
        // Base schema for all plugins
        const baseSchema = {
            name: { type: 'string', required: true },
            version: { type: 'string', required: true },
            type: { type: 'string', required: true, enum: this.pluginTypes },
            description: { type: 'string', required: false },
            author: { type: 'string', required: false },
            dependencies: { type: 'array', required: false },
            conflicts: { type: 'array', required: false },
            init: { type: 'function', required: true },
            destroy: { type: 'function', required: true }
        };
        
        // Emotion plugin schema
        schemas.set('emotion', {
            ...baseSchema,
            emotion: {
                type: 'object',
                required: true,
                properties: {
                    name: { type: 'string', required: true },
                    color: { type: 'string', required: true },
                    particleColor: { type: 'string', required: false },
                    animation: { type: 'object', required: true },
                    transitions: { type: 'object', required: false }
                }
            },
            updateEmotion: { type: 'function', required: true },
            renderEmotion: { type: 'function', required: false }
        });
        
        // Gesture plugin schema
        schemas.set('gesture', {
            ...baseSchema,
            gesture: {
                type: 'object',
                required: true,
                properties: {
                    name: { type: 'string', required: true },
                    duration: { type: 'number', required: true },
                    keyframes: { type: 'array', required: true },
                    compatibility: { type: 'object', required: false }
                }
            },
            executeGesture: { type: 'function', required: true },
            canExecute: { type: 'function', required: false }
        });
        
        // Particle plugin schema
        schemas.set('particle', {
            ...baseSchema,
            particle: {
                type: 'object',
                required: true,
                properties: {
                    name: { type: 'string', required: true },
                    maxParticles: { type: 'number', required: false },
                    behavior: { type: 'function', required: true },
                    render: { type: 'function', required: true }
                }
            },
            updateParticles: { type: 'function', required: true },
            spawnParticle: { type: 'function', required: false }
        });
        
        // Audio plugin schema
        schemas.set('audio', {
            ...baseSchema,
            audio: {
                type: 'object',
                required: true,
                properties: {
                    name: { type: 'string', required: true },
                    sounds: { type: 'object', required: true },
                    effects: { type: 'array', required: false }
                }
            },
            playSound: { type: 'function', required: true },
            processAudio: { type: 'function', required: false }
        });
        
        return schemas;
    }
    
    /**
     * Create sandbox environment for plugin execution
     * @returns {Object} Sandbox environment
     */
    createSandbox() {
        // Create a limited execution environment
        const sandbox = {
            // Safe global objects
            Math: Math,
            Date: Date,
            JSON: JSON,
            
            // Limited console
            console: {
                log: (...args) => null,
                warn: (...args) => null,
                error: (...args) => null
            },
            
            // No access to window, document, or other globals
            window: undefined,
            document: undefined,
            localStorage: undefined,
            sessionStorage: undefined,
            fetch: undefined,
            XMLHttpRequest: undefined,
            
            // Plugin API
            api: this.pluginAPI
        };
        
        return sandbox;
    }
    
    /**
     * Register a plugin
     * @param {Object} plugin - Plugin to register
     * @returns {boolean} Success status
     */
    async registerPlugin(plugin) {
        if (!this.config.enablePlugins) {
            // Plugins are disabled
            return false;
        }
        
        // Check plugin limit
        if (this.plugins.size >= this.config.maxPlugins) {
            // Maximum plugin limit reached
            return false;
        }
        
        // Validate plugin
        if (this.config.validatePlugins) {
            const validation = this.validatePlugin(plugin);
            if (!validation.valid) {
                // Plugin validation failed
                return false;
            }
        }
        
        // Check for conflicts
        const conflicts = this.checkConflicts(plugin);
        if (conflicts.length > 0 && !this.config.allowOverrides) {
            // Plugin conflicts detected
            return false;
        }
        
        // Resolve dependencies
        const dependencies = await this.resolveDependencies(plugin);
        if (!dependencies.resolved) {
            // Plugin dependencies not met
            return false;
        }
        
        // Initialize plugin in sandbox if enabled
        try {
            this.loadingPlugins.add(plugin.name);
            
            const context = this.config.sandboxPlugins ? this.sandbox : window;
            const initialized = await this.initializePlugin(plugin, context);
            
            if (!initialized) {
                throw new Error('Plugin initialization failed');
            }
            
            // Register plugin
            this.plugins.set(plugin.name, plugin);
            this.pluginsByType.get(plugin.type).add(plugin.name);
            this.pluginStates.set(plugin.name, 'active');
            this.activePlugins.add(plugin.name);
            
            // Store dependencies
            if (plugin.dependencies) {
                this.dependencies.set(plugin.name, plugin.dependencies);
                this.updateDependencyGraph(plugin.name, plugin.dependencies);
            }
            
            // Register hooks if provided
            if (plugin.hooks) {
                Object.entries(plugin.hooks).forEach(([hook, handler]) => {
                    this.registerHook(hook, handler, plugin.name);
                });
            }
            
            // Plugin registered
            
            // Emit registration event
            this.emitPluginEvent('pluginRegistered', {
                name: plugin.name,
                type: plugin.type,
                version: plugin.version
            });
            
            return true;
            
        } catch (error) {
            // Failed to register plugin
            return false;
        } finally {
            this.loadingPlugins.delete(plugin.name);
        }
    }
    
    /**
     * Validate a plugin against its schema
     * @param {Object} plugin - Plugin to validate
     * @returns {Object} Validation result
     */
    validatePlugin(plugin) {
        const errors = [];
        
        // Check required base properties
        if (!plugin.name || typeof plugin.name !== 'string') {
            errors.push('Plugin must have a valid name');
        }
        
        if (!plugin.type || !this.pluginTypes.includes(plugin.type)) {
            errors.push(`Plugin type must be one of: ${this.pluginTypes.join(', ')}`);
        }
        
        if (!plugin.version || typeof plugin.version !== 'string') {
            errors.push('Plugin must have a version');
        }
        
        if (typeof plugin.init !== 'function') {
            errors.push('Plugin must have an init function');
        }
        
        if (typeof plugin.destroy !== 'function') {
            errors.push('Plugin must have a destroy function');
        }
        
        // Validate type-specific schema
        if (plugin.type && this.validationSchemas.has(plugin.type)) {
            const schema = this.validationSchemas.get(plugin.type);
            const typeErrors = this.validateAgainstSchema(plugin, schema);
            errors.push(...typeErrors);
        }
        
        return {
            valid: errors.length === 0,
            errors
        };
    }
    
    /**
     * Validate object against schema
     * @param {Object} obj - Object to validate
     * @param {Object} schema - Schema to validate against
     * @returns {Array} Array of errors
     */
    validateAgainstSchema(obj, schema) {
        const errors = [];
        
        Object.entries(schema).forEach(([key, rules]) => {
            if (rules.required && !(key in obj)) {
                errors.push(`Missing required property: ${key}`);
            }
            
            if (key in obj) {
                const value = obj[key];
                
                if (rules.type && typeof value !== rules.type) {
                    errors.push(`Property ${key} must be of type ${rules.type}`);
                }
                
                if (rules.enum && !rules.enum.includes(value)) {
                    errors.push(`Property ${key} must be one of: ${rules.enum.join(', ')}`);
                }
                
                if (rules.properties && typeof value === 'object') {
                    const subErrors = this.validateAgainstSchema(value, rules.properties);
                    errors.push(...subErrors.map(e => `${key}.${e}`));
                }
            }
        });
        
        return errors;
    }
    
    /**
     * Check for plugin conflicts
     * @param {Object} plugin - Plugin to check
     * @returns {Array} Array of conflicts
     */
    checkConflicts(plugin) {
        const conflicts = [];
        
        // Check explicit conflicts
        if (plugin.conflicts) {
            plugin.conflicts.forEach(conflictName => {
                if (this.plugins.has(conflictName)) {
                    conflicts.push(conflictName);
                }
            });
        }
        
        // Check type-specific conflicts
        if (plugin.type === 'emotion' || plugin.type === 'gesture') {
            // Check for name collisions
            this.plugins.forEach((existingPlugin) => {
                if (existingPlugin.type === plugin.type) {
                    const existingName = existingPlugin[plugin.type]?.name;
                    const newName = plugin[plugin.type]?.name;
                    
                    if (existingName === newName) {
                        conflicts.push(`${plugin.type} name collision: ${newName}`);
                    }
                }
            });
        }
        
        return conflicts;
    }
    
    /**
     * Resolve plugin dependencies
     * @param {Object} plugin - Plugin to resolve dependencies for
     * @returns {Object} Resolution result
     */
    async resolveDependencies(plugin) {
        if (!plugin.dependencies || plugin.dependencies.length === 0) {
            return { resolved: true, missing: [] };
        }
        
        const missing = [];
        
        for (const dep of plugin.dependencies) {
            // Check if dependency is already loaded
            if (!this.plugins.has(dep)) {
                // Try to load dependency
                const loaded = await this.tryLoadDependency(dep);
                if (!loaded) {
                    missing.push(dep);
                }
            }
        }
        
        return {
            resolved: missing.length === 0,
            missing
        };
    }
    
    /**
     * Try to load a dependency
     * @param {string} dependencyName - Dependency name
     * @returns {boolean} Success status
     */
    async tryLoadDependency(dependencyName) {
        // This would attempt to load the dependency
        // For now, just check if it exists
        return this.plugins.has(dependencyName);
    }
    
    /**
     * Update dependency graph
     * @param {string} pluginName - Plugin name
     * @param {Array} dependencies - Dependencies
     */
    updateDependencyGraph(pluginName, dependencies) {
        this.dependencyGraph.set(pluginName, new Set(dependencies));
        
        // Update reverse dependencies
        dependencies.forEach(dep => {
            if (!this.dependencyGraph.has(dep)) {
                this.dependencyGraph.set(dep, new Set());
            }
        });
    }
    
    /**
     * Initialize a plugin
     * @param {Object} plugin - Plugin to initialize
     * @param {Object} context - Execution context
     * @returns {boolean} Success status
     */
    async initializePlugin(plugin, context) {
        try {
            // Set timeout for initialization
            const timeout = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Plugin initialization timeout')), this.config.pluginTimeout);
            });
            
            // Initialize plugin
            const init = plugin.init.bind(context);
            const result = await Promise.race([
                init(this.pluginAPI),
                timeout
            ]);
            
            return result !== false;
        } catch (error) {
            // Plugin initialization error
            return false;
        }
    }
    
    /**
     * Unregister a plugin
     * @param {string} pluginName - Name of plugin to unregister
     * @returns {boolean} Success status
     */
    async unregisterPlugin(pluginName) {
        const plugin = this.plugins.get(pluginName);
        if (!plugin) {
            // Plugin not found
            return false;
        }
        
        // Check for dependent plugins
        const dependents = this.getDependentPlugins(pluginName);
        if (dependents.length > 0) {
            // Cannot unregister plugin - required by dependents
            return false;
        }
        
        try {
            // Call destroy method
            if (typeof plugin.destroy === 'function') {
                await plugin.destroy();
            }
            
            // Remove from registries
            this.plugins.delete(pluginName);
            this.pluginsByType.get(plugin.type).delete(pluginName);
            this.pluginStates.delete(pluginName);
            this.activePlugins.delete(pluginName);
            this.dependencies.delete(pluginName);
            this.dependencyGraph.delete(pluginName);
            
            // Remove hooks
            this.hooks.forEach(hookSet => {
                hookSet.forEach(hook => {
                    if (hook.pluginName === pluginName) {
                        hookSet.delete(hook);
                    }
                });
            });
            
            // Plugin unregistered
            
            // Emit unregistration event
            this.emitPluginEvent('pluginUnregistered', { name: pluginName });
            
            return true;
        } catch (error) {
            // Failed to unregister plugin
            return false;
        }
    }
    
    /**
     * Get plugins dependent on a given plugin
     * @param {string} pluginName - Plugin name
     * @returns {Array} Array of dependent plugin names
     */
    getDependentPlugins(pluginName) {
        const dependents = [];
        
        this.dependencies.forEach((deps, name) => {
            if (deps.includes(pluginName)) {
                dependents.push(name);
            }
        });
        
        return dependents;
    }
    
    /**
     * Register a hook handler
     * @param {string} hookName - Hook name
     * @param {Function} handler - Handler function
     * @param {string} pluginName - Plugin name
     */
    registerHook(hookName, handler, pluginName) {
        if (!this.hooks.has(hookName)) {
            this.hooks.set(hookName, new Set());
        }
        
        this.hooks.get(hookName).add({
            handler,
            pluginName
        });
    }
    
    /**
     * Execute hooks for a given event
     * @param {string} hookName - Hook name
     * @param {*} data - Data to pass to hooks
     * @returns {Array} Results from hooks
     */
    async executeHooks(hookName, data) {
        const hooks = this.hooks.get(hookName);
        if (!hooks || hooks.size === 0) return [];
        
        const results = [];
        
        for (const hook of hooks) {
            try {
                const result = await hook.handler(data);
                results.push({ pluginName: hook.pluginName, result });
            } catch (error) {
                // Hook error in plugin
            }
        }
        
        return results;
    }
    
    /**
     * Get a plugin by name
     * @param {string} pluginName - Plugin name
     * @returns {Object} Plugin or null
     */
    getPlugin(pluginName) {
        return this.plugins.get(pluginName) || null;
    }
    
    /**
     * Check if a plugin exists
     * @param {string} pluginName - Plugin name
     * @returns {boolean} True if plugin exists
     */
    hasPlugin(pluginName) {
        return this.plugins.has(pluginName);
    }
    
    /**
     * Get plugins by type
     * @param {string} type - Plugin type
     * @returns {Array} Array of plugins
     */
    getPluginsByType(type) {
        const pluginNames = this.pluginsByType.get(type);
        if (!pluginNames) return [];
        
        return Array.from(pluginNames).map(name => this.plugins.get(name));
    }
    
    /**
     * Enable a plugin
     * @param {string} pluginName - Plugin name
     */
    enablePlugin(pluginName) {
        if (!this.plugins.has(pluginName)) return;
        
        this.pluginStates.set(pluginName, 'active');
        this.activePlugins.add(pluginName);
        
        const plugin = this.plugins.get(pluginName);
        if (plugin.onEnable) {
            plugin.onEnable();
        }
        
        this.emitPluginEvent('pluginEnabled', { name: pluginName });
    }
    
    /**
     * Disable a plugin
     * @param {string} pluginName - Plugin name
     */
    disablePlugin(pluginName) {
        if (!this.plugins.has(pluginName)) return;
        
        // Check dependents
        this.getDependentPlugins(pluginName);
        
        this.pluginStates.set(pluginName, 'disabled');
        this.activePlugins.delete(pluginName);
        
        const plugin = this.plugins.get(pluginName);
        if (plugin.onDisable) {
            plugin.onDisable();
        }
        
        this.emitPluginEvent('pluginDisabled', { name: pluginName });
    }
    
    /**
     * Emit plugin event
     * @param {string} eventName - Event name
     * @param {*} data - Event data
     */
    emitPluginEvent(eventName, data) {
        // This would integrate with the main event system
        if (this.onPluginEvent) {
            this.onPluginEvent(eventName, data);
        }
    }
    
    /**
     * Listen for plugin events
     * @param {string} eventName - Event name
     * @param {Function} handler - Event handler
     */
    onPluginEvent(eventName, handler) {
        // This would integrate with the main event system
        // Placeholder for event listening
    }
    
    /**
     * Log from plugin context
     * @param {string} pluginName - Plugin name
     * @param {...*} args - Log arguments
     */
    logFromPlugin(pluginName, ...args) {
        // Plugin log message
    }
    
    /**
     * Error from plugin context
     * @param {string} pluginName - Plugin name
     * @param {...*} args - Error arguments
     */
    errorFromPlugin(pluginName, ...args) {
        // Plugin error message
    }
    
    /**
     * Set plugin state
     * @param {string} pluginName - Plugin name
     * @param {string} key - State key
     * @param {*} value - State value
     */
    setPluginState(pluginName, key, value) {
        if (!this.pluginStates.has(pluginName)) {
            this.pluginStates.set(pluginName, {});
        }
        
        const state = this.pluginStates.get(pluginName);
        if (typeof state === 'object') {
            state[key] = value;
        }
    }
    
    /**
     * Get plugin state
     * @param {string} pluginName - Plugin name
     * @param {string} key - State key
     * @returns {*} State value
     */
    getPluginState(pluginName, key) {
        const state = this.pluginStates.get(pluginName);
        if (typeof state === 'object') {
            return state[key];
        }
        return undefined;
    }
    
    /**
     * Conflict resolution strategies
     */
    overrideConflict(existing, incoming) {
        return incoming; // New plugin overrides existing
    }
    
    mergeConflict(existing, incoming) {
        return { ...existing, ...incoming }; // Merge properties
    }
    
    rejectConflict(existing, incoming) {
        return existing; // Keep existing, reject new
    }
    
    queueConflict(existing, incoming) {
        return [existing, incoming]; // Queue both
    }
    
    /**
     * Get plugin system status
     * @returns {Object} Status report
     */
    getStatus() {
        return {
            enabled: this.config.enablePlugins,
            totalPlugins: this.plugins.size,
            activePlugins: this.activePlugins.size,
            loadingPlugins: this.loadingPlugins.size,
            pluginsByType: Object.fromEntries(
                Array.from(this.pluginsByType.entries()).map(([type, plugins]) => [type, plugins.size])
            ),
            hooks: Object.fromEntries(
                Array.from(this.hooks.entries()).map(([hook, handlers]) => [hook, handlers.size])
            )
        };
    }
    
    /**
     * Destroy plugin system
     */
    async destroy() {
        // Unregister all plugins
        const pluginNames = Array.from(this.plugins.keys());
        
        for (const name of pluginNames) {
            await this.unregisterPlugin(name);
        }
        
        // Clear all data
        this.plugins.clear();
        this.pluginsByType.clear();
        this.dependencies.clear();
        this.dependencyGraph.clear();
        this.pluginStates.clear();
        this.activePlugins.clear();
        this.loadingPlugins.clear();
        this.hooks.clear();
        this.conflicts.clear();
        
        // PluginSystem destroyed
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                 ◐ ◑ ◒ ◓  BROWSER COMPATIBILITY  ◓ ◒ ◑ ◐                 
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Browser Compatibility - Feature Detection & Graceful Degradation
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module BrowserCompatibility
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The COMPATIBILITY LAYER of the engine. Ensures the Emotive Engine runs           
 * ║ smoothly across all modern browsers by detecting features, providing              
 * ║ polyfills, and enabling graceful degradation when features are missing.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🌐 BROWSER FEATURES                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Web Audio API detection and fallbacks                                           
 * │ • Canvas 2D context recovery and management                                       
 * │ • RequestAnimationFrame polyfills                                                 
 * │ • Device pixel ratio handling                                                     
 * │ • Performance API detection                                                       
 * │ • Media device capabilities                                                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Feature detection utilities
 */
class FeatureDetection {
    constructor() {
        // Cache detection results to avoid repeated expensive checks
        if (FeatureDetection._cachedFeatures) {
            this.features = FeatureDetection._cachedFeatures;
            this.capabilities = FeatureDetection._cachedCapabilities;
            return;
        }
        
        this.features = {
            webAudio: this.detectWebAudio(),
            canvas2d: this.detectCanvas2D(),
            requestAnimationFrame: this.detectRequestAnimationFrame(),
            devicePixelRatio: this.detectDevicePixelRatio(),
            audioContext: this.detectAudioContext(),
            mediaDevices: this.detectMediaDevices(),
            performance: this.detectPerformance(),
            intersectionObserver: this.detectIntersectionObserver()
        };
        
        this.capabilities = this.assessCapabilities();
        
        // Cache results for future instantiations
        FeatureDetection._cachedFeatures = this.features;
        FeatureDetection._cachedCapabilities = this.capabilities;
    }

    /**
     * Detect Web Audio API support
     * @returns {boolean} True if Web Audio API is supported
     */
    detectWebAudio() {
        try {
            return !!(window.AudioContext || window.webkitAudioContext);
        } catch (e) {
            return false;
        }
    }

    /**
     * Detect Canvas 2D support
     * @returns {boolean} True if Canvas 2D is supported
     */
    detectCanvas2D() {
        try {
            const canvas = document.createElement('canvas');
            return !!(canvas.getContext && canvas.getContext('2d'));
        } catch (e) {
            return false;
        }
    }

    /**
     * Detect requestAnimationFrame support
     * @returns {boolean} True if requestAnimationFrame is supported
     */
    detectRequestAnimationFrame() {
        return !!(window.requestAnimationFrame || 
                 window.webkitRequestAnimationFrame || 
                 window.mozRequestAnimationFrame || 
                 window.oRequestAnimationFrame || 
                 window.msRequestAnimationFrame);
    }

    /**
     * Detect device pixel ratio support
     * @returns {boolean} True if devicePixelRatio is supported
     */
    detectDevicePixelRatio() {
        return typeof window.devicePixelRatio === 'number';
    }

    /**
     * Detect AudioContext support (more specific than Web Audio)
     * @returns {boolean} True if AudioContext is supported
     */
    detectAudioContext() {
        try {
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (!AudioContextClass) return false;
            
            // Don't create a test context - just check if the class exists
            // Creating contexts is expensive and has limits
            return true;
        } catch (e) {
            return false;
        }
    }

    /**
     * Detect MediaDevices API support
     * @returns {boolean} True if MediaDevices API is supported
     */
    detectMediaDevices() {
        return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }

    /**
     * Detect Performance API support
     * @returns {boolean} True if Performance API is supported
     */
    detectPerformance() {
        return !!(window.performance && window.performance.now);
    }

    /**
     * Detect Intersection Observer support
     * @returns {boolean} True if Intersection Observer is supported
     */
    detectIntersectionObserver() {
        return typeof window.IntersectionObserver === 'function';
    }

    /**
     * Assess overall browser capabilities
     * @returns {Object} Capability assessment
     */
    assessCapabilities() {
        const score = Object.values(this.features).filter(Boolean).length;
        const total = Object.keys(this.features).length;
        const percentage = (score / total) * 100;

        let level = 'basic';
        if (percentage >= 90) level = 'full';
        else if (percentage >= 70) level = 'good';
        else if (percentage >= 50) level = 'limited';

        return {
            score,
            total,
            percentage,
            level,
            recommendations: this.getRecommendations(level)
        };
    }

    /**
     * Get recommendations based on capability level
     * @param {string} level - Capability level
     * @returns {Array<string>} Array of recommendations
     */
    getRecommendations(level) {
        const recommendations = [];

        if (!this.features.webAudio) {
            recommendations.push('Audio features will be disabled');
        }
        if (!this.features.requestAnimationFrame) {
            recommendations.push('Animation will use setTimeout fallback');
        }
        if (!this.features.performance) {
            recommendations.push('Performance monitoring will be limited');
        }
        if (level === 'basic') {
            recommendations.push('Consider using minimal build for better performance');
        }

        return recommendations;
    }

    /**
     * Get all detected features
     * @returns {Object} Feature detection results
     */
    getFeatures() {
        return { ...this.features };
    }

    /**
     * Get capability assessment
     * @returns {Object} Capability assessment
     */
    getCapabilities() {
        return { ...this.capabilities };
    }
}

/**
 * Polyfill manager for missing browser features
 */
class PolyfillManager {
    constructor() {
        this.polyfills = new Map();
        this.applied = new Set();
    }

    /**
     * Register a polyfill
     * @param {string} feature - Feature name
     * @param {Function} polyfillFn - Polyfill function
     */
    register(feature, polyfillFn) {
        this.polyfills.set(feature, polyfillFn);
    }

    /**
     * Apply a specific polyfill
     * @param {string} feature - Feature name
     * @returns {boolean} True if polyfill was applied
     */
    apply(feature) {
        if (this.applied.has(feature)) {
            return true; // Already applied
        }

        const polyfillFn = this.polyfills.get(feature);
        if (!polyfillFn) {
            // No polyfill registered for feature
            return false;
        }

        try {
            polyfillFn();
            this.applied.add(feature);
            // Applied polyfill for feature
            return true;
        } catch (error) {
            // Failed to apply polyfill for feature
            return false;
        }
    }

    /**
     * Apply all registered polyfills
     * @returns {Array<string>} Array of successfully applied polyfills
     */
    applyAll() {
        const applied = [];
        for (const feature of this.polyfills.keys()) {
            if (this.apply(feature)) {
                applied.push(feature);
            }
        }
        return applied;
    }

    /**
     * Check if a polyfill has been applied
     * @param {string} feature - Feature name
     * @returns {boolean} True if polyfill has been applied
     */
    isApplied(feature) {
        return this.applied.has(feature);
    }
}

/**
 * RequestAnimationFrame polyfill
 */
function polyfillRequestAnimationFrame() {
    if (window.requestAnimationFrame) return;

    // Try vendor prefixes first
    window.requestAnimationFrame = 
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
            return window.setTimeout(function() {
                callback(Date.now());
            }, 1000 / 60); // 60 FPS fallback
        };

    window.cancelAnimationFrame = 
        window.webkitCancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        window.oCancelAnimationFrame ||
        window.msCancelAnimationFrame ||
        function(id) {
            window.clearTimeout(id);
        };
}

/**
 * Performance.now polyfill
 */
function polyfillPerformanceNow() {
    if (window.performance && window.performance.now) return;

    if (!window.performance) {
        window.performance = {};
    }

    const startTime = Date.now();
    window.performance.now = function() {
        return Date.now() - startTime;
    };
}

/**
 * Web Audio API polyfill (basic fallback)
 */
function polyfillWebAudio() {
    if (window.AudioContext || window.webkitAudioContext) return;

    // Create a minimal AudioContext-like interface
    window.AudioContext = function() {
        this.state = 'suspended';
        this.sampleRate = 44100;
        this.currentTime = 0;
        this.destination = {
            connect: function() {},
            disconnect: function() {}
        };

        this.createGain = function() {
            return {
                gain: { value: 1 },
                connect: function() {},
                disconnect: function() {}
            };
        };

        this.createOscillator = function() {
            return {
                frequency: { value: 440 },
                type: 'sine',
                start: function() {},
                stop: function() {},
                connect: function() {},
                disconnect: function() {}
            };
        };

        this.createAnalyser = function() {
            return {
                fftSize: 2048,
                frequencyBinCount: 1024,
                getByteFrequencyData: function(array) {
                    // Fill with zeros
                    for (let i = 0; i < array.length; i++) {
                        array[i] = 0;
                    }
                },
                connect: function() {},
                disconnect: function() {}
            };
        };

        this.resume = function() {
            this.state = 'running';
            return Promise.resolve();
        };

        this.suspend = function() {
            this.state = 'suspended';
            return Promise.resolve();
        };

        this.close = function() {
            this.state = 'closed';
            return Promise.resolve();
        };
    };

    // Web Audio API not supported - using fallback implementation
}

/**
 * Canvas context recovery utilities
 */
class CanvasContextRecovery {
    constructor(canvas) {
        this.canvas = canvas;
        this.context = null;
        this.isContextLost = false;
        this.recoveryCallbacks = [];
        
        this.setupContextLossHandling();
    }

    /**
     * Set up context loss and recovery handling
     */
    setupContextLossHandling() {
        this.canvas.addEventListener('webglcontextlost', (event) => {
            event.preventDefault();
            this.isContextLost = true;
            // Canvas context lost
        });

        this.canvas.addEventListener('webglcontextrestored', () => {
            this.isContextLost = false;
            this.context = this.canvas.getContext('2d');
            // Canvas context restored
            
            // Execute recovery callbacks
            this.recoveryCallbacks.forEach(callback => {
                try {
                    callback(this.context);
                } catch (error) {
                    // Context recovery callback failed
                }
            });
        });
    }

    /**
     * Get the canvas context with recovery handling
     * @returns {CanvasRenderingContext2D|null} Canvas context or null if lost
     */
    getContext() {
        if (this.isContextLost) {
            return null;
        }

        if (!this.context) {
            try {
                this.context = this.canvas.getContext('2d');
            } catch (error) {
                // Failed to get canvas context
                return null;
            }
        }

        return this.context;
    }

    /**
     * Add a callback to execute when context is recovered
     * @param {Function} callback - Recovery callback
     */
    onRecovery(callback) {
        this.recoveryCallbacks.push(callback);
    }

    /**
     * Check if context is currently lost
     * @returns {boolean} True if context is lost
     */
    isLost() {
        return this.isContextLost;
    }

    /**
     * Attempt to recover the context manually
     * @returns {boolean} True if recovery was successful
     */
    recover() {
        if (!this.isContextLost) {
            return true;
        }

        try {
            this.context = this.canvas.getContext('2d');
            if (this.context) {
                this.isContextLost = false;
                return true;
            }
        } catch (error) {
            // Manual context recovery failed
        }

        return false;
    }
}

/**
 * Browser-specific optimization manager
 */
class BrowserOptimizations {
    constructor() {
        // Cache browser detection
        if (BrowserOptimizations._cachedBrowser) {
            this.browser = BrowserOptimizations._cachedBrowser;
            this.optimizations = BrowserOptimizations._cachedOptimizations;
            return;
        }
        
        this.browser = this.detectBrowser();
        this.optimizations = new Map();
        this.setupOptimizations();
        
        // Cache for future instances
        BrowserOptimizations._cachedBrowser = this.browser;
        BrowserOptimizations._cachedOptimizations = this.optimizations;
    }

    /**
     * Detect the current browser
     * @returns {Object} Browser information
     */
    detectBrowser() {
        const userAgent = navigator.userAgent;
        
        let name = 'unknown';
        let version = 'unknown';
        
        if (userAgent.includes('Chrome')) {
            name = 'chrome';
            const match = userAgent.match(/Chrome\/(\d+)/);
            version = match ? match[1] : 'unknown';
        } else if (userAgent.includes('Firefox')) {
            name = 'firefox';
            const match = userAgent.match(/Firefox\/(\d+)/);
            version = match ? match[1] : 'unknown';
        } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
            name = 'safari';
            const match = userAgent.match(/Version\/(\d+)/);
            version = match ? match[1] : 'unknown';
        } else if (userAgent.includes('Edge')) {
            name = 'edge';
            const match = userAgent.match(/Edge\/(\d+)/);
            version = match ? match[1] : 'unknown';
        }

        return { name, version, userAgent };
    }

    /**
     * Set up browser-specific optimizations
     */
    setupOptimizations() {
        // Chrome optimizations
        this.optimizations.set('chrome', {
            preferredAnimationMethod: 'requestAnimationFrame',
            audioContextOptions: { latencyHint: 'interactive' },
            canvasOptimizations: ['willReadFrequently'],
            particleLimit: 50
        });

        // Firefox optimizations
        this.optimizations.set('firefox', {
            preferredAnimationMethod: 'requestAnimationFrame',
            audioContextOptions: { latencyHint: 'balanced' },
            canvasOptimizations: [],
            particleLimit: 40
        });

        // Safari optimizations
        this.optimizations.set('safari', {
            preferredAnimationMethod: 'requestAnimationFrame',
            audioContextOptions: { latencyHint: 'playback' },
            canvasOptimizations: [],
            particleLimit: 30
        });

        // Edge optimizations
        this.optimizations.set('edge', {
            preferredAnimationMethod: 'requestAnimationFrame',
            audioContextOptions: { latencyHint: 'interactive' },
            canvasOptimizations: ['willReadFrequently'],
            particleLimit: 45
        });
    }

    /**
     * Get optimizations for the current browser
     * @returns {Object} Browser-specific optimizations
     */
    getOptimizations() {
        return this.optimizations.get(this.browser.name) || this.optimizations.get('chrome');
    }

    /**
     * Get browser information
     * @returns {Object} Browser information
     */
    getBrowser() {
        return { ...this.browser };
    }

    /**
     * Apply canvas optimizations
     * @param {HTMLCanvasElement} canvas - Canvas element
     * @param {CanvasRenderingContext2D} context - Canvas context
     */
    applyCanvasOptimizations(canvas, context) {
        const opts = this.getOptimizations();
        
        if (opts.canvasOptimizations.includes('willReadFrequently')) {
            try {
                // Re-get context with optimization hint
                canvas.getContext('2d', { willReadFrequently: true });
            } catch (error) {
                // Failed to apply canvas optimization
            }
        }
    }

    /**
     * Get recommended particle limit for current browser
     * @returns {number} Recommended particle limit
     */
    getRecommendedParticleLimit() {
        return this.getOptimizations().particleLimit;
    }

    /**
     * Get audio context options for current browser
     * @returns {Object} Audio context options
     */
    getAudioContextOptions() {
        return this.getOptimizations().audioContextOptions;
    }
}

/**
 * Initialize all polyfills and compatibility features
 * @returns {Object} Initialization results
 */
let _initializationCache = null;

function initializeBrowserCompatibility() {
    // Return cached result if already initialized
    if (_initializationCache) {
        return _initializationCache;
    }
    
    const featureDetection = new FeatureDetection();
    const polyfillManager = new PolyfillManager();
    const browserOptimizations = new BrowserOptimizations();

    // Register polyfills
    polyfillManager.register('requestAnimationFrame', polyfillRequestAnimationFrame);
    polyfillManager.register('performanceNow', polyfillPerformanceNow);
    polyfillManager.register('webAudio', polyfillWebAudio);

    // Apply necessary polyfills based on feature detection
    const appliedPolyfills = [];
    
    if (!featureDetection.features.requestAnimationFrame) {
        if (polyfillManager.apply('requestAnimationFrame')) {
            appliedPolyfills.push('requestAnimationFrame');
        }
    }
    
    if (!featureDetection.features.performance) {
        if (polyfillManager.apply('performanceNow')) {
            appliedPolyfills.push('performanceNow');
        }
    }
    
    if (!featureDetection.features.webAudio) {
        if (polyfillManager.apply('webAudio')) {
            appliedPolyfills.push('webAudio');
        }
    }

    // Cache the result
    _initializationCache = {
        featureDetection,
        polyfillManager,
        browserOptimizations,
        appliedPolyfills,
        capabilities: featureDetection.getCapabilities(),
        browser: browserOptimizations.getBrowser()
    };
    
    return _initializationCache;
}

// Create singleton instance lazily
let _browserCompatibilityInstance = null;

function getBrowserCompatibility() {
    if (!_browserCompatibilityInstance) {
        _browserCompatibilityInstance = initializeBrowserCompatibility();
    }
    return _browserCompatibilityInstance;
}

// Export getter for backward compatibility
const browserCompatibility = getBrowserCompatibility();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  DEBUGGER  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Debugger - Enhanced Logging & Performance Profiling
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module Debugger
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The DIAGNOSTIC CENTER of the engine. Provides comprehensive debugging tools,      
 * ║ performance profiling, memory tracking, and runtime diagnostics to ensure         
 * ║ smooth operation and help developers optimize their implementations.              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🐛 DEBUG FEATURES                                                                 
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Multi-level logging (NONE, ERROR, WARN, INFO, DEBUG, TRACE)                     
 * │ • Performance profiling with timing metrics                                       
 * │ • Memory usage tracking and leak detection                                        
 * │ • Error tracking and stack trace capture                                          
 * │ • Runtime capability detection                                                    
 * │ • Visual debugging overlays                                                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Debug levels for controlling log output
 */
const DebugLevel = {
    NONE: 0,
    ERROR: 1,
    WARN: 2,
    INFO: 3,
    DEBUG: 4,
    TRACE: 5
};

/**
 * Enhanced debugger with performance profiling and error tracking
 */
class EmotiveDebugger {
    constructor(config = {}) {
        this.config = {
            enabled: config.enabled !== false,
            level: config.level || DebugLevel.INFO,
            enableProfiling: config.enableProfiling !== false,
            enableErrorTracking: config.enableErrorTracking !== false,
            enableMemoryTracking: config.enableMemoryTracking !== false,
            maxLogEntries: config.maxLogEntries || 1000,
            maxProfileEntries: config.maxProfileEntries || 500,
            ...config
        };

        // Log storage
        this.logs = [];
        this.errors = [];
        this.profiles = new Map();
        this.memorySnapshots = [];
        
        // Performance tracking
        this.frameTimings = [];
        this.maxFrameTimings = 120; // 2 seconds at 60fps
        
        // Error tracking
        this.errorCounts = new Map();
        this.lastErrors = new Map();
        
        // Feature detection for debugging capabilities
        this.capabilities = {
            performance: typeof performance !== 'undefined' && performance.now,
            memory: typeof performance !== 'undefined' && performance.memory,
            console: typeof console !== 'undefined',
            stackTrace: typeof Error !== 'undefined'
        };

        // Initialize
        this.startTime = this.now();
        this.setupErrorHandling();
        
        if (this.config.enabled) {
            this.log('DEBUG', 'EmotiveDebugger initialized', {
                config: this.config,
                capabilities: this.capabilities
            });
        }
    }

    /**
     * Get current high-resolution timestamp
     * @returns {number} Timestamp in milliseconds
     */
    now() {
        if (this.capabilities.performance) {
            return performance.now();
        }
        return Date.now() - this.startTime;
    }

    /**
     * Set up global error handling
     */
    setupErrorHandling() {
        if (!this.config.enableErrorTracking || typeof window === 'undefined') {
            return;
        }

        // Capture unhandled errors
        window.addEventListener('error', (event) => {
            this.trackError('UNHANDLED_ERROR', event.error || new Error(event.message), {
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });

        // Capture unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            this.trackError('UNHANDLED_REJECTION', event.reason, {
                promise: event.promise
            });
        });
    }

    /**
     * Log a message with specified level
     * @param {string} level - Log level
     * @param {string} message - Log message
     * @param {*} data - Additional data
     */
    log(level, message, data = null) {
        if (!this.config.enabled) return;

        const levelValue = DebugLevel[level] || DebugLevel.INFO;
        if (levelValue > this.config.level) return;

        const timestamp = this.now();
        const logEntry = {
            timestamp,
            level,
            message,
            data,
            stackTrace: this.getStackTrace()
        };

        // Store log entry
        this.logs.push(logEntry);
        if (this.logs.length > this.config.maxLogEntries) {
            this.logs.shift();
        }

        // Console output
        if (this.capabilities.console) {
            const consoleMethod = this.getConsoleMethod(level);
            const timeStr = `[${(timestamp / 1000).toFixed(3)}s]`;
            
            if (data) {
                consoleMethod(`${timeStr} [${level}] ${message}`, data);
            } else {
                consoleMethod(`${timeStr} [${level}] ${message}`);
            }
        }
    }

    /**
     * Get appropriate console method for log level
     * @param {string} level - Log level
     * @returns {Function} Console method
     */
    getConsoleMethod(level) {
        switch (level) {
            case 'ERROR': return (() => {}).bind(console);
            case 'WARN': return (() => {}).bind(console);
            case 'DEBUG': return (() => {}).bind(console);
            case 'TRACE': return (() => {}).bind(console);
            default: return (() => {}).bind(console);
        }
    }

    /**
     * Get current stack trace
     * @returns {string|null} Stack trace or null if not available
     */
    getStackTrace() {
        if (!this.capabilities.stackTrace) return null;
        
        try {
            throw new Error();
        } catch (e) {
            return e.stack;
        }
    }

    /**
     * Track an error with context
     * @param {string} type - Error type
     * @param {Error} error - Error object
     * @param {Object} context - Additional context
     */
    trackError(type, error, context = {}) {
        if (!this.config.enableErrorTracking) return;

        const timestamp = this.now();
        const errorEntry = {
            timestamp,
            type,
            message: error.message || String(error),
            stack: error.stack,
            context,
            count: 1
        };

        // Update error counts
        const errorKey = `${type}:${error.message}`;
        if (this.errorCounts.has(errorKey)) {
            this.errorCounts.set(errorKey, this.errorCounts.get(errorKey) + 1);
            errorEntry.count = this.errorCounts.get(errorKey);
        } else {
            this.errorCounts.set(errorKey, 1);
        }

        // Store error
        this.errors.push(errorEntry);
        this.lastErrors.set(type, errorEntry);

        // Log error
        this.log('ERROR', `${type}: ${error.message}`, {
            error: errorEntry,
            context
        });
    }

    /**
     * Start profiling a named operation
     * @param {string} name - Profile name
     * @param {Object} metadata - Additional metadata
     */
    startProfile(name, metadata = {}) {
        if (!this.config.enableProfiling) return;

        const profile = {
            name,
            startTime: this.now(),
            metadata,
            samples: [],
            isActive: true
        };

        this.profiles.set(name, profile);
        this.log('TRACE', `Started profiling: ${name}`, metadata);
    }

    /**
     * Add a sample to an active profile
     * @param {string} name - Profile name
     * @param {string} label - Sample label
     * @param {*} data - Sample data
     */
    profileSample(name, label, data = null) {
        if (!this.config.enableProfiling) return;

        const profile = this.profiles.get(name);
        if (!profile || !profile.isActive) return;

        const sample = {
            timestamp: this.now(),
            label,
            data,
            relativeTime: this.now() - profile.startTime
        };

        profile.samples.push(sample);
    }

    /**
     * End profiling and get results
     * @param {string} name - Profile name
     * @returns {Object|null} Profile results or null if not found
     */
    endProfile(name) {
        if (!this.config.enableProfiling) return null;

        const profile = this.profiles.get(name);
        if (!profile || !profile.isActive) return null;

        profile.endTime = this.now();
        profile.duration = profile.endTime - profile.startTime;
        profile.isActive = false;

        // Calculate statistics
        profile.stats = this.calculateProfileStats(profile);

        this.log('TRACE', `Ended profiling: ${name}`, {
            duration: profile.duration,
            samples: profile.samples.length,
            stats: profile.stats
        });

        // Limit stored profiles
        if (this.profiles.size > this.config.maxProfileEntries) {
            const oldestKey = this.profiles.keys().next().value;
            this.profiles.delete(oldestKey);
        }

        return { ...profile };
    }

    /**
     * Calculate statistics for a profile
     * @param {Object} profile - Profile data
     * @returns {Object} Profile statistics
     */
    calculateProfileStats(profile) {
        if (profile.samples.length === 0) {
            return { sampleCount: 0 };
        }

        const durations = [];
        for (let i = 1; i < profile.samples.length; i++) {
            durations.push(profile.samples[i].relativeTime - profile.samples[i - 1].relativeTime);
        }

        if (durations.length === 0) {
            return { sampleCount: profile.samples.length };
        }

        const sum = durations.reduce((a, b) => a + b, 0);
        const avg = sum / durations.length;
        const min = Math.min(...durations);
        const max = Math.max(...durations);

        return {
            sampleCount: profile.samples.length,
            avgSampleDuration: avg,
            minSampleDuration: min,
            maxSampleDuration: max,
            totalDuration: profile.duration
        };
    }

    /**
     * Track frame timing for performance analysis
     * @param {number} frameTime - Frame time in milliseconds
     */
    trackFrameTiming(frameTime) {
        if (!this.config.enableProfiling) return;

        this.frameTimings.push({
            timestamp: this.now(),
            frameTime,
            fps: 1000 / frameTime
        });

        if (this.frameTimings.length > this.maxFrameTimings) {
            this.frameTimings.shift();
        }
    }

    /**
     * Take a memory snapshot (if supported)
     * @param {string} label - Snapshot label
     */
    takeMemorySnapshot(label = 'snapshot') {
        if (!this.config.enableMemoryTracking || !this.capabilities.memory) return;

        const snapshot = {
            timestamp: this.now(),
            label,
            memory: {
                usedJSHeapSize: performance.memory.usedJSHeapSize,
                totalJSHeapSize: performance.memory.totalJSHeapSize,
                jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
            }
        };

        this.memorySnapshots.push(snapshot);
        
        // Limit snapshots
        if (this.memorySnapshots.length > 100) {
            this.memorySnapshots.shift();
        }

        this.log('DEBUG', `Memory snapshot: ${label}`, snapshot.memory);
    }

    /**
     * Get comprehensive debug report
     * @returns {Object} Debug report
     */
    getDebugReport() {
        const report = {
            timestamp: this.now(),
            uptime: this.now() - 0,
            config: this.config,
            capabilities: this.capabilities,
            
            // Logs
            logCount: this.logs.length,
            recentLogs: this.logs.slice(-10),
            
            // Errors
            errorCount: this.errors.length,
            uniqueErrors: this.errorCounts.size,
            recentErrors: this.errors.slice(-5),
            errorCounts: Object.fromEntries(this.errorCounts),
            
            // Profiles
            activeProfiles: Array.from(this.profiles.values()).filter(p => p.isActive).length,
            completedProfiles: Array.from(this.profiles.values()).filter(p => !p.isActive).length,
            
            // Performance
            frameTimings: this.getFrameTimingStats(),
            
            // Memory
            memorySnapshots: this.memorySnapshots.slice(-5)
        };

        return report;
    }

    /**
     * Get frame timing statistics
     * @returns {Object} Frame timing stats
     */
    getFrameTimingStats() {
        if (this.frameTimings.length === 0) {
            return { sampleCount: 0 };
        }

        const frameTimes = this.frameTimings.map(f => f.frameTime);
        const fps = this.frameTimings.map(f => f.fps);

        return {
            sampleCount: this.frameTimings.length,
            avgFrameTime: frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length,
            minFrameTime: Math.min(...frameTimes),
            maxFrameTime: Math.max(...frameTimes),
            avgFPS: fps.reduce((a, b) => a + b, 0) / fps.length,
            minFPS: Math.min(...fps),
            maxFPS: Math.max(...fps)
        };
    }

    /**
     * Export debug data for external analysis
     * @returns {Object} Exportable debug data
     */
    exportDebugData() {
        return {
            metadata: {
                exportTime: Date.now(),
                debuggerUptime: this.now(),
                config: this.config,
                capabilities: this.capabilities
            },
            logs: [...this.logs],
            errors: [...this.errors],
            profiles: Object.fromEntries(this.profiles),
            frameTimings: [...this.frameTimings],
            memorySnapshots: [...this.memorySnapshots],
            errorCounts: Object.fromEntries(this.errorCounts)
        };
    }

    /**
     * Clear all debug data
     */
    clear() {
        this.logs = [];
        this.errors = [];
        this.profiles.clear();
        this.frameTimings = [];
        this.memorySnapshots = [];
        this.errorCounts.clear();
        this.lastErrors.clear();
        
        this.log('INFO', 'Debug data cleared');
    }

    /**
     * Destroy the debugger and clean up
     */
    destroy() {
        this.clear();
        this.config.enabled = false;
    }
}

/**
 * Runtime feature detection and capability reporting
 */
class RuntimeCapabilities {
    constructor() {
        this.capabilities = this.detectCapabilities();
        this.performance = this.measurePerformance();
    }

    /**
     * Detect runtime capabilities
     * @returns {Object} Capability detection results
     */
    detectCapabilities() {
        const caps = {
            // JavaScript features
            es6: this.detectES6(),
            es2017: this.detectES2017(),
            modules: this.detectModules(),
            
            // Browser APIs
            webGL: this.detectWebGL(),
            webGL2: this.detectWebGL2(),
            webWorkers: this.detectWebWorkers(),
            serviceWorkers: this.detectServiceWorkers(),
            
            // Performance APIs
            performanceObserver: this.detectPerformanceObserver(),
            intersectionObserver: this.detectIntersectionObserver(),
            resizeObserver: this.detectResizeObserver(),
            
            // Storage
            localStorage: this.detectLocalStorage(),
            sessionStorage: this.detectSessionStorage(),
            indexedDB: this.detectIndexedDB(),
            
            // Network
            fetch: this.detectFetch(),
            webSockets: this.detectWebSockets(),
            
            // Device capabilities
            touchEvents: this.detectTouchEvents(),
            pointerEvents: this.detectPointerEvents(),
            deviceOrientation: this.detectDeviceOrientation(),
            
            // Graphics
            canvas2d: this.detectCanvas2D(),
            canvasFilters: this.detectCanvasFilters(),
            offscreenCanvas: this.detectOffscreenCanvas()
        };

        return caps;
    }

    detectES6() {
        try {
            // Check for arrow functions and classes without eval
            return typeof Symbol !== 'undefined' && 
                   typeof Promise !== 'undefined' && 
                   typeof Map !== 'undefined' && 
                   typeof Set !== 'undefined';
        } catch (e) {
            return false;
        }
    }

    detectES2017() {
        try {
            // Check for async/await support
            return typeof async !== 'undefined' || 
                   (function() { 
                       try { 
                           return Function('return async function(){}')().constructor.name === 'AsyncFunction'; 
                       } catch(e) { 
                           return false; 
                       } 
                   })();
        } catch (e) {
            return false;
        }
    }

    detectModules() {
        try {
            return typeof document !== 'undefined' && 'noModule' in document.createElement('script');
        } catch (e) {
            return false;
        }
    }

    detectWebGL() {
        try {
            const canvas = document.createElement('canvas');
            return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
        } catch (e) {
            return false;
        }
    }

    detectWebGL2() {
        try {
            const canvas = document.createElement('canvas');
            return !!canvas.getContext('webgl2');
        } catch (e) {
            return false;
        }
    }

    detectWebWorkers() {
        return typeof Worker !== 'undefined';
    }

    detectServiceWorkers() {
        return 'serviceWorker' in navigator;
    }

    detectPerformanceObserver() {
        return typeof PerformanceObserver !== 'undefined';
    }

    detectIntersectionObserver() {
        return typeof IntersectionObserver !== 'undefined';
    }

    detectResizeObserver() {
        return typeof ResizeObserver !== 'undefined';
    }

    detectLocalStorage() {
        try {
            return typeof localStorage !== 'undefined' && localStorage !== null;
        } catch (e) {
            return false;
        }
    }

    detectSessionStorage() {
        try {
            return typeof sessionStorage !== 'undefined' && sessionStorage !== null;
        } catch (e) {
            return false;
        }
    }

    detectIndexedDB() {
        return typeof indexedDB !== 'undefined';
    }

    detectFetch() {
        return typeof fetch !== 'undefined';
    }

    detectWebSockets() {
        return typeof WebSocket !== 'undefined';
    }

    detectTouchEvents() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }

    detectPointerEvents() {
        return typeof PointerEvent !== 'undefined';
    }

    detectDeviceOrientation() {
        return 'ondeviceorientation' in window;
    }

    detectCanvas2D() {
        try {
            const canvas = document.createElement('canvas');
            return !!canvas.getContext('2d');
        } catch (e) {
            return false;
        }
    }

    detectCanvasFilters() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            return 'filter' in ctx;
        } catch (e) {
            return false;
        }
    }

    detectOffscreenCanvas() {
        return typeof OffscreenCanvas !== 'undefined';
    }

    /**
     * Measure basic performance characteristics
     * @returns {Object} Performance measurements
     */
    measurePerformance() {
        const measurements = {};

        // Measure JavaScript execution speed
        const start = performance.now();
        measurements.jsExecutionSpeed = performance.now() - start;

        // Measure canvas performance
        try {
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            
            const canvasStart = performance.now();
            for (let i = 0; i < 1000; i++) {
                ctx.fillRect(Math.random() * 100, Math.random() * 100, 10, 10);
            }
            measurements.canvasPerformance = performance.now() - canvasStart;
        } catch (e) {
            measurements.canvasPerformance = null;
        }

        return measurements;
    }

    /**
     * Get all capabilities
     * @returns {Object} All detected capabilities
     */
    getCapabilities() {
        return { ...this.capabilities };
    }

    /**
     * Get performance measurements
     * @returns {Object} Performance measurements
     */
    getPerformance() {
        return { ...this.performance };
    }

    /**
     * Generate capability report
     * @returns {Object} Comprehensive capability report
     */
    generateReport() {
        const supportedFeatures = Object.entries(this.capabilities)
            .filter(([, supported]) => supported)
            .map(([feature]) => feature);

        const unsupportedFeatures = Object.entries(this.capabilities)
            .filter(([, supported]) => !supported)
            .map(([feature]) => feature);

        const supportPercentage = (supportedFeatures.length / Object.keys(this.capabilities).length) * 100;

        return {
            timestamp: Date.now(),
            userAgent: navigator.userAgent,
            supportedFeatures,
            unsupportedFeatures,
            supportPercentage: Math.round(supportPercentage),
            performance: this.performance,
            recommendations: this.generateRecommendations(supportPercentage)
        };
    }

    /**
     * Generate recommendations based on capabilities
     * @param {number} supportPercentage - Percentage of supported features
     * @returns {Array<string>} Recommendations
     */
    generateRecommendations(supportPercentage) {
        const recommendations = [];

        if (supportPercentage < 50) {
            recommendations.push('Consider using the minimal build for better compatibility');
        }

        if (!this.capabilities.webGL) {
            recommendations.push('WebGL not supported - advanced graphics features unavailable');
        }

        if (!this.capabilities.webWorkers) {
            recommendations.push('Web Workers not supported - background processing unavailable');
        }

        if (!this.capabilities.fetch) {
            recommendations.push('Fetch API not supported - consider using XMLHttpRequest polyfill');
        }

        if (this.performance.jsExecutionSpeed > 50) {
            recommendations.push('Slow JavaScript execution detected - consider performance optimizations');
        }

        if (this.performance.canvasPerformance > 100) {
            recommendations.push('Slow canvas performance detected - consider reducing visual complexity');
        }

        return recommendations;
    }
}

// Create singleton instances for convenience
const emotiveDebugger = new EmotiveDebugger({
    enabled: typeof window !== 'undefined' && window.location && window.location.search.includes('debug=true'),
    level: DebugLevel.INFO
});

const runtimeCapabilities = new RuntimeCapabilities();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Shape Definitions
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Static shape definitions for immediate loading
 * @author Emotive Engine Team
 * @module shapes/shapeDefinitions
 */

/**
 * Generate circle points
 */
function generateCircle(numPoints) {
    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * Math.PI * 2;
        points.push({
            x: 0.5 + Math.cos(angle) * 0.5,
            y: 0.5 + Math.sin(angle) * 0.5
        });
    }
    return points;
}

/**
 * Generate heart shape
 */
function generateHeart(numPoints) {
    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const t = (i / numPoints) * Math.PI * 2;

        // Heart parametric equations
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) -
                  2 * Math.cos(3 * t) - Math.cos(4 * t));

        // Normalize and scale
        points.push({
            x: 0.5 + x / 32,
            y: 0.5 + y / 32
        });
    }
    return points;
}

/**
 * Generate moon shape - keep it as a circle
 * The crescent effect should be done with visual shadows, not shape morphing
 */
function generateMoon(numPoints) {
    // Moon should stay as a circle - the crescent is a visual effect
    return generateCircle(numPoints);
}

/**
 * Generate star shape - proper 5-pointed star
 */
function generateStar(numPoints, starPoints = 5) {
    const points = [];
    const outerRadius = 0.5;
    const innerRadius = outerRadius * 0.382; // Golden ratio for perfect star
    
    // Generate the 10 vertices (5 outer, 5 inner)
    const vertices = [];
    const angleStep = (Math.PI * 2) / starPoints; // 72 degrees between star points
    const halfAngleStep = angleStep / 2; // 36 degrees offset for inner points
    
    for (let i = 0; i < starPoints; i++) {
        // Outer point (star tip)
        const outerAngle = (i * angleStep) - Math.PI / 2; // Start from top
        vertices.push({
            x: 0.5 + Math.cos(outerAngle) * outerRadius,
            y: 0.5 + Math.sin(outerAngle) * outerRadius
        });
        
        // Inner point (valley) - offset by half the angle
        const innerAngle = outerAngle + halfAngleStep;
        vertices.push({
            x: 0.5 + Math.cos(innerAngle) * innerRadius,
            y: 0.5 + Math.sin(innerAngle) * innerRadius
        });
    }
    
    // Now interpolate points along the star perimeter
    for (let i = 0; i < numPoints; i++) {
        const t = i / numPoints;
        const vertexCount = vertices.length;
        
        // Which edge are we on?
        const edgeFloat = t * vertexCount;
        const edgeIndex = Math.floor(edgeFloat) % vertexCount;
        const nextIndex = (edgeIndex + 1) % vertexCount;
        const edgeProgress = edgeFloat - Math.floor(edgeFloat);
        
        // Linear interpolation between vertices
        const v1 = vertices[edgeIndex];
        const v2 = vertices[nextIndex];
        
        points.push({
            x: v1.x + (v2.x - v1.x) * edgeProgress,
            y: v1.y + (v2.y - v1.y) * edgeProgress
        });
    }
    
    return points;
}

/**
 * Generate sun shape - just a circle, rays are visual effects only
 */
function generateSun(numPoints, numRays = 12) {
    // Sun is just a circle - the rays are rendered as effects, not part of the shape
    return generateCircle(numPoints);
}


/**
 * Generate suspicion shape (sly grin)
 */
function generateSuspicion(numPoints) {
    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const t = (i / numPoints) * Math.PI * 2;
        
        let x, y;
        if (t < Math.PI) {
            // Right side - outer arc of the grin
            x = Math.cos(t) * 0.45;
            y = Math.sin(t) * 0.45;
        } else {
            // Left side - inner arc for the mischievous smile
            const innerT = Math.PI * 2 - t;
            x = Math.cos(innerT) * 0.25 - 0.1;
            y = Math.sin(innerT) * 0.35;
        }
        
        points.push({
            x: 0.5 + x,
            y: 0.5 + y
        });
    }
    return points;
}

/**
 * Generate square shape
 */
function generateSquare(numPoints) {
    const points = [];
    const pointsPerSide = Math.floor(numPoints / 4);
    
    for (let side = 0; side < 4; side++) {
        for (let i = 0; i < pointsPerSide; i++) {
            const t = i / pointsPerSide;
            let x, y;
            
            switch (side) {
                case 0: // Top
                    x = -0.5 + t;
                    y = -0.5;
                    break;
                case 1: // Right
                    x = 0.5;
                    y = -0.5 + t;
                    break;
                case 2: // Bottom
                    x = 0.5 - t;
                    y = 0.5;
                    break;
                case 3: // Left
                    x = -0.5;
                    y = 0.5 - t;
                    break;
            }
            
            points.push({
                x: 0.5 + x * 0.8,
                y: 0.5 + y * 0.8
            });
        }
    }
    return points;
}

/**
 * Generate triangle shape
 */
function generateTriangle(numPoints) {
    const points = [];
    
    const vertices = [
        { x: 0, y: -0.5 },           // Top
        { x: -0.433, y: 0.25 },      // Bottom left
        { x: 0.433, y: 0.25 }        // Bottom right
    ];
    
    // Calculate perimeter of triangle
    const sides = [
        Math.sqrt(Math.pow(vertices[1].x - vertices[0].x, 2) + Math.pow(vertices[1].y - vertices[0].y, 2)),
        Math.sqrt(Math.pow(vertices[2].x - vertices[1].x, 2) + Math.pow(vertices[2].y - vertices[1].y, 2)),
        Math.sqrt(Math.pow(vertices[0].x - vertices[2].x, 2) + Math.pow(vertices[0].y - vertices[2].y, 2))
    ];
    const perimeter = sides[0] + sides[1] + sides[2];
    
    // Distribute points based on side length
    const pointsPerSide = sides.map(s => Math.round(numPoints * s / perimeter));
    
    // Adjust for rounding errors
    const totalPoints = pointsPerSide.reduce((a, b) => a + b, 0);
    if (totalPoints < numPoints) {
        pointsPerSide[0] += numPoints - totalPoints;
    }
    
    // Generate points along each edge
    for (let side = 0; side < 3; side++) {
        const v1 = vertices[side];
        const v2 = vertices[(side + 1) % 3];
        const sidePoints = pointsPerSide[side];
        
        for (let i = 0; i < sidePoints; i++) {
            // Don't duplicate the corner point
            if (i === sidePoints - 1 && side < 2) continue;
            
            const t = i / sidePoints;
            const x = v1.x + (v2.x - v1.x) * t;
            const y = v1.y + (v2.y - v1.y) * t;
            
            points.push({
                x: 0.5 + x * 0.9,
                y: 0.5 + y * 0.9
            });
        }
    }
    
    // Ensure we have exactly numPoints
    while (points.length < numPoints) {
        points.push(points[points.length - 1]);
    }
    while (points.length > numPoints) {
        points.pop();
    }
    
    return points;
}

/**
 * Shape definitions with their properties
 */
const SHAPE_DEFINITIONS = {
    circle: {
        points: generateCircle(64),
        shadow: { type: 'none' }
    },
    heart: {
        points: generateHeart(64),
        shadow: { type: 'none' }
    },
    star: {
        points: generateStar(64, 5),
        shadow: { type: 'none' }
    },
    sun: {
        points: generateSun(64, 12),
        shadow: {
            type: 'sun',
            corona: true,
            intensity: 1.5,
            flares: true,
            texture: true,
            turbulence: 0.3
        }
    },
    moon: {
        points: generateMoon(64),
        shadow: {
            type: 'crescent',
            coverage: 0.85,
            angle: -30,
            softness: 0.05,
            offset: 0.7
        }
    },
    lunar: {
        points: generateCircle(64),
        shadow: {
            type: 'lunar',
            coverage: 0.7,
            color: 'rgba(80, 20, 0, 0.8)',
            progression: 'center'
        }
    },
    suspicion: {
        points: generateSuspicion(64),
        shadow: { type: 'none' }
    },
    eclipse: {
        points: generateCircle(64),
        shadow: {
            type: 'lunar',
            coverage: 0.7,
            color: 'rgba(80, 20, 0, 0.8)'
        }
    },
    square: {
        points: generateSquare(64),
        shadow: { type: 'none' }
    },
    triangle: {
        points: generateTriangle(64),
        shadow: { type: 'none' }
    },
    solar: {
        points: generateSun(64, 12),
        shadow: {
            type: 'solar-hybrid',
            // Sun properties (rendered first)
            corona: true,
            intensity: 1.5,
            flares: true,
            texture: true,
            turbulence: 0.3,
            // Lunar shadow overlay (rendered on top) - BLACK for solar eclipse
            lunarOverlay: {
                type: 'lunar',
                coverage: 1.0,  // Full coverage for total eclipse
                color: 'rgba(0, 0, 0, 1.0)',  // Pure black shadow
                progression: 'center'
            }
        }
    }
};

/**
 * ArrayPool - Reusable array pool to reduce garbage collection
 * @module ArrayPool
 */

class ArrayPool {
    constructor() {
        this.pools = new Map(); // Key: size, Value: array of available arrays
        this.inUse = new Set(); // Track arrays currently in use
    }

    /**
     * Get an array from the pool or create a new one
     * @param {number} size - Size of array needed
     * @param {string} type - Type of array ('float32', 'array', 'uint8')
     * @returns {Array|Float32Array|Uint8Array}
     */
    acquire(size, type = 'array') {
        const key = `${type}_${size}`;
        
        if (!this.pools.has(key)) {
            this.pools.set(key, []);
        }
        
        const pool = this.pools.get(key);
        
        // Try to get from pool
        if (pool.length > 0) {
            const array = pool.pop();
            this.inUse.add(array);
            return array;
        }
        
        // Create new array if pool is empty
        let newArray;
        switch (type) {
            case 'float32':
                newArray = new Float32Array(size);
                break;
            case 'uint8':
                newArray = new Uint8Array(size);
                break;
            default:
                newArray = new Array(size).fill(0);
        }
        
        this.inUse.add(newArray);
        return newArray;
    }

    /**
     * Return an array to the pool
     * @param {Array|Float32Array|Uint8Array} array - Array to return
     */
    release(array) {
        if (!this.inUse.has(array)) {
            return; // Not from this pool
        }
        
        this.inUse.delete(array);
        
        // Determine type and size
        let type = 'array';
        if (array instanceof Float32Array) type = 'float32';
        else if (array instanceof Uint8Array) type = 'uint8';
        
        const size = array.length;
        const key = `${type}_${size}`;
        
        // Clear the array
        if (type === 'array') {
            array.fill(0);
        } else {
            array.fill(0);
        }
        
        // Return to pool
        if (!this.pools.has(key)) {
            this.pools.set(key, []);
        }
        
        const pool = this.pools.get(key);
        if (pool.length < 10) { // Keep max 10 arrays of each size
            pool.push(array);
        }
    }

    /**
     * Clear all pools
     */
    clear() {
        this.pools.clear();
        this.inUse.clear();
    }
}

// Create singleton instance
const arrayPool = new ArrayPool();

/**
 * AudioDeformer - Handles audio-based shape deformation
 * @module core/morpher/AudioDeformer
 */

class AudioDeformer {
    constructor(morpher) {
        this.morpher = morpher;
        
        // Audio deformation state
        this.audioDeformation = 0;
        this.vocalEnergy = 0;
        this.vocalEffectActive = false;
        this.beatGlitchIntensity = 0;
        this.glitchPoints = [];
        
        // Frequency analysis
        this.bassEnergy = 0;
        this.vocalPresence = 0;
        this.highFreqEnergy = 0;
        
        // Transient detection
        this.transientActive = false;
        this.transientStrength = 0;
        this.transientDecay = 0.92;
        this.transientHoldTime = 8;
        this.transientHoldCounter = 0;
    }

    /**
     * Apply audio deformation to shape points
     * @param {Array} points - Shape points to deform
     * @returns {Array} Deformed points
     */
    applyAudioDeformation(points) {
        // Validate points
        if (!points || points.length === 0) {
            return this.morpher.generateFallbackCircle();
        }
        
        // Get fresh frequency data if analyzer is available
        if (this.morpher.audioAnalyzer && this.morpher.audioAnalyzer.currentFrequencies && this.morpher.audioAnalyzer.currentFrequencies.length > 0) {
            this.morpher.frequencyData = [...this.morpher.audioAnalyzer.currentFrequencies];
            
            
            // We have 32 frequency bands (0-31) that cover the full spectrum
            // Approximate mapping: each band covers ~750 Hz (24000 Hz / 32 bands)
            // Band 0-1: Sub-bass
            // Band 2-4: Bass
            // Band 5-15: Midrange
            // Band 16-25: Upper mids/presence
            // Band 26-31: Treble
            
            // BASS THUMP DETECTION: Only trigger on meaty kicks
            let currentBassEnergy = 0;
            let bassCount = 0;
            
            // Focus on low bass (bands 0-2) for the real thumps
            for (let i = 0; i <= 2 && i < this.morpher.frequencyData.length; i++) {
                currentBassEnergy += this.morpher.frequencyData[i];
                bassCount++;
            }
            if (bassCount > 0) {
                currentBassEnergy /= bassCount;
            }
            
            // Initialize bass thump detection
            if (!this.morpher.bassPeakHistory) {
                this.morpher.bassPeakHistory = [];
                this.morpher.bassThumpTimer = 0;
            }
            
            // Track recent bass peaks
            this.morpher.bassPeakHistory.push(currentBassEnergy);
            if (this.morpher.bassPeakHistory.length > 20) { // ~0.6 seconds of history
                this.morpher.bassPeakHistory.shift();
            }
            
            // Calculate dynamic threshold
            const avgBass = this.morpher.bassPeakHistory.reduce((a, b) => a + b, 0) / this.morpher.bassPeakHistory.length;
            
            // THUMP = small increase above baseline
            // Check if we're using microphone (lower levels) or audio file (higher levels)
            const isMicrophoneMode = this.morpher.audioAnalyzer && this.morpher.audioAnalyzer.microphoneStream;
            const minThreshold = isMicrophoneMode ? 0.15 : 0.25; // Lower threshold for both, but mic is lowest
            
            const isThump = currentBassEnergy > avgBass * 1.08 && // Just 8% above average
                           currentBassEnergy > minThreshold;
            
            if (isThump) {
                // Boost the effect more for microphone input
                const effectMultiplier = isMicrophoneMode ? 8 : 6; // Increase audio multiplier too
                this.bassEnergy = Math.min(1.0, (currentBassEnergy - avgBass) * effectMultiplier);
                this.morpher.bassThumpTimer = 12; // Shorter hold (12 frames ~0.4 seconds)
            } else if (this.morpher.bassThumpTimer > 0) {
                this.morpher.bassThumpTimer--;
                this.bassEnergy *= 0.9; // Slower decay for smooth wobble
            } else {
                this.bassEnergy = 0;
            }
            
            // SPECTRAL FLUX: Detect onsets in the VOCAL RANGE you identified (bands 4-15, emphasis on 11)
            // This targets the actual vocal/lead frequencies in Electric Glow
            
            // Initialize spectral history if needed
            if (!this.morpher.spectralHistory) {
                this.morpher.spectralHistory = [];
                this.morpher.spectralFluxHistory = [];
                // Music detection initialization
                this.morpher.onsetThreshold = 0;
                this.morpher.musicDetector.reset();
                this.morpher.detectedBPM = 0;
                
                // Time signature detection
                this.morpher.onsetStrengths = []; // Array of {time: ms, strength: 0-1, bassWeight: 0-1}
                this.morpher.detectedTimeSignature = null;
                this.morpher.timeSignatureConfidence = 0;
                this.morpher.measureStartTime = 0;
                this.morpher.timeSignatureHistory = [];
                this.morpher.timeSignatureLocked = false;
            }
            
            // Store current spectrum
            const currentSpectrum = [...this.morpher.frequencyData];
            
            // SIMPLER APPROACH: Look for changes in vocal bands with bass rejection
            let spectralFlux = 0;
            let bassFlux = 0;
            
            if (this.morpher.spectralHistory.length > 0) {
                const prevSpectrum = this.morpher.spectralHistory[this.morpher.spectralHistory.length - 1];
                
                // Calculate bass flux (bands 0-2)
                for (let i = 0; i <= 2 && i < currentSpectrum.length; i++) {
                    const diff = currentSpectrum[i] - prevSpectrum[i];
                    if (diff > 0) bassFlux += diff;
                }
                
                // Calculate flux in extended vocal range (bands 4-15)
                // But weight the center (9-13) more heavily
                for (let i = 4; i <= 15 && i < currentSpectrum.length; i++) {
                    const diff = currentSpectrum[i] - prevSpectrum[i];
                    if (diff > 0) {
                        // Extra weight for bands 9-13
                        const weight = (i >= 9 && i <= 13) ? 2.0 : 1.0;
                        spectralFlux += diff * weight;
                    }
                }
                
                // Suppress if there's a strong bass hit (likely a drum)
                if (bassFlux > 0.15) {
                    spectralFlux *= 0.3; // Reduce by 70% for drum hits
                }
            }
            
            // Store history (keep last 30 frames for ~1 second at 30fps)
            this.morpher.spectralHistory.push(currentSpectrum);
            if (this.morpher.spectralHistory.length > 30) {
                this.morpher.spectralHistory.shift();
            }
            
            // Store flux history for adaptive thresholding
            this.morpher.spectralFluxHistory.push(spectralFlux);
            if (this.morpher.spectralFluxHistory.length > 30) {
                this.morpher.spectralFluxHistory.shift();
            }
            
            // Calculate adaptive threshold (median + margin)
            if (this.morpher.spectralFluxHistory.length >= 10) {
                const sorted = [...this.morpher.spectralFluxHistory].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                const mean = sorted.reduce((a, b) => a + b, 0) / sorted.length;
                
                // Threshold is slightly above the median to catch significant onsets
                this.morpher.onsetThreshold = median + (mean - median) * 0.5;
            }
            
            // Detect onset (transient/attack) - focus on stronger transients for BPM
            // Use higher threshold for BPM detection vs vocal detection
            const isVocalOnset = spectralFlux > this.morpher.onsetThreshold * 1.2 && spectralFlux > 0.02;
            const isBeatOnset = spectralFlux > this.morpher.onsetThreshold * 2.0 && spectralFlux > 0.05; // Stronger threshold for beats
            
            // Smooth the detection with a short hold time
            if (isVocalOnset) {
                this.transientHoldTime = 8; // Hold for 8 frames (~250ms) for visible glitches
                this.morpher.vocalGlowBoost = 0.3; // Add 30% glow boost on vocal onset
            }
            
            // BPM DETECTION: Only track stronger onsets that are likely beats
            if (isBeatOnset) {
                const now = performance.now();
                
                // Store onset strength for time signature detection
                const onsetStrength = {
                    time: now,
                    strength: spectralFlux / (this.morpher.onsetThreshold || 1), // Normalized strength
                    bassWeight: bassFlux // Keep bass weight for downbeat detection
                };
                this.morpher.onsetStrengths.push(onsetStrength);
                // Keep last 40 onsets (about 16-20 beats)
                if (this.morpher.onsetStrengths.length > 40) {
                    this.morpher.onsetStrengths.shift();
                }
                
                // Delegate onset tracking to music detector
                this.morpher.musicDetector.addOnset(now, spectralFlux);
                
            }
            
            // Update BPM detection through music detector
            this.morpher.musicDetector.update(performance.now());
            this.morpher.detectedBPM = this.morpher.musicDetector.detectedBPM;
            this.morpher.bpmConfidence = this.morpher.musicDetector.bpmConfidence;
            
            // Update local references for compatibility
            if (this.morpher.detectedBPM > 0 && this.morpher.bpmConfidence > 0.8) {
                // Clear fast mode once we've detected BPM with confidence
                if (this.morpher.forceFastDetection) {
                    this.morpher.forceFastDetection = false;
                }
            }
            
            if (this.transientHoldTime > 0) {
                this.transientHoldTime--;
            }
            
            // Decay glow boost smoothly
            if (this.morpher.vocalGlowBoost > 0) {
                this.morpher.vocalGlowBoost *= 0.92; // Smooth decay
            }
            
            // Set vocal presence based on flux intensity
            this.vocalPresence = spectralFlux;
            
            // Update rolling averages for smarter detection
            this.morpher.bassHistory[this.morpher.historyIndex] = this.bassEnergy;
            this.morpher.vocalHistory[this.morpher.historyIndex] = this.vocalPresence;
            this.morpher.historyIndex = (this.morpher.historyIndex + 1) % this.morpher.bassHistory.length;
            
            // Calculate averages
            this.morpher.bassHistory.reduce((a, b) => a + b, 0) / this.morpher.bassHistory.length;
            this.morpher.vocalHistory.reduce((a, b) => a + b, 0) / this.morpher.vocalHistory.length;
            
            // Bass effect is now controlled by thump detection above
            this.morpher.bassEffectActive = this.morpher.bassThumpTimer > 0;
            
            // ENHANCED VOCAL DETECTION
            // Vocals are present when:
            // 1. Bands 9-13 have high contrast vs background
            // 2. Energy is above minimum threshold
            // 3. Either sudden spike OR sustained presence
            
            this.morpher.lastVocalPresence = this.morpher.lastVocalPresence || 0;
            this.morpher.lastVocalPresence = this.vocalPresence;
            
            // Transient detection - triggers on musical onsets
            this.vocalEffectActive = this.transientHoldTime > 0;
            
        }
        
        // If no analyzer or no frequency data, fallback to using audioDeformation for effects
        // This is especially important for microphone input where bass frequencies might be weak
        const hasFrequencyData = this.morpher.frequencyData && this.morpher.frequencyData.some(f => f > 0.01);
        if (!this.morpher.audioAnalyzer || !hasFrequencyData) {
            // Enhanced fallback for microphone input
            // Use audioDeformation as a proxy for bass effect when no frequency data
            if (this.audioDeformation > 0.15) { // Lower threshold for mic sensitivity
                this.morpher.bassEffectActive = true;
                this.bassEnergy = Math.min(1.0, this.audioDeformation * 0.8); // Stronger response
                
                // Simulate bass thump timer for wobble effect
                if (!this.morpher.bassThumpTimer || this.morpher.bassThumpTimer <= 0) {
                    this.morpher.bassThumpTimer = 12; // Start wobble
                }
            } else if (this.morpher.bassThumpTimer > 0) {
                // Decay the wobble
                this.morpher.bassThumpTimer--;
                this.bassEnergy *= 0.9;
            }
            
            // Use vocalEnergy for vocal effects
            if (this.vocalEnergy > 0.2) { // Lower threshold for mic
                this.vocalEffectActive = true;
                this.vocalPresence = this.vocalEnergy;
            }
        }
        
        // ONLY apply fallback bass wobble for microphone input when no frequency data
        // This ensures wobble works for mic but NOT for web audio
        if (!hasFrequencyData && this.audioDeformation > 0.15 && !this.morpher.bassEffectActive) {
            this.morpher.bassEffectActive = true;
            this.bassEnergy = Math.max(this.bassEnergy, this.audioDeformation * 0.8);
            if (!this.morpher.bassThumpTimer || this.morpher.bassThumpTimer <= 0) {
                this.morpher.bassThumpTimer = 12;
            }
        }
        
        // No deformation if no audio
        const hasAudio = this.audioDeformation !== 0 || this.bassEnergy > 0.01 || 
                        this.vocalPresence > 0.01;
        if (!hasAudio) {
            return points;
        }
        
        const deformed = [];
        const center = { x: 0.5, y: 0.5 };
        
        // Update undulation phase only when bass is active
        if (this.morpher.bassEffectActive) {
            // Randomly change direction occasionally
            if (Math.random() < 0.05) { // 5% chance per frame
                this.morpher.undulationDirection *= -1; // Reverse direction
            }
            this.morpher.undulationPhase += 0.08 * this.morpher.undulationDirection; // Apply direction
        }
        
        // Update glitch points on beat
        if (this.morpher.audioAnalyzer && this.beatGlitchIntensity > 0) {
            this.beatGlitchIntensity *= 0.9; // Decay glitch intensity
        }
        
        // Create SUBTLE glitch points when vocal presence is detected
        if (this.vocalEffectActive && Math.random() < 0.2) { // 20% chance (reduced)
            this.glitchPoints = [];
            const numGlitches = 2 + Math.floor(Math.random() * 2); // 2-3 points (fewer)
            for (let i = 0; i < numGlitches; i++) {
                this.glitchPoints.push({
                    index: Math.floor(Math.random() * points.length),
                    intensity: 0.02 + Math.random() * 0.03, // 0.02-0.05 intensity (much subtler)
                    decay: 0.94 + Math.random() * 0.02 // Slightly slower decay for smoothness
                });
            }
        }
        
        // Update existing glitch points
        this.glitchPoints = this.glitchPoints.filter(g => {
            g.intensity *= g.decay;
            return g.intensity > 0.01;
        });
        
        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            
            // Handle invalid point
            if (!point || typeof point.x === 'undefined' || typeof point.y === 'undefined') {
                const angle = (i / points.length) * Math.PI * 2;
                deformed.push({
                    x: 0.5 + Math.cos(angle) * 0.5,
                    y: 0.5 + Math.sin(angle) * 0.5
                });
                continue;
            }
            
            // Calculate base position
            const dx = point.x - center.x;
            const dy = point.y - center.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            // 1. Base expansion from overall amplitude - always active for responsiveness
            const baseExpansion = Math.abs(this.audioDeformation) * 0.12; // Reduced to 12%
            
            // 2. Bass-triggered wiggle effect
            let undulation = 0;
            let breathPulse = 0;
            
            if (this.morpher.bassEffectActive) {
                // Strong bass-driven undulation
                const waveCount = 2; // 2 waves for clean look
                const wiggleIntensity = this.bassEnergy * 0.25; // Increased from 0.15 to 0.25
                undulation = Math.sin(angle * waveCount + this.morpher.undulationPhase) * wiggleIntensity;
                
                // Subtle breathing pulse synced with undulation
                breathPulse = Math.sin(this.morpher.undulationPhase * 0.5) * this.bassEnergy * 0.08; // Increased from 0.05
            }
            
            // 5. Check for glitch points - SUBTLE shimmer/ripple effect
            let glitchOffset = 0;
            const glitchPoint = this.glitchPoints.find(g => g.index === i);
            if (glitchPoint) {
                // Create a subtle ripple/shimmer instead of harsh glitch
                const shimmerTime = Date.now() * 0.015; // Slower oscillation
                const shimmer = Math.sin(shimmerTime + i * 0.5) * Math.cos(shimmerTime * 0.7);
                glitchOffset = glitchPoint.intensity * shimmer * 0.5; // Can go in or out, very subtle
            }
            
            // Combine all deformations - simpler, more selective
            const totalDeformation = 1 + baseExpansion + undulation + breathPulse + glitchOffset;
            
            const newDistance = distance * Math.max(0.8, totalDeformation); // Never shrink below 80%
            
            deformed.push({
                x: center.x + Math.cos(angle) * newDistance,
                y: center.y + Math.sin(angle) * newDistance
            });
        }
        
        return deformed;
    }

    /**
     * Set audio deformation value
     * @param {number} value - Deformation value (0-1)
     */
    setAudioDeformation(value) {
        this.audioDeformation = Math.max(0, Math.min(1, value));
        this.vocalEffectActive = value > 0.01;
    }

    /**
     * Set vocal energy for shape pulsing
     * @param {number} value - Energy value (0-1)
     */
    setVocalEnergy(value) {
        this.vocalEnergy = Math.max(0, Math.min(1, value));
        this.vocalEffectActive = value > 0.01;
    }

    /**
     * Update frequency band energies
     * @param {Object} frequencyData - Frequency analysis data
     */
    updateFrequencyBands(frequencyData) {
        if (frequencyData) {
            this.bassEnergy = frequencyData.bass || 0;
            this.vocalPresence = frequencyData.vocal || 0;
            this.highFreqEnergy = frequencyData.high || 0;
        }
    }

    /**
     * Process transient/beat detection
     * @param {number} amplitude - Current audio amplitude
     * @param {number} threshold - Beat threshold
     */
    processTransient(amplitude, threshold) {
        if (amplitude > threshold) {
            this.transientActive = true;
            this.transientStrength = amplitude;
            this.transientHoldCounter = this.transientHoldTime;
        } else if (this.transientHoldCounter > 0) {
            this.transientHoldCounter--;
        } else {
            this.transientStrength *= this.transientDecay;
            if (this.transientStrength < 0.01) {
                this.transientActive = false;
            }
        }
    }

    /**
     * Get current deformation state
     */
    getState() {
        return {
            audioDeformation: this.audioDeformation,
            vocalEnergy: this.vocalEnergy,
            vocalEffectActive: this.vocalEffectActive,
            beatGlitchIntensity: this.beatGlitchIntensity,
            transientActive: this.transientActive,
            transientStrength: this.transientStrength
        };
    }

    /**
     * Reset all audio effects
     */
    reset() {
        this.audioDeformation = 0;
        this.vocalEnergy = 0;
        this.vocalEffectActive = false;
        this.beatGlitchIntensity = 0;
        this.glitchPoints = [];
        this.transientActive = false;
        this.transientStrength = 0;
    }
}

/**
 * AgentBPMDetector - Fast, agent-based BPM detection
 * Uses multiple competing hypotheses that converge on the true tempo
 * @module core/morpher/AgentBPMDetector
 */

class AgentBPMDetector {
    constructor() {
        // Agent pool
        this.agents = [];
        this.maxAgents = 8;

        // Detection state
        this.isActive = false;
        this.confidence = 0;
        this.lockedBPM = 0;
        this.lastBeatTime = 0;

        // Audio analysis
        this.peakHistory = [];
        this.maxHistoryLength = 100; // ~3 seconds at 30fps

        // Configuration
        this.minBPM = 40;
        this.maxBPM = 300;
        this.convergenceThreshold = 0.7; // Lower threshold for faster lock
        this.subdivisionPreference = {
            slow: { min: 40, max: 80, prefer: 1 },     // Keep normal for slow (40-80 is already slow)
            normal: { min: 80, max: 140, prefer: 1 },  // Normal for mid
            fast: { min: 140, max: 180, prefer: 0.5 }, // Half for moderately fast
            veryfast: { min: 180, max: 300, prefer: 0.5 } // Half for very fast
        };
    }

    /**
     * BPM Agent - represents one tempo hypothesis
     */
    createAgent(bpm, subdivision = 1) {
        return {
            bpm: bpm,
            subdivision: subdivision,
            effectiveBPM: bpm * subdivision,
            phase: 0,
            confidence: 0.5,
            hits: 0,
            misses: 0,
            lastBeatTime: performance.now(),
            beatInterval: 60000 / (bpm * subdivision)
        };
    }

    /**
     * Initialize agents with diverse starting hypotheses
     */
    initializeAgents(initialGuess = 120) {
        this.agents = [];

        // Prefer lower subdivisions - if initial guess is high, try halving it
        let subdivisions = [1]; // Start with normal

        if (initialGuess > 180) {
            // Very fast - prefer half speed
            subdivisions = [0.5, 0.75, 1];
        } else if (initialGuess > 140) {
            // Fast - try half and normal
            subdivisions = [0.5, 0.75, 1];
        } else if (initialGuess < 60) {
            // Very slow - try doubling
            subdivisions = [1, 1.5, 2];
        } else {
            // Normal range - try various
            subdivisions = [0.5, 1, 1.5];
        }

        subdivisions.forEach(sub => {
            const agent = this.createAgent(initialGuess, sub);
            // Give preference to lower effective BPMs
            if (initialGuess * sub < 140) {
                agent.confidence = 0.6; // Slight boost for sensible BPMs
            }
            this.agents.push(agent);
        });

        // Add some agents that try to find a lower BPM if initial is high
        if (initialGuess > 140) {
            this.agents.push(this.createAgent(initialGuess / 2, 1));
            this.agents.push(this.createAgent(initialGuess / 2, 1.5));
        }
    }

    /**
     * Process new audio peak/onset
     */
    processPeak(strength, time = performance.now()) {
        // Add to history
        this.peakHistory.push({ strength, time });
        if (this.peakHistory.length > this.maxHistoryLength) {
            this.peakHistory.shift();
        }

        // Only process if we have enough history
        if (this.peakHistory.length < 4) return;

        // If not active, initialize from FFT guess
        if (!this.isActive || this.agents.length === 0) {
            const fftGuess = this.getFFTEstimate();
            this.initializeAgents(fftGuess);
            this.isActive = true;
        }

        // If already locked, be more conservative about changes
        if (this.lockedBPM > 0 && this.confidence > 0.7) {
            // Only update agents, don't evolve as aggressively
            this.agents.forEach(agent => {
                this.scoreAgent(agent, time, strength);
            });

            // Only evolve if confidence has dropped significantly
            if (this.confidence < 0.6) {
                this.evolveAgents();
                this.checkConvergence();
            }
        } else {
            // Not locked yet, be aggressive
            // Score each agent against the peak
            this.agents.forEach(agent => {
                this.scoreAgent(agent, time, strength);
            });

            // Evolution step
            this.evolveAgents();

            // Check for convergence
            this.checkConvergence();
        }
    }

    /**
     * Score agent based on how well it predicts this peak
     */
    scoreAgent(agent, peakTime, peakStrength) {
        const timeSinceLastBeat = peakTime - agent.lastBeatTime;
        const expectedNextBeat = agent.beatInterval;

        // Calculate phase alignment (0-1, where 1 is perfect)
        const phaseDiff = Math.abs((timeSinceLastBeat % expectedNextBeat) / expectedNextBeat - 0.5) * 2;
        const alignment = 1 - phaseDiff;

        // Update agent stats (more aggressive confidence building)
        if (alignment > 0.7) { // Lower threshold
            agent.hits++;
            agent.confidence = Math.min(1, agent.confidence + 0.1); // Faster increase

            // Update phase if we're close
            if (alignment > 0.85) {
                agent.lastBeatTime = peakTime;
            }
        } else if (alignment < 0.3) {
            agent.misses++;
            agent.confidence = Math.max(0, agent.confidence - 0.03);
        }

        // Decay confidence slowly for inactive agents
        agent.confidence *= 0.998; // Slower decay
    }

    /**
     * Evolve agents - kill weak ones, spawn variations of strong ones
     */
    evolveAgents() {
        // Sort by confidence
        this.agents.sort((a, b) => b.confidence - a.confidence);

        // Kill weakest if we have too many
        if (this.agents.length > this.maxAgents) {
            this.agents = this.agents.slice(0, this.maxAgents);
        }

        // If top agent is very confident, spawn slight variations
        const bestAgent = this.agents[0];
        if (bestAgent.confidence > 0.7 && this.agents.length < this.maxAgents) {
            // Try slight BPM variations
            const variation = 1 + (Math.random() - 0.5) * 0.02; // ±1%
            const newAgent = this.createAgent(
                bestAgent.bpm * variation,
                bestAgent.subdivision
            );
            newAgent.confidence = bestAgent.confidence * 0.8;
            this.agents.push(newAgent);
        }

        // Kill agents with very low confidence
        this.agents = this.agents.filter(a => a.confidence > 0.1);
    }

    /**
     * Check if agents have converged on a tempo
     */
    checkConvergence() {
        if (this.agents.length === 0) return;

        const bestAgent = this.agents[0];

        // Need high confidence and clear winner
        if (bestAgent.confidence > this.convergenceThreshold) {
            // Check if other top agents agree (within 5% for faster convergence)
            const similarAgents = this.agents.filter(a =>
                Math.abs(a.effectiveBPM - bestAgent.effectiveBPM) / bestAgent.effectiveBPM < 0.05
            );

            // Only need 2 agents to agree for faster lock
            if (similarAgents.length >= Math.min(2, this.agents.length * 0.3)) {
                // We have convergence!
                this.lockedBPM = Math.round(bestAgent.bpm);
                this.confidence = bestAgent.confidence;

                // Auto-select best subdivision
                this.autoSelectSubdivision();

                return true;
            }
        }

        return false;
    }

    /**
     * Auto-select subdivision based on BPM range
     */
    autoSelectSubdivision() {
        for (const [range, config] of Object.entries(this.subdivisionPreference)) {
            if (this.lockedBPM >= config.min && this.lockedBPM < config.max) {
                // Find agent with preferred subdivision
                const preferredAgent = this.agents.find(a =>
                    Math.abs(a.bpm - this.lockedBPM) < 2 &&
                    Math.abs(a.subdivision - config.prefer) < 0.1
                );

                if (preferredAgent) {
                    return config.prefer;
                }
            }
        }
        return 1; // Default
    }

    /**
     * Get rough BPM estimate from FFT (frequency domain)
     */
    getFFTEstimate() {
        if (this.peakHistory.length < 4) return 120; // Default

        // Calculate intervals between recent peaks
        const recentPeaks = this.peakHistory.slice(-10);
        const intervals = [];

        for (let i = 1; i < recentPeaks.length; i++) {
            intervals.push(recentPeaks[i].time - recentPeaks[i-1].time);
        }

        if (intervals.length === 0) return 120;

        // Find most common interval (mode)
        intervals.sort((a, b) => a - b);
        const median = intervals[Math.floor(intervals.length / 2)];

        // Convert to BPM
        let estimatedBPM = 60000 / median;

        // Sanity check - if way out of range, try doubling/halving
        if (estimatedBPM < this.minBPM) {
            estimatedBPM *= 2;
        } else if (estimatedBPM > this.maxBPM) {
            estimatedBPM /= 2;
        }

        return Math.max(this.minBPM, Math.min(this.maxBPM, estimatedBPM));
    }

    /**
     * Force reset detection with new seed
     */
    reset(seedBPM = null) {
        this.agents = [];
        this.confidence = 0;
        this.lockedBPM = 0;
        this.peakHistory = [];

        if (seedBPM) {
            this.initializeAgents(seedBPM);
        }
    }

    /**
     * Get current best BPM estimate
     */
    getBPM() {
        if (this.lockedBPM > 0 && this.confidence > 0.8) {
            return this.lockedBPM;
        }

        if (this.agents.length > 0) {
            return Math.round(this.agents[0].bpm);
        }

        return 0;
    }

    /**
     * Get recommended subdivision
     */
    getSubdivision() {
        if (this.agents.length > 0) {
            const bestAgent = this.agents[0];

            // Check BPM range preferences
            const bpm = bestAgent.bpm;
            for (const [range, config] of Object.entries(this.subdivisionPreference)) {
                if (bpm >= config.min && bpm < config.max) {
                    return config.prefer;
                }
            }

            return bestAgent.subdivision;
        }
        return 1;
    }

    /**
     * Get detection status
     */
    getStatus() {
        return {
            bpm: this.getBPM(),
            subdivision: this.getSubdivision(),
            confidence: this.confidence,
            locked: this.lockedBPM > 0 && this.confidence > 0.8,
            agentCount: this.agents.length,
            topAgents: this.agents.slice(0, 3).map(a => ({
                bpm: Math.round(a.bpm),
                subdivision: a.subdivision,
                confidence: a.confidence.toFixed(2)
            }))
        };
    }
}

/**
 * MusicDetector - Handles BPM and time signature detection
 * @module core/morpher/MusicDetector
 */


class MusicDetector {
    constructor() {
        // Beat detection state
        this.onsetIntervals = [];
        this.onsetStrengths = [];
        this.lastOnsetTime = 0;
        this.onsetThreshold = 0.3;

        // BPM detection
        this.detectedBPM = 0;
        this.bpmConfidence = 0;
        this.lastBPMCalculation = 0;
        this.bpmCalculationInterval = 2000; // Recalculate every 2 seconds

        // BPM tracking
        this.bpmHistory = [];
        this.tempoLocked = false;
        this.fundamentalBPM = 0;

        // Agent-based detector for fast convergence
        this.agentDetector = new AgentBPMDetector();
        this.useAgentDetection = true; // Flag to enable/disable

        // Time signature detection
        this.timeSignature = '4/4';
        this.detectedTimeSignature = null;
        this.timeSignatureConfidence = 0;
        this.timeSignatureHistory = [];
        this.timeSignatureLocked = false;
        this.downbeatPhase = 0;
        this.measureLength = 4;
        this.measureStartTime = 0;

        // Music state
        this.isMusicalContent = false;
        this.musicalityScore = 0;

        // Fast detection mode
        this.forceFastDetection = false;
    }

    /**
     * Calculate BPM from onset intervals with improved stability
     * @returns {number} Detected BPM
     */
    calculateBPM() {
        // Try agent detector first for faster results
        if (this.useAgentDetection) {
            const agentStatus = this.agentDetector.getStatus();
            if (agentStatus.locked && agentStatus.confidence > 0.6) { // Lower threshold
                // Use agent's locked BPM
                this.detectedBPM = agentStatus.bpm;
                this.bpmConfidence = agentStatus.confidence;
                this.tempoLocked = true;
                this.fundamentalBPM = agentStatus.bpm;

                // Update history
                this.bpmHistory.push(this.detectedBPM);
                if (this.bpmHistory.length > 10) {
                    this.bpmHistory.shift();
                }

                return this.detectedBPM;
            } else if (agentStatus.bpm > 0 && agentStatus.confidence > 0.4) { // Lower threshold
                // Use agent's estimate if somewhat confident
                this.detectedBPM = agentStatus.bpm;
                this.bpmConfidence = agentStatus.confidence;

                // Also mark as tempo locked if confidence is decent
                if (agentStatus.confidence > 0.6) {
                    this.tempoLocked = true;
                }

                return this.detectedBPM;
            }
        }

        // Fall back to original method if agent not ready
        if (this.onsetIntervals.length < 4) return this.detectedBPM;
        
        // Use appropriate window size based on available data
        const analysisWindow = this.onsetIntervals.slice(-15);
        
        // Find tempo candidates using autocorrelation-like approach
        const tempoCandidates = this.findTempoCandidates(analysisWindow);
        if (tempoCandidates.length === 0) return this.detectedBPM;
        
        // Get the best tempo candidate
        const bestCandidate = tempoCandidates[0];
        const candidateBPM = Math.round(60000 / bestCandidate.interval);
        
        // If we haven't locked a tempo yet, establish the fundamental
        if (!this.tempoLocked && this.bpmHistory.length > 3) {
            // Check if we have consistent readings
            const recentBPMs = this.bpmHistory.slice(-3);
            const avgRecent = recentBPMs.reduce((a, b) => a + b, 0) / recentBPMs.length;
            const variance = recentBPMs.reduce((sum, bpm) => sum + Math.pow(bpm - avgRecent, 2), 0) / recentBPMs.length;
            
            // Lock faster with tighter variance requirement
            if (variance < 5) { // Less than ~2 BPM standard deviation - much tighter
                this.fundamentalBPM = Math.round(avgRecent);
                this.tempoLocked = true;
                this.bpmConfidence = 1.0;
            }
        }
        
        // Check if new BPM is a harmonic of the fundamental
        let finalBPM = candidateBPM;
        if (this.tempoLocked) {
            const harmonic = this.checkHarmonicRelation(candidateBPM, this.fundamentalBPM);
            if (harmonic) {
                // It's a valid harmonic, adjust to fundamental
                finalBPM = this.fundamentalBPM;
                this.bpmConfidence = Math.min(1.0, this.bpmConfidence + 0.1);
            } else {
                // Not a harmonic - check if we should update fundamental
                this.bpmConfidence *= 0.9;
                
                // Only change if confidence is very low and new tempo is strong
                if (this.bpmConfidence < 0.3 && bestCandidate.strength > 0.8) {
                    this.fundamentalBPM = candidateBPM;
                    this.bpmConfidence = 0.5;
                } else {
                    // Stick with fundamental
                    finalBPM = this.fundamentalBPM;
                }
            }
        }
        
        // Update history
        this.bpmHistory.push(finalBPM);
        if (this.bpmHistory.length > 10) {
            this.bpmHistory.shift();
        }
        
        // Apply smoothing
        if (this.detectedBPM === 0) {
            this.detectedBPM = finalBPM;
        } else {
            const maxChange = this.tempoLocked ? 1 : 2; // Reduced from 5 to 2 for stability
            const diff = finalBPM - this.detectedBPM;
            if (Math.abs(diff) <= maxChange) {
                this.detectedBPM = finalBPM;
            } else {
                this.detectedBPM += Math.sign(diff) * maxChange;
            }
        }
        
        // Update rhythm engine if available
        if (window.rhythmIntegration && window.rhythmIntegration.updateBPM) {
            if (!window.rhythmManuallyStoppedForCurrentAudio) {
                window.rhythmIntegration.updateBPM(this.detectedBPM);
            }
        }
        
        return this.detectedBPM;
    }

    /**
     * Find tempo candidates from intervals
     * @param {Array} intervals - Time intervals between onsets
     * @returns {Array} Tempo candidates with confidence scores
     */
    findTempoCandidates(intervals) {
        const candidates = [];
        
        // Test different interval groupings (1x, 2x, 4x) for beat patterns
        for (let multiplier of [1, 2, 4]) {
            const testIntervals = intervals.map(i => i * multiplier);
            
            // Find clusters of similar intervals
            const clusters = this.clusterIntervals(testIntervals);
            
            for (let cluster of clusters) {
                const avgInterval = cluster.intervals.reduce((a, b) => a + b, 0) / cluster.intervals.length;
                const actualInterval = avgInterval / multiplier;
                
                // Calculate strength based on cluster size and consistency
                const strength = (cluster.intervals.length / intervals.length) * cluster.consistency;
                
                // Only consider if it would result in reasonable BPM
                const bpm = 60000 / actualInterval;
                // Prefer common BPM ranges (120-140 is very common)
                const commonBPMBonus = (bpm >= 120 && bpm <= 140) ? 0.2 : 0;
                if (bpm >= 60 && bpm <= 220) {
                    candidates.push({
                        interval: actualInterval,
                        strength: strength + commonBPMBonus,
                        multiplier: multiplier
                    });
                }
            }
        }
        
        // Sort by strength
        return candidates.sort((a, b) => b.strength - a.strength);
    }

    /**
     * Cluster similar intervals together
     * @param {Array} intervals - Time intervals
     * @returns {Array} Clustered intervals
     */
    clusterIntervals(intervals) {
        const sorted = [...intervals].sort((a, b) => a - b);
        const clusters = [];
        let currentCluster = [sorted[0]];
        
        for (let i = 1; i < sorted.length; i++) {
            const tolerance = currentCluster[0] * 0.03; // 3% tolerance - tighter for stable BPM
            if (sorted[i] - currentCluster[0] <= tolerance) {
                currentCluster.push(sorted[i]);
            } else {
                if (currentCluster.length >= 2) {
                    // Calculate consistency (inverse of variance)
                    const avg = currentCluster.reduce((a, b) => a + b, 0) / currentCluster.length;
                    const variance = currentCluster.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / currentCluster.length;
                    const consistency = 1 / (1 + variance / (avg * avg)); // Normalized by average
                    
                    clusters.push({
                        intervals: currentCluster,
                        consistency: consistency
                    });
                }
                currentCluster = [sorted[i]];
            }
        }
        
        // Don't forget the last cluster
        if (currentCluster.length >= 3) {
            const avg = currentCluster.reduce((a, b) => a + b, 0) / currentCluster.length;
            const variance = currentCluster.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / currentCluster.length;
            const consistency = 1 / (1 + variance / (avg * avg));
            clusters.push({
                intervals: currentCluster,
                consistency: consistency
            });
        }
        
        return clusters;
    }

    /**
     * Check if two BPMs are harmonically related
     * @param {number} bpm1 - First BPM
     * @param {number} bpm2 - Second BPM
     * @returns {boolean} True if harmonically related
     */
    checkHarmonicRelation(bpm1, bpm2) {
        const ratio = Math.max(bpm1, bpm2) / Math.min(bpm1, bpm2);
        const tolerance = 0.03;
        
        // Check for simple ratios (2:1, 3:2, 4:3, etc.)
        const simpleRatios = [2, 1.5, 1.333, 1.25];
        return simpleRatios.some(r => Math.abs(ratio - r) < tolerance);
    }

    /**
     * Detect time signature from onset patterns
     * @returns {string} Detected time signature
     */
    detectTimeSignature() {
        // Need at least a detected BPM and some onset data
        const minOnsets = this.forceFastDetection ? 6 : 12;
        if (this.detectedBPM === 0 || this.onsetStrengths.length < minOnsets) {
            return this.timeSignature;
        }
        
        // If already locked, don't change unless we're in fast mode (just reset)
        if (this.timeSignatureLocked && !this.forceFastDetection) {
            return this.detectedTimeSignature || this.timeSignature;
        }
        
        const beatInterval = 60000 / this.detectedBPM;
        
        // Only test the most common measure length first (4 beats)
        // We'll be conservative and mostly detect 4/4 unless very clear pattern
        const measureLength = 4;
        const beatBins = new Array(measureLength).fill(0).map(() => ({
            strength: 0,
            bassWeight: 0,
            count: 0
        }));
        
        // Align recent onsets to a 4-beat grid
        const recentOnsets = this.onsetStrengths.slice(-Math.min(20, this.onsetStrengths.length));
        if (recentOnsets.length === 0) return this.timeSignature;
        const startTime = recentOnsets[0].time;
        
        for (let onset of recentOnsets) {
            const timeSinceStart = onset.time - startTime;
            const beatPosition = (timeSinceStart / beatInterval) % measureLength;
            const binIndex = Math.round(beatPosition) % measureLength;
            
            beatBins[binIndex].strength += onset.strength;
            beatBins[binIndex].bassWeight += onset.bassWeight || 0;
            beatBins[binIndex].count++;
        }
        for (let bin of beatBins) {
            if (bin.count > 0) {
                bin.strength /= bin.count;
                bin.bassWeight /= bin.count;
            }
        }
        
        // Default to 4/4 for most music
        let detectedSig = '4/4';
        
        // Only detect 3/4 if we have a VERY clear waltz pattern
        // (strong-weak-weak with no emphasis on beat 4)
        if (beatBins[0].strength > beatBins[1].strength * 2 &&
            beatBins[0].strength > beatBins[2].strength * 2 &&
            beatBins[3].count < beatBins[0].count * 0.5) {
            // Might be 3/4, but need more confidence
            const waltzConfidence = this.testWaltzPattern(recentOnsets, beatInterval);
            if (waltzConfidence > 0.8) {
                detectedSig = '3/4';
            }
        }
        
        // Add to history
        this.timeSignatureHistory.push(detectedSig);
        if (this.timeSignatureHistory.length > 3) {
            this.timeSignatureHistory.shift();
        }
        
        // Lock faster - only need 2 readings in fast mode, 3 normally
        const minReadings = this.forceFastDetection ? 2 : 3;
        if (this.timeSignatureHistory.length >= minReadings) {
            const counts = {};
            for (let sig of this.timeSignatureHistory) {
                counts[sig] = (counts[sig] || 0) + 1;
            }
            
            // Find most common
            let mostCommon = '4/4';
            let maxCount = 0;
            for (let [sig, count] of Object.entries(counts)) {
                if (count > maxCount) {
                    maxCount = count;
                    mostCommon = sig;
                }
            }
            
            // Lock if we have agreement (at least 2 out of 3)
            if (maxCount >= 2) {
                this.detectedTimeSignature = mostCommon;
                this.timeSignatureLocked = true;
                this.timeSignatureConfidence = maxCount / 3;
                
                // Update rhythm engine if available
                if (window.rhythmIntegration && window.rhythmIntegration.setTimeSignature) {
                    window.rhythmIntegration.setTimeSignature(this.detectedTimeSignature);
                }
                
                
                // Also directly update UI in case rhythmIntegration doesn't
                const timeSigDisplay = document.getElementById('time-sig-display');
                if (timeSigDisplay) {
                    timeSigDisplay.textContent = this.detectedTimeSignature;
                }
            }
        }
        
        return this.detectedTimeSignature || this.timeSignature;
    }

    /**
     * Test for waltz pattern (3/4 time)
     * @param {Array} onsets - Onset times and strengths
     * @param {number} beatInterval - Beat interval in ms
     * @returns {number} Confidence score (0-1) for waltz pattern
     */
    testWaltzPattern(onsets, beatInterval) {
        // Look for groups of 3 beats with strong-weak-weak pattern
        let waltzGroups = 0;
        let totalGroups = 0;
        
        for (let i = 0; i < onsets.length - 2; i += 3) {
            if (i + 2 < onsets.length) {
                totalGroups++;
                const first = onsets[i].strength + (onsets[i].bassWeight || 0);
                const second = onsets[i + 1].strength + (onsets[i + 1].bassWeight || 0);
                const third = onsets[i + 2].strength + (onsets[i + 2].bassWeight || 0);
                
                // Check for strong-weak-weak pattern
                if (first > second * 1.5 && first > third * 1.5) {
                    waltzGroups++;
                }
            }
        }
        
        return totalGroups > 0 ? waltzGroups / totalGroups : 0;
    }

    /**
     * Add onset event for analysis
     * @param {number} time - Onset time
     * @param {number} strength - Onset strength
     * @param {number} bassWeight - Optional bass weight for downbeat detection
     */
    addOnset(time, strength, bassWeight = 0) {
        // Feed to agent detector for fast convergence
        if (this.useAgentDetection) {
            this.agentDetector.processPeak(strength, time);
        }

        if (this.lastOnsetTime > 0) {
            const interval = time - this.lastOnsetTime;
            // Filter reasonable intervals (60-220 BPM range)
            if (interval > 273 && interval < 1000) {
                this.onsetIntervals.push(interval);
                if (this.onsetIntervals.length > 20) {
                    this.onsetIntervals.shift();
                }
            }
        }

        this.onsetStrengths.push({ time, strength, bassWeight });
        if (this.onsetStrengths.length > 40) {
            this.onsetStrengths.shift();
        }

        this.lastOnsetTime = time;
    }

    /**
     * Update music detection
     * @param {number} now - Current time
     */
    update(now) {
        // Periodically recalculate BPM
        if (now - this.lastBPMCalculation > this.bpmCalculationInterval) {
            this.calculateBPM();
            this.detectTimeSignature();
            this.lastBPMCalculation = now;
        }
    }

    /**
     * Get recommended subdivision for current BPM
     */
    getRecommendedSubdivision() {
        if (this.useAgentDetection) {
            return this.agentDetector.getSubdivision();
        }

        // Fallback logic based on BPM ranges - prefer lower subdivisions
        if (this.detectedBPM < 60) return 2;     // Double for very slow
        if (this.detectedBPM < 80) return 1;     // Normal for slow
        if (this.detectedBPM > 180) return 0.5;  // Half for very fast
        if (this.detectedBPM > 140) return 0.5;  // Half for fast
        return 1; // Normal for mid-range (80-140)
    }

    /**
     * Reset music detection state
     */
    reset() {
        this.onsetIntervals = [];
        this.onsetStrengths = [];
        this.lastOnsetTime = 0;
        this.detectedBPM = 0;
        this.bpmConfidence = 0;
        this.bpmHistory = [];
        this.tempoLocked = false;
        this.fundamentalBPM = 0;
        this.timeSignature = '4/4';
        this.detectedTimeSignature = null;
        this.timeSignatureConfidence = 0;
        this.timeSignatureHistory = [];

        // Reset agent detector
        if (this.agentDetector) {
            this.agentDetector.reset();
        }
        this.timeSignatureLocked = false;
        this.isMusicalContent = false;
        this.forceFastDetection = false;
    }

    /**
     * Get current music information
     */
    getMusicInfo() {
        return {
            bpm: this.detectedBPM,
            confidence: this.bpmConfidence,
            timeSignature: this.timeSignature,
            isMusical: this.isMusicalContent,
            musicalityScore: this.musicalityScore
        };
    }
}

/**
 * TransitionManager - Manages shape transitions and morphing queue
 * @module core/morpher/TransitionManager
 */

class TransitionManager {
    constructor(morpher) {
        this.morpher = morpher;
        
        // Transition state
        this.isTransitioning = false;
        this.transitionStartTime = 0;
        this.transitionDuration = 800;
        this.transitionProgress = 0;
        this.easingFunction = 'easeInOutQuad';
        
        // Shape state
        this.currentShape = 'circle';
        this.targetShape = null;
        this.previousShape = null;
        
        // Morph queue
        this.morphQueue = [];
        this.maxQueueSize = 3;
        
        // Shadow effects
        this.shadowConfig = null;
        this.shadowProgress = 0;
    }

    /**
     * Start a shape transition
     * @param {string} targetShape - Target shape name
     * @param {Object} options - Transition options
     */
    startTransition(targetShape, options = {}) {
        // If already transitioning, queue it
        if (this.isTransitioning && this.morphQueue.length < this.maxQueueSize) {
            this.morphQueue.push({ shape: targetShape, options });
            return;
        }
        
        this.previousShape = this.currentShape;
        this.targetShape = targetShape;
        this.isTransitioning = true;
        this.transitionStartTime = performance.now();
        this.transitionDuration = options.duration || 800;
        this.easingFunction = options.easing || 'easeInOutQuad';
        this.transitionProgress = 0;
        
        // Get transition config for special effects
        this.shadowConfig = this.getTransitionConfig(this.currentShape, targetShape);
    }

    /**
     * Update transition progress
     * @param {number} deltaTime - Time since last frame
     */
    update(deltaTime) {
        if (!this.isTransitioning) return;
        
        const now = performance.now();
        const elapsed = now - this.transitionStartTime;
        const rawProgress = Math.min(1, elapsed / this.transitionDuration);
        
        // Apply easing
        this.transitionProgress = this.applyEasing(rawProgress);
        
        // Update shadow progress if configured
        if (this.shadowConfig) {
            this.shadowProgress = this.calculateShadowProgress(rawProgress);
        }
        
        // Complete transition if done
        if (rawProgress >= 1) {
            this.completeTransition();
        }
    }

    /**
     * Complete current transition
     */
    completeTransition() {
        this.currentShape = this.targetShape;
        this.targetShape = null;
        this.isTransitioning = false;
        this.transitionProgress = 0;
        this.shadowConfig = null;
        
        // Process queue if there are pending morphs
        if (this.morphQueue.length > 0) {
            const next = this.morphQueue.shift();
            this.startTransition(next.shape, next.options);
        }
    }

    /**
     * Get transition configuration for special effects
     * @param {string} from - Source shape
     * @param {string} to - Target shape
     * @returns {Object} Transition configuration
     */
    getTransitionConfig(from, to) {
        // Special transition effects for certain shape combinations
        const transitions = {
            'circle-heart': {
                type: 'bloom',
                shadowColor: '#ff69b4',
                shadowIntensity: 0.3
            },
            'heart-circle': {
                type: 'contract',
                shadowColor: '#ff69b4',
                shadowIntensity: 0.2
            },
            'circle-star': {
                type: 'burst',
                shadowColor: '#ffd700',
                shadowIntensity: 0.4
            },
            'star-circle': {
                type: 'collapse',
                shadowColor: '#ffd700',
                shadowIntensity: 0.3
            }
        };
        
        const key = `${from}-${to}`;
        return transitions[key] || null;
    }

    /**
     * Calculate shadow progress for special effects
     * @param {number} progress - Raw transition progress
     * @returns {number} Shadow effect progress
     */
    calculateShadowProgress(progress) {
        if (!this.shadowConfig) return 0;
        
        switch (this.shadowConfig.type) {
            case 'bloom':
                // Expand then fade
                return progress < 0.5 
                    ? progress * 2 
                    : 2 - (progress * 2);
            
            case 'burst':
                // Quick expand and fade
                return Math.pow(1 - progress, 2);
            
            case 'contract':
            case 'collapse':
                // Fade in then shrink
                return Math.sin(progress * Math.PI);
            
            default:
                return 0;
        }
    }

    /**
     * Apply easing function to progress
     * @param {number} t - Linear progress (0-1)
     * @returns {number} Eased progress
     */
    applyEasing(t) {
        switch (this.easingFunction) {
            case 'linear':
                return t;
            case 'easeInQuad':
                return t * t;
            case 'easeOutQuad':
                return t * (2 - t);
            case 'easeInOutQuad':
                return t < 0.5 
                    ? 2 * t * t 
                    : -1 + (4 - 2 * t) * t;
            case 'easeInCubic':
                return t * t * t;
            case 'easeOutCubic':
                return (--t) * t * t + 1;
            case 'easeInOutCubic':
                return t < 0.5 
                    ? 4 * t * t * t 
                    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
            default:
                return t;
        }
    }

    /**
     * Clear morph queue
     */
    clearQueue() {
        this.morphQueue = [];
    }

    /**
     * Check if has queued morphs
     */
    hasQueuedMorphs() {
        return this.morphQueue.length > 0;
    }

    /**
     * Get current state
     */
    getState() {
        return {
            isTransitioning: this.isTransitioning,
            currentShape: this.currentShape,
            targetShape: this.targetShape,
            progress: this.transitionProgress,
            queueLength: this.morphQueue.length
        };
    }

    /**
     * Reset to default state
     */
    reset() {
        this.isTransitioning = false;
        this.currentShape = 'circle';
        this.targetShape = null;
        this.transitionProgress = 0;
        this.morphQueue = [];
        this.shadowConfig = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Shape Morphing System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Musical shape morphing system using modular shapes
 * @author Emotive Engine Team
 * @module core/ShapeMorpher
 */


/**
 * ShapeMorpher class - manages smooth transitions between shapes
 */
class ShapeMorpher {
    constructor(options = {}) {
        // Configuration
        this.numPoints = options.numPoints || 64;
        this.morphDuration = options.morphDuration || 1000; // Default 1 second
        this.easing = options.easing || 'easeInOutCubic';
        
        // Initialize modular components
        this.transitionManager = new TransitionManager(this);
        this.audioDeformer = new AudioDeformer(this);
        this.musicDetector = new MusicDetector();
        
        // State - delegated to TransitionManager
        this.currentShape = 'circle';
        this.targetShape = null;
        this.morphProgress = 0;
        this.visualProgress = 0; // Smoothed visual progress for rendering
        this.morphStartTime = null;
        this.isTransitioning = false;
        
        // Shape data cache
        this.shapeCache = new Map();
        this.currentPoints = [];
        this.targetPoints = [];
        
        // Musical timing
        this.musicalDuration = null;
        this.onBeat = false;
        
        // Audio deformation with throttling - delegated to AudioDeformer
        this.audioDeformation = 0;
        this.vocalEnergy = 0;
        this.lastAudioUpdate = 0;
        this.lastVocalUpdate = 0;  // Separate timestamp for vocal updates
        this.audioUpdateInterval = 33; // Update at ~30fps max
        
        // Enhanced audio visualization
        this.audioAnalyzer = null; // Reference to audio analyzer for frequency data
        this.frequencyData = arrayPool.acquire(32, 'float32'); // Store frequency bands
        this.glitchPoints = []; // Track points that are glitching
        this.undulationPhase = 0; // Phase for wave animation
        this.undulationDirection = 1; // Random direction for bass wobble
        this.beatGlitchIntensity = 0; // Intensity of beat-triggered glitches
        
        // Frequency-specific energy tracking
        this.bassEnergy = 0; // Low frequency energy (20-250 Hz)
        this.vocalPresence = 0; // Mid frequency energy (250-4000 Hz)
        
        // Rolling averages for dynamic thresholds
        this.bassHistory = arrayPool.acquire(60, 'float32'); // 2 seconds at 30fps
        this.vocalHistory = arrayPool.acquire(60, 'float32');
        this.historyIndex = 0;
        
        // Cooldown timers to prevent effect spam
        this.bassEffectCooldown = 0;
        this.vocalEffectCooldown = 0;
        
        // Threshold multipliers (can be adjusted for mic vs audio)
        this.bassThresholdMultiplier = 1.2;  // Lowered from 1.8 for testing
        this.vocalThresholdMultiplier = 1.1;  // Even lower for more frequent vocal triggers
        
        // Effect states
        this.bassEffectActive = false;
        this.vocalEffectActive = false;
        
        // Transient detection
        this.transientHoldTime = 0;
        this.vocalGlowBoost = 0;
        
        // Callbacks
        this.onComplete = null;
        this.onProgress = null;
        
        // Morph queue
        this.queuedMorph = null;
        
        // Initialize with circle shape
        this.currentPoints = this.getShapePoints('circle');
        this.shapesLoaded = true; // Static definitions are always loaded
        
        // Pre-warm the shape cache to prevent first-run choppiness
        this.prewarmCache();
    }
    
    /**
     * Pre-warm the shape cache to prevent first-run lag
     */
    prewarmCache() {
        // Pre-generate all common shapes
        const commonShapes = [
            'circle', 'heart', 'star', 'sun', 'moon', 
            'lunar', 'square', 'triangle'
        ];
        
        
        commonShapes.forEach(shape => {
            if (SHAPE_DEFINITIONS[shape]) {
                // Generate and cache the points
                this.getShapePoints(shape);
            }
        });
        
        // Also pre-calculate some common easing values
        const testProgress = [0, 0.25, 0.5, 0.75, 1];
        testProgress.forEach(t => {
            this.applyEasing(t); // Warm up easing calculations
        });
    }
    
    /**
     * Get shape points from cache or generate
     */
    getShapePoints(shapeName) {
        if (!this.shapeCache.has(shapeName)) {
            const shapeDef = SHAPE_DEFINITIONS[shapeName];
            if (!shapeDef || !shapeDef.points) {
                const circlePoints = SHAPE_DEFINITIONS.circle.points;
                this.shapeCache.set(shapeName, circlePoints);
                return circlePoints;
            }
            // Store reference directly - shapes are immutable
            const points = shapeDef.points;
            this.shapeCache.set(shapeName, points);
            return points;
        }
        return this.shapeCache.get(shapeName);
    }
    
    /**
     * Start morphing to a new shape
     * @param {string} targetShape - Target shape name
     * @param {Object} options - Morph options
     */
    morphTo(targetShape, options = {}) {
        if (!this.shapesLoaded) {
            return;
        }
        
        if (targetShape === this.currentShape && !this.isTransitioning) {
            return; // Already at target shape
        }
        
        // Handle queueing or forcing
        if (this.isTransitioning && !options.force) {
            // Queue this morph for after current one completes
            this.queuedMorph = { targetShape, options };
            return 'queued'; // Return status so caller knows it was queued
        } else if (this.isTransitioning && options.force) {
            // Force interrupt current morph
            this.completeMorph(true); // Skip to end without processing queue
        }
        
        // Get transition configuration
        const transitionConfig = this.getTransitionConfig(this.currentShape, targetShape);
        
        // Set up transition
        this.targetShape = targetShape;
        this.targetPoints = this.getShapePoints(targetShape);
        this.morphStartTime = Date.now();
        this.isTransitioning = true;
        this.morphProgress = 0;
        this.visualProgress = 0; // Reset visual progress

        
        // Configure timing - use transition config duration if available
        if (options.duration === 'bar' || options.duration === 'beat') {
            // Musical timing - calculate duration based on current BPM
            const bpm = rhythmEngine.bpm || 120;
            const beatDuration = 60000 / bpm; // ms per beat
            
            if (options.duration === 'bar') {
                // Assume 4/4 time signature
                this.morphDuration = beatDuration * 4; // 4 beats per bar
            } else {
                this.morphDuration = beatDuration; // 1 beat
            }
            
            this.musicalDuration = true; // Flag for musical timing
            this.onBeat = options.onBeat !== false; // Default true for musical timing
        } else {
            // Fixed duration - prefer transition config duration
            this.morphDuration = transitionConfig?.duration || options.duration || 1000;
            this.musicalDuration = null;
            this.onBeat = false;
        }
        
        // Store options
        this.morphMode = options.mode || 'smooth';
        this.transitionConfig = transitionConfig;
        
        // Callbacks
        this.onComplete = options.onComplete;
        this.onProgress = options.onProgress;
        
    }
    
    /**
     * Update morph animation
     * @param {number} deltaTime - Time since last update (can be from RAF timestamp)
     */
    update(deltaTime) {
        // Always update frequency data from audio analyzer if available
        if (this.audioAnalyzer && this.audioAnalyzer.isAnalyzing) {
            const audioData = this.audioAnalyzer.getShapeMorpherData();
            if (audioData && audioData.frequencies) {
                // Copy frequency data for visualization
                let hasNonZero = false;
                for (let i = 0; i < Math.min(audioData.frequencies.length, this.frequencyData.length); i++) {
                    this.frequencyData[i] = audioData.frequencies[i];
                    if (audioData.frequencies[i] > 0) hasNonZero = true;
                }
                // Log once if we start getting data
                if (hasNonZero && !this._loggedAudioData) {
                    console.log('ShapeMorpher: Receiving audio frequency data');
                    this._loggedAudioData = true;
                }
            }
        }

        // Update music detector BPM calculation
        if (this.musicDetector) {
            this.musicDetector.update(performance.now());
        }

        // Return early if not transitioning
        if (!this.isTransitioning || !this.targetShape) return;
        
        // Calculate progress based on total elapsed time
        const currentTime = Date.now();
        const elapsed = currentTime - this.morphStartTime;
        
        // Recalculate duration if BPM changed during morph (for rhythm sync)
        if (this.musicalDuration) {
            const currentBpm = rhythmEngine.bpm || 120;
            const beatDuration = 60000 / currentBpm;
            // Recalculate based on original intention (bar or beat)
            const originalDuration = this.morphDuration;
            const wasBar = originalDuration > beatDuration * 2; // Heuristic: if > 2 beats, it was a bar
            this.morphDuration = wasBar ? beatDuration * 4 : beatDuration;
        }
        
        let progress = Math.min(elapsed / this.morphDuration, 1);
        
        // Apply musical quantization if needed
        if (this.musicalDuration && this.onBeat) {
            const bpm = rhythmEngine.bpm || 120;
            
            // Adaptive granularity - use coarser quantization at higher BPMs
            let subdivision;
            if (bpm > 140) {
                subdivision = 2; // 8th notes for fast tempos
            } else if (bpm > 100) {
                subdivision = 4; // 16th notes for medium tempos  
            } else {
                subdivision = 8; // 32nd notes for slow tempos
            }
            
            // Quantize to nearest subdivision
            const beatDuration = 60000 / bpm;
            const totalBeats = this.morphDuration / beatDuration;
            const currentBeat = progress * totalBeats;
            const quantizedBeat = Math.round(currentBeat * subdivision) / subdivision;
            const quantizedProgress = Math.min(1, quantizedBeat / totalBeats);
            
            // BPM-based strength - weaker quantization at extremes (very slow or very fast)
            const bpmFactor = bpm < 90 ? 
                Math.max(0.3, (bpm - 60) / 30) :  // 0.3 at 60bpm, 1.0 at 90bpm (weaker for slow)
                Math.max(0.4, Math.min(1, 1 - ((bpm - 90) / 90))); // 1.0 at 90bpm, 0.4 at 180bpm (weaker for fast)
            const baseStrength = 0.3 + (bpmFactor * 0.5); // Range: 0.3 to 0.8 based on BPM
            
            // Phase-aware quantization - weaker at start/end, stronger in middle
            const phaseMultiplier = Math.sin(progress * Math.PI); // 0 at edges, 1 at center
            const quantizationStrength = baseStrength * (0.3 + phaseMultiplier * 0.7); // Further modulated by phase
            
            // Apply smoothed quantization with cubic interpolation (smoothstep)
            const t = quantizationStrength;
            const cubicT = t * t * (3 - 2 * t); // Smoothstep for S-curve blending
            progress = progress + (quantizedProgress - progress) * cubicT;
        }
        
        // Apply easing
        this.morphProgress = this.applyEasing(progress);

        // Smooth visual progress for ultra-smooth rendering
        // Heavy smoothing: 80% of previous frame, 20% of new
        this.visualProgress = this.visualProgress * 0.8 + this.morphProgress * 0.2;

        // Snap to final value when very close to avoid infinite approach
        if (Math.abs(this.visualProgress - this.morphProgress) < 0.001) {
            this.visualProgress = this.morphProgress;
        }
        
        // Notify progress
        if (this.onProgress) {
            this.onProgress(this.morphProgress);
        }
        
        // Check if complete (use logical progress, not visual)
        if (this.morphProgress >= 1) {
            this.visualProgress = 1; // Ensure visual completes too
            this.completeMorph();
        }
    }
    
    /**
     * Complete the morph transition
     * @param {boolean} skipQueue - Skip processing queued morphs (for force override)
     */
    completeMorph(skipQueue = false) {
        // Only update current shape if we actually have a target
        if (this.targetShape) {
            this.currentShape = this.targetShape;
            this.currentPoints = [...this.targetPoints];
        }
        this.targetShape = null;
        this.isTransitioning = false;
        this.morphProgress = 0;
        this.visualProgress = 0; // Reset visual progress
        
        if (this.onComplete) {
            this.onComplete(this.currentShape);
        }
        
        // Process queued morph if exists and not skipping
        if (!skipQueue && this.queuedMorph) {
            const queued = this.queuedMorph;
            this.queuedMorph = null; // Clear queue before morphing
            
            // Small delay to ensure smooth transition
            setTimeout(() => {
                this.morphTo(queued.targetShape, queued.options);
            }, 50);
        }
    }
    
    /**
     * Check if there's a queued morph
     * @returns {boolean} True if morph is queued
     */
    hasQueuedMorph() {
        return this.queuedMorph !== null;
    }
    
    /**
     * Clear the morph queue
     */
    clearQueue() {
        this.queuedMorph = null;
    }
    
    /**
     * Get shape points in canvas coordinates
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate  
     * @param {number} radius - Shape radius
     * @returns {Array} Points in canvas coordinates
     */
    getCanvasPoints(centerX, centerY, radius) {
        let normalizedPoints;
        
        try {
            normalizedPoints = this.getInterpolatedPoints();
        } catch (e) {
            normalizedPoints = this.generateFallbackCircle();
        }
        
        // Reuse canvas points array
        if (!this.canvasPointsCache) {
            this.canvasPointsCache = [];
        }
        const canvasPoints = this.canvasPointsCache;
        canvasPoints.length = 0; // Clear without allocating new array
        
        // Handle case where points aren't loaded yet
        if (!normalizedPoints || normalizedPoints.length === 0) {
            // Return fallback circle points
            for (let i = 0; i < this.numPoints; i++) {
                const angle = (i / this.numPoints) * Math.PI * 2;
                canvasPoints.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            }
            return canvasPoints;
        }
        
        // Ensure we're working with an array
        const pointsArray = Array.isArray(normalizedPoints) ? normalizedPoints : [];
        
        for (let i = 0; i < pointsArray.length; i++) {
            const point = pointsArray[i];
            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {
                // Add fallback point
                const angle = (i / pointsArray.length) * Math.PI * 2;
                canvasPoints.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            } else {
                // Convert normalized (0-1) to canvas coordinates
                const x = centerX + (point.x - 0.5) * radius * 2;
                const y = centerY + (point.y - 0.5) * radius * 2;
                canvasPoints.push({ x, y });
            }
        }
        
        // Ensure we have enough points
        while (canvasPoints.length < this.numPoints) {
            const i = canvasPoints.length;
            const angle = (i / this.numPoints) * Math.PI * 2;
            canvasPoints.push({
                x: centerX + Math.cos(angle) * radius,
                y: centerY + Math.sin(angle) * radius
            });
        }
        
        return canvasPoints;
    }
    
    /**
     * Get interpolated shape points
     * @returns {Array} Current interpolated points
     */
    getInterpolatedPoints() {
        // Ensure we always have points
        if (!this.currentPoints || this.currentPoints.length === 0) {
            this.currentPoints = this.generateFallbackCircle();
        }
        
        if (!this.isTransitioning) {
            return this.applyAudioDeformation(this.currentPoints);
        }
        
        const points = [];
        for (let i = 0; i < this.numPoints; i++) {
            const current = this.currentPoints[i];
            const target = this.targetPoints[i];
            
            // Handle missing points
            if (!current || !target) {
                const angle = (i / this.numPoints) * Math.PI * 2;
                points.push({
                    x: 0.5 + Math.cos(angle) * 0.5,
                    y: 0.5 + Math.sin(angle) * 0.5
                });
                continue;
            }
            
            // Interpolate based on mode - use visualProgress for smooth rendering
            const progress = this.visualProgress;
            let x, y;
            
            // RADIAL MORPH: These shapes radiate from/to center
            const radialShapes = ['square', 'circle', 'star', 'triangle'];
            const currentIsRadial = radialShapes.includes(this.currentShape);
            const targetIsRadial = radialShapes.includes(this.targetShape);
            const needsRadialMorph = currentIsRadial || targetIsRadial;
            
            if (needsRadialMorph) {
                // RADIATE FROM/TO CENTER
                const cx = 0.5, cy = 0.5;
                
                // Calculate radial interpolation
                if (targetIsRadial && !currentIsRadial) {
                    // Morphing TO a radial shape - expand from center
                    // Start at center, expand to target position
                    const targetDx = target.x - cx;
                    const targetDy = target.y - cy;
                    
                    // Ease the expansion with a smooth curve
                    this.applyEasing(progress);
                    
                    // Start from center point for first half, then expand outward
                    if (progress < 0.3) {
                        // Gather at center
                        const gatherProgress = progress / 0.3;
                        x = current.x + (cx - current.x) * gatherProgress;
                        y = current.y + (cy - current.y) * gatherProgress;
                    } else {
                        // Expand from center to target
                        const expandPhase = (progress - 0.3) / 0.7;
                        x = cx + targetDx * expandPhase;
                        y = cy + targetDy * expandPhase;
                    }
                } else if (currentIsRadial && !targetIsRadial) {
                    // Morphing FROM a radial shape - collapse to center then expand to target
                    const currentDx = current.x - cx;
                    const currentDy = current.y - cy;
                    
                    if (progress < 0.5) {
                        // Collapse to center
                        const collapseProgress = progress / 0.5;
                        x = current.x - currentDx * collapseProgress;
                        y = current.y - currentDy * collapseProgress;
                    } else {
                        // Expand from center to target
                        const expandProgress = (progress - 0.5) / 0.5;
                        x = cx + (target.x - cx) * expandProgress;
                        y = cy + (target.y - cy) * expandProgress;
                    }
                } else {
                    // Both are radial shapes - morph through center
                    const currentDx = current.x - cx;
                    const currentDy = current.y - cy;
                    const targetDx = target.x - cx;
                    const targetDy = target.y - cy;
                    
                    if (progress < 0.5) {
                        // Collapse current shape to center
                        const collapseProgress = progress / 0.5;
                        x = current.x - currentDx * collapseProgress;
                        y = current.y - currentDy * collapseProgress;
                    } else {
                        // Expand from center to target shape
                        const expandProgress = (progress - 0.5) / 0.5;
                        x = cx + targetDx * expandProgress;
                        y = cy + targetDy * expandProgress;
                    }
                }
            } else if (this.morphMode === 'spiral') {
                // Spiral interpolation
                const angle = progress * Math.PI * 2;
                const spiral = Math.sin(angle + i * 0.2) * 0.02 * (1 - Math.abs(progress - 0.5) * 2);
                x = current.x + (target.x - current.x) * progress + spiral;
                y = current.y + (target.y - current.y) * progress + spiral;
            } else if (this.morphMode === 'wave') {
                // Wave interpolation
                const wave = Math.sin(i * 0.3 + progress * Math.PI * 4) * 0.01;
                x = current.x + (target.x - current.x) * progress + wave;
                y = current.y + (target.y - current.y) * progress + wave;
            } else {
                // Smooth interpolation
                x = current.x + (target.x - current.x) * progress;
                y = current.y + (target.y - current.y) * progress;
            }
            
            points.push({ x, y });
        }
        
        return this.applyAudioDeformation(points);
    }
    
    /**
     * Apply audio-reactive deformation to points
     */
    applyAudioDeformation(points) {
        // Delegate to AudioDeformer module
        return this.audioDeformer.applyAudioDeformation(points);
    }
    
    /**
     * Set audio deformation from analyzer with throttling
     * @param {number} value - Deformation value (-1 to 1)
     */
    setAudioDeformation(value) {
        const now = Date.now();
        if (now - this.lastAudioUpdate > this.audioUpdateInterval) {
            this.audioDeformation = Math.max(-1, Math.min(1, value));
            this.lastAudioUpdate = now;
            // CRITICAL: Also update the AudioDeformer module!
            if (this.audioDeformer) {
                this.audioDeformer.setAudioDeformation(Math.abs(this.audioDeformation)); // Pass absolute value
            }
        }
    }
    
    /**
     * Set vocal energy from analyzer with throttling
     * @param {number} value - Energy value (0 to 1)
     */
    setVocalEnergy(value) {
        const now = Date.now();
        if (now - this.lastVocalUpdate > this.audioUpdateInterval) {
            this.vocalEnergy = Math.max(0, Math.min(1, value));
            this.lastVocalUpdate = now;
            // Also update the AudioDeformer module
            if (this.audioDeformer) {
                this.audioDeformer.setVocalEnergy(this.vocalEnergy);
            }
        }
    }
    
    /**
     * Get transition configuration
     */
    getTransitionConfig(from, to) {
        const fromShape = SHAPE_DEFINITIONS[from];
        const toShape = SHAPE_DEFINITIONS[to];
        
        // Special transitions for moon - add a dreamy quality
        if (to === 'moon') {
            return {
                type: 'to_moon',
                easing: 'easeInOutCubic',  // Smooth acceleration/deceleration
                duration: 1500,  // Slightly longer for dramatic effect
                glowIntensity: 1.5,  // Extra glow during transition
                fadeInCrescent: true  // Fade in the crescent shadow
            };
        }
        
        
        // Moon to lunar - special eclipse transition
        if (from === 'moon' && to === 'lunar') {
            return {
                type: 'moon_to_lunar',
                easing: 'easeInOutSine',
                duration: 2000,  // Slower for dramatic effect
                slideOutCrescent: false, // Don't use standard slide
                description: 'Crescent shadow moves to center and becomes lunar eclipse'
            };
        }
        
        // All other moon transitions - shadow slides away first
        if (from === 'moon') {
            return {
                type: 'from_moon', 
                easing: 'easeInOutCubic',
                duration: 1000,
                slideOutCrescent: true,  // Shadow ALWAYS slides away
                shadowSlideRatio: 0.4,   // First 40% for shadow slide
                description: 'Moon shadow slides away THEN morphs to target'
            };
        }
        
        
        // Other shapes to lunar - morph to circle first, then eclipse comes in
        if (to === 'lunar') {
            return {
                type: 'eclipse_enter_lunar',
                startAngle: -30  // Eclipse enters from top-left like moon crescent
            };
        }
        
        // Lunar to moon - special case: shadow exits to crescent position and stays
        if (from === 'lunar' && to === 'moon') {
            return {
                type: 'lunar_to_moon',
                exitAngle: -30
            };
        }
        
        // Lunar to other shapes - eclipse exits first, then morph to target shape
        if (from === 'lunar') {
            return {
                type: 'eclipse_exit_lunar',
                exitAngle: -30  // Eclipse exits at same angle
            };
        }
        
        // Special eclipse transitions for other shapes
        if (fromShape?.shadow?.type === 'none' && toShape?.shadow?.type === 'solar') {
            return {
                type: 'eclipse_enter',
                direction: 'right'
            };
        }
        
        if (fromShape?.shadow?.type === 'solar' && toShape?.shadow?.type === 'none') {
            return {
                type: 'eclipse_exit',
                direction: 'left'
            };
        }
        
        // Sun transitions need effect fading/blooming
        if (from === 'sun' && to !== 'sun') {
            return {
                type: 'sun_fade',
                fadeEffects: true
            };
        }
        
        if (from !== 'sun' && to === 'sun') {
            return {
                type: 'sun_bloom',
                bloomEffects: true
            };
        }
        
        return {
            type: 'standard'
        };
    }
    
    /**
     * Get current shadow configuration
     * @returns {Object} Shadow configuration
     */
    getCurrentShadow() {
        // Default to circle if currentShape is somehow null/undefined
        const shapeName = this.currentShape || 'circle';
        const currentDef = SHAPE_DEFINITIONS[shapeName];
        const targetDef = this.targetShape ? SHAPE_DEFINITIONS[this.targetShape] : null;
        
        const currentShadow = currentDef?.shadow || { type: 'none' };
        const targetShadow = targetDef?.shadow || null;
        
        
        // If not transitioning, return current shadow
        if (!this.isTransitioning || !targetShadow) {
            return currentShadow;
        }
        
        // Handle eclipse progressions and other special transitions
        const easedProgress = this.morphProgress;
        
        
        // FROM MOON - ALWAYS slide shadow away first (other shapes)
        if (this.transitionConfig && this.transitionConfig.type === 'from_moon' && this.transitionConfig.slideOutCrescent) {
            const slideRatio = this.transitionConfig.shadowSlideRatio || 0.4;
            
            // PHASE 1: Shadow slides away
            if (easedProgress < slideRatio) {
                const slideProgress = easedProgress / slideRatio; // 0 to 1 during slide
                const angle = -30 * Math.PI / 180; // Moon shadow angle (bottom-left)
                
                // Shadow continues sliding in its direction (away to bottom-left)
                const startOffset = 0.7;  // Where moon shadow normally sits
                const endOffset = 2.5;    // Far off screen
                const currentOffset = startOffset + (endOffset - startOffset) * slideProgress;
                
                const offsetX = Math.cos(angle) * currentOffset;
                const offsetY = Math.sin(angle) * currentOffset;
                
                // Keep full opacity while sliding, slight fade at the end
                const coverage = slideProgress > 0.8 ? 0.85 * (1 - (slideProgress - 0.8) * 5) : 0.85;
                
                return {
                    type: 'crescent',
                    coverage: coverage,
                    angle: -30,
                    offset: currentOffset,
                    shadowX: offsetX,
                    shadowY: offsetY
                };
            }
            
            // PHASE 2: No shadow, morph can proceed
            return { type: 'none' };
        }
        
        // Moon to lunar - smooth crescent to eclipse transition
        if (this.transitionConfig && this.transitionConfig.type === 'moon_to_lunar') {
            const angle = this.transitionConfig.startAngle * Math.PI / 180;
            const offsetProgress = 1 - easedProgress; // Goes from 1 to 0 (crescent position to center)
            const offsetX = Math.cos(angle) * 0.7 * offsetProgress;
            const offsetY = Math.sin(angle) * 0.7 * offsetProgress;
            
            // Smooth transition from crescent to lunar
            const lunarBlend = Math.pow(easedProgress, 2); // Quadratic for smooth blend
            
            // Gradually change from crescent to lunar shadow
            if (easedProgress < 0.6) {
                // Still mostly crescent, moving to center
                return {
                    type: 'crescent',
                    coverage: 0.85 * (1 - lunarBlend * 0.2), // Slight fade
                    angle: this.transitionConfig.startAngle,
                    offset: 0.7 * offsetProgress,
                    shadowX: offsetX,
                    shadowY: offsetY
                };
            } else {
                // Smooth blend to lunar shadow
                const blendPhase = (easedProgress - 0.6) / 0.4; // 0 to 1 for last 40%
                const smoothBlend = Math.sin(blendPhase * Math.PI / 2); // Smooth S-curve
                
                return {
                    type: 'lunar',
                    coverage: 0.85 + 0.1 * smoothBlend, // Gradually increase to 0.95
                    color: `rgba(80, 20, 0, ${0.7 + 0.2 * smoothBlend})`, // Fade in red
                    shadowX: offsetX * (1 - smoothBlend), // Smooth center
                    shadowY: offsetY * (1 - smoothBlend),
                    diffusion: smoothBlend,
                    shadowProgress: easedProgress
                };
            }
        }
        
        // Eclipse entering lunar - smooth shadow entry
        if (this.transitionConfig && this.transitionConfig.type === 'eclipse_enter_lunar') {
            // First 30%: Just morph shape, no shadow (reduced from 40%)
            if (easedProgress < 0.3) {
                return { type: 'none' };
            }
            
            // Last 70%: Shadow smoothly enters and transforms
            const shadowProgress = (easedProgress - 0.3) / 0.7; // 0 to 1 for shadow animation
            const smoothProgress = Math.sin(shadowProgress * Math.PI / 2); // Smooth ease-in
            const angle = this.transitionConfig.startAngle * Math.PI / 180;
            const offsetProgress = 1 - smoothProgress; // Goes from 1 to 0
            const offsetX = Math.cos(angle) * 0.7 * offsetProgress;
            const offsetY = Math.sin(angle) * 0.7 * offsetProgress;
            
            // Smooth transition throughout
            if (shadowProgress < 0.7) {
                // Crescent shadow sliding in with gradual fade
                const fadeIn = Math.pow(shadowProgress / 0.7, 0.5); // Smooth fade in
                return {
                    type: 'crescent',
                    coverage: 0.85 * fadeIn,
                    angle: this.transitionConfig.startAngle,
                    offset: 0.7 * offsetProgress,
                    shadowX: offsetX,
                    shadowY: offsetY
                };
            } else {
                // Smooth blend to lunar
                const blendProgress = (shadowProgress - 0.7) / 0.3; // Last 30% for blend
                const smoothBlend = Math.sin(blendProgress * Math.PI / 2); // Smooth curve
                
                return {
                    type: 'lunar',
                    coverage: 0.85 + 0.1 * smoothBlend,
                    color: `rgba(80, 20, 0, ${0.6 + 0.3 * smoothBlend})`,
                    shadowX: offsetX * (1 - smoothBlend),
                    shadowY: offsetY * (1 - smoothBlend),
                    diffusion: smoothBlend,
                    shadowProgress: shadowProgress
                };
            }
        }
        
        // Lunar to moon - smooth shadow transformation and movement
        if (this.transitionConfig && this.transitionConfig.type === 'lunar_to_moon') {
            const angle = this.transitionConfig.exitAngle * Math.PI / 180;
            
            // Smooth movement curve
            const movementCurve = Math.sin(easedProgress * Math.PI / 2); // Smooth ease-out
            const offsetX = Math.cos(angle) * 0.7 * movementCurve;
            const offsetY = Math.sin(angle) * 0.7 * movementCurve;
            
            // Smooth blend between lunar and crescent
            if (easedProgress < 0.6) {
                // Lunar shadow gradually transforming
                const transformPhase = easedProgress / 0.6;
                const smoothTransform = Math.pow(transformPhase, 0.7);
                
                return {
                    type: 'lunar',
                    coverage: 0.95 - (0.1 * smoothTransform),
                    color: `rgba(80, 20, 0, ${0.9 - 0.3 * smoothTransform})`,
                    shadowX: offsetX * 0.7, // Start moving earlier
                    shadowY: offsetY * 0.7,
                    diffusion: 1 - smoothTransform
                };
            } else {
                // Smooth transition to crescent
                const crescentPhase = (easedProgress - 0.6) / 0.4;
                const fadeIn = Math.sin(crescentPhase * Math.PI / 2);
                
                return {
                    type: 'crescent',
                    coverage: 0.85 * fadeIn + 0.1, // Smooth fade in
                    angle: this.transitionConfig.exitAngle,
                    offset: 0.7,
                    shadowX: offsetX,
                    shadowY: offsetY
                };
            }
        }
        
        // Eclipse exiting lunar - smooth shadow exit
        if (this.transitionConfig && this.transitionConfig.type === 'eclipse_exit_lunar') {
            // First 70%: Shadow smoothly exits
            if (easedProgress < 0.7) {
                const shadowProgress = easedProgress / 0.7; // 0 to 1 for shadow exit
                const angle = this.transitionConfig.exitAngle * Math.PI / 180;
                
                // Gradual transformation and movement
                if (shadowProgress < 0.4) {
                    // Lunar shadow gradually transforming
                    const transformPhase = shadowProgress / 0.4;
                    const diffusion = 1 - transformPhase;
                    const moveStart = transformPhase * 0.3; // Start moving early
                    
                    return {
                        type: 'lunar',
                        coverage: 0.95 - (0.1 * transformPhase),
                        color: `rgba(80, 20, 0, ${0.9 - 0.2 * transformPhase})`,
                        shadowX: Math.cos(angle) * 0.7 * moveStart,
                        shadowY: Math.sin(angle) * 0.7 * moveStart,
                        diffusion: diffusion
                    };
                } else {
                    // Smooth exit as crescent
                    const exitPhase = (shadowProgress - 0.4) / 0.6;
                    const smoothMove = Math.pow(exitPhase, 0.8);
                    const offsetX = Math.cos(angle) * 0.7 * smoothMove;
                    const offsetY = Math.sin(angle) * 0.7 * smoothMove;
                    const fadeOut = 1 - Math.pow(exitPhase, 2); // Gradual fade
                    
                    return {
                        type: 'crescent',
                        coverage: 0.85 * fadeOut,
                        angle: this.transitionConfig.exitAngle,
                        offset: 0.7 * smoothMove,
                        shadowX: offsetX,
                        shadowY: offsetY
                    };
                }
            }
            
            // Last 30%: Just morph shape, no shadow
            return { type: 'none' };
        }
        
        // Solar eclipse transitions
        if (this.transitionConfig && this.transitionConfig.type === 'eclipse_enter') {
            const shadowX = 1.5 - (easedProgress * 1.5); // From right
            
            return {
                ...targetShadow,
                shadowX: shadowX,
                shadowProgress: easedProgress
            };
        } else if (this.transitionConfig.type === 'eclipse_exit') {
            const shadowX = -easedProgress * 1.5; // To left
            
            return {
                ...currentShadow,
                coverage: currentShadow.coverage * (1 - easedProgress),
                shadowX: shadowX,
                shadowProgress: 1 - easedProgress
            };
        } else if (this.transitionConfig.type === 'sun_fade') {
            // Smooth fading of sun effects
            const fadeMultiplier = 1 - easedProgress;
            
            // Gradual fade with different timing for each effect
            return {
                ...currentShadow,
                intensity: (currentShadow.intensity || 1) * Math.pow(fadeMultiplier, 0.7), // Slower fade
                corona: currentShadow.corona,
                coronaOpacity: fadeMultiplier, // Fade corona smoothly
                flares: currentShadow.flares,
                flaresOpacity: Math.pow(fadeMultiplier, 1.5), // Flares fade faster
                texture: currentShadow.texture,
                textureOpacity: Math.pow(fadeMultiplier, 2), // Texture fades fastest
                turbulence: (currentShadow.turbulence || 0.3) * fadeMultiplier
            };
        } else if (this.transitionConfig.type === 'sun_bloom') {
            // Smooth blooming of sun effects
            const bloomProgress = easedProgress;
            
            // Gradual bloom with different timing for each effect
            return {
                ...targetShadow,
                intensity: (targetShadow.intensity || 1) * Math.pow(bloomProgress, 1.5), // Start slow
                corona: targetShadow.corona,
                coronaOpacity: Math.pow(bloomProgress, 0.8), // Corona blooms gradually
                flares: targetShadow.flares,
                flaresOpacity: bloomProgress > 0.3 ? Math.pow((bloomProgress - 0.3) / 0.7, 0.7) : 0, // Flares appear later
                texture: targetShadow.texture,
                textureOpacity: bloomProgress > 0.5 ? Math.pow((bloomProgress - 0.5) / 0.5, 2) : 0, // Texture appears last
                turbulence: (targetShadow.turbulence || 0.3) * bloomProgress
            };
        }
        
        // Standard transition
        if (currentShadow.type !== 'none' || targetShadow.type !== 'none') {
            const coverage = (currentShadow.coverage || 0) + 
                           ((targetShadow.coverage || 0) - (currentShadow.coverage || 0)) * easedProgress;
            
            return {
                type: targetShadow.type !== 'none' ? targetShadow.type : currentShadow.type,
                coverage: coverage,
                angle: targetShadow.angle || currentShadow.angle || 0,
                softness: targetShadow.softness || currentShadow.softness || 0.2,
                progress: easedProgress
            };
        }
        
        return currentShadow;
    }
    
    /**
     * Get custom renderer for current shape
     * @returns {Function|null} Custom render function
     */
    getCurrentRenderer() {
        // For now, return null - rendering is handled by EmotiveRenderer
        // This can be extended later if we want shape-specific rendering
        return null;
    }
    
    /**
     * Apply easing function
     */
    applyEasing(t) {
        const easing = this.transitionConfig?.easing || this.easing || 'linear';
        switch (easing) {
            case 'linear':
                return t;
            case 'easeInQuad':
                return t * t;
            case 'easeOutQuad':
                return t * (2 - t);
            case 'easeInOutQuad':
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            case 'easeInOutSine':
                return -(Math.cos(Math.PI * t) - 1) / 2;
            case 'easeInOutCubic':
            default:
                return t < 0.5 
                    ? 4 * t * t * t 
                    : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
    }
    
    /**
     * Calculate BPM from onset intervals with improved stability
     */
    calculateBPM() {
        return this.musicDetector.calculateBPM();
    }
    
    /**
     * Find tempo candidates from onset intervals
     */
    findTempoCandidates(intervals) {
        return this.musicDetector.findTempoCandidates(intervals);
    }
    
    /**
     * Cluster similar intervals together
     */
    clusterIntervals(intervals) {
        return this.musicDetector.clusterIntervals(intervals);
    }
    
    /**
     * Check if BPM is a harmonic of the fundamental
     */
    checkHarmonicRelation(bpm1, bpm2) {
        return this.musicDetector.checkHarmonicRelation(bpm1, bpm2);
    }
    
    /**
     * Detect time signature from onset patterns - delegated to MusicDetector
     */
    detectTimeSignature() {
        // Set fast detection mode if needed
        this.musicDetector.forceFastDetection = this.forceFastDetection;
        
        // Delegate to MusicDetector
        const timeSignature = this.musicDetector.detectTimeSignature();
        
        // Update local references for compatibility
        this.detectedTimeSignature = this.musicDetector.detectedTimeSignature;
        this.timeSignatureConfidence = this.musicDetector.timeSignatureConfidence;
        this.timeSignatureLocked = this.musicDetector.timeSignatureLocked;
        
        return timeSignature;
    }
    
    /**
     * Test specifically for 3/4 waltz pattern - delegated to MusicDetector
     */
    testWaltzPattern(onsets, beatInterval) {
        return this.musicDetector.testWaltzPattern(onsets, beatInterval);
    }
    
    
    /**
     * Reset music detection when new audio is loaded
     */
    resetMusicDetection() {
        // Store if we should force fast detection (for resampling)
        this.forceFastDetection = true;
        
        // Reset music detector
        this.musicDetector.reset();
        
        // Set fast detection on the music detector
        this.musicDetector.forceFastDetection = true;
        
        // Reset local references
        this.onsetThreshold = 0;
        this.detectedBPM = 0;
        this.bpmConfidence = 0;
        
        // Reset time signature detection (still local for now)
        this.onsetStrengths = [];
        this.detectedTimeSignature = null;
        this.timeSignatureConfidence = 0;
        
        // Force immediate resampling on next update
        this.musicDetector.lastBPMCalculation = 0;
        this.measureStartTime = 0;
        this.timeSignatureHistory = [];
        this.timeSignatureLocked = false;
        
        // Reset spectral analysis
        this.spectralHistory = [];
        this.spectralFluxHistory = [];
        
        // Clear UI displays
        const timeSigDisplay = document.getElementById('time-sig-display');
        if (timeSigDisplay) {
            timeSigDisplay.textContent = '—';
        }
        
    }
    
    /**
     * Get current detected BPM and time signature
     */
    getCurrentMusicInfo() {
        return {
            bpm: this.detectedBPM,
            timeSignature: this.detectedTimeSignature,
            bpmLocked: this.tempoLocked,
            timeSigLocked: this.timeSignatureLocked
        };
    }
    
    /**
     * Fallback circle generation
     */
    generateFallbackCircle() {
        const points = [];
        for (let i = 0; i < this.numPoints; i++) {
            const angle = (i / this.numPoints) * Math.PI * 2;
            points.push({
                x: 0.5 + Math.cos(angle) * 0.5,
                y: 0.5 + Math.sin(angle) * 0.5
            });
        }
        return points;
    }
    
    /**
     * Get current state
     */
    getState() {
        return {
            currentShape: this.currentShape,
            targetShape: this.targetShape,
            isTransitioning: this.isTransitioning,
            progress: this.morphProgress,
            audioDeformation: this.audioDeformation,
            vocalEnergy: this.vocalEnergy
        };
    }
    
    /**
     * Get progress (0-1)
     * @param {boolean} visual - Return smoothed visual progress instead of logical
     */
    getProgress(visual = true) {
        // Default to visual progress for smooth rendering
        return visual ? this.visualProgress : this.morphProgress;
    }
    
    /**
     * Check if currently transitioning
     */
    isInTransition() {
        return this.isTransitioning;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Audio Analysis System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Real-time audio analysis for vocal visualization
 * @author Emotive Engine Team
 * @module core/AudioAnalyzer
 */

/**
 * AudioAnalyzer - Analyzes audio for vocal visualization
 */
class AudioAnalyzer {
    constructor() {
        this.audioContext = null;
        this.analyser = null;
        this.source = null;
        this.elementSource = null;  // Track audio element source separately
        this.dataArray = null;
        this.isAnalyzing = false;
        this.connectedElement = null;
        this.gainNode = null;  // Store gain node for cleanup
        
        // Frequency band configuration
        this.frequencyBands = 32;
        this.smoothingFactor = 0.3; // Lower smoothing for better responsiveness
        
        // Vocal detection
        this.vocalRange = { min: 80, max: 1000 }; // Hz - typical vocal range
        this.currentAmplitude = 0;
        this.currentFrequencies = new Array(this.frequencyBands).fill(0);
        
        // Beat detection (for rhythm sync)
        this.beatThreshold = 0.3;
        this.lastBeatTime = 0;
        this.beatCallbacks = [];
    }
    
    /**
     * Initialize audio context and analyzer
     */
    async init() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048; // Good balance of frequency/time resolution
            this.analyser.smoothingTimeConstant = 0.5; // Moderate smoothing
            
            const bufferLength = this.analyser.frequencyBinCount;
            this.dataArray = new Uint8Array(bufferLength);
            
            return true;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Connect audio element for analysis
     * @param {HTMLAudioElement} audioElement - Audio element to analyze
     */
    connectAudioElement(audioElement) {
        if (!this.audioContext) {
            return;
        }
        
        try {
            // Create source from audio element (only if not already created)
            if (!this.elementSource || this.connectedElement !== audioElement) {
                this.elementSource = this.audioContext.createMediaElementSource(audioElement);
                this.elementSource.connect(this.analyser);
                this.elementSource.connect(this.audioContext.destination); // Pass through audio
            }
            this.source = this.elementSource;  // Set current source
            this.connectedElement = audioElement;
            this.isAnalyzing = true;
            
            // Start analysis loop
            this.analyze();
        } catch (error) {
            // If already connected, just restart analysis
            if (error.message && error.message.includes('already been used')) {
                this.source = this.elementSource;  // Use existing source
                this.connectedElement = audioElement;
                this.isAnalyzing = true;
                this.analyze();
            }
        }
    }
    
    
    /**
     * Main analysis loop
     */
    analyze() {
        if (!this.isAnalyzing) return;
        
        requestAnimationFrame(() => this.analyze());
        
        // Get frequency data
        this.analyser.getByteFrequencyData(this.dataArray);
        
        // Also try time domain data to see if mic is working
        const timeData = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteTimeDomainData(timeData);
        
        // Debug: Check both frequency and time domain
        if (!this._debugLogged) {
            const freqMax = Math.max(...this.dataArray);
            const timeMax = Math.max(...timeData);
            const timeMin = Math.min(...timeData);
            
            if (freqMax > 0 || (timeMax !== 128 || timeMin !== 128)) {
                console.log('AudioAnalyzer: Got audio data! Freq max:', freqMax, 'Time range:', timeMin, '-', timeMax);
                this._debugLogged = true;
            } else {
                // Log every 60 frames (1 second at 60fps)
                if (!this._debugCounter) this._debugCounter = 0;
                this._debugCounter++;
                if (this._debugCounter % 60 === 0) {
                    console.log('AudioAnalyzer: No data. Freq all zeros, Time at 128 (silence)');
                }
            }
        }
        
        // Calculate overall amplitude
        let sum = 0;
        let vocalSum = 0;
        let vocalCount = 0;
        
        // Frequency to bin conversion
        const nyquist = this.audioContext.sampleRate / 2;
        const binHz = nyquist / this.dataArray.length;
        const vocalMinBin = Math.floor(this.vocalRange.min / binHz);
        const vocalMaxBin = Math.ceil(this.vocalRange.max / binHz);
        
        // Process frequency data
        for (let i = 0; i < this.dataArray.length; i++) {
            const value = this.dataArray[i] / 255; // Normalize to 0-1
            sum += value;
            
            // Check if in vocal range
            if (i >= vocalMinBin && i <= vocalMaxBin) {
                vocalSum += value;
                vocalCount++;
            }
        }
        
        // Calculate amplitudes
        this.currentAmplitude = sum / this.dataArray.length;
        const vocalAmplitude = vocalCount > 0 ? vocalSum / vocalCount : 0;
        
        // Extract frequency bands for visualization
        this.extractFrequencyBands();
        
        // Detect beats
        this.detectBeat(this.currentAmplitude);
        
        // Return analysis data
        return {
            amplitude: this.currentAmplitude,
            vocalAmplitude: vocalAmplitude,
            frequencies: this.currentFrequencies,
            rawData: this.dataArray
        };
    }
    
    /**
     * Extract frequency bands for shape deformation
     */
    extractFrequencyBands() {
        const bandsPerBin = Math.floor(this.dataArray.length / this.frequencyBands);
        
        for (let i = 0; i < this.frequencyBands; i++) {
            let sum = 0;
            const startBin = i * bandsPerBin;
            const endBin = Math.min(startBin + bandsPerBin, this.dataArray.length);
            
            for (let j = startBin; j < endBin; j++) {
                sum += this.dataArray[j] / 255; // Normalize
            }
            
            // Apply smoothing
            const newValue = sum / bandsPerBin;
            this.currentFrequencies[i] = this.currentFrequencies[i] * this.smoothingFactor + 
                                         newValue * (1 - this.smoothingFactor);
        }
    }
    
    /**
     * Simple beat detection
     */
    detectBeat(amplitude) {
        const now = performance.now();
        
        // Simple threshold-based beat detection
        // Allow faster beats - 273ms = 220 BPM, but go down to 60ms for very fast tapping
        if (amplitude > this.beatThreshold && now - this.lastBeatTime > 60) {
            this.lastBeatTime = now;
            
            // Trigger beat callbacks
            this.beatCallbacks.forEach(callback => callback(amplitude));
        }
    }
    
    /**
     * Get current vocal instability (0-1)
     */
    getVocalInstability() {
        // Calculate instability based on frequency variance
        let variance = 0;
        const mean = this.currentFrequencies.reduce((a, b) => a + b, 0) / this.frequencyBands;
        
        for (let i = 0; i < this.frequencyBands; i++) {
            variance += Math.pow(this.currentFrequencies[i] - mean, 2);
        }
        
        variance = Math.sqrt(variance / this.frequencyBands);
        
        // Combine with amplitude for overall instability
        const instability = Math.min(1, variance * 2 + this.currentAmplitude * 0.5);
        return instability;
    }
    
    /**
     * Get analysis data formatted for ShapeMorpher
     */
    getShapeMorpherData() {
        return {
            instability: this.getVocalInstability(),
            frequencies: [...this.currentFrequencies],
            amplitude: this.currentAmplitude
        };
    }
    
    /**
     * Add beat detection callback
     */
    onBeat(callback) {
        this.beatCallbacks.push(callback);
    }
    
    /**
     * Stop analysis
     */
    stop() {
        this.isAnalyzing = false;
        
        if (this.gainNode) {
            try {
                this.gainNode.disconnect();
            } catch (e) {}
            this.gainNode = null;
        }
        
        // Reconnect element source to analyser if it was disconnected
        if (this.elementSource && this.connectedElement) {
            try {
                this.elementSource.connect(this.analyser);
            } catch (e) {
                // Already connected, that's fine
            }
            this.source = this.elementSource;
        }
    }
    
    /**
     * Resume audio context (needed after user interaction)
     */
    async resume() {
        if (this.audioContext && this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
        }
    }
    
    /**
     * Cleanup
     */
    destroy() {
        this.stop();
        
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
        }
        
        this.analyser = null;
        this.dataArray = null;
        this.beatCallbacks = [];
    }
}

/**
 * GestureCompatibility - Core gesture compatibility and chord system
 * Defines which gestures can execute simultaneously vs sequentially
 * Part of the Emotive Engine core
 */

class GestureCompatibility {
    constructor() {
        // Musical timing classes - defines when gestures should fire
        this.timingClasses = {
            downbeat: {
                gestures: ['bounce', 'jump', 'headBob', 'spin', 'orbit'],
                timing: 1.0,  // Fire on the beat
                priority: 1,
                description: 'Strong emphasis on the downbeat'
            },
            upbeat: {
                gestures: ['wave', 'nod', 'point', 'reach'],
                timing: 0.5,  // Fire on the half-beat
                priority: 2,
                description: 'Medium emphasis on upbeat'
            },
            offbeat: {
                gestures: ['wiggle', 'sway', 'lean', 'tilt', 'groove'],
                timing: 0.5,  // Fire between beats (syncopated)
                priority: 3,
                description: 'Syncopated, creates groove'
            },
            subdivision: {
                gestures: ['pulse', 'sparkle', 'flash', 'shimmer', 'flicker'],
                timing: 0.25,  // Can fire on quarter beats
                priority: 4,
                description: 'Quick accents and fills'
            },
            continuous: {
                gestures: ['breathe', 'float', 'rain'],
                timing: -1,  // Can start anytime, flows across beats
                priority: 5,
                description: 'Ambient, continuous motion'
            }
        };

        // Fill patterns for automatic motion between gestures
        this.fillPatterns = {
            subtle: ['breathe', 'float'],
            rhythmic: ['pulse', 'shimmer'],
            energetic: ['wiggle', 'sparkle'],
            smooth: ['sway', 'glow']
        };

        // Dynamic density settings based on BPM
        this.densityProfiles = {
            sparse: {
                fillProbability: 0.1,
                subdivisionLevel: 2,  // Half notes only
                description: 'Minimal movement'
            },
            moderate: {
                fillProbability: 0.3,
                subdivisionLevel: 4,  // Quarter notes
                description: 'Balanced movement'
            },
            dense: {
                fillProbability: 0.5,
                subdivisionLevel: 8,  // Eighth notes
                description: 'Busy, energetic'
            },
            chaos: {
                fillProbability: 0.8,
                subdivisionLevel: 16,  // Sixteenth notes
                description: 'Maximum energy'
            }
        };

        // Gesture group definitions
        this.groups = {
            // Primary movement - only one can execute at a time
            movement: {
                gestures: ['bounce', 'spin', 'orbit', 'sway', 'hula', 'jump', 'twist', 'groove'],
                maxSimultaneous: 1,
                priority: 1,
                description: 'Primary body movements - mutually exclusive'
            },

            // Secondary movements - can layer 2 together
            expression: {
                gestures: ['wave', 'nod', 'shake', 'point', 'lean', 'tilt', 'reach'],
                maxSimultaneous: 2,
                priority: 2,
                description: 'Expressive gestures - can combine up to 2'
            },

            // Dance moves - special category that can combine with effects
            dance: {
                gestures: ['headBob', 'wiggle', 'runningman', 'charleston'],
                maxSimultaneous: 1,
                priority: 2,
                description: 'Dance moves - one at a time but can add effects'
            },

            // Visual effects - all can stack
            effects: {
                gestures: ['pulse', 'glow', 'sparkle', 'flash', 'shimmer', 'flicker'],
                maxSimultaneous: -1, // Unlimited
                priority: 3,
                description: 'Visual effects - all can layer together'
            },

            // Ambient modifiers - always allowed to layer
            modifiers: {
                gestures: ['breathe', 'float', 'rain'],
                maxSimultaneous: -1, // Unlimited
                priority: 4,
                description: 'Ambient effects - always allowed'
            }
        };

        // Specific combinations that work well together
        this.enhancingCombinations = [
            ['bounce', 'sparkle'],
            ['spin', 'glow'],
            ['wave', 'pulse'],
            ['nod', 'pulse'],
            ['jump', 'flash'],
            ['sway', 'breathe'],
            ['float', 'shimmer'],
            ['orbit', 'sparkle'],
            ['headBob', 'pulse']
        ];

        // Gestures that should never combine
        this.incompatiblePairs = [
            ['bounce', 'jump'],
            ['spin', 'orbit'],
            ['wave', 'point'],
            ['nod', 'shake'],
            ['lean', 'tilt']
        ];

        // Pre-defined chord combinations
        this.chords = {
            celebrate: ['bounce', 'sparkle', 'pulse'],
            greeting: ['wave', 'nod', 'glow'],
            excited: ['jump', 'flash', 'wiggle'],
            mystical: ['float', 'shimmer', 'breathe'],
            party: ['headBob', 'pulse', 'sparkle'],
            smooth: ['sway', 'glow', 'breathe'],
            dramatic: ['spin', 'flash', 'sparkle']
        };

        // Chain definitions with simultaneous markers
        // '+' means simultaneous, '>' means sequential
        this.chains = {
            buildup: 'pulse > pulse > bounce+sparkle > spin+flash',
            cascade: 'wave > lean > tilt > spin > bounce+glow',
            celebrate: 'bounce+sparkle > spin > jump+flash > headBob+pulse',
            smooth: 'sway+breathe > float > orbit+shimmer > sway+glow',
            chaos: 'wiggle > shake+flash > spin+sparkle > bounce+pulse > twist',
            greeting: 'wave+glow > nod+pulse > wave',
            mystical: 'float+shimmer > orbit+breathe > spin+sparkle > float+glow',
            dance: 'headBob > bounce+pulse > spin > sway+glow > headBob+sparkle'
        };
    }

    /**
     * Check if two gestures can execute simultaneously
     * @param {string} gesture1 - First gesture name
     * @param {string} gesture2 - Second gesture name
     * @returns {boolean} - True if they can execute together
     */
    canExecuteSimultaneously(gesture1, gesture2) {
        // Check if they're the same gesture
        if (gesture1 === gesture2) return false;

        // Check if they're in incompatible list
        const incompatible = this.incompatiblePairs.some(pair =>
            (pair.includes(gesture1) && pair.includes(gesture2))
        );
        if (incompatible) return false;

        // Get groups for each gesture
        const group1 = this.getGestureGroup(gesture1);
        const group2 = this.getGestureGroup(gesture2);

        // If same group, check maxSimultaneous
        if (group1 === group2) {
            const group = this.groups[group1];
            return group && group.maxSimultaneous !== 1;
        }

        // Different groups can usually combine
        // Movement can't combine with other movement
        if (group1 === 'movement' && group2 === 'movement') return false;
        if (group1 === 'dance' && group2 === 'dance') return false;

        return true;
    }

    /**
     * Get the group a gesture belongs to
     * @param {string} gesture - Gesture name
     * @returns {string|null} - Group name or null
     */
    getGestureGroup(gesture) {
        for (const [groupName, group] of Object.entries(this.groups)) {
            if (group.gestures.includes(gesture)) {
                return groupName;
            }
        }
        return null;
    }

    /**
     * Get priority of a gesture
     * @param {string} gesture - Gesture name
     * @returns {number} - Priority value (lower = higher priority)
     */
    getGesturePriority(gesture) {
        const group = this.getGestureGroup(gesture);
        return group ? this.groups[group].priority : 99;
    }

    /**
     * Get compatible gestures from a list that can execute together
     * @param {Array} gestures - Array of gesture objects or names
     * @returns {Array} - Gestures that can execute simultaneously
     */
    getCompatibleGestures(gestures) {
        if (!gestures || gestures.length === 0) return [];
        if (gestures.length === 1) return gestures;

        const chord = [];
        const used = new Set();

        // Normalize to gesture names
        const normalizeGesture = (g) => typeof g === 'string' ? g : g.gestureName;

        // Sort by priority
        const sorted = [...gestures].sort((a, b) => {
            const priorityA = this.getGesturePriority(normalizeGesture(a));
            const priorityB = this.getGesturePriority(normalizeGesture(b));
            return priorityA - priorityB;
        });

        for (const gesture of sorted) {
            if (used.has(gesture)) continue;

            const gestureName = normalizeGesture(gesture);

            // Check if this gesture can combine with all in chord
            let canAdd = true;
            for (const chordItem of chord) {
                const chordGestureName = normalizeGesture(chordItem);
                if (!this.canExecuteSimultaneously(gestureName, chordGestureName)) {
                    canAdd = false;
                    break;
                }
            }

            if (canAdd) {
                // Check group limits
                const group = this.groups[this.getGestureGroup(gestureName)];
                if (group && group.maxSimultaneous > 0) {
                    const groupCount = chord.filter(c =>
                        this.getGestureGroup(normalizeGesture(c)) === this.getGestureGroup(gestureName)
                    ).length;
                    if (groupCount >= group.maxSimultaneous) {
                        continue; // Skip, group limit reached
                    }
                }

                chord.push(gesture);
                used.add(gesture);
            }
        }

        return chord;
    }

    /**
     * Parse a chain string into steps of simultaneous gestures
     * @param {string} chainString - Chain definition string
     * @returns {Array<Array<string>>} - Array of steps, each containing simultaneous gestures
     */
    parseChain(chainString) {
        if (!chainString) return [];

        // Handle predefined chains
        if (this.chains[chainString]) {
            chainString = this.chains[chainString];
        }

        const steps = chainString.split('>').map(s => s.trim());
        return steps.map(step => {
            // Split by + for simultaneous gestures
            return step.split('+').map(g => g.trim()).filter(g => g);
        });
    }

    /**
     * Check if gestures form an enhancing combination
     * @param {Array} gestures - Array of gesture names
     * @returns {boolean} - True if they enhance each other
     */
    isEnhancingCombination(gestures) {
        const gestureNames = gestures.map(g =>
            typeof g === 'string' ? g : g.gestureName
        );

        return this.enhancingCombinations.some(combo =>
            combo.every(gesture => gestureNames.includes(gesture))
        );
    }

    /**
     * Get a predefined chord by name
     * @param {string} chordName - Name of the chord
     * @returns {Array<string>|null} - Array of gesture names or null
     */
    getChord(chordName) {
        return this.chords[chordName] || null;
    }

    /**
     * Create a gesture chord command
     * @param {Array<string>} gestures - Gestures to combine
     * @returns {Object} - Chord command object
     */
    createChord(gestures) {
        const compatible = this.getCompatibleGestures(gestures);
        const isEnhancing = this.isEnhancingCombination(compatible);

        return {
            type: 'chord',
            gestures: compatible.map(g => typeof g === 'string' ? g : g.gestureName),
            isEnhancing,
            timestamp: Date.now()
        };
    }

    /**
     * Validate if a gesture exists in the system
     * @param {string} gesture - Gesture name
     * @returns {boolean} - True if gesture is valid
     */
    isValidGesture(gesture) {
        return this.getGestureGroup(gesture) !== null;
    }

    /**
     * Get all available gestures
     * @returns {Array<string>} - All gesture names
     */
    getAllGestures() {
        const gestures = [];
        for (const group of Object.values(this.groups)) {
            gestures.push(...group.gestures);
        }
        return [...new Set(gestures)];
    }

    /**
     * Get timing class for a gesture
     * @param {string} gesture - Gesture name
     * @returns {Object|null} - Timing class info
     */
    getGestureTiming(gesture) {
        for (const [className, timingClass] of Object.entries(this.timingClasses)) {
            if (timingClass.gestures.includes(gesture)) {
                return {
                    name: className,
                    ...timingClass
                };
            }
        }
        return null;
    }

    /**
     * Get next subdivision beat for a gesture
     * @param {string} gesture - Gesture name
     * @param {number} currentBeat - Current beat number
     * @param {number} subdivision - Beat subdivision (1, 0.5, 0.25, etc)
     * @returns {number} - Next beat to fire on
     */
    getNextBeatForGesture(gesture, currentBeat, subdivision = 1) {
        const timing = this.getGestureTiming(gesture);
        if (!timing) return currentBeat + 1;

        // Continuous gestures can start immediately
        if (timing.timing === -1) return currentBeat;

        // Calculate next appropriate beat based on timing class
        const beatInterval = timing.timing / subdivision;
        const nextBeat = Math.ceil(currentBeat / beatInterval) * beatInterval;

        // For offbeat gestures, add half beat offset
        if (timing.name === 'offbeat') {
            return nextBeat + 0.5;
        }

        return nextBeat;
    }

    /**
     * Get fill gestures based on density and BPM
     * @param {number} bpm - Current BPM
     * @param {string} intensity - Intensity level (sparse, moderate, dense, chaos)
     * @returns {Array<string>} - Suggested fill gestures
     */
    getFillGestures(bpm, intensity = 'moderate') {
        const profile = this.densityProfiles[intensity] || this.densityProfiles.moderate;

        // Determine fill pattern based on BPM
        let pattern;
        if (bpm < 80) {
            pattern = 'energetic';  // More movement for slow tempos
        } else if (bpm < 120) {
            pattern = 'rhythmic';
        } else if (bpm < 160) {
            pattern = 'smooth';
        } else {
            pattern = 'subtle';  // Less movement for fast tempos
        }

        // Return fills based on probability
        if (Math.random() < profile.fillProbability) {
            return this.fillPatterns[pattern] || [];
        }
        return [];
    }

    /**
     * Get next beat timing for a gesture (for rhythm game mode)
     * @param {string} gestureName - Name of the gesture
     * @param {number} currentBeat - Current beat number
     * @param {number} bpm - Current BPM
     * @returns {number} - Next beat to trigger on
     */
    getNextBeatTiming(gestureName, currentBeat, bpm) {
        // In rhythm game mode, this will be determined by the game logic
        // For now, just return the next appropriate beat based on gesture type
        const nextBeat = this.getNextBeatForGesture(gestureName, currentBeat);
        return nextBeat;
    }

    /**
     * Get intensity profile based on BPM
     * @param {number} bpm - Current BPM
     * @returns {string} - Intensity level
     */
    getIntensityFromBPM(bpm) {
        if (bpm < 60) return 'dense';      // Very slow needs more fills
        if (bpm < 100) return 'moderate';
        if (bpm < 140) return 'moderate';
        if (bpm < 180) return 'sparse';
        return 'sparse';  // Very fast needs less
    }

    /**
     * Create swing/shuffle timing
     * @param {number} straightBeat - Straight beat number
     * @param {number} swingRatio - Swing ratio (0.5 = straight, 0.67 = swing)
     * @returns {number} - Adjusted beat with swing
     */
    applySwingTiming(straightBeat, swingRatio = 0.67) {
        const beatPart = straightBeat % 1;
        if (beatPart === 0.5) {
            // Delay the offbeat for swing feel
            return Math.floor(straightBeat) + swingRatio;
        }
        return straightBeat;
    }
}

// Create singleton instance
const gestureCompatibility = new GestureCompatibility();

var GestureCompatibility$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    GestureCompatibility: GestureCompatibility,
    default: gestureCompatibility
});

/**
 * GrooveTemplates - Musical rhythm patterns and groove definitions
 * Provides pre-defined rhythmic patterns that make the mascot dance musically
 */

class GrooveTemplates {
    constructor() {
        // Core groove definitions with emphasis patterns
        this.templates = {
            straight: {
                name: 'Straight',
                timeSignature: '4/4',
                baseMovement: 'grooveBob', // Continuous base layer
                transitionStyle: 'transitionLean',
                pattern: {
                    emphasis: [1, 0, 0.5, 0], // Strong on 1, medium on 3
                    velocities: [1.0, 0, 0.6, 0],
                    subdivisions: [0, 0.5] // Only play on beats and offbeats
                },
                swing: 0,
                humanization: 0.05, // 5% timing variance for human feel
                preferredGestures: {
                    downbeat: ['bounce', 'headBob', 'jump'],
                    offbeat: ['pulse', 'breathe'],
                    fills: ['sparkle', 'glow']
                },
                compositeMove: null, // No special composite for straight
                intensity: 'moderate',
                description: 'Standard 4/4 rhythm, good for pop/rock'
            },

            swing: {
                name: 'Swing',
                timeSignature: '4/4',
                baseMovement: 'grooveFlow',
                transitionStyle: 'transitionGlide',
                compositeMove: 'swingOut',
                pattern: {
                    emphasis: [1, 0, 0.66, 0], // Swung eighth notes
                    velocities: [1.0, 0, 0.7, 0],
                    subdivisions: [0, 0.66] // Delayed upbeat for swing feel
                },
                swing: 0.67, // 67% swing ratio (2:1 triplet feel)
                humanization: 0.08,
                preferredGestures: {
                    downbeat: ['sway', 'lean', 'bounce'],
                    offbeat: ['wiggle', 'pulse'],
                    fills: ['shimmer', 'float']
                },
                intensity: 'moderate',
                description: 'Jazz swing feel with triplet subdivision'
            },

            shuffle: {
                name: 'Shuffle',
                timeSignature: '4/4',
                baseMovement: 'grooveBob',
                transitionStyle: 'transitionLean',
                compositeMove: null,
                pattern: {
                    emphasis: [1, 0.25, 0.5, 0.75], // Driving shuffle
                    velocities: [1.0, 0.3, 0.7, 0.3],
                    subdivisions: [0, 0.25, 0.5, 0.75]
                },
                swing: 0.75, // Heavy shuffle
                humanization: 0.06,
                preferredGestures: {
                    downbeat: ['bounce', 'headBob'],
                    upbeat: ['twist', 'wiggle'],
                    offbeat: ['pulse', 'breathe'],
                    fills: ['sparkle', 'flash']
                },
                intensity: 'dense',
                description: 'Blues/rock shuffle with heavy swing'
            },

            latin: {
                name: 'Latin',
                timeSignature: '4/4',
                baseMovement: 'grooveSway',
                transitionStyle: 'transitionRoll',
                compositeMove: 'latinHips',
                pattern: {
                    // Clave-inspired pattern: 1 e + a 2 e + a 3 e + a 4 e + a
                    emphasis: [1, 0, 0.375, 0.5, 0, 0.75, 0, 0],
                    velocities: [1.0, 0, 0.8, 0.9, 0, 0.8, 0, 0],
                    subdivisions: [0, 0.375, 0.5, 0.75] // Syncopated
                },
                swing: 0,
                humanization: 0.04,
                preferredGestures: {
                    downbeat: ['sway', 'wiggle'],
                    syncopation: ['twist', 'lean'],
                    offbeat: ['pulse', 'shimmer'],
                    fills: ['sparkle', 'shake']
                },
                intensity: 'dense',
                description: 'Latin clave rhythm with syncopation'
            },

            breakbeat: {
                name: 'Breakbeat',
                timeSignature: '4/4',
                baseMovement: 'grooveStep',
                transitionStyle: 'transitionGlide',
                compositeMove: null,
                pattern: {
                    // Classic Amen break pattern simplified
                    emphasis: [1, 0, 0, 0.75, 0.25, 0.5, 0, 0.625],
                    velocities: [1.0, 0, 0, 0.9, 0.6, 0.8, 0, 0.7],
                    subdivisions: [0, 0.25, 0.5, 0.625, 0.75] // Complex syncopation
                },
                swing: 0,
                humanization: 0.03, // Tighter timing for electronic feel
                preferredGestures: {
                    downbeat: ['bounce', 'twist'],
                    syncopation: ['flash', 'shake'],
                    offbeat: ['pulse', 'wiggle'],
                    fills: ['sparkle', 'glitch']
                },
                intensity: 'chaos',
                description: 'Hip-hop/DnB breakbeat pattern'
            },

            waltz: {
                name: 'Waltz',
                timeSignature: '3/4',
                baseMovement: 'grooveFlow',
                transitionStyle: 'transitionGlide',
                compositeMove: null,
                pattern: {
                    emphasis: [1, 0.33, 0.67], // 1-2-3, 1-2-3
                    velocities: [1.0, 0.5, 0.5],
                    subdivisions: [0, 0.33, 0.67]
                },
                swing: 0,
                humanization: 0.07,
                preferredGestures: {
                    downbeat: ['sway', 'float'],
                    weak: ['breathe', 'lean'],
                    fills: ['shimmer', 'glow']
                },
                intensity: 'sparse',
                description: '3/4 waltz time'
            },

            techno: {
                name: 'Techno',
                timeSignature: '4/4',
                baseMovement: 'groovePulse',
                transitionStyle: 'transitionLean',
                compositeMove: 'robotPop',
                pattern: {
                    // Four-on-the-floor with 16th note variations
                    emphasis: [1, 0.25, 0.5, 0.75, 1, 0.25, 0.5, 0.75],
                    velocities: [1.0, 0.6, 1.0, 0.6, 1.0, 0.6, 1.0, 0.6],
                    subdivisions: [0, 0.25, 0.5, 0.75] // All subdivisions
                },
                swing: 0,
                humanization: 0.02, // Very tight, machine-like
                preferredGestures: {
                    downbeat: ['pulse', 'bounce'],
                    subdivision: ['flash', 'glitch'],
                    fills: ['sparkle', 'strobe']
                },
                intensity: 'dense',
                description: 'Driving techno four-on-the-floor'
            },

            ambient: {
                name: 'Ambient',
                timeSignature: '4/4',
                baseMovement: 'groovePulse',
                transitionStyle: 'transitionGlide',
                compositeMove: null,
                pattern: {
                    emphasis: [0.8, 0, 0.3, 0, 0.5, 0, 0.3, 0],
                    velocities: [0.8, 0, 0.3, 0, 0.5, 0, 0.3, 0],
                    subdivisions: [0, 0.5] // Sparse
                },
                swing: 0,
                humanization: 0.15, // Very loose timing
                preferredGestures: {
                    downbeat: ['float', 'breathe'],
                    offbeat: ['sway', 'shimmer'],
                    fills: ['glow', 'pulse']
                },
                intensity: 'sparse',
                description: 'Floating ambient rhythm'
            },

            funk: {
                name: 'Funk',
                timeSignature: '4/4',
                baseMovement: 'grooveSway',
                transitionStyle: 'transitionRoll',
                compositeMove: 'funkChicken',
                pattern: {
                    // "One" emphasis with 16th note ghost notes
                    emphasis: [1.2, 0.125, 0.25, 0, 0.625, 0.75, 0, 0.875],
                    velocities: [1.2, 0.3, 0.4, 0, 0.8, 0.6, 0, 0.4],
                    subdivisions: [0, 0.125, 0.25, 0.625, 0.75, 0.875]
                },
                swing: 0.1, // Slight swing
                humanization: 0.06,
                preferredGestures: {
                    one: ['bounce', 'twist'], // THE ONE
                    ghost: ['wiggle', 'pulse'], // Ghost notes
                    syncopation: ['lean', 'shake'],
                    fills: ['flash', 'sparkle']
                },
                intensity: 'chaos',
                description: 'Funky syncopated rhythm with THE ONE'
            },

            trap: {
                name: 'Trap',
                timeSignature: '4/4',
                baseMovement: 'grooveStep',
                transitionStyle: 'transitionLean',
                compositeMove: null,
                pattern: {
                    // Hi-hat rolls and syncopated kicks
                    emphasis: [1, 0, 0, 0.375, 0, 0.75, 0.875, 0],
                    velocities: [1.0, 0, 0, 0.7, 0, 0.8, 0.6, 0],
                    subdivisions: [0, 0.375, 0.75, 0.875] // Triplet feel
                },
                swing: 0,
                humanization: 0.03,
                preferredGestures: {
                    downbeat: ['bounce', 'lean'],
                    hihat: ['shake', 'shimmer'],
                    syncopation: ['twist', 'flash'],
                    fills: ['sparkle', 'glitch']
                },
                intensity: 'moderate',
                description: 'Trap rhythm with triplet hi-hats'
            }
        };

        // Transition rules for smooth groove changes
        this.transitions = {
            instant: 0, // Change immediately
            nextBar: 1, // Change on next bar line
            nextPhrase: 4, // Change on next 4-bar phrase
            fadeIn: 8 // Gradually introduce over 8 beats
        };

        // Current active groove
        this.currentGroove = null;
        this.transitionMode = 'nextBar';
        this.pendingGroove = null;
    }

    /**
     * Get a groove template by name
     */
    getTemplate(name) {
        return this.templates[name.toLowerCase()] || this.templates.straight;
    }

    /**
     * Get emphasis for current beat and subdivision
     */
    getEmphasis(groove, beatNumber, subdivision) {
        if (!groove || !groove.pattern) return 0;

        // Find closest pattern position
        const patternIndex = groove.pattern.subdivisions.findIndex(
            sub => Math.abs(sub - subdivision) < 0.01
        );

        if (patternIndex === -1) return 0;

        return groove.pattern.emphasis[patternIndex] || 0;
    }

    /**
     * Get velocity for current position
     */
    getVelocity(groove, beatNumber, subdivision) {
        if (!groove || !groove.pattern) return 1.0;

        const patternIndex = groove.pattern.subdivisions.findIndex(
            sub => Math.abs(sub - subdivision) < 0.01
        );

        if (patternIndex === -1) return 0;

        return groove.pattern.velocities[patternIndex] || 0;
    }

    /**
     * Get preferred gesture for current position
     */
    getPreferredGesture(groove, beatNumber, subdivision, availableGestures = []) {
        if (!groove || !groove.preferredGestures) return null;

        // Determine the beat type
        let beatType;
        if (subdivision === 0) {
            beatType = 'downbeat';
        } else if (subdivision === 0.5) {
            beatType = 'offbeat';
        } else if (subdivision === 0.25 || subdivision === 0.75) {
            beatType = 'subdivision';
        } else {
            beatType = 'syncopation';
        }

        // Special case for THE ONE in funk
        if (groove.name === 'Funk' && beatNumber % 4 === 0 && subdivision === 0) {
            beatType = 'one';
        }

        const preferred = groove.preferredGestures[beatType] || groove.preferredGestures.fills;
        if (!preferred || preferred.length === 0) return null;

        // Filter to available gestures if provided
        if (availableGestures.length > 0) {
            const available = preferred.filter(g => availableGestures.includes(g));
            if (available.length > 0) {
                return available[Math.floor(Math.random() * available.length)];
            }
        }

        // Return random from preferred
        return preferred[Math.floor(Math.random() * preferred.length)];
    }

    /**
     * Apply humanization to timing
     */
    humanizeTiming(groove, timing) {
        if (!groove || !groove.humanization) return timing;

        const variance = groove.humanization;
        const offset = (Math.random() - 0.5) * variance;
        return Math.max(0, Math.min(1, timing + offset));
    }

    /**
     * Apply swing to subdivision
     */
    applySwing(groove, subdivision) {
        if (!groove || !groove.swing || groove.swing === 0) return subdivision;

        // Apply swing to upbeats (0.5)
        if (Math.abs(subdivision - 0.5) < 0.01) {
            return 0.5 + (groove.swing - 0.5) * 0.5;
        }

        // Apply swing to 16th note upbeats (0.25, 0.75)
        if (Math.abs(subdivision - 0.25) < 0.01) {
            return 0.25 + (groove.swing - 0.5) * 0.25;
        }
        if (Math.abs(subdivision - 0.75) < 0.01) {
            return 0.75 + (groove.swing - 0.5) * 0.25;
        }

        return subdivision;
    }

    /**
     * Set active groove with optional transition
     */
    setGroove(name, transitionMode = null) {
        const groove = this.getTemplate(name);
        if (!groove) return false;

        const mode = transitionMode || this.transitionMode;

        if (mode === 'instant' || !this.currentGroove) {
            this.currentGroove = groove;
            this.pendingGroove = null;
        } else {
            this.pendingGroove = groove;
            // Transition will happen based on mode
        }

        return true;
    }

    /**
     * Handle beat transition
     */
    onBeat(beatNumber) {
        if (!this.pendingGroove) return;

        const shouldTransition =
            (this.transitionMode === 'nextBar' && beatNumber % 4 === 0) ||
            (this.transitionMode === 'nextPhrase' && beatNumber % 16 === 0);

        if (shouldTransition) {
            this.currentGroove = this.pendingGroove;
            this.pendingGroove = null;
        }
    }

    /**
     * Get base movement for current groove
     */
    getBaseMovement() {
        return this.currentGroove?.baseMovement || null;
    }

    /**
     * Get transition style for current groove
     */
    getTransitionStyle() {
        return this.currentGroove?.transitionStyle || 'transitionLean';
    }

    /**
     * Get composite move for current groove
     */
    getCompositeMove() {
        return this.currentGroove?.compositeMove || null;
    }

    /**
     * Check if we should trigger composite move
     * @param {number} beatNumber - Current beat number
     * @returns {boolean} True if composite should trigger
     */
    shouldTriggerComposite(beatNumber) {
        if (!this.currentGroove?.compositeMove) return false;

        // Trigger composite every 4 or 8 bars depending on intensity
        const interval = this.currentGroove.intensity === 'sparse' ? 32 : 16;
        return beatNumber % interval === 0;
    }

    /**
     * Get layered gesture configuration for current position
     * @param {number} beatNumber - Current beat number
     * @param {number} subdivision - Current subdivision (0, 0.25, 0.5, 0.75)
     * @returns {Object} Configuration with base, accent, and transition layers
     */
    getLayeredGestures(beatNumber, subdivision) {
        if (!this.currentGroove) return null;

        const config = {
            base: this.getBaseMovement(),
            accent: null,
            transition: null,
            composite: null,
            velocity: 1.0
        };

        // Check for composite move trigger
        if (this.shouldTriggerComposite(beatNumber) && subdivision === 0) {
            config.composite = this.getCompositeMove();
        }

        // Get accent gesture based on emphasis
        const emphasis = this.getEmphasis(this.currentGroove, beatNumber, subdivision);
        const velocity = this.getVelocity(this.currentGroove, beatNumber, subdivision);

        if (emphasis > 0.3 && velocity > 0.3) {
            config.accent = this.getPreferredGesture(
                this.currentGroove,
                beatNumber,
                subdivision
            );
            config.velocity = velocity;
        }

        // Add transition if changing positions
        if (config.accent && Math.random() < 0.3) {
            config.transition = this.getTransitionStyle();
        }

        return config;
    }

    /**
     * Get all available groove names
     */
    getGrooveNames() {
        return Object.keys(this.templates);
    }

    /**
     * Get groove info for UI
     */
    getGrooveInfo(name) {
        const template = this.templates[name];
        if (!template) return null;

        return {
            name: template.name,
            timeSignature: template.timeSignature,
            description: template.description,
            intensity: template.intensity,
            swing: template.swing,
            baseMovement: template.baseMovement,
            compositeMove: template.compositeMove
        };
    }
}

/**
 * AudioHandler - Manages all audio-related functionality for EmotiveMascot
 * @module mascot/AudioHandler
 */

class AudioHandler {
    constructor(mascot) {
        this.mascot = mascot;
        this.vocalUpdateInterval = null;
    }

    /**
     * Initialize audio handler
     */
    init() {
        // Will contain initialization logic
    }


    /**
     * Disconnect audio analysis
     * @returns {Object} The mascot instance for chaining
     */
    disconnectAudio() {
        // Stop analysis
        if (this.mascot.audioAnalyzer) {
            this.mascot.audioAnalyzer.stop();
        }
        
        // Clear update interval
        if (this.vocalUpdateInterval) {
            clearInterval(this.vocalUpdateInterval);
            this.vocalUpdateInterval = null;
        }
        
        
        // Clear vocal data and analyzer reference
        if (this.mascot.shapeMorpher) {
            this.mascot.shapeMorpher.setVocalEnergy(0);
            this.mascot.shapeMorpher.setAudioDeformation(0);
            this.mascot.shapeMorpher.audioAnalyzer = null;
            this.mascot.shapeMorpher.beatGlitchIntensity = 0;
            this.mascot.shapeMorpher.glitchPoints = [];
        }

        // Stop ambient groove animation when audio stops
        if (this.mascot.renderer) {
            this.mascot.renderer.ambientDanceAnimator.stopAmbientAnimation('grooveBob');
        }

        return this.mascot;
    }

    /**
     * Connect audio element for vocal visualization
     * @param {HTMLAudioElement} audioElement - Audio element to analyze
     * @returns {Object} The mascot instance for chaining
     */
    async connectAudio(audioElement) {
        if (!this.mascot.audioAnalyzer) {
            return this.mascot;
        }
        
        // Initialize audio context if needed
        if (!this.mascot.audioAnalyzer.audioContext) {
            await this.mascot.audioAnalyzer.init();
        }
        
        // Connect the audio element
        this.mascot.audioAnalyzer.connectAudioElement(audioElement);
        
        // Pass analyzer reference to shape morpher for frequency data
        if (this.mascot.shapeMorpher) {
            this.mascot.shapeMorpher.audioAnalyzer = this.mascot.audioAnalyzer;
            
            // Set up beat detection callback for glitches and rhythm detection
            this.mascot.audioAnalyzer.onBeat((amplitude) => {
                if (this.mascot.shapeMorpher) {
                    // Feed beat to music detector for BPM detection
                    if (this.mascot.shapeMorpher.musicDetector) {
                        const now = performance.now();
                        this.mascot.shapeMorpher.musicDetector.addOnset(now, amplitude);
                    }

                    // Only trigger beat glitches when vocals are active
                    if (this.mascot.shapeMorpher.vocalEffectActive) {
                        this.mascot.shapeMorpher.beatGlitchIntensity = amplitude * 0.3;
                    }
                }
            });
        }
        
        // Start updating shape morpher with vocal data
        if (this.vocalUpdateInterval) {
            clearInterval(this.vocalUpdateInterval);
        }
        
        // Start ambient groove animation when audio starts
        // This provides the continuous background movement
        if (this.mascot.renderer) {
            this.mascot.renderer.startGrooveBob({ intensity: 0.5, frequency: 1.0 });
        }

        this.vocalUpdateInterval = setInterval(() => {
            if (this.mascot.audioAnalyzer.isAnalyzing && this.mascot.shapeMorpher) {
                // Get current analysis data directly from properties
                const amplitude = this.mascot.audioAnalyzer.currentAmplitude || 0;
                const vocalInstability = this.mascot.audioAnalyzer.getVocalInstability() || 0;

                // Set vocal energy for shape pulsing
                this.mascot.shapeMorpher.setVocalEnergy(vocalInstability);

                // Set overall deformation based on amplitude (0 to 1, no shrinking)
                this.mascot.shapeMorpher.setAudioDeformation(amplitude * 2); // Keep positive for expansion only
            }
        }, 50); // Update at 20 FPS
        
        // Pass audio analyzer to renderer
        if (this.mascot.renderer) {
            this.mascot.renderer.audioAnalyzer = this.mascot.audioAnalyzer;
        }
        
        return this.mascot;
    }

    /**
     * Stops speech reactivity mode and returns to base emotional state
     * @returns {Object} The mascot instance for chaining
     */
    stopSpeaking() {
        if (!this.mascot.speaking) {
            return this.mascot;
        }
        
        // Store previous state for event
        const previousAudioLevel = this.mascot.audioLevelProcessor.getCurrentLevel();
        
        // Clean up audio level processor
        this.mascot.audioLevelProcessor.cleanup();
        
        // Reset speech state
        this.mascot.speaking = false;
        
        // Notify renderer about speech stop (triggers 500ms return-to-base transition)
        this.mascot.renderer.onSpeechStop();
        
        // Emit speech stop event
        this.mascot.emit('speechStopped', { 
            previousAudioLevel,
            returnToBaseTime: 500
        });
        
        return this.mascot;
    }

    /**
     * Sets master volume for all audio output
     * @param {number} volume - Volume level (0.0 to 1.0)
     * @returns {Object} The mascot instance for chaining
     */
    setVolume(volume) {
        const clampedVolume = Math.max(0, Math.min(1, volume));
        this.mascot.config.masterVolume = clampedVolume;
        
        if (this.mascot.soundSystem.isAvailable()) {
            const currentEmotion = this.mascot.stateMachine.getCurrentState().emotion;
            this.mascot.soundSystem.setMasterVolume(clampedVolume, currentEmotion);
        }
        
        this.mascot.emit('volumeChanged', { volume: clampedVolume });
        
        return this.mascot;
    }

    /**
     * Cleanup
     */
    destroy() {
        this.disconnectAudio();
    }
}

/**
 * GestureController - Manages gesture animations and protocols
 * @module mascot/GestureController
 */

class GestureController {
    constructor(mascot) {
        this.mascot = mascot;
        this.currentGesture = null;
    }

    /**
     * Initialize gesture controller
     */
    init() {
        // Will contain initialization logic
    }

    /**
     * Methods to be moved here:
     * - setGestureProtocol()
     * - performGesture()
     * - Gesture animation logic
     */

    /**
     * Cleanup
     */
    destroy() {
        this.currentGesture = null;
    }
}

/**
 * StateCoordinator - Manages emotion states and transitions
 * @module mascot/StateCoordinator
 */


class StateCoordinator {
    constructor(mascot) {
        this.mascot = mascot;
        this.currentEmotion = 'neutral';
        this.emotionIntensity = 1.0;
    }

    /**
     * Initialize state coordinator
     */
    init() {
        // Will contain initialization logic
    }

    /**
     * Sets the emotional state with optional undertone
     * @param {string} emotion - The emotion to set
     * @param {Object|string|null} options - Options object or undertone string for backward compatibility
     * @returns {Object} The mascot instance for chaining
     */
    setEmotion(emotion, options = null) {
        // Map common aliases to actual emotion states
        const emotionMapping = {
            'happy': 'joy',
            'curious': 'surprise',
            'frustrated': 'anger',
            'sad': 'sadness'
        };
        
        // Use mapped emotion or original if not an alias
        const mappedEmotion = emotionMapping[emotion] || emotion;
        
        // Handle backward compatibility - if options is a string, treat as undertone
        let undertone = null;
        let duration = 500;
        
        if (typeof options === 'string') {
            undertone = options;
        } else if (options && typeof options === 'object') {
            undertone = options.undertone || null;
            duration = options.duration || 500;
        }
        
        // Set emotional state in state machine
        const success = this.mascot.stateMachine.setEmotion(mappedEmotion, undertone, duration);
        
        if (success) {
            // Register emotion's rhythm configuration
            const emotionConfig = getEmotion(mappedEmotion);
            if (emotionConfig) {
                rhythmIntegration.registerConfig('emotion', mappedEmotion, emotionConfig);
            }
            // Clear and reset particles when changing emotional states
            if (this.mascot.particleSystem) {
                // Clear all existing particles
                this.mascot.particleSystem.clear();
                
                // Get the new emotional properties
                const emotionalProps = this.mascot.stateMachine.getCurrentEmotionalProperties();
                
                // Spawn initial particles for the new state
                // Use burst to immediately populate with a few particles
                // DECIMATED neutral
                let initialCount;
                if (mappedEmotion === 'neutral') {
                    initialCount = 1;  // DECIMATED to 1 particle
                } else if (mappedEmotion === 'resting') {
                    initialCount = 4;  // Keep resting at 4
                } else {
                    initialCount = Math.min(3, Math.floor(emotionalProps.particleRate / 4));
                }
                
                if (initialCount > 0) {
                    // Always spawn from canvas center, not gaze-adjusted position
                    const centerX = this.mascot.canvasManager.width / 2;
                    const centerY = this.mascot.canvasManager.height / 2;
                    
                    this.mascot.particleSystem.burst(
                        initialCount, 
                        emotionalProps.particleBehavior,
                        centerX,
                        centerY
                    );
                }
            }
            
            // Update sound system ambient tone - DISABLED (annoying)
            // if (this.mascot.soundSystem.isAvailable()) {
            //     this.mascot.soundSystem.setAmbientTone(mappedEmotion, duration);
            // }
            
            // Update Emotive renderer if in classic mode
            if (this.mascot.config.renderingStyle === 'classic' && this.mascot.renderer.setEmotionalState) {
                const emotionParams = getEmotionVisualParams(mappedEmotion);
                this.mascot.renderer.setEmotionalState(mappedEmotion, emotionParams, undertone);
            }
            
            // Emit emotion change event
            this.mascot.emit('emotionChanged', { emotion: mappedEmotion, undertone, duration });
            
        }
        
        this.currentEmotion = mappedEmotion;
        return this.mascot;
    }

    /**
     * Methods to be moved here:
     * - getEmotion()
     * - setUndertoneModifier()
     * - transitionToEmotion() (new smooth transition)
     * - setEmotionVector() (new 2D control)
     * - Emotion blending logic
     */

    /**
     * Cleanup
     */
    destroy() {
        this.currentEmotion = 'neutral';
    }
}

/**
 * VisualizationRunner - Manages the main animation loop and rendering
 * @module mascot/VisualizationRunner
 */


class VisualizationRunner {
    constructor(mascot) {
        this.mascot = mascot;
        this.animationId = null;
        this.isRunning = false;
        this.lastTime = 0;
    }

    /**
     * Initialize visualization runner
     */
    init() {
        // Will contain initialization logic
    }

    /**
     * Starts the animation loop at target 60 FPS
     * @returns {Object} The mascot instance for chaining
     */
    start() {
        if (this.mascot.animationController.isAnimating()) {
            return this.mascot;
        }
        
        // Start the animation controller
        const success = this.mascot.animationController.start();
        
        if (success) {
            this.mascot.isRunning = true;
            this.isRunning = true;
            
            // Spawn initial particles for classic mode
            if (this.mascot.config.renderingStyle === 'classic' && this.mascot.particleSystem) {
                const currentState = this.mascot.stateMachine.getCurrentState();
                const emotion = currentState.emotion;
                const emotionParams = getEmotionVisualParams(emotion);
                
                // Get the actual orb position from the renderer (includes gaze offset)
                let orbX, orbY;
                if (this.mascot.renderer && this.mascot.renderer.getCurrentOrbPosition) {
                    const orbPos = this.mascot.renderer.getCurrentOrbPosition();
                    orbX = orbPos.x;
                    orbY = orbPos.y;
                } else {
                    // Fallback to center if method doesn't exist
                    orbX = this.mascot.canvasManager.width / 2;
                    orbY = this.mascot.canvasManager.height / 2;
                }
                
                // Clear any existing particles first
                this.mascot.particleSystem.clear();
                
                // Check if emotion has specific particle configuration
                if (emotionParams.particleRate > 0) {
                    // Spawn initial burst of particles
                    const initialCount = Math.min(3, Math.floor(emotionParams.particleRate / 4));
                    
                    if (initialCount > 0) {
                        this.mascot.particleSystem.burst(
                            initialCount,
                            emotionParams.particleBehavior,
                            orbX,
                            orbY
                        );
                    }
                }
            }
            
            // Start degradation monitoring
            if (this.mascot.degradationManager) {
                this.mascot.degradationManager.startMonitoring();
            }
            
            // Emit start event
            this.mascot.emit('started');
        }
        
        return this.mascot;
    }

    /**
     * Stops the animation loop and cleans up resources
     * @returns {Object} The mascot instance for chaining
     */
    stop() {
        if (!this.mascot.animationController.isAnimating()) {
            return this.mascot;
        }
        
        // Stop speech reactivity if active
        if (this.mascot.speaking) {
            this.mascot.audioHandler.stopSpeaking();
        }
        
        // Stop the animation controller
        const success = this.mascot.animationController.stop();
        
        if (success) {
            this.mascot.isRunning = false;
            this.isRunning = false;
            
            // Stop degradation monitoring
            if (this.mascot.degradationManager) {
                this.mascot.degradationManager.stopMonitoring();
            }
            
            // Emit stop event
            this.mascot.emit('stopped');
        }
        
        return this.mascot;
    }

    /**
     * Updates audio level monitoring and other per-frame updates
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    update(deltaTime) {
        // Update audio level monitoring if speaking
        if (this.mascot.speaking && this.mascot.audioLevelProcessor.isProcessingActive()) {
            this.mascot.audioLevelProcessor.updateAudioLevel(deltaTime);
        }
        
        // Update classic mode components
        if (this.mascot.config.renderingStyle === 'classic') {
            // Update gaze tracker
            if (this.mascot.gazeTracker) {
                this.mascot.gazeTracker.update(deltaTime);
                
                // Update threat level for suspicion emotion
                const currentEmotion = this.mascot.stateMachine.getCurrentState().emotion;
                if (currentEmotion === 'suspicion') {
                    // Get mouse position and calculate distance to center
                    const mousePos = this.mascot.gazeTracker.mousePos;
                    const centerX = this.mascot.canvas.width / 2;
                    const centerY = this.mascot.canvas.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(mousePos.x - centerX, 2) + 
                        Math.pow(mousePos.y - centerY, 2)
                    );
                    
                    // Get emotion configuration
                    const suspicionEmotion = getEmotion('suspicion');
                    if (suspicionEmotion && suspicionEmotion.visual) {
                        const maxDistance = Math.min(centerX, centerY);
                        const threatLevel = Math.max(0, Math.min(1, 1 - (distance / maxDistance)));
                        suspicionEmotion.visual.threatLevel = threatLevel;
                    }
                }
            }
            
            // Update idle behaviors
            if (this.mascot.idleBehavior) {
                this.mascot.idleBehavior.update(deltaTime);
            }
            
            // Combine gaze and sway offsets
            if (this.mascot.gazeTracker && this.mascot.idleBehavior) {
                const gazeOffset = this.mascot.gazeTracker.getGazeOffset();
                const swayOffset = this.mascot.idleBehavior.getSwayOffset();
                
                // Get full gaze state including proximity for eye narrowing
                const gazeState = this.mascot.gazeTracker.getState();
                
                // Combine the offsets and include proximity data
                const gazeData = {
                    offset: {
                        x: gazeOffset.x + swayOffset.x,
                        y: gazeOffset.y + swayOffset.y
                    },
                    proximity: gazeState.proximity,
                    isFocused: gazeState.isFocused
                };
                
                // Pass to renderer
                if (this.mascot.renderer.setGazeData) {
                    this.mascot.renderer.setGazeData(gazeData);
                }
            }
        }
    }

    /**
     * Cleanup
     */
    destroy() {
        this.stop();
    }
}

/**
 * ConfigurationManager - Manages settings and configuration
 * @module mascot/ConfigurationManager
 */

class ConfigurationManager {
    constructor(mascot, config = {}) {
        this.mascot = mascot;
        this.config = this.validateConfig(config);
    }

    /**
     * Validate and set defaults for configuration
     */
    validateConfig(config) {
        return {
            canvasId: config.canvasId || 'emotive-canvas',
            startingEmotion: config.startingEmotion || 'neutral',
            emotionalResponsiveness: config.emotionalResponsiveness ?? 0.5,
            particleIntensity: config.particleIntensity ?? 1.0,
            glowIntensity: config.glowIntensity ?? 1.0,
            audioEnabled: config.audioEnabled ?? false,
            showFPS: config.showFPS ?? false,
            debugMode: config.debugMode ?? false,
            renderMode: config.renderMode || 'default',
            maxParticles: config.maxParticles || 100,
            ...config
        };
    }

    /**
     * Methods to be moved here:
     * - getConfig()
     * - updateConfig()
     * - Configuration validation
     */

    /**
     * Get current configuration
     */
    getConfig() {
        return { ...this.config };
    }

    /**
     * Update configuration
     */
    updateConfig(updates) {
        this.config = { ...this.config, ...updates };
        return this.config;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                   ◐ ◑ ◒ ◓  EMOTIVE MASCOT  ◓ ◒ ◑ ◐                   
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview EmotiveMascot - Main API Class for the Emotive Engine
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module EmotiveMascot
 * @changelog 2.1.0 - Added resize handling with visual resampling for consistent quality
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The MAIN ORCHESTRATOR of the Emotive Engine. This is the primary API class        
 * ║ that developers interact with. It coordinates all subsystems, manages the         
 * ║ lifecycle, and provides the fluent API for emotional expression.                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 CORE FEATURES                                                                  
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Emotional state management with smooth transitions                              
 * │ • Gesture triggering and animation control                                        
 * │ • Particle system orchestration                                                   
 * │ • Dynamic visual resampling on resize                                             
 * │ • Plugin system for extensibility                                                 
 * │ • Event handling and listener management                                          
 * │ • Performance optimization and degradation                                        
 * │ • Accessibility features                                                          
 * │ • Mobile optimization                                                             
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class EmotiveMascot {
    constructor(config = {}) {
        // Initialize error boundary first
        this.errorBoundary = new ErrorBoundary();
        
        // Initialize EventManager with simple event emitter functionality
        this.eventManager = new EventManager({
            maxListeners: config.maxEventListeners || 100,
            enableDebugging: config.enableEventDebugging || false,
            enableMonitoring: config.enableEventMonitoring || true,
            memoryWarningThreshold: config.eventMemoryWarningThreshold || 50
        });

        // Add simple event emitter methods if not present
        if (!this.eventManager.emit) {
            this.eventManager._listeners = {};
            this.eventManager.emit = (event, data) => {
                const listeners = this.eventManager._listeners[event];
                if (listeners) {
                    listeners.forEach(listener => listener(data));
                }
            };
            this.eventManager.on = (event, listener) => {
                if (!this.eventManager._listeners[event]) {
                    this.eventManager._listeners[event] = [];
                }
                this.eventManager._listeners[event].push(listener);
            };
            this.eventManager.off = (event, listener) => {
                const listeners = this.eventManager._listeners[event];
                if (listeners) {
                    const index = listeners.indexOf(listener);
                    if (index > -1) {
                        listeners.splice(index, 1);
                    }
                }
            };
        }
        
        // Wrap initialization in error boundary
        this.errorBoundary.wrap(() => {
            this.initialize(config);
        }, 'initialization')();
    }

    /**
     * Get default duration for a gesture
     */
    /**
     * Initialize the mascot system
     * @param {Object} config - Configuration options
     */
    initialize(config) {
        // Get browser-specific optimizations
        const browserOpts = browserCompatibility.browserOptimizations.getOptimizations();
        
        // Default configuration with browser-specific optimizations
        const defaults = {
            canvasId: 'emotive-mascot',
            targetFPS: 60,
            enableAudio: browserCompatibility.featureDetection.features.webAudio,
            soundEnabled: false,  // Disable gesture sounds by default
            masterVolume: 0.5,
            maxParticles: browserOpts.particleLimit,
            defaultEmotion: 'neutral',
            enableAutoOptimization: true,
            enableGracefulDegradation: true,
            renderingStyle: 'classic',  // 'classic' (Emotive) or 'advanced' (3-layer)
            enableGazeTracking: true,
            enableIdleBehaviors: true,
            classicConfig: {
                coreColor: '#FFFFFF',
                coreSizeDivisor: 12,      // Core radius = canvas_size / 12 (original Emotive)
                glowMultiplier: 2.5,      // Glow radius = core * 2.5 (original Emotive)
                defaultGlowColor: '#14B8A6'
            },
            topOffset: 0  // Vertical offset to shift mascot upward (in pixels)
        };
        
        this.config = { ...defaults, ...config };
        
        // Get canvas element
        this.canvas = typeof this.config.canvasId === 'string' 
            ? document.getElementById(this.config.canvasId)
            : this.config.canvasId;
            
        if (!this.canvas) {
            throw new Error(`Canvas with ID '${this.config.canvasId}' not found`);
        }

        // Initialize core systems with browser compatibility
        this.canvasManager = new CanvasManager(this.canvas);
        
        // Set up canvas context recovery
        this.contextRecovery = new CanvasContextRecovery(this.canvas);
        this.contextRecovery.onRecovery((context) => {
            // Canvas context recovered, reinitializing renderer
            if (this.renderer) {
                this.renderer.handleContextRecovery(context);
            }
        });
        
        // Apply browser-specific canvas optimizations
        browserCompatibility.browserOptimizations.applyCanvasOptimizations(
            this.canvas, 
            this.canvasManager.getContext()
        );
        
        this.stateMachine = new EmotiveStateMachine(this.errorBoundary);
        this.particleSystem = new ParticleSystem(this.config.maxParticles, this.errorBoundary);
        
        // Always use EmotiveRenderer, pass full config including topOffset
        this.renderer = new EmotiveRenderer(this.canvasManager, {
            ...this.config.classicConfig,
            topOffset: this.config.topOffset || 0
        });
        
        // Initialize shape morphing and audio analysis early
        this.shapeMorpher = new ShapeMorpher();
        this.audioAnalyzer = new AudioAnalyzer();

        // Gesture compatibility system
        this.gestureCompatibility = gestureCompatibility;

        // Groove templates for musical rhythm patterns
        this.grooveTemplates = new GrooveTemplates();
        
        // Pass audioAnalyzer to shapeMorpher for audio-reactive deformation
        this.shapeMorpher.audioAnalyzer = this.audioAnalyzer;
        
        // Pass them to renderer
        this.renderer.shapeMorpher = this.shapeMorpher;
        this.renderer.audioAnalyzer = this.audioAnalyzer;
        
        // Connect renderer and state machine for undertone modifiers
        this.renderer.stateMachine = this.stateMachine;
        this.stateMachine.renderer = this.renderer;
        
        // Initialize gaze tracking
        if (this.config.enableGazeTracking) {
            this.gazeTracker = new GazeTracker(this.canvas, {
                smoothing: 0.1,
                maxOffset: 0.15,
                enabled: true
            });
            
            // Reset idle timer on interaction and wake if sleeping
            this.gazeTracker.setInteractionCallback(() => {
                if (this.sleeping) {
                    // Wake with full animation sequence
                    this.wake();
                } else if (this.idleBehavior) {
                    // Just reset idle timer if not sleeping
                    this.idleBehavior.resetIdleTimer();
                }
            });
        }
        
        // Initialize idle behaviors
        if (this.config.enableIdleBehaviors) {
            this.idleBehavior = new IdleBehavior({
                enabled: true,
                sleepTimeout: Infinity  // Disable automatic sleep
            });
            
            // Connect idle behavior callbacks to renderer
            this.idleBehavior.setCallback('onBlink', (data) => {
                if (this.renderer && this.renderer.state) {
                    this.renderer.state.blinking = data.phase === 'start';
                }
            });
            
            this.idleBehavior.setCallback('onSleep', () => {
                if (this.renderer && this.renderer.enterSleepMode) {
                    this.renderer.enterSleepMode();
                }
            });
            
            this.idleBehavior.setCallback('onWake', () => {
                if (this.renderer && this.renderer.wakeUp) {
                    this.renderer.wakeUp();
                }
            });
        }
        
        this.soundSystem = new SoundSystem();
        
        // DegradationManager removed - no performance interference
        this.degradationManager = null;
        
        // Initialize accessibility manager
        this.accessibilityManager = new AccessibilityManager({
            enableReducedMotion: this.config.enableReducedMotion !== false,
            enableHighContrast: this.config.enableHighContrast !== false,
            enableScreenReaderSupport: this.config.enableScreenReaderSupport !== false,
            enableKeyboardNavigation: this.config.enableKeyboardNavigation !== false,
            colorBlindMode: this.config.colorBlindMode || 'none'
        });
        
        // Initialize mobile optimization
        this.mobileOptimization = new MobileOptimization({
            enableTouchOptimization: this.config.enableTouchOptimization !== false,
            enableViewportHandling: this.config.enableViewportHandling !== false,
            enableBatteryOptimization: this.config.enableBatteryOptimization !== false
        });
        
        // Set canvas for mobile optimization
        this.mobileOptimization.setCanvas(this.canvas);
        
        // Initialize plugin system
        this.pluginSystem = new PluginSystem({
            enablePlugins: this.config.enablePlugins !== false,
            validatePlugins: this.config.validatePlugins !== false,
            sandboxPlugins: this.config.sandboxPlugins !== false
        });
        
        // Initialize audio level processor for speech reactivity
        this.audioLevelProcessor = new AudioLevelProcessor({
            spikeThreshold: this.config.spikeThreshold || 1.5,
            minimumSpikeLevel: this.config.minimumSpikeLevel || 0.1,
            spikeMinInterval: this.config.spikeMinInterval || 1000
        });
        
        // Initialize animation controller
        try {
            this.animationController = new AnimationController(this.errorBoundary, {
                targetFPS: this.config.targetFPS
            });
        } catch (error) {
            // Failed to initialize AnimationController
            // Fallback: create a minimal animation controller interface
            this.animationController = {
                isAnimating: () => this.isRunning,
                start: () => { this.isRunning = true; return true; },
                stop: () => { this.isRunning = false; return true; },
                setTargetFPS: () => {},
                targetFPS: this.config.targetFPS,
                getPerformanceMetrics: () => ({ fps: 0, isRunning: this.isRunning, performanceDegradation: false, deltaTime: 16, frameCount: 0, targetFPS: this.config.targetFPS }),
                setSubsystems: () => {},
                setEventCallback: () => {},
                setParentMascot: () => {},
                destroy: () => {},
                deltaTime: 16
            };
        }
        
        // Configure animation controller with subsystems
        this.animationController.setSubsystems({
            stateMachine: this.stateMachine,
            particleSystem: this.particleSystem,
            renderer: this.renderer,
            soundSystem: this.soundSystem,
            canvasManager: this.canvasManager
        });
        
        // Set up event forwarding from animation controller
        this.animationController.setEventCallback((event, data) => {
            this.emit(event, data);
        });
        
        // Set parent mascot reference for audio level updates
        this.animationController.setParentMascot(this);
        
        // Runtime state
        this.isRunning = false;
        
        // Initialize sound system if enabled
        if (this.config.enableAudio) {
            this.soundSystem.initialize().then(success => {
                if (success) {
                    this.soundSystem.setMasterVolume(this.config.masterVolume);
                    // Sound system initialized successfully
                }
            });
        }
        
        // Speech reactivity state
        this.speaking = false;
        
        // Track warning frequency to reduce spam
        this.warningTimestamps = {};
        
        // Initialize rhythm integration
        this.rhythmEnabled = false;
        rhythmIntegration.initialize();

        // Expose rhythmIntegration globally for UI controls
        // Store rhythm integration internally instead of global
        this.rhythmIntegration = rhythmIntegration;
        this.warningThrottle = 5000; // Only show same warning every 5 seconds
        
        // Recording state (listening/capturing)
        this.recording = false;
        
        // Sleeping state
        this.sleeping = false;
        
        // TTS (Text-to-Speech) state
        this.tts = {
            available: typeof window !== 'undefined' && 'speechSynthesis' in window,
            speaking: false,
            currentUtterance: null
        };
        
        // Initialize modular handlers
        this.audioHandler = new AudioHandler(this);
        this.gestureController = new GestureController(this);
        this.stateCoordinator = new StateCoordinator(this);
        this.visualizationRunner = new VisualizationRunner(this);
        this.configurationManager = new ConfigurationManager(this, config);
        
        // Initialize the handlers
        this.audioHandler.init();
        this.gestureController.init();
        this.stateCoordinator.init();
        this.visualizationRunner.init();
        
        // EventManager already initialized in constructor
        
        // Initialize debugging if enabled
        this.debugMode = this.config.enableDebug || false;
        if (this.debugMode) {
            emotiveDebugger.log('INFO', 'Debug mode enabled for EmotiveMascot', {
                config: this.config,
                runtimeCapabilities: runtimeCapabilities.generateReport()
            });
            
            // Start profiling initialization
            emotiveDebugger.startProfile('mascot-initialization', {
                canvasId: this.config.canvasId,
                maxParticles: this.config.maxParticles
            });
        }
        
        // Set up audio level processor callbacks
        this.setupAudioLevelProcessorCallbacks();
        
        // Set initial emotional state
        this.stateMachine.setEmotion(this.config.defaultEmotion);
        
        // Register for canvas resize events to trigger visual resampling
        this.canvasManager.onResize((width, height, dpr) => {
            this.handleResize(width, height, dpr);
        });
        
        // Log browser compatibility information
        // EmotiveMascot initialized successfully
        
        // Complete initialization profiling
        if (this.debugMode) {
            emotiveDebugger.endProfile('mascot-initialization');
            emotiveDebugger.takeMemorySnapshot('post-initialization');
        }
    }

    /**
     * Handle degradation manager events
     * @param {string} event - Event type
     * @param {Object} data - Event data
     */
    handleDegradationEvent(event, data) {
        switch (event) {
            case 'degradationApplied':
                // Silently handle performance degradation
                this.applyDegradationSettings(data.settings);
                this.emit('performanceDegradation', data);
                break;
                
            case 'recoveryApplied':
                // Silently handle performance recovery
                this.applyDegradationSettings(data.settings);
                this.emit('performanceRecovery', data);
                break;
                
            case 'levelChanged':
                // Silently handle degradation level change
                this.applyDegradationSettings(data.settings);
                this.emit('degradationLevelChanged', data);
                break;
        }
    }

    /**
     * Apply degradation settings to all systems
     * @param {Object} settings - Degradation settings
     */
    applyDegradationSettings(settings) {
        // Update particle system limits
        if (this.particleSystem && settings.particleLimit !== undefined) {
            this.particleSystem.setMaxParticles(settings.particleLimit);
        }
        
        // Update audio system
        if (this.soundSystem && settings.audioEnabled !== undefined) {
            if (!settings.audioEnabled && this.soundSystem.isAvailable()) {
                this.soundSystem.stopAmbientTone(200);
            }
        }
        
        // DISABLED - Don't change FPS based on degradation
        /*
        // Update animation controller target FPS
        if (this.animationController && settings.targetFPS !== undefined) {
            this.animationController.setTargetFPS(settings.targetFPS);
        }
        */
        
        // Update renderer quality
        if (this.renderer && settings.qualityLevel !== undefined) {
            this.renderer.setQualityLevel(settings.qualityLevel);
        }
    }

    /**
     * Set up callbacks for the audio level processor
     */
    setupAudioLevelProcessorCallbacks() {
        // Handle audio level updates
        this.audioLevelProcessor.onLevelUpdate((data) => {
            // Update renderer with current audio level
            this.renderer.updateAudioLevel(data.level);
            
            // Emit audio level update event
            this.emit('audioLevelUpdate', {
                level: data.level,
                rawData: Array.from(data.rawData),
                timestamp: data.timestamp
            });
        });
        
        // Handle volume spikes for gesture triggering
        this.audioLevelProcessor.onVolumeSpike((spikeData) => {
            // Trigger pulse gesture if not already active
            // Check if any particle has an active gesture
            const hasActiveGesture = this.particleSystem.particles.some(p => p.gestureProgress < 1);
            if (!hasActiveGesture) {
                ({
                    emotion: this.stateMachine.getCurrentState().emotion,
                    properties: this.stateMachine.getCurrentEmotionalProperties()
                });
                
                // Execute pulse gesture through express method
                this.express('pulse');
                
                {
                    // Emit volume spike event with gesture trigger info
                    this.emit('volumeSpike', {
                        ...spikeData,
                        gestureTriggered: true
                    });
                    
                    // Volume spike detected - triggered pulse gesture
                }
            }
        });
        
        // Handle audio processing errors
        this.audioLevelProcessor.onError((errorData) => {
            // AudioLevelProcessor error
            this.emit('audioProcessingError', errorData);
        });
    }

    /**
     * Sets the emotional state with optional undertone
     * @param {string} emotion - The emotion to set
     * @param {Object|string|null} options - Options object or undertone string
     * @returns {EmotiveMascot} This instance for chaining
     */
    setEmotion(emotion, options = null) {
        return this.errorBoundary.wrap(() => {
            return this.stateCoordinator.setEmotion(emotion, options);
        }, 'emotion-setting', this)();
    }
    
    /**
     * Update the undertone without resetting emotion
     * @param {string|null} undertone - The undertone to apply (subdued, tired, nervous, energetic, confident, intense, or null)
     * @returns {EmotiveMascot} This instance for chaining
     */
    updateUndertone(undertone) {
        return this.errorBoundary.wrap(() => {
            // Update state machine's undertone
            this.stateMachine.applyUndertoneModifier(undertone);
            // Update renderer's undertone without resetting emotion
            if (this.renderer && this.renderer.updateUndertone) {
                this.renderer.updateUndertone(undertone);
            }
            return this;
        }, 'undertone-update', this)();
    }
    
    /**
     * Set BPM for core rotation (record player effect)
     * @param {number} bpm - Beats per minute
     * @returns {EmotiveMascot} This instance for chaining
     */
    setBPM(bpm) {
        return this.errorBoundary.wrap(() => {
            if (this.renderer && this.renderer.setBPM) {
                this.renderer.setBPM(bpm);
            }
            return this;
        }, 'bpm-update', this)();
    }

    /**
     * Set manual rotation speed for the shape
     * @param {number} speed - Rotation speed (-1 to 1, negative for reverse)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setRotationSpeed(speed) {
        return this.errorBoundary.wrap(() => {
            if (this.renderer && this.renderer.setRotationSpeed) {
                this.renderer.setRotationSpeed(speed);
            }
            return this;
        }, 'rotation-speed-update', this)();
    }

    /**
     * Set manual rotation angle directly (for scratching)
     * @param {number} angle - Rotation angle in radians
     * @returns {EmotiveMascot} This instance for chaining
     */
    setRotationAngle(angle) {
        return this.errorBoundary.wrap(() => {
            if (this.renderer && this.renderer.setRotationAngle) {
                this.renderer.setRotationAngle(angle);
            }
            return this;
        }, 'rotation-angle-update', this)();
    }

    /**
     * Enable or disable gaze tracking
     * @param {boolean} enabled - Whether to enable gaze tracking
     * @returns {EmotiveMascot} This instance for chaining
     */
    setGazeTracking(enabled) {
        return this.errorBoundary.wrap(() => {
            if (this.renderer && this.renderer.setGazeTracking) {
                this.renderer.setGazeTracking(enabled);
            }
            return this;
        }, 'gaze-tracking-update', this)();
    }

    /**
     * Executes a single gesture or chord (multiple simultaneous gestures)
     * @param {string|Array<string>|Object} gesture - Single gesture, array of gestures, or chord object
     * @param {Object} options - Options for the gesture execution
     * @returns {EmotiveMascot} This instance for chaining
     */
    express(gesture, options = {}) {
        return this.errorBoundary.wrap(() => {
            // Performance marker: Gesture start
            const gestureStartTime = performance.now();
            const gestureName = Array.isArray(gesture) ? 'chord' :
                               (typeof gesture === 'object' && gesture.type === 'chord') ? 'chord' :
                               gesture;

            if (this.performanceMonitor) {
                this.performanceMonitor.markGestureStart(gestureName);
            }

            if (!gesture) {
                // No gesture provided to express()
                if (this.performanceMonitor) {
                    this.performanceMonitor.markGestureEnd(gestureName);
                }
                return this;
            }

            // Handle chord (multiple simultaneous gestures)
            if (Array.isArray(gesture)) {
                return this.expressChord(gesture, options);
            }

            // Handle chord object
            if (typeof gesture === 'object' && gesture.type === 'chord') {
                return this.expressChord(gesture.gestures, options);
            }

            // Express called with single gesture
            // In rhythm game mode, gestures will be triggered directly by gameplay
            // No queuing needed - immediate response to player actions

            // Direct mapping to renderer methods for all gestures
            const rendererMethods = {
                'bounce': 'startBounce',
                'pulse': 'startPulse',
                'shake': 'startShake',
                'spin': 'startSpin',
                'nod': 'startNod',
                'tilt': 'startTilt',
                'expand': 'startExpand',
                'contract': 'startContract',
                'flash': 'startFlash',
                'drift': 'startDrift',
                'stretch': 'startStretch',
                'glow': 'startGlow',
                'sparkle': 'startSparkle',
                'shimmer': 'startShimmer',
                'wiggle': 'startWiggle',
                'groove': 'startGroove',
                'point': 'startPoint',
                'lean': 'startLean',
                'reach': 'startReach',
                'headBob': 'startHeadBob',
                'orbit': 'startOrbit',
                'flicker': 'startFlicker',
                'vibrate': 'startVibrate',
                'wave': 'startWave',
                'breathe': 'startBreathe',
                'morph': 'startMorph',
                'slowBlink': 'startSlowBlink',
                'look': 'startLook',
                'settle': 'startSettle',
                'orbit': 'startOrbital',
                'orbital': 'startOrbital',  // Alias for backwards compatibility
                'hula': 'startHula',
                'sway': 'startSway',
                'breathIn': 'startBreathIn',
                'breathOut': 'startBreathOut',
                'breathHold': 'startBreathHold',
                'breathHoldEmpty': 'startBreathHoldEmpty',
                'jump': 'startJump',
                'rain': 'startRain',
                'runningman': 'startRunningMan',
                'charleston': 'startCharleston',
                // Ambient dance gestures
                'grooveSway': 'startGrooveSway',
                'grooveBob': 'startGrooveBob',
                'grooveFlow': 'startGrooveFlow',
                'groovePulse': 'startGroovePulse',
                'grooveStep': 'startGrooveStep'
                // Note: burst, peek, hold, scan, twitch, jitter, float
                // are handled by the gesture system below
            };
            
            // Check if this gesture has a direct renderer method
            const methodName = rendererMethods[gesture];
            if (methodName && this.renderer && this.renderer[methodName]) {
                // Call the renderer method directly
                this.renderer[methodName](options);

                // Play gesture sound effect if available and enabled
                if (this.config.soundEnabled && this.soundSystem.isAvailable()) {
                    this.soundSystem.playGestureSound(gesture);
                }

                // Performance marker: Gesture end
                if (this.performanceMonitor) {
                    const gestureEndTime = performance.now();
                    this.performanceMonitor.markGestureEnd(gestureName);
                    this.performanceMonitor.recordGestureTime(gestureName, gestureEndTime - gestureStartTime);
                }

                return this;
            }
            
            // Try to execute gesture through the particle system
            // This handles modular gestures from the gesture registry
            // Check if gesture exists in the gesture registry
            const gestureConfig = getGesture(gesture);
            
            if (gestureConfig) {
                // Register gesture's rhythm configuration
                rhythmIntegration.registerConfig('gesture', gesture, gestureConfig);
                
                // Store the current gesture info for the particle system to use
                this.currentModularGesture = {
                    type: gesture,
                    config: gestureConfig,
                    startTime: performance.now(),
                    duration: gestureConfig.defaultParams?.duration || 1000,
                    progress: 0
                };
                
                // Executed gesture through particle system
                
                // Play gesture sound effect if available and enabled
                if (this.config.soundEnabled && this.soundSystem.isAvailable()) {
                    this.soundSystem.playGestureSound(gesture);
                }

                // Performance marker: Gesture end
                if (this.performanceMonitor) {
                    const gestureEndTime = performance.now();
                    this.performanceMonitor.markGestureEnd(gestureName);
                    this.performanceMonitor.recordGestureTime(gestureName, gestureEndTime - gestureStartTime);
                }

                return this;
            }
            
            // Unknown gesture - throttled warning
            this.throttledWarn(`Unknown gesture: ${gesture}`, `gesture_${gesture}`);

            // Performance marker: Gesture end (failed)
            if (this.performanceMonitor) {
                this.performanceMonitor.markGestureEnd(gestureName);
            }

            return this;
        }, 'gesture-expression', this)();
    }

    /**
     * Express multiple gestures simultaneously (chord)
     * @param {Array<string>} gestures - Array of gesture names to execute together
     * @param {Object} options - Options for the chord execution
     * @returns {EmotiveMascot} This instance for chaining
     */
    expressChord(gestures, options = {}) {
        return this.errorBoundary.wrap(() => {
            if (!gestures || !Array.isArray(gestures) || gestures.length === 0) {
                return this;
            }

            // Import gesture compatibility if not loaded
            if (!this.gestureCompatibility) {
                // Try to load it dynamically
                Promise.resolve().then(function () { return GestureCompatibility$1; }).then(module => {
                    this.gestureCompatibility = module.default;
                }).catch(err => {
                    console.warn('GestureCompatibility not available:', err);
                });
            }

            // Use compatibility system if available
            const compatibleGestures = this.gestureCompatibility ?
                this.gestureCompatibility.getCompatibleGestures(gestures) :
                gestures;

            console.log('Executing gesture chord:', compatibleGestures);

            // Execute all compatible gestures simultaneously
            compatibleGestures.forEach(gestureName => {
                const normalizedGesture = typeof gestureName === 'string' ?
                    gestureName : gestureName.gestureName;

                // Execute directly to ensure simultaneity
                this.executeGestureDirectly(normalizedGesture, options);
            });

            // Check for enhancing combination
            if (this.gestureCompatibility?.isEnhancingCombination?.(compatibleGestures)) {
                // Add extra visual flair
                this.renderer?.specialEffects?.addSparkle?.();
            }

            return this;
        }, 'gesture-chord', this)();
    }

    /**
     * Execute a gesture directly on the renderer (bypasses routing)
     * @private
     */
    executeGestureDirectly(gesture, options = {}) {
        // Direct mapping to renderer methods
        const rendererMethods = {
            'bounce': 'startBounce',
            'pulse': 'startPulse',
            'shake': 'startShake',
            'spin': 'startSpin',
            'nod': 'startNod',
            'tilt': 'startTilt',
            'flash': 'startFlash',
            'glow': 'startGlow',
            'sparkle': 'startSparkle',
            'shimmer': 'startShimmer',
            'wiggle': 'startWiggle',
            'groove': 'startGroove',
            'point': 'startPoint',
            'lean': 'startLean',
            'reach': 'startReach',
            'headBob': 'startHeadBob',
            'orbit': 'startOrbit',
            'sway': 'startSway',
            'jump': 'startJump',
            'wave': 'startWave',
            'flicker': 'startFlicker',
            'breathe': 'startBreathe',
            'float': 'startFloat',
            'rain': 'startRain',
            'hula': 'startHula',
            'twist': 'startTwist'
        };

        const methodName = rendererMethods[gesture];
        if (methodName && this.renderer && typeof this.renderer[methodName] === 'function') {
            this.renderer[methodName](options);
        }

        // Emit event
        this.emit('gesture', { name: gesture, options });
    }

    /**
     * Chains multiple gestures for sequential execution
     * @param {...string} gestures - Gestures to chain
     * @returns {EmotiveMascot} This instance for chaining
     */
    chain(...gestures) {
        // Parse the chain using GestureCompatibility if available
        if (this.gestureCompatibility) {
            const steps = this.gestureCompatibility.parseChain(gestures.join('>'));
            // Execute first step (which might be a chord)
            if (steps.length > 0) {
                const firstStep = steps[0];
                if (firstStep.length > 1) {
                    this.expressChord(firstStep);
                } else {
                    this.express(firstStep[0]);
                }
            }
        } else {
            // Fallback: execute first gesture
            if (gestures.length > 0) {
                this.express(gestures[0]);
            }
        }
        return this;
    }

    /**
     * Starts speech reactivity mode with audio level monitoring
     * @param {AudioContext} audioContext - Web Audio API context
     * @returns {EmotiveMascot} This instance for chaining
     */
    startSpeaking(audioContext) {
        return this.errorBoundary.wrap(() => {
            if (!audioContext) {
                throw new Error('AudioContext is required for speech reactivity');
            }
            
            if (!this.config.enableAudio) {
                // Audio is disabled, cannot start speech reactivity
                return this;
            }
            
            if (this.speaking) {
                // Speech reactivity is already active
                return this;
            }
            
            // Initialize audio level processor
            const success = this.audioLevelProcessor.initialize(audioContext);
            
            if (!success) {
                // Failed to initialize audio level processor
                return this;
            }
            
            // Update speech state
            this.speaking = true;
            
            // Notify renderer about speech start
            this.renderer.onSpeechStart(audioContext);
            
            // Emit speech start event with analyser for external connection
            this.emit('speechStarted', { 
                audioContext, 
                analyser: this.audioLevelProcessor.getAnalyser(),
                mascot: this
            });
            
            // Speech reactivity started - connect audio source to analyser
            return this;
        }, 'speech-start', this)();
    }

    /**
     * Stops speech reactivity mode and returns to base emotional state
     * @returns {EmotiveMascot} This instance for chaining
     */
    stopSpeaking() {
        return this.errorBoundary.wrap(() => {
            return this.audioHandler.stopSpeaking();
        }, 'speech-stop', this)();
    }

    /**
     * Speaks text using the Web Speech API with visual feedback
     * @param {string} text - Text to speak
     * @param {Object} options - Speech options (rate, pitch, volume, voice)
     * @returns {EmotiveMascot} This instance for chaining
     */
    speak(text, options = {}) {
        return this.errorBoundary.wrap(() => {
            if (!this.tts.available) {
                // Text-to-Speech is not available in this browser
                return this;
            }
            
            if (!text || typeof text !== 'string') {
                // Invalid text provided to speak()
                return this;
            }
            
            // Cancel any ongoing speech
            if (this.tts.speaking) {
                window.speechSynthesis.cancel();
            }
            
            // Create utterance
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Apply options
            utterance.rate = options.rate || 1.0;
            utterance.pitch = options.pitch || 1.0;
            utterance.volume = options.volume || 1.0;
            
            // Select voice if specified
            if (options.voice) {
                const voices = window.speechSynthesis.getVoices();
                const selectedVoice = voices.find(v => v.name === options.voice);
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }
            }
            
            // Store current utterance
            this.tts.currentUtterance = utterance;
            
            // Handle speech events
            utterance.onstart = () => {
                this.tts.speaking = true;
                
                // Trigger speaking gesture
                this.express('pulse');
                
                // Emit TTS start event
                this.emit('ttsStarted', { text, options });
                
                // TTS started
            };
            
            utterance.onend = () => {
                this.tts.speaking = false;
                this.tts.currentUtterance = null;
                
                // Return to neutral
                this.express('nod');
                
                // Emit TTS end event
                this.emit('ttsEnded', { text });
                
                // TTS ended
            };
            
            utterance.onerror = (error) => {
                this.tts.speaking = false;
                this.tts.currentUtterance = null;
                
                // TTS error
                this.emit('ttsError', { error, text });
            };
            
            // Add word boundary events for more dynamic animation
            utterance.onboundary = (event) => {
                if (event.name === 'word') {
                    // Subtle pulse on each word
                    if (Math.random() < 0.3) { // 30% chance per word
                        // Trigger micro pulse gesture
                        this.express('pulse');
                    }
                }
            };
            
            // Start speaking
            window.speechSynthesis.speak(utterance);
            
            return this;
        }, 'tts-speak', this)();
    }
    
    /**
     * Stops any ongoing text-to-speech
     * @returns {EmotiveMascot} This instance for chaining
     */
    stopTTS() {
        return this.errorBoundary.wrap(() => {
            if (!this.tts.available) {
                return this;
            }
            
            if (this.tts.speaking) {
                window.speechSynthesis.cancel();
                this.tts.speaking = false;
                this.tts.currentUtterance = null;
                
                // Return to neutral
                this.express('nod');
                
                // Emit TTS stopped event
                this.emit('ttsStopped');
                
                // TTS stopped by user
            }
            
            return this;
        }, 'tts-stop', this)();
    }
    
    /**
     * Start recording state (listening/capturing mode)
     * @returns {EmotiveMascot} This instance for chaining
     */
    startRecording() {
        return this.errorBoundary.wrap(() => {
            if (this.recording) {
                // Already recording
                return this;
            }
            
            this.recording = true;
            
            // Update renderer if using Emotive style
            if (this.renderer && this.renderer.startRecording) {
                this.renderer.startRecording();
            }
            
            // Emit recording started event
            this.emit('recordingStarted');
            
            // Recording started
            return this;
        }, 'recording-start', this)();
    }
    
    /**
     * Stop recording state
     * @returns {EmotiveMascot} This instance for chaining
     */
    stopRecording() {
        return this.errorBoundary.wrap(() => {
            if (!this.recording) {
                // Not currently recording
                return this;
            }
            
            this.recording = false;
            
            // Update renderer if using Emotive style
            if (this.renderer && this.renderer.stopRecording) {
                this.renderer.stopRecording();
            }
            
            // Emit recording stopped event
            this.emit('recordingStopped');
            
            // Recording stopped
            return this;
        }, 'recording-stop', this)();
    }
    
    /**
     * Enter sleep state with animation sequence
     * @returns {EmotiveMascot} This instance for chaining
     */
    sleep() {
        return this.errorBoundary.wrap(async () => {
            if (this.sleeping) {
                // Already sleeping
                return this;
            }
            
            // Sleep entry animation sequence
            // Starting sleep sequence...
            
            // First: Yawn
            this.express('yawn');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Second: Drowsy sway
            this.express('sway');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Now enter sleep state
            this.sleeping = true;
            
            // Update renderer if using Emotive style (handles eye closing)
            if (this.renderer && this.renderer.enterSleepMode) {
                this.renderer.enterSleepMode();
            }
            
            // Update idle behavior if available
            if (this.idleBehavior && this.idleBehavior.enterSleep) {
                this.idleBehavior.enterSleep();
            }
            
            // Emit sleep event
            this.emit('sleep');
            
            // Mascot entered sleep state
            return this;
        }, 'sleep', this)();
    }
    
    /**
     * Wake up from sleep state with animation sequence
     * @returns {EmotiveMascot} This instance for chaining
     */
    wake() {
        return this.errorBoundary.wrap(async () => {
            if (!this.sleeping) {
                // Not currently sleeping
                return this;
            }
            
            // Exit sleep state first
            this.sleeping = false;
            
            // Update renderer if using Emotive style (handles eye opening)
            if (this.renderer && this.renderer.wakeUp) {
                this.renderer.wakeUp();
            }
            
            // Update idle behavior if available
            if (this.idleBehavior && this.idleBehavior.wakeUp) {
                this.idleBehavior.wakeUp();
            }
            
            // Wake animation sequence
            // Starting wake sequence...
            
            // First: Stretch
            this.express('stretch');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Second: Slow blink
            this.express('slowBlink');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Third: Small shake to fully wake
            this.express('shake');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Emit wake event
            this.emit('wake');
            
            // Mascot fully awake
            return this;
        }, 'wake', this)();
    }
    
    /**
     * Gets available TTS voices
     * @returns {Array} Array of available voice objects
     */
    getTTSVoices() {
        if (!this.tts.available) {
            return [];
        }
        
        return window.speechSynthesis.getVoices();
    }
    
    /**
     * Checks if TTS is currently speaking
     * @returns {boolean} True if currently speaking
     */
    isTTSSpeaking() {
        return this.tts.speaking;
    }

    /**
     * Starts the animation loop at target 60 FPS
     * @returns {EmotiveMascot} This instance for chaining
     */
    start() {
        return this.errorBoundary.wrap(() => {
            return this.visualizationRunner.start();
        }, 'start', this)();
    }

    /**
     * Stops the animation loop and cleans up resources
     * @returns {EmotiveMascot} This instance for chaining
     */
    stop() {
        return this.errorBoundary.wrap(() => {
            return this.visualizationRunner.stop();
        }, 'stop', this)();
    }



    /**
     * Sets a breathing pattern for the orb
     * @param {number} inhale - Inhale duration in seconds
     * @param {number} hold1 - Hold after inhale in seconds
     * @param {number} exhale - Exhale duration in seconds
     * @param {number} hold2 - Hold after exhale in seconds
     * @returns {EmotiveMascot} This instance for chaining
     */
    setBreathePattern(inhale, hold1, exhale, hold2) {
        return this.errorBoundary.wrap(() => {
            // Calculate total cycle time
            const totalCycle = inhale + hold1 + exhale + hold2;
            
            // Store pattern for custom animation
            this.breathePattern = {
                inhale,
                hold1,
                exhale,
                hold2,
                totalCycle,
                currentPhase: 'inhale',
                phaseStartTime: Date.now(),
                phaseProgress: 0
            };
            
            // Start custom breathing animation
            this.startBreathingAnimation();
            
            return this;
        }, 'setBreathePattern', this)();
    }
    
    /**
     * Directly sets the orb scale with animation
     * @param {number} scale - Target scale (1.0 = normal)
     * @param {number} duration - Animation duration in milliseconds
     * @param {string} easing - Easing function ('linear', 'ease', 'easeIn', 'easeOut', 'easeInOut')
     * @returns {EmotiveMascot} This instance for chaining
     */
    setOrbScale(scale, duration = 1000, easing = 'easeInOut') {
        return this.errorBoundary.wrap(() => {
            if (this.renderer) {
                // Create scale animation
                const startScale = this.currentOrbScale || 1.0;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Apply easing
                    let easedProgress = progress;
                    if (easing === 'easeIn') {
                        easedProgress = progress * progress;
                    } else if (easing === 'easeOut') {
                        easedProgress = progress * (2 - progress);
                    } else if (easing === 'easeInOut') {
                        easedProgress = progress < 0.5
                            ? 2 * progress * progress
                            : -1 + (4 - 2 * progress) * progress;
                    }
                    
                    // Calculate current scale
                    this.currentOrbScale = startScale + (scale - startScale) * easedProgress;
                    
                    // Apply to renderer
                    if (this.renderer.setCustomScale) {
                        this.renderer.setCustomScale(this.currentOrbScale);
                    }
                    
                    // Continue animation
                    if (progress < 1 && this.isRunning) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            return this;
        }, 'setOrbScale', this)();
    }
    
    /**
     * Applies a preset breathing pattern
     * @param {string} type - Preset type: 'calm', 'anxious', 'meditative', 'deep'
     * @returns {EmotiveMascot} This instance for chaining
     */
    breathe(type = 'calm') {
        return this.errorBoundary.wrap(() => {
            const presets = {
                calm: { inhale: 4, hold1: 0, exhale: 4, hold2: 0 },        // 4-4 breathing
                anxious: { inhale: 2, hold1: 0, exhale: 2, hold2: 0 },    // Quick shallow
                meditative: { inhale: 4, hold1: 7, exhale: 8, hold2: 0 }, // 4-7-8 breathing
                deep: { inhale: 5, hold1: 5, exhale: 5, hold2: 5 },       // Box breathing
                sleep: { inhale: 6, hold1: 0, exhale: 8, hold2: 2 }       // Sleep breathing
            };
            
            const pattern = presets[type] || presets.calm;
            return this.setBreathePattern(pattern.inhale, pattern.hold1, pattern.exhale, pattern.hold2);
        }, 'breathe', this)();
    }
    
    /**
     * Starts the custom breathing animation
     * @private
     */
    startBreathingAnimation() {
        // Cancel any existing breathing animation
        if (this.breathingAnimationId) {
            cancelAnimationFrame(this.breathingAnimationId);
        }
        
        const animate = () => {
            if (!this.breathePattern || !this.isRunning) return;
            
            const pattern = this.breathePattern;
            const now = Date.now();
            const phaseElapsed = (now - pattern.phaseStartTime) / 1000; // Convert to seconds
            
            let scale = 1.0;
            let nextPhase = pattern.currentPhase;
            
            // Determine current phase and scale
            switch (pattern.currentPhase) {
                case 'inhale':
                    if (phaseElapsed >= pattern.inhale) {
                        nextPhase = 'hold1';
                        pattern.phaseStartTime = now;
                        this.emit('hold-start', { type: 'post-inhale' });
                    } else {
                        // Scale up during inhale
                        const progress = phaseElapsed / pattern.inhale;
                        scale = 1.0 + (0.3 * progress); // Expand to 1.3x
                    }
                    break;
                    
                case 'hold1':
                    if (phaseElapsed >= pattern.hold1) {
                        nextPhase = 'exhale';
                        pattern.phaseStartTime = now;
                        this.emit('exhale-start');
                    }
                    scale = 1.3; // Stay expanded
                    break;
                    
                case 'exhale':
                    if (phaseElapsed >= pattern.exhale) {
                        nextPhase = 'hold2';
                        pattern.phaseStartTime = now;
                        this.emit('hold-start', { type: 'post-exhale' });
                    } else {
                        // Scale down during exhale
                        const progress = phaseElapsed / pattern.exhale;
                        scale = 1.3 - (0.4 * progress); // Contract to 0.9x
                    }
                    break;
                    
                case 'hold2':
                    if (phaseElapsed >= pattern.hold2) {
                        nextPhase = 'inhale';
                        pattern.phaseStartTime = now;
                        this.emit('inhale-start');
                    }
                    scale = 0.9; // Stay contracted
                    break;
            }
            
            // Update phase
            if (nextPhase !== pattern.currentPhase) {
                pattern.currentPhase = nextPhase;
            }
            
            // Apply scale to renderer
            if (this.renderer && this.renderer.setCustomScale) {
                this.renderer.setCustomScale(scale);
            }
            
            // Continue animation
            this.breathingAnimationId = requestAnimationFrame(animate);
        };
        
        // Start with inhale
        this.breathePattern.currentPhase = 'inhale';
        this.breathePattern.phaseStartTime = Date.now();
        this.emit('inhale-start');
        animate();
    }
    
    /**
     * Stops any active breathing animation
     * @returns {EmotiveMascot} This instance for chaining
     */
    stopBreathing() {
        return this.errorBoundary.wrap(() => {
            if (this.breathingAnimationId) {
                cancelAnimationFrame(this.breathingAnimationId);
                this.breathingAnimationId = null;
            }
            
            this.breathePattern = null;
            
            // Reset scale
            if (this.renderer && this.renderer.setCustomScale) {
                this.renderer.setCustomScale(1.0);
            }
            
            return this;
        }, 'stopBreathing', this)();
    }
    
    /**
     * Adds an event listener for external integration hooks
     * @param {string} event - Event name
     * @param {Function} callback - Event callback function
     * @returns {EmotiveMascot} This instance for chaining
     */
    on(event, callback) {
        return this.errorBoundary.wrap(() => {
            this.eventManager.on(event, callback);
            return this;
        }, 'event-listener-add', this)();
    }

    /**
     * Removes an event listener
     * @param {string} event - Event name
     * @param {Function} callback - Event callback function to remove
     * @returns {EmotiveMascot} This instance for chaining
     */
    off(event, callback) {
        return this.errorBoundary.wrap(() => {
            this.eventManager.off(event, callback);
            return this;
        }, 'event-listener-remove', this)();
    }

    /**
     * Adds a one-time event listener that removes itself after first execution
     * @param {string} event - Event name
     * @param {Function} callback - Event callback function
     * @returns {EmotiveMascot} This instance for chaining
     */
    once(event, callback) {
        return this.errorBoundary.wrap(() => {
            this.eventManager.once(event, callback);
            return this;
        }, 'event-listener-once', this)();
    }

    /**
     * Removes all listeners for a specific event or all events
     * @param {string|null} event - Event name to clear, or null to clear all
     * @returns {EmotiveMascot} This instance for chaining
     */
    removeAllListeners(event = null) {
        return this.errorBoundary.wrap(() => {
            this.eventManager.removeAllListeners(event);
            return this;
        }, 'event-listeners-clear', this)();
    }

    /**
     * Gets the number of listeners for an event
     * @param {string} event - Event name
     * @returns {number} Number of listeners
     */
    listenerCount(event) {
        return this.eventManager.listenerCount(event);
    }

    /**
     * Gets all registered event names
     * @returns {Array<string>} Array of event names
     */
    getEventNames() {
        return this.eventManager.getEventNames();
    }

    /**
     * Gets comprehensive event system statistics
     * @returns {Object} Event system statistics and monitoring data
     */
    getEventStats() {
        return this.eventManager.getEventStats();
    }

    /**
     * Gets EventManager debugging information
     * @returns {Object} Debug information about the event system
     */
    getEventDebugInfo() {
        return this.eventManager.getDebugInfo();
    }

    /**
     * Gets browser compatibility information
     * @returns {Object} Browser compatibility details
     */
    getBrowserCompatibility() {
        return {
            browser: browserCompatibility.browser,
            features: browserCompatibility.featureDetection.getFeatures(),
            capabilities: browserCompatibility.capabilities,
            appliedPolyfills: browserCompatibility.appliedPolyfills,
            optimizations: browserCompatibility.browserOptimizations.getOptimizations()
        };
    }

    /**
     * Gets degradation manager status and settings
     * @returns {Object|null} Degradation manager information or null if disabled
     */
    getDegradationStatus() {
        if (!this.degradationManager) {
            return null;
        }
        
        return {
            currentLevel: this.degradationManager.getCurrentLevel(),
            availableFeatures: this.degradationManager.getAvailableFeatures(),
            recommendedSettings: this.degradationManager.getRecommendedSettings(),
            performanceStats: this.degradationManager.getPerformanceStats(),
            allLevels: this.degradationManager.getAllLevels()
        };
    }

    /**
     * Manually set degradation level
     * @param {number|string} level - Degradation level index or name
     * @returns {boolean} True if level was set successfully
     */
    setDegradationLevel(level) {
        if (!this.degradationManager) {
            // Degradation manager is not enabled
            return false;
        }
        
        return this.degradationManager.setLevel(level);
    }

    /**
     * Check if a specific feature is available in current degradation level
     * @param {string} feature - Feature name (audio, particles, fullEffects, etc.)
     * @returns {boolean} True if feature is available
     */
    isFeatureAvailable(feature) {
        if (!this.degradationManager) {
            // Fallback to basic feature detection
            const features = browserCompatibility.featureDetection.getFeatures();
            return features[feature] || false;
        }
        
        return this.degradationManager.isFeatureAvailable(feature);
    }

    /**
     * Force canvas context recovery
     * @returns {boolean} True if recovery was successful
     */
    recoverCanvasContext() {
        if (!this.contextRecovery) {
            return false;
        }
        
        return this.contextRecovery.recover();
    }

    /**
     * Check if canvas context is currently lost
     * @returns {boolean} True if context is lost
     */
    isCanvasContextLost() {
        if (!this.contextRecovery) {
            return false;
        }
        
        return this.contextRecovery.isLost();
    }

    /**
     * Enable or disable debug mode
     * @param {boolean} enabled - Whether to enable debug mode
     */
    setDebugMode(enabled) {
        this.debugMode = enabled;
        
        if (enabled) {
            emotiveDebugger.log('INFO', 'Debug mode enabled');
            emotiveDebugger.takeMemorySnapshot('debug-mode-enabled');
        } else {
            emotiveDebugger.log('INFO', 'Debug mode disabled');
        }
    }

    /**
     * Get comprehensive debug report
     * @returns {Object} Debug report including all system states
     */
    getDebugReport() {
        const report = {
            timestamp: Date.now(),
            mascot: {
                isRunning: this.isRunning,
                speaking: this.speaking,
                debugMode: this.debugMode,
                config: this.config
            },
            
            // System states
            currentState: this.getCurrentState(),
            performanceMetrics: this.getPerformanceMetrics(),
            audioStats: this.getAudioStats(),
            eventStats: this.getEventStats(),
            
            // Browser compatibility
            browserCompatibility: this.getBrowserCompatibility(),
            degradationStatus: this.getDegradationStatus(),
            
            // Runtime capabilities
            runtimeCapabilities: runtimeCapabilities.generateReport(),
            
            // Debugger data
            debuggerReport: emotiveDebugger.getDebugReport()
        };

        if (this.debugMode) {
            emotiveDebugger.log('DEBUG', 'Generated debug report', {
                reportSize: JSON.stringify(report).length,
                sections: Object.keys(report)
            });
        }

        return report;
    }

    /**
     * Export debug data for external analysis
     * @returns {Object} Exportable debug data
     */
    exportDebugData() {
        const data = {
            metadata: {
                exportTime: Date.now(),
                version: '1.0.0', // Should be dynamically set
                userAgent: navigator.userAgent,
                url: window.location?.href
            },
            
            mascotState: {
                config: this.config,
                currentState: this.getCurrentState(),
                isRunning: this.isRunning,
                speaking: this.speaking
            },
            
            performance: {
                metrics: this.getPerformanceMetrics(),
                degradationStatus: this.getDegradationStatus(),
                frameTimings: emotiveDebugger.frameTimings
            },
            
            compatibility: {
                browser: this.getBrowserCompatibility(),
                runtimeCapabilities: runtimeCapabilities.generateReport()
            },
            
            debuggerData: emotiveDebugger.exportDebugData()
        };

        if (this.debugMode) {
            emotiveDebugger.log('INFO', 'Exported debug data', {
                dataSize: JSON.stringify(data).length
            });
        }

        return data;
    }

    /**
     * Start profiling a named operation
     * @param {string} name - Profile name
     * @param {Object} metadata - Additional metadata
     */
    startProfiling(name, metadata = {}) {
        if (this.debugMode) {
            emotiveDebugger.startProfile(name, metadata);
        }
    }

    /**
     * End profiling and get results
     * @param {string} name - Profile name
     * @returns {Object|null} Profile results
     */
    endProfiling(name) {
        if (this.debugMode) {
            return emotiveDebugger.endProfile(name);
        }
        return null;
    }

    /**
     * Take a memory snapshot
     * @param {string} label - Snapshot label
     */
    takeMemorySnapshot(label) {
        if (this.debugMode) {
            emotiveDebugger.takeMemorySnapshot(label);
        }
    }

    /**
     * Clear all debug data
     */
    clearDebugData() {
        emotiveDebugger.clear();
        
        if (this.debugMode) {
            emotiveDebugger.log('INFO', 'Debug data cleared');
        }
    }

    /**
     * Get runtime performance capabilities
     * @returns {Object} Runtime capabilities report
     */
    getRuntimeCapabilities() {
        return runtimeCapabilities.generateReport();
    }

    /**
     * Emits an event to all registered listeners with error boundary protection
     * @param {string} event - Event name
     * @param {*} data - Event data
     */
    emit(event, data = null) {
        this.eventManager.emit(event, data);
    }

    /**
     * Updates audio level monitoring (called by AnimationController)
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    update(deltaTime) {
        this.errorBoundary.wrap(() => {
            this.visualizationRunner.update(deltaTime);
        }, 'audio-update')();
    }





    /**
     * Renders the current frame (called by AnimationController)
     */
    render() {
        let deltaTime = 16.67; // Default fallback value
        let renderStart = 0;
        
        try {
            renderStart = this.debugMode ? performance.now() : 0;
            
            // Get deltaTime from animation controller
            deltaTime = this.animationController ? this.animationController.deltaTime : 16.67;
            
            // Prepare render state
            const renderState = {
                properties: this.stateMachine.getCurrentEmotionalProperties(),
                emotion: this.stateMachine.getCurrentState().emotion,
                undertone: this.stateMachine.getCurrentState().undertone,
                particleSystem: this.particleSystem,
                speaking: this.speaking,
                audioLevel: this.audioLevelProcessor.getCurrentLevel(),
                gazeOffset: this.gazeTracker ? this.gazeTracker.currentGaze : { x: 0, y: 0 }
            };
            
            
            // Track frame timing for debugging
            if (this.debugMode) {
                emotiveDebugger.trackFrameTiming(deltaTime);
            }
            
            // Always use EmotiveRenderer
            // Clear canvas ONCE at the beginning
            this.canvasManager.clear();
            
            // Update gaze tracker
            if (this.gazeTracker) {
                this.gazeTracker.update(deltaTime);
            }
            
            // Update threat level for suspicion state based on gaze distance
            if (renderState.emotion === 'suspicion' && this.gazeTracker) {
                const suspicionEmotion = getEmotion('suspicion');
                if (suspicionEmotion && suspicionEmotion.visual) {
                    this.gazeTracker.getState();
                    const mousePos = this.gazeTracker.mousePos;
                    const centerX = this.canvasManager.width / 2;
                    const centerY = this.canvasManager.height / 2 - this.config.topOffset;
                    
                    // Calculate distance from mouse to center
                    const distance = Math.sqrt(
                        Math.pow(mousePos.x - centerX, 2) + 
                        Math.pow(mousePos.y - centerY, 2)
                    );
                    
                    // Maximum distance for threat calculation (canvas diagonal / 3)
                    const maxDist = Math.min(this.canvasManager.width, this.canvasManager.height) / 2;
                    
                    // Closer = higher threat (inverted distance)
                    const threatLevel = Math.max(0, Math.min(1, 1 - (distance / maxDist)));
                    
                    // Update the threat level
                    suspicionEmotion.visual.threatLevel = threatLevel;
                }
            }
            
            // For Emotive style, convert emotion to visual params (AFTER updating threat level)
            let emotionParams = getEmotionVisualParams(renderState.emotion);
            
            this.renderer.setEmotionalState(renderState.emotion, emotionParams, renderState.undertone);
            
            // Always use center for particle spawning (not gaze-adjusted position)
            const orbX = this.canvasManager.width / 2;
            let orbY = this.canvasManager.height / 2 - this.config.topOffset;

            // Spawn new particles based on emotion at ORB position
            // Get min/max from state machine
            const stateProps = this.stateMachine.getCurrentEmotionalProperties();

            // Apply vertical offset for certain emotions (like excited for exclamation mark)
            if (stateProps.verticalOffset) {
                orbY = (this.canvasManager.height / 2 - this.config.topOffset) + (this.canvasManager.height * stateProps.verticalOffset);
            }
            
            // Apply undertone modifiers to particle behavior
            let particleBehavior = emotionParams.particleBehavior || 'ambient';
            let particleRate = emotionParams.particleRate || 15;
            // Use emotionParams min/max if available, otherwise fall back to stateProps
            let minParticles = emotionParams.minParticles !== undefined ? emotionParams.minParticles : (stateProps.minParticles || 0);
            let maxParticles = emotionParams.maxParticles !== undefined ? emotionParams.maxParticles : (stateProps.maxParticles || 10);
            
            
            // Special case for zen: mix falling and orbiting behaviors
            if (renderState.emotion === 'zen') {
                // Randomly choose between falling (sad) and orbiting (love) for each spawn
                particleBehavior = Math.random() < 0.6 ? 'falling' : 'orbiting';
            }
            
            // Check if renderer has undertone overrides
            if (this.renderer.state && this.renderer.state.particleBehaviorOverride) {
                particleBehavior = this.renderer.state.particleBehaviorOverride;
            }
            if (this.renderer.state && this.renderer.state.particleRateMult) {
                particleRate = Math.floor(particleRate * this.renderer.state.particleRateMult);
                maxParticles = Math.floor(maxParticles * this.renderer.state.particleRateMult);
            }
            
            this.particleSystem.spawn(
                particleBehavior,
                renderState.emotion,
                particleRate,
                orbX,
                orbY,
                deltaTime,
                null,  // no forced count
                minParticles,
                maxParticles,
                this.renderer.scaleFactor || 1,  // Pass scale factor
                this.config.classicConfig?.particleSizeMultiplier || 1,  // Pass particle size multiplier
                emotionParams.particleColors || null,  // Pass emotion colors
                renderState.undertone  // Pass undertone for saturation adjustments
            );
            
            // Debug logging disabled to prevent console spam
            // Uncomment only for debugging particle issues
            // if (!this._particleDebugCounter) this._particleDebugCounter = 0;
            // this._particleDebugCounter++;
            // if (this._particleDebugCounter % 120 === 0) {  // Log every 2 seconds at 60fps
            //     Particle status:
            //         behavior: particleBehavior,
            //         rate: particleRate,
            //         emotion: renderState.emotion,
            //         minParticles,
            //         maxParticles,
            //         currentCount: this.particleSystem.particles.length,
            //         stats: this.particleSystem.getStats(),
            //         position: { x: orbX, y: orbY }
            //     });
            // }
            
            // Get undertone modifier from renderer if present
            const undertoneModifier = this.renderer.getUndertoneModifier ? 
                this.renderer.getUndertoneModifier() : null;
            
            // Add zen vortex intensity to undertone modifier if in zen state
            let particleModifier = undertoneModifier;
            if (renderState.emotion === 'zen' && this.renderer.state.zenVortexIntensity) {
                particleModifier = { ...(undertoneModifier || {}), zenVortexIntensity: this.renderer.state.zenVortexIntensity };
            }
            
            // Get current gesture info from renderer or modular gesture
            let gestureMotion = null;
            let gestureProgress = 0;
            
            // First check for modular gesture
            if (this.currentModularGesture) {
                const elapsed = performance.now() - this.currentModularGesture.startTime;
                gestureProgress = Math.min(elapsed / this.currentModularGesture.duration, 1);
                
                if (gestureProgress >= 1) {
                    // Ensure cleanup happens before clearing gesture
                    gestureMotion = {
                        type: this.currentModularGesture.type,
                        amplitude: 1.0,
                        frequency: 1.0,
                        intensity: 1.0
                    };
                    // Pass progress = 1 to trigger cleanup
                    gestureProgress = 1.0;
                    // Clear gesture on next frame after cleanup
                    if (!this.currentModularGesture.cleanupPending) {
                        this.currentModularGesture.cleanupPending = true;
                    } else {
                        // Cleanup was called last frame, now clear the gesture
                        this.currentModularGesture = null;
                    }
                } else {
                    // Set gesture motion for particles
                    gestureMotion = {
                        type: this.currentModularGesture.type,
                        amplitude: 1.0,
                        frequency: 1.0,
                        intensity: 1.0
                    };
                }
            }
            // Fallback to renderer gesture
            else if (this.renderer && this.renderer.getCurrentGesture) {
                const currentGesture = this.renderer.getCurrentGesture();
                if (currentGesture && currentGesture.particleMotion) {
                    gestureMotion = currentGesture.particleMotion;
                    gestureProgress = currentGesture.progress || 0;
                }
            }
            
            // Update particles with orb position, gesture motion, and modifier
            this.particleSystem.update(deltaTime, orbX, orbY, gestureMotion, gestureProgress, particleModifier);

            // Get gesture transform from renderer
            const gestureTransform = this.renderer.gestureAnimator ?
                this.renderer.gestureAnimator.applyGestureAnimations() : null;

            // Render BACKGROUND particles (behind orb)
            this.particleSystem.renderBackground(this.canvasManager.getContext(), emotionParams.glowColor, gestureTransform);

            // Render the Emotive orb in the MIDDLE layer
            this.renderer.render(renderState, deltaTime, gestureTransform);

            // Render FOREGROUND particles (in front of orb)
            this.particleSystem.renderForeground(this.canvasManager.getContext(), emotionParams.glowColor, gestureTransform);
            
            // Draw debug information if enabled
            if (this.config.showFPS || this.config.showDebug) {
                this.renderDebugInfo(deltaTime);
            }
            
            // Log render performance if debugging
            if (this.debugMode) {
                const renderTime = performance.now() - renderStart;
                if (renderTime > 16.67) { // Longer than 60fps frame
                    emotiveDebugger.log('WARN', 'Slow render frame detected', {
                        renderTime,
                        deltaTime,
                        particleCount: this.particleSystem.getStats().activeParticles
                    });
                }
            }
        } catch (error) {
            this.errorBoundary.logError(error, 'main-render');
        }
    }

    /**
     * Renders debug information overlay
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    renderDebugInfo(deltaTime) {
        const ctx = this.canvasManager.getContext();
        ctx.save();
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px monospace';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        
        let y = 20;
        const lineHeight = 16;
        
        if (this.config.showFPS) {
            const metrics = this.animationController.getPerformanceMetrics();
            // Use smoothed FPS for stable display
            const fps = metrics.instantFps || metrics.fps || 0;
            const frameTime = metrics.averageFrameTime ? metrics.averageFrameTime.toFixed(1) : '0.0';
            const particleStats = this.particleSystem.getStats();
            
            // Build simple display
            const lines = [
                `FPS: ${fps}`,
                `Frame: ${frameTime}ms`,
                `Particles: ${particleStats.activeParticles}`
            ];
            
            // Draw each line
            const padding = 8;
            let maxWidth = 0;
            lines.forEach(line => {
                const width = ctx.measureText(line).width;
                if (width > maxWidth) maxWidth = width;
            });
            
            const x = this.canvasManager.width - maxWidth - padding - 10;
            
            // Background box with semi-transparent dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - padding, y - 14, maxWidth + padding * 2, 18 * lines.length + 4);
            
            // Border color based on FPS
            let borderColor;
            if (fps >= 55) {
                borderColor = '#00ff00';  // Green for good FPS
            } else if (fps >= 30) {
                borderColor = '#ffff00';  // Yellow for okay FPS
            } else {
                borderColor = '#ff0000';  // Red for poor FPS
            }
            
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - padding, y - 14, maxWidth + padding * 2, 18 * lines.length + 4);
            
            // Draw each line of text
            lines.forEach((line, i) => {
                const lineY = y + (i * lineHeight);
                // No stroke for cleaner look
                ctx.fillStyle = '#ffffff';
                ctx.fillText(line, x, lineY);
            });
            
            y += lineHeight * lines.length;
        }
        
        if (this.config.showDebug) {
            const state = this.stateMachine.getCurrentState();
            const particleStats = this.particleSystem.getStats();
            
            const debugInfo = [
                `Emotion: ${state.emotion}${state.undertone ? ` (${state.undertone})` : ''}`,
                `Particles: ${particleStats.activeParticles}/${particleStats.maxParticles}`,
                `Gesture: ${this.currentModularGesture ? this.currentModularGesture.type : 'none'}`,
                `Speaking: ${this.speaking ? 'yes' : 'no'}`,
                `Audio Level: ${(this.audioLevel * 100).toFixed(1)}%`
            ];
            
            // Draw debug info with background for readability
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            const debugWidth = Math.max(...debugInfo.map(line => ctx.measureText(line).width));
            ctx.fillRect(8, y - 14, debugWidth + 16, debugInfo.length * lineHeight + 4);
            
            ctx.fillStyle = '#ffffff';
            for (const info of debugInfo) {
                ctx.fillText(info, 10, y);
                y += lineHeight;
            }
        }
        
        ctx.restore();
    }

    /**
     * Gets the current emotional color
     * @returns {string} Hex color for current emotion
     */
    getEmotionalColor() {
        const properties = this.stateMachine.getCurrentEmotionalProperties();
        // Fallback to neutral gray if properties are undefined
        return properties?.primaryColor || '#B0B0B0';
    }

    /**
     * Gets the current emotional state information
     * @returns {Object} Current state with properties
     */
    getCurrentState() {
        return this.stateMachine.getCurrentState();
    }

    /**
     * Gets all available emotions
     * @returns {Array<string>} Array of emotion names
     */
    getAvailableEmotions() {
        return this.stateMachine.getAvailableEmotions();
    }

    /**
     * Gets all available undertones
     * @returns {Array<string>} Array of undertone names
     */
    getAvailableUndertones() {
        return this.stateMachine.getAvailableUndertones();
    }

    /**
     * Gets the current audio level (0-1 range)
     * @returns {number} Current audio level
     */
    getAudioLevel() {
        return this.audioLevelProcessor.getCurrentLevel();
    }

    /**
     * Gets audio level processing statistics
     * @returns {Object} Audio processing statistics
     */
    getAudioStats() {
        return this.audioLevelProcessor.getStats();
    }

    /**
     * Updates audio level processor configuration
     * @param {Object} config - New configuration options
     */
    updateAudioConfig(config) {
        this.audioLevelProcessor.updateConfig(config);
    }

    /**
     * Gets all available gestures
     * @returns {Array<string>} Array of gesture names
     */
    getAvailableGestures() {
        return [
            'bounce', 'pulse', 'shake', 'spin', 'drift', 
            'nod', 'tilt', 'expand', 'contract', 'flash',
            'stretch', 'glow', 'flicker', 'vibrate', 'wave',
            'morph', 'slowBlink', 'look', 'settle',
            'breathIn', 'breathOut', 'breathHold', 'breathHoldEmpty', 'jump'
        ];
    }

    /**
     * Connects an audio source to the speech analyser
     * @param {AudioNode} audioSource - Web Audio API source node
     * @returns {EmotiveMascot} This instance for chaining
     */
    connectAudioSource(audioSource) {
        return this.errorBoundary.wrap(() => {
            if (!this.audioAnalyser) {
                // Speech reactivity not started. Call startSpeaking() first.
                return this;
            }
            
            if (!audioSource || typeof audioSource.connect !== 'function') {
                // Invalid audio source provided to connectAudioSource()
                return this;
            }
            
            // Connect the audio source to our analyser
            audioSource.connect(this.audioAnalyser);
            
            // Audio source connected to speech analyser
            this.emit('audioSourceConnected', { audioSource });
            
            return this;
        }, 'audio-source-connection', this)();
    }

    /**
     * Sets master volume for all audio output
     * @param {number} volume - Volume level (0.0 to 1.0)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setVolume(volume) {
        return this.errorBoundary.wrap(() => {
            return this.audioHandler.setVolume(volume);
        }, 'volume-setting', this)();
    }

    /**
     * Gets current master volume
     * @returns {number} Current volume level (0.0 to 1.0)
     */
    getVolume() {
        return this.config.masterVolume;
    }

    /**
     * Enable or disable gesture sounds
     * @param {boolean} enabled - Whether to enable gesture sounds
     * @returns {EmotiveMascot} This instance for chaining
     */
    setSoundEnabled(enabled) {
        this.config.soundEnabled = enabled;
        return this;
    }

    /**
     * Check if gesture sounds are enabled
     * @returns {boolean} Whether gesture sounds are enabled
     */
    isSoundEnabled() {
        return this.config.soundEnabled;
    }

    /**
     * Pauses the animation loop (can be resumed with start())
     * @returns {EmotiveMascot} This instance for chaining
     */
    pause() {
        return this.errorBoundary.wrap(() => {
            if (!this.animationController.isAnimating()) {
                // EmotiveMascot is not running
                return this;
            }
            
            // Stop animation controller
            this.animationController.stop();
            this.isRunning = false;
            
            // Pause ambient audio
            if (this.soundSystem.isAvailable()) {
                this.soundSystem.stopAmbientTone(200); // Quick fade out
            }
            
            this.emit('paused');
            // EmotiveMascot paused
            return this;
        }, 'pause', this)();
    }

    /**
     * Resumes the animation loop from paused state
     * @returns {EmotiveMascot} This instance for chaining
     */
    resume() {
        return this.errorBoundary.wrap(() => {
            if (this.animationController.isAnimating()) {
                // EmotiveMascot is already running
                return this;
            }
            
            // Start animation controller
            this.animationController.start();
            this.isRunning = true;
            
            // Resume ambient audio
            // Update ambient tone based on emotional state - DISABLED (annoying)
            // if (this.soundSystem.isAvailable()) {
            //     const currentEmotion = this.stateMachine.getCurrentState().emotion;
            //     this.soundSystem.setAmbientTone(currentEmotion, 200);
            // }
            
            this.emit('resumed');
            // EmotiveMascot resumed
            return this;
        }, 'resume', this)();
    }

    /**
     * Checks if the mascot is currently running
     * @returns {boolean} True if animation loop is active
     */
    isActive() {
        return this.animationController.isAnimating();
    }

    /**
     * Sets the target FPS for performance monitoring
     * @param {number} targetFPS - Target frames per second (default: 60)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setTargetFPS(targetFPS) {
        const clampedFPS = Math.max(15, Math.min(120, targetFPS)); // Clamp between 15-120 FPS
        this.config.targetFPS = clampedFPS;
        this.animationController.setTargetFPS(clampedFPS);
        
        // Target FPS set
        this.emit('targetFPSChanged', { targetFPS: clampedFPS });
        
        return this;
    }

    /**
     * Gets the current target FPS
     * @returns {number} Target frames per second
     */
    getTargetFPS() {
        return this.animationController.targetFPS;
    }

    /**
     * Forces performance degradation mode (for testing)
     * @param {boolean} enabled - Whether to enable degradation mode
     * @returns {EmotiveMascot} This instance for chaining
     */
    setPerformanceDegradation(enabled) {
        const metrics = this.animationController.getPerformanceMetrics();
        
        if (enabled && !metrics.performanceDegradation) {
            const currentMax = this.particleSystem.maxParticles;
            const newMax = Math.max(5, Math.floor(currentMax * 0.5));
            this.particleSystem.setMaxParticles(newMax);
            
            // Forced performance degradation
        } else if (!enabled && metrics.performanceDegradation) {
            this.particleSystem.setMaxParticles(this.config.maxParticles);
            
            // Disabled performance degradation
        }
        
        return this;
    }

    /**
     * Gets the current audio level (0-1) if speech reactivity is active
     * @returns {number} Current audio level or 0 if not speaking
     */
    getAudioLevel() {
        return this.speaking ? this.audioLevel : 0;
    }

    /**
     * Checks if speech reactivity is currently active
     * @returns {boolean} True if speech monitoring is active
     */
    isSpeaking() {
        return this.speaking;
    }

    /**
     * Sets the audio analyser smoothing time constant
     * @param {number} smoothing - Smoothing value (0-1, default: 0.8)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setAudioSmoothing(smoothing) {
        return this.errorBoundary.wrap(() => {
            const clampedSmoothing = Math.max(0, Math.min(1, smoothing));
            
            if (this.audioAnalyser) {
                this.audioAnalyser.smoothingTimeConstant = clampedSmoothing;
                // Audio smoothing set
            }
            
            return this;
        }, 'audio-smoothing', this)();
    }

    /**
     * Gets comprehensive system status for debugging and monitoring
     * @returns {Object} Complete system status
     */
    getSystemStatus() {
        return this.errorBoundary.wrap(() => {
            const state = this.stateMachine.getCurrentState();
            const particleStats = this.particleSystem.getStats();
            const rendererStats = this.renderer.getStats();
            
            const animationMetrics = this.animationController.getPerformanceMetrics();
            
            return {
                // Core status
                isRunning: animationMetrics.isRunning,
                fps: animationMetrics.fps,
                targetFPS: animationMetrics.targetFPS,
                performanceDegradation: animationMetrics.performanceDegradation,
                
                // Emotional state
                emotion: state.emotion,
                undertone: state.undertone,
                isTransitioning: state.isTransitioning,
                transitionProgress: state.transitionProgress,
                
                // Gesture system
                currentGesture: this.renderer?.currentGesture || null,
                gestureActive: this.renderer?.isGestureActive() || false,
                
                // Particle system
                particles: {
                    active: particleStats.activeParticles,
                    max: particleStats.maxParticles,
                    poolEfficiency: particleStats.poolEfficiency
                },
                
                // Audio system
                audioEnabled: this.config.enableAudio,
                soundSystemAvailable: this.soundSystem.isAvailable(),
                speaking: this.speaking,
                audioLevel: this.audioLevel,
                masterVolume: this.config.masterVolume,
                
                // Renderer
                renderer: {
                    gradientCacheSize: rendererStats.gradientCacheSize,
                    breathingPhase: rendererStats.breathingPhase,
                    layers: rendererStats.layers
                },
                
                // Event system
                eventListeners: this.getEventNames().length,
                
                // Error boundary
                errorStats: this.errorBoundary.getErrorStats()
            };
        }, 'system-status', {})();
    }

    /**
     * Enables or disables debug mode
     * @param {boolean} enabled - Whether to enable debug mode
     * @returns {EmotiveMascot} This instance for chaining
     */
    setDebugMode(enabled) {
        this.config.showDebug = !!enabled;
        this.config.showFPS = !!enabled;
        
        return this;
    }

    /**
     * Triggers a manual error for testing error boundary
     * @param {string} context - Error context for testing
     * @returns {EmotiveMascot} This instance for chaining
     */
    triggerTestError(context = 'manual-test') {
        return this.errorBoundary.wrap(() => {
            throw new Error(`Test error triggered in context: ${context}`);
        }, context, this)();
    }

    /**
     * Gets current performance metrics
     * @returns {Object} Performance data
     */
    getPerformanceMetrics() {
        const animationMetrics = this.animationController.getPerformanceMetrics();
        const state = this.stateMachine.getCurrentState();
        
        return {
            ...animationMetrics,
            currentEmotion: state.emotion,
            currentUndertone: state.undertone,
            isTransitioning: state.isTransitioning,
            errorStats: this.errorBoundary.getErrorStats()
        };
    }

    /**
     * Register a plugin
     * @param {Object} plugin - Plugin to register
     * @returns {Promise<boolean>} Success status
     */
    async registerPlugin(plugin) {
        return this.pluginSystem.registerPlugin(plugin);
    }
    
    /**
     * Set accessibility options
     * @param {Object} options - Accessibility options
     */
    setAccessibility(options) {
        if (options.colorBlindMode) {
            this.accessibilityManager.setColorBlindMode(options.colorBlindMode);
        }
        if (options.reducedMotion !== undefined) {
            this.accessibilityManager.reducedMotionPreferred = options.reducedMotion;
        }
        if (options.highContrast !== undefined) {
            this.accessibilityManager.highContrastEnabled = options.highContrast;
        }
    }
    
    /**
     * Get mobile optimization status
     * @returns {Object} Mobile optimization status
     */
    getMobileStatus() {
        return this.mobileOptimization.getStatus();
    }
    
    /**
     * Get accessibility status
     * @returns {Object} Accessibility status
     */
    getAccessibilityStatus() {
        return this.accessibilityManager.getStatus();
    }
    
    /**
     * Set the emotional state (alias for setEmotion for compatibility)
     * @param {string} newState - The emotion/state to set
     * @returns {EmotiveMascot} This instance for chaining
     */
    setState(newState) {
        return this.setEmotion(newState);
    }
    
    /**
     * Speak text using TTS with synchronized animation
     * @param {string} text - The text to speak
     * @param {Object} options - TTS options
     * @returns {SpeechSynthesisUtterance} The utterance object for additional control
     */
    speak(text, options = {}) {
        // Check if speech synthesis is available
        if (!window.speechSynthesis) {
            // Speech synthesis not available in this browser
            return null;
        }
        
        // Create utterance
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Apply options
        if (options.voice) utterance.voice = options.voice;
        if (options.rate) utterance.rate = options.rate;
        if (options.pitch) utterance.pitch = options.pitch;
        if (options.volume) utterance.volume = options.volume;
        if (options.lang) utterance.lang = options.lang;
        
        // Set up event handlers for animation sync
        utterance.onstart = () => {
            // TTS: Starting speech
            this.setTTSSpeaking(true);
            this.emit('tts:start', { text });
        };
        
        utterance.onend = () => {
            // TTS: Speech ended
            this.setTTSSpeaking(false);
            this.emit('tts:end');
        };
        
        utterance.onerror = (event) => {
            // TTS: Speech error
            this.setTTSSpeaking(false);
            this.emit('tts:error', { error: event });
        };
        
        utterance.onboundary = (event) => {
            // Word/sentence boundaries for potential lip-sync
            this.emit('tts:boundary', { 
                name: event.name,
                charIndex: event.charIndex,
                charLength: event.charLength
            });
        };
        
        // Speak the text
        window.speechSynthesis.speak(utterance);
        
        return utterance;
    }
    
    /**
     * Set TTS speaking state (triggers visual animation)
     * @param {boolean} speaking - Whether TTS is speaking
     */
    setTTSSpeaking(speaking) {
        this.ttsSpeaking = speaking;
        
        // Update renderer if using Emotive style
        if (this.renderer && this.renderer.startSpeaking) {
            if (speaking) {
                this.renderer.startSpeaking();
            } else {
                this.renderer.stopSpeaking();
            }
        }
        
        // Also update the speaking flag for compatibility
        this.speaking = speaking;
    }
    
    /**
     * Get available TTS voices
     * @returns {Array} Array of available voices
     */
    getVoices() {
        if (!window.speechSynthesis) {
            return [];
        }
        return window.speechSynthesis.getVoices();
    }
    
    /**
     * Stop any ongoing TTS speech
     */
    stopTTS() {
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
            this.setTTSSpeaking(false);
        }
    }
    
    /**
     * Handle canvas resize events to trigger visual resampling
     * This ensures visuals look crisp at any size
     * @param {number} width - New canvas width
     * @param {number} height - New canvas height
     * @param {number} dpr - Device pixel ratio
     */
    handleResize(width, height, dpr) {
        // EmotiveMascot handleResize
        
        // Force a re-initialization of the offscreen canvas in renderer
        if (this.renderer && this.renderer.initOffscreenCanvas) {
            this.renderer.initOffscreenCanvas();
        }
        
        // Trigger a state update to recalculate all visual parameters
        if (this.stateMachine) {
            const currentEmotion = this.stateMachine.currentEmotion;
            const currentUndertone = this.stateMachine.currentUndertone;
            
            // Re-apply current emotion to trigger fresh calculations
            if (currentEmotion) {
                this.stateMachine.setEmotion(currentEmotion);
            }
            
            // Re-apply current undertone if any
            if (currentUndertone && currentUndertone !== 'none') {
                this.stateMachine.setUndertone(currentUndertone);
            }
        }
        
        // Emit resize event for any listeners
        this.emit('resize', { width, height, dpr });
    }
    
    /**
     * Morph the core to a different shape
     * @param {string} shape - Target shape name (circle, heart, star, sun, moon, eclipse, square, triangle)
     * @param {Object} config - Morph configuration
     * @returns {EmotiveMascot} This instance for chaining
     */
    morphTo(shape, config = {}) {
        return this.errorBoundary.wrap(() => {
            if (!this.shapeMorpher) {
                // ShapeMorpher not initialized
                return this;
            }
            
            // Start the morph
            this.shapeMorpher.morphTo(shape, config);
            
            // Pass shape morpher to renderer
            if (this.renderer) {
                this.renderer.shapeMorpher = this.shapeMorpher;
            }
            
            // Emit event
            this.emit('shapeMorphStarted', { from: this.shapeMorpher.currentShape, to: shape });
            
            // Morphing to new shape
            return this;
        }, 'morphTo', this)();
    }
    
    /**
     * Connect audio element for vocal visualization
     * @param {HTMLAudioElement} audioElement - Audio element to analyze
     * @returns {EmotiveMascot} This instance for chaining
     */
    connectAudio(audioElement) {
        return this.errorBoundary.wrap(async () => {
            return await this.audioHandler.connectAudio(audioElement);
        }, 'connectAudio', this)();
    }
    
    /**
     * Disconnect audio analysis
     * @returns {EmotiveMascot} This instance for chaining
     */
    disconnectAudio() {
        return this.errorBoundary.wrap(() => {
            return this.audioHandler.disconnectAudio();
        }, 'disconnectAudio', this)();
    }
    
    /**
     * Get available shapes for morphing
     * @returns {Array} List of available shape names
     */
    getAvailableShapes() {
        return ShapeMorpher.getAvailableShapes();
    }
    
    /**
     * Destroys the mascot instance and cleans up resources
     */
    destroy() {
        this.errorBoundary.wrap(() => {
            // Stop animation
            this.stop();
            
            // Stop speech reactivity
            if (this.speaking) {
                this.stopSpeaking();
            }
            
            // Destroy animation controller
            if (this.animationController) {
                this.animationController.destroy();
            }
            
            // Clean up all subsystems
            if (this.soundSystem) {
                this.soundSystem.cleanup();
            }
            
            if (this.audioLevelProcessor) {
                this.audioLevelProcessor.cleanup();
            }
            
            if (this.particleSystem) {
                this.particleSystem.destroy();
            }
            
            if (this.renderer) {
                // Stop all active gestures
                this.renderer.stopAllGestures();
                this.renderer.destroy();
            }
            
            if (this.canvasManager) {
                this.canvasManager.destroy();
            }
            
            // Clear event listeners
            if (this.eventManager) {
                this.eventManager.destroy();
            }
            
            // Destroy new systems
            if (this.accessibilityManager) {
                this.accessibilityManager.destroy();
            }
            
            if (this.mobileOptimization) {
                this.mobileOptimization.destroy();
            }
            
            if (this.pluginSystem) {
                this.pluginSystem.destroy();
            }
            
            // Clean up shape morpher and audio analyzer
            if (this.audioAnalyzer) {
                this.disconnectAudio();
                this.audioAnalyzer.destroy();
            }
            
            if (this.shapeMorpher) {
                this.shapeMorpher.reset();
            }
            
            // DegradationManager removed
            
            // Clear error boundary
            this.errorBoundary.clearErrors();
            
            // EmotiveMascot destroyed
        }, 'destruction')();
    }
    
    /**
     * Throttled warning to reduce console spam
     * @param {string} message - Warning message
     * @param {string} key - Unique key for this warning type
     */
    throttledWarn(message, key) {
        const now = Date.now();
        const lastWarning = this.warningTimestamps[key] || 0;
        
        if (now - lastWarning > this.warningThrottle) {
            // Warning message throttled
            this.warningTimestamps[key] = now;
        }
    }
}

export { EmotiveMascot as default };
