const e="181",t={ROTATE:0,DOLLY:1,PAN:2},n={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},a=0,i=1,r=2,s=100,o=101,l=102,c=200,h=201,d=202,u=203,p=204,m=205,f=206,g=207,y=208,v=209,b=210,w=211,x=212,S=213,M=214,_=0,A=1,C=2,T=3,P=4,D=5,O=6,E=7,I="attached",k="detached",R=301,z=302,F=303,B=304,L=306,N=1e3,V=1001,U=1002,G=1003,W=1004,q=1005,H=1006,j=1007,X=1008,Y=1009,$=1010,Q=1011,K=1012,Z=1013,J=1014,ee=1015,te=1016,ne=1017,ae=1018,ie=1020,re=35902,se=35899,oe=1021,le=1022,ce=1023,he=1026,de=1027,ue=1028,pe=1029,me=1030,fe=1031,ge=1033,ye=33776,ve=33777,be=33778,we=33779,xe=35840,Se=35841,Me=35842,_e=35843,Ae=36196,Ce=37492,Te=37496,Pe=37808,De=37809,Oe=37810,Ee=37811,Ie=37812,ke=37813,Re=37814,ze=37815,Fe=37816,Be=37817,Le=37818,Ne=37819,Ve=37820,Ue=37821,Ge=36492,We=36494,qe=36495,He=36283,je=36284,Xe=36285,Ye=36286,$e=2300,Qe=2301,Ke=2302,Ze=2400,Je=2401,et=2402,tt="",nt="srgb",at="srgb-linear",it="linear",rt="srgb",st=7680,ot=512,lt=513,ct=514,ht=515,dt=516,ut=517,pt=518,mt=519,ft=35044,gt=35048,yt="300 es",vt=2e3,bt=2001;function wt(e){for(let t=e.length-1;t>=0;--t)if(e[t]>=65535)return!0;return!1}function xt(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}function St(){const e=xt("canvas");return e.style.display="block",e}const Mt={};function _t(...e){const t="THREE."+e.shift();console.log(t,...e)}function At(...e){const t="THREE."+e.shift();console.warn(t,...e)}function Ct(...e){const t="THREE."+e.shift();console.error(t,...e)}function Tt(...e){const t=e.join(" ");t in Mt||(Mt[t]=!0,At(...e))}class Pt{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)}hasEventListener(e,t){const n=this._listeners;return void 0!==n&&void 0!==n[e]&&-1!==n[e].indexOf(t)}removeEventListener(e,t){const n=this._listeners;if(void 0===n)return;const a=n[e];if(void 0!==a){const e=a.indexOf(t);-1!==e&&a.splice(e,1)}}dispatchEvent(e){const t=this._listeners;if(void 0===t)return;const n=t[e.type];if(void 0!==n){e.target=this;const t=n.slice(0);for(let n=0,a=t.length;n<a;n++)t[n].call(this,e);e.target=null}}}const Dt=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Ot=1234567;const Et=Math.PI/180,It=180/Math.PI;function kt(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,a=4294967295*Math.random()|0;return(Dt[255&e]+Dt[e>>8&255]+Dt[e>>16&255]+Dt[e>>24&255]+"-"+Dt[255&t]+Dt[t>>8&255]+"-"+Dt[t>>16&15|64]+Dt[t>>24&255]+"-"+Dt[63&n|128]+Dt[n>>8&255]+"-"+Dt[n>>16&255]+Dt[n>>24&255]+Dt[255&a]+Dt[a>>8&255]+Dt[a>>16&255]+Dt[a>>24&255]).toLowerCase()}function Rt(e,t,n){return Math.max(t,Math.min(n,e))}function zt(e,t){return(e%t+t)%t}function Ft(e,t,n){return(1-n)*e+n*t}function Bt(e,t){switch(t.constructor){case Float32Array:return e;case Uint32Array:return e/4294967295;case Uint16Array:return e/65535;case Uint8Array:return e/255;case Int32Array:return Math.max(e/2147483647,-1);case Int16Array:return Math.max(e/32767,-1);case Int8Array:return Math.max(e/127,-1);default:throw new Error("Invalid component type.")}}function Lt(e,t){switch(t.constructor){case Float32Array:return e;case Uint32Array:return Math.round(4294967295*e);case Uint16Array:return Math.round(65535*e);case Uint8Array:return Math.round(255*e);case Int32Array:return Math.round(2147483647*e);case Int16Array:return Math.round(32767*e);case Int8Array:return Math.round(127*e);default:throw new Error("Invalid component type.")}}const Nt={DEG2RAD:Et,RAD2DEG:It,generateUUID:kt,clamp:Rt,euclideanModulo:zt,mapLinear:function(e,t,n,a,i){return a+(e-t)*(i-a)/(n-t)},inverseLerp:function(e,t,n){return e!==t?(n-e)/(t-e):0},lerp:Ft,damp:function(e,t,n,a){return Ft(e,t,1-Math.exp(-n*a))},pingpong:function(e,t=1){return t-Math.abs(zt(e,2*t)-t)},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*e*(e*(6*e-15)+10)},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){void 0!==e&&(Ot=e);let t=Ot+=1831565813;return t=Math.imul(t^t>>>15,1|t),t^=t+Math.imul(t^t>>>7,61|t),((t^t>>>14)>>>0)/4294967296},degToRad:function(e){return e*Et},radToDeg:function(e){return e*It},isPowerOfTwo:function(e){return!(e&e-1)&&0!==e},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,n,a,i){const r=Math.cos,s=Math.sin,o=r(n/2),l=s(n/2),c=r((t+a)/2),h=s((t+a)/2),d=r((t-a)/2),u=s((t-a)/2),p=r((a-t)/2),m=s((a-t)/2);switch(i){case"XYX":e.set(o*h,l*d,l*u,o*c);break;case"YZY":e.set(l*u,o*h,l*d,o*c);break;case"ZXZ":e.set(l*d,l*u,o*h,o*c);break;case"XZX":e.set(o*h,l*m,l*p,o*c);break;case"YXY":e.set(l*p,o*h,l*m,o*c);break;case"ZYZ":e.set(l*m,l*p,o*h,o*c);break;default:At("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}},normalize:Lt,denormalize:Bt};class Vt{constructor(e=0,t=0){Vt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,a=e.elements;return this.x=a[0]*t+a[3]*n+a[6],this.y=a[1]*t+a[4]*n+a[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Rt(this.x,e.x,t.x),this.y=Rt(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=Rt(this.x,e,t),this.y=Rt(this.y,e,t),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Rt(n,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Rt(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),a=Math.sin(t),i=this.x-e.x,r=this.y-e.y;return this.x=i*n-r*a+e.x,this.y=i*a+r*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Ut{constructor(e=0,t=0,n=0,a=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=a}static slerpFlat(e,t,n,a,i,r,s){let o=n[a+0],l=n[a+1],c=n[a+2],h=n[a+3],d=i[r+0],u=i[r+1],p=i[r+2],m=i[r+3];if(s<=0)return e[t+0]=o,e[t+1]=l,e[t+2]=c,void(e[t+3]=h);if(s>=1)return e[t+0]=d,e[t+1]=u,e[t+2]=p,void(e[t+3]=m);if(h!==m||o!==d||l!==u||c!==p){let e=o*d+l*u+c*p+h*m;e<0&&(d=-d,u=-u,p=-p,m=-m,e=-e);let t=1-s;if(e<.9995){const n=Math.acos(e),a=Math.sin(n);t=Math.sin(t*n)/a,o=o*t+d*(s=Math.sin(s*n)/a),l=l*t+u*s,c=c*t+p*s,h=h*t+m*s}else{o=o*t+d*s,l=l*t+u*s,c=c*t+p*s,h=h*t+m*s;const e=1/Math.sqrt(o*o+l*l+c*c+h*h);o*=e,l*=e,c*=e,h*=e}}e[t]=o,e[t+1]=l,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,n,a,i,r){const s=n[a],o=n[a+1],l=n[a+2],c=n[a+3],h=i[r],d=i[r+1],u=i[r+2],p=i[r+3];return e[t]=s*p+c*h+o*u-l*d,e[t+1]=o*p+c*d+l*h-s*u,e[t+2]=l*p+c*u+s*d-o*h,e[t+3]=c*p-s*h-o*d-l*u,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,a){return this._x=e,this._y=t,this._z=n,this._w=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const n=e._x,a=e._y,i=e._z,r=e._order,s=Math.cos,o=Math.sin,l=s(n/2),c=s(a/2),h=s(i/2),d=o(n/2),u=o(a/2),p=o(i/2);switch(r){case"XYZ":this._x=d*c*h+l*u*p,this._y=l*u*h-d*c*p,this._z=l*c*p+d*u*h,this._w=l*c*h-d*u*p;break;case"YXZ":this._x=d*c*h+l*u*p,this._y=l*u*h-d*c*p,this._z=l*c*p-d*u*h,this._w=l*c*h+d*u*p;break;case"ZXY":this._x=d*c*h-l*u*p,this._y=l*u*h+d*c*p,this._z=l*c*p+d*u*h,this._w=l*c*h-d*u*p;break;case"ZYX":this._x=d*c*h-l*u*p,this._y=l*u*h+d*c*p,this._z=l*c*p-d*u*h,this._w=l*c*h+d*u*p;break;case"YZX":this._x=d*c*h+l*u*p,this._y=l*u*h+d*c*p,this._z=l*c*p-d*u*h,this._w=l*c*h-d*u*p;break;case"XZY":this._x=d*c*h-l*u*p,this._y=l*u*h-d*c*p,this._z=l*c*p+d*u*h,this._w=l*c*h+d*u*p;break;default:At("Quaternion: .setFromEuler() encountered an unknown order: "+r)}return!0===t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,a=Math.sin(n);return this._x=e.x*a,this._y=e.y*a,this._z=e.z*a,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],a=t[4],i=t[8],r=t[1],s=t[5],o=t[9],l=t[2],c=t[6],h=t[10],d=n+s+h;if(d>0){const e=.5/Math.sqrt(d+1);this._w=.25/e,this._x=(c-o)*e,this._y=(i-l)*e,this._z=(r-a)*e}else if(n>s&&n>h){const e=2*Math.sqrt(1+n-s-h);this._w=(c-o)/e,this._x=.25*e,this._y=(a+r)/e,this._z=(i+l)/e}else if(s>h){const e=2*Math.sqrt(1+s-n-h);this._w=(i-l)/e,this._x=(a+r)/e,this._y=.25*e,this._z=(o+c)/e}else{const e=2*Math.sqrt(1+h-n-s);this._w=(r-a)/e,this._x=(i+l)/e,this._y=(o+c)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<1e-8?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Rt(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const a=Math.min(1,t/n);return this.slerp(e,a),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,a=e._y,i=e._z,r=e._w,s=t._x,o=t._y,l=t._z,c=t._w;return this._x=n*c+r*s+a*l-i*o,this._y=a*c+r*o+i*s-n*l,this._z=i*c+r*l+n*o-a*s,this._w=r*c-n*s-a*o-i*l,this._onChangeCallback(),this}slerp(e,t){if(t<=0)return this;if(t>=1)return this.copy(e);let n=e._x,a=e._y,i=e._z,r=e._w,s=this.dot(e);s<0&&(n=-n,a=-a,i=-i,r=-r,s=-s);let o=1-t;if(s<.9995){const e=Math.acos(s),l=Math.sin(e);o=Math.sin(o*e)/l,t=Math.sin(t*e)/l,this._x=this._x*o+n*t,this._y=this._y*o+a*t,this._z=this._z*o+i*t,this._w=this._w*o+r*t,this._onChangeCallback()}else this._x=this._x*o+n*t,this._y=this._y*o+a*t,this._z=this._z*o+i*t,this._w=this._w*o+r*t,this.normalize();return this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),n=Math.random(),a=Math.sqrt(1-n),i=Math.sqrt(n);return this.set(a*Math.sin(e),a*Math.cos(e),i*Math.sin(t),i*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Gt{constructor(e=0,t=0,n=0){Gt.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return void 0===n&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(qt.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(qt.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,a=this.z,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6]*a,this.y=i[1]*t+i[4]*n+i[7]*a,this.z=i[2]*t+i[5]*n+i[8]*a,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,a=this.z,i=e.elements,r=1/(i[3]*t+i[7]*n+i[11]*a+i[15]);return this.x=(i[0]*t+i[4]*n+i[8]*a+i[12])*r,this.y=(i[1]*t+i[5]*n+i[9]*a+i[13])*r,this.z=(i[2]*t+i[6]*n+i[10]*a+i[14])*r,this}applyQuaternion(e){const t=this.x,n=this.y,a=this.z,i=e.x,r=e.y,s=e.z,o=e.w,l=2*(r*a-s*n),c=2*(s*t-i*a),h=2*(i*n-r*t);return this.x=t+o*l+r*h-s*c,this.y=n+o*c+s*l-i*h,this.z=a+o*h+i*c-r*l,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,a=this.z,i=e.elements;return this.x=i[0]*t+i[4]*n+i[8]*a,this.y=i[1]*t+i[5]*n+i[9]*a,this.z=i[2]*t+i[6]*n+i[10]*a,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Rt(this.x,e.x,t.x),this.y=Rt(this.y,e.y,t.y),this.z=Rt(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=Rt(this.x,e,t),this.y=Rt(this.y,e,t),this.z=Rt(this.z,e,t),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Rt(n,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,a=e.y,i=e.z,r=t.x,s=t.y,o=t.z;return this.x=a*o-i*s,this.y=i*r-n*o,this.z=n*s-a*r,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return Wt.copy(this).projectOnVector(e),this.sub(Wt)}reflect(e){return this.sub(Wt.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Rt(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,a=this.z-e.z;return t*t+n*n+a*a}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const a=Math.sin(t)*e;return this.x=a*Math.sin(n),this.y=Math.cos(t)*e,this.z=a*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),a=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=a,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=2*Math.random()-1,n=Math.sqrt(1-t*t);return this.x=n*Math.cos(e),this.y=t,this.z=n*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Wt=new Gt,qt=new Ut;class Ht{constructor(e,t,n,a,i,r,s,o,l){Ht.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==e&&this.set(e,t,n,a,i,r,s,o,l)}set(e,t,n,a,i,r,s,o,l){const c=this.elements;return c[0]=e,c[1]=a,c[2]=s,c[3]=t,c[4]=i,c[5]=o,c[6]=n,c[7]=r,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,a=t.elements,i=this.elements,r=n[0],s=n[3],o=n[6],l=n[1],c=n[4],h=n[7],d=n[2],u=n[5],p=n[8],m=a[0],f=a[3],g=a[6],y=a[1],v=a[4],b=a[7],w=a[2],x=a[5],S=a[8];return i[0]=r*m+s*y+o*w,i[3]=r*f+s*v+o*x,i[6]=r*g+s*b+o*S,i[1]=l*m+c*y+h*w,i[4]=l*f+c*v+h*x,i[7]=l*g+c*b+h*S,i[2]=d*m+u*y+p*w,i[5]=d*f+u*v+p*x,i[8]=d*g+u*b+p*S,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],a=e[2],i=e[3],r=e[4],s=e[5],o=e[6],l=e[7],c=e[8];return t*r*c-t*s*l-n*i*c+n*s*o+a*i*l-a*r*o}invert(){const e=this.elements,t=e[0],n=e[1],a=e[2],i=e[3],r=e[4],s=e[5],o=e[6],l=e[7],c=e[8],h=c*r-s*l,d=s*o-c*i,u=l*i-r*o,p=t*h+n*d+a*u;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(a*l-c*n)*m,e[2]=(s*n-a*r)*m,e[3]=d*m,e[4]=(c*t-a*o)*m,e[5]=(a*i-s*t)*m,e[6]=u*m,e[7]=(n*o-l*t)*m,e[8]=(r*t-n*i)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,a,i,r,s){const o=Math.cos(i),l=Math.sin(i);return this.set(n*o,n*l,-n*(o*r+l*s)+r+e,-a*l,a*o,-a*(-l*r+o*s)+s+t,0,0,1),this}scale(e,t){return this.premultiply(jt.makeScale(e,t)),this}rotate(e){return this.premultiply(jt.makeRotation(-e)),this}translate(e,t){return this.premultiply(jt.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<9;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return(new this.constructor).fromArray(this.elements)}}const jt=new Ht,Xt=(new Ht).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Yt=(new Ht).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function $t(){const e={enabled:!0,workingColorSpace:at,spaces:{},convert:function(e,t,n){return!1!==this.enabled&&t!==n&&t&&n?(this.spaces[t].transfer===rt&&(e.r=Kt(e.r),e.g=Kt(e.g),e.b=Kt(e.b)),this.spaces[t].primaries!==this.spaces[n].primaries&&(e.applyMatrix3(this.spaces[t].toXYZ),e.applyMatrix3(this.spaces[n].fromXYZ)),this.spaces[n].transfer===rt&&(e.r=Zt(e.r),e.g=Zt(e.g),e.b=Zt(e.b)),e):e},workingToColorSpace:function(e,t){return this.convert(e,this.workingColorSpace,t)},colorSpaceToWorking:function(e,t){return this.convert(e,t,this.workingColorSpace)},getPrimaries:function(e){return this.spaces[e].primaries},getTransfer:function(e){return e===tt?it:this.spaces[e].transfer},getToneMappingMode:function(e){return this.spaces[e].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(e,t=this.workingColorSpace){return e.fromArray(this.spaces[t].luminanceCoefficients)},define:function(e){Object.assign(this.spaces,e)},_getMatrix:function(e,t,n){return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ)},_getDrawingBufferColorSpace:function(e){return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(e=this.workingColorSpace){return this.spaces[e].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(t,n){return Tt("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),e.workingToColorSpace(t,n)},toWorkingColorSpace:function(t,n){return Tt("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),e.colorSpaceToWorking(t,n)}},t=[.64,.33,.3,.6,.15,.06],n=[.2126,.7152,.0722],a=[.3127,.329];return e.define({[at]:{primaries:t,whitePoint:a,transfer:it,toXYZ:Xt,fromXYZ:Yt,luminanceCoefficients:n,workingColorSpaceConfig:{unpackColorSpace:nt},outputColorSpaceConfig:{drawingBufferColorSpace:nt}},[nt]:{primaries:t,whitePoint:a,transfer:rt,toXYZ:Xt,fromXYZ:Yt,luminanceCoefficients:n,outputColorSpaceConfig:{drawingBufferColorSpace:nt}}}),e}const Qt=$t();function Kt(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function Zt(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}let Jt;class en{static getDataURL(e,t="image/png"){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let n;if(e instanceof HTMLCanvasElement)n=e;else{void 0===Jt&&(Jt=xt("canvas")),Jt.width=e.width,Jt.height=e.height;const t=Jt.getContext("2d");e instanceof ImageData?t.putImageData(e,0,0):t.drawImage(e,0,0,e.width,e.height),n=Jt}return n.toDataURL(t)}static sRGBToLinear(e){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const t=xt("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const a=n.getImageData(0,0,e.width,e.height),i=a.data;for(let e=0;e<i.length;e++)i[e]=255*Kt(i[e]/255);return n.putImageData(a,0,0),t}if(e.data){const t=e.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(255*Kt(t[e]/255)):t[e]=Kt(t[e]);return{data:t,width:e.width,height:e.height}}return At("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let tn=0;class nn{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:tn++}),this.uuid=kt(),this.data=e,this.dataReady=!0,this.version=0}getSize(e){const t=this.data;return"undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement?e.set(t.videoWidth,t.videoHeight,0):t instanceof VideoFrame?e.set(t.displayHeight,t.displayWidth,0):null!==t?e.set(t.width,t.height,t.depth||0):e.set(0,0,0),e}set needsUpdate(e){!0===e&&this.version++}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.images[this.uuid])return e.images[this.uuid];const n={uuid:this.uuid,url:""},a=this.data;if(null!==a){let e;if(Array.isArray(a)){e=[];for(let t=0,n=a.length;t<n;t++)a[t].isDataTexture?e.push(an(a[t].image)):e.push(an(a[t]))}else e=an(a);n.url=e}return t||(e.images[this.uuid]=n),n}}function an(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap?en.getDataURL(e):e.data?{data:Array.from(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(At("Texture: Unable to serialize Texture."),{})}let rn=0;const sn=new Gt;class on extends Pt{constructor(e=on.DEFAULT_IMAGE,t=on.DEFAULT_MAPPING,n=1001,a=1001,i=1006,r=1008,s=1023,o=1009,l=on.DEFAULT_ANISOTROPY,c=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:rn++}),this.uuid=kt(),this.name="",this.source=new nn(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=n,this.wrapT=a,this.magFilter=i,this.minFilter=r,this.anisotropy=l,this.format=s,this.internalFormat=null,this.type=o,this.offset=new Vt(0,0),this.repeat=new Vt(1,1),this.center=new Vt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ht,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=c,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(e&&e.depth&&e.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(sn).x}get height(){return this.source.getSize(sn).y}get depth(){return this.source.getSize(sn).z}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return(new this.constructor).copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.isArrayTexture=e.isArrayTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}setValues(e){for(const t in e){const n=e[t];if(void 0===n){At(`Texture.setValues(): parameter '${t}' has value of undefined.`);continue}const a=this[t];void 0!==a?a&&n&&a.isVector2&&n.isVector2||a&&n&&a.isVector3&&n.isVector3||a&&n&&a.isMatrix3&&n.isMatrix3?a.copy(n):this[t]=n:At(`Texture.setValues(): property '${t}' does not exist.`)}}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(300!==this.mapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case N:e.x=e.x-Math.floor(e.x);break;case V:e.x=e.x<0?0:1;break;case U:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case N:e.y=e.y-Math.floor(e.y);break;case V:e.y=e.y<0?0:1;break;case U:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){!0===e&&this.pmremVersion++}}on.DEFAULT_IMAGE=null,on.DEFAULT_MAPPING=300,on.DEFAULT_ANISOTROPY=1;class ln{constructor(e=0,t=0,n=0,a=1){ln.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=a}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,a){return this.x=e,this.y=t,this.z=n,this.w=a,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,a=this.z,i=this.w,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*a+r[12]*i,this.y=r[1]*t+r[5]*n+r[9]*a+r[13]*i,this.z=r[2]*t+r[6]*n+r[10]*a+r[14]*i,this.w=r[3]*t+r[7]*n+r[11]*a+r[15]*i,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,a,i;const r=.01,s=.1,o=e.elements,l=o[0],c=o[4],h=o[8],d=o[1],u=o[5],p=o[9],m=o[2],f=o[6],g=o[10];if(Math.abs(c-d)<r&&Math.abs(h-m)<r&&Math.abs(p-f)<r){if(Math.abs(c+d)<s&&Math.abs(h+m)<s&&Math.abs(p+f)<s&&Math.abs(l+u+g-3)<s)return this.set(1,0,0,0),this;t=Math.PI;const e=(l+1)/2,o=(u+1)/2,y=(g+1)/2,v=(c+d)/4,b=(h+m)/4,w=(p+f)/4;return e>o&&e>y?e<r?(n=0,a=.707106781,i=.707106781):(n=Math.sqrt(e),a=v/n,i=b/n):o>y?o<r?(n=.707106781,a=0,i=.707106781):(a=Math.sqrt(o),n=v/a,i=w/a):y<r?(n=.707106781,a=.707106781,i=0):(i=Math.sqrt(y),n=b/i,a=w/i),this.set(n,a,i,t),this}let y=Math.sqrt((f-p)*(f-p)+(h-m)*(h-m)+(d-c)*(d-c));return Math.abs(y)<.001&&(y=1),this.x=(f-p)/y,this.y=(h-m)/y,this.z=(d-c)/y,this.w=Math.acos((l+u+g-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Rt(this.x,e.x,t.x),this.y=Rt(this.y,e.y,t.y),this.z=Rt(this.z,e.z,t.z),this.w=Rt(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=Rt(this.x,e,t),this.y=Rt(this.y,e,t),this.z=Rt(this.z,e,t),this.w=Rt(this.w,e,t),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Rt(n,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class cn extends Pt{constructor(e=1,t=1,n={}){super(),n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:H,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},n),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=n.depth,this.scissor=new ln(0,0,e,t),this.scissorTest=!1,this.viewport=new ln(0,0,e,t);const a={width:e,height:t,depth:n.depth},i=new on(a);this.textures=[];const r=n.count;for(let e=0;e<r;e++)this.textures[e]=i.clone(),this.textures[e].isRenderTargetTexture=!0,this.textures[e].renderTarget=this;this._setTextureOptions(n),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=n.depthTexture,this.samples=n.samples,this.multiview=n.multiview}_setTextureOptions(e={}){const t={minFilter:H,generateMipmaps:!1,flipY:!1,internalFormat:null};void 0!==e.mapping&&(t.mapping=e.mapping),void 0!==e.wrapS&&(t.wrapS=e.wrapS),void 0!==e.wrapT&&(t.wrapT=e.wrapT),void 0!==e.wrapR&&(t.wrapR=e.wrapR),void 0!==e.magFilter&&(t.magFilter=e.magFilter),void 0!==e.minFilter&&(t.minFilter=e.minFilter),void 0!==e.format&&(t.format=e.format),void 0!==e.type&&(t.type=e.type),void 0!==e.anisotropy&&(t.anisotropy=e.anisotropy),void 0!==e.colorSpace&&(t.colorSpace=e.colorSpace),void 0!==e.flipY&&(t.flipY=e.flipY),void 0!==e.generateMipmaps&&(t.generateMipmaps=e.generateMipmaps),void 0!==e.internalFormat&&(t.internalFormat=e.internalFormat);for(let e=0;e<this.textures.length;e++)this.textures[e].setValues(t)}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){null!==this._depthTexture&&(this._depthTexture.renderTarget=null),null!==e&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let a=0,i=this.textures.length;a<i;a++)this.textures[a].image.width=e,this.textures[a].image.height=t,this.textures[a].image.depth=n,!0!==this.textures[a].isData3DTexture&&(this.textures[a].isArrayTexture=this.textures[a].image.depth>1);this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let t=0,n=e.textures.length;t<n;t++){this.textures[t]=e.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;const n=Object.assign({},e.textures[t].image);this.textures[t].source=new nn(n)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class hn extends cn{constructor(e=1,t=1,n={}){super(e,t,n),this.isWebGLRenderTarget=!0}}class dn extends on{constructor(e=null,t=1,n=1,a=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:a},this.magFilter=G,this.minFilter=G,this.wrapR=V,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class un extends on{constructor(e=null,t=1,n=1,a=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:a},this.magFilter=G,this.minFilter=G,this.wrapR=V,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class pn{constructor(e=new Gt(1/0,1/0,1/0),t=new Gt(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t+=3)this.expandByPoint(fn.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,n=e.count;t<n;t++)this.expandByPoint(fn.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=fn.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(void 0!==n){const a=n.getAttribute("position");if(!0===t&&void 0!==a&&!0!==e.isInstancedMesh)for(let t=0,n=a.count;t<n;t++)!0===e.isMesh?e.getVertexPosition(t,fn):fn.fromBufferAttribute(a,t),fn.applyMatrix4(e.matrixWorld),this.expandByPoint(fn);else void 0!==e.boundingBox?(null===e.boundingBox&&e.computeBoundingBox(),gn.copy(e.boundingBox)):(null===n.boundingBox&&n.computeBoundingBox(),gn.copy(n.boundingBox)),gn.applyMatrix4(e.matrixWorld),this.union(gn)}const a=e.children;for(let e=0,n=a.length;e<n;e++)this.expandByObject(a[e],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,fn),fn.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Mn),_n.subVectors(this.max,Mn),yn.subVectors(e.a,Mn),vn.subVectors(e.b,Mn),bn.subVectors(e.c,Mn),wn.subVectors(vn,yn),xn.subVectors(bn,vn),Sn.subVectors(yn,bn);let t=[0,-wn.z,wn.y,0,-xn.z,xn.y,0,-Sn.z,Sn.y,wn.z,0,-wn.x,xn.z,0,-xn.x,Sn.z,0,-Sn.x,-wn.y,wn.x,0,-xn.y,xn.x,0,-Sn.y,Sn.x,0];return!!Tn(t,yn,vn,bn,_n)&&(t=[1,0,0,0,1,0,0,0,1],!!Tn(t,yn,vn,bn,_n)&&(An.crossVectors(wn,xn),t=[An.x,An.y,An.z],Tn(t,yn,vn,bn,_n)))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,fn).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=.5*this.getSize(fn).length()),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(mn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),mn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),mn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),mn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),mn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),mn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),mn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),mn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(mn)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(e){return this.min.fromArray(e.min),this.max.fromArray(e.max),this}}const mn=[new Gt,new Gt,new Gt,new Gt,new Gt,new Gt,new Gt,new Gt],fn=new Gt,gn=new pn,yn=new Gt,vn=new Gt,bn=new Gt,wn=new Gt,xn=new Gt,Sn=new Gt,Mn=new Gt,_n=new Gt,An=new Gt,Cn=new Gt;function Tn(e,t,n,a,i){for(let r=0,s=e.length-3;r<=s;r+=3){Cn.fromArray(e,r);const s=i.x*Math.abs(Cn.x)+i.y*Math.abs(Cn.y)+i.z*Math.abs(Cn.z),o=t.dot(Cn),l=n.dot(Cn),c=a.dot(Cn);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>s)return!1}return!0}const Pn=new pn,Dn=new Gt,On=new Gt;class En{constructor(e=new Gt,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):Pn.setFromPoints(e).getCenter(n);let a=0;for(let t=0,i=e.length;t<i;t++)a=Math.max(a,n.distanceToSquared(e[t]));return this.radius=Math.sqrt(a),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Dn.subVectors(e,this.center);const t=Dn.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),n=.5*(e-this.radius);this.center.addScaledVector(Dn,n/e),this.radius+=n}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(!0===this.center.equals(e.center)?this.radius=Math.max(this.radius,e.radius):(On.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Dn.copy(e.center).add(On)),this.expandByPoint(Dn.copy(e.center).sub(On))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(e){return this.radius=e.radius,this.center.fromArray(e.center),this}}const In=new Gt,kn=new Gt,Rn=new Gt,zn=new Gt,Fn=new Gt,Bn=new Gt,Ln=new Gt;class Nn{constructor(e=new Gt,t=new Gt(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,In)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=In.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(In.copy(this.origin).addScaledVector(this.direction,t),In.distanceToSquared(e))}distanceSqToSegment(e,t,n,a){kn.copy(e).add(t).multiplyScalar(.5),Rn.copy(t).sub(e).normalize(),zn.copy(this.origin).sub(kn);const i=.5*e.distanceTo(t),r=-this.direction.dot(Rn),s=zn.dot(this.direction),o=-zn.dot(Rn),l=zn.lengthSq(),c=Math.abs(1-r*r);let h,d,u,p;if(c>0)if(h=r*o-s,d=r*s-o,p=i*c,h>=0)if(d>=-p)if(d<=p){const e=1/c;h*=e,d*=e,u=h*(h+r*d+2*s)+d*(r*h+d+2*o)+l}else d=i,h=Math.max(0,-(r*d+s)),u=-h*h+d*(d+2*o)+l;else d=-i,h=Math.max(0,-(r*d+s)),u=-h*h+d*(d+2*o)+l;else d<=-p?(h=Math.max(0,-(-r*i+s)),d=h>0?-i:Math.min(Math.max(-i,-o),i),u=-h*h+d*(d+2*o)+l):d<=p?(h=0,d=Math.min(Math.max(-i,-o),i),u=d*(d+2*o)+l):(h=Math.max(0,-(r*i+s)),d=h>0?i:Math.min(Math.max(-i,-o),i),u=-h*h+d*(d+2*o)+l);else d=r>0?-i:i,h=Math.max(0,-(r*d+s)),u=-h*h+d*(d+2*o)+l;return n&&n.copy(this.origin).addScaledVector(this.direction,h),a&&a.copy(kn).addScaledVector(Rn,d),u}intersectSphere(e,t){In.subVectors(e.center,this.origin);const n=In.dot(this.direction),a=In.dot(In)-n*n,i=e.radius*e.radius;if(a>i)return null;const r=Math.sqrt(i-a),s=n-r,o=n+r;return o<0?null:s<0?this.at(o,t):this.at(s,t)}intersectsSphere(e){return!(e.radius<0)&&this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return 0===t||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,a,i,r,s,o;const l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,d=this.origin;return l>=0?(n=(e.min.x-d.x)*l,a=(e.max.x-d.x)*l):(n=(e.max.x-d.x)*l,a=(e.min.x-d.x)*l),c>=0?(i=(e.min.y-d.y)*c,r=(e.max.y-d.y)*c):(i=(e.max.y-d.y)*c,r=(e.min.y-d.y)*c),n>r||i>a?null:((i>n||isNaN(n))&&(n=i),(r<a||isNaN(a))&&(a=r),h>=0?(s=(e.min.z-d.z)*h,o=(e.max.z-d.z)*h):(s=(e.max.z-d.z)*h,o=(e.min.z-d.z)*h),n>o||s>a?null:((s>n||n!=n)&&(n=s),(o<a||a!=a)&&(a=o),a<0?null:this.at(n>=0?n:a,t)))}intersectsBox(e){return null!==this.intersectBox(e,In)}intersectTriangle(e,t,n,a,i){Fn.subVectors(t,e),Bn.subVectors(n,e),Ln.crossVectors(Fn,Bn);let r,s=this.direction.dot(Ln);if(s>0){if(a)return null;r=1}else{if(!(s<0))return null;r=-1,s=-s}zn.subVectors(this.origin,e);const o=r*this.direction.dot(Bn.crossVectors(zn,Bn));if(o<0)return null;const l=r*this.direction.dot(Fn.cross(zn));if(l<0)return null;if(o+l>s)return null;const c=-r*zn.dot(Ln);return c<0?null:this.at(c/s,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Vn{constructor(e,t,n,a,i,r,s,o,l,c,h,d,u,p,m,f){Vn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==e&&this.set(e,t,n,a,i,r,s,o,l,c,h,d,u,p,m,f)}set(e,t,n,a,i,r,s,o,l,c,h,d,u,p,m,f){const g=this.elements;return g[0]=e,g[4]=t,g[8]=n,g[12]=a,g[1]=i,g[5]=r,g[9]=s,g[13]=o,g[2]=l,g[6]=c,g[10]=h,g[14]=d,g[3]=u,g[7]=p,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Vn).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,a=1/Un.setFromMatrixColumn(e,0).length(),i=1/Un.setFromMatrixColumn(e,1).length(),r=1/Un.setFromMatrixColumn(e,2).length();return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=0,t[4]=n[4]*i,t[5]=n[5]*i,t[6]=n[6]*i,t[7]=0,t[8]=n[8]*r,t[9]=n[9]*r,t[10]=n[10]*r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,a=e.y,i=e.z,r=Math.cos(n),s=Math.sin(n),o=Math.cos(a),l=Math.sin(a),c=Math.cos(i),h=Math.sin(i);if("XYZ"===e.order){const e=r*c,n=r*h,a=s*c,i=s*h;t[0]=o*c,t[4]=-o*h,t[8]=l,t[1]=n+a*l,t[5]=e-i*l,t[9]=-s*o,t[2]=i-e*l,t[6]=a+n*l,t[10]=r*o}else if("YXZ"===e.order){const e=o*c,n=o*h,a=l*c,i=l*h;t[0]=e+i*s,t[4]=a*s-n,t[8]=r*l,t[1]=r*h,t[5]=r*c,t[9]=-s,t[2]=n*s-a,t[6]=i+e*s,t[10]=r*o}else if("ZXY"===e.order){const e=o*c,n=o*h,a=l*c,i=l*h;t[0]=e-i*s,t[4]=-r*h,t[8]=a+n*s,t[1]=n+a*s,t[5]=r*c,t[9]=i-e*s,t[2]=-r*l,t[6]=s,t[10]=r*o}else if("ZYX"===e.order){const e=r*c,n=r*h,a=s*c,i=s*h;t[0]=o*c,t[4]=a*l-n,t[8]=e*l+i,t[1]=o*h,t[5]=i*l+e,t[9]=n*l-a,t[2]=-l,t[6]=s*o,t[10]=r*o}else if("YZX"===e.order){const e=r*o,n=r*l,a=s*o,i=s*l;t[0]=o*c,t[4]=i-e*h,t[8]=a*h+n,t[1]=h,t[5]=r*c,t[9]=-s*c,t[2]=-l*c,t[6]=n*h+a,t[10]=e-i*h}else if("XZY"===e.order){const e=r*o,n=r*l,a=s*o,i=s*l;t[0]=o*c,t[4]=-h,t[8]=l*c,t[1]=e*h+i,t[5]=r*c,t[9]=n*h-a,t[2]=a*h-n,t[6]=s*c,t[10]=i*h+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Wn,e,qn)}lookAt(e,t,n){const a=this.elements;return Xn.subVectors(e,t),0===Xn.lengthSq()&&(Xn.z=1),Xn.normalize(),Hn.crossVectors(n,Xn),0===Hn.lengthSq()&&(1===Math.abs(n.z)?Xn.x+=1e-4:Xn.z+=1e-4,Xn.normalize(),Hn.crossVectors(n,Xn)),Hn.normalize(),jn.crossVectors(Xn,Hn),a[0]=Hn.x,a[4]=jn.x,a[8]=Xn.x,a[1]=Hn.y,a[5]=jn.y,a[9]=Xn.y,a[2]=Hn.z,a[6]=jn.z,a[10]=Xn.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,a=t.elements,i=this.elements,r=n[0],s=n[4],o=n[8],l=n[12],c=n[1],h=n[5],d=n[9],u=n[13],p=n[2],m=n[6],f=n[10],g=n[14],y=n[3],v=n[7],b=n[11],w=n[15],x=a[0],S=a[4],M=a[8],_=a[12],A=a[1],C=a[5],T=a[9],P=a[13],D=a[2],O=a[6],E=a[10],I=a[14],k=a[3],R=a[7],z=a[11],F=a[15];return i[0]=r*x+s*A+o*D+l*k,i[4]=r*S+s*C+o*O+l*R,i[8]=r*M+s*T+o*E+l*z,i[12]=r*_+s*P+o*I+l*F,i[1]=c*x+h*A+d*D+u*k,i[5]=c*S+h*C+d*O+u*R,i[9]=c*M+h*T+d*E+u*z,i[13]=c*_+h*P+d*I+u*F,i[2]=p*x+m*A+f*D+g*k,i[6]=p*S+m*C+f*O+g*R,i[10]=p*M+m*T+f*E+g*z,i[14]=p*_+m*P+f*I+g*F,i[3]=y*x+v*A+b*D+w*k,i[7]=y*S+v*C+b*O+w*R,i[11]=y*M+v*T+b*E+w*z,i[15]=y*_+v*P+b*I+w*F,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],a=e[8],i=e[12],r=e[1],s=e[5],o=e[9],l=e[13],c=e[2],h=e[6],d=e[10],u=e[14];return e[3]*(+i*o*h-a*l*h-i*s*d+n*l*d+a*s*u-n*o*u)+e[7]*(+t*o*u-t*l*d+i*r*d-a*r*u+a*l*c-i*o*c)+e[11]*(+t*l*h-t*s*u-i*r*h+n*r*u+i*s*c-n*l*c)+e[15]*(-a*s*c-t*o*h+t*s*d+a*r*h-n*r*d+n*o*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const a=this.elements;return e.isVector3?(a[12]=e.x,a[13]=e.y,a[14]=e.z):(a[12]=e,a[13]=t,a[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],a=e[2],i=e[3],r=e[4],s=e[5],o=e[6],l=e[7],c=e[8],h=e[9],d=e[10],u=e[11],p=e[12],m=e[13],f=e[14],g=e[15],y=h*f*l-m*d*l+m*o*u-s*f*u-h*o*g+s*d*g,v=p*d*l-c*f*l-p*o*u+r*f*u+c*o*g-r*d*g,b=c*m*l-p*h*l+p*s*u-r*m*u-c*s*g+r*h*g,w=p*h*o-c*m*o-p*s*d+r*m*d+c*s*f-r*h*f,x=t*y+n*v+a*b+i*w;if(0===x)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/x;return e[0]=y*S,e[1]=(m*d*i-h*f*i-m*a*u+n*f*u+h*a*g-n*d*g)*S,e[2]=(s*f*i-m*o*i+m*a*l-n*f*l-s*a*g+n*o*g)*S,e[3]=(h*o*i-s*d*i-h*a*l+n*d*l+s*a*u-n*o*u)*S,e[4]=v*S,e[5]=(c*f*i-p*d*i+p*a*u-t*f*u-c*a*g+t*d*g)*S,e[6]=(p*o*i-r*f*i-p*a*l+t*f*l+r*a*g-t*o*g)*S,e[7]=(r*d*i-c*o*i+c*a*l-t*d*l-r*a*u+t*o*u)*S,e[8]=b*S,e[9]=(p*h*i-c*m*i-p*n*u+t*m*u+c*n*g-t*h*g)*S,e[10]=(r*m*i-p*s*i+p*n*l-t*m*l-r*n*g+t*s*g)*S,e[11]=(c*s*i-r*h*i-c*n*l+t*h*l+r*n*u-t*s*u)*S,e[12]=w*S,e[13]=(c*m*a-p*h*a+p*n*d-t*m*d-c*n*f+t*h*f)*S,e[14]=(p*s*a-r*m*a-p*n*o+t*m*o+r*n*f-t*s*f)*S,e[15]=(r*h*a-c*s*a+c*n*o-t*h*o-r*n*d+t*s*d)*S,this}scale(e){const t=this.elements,n=e.x,a=e.y,i=e.z;return t[0]*=n,t[4]*=a,t[8]*=i,t[1]*=n,t[5]*=a,t[9]*=i,t[2]*=n,t[6]*=a,t[10]*=i,t[3]*=n,t[7]*=a,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],a=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,a))}makeTranslation(e,t,n){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),a=Math.sin(t),i=1-n,r=e.x,s=e.y,o=e.z,l=i*r,c=i*s;return this.set(l*r+n,l*s-a*o,l*o+a*s,0,l*s+a*o,c*s+n,c*o-a*r,0,l*o-a*s,c*o+a*r,i*o*o+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,a,i,r){return this.set(1,n,i,0,e,1,r,0,t,a,1,0,0,0,0,1),this}compose(e,t,n){const a=this.elements,i=t._x,r=t._y,s=t._z,o=t._w,l=i+i,c=r+r,h=s+s,d=i*l,u=i*c,p=i*h,m=r*c,f=r*h,g=s*h,y=o*l,v=o*c,b=o*h,w=n.x,x=n.y,S=n.z;return a[0]=(1-(m+g))*w,a[1]=(u+b)*w,a[2]=(p-v)*w,a[3]=0,a[4]=(u-b)*x,a[5]=(1-(d+g))*x,a[6]=(f+y)*x,a[7]=0,a[8]=(p+v)*S,a[9]=(f-y)*S,a[10]=(1-(d+m))*S,a[11]=0,a[12]=e.x,a[13]=e.y,a[14]=e.z,a[15]=1,this}decompose(e,t,n){const a=this.elements;let i=Un.set(a[0],a[1],a[2]).length();const r=Un.set(a[4],a[5],a[6]).length(),s=Un.set(a[8],a[9],a[10]).length();this.determinant()<0&&(i=-i),e.x=a[12],e.y=a[13],e.z=a[14],Gn.copy(this);const o=1/i,l=1/r,c=1/s;return Gn.elements[0]*=o,Gn.elements[1]*=o,Gn.elements[2]*=o,Gn.elements[4]*=l,Gn.elements[5]*=l,Gn.elements[6]*=l,Gn.elements[8]*=c,Gn.elements[9]*=c,Gn.elements[10]*=c,t.setFromRotationMatrix(Gn),n.x=i,n.y=r,n.z=s,this}makePerspective(e,t,n,a,i,r,s=2e3,o=!1){const l=this.elements,c=2*i/(t-e),h=2*i/(n-a),d=(t+e)/(t-e),u=(n+a)/(n-a);let p,m;if(o)p=i/(r-i),m=r*i/(r-i);else if(s===vt)p=-(r+i)/(r-i),m=-2*r*i/(r-i);else{if(s!==bt)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+s);p=-r/(r-i),m=-r*i/(r-i)}return l[0]=c,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=h,l[9]=u,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=m,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,n,a,i,r,s=2e3,o=!1){const l=this.elements,c=2/(t-e),h=2/(n-a),d=-(t+e)/(t-e),u=-(n+a)/(n-a);let p,m;if(o)p=1/(r-i),m=r/(r-i);else if(s===vt)p=-2/(r-i),m=-(r+i)/(r-i);else{if(s!==bt)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+s);p=-1/(r-i),m=-i/(r-i)}return l[0]=c,l[4]=0,l[8]=0,l[12]=d,l[1]=0,l[5]=h,l[9]=0,l[13]=u,l[2]=0,l[6]=0,l[10]=p,l[14]=m,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<16;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const Un=new Gt,Gn=new Vn,Wn=new Gt(0,0,0),qn=new Gt(1,1,1),Hn=new Gt,jn=new Gt,Xn=new Gt,Yn=new Vn,$n=new Ut;class Qn{constructor(e=0,t=0,n=0,a=Qn.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=a}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,a=this._order){return this._x=e,this._y=t,this._z=n,this._order=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const a=e.elements,i=a[0],r=a[4],s=a[8],o=a[1],l=a[5],c=a[9],h=a[2],d=a[6],u=a[10];switch(t){case"XYZ":this._y=Math.asin(Rt(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-c,u),this._z=Math.atan2(-r,i)):(this._x=Math.atan2(d,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Rt(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(s,u),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-h,i),this._z=0);break;case"ZXY":this._x=Math.asin(Rt(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,u),this._z=Math.atan2(-r,l)):(this._y=0,this._z=Math.atan2(o,i));break;case"ZYX":this._y=Math.asin(-Rt(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,u),this._z=Math.atan2(o,i)):(this._x=0,this._z=Math.atan2(-r,l));break;case"YZX":this._z=Math.asin(Rt(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,i)):(this._x=0,this._y=Math.atan2(s,u));break;case"XZY":this._z=Math.asin(-Rt(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(d,l),this._y=Math.atan2(s,i)):(this._x=Math.atan2(-c,u),this._y=0);break;default:At("Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!0===n&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return Yn.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Yn,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return $n.setFromEuler(this),this.setFromQuaternion($n,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Qn.DEFAULT_ORDER="XYZ";class Kn{constructor(){this.mask=1}set(e){this.mask=1<<e>>>0}enable(e){this.mask|=1<<e}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e}disable(e){this.mask&=~(1<<e)}disableAll(){this.mask=0}test(e){return 0!==(this.mask&e.mask)}isEnabled(e){return!!(this.mask&1<<e)}}let Zn=0;const Jn=new Gt,ea=new Ut,ta=new Vn,na=new Gt,aa=new Gt,ia=new Gt,ra=new Ut,sa=new Gt(1,0,0),oa=new Gt(0,1,0),la=new Gt(0,0,1),ca={type:"added"},ha={type:"removed"},da={type:"childadded",child:null},ua={type:"childremoved",child:null};class pa extends Pt{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Zn++}),this.uuid=kt(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=pa.DEFAULT_UP.clone();const e=new Gt,t=new Qn,n=new Ut,a=new Gt(1,1,1);t._onChange(function(){n.setFromEuler(t,!1)}),n._onChange(function(){t.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:a},modelViewMatrix:{value:new Vn},normalMatrix:{value:new Ht}}),this.matrix=new Vn,this.matrixWorld=new Vn,this.matrixAutoUpdate=pa.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=pa.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Kn,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return ea.setFromAxisAngle(e,t),this.quaternion.multiply(ea),this}rotateOnWorldAxis(e,t){return ea.setFromAxisAngle(e,t),this.quaternion.premultiply(ea),this}rotateX(e){return this.rotateOnAxis(sa,e)}rotateY(e){return this.rotateOnAxis(oa,e)}rotateZ(e){return this.rotateOnAxis(la,e)}translateOnAxis(e,t){return Jn.copy(e).applyQuaternion(this.quaternion),this.position.add(Jn.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(sa,e)}translateY(e){return this.translateOnAxis(oa,e)}translateZ(e){return this.translateOnAxis(la,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(ta.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?na.copy(e):na.set(e,t,n);const a=this.parent;this.updateWorldMatrix(!0,!1),aa.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ta.lookAt(aa,na,this.up):ta.lookAt(na,aa,this.up),this.quaternion.setFromRotationMatrix(ta),a&&(ta.extractRotation(a.matrixWorld),ea.setFromRotationMatrix(ta),this.quaternion.premultiply(ea.invert()))}add(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(Ct("Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(ca),da.child=e,this.dispatchEvent(da),da.child=null):Ct("Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(ha),ua.child=e,this.dispatchEvent(ua),ua.child=null),this}removeFromParent(){const e=this.parent;return null!==e&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),ta.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),ta.multiply(e.parent.matrixWorld)),e.applyMatrix4(ta),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(ca),da.child=e,this.dispatchEvent(da),da.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,a=this.children.length;n<a;n++){const a=this.children[n].getObjectByProperty(e,t);if(void 0!==a)return a}}getObjectsByProperty(e,t,n=[]){this[e]===t&&n.push(this);const a=this.children;for(let i=0,r=a.length;i<r;i++)a[i].getObjectsByProperty(e,t,n);return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(aa,e,ia),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(aa,ra,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,a=t.length;n<a;n++)t[n].traverse(e)}traverseVisible(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,a=t.length;n<a;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,a=t.length;n<a;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}}toJSON(e){const t=void 0===e||"string"==typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const a={};function i(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(a.uuid=this.uuid,a.type=this.type,""!==this.name&&(a.name=this.name),!0===this.castShadow&&(a.castShadow=!0),!0===this.receiveShadow&&(a.receiveShadow=!0),!1===this.visible&&(a.visible=!1),!1===this.frustumCulled&&(a.frustumCulled=!1),0!==this.renderOrder&&(a.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(a.userData=this.userData),a.layers=this.layers.mask,a.matrix=this.matrix.toArray(),a.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(a.matrixAutoUpdate=!1),this.isInstancedMesh&&(a.type="InstancedMesh",a.count=this.count,a.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(a.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(a.type="BatchedMesh",a.perObjectFrustumCulled=this.perObjectFrustumCulled,a.sortObjects=this.sortObjects,a.drawRanges=this._drawRanges,a.reservedRanges=this._reservedRanges,a.geometryInfo=this._geometryInfo.map(e=>({...e,boundingBox:e.boundingBox?e.boundingBox.toJSON():void 0,boundingSphere:e.boundingSphere?e.boundingSphere.toJSON():void 0})),a.instanceInfo=this._instanceInfo.map(e=>({...e})),a.availableInstanceIds=this._availableInstanceIds.slice(),a.availableGeometryIds=this._availableGeometryIds.slice(),a.nextIndexStart=this._nextIndexStart,a.nextVertexStart=this._nextVertexStart,a.geometryCount=this._geometryCount,a.maxInstanceCount=this._maxInstanceCount,a.maxVertexCount=this._maxVertexCount,a.maxIndexCount=this._maxIndexCount,a.geometryInitialized=this._geometryInitialized,a.matricesTexture=this._matricesTexture.toJSON(e),a.indirectTexture=this._indirectTexture.toJSON(e),null!==this._colorsTexture&&(a.colorsTexture=this._colorsTexture.toJSON(e)),null!==this.boundingSphere&&(a.boundingSphere=this.boundingSphere.toJSON()),null!==this.boundingBox&&(a.boundingBox=this.boundingBox.toJSON())),this.isScene)this.background&&(this.background.isColor?a.background=this.background.toJSON():this.background.isTexture&&(a.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(a.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){a.geometry=i(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,a=n.length;t<a;t++){const a=n[t];i(e.shapes,a)}else i(e.shapes,n)}}if(this.isSkinnedMesh&&(a.bindMode=this.bindMode,a.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(e.skeletons,this.skeleton),a.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,a=this.material.length;n<a;n++)t.push(i(e.materials,this.material[n]));a.material=t}else a.material=i(e.materials,this.material);if(this.children.length>0){a.children=[];for(let t=0;t<this.children.length;t++)a.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){a.animations=[];for(let t=0;t<this.animations.length;t++){const n=this.animations[t];a.animations.push(i(e.animations,n))}}if(t){const t=r(e.geometries),a=r(e.materials),i=r(e.textures),s=r(e.images),o=r(e.shapes),l=r(e.skeletons),c=r(e.animations),h=r(e.nodes);t.length>0&&(n.geometries=t),a.length>0&&(n.materials=a),i.length>0&&(n.textures=i),s.length>0&&(n.images=s),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c),h.length>0&&(n.nodes=h)}return n.object=a,n;function r(e){const t=[];for(const n in e){const a=e[n];delete a.metadata,t.push(a)}return t}}clone(e){return(new this.constructor).copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let t=0;t<e.children.length;t++){const n=e.children[t];this.add(n.clone())}return this}}pa.DEFAULT_UP=new Gt(0,1,0),pa.DEFAULT_MATRIX_AUTO_UPDATE=!0,pa.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ma=new Gt,fa=new Gt,ga=new Gt,ya=new Gt,va=new Gt,ba=new Gt,wa=new Gt,xa=new Gt,Sa=new Gt,Ma=new Gt,_a=new ln,Aa=new ln,Ca=new ln;class Ta{constructor(e=new Gt,t=new Gt,n=new Gt){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,a){a.subVectors(n,t),ma.subVectors(e,t),a.cross(ma);const i=a.lengthSq();return i>0?a.multiplyScalar(1/Math.sqrt(i)):a.set(0,0,0)}static getBarycoord(e,t,n,a,i){ma.subVectors(a,t),fa.subVectors(n,t),ga.subVectors(e,t);const r=ma.dot(ma),s=ma.dot(fa),o=ma.dot(ga),l=fa.dot(fa),c=fa.dot(ga),h=r*l-s*s;if(0===h)return i.set(0,0,0),null;const d=1/h,u=(l*o-s*c)*d,p=(r*c-s*o)*d;return i.set(1-u-p,p,u)}static containsPoint(e,t,n,a){return null!==this.getBarycoord(e,t,n,a,ya)&&ya.x>=0&&ya.y>=0&&ya.x+ya.y<=1}static getInterpolation(e,t,n,a,i,r,s,o){return null===this.getBarycoord(e,t,n,a,ya)?(o.x=0,o.y=0,"z"in o&&(o.z=0),"w"in o&&(o.w=0),null):(o.setScalar(0),o.addScaledVector(i,ya.x),o.addScaledVector(r,ya.y),o.addScaledVector(s,ya.z),o)}static getInterpolatedAttribute(e,t,n,a,i,r){return _a.setScalar(0),Aa.setScalar(0),Ca.setScalar(0),_a.fromBufferAttribute(e,t),Aa.fromBufferAttribute(e,n),Ca.fromBufferAttribute(e,a),r.setScalar(0),r.addScaledVector(_a,i.x),r.addScaledVector(Aa,i.y),r.addScaledVector(Ca,i.z),r}static isFrontFacing(e,t,n,a){return ma.subVectors(n,t),fa.subVectors(e,t),ma.cross(fa).dot(a)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,a){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[a]),this}setFromAttributeAndIndices(e,t,n,a){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,a),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return ma.subVectors(this.c,this.b),fa.subVectors(this.a,this.b),.5*ma.cross(fa).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ta.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ta.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,n,a,i){return Ta.getInterpolation(e,this.a,this.b,this.c,t,n,a,i)}containsPoint(e){return Ta.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ta.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,a=this.b,i=this.c;let r,s;va.subVectors(a,n),ba.subVectors(i,n),xa.subVectors(e,n);const o=va.dot(xa),l=ba.dot(xa);if(o<=0&&l<=0)return t.copy(n);Sa.subVectors(e,a);const c=va.dot(Sa),h=ba.dot(Sa);if(c>=0&&h<=c)return t.copy(a);const d=o*h-c*l;if(d<=0&&o>=0&&c<=0)return r=o/(o-c),t.copy(n).addScaledVector(va,r);Ma.subVectors(e,i);const u=va.dot(Ma),p=ba.dot(Ma);if(p>=0&&u<=p)return t.copy(i);const m=u*l-o*p;if(m<=0&&l>=0&&p<=0)return s=l/(l-p),t.copy(n).addScaledVector(ba,s);const f=c*p-u*h;if(f<=0&&h-c>=0&&u-p>=0)return wa.subVectors(i,a),s=(h-c)/(h-c+(u-p)),t.copy(a).addScaledVector(wa,s);const g=1/(f+m+d);return r=m*g,s=d*g,t.copy(n).addScaledVector(va,r).addScaledVector(ba,s)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const Pa={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Da={h:0,s:0,l:0},Oa={h:0,s:0,l:0};function Ea(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}class Ia{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(void 0===t&&void 0===n){const t=e;t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=nt){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,Qt.colorSpaceToWorking(this,t),this}setRGB(e,t,n,a=Qt.workingColorSpace){return this.r=e,this.g=t,this.b=n,Qt.colorSpaceToWorking(this,a),this}setHSL(e,t,n,a=Qt.workingColorSpace){if(e=zt(e,1),t=Rt(t,0,1),n=Rt(n,0,1),0===t)this.r=this.g=this.b=n;else{const a=n<=.5?n*(1+t):n+t-n*t,i=2*n-a;this.r=Ea(i,a,e+1/3),this.g=Ea(i,a,e),this.b=Ea(i,a,e-1/3)}return Qt.colorSpaceToWorking(this,a),this}setStyle(e,t=nt){function n(t){void 0!==t&&parseFloat(t)<1&&At("Color: Alpha component of "+e+" will be ignored.")}let a;if(a=/^(\w+)\(([^\)]*)\)/.exec(e)){let i;const r=a[1],s=a[2];switch(r){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,t);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,t);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,t);break;default:At("Color: Unknown color model "+e)}}else if(a=/^\#([A-Fa-f\d]+)$/.exec(e)){const n=a[1],i=n.length;if(3===i)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,t);if(6===i)return this.setHex(parseInt(n,16),t);At("Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=nt){const n=Pa[e.toLowerCase()];return void 0!==n?this.setHex(n,t):At("Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Kt(e.r),this.g=Kt(e.g),this.b=Kt(e.b),this}copyLinearToSRGB(e){return this.r=Zt(e.r),this.g=Zt(e.g),this.b=Zt(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=nt){return Qt.workingToColorSpace(ka.copy(this),e),65536*Math.round(Rt(255*ka.r,0,255))+256*Math.round(Rt(255*ka.g,0,255))+Math.round(Rt(255*ka.b,0,255))}getHexString(e=nt){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Qt.workingColorSpace){Qt.workingToColorSpace(ka.copy(this),t);const n=ka.r,a=ka.g,i=ka.b,r=Math.max(n,a,i),s=Math.min(n,a,i);let o,l;const c=(s+r)/2;if(s===r)o=0,l=0;else{const e=r-s;switch(l=c<=.5?e/(r+s):e/(2-r-s),r){case n:o=(a-i)/e+(a<i?6:0);break;case a:o=(i-n)/e+2;break;case i:o=(n-a)/e+4}o/=6}return e.h=o,e.s=l,e.l=c,e}getRGB(e,t=Qt.workingColorSpace){return Qt.workingToColorSpace(ka.copy(this),t),e.r=ka.r,e.g=ka.g,e.b=ka.b,e}getStyle(e=nt){Qt.workingToColorSpace(ka.copy(this),e);const t=ka.r,n=ka.g,a=ka.b;return e!==nt?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${a.toFixed(3)})`:`rgb(${Math.round(255*t)},${Math.round(255*n)},${Math.round(255*a)})`}offsetHSL(e,t,n){return this.getHSL(Da),this.setHSL(Da.h+e,Da.s+t,Da.l+n)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Da),e.getHSL(Oa);const n=Ft(Da.h,Oa.h,t),a=Ft(Da.s,Oa.s,t),i=Ft(Da.l,Oa.l,t);return this.setHSL(n,a,i),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,a=this.b,i=e.elements;return this.r=i[0]*t+i[3]*n+i[6]*a,this.g=i[1]*t+i[4]*n+i[7]*a,this.b=i[2]*t+i[5]*n+i[8]*a,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ka=new Ia;Ia.NAMES=Pa;let Ra=0;class za extends Pt{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Ra++}),this.uuid=kt(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=p,this.blendDst=m,this.blendEquation=s,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Ia(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=st,this.stencilZFail=st,this.stencilZPass=st,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){At(`Material: parameter '${t}' has value of undefined.`);continue}const a=this[t];void 0!==a?a&&a.isColor?a.set(n):a&&a.isVector3&&n&&n.isVector3?a.copy(n):this[t]=n:At(`Material: '${t}' is not a property of THREE.${this.type}.`)}}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};function a(e){const t=[];for(const n in e){const a=e[n];delete a.metadata,t.push(a)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.sheenColorMap&&this.sheenColorMap.isTexture&&(n.sheenColorMap=this.sheenColorMap.toJSON(e).uuid),this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture&&(n.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(e).uuid),void 0!==this.dispersion&&(n.dispersion=this.dispersion),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),void 0!==this.anisotropy&&(n.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapRotation&&(n.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),!0===this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=!0),this.blendSrc!==p&&(n.blendSrc=this.blendSrc),this.blendDst!==m&&(n.blendDst=this.blendDst),this.blendEquation!==s&&(n.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(n.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(n.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(n.blendAlpha=this.blendAlpha),3!==this.depthFunc&&(n.depthFunc=this.depthFunc),!1===this.depthTest&&(n.depthTest=this.depthTest),!1===this.depthWrite&&(n.depthWrite=this.depthWrite),!1===this.colorWrite&&(n.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(n.stencilWriteMask=this.stencilWriteMask),519!==this.stencilFunc&&(n.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(n.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==st&&(n.stencilFail=this.stencilFail),this.stencilZFail!==st&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==st&&(n.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(n.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaHash&&(n.alphaHash=!0),!0===this.alphaToCoverage&&(n.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=!0),!0===this.forceSinglePass&&(n.forceSinglePass=!0),!0===this.wireframe&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData),t){const t=a(e.textures),i=a(e.images);t.length>0&&(n.textures=t),i.length>0&&(n.images=i)}return n}clone(){return(new this.constructor).copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let a=0;a!==e;++a)n[a]=t[a].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}}class Fa extends za{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Ia(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Qn,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Ba=La();function La(){const e=new ArrayBuffer(4),t=new Float32Array(e),n=new Uint32Array(e),a=new Uint32Array(512),i=new Uint32Array(512);for(let e=0;e<256;++e){const t=e-127;t<-27?(a[e]=0,a[256|e]=32768,i[e]=24,i[256|e]=24):t<-14?(a[e]=1024>>-t-14,a[256|e]=1024>>-t-14|32768,i[e]=-t-1,i[256|e]=-t-1):t<=15?(a[e]=t+15<<10,a[256|e]=t+15<<10|32768,i[e]=13,i[256|e]=13):t<128?(a[e]=31744,a[256|e]=64512,i[e]=24,i[256|e]=24):(a[e]=31744,a[256|e]=64512,i[e]=13,i[256|e]=13)}const r=new Uint32Array(2048),s=new Uint32Array(64),o=new Uint32Array(64);for(let e=1;e<1024;++e){let t=e<<13,n=0;for(;!(8388608&t);)t<<=1,n-=8388608;t&=-8388609,n+=947912704,r[e]=t|n}for(let e=1024;e<2048;++e)r[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)s[e]=e<<23;s[31]=1199570944,s[32]=2147483648;for(let e=33;e<63;++e)s[e]=2147483648+(e-32<<23);s[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(o[e]=1024);return{floatView:t,uint32View:n,baseTable:a,shiftTable:i,mantissaTable:r,exponentTable:s,offsetTable:o}}class Na{static toHalfFloat(e){return function(e){Math.abs(e)>65504&&At("DataUtils.toHalfFloat(): Value out of range."),e=Rt(e,-65504,65504),Ba.floatView[0]=e;const t=Ba.uint32View[0],n=t>>23&511;return Ba.baseTable[n]+((8388607&t)>>Ba.shiftTable[n])}(e)}static fromHalfFloat(e){return function(e){const t=e>>10;return Ba.uint32View[0]=Ba.mantissaTable[Ba.offsetTable[t]+(1023&e)]+Ba.exponentTable[t],Ba.floatView[0]}(e)}}const Va=new Gt,Ua=new Vt;let Ga=0;class Wa{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:Ga++}),this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=n,this.usage=ft,this.updateRanges=[],this.gpuType=ee,this.version=0}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let a=0,i=this.itemSize;a<i;a++)this.array[e+a]=t.array[n+a];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)Ua.fromBufferAttribute(this,t),Ua.applyMatrix3(e),this.setXY(t,Ua.x,Ua.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)Va.fromBufferAttribute(this,t),Va.applyMatrix3(e),this.setXYZ(t,Va.x,Va.y,Va.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Va.fromBufferAttribute(this,t),Va.applyMatrix4(e),this.setXYZ(t,Va.x,Va.y,Va.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Va.fromBufferAttribute(this,t),Va.applyNormalMatrix(e),this.setXYZ(t,Va.x,Va.y,Va.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Va.fromBufferAttribute(this,t),Va.transformDirection(e),this.setXYZ(t,Va.x,Va.y,Va.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let n=this.array[e*this.itemSize+t];return this.normalized&&(n=Bt(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=Lt(n,this.array)),this.array[e*this.itemSize+t]=n,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Bt(t,this.array)),t}setX(e,t){return this.normalized&&(t=Lt(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Bt(t,this.array)),t}setY(e,t){return this.normalized&&(t=Lt(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Bt(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Lt(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Bt(t,this.array)),t}setW(e,t){return this.normalized&&(t=Lt(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=Lt(t,this.array),n=Lt(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,a){return e*=this.itemSize,this.normalized&&(t=Lt(t,this.array),n=Lt(n,this.array),a=Lt(a,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=a,this}setXYZW(e,t,n,a,i){return e*=this.itemSize,this.normalized&&(t=Lt(t,this.array),n=Lt(n,this.array),a=Lt(a,this.array),i=Lt(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=a,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(e.name=this.name),this.usage!==ft&&(e.usage=this.usage),e}}class qa extends Wa{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Ha extends Wa{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class ja extends Wa{constructor(e,t,n){super(new Float32Array(e),t,n)}}let Xa=0;const Ya=new Vn,$a=new pa,Qa=new Gt,Ka=new pn,Za=new pn,Ja=new Gt;class ei extends Pt{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Xa++}),this.uuid=kt(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(wt(e)?Ha:qa)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new Ht).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const a=this.attributes.tangent;return void 0!==a&&(a.transformDirection(e),a.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(e){return Ya.makeRotationFromQuaternion(e),this.applyMatrix4(Ya),this}rotateX(e){return Ya.makeRotationX(e),this.applyMatrix4(Ya),this}rotateY(e){return Ya.makeRotationY(e),this.applyMatrix4(Ya),this}rotateZ(e){return Ya.makeRotationZ(e),this.applyMatrix4(Ya),this}translate(e,t,n){return Ya.makeTranslation(e,t,n),this.applyMatrix4(Ya),this}scale(e,t,n){return Ya.makeScale(e,t,n),this.applyMatrix4(Ya),this}lookAt(e){return $a.lookAt(e),$a.updateMatrix(),this.applyMatrix4($a.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Qa).negate(),this.translate(Qa.x,Qa.y,Qa.z),this}setFromPoints(e){const t=this.getAttribute("position");if(void 0===t){const t=[];for(let n=0,a=e.length;n<a;n++){const a=e[n];t.push(a.x,a.y,a.z||0)}this.setAttribute("position",new ja(t,3))}else{const n=Math.min(e.length,t.count);for(let a=0;a<n;a++){const n=e[a];t.setXYZ(a,n.x,n.y,n.z||0)}e.length>t.count&&At("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new pn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return Ct("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new Gt(-1/0,-1/0,-1/0),new Gt(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Ka.setFromBufferAttribute(n),this.morphTargetsRelative?(Ja.addVectors(this.boundingBox.min,Ka.min),this.boundingBox.expandByPoint(Ja),Ja.addVectors(this.boundingBox.max,Ka.max),this.boundingBox.expandByPoint(Ja)):(this.boundingBox.expandByPoint(Ka.min),this.boundingBox.expandByPoint(Ka.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&Ct('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new En);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return Ct("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new Gt,1/0);if(e){const n=this.boundingSphere.center;if(Ka.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Za.setFromBufferAttribute(n),this.morphTargetsRelative?(Ja.addVectors(Ka.min,Za.min),Ka.expandByPoint(Ja),Ja.addVectors(Ka.max,Za.max),Ka.expandByPoint(Ja)):(Ka.expandByPoint(Za.min),Ka.expandByPoint(Za.max))}Ka.getCenter(n);let a=0;for(let t=0,i=e.count;t<i;t++)Ja.fromBufferAttribute(e,t),a=Math.max(a,n.distanceToSquared(Ja));if(t)for(let i=0,r=t.length;i<r;i++){const r=t[i],s=this.morphTargetsRelative;for(let t=0,i=r.count;t<i;t++)Ja.fromBufferAttribute(r,t),s&&(Qa.fromBufferAttribute(e,t),Ja.add(Qa)),a=Math.max(a,n.distanceToSquared(Ja))}this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&Ct('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv)return void Ct("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.position,a=t.normal,i=t.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Wa(new Float32Array(4*n.count),4));const r=this.getAttribute("tangent"),s=[],o=[];for(let e=0;e<n.count;e++)s[e]=new Gt,o[e]=new Gt;const l=new Gt,c=new Gt,h=new Gt,d=new Vt,u=new Vt,p=new Vt,m=new Gt,f=new Gt;function g(e,t,a){l.fromBufferAttribute(n,e),c.fromBufferAttribute(n,t),h.fromBufferAttribute(n,a),d.fromBufferAttribute(i,e),u.fromBufferAttribute(i,t),p.fromBufferAttribute(i,a),c.sub(l),h.sub(l),u.sub(d),p.sub(d);const r=1/(u.x*p.y-p.x*u.y);isFinite(r)&&(m.copy(c).multiplyScalar(p.y).addScaledVector(h,-u.y).multiplyScalar(r),f.copy(h).multiplyScalar(u.x).addScaledVector(c,-p.x).multiplyScalar(r),s[e].add(m),s[t].add(m),s[a].add(m),o[e].add(f),o[t].add(f),o[a].add(f))}let y=this.groups;0===y.length&&(y=[{start:0,count:e.count}]);for(let t=0,n=y.length;t<n;++t){const n=y[t],a=n.start;for(let t=a,i=a+n.count;t<i;t+=3)g(e.getX(t+0),e.getX(t+1),e.getX(t+2))}const v=new Gt,b=new Gt,w=new Gt,x=new Gt;function S(e){w.fromBufferAttribute(a,e),x.copy(w);const t=s[e];v.copy(t),v.sub(w.multiplyScalar(w.dot(t))).normalize(),b.crossVectors(x,t);const n=b.dot(o[e])<0?-1:1;r.setXYZW(e,v.x,v.y,v.z,n)}for(let t=0,n=y.length;t<n;++t){const n=y[t],a=n.start;for(let t=a,i=a+n.count;t<i;t+=3)S(e.getX(t+0)),S(e.getX(t+1)),S(e.getX(t+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new Wa(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const a=new Gt,i=new Gt,r=new Gt,s=new Gt,o=new Gt,l=new Gt,c=new Gt,h=new Gt;if(e)for(let d=0,u=e.count;d<u;d+=3){const u=e.getX(d+0),p=e.getX(d+1),m=e.getX(d+2);a.fromBufferAttribute(t,u),i.fromBufferAttribute(t,p),r.fromBufferAttribute(t,m),c.subVectors(r,i),h.subVectors(a,i),c.cross(h),s.fromBufferAttribute(n,u),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,m),s.add(c),o.add(c),l.add(c),n.setXYZ(u,s.x,s.y,s.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(m,l.x,l.y,l.z)}else for(let e=0,s=t.count;e<s;e+=3)a.fromBufferAttribute(t,e+0),i.fromBufferAttribute(t,e+1),r.fromBufferAttribute(t,e+2),c.subVectors(r,i),h.subVectors(a,i),c.cross(h),n.setXYZ(e+0,c.x,c.y,c.z),n.setXYZ(e+1,c.x,c.y,c.z),n.setXYZ(e+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Ja.fromBufferAttribute(e,t),Ja.normalize(),e.setXYZ(t,Ja.x,Ja.y,Ja.z)}toNonIndexed(){function e(e,t){const n=e.array,a=e.itemSize,i=e.normalized,r=new n.constructor(t.length*a);let s=0,o=0;for(let i=0,l=t.length;i<l;i++){s=e.isInterleavedBufferAttribute?t[i]*e.data.stride+e.offset:t[i]*a;for(let e=0;e<a;e++)r[o++]=n[s++]}return new Wa(r,a,i)}if(null===this.index)return At("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new ei,n=this.index.array,a=this.attributes;for(const i in a){const r=e(a[i],n);t.setAttribute(i,r)}const i=this.morphAttributes;for(const a in i){const r=[],s=i[a];for(let t=0,a=s.length;t<a;t++){const a=e(s[t],n);r.push(a)}t.morphAttributes[a]=r}t.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let e=0,n=r.length;e<n;e++){const n=r[e];t.addGroup(n.start,n.count,n.materialIndex)}return t}toJSON(){const e={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const t in n){const a=n[t];e.data.attributes[t]=a.toJSON(e.data)}const a={};let i=!1;for(const t in this.morphAttributes){const n=this.morphAttributes[t],r=[];for(let t=0,a=n.length;t<a;t++){const a=n[t];r.push(a.toJSON(e.data))}r.length>0&&(a[t]=r,i=!0)}i&&(e.data.morphAttributes=a,e.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(e.data.groups=JSON.parse(JSON.stringify(r)));const s=this.boundingSphere;return null!==s&&(e.data.boundingSphere=s.toJSON()),e}clone(){return(new this.constructor).copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone());const a=e.attributes;for(const e in a){const n=a[e];this.setAttribute(e,n.clone(t))}const i=e.morphAttributes;for(const e in i){const n=[],a=i[e];for(let e=0,i=a.length;e<i;e++)n.push(a[e].clone(t));this.morphAttributes[e]=n}this.morphTargetsRelative=e.morphTargetsRelative;const r=e.groups;for(let e=0,t=r.length;e<t;e++){const t=r[e];this.addGroup(t.start,t.count,t.materialIndex)}const s=e.boundingBox;null!==s&&(this.boundingBox=s.clone());const o=e.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const ti=new Vn,ni=new Nn,ai=new En,ii=new Gt,ri=new Gt,si=new Gt,oi=new Gt,li=new Gt,ci=new Gt,hi=new Gt,di=new Gt;class ui extends pa{constructor(e=new ei,t=new Fa){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){const t=n[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}getVertexPosition(e,t){const n=this.geometry,a=n.attributes.position,i=n.morphAttributes.position,r=n.morphTargetsRelative;t.fromBufferAttribute(a,e);const s=this.morphTargetInfluences;if(i&&s){ci.set(0,0,0);for(let n=0,a=i.length;n<a;n++){const a=s[n],o=i[n];0!==a&&(li.fromBufferAttribute(o,e),r?ci.addScaledVector(li,a):ci.addScaledVector(li.sub(t),a))}t.add(ci)}return t}raycast(e,t){const n=this.geometry,a=this.material,i=this.matrixWorld;if(void 0!==a){if(null===n.boundingSphere&&n.computeBoundingSphere(),ai.copy(n.boundingSphere),ai.applyMatrix4(i),ni.copy(e.ray).recast(e.near),!1===ai.containsPoint(ni.origin)){if(null===ni.intersectSphere(ai,ii))return;if(ni.origin.distanceToSquared(ii)>(e.far-e.near)**2)return}ti.copy(i).invert(),ni.copy(e.ray).applyMatrix4(ti),null!==n.boundingBox&&!1===ni.intersectsBox(n.boundingBox)||this._computeIntersections(e,t,ni)}}_computeIntersections(e,t,n){let a;const i=this.geometry,r=this.material,s=i.index,o=i.attributes.position,l=i.attributes.uv,c=i.attributes.uv1,h=i.attributes.normal,d=i.groups,u=i.drawRange;if(null!==s)if(Array.isArray(r))for(let i=0,o=d.length;i<o;i++){const o=d[i],p=r[o.materialIndex];for(let i=Math.max(o.start,u.start),r=Math.min(s.count,Math.min(o.start+o.count,u.start+u.count));i<r;i+=3)a=pi(this,p,e,n,l,c,h,s.getX(i),s.getX(i+1),s.getX(i+2)),a&&(a.faceIndex=Math.floor(i/3),a.face.materialIndex=o.materialIndex,t.push(a))}else for(let i=Math.max(0,u.start),o=Math.min(s.count,u.start+u.count);i<o;i+=3)a=pi(this,r,e,n,l,c,h,s.getX(i),s.getX(i+1),s.getX(i+2)),a&&(a.faceIndex=Math.floor(i/3),t.push(a));else if(void 0!==o)if(Array.isArray(r))for(let i=0,s=d.length;i<s;i++){const s=d[i],p=r[s.materialIndex];for(let i=Math.max(s.start,u.start),r=Math.min(o.count,Math.min(s.start+s.count,u.start+u.count));i<r;i+=3)a=pi(this,p,e,n,l,c,h,i,i+1,i+2),a&&(a.faceIndex=Math.floor(i/3),a.face.materialIndex=s.materialIndex,t.push(a))}else for(let i=Math.max(0,u.start),s=Math.min(o.count,u.start+u.count);i<s;i+=3)a=pi(this,r,e,n,l,c,h,i,i+1,i+2),a&&(a.faceIndex=Math.floor(i/3),t.push(a))}}function pi(e,t,n,a,i,r,s,o,l,c){e.getVertexPosition(o,ri),e.getVertexPosition(l,si),e.getVertexPosition(c,oi);const h=function(e,t,n,a,i,r,s,o){let l;if(l=1===t.side?a.intersectTriangle(s,r,i,!0,o):a.intersectTriangle(i,r,s,0===t.side,o),null===l)return null;di.copy(o),di.applyMatrix4(e.matrixWorld);const c=n.ray.origin.distanceTo(di);return c<n.near||c>n.far?null:{distance:c,point:di.clone(),object:e}}(e,t,n,a,ri,si,oi,hi);if(h){const e=new Gt;Ta.getBarycoord(hi,ri,si,oi,e),i&&(h.uv=Ta.getInterpolatedAttribute(i,o,l,c,e,new Vt)),r&&(h.uv1=Ta.getInterpolatedAttribute(r,o,l,c,e,new Vt)),s&&(h.normal=Ta.getInterpolatedAttribute(s,o,l,c,e,new Gt),h.normal.dot(a.direction)>0&&h.normal.multiplyScalar(-1));const t={a:o,b:l,c:c,normal:new Gt,materialIndex:0};Ta.getNormal(ri,si,oi,t.normal),h.face=t,h.barycoord=e}return h}class mi extends ei{constructor(e=1,t=1,n=1,a=1,i=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:a,heightSegments:i,depthSegments:r};const s=this;a=Math.floor(a),i=Math.floor(i),r=Math.floor(r);const o=[],l=[],c=[],h=[];let d=0,u=0;function p(e,t,n,a,i,r,p,m,f,g,y){const v=r/f,b=p/g,w=r/2,x=p/2,S=m/2,M=f+1,_=g+1;let A=0,C=0;const T=new Gt;for(let r=0;r<_;r++){const s=r*b-x;for(let o=0;o<M;o++){const d=o*v-w;T[e]=d*a,T[t]=s*i,T[n]=S,l.push(T.x,T.y,T.z),T[e]=0,T[t]=0,T[n]=m>0?1:-1,c.push(T.x,T.y,T.z),h.push(o/f),h.push(1-r/g),A+=1}}for(let e=0;e<g;e++)for(let t=0;t<f;t++){const n=d+t+M*e,a=d+t+M*(e+1),i=d+(t+1)+M*(e+1),r=d+(t+1)+M*e;o.push(n,a,r),o.push(a,i,r),C+=6}s.addGroup(u,C,y),u+=C,d+=A}p("z","y","x",-1,-1,n,t,e,r,i,0),p("z","y","x",1,-1,n,t,-e,r,i,1),p("x","z","y",1,1,e,n,t,a,r,2),p("x","z","y",1,-1,e,n,-t,a,r,3),p("x","y","z",1,-1,e,t,n,a,i,4),p("x","y","z",-1,-1,e,t,-n,a,i,5),this.setIndex(o),this.setAttribute("position",new ja(l,3)),this.setAttribute("normal",new ja(c,3)),this.setAttribute("uv",new ja(h,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new mi(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function fi(e){const t={};for(const n in e){t[n]={};for(const a in e[n]){const i=e[n][a];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(At("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[n][a]=null):t[n][a]=i.clone():Array.isArray(i)?t[n][a]=i.slice():t[n][a]=i}}return t}function gi(e){const t={};for(let n=0;n<e.length;n++){const a=fi(e[n]);for(const e in a)t[e]=a[e]}return t}function yi(e){const t=e.getRenderTarget();return null===t?e.outputColorSpace:!0===t.isXRRenderTarget?t.texture.colorSpace:Qt.workingColorSpace}const vi={clone:fi,merge:gi};class bi extends za{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=fi(e.uniforms),this.uniformsGroups=function(e){const t=[];for(let n=0;n<e.length;n++)t.push(e[n].clone());return t}(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const a=this.uniforms[n].value;a&&a.isTexture?t.uniforms[n]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[n]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[n]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[n]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[n]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[n]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[n]={type:"m4",value:a.toArray()}:t.uniforms[n]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const n={};for(const e in this.extensions)!0===this.extensions[e]&&(n[e]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class wi extends pa{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Vn,this.projectionMatrix=new Vn,this.projectionMatrixInverse=new Vn,this.coordinateSystem=vt,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}const xi=new Gt,Si=new Vt,Mi=new Vt;class _i extends wi{constructor(e=50,t=1,n=.1,a=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=a,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*It*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*Et*this.fov);return.5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*It*Math.atan(Math.tan(.5*Et*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,n){xi.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(xi.x,xi.y).multiplyScalar(-e/xi.z),xi.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(xi.x,xi.y).multiplyScalar(-e/xi.z)}getViewSize(e,t){return this.getViewBounds(e,Si,Mi),t.subVectors(Mi,Si)}setViewOffset(e,t,n,a,i,r){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=a,this.view.width=i,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*Et*this.fov)/this.zoom,n=2*t,a=this.aspect*n,i=-.5*a;const r=this.view;if(null!==this.view&&this.view.enabled){const e=r.fullWidth,s=r.fullHeight;i+=r.offsetX*a/e,t-=r.offsetY*n/s,a*=r.width/e,n*=r.height/s}const s=this.filmOffset;0!==s&&(i+=e*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+a,t,t-n,e,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Ai=-90;class Ci extends pa{constructor(e,t,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const a=new _i(Ai,1,e,t);a.layers=this.layers,this.add(a);const i=new _i(Ai,1,e,t);i.layers=this.layers,this.add(i);const r=new _i(Ai,1,e,t);r.layers=this.layers,this.add(r);const s=new _i(Ai,1,e,t);s.layers=this.layers,this.add(s);const o=new _i(Ai,1,e,t);o.layers=this.layers,this.add(o);const l=new _i(Ai,1,e,t);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[n,a,i,r,s,o]=t;for(const e of t)this.remove(e);if(e===vt)n.up.set(0,1,0),n.lookAt(1,0,0),a.up.set(0,1,0),a.lookAt(-1,0,0),i.up.set(0,0,-1),i.lookAt(0,1,0),r.up.set(0,0,1),r.lookAt(0,-1,0),s.up.set(0,1,0),s.lookAt(0,0,1),o.up.set(0,1,0),o.lookAt(0,0,-1);else{if(e!==bt)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);n.up.set(0,-1,0),n.lookAt(-1,0,0),a.up.set(0,-1,0),a.lookAt(1,0,0),i.up.set(0,0,1),i.lookAt(0,1,0),r.up.set(0,0,-1),r.lookAt(0,-1,0),s.up.set(0,-1,0),s.lookAt(0,0,1),o.up.set(0,-1,0),o.lookAt(0,0,-1)}for(const e of t)this.add(e),e.updateMatrixWorld()}update(e,t){null===this.parent&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:a}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[i,r,s,o,l,c]=this.children,h=e.getRenderTarget(),d=e.getActiveCubeFace(),u=e.getActiveMipmapLevel(),p=e.xr.enabled;e.xr.enabled=!1;const m=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0,a),e.render(t,i),e.setRenderTarget(n,1,a),e.render(t,r),e.setRenderTarget(n,2,a),e.render(t,s),e.setRenderTarget(n,3,a),e.render(t,o),e.setRenderTarget(n,4,a),e.render(t,l),n.texture.generateMipmaps=m,e.setRenderTarget(n,5,a),e.render(t,c),e.setRenderTarget(h,d,u),e.xr.enabled=p,n.texture.needsPMREMUpdate=!0}}class Ti extends on{constructor(e=[],t=301,n,a,i,r,s,o,l,c){super(e,t,n,a,i,r,s,o,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class Pi extends hn{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},a=[n,n,n,n,n,n];this.texture=new Ti(a),this._setTextureOptions(t),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={tEquirect:{value:null}},a="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",i="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",r=new mi(5,5,5),s=new bi({name:"CubemapFromEquirect",uniforms:fi(n),vertexShader:a,fragmentShader:i,side:1,blending:0});s.uniforms.tEquirect.value=t;const o=new ui(r,s),l=t.minFilter;return t.minFilter===X&&(t.minFilter=H),new Ci(1,10,this).update(e,o),t.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(e,t=!0,n=!0,a=!0){const i=e.getRenderTarget();for(let i=0;i<6;i++)e.setRenderTarget(this,i),e.clear(t,n,a);e.setRenderTarget(i)}}class Di extends pa{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Oi={type:"move"};class Ei{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new Di,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new Di,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Gt,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Gt),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new Di,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Gt,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Gt),this._grip}dispatchEvent(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const n of e.hand.values())this._getHandJoint(t,n)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(e,t,n){let a=null,i=null,r=null;const s=this._targetRay,o=this._grip,l=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState){if(l&&e.hand){r=!0;for(const a of e.hand.values()){const e=t.getJointPose(a,n),i=this._getHandJoint(l,a);null!==e&&(i.matrix.fromArray(e.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.matrixWorldNeedsUpdate=!0,i.jointRadius=e.radius),i.visible=null!==e}const a=l.joints["index-finger-tip"],i=l.joints["thumb-tip"],s=a.position.distanceTo(i.position),o=.02,c=.005;l.inputState.pinching&&s>o+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&s<=o-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==o&&e.gripSpace&&(i=t.getPose(e.gripSpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1));null!==s&&(a=t.getPose(e.targetRaySpace,n),null===a&&null!==i&&(a=i),null!==a&&(s.matrix.fromArray(a.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),s.matrixWorldNeedsUpdate=!0,a.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(a.linearVelocity)):s.hasLinearVelocity=!1,a.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(a.angularVelocity)):s.hasAngularVelocity=!1,this.dispatchEvent(Oi)))}return null!==s&&(s.visible=null!==a),null!==o&&(o.visible=null!==i),null!==l&&(l.visible=null!==r),this}_getHandJoint(e,t){if(void 0===e.joints[t.jointName]){const n=new Di;n.matrixAutoUpdate=!1,n.visible=!1,e.joints[t.jointName]=n,e.add(n)}return e.joints[t.jointName]}}class Ii extends pa{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Qn,this.environmentIntensity=1,this.environmentRotation=new Qn,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return null!==this.fog&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}class ki{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=ft,this.updateRanges=[],this.version=0,this.uuid=kt()}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let a=0,i=this.stride;a<i;a++)this.array[e+a]=t.array[n+a];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=kt()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=kt()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Ri=new Gt;class zi{constructor(e,t,n,a=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=a}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Ri.fromBufferAttribute(this,t),Ri.applyMatrix4(e),this.setXYZ(t,Ri.x,Ri.y,Ri.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Ri.fromBufferAttribute(this,t),Ri.applyNormalMatrix(e),this.setXYZ(t,Ri.x,Ri.y,Ri.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Ri.fromBufferAttribute(this,t),Ri.transformDirection(e),this.setXYZ(t,Ri.x,Ri.y,Ri.z);return this}getComponent(e,t){let n=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(n=Bt(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=Lt(n,this.array)),this.data.array[e*this.data.stride+this.offset+t]=n,this}setX(e,t){return this.normalized&&(t=Lt(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Lt(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Lt(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Lt(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Bt(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Bt(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Bt(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Bt(t,this.array)),t}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=Lt(t,this.array),n=Lt(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,a){return e=e*this.data.stride+this.offset,this.normalized&&(t=Lt(t,this.array),n=Lt(n,this.array),a=Lt(a,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=a,this}setXYZW(e,t,n,a,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Lt(t,this.array),n=Lt(n,this.array),a=Lt(a,this.array),i=Lt(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=a,this.data.array[e+3]=i,this}clone(e){if(void 0===e){_t("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return new Wa(new this.array.constructor(e),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new zi(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(void 0===e){_t("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class Fi extends za{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Ia(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let Bi;const Li=new Gt,Ni=new Gt,Vi=new Gt,Ui=new Vt,Gi=new Vt,Wi=new Vn,qi=new Gt,Hi=new Gt,ji=new Gt,Xi=new Vt,Yi=new Vt,$i=new Vt;class Qi extends pa{constructor(e=new Fi){if(super(),this.isSprite=!0,this.type="Sprite",void 0===Bi){Bi=new ei;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new ki(e,5);Bi.setIndex([0,1,2,0,2,3]),Bi.setAttribute("position",new zi(t,3,0,!1)),Bi.setAttribute("uv",new zi(t,2,3,!1))}this.geometry=Bi,this.material=e,this.center=new Vt(.5,.5),this.count=1}raycast(e,t){null===e.camera&&Ct('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ni.setFromMatrixScale(this.matrixWorld),Wi.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Vi.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Ni.multiplyScalar(-Vi.z);const n=this.material.rotation;let a,i;0!==n&&(i=Math.cos(n),a=Math.sin(n));const r=this.center;Ki(qi.set(-.5,-.5,0),Vi,r,Ni,a,i),Ki(Hi.set(.5,-.5,0),Vi,r,Ni,a,i),Ki(ji.set(.5,.5,0),Vi,r,Ni,a,i),Xi.set(0,0),Yi.set(1,0),$i.set(1,1);let s=e.ray.intersectTriangle(qi,Hi,ji,!1,Li);if(null===s&&(Ki(Hi.set(-.5,.5,0),Vi,r,Ni,a,i),Yi.set(0,1),s=e.ray.intersectTriangle(qi,ji,Hi,!1,Li),null===s))return;const o=e.ray.origin.distanceTo(Li);o<e.near||o>e.far||t.push({distance:o,point:Li.clone(),uv:Ta.getInterpolation(Li,qi,Hi,ji,Xi,Yi,$i,new Vt),face:null,object:this})}copy(e,t){return super.copy(e,t),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}}function Ki(e,t,n,a,i,r){Ui.subVectors(e,n).addScalar(.5).multiply(a),void 0!==i?(Gi.x=r*Ui.x-i*Ui.y,Gi.y=i*Ui.x+r*Ui.y):Gi.copy(Ui),e.copy(t),e.x+=Gi.x,e.y+=Gi.y,e.applyMatrix4(Wi)}const Zi=new Gt,Ji=new ln,er=new ln,tr=new Gt,nr=new Vn,ar=new Gt,ir=new En,rr=new Vn,sr=new Nn;class or extends ui{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=I,this.bindMatrix=new Vn,this.bindMatrixInverse=new Vn,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;null===this.boundingBox&&(this.boundingBox=new pn),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let e=0;e<t.count;e++)this.getVertexPosition(e,ar),this.boundingBox.expandByPoint(ar)}computeBoundingSphere(){const e=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new En),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let e=0;e<t.count;e++)this.getVertexPosition(e,ar),this.boundingSphere.expandByPoint(ar)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const n=this.material,a=this.matrixWorld;void 0!==n&&(null===this.boundingSphere&&this.computeBoundingSphere(),ir.copy(this.boundingSphere),ir.applyMatrix4(a),!1!==e.ray.intersectsSphere(ir)&&(rr.copy(a).invert(),sr.copy(e.ray).applyMatrix4(rr),null!==this.boundingBox&&!1===sr.intersectsBox(this.boundingBox)||this._computeIntersections(e,t,sr)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new ln,t=this.geometry.attributes.skinWeight;for(let n=0,a=t.count;n<a;n++){e.fromBufferAttribute(t,n);const a=1/e.manhattanLength();a!==1/0?e.multiplyScalar(a):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===I?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===k?this.bindMatrixInverse.copy(this.bindMatrix).invert():At("SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const n=this.skeleton,a=this.geometry;Ji.fromBufferAttribute(a.attributes.skinIndex,e),er.fromBufferAttribute(a.attributes.skinWeight,e),Zi.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let e=0;e<4;e++){const a=er.getComponent(e);if(0!==a){const i=Ji.getComponent(e);nr.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]),t.addScaledVector(tr.copy(Zi).applyMatrix4(nr),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}class lr extends pa{constructor(){super(),this.isBone=!0,this.type="Bone"}}class cr extends on{constructor(e=null,t=1,n=1,a,i,r,s,o,l=1003,c=1003,h,d){super(null,r,s,o,l,c,a,i,h,d),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const hr=new Vn,dr=new Vn;class ur{constructor(e=[],t=[]){this.uuid=kt(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){At("Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Vn)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const t=new Vn;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,a=this.boneTexture;for(let a=0,i=e.length;a<i;a++){const i=e[a]?e[a].matrixWorld:dr;hr.multiplyMatrices(i,t[a]),hr.toArray(n,16*a)}null!==a&&(a.needsUpdate=!0)}clone(){return new ur(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=4*Math.ceil(e/4),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new cr(t,e,e,ce,ee);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const n=this.bones[t];if(n.name===e)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,a=e.bones.length;n<a;n++){const a=e.bones[n];let i=t[a];void 0===i&&(At("Skeleton: No bone found with UUID:",a),i=new lr),this.bones.push(i),this.boneInverses.push((new Vn).fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let a=0,i=t.length;a<i;a++){const i=t[a];e.bones.push(i.uuid);const r=n[a];e.boneInverses.push(r.toArray())}return e}}class pr extends Wa{constructor(e,t,n,a=1){super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=a}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const mr=new Vn,fr=new Vn,gr=[],yr=new pn,vr=new Vn,br=new ui,wr=new En;class xr extends ui{constructor(e,t,n){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new pr(new Float32Array(16*n),16),this.instanceColor=null,this.morphTexture=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let e=0;e<n;e++)this.setMatrixAt(e,vr)}computeBoundingBox(){const e=this.geometry,t=this.count;null===this.boundingBox&&(this.boundingBox=new pn),null===e.boundingBox&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,mr),yr.copy(e.boundingBox).applyMatrix4(mr),this.boundingBox.union(yr)}computeBoundingSphere(){const e=this.geometry,t=this.count;null===this.boundingSphere&&(this.boundingSphere=new En),null===e.boundingSphere&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,mr),wr.copy(e.boundingSphere).applyMatrix4(mr),this.boundingSphere.union(wr)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),null!==e.morphTexture&&(this.morphTexture=e.morphTexture.clone()),null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}getMorphAt(e,t){const n=t.morphTargetInfluences,a=this.morphTexture.source.data.data,i=e*(n.length+1)+1;for(let e=0;e<n.length;e++)n[e]=a[i+e]}raycast(e,t){const n=this.matrixWorld,a=this.count;if(br.geometry=this.geometry,br.material=this.material,void 0!==br.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),wr.copy(this.boundingSphere),wr.applyMatrix4(n),!1!==e.ray.intersectsSphere(wr)))for(let i=0;i<a;i++){this.getMatrixAt(i,mr),fr.multiplyMatrices(n,mr),br.matrixWorld=fr,br.raycast(e,gr);for(let e=0,n=gr.length;e<n;e++){const n=gr[e];n.instanceId=i,n.object=this,t.push(n)}gr.length=0}}setColorAt(e,t){null===this.instanceColor&&(this.instanceColor=new pr(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}setMorphAt(e,t){const n=t.morphTargetInfluences,a=n.length+1;null===this.morphTexture&&(this.morphTexture=new cr(new Float32Array(a*this.count),a,this.count,ue,ee));const i=this.morphTexture.source.data.data;let r=0;for(let e=0;e<n.length;e++)r+=n[e];const s=this.geometry.morphTargetsRelative?1:1-r,o=a*e;i[o]=s,i.set(n,o+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null)}}const Sr=new Gt,Mr=new Gt,_r=new Ht;class Ar{constructor(e=new Gt(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,a){return this.normal.set(e,t,n),this.constant=a,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const a=Sr.subVectors(n,t).cross(Mr.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(a,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const n=e.delta(Sr),a=this.normal.dot(n);if(0===a)return 0===this.distanceToPoint(e.start)?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/a;return i<0||i>1?null:t.copy(e.start).addScaledVector(n,i)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||_r.getNormalMatrix(e),a=this.coplanarPoint(Sr).applyMatrix4(e),i=this.normal.applyMatrix3(n).normalize();return this.constant=-a.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const Cr=new En,Tr=new Vt(.5,.5),Pr=new Gt;class Dr{constructor(e=new Ar,t=new Ar,n=new Ar,a=new Ar,i=new Ar,r=new Ar){this.planes=[e,t,n,a,i,r]}set(e,t,n,a,i,r){const s=this.planes;return s[0].copy(e),s[1].copy(t),s[2].copy(n),s[3].copy(a),s[4].copy(i),s[5].copy(r),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e,t=2e3,n=!1){const a=this.planes,i=e.elements,r=i[0],s=i[1],o=i[2],l=i[3],c=i[4],h=i[5],d=i[6],u=i[7],p=i[8],m=i[9],f=i[10],g=i[11],y=i[12],v=i[13],b=i[14],w=i[15];if(a[0].setComponents(l-r,u-c,g-p,w-y).normalize(),a[1].setComponents(l+r,u+c,g+p,w+y).normalize(),a[2].setComponents(l+s,u+h,g+m,w+v).normalize(),a[3].setComponents(l-s,u-h,g-m,w-v).normalize(),n)a[4].setComponents(o,d,f,b).normalize(),a[5].setComponents(l-o,u-d,g-f,w-b).normalize();else if(a[4].setComponents(l-o,u-d,g-f,w-b).normalize(),t===vt)a[5].setComponents(l+o,u+d,g+f,w+b).normalize();else{if(t!==bt)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);a[5].setComponents(o,d,f,b).normalize()}return this}intersectsObject(e){if(void 0!==e.boundingSphere)null===e.boundingSphere&&e.computeBoundingSphere(),Cr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;null===t.boundingSphere&&t.computeBoundingSphere(),Cr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Cr)}intersectsSprite(e){Cr.center.set(0,0,0);const t=Tr.distanceTo(e.center);return Cr.radius=.7071067811865476+t,Cr.applyMatrix4(e.matrixWorld),this.intersectsSphere(Cr)}intersectsSphere(e){const t=this.planes,n=e.center,a=-e.radius;for(let e=0;e<6;e++)if(t[e].distanceToPoint(n)<a)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const a=t[n];if(Pr.x=a.normal.x>0?e.max.x:e.min.x,Pr.y=a.normal.y>0?e.max.y:e.min.y,Pr.z=a.normal.z>0?e.max.z:e.min.z,a.distanceToPoint(Pr)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}class Or extends za{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Ia(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const Er=new Gt,Ir=new Gt,kr=new Vn,Rr=new Nn,zr=new En,Fr=new Gt,Br=new Gt;class Lr extends pa{constructor(e=new ei,t=new Or){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(null===e.index){const t=e.attributes.position,n=[0];for(let e=1,a=t.count;e<a;e++)Er.fromBufferAttribute(t,e-1),Ir.fromBufferAttribute(t,e),n[e]=n[e-1],n[e]+=Er.distanceTo(Ir);e.setAttribute("lineDistance",new ja(n,1))}else At("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,a=this.matrixWorld,i=e.params.Line.threshold,r=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),zr.copy(n.boundingSphere),zr.applyMatrix4(a),zr.radius+=i,!1===e.ray.intersectsSphere(zr))return;kr.copy(a).invert(),Rr.copy(e.ray).applyMatrix4(kr);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,l=this.isLineSegments?2:1,c=n.index,h=n.attributes.position;if(null!==c){const n=Math.max(0,r.start),a=Math.min(c.count,r.start+r.count);for(let i=n,r=a-1;i<r;i+=l){const n=c.getX(i),a=c.getX(i+1),r=Nr(this,e,Rr,o,n,a,i);r&&t.push(r)}if(this.isLineLoop){const i=c.getX(a-1),r=c.getX(n),s=Nr(this,e,Rr,o,i,r,a-1);s&&t.push(s)}}else{const n=Math.max(0,r.start),a=Math.min(h.count,r.start+r.count);for(let i=n,r=a-1;i<r;i+=l){const n=Nr(this,e,Rr,o,i,i+1,i);n&&t.push(n)}if(this.isLineLoop){const i=Nr(this,e,Rr,o,a-1,n,a-1);i&&t.push(i)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){const t=n[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}}function Nr(e,t,n,a,i,r,s){const o=e.geometry.attributes.position;if(Er.fromBufferAttribute(o,i),Ir.fromBufferAttribute(o,r),n.distanceSqToSegment(Er,Ir,Fr,Br)>a)return;Fr.applyMatrix4(e.matrixWorld);const l=t.ray.origin.distanceTo(Fr);return l<t.near||l>t.far?void 0:{distance:l,point:Br.clone().applyMatrix4(e.matrixWorld),index:s,face:null,faceIndex:null,barycoord:null,object:e}}const Vr=new Gt,Ur=new Gt;class Gr extends Lr{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(null===e.index){const t=e.attributes.position,n=[];for(let e=0,a=t.count;e<a;e+=2)Vr.fromBufferAttribute(t,e),Ur.fromBufferAttribute(t,e+1),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+Vr.distanceTo(Ur);e.setAttribute("lineDistance",new ja(n,1))}else At("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Wr extends Lr{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class qr extends za{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Ia(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const Hr=new Vn,jr=new Nn,Xr=new En,Yr=new Gt;class $r extends pa{constructor(e=new ei,t=new qr){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,a=this.matrixWorld,i=e.params.Points.threshold,r=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Xr.copy(n.boundingSphere),Xr.applyMatrix4(a),Xr.radius+=i,!1===e.ray.intersectsSphere(Xr))return;Hr.copy(a).invert(),jr.copy(e.ray).applyMatrix4(Hr);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,l=n.index,c=n.attributes.position;if(null!==l)for(let n=Math.max(0,r.start),i=Math.min(l.count,r.start+r.count);n<i;n++){const i=l.getX(n);Yr.fromBufferAttribute(c,i),Qr(Yr,i,o,a,e,t,this)}else for(let n=Math.max(0,r.start),i=Math.min(c.count,r.start+r.count);n<i;n++)Yr.fromBufferAttribute(c,n),Qr(Yr,n,o,a,e,t,this)}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){const t=n[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}}function Qr(e,t,n,a,i,r,s){const o=jr.distanceSqToPoint(e);if(o<n){const n=new Gt;jr.closestPointToPoint(e,n),n.applyMatrix4(a);const l=i.ray.origin.distanceTo(n);if(l<i.near||l>i.far)return;r.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:t,face:null,faceIndex:null,barycoord:null,object:s})}}class Kr extends on{constructor(e,t,n,a,i,r,s,o,l){super(e,t,n,a,i,r,s,o,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Zr extends on{constructor(e,t,n=1014,a,i,r,s=1003,o=1003,l,c=1026,h=1){if(c!==he&&c!==de)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");super({width:e,height:t,depth:h},a,i,r,s,o,c,n,l),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new nn(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return null!==this.compareFunction&&(t.compareFunction=this.compareFunction),t}}class Jr extends on{constructor(e=null){super(),this.sourceTexture=e,this.isExternalTexture=!0}copy(e){return super.copy(e),this.sourceTexture=e.sourceTexture,this}}class es extends ei{constructor(e=1,t=32,n=0,a=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:a},t=Math.max(3,t);const i=[],r=[],s=[],o=[],l=new Gt,c=new Vt;r.push(0,0,0),s.push(0,0,1),o.push(.5,.5);for(let i=0,h=3;i<=t;i++,h+=3){const d=n+i/t*a;l.x=e*Math.cos(d),l.y=e*Math.sin(d),r.push(l.x,l.y,l.z),s.push(0,0,1),c.x=(r[h]/e+1)/2,c.y=(r[h+1]/e+1)/2,o.push(c.x,c.y)}for(let e=1;e<=t;e++)i.push(e,e+1,0);this.setIndex(i),this.setAttribute("position",new ja(r,3)),this.setAttribute("normal",new ja(s,3)),this.setAttribute("uv",new ja(o,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new es(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class ts extends ei{constructor(e=[],t=[],n=1,a=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:a};const i=[],r=[];function s(e,t,n,a){const i=a+1,r=[];for(let a=0;a<=i;a++){r[a]=[];const s=e.clone().lerp(n,a/i),o=t.clone().lerp(n,a/i),l=i-a;for(let e=0;e<=l;e++)r[a][e]=0===e&&a===i?s:s.clone().lerp(o,e/l)}for(let e=0;e<i;e++)for(let t=0;t<2*(i-e)-1;t++){const n=Math.floor(t/2);t%2==0?(o(r[e][n+1]),o(r[e+1][n]),o(r[e][n])):(o(r[e][n+1]),o(r[e+1][n+1]),o(r[e+1][n]))}}function o(e){i.push(e.x,e.y,e.z)}function l(t,n){const a=3*t;n.x=e[a+0],n.y=e[a+1],n.z=e[a+2]}function c(e,t,n,a){a<0&&1===e.x&&(r[t]=e.x-1),0===n.x&&0===n.z&&(r[t]=a/2/Math.PI+.5)}function h(e){return Math.atan2(e.z,-e.x)}function d(e){return Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))}!function(e){const n=new Gt,a=new Gt,i=new Gt;for(let r=0;r<t.length;r+=3)l(t[r+0],n),l(t[r+1],a),l(t[r+2],i),s(n,a,i,e)}(a),function(e){const t=new Gt;for(let n=0;n<i.length;n+=3)t.x=i[n+0],t.y=i[n+1],t.z=i[n+2],t.normalize().multiplyScalar(e),i[n+0]=t.x,i[n+1]=t.y,i[n+2]=t.z}(n),function(){const e=new Gt;for(let t=0;t<i.length;t+=3){e.x=i[t+0],e.y=i[t+1],e.z=i[t+2];const n=h(e)/2/Math.PI+.5,a=d(e)/Math.PI+.5;r.push(n,1-a)}(function(){const e=new Gt,t=new Gt,n=new Gt,a=new Gt,s=new Vt,o=new Vt,l=new Vt;for(let d=0,u=0;d<i.length;d+=9,u+=6){e.set(i[d+0],i[d+1],i[d+2]),t.set(i[d+3],i[d+4],i[d+5]),n.set(i[d+6],i[d+7],i[d+8]),s.set(r[u+0],r[u+1]),o.set(r[u+2],r[u+3]),l.set(r[u+4],r[u+5]),a.copy(e).add(t).add(n).divideScalar(3);const p=h(a);c(s,u+0,e,p),c(o,u+2,t,p),c(l,u+4,n,p)}})(),function(){for(let e=0;e<r.length;e+=6){const t=r[e+0],n=r[e+2],a=r[e+4],i=Math.max(t,n,a),s=Math.min(t,n,a);i>.9&&s<.1&&(t<.2&&(r[e+0]+=1),n<.2&&(r[e+2]+=1),a<.2&&(r[e+4]+=1))}}()}(),this.setAttribute("position",new ja(i,3)),this.setAttribute("normal",new ja(i.slice(),3)),this.setAttribute("uv",new ja(r,2)),0===a?this.computeVertexNormals():this.normalizeNormals()}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ts(e.vertices,e.indices,e.radius,e.details)}}class ns extends ts{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,a=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-a,-n,0,-a,n,0,a,-n,0,a,n,-a,-n,0,-a,n,0,a,-n,0,a,n,0,-n,0,-a,n,0,-a,-n,0,a,n,0,a],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new ns(e.radius,e.detail)}}class as{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){At("Curve: .getPoint() not implemented.")}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,a=this.getPoint(0),i=0;t.push(0);for(let r=1;r<=e;r++)n=this.getPoint(r/e),i+=n.distanceTo(a),t.push(i),a=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t=null){const n=this.getLengths();let a=0;const i=n.length;let r;r=t||e*n[i-1];let s,o=0,l=i-1;for(;o<=l;)if(a=Math.floor(o+(l-o)/2),s=n[a]-r,s<0)o=a+1;else{if(!(s>0)){l=a;break}l=a-1}if(a=l,n[a]===r)return a/(i-1);const c=n[a];return(a+(r-c)/(n[a+1]-c))/(i-1)}getTangent(e,t){const n=1e-4;let a=e-n,i=e+n;a<0&&(a=0),i>1&&(i=1);const r=this.getPoint(a),s=this.getPoint(i),o=t||(r.isVector2?new Vt:new Gt);return o.copy(s).sub(r).normalize(),o}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t=!1){const n=new Gt,a=[],i=[],r=[],s=new Gt,o=new Vn;for(let t=0;t<=e;t++){const n=t/e;a[t]=this.getTangentAt(n,new Gt)}i[0]=new Gt,r[0]=new Gt;let l=Number.MAX_VALUE;const c=Math.abs(a[0].x),h=Math.abs(a[0].y),d=Math.abs(a[0].z);c<=l&&(l=c,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),d<=l&&n.set(0,0,1),s.crossVectors(a[0],n).normalize(),i[0].crossVectors(a[0],s),r[0].crossVectors(a[0],i[0]);for(let t=1;t<=e;t++){if(i[t]=i[t-1].clone(),r[t]=r[t-1].clone(),s.crossVectors(a[t-1],a[t]),s.length()>Number.EPSILON){s.normalize();const e=Math.acos(Rt(a[t-1].dot(a[t]),-1,1));i[t].applyMatrix4(o.makeRotationAxis(s,e))}r[t].crossVectors(a[t],i[t])}if(!0===t){let t=Math.acos(Rt(i[0].dot(i[e]),-1,1));t/=e,a[0].dot(s.crossVectors(i[0],i[e]))>0&&(t=-t);for(let n=1;n<=e;n++)i[n].applyMatrix4(o.makeRotationAxis(a[n],t*n)),r[n].crossVectors(a[n],i[n])}return{tangents:a,normals:i,binormals:r}}clone(){return(new this.constructor).copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class is extends as{constructor(e=0,t=0,n=1,a=1,i=0,r=2*Math.PI,s=!1,o=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=a,this.aStartAngle=i,this.aEndAngle=r,this.aClockwise=s,this.aRotation=o}getPoint(e,t=new Vt){const n=t,a=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const r=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=a;for(;i>a;)i-=a;i<Number.EPSILON&&(i=r?0:a),!0!==this.aClockwise||r||(i===a?i=-a:i-=a);const s=this.aStartAngle+e*i;let o=this.aX+this.xRadius*Math.cos(s),l=this.aY+this.yRadius*Math.sin(s);if(0!==this.aRotation){const e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),n=o-this.aX,a=l-this.aY;o=n*e-a*t+this.aX,l=n*t+a*e+this.aY}return n.set(o,l)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class rs extends is{constructor(e,t,n,a,i,r){super(e,t,n,n,a,i,r),this.isArcCurve=!0,this.type="ArcCurve"}}function ss(){let e=0,t=0,n=0,a=0;function i(i,r,s,o){e=i,t=s,n=-3*i+3*r-2*s-o,a=2*i-2*r+s+o}return{initCatmullRom:function(e,t,n,a,r){i(t,n,r*(n-e),r*(a-t))},initNonuniformCatmullRom:function(e,t,n,a,r,s,o){let l=(t-e)/r-(n-e)/(r+s)+(n-t)/s,c=(n-t)/s-(a-t)/(s+o)+(a-n)/o;l*=s,c*=s,i(t,n,l,c)},calc:function(i){const r=i*i;return e+t*i+n*r+a*(r*i)}}}const os=new Gt,ls=new ss,cs=new ss,hs=new ss;class ds extends as{constructor(e=[],t=!1,n="centripetal",a=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=a}getPoint(e,t=new Gt){const n=t,a=this.points,i=a.length,r=(i-(this.closed?0:1))*e;let s,o,l=Math.floor(r),c=r-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/i)+1)*i:0===c&&l===i-1&&(l=i-2,c=1),this.closed||l>0?s=a[(l-1)%i]:(os.subVectors(a[0],a[1]).add(a[0]),s=os);const h=a[l%i],d=a[(l+1)%i];if(this.closed||l+2<i?o=a[(l+2)%i]:(os.subVectors(a[i-1],a[i-2]).add(a[i-1]),o=os),"centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(s.distanceToSquared(h),e),n=Math.pow(h.distanceToSquared(d),e),a=Math.pow(d.distanceToSquared(o),e);n<1e-4&&(n=1),t<1e-4&&(t=n),a<1e-4&&(a=n),ls.initNonuniformCatmullRom(s.x,h.x,d.x,o.x,t,n,a),cs.initNonuniformCatmullRom(s.y,h.y,d.y,o.y,t,n,a),hs.initNonuniformCatmullRom(s.z,h.z,d.z,o.z,t,n,a)}else"catmullrom"===this.curveType&&(ls.initCatmullRom(s.x,h.x,d.x,o.x,this.tension),cs.initCatmullRom(s.y,h.y,d.y,o.y,this.tension),hs.initCatmullRom(s.z,h.z,d.z,o.z,this.tension));return n.set(ls.calc(c),cs.calc(c),hs.calc(c)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Gt).fromArray(n))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function us(e,t,n,a,i){const r=.5*(a-t),s=.5*(i-n),o=e*e;return(2*n-2*a+r+s)*(e*o)+(-3*n+3*a-2*r-s)*o+r*e+n}function ps(e,t,n,a){return function(e,t){const n=1-e;return n*n*t}(e,t)+function(e,t){return 2*(1-e)*e*t}(e,n)+function(e,t){return e*e*t}(e,a)}function ms(e,t,n,a,i){return function(e,t){const n=1-e;return n*n*n*t}(e,t)+function(e,t){const n=1-e;return 3*n*n*e*t}(e,n)+function(e,t){return 3*(1-e)*e*e*t}(e,a)+function(e,t){return e*e*e*t}(e,i)}class fs extends as{constructor(e=new Vt,t=new Vt,n=new Vt,a=new Vt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=a}getPoint(e,t=new Vt){const n=t,a=this.v0,i=this.v1,r=this.v2,s=this.v3;return n.set(ms(e,a.x,i.x,r.x,s.x),ms(e,a.y,i.y,r.y,s.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class gs extends as{constructor(e=new Gt,t=new Gt,n=new Gt,a=new Gt){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=a}getPoint(e,t=new Gt){const n=t,a=this.v0,i=this.v1,r=this.v2,s=this.v3;return n.set(ms(e,a.x,i.x,r.x,s.x),ms(e,a.y,i.y,r.y,s.y),ms(e,a.z,i.z,r.z,s.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class ys extends as{constructor(e=new Vt,t=new Vt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Vt){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Vt){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class vs extends as{constructor(e=new Gt,t=new Gt){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new Gt){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Gt){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class bs extends as{constructor(e=new Vt,t=new Vt,n=new Vt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Vt){const n=t,a=this.v0,i=this.v1,r=this.v2;return n.set(ps(e,a.x,i.x,r.x),ps(e,a.y,i.y,r.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class ws extends as{constructor(e=new Gt,t=new Gt,n=new Gt){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Gt){const n=t,a=this.v0,i=this.v1,r=this.v2;return n.set(ps(e,a.x,i.x,r.x),ps(e,a.y,i.y,r.y),ps(e,a.z,i.z,r.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class xs extends as{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Vt){const n=t,a=this.points,i=(a.length-1)*e,r=Math.floor(i),s=i-r,o=a[0===r?r:r-1],l=a[r],c=a[r>a.length-2?a.length-1:r+1],h=a[r>a.length-3?a.length-1:r+2];return n.set(us(s,o.x,l.x,c.x,h.x),us(s,o.y,l.y,c.y,h.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Vt).fromArray(n))}return this}}var Ss=Object.freeze({__proto__:null,ArcCurve:rs,CatmullRomCurve3:ds,CubicBezierCurve:fs,CubicBezierCurve3:gs,EllipseCurve:is,LineCurve:ys,LineCurve3:vs,QuadraticBezierCurve:bs,QuadraticBezierCurve3:ws,SplineCurve:xs});class Ms extends as{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const n=!0===e.isVector2?"LineCurve":"LineCurve3";this.curves.push(new Ss[n](t,e))}return this}getPoint(e,t){const n=e*this.getLength(),a=this.getCurveLengths();let i=0;for(;i<a.length;){if(a[i]>=n){const e=a[i]-n,r=this.curves[i],s=r.getLength(),o=0===s?0:1-e/s;return r.getPointAt(o,t)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,a=this.curves.length;n<a;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let a=0,i=this.curves;a<i.length;a++){const r=i[a],s=r.isEllipseCurve?2*e:r.isLineCurve||r.isLineCurve3?1:r.isSplineCurve?e*r.points.length:e,o=r.getPoints(s);for(let e=0;e<o.length;e++){const a=o[e];n&&n.equals(a)||(t.push(a),n=a)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push(n.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const n=this.curves[t];e.curves.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push((new Ss[n.type]).fromJSON(n))}return this}}class _s extends Ms{constructor(e){super(),this.type="Path",this.currentPoint=new Vt,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new ys(this.currentPoint.clone(),new Vt(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,a){const i=new bs(this.currentPoint.clone(),new Vt(e,t),new Vt(n,a));return this.curves.push(i),this.currentPoint.set(n,a),this}bezierCurveTo(e,t,n,a,i,r){const s=new fs(this.currentPoint.clone(),new Vt(e,t),new Vt(n,a),new Vt(i,r));return this.curves.push(s),this.currentPoint.set(i,r),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new xs(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,a,i,r){const s=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(e+s,t+o,n,a,i,r),this}absarc(e,t,n,a,i,r){return this.absellipse(e,t,n,n,a,i,r),this}ellipse(e,t,n,a,i,r,s,o){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+l,t+c,n,a,i,r,s,o),this}absellipse(e,t,n,a,i,r,s,o){const l=new is(e,t,n,a,i,r,s,o);if(this.curves.length>0){const e=l.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class As extends _s{constructor(e){super(e),this.uuid=kt(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,a=this.holes.length;n<a;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push((new _s).fromJSON(n))}return this}}function Cs(e,t,n,a,i){let r;if(i===function(e,t,n,a){let i=0;for(let r=t,s=n-a;r<n;r+=a)i+=(e[s]-e[r])*(e[r+1]+e[s+1]),s=r;return i}(e,t,n,a)>0)for(let i=t;i<n;i+=a)r=Ys(i/a|0,e[i],e[i+1],r);else for(let i=n-a;i>=t;i-=a)r=Ys(i/a|0,e[i],e[i+1],r);return r&&Gs(r,r.next)&&($s(r),r=r.next),r}function Ts(e,t){if(!e)return e;t||(t=e);let n,a=e;do{if(n=!1,a.steiner||!Gs(a,a.next)&&0!==Us(a.prev,a,a.next))a=a.next;else{if($s(a),a=t=a.prev,a===a.next)break;n=!0}}while(n||a!==t);return t}function Ps(e,t,n,a,i,r,s){if(!e)return;!s&&r&&function(e,t,n,a){let i=e;do{0===i.z&&(i.z=Fs(i.x,i.y,t,n,a)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==e);i.prevZ.nextZ=null,i.prevZ=null,function(e){let t,n=1;do{let a,i=e;e=null;let r=null;for(t=0;i;){t++;let s=i,o=0;for(let e=0;e<n&&(o++,s=s.nextZ,s);e++);let l=n;for(;o>0||l>0&&s;)0!==o&&(0===l||!s||i.z<=s.z)?(a=i,i=i.nextZ,o--):(a=s,s=s.nextZ,l--),r?r.nextZ=a:e=a,a.prevZ=r,r=a;i=s}r.nextZ=null,n*=2}while(t>1)}(i)}(e,a,i,r);let o=e;for(;e.prev!==e.next;){const l=e.prev,c=e.next;if(r?Os(e,a,i,r):Ds(e))t.push(l.i,e.i,c.i),$s(e),e=c.next,o=c.next;else if((e=c)===o){s?1===s?Ps(e=Es(Ts(e),t),t,n,a,i,r,2):2===s&&Is(e,t,n,a,i,r):Ps(Ts(e),t,n,a,i,r,1);break}}}function Ds(e){const t=e.prev,n=e,a=e.next;if(Us(t,n,a)>=0)return!1;const i=t.x,r=n.x,s=a.x,o=t.y,l=n.y,c=a.y,h=Math.min(i,r,s),d=Math.min(o,l,c),u=Math.max(i,r,s),p=Math.max(o,l,c);let m=a.next;for(;m!==t;){if(m.x>=h&&m.x<=u&&m.y>=d&&m.y<=p&&Ns(i,o,r,l,s,c,m.x,m.y)&&Us(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function Os(e,t,n,a){const i=e.prev,r=e,s=e.next;if(Us(i,r,s)>=0)return!1;const o=i.x,l=r.x,c=s.x,h=i.y,d=r.y,u=s.y,p=Math.min(o,l,c),m=Math.min(h,d,u),f=Math.max(o,l,c),g=Math.max(h,d,u),y=Fs(p,m,t,n,a),v=Fs(f,g,t,n,a);let b=e.prevZ,w=e.nextZ;for(;b&&b.z>=y&&w&&w.z<=v;){if(b.x>=p&&b.x<=f&&b.y>=m&&b.y<=g&&b!==i&&b!==s&&Ns(o,h,l,d,c,u,b.x,b.y)&&Us(b.prev,b,b.next)>=0)return!1;if(b=b.prevZ,w.x>=p&&w.x<=f&&w.y>=m&&w.y<=g&&w!==i&&w!==s&&Ns(o,h,l,d,c,u,w.x,w.y)&&Us(w.prev,w,w.next)>=0)return!1;w=w.nextZ}for(;b&&b.z>=y;){if(b.x>=p&&b.x<=f&&b.y>=m&&b.y<=g&&b!==i&&b!==s&&Ns(o,h,l,d,c,u,b.x,b.y)&&Us(b.prev,b,b.next)>=0)return!1;b=b.prevZ}for(;w&&w.z<=v;){if(w.x>=p&&w.x<=f&&w.y>=m&&w.y<=g&&w!==i&&w!==s&&Ns(o,h,l,d,c,u,w.x,w.y)&&Us(w.prev,w,w.next)>=0)return!1;w=w.nextZ}return!0}function Es(e,t){let n=e;do{const a=n.prev,i=n.next.next;!Gs(a,i)&&Ws(a,n,n.next,i)&&js(a,i)&&js(i,a)&&(t.push(a.i,n.i,i.i),$s(n),$s(n.next),n=e=i),n=n.next}while(n!==e);return Ts(n)}function Is(e,t,n,a,i,r){let s=e;do{let e=s.next.next;for(;e!==s.prev;){if(s.i!==e.i&&Vs(s,e)){let o=Xs(s,e);return s=Ts(s,s.next),o=Ts(o,o.next),Ps(s,t,n,a,i,r,0),void Ps(o,t,n,a,i,r,0)}e=e.next}s=s.next}while(s!==e)}function ks(e,t){let n=e.x-t.x;return 0===n&&(n=e.y-t.y,0===n)&&(n=(e.next.y-e.y)/(e.next.x-e.x)-(t.next.y-t.y)/(t.next.x-t.x)),n}function Rs(e,t){const n=function(e,t){let n=t;const a=e.x,i=e.y;let r,s=-1/0;if(Gs(e,n))return n;do{if(Gs(e,n.next))return n.next;if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){const e=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=a&&e>s&&(s=e,r=n.x<n.next.x?n:n.next,e===a))return r}n=n.next}while(n!==t);if(!r)return null;const o=r,l=r.x,c=r.y;let h=1/0;n=r;do{if(a>=n.x&&n.x>=l&&a!==n.x&&Ls(i<c?a:s,i,l,c,i<c?s:a,i,n.x,n.y)){const t=Math.abs(i-n.y)/(a-n.x);js(n,e)&&(t<h||t===h&&(n.x>r.x||n.x===r.x&&zs(r,n)))&&(r=n,h=t)}n=n.next}while(n!==o);return r}(e,t);if(!n)return t;const a=Xs(n,e);return Ts(a,a.next),Ts(n,n.next)}function zs(e,t){return Us(e.prev,e,t.prev)<0&&Us(t.next,e,e.next)<0}function Fs(e,t,n,a,i){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*i|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-a)*i|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function Bs(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function Ls(e,t,n,a,i,r,s,o){return(i-s)*(t-o)>=(e-s)*(r-o)&&(e-s)*(a-o)>=(n-s)*(t-o)&&(n-s)*(r-o)>=(i-s)*(a-o)}function Ns(e,t,n,a,i,r,s,o){return!(e===s&&t===o)&&Ls(e,t,n,a,i,r,s,o)}function Vs(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&Ws(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(js(e,t)&&js(t,e)&&function(e,t){let n=e,a=!1;const i=(e.x+t.x)/2,r=(e.y+t.y)/2;do{n.y>r!=n.next.y>r&&n.next.y!==n.y&&i<(n.next.x-n.x)*(r-n.y)/(n.next.y-n.y)+n.x&&(a=!a),n=n.next}while(n!==e);return a}(e,t)&&(Us(e.prev,e,t.prev)||Us(e,t.prev,t))||Gs(e,t)&&Us(e.prev,e,e.next)>0&&Us(t.prev,t,t.next)>0)}function Us(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function Gs(e,t){return e.x===t.x&&e.y===t.y}function Ws(e,t,n,a){const i=Hs(Us(e,t,n)),r=Hs(Us(e,t,a)),s=Hs(Us(n,a,e)),o=Hs(Us(n,a,t));return i!==r&&s!==o||!(0!==i||!qs(e,n,t))||!(0!==r||!qs(e,a,t))||!(0!==s||!qs(n,e,a))||!(0!==o||!qs(n,t,a))}function qs(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function Hs(e){return e>0?1:e<0?-1:0}function js(e,t){return Us(e.prev,e,e.next)<0?Us(e,t,e.next)>=0&&Us(e,e.prev,t)>=0:Us(e,t,e.prev)<0||Us(e,e.next,t)<0}function Xs(e,t){const n=Qs(e.i,e.x,e.y),a=Qs(t.i,t.x,t.y),i=e.next,r=t.prev;return e.next=t,t.prev=e,n.next=i,i.prev=n,a.next=n,n.prev=a,r.next=a,a.prev=r,a}function Ys(e,t,n,a){const i=Qs(e,t,n);return a?(i.next=a.next,i.prev=a,a.next.prev=i,a.next=i):(i.prev=i,i.next=i),i}function $s(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Qs(e,t,n){return{i:e,x:t,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}class Ks{static triangulate(e,t,n=2){return function(e,t,n=2){const a=t&&t.length,i=a?t[0]*n:e.length;let r=Cs(e,0,i,n,!0);const s=[];if(!r||r.next===r.prev)return s;let o,l,c;if(a&&(r=function(e,t,n,a){const i=[];for(let n=0,r=t.length;n<r;n++){const s=Cs(e,t[n]*a,n<r-1?t[n+1]*a:e.length,a,!1);s===s.next&&(s.steiner=!0),i.push(Bs(s))}i.sort(ks);for(let e=0;e<i.length;e++)n=Rs(i[e],n);return n}(e,t,r,n)),e.length>80*n){o=e[0],l=e[1];let t=o,a=l;for(let r=n;r<i;r+=n){const n=e[r],i=e[r+1];n<o&&(o=n),i<l&&(l=i),n>t&&(t=n),i>a&&(a=i)}c=Math.max(t-o,a-l),c=0!==c?32767/c:0}return Ps(r,s,n,o,l,c,0),s}(e,t,n)}}class Zs{static area(e){const t=e.length;let n=0;for(let a=t-1,i=0;i<t;a=i++)n+=e[a].x*e[i].y-e[i].x*e[a].y;return.5*n}static isClockWise(e){return Zs.area(e)<0}static triangulateShape(e,t){const n=[],a=[],i=[];Js(e),eo(n,e);let r=e.length;t.forEach(Js);for(let e=0;e<t.length;e++)a.push(r),r+=t[e].length,eo(n,t[e]);const s=Ks.triangulate(n,a);for(let e=0;e<s.length;e+=3)i.push(s.slice(e,e+3));return i}}function Js(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function eo(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class to extends ts{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new to(e.radius,e.detail)}}class no extends ts{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new no(e.radius,e.detail)}}class ao extends ei{constructor(e=1,t=1,n=1,a=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:a};const i=e/2,r=t/2,s=Math.floor(n),o=Math.floor(a),l=s+1,c=o+1,h=e/s,d=t/o,u=[],p=[],m=[],f=[];for(let e=0;e<c;e++){const t=e*d-r;for(let n=0;n<l;n++){const a=n*h-i;p.push(a,-t,0),m.push(0,0,1),f.push(n/s),f.push(1-e/o)}}for(let e=0;e<o;e++)for(let t=0;t<s;t++){const n=t+l*e,a=t+l*(e+1),i=t+1+l*(e+1),r=t+1+l*e;u.push(n,a,r),u.push(a,i,r)}this.setIndex(u),this.setAttribute("position",new ja(p,3)),this.setAttribute("normal",new ja(m,3)),this.setAttribute("uv",new ja(f,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ao(e.width,e.height,e.widthSegments,e.heightSegments)}}class io extends ei{constructor(e=.5,t=1,n=32,a=1,i=0,r=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:a,thetaStart:i,thetaLength:r},n=Math.max(3,n);const s=[],o=[],l=[],c=[];let h=e;const d=(t-e)/(a=Math.max(1,a)),u=new Gt,p=new Vt;for(let e=0;e<=a;e++){for(let e=0;e<=n;e++){const a=i+e/n*r;u.x=h*Math.cos(a),u.y=h*Math.sin(a),o.push(u.x,u.y,u.z),l.push(0,0,1),p.x=(u.x/t+1)/2,p.y=(u.y/t+1)/2,c.push(p.x,p.y)}h+=d}for(let e=0;e<a;e++){const t=e*(n+1);for(let e=0;e<n;e++){const a=e+t,i=a,r=a+n+1,o=a+n+2,l=a+1;s.push(i,r,l),s.push(r,o,l)}}this.setIndex(s),this.setAttribute("position",new ja(o,3)),this.setAttribute("normal",new ja(l,3)),this.setAttribute("uv",new ja(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new io(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class ro extends ei{constructor(e=new As([new Vt(0,.5),new Vt(-.5,-.5),new Vt(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],a=[],i=[],r=[];let s=0,o=0;if(!1===Array.isArray(e))l(e);else for(let t=0;t<e.length;t++)l(e[t]),this.addGroup(s,o,t),s+=o,o=0;function l(e){const s=a.length/3,l=e.extractPoints(t);let c=l.shape;const h=l.holes;!1===Zs.isClockWise(c)&&(c=c.reverse());for(let e=0,t=h.length;e<t;e++){const t=h[e];!0===Zs.isClockWise(t)&&(h[e]=t.reverse())}const d=Zs.triangulateShape(c,h);for(let e=0,t=h.length;e<t;e++){const t=h[e];c=c.concat(t)}for(let e=0,t=c.length;e<t;e++){const t=c[e];a.push(t.x,t.y,0),i.push(0,0,1),r.push(t.x,t.y)}for(let e=0,t=d.length;e<t;e++){const t=d[e],a=t[0]+s,i=t[1]+s,r=t[2]+s;n.push(a,i,r),o+=3}}this.setIndex(n),this.setAttribute("position",new ja(a,3)),this.setAttribute("normal",new ja(i,3)),this.setAttribute("uv",new ja(r,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return function(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,a=e.length;n<a;n++){const a=e[n];t.shapes.push(a.uuid)}else t.shapes.push(e.uuid);return t}(this.parameters.shapes,e)}static fromJSON(e,t){const n=[];for(let a=0,i=e.shapes.length;a<i;a++){const i=t[e.shapes[a]];n.push(i)}return new ro(n,e.curveSegments)}}class so extends ei{constructor(e=1,t=32,n=16,a=0,i=2*Math.PI,r=0,s=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:a,phiLength:i,thetaStart:r,thetaLength:s},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const o=Math.min(r+s,Math.PI);let l=0;const c=[],h=new Gt,d=new Gt,u=[],p=[],m=[],f=[];for(let u=0;u<=n;u++){const g=[],y=u/n;let v=0;0===u&&0===r?v=.5/t:u===n&&o===Math.PI&&(v=-.5/t);for(let n=0;n<=t;n++){const o=n/t;h.x=-e*Math.cos(a+o*i)*Math.sin(r+y*s),h.y=e*Math.cos(r+y*s),h.z=e*Math.sin(a+o*i)*Math.sin(r+y*s),p.push(h.x,h.y,h.z),d.copy(h).normalize(),m.push(d.x,d.y,d.z),f.push(o+v,1-y),g.push(l++)}c.push(g)}for(let e=0;e<n;e++)for(let a=0;a<t;a++){const t=c[e][a+1],i=c[e][a],s=c[e+1][a],l=c[e+1][a+1];(0!==e||r>0)&&u.push(t,i,l),(e!==n-1||o<Math.PI)&&u.push(i,s,l)}this.setIndex(u),this.setAttribute("position",new ja(p,3)),this.setAttribute("normal",new ja(m,3)),this.setAttribute("uv",new ja(f,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new so(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class oo extends ei{constructor(e=1,t=.4,n=12,a=48,i=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:a,arc:i},n=Math.floor(n),a=Math.floor(a);const r=[],s=[],o=[],l=[],c=new Gt,h=new Gt,d=new Gt;for(let r=0;r<=n;r++)for(let u=0;u<=a;u++){const p=u/a*i,m=r/n*Math.PI*2;h.x=(e+t*Math.cos(m))*Math.cos(p),h.y=(e+t*Math.cos(m))*Math.sin(p),h.z=t*Math.sin(m),s.push(h.x,h.y,h.z),c.x=e*Math.cos(p),c.y=e*Math.sin(p),d.subVectors(h,c).normalize(),o.push(d.x,d.y,d.z),l.push(u/a),l.push(r/n)}for(let e=1;e<=n;e++)for(let t=1;t<=a;t++){const n=(a+1)*e+t-1,i=(a+1)*(e-1)+t-1,s=(a+1)*(e-1)+t,o=(a+1)*e+t;r.push(n,i,o),r.push(i,s,o)}this.setIndex(r),this.setAttribute("position",new ja(s,3)),this.setAttribute("normal",new ja(o,3)),this.setAttribute("uv",new ja(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new oo(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class lo extends za{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Ia(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ia(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Vt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Qn,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class co extends lo{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Rt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Ia(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Ia(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ia(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class ho extends za{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Ia(16777215),this.specular=new Ia(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ia(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Vt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Qn,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class uo extends za{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class po extends za{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}function mo(e,t){return e&&e.constructor!==t?"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e):e}function fo(e){const t=e.length,n=new Array(t);for(let e=0;e!==t;++e)n[e]=e;return n.sort(function(t,n){return e[t]-e[n]}),n}function go(e,t,n){const a=e.length,i=new e.constructor(a);for(let r=0,s=0;s!==a;++r){const a=n[r]*t;for(let n=0;n!==t;++n)i[s++]=e[a+n]}return i}function yo(e,t,n,a){let i=1,r=e[0];for(;void 0!==r&&void 0===r[a];)r=e[i++];if(void 0===r)return;let s=r[a];if(void 0!==s)if(Array.isArray(s))do{s=r[a],void 0!==s&&(t.push(r.time),n.push(...s)),r=e[i++]}while(void 0!==r);else if(void 0!==s.toArray)do{s=r[a],void 0!==s&&(t.push(r.time),s.toArray(n,n.length)),r=e[i++]}while(void 0!==r);else do{s=r[a],void 0!==s&&(t.push(r.time),n.push(s)),r=e[i++]}while(void 0!==r)}class vo{constructor(e,t,n,a){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==a?a:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,a=t[n],i=t[n-1];e:{t:{let r;n:{a:if(!(e<a)){for(let r=n+2;;){if(void 0===a){if(e<i)break a;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===r)break;if(i=a,a=t[++n],e<a)break t}r=t.length;break n}if(!(e>=i)){const s=t[1];e<s&&(n=2,i=s);for(let r=n-2;;){if(void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(n===r)break;if(a=i,i=t[--n-1],e>=i)break t}r=n,n=0;break n}break e}for(;n<r;){const a=n+r>>>1;e<t[a]?r=a:n=a+1}if(a=t[n],i=t[n-1],void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===a)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,i,a)}return this.interpolate_(n,i,e,a)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,a=this.valueSize,i=e*a;for(let e=0;e!==a;++e)t[e]=n[i+e];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class bo extends vo{constructor(e,t,n,a){super(e,t,n,a),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Ze,endingEnd:Ze}}intervalChanged_(e,t,n){const a=this.parameterPositions;let i=e-2,r=e+1,s=a[i],o=a[r];if(void 0===s)switch(this.getSettings_().endingStart){case Je:i=e,s=2*t-n;break;case et:i=a.length-2,s=t+a[i]-a[i+1];break;default:i=e,s=n}if(void 0===o)switch(this.getSettings_().endingEnd){case Je:r=e,o=2*n-t;break;case et:r=1,o=n+a[1]-a[0];break;default:r=e-1,o=t}const l=.5*(n-t),c=this.valueSize;this._weightPrev=l/(t-s),this._weightNext=l/(o-n),this._offsetPrev=i*c,this._offsetNext=r*c}interpolate_(e,t,n,a){const i=this.resultBuffer,r=this.sampleValues,s=this.valueSize,o=e*s,l=o-s,c=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,u=this._weightNext,p=(n-t)/(a-t),m=p*p,f=m*p,g=-d*f+2*d*m-d*p,y=(1+d)*f+(-1.5-2*d)*m+(-.5+d)*p+1,v=(-1-u)*f+(1.5+u)*m+.5*p,b=u*f-u*m;for(let e=0;e!==s;++e)i[e]=g*r[c+e]+y*r[l+e]+v*r[o+e]+b*r[h+e];return i}}class wo extends vo{constructor(e,t,n,a){super(e,t,n,a)}interpolate_(e,t,n,a){const i=this.resultBuffer,r=this.sampleValues,s=this.valueSize,o=e*s,l=o-s,c=(n-t)/(a-t),h=1-c;for(let e=0;e!==s;++e)i[e]=r[l+e]*h+r[o+e]*c;return i}}class xo extends vo{constructor(e,t,n,a){super(e,t,n,a)}interpolate_(e){return this.copySampleValue_(e-1)}}class So{constructor(e,t,n,a){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=mo(t,this.TimeBufferType),this.values=mo(n,this.ValueBufferType),this.setInterpolation(a||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:mo(e.times,Array),values:mo(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new xo(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new wo(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new bo(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case $e:t=this.InterpolantFactoryMethodDiscrete;break;case Qe:t=this.InterpolantFactoryMethodLinear;break;case Ke:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return At("KeyframeTrack:",t),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return $e;case this.InterpolantFactoryMethodLinear:return Qe;case this.InterpolantFactoryMethodSmooth:return Ke}}getValueSize(){return this.values.length/this.times.length}shift(e){if(0!==e){const t=this.times;for(let n=0,a=t.length;n!==a;++n)t[n]+=e}return this}scale(e){if(1!==e){const t=this.times;for(let n=0,a=t.length;n!==a;++n)t[n]*=e}return this}trim(e,t){const n=this.times,a=n.length;let i=0,r=a-1;for(;i!==a&&n[i]<e;)++i;for(;-1!==r&&n[r]>t;)--r;if(++r,0!==i||r!==a){i>=r&&(r=Math.max(r,1),i=r-1);const e=this.getValueSize();this.times=n.slice(i,r),this.values=this.values.slice(i*e,r*e)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(Ct("KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,a=this.values,i=n.length;0===i&&(Ct("KeyframeTrack: Track is empty.",this),e=!1);let r=null;for(let t=0;t!==i;t++){const a=n[t];if("number"==typeof a&&isNaN(a)){Ct("KeyframeTrack: Time is not a valid number.",this,t,a),e=!1;break}if(null!==r&&r>a){Ct("KeyframeTrack: Out of order keys.",this,t,a,r),e=!1;break}r=a}if(void 0!==a&&(s=a,ArrayBuffer.isView(s)&&!(s instanceof DataView)))for(let t=0,n=a.length;t!==n;++t){const n=a[t];if(isNaN(n)){Ct("KeyframeTrack: Value is not a valid number.",this,t,n),e=!1;break}}var s;return e}optimize(){const e=this.times.slice(),t=this.values.slice(),n=this.getValueSize(),a=this.getInterpolation()===Ke,i=e.length-1;let r=1;for(let s=1;s<i;++s){let i=!1;const o=e[s];if(o!==e[s+1]&&(1!==s||o!==e[0]))if(a)i=!0;else{const e=s*n,a=e-n,r=e+n;for(let s=0;s!==n;++s){const n=t[e+s];if(n!==t[a+s]||n!==t[r+s]){i=!0;break}}}if(i){if(s!==r){e[r]=e[s];const a=s*n,i=r*n;for(let e=0;e!==n;++e)t[i+e]=t[a+e]}++r}}if(i>0){e[r]=e[i];for(let e=i*n,a=r*n,s=0;s!==n;++s)t[a+s]=t[e+s];++r}return r!==e.length?(this.times=e.slice(0,r),this.values=t.slice(0,r*n)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),n=new(0,this.constructor)(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}So.prototype.ValueTypeName="",So.prototype.TimeBufferType=Float32Array,So.prototype.ValueBufferType=Float32Array,So.prototype.DefaultInterpolation=Qe;class Mo extends So{constructor(e,t,n){super(e,t,n)}}Mo.prototype.ValueTypeName="bool",Mo.prototype.ValueBufferType=Array,Mo.prototype.DefaultInterpolation=$e,Mo.prototype.InterpolantFactoryMethodLinear=void 0,Mo.prototype.InterpolantFactoryMethodSmooth=void 0;class _o extends So{constructor(e,t,n,a){super(e,t,n,a)}}_o.prototype.ValueTypeName="color";class Ao extends So{constructor(e,t,n,a){super(e,t,n,a)}}Ao.prototype.ValueTypeName="number";class Co extends vo{constructor(e,t,n,a){super(e,t,n,a)}interpolate_(e,t,n,a){const i=this.resultBuffer,r=this.sampleValues,s=this.valueSize,o=(n-t)/(a-t);let l=e*s;for(let e=l+s;l!==e;l+=4)Ut.slerpFlat(i,0,r,l-s,r,l,o);return i}}class To extends So{constructor(e,t,n,a){super(e,t,n,a)}InterpolantFactoryMethodLinear(e){return new Co(this.times,this.values,this.getValueSize(),e)}}To.prototype.ValueTypeName="quaternion",To.prototype.InterpolantFactoryMethodSmooth=void 0;class Po extends So{constructor(e,t,n){super(e,t,n)}}Po.prototype.ValueTypeName="string",Po.prototype.ValueBufferType=Array,Po.prototype.DefaultInterpolation=$e,Po.prototype.InterpolantFactoryMethodLinear=void 0,Po.prototype.InterpolantFactoryMethodSmooth=void 0;class Do extends So{constructor(e,t,n,a){super(e,t,n,a)}}Do.prototype.ValueTypeName="vector";class Oo{constructor(e="",t=-1,n=[],a=2500){this.name=e,this.tracks=n,this.duration=t,this.blendMode=a,this.uuid=kt(),this.userData={},this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,a=1/(e.fps||1);for(let e=0,i=n.length;e!==i;++e)t.push(Eo(n[e]).scale(a));const i=new this(e.name,e.duration,t,e.blendMode);return i.uuid=e.uuid,i.userData=JSON.parse(e.userData||"{}"),i}static toJSON(e){const t=[],n=e.tracks,a={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode,userData:JSON.stringify(e.userData)};for(let e=0,a=n.length;e!==a;++e)t.push(So.toJSON(n[e]));return a}static CreateFromMorphTargetSequence(e,t,n,a){const i=t.length,r=[];for(let e=0;e<i;e++){let s=[],o=[];s.push((e+i-1)%i,e,(e+1)%i),o.push(0,1,0);const l=fo(s);s=go(s,1,l),o=go(o,1,l),a||0!==s[0]||(s.push(i),o.push(o[0])),r.push(new Ao(".morphTargetInfluences["+t[e].name+"]",s,o).scale(1/n))}return new this(e,-1,r)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const t=e;n=t.geometry&&t.geometry.animations||t.animations}for(let e=0;e<n.length;e++)if(n[e].name===t)return n[e];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const a={},i=/^([\w-]*?)([\d]+)$/;for(let t=0,n=e.length;t<n;t++){const n=e[t],r=n.name.match(i);if(r&&r.length>1){const e=r[1];let t=a[e];t||(a[e]=t=[]),t.push(n)}}const r=[];for(const e in a)r.push(this.CreateFromMorphTargetSequence(e,a[e],t,n));return r}static parseAnimation(e,t){if(At("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!e)return Ct("AnimationClip: No animation in JSONLoader data."),null;const n=function(e,t,n,a,i){if(0!==n.length){const r=[],s=[];yo(n,r,s,a),0!==r.length&&i.push(new e(t,r,s))}},a=[],i=e.name||"default",r=e.fps||30,s=e.blendMode;let o=e.length||-1;const l=e.hierarchy||[];for(let e=0;e<l.length;e++){const i=l[e].keys;if(i&&0!==i.length)if(i[0].morphTargets){const e={};let t;for(t=0;t<i.length;t++)if(i[t].morphTargets)for(let n=0;n<i[t].morphTargets.length;n++)e[i[t].morphTargets[n]]=-1;for(const n in e){const e=[],r=[];for(let a=0;a!==i[t].morphTargets.length;++a){const a=i[t];e.push(a.time),r.push(a.morphTarget===n?1:0)}a.push(new Ao(".morphTargetInfluence["+n+"]",e,r))}o=e.length*r}else{const r=".bones["+t[e].name+"]";n(Do,r+".position",i,"pos",a),n(To,r+".quaternion",i,"rot",a),n(Do,r+".scale",i,"scl",a)}}return 0===a.length?null:new this(i,o,a,s)}resetDuration(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){const n=this.tracks[t];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());const t=new this.constructor(this.name,this.duration,e,this.blendMode);return t.userData=JSON.parse(JSON.stringify(this.userData)),t}toJSON(){return this.constructor.toJSON(this)}}function Eo(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Ao;case"vector":case"vector2":case"vector3":case"vector4":return Do;case"color":return _o;case"quaternion":return To;case"bool":case"boolean":return Mo;case"string":return Po}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(e.type);if(void 0===e.times){const t=[],n=[];yo(e.keys,t,n,"value"),e.times=t,e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}const Io={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};class ko{constructor(e,t,n){const a=this;let i,r=!1,s=0,o=0;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this._abortController=null,this.itemStart=function(e){o++,!1===r&&void 0!==a.onStart&&a.onStart(e,s,o),r=!0},this.itemEnd=function(e){s++,void 0!==a.onProgress&&a.onProgress(e,s,o),s===o&&(r=!1,void 0!==a.onLoad&&a.onLoad())},this.itemError=function(e){void 0!==a.onError&&a.onError(e)},this.resolveURL=function(e){return i?i(e):e},this.setURLModifier=function(e){return i=e,this},this.addHandler=function(e,t){return l.push(e,t),this},this.removeHandler=function(e){const t=l.indexOf(e);return-1!==t&&l.splice(t,2),this},this.getHandler=function(e){for(let t=0,n=l.length;t<n;t+=2){const n=l[t],a=l[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return a}return null},this.abort=function(){return this.abortController.abort(),this._abortController=null,this}}get abortController(){return this._abortController||(this._abortController=new AbortController),this._abortController}}const Ro=new ko;class zo{constructor(e){this.manager=void 0!==e?e:Ro,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(a,i){n.load(e,a,t,i)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}abort(){return this}}zo.DEFAULT_MATERIAL_NAME="__DEFAULT";const Fo={};class Bo extends Error{constructor(e,t){super(e),this.response=t}}class Lo extends zo{constructor(e){super(e),this.mimeType="",this.responseType="",this._abortController=new AbortController}load(e,t,n,a){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const i=Io.get(`file:${e}`);if(void 0!==i)return this.manager.itemStart(e),setTimeout(()=>{t&&t(i),this.manager.itemEnd(e)},0),i;if(void 0!==Fo[e])return void Fo[e].push({onLoad:t,onProgress:n,onError:a});Fo[e]=[],Fo[e].push({onLoad:t,onProgress:n,onError:a});const r=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:"function"==typeof AbortSignal.any?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal}),s=this.mimeType,o=this.responseType;fetch(r).then(t=>{if(200===t.status||0===t.status){if(0===t.status&&At("FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===t.body||void 0===t.body.getReader)return t;const n=Fo[e],a=t.body.getReader(),i=t.headers.get("X-File-Size")||t.headers.get("Content-Length"),r=i?parseInt(i):0,s=0!==r;let o=0;const l=new ReadableStream({start(e){!function t(){a.read().then(({done:a,value:i})=>{if(a)e.close();else{o+=i.byteLength;const a=new ProgressEvent("progress",{lengthComputable:s,loaded:o,total:r});for(let e=0,t=n.length;e<t;e++){const t=n[e];t.onProgress&&t.onProgress(a)}e.enqueue(i),t()}},t=>{e.error(t)})}()}});return new Response(l)}throw new Bo(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)}).then(e=>{switch(o){case"arraybuffer":return e.arrayBuffer();case"blob":return e.blob();case"document":return e.text().then(e=>(new DOMParser).parseFromString(e,s));case"json":return e.json();default:if(""===s)return e.text();{const t=/charset="?([^;"\s]*)"?/i.exec(s),n=t&&t[1]?t[1].toLowerCase():void 0,a=new TextDecoder(n);return e.arrayBuffer().then(e=>a.decode(e))}}}).then(t=>{Io.add(`file:${e}`,t);const n=Fo[e];delete Fo[e];for(let e=0,a=n.length;e<a;e++){const a=n[e];a.onLoad&&a.onLoad(t)}}).catch(t=>{const n=Fo[e];if(void 0===n)throw this.manager.itemError(e),t;delete Fo[e];for(let e=0,a=n.length;e<a;e++){const a=n[e];a.onError&&a.onError(t)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}const No=new WeakMap;class Vo extends zo{constructor(e){super(e)}load(e,t,n,a){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,r=Io.get(`image:${e}`);if(void 0!==r){if(!0===r.complete)i.manager.itemStart(e),setTimeout(function(){t&&t(r),i.manager.itemEnd(e)},0);else{let e=No.get(r);void 0===e&&(e=[],No.set(r,e)),e.push({onLoad:t,onError:a})}return r}const s=xt("img");function o(){c(),t&&t(this);const n=No.get(this)||[];for(let e=0;e<n.length;e++){const t=n[e];t.onLoad&&t.onLoad(this)}No.delete(this),i.manager.itemEnd(e)}function l(t){c(),a&&a(t),Io.remove(`image:${e}`);const n=No.get(this)||[];for(let e=0;e<n.length;e++){const a=n[e];a.onError&&a.onError(t)}No.delete(this),i.manager.itemError(e),i.manager.itemEnd(e)}function c(){s.removeEventListener("load",o,!1),s.removeEventListener("error",l,!1)}return s.addEventListener("load",o,!1),s.addEventListener("error",l,!1),"data:"!==e.slice(0,5)&&void 0!==this.crossOrigin&&(s.crossOrigin=this.crossOrigin),Io.add(`image:${e}`,s),i.manager.itemStart(e),s.src=e,s}}class Uo extends zo{constructor(e){super(e)}load(e,t,n,a){const i=this,r=new cr,s=new Lo(this.manager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(i.withCredentials),s.load(e,function(e){let n;try{n=i.parse(e)}catch(e){if(void 0===a)return void e(e);a(e)}void 0!==n.image?r.image=n.image:void 0!==n.data&&(r.image.width=n.width,r.image.height=n.height,r.image.data=n.data),r.wrapS=void 0!==n.wrapS?n.wrapS:V,r.wrapT=void 0!==n.wrapT?n.wrapT:V,r.magFilter=void 0!==n.magFilter?n.magFilter:H,r.minFilter=void 0!==n.minFilter?n.minFilter:H,r.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.colorSpace&&(r.colorSpace=n.colorSpace),void 0!==n.flipY&&(r.flipY=n.flipY),void 0!==n.format&&(r.format=n.format),void 0!==n.type&&(r.type=n.type),void 0!==n.mipmaps&&(r.mipmaps=n.mipmaps,r.minFilter=X),1===n.mipmapCount&&(r.minFilter=H),void 0!==n.generateMipmaps&&(r.generateMipmaps=n.generateMipmaps),r.needsUpdate=!0,t&&t(r,n)},n,a),r}}class Go extends zo{constructor(e){super(e)}load(e,t,n,a){const i=new on,r=new Vo(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(e,function(e){i.image=e,i.needsUpdate=!0,void 0!==t&&t(i)},n,a),i}}class Wo extends pa{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Ia(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),void 0!==this.target&&(t.object.target=this.target.uuid),t}}class qo extends Wo{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(pa.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Ia(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const Ho=new Vn,jo=new Gt,Xo=new Gt;class Yo{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vt(512,512),this.mapType=Y,this.map=null,this.mapPass=null,this.matrix=new Vn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Dr,this._frameExtents=new Vt(1,1),this._viewportCount=1,this._viewports=[new ln(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;jo.setFromMatrixPosition(e.matrixWorld),t.position.copy(jo),Xo.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(Xo),t.updateMatrixWorld(),Ho.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ho,t.coordinateSystem,t.reversedDepth),t.reversedDepth?n.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(Ho)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.autoUpdate=e.autoUpdate,this.needsUpdate=e.needsUpdate,this.normalBias=e.normalBias,this.blurSamples=e.blurSamples,this.mapSize.copy(e.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const e={};return 1!==this.intensity&&(e.intensity=this.intensity),0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class $o extends Yo{constructor(){super(new _i(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(e){const t=this.camera,n=2*It*e.angle*this.focus,a=this.mapSize.width/this.mapSize.height*this.aspect,i=e.distance||t.far;n===t.fov&&a===t.aspect&&i===t.far||(t.fov=n,t.aspect=a,t.far=i,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class Qo extends Wo{constructor(e,t,n=0,a=Math.PI/3,i=0,r=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(pa.DEFAULT_UP),this.updateMatrix(),this.target=new pa,this.distance=n,this.angle=a,this.penumbra=i,this.decay=r,this.map=null,this.shadow=new $o}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const Ko=new Vn,Zo=new Gt,Jo=new Gt;class el extends Yo{constructor(){super(new _i(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vt(4,2),this._viewportCount=6,this._viewports=[new ln(2,1,1,1),new ln(0,1,1,1),new ln(3,1,1,1),new ln(1,1,1,1),new ln(3,0,1,1),new ln(1,0,1,1)],this._cubeDirections=[new Gt(1,0,0),new Gt(-1,0,0),new Gt(0,0,1),new Gt(0,0,-1),new Gt(0,1,0),new Gt(0,-1,0)],this._cubeUps=[new Gt(0,1,0),new Gt(0,1,0),new Gt(0,1,0),new Gt(0,1,0),new Gt(0,0,1),new Gt(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,a=this.matrix,i=e.distance||n.far;i!==n.far&&(n.far=i,n.updateProjectionMatrix()),Zo.setFromMatrixPosition(e.matrixWorld),n.position.copy(Zo),Jo.copy(n.position),Jo.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(Jo),n.updateMatrixWorld(),a.makeTranslation(-Zo.x,-Zo.y,-Zo.z),Ko.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ko,n.coordinateSystem,n.reversedDepth)}}class tl extends Wo{constructor(e,t,n=0,a=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=a,this.shadow=new el}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class nl extends wi{constructor(e=-1,t=1,n=1,a=-1,i=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=a,this.near=i,this.far=r,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,t,n,a,i,r){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=a,this.view.width=i,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,a=(this.top+this.bottom)/2;let i=n-e,r=n+e,s=a+t,o=a-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=e*this.view.offsetX,r=i+e*this.view.width,s-=t*this.view.offsetY,o=s-t*this.view.height}this.projectionMatrix.makeOrthographic(i,r,s,o,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}class al extends Yo{constructor(){super(new nl(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class il extends Wo{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(pa.DEFAULT_UP),this.updateMatrix(),this.target=new pa,this.shadow=new al}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class rl extends Wo{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class sl{static extractUrlBase(e){const t=e.lastIndexOf("/");return-1===t?"./":e.slice(0,t+1)}static resolveURL(e,t){return"string"!=typeof e||""===e?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class ol extends ei{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}const ll=new WeakMap;class cl extends zo{constructor(e){super(e),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&At("ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&At("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"},this._abortController=new AbortController}setOptions(e){return this.options=e,this}load(e,t,n,a){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,r=Io.get(`image-bitmap:${e}`);if(void 0!==r)return i.manager.itemStart(e),r.then?void r.then(n=>{if(!0!==ll.has(r))return t&&t(n),i.manager.itemEnd(e),n;a&&a(ll.get(r)),i.manager.itemError(e),i.manager.itemEnd(e)}):(setTimeout(function(){t&&t(r),i.manager.itemEnd(e)},0),r);const s={};s.credentials="anonymous"===this.crossOrigin?"same-origin":"include",s.headers=this.requestHeader,s.signal="function"==typeof AbortSignal.any?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal;const o=fetch(e,s).then(function(e){return e.blob()}).then(function(e){return createImageBitmap(e,Object.assign(i.options,{colorSpaceConversion:"none"}))}).then(function(n){return Io.add(`image-bitmap:${e}`,n),t&&t(n),i.manager.itemEnd(e),n}).catch(function(t){a&&a(t),ll.set(o,t),Io.remove(`image-bitmap:${e}`),i.manager.itemError(e),i.manager.itemEnd(e)});Io.add(`image-bitmap:${e}`,o),i.manager.itemStart(e)}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}class hl extends _i{constructor(e=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=e}}class dl{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=performance.now();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}const ul="\\[\\]\\.:\\/",pl=new RegExp("["+ul+"]","g"),ml="[^"+ul+"]",fl="[^"+ul.replace("\\.","")+"]",gl=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",ml)+/(WCOD+)?/.source.replace("WCOD",fl)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",ml)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",ml)+"$"),yl=["material","materials","bones","map"];class vl{constructor(e,t,n){this.path=t,this.parsedPath=n||vl.parseTrackName(t),this.node=vl.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new vl.Composite(e,t,n):new vl(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(pl,"")}static parseTrackName(e){const t=gl.exec(e);if(null===t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},a=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==a&&-1!==a){const e=n.nodeName.substring(a+1);-1!==yl.indexOf(e)&&(n.nodeName=n.nodeName.substring(0,a),n.objectName=e)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(void 0===t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const n=function(e){for(let a=0;a<e.length;a++){const i=e[a];if(i.name===t||i.uuid===t)return i;const r=n(i.children);if(r)return r}return null},a=n(e.children);if(a)return a}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let a=0,i=n.length;a!==i;++a)e[t++]=n[a]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let a=0,i=n.length;a!==i;++a)n[a]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let a=0,i=n.length;a!==i;++a)n[a]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let a=0,i=n.length;a!==i;++a)n[a]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,a=t.propertyName;let i=t.propertyIndex;if(e||(e=vl.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void At("PropertyBinding: No target node found for track: "+this.path+".");if(n){let a=t.objectIndex;switch(n){case"materials":if(!e.material)return void Ct("PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void Ct("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void Ct("PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===a){a=t;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material)return void Ct("PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.map)return void Ct("PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);e=e.material.map;break;default:if(void 0===e[n])return void Ct("PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==a){if(void 0===e[a])return void Ct("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[a]}}const r=e[a];if(void 0===r)return void Ct("PropertyBinding: Trying to update property for track: "+t.nodeName+"."+a+" but it wasn't found.",e);let s=this.Versioning.None;this.targetObject=e,!0===e.isMaterial?s=this.Versioning.NeedsUpdate:!0===e.isObject3D&&(s=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===a){if(!e.geometry)return void Ct("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void Ct("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[i]&&(i=e.morphTargetDictionary[i])}o=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=i}else void 0!==r.fromArray&&void 0!==r.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(o=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=a;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][s]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}vl.Composite=class{constructor(e,t,n){const a=n||vl.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,a)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,a=this._bindings[n];void 0!==a&&a.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let a=this._targetGroup.nCachedObjects_,i=n.length;a!==i;++a)n[a].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}},vl.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},vl.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},vl.prototype.GetterByBindingType=[vl.prototype._getValue_direct,vl.prototype._getValue_array,vl.prototype._getValue_arrayElement,vl.prototype._getValue_toArray],vl.prototype.SetterByBindingTypeAndVersioning=[[vl.prototype._setValue_direct,vl.prototype._setValue_direct_setNeedsUpdate,vl.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[vl.prototype._setValue_array,vl.prototype._setValue_array_setNeedsUpdate,vl.prototype._setValue_array_setMatrixWorldNeedsUpdate],[vl.prototype._setValue_arrayElement,vl.prototype._setValue_arrayElement_setNeedsUpdate,vl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[vl.prototype._setValue_fromArray,vl.prototype._setValue_fromArray_setNeedsUpdate,vl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class bl{constructor(e=1,t=0,n=0){this.radius=e,this.phi=t,this.theta=n}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){const e=1e-6;return this.phi=Rt(this.phi,e,Math.PI-e),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Rt(t/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class wl extends Pt{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(e){void 0!==e?(null!==this.domElement&&this.disconnect(),this.domElement=e):At("Controls: connect() now requires an element.")}disconnect(){}dispose(){}update(){}}function xl(e,t,n,a){const i=function(e){switch(e){case Y:case $:return{byteLength:1,components:1};case K:case Q:case te:return{byteLength:2,components:1};case ne:case ae:return{byteLength:2,components:4};case J:case Z:case ee:return{byteLength:4,components:1};case re:case se:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${e}.`)}(a);switch(n){case oe:return e*t;case ue:case pe:return e*t/i.components*i.byteLength;case me:case fe:return e*t*2/i.components*i.byteLength;case le:return e*t*3/i.components*i.byteLength;case ce:case ge:return e*t*4/i.components*i.byteLength;case ye:case ve:return Math.floor((e+3)/4)*Math.floor((t+3)/4)*8;case be:case we:return Math.floor((e+3)/4)*Math.floor((t+3)/4)*16;case Se:case _e:return Math.max(e,16)*Math.max(t,8)/4;case xe:case Me:return Math.max(e,8)*Math.max(t,8)/2;case Ae:case Ce:return Math.floor((e+3)/4)*Math.floor((t+3)/4)*8;case Te:case Pe:return Math.floor((e+3)/4)*Math.floor((t+3)/4)*16;case De:return Math.floor((e+4)/5)*Math.floor((t+3)/4)*16;case Oe:return Math.floor((e+4)/5)*Math.floor((t+4)/5)*16;case Ee:return Math.floor((e+5)/6)*Math.floor((t+4)/5)*16;case Ie:return Math.floor((e+5)/6)*Math.floor((t+5)/6)*16;case ke:return Math.floor((e+7)/8)*Math.floor((t+4)/5)*16;case Re:return Math.floor((e+7)/8)*Math.floor((t+5)/6)*16;case ze:return Math.floor((e+7)/8)*Math.floor((t+7)/8)*16;case Fe:return Math.floor((e+9)/10)*Math.floor((t+4)/5)*16;case Be:return Math.floor((e+9)/10)*Math.floor((t+5)/6)*16;case Le:return Math.floor((e+9)/10)*Math.floor((t+7)/8)*16;case Ne:return Math.floor((e+9)/10)*Math.floor((t+9)/10)*16;case Ve:return Math.floor((e+11)/12)*Math.floor((t+9)/10)*16;case Ue:return Math.floor((e+11)/12)*Math.floor((t+11)/12)*16;case Ge:case We:case qe:return Math.ceil(e/4)*Math.ceil(t/4)*16;case He:case je:return Math.ceil(e/4)*Math.ceil(t/4)*8;case Xe:case Ye:return Math.ceil(e/4)*Math.ceil(t/4)*16}throw new Error(`Unable to determine texture byte length for ${n} format.`)}function Sl(){let e=null,t=!1,n=null,a=null;function i(t,r){n(t,r),a=e.requestAnimationFrame(i)}return{start:function(){!0!==t&&null!==n&&(a=e.requestAnimationFrame(i),t=!0)},stop:function(){e.cancelAnimationFrame(a),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function Ml(e){const t=new WeakMap;return{get:function(e){return e.isInterleavedBufferAttribute&&(e=e.data),t.get(e)},remove:function(n){n.isInterleavedBufferAttribute&&(n=n.data);const a=t.get(n);a&&(e.deleteBuffer(a.buffer),t.delete(n))},update:function(n,a){if(n.isInterleavedBufferAttribute&&(n=n.data),n.isGLBufferAttribute){const e=t.get(n);return void((!e||e.version<n.version)&&t.set(n,{buffer:n.buffer,type:n.type,bytesPerElement:n.elementSize,version:n.version}))}const i=t.get(n);if(void 0===i)t.set(n,function(t,n){const a=t.array,i=t.usage,r=a.byteLength,s=e.createBuffer();let o;if(e.bindBuffer(n,s),e.bufferData(n,a,i),t.onUploadCallback(),a instanceof Float32Array)o=e.FLOAT;else if("undefined"!=typeof Float16Array&&a instanceof Float16Array)o=e.HALF_FLOAT;else if(a instanceof Uint16Array)o=t.isFloat16BufferAttribute?e.HALF_FLOAT:e.UNSIGNED_SHORT;else if(a instanceof Int16Array)o=e.SHORT;else if(a instanceof Uint32Array)o=e.UNSIGNED_INT;else if(a instanceof Int32Array)o=e.INT;else if(a instanceof Int8Array)o=e.BYTE;else if(a instanceof Uint8Array)o=e.UNSIGNED_BYTE;else{if(!(a instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+a);o=e.UNSIGNED_BYTE}return{buffer:s,type:o,bytesPerElement:a.BYTES_PER_ELEMENT,version:t.version,size:r}}(n,a));else if(i.version<n.version){if(i.size!==n.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(t,n,a){const i=n.array,r=n.updateRanges;if(e.bindBuffer(a,t),0===r.length)e.bufferSubData(a,0,i);else{r.sort((e,t)=>e.start-t.start);let t=0;for(let e=1;e<r.length;e++){const n=r[t],a=r[e];a.start<=n.start+n.count+1?n.count=Math.max(n.count,a.start+a.count-n.start):(++t,r[t]=a)}r.length=t+1;for(let t=0,n=r.length;t<n;t++){const n=r[t];e.bufferSubData(a,n.start*i.BYTES_PER_ELEMENT,i,n.start,n.count)}n.clearUpdateRanges()}n.onUploadCallback()}(i.buffer,n,a),i.version=n.version}}}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:e}})),"undefined"!=typeof window&&(window.__THREE__?At("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=e);const _l={alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",alphahash_pars_fragment:"#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",batching_pars_vertex:"#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",batching_vertex:"#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",begin_vertex:"vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",colorspace_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment:"vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"uniform sampler2D dfgLUT;\nstruct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 uv = vec2( roughness, dotNV );\n\treturn texture2D( dfgLUT, uv ).rg;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nvec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );\n\tvec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );\n\tvec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;\n\tvec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;\n\tfloat Ess_V = dfgV.x + dfgV.y;\n\tfloat Ess_L = dfgL.x + dfgL.y;\n\tfloat Ems_V = 1.0 - Ess_V;\n\tfloat Ems_L = 1.0 - Ess_L;\n\tvec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;\n\tvec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );\n\tfloat compensationFactor = Ems_V * Ems_L;\n\tvec3 multiScatter = Fms * compensationFactor;\n\treturn singleScatter + multiScatter;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphinstance_vertex:"#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",opaque_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\tfloat depth = unpackRGBAToDepth( texture2D( depths, uv ) );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\treturn step( depth, compare );\n\t\t#else\n\t\t\treturn step( compare, depth );\n\t\t#endif\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow( sampler2D shadow, vec2 uv, float compare ) {\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\tfloat hard_shadow = step( distribution.x, compare );\n\t\t#else\n\t\t\tfloat hard_shadow = step( compare, distribution.x );\n\t\t#endif\n\t\tif ( hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",depth_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\tfloat fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n\t#else\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n\t#endif\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"},Al={common:{diffuse:{value:new Ia(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Ht},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Ht}},envmap:{envMap:{value:null},envMapRotation:{value:new Ht},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},dfgLUT:{value:null}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Ht}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Ht}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Ht},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Ht},normalScale:{value:new Vt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Ht},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Ht}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Ht}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Ht}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ia(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ia(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0},uvTransform:{value:new Ht}},sprite:{diffuse:{value:new Ia(16777215)},opacity:{value:1},center:{value:new Vt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Ht},alphaMap:{value:null},alphaMapTransform:{value:new Ht},alphaTest:{value:0}}},Cl={basic:{uniforms:gi([Al.common,Al.specularmap,Al.envmap,Al.aomap,Al.lightmap,Al.fog]),vertexShader:_l.meshbasic_vert,fragmentShader:_l.meshbasic_frag},lambert:{uniforms:gi([Al.common,Al.specularmap,Al.envmap,Al.aomap,Al.lightmap,Al.emissivemap,Al.bumpmap,Al.normalmap,Al.displacementmap,Al.fog,Al.lights,{emissive:{value:new Ia(0)}}]),vertexShader:_l.meshlambert_vert,fragmentShader:_l.meshlambert_frag},phong:{uniforms:gi([Al.common,Al.specularmap,Al.envmap,Al.aomap,Al.lightmap,Al.emissivemap,Al.bumpmap,Al.normalmap,Al.displacementmap,Al.fog,Al.lights,{emissive:{value:new Ia(0)},specular:{value:new Ia(1118481)},shininess:{value:30}}]),vertexShader:_l.meshphong_vert,fragmentShader:_l.meshphong_frag},standard:{uniforms:gi([Al.common,Al.envmap,Al.aomap,Al.lightmap,Al.emissivemap,Al.bumpmap,Al.normalmap,Al.displacementmap,Al.roughnessmap,Al.metalnessmap,Al.fog,Al.lights,{emissive:{value:new Ia(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:_l.meshphysical_vert,fragmentShader:_l.meshphysical_frag},toon:{uniforms:gi([Al.common,Al.aomap,Al.lightmap,Al.emissivemap,Al.bumpmap,Al.normalmap,Al.displacementmap,Al.gradientmap,Al.fog,Al.lights,{emissive:{value:new Ia(0)}}]),vertexShader:_l.meshtoon_vert,fragmentShader:_l.meshtoon_frag},matcap:{uniforms:gi([Al.common,Al.bumpmap,Al.normalmap,Al.displacementmap,Al.fog,{matcap:{value:null}}]),vertexShader:_l.meshmatcap_vert,fragmentShader:_l.meshmatcap_frag},points:{uniforms:gi([Al.points,Al.fog]),vertexShader:_l.points_vert,fragmentShader:_l.points_frag},dashed:{uniforms:gi([Al.common,Al.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:_l.linedashed_vert,fragmentShader:_l.linedashed_frag},depth:{uniforms:gi([Al.common,Al.displacementmap]),vertexShader:_l.depth_vert,fragmentShader:_l.depth_frag},normal:{uniforms:gi([Al.common,Al.bumpmap,Al.normalmap,Al.displacementmap,{opacity:{value:1}}]),vertexShader:_l.meshnormal_vert,fragmentShader:_l.meshnormal_frag},sprite:{uniforms:gi([Al.sprite,Al.fog]),vertexShader:_l.sprite_vert,fragmentShader:_l.sprite_frag},background:{uniforms:{uvTransform:{value:new Ht},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:_l.background_vert,fragmentShader:_l.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Ht}},vertexShader:_l.backgroundCube_vert,fragmentShader:_l.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:_l.cube_vert,fragmentShader:_l.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:_l.equirect_vert,fragmentShader:_l.equirect_frag},distanceRGBA:{uniforms:gi([Al.common,Al.displacementmap,{referencePosition:{value:new Gt},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:_l.distanceRGBA_vert,fragmentShader:_l.distanceRGBA_frag},shadow:{uniforms:gi([Al.lights,Al.fog,{color:{value:new Ia(0)},opacity:{value:1}}]),vertexShader:_l.shadow_vert,fragmentShader:_l.shadow_frag}};Cl.physical={uniforms:gi([Cl.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Ht},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Ht},clearcoatNormalScale:{value:new Vt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Ht},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Ht},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Ht},sheen:{value:0},sheenColor:{value:new Ia(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Ht},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Ht},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Ht},transmissionSamplerSize:{value:new Vt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Ht},attenuationDistance:{value:0},attenuationColor:{value:new Ia(0)},specularColor:{value:new Ia(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Ht},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Ht},anisotropyVector:{value:new Vt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Ht}}]),vertexShader:_l.meshphysical_vert,fragmentShader:_l.meshphysical_frag};const Tl={r:0,b:0,g:0},Pl=new Qn,Dl=new Vn;function Ol(e,t,n,a,i,r,s){const o=new Ia(0);let l,c,h=!0===r?0:1,d=null,u=0,p=null;function m(e){let a=!0===e.isScene?e.background:null;return a&&a.isTexture&&(a=(e.backgroundBlurriness>0?n:t).get(a)),a}function f(t,n){t.getRGB(Tl,yi(e)),a.buffers.color.setClear(Tl.r,Tl.g,Tl.b,n,s)}return{getClearColor:function(){return o},setClearColor:function(e,t=1){o.set(e),h=t,f(o,h)},getClearAlpha:function(){return h},setClearAlpha:function(e){h=e,f(o,h)},render:function(t){let n=!1;const i=m(t);null===i?f(o,h):i&&i.isColor&&(f(i,1),n=!0);const r=e.xr.getEnvironmentBlendMode();"additive"===r?a.buffers.color.setClear(0,0,0,1,s):"alpha-blend"===r&&a.buffers.color.setClear(0,0,0,0,s),(e.autoClear||n)&&(a.buffers.depth.setTest(!0),a.buffers.depth.setMask(!0),a.buffers.color.setMask(!0),e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil))},addToRenderList:function(t,n){const a=m(n);a&&(a.isCubeTexture||a.mapping===L)?(void 0===c&&(c=new ui(new mi(1,1,1),new bi({name:"BackgroundCubeMaterial",uniforms:fi(Cl.backgroundCube.uniforms),vertexShader:Cl.backgroundCube.vertexShader,fragmentShader:Cl.backgroundCube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),Pl.copy(n.backgroundRotation),Pl.x*=-1,Pl.y*=-1,Pl.z*=-1,a.isCubeTexture&&!1===a.isRenderTargetTexture&&(Pl.y*=-1,Pl.z*=-1),c.material.uniforms.envMap.value=a,c.material.uniforms.flipEnvMap.value=a.isCubeTexture&&!1===a.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=n.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,c.material.uniforms.backgroundRotation.value.setFromMatrix4(Dl.makeRotationFromEuler(Pl)),c.material.toneMapped=Qt.getTransfer(a.colorSpace)!==rt,d===a&&u===a.version&&p===e.toneMapping||(c.material.needsUpdate=!0,d=a,u=a.version,p=e.toneMapping),c.layers.enableAll(),t.unshift(c,c.geometry,c.material,0,0,null)):a&&a.isTexture&&(void 0===l&&(l=new ui(new ao(2,2),new bi({name:"BackgroundMaterial",uniforms:fi(Cl.background.uniforms),vertexShader:Cl.background.vertexShader,fragmentShader:Cl.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=a,l.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,l.material.toneMapped=Qt.getTransfer(a.colorSpace)!==rt,!0===a.matrixAutoUpdate&&a.updateMatrix(),l.material.uniforms.uvTransform.value.copy(a.matrix),d===a&&u===a.version&&p===e.toneMapping||(l.material.needsUpdate=!0,d=a,u=a.version,p=e.toneMapping),l.layers.enableAll(),t.unshift(l,l.geometry,l.material,0,0,null))},dispose:function(){void 0!==c&&(c.geometry.dispose(),c.material.dispose(),c=void 0),void 0!==l&&(l.geometry.dispose(),l.material.dispose(),l=void 0)}}}function El(e,t){const n=e.getParameter(e.MAX_VERTEX_ATTRIBS),a={},i=c(null);let r=i,s=!1;function o(t){return e.bindVertexArray(t)}function l(t){return e.deleteVertexArray(t)}function c(e){const t=[],a=[],i=[];for(let e=0;e<n;e++)t[e]=0,a[e]=0,i[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:a,attributeDivisors:i,object:e,attributes:{},index:null}}function h(){const e=r.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function d(e){u(e,0)}function u(t,n){const a=r.newAttributes,i=r.enabledAttributes,s=r.attributeDivisors;a[t]=1,0===i[t]&&(e.enableVertexAttribArray(t),i[t]=1),s[t]!==n&&(e.vertexAttribDivisor(t,n),s[t]=n)}function p(){const t=r.newAttributes,n=r.enabledAttributes;for(let a=0,i=n.length;a<i;a++)n[a]!==t[a]&&(e.disableVertexAttribArray(a),n[a]=0)}function m(t,n,a,i,r,s,o){!0===o?e.vertexAttribIPointer(t,n,a,r,s):e.vertexAttribPointer(t,n,a,i,r,s)}function f(){g(),s=!0,r!==i&&(r=i,o(r.object))}function g(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:function(n,i,l,f,g){let y=!1;const v=function(t,n,i){const r=!0===i.wireframe;let s=a[t.id];void 0===s&&(s={},a[t.id]=s);let o=s[n.id];void 0===o&&(o={},s[n.id]=o);let l=o[r];return void 0===l&&(l=c(e.createVertexArray()),o[r]=l),l}(f,l,i);r!==v&&(r=v,o(r.object)),y=function(e,t,n,a){const i=r.attributes,s=t.attributes;let o=0;const l=n.getAttributes();for(const t in l)if(l[t].location>=0){const n=i[t];let a=s[t];if(void 0===a&&("instanceMatrix"===t&&e.instanceMatrix&&(a=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(a=e.instanceColor)),void 0===n)return!0;if(n.attribute!==a)return!0;if(a&&n.data!==a.data)return!0;o++}return r.attributesNum!==o||r.index!==a}(n,f,l,g),y&&function(e,t,n,a){const i={},s=t.attributes;let o=0;const l=n.getAttributes();for(const t in l)if(l[t].location>=0){let n=s[t];void 0===n&&("instanceMatrix"===t&&e.instanceMatrix&&(n=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(n=e.instanceColor));const a={};a.attribute=n,n&&n.data&&(a.data=n.data),i[t]=a,o++}r.attributes=i,r.attributesNum=o,r.index=a}(n,f,l,g),null!==g&&t.update(g,e.ELEMENT_ARRAY_BUFFER),(y||s)&&(s=!1,function(n,a,i,r){h();const s=r.attributes,o=i.getAttributes(),l=a.defaultAttributeValues;for(const a in o){const i=o[a];if(i.location>=0){let o=s[a];if(void 0===o&&("instanceMatrix"===a&&n.instanceMatrix&&(o=n.instanceMatrix),"instanceColor"===a&&n.instanceColor&&(o=n.instanceColor)),void 0!==o){const a=o.normalized,s=o.itemSize,l=t.get(o);if(void 0===l)continue;const c=l.buffer,h=l.type,p=l.bytesPerElement,f=h===e.INT||h===e.UNSIGNED_INT||o.gpuType===Z;if(o.isInterleavedBufferAttribute){const t=o.data,l=t.stride,g=o.offset;if(t.isInstancedInterleavedBuffer){for(let e=0;e<i.locationSize;e++)u(i.location+e,t.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===r._maxInstanceCount&&(r._maxInstanceCount=t.meshPerAttribute*t.count)}else for(let e=0;e<i.locationSize;e++)d(i.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<i.locationSize;e++)m(i.location+e,s/i.locationSize,h,a,l*p,(g+s/i.locationSize*e)*p,f)}else{if(o.isInstancedBufferAttribute){for(let e=0;e<i.locationSize;e++)u(i.location+e,o.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===r._maxInstanceCount&&(r._maxInstanceCount=o.meshPerAttribute*o.count)}else for(let e=0;e<i.locationSize;e++)d(i.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<i.locationSize;e++)m(i.location+e,s/i.locationSize,h,a,s*p,s/i.locationSize*e*p,f)}}else if(void 0!==l){const t=l[a];if(void 0!==t)switch(t.length){case 2:e.vertexAttrib2fv(i.location,t);break;case 3:e.vertexAttrib3fv(i.location,t);break;case 4:e.vertexAttrib4fv(i.location,t);break;default:e.vertexAttrib1fv(i.location,t)}}}}p()}(n,i,l,f),null!==g&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.get(g).buffer))},reset:f,resetDefaultState:g,dispose:function(){f();for(const e in a){const t=a[e];for(const e in t){const n=t[e];for(const e in n)l(n[e].object),delete n[e];delete t[e]}delete a[e]}},releaseStatesOfGeometry:function(e){if(void 0===a[e.id])return;const t=a[e.id];for(const e in t){const n=t[e];for(const e in n)l(n[e].object),delete n[e];delete t[e]}delete a[e.id]},releaseStatesOfProgram:function(e){for(const t in a){const n=a[t];if(void 0===n[e.id])continue;const i=n[e.id];for(const e in i)l(i[e].object),delete i[e];delete n[e.id]}},initAttributes:h,enableAttribute:d,disableUnusedAttributes:p}}function Il(e,t,n){let a;function i(t,i,r){0!==r&&(e.drawArraysInstanced(a,t,i,r),n.update(i,a,r))}this.setMode=function(e){a=e},this.render=function(t,i){e.drawArrays(a,t,i),n.update(i,a,1)},this.renderInstances=i,this.renderMultiDraw=function(e,i,r){if(0===r)return;t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(a,e,0,i,0,r);let s=0;for(let e=0;e<r;e++)s+=i[e];n.update(s,a,1)},this.renderMultiDrawInstances=function(e,r,s,o){if(0===s)return;const l=t.get("WEBGL_multi_draw");if(null===l)for(let t=0;t<e.length;t++)i(e[t],r[t],o[t]);else{l.multiDrawArraysInstancedWEBGL(a,e,0,r,0,o,0,s);let t=0;for(let e=0;e<s;e++)t+=r[e]*o[e];n.update(t,a,1)}}}function kl(e,t,n,a){let i;function r(t){if("highp"===t){if(e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let s=void 0!==n.precision?n.precision:"highp";const o=r(s);o!==s&&(At("WebGLRenderer:",s,"not supported, using",o,"instead."),s=o);const l=!0===n.logarithmicDepthBuffer,c=!0===n.reversedDepthBuffer&&t.has("EXT_clip_control"),h=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),d=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);return{isWebGL2:!0,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");i=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:r,textureFormatReadable:function(t){return t===ce||a.convert(t)===e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)},textureTypeReadable:function(n){const i=n===te&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(n!==Y&&a.convert(n)!==e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE)&&n!==ee&&!i)},precision:s,logarithmicDepthBuffer:l,reversedDepthBuffer:c,maxTextures:h,maxVertexTextures:d,maxTextureSize:e.getParameter(e.MAX_TEXTURE_SIZE),maxCubemapSize:e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes:e.getParameter(e.MAX_VERTEX_ATTRIBS),maxVertexUniforms:e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings:e.getParameter(e.MAX_VARYING_VECTORS),maxFragmentUniforms:e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures:d>0,maxSamples:e.getParameter(e.MAX_SAMPLES)}}function Rl(e){const t=this;let n=null,a=0,i=!1,r=!1;const s=new Ar,o=new Ht,l={value:null,needsUpdate:!1};function c(e,n,a,i){const r=null!==e?e.length:0;let c=null;if(0!==r){if(c=l.value,!0!==i||null===c){const t=a+4*r,i=n.matrixWorldInverse;o.getNormalMatrix(i),(null===c||c.length<t)&&(c=new Float32Array(t));for(let t=0,n=a;t!==r;++t,n+=4)s.copy(e[t]).applyMatrix4(i,o),s.normal.toArray(c,n),c[n+3]=s.constant}l.value=c,l.needsUpdate=!0}return t.numPlanes=r,t.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t){const n=0!==e.length||t||0!==a||i;return i=t,a=e.length,n},this.beginShadows=function(){r=!0,c(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(e,t){n=c(e,t,0)},this.setState=function(s,o,h){const d=s.clippingPlanes,u=s.clipIntersection,p=s.clipShadows,m=e.get(s);if(!i||null===d||0===d.length||r&&!p)r?c(null):(l.value!==n&&(l.value=n,l.needsUpdate=a>0),t.numPlanes=a,t.numIntersection=0);else{const e=r?0:a,t=4*e;let i=m.clippingState||null;l.value=i,i=c(d,o,t,h);for(let e=0;e!==t;++e)i[e]=n[e];m.clippingState=i,this.numIntersection=u?this.numPlanes:0,this.numPlanes+=e}}}function zl(e){let t=new WeakMap;function n(e,t){return t===F?e.mapping=R:t===B&&(e.mapping=z),e}function a(e){const n=e.target;n.removeEventListener("dispose",a);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const r=i.mapping;if(r===F||r===B){if(t.has(i))return n(t.get(i).texture,i.mapping);{const r=i.image;if(r&&r.height>0){const s=new Pi(r.height);return s.fromEquirectangularTexture(e,i),t.set(i,s),i.addEventListener("dispose",a),n(s.texture,i.mapping)}return null}}}return i},dispose:function(){t=new WeakMap}}}const Fl=[.125,.215,.35,.446,.526,.582],Bl=new nl,Ll=new Ia;let Nl=null,Vl=0,Ul=0,Gl=!1;const Wl=new Gt;class ql{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._backgroundBox=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._blurMaterial=null,this._ggxMaterial=null}fromScene(e,t=0,n=.1,a=100,i={}){const{size:r=256,position:s=Wl}=i;Nl=this._renderer.getRenderTarget(),Vl=this._renderer.getActiveCubeFace(),Ul=this._renderer.getActiveMipmapLevel(),Gl=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(r);const o=this._allocateTargets();return o.depthBuffer=!0,this._sceneToCubeUV(e,n,a,o,s),t>0&&this._blur(o,0,0,t),this._applyPMREM(o),this._cleanup(o),o}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=Yl(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=Xl(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose(),null!==this._backgroundBox&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._ggxMaterial&&this._ggxMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodMeshes.length;e++)this._lodMeshes[e].geometry.dispose()}_cleanup(e){this._renderer.setRenderTarget(Nl,Vl,Ul),this._renderer.xr.enabled=Gl,e.scissorTest=!1,jl(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===R||e.mapping===z?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Nl=this._renderer.getRenderTarget(),Vl=this._renderer.getActiveCubeFace(),Ul=this._renderer.getActiveMipmapLevel(),Gl=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:H,minFilter:H,generateMipmaps:!1,type:te,format:ce,colorSpace:at,depthBuffer:!1},a=Hl(e,t,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Hl(e,t,n);const{_lodMax:a}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=function(e){const t=[],n=[],a=[];let i=e;const r=e-4+1+Fl.length;for(let s=0;s<r;s++){const r=Math.pow(2,i);t.push(r);let o=1/r;s>e-4?o=Fl[s-e+4-1]:0===s&&(o=0),n.push(o);const l=1/(r-2),c=-l,h=1+l,d=[c,c,h,c,h,h,c,c,h,h,c,h],u=6,p=6,m=3,f=2,g=1,y=new Float32Array(m*p*u),v=new Float32Array(f*p*u),b=new Float32Array(g*p*u);for(let e=0;e<u;e++){const t=e%3*2/3-1,n=e>2?0:-1,a=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];y.set(a,m*p*e),v.set(d,f*p*e);const i=[e,e,e,e,e,e];b.set(i,g*p*e)}const w=new ei;w.setAttribute("position",new Wa(y,m)),w.setAttribute("uv",new Wa(v,f)),w.setAttribute("faceIndex",new Wa(b,g)),a.push(new ui(w,null)),i>4&&i--}return{lodMeshes:a,sizeLods:t,sigmas:n}}(a)),this._blurMaterial=function(e,t,n){const a=new Float32Array(20),i=new Gt(0,1,0);return new bi({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:a},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}(a,e,t)}return a}_compileMaterial(e){const t=new ui(new ei,e);this._renderer.compile(t,Bl)}_sceneToCubeUV(e,t,n,a,i){const r=new _i(90,1,t,n),s=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],l=this._renderer,c=l.autoClear,h=l.toneMapping;l.getClearColor(Ll),l.toneMapping=0,l.autoClear=!1,l.state.buffers.depth.getReversed()&&(l.setRenderTarget(a),l.clearDepth(),l.setRenderTarget(null)),null===this._backgroundBox&&(this._backgroundBox=new ui(new mi,new Fa({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1})));const d=this._backgroundBox,u=d.material;let p=!1;const m=e.background;m?m.isColor&&(u.color.copy(m),e.background=null,p=!0):(u.color.copy(Ll),p=!0);for(let t=0;t<6;t++){const n=t%3;0===n?(r.up.set(0,s[t],0),r.position.set(i.x,i.y,i.z),r.lookAt(i.x+o[t],i.y,i.z)):1===n?(r.up.set(0,0,s[t]),r.position.set(i.x,i.y,i.z),r.lookAt(i.x,i.y+o[t],i.z)):(r.up.set(0,s[t],0),r.position.set(i.x,i.y,i.z),r.lookAt(i.x,i.y,i.z+o[t]));const c=this._cubeSize;jl(a,n*c,t>2?c:0,c,c),l.setRenderTarget(a),p&&l.render(d,r),l.render(e,r)}l.toneMapping=h,l.autoClear=c,e.background=m}_textureToCubeUV(e,t){const n=this._renderer,a=e.mapping===R||e.mapping===z;a?(null===this._cubemapMaterial&&(this._cubemapMaterial=Yl()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=Xl());const i=a?this._cubemapMaterial:this._equirectMaterial,r=this._lodMeshes[0];r.material=i,i.uniforms.envMap.value=e;const s=this._cubeSize;jl(t,0,0,3*s,2*s),n.setRenderTarget(t),n.render(r,Bl)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;const a=this._lodMeshes.length;for(let t=1;t<a;t++)this._applyGGXFilter(e,t-1,t);t.autoClear=n}_applyGGXFilter(e,t,n){const a=this._renderer,i=this._pingPongRenderTarget;if(null===this._ggxMaterial){const e=3*Math.max(this._cubeSize,16),t=4*this._cubeSize;this._ggxMaterial=function(e,t,n){return new bi({name:"PMREMGGXConvolution",defines:{GGX_SAMPLES:512,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},roughness:{value:0},mipInt:{value:0}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:'\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform float roughness;\n\t\t\tuniform float mipInt;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t#define PI 3.14159265359\n\n\t\t\t// Van der Corput radical inverse\n\t\t\tfloat radicalInverse_VdC(uint bits) {\n\t\t\t\tbits = (bits << 16u) | (bits >> 16u);\n\t\t\t\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\t\t\t\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\t\t\t\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\t\t\t\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\t\t\t\treturn float(bits) * 2.3283064365386963e-10; // / 0x100000000\n\t\t\t}\n\n\t\t\t// Hammersley sequence\n\t\t\tvec2 hammersley(uint i, uint N) {\n\t\t\t\treturn vec2(float(i) / float(N), radicalInverse_VdC(i));\n\t\t\t}\n\n\t\t\t// GGX VNDF importance sampling (Eric Heitz 2018)\n\t\t\t// "Sampling the GGX Distribution of Visible Normals"\n\t\t\t// https://jcgt.org/published/0007/04/01/\n\t\t\tvec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {\n\t\t\t\tfloat alpha = roughness * roughness;\n\n\t\t\t\t// Section 3.2: Transform view direction to hemisphere configuration\n\t\t\t\tvec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));\n\n\t\t\t\t// Section 4.1: Orthonormal basis\n\t\t\t\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\t\t\t\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 T2 = cross(Vh, T1);\n\n\t\t\t\t// Section 4.2: Parameterization of projected area\n\t\t\t\tfloat r = sqrt(Xi.x);\n\t\t\t\tfloat phi = 2.0 * PI * Xi.y;\n\t\t\t\tfloat t1 = r * cos(phi);\n\t\t\t\tfloat t2 = r * sin(phi);\n\t\t\t\tfloat s = 0.5 * (1.0 + Vh.z);\n\t\t\t\tt2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n\t\t\t\t// Section 4.3: Reprojection onto hemisphere\n\t\t\t\tvec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n\t\t\t\t// Section 3.4: Transform back to ellipsoid configuration\n\t\t\t\treturn normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));\n\t\t\t}\n\n\t\t\tvoid main() {\n\t\t\t\tvec3 N = normalize(vOutputDirection);\n\t\t\t\tvec3 V = N; // Assume view direction equals normal for pre-filtering\n\n\t\t\t\tvec3 prefilteredColor = vec3(0.0);\n\t\t\t\tfloat totalWeight = 0.0;\n\n\t\t\t\t// For very low roughness, just sample the environment directly\n\t\t\t\tif (roughness < 0.001) {\n\t\t\t\t\tgl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Tangent space basis for VNDF sampling\n\t\t\t\tvec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 tangent = normalize(cross(up, N));\n\t\t\t\tvec3 bitangent = cross(N, tangent);\n\n\t\t\t\tfor(uint i = 0u; i < uint(GGX_SAMPLES); i++) {\n\t\t\t\t\tvec2 Xi = hammersley(i, uint(GGX_SAMPLES));\n\n\t\t\t\t\t// For PMREM, V = N, so in tangent space V is always (0, 0, 1)\n\t\t\t\t\tvec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);\n\n\t\t\t\t\t// Transform H back to world space\n\t\t\t\t\tvec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);\n\t\t\t\t\tvec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n\t\t\t\t\tfloat NdotL = max(dot(N, L), 0.0);\n\n\t\t\t\t\tif(NdotL > 0.0) {\n\t\t\t\t\t\t// Sample environment at fixed mip level\n\t\t\t\t\t\t// VNDF importance sampling handles the distribution filtering\n\t\t\t\t\t\tvec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);\n\n\t\t\t\t\t\t// Weight by NdotL for the split-sum approximation\n\t\t\t\t\t\t// VNDF PDF naturally accounts for the visible microfacet distribution\n\t\t\t\t\t\tprefilteredColor += sampleColor * NdotL;\n\t\t\t\t\t\ttotalWeight += NdotL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (totalWeight > 0.0) {\n\t\t\t\t\tprefilteredColor = prefilteredColor / totalWeight;\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = vec4(prefilteredColor, 1.0);\n\t\t\t}\n\t\t',blending:0,depthTest:!1,depthWrite:!1})}(this._lodMax,e,t)}const r=this._ggxMaterial,s=this._lodMeshes[n];s.material=r;const o=r.uniforms,l=n/(this._lodMeshes.length-1),c=t/(this._lodMeshes.length-1),h=Math.sqrt(l*l-c*c)*(.05+.95*l),{_lodMax:d}=this,u=this._sizeLods[n],p=3*u*(n>d-4?n-d+4:0),m=4*(this._cubeSize-u);o.envMap.value=e.texture,o.roughness.value=h,o.mipInt.value=d-t,jl(i,p,m,3*u,2*u),a.setRenderTarget(i),a.render(s,Bl),o.envMap.value=i.texture,o.roughness.value=0,o.mipInt.value=d-n,jl(e,p,m,3*u,2*u),a.setRenderTarget(e),a.render(s,Bl)}_blur(e,t,n,a,i){const r=this._pingPongRenderTarget;this._halfBlur(e,r,t,n,a,"latitudinal",i),this._halfBlur(r,e,n,n,a,"longitudinal",i)}_halfBlur(e,t,n,a,i,r,s){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==r&&"longitudinal"!==r&&Ct("blur direction must be either latitudinal or longitudinal!");const c=this._lodMeshes[a];c.material=l;const h=l.uniforms,d=this._sizeLods[n]-1,u=isFinite(i)?Math.PI/(2*d):2*Math.PI/39,p=i/u,m=isFinite(i)?1+Math.floor(3*p):20;m>20&&At(`sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);const f=[];let g=0;for(let e=0;e<20;++e){const t=e/p,n=Math.exp(-t*t/2);f.push(n),0===e?g+=n:e<m&&(g+=2*n)}for(let e=0;e<f.length;e++)f[e]=f[e]/g;h.envMap.value=e.texture,h.samples.value=m,h.weights.value=f,h.latitudinal.value="latitudinal"===r,s&&(h.poleAxis.value=s);const{_lodMax:y}=this;h.dTheta.value=u,h.mipInt.value=y-n;const v=this._sizeLods[a];jl(t,3*v*(a>y-4?a-y+4:0),4*(this._cubeSize-v),3*v,2*v),o.setRenderTarget(t),o.render(c,Bl)}}function Hl(e,t,n){const a=new hn(e,t,n);return a.texture.mapping=L,a.texture.name="PMREM.cubeUv",a.scissorTest=!0,a}function jl(e,t,n,a,i){e.viewport.set(t,n,a,i),e.scissor.set(t,n,a,i)}function Xl(){return new bi({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function Yl(){return new bi({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function $l(e){let t=new WeakMap,n=null;function a(e){const n=e.target;n.removeEventListener("dispose",a);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const r=i.mapping,s=r===F||r===B,o=r===R||r===z;if(s||o){let r=t.get(i);const l=void 0!==r?r.texture.pmremVersion:0;if(i.isRenderTargetTexture&&i.pmremVersion!==l)return null===n&&(n=new ql(e)),r=s?n.fromEquirectangular(i,r):n.fromCubemap(i,r),r.texture.pmremVersion=i.pmremVersion,t.set(i,r),r.texture;if(void 0!==r)return r.texture;{const l=i.image;return s&&l&&l.height>0||o&&l&&function(e){let t=0;for(let n=0;n<6;n++)void 0!==e[n]&&t++;return 6===t}(l)?(null===n&&(n=new ql(e)),r=s?n.fromEquirectangular(i):n.fromCubemap(i),r.texture.pmremVersion=i.pmremVersion,t.set(i,r),i.addEventListener("dispose",a),r.texture):null}}}return i},dispose:function(){t=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function Ql(e){const t={};function n(n){if(void 0!==t[n])return t[n];const a=e.getExtension(n);return t[n]=a,a}return{has:function(e){return null!==n(e)},init:function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")},get:function(e){const t=n(e);return null===t&&Tt("WebGLRenderer: "+e+" extension not supported."),t}}}function Kl(e,t,n,a){const i={},r=new WeakMap;function s(e){const o=e.target;null!==o.index&&t.remove(o.index);for(const e in o.attributes)t.remove(o.attributes[e]);o.removeEventListener("dispose",s),delete i[o.id];const l=r.get(o);l&&(t.remove(l),r.delete(o)),a.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(e){const n=[],a=e.index,i=e.attributes.position;let s=0;if(null!==a){const e=a.array;s=a.version;for(let t=0,a=e.length;t<a;t+=3){const a=e[t+0],i=e[t+1],r=e[t+2];n.push(a,i,i,r,r,a)}}else{if(void 0===i)return;{const e=i.array;s=i.version;for(let t=0,a=e.length/3-1;t<a;t+=3){const e=t+0,a=t+1,i=t+2;n.push(e,a,a,i,i,e)}}}const o=new(wt(n)?Ha:qa)(n,1);o.version=s;const l=r.get(e);l&&t.remove(l),r.set(e,o)}return{get:function(e,t){return!0===i[t.id]||(t.addEventListener("dispose",s),i[t.id]=!0,n.memory.geometries++),t},update:function(n){const a=n.attributes;for(const n in a)t.update(a[n],e.ARRAY_BUFFER)},getWireframeAttribute:function(e){const t=r.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&o(e)}else o(e);return r.get(e)}}}function Zl(e,t,n){let a,i,r;function s(t,s,o){0!==o&&(e.drawElementsInstanced(a,s,i,t*r,o),n.update(s,a,o))}this.setMode=function(e){a=e},this.setIndex=function(e){i=e.type,r=e.bytesPerElement},this.render=function(t,s){e.drawElements(a,s,i,t*r),n.update(s,a,1)},this.renderInstances=s,this.renderMultiDraw=function(e,r,s){if(0===s)return;t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(a,r,0,i,e,0,s);let o=0;for(let e=0;e<s;e++)o+=r[e];n.update(o,a,1)},this.renderMultiDrawInstances=function(e,o,l,c){if(0===l)return;const h=t.get("WEBGL_multi_draw");if(null===h)for(let t=0;t<e.length;t++)s(e[t]/r,o[t],c[t]);else{h.multiDrawElementsInstancedWEBGL(a,o,0,i,e,0,c,0,l);let t=0;for(let e=0;e<l;e++)t+=o[e]*c[e];n.update(t,a,1)}}}function Jl(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(n,a,i){switch(t.calls++,a){case e.TRIANGLES:t.triangles+=i*(n/3);break;case e.LINES:t.lines+=i*(n/2);break;case e.LINE_STRIP:t.lines+=i*(n-1);break;case e.LINE_LOOP:t.lines+=i*n;break;case e.POINTS:t.points+=i*n;break;default:Ct("WebGLInfo: Unknown draw mode:",a)}}}}function ec(e,t,n){const a=new WeakMap,i=new ln;return{update:function(r,s,o){const l=r.morphTargetInfluences,c=s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color,h=void 0!==c?c.length:0;let d=a.get(s);if(void 0===d||d.count!==h){void 0!==d&&d.texture.dispose();const u=void 0!==s.morphAttributes.position,p=void 0!==s.morphAttributes.normal,m=void 0!==s.morphAttributes.color,f=s.morphAttributes.position||[],g=s.morphAttributes.normal||[],y=s.morphAttributes.color||[];let v=0;!0===u&&(v=1),!0===p&&(v=2),!0===m&&(v=3);let b=s.attributes.position.count*v,w=1;b>t.maxTextureSize&&(w=Math.ceil(b/t.maxTextureSize),b=t.maxTextureSize);const x=new Float32Array(b*w*4*h),S=new dn(x,b,w,h);S.type=ee,S.needsUpdate=!0;const M=4*v;for(let A=0;A<h;A++){const C=f[A],T=g[A],P=y[A],D=b*w*4*A;for(let O=0;O<C.count;O++){const E=O*M;!0===u&&(i.fromBufferAttribute(C,O),x[D+E+0]=i.x,x[D+E+1]=i.y,x[D+E+2]=i.z,x[D+E+3]=0),!0===p&&(i.fromBufferAttribute(T,O),x[D+E+4]=i.x,x[D+E+5]=i.y,x[D+E+6]=i.z,x[D+E+7]=0),!0===m&&(i.fromBufferAttribute(P,O),x[D+E+8]=i.x,x[D+E+9]=i.y,x[D+E+10]=i.z,x[D+E+11]=4===P.itemSize?i.w:1)}}function _(){S.dispose(),a.delete(s),s.removeEventListener("dispose",_)}d={count:h,texture:S,size:new Vt(b,w)},a.set(s,d),s.addEventListener("dispose",_)}if(!0===r.isInstancedMesh&&null!==r.morphTexture)o.getUniforms().setValue(e,"morphTexture",r.morphTexture,n);else{let I=0;for(let R=0;R<l.length;R++)I+=l[R];const k=s.morphTargetsRelative?1:1-I;o.getUniforms().setValue(e,"morphTargetBaseInfluence",k),o.getUniforms().setValue(e,"morphTargetInfluences",l)}o.getUniforms().setValue(e,"morphTargetsTexture",d.texture,n),o.getUniforms().setValue(e,"morphTargetsTextureSize",d.size)}}}function tc(e,t,n,a){let i=new WeakMap;function r(e){const t=e.target;t.removeEventListener("dispose",r),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}return{update:function(s){const o=a.render.frame,l=s.geometry,c=t.get(s,l);if(i.get(c)!==o&&(t.update(c),i.set(c,o)),s.isInstancedMesh&&(!1===s.hasEventListener("dispose",r)&&s.addEventListener("dispose",r),i.get(s)!==o&&(n.update(s.instanceMatrix,e.ARRAY_BUFFER),null!==s.instanceColor&&n.update(s.instanceColor,e.ARRAY_BUFFER),i.set(s,o))),s.isSkinnedMesh){const e=s.skeleton;i.get(e)!==o&&(e.update(),i.set(e,o))}return c},dispose:function(){i=new WeakMap}}}const nc=new on,ac=new Zr(1,1),ic=new dn,rc=new un,sc=new Ti,oc=[],lc=[],cc=new Float32Array(16),hc=new Float32Array(9),dc=new Float32Array(4);function uc(e,t,n){const a=e[0];if(a<=0||a>0)return e;const i=t*n;let r=oc[i];if(void 0===r&&(r=new Float32Array(i),oc[i]=r),0!==t){a.toArray(r,0);for(let a=1,i=0;a!==t;++a)i+=n,e[a].toArray(r,i)}return r}function pc(e,t){if(e.length!==t.length)return!1;for(let n=0,a=e.length;n<a;n++)if(e[n]!==t[n])return!1;return!0}function mc(e,t){for(let n=0,a=t.length;n<a;n++)e[n]=t[n]}function fc(e,t){let n=lc[t];void 0===n&&(n=new Int32Array(t),lc[t]=n);for(let a=0;a!==t;++a)n[a]=e.allocateTextureUnit();return n}function gc(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function yc(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(pc(n,t))return;e.uniform2fv(this.addr,t),mc(n,t)}}function vc(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(pc(n,t))return;e.uniform3fv(this.addr,t),mc(n,t)}}function bc(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(pc(n,t))return;e.uniform4fv(this.addr,t),mc(n,t)}}function wc(e,t){const n=this.cache,a=t.elements;if(void 0===a){if(pc(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),mc(n,t)}else{if(pc(n,a))return;dc.set(a),e.uniformMatrix2fv(this.addr,!1,dc),mc(n,a)}}function xc(e,t){const n=this.cache,a=t.elements;if(void 0===a){if(pc(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),mc(n,t)}else{if(pc(n,a))return;hc.set(a),e.uniformMatrix3fv(this.addr,!1,hc),mc(n,a)}}function Sc(e,t){const n=this.cache,a=t.elements;if(void 0===a){if(pc(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),mc(n,t)}else{if(pc(n,a))return;cc.set(a),e.uniformMatrix4fv(this.addr,!1,cc),mc(n,a)}}function Mc(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function _c(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2i(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(pc(n,t))return;e.uniform2iv(this.addr,t),mc(n,t)}}function Ac(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3i(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else{if(pc(n,t))return;e.uniform3iv(this.addr,t),mc(n,t)}}function Cc(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4i(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(pc(n,t))return;e.uniform4iv(this.addr,t),mc(n,t)}}function Tc(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function Pc(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2ui(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(pc(n,t))return;e.uniform2uiv(this.addr,t),mc(n,t)}}function Dc(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3ui(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else{if(pc(n,t))return;e.uniform3uiv(this.addr,t),mc(n,t)}}function Oc(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4ui(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(pc(n,t))return;e.uniform4uiv(this.addr,t),mc(n,t)}}function Ec(e,t,n){const a=this.cache,i=n.allocateTextureUnit();let r;a[0]!==i&&(e.uniform1i(this.addr,i),a[0]=i),this.type===e.SAMPLER_2D_SHADOW?(ac.compareFunction=515,r=ac):r=nc,n.setTexture2D(t||r,i)}function Ic(e,t,n){const a=this.cache,i=n.allocateTextureUnit();a[0]!==i&&(e.uniform1i(this.addr,i),a[0]=i),n.setTexture3D(t||rc,i)}function kc(e,t,n){const a=this.cache,i=n.allocateTextureUnit();a[0]!==i&&(e.uniform1i(this.addr,i),a[0]=i),n.setTextureCube(t||sc,i)}function Rc(e,t,n){const a=this.cache,i=n.allocateTextureUnit();a[0]!==i&&(e.uniform1i(this.addr,i),a[0]=i),n.setTexture2DArray(t||ic,i)}function zc(e,t){e.uniform1fv(this.addr,t)}function Fc(e,t){const n=uc(t,this.size,2);e.uniform2fv(this.addr,n)}function Bc(e,t){const n=uc(t,this.size,3);e.uniform3fv(this.addr,n)}function Lc(e,t){const n=uc(t,this.size,4);e.uniform4fv(this.addr,n)}function Nc(e,t){const n=uc(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function Vc(e,t){const n=uc(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function Uc(e,t){const n=uc(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function Gc(e,t){e.uniform1iv(this.addr,t)}function Wc(e,t){e.uniform2iv(this.addr,t)}function qc(e,t){e.uniform3iv(this.addr,t)}function Hc(e,t){e.uniform4iv(this.addr,t)}function jc(e,t){e.uniform1uiv(this.addr,t)}function Xc(e,t){e.uniform2uiv(this.addr,t)}function Yc(e,t){e.uniform3uiv(this.addr,t)}function $c(e,t){e.uniform4uiv(this.addr,t)}function Qc(e,t,n){const a=this.cache,i=t.length,r=fc(n,i);pc(a,r)||(e.uniform1iv(this.addr,r),mc(a,r));for(let e=0;e!==i;++e)n.setTexture2D(t[e]||nc,r[e])}function Kc(e,t,n){const a=this.cache,i=t.length,r=fc(n,i);pc(a,r)||(e.uniform1iv(this.addr,r),mc(a,r));for(let e=0;e!==i;++e)n.setTexture3D(t[e]||rc,r[e])}function Zc(e,t,n){const a=this.cache,i=t.length,r=fc(n,i);pc(a,r)||(e.uniform1iv(this.addr,r),mc(a,r));for(let e=0;e!==i;++e)n.setTextureCube(t[e]||sc,r[e])}function Jc(e,t,n){const a=this.cache,i=t.length,r=fc(n,i);pc(a,r)||(e.uniform1iv(this.addr,r),mc(a,r));for(let e=0;e!==i;++e)n.setTexture2DArray(t[e]||ic,r[e])}class eh{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.setValue=function(e){switch(e){case 5126:return gc;case 35664:return yc;case 35665:return vc;case 35666:return bc;case 35674:return wc;case 35675:return xc;case 35676:return Sc;case 5124:case 35670:return Mc;case 35667:case 35671:return _c;case 35668:case 35672:return Ac;case 35669:case 35673:return Cc;case 5125:return Tc;case 36294:return Pc;case 36295:return Dc;case 36296:return Oc;case 35678:case 36198:case 36298:case 36306:case 35682:return Ec;case 35679:case 36299:case 36307:return Ic;case 35680:case 36300:case 36308:case 36293:return kc;case 36289:case 36303:case 36311:case 36292:return Rc}}(t.type)}}class th{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=function(e){switch(e){case 5126:return zc;case 35664:return Fc;case 35665:return Bc;case 35666:return Lc;case 35674:return Nc;case 35675:return Vc;case 35676:return Uc;case 5124:case 35670:return Gc;case 35667:case 35671:return Wc;case 35668:case 35672:return qc;case 35669:case 35673:return Hc;case 5125:return jc;case 36294:return Xc;case 36295:return Yc;case 36296:return $c;case 35678:case 36198:case 36298:case 36306:case 35682:return Qc;case 35679:case 36299:case 36307:return Kc;case 35680:case 36300:case 36308:case 36293:return Zc;case 36289:case 36303:case 36311:case 36292:return Jc}}(t.type)}}class nh{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const a=this.seq;for(let i=0,r=a.length;i!==r;++i){const r=a[i];r.setValue(e,t[r.id],n)}}}const ah=/(\w+)(\])?(\[|\.)?/g;function ih(e,t){e.seq.push(t),e.map[t.id]=t}function rh(e,t,n){const a=e.name,i=a.length;for(ah.lastIndex=0;;){const r=ah.exec(a),s=ah.lastIndex;let o=r[1];const l="]"===r[2],c=r[3];if(l&&(o|=0),void 0===c||"["===c&&s+2===i){ih(n,void 0===c?new eh(o,e,t):new th(o,e,t));break}{let e=n.map[o];void 0===e&&(e=new nh(o),ih(n,e)),n=e}}}class sh{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let a=0;a<n;++a){const n=e.getActiveUniform(t,a);rh(n,e.getUniformLocation(t,n.name),this)}}setValue(e,t,n,a){const i=this.map[t];void 0!==i&&i.setValue(e,n,a)}setOptional(e,t,n){const a=t[n];void 0!==a&&this.setValue(e,n,a)}static upload(e,t,n,a){for(let i=0,r=t.length;i!==r;++i){const r=t[i],s=n[r.id];!1!==s.needsUpdate&&r.setValue(e,s.value,a)}}static seqWithValue(e,t){const n=[];for(let a=0,i=e.length;a!==i;++a){const i=e[a];i.id in t&&n.push(i)}return n}}function oh(e,t,n){const a=e.createShader(t);return e.shaderSource(a,n),e.compileShader(a),a}let lh=0;const ch=new Ht;function hh(e,t,n){const a=e.getShaderParameter(t,e.COMPILE_STATUS),i=(e.getShaderInfoLog(t)||"").trim();if(a&&""===i)return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const a=parseInt(r[1]);return n.toUpperCase()+"\n\n"+i+"\n\n"+function(e,t){const n=e.split("\n"),a=[],i=Math.max(t-6,0),r=Math.min(t+6,n.length);for(let e=i;e<r;e++){const i=e+1;a.push(`${i===t?">":" "} ${i}: ${n[e]}`)}return a.join("\n")}(e.getShaderSource(t),a)}return i}function dh(e,t){const n=function(e){Qt._getMatrix(ch,Qt.workingColorSpace,e);const t=`mat3( ${ch.elements.map(e=>e.toFixed(4))} )`;switch(Qt.getTransfer(e)){case it:return[t,"LinearTransferOETF"];case rt:return[t,"sRGBTransferOETF"];default:return At("WebGLProgram: Unsupported color space: ",e),[t,"LinearTransferOETF"]}}(t);return[`vec4 ${e}( vec4 value ) {`,`\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,"}"].join("\n")}function uh(e,t){let n;switch(t){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="Cineon";break;case 4:n="ACESFilmic";break;case 6:n="AgX";break;case 7:n="Neutral";break;case 5:n="Custom";break;default:At("WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}const ph=new Gt;function mh(e){return""!==e}function fh(e,t){const n=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function gh(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const yh=/^[ \t]*#include +<([\w\d./]+)>/gm;function vh(e){return e.replace(yh,wh)}const bh=new Map;function wh(e,t){let n=_l[t];if(void 0===n){const e=bh.get(t);if(void 0===e)throw new Error("Can not resolve #include <"+t+">");n=_l[e],At('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',t,e)}return vh(n)}const xh=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Sh(e){return e.replace(xh,Mh)}function Mh(e,t,n,a){let i="";for(let e=parseInt(t);e<parseInt(n);e++)i+=a.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return i}function _h(e){let t=`precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function Ah(e,t,n,a){const i=e.getContext(),r=n.defines;let s=n.vertexShader,o=n.fragmentShader;const l=function(e){let t="SHADOWMAP_TYPE_BASIC";return 1===e.shadowMapType?t="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?t="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(t="SHADOWMAP_TYPE_VSM"),t}(n),c=function(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case R:case z:t="ENVMAP_TYPE_CUBE";break;case L:t="ENVMAP_TYPE_CUBE_UV"}return t}(n),h=function(e){let t="ENVMAP_MODE_REFLECTION";return e.envMap&&e.envMapMode===z&&(t="ENVMAP_MODE_REFRACTION"),t}(n),d=function(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case 0:t="ENVMAP_BLENDING_MULTIPLY";break;case 1:t="ENVMAP_BLENDING_MIX";break;case 2:t="ENVMAP_BLENDING_ADD"}return t}(n),u=function(e){const t=e.envMapCubeUVHeight;if(null===t)return null;const n=Math.log2(t)-2,a=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:a,maxMip:n}}(n),p=function(e){return[e.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",e.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(mh).join("\n")}(n),m=function(e){const t=[];for(const n in e){const a=e[n];!1!==a&&t.push("#define "+n+" "+a)}return t.join("\n")}(r),f=i.createProgram();let g,y,v=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,m].filter(mh).join("\n"),g.length>0&&(g+="\n"),y=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,m].filter(mh).join("\n"),y.length>0&&(y+="\n")):(g=[_h(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,m,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.batchingColor?"#define USE_BATCHING_COLOR":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.instancingMorph?"#define USE_INSTANCING_MORPH":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",n.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(mh).join("\n"),y=[_h(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,m,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",n.envMap?"#define "+d:"",u?"#define CUBEUV_TEXEL_WIDTH "+u.texelWidth:"",u?"#define CUBEUV_TEXEL_HEIGHT "+u.texelHeight:"",u?"#define CUBEUV_MAX_MIP "+u.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.dispersion?"#define USE_DISPERSION":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor||n.batchingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",n.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",n.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?_l.tonemapping_pars_fragment:"",0!==n.toneMapping?uh("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",_l.colorspace_pars_fragment,dh("linearToOutputTexel",n.outputColorSpace),(Qt.getLuminanceCoefficients(ph),["float luminance( const in vec3 rgb ) {",`\tconst vec3 weights = vec3( ${ph.x.toFixed(4)}, ${ph.y.toFixed(4)}, ${ph.z.toFixed(4)} );`,"\treturn dot( weights, rgb );","}"].join("\n")),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(mh).join("\n")),s=vh(s),s=fh(s,n),s=gh(s,n),o=vh(o),o=fh(o,n),o=gh(o,n),s=Sh(s),o=Sh(o),!0!==n.isRawShaderMaterial&&(v="#version 300 es\n",g=[p,"#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,y=["#define varying in",n.glslVersion===yt?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===yt?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+y);const b=v+g+s,w=v+y+o,x=oh(i,i.VERTEX_SHADER,b),S=oh(i,i.FRAGMENT_SHADER,w);function M(t){if(e.debug.checkShaderErrors){const n=i.getProgramInfoLog(f)||"",a=i.getShaderInfoLog(x)||"",r=i.getShaderInfoLog(S)||"",s=n.trim(),o=a.trim(),l=r.trim();let c=!0,h=!0;if(!1===i.getProgramParameter(f,i.LINK_STATUS))if(c=!1,"function"==typeof e.debug.onShaderError)e.debug.onShaderError(i,f,x,S);else{const e=hh(i,x,"vertex"),n=hh(i,S,"fragment");Ct("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(f,i.VALIDATE_STATUS)+"\n\nMaterial Name: "+t.name+"\nMaterial Type: "+t.type+"\n\nProgram Info Log: "+s+"\n"+e+"\n"+n)}else""!==s?At("WebGLProgram: Program Info Log:",s):""!==o&&""!==l||(h=!1);h&&(t.diagnostics={runnable:c,programLog:s,vertexShader:{log:o,prefix:g},fragmentShader:{log:l,prefix:y}})}i.deleteShader(x),i.deleteShader(S),_=new sh(i,f),A=function(e,t){const n={},a=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES);for(let i=0;i<a;i++){const a=e.getActiveAttrib(t,i),r=a.name;let s=1;a.type===e.FLOAT_MAT2&&(s=2),a.type===e.FLOAT_MAT3&&(s=3),a.type===e.FLOAT_MAT4&&(s=4),n[r]={type:a.type,location:e.getAttribLocation(t,r),locationSize:s}}return n}(i,f)}let _,A;i.attachShader(f,x),i.attachShader(f,S),void 0!==n.index0AttributeName?i.bindAttribLocation(f,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(f,0,"position"),i.linkProgram(f),this.getUniforms=function(){return void 0===_&&M(this),_},this.getAttributes=function(){return void 0===A&&M(this),A};let C=!1===n.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===C&&(C=i.getProgramParameter(f,37297)),C},this.destroy=function(){a.releaseStatesOfProgram(this),i.deleteProgram(f),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=lh++,this.cacheKey=t,this.usedTimes=1,this.program=f,this.vertexShader=x,this.fragmentShader=S,this}let Ch=0;class Th{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,a=this._getShaderStage(t),i=this._getShaderStage(n),r=this._getShaderCacheForMaterial(e);return!1===r.has(a)&&(r.add(a),a.usedTimes++),!1===r.has(i)&&(r.add(i),i.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const e of t)e.usedTimes--,0===e.usedTimes&&this.shaderCache.delete(e.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return void 0===n&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return void 0===n&&(n=new Ph(e),t.set(e,n)),n}}class Ph{constructor(e){this.id=Ch++,this.code=e,this.usedTimes=0}}function Dh(e,t,n,a,i,r,s){const o=new Kn,l=new Th,c=new Set,h=[],d=i.logarithmicDepthBuffer,u=i.vertexTextures;let p=i.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function f(e){return c.add(e),0===e?"uv":`uv${e}`}return{getParameters:function(r,o,h,g,y){const v=g.fog,b=y.geometry,w=r.isMeshStandardMaterial?g.environment:null,x=(r.isMeshStandardMaterial?n:t).get(r.envMap||w),S=x&&x.mapping===L?x.image.height:null,M=m[r.type];null!==r.precision&&(p=i.getMaxPrecision(r.precision),p!==r.precision&&At("WebGLProgram.getParameters:",r.precision,"not supported, using",p,"instead."));const _=b.morphAttributes.position||b.morphAttributes.normal||b.morphAttributes.color,A=void 0!==_?_.length:0;let C,T,P,D,O=0;if(void 0!==b.morphAttributes.position&&(O=1),void 0!==b.morphAttributes.normal&&(O=2),void 0!==b.morphAttributes.color&&(O=3),M){const e=Cl[M];C=e.vertexShader,T=e.fragmentShader}else C=r.vertexShader,T=r.fragmentShader,l.update(r),P=l.getVertexShaderID(r),D=l.getFragmentShaderID(r);const E=e.getRenderTarget(),I=e.state.buffers.depth.getReversed(),k=!0===y.isInstancedMesh,R=!0===y.isBatchedMesh,z=!!r.map,F=!!r.matcap,B=!!x,N=!!r.aoMap,V=!!r.lightMap,U=!!r.bumpMap,G=!!r.normalMap,W=!!r.displacementMap,q=!!r.emissiveMap,H=!!r.metalnessMap,j=!!r.roughnessMap,X=r.anisotropy>0,Y=r.clearcoat>0,$=r.dispersion>0,Q=r.iridescence>0,K=r.sheen>0,Z=r.transmission>0,J=X&&!!r.anisotropyMap,ee=Y&&!!r.clearcoatMap,te=Y&&!!r.clearcoatNormalMap,ne=Y&&!!r.clearcoatRoughnessMap,ae=Q&&!!r.iridescenceMap,ie=Q&&!!r.iridescenceThicknessMap,re=K&&!!r.sheenColorMap,se=K&&!!r.sheenRoughnessMap,oe=!!r.specularMap,le=!!r.specularColorMap,ce=!!r.specularIntensityMap,he=Z&&!!r.transmissionMap,de=Z&&!!r.thicknessMap,ue=!!r.gradientMap,pe=!!r.alphaMap,me=r.alphaTest>0,fe=!!r.alphaHash,ge=!!r.extensions;let ye=0;r.toneMapped&&(null!==E&&!0!==E.isXRRenderTarget||(ye=e.toneMapping));const ve={shaderID:M,shaderType:r.type,shaderName:r.name,vertexShader:C,fragmentShader:T,defines:r.defines,customVertexShaderID:P,customFragmentShaderID:D,isRawShaderMaterial:!0===r.isRawShaderMaterial,glslVersion:r.glslVersion,precision:p,batching:R,batchingColor:R&&null!==y._colorsTexture,instancing:k,instancingColor:k&&null!==y.instanceColor,instancingMorph:k&&null!==y.morphTexture,supportsVertexTextures:u,outputColorSpace:null===E?e.outputColorSpace:!0===E.isXRRenderTarget?E.texture.colorSpace:at,alphaToCoverage:!!r.alphaToCoverage,map:z,matcap:F,envMap:B,envMapMode:B&&x.mapping,envMapCubeUVHeight:S,aoMap:N,lightMap:V,bumpMap:U,normalMap:G,displacementMap:u&&W,emissiveMap:q,normalMapObjectSpace:G&&1===r.normalMapType,normalMapTangentSpace:G&&0===r.normalMapType,metalnessMap:H,roughnessMap:j,anisotropy:X,anisotropyMap:J,clearcoat:Y,clearcoatMap:ee,clearcoatNormalMap:te,clearcoatRoughnessMap:ne,dispersion:$,iridescence:Q,iridescenceMap:ae,iridescenceThicknessMap:ie,sheen:K,sheenColorMap:re,sheenRoughnessMap:se,specularMap:oe,specularColorMap:le,specularIntensityMap:ce,transmission:Z,transmissionMap:he,thicknessMap:de,gradientMap:ue,opaque:!1===r.transparent&&1===r.blending&&!1===r.alphaToCoverage,alphaMap:pe,alphaTest:me,alphaHash:fe,combine:r.combine,mapUv:z&&f(r.map.channel),aoMapUv:N&&f(r.aoMap.channel),lightMapUv:V&&f(r.lightMap.channel),bumpMapUv:U&&f(r.bumpMap.channel),normalMapUv:G&&f(r.normalMap.channel),displacementMapUv:W&&f(r.displacementMap.channel),emissiveMapUv:q&&f(r.emissiveMap.channel),metalnessMapUv:H&&f(r.metalnessMap.channel),roughnessMapUv:j&&f(r.roughnessMap.channel),anisotropyMapUv:J&&f(r.anisotropyMap.channel),clearcoatMapUv:ee&&f(r.clearcoatMap.channel),clearcoatNormalMapUv:te&&f(r.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:ne&&f(r.clearcoatRoughnessMap.channel),iridescenceMapUv:ae&&f(r.iridescenceMap.channel),iridescenceThicknessMapUv:ie&&f(r.iridescenceThicknessMap.channel),sheenColorMapUv:re&&f(r.sheenColorMap.channel),sheenRoughnessMapUv:se&&f(r.sheenRoughnessMap.channel),specularMapUv:oe&&f(r.specularMap.channel),specularColorMapUv:le&&f(r.specularColorMap.channel),specularIntensityMapUv:ce&&f(r.specularIntensityMap.channel),transmissionMapUv:he&&f(r.transmissionMap.channel),thicknessMapUv:de&&f(r.thicknessMap.channel),alphaMapUv:pe&&f(r.alphaMap.channel),vertexTangents:!!b.attributes.tangent&&(G||X),vertexColors:r.vertexColors,vertexAlphas:!0===r.vertexColors&&!!b.attributes.color&&4===b.attributes.color.itemSize,pointsUvs:!0===y.isPoints&&!!b.attributes.uv&&(z||pe),fog:!!v,useFog:!0===r.fog,fogExp2:!!v&&v.isFogExp2,flatShading:!0===r.flatShading&&!1===r.wireframe,sizeAttenuation:!0===r.sizeAttenuation,logarithmicDepthBuffer:d,reversedDepthBuffer:I,skinning:!0===y.isSkinnedMesh,morphTargets:void 0!==b.morphAttributes.position,morphNormals:void 0!==b.morphAttributes.normal,morphColors:void 0!==b.morphAttributes.color,morphTargetsCount:A,morphTextureStride:O,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numSpotLightMaps:o.spotLightMap.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numSpotLightShadowsWithMaps:o.numSpotLightShadowsWithMaps,numLightProbes:o.numLightProbes,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:r.dithering,shadowMapEnabled:e.shadowMap.enabled&&h.length>0,shadowMapType:e.shadowMap.type,toneMapping:ye,decodeVideoTexture:z&&!0===r.map.isVideoTexture&&Qt.getTransfer(r.map.colorSpace)===rt,decodeVideoTextureEmissive:q&&!0===r.emissiveMap.isVideoTexture&&Qt.getTransfer(r.emissiveMap.colorSpace)===rt,premultipliedAlpha:r.premultipliedAlpha,doubleSided:2===r.side,flipSided:1===r.side,useDepthPacking:r.depthPacking>=0,depthPacking:r.depthPacking||0,index0AttributeName:r.index0AttributeName,extensionClipCullDistance:ge&&!0===r.extensions.clipCullDistance&&a.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(ge&&!0===r.extensions.multiDraw||R)&&a.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:a.has("KHR_parallel_shader_compile"),customProgramCacheKey:r.customProgramCacheKey()};return ve.vertexUv1s=c.has(1),ve.vertexUv2s=c.has(2),ve.vertexUv3s=c.has(3),c.clear(),ve},getProgramCacheKey:function(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.customVertexShaderID),n.push(t.customFragmentShaderID)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(function(e,t){e.push(t.precision),e.push(t.outputColorSpace),e.push(t.envMapMode),e.push(t.envMapCubeUVHeight),e.push(t.mapUv),e.push(t.alphaMapUv),e.push(t.lightMapUv),e.push(t.aoMapUv),e.push(t.bumpMapUv),e.push(t.normalMapUv),e.push(t.displacementMapUv),e.push(t.emissiveMapUv),e.push(t.metalnessMapUv),e.push(t.roughnessMapUv),e.push(t.anisotropyMapUv),e.push(t.clearcoatMapUv),e.push(t.clearcoatNormalMapUv),e.push(t.clearcoatRoughnessMapUv),e.push(t.iridescenceMapUv),e.push(t.iridescenceThicknessMapUv),e.push(t.sheenColorMapUv),e.push(t.sheenRoughnessMapUv),e.push(t.specularMapUv),e.push(t.specularColorMapUv),e.push(t.specularIntensityMapUv),e.push(t.transmissionMapUv),e.push(t.thicknessMapUv),e.push(t.combine),e.push(t.fogExp2),e.push(t.sizeAttenuation),e.push(t.morphTargetsCount),e.push(t.morphAttributeCount),e.push(t.numDirLights),e.push(t.numPointLights),e.push(t.numSpotLights),e.push(t.numSpotLightMaps),e.push(t.numHemiLights),e.push(t.numRectAreaLights),e.push(t.numDirLightShadows),e.push(t.numPointLightShadows),e.push(t.numSpotLightShadows),e.push(t.numSpotLightShadowsWithMaps),e.push(t.numLightProbes),e.push(t.shadowMapType),e.push(t.toneMapping),e.push(t.numClippingPlanes),e.push(t.numClipIntersection),e.push(t.depthPacking)}(n,t),function(e,t){o.disableAll(),t.supportsVertexTextures&&o.enable(0),t.instancing&&o.enable(1),t.instancingColor&&o.enable(2),t.instancingMorph&&o.enable(3),t.matcap&&o.enable(4),t.envMap&&o.enable(5),t.normalMapObjectSpace&&o.enable(6),t.normalMapTangentSpace&&o.enable(7),t.clearcoat&&o.enable(8),t.iridescence&&o.enable(9),t.alphaTest&&o.enable(10),t.vertexColors&&o.enable(11),t.vertexAlphas&&o.enable(12),t.vertexUv1s&&o.enable(13),t.vertexUv2s&&o.enable(14),t.vertexUv3s&&o.enable(15),t.vertexTangents&&o.enable(16),t.anisotropy&&o.enable(17),t.alphaHash&&o.enable(18),t.batching&&o.enable(19),t.dispersion&&o.enable(20),t.batchingColor&&o.enable(21),t.gradientMap&&o.enable(22),e.push(o.mask),o.disableAll(),t.fog&&o.enable(0),t.useFog&&o.enable(1),t.flatShading&&o.enable(2),t.logarithmicDepthBuffer&&o.enable(3),t.reversedDepthBuffer&&o.enable(4),t.skinning&&o.enable(5),t.morphTargets&&o.enable(6),t.morphNormals&&o.enable(7),t.morphColors&&o.enable(8),t.premultipliedAlpha&&o.enable(9),t.shadowMapEnabled&&o.enable(10),t.doubleSided&&o.enable(11),t.flipSided&&o.enable(12),t.useDepthPacking&&o.enable(13),t.dithering&&o.enable(14),t.transmission&&o.enable(15),t.sheen&&o.enable(16),t.opaque&&o.enable(17),t.pointsUvs&&o.enable(18),t.decodeVideoTexture&&o.enable(19),t.decodeVideoTextureEmissive&&o.enable(20),t.alphaToCoverage&&o.enable(21),e.push(o.mask)}(n,t),n.push(e.outputColorSpace)),n.push(t.customProgramCacheKey),n.join()},getUniforms:function(e){const t=m[e.type];let n;if(t){const e=Cl[t];n=vi.clone(e.uniforms)}else n=e.uniforms;return n},acquireProgram:function(t,n){let a;for(let e=0,t=h.length;e<t;e++){const t=h[e];if(t.cacheKey===n){a=t,++a.usedTimes;break}}return void 0===a&&(a=new Ah(e,n,t,r),h.push(a)),a},releaseProgram:function(e){if(0===--e.usedTimes){const t=h.indexOf(e);h[t]=h[h.length-1],h.pop(),e.destroy()}},releaseShaderCache:function(e){l.remove(e)},programs:h,dispose:function(){l.dispose()}}}function Oh(){let e=new WeakMap;return{has:function(t){return e.has(t)},get:function(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n},remove:function(t){e.delete(t)},update:function(t,n,a){e.get(t)[n]=a},dispose:function(){e=new WeakMap}}}function Eh(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function Ih(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function kh(){const e=[];let t=0;const n=[],a=[],i=[];function r(n,a,i,r,s,o){let l=e[t];return void 0===l?(l={id:n.id,object:n,geometry:a,material:i,groupOrder:r,renderOrder:n.renderOrder,z:s,group:o},e[t]=l):(l.id=n.id,l.object=n,l.geometry=a,l.material=i,l.groupOrder=r,l.renderOrder=n.renderOrder,l.z=s,l.group=o),t++,l}return{opaque:n,transmissive:a,transparent:i,init:function(){t=0,n.length=0,a.length=0,i.length=0},push:function(e,t,s,o,l,c){const h=r(e,t,s,o,l,c);s.transmission>0?a.push(h):!0===s.transparent?i.push(h):n.push(h)},unshift:function(e,t,s,o,l,c){const h=r(e,t,s,o,l,c);s.transmission>0?a.unshift(h):!0===s.transparent?i.unshift(h):n.unshift(h)},finish:function(){for(let n=t,a=e.length;n<a;n++){const t=e[n];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}},sort:function(e,t){n.length>1&&n.sort(e||Eh),a.length>1&&a.sort(t||Ih),i.length>1&&i.sort(t||Ih)}}}function Rh(){let e=new WeakMap;return{get:function(t,n){const a=e.get(t);let i;return void 0===a?(i=new kh,e.set(t,[i])):n>=a.length?(i=new kh,a.push(i)):i=a[n],i},dispose:function(){e=new WeakMap}}}function zh(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new Gt,color:new Ia};break;case"SpotLight":n={position:new Gt,direction:new Gt,color:new Ia,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Gt,color:new Ia,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Gt,skyColor:new Ia,groundColor:new Ia};break;case"RectAreaLight":n={color:new Ia,position:new Gt,halfWidth:new Gt,halfHeight:new Gt}}return e[t.id]=n,n}}}let Fh=0;function Bh(e,t){return(t.castShadow?2:0)-(e.castShadow?2:0)+(t.map?1:0)-(e.map?1:0)}function Lh(e){const t=new zh,n=function(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":case"SpotLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vt};break;case"PointLight":n={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vt,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=n,n}}}(),a={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let e=0;e<9;e++)a.probe.push(new Gt);const i=new Gt,r=new Vn,s=new Vn;return{setup:function(i){let r=0,s=0,o=0;for(let e=0;e<9;e++)a.probe[e].set(0,0,0);let l=0,c=0,h=0,d=0,u=0,p=0,m=0,f=0,g=0,y=0,v=0;i.sort(Bh);for(let e=0,b=i.length;e<b;e++){const b=i[e],w=b.color,x=b.intensity,S=b.distance,M=b.shadow&&b.shadow.map?b.shadow.map.texture:null;if(b.isAmbientLight)r+=w.r*x,s+=w.g*x,o+=w.b*x;else if(b.isLightProbe){for(let e=0;e<9;e++)a.probe[e].addScaledVector(b.sh.coefficients[e],x);v++}else if(b.isDirectionalLight){const e=t.get(b);if(e.color.copy(b.color).multiplyScalar(b.intensity),b.castShadow){const e=b.shadow,t=n.get(b);t.shadowIntensity=e.intensity,t.shadowBias=e.bias,t.shadowNormalBias=e.normalBias,t.shadowRadius=e.radius,t.shadowMapSize=e.mapSize,a.directionalShadow[l]=t,a.directionalShadowMap[l]=M,a.directionalShadowMatrix[l]=b.shadow.matrix,p++}a.directional[l]=e,l++}else if(b.isSpotLight){const e=t.get(b);e.position.setFromMatrixPosition(b.matrixWorld),e.color.copy(w).multiplyScalar(x),e.distance=S,e.coneCos=Math.cos(b.angle),e.penumbraCos=Math.cos(b.angle*(1-b.penumbra)),e.decay=b.decay,a.spot[h]=e;const i=b.shadow;if(b.map&&(a.spotLightMap[g]=b.map,g++,i.updateMatrices(b),b.castShadow&&y++),a.spotLightMatrix[h]=i.matrix,b.castShadow){const e=n.get(b);e.shadowIntensity=i.intensity,e.shadowBias=i.bias,e.shadowNormalBias=i.normalBias,e.shadowRadius=i.radius,e.shadowMapSize=i.mapSize,a.spotShadow[h]=e,a.spotShadowMap[h]=M,f++}h++}else if(b.isRectAreaLight){const e=t.get(b);e.color.copy(w).multiplyScalar(x),e.halfWidth.set(.5*b.width,0,0),e.halfHeight.set(0,.5*b.height,0),a.rectArea[d]=e,d++}else if(b.isPointLight){const e=t.get(b);if(e.color.copy(b.color).multiplyScalar(b.intensity),e.distance=b.distance,e.decay=b.decay,b.castShadow){const e=b.shadow,t=n.get(b);t.shadowIntensity=e.intensity,t.shadowBias=e.bias,t.shadowNormalBias=e.normalBias,t.shadowRadius=e.radius,t.shadowMapSize=e.mapSize,t.shadowCameraNear=e.camera.near,t.shadowCameraFar=e.camera.far,a.pointShadow[c]=t,a.pointShadowMap[c]=M,a.pointShadowMatrix[c]=b.shadow.matrix,m++}a.point[c]=e,c++}else if(b.isHemisphereLight){const e=t.get(b);e.skyColor.copy(b.color).multiplyScalar(x),e.groundColor.copy(b.groundColor).multiplyScalar(x),a.hemi[u]=e,u++}}d>0&&(!0===e.has("OES_texture_float_linear")?(a.rectAreaLTC1=Al.LTC_FLOAT_1,a.rectAreaLTC2=Al.LTC_FLOAT_2):(a.rectAreaLTC1=Al.LTC_HALF_1,a.rectAreaLTC2=Al.LTC_HALF_2)),a.ambient[0]=r,a.ambient[1]=s,a.ambient[2]=o;const b=a.hash;b.directionalLength===l&&b.pointLength===c&&b.spotLength===h&&b.rectAreaLength===d&&b.hemiLength===u&&b.numDirectionalShadows===p&&b.numPointShadows===m&&b.numSpotShadows===f&&b.numSpotMaps===g&&b.numLightProbes===v||(a.directional.length=l,a.spot.length=h,a.rectArea.length=d,a.point.length=c,a.hemi.length=u,a.directionalShadow.length=p,a.directionalShadowMap.length=p,a.pointShadow.length=m,a.pointShadowMap.length=m,a.spotShadow.length=f,a.spotShadowMap.length=f,a.directionalShadowMatrix.length=p,a.pointShadowMatrix.length=m,a.spotLightMatrix.length=f+g-y,a.spotLightMap.length=g,a.numSpotLightShadowsWithMaps=y,a.numLightProbes=v,b.directionalLength=l,b.pointLength=c,b.spotLength=h,b.rectAreaLength=d,b.hemiLength=u,b.numDirectionalShadows=p,b.numPointShadows=m,b.numSpotShadows=f,b.numSpotMaps=g,b.numLightProbes=v,a.version=Fh++)},setupView:function(e,t){let n=0,o=0,l=0,c=0,h=0;const d=t.matrixWorldInverse;for(let t=0,u=e.length;t<u;t++){const u=e[t];if(u.isDirectionalLight){const e=a.directional[n];e.direction.setFromMatrixPosition(u.matrixWorld),i.setFromMatrixPosition(u.target.matrixWorld),e.direction.sub(i),e.direction.transformDirection(d),n++}else if(u.isSpotLight){const e=a.spot[l];e.position.setFromMatrixPosition(u.matrixWorld),e.position.applyMatrix4(d),e.direction.setFromMatrixPosition(u.matrixWorld),i.setFromMatrixPosition(u.target.matrixWorld),e.direction.sub(i),e.direction.transformDirection(d),l++}else if(u.isRectAreaLight){const e=a.rectArea[c];e.position.setFromMatrixPosition(u.matrixWorld),e.position.applyMatrix4(d),s.identity(),r.copy(u.matrixWorld),r.premultiply(d),s.extractRotation(r),e.halfWidth.set(.5*u.width,0,0),e.halfHeight.set(0,.5*u.height,0),e.halfWidth.applyMatrix4(s),e.halfHeight.applyMatrix4(s),c++}else if(u.isPointLight){const e=a.point[o];e.position.setFromMatrixPosition(u.matrixWorld),e.position.applyMatrix4(d),o++}else if(u.isHemisphereLight){const e=a.hemi[h];e.direction.setFromMatrixPosition(u.matrixWorld),e.direction.transformDirection(d),h++}}},state:a}}function Nh(e){const t=new Lh(e),n=[],a=[],i={lightsArray:n,shadowsArray:a,camera:null,lights:t,transmissionRenderTarget:{}};return{init:function(e){i.camera=e,n.length=0,a.length=0},state:i,setupLights:function(){t.setup(n)},setupLightsView:function(e){t.setupView(n,e)},pushLight:function(e){n.push(e)},pushShadow:function(e){a.push(e)}}}function Vh(e){let t=new WeakMap;return{get:function(n,a=0){const i=t.get(n);let r;return void 0===i?(r=new Nh(e),t.set(n,[r])):a>=i.length?(r=new Nh(e),i.push(r)):r=i[a],r},dispose:function(){t=new WeakMap}}}function Uh(e,t,n){let s=new Dr;const o=new Vt,l=new Vt,c=new ln,h=new uo({depthPacking:3201}),d=new po,u={},p=n.maxTextureSize,m={[a]:1,[i]:0,[r]:2},f=new bi({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vt},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),g=f.clone();g.defines.HORIZONTAL_PASS=1;const y=new ei;y.setAttribute("position",new Wa(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const v=new ui(y,f),b=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1;let w=this.type;function x(n,a){const i=t.update(v);f.defines.VSM_SAMPLES!==n.blurSamples&&(f.defines.VSM_SAMPLES=n.blurSamples,g.defines.VSM_SAMPLES=n.blurSamples,f.needsUpdate=!0,g.needsUpdate=!0),null===n.mapPass&&(n.mapPass=new hn(o.x,o.y)),f.uniforms.shadow_pass.value=n.map.texture,f.uniforms.resolution.value=n.mapSize,f.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(a,null,i,f,v,null),g.uniforms.shadow_pass.value=n.mapPass.texture,g.uniforms.resolution.value=n.mapSize,g.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(a,null,i,g,v,null)}function S(t,n,a,i){let r=null;const s=!0===a.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(void 0!==s)r=s;else if(r=!0===a.isPointLight?d:h,e.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0||n.map&&n.alphaTest>0||!0===n.alphaToCoverage){const e=r.uuid,t=n.uuid;let a=u[e];void 0===a&&(a={},u[e]=a);let i=a[t];void 0===i&&(i=r.clone(),a[t]=i,n.addEventListener("dispose",_)),r=i}return r.visible=n.visible,r.wireframe=n.wireframe,r.side=3===i?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:m[n.side],r.alphaMap=n.alphaMap,r.alphaTest=!0===n.alphaToCoverage?.5:n.alphaTest,r.map=n.map,r.clipShadows=n.clipShadows,r.clippingPlanes=n.clippingPlanes,r.clipIntersection=n.clipIntersection,r.displacementMap=n.displacementMap,r.displacementScale=n.displacementScale,r.displacementBias=n.displacementBias,r.wireframeLinewidth=n.wireframeLinewidth,r.linewidth=n.linewidth,!0===a.isPointLight&&!0===r.isMeshDistanceMaterial&&(e.properties.get(r).light=a),r}function M(n,a,i,r,o){if(!1===n.visible)return;if(n.layers.test(a.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===o)&&(!n.frustumCulled||s.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,n.matrixWorld);const s=t.update(n),l=n.material;if(Array.isArray(l)){const t=s.groups;for(let c=0,h=t.length;c<h;c++){const h=t[c],d=l[h.materialIndex];if(d&&d.visible){const t=S(n,d,r,o);n.onBeforeShadow(e,n,a,i,s,t,h),e.renderBufferDirect(i,null,s,t,n,h),n.onAfterShadow(e,n,a,i,s,t,h)}}}else if(l.visible){const t=S(n,l,r,o);n.onBeforeShadow(e,n,a,i,s,t,null),e.renderBufferDirect(i,null,s,t,n,null),n.onAfterShadow(e,n,a,i,s,t,null)}}const l=n.children;for(let e=0,t=l.length;e<t;e++)M(l[e],a,i,r,o)}function _(e){e.target.removeEventListener("dispose",_);for(const t in u){const n=u[t],a=e.target.uuid;a in n&&(n[a].dispose(),delete n[a])}}this.render=function(t,n,a){if(!1===b.enabled)return;if(!1===b.autoUpdate&&!1===b.needsUpdate)return;if(0===t.length)return;const i=e.getRenderTarget(),r=e.getActiveCubeFace(),h=e.getActiveMipmapLevel(),d=e.state;d.setBlending(0),!0===d.buffers.depth.getReversed()?d.buffers.color.setClear(0,0,0,0):d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);const u=3!==w&&3===this.type,m=3===w&&3!==this.type;for(let i=0,r=t.length;i<r;i++){const r=t[i],h=r.shadow;if(void 0===h){At("WebGLShadowMap:",r,"has no shadow.");continue}if(!1===h.autoUpdate&&!1===h.needsUpdate)continue;o.copy(h.mapSize);const f=h.getFrameExtents();if(o.multiply(f),l.copy(h.mapSize),(o.x>p||o.y>p)&&(o.x>p&&(l.x=Math.floor(p/f.x),o.x=l.x*f.x,h.mapSize.x=l.x),o.y>p&&(l.y=Math.floor(p/f.y),o.y=l.y*f.y,h.mapSize.y=l.y)),null===h.map||!0===u||!0===m){const e=3!==this.type?{minFilter:G,magFilter:G}:{};null!==h.map&&h.map.dispose(),h.map=new hn(o.x,o.y,e),h.map.texture.name=r.name+".shadowMap",h.camera.updateProjectionMatrix()}e.setRenderTarget(h.map),e.clear();const g=h.getViewportCount();for(let e=0;e<g;e++){const t=h.getViewport(e);c.set(l.x*t.x,l.y*t.y,l.x*t.z,l.y*t.w),d.viewport(c),h.updateMatrices(r,e),s=h.getFrustum(),M(n,a,h.camera,r,this.type)}!0!==h.isPointLightShadow&&3===this.type&&x(h,a),h.needsUpdate=!1}w=this.type,b.needsUpdate=!1,e.setRenderTarget(i,r,h)}}const Gh={[_]:1,[C]:6,[P]:7,[T]:5,[A]:0,[O]:2,[E]:4,[D]:3};function Wh(e,t){const n=new function(){let t=!1;const n=new ln;let a=null;const i=new ln(0,0,0,0);return{setMask:function(n){a===n||t||(e.colorMask(n,n,n,n),a=n)},setLocked:function(e){t=e},setClear:function(t,a,r,s,o){!0===o&&(t*=s,a*=s,r*=s),n.set(t,a,r,s),!1===i.equals(n)&&(e.clearColor(t,a,r,s),i.copy(n))},reset:function(){t=!1,a=null,i.set(-1,0,0,0)}}},a=new function(){let n=!1,a=!1,i=null,r=null,s=null;return{setReversed:function(e){if(a!==e){const n=t.get("EXT_clip_control");e?n.clipControlEXT(n.LOWER_LEFT_EXT,n.ZERO_TO_ONE_EXT):n.clipControlEXT(n.LOWER_LEFT_EXT,n.NEGATIVE_ONE_TO_ONE_EXT),a=e;const i=s;s=null,this.setClear(i)}},getReversed:function(){return a},setTest:function(t){t?ie(e.DEPTH_TEST):re(e.DEPTH_TEST)},setMask:function(t){i===t||n||(e.depthMask(t),i=t)},setFunc:function(t){if(a&&(t=Gh[t]),r!==t){switch(t){case 0:e.depthFunc(e.NEVER);break;case 1:e.depthFunc(e.ALWAYS);break;case 2:e.depthFunc(e.LESS);break;case 3:default:e.depthFunc(e.LEQUAL);break;case 4:e.depthFunc(e.EQUAL);break;case 5:e.depthFunc(e.GEQUAL);break;case 6:e.depthFunc(e.GREATER);break;case 7:e.depthFunc(e.NOTEQUAL)}r=t}},setLocked:function(e){n=e},setClear:function(t){s!==t&&(a&&(t=1-t),e.clearDepth(t),s=t)},reset:function(){n=!1,i=null,r=null,s=null,a=!1}}},i=new function(){let t=!1,n=null,a=null,i=null,r=null,s=null,o=null,l=null,c=null;return{setTest:function(n){t||(n?ie(e.STENCIL_TEST):re(e.STENCIL_TEST))},setMask:function(a){n===a||t||(e.stencilMask(a),n=a)},setFunc:function(t,n,s){a===t&&i===n&&r===s||(e.stencilFunc(t,n,s),a=t,i=n,r=s)},setOp:function(t,n,a){s===t&&o===n&&l===a||(e.stencilOp(t,n,a),s=t,o=n,l=a)},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearStencil(t),c=t)},reset:function(){t=!1,n=null,a=null,i=null,r=null,s=null,o=null,l=null,c=null}}},r=new WeakMap,_=new WeakMap;let A={},C={},T=new WeakMap,P=[],D=null,O=!1,E=null,I=null,k=null,R=null,z=null,F=null,B=null,L=new Ia(0,0,0),N=0,V=!1,U=null,G=null,W=null,q=null,H=null;const j=e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let X=!1,Y=0;const $=e.getParameter(e.VERSION);-1!==$.indexOf("WebGL")?(Y=parseFloat(/^WebGL (\d)/.exec($)[1]),X=Y>=1):-1!==$.indexOf("OpenGL ES")&&(Y=parseFloat(/^OpenGL ES (\d)/.exec($)[1]),X=Y>=2);let Q=null,K={};const Z=e.getParameter(e.SCISSOR_BOX),J=e.getParameter(e.VIEWPORT),ee=(new ln).fromArray(Z),te=(new ln).fromArray(J);function ne(t,n,a,i){const r=new Uint8Array(4),s=e.createTexture();e.bindTexture(t,s),e.texParameteri(t,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(t,e.TEXTURE_MAG_FILTER,e.NEAREST);for(let s=0;s<a;s++)t===e.TEXTURE_3D||t===e.TEXTURE_2D_ARRAY?e.texImage3D(n,0,e.RGBA,1,1,i,0,e.RGBA,e.UNSIGNED_BYTE,r):e.texImage2D(n+s,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,r);return s}const ae={};function ie(t){!0!==A[t]&&(e.enable(t),A[t]=!0)}function re(t){!1!==A[t]&&(e.disable(t),A[t]=!1)}ae[e.TEXTURE_2D]=ne(e.TEXTURE_2D,e.TEXTURE_2D,1),ae[e.TEXTURE_CUBE_MAP]=ne(e.TEXTURE_CUBE_MAP,e.TEXTURE_CUBE_MAP_POSITIVE_X,6),ae[e.TEXTURE_2D_ARRAY]=ne(e.TEXTURE_2D_ARRAY,e.TEXTURE_2D_ARRAY,1,1),ae[e.TEXTURE_3D]=ne(e.TEXTURE_3D,e.TEXTURE_3D,1,1),n.setClear(0,0,0,1),a.setClear(1),i.setClear(0),ie(e.DEPTH_TEST),a.setFunc(3),ce(!1),he(1),ie(e.CULL_FACE),le(0);const se={[s]:e.FUNC_ADD,[o]:e.FUNC_SUBTRACT,[l]:e.FUNC_REVERSE_SUBTRACT};se[103]=e.MIN,se[104]=e.MAX;const oe={[c]:e.ZERO,[h]:e.ONE,[d]:e.SRC_COLOR,[p]:e.SRC_ALPHA,[b]:e.SRC_ALPHA_SATURATE,[y]:e.DST_COLOR,[f]:e.DST_ALPHA,[u]:e.ONE_MINUS_SRC_COLOR,[m]:e.ONE_MINUS_SRC_ALPHA,[v]:e.ONE_MINUS_DST_COLOR,[g]:e.ONE_MINUS_DST_ALPHA,[w]:e.CONSTANT_COLOR,[x]:e.ONE_MINUS_CONSTANT_COLOR,[S]:e.CONSTANT_ALPHA,[M]:e.ONE_MINUS_CONSTANT_ALPHA};function le(t,n,a,i,r,o,l,c,h,d){if(0!==t){if(!1===O&&(ie(e.BLEND),O=!0),5===t)r=r||n,o=o||a,l=l||i,n===I&&r===z||(e.blendEquationSeparate(se[n],se[r]),I=n,z=r),a===k&&i===R&&o===F&&l===B||(e.blendFuncSeparate(oe[a],oe[i],oe[o],oe[l]),k=a,R=i,F=o,B=l),!1!==c.equals(L)&&h===N||(e.blendColor(c.r,c.g,c.b,h),L.copy(c),N=h),E=t,V=!1;else if(t!==E||d!==V){if(I===s&&z===s||(e.blendEquation(e.FUNC_ADD),I=s,z=s),d)switch(t){case 1:e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case 2:e.blendFunc(e.ONE,e.ONE);break;case 3:e.blendFuncSeparate(e.ZERO,e.ONE_MINUS_SRC_COLOR,e.ZERO,e.ONE);break;case 4:e.blendFuncSeparate(e.DST_COLOR,e.ONE_MINUS_SRC_ALPHA,e.ZERO,e.ONE);break;default:Ct("WebGLState: Invalid blending: ",t)}else switch(t){case 1:e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case 2:e.blendFuncSeparate(e.SRC_ALPHA,e.ONE,e.ONE,e.ONE);break;case 3:Ct("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case 4:Ct("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:Ct("WebGLState: Invalid blending: ",t)}k=null,R=null,F=null,B=null,L.set(0,0,0),N=0,E=t,V=d}}else!0===O&&(re(e.BLEND),O=!1)}function ce(t){U!==t&&(t?e.frontFace(e.CW):e.frontFace(e.CCW),U=t)}function he(t){0!==t?(ie(e.CULL_FACE),t!==G&&(1===t?e.cullFace(e.BACK):2===t?e.cullFace(e.FRONT):e.cullFace(e.FRONT_AND_BACK))):re(e.CULL_FACE),G=t}function de(t,n,a){t?(ie(e.POLYGON_OFFSET_FILL),q===n&&H===a||(e.polygonOffset(n,a),q=n,H=a)):re(e.POLYGON_OFFSET_FILL)}return{buffers:{color:n,depth:a,stencil:i},enable:ie,disable:re,bindFramebuffer:function(t,n){return C[t]!==n&&(e.bindFramebuffer(t,n),C[t]=n,t===e.DRAW_FRAMEBUFFER&&(C[e.FRAMEBUFFER]=n),t===e.FRAMEBUFFER&&(C[e.DRAW_FRAMEBUFFER]=n),!0)},drawBuffers:function(t,n){let a=P,i=!1;if(t){a=T.get(n),void 0===a&&(a=[],T.set(n,a));const r=t.textures;if(a.length!==r.length||a[0]!==e.COLOR_ATTACHMENT0){for(let t=0,n=r.length;t<n;t++)a[t]=e.COLOR_ATTACHMENT0+t;a.length=r.length,i=!0}}else a[0]!==e.BACK&&(a[0]=e.BACK,i=!0);i&&e.drawBuffers(a)},useProgram:function(t){return D!==t&&(e.useProgram(t),D=t,!0)},setBlending:le,setMaterial:function(t,r){2===t.side?re(e.CULL_FACE):ie(e.CULL_FACE);let s=1===t.side;r&&(s=!s),ce(s),1===t.blending&&!1===t.transparent?le(0):le(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.blendColor,t.blendAlpha,t.premultipliedAlpha),a.setFunc(t.depthFunc),a.setTest(t.depthTest),a.setMask(t.depthWrite),n.setMask(t.colorWrite);const o=t.stencilWrite;i.setTest(o),o&&(i.setMask(t.stencilWriteMask),i.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),i.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),de(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?ie(e.SAMPLE_ALPHA_TO_COVERAGE):re(e.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:ce,setCullFace:he,setLineWidth:function(t){t!==W&&(X&&e.lineWidth(t),W=t)},setPolygonOffset:de,setScissorTest:function(t){t?ie(e.SCISSOR_TEST):re(e.SCISSOR_TEST)},activeTexture:function(t){void 0===t&&(t=e.TEXTURE0+j-1),Q!==t&&(e.activeTexture(t),Q=t)},bindTexture:function(t,n,a){void 0===a&&(a=null===Q?e.TEXTURE0+j-1:Q);let i=K[a];void 0===i&&(i={type:void 0,texture:void 0},K[a]=i),i.type===t&&i.texture===n||(Q!==a&&(e.activeTexture(a),Q=a),e.bindTexture(t,n||ae[t]),i.type=t,i.texture=n)},unbindTexture:function(){const t=K[Q];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D(...arguments)}catch(e){e("WebGLState:",e)}},compressedTexImage3D:function(){try{e.compressedTexImage3D(...arguments)}catch(e){e("WebGLState:",e)}},texImage2D:function(){try{e.texImage2D(...arguments)}catch(e){e("WebGLState:",e)}},texImage3D:function(){try{e.texImage3D(...arguments)}catch(e){e("WebGLState:",e)}},updateUBOMapping:function(t,n){let a=_.get(n);void 0===a&&(a=new WeakMap,_.set(n,a));let i=a.get(t);void 0===i&&(i=e.getUniformBlockIndex(n,t.name),a.set(t,i))},uniformBlockBinding:function(t,n){const a=_.get(n).get(t);r.get(n)!==a&&(e.uniformBlockBinding(n,a,t.__bindingPointIndex),r.set(n,a))},texStorage2D:function(){try{e.texStorage2D(...arguments)}catch(e){e("WebGLState:",e)}},texStorage3D:function(){try{e.texStorage3D(...arguments)}catch(e){e("WebGLState:",e)}},texSubImage2D:function(){try{e.texSubImage2D(...arguments)}catch(e){e("WebGLState:",e)}},texSubImage3D:function(){try{e.texSubImage3D(...arguments)}catch(e){e("WebGLState:",e)}},compressedTexSubImage2D:function(){try{e.compressedTexSubImage2D(...arguments)}catch(e){e("WebGLState:",e)}},compressedTexSubImage3D:function(){try{e.compressedTexSubImage3D(...arguments)}catch(e){e("WebGLState:",e)}},scissor:function(t){!1===ee.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),ee.copy(t))},viewport:function(t){!1===te.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),te.copy(t))},reset:function(){e.disable(e.BLEND),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SCISSOR_TEST),e.disable(e.STENCIL_TEST),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO),e.blendFuncSeparate(e.ONE,e.ZERO,e.ONE,e.ZERO),e.blendColor(0,0,0,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(e.LESS),a.setReversed(!1),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(e.ALWAYS,0,4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.clearStencil(0),e.cullFace(e.BACK),e.frontFace(e.CCW),e.polygonOffset(0,0),e.activeTexture(e.TEXTURE0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),e.bindFramebuffer(e.READ_FRAMEBUFFER,null),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),A={},Q=null,K={},C={},T=new WeakMap,P=[],D=null,O=!1,E=null,I=null,k=null,R=null,z=null,F=null,B=null,L=new Ia(0,0,0),N=0,V=!1,U=null,G=null,W=null,q=null,H=null,ee.set(0,0,e.canvas.width,e.canvas.height),te.set(0,0,e.canvas.width,e.canvas.height),n.reset(),a.reset(),i.reset()}}}function qh(e,t,n,a,i,r,s){const o=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,l="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),c=new Vt,h=new WeakMap;let d;const u=new WeakMap;let p=!1;try{p="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function m(e,t){return p?new OffscreenCanvas(e,t):xt("canvas")}function f(e,t,n){let a=1;const i=ne(e);if((i.width>n||i.height>n)&&(a=n/Math.max(i.width,i.height)),a<1){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof VideoFrame&&e instanceof VideoFrame){const n=Math.floor(a*i.width),r=Math.floor(a*i.height);void 0===d&&(d=m(n,r));const s=t?m(n,r):d;return s.width=n,s.height=r,s.getContext("2d").drawImage(e,0,0,n,r),At("WebGLRenderer: Texture has been resized from ("+i.width+"x"+i.height+") to ("+n+"x"+r+")."),s}return"data"in e&&At("WebGLRenderer: Image in DataTexture is too big ("+i.width+"x"+i.height+")."),e}return e}function g(e){return e.generateMipmaps}function y(t){e.generateMipmap(t)}function v(t){return t.isWebGLCubeRenderTarget?e.TEXTURE_CUBE_MAP:t.isWebGL3DRenderTarget?e.TEXTURE_3D:t.isWebGLArrayRenderTarget||t.isCompressedArrayTexture?e.TEXTURE_2D_ARRAY:e.TEXTURE_2D}function b(n,a,i,r,s=!1){if(null!==n){if(void 0!==e[n])return e[n];At("WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let o=a;if(a===e.RED&&(i===e.FLOAT&&(o=e.R32F),i===e.HALF_FLOAT&&(o=e.R16F),i===e.UNSIGNED_BYTE&&(o=e.R8)),a===e.RED_INTEGER&&(i===e.UNSIGNED_BYTE&&(o=e.R8UI),i===e.UNSIGNED_SHORT&&(o=e.R16UI),i===e.UNSIGNED_INT&&(o=e.R32UI),i===e.BYTE&&(o=e.R8I),i===e.SHORT&&(o=e.R16I),i===e.INT&&(o=e.R32I)),a===e.RG&&(i===e.FLOAT&&(o=e.RG32F),i===e.HALF_FLOAT&&(o=e.RG16F),i===e.UNSIGNED_BYTE&&(o=e.RG8)),a===e.RG_INTEGER&&(i===e.UNSIGNED_BYTE&&(o=e.RG8UI),i===e.UNSIGNED_SHORT&&(o=e.RG16UI),i===e.UNSIGNED_INT&&(o=e.RG32UI),i===e.BYTE&&(o=e.RG8I),i===e.SHORT&&(o=e.RG16I),i===e.INT&&(o=e.RG32I)),a===e.RGB_INTEGER&&(i===e.UNSIGNED_BYTE&&(o=e.RGB8UI),i===e.UNSIGNED_SHORT&&(o=e.RGB16UI),i===e.UNSIGNED_INT&&(o=e.RGB32UI),i===e.BYTE&&(o=e.RGB8I),i===e.SHORT&&(o=e.RGB16I),i===e.INT&&(o=e.RGB32I)),a===e.RGBA_INTEGER&&(i===e.UNSIGNED_BYTE&&(o=e.RGBA8UI),i===e.UNSIGNED_SHORT&&(o=e.RGBA16UI),i===e.UNSIGNED_INT&&(o=e.RGBA32UI),i===e.BYTE&&(o=e.RGBA8I),i===e.SHORT&&(o=e.RGBA16I),i===e.INT&&(o=e.RGBA32I)),a===e.RGB&&(i===e.UNSIGNED_INT_5_9_9_9_REV&&(o=e.RGB9_E5),i===e.UNSIGNED_INT_10F_11F_11F_REV&&(o=e.R11F_G11F_B10F)),a===e.RGBA){const t=s?it:Qt.getTransfer(r);i===e.FLOAT&&(o=e.RGBA32F),i===e.HALF_FLOAT&&(o=e.RGBA16F),i===e.UNSIGNED_BYTE&&(o=t===rt?e.SRGB8_ALPHA8:e.RGBA8),i===e.UNSIGNED_SHORT_4_4_4_4&&(o=e.RGBA4),i===e.UNSIGNED_SHORT_5_5_5_1&&(o=e.RGB5_A1)}return o!==e.R16F&&o!==e.R32F&&o!==e.RG16F&&o!==e.RG32F&&o!==e.RGBA16F&&o!==e.RGBA32F||t.get("EXT_color_buffer_float"),o}function w(t,n){let a;return t?null===n||n===J||n===ie?a=e.DEPTH24_STENCIL8:n===ee?a=e.DEPTH32F_STENCIL8:n===K&&(a=e.DEPTH24_STENCIL8,At("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):null===n||n===J||n===ie?a=e.DEPTH_COMPONENT24:n===ee?a=e.DEPTH_COMPONENT32F:n===K&&(a=e.DEPTH_COMPONENT16),a}function x(e,t){return!0===g(e)||e.isFramebufferTexture&&e.minFilter!==G&&e.minFilter!==H?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}function S(e){const t=e.target;t.removeEventListener("dispose",S),function(e){const t=a.get(e);if(void 0===t.__webglInit)return;const n=e.source,i=u.get(n);if(i){const a=i[t.__cacheKey];a.usedTimes--,0===a.usedTimes&&_(e),0===Object.keys(i).length&&u.delete(n)}a.remove(e)}(t),t.isVideoTexture&&h.delete(t)}function M(t){const n=t.target;n.removeEventListener("dispose",M),function(t){const n=a.get(t);if(t.depthTexture&&(t.depthTexture.dispose(),a.remove(t.depthTexture)),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++){if(Array.isArray(n.__webglFramebuffer[t]))for(let a=0;a<n.__webglFramebuffer[t].length;a++)e.deleteFramebuffer(n.__webglFramebuffer[t][a]);else e.deleteFramebuffer(n.__webglFramebuffer[t]);n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer[t])}else{if(Array.isArray(n.__webglFramebuffer))for(let t=0;t<n.__webglFramebuffer.length;t++)e.deleteFramebuffer(n.__webglFramebuffer[t]);else e.deleteFramebuffer(n.__webglFramebuffer);if(n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&e.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer)for(let t=0;t<n.__webglColorRenderbuffer.length;t++)n.__webglColorRenderbuffer[t]&&e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);n.__webglDepthRenderbuffer&&e.deleteRenderbuffer(n.__webglDepthRenderbuffer)}const i=t.textures;for(let t=0,n=i.length;t<n;t++){const n=a.get(i[t]);n.__webglTexture&&(e.deleteTexture(n.__webglTexture),s.memory.textures--),a.remove(i[t])}a.remove(t)}(n)}function _(t){const n=a.get(t);e.deleteTexture(n.__webglTexture);const i=t.source;delete u.get(i)[n.__cacheKey],s.memory.textures--}let A=0;function C(t,i){const r=a.get(t);if(t.isVideoTexture&&function(e){const t=s.render.frame;h.get(e)!==t&&(h.set(e,t),e.update())}(t),!1===t.isRenderTargetTexture&&!0!==t.isExternalTexture&&t.version>0&&r.__version!==t.version){const e=t.image;if(null===e)At("WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==e.complete)return void k(r,t,i);At("WebGLRenderer: Texture marked for update but image is incomplete")}}else t.isExternalTexture&&(r.__webglTexture=t.sourceTexture?t.sourceTexture:null);n.bindTexture(e.TEXTURE_2D,r.__webglTexture,e.TEXTURE0+i)}const T={[N]:e.REPEAT,[V]:e.CLAMP_TO_EDGE,[U]:e.MIRRORED_REPEAT},P={[G]:e.NEAREST,[W]:e.NEAREST_MIPMAP_NEAREST,[q]:e.NEAREST_MIPMAP_LINEAR,[H]:e.LINEAR,[j]:e.LINEAR_MIPMAP_NEAREST,[X]:e.LINEAR_MIPMAP_LINEAR},D={[ot]:e.NEVER,[mt]:e.ALWAYS,[lt]:e.LESS,[ht]:e.LEQUAL,[ct]:e.EQUAL,[pt]:e.GEQUAL,[dt]:e.GREATER,[ut]:e.NOTEQUAL};function O(n,r){if(r.type!==ee||!1!==t.has("OES_texture_float_linear")||r.magFilter!==H&&r.magFilter!==j&&r.magFilter!==q&&r.magFilter!==X&&r.minFilter!==H&&r.minFilter!==j&&r.minFilter!==q&&r.minFilter!==X||At("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),e.texParameteri(n,e.TEXTURE_WRAP_S,T[r.wrapS]),e.texParameteri(n,e.TEXTURE_WRAP_T,T[r.wrapT]),n!==e.TEXTURE_3D&&n!==e.TEXTURE_2D_ARRAY||e.texParameteri(n,e.TEXTURE_WRAP_R,T[r.wrapR]),e.texParameteri(n,e.TEXTURE_MAG_FILTER,P[r.magFilter]),e.texParameteri(n,e.TEXTURE_MIN_FILTER,P[r.minFilter]),r.compareFunction&&(e.texParameteri(n,e.TEXTURE_COMPARE_MODE,e.COMPARE_REF_TO_TEXTURE),e.texParameteri(n,e.TEXTURE_COMPARE_FUNC,D[r.compareFunction])),!0===t.has("EXT_texture_filter_anisotropic")){if(r.magFilter===G)return;if(r.minFilter!==q&&r.minFilter!==X)return;if(r.type===ee&&!1===t.has("OES_texture_float_linear"))return;if(r.anisotropy>1||a.get(r).__currentAnisotropy){const s=t.get("EXT_texture_filter_anisotropic");e.texParameterf(n,s.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(r.anisotropy,i.getMaxAnisotropy())),a.get(r).__currentAnisotropy=r.anisotropy}}}function E(t,n){let a=!1;void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",S));const i=n.source;let r=u.get(i);void 0===r&&(r={},u.set(i,r));const o=function(e){const t=[];return t.push(e.wrapS),t.push(e.wrapT),t.push(e.wrapR||0),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy),t.push(e.internalFormat),t.push(e.format),t.push(e.type),t.push(e.generateMipmaps),t.push(e.premultiplyAlpha),t.push(e.flipY),t.push(e.unpackAlignment),t.push(e.colorSpace),t.join()}(n);if(o!==t.__cacheKey){void 0===r[o]&&(r[o]={texture:e.createTexture(),usedTimes:0},s.memory.textures++,a=!0),r[o].usedTimes++;const i=r[t.__cacheKey];void 0!==i&&(r[t.__cacheKey].usedTimes--,0===i.usedTimes&&_(n)),t.__cacheKey=o,t.__webglTexture=r[o].texture}return a}function I(e,t,n){return Math.floor(Math.floor(e/n)/t)}function k(t,s,o){let l=e.TEXTURE_2D;(s.isDataArrayTexture||s.isCompressedArrayTexture)&&(l=e.TEXTURE_2D_ARRAY),s.isData3DTexture&&(l=e.TEXTURE_3D);const c=E(t,s),h=s.source;n.bindTexture(l,t.__webglTexture,e.TEXTURE0+o);const d=a.get(h);if(h.version!==d.__version||!0===c){n.activeTexture(e.TEXTURE0+o);const t=Qt.getPrimaries(Qt.workingColorSpace),a=s.colorSpace===tt?null:Qt.getPrimaries(s.colorSpace),u=s.colorSpace===tt||t===a?e.NONE:e.BROWSER_DEFAULT_WEBGL;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,s.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,s.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,u);let p=f(s.image,!1,i.maxTextureSize);p=te(s,p);const m=r.convert(s.format,s.colorSpace),v=r.convert(s.type);let S,M=b(s.internalFormat,m,v,s.colorSpace,s.isVideoTexture);O(l,s);const _=s.mipmaps,A=!0!==s.isVideoTexture,C=void 0===d.__version||!0===c,T=h.dataReady,P=x(s,p);if(s.isDepthTexture)M=w(s.format===de,s.type),C&&(A?n.texStorage2D(e.TEXTURE_2D,1,M,p.width,p.height):n.texImage2D(e.TEXTURE_2D,0,M,p.width,p.height,0,m,v,null));else if(s.isDataTexture)if(_.length>0){A&&C&&n.texStorage2D(e.TEXTURE_2D,P,M,_[0].width,_[0].height);for(let t=0,a=_.length;t<a;t++)S=_[t],A?T&&n.texSubImage2D(e.TEXTURE_2D,t,0,0,S.width,S.height,m,v,S.data):n.texImage2D(e.TEXTURE_2D,t,M,S.width,S.height,0,m,v,S.data);s.generateMipmaps=!1}else A?(C&&n.texStorage2D(e.TEXTURE_2D,P,M,p.width,p.height),T&&function(t,a,i,r){const s=t.updateRanges;if(0===s.length)n.texSubImage2D(e.TEXTURE_2D,0,0,0,a.width,a.height,i,r,a.data);else{s.sort((e,t)=>e.start-t.start);let o=0;for(let e=1;e<s.length;e++){const t=s[o],n=s[e],i=t.start+t.count,r=I(n.start,a.width,4),l=I(t.start,a.width,4);n.start<=i+1&&r===l&&I(n.start+n.count-1,a.width,4)===r?t.count=Math.max(t.count,n.start+n.count-t.start):(++o,s[o]=n)}s.length=o+1;const l=e.getParameter(e.UNPACK_ROW_LENGTH),c=e.getParameter(e.UNPACK_SKIP_PIXELS),h=e.getParameter(e.UNPACK_SKIP_ROWS);e.pixelStorei(e.UNPACK_ROW_LENGTH,a.width);for(let t=0,o=s.length;t<o;t++){const o=s[t],l=Math.floor(o.start/4),c=Math.ceil(o.count/4),h=l%a.width,d=Math.floor(l/a.width),u=c,p=1;e.pixelStorei(e.UNPACK_SKIP_PIXELS,h),e.pixelStorei(e.UNPACK_SKIP_ROWS,d),n.texSubImage2D(e.TEXTURE_2D,0,h,d,u,p,i,r,a.data)}t.clearUpdateRanges(),e.pixelStorei(e.UNPACK_ROW_LENGTH,l),e.pixelStorei(e.UNPACK_SKIP_PIXELS,c),e.pixelStorei(e.UNPACK_SKIP_ROWS,h)}}(s,p,m,v)):n.texImage2D(e.TEXTURE_2D,0,M,p.width,p.height,0,m,v,p.data);else if(s.isCompressedTexture)if(s.isCompressedArrayTexture){A&&C&&n.texStorage3D(e.TEXTURE_2D_ARRAY,P,M,_[0].width,_[0].height,p.depth);for(let t=0,a=_.length;t<a;t++)if(S=_[t],s.format!==ce)if(null!==m)if(A){if(T)if(s.layerUpdates.size>0){const a=xl(S.width,S.height,s.format,s.type);for(const i of s.layerUpdates){const r=S.data.subarray(i*a/S.data.BYTES_PER_ELEMENT,(i+1)*a/S.data.BYTES_PER_ELEMENT);n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,i,S.width,S.height,1,m,r)}s.clearLayerUpdates()}else n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,0,S.width,S.height,p.depth,m,S.data)}else n.compressedTexImage3D(e.TEXTURE_2D_ARRAY,t,M,S.width,S.height,p.depth,0,S.data,0,0);else At("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else A?T&&n.texSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,0,S.width,S.height,p.depth,m,v,S.data):n.texImage3D(e.TEXTURE_2D_ARRAY,t,M,S.width,S.height,p.depth,0,m,v,S.data)}else{A&&C&&n.texStorage2D(e.TEXTURE_2D,P,M,_[0].width,_[0].height);for(let t=0,a=_.length;t<a;t++)S=_[t],s.format!==ce?null!==m?A?T&&n.compressedTexSubImage2D(e.TEXTURE_2D,t,0,0,S.width,S.height,m,S.data):n.compressedTexImage2D(e.TEXTURE_2D,t,M,S.width,S.height,0,S.data):At("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):A?T&&n.texSubImage2D(e.TEXTURE_2D,t,0,0,S.width,S.height,m,v,S.data):n.texImage2D(e.TEXTURE_2D,t,M,S.width,S.height,0,m,v,S.data)}else if(s.isDataArrayTexture)if(A){if(C&&n.texStorage3D(e.TEXTURE_2D_ARRAY,P,M,p.width,p.height,p.depth),T)if(s.layerUpdates.size>0){const t=xl(p.width,p.height,s.format,s.type);for(const a of s.layerUpdates){const i=p.data.subarray(a*t/p.data.BYTES_PER_ELEMENT,(a+1)*t/p.data.BYTES_PER_ELEMENT);n.texSubImage3D(e.TEXTURE_2D_ARRAY,0,0,0,a,p.width,p.height,1,m,v,i)}s.clearLayerUpdates()}else n.texSubImage3D(e.TEXTURE_2D_ARRAY,0,0,0,0,p.width,p.height,p.depth,m,v,p.data)}else n.texImage3D(e.TEXTURE_2D_ARRAY,0,M,p.width,p.height,p.depth,0,m,v,p.data);else if(s.isData3DTexture)A?(C&&n.texStorage3D(e.TEXTURE_3D,P,M,p.width,p.height,p.depth),T&&n.texSubImage3D(e.TEXTURE_3D,0,0,0,0,p.width,p.height,p.depth,m,v,p.data)):n.texImage3D(e.TEXTURE_3D,0,M,p.width,p.height,p.depth,0,m,v,p.data);else if(s.isFramebufferTexture){if(C)if(A)n.texStorage2D(e.TEXTURE_2D,P,M,p.width,p.height);else{let t=p.width,a=p.height;for(let i=0;i<P;i++)n.texImage2D(e.TEXTURE_2D,i,M,t,a,0,m,v,null),t>>=1,a>>=1}}else if(_.length>0){if(A&&C){const t=ne(_[0]);n.texStorage2D(e.TEXTURE_2D,P,M,t.width,t.height)}for(let t=0,a=_.length;t<a;t++)S=_[t],A?T&&n.texSubImage2D(e.TEXTURE_2D,t,0,0,m,v,S):n.texImage2D(e.TEXTURE_2D,t,M,m,v,S);s.generateMipmaps=!1}else if(A){if(C){const t=ne(p);n.texStorage2D(e.TEXTURE_2D,P,M,t.width,t.height)}T&&n.texSubImage2D(e.TEXTURE_2D,0,0,0,m,v,p)}else n.texImage2D(e.TEXTURE_2D,0,M,m,v,p);g(s)&&y(l),d.__version=h.version,s.onUpdate&&s.onUpdate(s)}t.__version=s.version}function R(t,i,s,l,c,h){const d=r.convert(s.format,s.colorSpace),u=r.convert(s.type),p=b(s.internalFormat,d,u,s.colorSpace),m=a.get(i),f=a.get(s);if(f.__renderTarget=i,!m.__hasExternalTextures){const t=Math.max(1,i.width>>h),a=Math.max(1,i.height>>h);c===e.TEXTURE_3D||c===e.TEXTURE_2D_ARRAY?n.texImage3D(c,h,p,t,a,i.depth,0,d,u,null):n.texImage2D(c,h,p,t,a,0,d,u,null)}n.bindFramebuffer(e.FRAMEBUFFER,t),Z(i)?o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,l,c,f.__webglTexture,0,Q(i)):(c===e.TEXTURE_2D||c>=e.TEXTURE_CUBE_MAP_POSITIVE_X&&c<=e.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&e.framebufferTexture2D(e.FRAMEBUFFER,l,c,f.__webglTexture,h),n.bindFramebuffer(e.FRAMEBUFFER,null)}function z(t,n,a){if(e.bindRenderbuffer(e.RENDERBUFFER,t),n.depthBuffer){const i=n.depthTexture,r=i&&i.isDepthTexture?i.type:null,s=w(n.stencilBuffer,r),l=n.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,c=Q(n);Z(n)?o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,c,s,n.width,n.height):a?e.renderbufferStorageMultisample(e.RENDERBUFFER,c,s,n.width,n.height):e.renderbufferStorage(e.RENDERBUFFER,s,n.width,n.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,l,e.RENDERBUFFER,t)}else{const t=n.textures;for(let i=0;i<t.length;i++){const s=t[i],l=r.convert(s.format,s.colorSpace),c=r.convert(s.type),h=b(s.internalFormat,l,c,s.colorSpace),d=Q(n);a&&!1===Z(n)?e.renderbufferStorageMultisample(e.RENDERBUFFER,d,h,n.width,n.height):Z(n)?o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,d,h,n.width,n.height):e.renderbufferStorage(e.RENDERBUFFER,h,n.width,n.height)}}e.bindRenderbuffer(e.RENDERBUFFER,null)}function F(t,i){if(i&&i.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(e.FRAMEBUFFER,t),!i.depthTexture||!i.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const r=a.get(i.depthTexture);r.__renderTarget=i,r.__webglTexture&&i.depthTexture.image.width===i.width&&i.depthTexture.image.height===i.height||(i.depthTexture.image.width=i.width,i.depthTexture.image.height=i.height,i.depthTexture.needsUpdate=!0),C(i.depthTexture,0);const s=r.__webglTexture,l=Q(i);if(i.depthTexture.format===he)Z(i)?o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,s,0,l):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,s,0);else{if(i.depthTexture.format!==de)throw new Error("Unknown depthTexture format");Z(i)?o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,s,0,l):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,s,0)}}function B(t){const i=a.get(t),r=!0===t.isWebGLCubeRenderTarget;if(i.__boundDepthTexture!==t.depthTexture){const e=t.depthTexture;if(i.__depthDisposeCallback&&i.__depthDisposeCallback(),e){const t=()=>{delete i.__boundDepthTexture,delete i.__depthDisposeCallback,e.removeEventListener("dispose",t)};e.addEventListener("dispose",t),i.__depthDisposeCallback=t}i.__boundDepthTexture=e}if(t.depthTexture&&!i.__autoAllocateDepthBuffer){if(r)throw new Error("target.depthTexture not supported in Cube render targets");const e=t.texture.mipmaps;e&&e.length>0?F(i.__webglFramebuffer[0],t):F(i.__webglFramebuffer,t)}else if(r){i.__webglDepthbuffer=[];for(let a=0;a<6;a++)if(n.bindFramebuffer(e.FRAMEBUFFER,i.__webglFramebuffer[a]),void 0===i.__webglDepthbuffer[a])i.__webglDepthbuffer[a]=e.createRenderbuffer(),z(i.__webglDepthbuffer[a],t,!1);else{const n=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,r=i.__webglDepthbuffer[a];e.bindRenderbuffer(e.RENDERBUFFER,r),e.framebufferRenderbuffer(e.FRAMEBUFFER,n,e.RENDERBUFFER,r)}}else{const a=t.texture.mipmaps;if(a&&a.length>0?n.bindFramebuffer(e.FRAMEBUFFER,i.__webglFramebuffer[0]):n.bindFramebuffer(e.FRAMEBUFFER,i.__webglFramebuffer),void 0===i.__webglDepthbuffer)i.__webglDepthbuffer=e.createRenderbuffer(),z(i.__webglDepthbuffer,t,!1);else{const n=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,a=i.__webglDepthbuffer;e.bindRenderbuffer(e.RENDERBUFFER,a),e.framebufferRenderbuffer(e.FRAMEBUFFER,n,e.RENDERBUFFER,a)}}n.bindFramebuffer(e.FRAMEBUFFER,null)}const L=[],$=[];function Q(e){return Math.min(i.maxSamples,e.samples)}function Z(e){const n=a.get(e);return e.samples>0&&!0===t.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function te(e,t){const n=e.colorSpace,a=e.format,i=e.type;return!0===e.isCompressedTexture||!0===e.isVideoTexture||n!==at&&n!==tt&&(Qt.getTransfer(n)===rt?a===ce&&i===Y||At("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):Ct("WebGLTextures: Unsupported texture color space:",n)),t}function ne(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement?(c.width=e.naturalWidth||e.width,c.height=e.naturalHeight||e.height):"undefined"!=typeof VideoFrame&&e instanceof VideoFrame?(c.width=e.displayWidth,c.height=e.displayHeight):(c.width=e.width,c.height=e.height),c}this.allocateTextureUnit=function(){const e=A;return e>=i.maxTextures&&At("WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+i.maxTextures),A+=1,e},this.resetTextureUnits=function(){A=0},this.setTexture2D=C,this.setTexture2DArray=function(t,i){const r=a.get(t);!1===t.isRenderTargetTexture&&t.version>0&&r.__version!==t.version?k(r,t,i):(t.isExternalTexture&&(r.__webglTexture=t.sourceTexture?t.sourceTexture:null),n.bindTexture(e.TEXTURE_2D_ARRAY,r.__webglTexture,e.TEXTURE0+i))},this.setTexture3D=function(t,i){const r=a.get(t);!1===t.isRenderTargetTexture&&t.version>0&&r.__version!==t.version?k(r,t,i):n.bindTexture(e.TEXTURE_3D,r.__webglTexture,e.TEXTURE0+i)},this.setTextureCube=function(t,s){const o=a.get(t);t.version>0&&o.__version!==t.version?function(t,s,o){if(6!==s.image.length)return;const l=E(t,s),c=s.source;n.bindTexture(e.TEXTURE_CUBE_MAP,t.__webglTexture,e.TEXTURE0+o);const h=a.get(c);if(c.version!==h.__version||!0===l){n.activeTexture(e.TEXTURE0+o);const t=Qt.getPrimaries(Qt.workingColorSpace),a=s.colorSpace===tt?null:Qt.getPrimaries(s.colorSpace),d=s.colorSpace===tt||t===a?e.NONE:e.BROWSER_DEFAULT_WEBGL;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,s.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,s.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,d);const u=s.isCompressedTexture||s.image[0].isCompressedTexture,p=s.image[0]&&s.image[0].isDataTexture,m=[];for(let e=0;e<6;e++)m[e]=u||p?p?s.image[e].image:s.image[e]:f(s.image[e],!0,i.maxCubemapSize),m[e]=te(s,m[e]);const v=m[0],w=r.convert(s.format,s.colorSpace),S=r.convert(s.type),M=b(s.internalFormat,w,S,s.colorSpace),_=!0!==s.isVideoTexture,A=void 0===h.__version||!0===l,C=c.dataReady;let T,P=x(s,v);if(O(e.TEXTURE_CUBE_MAP,s),u){_&&A&&n.texStorage2D(e.TEXTURE_CUBE_MAP,P,M,v.width,v.height);for(let t=0;t<6;t++){T=m[t].mipmaps;for(let a=0;a<T.length;a++){const i=T[a];s.format!==ce?null!==w?_?C&&n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,a,0,0,i.width,i.height,w,i.data):n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,a,M,i.width,i.height,0,i.data):At("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):_?C&&n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,a,0,0,i.width,i.height,w,S,i.data):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,a,M,i.width,i.height,0,w,S,i.data)}}}else{if(T=s.mipmaps,_&&A){T.length>0&&P++;const t=ne(m[0]);n.texStorage2D(e.TEXTURE_CUBE_MAP,P,M,t.width,t.height)}for(let t=0;t<6;t++)if(p){_?C&&n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,0,0,m[t].width,m[t].height,w,S,m[t].data):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,M,m[t].width,m[t].height,0,w,S,m[t].data);for(let a=0;a<T.length;a++){const i=T[a].image[t].image;_?C&&n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,a+1,0,0,i.width,i.height,w,S,i.data):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,a+1,M,i.width,i.height,0,w,S,i.data)}}else{_?C&&n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,0,0,w,S,m[t]):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,M,w,S,m[t]);for(let a=0;a<T.length;a++){const i=T[a];_?C&&n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,a+1,0,0,w,S,i.image[t]):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,a+1,M,w,S,i.image[t])}}}g(s)&&y(e.TEXTURE_CUBE_MAP),h.__version=c.version,s.onUpdate&&s.onUpdate(s)}t.__version=s.version}(o,t,s):n.bindTexture(e.TEXTURE_CUBE_MAP,o.__webglTexture,e.TEXTURE0+s)},this.rebindTextures=function(t,n,i){const r=a.get(t);void 0!==n&&R(r.__webglFramebuffer,t,t.texture,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,0),void 0!==i&&B(t)},this.setupRenderTarget=function(t){const i=t.texture,o=a.get(t),l=a.get(i);t.addEventListener("dispose",M);const c=t.textures,h=!0===t.isWebGLCubeRenderTarget,d=c.length>1;if(d||(void 0===l.__webglTexture&&(l.__webglTexture=e.createTexture()),l.__version=i.version,s.memory.textures++),h){o.__webglFramebuffer=[];for(let t=0;t<6;t++)if(i.mipmaps&&i.mipmaps.length>0){o.__webglFramebuffer[t]=[];for(let n=0;n<i.mipmaps.length;n++)o.__webglFramebuffer[t][n]=e.createFramebuffer()}else o.__webglFramebuffer[t]=e.createFramebuffer()}else{if(i.mipmaps&&i.mipmaps.length>0){o.__webglFramebuffer=[];for(let t=0;t<i.mipmaps.length;t++)o.__webglFramebuffer[t]=e.createFramebuffer()}else o.__webglFramebuffer=e.createFramebuffer();if(d)for(let t=0,n=c.length;t<n;t++){const n=a.get(c[t]);void 0===n.__webglTexture&&(n.__webglTexture=e.createTexture(),s.memory.textures++)}if(t.samples>0&&!1===Z(t)){o.__webglMultisampledFramebuffer=e.createFramebuffer(),o.__webglColorRenderbuffer=[],n.bindFramebuffer(e.FRAMEBUFFER,o.__webglMultisampledFramebuffer);for(let n=0;n<c.length;n++){const a=c[n];o.__webglColorRenderbuffer[n]=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,o.__webglColorRenderbuffer[n]);const i=r.convert(a.format,a.colorSpace),s=r.convert(a.type),l=b(a.internalFormat,i,s,a.colorSpace,!0===t.isXRRenderTarget),h=Q(t);e.renderbufferStorageMultisample(e.RENDERBUFFER,h,l,t.width,t.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+n,e.RENDERBUFFER,o.__webglColorRenderbuffer[n])}e.bindRenderbuffer(e.RENDERBUFFER,null),t.depthBuffer&&(o.__webglDepthRenderbuffer=e.createRenderbuffer(),z(o.__webglDepthRenderbuffer,t,!0)),n.bindFramebuffer(e.FRAMEBUFFER,null)}}if(h){n.bindTexture(e.TEXTURE_CUBE_MAP,l.__webglTexture),O(e.TEXTURE_CUBE_MAP,i);for(let n=0;n<6;n++)if(i.mipmaps&&i.mipmaps.length>0)for(let a=0;a<i.mipmaps.length;a++)R(o.__webglFramebuffer[n][a],t,i,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+n,a);else R(o.__webglFramebuffer[n],t,i,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+n,0);g(i)&&y(e.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(d){for(let i=0,r=c.length;i<r;i++){const r=c[i],s=a.get(r);let l=e.TEXTURE_2D;(t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(l=t.isWebGL3DRenderTarget?e.TEXTURE_3D:e.TEXTURE_2D_ARRAY),n.bindTexture(l,s.__webglTexture),O(l,r),R(o.__webglFramebuffer,t,r,e.COLOR_ATTACHMENT0+i,l,0),g(r)&&y(l)}n.unbindTexture()}else{let a=e.TEXTURE_2D;if((t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(a=t.isWebGL3DRenderTarget?e.TEXTURE_3D:e.TEXTURE_2D_ARRAY),n.bindTexture(a,l.__webglTexture),O(a,i),i.mipmaps&&i.mipmaps.length>0)for(let n=0;n<i.mipmaps.length;n++)R(o.__webglFramebuffer[n],t,i,e.COLOR_ATTACHMENT0,a,n);else R(o.__webglFramebuffer,t,i,e.COLOR_ATTACHMENT0,a,0);g(i)&&y(a),n.unbindTexture()}t.depthBuffer&&B(t)},this.updateRenderTargetMipmap=function(e){const t=e.textures;for(let i=0,r=t.length;i<r;i++){const r=t[i];if(g(r)){const t=v(e),i=a.get(r).__webglTexture;n.bindTexture(t,i),y(t),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(t){if(t.samples>0)if(!1===Z(t)){const i=t.textures,r=t.width,s=t.height;let o=e.COLOR_BUFFER_BIT;const c=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,h=a.get(t),d=i.length>1;if(d)for(let t=0;t<i.length;t++)n.bindFramebuffer(e.FRAMEBUFFER,h.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.RENDERBUFFER,null),n.bindFramebuffer(e.FRAMEBUFFER,h.__webglFramebuffer),e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.TEXTURE_2D,null,0);n.bindFramebuffer(e.READ_FRAMEBUFFER,h.__webglMultisampledFramebuffer);const u=t.texture.mipmaps;u&&u.length>0?n.bindFramebuffer(e.DRAW_FRAMEBUFFER,h.__webglFramebuffer[0]):n.bindFramebuffer(e.DRAW_FRAMEBUFFER,h.__webglFramebuffer);for(let n=0;n<i.length;n++){if(t.resolveDepthBuffer&&(t.depthBuffer&&(o|=e.DEPTH_BUFFER_BIT),t.stencilBuffer&&t.resolveStencilBuffer&&(o|=e.STENCIL_BUFFER_BIT)),d){e.framebufferRenderbuffer(e.READ_FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,h.__webglColorRenderbuffer[n]);const t=a.get(i[n]).__webglTexture;e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)}e.blitFramebuffer(0,0,r,s,0,0,r,s,o,e.NEAREST),!0===l&&(L.length=0,$.length=0,L.push(e.COLOR_ATTACHMENT0+n),t.depthBuffer&&!1===t.resolveDepthBuffer&&(L.push(c),$.push(c),e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER,$)),e.invalidateFramebuffer(e.READ_FRAMEBUFFER,L))}if(n.bindFramebuffer(e.READ_FRAMEBUFFER,null),n.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),d)for(let t=0;t<i.length;t++){n.bindFramebuffer(e.FRAMEBUFFER,h.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.RENDERBUFFER,h.__webglColorRenderbuffer[t]);const r=a.get(i[t]).__webglTexture;n.bindFramebuffer(e.FRAMEBUFFER,h.__webglFramebuffer),e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.TEXTURE_2D,r,0)}n.bindFramebuffer(e.DRAW_FRAMEBUFFER,h.__webglMultisampledFramebuffer)}else if(t.depthBuffer&&!1===t.resolveDepthBuffer&&l){const n=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT;e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER,[n])}},this.setupDepthRenderbuffer=B,this.setupFrameBufferTexture=R,this.useMultisampledRTT=Z}function Hh(e,t){return{convert:function(n,a=""){let i;const r=Qt.getTransfer(a);if(n===Y)return e.UNSIGNED_BYTE;if(n===ne)return e.UNSIGNED_SHORT_4_4_4_4;if(n===ae)return e.UNSIGNED_SHORT_5_5_5_1;if(n===re)return e.UNSIGNED_INT_5_9_9_9_REV;if(n===se)return e.UNSIGNED_INT_10F_11F_11F_REV;if(n===$)return e.BYTE;if(n===Q)return e.SHORT;if(n===K)return e.UNSIGNED_SHORT;if(n===Z)return e.INT;if(n===J)return e.UNSIGNED_INT;if(n===ee)return e.FLOAT;if(n===te)return e.HALF_FLOAT;if(n===oe)return e.ALPHA;if(n===le)return e.RGB;if(n===ce)return e.RGBA;if(n===he)return e.DEPTH_COMPONENT;if(n===de)return e.DEPTH_STENCIL;if(n===ue)return e.RED;if(n===pe)return e.RED_INTEGER;if(n===me)return e.RG;if(n===fe)return e.RG_INTEGER;if(n===ge)return e.RGBA_INTEGER;if(n===ye||n===ve||n===be||n===we)if(r===rt){if(i=t.get("WEBGL_compressed_texture_s3tc_srgb"),null===i)return null;if(n===ye)return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===ve)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===be)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===we)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(i=t.get("WEBGL_compressed_texture_s3tc"),null===i)return null;if(n===ye)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===ve)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===be)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===we)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===xe||n===Se||n===Me||n===_e){if(i=t.get("WEBGL_compressed_texture_pvrtc"),null===i)return null;if(n===xe)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===Se)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===Me)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===_e)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===Ae||n===Ce||n===Te){if(i=t.get("WEBGL_compressed_texture_etc"),null===i)return null;if(n===Ae||n===Ce)return r===rt?i.COMPRESSED_SRGB8_ETC2:i.COMPRESSED_RGB8_ETC2;if(n===Te)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:i.COMPRESSED_RGBA8_ETC2_EAC}if(n===Pe||n===De||n===Oe||n===Ee||n===Ie||n===ke||n===Re||n===ze||n===Fe||n===Be||n===Le||n===Ne||n===Ve||n===Ue){if(i=t.get("WEBGL_compressed_texture_astc"),null===i)return null;if(n===Pe)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:i.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===De)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:i.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===Oe)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:i.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===Ee)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:i.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===Ie)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:i.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===ke)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:i.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===Re)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:i.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===ze)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:i.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===Fe)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:i.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===Be)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:i.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Le)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:i.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===Ne)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:i.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===Ve)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:i.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===Ue)return r===rt?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:i.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===Ge||n===We||n===qe){if(i=t.get("EXT_texture_compression_bptc"),null===i)return null;if(n===Ge)return r===rt?i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:i.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===We)return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===qe)return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(n===He||n===je||n===Xe||n===Ye){if(i=t.get("EXT_texture_compression_rgtc"),null===i)return null;if(n===He)return i.COMPRESSED_RED_RGTC1_EXT;if(n===je)return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===Xe)return i.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===Ye)return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return n===ie?e.UNSIGNED_INT_24_8:void 0!==e[n]?e[n]:null}}}class jh{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t){if(null===this.texture){const n=new Jr(e.texture);e.depthNear===t.depthNear&&e.depthFar===t.depthFar||(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=n}}getMesh(e){if(null!==this.texture&&null===this.mesh){const t=e.cameras[0].viewport,n=new bi({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new ui(new ao(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class Xh extends Pt{constructor(e,t){super();const n=this;let a=null,i=1,r=null,s="local-floor",o=1,l=null,c=null,h=null,d=null,u=null,p=null;const m="undefined"!=typeof XRWebGLBinding,f=new jh,g={},y=t.getContextAttributes();let v=null,b=null;const w=[],x=[],S=new Vt;let M=null;const _=new _i;_.viewport=new ln;const A=new _i;A.viewport=new ln;const C=[_,A],T=new hl;let P=null,D=null;function O(e){const t=x.indexOf(e.inputSource);if(-1===t)return;const n=w[t];void 0!==n&&(n.update(e.inputSource,e.frame,l||r),n.dispatchEvent({type:e.type,data:e.inputSource}))}function E(){a.removeEventListener("select",O),a.removeEventListener("selectstart",O),a.removeEventListener("selectend",O),a.removeEventListener("squeeze",O),a.removeEventListener("squeezestart",O),a.removeEventListener("squeezeend",O),a.removeEventListener("end",E),a.removeEventListener("inputsourceschange",I);for(let e=0;e<w.length;e++){const t=x[e];null!==t&&(x[e]=null,w[e].disconnect(t))}P=null,D=null,f.reset();for(const e in g)delete g[e];e.setRenderTarget(v),u=null,d=null,h=null,a=null,b=null,B.stop(),n.isPresenting=!1,e.setPixelRatio(M),e.setSize(S.width,S.height,!1),n.dispatchEvent({type:"sessionend"})}function I(e){for(let t=0;t<e.removed.length;t++){const n=e.removed[t],a=x.indexOf(n);a>=0&&(x[a]=null,w[a].disconnect(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t];let a=x.indexOf(n);if(-1===a){for(let e=0;e<w.length;e++){if(e>=x.length){x.push(n),a=e;break}if(null===x[e]){x[e]=n,a=e;break}}if(-1===a)break}const i=w[a];i&&i.connect(n)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=w[e];return void 0===t&&(t=new Ei,w[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=w[e];return void 0===t&&(t=new Ei,w[e]=t),t.getGripSpace()},this.getHand=function(e){let t=w[e];return void 0===t&&(t=new Ei,w[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){i=e,!0===n.isPresenting&&At("WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){s=e,!0===n.isPresenting&&At("WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||r},this.setReferenceSpace=function(e){l=e},this.getBaseLayer=function(){return null!==d?d:u},this.getBinding=function(){return null===h&&m&&(h=new XRWebGLBinding(a,t)),h},this.getFrame=function(){return p},this.getSession=function(){return a},this.setSession=async function(c){if(a=c,null!==a){if(v=e.getRenderTarget(),a.addEventListener("select",O),a.addEventListener("selectstart",O),a.addEventListener("selectend",O),a.addEventListener("squeeze",O),a.addEventListener("squeezestart",O),a.addEventListener("squeezeend",O),a.addEventListener("end",E),a.addEventListener("inputsourceschange",I),!0!==y.xrCompatible&&await t.makeXRCompatible(),M=e.getPixelRatio(),e.getSize(S),m&&"createProjectionLayer"in XRWebGLBinding.prototype){let n=null,r=null,s=null;y.depth&&(s=y.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,n=y.stencil?de:he,r=y.stencil?ie:J);const o={colorFormat:t.RGBA8,depthFormat:s,scaleFactor:i};h=this.getBinding(),d=h.createProjectionLayer(o),a.updateRenderState({layers:[d]}),e.setPixelRatio(1),e.setSize(d.textureWidth,d.textureHeight,!1),b=new hn(d.textureWidth,d.textureHeight,{format:ce,type:Y,depthTexture:new Zr(d.textureWidth,d.textureHeight,r,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:y.stencil,colorSpace:e.outputColorSpace,samples:y.antialias?4:0,resolveDepthBuffer:!1===d.ignoreDepthValues,resolveStencilBuffer:!1===d.ignoreDepthValues})}else{const n={antialias:y.antialias,alpha:!0,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:i};u=new XRWebGLLayer(a,t,n),a.updateRenderState({baseLayer:u}),e.setPixelRatio(1),e.setSize(u.framebufferWidth,u.framebufferHeight,!1),b=new hn(u.framebufferWidth,u.framebufferHeight,{format:ce,type:Y,colorSpace:e.outputColorSpace,stencilBuffer:y.stencil,resolveDepthBuffer:!1===u.ignoreDepthValues,resolveStencilBuffer:!1===u.ignoreDepthValues})}b.isXRRenderTarget=!0,this.setFoveation(o),l=null,r=await a.requestReferenceSpace(s),B.setContext(a),B.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==a)return a.environmentBlendMode},this.getDepthTexture=function(){return f.getDepthTexture()};const k=new Gt,R=new Gt;function z(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=function(e){if(null===a)return;let t=e.near,n=e.far;null!==f.texture&&(f.depthNear>0&&(t=f.depthNear),f.depthFar>0&&(n=f.depthFar)),T.near=A.near=_.near=t,T.far=A.far=_.far=n,P===T.near&&D===T.far||(a.updateRenderState({depthNear:T.near,depthFar:T.far}),P=T.near,D=T.far),T.layers.mask=6|e.layers.mask,_.layers.mask=3&T.layers.mask,A.layers.mask=5&T.layers.mask;const i=e.parent,r=T.cameras;z(T,i);for(let e=0;e<r.length;e++)z(r[e],i);2===r.length?function(e,t,n){k.setFromMatrixPosition(t.matrixWorld),R.setFromMatrixPosition(n.matrixWorld);const a=k.distanceTo(R),i=t.projectionMatrix.elements,r=n.projectionMatrix.elements,s=i[14]/(i[10]-1),o=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],h=(i[8]-1)/i[0],d=(r[8]+1)/r[0],u=s*h,p=s*d,m=a/(-h+d),f=m*-h;if(t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(f),e.translateZ(m),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert(),-1===i[10])e.projectionMatrix.copy(t.projectionMatrix),e.projectionMatrixInverse.copy(t.projectionMatrixInverse);else{const t=s+m,n=o+m,i=u-f,r=p+(a-f),h=l*o/n*t,d=c*o/n*t;e.projectionMatrix.makePerspective(i,r,h,d,t,n),e.projectionMatrixInverse.copy(e.projectionMatrix).invert()}}(T,_,A):T.projectionMatrix.copy(_.projectionMatrix),function(e,t,n){null===n?e.matrix.copy(t.matrixWorld):(e.matrix.copy(n.matrixWorld),e.matrix.invert(),e.matrix.multiply(t.matrixWorld)),e.matrix.decompose(e.position,e.quaternion,e.scale),e.updateMatrixWorld(!0),e.projectionMatrix.copy(t.projectionMatrix),e.projectionMatrixInverse.copy(t.projectionMatrixInverse),e.isPerspectiveCamera&&(e.fov=2*It*Math.atan(1/e.projectionMatrix.elements[5]),e.zoom=1)}(e,T,i)},this.getCamera=function(){return T},this.getFoveation=function(){if(null!==d||null!==u)return o},this.setFoveation=function(e){o=e,null!==d&&(d.fixedFoveation=e),null!==u&&void 0!==u.fixedFoveation&&(u.fixedFoveation=e)},this.hasDepthSensing=function(){return null!==f.texture},this.getDepthSensingMesh=function(){return f.getMesh(T)},this.getCameraTexture=function(e){return g[e]};let F=null;const B=new Sl;B.setAnimationLoop(function(t,i){if(c=i.getViewerPose(l||r),p=i,null!==c){const t=c.views;null!==u&&(e.setRenderTargetFramebuffer(b,u.framebuffer),e.setRenderTarget(b));let i=!1;t.length!==T.cameras.length&&(T.cameras.length=0,i=!0);for(let n=0;n<t.length;n++){const a=t[n];let r=null;if(null!==u)r=u.getViewport(a);else{const t=h.getViewSubImage(d,a);r=t.viewport,0===n&&(e.setRenderTargetTextures(b,t.colorTexture,t.depthStencilTexture),e.setRenderTarget(b))}let s=C[n];void 0===s&&(s=new _i,s.layers.enable(n),s.viewport=new ln,C[n]=s),s.matrix.fromArray(a.transform.matrix),s.matrix.decompose(s.position,s.quaternion,s.scale),s.projectionMatrix.fromArray(a.projectionMatrix),s.projectionMatrixInverse.copy(s.projectionMatrix).invert(),s.viewport.set(r.x,r.y,r.width,r.height),0===n&&(T.matrix.copy(s.matrix),T.matrix.decompose(T.position,T.quaternion,T.scale)),!0===i&&T.cameras.push(s)}const r=a.enabledFeatures;if(r&&r.includes("depth-sensing")&&"gpu-optimized"==a.depthUsage&&m){h=n.getBinding();const e=h.getDepthInformation(t[0]);e&&e.isValid&&e.texture&&f.init(e,a.renderState)}if(r&&r.includes("camera-access")&&m){e.state.unbindTexture(),h=n.getBinding();for(let e=0;e<t.length;e++){const n=t[e].camera;if(n){let e=g[n];e||(e=new Jr,g[n]=e);const t=h.getCameraImage(n);e.sourceTexture=t}}}}for(let e=0;e<w.length;e++){const t=x[e],n=w[e];null!==t&&void 0!==n&&n.update(t,i,l||r)}F&&F(t,i),i.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:i}),p=null}),this.setAnimationLoop=function(e){F=e},this.dispose=function(){}}}const Yh=new Qn,$h=new Vn;function Qh(e,t){function n(e,t){!0===e.matrixAutoUpdate&&e.updateMatrix(),t.value.copy(e.matrix)}function a(e,a){e.opacity.value=a.opacity,a.color&&e.diffuse.value.copy(a.color),a.emissive&&e.emissive.value.copy(a.emissive).multiplyScalar(a.emissiveIntensity),a.map&&(e.map.value=a.map,n(a.map,e.mapTransform)),a.alphaMap&&(e.alphaMap.value=a.alphaMap,n(a.alphaMap,e.alphaMapTransform)),a.bumpMap&&(e.bumpMap.value=a.bumpMap,n(a.bumpMap,e.bumpMapTransform),e.bumpScale.value=a.bumpScale,1===a.side&&(e.bumpScale.value*=-1)),a.normalMap&&(e.normalMap.value=a.normalMap,n(a.normalMap,e.normalMapTransform),e.normalScale.value.copy(a.normalScale),1===a.side&&e.normalScale.value.negate()),a.displacementMap&&(e.displacementMap.value=a.displacementMap,n(a.displacementMap,e.displacementMapTransform),e.displacementScale.value=a.displacementScale,e.displacementBias.value=a.displacementBias),a.emissiveMap&&(e.emissiveMap.value=a.emissiveMap,n(a.emissiveMap,e.emissiveMapTransform)),a.specularMap&&(e.specularMap.value=a.specularMap,n(a.specularMap,e.specularMapTransform)),a.alphaTest>0&&(e.alphaTest.value=a.alphaTest);const i=t.get(a),r=i.envMap,s=i.envMapRotation;r&&(e.envMap.value=r,Yh.copy(s),Yh.x*=-1,Yh.y*=-1,Yh.z*=-1,r.isCubeTexture&&!1===r.isRenderTargetTexture&&(Yh.y*=-1,Yh.z*=-1),e.envMapRotation.value.setFromMatrix4($h.makeRotationFromEuler(Yh)),e.flipEnvMap.value=r.isCubeTexture&&!1===r.isRenderTargetTexture?-1:1,e.reflectivity.value=a.reflectivity,e.ior.value=a.ior,e.refractionRatio.value=a.refractionRatio),a.lightMap&&(e.lightMap.value=a.lightMap,e.lightMapIntensity.value=a.lightMapIntensity,n(a.lightMap,e.lightMapTransform)),a.aoMap&&(e.aoMap.value=a.aoMap,e.aoMapIntensity.value=a.aoMapIntensity,n(a.aoMap,e.aoMapTransform))}return{refreshFogUniforms:function(t,n){n.color.getRGB(t.fogColor.value,yi(e)),n.isFog?(t.fogNear.value=n.near,t.fogFar.value=n.far):n.isFogExp2&&(t.fogDensity.value=n.density)},refreshMaterialUniforms:function(e,i,r,s,o){i.isMeshBasicMaterial||i.isMeshLambertMaterial?a(e,i):i.isMeshToonMaterial?(a(e,i),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap)}(e,i)):i.isMeshPhongMaterial?(a(e,i),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4)}(e,i)):i.isMeshStandardMaterial?(a(e,i),function(e,t){e.metalness.value=t.metalness,t.metalnessMap&&(e.metalnessMap.value=t.metalnessMap,n(t.metalnessMap,e.metalnessMapTransform)),e.roughness.value=t.roughness,t.roughnessMap&&(e.roughnessMap.value=t.roughnessMap,n(t.roughnessMap,e.roughnessMapTransform)),t.envMap&&(e.envMapIntensity.value=t.envMapIntensity)}(e,i),i.isMeshPhysicalMaterial&&function(e,t,a){e.ior.value=t.ior,t.sheen>0&&(e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),e.sheenRoughness.value=t.sheenRoughness,t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap,n(t.sheenColorMap,e.sheenColorMapTransform)),t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap,n(t.sheenRoughnessMap,e.sheenRoughnessMapTransform))),t.clearcoat>0&&(e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap,n(t.clearcoatMap,e.clearcoatMapTransform)),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap,n(t.clearcoatRoughnessMap,e.clearcoatRoughnessMapTransform)),t.clearcoatNormalMap&&(e.clearcoatNormalMap.value=t.clearcoatNormalMap,n(t.clearcoatNormalMap,e.clearcoatNormalMapTransform),e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),1===t.side&&e.clearcoatNormalScale.value.negate())),t.dispersion>0&&(e.dispersion.value=t.dispersion),t.iridescence>0&&(e.iridescence.value=t.iridescence,e.iridescenceIOR.value=t.iridescenceIOR,e.iridescenceThicknessMinimum.value=t.iridescenceThicknessRange[0],e.iridescenceThicknessMaximum.value=t.iridescenceThicknessRange[1],t.iridescenceMap&&(e.iridescenceMap.value=t.iridescenceMap,n(t.iridescenceMap,e.iridescenceMapTransform)),t.iridescenceThicknessMap&&(e.iridescenceThicknessMap.value=t.iridescenceThicknessMap,n(t.iridescenceThicknessMap,e.iridescenceThicknessMapTransform))),t.transmission>0&&(e.transmission.value=t.transmission,e.transmissionSamplerMap.value=a.texture,e.transmissionSamplerSize.value.set(a.width,a.height),t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap,n(t.transmissionMap,e.transmissionMapTransform)),e.thickness.value=t.thickness,t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap,n(t.thicknessMap,e.thicknessMapTransform)),e.attenuationDistance.value=t.attenuationDistance,e.attenuationColor.value.copy(t.attenuationColor)),t.anisotropy>0&&(e.anisotropyVector.value.set(t.anisotropy*Math.cos(t.anisotropyRotation),t.anisotropy*Math.sin(t.anisotropyRotation)),t.anisotropyMap&&(e.anisotropyMap.value=t.anisotropyMap,n(t.anisotropyMap,e.anisotropyMapTransform))),e.specularIntensity.value=t.specularIntensity,e.specularColor.value.copy(t.specularColor),t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap,n(t.specularColorMap,e.specularColorMapTransform)),t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap,n(t.specularIntensityMap,e.specularIntensityMapTransform))}(e,i,o)):i.isMeshMatcapMaterial?(a(e,i),function(e,t){t.matcap&&(e.matcap.value=t.matcap)}(e,i)):i.isMeshDepthMaterial?a(e,i):i.isMeshDistanceMaterial?(a(e,i),function(e,n){const a=t.get(n).light;e.referencePosition.value.setFromMatrixPosition(a.matrixWorld),e.nearDistance.value=a.shadow.camera.near,e.farDistance.value=a.shadow.camera.far}(e,i)):i.isMeshNormalMaterial?a(e,i):i.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,t.map&&(e.map.value=t.map,n(t.map,e.mapTransform))}(e,i),i.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,i)):i.isPointsMaterial?function(e,t,a,i){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*a,e.scale.value=.5*i,t.map&&(e.map.value=t.map,n(t.map,e.uvTransform)),t.alphaMap&&(e.alphaMap.value=t.alphaMap,n(t.alphaMap,e.alphaMapTransform)),t.alphaTest>0&&(e.alphaTest.value=t.alphaTest)}(e,i,r,s):i.isSpriteMaterial?function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map,n(t.map,e.mapTransform)),t.alphaMap&&(e.alphaMap.value=t.alphaMap,n(t.alphaMap,e.alphaMapTransform)),t.alphaTest>0&&(e.alphaTest.value=t.alphaTest)}(e,i):i.isShadowMaterial?(e.color.value.copy(i.color),e.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function Kh(e,t,n,a){let i={},r={},s=[];const o=e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);function l(e,t,n,a){const i=e.value,r=t+"_"+n;if(void 0===a[r])return a[r]="number"==typeof i||"boolean"==typeof i?i:i.clone(),!0;{const e=a[r];if("number"==typeof i||"boolean"==typeof i){if(e!==i)return a[r]=i,!0}else if(!1===e.equals(i))return e.copy(i),!0}return!1}function c(e){const t={boundary:0,storage:0};return"number"==typeof e||"boolean"==typeof e?(t.boundary=4,t.storage=4):e.isVector2?(t.boundary=8,t.storage=8):e.isVector3||e.isColor?(t.boundary=16,t.storage=12):e.isVector4?(t.boundary=16,t.storage=16):e.isMatrix3?(t.boundary=48,t.storage=48):e.isMatrix4?(t.boundary=64,t.storage=64):e.isTexture?At("WebGLRenderer: Texture samplers can not be part of an uniforms group."):At("WebGLRenderer: Unsupported uniform value type.",e),t}function h(t){const n=t.target;n.removeEventListener("dispose",h);const a=s.indexOf(n.__bindingPointIndex);s.splice(a,1),e.deleteBuffer(i[n.id]),delete i[n.id],delete r[n.id]}return{bind:function(e,t){const n=t.program;a.uniformBlockBinding(e,n)},update:function(n,d){let u=i[n.id];void 0===u&&(function(e){const t=e.uniforms;let n=0;for(let e=0,a=t.length;e<a;e++){const a=Array.isArray(t[e])?t[e]:[t[e]];for(let e=0,t=a.length;e<t;e++){const t=a[e],i=Array.isArray(t.value)?t.value:[t.value];for(let e=0,a=i.length;e<a;e++){const a=c(i[e]),r=n%16,s=r%a.boundary,o=r+s;n+=s,0!==o&&16-o<a.storage&&(n+=16-o),t.__data=new Float32Array(a.storage/Float32Array.BYTES_PER_ELEMENT),t.__offset=n,n+=a.storage}}}const a=n%16;a>0&&(n+=16-a),e.__size=n,e.__cache={}}(n),u=function(t){const n=function(){for(let e=0;e<o;e++)if(-1===s.indexOf(e))return s.push(e),e;return Ct("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();t.__bindingPointIndex=n;const a=e.createBuffer(),i=t.__size,r=t.usage;return e.bindBuffer(e.UNIFORM_BUFFER,a),e.bufferData(e.UNIFORM_BUFFER,i,r),e.bindBuffer(e.UNIFORM_BUFFER,null),e.bindBufferBase(e.UNIFORM_BUFFER,n,a),a}(n),i[n.id]=u,n.addEventListener("dispose",h));const p=d.program;a.updateUBOMapping(n,p);const m=t.render.frame;r[n.id]!==m&&(function(t){const n=i[t.id],a=t.uniforms,r=t.__cache;e.bindBuffer(e.UNIFORM_BUFFER,n);for(let t=0,n=a.length;t<n;t++){const n=Array.isArray(a[t])?a[t]:[a[t]];for(let a=0,i=n.length;a<i;a++){const i=n[a];if(!0===l(i,t,a,r)){const t=i.__offset,n=Array.isArray(i.value)?i.value:[i.value];let a=0;for(let r=0;r<n.length;r++){const s=n[r],o=c(s);"number"==typeof s||"boolean"==typeof s?(i.__data[0]=s,e.bufferSubData(e.UNIFORM_BUFFER,t+a,i.__data)):s.isMatrix3?(i.__data[0]=s.elements[0],i.__data[1]=s.elements[1],i.__data[2]=s.elements[2],i.__data[3]=0,i.__data[4]=s.elements[3],i.__data[5]=s.elements[4],i.__data[6]=s.elements[5],i.__data[7]=0,i.__data[8]=s.elements[6],i.__data[9]=s.elements[7],i.__data[10]=s.elements[8],i.__data[11]=0):(s.toArray(i.__data,a),a+=o.storage/Float32Array.BYTES_PER_ELEMENT)}e.bufferSubData(e.UNIFORM_BUFFER,t,i.__data)}}}e.bindBuffer(e.UNIFORM_BUFFER,null)}(n),r[n.id]=m)},dispose:function(){for(const t in i)e.deleteBuffer(i[t]);s=[],i={},r={}}}}const Zh=new Uint16Array([11481,15204,11534,15171,11808,15015,12385,14843,12894,14716,13396,14600,13693,14483,13976,14366,14237,14171,14405,13961,14511,13770,14605,13598,14687,13444,14760,13305,14822,13066,14876,12857,14923,12675,14963,12517,14997,12379,15025,12230,15049,12023,15070,11843,15086,11687,15100,11551,15111,11433,15120,11330,15127,11217,15132,11060,15135,10922,15138,10801,15139,10695,15139,10600,13012,14923,13020,14917,13064,14886,13176,14800,13349,14666,13513,14526,13724,14398,13960,14230,14200,14020,14383,13827,14488,13651,14583,13491,14667,13348,14740,13132,14803,12908,14856,12713,14901,12542,14938,12394,14968,12241,14992,12017,15010,11822,15024,11654,15034,11507,15041,11380,15044,11269,15044,11081,15042,10913,15037,10764,15031,10635,15023,10520,15014,10419,15003,10330,13657,14676,13658,14673,13670,14660,13698,14622,13750,14547,13834,14442,13956,14317,14112,14093,14291,13889,14407,13704,14499,13538,14586,13389,14664,13201,14733,12966,14792,12758,14842,12577,14882,12418,14915,12272,14940,12033,14959,11826,14972,11646,14980,11490,14983,11355,14983,11212,14979,11008,14971,10830,14961,10675,14950,10540,14936,10420,14923,10315,14909,10204,14894,10041,14089,14460,14090,14459,14096,14452,14112,14431,14141,14388,14186,14305,14252,14130,14341,13941,14399,13756,14467,13585,14539,13430,14610,13272,14677,13026,14737,12808,14790,12617,14833,12449,14869,12303,14896,12065,14916,11845,14929,11655,14937,11490,14939,11347,14936,11184,14930,10970,14921,10783,14912,10621,14900,10480,14885,10356,14867,10247,14848,10062,14827,9894,14805,9745,14400,14208,14400,14206,14402,14198,14406,14174,14415,14122,14427,14035,14444,13913,14469,13767,14504,13613,14548,13463,14598,13324,14651,13082,14704,12858,14752,12658,14795,12483,14831,12330,14860,12106,14881,11875,14895,11675,14903,11501,14905,11351,14903,11178,14900,10953,14892,10757,14880,10589,14865,10442,14847,10313,14827,10162,14805,9965,14782,9792,14757,9642,14731,9507,14562,13883,14562,13883,14563,13877,14566,13862,14570,13830,14576,13773,14584,13689,14595,13582,14613,13461,14637,13336,14668,13120,14704,12897,14741,12695,14776,12516,14808,12358,14835,12150,14856,11910,14870,11701,14878,11519,14882,11361,14884,11187,14880,10951,14871,10748,14858,10572,14842,10418,14823,10286,14801,10099,14777,9897,14751,9722,14725,9567,14696,9430,14666,9309,14702,13604,14702,13604,14702,13600,14703,13591,14705,13570,14707,13533,14709,13477,14712,13400,14718,13305,14727,13106,14743,12907,14762,12716,14784,12539,14807,12380,14827,12190,14844,11943,14855,11727,14863,11539,14870,11376,14871,11204,14868,10960,14858,10748,14845,10565,14829,10406,14809,10269,14786,10058,14761,9852,14734,9671,14705,9512,14674,9374,14641,9253,14608,9076,14821,13366,14821,13365,14821,13364,14821,13358,14821,13344,14821,13320,14819,13252,14817,13145,14815,13011,14814,12858,14817,12698,14823,12539,14832,12389,14841,12214,14850,11968,14856,11750,14861,11558,14866,11390,14867,11226,14862,10972,14853,10754,14840,10565,14823,10401,14803,10259,14780,10032,14754,9820,14725,9635,14694,9473,14661,9333,14627,9203,14593,8988,14557,8798,14923,13014,14922,13014,14922,13012,14922,13004,14920,12987,14919,12957,14915,12907,14909,12834,14902,12738,14894,12623,14888,12498,14883,12370,14880,12203,14878,11970,14875,11759,14873,11569,14874,11401,14872,11243,14865,10986,14855,10762,14842,10568,14825,10401,14804,10255,14781,10017,14754,9799,14725,9611,14692,9445,14658,9301,14623,9139,14587,8920,14548,8729,14509,8562,15008,12672,15008,12672,15008,12671,15007,12667,15005,12656,15001,12637,14997,12605,14989,12556,14978,12490,14966,12407,14953,12313,14940,12136,14927,11934,14914,11742,14903,11563,14896,11401,14889,11247,14879,10992,14866,10767,14851,10570,14833,10400,14812,10252,14789,10007,14761,9784,14731,9592,14698,9424,14663,9279,14627,9088,14588,8868,14548,8676,14508,8508,14467,8360,15080,12386,15080,12386,15079,12385,15078,12383,15076,12378,15072,12367,15066,12347,15057,12315,15045,12253,15030,12138,15012,11998,14993,11845,14972,11685,14951,11530,14935,11383,14920,11228,14904,10981,14887,10762,14870,10567,14850,10397,14827,10248,14803,9997,14774,9771,14743,9578,14710,9407,14674,9259,14637,9048,14596,8826,14555,8632,14514,8464,14471,8317,14427,8182,15139,12008,15139,12008,15138,12008,15137,12007,15135,12003,15130,11990,15124,11969,15115,11929,15102,11872,15086,11794,15064,11693,15041,11581,15013,11459,14987,11336,14966,11170,14944,10944,14921,10738,14898,10552,14875,10387,14850,10239,14824,9983,14794,9758,14762,9563,14728,9392,14692,9244,14653,9014,14611,8791,14569,8597,14526,8427,14481,8281,14436,8110,14391,7885,15188,11617,15188,11617,15187,11617,15186,11618,15183,11617,15179,11612,15173,11601,15163,11581,15150,11546,15133,11495,15110,11427,15083,11346,15051,11246,15024,11057,14996,10868,14967,10687,14938,10517,14911,10362,14882,10206,14853,9956,14821,9737,14787,9543,14752,9375,14715,9228,14675,8980,14632,8760,14589,8565,14544,8395,14498,8248,14451,8049,14404,7824,14357,7630,15228,11298,15228,11298,15227,11299,15226,11301,15223,11303,15219,11302,15213,11299,15204,11290,15191,11271,15174,11217,15150,11129,15119,11015,15087,10886,15057,10744,15024,10599,14990,10455,14957,10318,14924,10143,14891,9911,14856,9701,14820,9516,14782,9352,14744,9200,14703,8946,14659,8725,14615,8533,14568,8366,14521,8220,14472,7992,14423,7770,14374,7578,14315,7408,15260,10819,15260,10819,15259,10822,15258,10826,15256,10832,15251,10836,15246,10841,15237,10838,15225,10821,15207,10788,15183,10734,15151,10660,15120,10571,15087,10469,15049,10359,15012,10249,14974,10041,14937,9837,14900,9647,14860,9475,14820,9320,14779,9147,14736,8902,14691,8688,14646,8499,14598,8335,14549,8189,14499,7940,14448,7720,14397,7529,14347,7363,14256,7218,15285,10410,15285,10411,15285,10413,15284,10418,15282,10425,15278,10434,15272,10442,15264,10449,15252,10445,15235,10433,15210,10403,15179,10358,15149,10301,15113,10218,15073,10059,15033,9894,14991,9726,14951,9565,14909,9413,14865,9273,14822,9073,14777,8845,14730,8641,14682,8459,14633,8300,14583,8129,14531,7883,14479,7670,14426,7482,14373,7321,14305,7176,14201,6939,15305,9939,15305,9940,15305,9945,15304,9955,15302,9967,15298,9989,15293,10010,15286,10033,15274,10044,15258,10045,15233,10022,15205,9975,15174,9903,15136,9808,15095,9697,15053,9578,15009,9451,14965,9327,14918,9198,14871,8973,14825,8766,14775,8579,14725,8408,14675,8259,14622,8058,14569,7821,14515,7615,14460,7435,14405,7276,14350,7108,14256,6866,14149,6653,15321,9444,15321,9445,15321,9448,15320,9458,15317,9470,15314,9490,15310,9515,15302,9540,15292,9562,15276,9579,15251,9577,15226,9559,15195,9519,15156,9463,15116,9389,15071,9304,15025,9208,14978,9023,14927,8838,14878,8661,14827,8496,14774,8344,14722,8206,14667,7973,14612,7749,14556,7555,14499,7382,14443,7229,14385,7025,14322,6791,14210,6588,14100,6409,15333,8920,15333,8921,15332,8927,15332,8943,15329,8965,15326,9002,15322,9048,15316,9106,15307,9162,15291,9204,15267,9221,15244,9221,15212,9196,15175,9134,15133,9043,15088,8930,15040,8801,14990,8665,14938,8526,14886,8391,14830,8261,14775,8087,14719,7866,14661,7664,14603,7482,14544,7322,14485,7178,14426,6936,14367,6713,14281,6517,14166,6348,14054,6198,15341,8360,15341,8361,15341,8366,15341,8379,15339,8399,15336,8431,15332,8473,15326,8527,15318,8585,15302,8632,15281,8670,15258,8690,15227,8690,15191,8664,15149,8612,15104,8543,15055,8456,15001,8360,14948,8259,14892,8122,14834,7923,14776,7734,14716,7558,14656,7397,14595,7250,14534,7070,14472,6835,14410,6628,14350,6443,14243,6283,14125,6135,14010,5889,15348,7715,15348,7717,15348,7725,15347,7745,15345,7780,15343,7836,15339,7905,15334,8e3,15326,8103,15310,8193,15293,8239,15270,8270,15240,8287,15204,8283,15163,8260,15118,8223,15067,8143,15014,8014,14958,7873,14899,7723,14839,7573,14778,7430,14715,7293,14652,7164,14588,6931,14524,6720,14460,6531,14396,6362,14330,6210,14207,6015,14086,5781,13969,5576,15352,7114,15352,7116,15352,7128,15352,7159,15350,7195,15348,7237,15345,7299,15340,7374,15332,7457,15317,7544,15301,7633,15280,7703,15251,7754,15216,7775,15176,7767,15131,7733,15079,7670,15026,7588,14967,7492,14906,7387,14844,7278,14779,7171,14714,6965,14648,6770,14581,6587,14515,6420,14448,6269,14382,6123,14299,5881,14172,5665,14049,5477,13929,5310,15355,6329,15355,6330,15355,6339,15355,6362,15353,6410,15351,6472,15349,6572,15344,6688,15337,6835,15323,6985,15309,7142,15287,7220,15260,7277,15226,7310,15188,7326,15142,7318,15090,7285,15036,7239,14976,7177,14914,7045,14849,6892,14782,6736,14714,6581,14645,6433,14576,6293,14506,6164,14438,5946,14369,5733,14270,5540,14140,5369,14014,5216,13892,5043,15357,5483,15357,5484,15357,5496,15357,5528,15356,5597,15354,5692,15351,5835,15347,6011,15339,6195,15328,6317,15314,6446,15293,6566,15268,6668,15235,6746,15197,6796,15152,6811,15101,6790,15046,6748,14985,6673,14921,6583,14854,6479,14785,6371,14714,6259,14643,6149,14571,5946,14499,5750,14428,5567,14358,5401,14242,5250,14109,5111,13980,4870,13856,4657,15359,4555,15359,4557,15358,4573,15358,4633,15357,4715,15355,4841,15353,5061,15349,5216,15342,5391,15331,5577,15318,5770,15299,5967,15274,6150,15243,6223,15206,6280,15161,6310,15111,6317,15055,6300,14994,6262,14928,6208,14860,6141,14788,5994,14715,5838,14641,5684,14566,5529,14492,5384,14418,5247,14346,5121,14216,4892,14079,4682,13948,4496,13822,4330,15359,3498,15359,3501,15359,3520,15359,3598,15358,3719,15356,3860,15355,4137,15351,4305,15344,4563,15334,4809,15321,5116,15303,5273,15280,5418,15250,5547,15214,5653,15170,5722,15120,5761,15064,5763,15002,5733,14935,5673,14865,5597,14792,5504,14716,5400,14640,5294,14563,5185,14486,5041,14410,4841,14335,4655,14191,4482,14051,4325,13918,4183,13790,4012,15360,2282,15360,2285,15360,2306,15360,2401,15359,2547,15357,2748,15355,3103,15352,3349,15345,3675,15336,4020,15324,4272,15307,4496,15285,4716,15255,4908,15220,5086,15178,5170,15128,5214,15072,5234,15010,5231,14943,5206,14871,5166,14796,5102,14718,4971,14639,4833,14559,4687,14480,4541,14402,4401,14315,4268,14167,4142,14025,3958,13888,3747,13759,3556,15360,923,15360,925,15360,946,15360,1052,15359,1214,15357,1494,15356,1892,15352,2274,15346,2663,15338,3099,15326,3393,15309,3679,15288,3980,15260,4183,15226,4325,15185,4437,15136,4517,15080,4570,15018,4591,14950,4581,14877,4545,14800,4485,14720,4411,14638,4325,14556,4231,14475,4136,14395,3988,14297,3803,14145,3628,13999,3465,13861,3314,13729,3177,15360,263,15360,264,15360,272,15360,325,15359,407,15358,548,15356,780,15352,1144,15347,1580,15339,2099,15328,2425,15312,2795,15292,3133,15264,3329,15232,3517,15191,3689,15143,3819,15088,3923,15025,3978,14956,3999,14882,3979,14804,3931,14722,3855,14639,3756,14554,3645,14470,3529,14388,3409,14279,3289,14124,3173,13975,3055,13834,2848,13701,2658,15360,49,15360,49,15360,52,15360,75,15359,111,15358,201,15356,283,15353,519,15348,726,15340,1045,15329,1415,15314,1795,15295,2173,15269,2410,15237,2649,15197,2866,15150,3054,15095,3140,15032,3196,14963,3228,14888,3236,14808,3224,14725,3191,14639,3146,14553,3088,14466,2976,14382,2836,14262,2692,14103,2549,13952,2409,13808,2278,13674,2154,15360,4,15360,4,15360,4,15360,13,15359,33,15358,59,15357,112,15353,199,15348,302,15341,456,15331,628,15316,827,15297,1082,15272,1332,15241,1601,15202,1851,15156,2069,15101,2172,15039,2256,14970,2314,14894,2348,14813,2358,14728,2344,14640,2311,14551,2263,14463,2203,14376,2133,14247,2059,14084,1915,13930,1761,13784,1609,13648,1464,15360,0,15360,0,15360,0,15360,3,15359,18,15358,26,15357,53,15354,80,15348,97,15341,165,15332,238,15318,326,15299,427,15275,529,15245,654,15207,771,15161,885,15108,994,15046,1089,14976,1170,14900,1229,14817,1266,14731,1284,14641,1282,14550,1260,14460,1223,14370,1174,14232,1116,14066,1050,13909,981,13761,910,13623,839]);let Jh=null;class ed{constructor(t={}){const{canvas:n=St(),context:a=null,depth:i=!0,stencil:r=!1,alpha:s=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:d=!1,reversedDepthBuffer:u=!1}=t;let p;if(this.isWebGLRenderer=!0,null!==a){if("undefined"!=typeof WebGLRenderingContext&&a instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");p=a.getContextAttributes().alpha}else p=s;const m=new Set([ge,fe,pe]),f=new Set([Y,J,K,ie,ne,ae]),g=new Uint32Array(4),y=new Int32Array(4);let v=null,b=null;const w=[],x=[];this.domElement=n,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=0,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const S=this;let M=!1;this._outputColorSpace=nt;let _=0,A=0,C=null,T=-1,P=null;const D=new ln,O=new ln;let E=null;const I=new Ia(0);let k=0,R=n.width,z=n.height,F=1,B=null,L=null;const N=new ln(0,0,R,z),U=new ln(0,0,R,z);let G=!1;const W=new Dr;let q=!1,j=!1;const $=new Vn,Q=new Gt,Z=new ln,ee={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let re=!1;function se(){return null===C?F:1}let oe,le,ce,he,de,ue,ye,ve,be,we,xe,Se,Me,_e,Ae,Ce,Te,Pe,De,Oe,Ee,Ie,ke,Re,ze=a;function Fe(e,t){return n.getContext(e,t)}try{const t={alpha:!0,depth:i,stencil:r,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:d};if("setAttribute"in n&&n.setAttribute("data-engine",`three.js r${e}`),n.addEventListener("webglcontextlost",Ne,!1),n.addEventListener("webglcontextrestored",Ve,!1),n.addEventListener("webglcontextcreationerror",Ue,!1),null===ze){const e="webgl2";if(ze=Fe(e,t),null===ze)throw Fe(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(e){throw e("WebGLRenderer: "+e.message),e}function Be(){oe=new Ql(ze),oe.init(),Ie=new Hh(ze,oe),le=new kl(ze,oe,t,Ie),ce=new Wh(ze,oe),le.reversedDepthBuffer&&u&&ce.buffers.depth.setReversed(!0),he=new Jl(ze),de=new Oh,ue=new qh(ze,oe,ce,de,le,Ie,he),ye=new zl(S),ve=new $l(S),be=new Ml(ze),ke=new El(ze,be),we=new Kl(ze,be,he,ke),xe=new tc(ze,we,be,he),De=new ec(ze,le,ue),Ce=new Rl(de),Se=new Dh(S,ye,ve,oe,le,ke,Ce),Me=new Qh(S,de),_e=new Rh,Ae=new Vh(oe),Pe=new Ol(S,ye,ve,ce,xe,p,l),Te=new Uh(S,xe,le),Re=new Kh(ze,he,le,ce),Oe=new Il(ze,oe,he),Ee=new Zl(ze,oe,he),he.programs=Se.programs,S.capabilities=le,S.extensions=oe,S.properties=de,S.renderLists=_e,S.shadowMap=Te,S.state=ce,S.info=he}Be();const Le=new Xh(S,ze);function Ne(e){e.preventDefault(),_t("WebGLRenderer: Context Lost."),M=!0}function Ve(){_t("WebGLRenderer: Context Restored."),M=!1;const e=he.autoReset,t=Te.enabled,n=Te.autoUpdate,a=Te.needsUpdate,i=Te.type;Be(),he.autoReset=e,Te.enabled=t,Te.autoUpdate=n,Te.needsUpdate=a,Te.type=i}function Ue(e){Ct("WebGLRenderer: A WebGL context could not be created. Reason: ",e.statusMessage)}function Ge(e){const t=e.target;t.removeEventListener("dispose",Ge),function(e){(function(e){const t=de.get(e).programs;void 0!==t&&(t.forEach(function(e){Se.releaseProgram(e)}),e.isShaderMaterial&&Se.releaseShaderCache(e))})(e),de.remove(e)}(t)}function We(e,t,n){!0===e.transparent&&2===e.side&&!1===e.forceSinglePass?(e.side=1,e.needsUpdate=!0,Je(e,t,n),e.side=0,e.needsUpdate=!0,Je(e,t,n),e.side=2):Je(e,t,n)}this.xr=Le,this.getContext=function(){return ze},this.getContextAttributes=function(){return ze.getContextAttributes()},this.forceContextLoss=function(){const e=oe.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=oe.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return F},this.setPixelRatio=function(e){void 0!==e&&(F=e,this.setSize(R,z,!1))},this.getSize=function(e){return e.set(R,z)},this.setSize=function(e,t,a=!0){Le.isPresenting?At("WebGLRenderer: Can't change size while VR device is presenting."):(R=e,z=t,n.width=Math.floor(e*F),n.height=Math.floor(t*F),!0===a&&(n.style.width=e+"px",n.style.height=t+"px"),this.setViewport(0,0,e,t))},this.getDrawingBufferSize=function(e){return e.set(R*F,z*F).floor()},this.setDrawingBufferSize=function(e,t,a){R=e,z=t,F=a,n.width=Math.floor(e*a),n.height=Math.floor(t*a),this.setViewport(0,0,e,t)},this.getCurrentViewport=function(e){return e.copy(D)},this.getViewport=function(e){return e.copy(N)},this.setViewport=function(e,t,n,a){e.isVector4?N.set(e.x,e.y,e.z,e.w):N.set(e,t,n,a),ce.viewport(D.copy(N).multiplyScalar(F).round())},this.getScissor=function(e){return e.copy(U)},this.setScissor=function(e,t,n,a){e.isVector4?U.set(e.x,e.y,e.z,e.w):U.set(e,t,n,a),ce.scissor(O.copy(U).multiplyScalar(F).round())},this.getScissorTest=function(){return G},this.setScissorTest=function(e){ce.setScissorTest(G=e)},this.setOpaqueSort=function(e){B=e},this.setTransparentSort=function(e){L=e},this.getClearColor=function(e){return e.copy(Pe.getClearColor())},this.setClearColor=function(){Pe.setClearColor(...arguments)},this.getClearAlpha=function(){return Pe.getClearAlpha()},this.setClearAlpha=function(){Pe.setClearAlpha(...arguments)},this.clear=function(e=!0,t=!0,n=!0){let a=0;if(e){let e=!1;if(null!==C){const t=C.texture.format;e=m.has(t)}if(e){const e=C.texture.type,t=f.has(e),n=Pe.getClearColor(),a=Pe.getClearAlpha(),i=n.r,r=n.g,s=n.b;t?(g[0]=i,g[1]=r,g[2]=s,g[3]=a,ze.clearBufferuiv(ze.COLOR,0,g)):(y[0]=i,y[1]=r,y[2]=s,y[3]=a,ze.clearBufferiv(ze.COLOR,0,y))}else a|=ze.COLOR_BUFFER_BIT}t&&(a|=ze.DEPTH_BUFFER_BIT),n&&(a|=ze.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),ze.clear(a)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){n.removeEventListener("webglcontextlost",Ne,!1),n.removeEventListener("webglcontextrestored",Ve,!1),n.removeEventListener("webglcontextcreationerror",Ue,!1),Pe.dispose(),_e.dispose(),Ae.dispose(),de.dispose(),ye.dispose(),ve.dispose(),xe.dispose(),ke.dispose(),Re.dispose(),Se.dispose(),Le.dispose(),Le.removeEventListener("sessionstart",He),Le.removeEventListener("sessionend",je),Xe.stop()},this.renderBufferDirect=function(e,t,n,a,i,r){null===t&&(t=ee);const s=i.isMesh&&i.matrixWorld.determinant()<0,o=function(e,t,n,a,i){!0!==t.isScene&&(t=ee),ue.resetTextureUnits();const r=t.fog,s=a.isMeshStandardMaterial?t.environment:null,o=null===C?S.outputColorSpace:!0===C.isXRRenderTarget?C.texture.colorSpace:at,l=(a.isMeshStandardMaterial?ve:ye).get(a.envMap||s),c=!0===a.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,h=!!n.attributes.tangent&&(!!a.normalMap||a.anisotropy>0),d=!!n.morphAttributes.position,u=!!n.morphAttributes.normal,p=!!n.morphAttributes.color;let m=0;a.toneMapped&&(null!==C&&!0!==C.isXRRenderTarget||(m=S.toneMapping));const f=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,g=void 0!==f?f.length:0,y=de.get(a),v=b.state.lights;if(!0===q&&(!0===j||e!==P)){const t=e===P&&a.id===T;Ce.setState(a,e,t)}let w=!1;a.version===y.__version?y.needsLights&&y.lightsStateVersion!==v.state.version||y.outputColorSpace!==o||i.isBatchedMesh&&!1===y.batching?w=!0:i.isBatchedMesh||!0!==y.batching?i.isBatchedMesh&&!0===y.batchingColor&&null===i.colorTexture||i.isBatchedMesh&&!1===y.batchingColor&&null!==i.colorTexture||i.isInstancedMesh&&!1===y.instancing?w=!0:i.isInstancedMesh||!0!==y.instancing?i.isSkinnedMesh&&!1===y.skinning?w=!0:i.isSkinnedMesh||!0!==y.skinning?i.isInstancedMesh&&!0===y.instancingColor&&null===i.instanceColor||i.isInstancedMesh&&!1===y.instancingColor&&null!==i.instanceColor||i.isInstancedMesh&&!0===y.instancingMorph&&null===i.morphTexture||i.isInstancedMesh&&!1===y.instancingMorph&&null!==i.morphTexture||y.envMap!==l||!0===a.fog&&y.fog!==r?w=!0:void 0===y.numClippingPlanes||y.numClippingPlanes===Ce.numPlanes&&y.numIntersection===Ce.numIntersection?(y.vertexAlphas!==c||y.vertexTangents!==h||y.morphTargets!==d||y.morphNormals!==u||y.morphColors!==p||y.toneMapping!==m||y.morphTargetsCount!==g)&&(w=!0):w=!0:w=!0:w=!0:w=!0:(w=!0,y.__version=a.version);let x=y.currentProgram;!0===w&&(x=Je(a,t,i));let M=!1,_=!1,A=!1;const D=x.getUniforms(),O=y.uniforms;if(ce.useProgram(x.program)&&(M=!0,_=!0,A=!0),a.id!==T&&(T=a.id,_=!0),M||P!==e){ce.buffers.depth.getReversed()&&!0!==e.reversedDepth&&(e._reversedDepth=!0,e.updateProjectionMatrix()),D.setValue(ze,"projectionMatrix",e.projectionMatrix),D.setValue(ze,"viewMatrix",e.matrixWorldInverse);const t=D.map.cameraPosition;void 0!==t&&t.setValue(ze,Q.setFromMatrixPosition(e.matrixWorld)),le.logarithmicDepthBuffer&&D.setValue(ze,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),(a.isMeshPhongMaterial||a.isMeshToonMaterial||a.isMeshLambertMaterial||a.isMeshBasicMaterial||a.isMeshStandardMaterial||a.isShaderMaterial)&&D.setValue(ze,"isOrthographic",!0===e.isOrthographicCamera),P!==e&&(P=e,_=!0,A=!0)}if(i.isSkinnedMesh){D.setOptional(ze,i,"bindMatrix"),D.setOptional(ze,i,"bindMatrixInverse");const e=i.skeleton;e&&(null===e.boneTexture&&e.computeBoneTexture(),D.setValue(ze,"boneTexture",e.boneTexture,ue))}i.isBatchedMesh&&(D.setOptional(ze,i,"batchingTexture"),D.setValue(ze,"batchingTexture",i._matricesTexture,ue),D.setOptional(ze,i,"batchingIdTexture"),D.setValue(ze,"batchingIdTexture",i._indirectTexture,ue),D.setOptional(ze,i,"batchingColorTexture"),null!==i._colorsTexture&&D.setValue(ze,"batchingColorTexture",i._colorsTexture,ue));const E=n.morphAttributes;var I,k;if(void 0===E.position&&void 0===E.normal&&void 0===E.color||De.update(i,n,x),(_||y.receiveShadow!==i.receiveShadow)&&(y.receiveShadow=i.receiveShadow,D.setValue(ze,"receiveShadow",i.receiveShadow)),a.isMeshGouraudMaterial&&null!==a.envMap&&(O.envMap.value=l,O.flipEnvMap.value=l.isCubeTexture&&!1===l.isRenderTargetTexture?-1:1),a.isMeshStandardMaterial&&null===a.envMap&&null!==t.environment&&(O.envMapIntensity.value=t.environmentIntensity),void 0!==O.dfgLUT&&(O.dfgLUT.value=(null===Jh&&(Jh=new cr(Zh,32,32,me,te),Jh.minFilter=H,Jh.magFilter=H,Jh.wrapS=V,Jh.wrapT=V,Jh.generateMipmaps=!1,Jh.needsUpdate=!0),Jh)),_&&(D.setValue(ze,"toneMappingExposure",S.toneMappingExposure),y.needsLights&&(k=A,(I=O).ambientLightColor.needsUpdate=k,I.lightProbe.needsUpdate=k,I.directionalLights.needsUpdate=k,I.directionalLightShadows.needsUpdate=k,I.pointLights.needsUpdate=k,I.pointLightShadows.needsUpdate=k,I.spotLights.needsUpdate=k,I.spotLightShadows.needsUpdate=k,I.rectAreaLights.needsUpdate=k,I.hemisphereLights.needsUpdate=k),r&&!0===a.fog&&Me.refreshFogUniforms(O,r),Me.refreshMaterialUniforms(O,a,F,z,b.state.transmissionRenderTarget[e.id]),sh.upload(ze,et(y),O,ue)),a.isShaderMaterial&&!0===a.uniformsNeedUpdate&&(sh.upload(ze,et(y),O,ue),a.uniformsNeedUpdate=!1),a.isSpriteMaterial&&D.setValue(ze,"center",i.center),D.setValue(ze,"modelViewMatrix",i.modelViewMatrix),D.setValue(ze,"normalMatrix",i.normalMatrix),D.setValue(ze,"modelMatrix",i.matrixWorld),a.isShaderMaterial||a.isRawShaderMaterial){const e=a.uniformsGroups;for(let t=0,n=e.length;t<n;t++){const n=e[t];Re.update(n,x),Re.bind(n,x)}}return x}(e,t,n,a,i);ce.setMaterial(a,s);let l=n.index,c=1;if(!0===a.wireframe){if(l=we.getWireframeAttribute(n),void 0===l)return;c=2}const h=n.drawRange,d=n.attributes.position;let u=h.start*c,p=(h.start+h.count)*c;null!==r&&(u=Math.max(u,r.start*c),p=Math.min(p,(r.start+r.count)*c)),null!==l?(u=Math.max(u,0),p=Math.min(p,l.count)):null!=d&&(u=Math.max(u,0),p=Math.min(p,d.count));const m=p-u;if(m<0||m===1/0)return;let f;ke.setup(i,a,o,n,l);let g=Oe;if(null!==l&&(f=be.get(l),g=Ee,g.setIndex(f)),i.isMesh)!0===a.wireframe?(ce.setLineWidth(a.wireframeLinewidth*se()),g.setMode(ze.LINES)):g.setMode(ze.TRIANGLES);else if(i.isLine){let e=a.linewidth;void 0===e&&(e=1),ce.setLineWidth(e*se()),i.isLineSegments?g.setMode(ze.LINES):i.isLineLoop?g.setMode(ze.LINE_LOOP):g.setMode(ze.LINE_STRIP)}else i.isPoints?g.setMode(ze.POINTS):i.isSprite&&g.setMode(ze.TRIANGLES);if(i.isBatchedMesh)if(null!==i._multiDrawInstances)Tt("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),g.renderMultiDrawInstances(i._multiDrawStarts,i._multiDrawCounts,i._multiDrawCount,i._multiDrawInstances);else if(oe.get("WEBGL_multi_draw"))g.renderMultiDraw(i._multiDrawStarts,i._multiDrawCounts,i._multiDrawCount);else{const e=i._multiDrawStarts,t=i._multiDrawCounts,n=i._multiDrawCount,r=l?be.get(l).bytesPerElement:1,s=de.get(a).currentProgram.getUniforms();for(let a=0;a<n;a++)s.setValue(ze,"_gl_DrawID",a),g.render(e[a]/r,t[a])}else if(i.isInstancedMesh)g.renderInstances(u,m,i.count);else if(n.isInstancedBufferGeometry){const e=void 0!==n._maxInstanceCount?n._maxInstanceCount:1/0,t=Math.min(n.instanceCount,e);g.renderInstances(u,m,t)}else g.render(u,m)},this.compile=function(e,t,n=null){null===n&&(n=e),b=Ae.get(n),b.init(t),x.push(b),n.traverseVisible(function(e){e.isLight&&e.layers.test(t.layers)&&(b.pushLight(e),e.castShadow&&b.pushShadow(e))}),e!==n&&e.traverseVisible(function(e){e.isLight&&e.layers.test(t.layers)&&(b.pushLight(e),e.castShadow&&b.pushShadow(e))}),b.setupLights();const a=new Set;return e.traverse(function(e){if(!(e.isMesh||e.isPoints||e.isLine||e.isSprite))return;const t=e.material;if(t)if(Array.isArray(t))for(let i=0;i<t.length;i++){const r=t[i];We(r,n,e),a.add(r)}else We(t,n,e),a.add(t)}),b=x.pop(),a},this.compileAsync=function(e,t,n=null){const a=this.compile(e,t,n);return new Promise(t=>{function n(){a.forEach(function(e){de.get(e).currentProgram.isReady()&&a.delete(e)}),0!==a.size?setTimeout(n,10):t(e)}null!==oe.get("KHR_parallel_shader_compile")?n():setTimeout(n,10)})};let qe=null;function He(){Xe.stop()}function je(){Xe.start()}const Xe=new Sl;function Ye(e,t,n,a){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)b.pushLight(e),e.castShadow&&b.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||W.intersectsSprite(e)){a&&Z.setFromMatrixPosition(e.matrixWorld).applyMatrix4($);const t=xe.update(e),i=e.material;i.visible&&v.push(e,t,i,n,Z.z,null)}}else if((e.isMesh||e.isLine||e.isPoints)&&(!e.frustumCulled||W.intersectsObject(e))){const t=xe.update(e),i=e.material;if(a&&(void 0!==e.boundingSphere?(null===e.boundingSphere&&e.computeBoundingSphere(),Z.copy(e.boundingSphere.center)):(null===t.boundingSphere&&t.computeBoundingSphere(),Z.copy(t.boundingSphere.center)),Z.applyMatrix4(e.matrixWorld).applyMatrix4($)),Array.isArray(i)){const a=t.groups;for(let r=0,s=a.length;r<s;r++){const s=a[r],o=i[s.materialIndex];o&&o.visible&&v.push(e,t,o,n,Z.z,s)}}else i.visible&&v.push(e,t,i,n,Z.z,null)}const i=e.children;for(let e=0,r=i.length;e<r;e++)Ye(i[e],t,n,a)}function $e(e,t,n,a){const{opaque:i,transmissive:r,transparent:s}=e;b.setupLightsView(n),!0===q&&Ce.setGlobalState(S.clippingPlanes,n),a&&ce.viewport(D.copy(a)),i.length>0&&Ke(i,t,n),r.length>0&&Ke(r,t,n),s.length>0&&Ke(s,t,n),ce.buffers.depth.setTest(!0),ce.buffers.depth.setMask(!0),ce.buffers.color.setMask(!0),ce.setPolygonOffset(!1)}function Qe(e,t,n,a){if(null!==(!0===n.isScene?n.overrideMaterial:null))return;void 0===b.state.transmissionRenderTarget[a.id]&&(b.state.transmissionRenderTarget[a.id]=new hn(1,1,{generateMipmaps:!0,type:oe.has("EXT_color_buffer_half_float")||oe.has("EXT_color_buffer_float")?te:Y,minFilter:X,samples:4,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:Qt.workingColorSpace}));const i=b.state.transmissionRenderTarget[a.id],s=a.viewport||D;i.setSize(s.z*S.transmissionResolutionScale,s.w*S.transmissionResolutionScale);const o=S.getRenderTarget(),l=S.getActiveCubeFace(),c=S.getActiveMipmapLevel();S.setRenderTarget(i),S.getClearColor(I),k=S.getClearAlpha(),k<1&&S.setClearColor(16777215,.5),S.clear(),re&&Pe.render(n);const h=S.toneMapping;S.toneMapping=0;const d=a.viewport;if(void 0!==a.viewport&&(a.viewport=void 0),b.setupLightsView(a),!0===q&&Ce.setGlobalState(S.clippingPlanes,a),Ke(e,n,a),ue.updateMultisampleRenderTarget(i),ue.updateRenderTargetMipmap(i),!1===oe.has("WEBGL_multisampled_render_to_texture")){let e=!1;for(let i=0,r=t.length;i<r;i++){const r=t[i],{object:s,geometry:o,material:l,group:c}=r;if(2===l.side&&s.layers.test(a.layers)){const t=l.side;l.side=1,l.needsUpdate=!0,Ze(s,n,a,o,l,c),l.side=t,l.needsUpdate=!0,e=!0}}!0===e&&(ue.updateMultisampleRenderTarget(i),ue.updateRenderTargetMipmap(i))}S.setRenderTarget(o,l,c),S.setClearColor(I,k),void 0!==d&&(a.viewport=d),S.toneMapping=h}function Ke(e,t,n){const a=!0===t.isScene?t.overrideMaterial:null;for(let i=0,r=e.length;i<r;i++){const r=e[i],{object:s,geometry:o,group:l}=r;let c=r.material;!0===c.allowOverride&&null!==a&&(c=a),s.layers.test(n.layers)&&Ze(s,t,n,o,c,l)}}function Ze(e,t,n,a,i,r){e.onBeforeRender(S,t,n,a,i,r),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),i.onBeforeRender(S,t,n,a,e,r),!0===i.transparent&&2===i.side&&!1===i.forceSinglePass?(i.side=1,i.needsUpdate=!0,S.renderBufferDirect(n,t,a,i,e,r),i.side=0,i.needsUpdate=!0,S.renderBufferDirect(n,t,a,i,e,r),i.side=2):S.renderBufferDirect(n,t,a,i,e,r),e.onAfterRender(S,t,n,a,i,r)}function Je(e,t,n){!0!==t.isScene&&(t=ee);const a=de.get(e),i=b.state.lights,r=b.state.shadowsArray,s=i.state.version,o=Se.getParameters(e,i.state,r,t,n),l=Se.getProgramCacheKey(o);let c=a.programs;a.environment=e.isMeshStandardMaterial?t.environment:null,a.fog=t.fog,a.envMap=(e.isMeshStandardMaterial?ve:ye).get(e.envMap||a.environment),a.envMapRotation=null!==a.environment&&null===e.envMap?t.environmentRotation:e.envMapRotation,void 0===c&&(e.addEventListener("dispose",Ge),c=new Map,a.programs=c);let h=c.get(l);if(void 0!==h){if(a.currentProgram===h&&a.lightsStateVersion===s)return tt(e,o),h}else o.uniforms=Se.getUniforms(e),e.onBeforeCompile(o,S),h=Se.acquireProgram(o,l),c.set(l,h),a.uniforms=o.uniforms;const d=a.uniforms;return(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(d.clippingPlanes=Ce.uniform),tt(e,o),a.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),a.lightsStateVersion=s,a.needsLights&&(d.ambientLightColor.value=i.state.ambient,d.lightProbe.value=i.state.probe,d.directionalLights.value=i.state.directional,d.directionalLightShadows.value=i.state.directionalShadow,d.spotLights.value=i.state.spot,d.spotLightShadows.value=i.state.spotShadow,d.rectAreaLights.value=i.state.rectArea,d.ltc_1.value=i.state.rectAreaLTC1,d.ltc_2.value=i.state.rectAreaLTC2,d.pointLights.value=i.state.point,d.pointLightShadows.value=i.state.pointShadow,d.hemisphereLights.value=i.state.hemi,d.directionalShadowMap.value=i.state.directionalShadowMap,d.directionalShadowMatrix.value=i.state.directionalShadowMatrix,d.spotShadowMap.value=i.state.spotShadowMap,d.spotLightMatrix.value=i.state.spotLightMatrix,d.spotLightMap.value=i.state.spotLightMap,d.pointShadowMap.value=i.state.pointShadowMap,d.pointShadowMatrix.value=i.state.pointShadowMatrix),a.currentProgram=h,a.uniformsList=null,h}function et(e){if(null===e.uniformsList){const t=e.currentProgram.getUniforms();e.uniformsList=sh.seqWithValue(t.seq,e.uniforms)}return e.uniformsList}function tt(e,t){const n=de.get(e);n.outputColorSpace=t.outputColorSpace,n.batching=t.batching,n.batchingColor=t.batchingColor,n.instancing=t.instancing,n.instancingColor=t.instancingColor,n.instancingMorph=t.instancingMorph,n.skinning=t.skinning,n.morphTargets=t.morphTargets,n.morphNormals=t.morphNormals,n.morphColors=t.morphColors,n.morphTargetsCount=t.morphTargetsCount,n.numClippingPlanes=t.numClippingPlanes,n.numIntersection=t.numClipIntersection,n.vertexAlphas=t.vertexAlphas,n.vertexTangents=t.vertexTangents,n.toneMapping=t.toneMapping}Xe.setAnimationLoop(function(e){qe&&qe(e)}),"undefined"!=typeof self&&Xe.setContext(self),this.setAnimationLoop=function(e){qe=e,Le.setAnimationLoop(e),null===e?Xe.stop():Xe.start()},Le.addEventListener("sessionstart",He),Le.addEventListener("sessionend",je),this.render=function(e,t){if(void 0!==t&&!0!==t.isCamera)return void Ct("WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===M)return;if(!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),null===t.parent&&!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),!0===Le.enabled&&!0===Le.isPresenting&&(!0===Le.cameraAutoUpdate&&Le.updateCamera(t),t=Le.getCamera()),!0===e.isScene&&e.onBeforeRender(S,e,t,C),b=Ae.get(e,x.length),b.init(t),x.push(b),$.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),W.setFromProjectionMatrix($,vt,t.reversedDepth),j=this.localClippingEnabled,q=Ce.init(this.clippingPlanes,j),v=_e.get(e,w.length),v.init(),w.push(v),!0===Le.enabled&&!0===Le.isPresenting){const e=S.xr.getDepthSensingMesh();null!==e&&Ye(e,t,-1/0,S.sortObjects)}Ye(e,t,0,S.sortObjects),v.finish(),!0===S.sortObjects&&v.sort(B,L),re=!1===Le.enabled||!1===Le.isPresenting||!1===Le.hasDepthSensing(),re&&Pe.addToRenderList(v,e),this.info.render.frame++,!0===q&&Ce.beginShadows();const n=b.state.shadowsArray;Te.render(n,e,t),!0===q&&Ce.endShadows(),!0===this.info.autoReset&&this.info.reset();const a=v.opaque,i=v.transmissive;if(b.setupLights(),t.isArrayCamera){const n=t.cameras;if(i.length>0)for(let t=0,r=n.length;t<r;t++)Qe(a,i,e,n[t]);re&&Pe.render(e);for(let t=0,a=n.length;t<a;t++){const a=n[t];$e(v,e,a,a.viewport)}}else i.length>0&&Qe(a,i,e,t),re&&Pe.render(e),$e(v,e,t);null!==C&&0===A&&(ue.updateMultisampleRenderTarget(C),ue.updateRenderTargetMipmap(C)),!0===e.isScene&&e.onAfterRender(S,e,t),ke.resetDefaultState(),T=-1,P=null,x.pop(),x.length>0?(b=x[x.length-1],!0===q&&Ce.setGlobalState(S.clippingPlanes,b.state.camera)):b=null,w.pop(),v=w.length>0?w[w.length-1]:null},this.getActiveCubeFace=function(){return _},this.getActiveMipmapLevel=function(){return A},this.getRenderTarget=function(){return C},this.setRenderTargetTextures=function(e,t,n){const a=de.get(e);a.__autoAllocateDepthBuffer=!1===e.resolveDepthBuffer,!1===a.__autoAllocateDepthBuffer&&(a.__useRenderToTexture=!1),de.get(e.texture).__webglTexture=t,de.get(e.depthTexture).__webglTexture=a.__autoAllocateDepthBuffer?void 0:n,a.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(e,t){const n=de.get(e);n.__webglFramebuffer=t,n.__useDefaultFramebuffer=void 0===t};const it=ze.createFramebuffer();this.setRenderTarget=function(e,t=0,n=0){C=e,_=t,A=n;let a=!0,i=null,r=!1,s=!1;if(e){const o=de.get(e);if(void 0!==o.__useDefaultFramebuffer)ce.bindFramebuffer(ze.FRAMEBUFFER,null),a=!1;else if(void 0===o.__webglFramebuffer)ue.setupRenderTarget(e);else if(o.__hasExternalTextures)ue.rebindTextures(e,de.get(e.texture).__webglTexture,de.get(e.depthTexture).__webglTexture);else if(e.depthBuffer){const t=e.depthTexture;if(o.__boundDepthTexture!==t){if(null!==t&&de.has(t)&&(e.width!==t.image.width||e.height!==t.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");ue.setupDepthRenderbuffer(e)}}const l=e.texture;(l.isData3DTexture||l.isDataArrayTexture||l.isCompressedArrayTexture)&&(s=!0);const c=de.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(i=Array.isArray(c[t])?c[t][n]:c[t],r=!0):i=e.samples>0&&!1===ue.useMultisampledRTT(e)?de.get(e).__webglMultisampledFramebuffer:Array.isArray(c)?c[n]:c,D.copy(e.viewport),O.copy(e.scissor),E=e.scissorTest}else D.copy(N).multiplyScalar(F).floor(),O.copy(U).multiplyScalar(F).floor(),E=G;if(0!==n&&(i=it),ce.bindFramebuffer(ze.FRAMEBUFFER,i)&&a&&ce.drawBuffers(e,i),ce.viewport(D),ce.scissor(O),ce.setScissorTest(E),r){const a=de.get(e.texture);ze.framebufferTexture2D(ze.FRAMEBUFFER,ze.COLOR_ATTACHMENT0,ze.TEXTURE_CUBE_MAP_POSITIVE_X+t,a.__webglTexture,n)}else if(s){const a=t;for(let t=0;t<e.textures.length;t++){const i=de.get(e.textures[t]);ze.framebufferTextureLayer(ze.FRAMEBUFFER,ze.COLOR_ATTACHMENT0+t,i.__webglTexture,n,a)}}else if(null!==e&&0!==n){const t=de.get(e.texture);ze.framebufferTexture2D(ze.FRAMEBUFFER,ze.COLOR_ATTACHMENT0,ze.TEXTURE_2D,t.__webglTexture,n)}T=-1},this.readRenderTargetPixels=function(e,t,n,a,i,r,s,o=0){if(!e||!e.isWebGLRenderTarget)return void Ct("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=de.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==s&&(l=l[s]),l){ce.bindFramebuffer(ze.FRAMEBUFFER,l);try{const s=e.textures[o],l=s.format,c=s.type;if(!le.textureFormatReadable(l))return void Ct("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!le.textureTypeReadable(c))return void Ct("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");t>=0&&t<=e.width-a&&n>=0&&n<=e.height-i&&(e.textures.length>1&&ze.readBuffer(ze.COLOR_ATTACHMENT0+o),ze.readPixels(t,n,a,i,Ie.convert(l),Ie.convert(c),r))}finally{const e=null!==C?de.get(C).__webglFramebuffer:null;ce.bindFramebuffer(ze.FRAMEBUFFER,e)}}},this.readRenderTargetPixelsAsync=async function(e,t,n,a,i,r,s,o=0){if(!e||!e.isWebGLRenderTarget)throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=de.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==s&&(l=l[s]),l){if(t>=0&&t<=e.width-a&&n>=0&&n<=e.height-i){ce.bindFramebuffer(ze.FRAMEBUFFER,l);const s=e.textures[o],c=s.format,h=s.type;if(!le.textureFormatReadable(c))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!le.textureTypeReadable(h))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const d=ze.createBuffer();ze.bindBuffer(ze.PIXEL_PACK_BUFFER,d),ze.bufferData(ze.PIXEL_PACK_BUFFER,r.byteLength,ze.STREAM_READ),e.textures.length>1&&ze.readBuffer(ze.COLOR_ATTACHMENT0+o),ze.readPixels(t,n,a,i,Ie.convert(c),Ie.convert(h),0);const u=null!==C?de.get(C).__webglFramebuffer:null;ce.bindFramebuffer(ze.FRAMEBUFFER,u);const p=ze.fenceSync(ze.SYNC_GPU_COMMANDS_COMPLETE,0);return ze.flush(),await function(e,t){return new Promise(function(n,a){setTimeout(function i(){switch(e.clientWaitSync(t,e.SYNC_FLUSH_COMMANDS_BIT,0)){case e.WAIT_FAILED:a();break;case e.TIMEOUT_EXPIRED:setTimeout(i,4);break;default:n()}},4)})}(ze,p),ze.bindBuffer(ze.PIXEL_PACK_BUFFER,d),ze.getBufferSubData(ze.PIXEL_PACK_BUFFER,0,r),ze.deleteBuffer(d),ze.deleteSync(p),r}throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(e,t=null,n=0){const a=Math.pow(2,-n),i=Math.floor(e.image.width*a),r=Math.floor(e.image.height*a),s=null!==t?t.x:0,o=null!==t?t.y:0;ue.setTexture2D(e,0),ze.copyTexSubImage2D(ze.TEXTURE_2D,n,0,0,s,o,i,r),ce.unbindTexture()};const rt=ze.createFramebuffer(),st=ze.createFramebuffer();this.copyTextureToTexture=function(e,t,n=null,a=null,i=0,r=null){let s,o,l,c,h,d,u,p,m;null===r&&(0!==i?(Tt("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),r=i,i=0):r=0);const f=e.isCompressedTexture?e.mipmaps[r]:e.image;if(null!==n)s=n.max.x-n.min.x,o=n.max.y-n.min.y,l=n.isBox3?n.max.z-n.min.z:1,c=n.min.x,h=n.min.y,d=n.isBox3?n.min.z:0;else{const t=Math.pow(2,-i);s=Math.floor(f.width*t),o=Math.floor(f.height*t),l=e.isDataArrayTexture?f.depth:e.isData3DTexture?Math.floor(f.depth*t):1,c=0,h=0,d=0}null!==a?(u=a.x,p=a.y,m=a.z):(u=0,p=0,m=0);const g=Ie.convert(t.format),y=Ie.convert(t.type);let v;t.isData3DTexture?(ue.setTexture3D(t,0),v=ze.TEXTURE_3D):t.isDataArrayTexture||t.isCompressedArrayTexture?(ue.setTexture2DArray(t,0),v=ze.TEXTURE_2D_ARRAY):(ue.setTexture2D(t,0),v=ze.TEXTURE_2D),ze.pixelStorei(ze.UNPACK_FLIP_Y_WEBGL,t.flipY),ze.pixelStorei(ze.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.premultiplyAlpha),ze.pixelStorei(ze.UNPACK_ALIGNMENT,t.unpackAlignment);const b=ze.getParameter(ze.UNPACK_ROW_LENGTH),w=ze.getParameter(ze.UNPACK_IMAGE_HEIGHT),x=ze.getParameter(ze.UNPACK_SKIP_PIXELS),S=ze.getParameter(ze.UNPACK_SKIP_ROWS),M=ze.getParameter(ze.UNPACK_SKIP_IMAGES);ze.pixelStorei(ze.UNPACK_ROW_LENGTH,f.width),ze.pixelStorei(ze.UNPACK_IMAGE_HEIGHT,f.height),ze.pixelStorei(ze.UNPACK_SKIP_PIXELS,c),ze.pixelStorei(ze.UNPACK_SKIP_ROWS,h),ze.pixelStorei(ze.UNPACK_SKIP_IMAGES,d);const _=e.isDataArrayTexture||e.isData3DTexture,A=t.isDataArrayTexture||t.isData3DTexture;if(e.isDepthTexture){const n=de.get(e),a=de.get(t),f=de.get(n.__renderTarget),g=de.get(a.__renderTarget);ce.bindFramebuffer(ze.READ_FRAMEBUFFER,f.__webglFramebuffer),ce.bindFramebuffer(ze.DRAW_FRAMEBUFFER,g.__webglFramebuffer);for(let n=0;n<l;n++)_&&(ze.framebufferTextureLayer(ze.READ_FRAMEBUFFER,ze.COLOR_ATTACHMENT0,de.get(e).__webglTexture,i,d+n),ze.framebufferTextureLayer(ze.DRAW_FRAMEBUFFER,ze.COLOR_ATTACHMENT0,de.get(t).__webglTexture,r,m+n)),ze.blitFramebuffer(c,h,s,o,u,p,s,o,ze.DEPTH_BUFFER_BIT,ze.NEAREST);ce.bindFramebuffer(ze.READ_FRAMEBUFFER,null),ce.bindFramebuffer(ze.DRAW_FRAMEBUFFER,null)}else if(0!==i||e.isRenderTargetTexture||de.has(e)){const n=de.get(e),a=de.get(t);ce.bindFramebuffer(ze.READ_FRAMEBUFFER,rt),ce.bindFramebuffer(ze.DRAW_FRAMEBUFFER,st);for(let e=0;e<l;e++)_?ze.framebufferTextureLayer(ze.READ_FRAMEBUFFER,ze.COLOR_ATTACHMENT0,n.__webglTexture,i,d+e):ze.framebufferTexture2D(ze.READ_FRAMEBUFFER,ze.COLOR_ATTACHMENT0,ze.TEXTURE_2D,n.__webglTexture,i),A?ze.framebufferTextureLayer(ze.DRAW_FRAMEBUFFER,ze.COLOR_ATTACHMENT0,a.__webglTexture,r,m+e):ze.framebufferTexture2D(ze.DRAW_FRAMEBUFFER,ze.COLOR_ATTACHMENT0,ze.TEXTURE_2D,a.__webglTexture,r),0!==i?ze.blitFramebuffer(c,h,s,o,u,p,s,o,ze.COLOR_BUFFER_BIT,ze.NEAREST):A?ze.copyTexSubImage3D(v,r,u,p,m+e,c,h,s,o):ze.copyTexSubImage2D(v,r,u,p,c,h,s,o);ce.bindFramebuffer(ze.READ_FRAMEBUFFER,null),ce.bindFramebuffer(ze.DRAW_FRAMEBUFFER,null)}else A?e.isDataTexture||e.isData3DTexture?ze.texSubImage3D(v,r,u,p,m,s,o,l,g,y,f.data):t.isCompressedArrayTexture?ze.compressedTexSubImage3D(v,r,u,p,m,s,o,l,g,f.data):ze.texSubImage3D(v,r,u,p,m,s,o,l,g,y,f):e.isDataTexture?ze.texSubImage2D(ze.TEXTURE_2D,r,u,p,s,o,g,y,f.data):e.isCompressedTexture?ze.compressedTexSubImage2D(ze.TEXTURE_2D,r,u,p,f.width,f.height,g,f.data):ze.texSubImage2D(ze.TEXTURE_2D,r,u,p,s,o,g,y,f);ze.pixelStorei(ze.UNPACK_ROW_LENGTH,b),ze.pixelStorei(ze.UNPACK_IMAGE_HEIGHT,w),ze.pixelStorei(ze.UNPACK_SKIP_PIXELS,x),ze.pixelStorei(ze.UNPACK_SKIP_ROWS,S),ze.pixelStorei(ze.UNPACK_SKIP_IMAGES,M),0===r&&t.generateMipmaps&&ze.generateMipmap(v),ce.unbindTexture()},this.initRenderTarget=function(e){void 0===de.get(e).__webglFramebuffer&&ue.setupRenderTarget(e)},this.initTexture=function(e){e.isCubeTexture?ue.setTextureCube(e,0):e.isData3DTexture?ue.setTexture3D(e,0):e.isDataArrayTexture||e.isCompressedArrayTexture?ue.setTexture2DArray(e,0):ue.setTexture2D(e,0),ce.unbindTexture()},this.resetState=function(){_=0,A=0,C=null,ce.reset(),ke.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return vt}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=Qt._getDrawingBufferColorSpace(e),t.unpackColorSpace=Qt._getUnpackColorSpace()}}var td=Object.freeze({__proto__:null,ACESFilmicToneMapping:4,AddEquation:s,AddOperation:2,AdditiveBlending:2,AgXToneMapping:6,AlphaFormat:oe,AlwaysCompare:519,AlwaysDepth:1,AlwaysStencilFunc:519,AmbientLight:rl,AnimationClip:Oo,ArcCurve:rs,ArrayCamera:hl,AttachedBindMode:I,BackSide:1,BasicDepthPacking:3200,Bone:lr,BooleanKeyframeTrack:Mo,Box3:pn,BoxGeometry:mi,BufferAttribute:Wa,BufferGeometry:ei,ByteType:$,Cache:Io,Camera:wi,CanvasTexture:Kr,CatmullRomCurve3:ds,CineonToneMapping:3,CircleGeometry:es,ClampToEdgeWrapping:V,Clock:dl,Color:Ia,ColorKeyframeTrack:_o,ColorManagement:Qt,ConstantAlphaFactor:213,ConstantColorFactor:211,Controls:wl,CubeCamera:Ci,CubeReflectionMapping:R,CubeRefractionMapping:z,CubeTexture:Ti,CubeUVReflectionMapping:L,CubicBezierCurve:fs,CubicBezierCurve3:gs,CubicInterpolant:bo,CullFaceBack:1,CullFaceFront:2,CullFaceNone:0,Curve:as,CurvePath:Ms,CustomBlending:5,CustomToneMapping:5,Data3DTexture:un,DataArrayTexture:dn,DataTexture:cr,DataTextureLoader:Uo,DataUtils:Na,DefaultLoadingManager:Ro,DepthFormat:he,DepthStencilFormat:de,DepthTexture:Zr,DetachedBindMode:k,DirectionalLight:il,DiscreteInterpolant:xo,DodecahedronGeometry:ns,DoubleSide:2,DstAlphaFactor:206,DstColorFactor:208,DynamicDrawUsage:gt,EllipseCurve:is,EqualCompare:514,EqualDepth:4,EquirectangularReflectionMapping:F,EquirectangularRefractionMapping:B,Euler:Qn,EventDispatcher:Pt,ExternalTexture:Jr,FileLoader:Lo,Float32BufferAttribute:ja,FloatType:ee,FrontSide:0,Frustum:Dr,GLSL3:yt,GreaterCompare:516,GreaterDepth:6,GreaterEqualCompare:518,GreaterEqualDepth:5,Group:Di,HalfFloatType:te,HemisphereLight:qo,IcosahedronGeometry:to,ImageBitmapLoader:cl,ImageLoader:Vo,ImageUtils:en,InstancedBufferAttribute:pr,InstancedBufferGeometry:ol,InstancedMesh:xr,IntType:Z,InterleavedBuffer:ki,InterleavedBufferAttribute:zi,Interpolant:vo,InterpolateDiscrete:$e,InterpolateLinear:Qe,InterpolateSmooth:Ke,KeepStencilOp:st,KeyframeTrack:So,Layers:Kn,LessCompare:513,LessDepth:2,LessEqualCompare:515,LessEqualDepth:3,Light:Wo,Line:Lr,LineBasicMaterial:Or,LineCurve:ys,LineCurve3:vs,LineLoop:Wr,LineSegments:Gr,LinearFilter:H,LinearInterpolant:wo,LinearMipmapLinearFilter:X,LinearMipmapNearestFilter:j,LinearSRGBColorSpace:at,LinearToneMapping:1,LinearTransfer:it,Loader:zo,LoaderUtils:sl,LoadingManager:ko,MOUSE:t,Material:za,MathUtils:Nt,Matrix3:Ht,Matrix4:Vn,MaxEquation:104,Mesh:ui,MeshBasicMaterial:Fa,MeshDepthMaterial:uo,MeshDistanceMaterial:po,MeshPhongMaterial:ho,MeshPhysicalMaterial:co,MeshStandardMaterial:lo,MinEquation:103,MirroredRepeatWrapping:U,MixOperation:1,MultiplyBlending:4,MultiplyOperation:0,NearestFilter:G,NearestMipmapLinearFilter:q,NearestMipmapNearestFilter:W,NeutralToneMapping:7,NeverCompare:512,NeverDepth:0,NoBlending:0,NoColorSpace:tt,NoToneMapping:0,NormalAnimationBlendMode:2500,NormalBlending:1,NotEqualCompare:517,NotEqualDepth:7,NumberKeyframeTrack:Ao,Object3D:pa,ObjectSpaceNormalMap:1,OctahedronGeometry:no,OneFactor:h,OneMinusConstantAlphaFactor:214,OneMinusConstantColorFactor:212,OneMinusDstAlphaFactor:207,OneMinusDstColorFactor:209,OneMinusSrcAlphaFactor:m,OneMinusSrcColorFactor:203,OrthographicCamera:nl,PCFShadowMap:1,PCFSoftShadowMap:2,PMREMGenerator:ql,Path:_s,PerspectiveCamera:_i,Plane:Ar,PlaneGeometry:ao,PointLight:tl,Points:$r,PointsMaterial:qr,PolyhedronGeometry:ts,PropertyBinding:vl,QuadraticBezierCurve:bs,QuadraticBezierCurve3:ws,Quaternion:Ut,QuaternionKeyframeTrack:To,QuaternionLinearInterpolant:Co,RED_GREEN_RGTC2_Format:Xe,RED_RGTC1_Format:He,REVISION:e,RGBADepthPacking:3201,RGBAFormat:ce,RGBAIntegerFormat:ge,RGBA_ASTC_10x10_Format:Ne,RGBA_ASTC_10x5_Format:Fe,RGBA_ASTC_10x6_Format:Be,RGBA_ASTC_10x8_Format:Le,RGBA_ASTC_12x10_Format:Ve,RGBA_ASTC_12x12_Format:Ue,RGBA_ASTC_4x4_Format:Pe,RGBA_ASTC_5x4_Format:De,RGBA_ASTC_5x5_Format:Oe,RGBA_ASTC_6x5_Format:Ee,RGBA_ASTC_6x6_Format:Ie,RGBA_ASTC_8x5_Format:ke,RGBA_ASTC_8x6_Format:Re,RGBA_ASTC_8x8_Format:ze,RGBA_BPTC_Format:Ge,RGBA_ETC2_EAC_Format:Te,RGBA_PVRTC_2BPPV1_Format:_e,RGBA_PVRTC_4BPPV1_Format:Me,RGBA_S3TC_DXT1_Format:ve,RGBA_S3TC_DXT3_Format:be,RGBA_S3TC_DXT5_Format:we,RGBFormat:le,RGB_BPTC_SIGNED_Format:We,RGB_BPTC_UNSIGNED_Format:qe,RGB_ETC1_Format:Ae,RGB_ETC2_Format:Ce,RGB_PVRTC_2BPPV1_Format:Se,RGB_PVRTC_4BPPV1_Format:xe,RGB_S3TC_DXT1_Format:ye,RGFormat:me,RGIntegerFormat:fe,Ray:Nn,RedFormat:ue,RedIntegerFormat:pe,ReinhardToneMapping:2,RenderTarget:cn,RepeatWrapping:N,ReverseSubtractEquation:102,RingGeometry:io,SIGNED_RED_GREEN_RGTC2_Format:Ye,SIGNED_RED_RGTC1_Format:je,SRGBColorSpace:nt,SRGBTransfer:rt,Scene:Ii,ShaderChunk:_l,ShaderLib:Cl,ShaderMaterial:bi,Shape:As,ShapeGeometry:ro,ShapeUtils:Zs,ShortType:Q,Skeleton:ur,SkinnedMesh:or,Source:nn,Sphere:En,SphereGeometry:so,Spherical:bl,SplineCurve:xs,SpotLight:Qo,Sprite:Qi,SpriteMaterial:Fi,SrcAlphaFactor:p,SrcAlphaSaturateFactor:210,SrcColorFactor:202,StaticDrawUsage:ft,StringKeyframeTrack:Po,SubtractEquation:101,SubtractiveBlending:3,TOUCH:n,TangentSpaceNormalMap:0,Texture:on,TextureLoader:Go,TorusGeometry:oo,Triangle:Ta,TriangleFanDrawMode:2,TriangleStripDrawMode:1,TrianglesDrawMode:0,UVMapping:300,Uint16BufferAttribute:qa,Uint32BufferAttribute:Ha,UniformsLib:Al,UniformsUtils:vi,UnsignedByteType:Y,UnsignedInt101111Type:se,UnsignedInt248Type:ie,UnsignedInt5999Type:re,UnsignedIntType:J,UnsignedShort4444Type:ne,UnsignedShort5551Type:ae,UnsignedShortType:K,VSMShadowMap:3,Vector2:Vt,Vector3:Gt,Vector4:ln,VectorKeyframeTrack:Do,WebGLCoordinateSystem:vt,WebGLCubeRenderTarget:Pi,WebGLRenderTarget:hn,WebGLRenderer:ed,WebGLUtils:Hh,WebGPUCoordinateSystem:bt,WebXRController:Ei,WrapAroundEnding:et,ZeroCurvatureEnding:Ze,ZeroFactor:c,ZeroSlopeEnding:Je,createCanvasElement:St,error:Ct,log:_t,warn:At,warnOnce:Tt});const nd={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class ad{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const id=new nl(-1,1,1,-1,0,1),rd=new class extends ei{constructor(){super(),this.setAttribute("position",new ja([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new ja([0,2,0,0,2,0],2))}};class sd{constructor(e){this._mesh=new ui(rd,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,id)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class od extends ad{constructor(e,t="tDiffuse"){super(),this.textureID=t,this.uniforms=null,this.material=null,e instanceof bi?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=vi.clone(e.uniforms),this.material=new bi({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this._fsQuad=new sd(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this._fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this._fsQuad.render(e))}dispose(){this.material.dispose(),this._fsQuad.dispose()}}class ld extends ad{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const a=e.getContext(),i=e.state;let r,s;i.buffers.color.setMask(!1),i.buffers.depth.setMask(!1),i.buffers.color.setLocked(!0),i.buffers.depth.setLocked(!0),this.inverse?(r=0,s=1):(r=1,s=0),i.buffers.stencil.setTest(!0),i.buffers.stencil.setOp(a.REPLACE,a.REPLACE,a.REPLACE),i.buffers.stencil.setFunc(a.ALWAYS,r,4294967295),i.buffers.stencil.setClear(s),i.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),i.buffers.color.setLocked(!1),i.buffers.depth.setLocked(!1),i.buffers.color.setMask(!0),i.buffers.depth.setMask(!0),i.buffers.stencil.setLocked(!1),i.buffers.stencil.setFunc(a.EQUAL,1,4294967295),i.buffers.stencil.setOp(a.KEEP,a.KEEP,a.KEEP),i.buffers.stencil.setLocked(!0)}}class cd extends ad{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class hd{constructor(e,t){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===t){const n=e.getSize(new Vt);this._width=n.width,this._height=n.height,(t=new hn(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:te})).texture.name="EffectComposer.rt1"}else this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new od(nd),this.copyPass.material.blending=0,this.clock=new dl}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let t=0,a=this.passes.length;t<a;t++){const a=this.passes[t];if(!1!==a.enabled){if(a.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),a.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),a.needsSwap){if(n){const t=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),n.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==ld&&(a instanceof ld?n=!0:a instanceof cd&&(n=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new Vt);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=this._width*this._pixelRatio,a=this._height*this._pixelRatio;this.renderTarget1.setSize(n,a),this.renderTarget2.setSize(n,a);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(n,a)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class dd extends ad{constructor(e,t,n=null,a=null,i=null){super(),this.scene=e,this.camera=t,this.overrideMaterial=n,this.clearColor=a,this.clearAlpha=i,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new Ia}render(e,t,n){const a=e.autoClear;let i,r;e.autoClear=!1,null!==this.overrideMaterial&&(r=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor,e.getClearAlpha())),null!==this.clearAlpha&&(i=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(i),null!==this.overrideMaterial&&(this.scene.overrideMaterial=r),e.autoClear=a}}class ud extends ad{constructor(e,t,n,a){super(),this.strength=void 0!==t?t:1,this.radius=n,this.threshold=a,this.resolution=void 0!==e?new Vt(e.x,e.y):new Vt(256,256);const i={minFilter:H,magFilter:H,format:ce,type:te};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let r=Math.round(.75*this.resolution.x),s=Math.round(.75*this.resolution.y);this.renderTargetBright=new hn(r,s,i),this.renderTargetBright.texture.name="UnrealBloomPassAlpha.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this.nMips;e++){const t=new hn(r,s,i);t.texture.name=`UnrealBloomPassAlpha.h${e}`,t.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(t);const n=new hn(r,s,i);n.texture.name=`UnrealBloomPassAlpha.v${e}`,n.texture.generateMipmaps=!1,this.renderTargetsVertical.push(n),r=Math.round(r/2),s=Math.round(s/2)}this.highPassUniforms={tDiffuse:{value:null},luminosityThreshold:{value:a},smoothWidth:{value:.1}},this.materialHighPassFilter=new bi({uniforms:this.highPassUniforms,vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                uniform float luminosityThreshold;\n                uniform float smoothWidth;\n                varying vec2 vUv;\n\n                void main() {\n                    vec4 texel = texture2D(tDiffuse, vUv);\n                    vec3 luma = vec3(0.299, 0.587, 0.114);\n                    float v = dot(texel.xyz, luma);\n                    float alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);\n\n                    // CRITICAL: Preserve original alpha, only filter by luminosity\n                    gl_FragColor = vec4(texel.rgb * alpha, texel.a);\n                }"}),this.separableBlurMaterials=[];const o=[3,5,7,9,11];r=Math.round(.75*this.resolution.x),s=Math.round(.75*this.resolution.y);for(let e=0;e<this.nMips;e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(o[e])),this.separableBlurMaterials[e].uniforms.texSize.value=new Vt(r,s),r=Math.round(r/2),s=Math.round(s/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new Gt(1,1,1),new Gt(1,1,1),new Gt(1,1,1),new Gt(1,1,1),new Gt(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,this.materialCopy=new bi({uniforms:{tDiffuse:{value:null},texelSize:{value:new Vt(1/256,1/256)}},vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                uniform vec2 texelSize;\n                varying vec2 vUv;\n                void main() {\n                    // B-spline bicubic upsampling  4 bilinear taps, all-positive weights.\n                    // Smoothly upscales 0.75-resolution bloom to canvas without pixel grid\n                    // artifacts or ringing. Slightly smoother than Catmull-Rom (no negative\n                    // lobes) which is ideal for bloom halos.\n                    vec2 coord = vUv / texelSize - 0.5;\n                    vec2 f = fract(coord);\n                    coord = floor(coord);\n\n                    vec2 f2 = f * f;\n                    vec2 f3 = f2 * f;\n                    vec2 omf = 1.0 - f;\n\n                    // B-spline weights (unnormalized  divided out via s0/s1 pairs)\n                    vec2 w0 = omf * omf * omf;\n                    vec2 w1 = 3.0 * f3 - 6.0 * f2 + 4.0;\n                    vec2 w2 = -3.0 * f3 + 3.0 * f2 + 3.0 * f + 1.0;\n                    vec2 w3 = f3;\n\n                    // Pair sums normalized to [0,1] range (weights sum to 6 per axis)\n                    vec2 s0 = (w0 + w1) / 6.0;\n                    vec2 s1 = (w2 + w3) / 6.0;\n\n                    // Bilinear tap offsets within each pair\n                    vec2 f0 = w1 / (w0 + w1);\n                    vec2 f1 = w3 / max(w2 + w3, 1e-4);\n\n                    // 4 sample positions\n                    vec2 t0 = (coord - 0.5 + f0) * texelSize;\n                    vec2 t1 = (coord + 1.5 + f1) * texelSize;\n\n                    vec4 color =\n                        (texture2D(tDiffuse, vec2(t0.x, t0.y)) * s0.x +\n                         texture2D(tDiffuse, vec2(t1.x, t0.y)) * s1.x) * s0.y +\n                        (texture2D(tDiffuse, vec2(t0.x, t1.y)) * s0.x +\n                         texture2D(tDiffuse, vec2(t1.x, t1.y)) * s1.x) * s1.y;\n\n                    // Interleaved Gradient Noise dithering (Jimenez 2014)\n                    // Breaks 8-bit display banding into imperceptible noise\n                    float ign = fract(52.9829189 * fract(0.06711056 * gl_FragCoord.x + 0.00583715 * gl_FragCoord.y));\n                    gl_FragColor = color + (ign - 0.5) / 255.0;\n                }",blending:5,blendSrc:h,blendDst:h,blendSrcAlpha:c,blendDstAlpha:h,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new Ia,this.oldClearAlpha=1,this.clearColor=new Ia(0,0,0),this.basic=new Fa({transparent:!1,depthTest:!1,depthWrite:!1,blending:0}),this.fsQuad=new sd(null)}dispose(){if(this.renderTargetsHorizontal)for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e]?.dispose();if(this.renderTargetsVertical)for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e]?.dispose();if(this.renderTargetBright?.dispose(),this.separableBlurMaterials)for(let e=0;e<this.separableBlurMaterials.length;e++)this.separableBlurMaterials[e]?.dispose();this.compositeMaterial?.dispose(),this.blendMaterial?.dispose(),this.basic?.dispose(),this.fsQuad?.dispose()}clearBloomBuffers(e){const t=e.getRenderTarget(),n=e.getClearColor(this._oldClearColor),a=e.getClearAlpha();e.setClearColor(0,0),e.setRenderTarget(this.renderTargetBright),e.clear();for(let t=0;t<this.renderTargetsHorizontal.length;t++)e.setRenderTarget(this.renderTargetsHorizontal[t]),e.clear();for(let t=0;t<this.renderTargetsVertical.length;t++)e.setRenderTarget(this.renderTargetsVertical[t]),e.clear();e.setRenderTarget(t),e.setClearColor(n,a)}setSize(e,t){this.resolution.set(e,t);let n=Math.round(.75*e),a=Math.round(.75*t);this.renderTargetBright.setSize(n,a);for(let e=0;e<this.nMips;e++)this.renderTargetsHorizontal[e].setSize(n,a),this.renderTargetsVertical[e].setSize(n,a),this.separableBlurMaterials[e].uniforms.texSize.value=new Vt(n,a),n=Math.round(n/2),a=Math.round(a/2)}render(e,t,n,a,i){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const r=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),i&&e.state.buffers.stencil.setTest(!1),this.renderToScreen&&!this.skipBaseCopy&&(this.fsQuad.material=this.basic,this.basic.map=n.texture,e.setRenderTarget(null),this.fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=n.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this.fsQuad.render(e);let s=this.renderTargetBright;for(let t=0;t<this.nMips;t++)this.fsQuad.material=this.separableBlurMaterials[t],this.separableBlurMaterials[t].uniforms.colorTexture.value=s.texture,this.separableBlurMaterials[t].uniforms.direction.value=ud.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[t]),e.clear(),this.fsQuad.render(e),this.separableBlurMaterials[t].uniforms.colorTexture.value=this.renderTargetsHorizontal[t].texture,this.separableBlurMaterials[t].uniforms.direction.value=ud.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[t]),e.clear(),this.fsQuad.render(e),s=this.renderTargetsVertical[t];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this.fsQuad.render(e);const o=this.renderTargetsHorizontal[0];this.fsQuad.material=this.materialCopy,this.materialCopy.uniforms.tDiffuse.value=o.texture,this.materialCopy.uniforms.texelSize.value.set(1/o.width,1/o.height),i&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(n),this.fsQuad.render(e)),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=r}getSeperableBlurMaterial(e){return new bi({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new Vt(.5,.5)},direction:{value:new Vt(.5,.5)},kernelRadius:{value:1}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",fragmentShader:"\n                #include <common>\n                varying vec2 vUv;\n                uniform sampler2D colorTexture;\n                uniform vec2 texSize;\n                uniform vec2 direction;\n                uniform float kernelRadius;\n\n                float gaussianPdf(in float x, in float sigma) {\n                    return 0.39894 * exp( -0.5 * x * x / ( sigma * sigma ) ) / sigma;\n                }\n\n                void main() {\n                    vec2 invSize = 1.0 / texSize;\n                    float sigma = kernelRadius / 2.0;\n                    float weightSum = gaussianPdf(0.0, sigma);\n\n                    // CRITICAL: Accumulate RGB and alpha SEPARATELY\n                    // Include center pixel for BOTH RGB and alpha\n                    vec4 centerPixel = texture2D(colorTexture, vUv);\n                    vec3 diffuseSum = centerPixel.rgb * weightSum;\n                    float alphaSum = centerPixel.a * weightSum;\n\n                    vec2 delta = direction * invSize * kernelRadius / float(MAX_RADIUS);\n\n                    for( int i = 1; i < MAX_RADIUS; i ++ ) {\n                        float x = kernelRadius * float(i) / float(MAX_RADIUS);\n                        float w = gaussianPdf(x, sigma);\n\n                        vec2 uvOffset = delta * float(i);\n                        vec4 sample1 = texture2D(colorTexture, vUv + uvOffset);\n                        vec4 sample2 = texture2D(colorTexture, vUv - uvOffset);\n\n                        // Accumulate RGB and alpha separately\n                        diffuseSum += (sample1.rgb + sample2.rgb) * w;\n                        alphaSum += (sample1.a + sample2.a) * w;\n                        weightSum += 2.0 * w;\n                    }\n\n                    // Output with separately normalized alpha\n                    gl_FragColor = vec4(diffuseSum / weightSum, alphaSum / weightSum);\n                }"})}getCompositeMaterial(e){return new bi({uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",fragmentShader:"\n                varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[5];\n                uniform vec3 bloomTintColors[5];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    // ALPHA PRESERVATION: Sample all textures and preserve their alpha\n                    vec4 sample1 = texture2D(blurTexture1, vUv);\n                    vec4 sample2 = texture2D(blurTexture2, vUv);\n                    vec4 sample3 = texture2D(blurTexture3, vUv);\n                    vec4 sample4 = texture2D(blurTexture4, vUv);\n                    vec4 sample5 = texture2D(blurTexture5, vUv);\n\n                    // Apply tint to RGB only, preserve alpha from samples\n                    vec4 color = bloomStrength * (\n                        lerpBloomFactor(bloomFactors[0]) * vec4(sample1.rgb * bloomTintColors[0], sample1.a) +\n                        lerpBloomFactor(bloomFactors[1]) * vec4(sample2.rgb * bloomTintColors[1], sample2.a) +\n                        lerpBloomFactor(bloomFactors[2]) * vec4(sample3.rgb * bloomTintColors[2], sample3.a) +\n                        lerpBloomFactor(bloomFactors[3]) * vec4(sample4.rgb * bloomTintColors[3], sample4.a) +\n                        lerpBloomFactor(bloomFactors[4]) * vec4(sample5.rgb * bloomTintColors[4], sample5.a)\n                    );\n\n                    gl_FragColor = color;\n                }"})}}ud.BlurDirectionX=new Vt(1,0),ud.BlurDirectionY=new Vt(0,1);const pd={name:"DistortionShader",uniforms:{tDiffuse:{value:null},tDistortion:{value:null},uGlobalStrength:{value:1}},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n    ",fragmentShader:"\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDistortion;\n        uniform float uGlobalStrength;\n        varying vec2 vUv;\n\n        void main() {\n            vec4 distSample = texture2D(tDistortion, vUv);\n\n            // R/G = signed UV offset (pre-multiplied by strength/falloff)\n            vec2 offset = distSample.rg * uGlobalStrength;\n\n            // Hard clamp: safety rail against runaway accumulation\n            offset = clamp(offset, vec2(-0.04), vec2(0.04));\n\n            // Base scene warp  full vec4 preserves alpha\n            // (canvas is transparent + premultipliedAlpha; alpha=1.0 would make BG opaque black)\n            vec4 scene = texture2D(tDiffuse, vUv + offset);\n\n            // B channel = chromatic aberration UV spread (written by light distortion)\n            // Prism split: red refracts outward more, blue less (matches real dispersion)\n            // B is a direct UV spread amount (~0.008-0.016), NOT scaled by offset.\n            // When B=0 (non-light elements), chrShift=vec2(0), R/B read same UV as scene.\n            float chromatic = distSample.b * uGlobalStrength;\n            vec2 chrDir = length(offset) > 0.0001 ? normalize(offset) : vec2(0.0);\n            vec2 chrShift = chrDir * chromatic;\n            scene.r = texture2D(tDiffuse, vUv + offset + chrShift).r;\n            scene.b = texture2D(tDiffuse, vUv + offset - chrShift).b;\n\n            gl_FragColor = scene;\n        }\n    "},md="\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";class fd extends ad{constructor(e,t,n){super(),this.camera=e,this.needsSwap=!0,this.intensity=1.3,this.fineRadius=120,this.coarseRadius=280,this.bias=.05,this.fineFalloff=1.5,this.coarseFalloff=3,this.shadowEnabled=!0,this.shadowIntensity=.65,this._fullWidth=t,this._fullHeight=n,this._halfWidth=Math.ceil(t/2),this._halfHeight=Math.ceil(n/2);const a={format:ce,type:te,minFilter:H,magFilter:H};this.aoTarget=new hn(this._halfWidth,this._halfHeight,a),this.blurTarget=new hn(this._halfWidth,this._halfHeight,a);const i=new Float32Array(16384);for(let e=0;e<4096;e++){const t=4*e,n=Math.random()*Math.PI*2;i[t]=Math.cos(n),i[t+1]=Math.sin(n),i[t+2]=0,i[t+3]=1}this.noiseTexture=new cr(i,64,64,ce,ee),this.noiseTexture.minFilter=G,this.noiseTexture.magFilter=G,this.noiseTexture.wrapS=N,this.noiseTexture.wrapT=N,this.noiseTexture.needsUpdate=!0,this.copyMaterial=new bi({uniforms:{tDiffuse:{value:null}},vertexShader:md,fragmentShader:"\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n    gl_FragColor = texture2D(tDiffuse, vUv);\n}\n",blending:0,depthTest:!1,depthWrite:!1}),this.aoMaterial=new bi({uniforms:{tDepth:{value:null},tNoise:{value:this.noiseTexture},resolution:{value:new Vt(t,n)},uViewParams:{value:new Vt},cameraNear:{value:e.near},cameraFar:{value:e.far},uFineRadius:{value:this.fineRadius},uCoarseRadius:{value:this.coarseRadius},uIntensity:{value:this.intensity},uBias:{value:this.bias},uFineFalloff:{value:this.fineFalloff},uCoarseFalloff:{value:this.coarseFalloff},uLightDirView:{value:new Gt},uShadowIntensity:{value:this.shadowIntensity}},vertexShader:md,fragmentShader:"\n#define GOLDEN_ANGLE 2.39996323\n\nuniform sampler2D tDepth;\nuniform sampler2D tNoise;\nuniform vec2 resolution;\nuniform vec2 uViewParams;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float uFineRadius;\nuniform float uCoarseRadius;\nuniform float uIntensity;\nuniform float uBias;\nuniform float uFineFalloff;\nuniform float uCoarseFalloff;\nuniform vec3 uLightDirView;\nuniform float uShadowIntensity;\n\nvarying vec2 vUv;\n\nfloat linDepth(float d) {\n    return (cameraNear * cameraFar) / (cameraFar - d * (cameraFar - cameraNear));\n}\n\nvoid main() {\n    float rawDepth = textureLod(tDepth, vUv, 0.0).x;\n\n    if (rawDepth > 0.999) {\n        gl_FragColor = vec4(1.0);\n        return;\n    }\n\n    float centerDepth = linDepth(rawDepth);\n    vec2 texelSize = 1.0 / resolution;\n\n    // Reconstruct view-space position\n    vec2 ndc = vUv * 2.0 - 1.0;\n    vec3 viewPos = vec3(ndc * uViewParams, -1.0) * centerDepth;\n\n    // Reconstruct normal from depth derivatives\n    vec3 normal = normalize(cross(dFdx(viewPos), dFdy(viewPos)));\n\n    vec2 noiseUV = vUv * resolution / 64.0;\n    vec2 noise = texture2D(tNoise, noiseUV).rg;\n    mat2 rotMat = mat2(noise.x, -noise.y, noise.y, noise.x);\n\n    //  Fine scale: tight contact shadows between adjacent geometry \n    float fineOcc = 0.0;\n    float fineScreenR = uFineRadius / centerDepth;\n    for (int i = 0; i < 16; i++) {\n        float fi = float(i);\n        float angle = fi * GOLDEN_ANGLE;\n        float r = sqrt((fi + 0.5) / 16.0) * fineScreenR;\n        // Per-sample radius jitter  breaks Fibonacci ring banding\n        r *= (0.85 + 0.3 * fract(noise.x * (fi + 1.0) * 7.3));\n        vec2 dir = rotMat * vec2(cos(angle), sin(angle));\n        vec2 sUV = clamp(vUv + dir * r * texelSize, vec2(0.0), vec2(1.0));\n\n        float sd = textureLod(tDepth, sUV, 0.0).x;\n        if (sd > 0.999) continue;\n\n        float sDepth = linDepth(sd);\n        float diff = centerDepth - sDepth;\n\n        if (diff > uBias) {\n            // Normal-aware hemisphere weighting: reject samples behind the surface\n            vec3 sViewPos = vec3((sUV * 2.0 - 1.0) * uViewParams, -1.0) * sDepth;\n            vec3 sDir = normalize(sViewPos - viewPos);\n            float nWeight = smoothstep(-0.2, 0.3, dot(sDir, normal));\n\n            fineOcc += nWeight * (1.0 - smoothstep(0.0, uFineFalloff, diff));\n        }\n    }\n    fineOcc /= 16.0;\n\n    //  Coarse scale: broad ambient darkening in concavities \n    float coarseOcc = 0.0;\n    float coarseScreenR = uCoarseRadius / centerDepth;\n    for (int i = 0; i < 16; i++) {\n        float fi = float(i);\n        float angle = (fi + 16.0) * GOLDEN_ANGLE;\n        float r = sqrt((fi + 0.5) / 16.0) * coarseScreenR;\n        // Per-sample radius jitter  breaks Fibonacci ring banding\n        r *= (0.85 + 0.3 * fract(noise.y * (fi + 1.0) * 11.7));\n        vec2 dir = rotMat * vec2(cos(angle), sin(angle));\n        vec2 sUV = clamp(vUv + dir * r * texelSize, vec2(0.0), vec2(1.0));\n\n        float sd = textureLod(tDepth, sUV, 0.0).x;\n        if (sd > 0.999) continue;\n\n        float sDepth = linDepth(sd);\n        float diff = centerDepth - sDepth;\n\n        // Higher bias for coarse: only deep cavities, not adjacent surfaces\n        if (diff > uBias * 6.0) {\n            vec3 sViewPos = vec3((sUV * 2.0 - 1.0) * uViewParams, -1.0) * sDepth;\n            vec3 sDir = normalize(sViewPos - viewPos);\n            float nWeight = smoothstep(-0.2, 0.3, dot(sDir, normal));\n\n            coarseOcc += nWeight * (1.0 - smoothstep(0.0, uCoarseFalloff, diff));\n        }\n    }\n    coarseOcc /= 16.0;\n\n    // Combine: fine for contact detail, coarse for ambient depth\n    float totalOcc = fineOcc * 0.75 + coarseOcc * 0.25;\n    float ao = clamp(1.0 - totalOcc * uIntensity, 0.0, 1.0);\n\n    // Perceptual curve: soften harsh shadow edges\n    ao = pow(ao, 0.85);\n\n    // Distance fade: reduce AO for far geometry (less visible, saves quality)\n    float distFade = smoothstep(15.0, 25.0, centerDepth);\n    ao = mix(ao, 1.0, distFade);\n\n    //  Screen-space contact shadows (directional) \n    // Ray-march toward the key light in view space. Accumulated penumbra:\n    // each occluding step contributes, closer = more shadow. Floor at 0.3\n    // so shadows never crush to black (ambient light persists).\n    float contactShadow = 1.0;\n    if (uShadowIntensity > 0.0) {\n        vec3 marchDir = normalize(uLightDirView);\n        float maxRayDist = centerDepth * 0.15;\n        float rayStep = maxRayDist / 16.0;\n        float thickThresh = centerDepth * 0.03;\n        float jitter = noise.x * 0.5 + 0.5;\n\n        float shadowAccum = 0.0;\n        for (int i = 1; i <= 16; i++) {\n            float dist = rayStep * (float(i) + jitter - 0.5);\n            vec3 marchPos = viewPos + marchDir * dist;\n\n            float marchZ = -marchPos.z;\n            if (marchZ <= cameraNear || marchZ > cameraFar) break;\n\n            vec2 marchUV = marchPos.xy / (uViewParams * marchZ) * 0.5 + 0.5;\n            if (marchUV.x < 0.0 || marchUV.x > 1.0 || marchUV.y < 0.0 || marchUV.y > 1.0) break;\n\n            float sRaw = textureLod(tDepth, marchUV, 0.0).x;\n            if (sRaw > 0.999) continue;\n            float sDepth = linDepth(sRaw);\n\n            float depthDiff = marchZ - sDepth;\n            if (depthDiff > 0.005 && depthDiff < thickThresh) {\n                // Closer occluders contribute more shadow\n                float stepOcc = 1.0 - smoothstep(0.0, maxRayDist, dist);\n                shadowAccum = max(shadowAccum, stepOcc);\n            }\n        }\n\n        // Floor: shadows never go below 30% brightness (ambient persists)\n        contactShadow = max(1.0 - shadowAccum, 0.3);\n        contactShadow = mix(1.0, contactShadow, uShadowIntensity);\n        contactShadow = mix(contactShadow, 1.0, distFade);\n    }\n\n    // Combine AO and contact shadow\n    float combined = ao * contactShadow;\n    float totalShadow = 1.0 - combined;\n\n    // Warm tint in shadows  earthy bounce light instead of cool blue\n    vec3 aoColor = vec3(combined) + vec3(0.02, 0.005, -0.02) * totalShadow;\n    gl_FragColor = vec4(aoColor, 1.0);\n}\n",blending:0,depthTest:!1,depthWrite:!1}),this.blurMaterial=new bi({uniforms:{tAO:{value:null},tDepth:{value:null},aoResolution:{value:new Vt(this._halfWidth,this._halfHeight)},cameraNear:{value:e.near},cameraFar:{value:e.far}},vertexShader:md,fragmentShader:"\nuniform sampler2D tAO;\nuniform sampler2D tDepth;\nuniform vec2 aoResolution;\nuniform float cameraNear;\nuniform float cameraFar;\n\nvarying vec2 vUv;\n\nfloat linDepth(float d) {\n    return (cameraNear * cameraFar) / (cameraFar - d * (cameraFar - cameraNear));\n}\n\nvoid main() {\n    vec2 texelSize = 1.0 / aoResolution;\n    float centerDepth = linDepth(textureLod(tDepth, vUv, 0.0).x);\n\n    // Depth-adaptive bilateral threshold (2% of center depth)\n    float depthThreshold = centerDepth * 0.02;\n    float invThreshSq = 1.0 / (2.0 * depthThreshold * depthThreshold);\n\n    vec3 totalColor = vec3(0.0);\n    float totalWeight = 0.0;\n\n    // 7x7 bilateral blur with Gaussian spatial weighting\n    for (int x = -3; x <= 3; x++) {\n        for (int y = -3; y <= 3; y++) {\n            vec2 sUV = vUv + vec2(float(x), float(y)) * texelSize;\n\n            float sDepth = linDepth(textureLod(tDepth, sUV, 0.0).x);\n            float depthDiff = centerDepth - sDepth;\n\n            // Bilateral weight: preserve edges at depth discontinuities\n            float w = exp(-depthDiff * depthDiff * invThreshSq);\n            // Spatial Gaussian weight (sigma ~2 pixels)\n            float dist2 = float(x * x + y * y);\n            w *= exp(-dist2 / 8.0);\n\n            totalColor += texture2D(tAO, sUV).rgb * w;\n            totalWeight += w;\n        }\n    }\n\n    gl_FragColor = vec4(totalColor / max(totalWeight, 0.001), 1.0);\n}\n",blending:0,depthTest:!1,depthWrite:!1}),this.compositeMaterial=new bi({uniforms:{tAO:{value:null}},vertexShader:md,fragmentShader:"\nuniform sampler2D tAO;\nvarying vec2 vUv;\nvoid main() {\n    vec4 ao = texture2D(tAO, vUv);\n    // Interleaved Gradient Noise dithering (Jimenez 2014)\n    // Breaks banding into imperceptible noise\n    float ign = fract(52.9829189 * fract(0.06711056 * gl_FragCoord.x + 0.00583715 * gl_FragCoord.y));\n    ao.rgb += (ign - 0.5) / 32.0;\n    gl_FragColor = ao;\n}\n",blending:5,blendSrc:c,blendDst:202,blendSrcAlpha:c,blendDstAlpha:h,depthTest:!1,depthWrite:!1}),this._fsQuad=new sd(null),this._tempVec3=new Gt}render(e,t,n){const{depthTexture:a}=n;if(!a)return void console.warn("[AO] No depth texture on readBuffer  skipping");const i=this.camera,r=i.fov*Math.PI/180,s=Math.tan(.5*r),o=this.aoMaterial.uniforms;o.tDepth.value=a,o.resolution.value.set(this._fullWidth,this._fullHeight),o.uViewParams.value.set(i.aspect*s,s),o.cameraNear.value=i.near,o.cameraFar.value=i.far,o.uFineRadius.value=this.fineRadius,o.uCoarseRadius.value=this.coarseRadius,o.uIntensity.value=this.intensity,o.uBias.value=this.bias,o.uFineFalloff.value=this.fineFalloff,o.uCoarseFalloff.value=this.coarseFalloff,this._tempVec3.set(.5,1,.3).normalize().transformDirection(i.matrixWorldInverse),o.uLightDirView.value.copy(this._tempVec3),o.uShadowIntensity.value=this.shadowEnabled?this.shadowIntensity:0,this._fsQuad.material=this.aoMaterial,e.setRenderTarget(this.aoTarget),e.clear(),this._fsQuad.render(e);const l=this.blurMaterial.uniforms;l.tAO.value=this.aoTarget.texture,l.tDepth.value=a,l.aoResolution.value.set(this._halfWidth,this._halfHeight),l.cameraNear.value=i.near,l.cameraFar.value=i.far,this._fsQuad.material=this.blurMaterial,e.setRenderTarget(this.blurTarget),e.clear(),this._fsQuad.render(e),l.tAO.value=this.blurTarget.texture,e.setRenderTarget(this.aoTarget),e.clear(),this._fsQuad.render(e),this.copyMaterial.uniforms.tDiffuse.value=n.texture,this._fsQuad.material=this.copyMaterial,e.setRenderTarget(t),e.clear(),this._fsQuad.render(e),this.compositeMaterial.uniforms.tAO.value=this.aoTarget.texture,this._fsQuad.material=this.compositeMaterial,this._fsQuad.render(e)}setSize(e,t){this._fullWidth=e,this._fullHeight=t,this._halfWidth=Math.ceil(e/2),this._halfHeight=Math.ceil(t/2),this.aoTarget.setSize(this._halfWidth,this._halfHeight),this.blurTarget.setSize(this._halfWidth,this._halfHeight)}dispose(){this.copyMaterial.dispose(),this.aoMaterial.dispose(),this.blurMaterial.dispose(),this.compositeMaterial.dispose(),this.aoTarget.dispose(),this.blurTarget.dispose(),this.noiseTexture&&this.noiseTexture.dispose(),this._fsQuad.dispose()}}class gd extends ad{constructor(e,t={}){super(),this.camera=e;const{intensity:n=1,depthThreshold:a=.5}=t;this.intensity=n,this.depthThreshold=a,this.velocityTarget=null,this._targetWidth=0,this._targetHeight=0,this.velocityMaterial=new bi({vertexShader:"\nattribute vec4 aVelocity;\nvarying vec2 vScreenVelocity;\n\nvoid main() {\n    vec4 localPos = vec4(position, 1.0);\n    #ifdef USE_INSTANCING\n        localPos = instanceMatrix * localPos;\n    #endif\n\n    // Current world position (vertex)\n    vec4 worldPos = modelMatrix * localPos;\n\n    // Project current position to clip space\n    vec4 clipPos = projectionMatrix * viewMatrix * worldPos;\n\n    // Compute screen-space velocity at INSTANCE CENTER only.\n    // aVelocity is the translational velocity of the instance center (container space).\n    // Using the vertex position would include rotational displacement as fake velocity \n    // a spinning ring's edge vertices would get tangential blur even when barely translating.\n    // By projecting the center and its previous position, rotation is excluded cleanly.\n    #ifdef USE_INSTANCING\n        vec3 instanceCenter = (modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n    #else\n        vec3 instanceCenter = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n    #endif\n    vec3 prevCenter = instanceCenter - (mat3(modelMatrix) * aVelocity.xyz);\n\n    vec4 centerClip = projectionMatrix * viewMatrix * vec4(instanceCenter, 1.0);\n    vec4 prevCenterClip = projectionMatrix * viewMatrix * vec4(prevCenter, 1.0);\n\n    // Screen-space velocity in UV coordinates\n    // NDC is [-1,1], UV is [0,1]  scale by 0.5\n    vec2 ndcCurr = centerClip.xy / centerClip.w;\n    vec2 ndcPrev = prevCenterClip.xy / prevCenterClip.w;\n    vScreenVelocity = (ndcCurr - ndcPrev) * 0.5;\n\n    gl_Position = clipPos;\n}\n",fragmentShader:"\nvarying vec2 vScreenVelocity;\n\nvoid main() {\n    // Clamp screen-space velocity to 50% of screen (sanity limit)\n    vec2 vel = clamp(vScreenVelocity, vec2(-0.5), vec2(0.5));\n    // Encode: bias to [0,1] range (0.5 = zero velocity)\n    gl_FragColor = vec4(vel * 0.5 + 0.5, 0.0, 1.0);\n}\n"}),this.blurMaterial=new bi({uniforms:{tColor:{value:null},tVelocity:{value:null},tDepth:{value:null},uIntensity:{value:n},cameraNear:{value:e.near},cameraFar:{value:e.far},uDepthThreshold:{value:a}},vertexShader:"\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\nuniform sampler2D tColor;\nuniform sampler2D tVelocity;\nuniform sampler2D tDepth;\nuniform float uIntensity;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float uDepthThreshold;\n\nvarying vec2 vUv;\n\nfloat linDepth(float d) {\n    return (cameraNear * cameraFar) / (cameraFar - d * (cameraFar - cameraNear));\n}\n\n// Per-pixel jitter to break banding  cheap interleaved gradient noise\nfloat interleavedGradientNoise(vec2 coord) {\n    return fract(52.9829189 * fract(0.06711056 * coord.x + 0.00583715 * coord.y));\n}\n\nvoid main() {\n    vec4 velData = texture2D(tVelocity, vUv);\n\n    // Gate 1: Non-element pixel  pass through scene untouched.\n    if (velData.a < 0.5) {\n        gl_FragColor = texture2D(tColor, vUv);\n        return;\n    }\n\n    // Decode screen-space velocity from RG channels (UV coordinates)\n    vec2 velocity = (velData.rg - 0.5) * 2.0;\n    velocity *= uIntensity;\n\n    // Stationary element  no blur needed\n    float speed = length(velocity);\n    if (speed < 0.0001) {\n        gl_FragColor = texture2D(tColor, vUv);\n        return;\n    }\n\n    // Clamp max blur to 2% of screen (resolution-independent)\n    // ~38px at 1920px, ~7.5px at 375px  subtle streaks, never smear\n    if (speed > 0.02) velocity *= 0.02 / speed;\n\n    // Center pixel depth for comparison\n    float centerDepth = linDepth(texture2D(tDepth, vUv).x);\n\n    // Per-pixel jitter offset  shifts sample positions to break banding\n    float jitter = (interleavedGradientNoise(gl_FragCoord.xy) - 0.5) / 8.0;\n\n    // 8 samples along velocity direction with per-sample isolation.\n    // 8 is enough with jitter  halves texture lookups vs 16 (24 vs 48).\n    vec4 color = vec4(0.0);\n    float totalWeight = 0.0;\n\n    for (int i = 0; i < 8; i++) {\n        float t = (float(i) + 0.5) / 8.0 - 0.5 + jitter;\n        vec2 sampleUv = clamp(vUv + velocity * t, vec2(0.001), vec2(0.999));\n\n        // Gate A: velocity alpha  only sample element-covered pixels\n        if (texture2D(tVelocity, sampleUv).a < 0.5) continue;\n\n        // Gate B: depth  reject samples at a different depth layer\n        float sampleDepth = linDepth(texture2D(tDepth, sampleUv).x);\n        if (abs(sampleDepth - centerDepth) > uDepthThreshold) continue;\n\n        // Tent weight  center samples contribute more than edge samples\n        float weight = 1.0 - abs(t * 2.0);\n        weight = max(weight, 0.15);\n        color += texture2D(tColor, sampleUv) * weight;\n        totalWeight += weight;\n    }\n\n    // Fallback: all samples rejected (element at depth boundary)\n    if (totalWeight < 0.001) {\n        gl_FragColor = texture2D(tColor, vUv);\n        return;\n    }\n\n    // Preserve original alpha (canvas uses premultiplied alpha)\n    vec4 original = texture2D(tColor, vUv);\n    gl_FragColor = vec4((color / totalWeight).rgb, original.a);\n}\n"}),this.fsQuad=new sd(this.blurMaterial),this.instancedMeshes=new Set,this._velocityScene=new Ii}addInstancedMesh(e){this.instancedMeshes.add(e)}removeInstancedMesh(e){this.instancedMeshes.delete(e)}setIntensity(e){this.intensity=e,this.blurMaterial.uniforms.uIntensity.value=e}setDepthThreshold(e){this.depthThreshold=e,this.blurMaterial.uniforms.uDepthThreshold.value=e}setSize(e,t){this._targetWidth=e,this._targetHeight=t,this.velocityTarget&&this.velocityTarget.setSize(e,t)}render(e,t,n){if(!this.enabled)return;const{depthTexture:a}=n;if(!a)return;const i=this._targetWidth||n.width,r=this._targetHeight||n.height;this.velocityTarget&&this.velocityTarget.width===i&&this.velocityTarget.height===r||(this.velocityTarget&&this.velocityTarget.dispose(),this.velocityTarget=new hn(i,r,{minFilter:H,magFilter:H,format:ce,type:ee})),this._renderVelocityPass(e);const s=this.camera;this.blurMaterial.uniforms.cameraNear.value=s.near,this.blurMaterial.uniforms.cameraFar.value=s.far;const o=s.far-s.near;this.blurMaterial.uniforms.uDepthThreshold.value=Math.max(.1,.005*o),this.blurMaterial.uniforms.tColor.value=n.texture,this.blurMaterial.uniforms.tVelocity.value=this.velocityTarget.texture,this.blurMaterial.uniforms.tDepth.value=a,this.renderToScreen?e.setRenderTarget(null):(e.setRenderTarget(t),this.clear&&e.clear()),this.fsQuad.render(e)}_renderVelocityPass(e){const t=e.getRenderTarget(),n=new Ia,a=e.getClearAlpha();e.getClearColor(n);const i=e.autoClear;e.setRenderTarget(this.velocityTarget),e.setClearColor(8421376,0),e.clear(),e.autoClear=!1;const r=new Map,s=new Map,o=new Map;for(const e of this.instancedMeshes)e.visible&&0!==e.count&&(o.set(e,e.matrixWorld.clone()),r.set(e,e.parent),s.set(e,e.material),e.material=this.velocityMaterial,this._velocityScene.add(e),e.matrixWorldAutoUpdate=!1,e.matrixWorld.copy(o.get(e)));this._velocityScene.children.length>0&&e.render(this._velocityScene,this.camera);for(const[e,t]of r)this._velocityScene.remove(e),e.material=s.get(e),e.matrixWorldAutoUpdate=!0,t&&t.add(e);e.autoClear=i,e.setClearColor(n,a),e.setRenderTarget(t)}dispose(){this.velocityTarget&&this.velocityTarget.dispose(),this.velocityMaterial.dispose(),this.blurMaterial.dispose(),this.fsQuad.dispose(),this.instancedMeshes.clear()}}class yd{constructor(e,t){this.renderer=e,this.camera=t,this.distortionScene=new Ii,this.elementMeshes=new Map,this.configs=new Map,this._tmpMatrix=new Vn,this._tmpPos=new Gt,this._tmpQuat=new Ut,this._tmpScl=new Gt,this._savedClearColor=new Ia,this._savedClearAlpha=1}hasElement(e){return this.elementMeshes.has(e)}registerElement(e,t){if(this.elementMeshes.has(e))return;t.material.uniforms.uStrength&&(t.material.uniforms.uStrength.value=t.strength);const n=new ui(t.geometry,t.material);n.visible=!1,n.frustumCulled=!1,n.matrixAutoUpdate=!1,this.distortionScene.add(n),this.elementMeshes.set(e,n),this.configs.set(e,t),n.visible=!0,this.renderer.compile(this.distortionScene,this.camera),n.visible=!1}syncInstances(e,t,n){const a=this.elementMeshes.get(e);if(!a)return;if(0===n)return a.visible&&(a.visible=!1),void(this._peakAABB&&this._peakAABB.delete(e));const i=n,r=this.configs.get(e),s=this._tmpMatrix,o=this._tmpPos,l=this._tmpQuat,c=this._tmpScl;this._peakAABB||(this._peakAABB=new Map);const h=this._peakAABB.get(e);if(h&&i<h.count)o.copy(h.center),c.copy(h.size);else{let n=1/0,a=1/0,l=1/0,h=-1/0,d=-1/0,u=-1/0;for(let e=0;e<i;e++){t.getMatrixAt(e,s);const i=s.elements[12],r=s.elements[13],o=s.elements[14];i<n&&(n=i),i>h&&(h=i),r<a&&(a=r),r>d&&(d=r),o<l&&(l=o),o>u&&(u=o)}o.set(.5*(n+h),.5*(a+d),.5*(l+u));const{centerOffset:p}=r.transform;p&&(o.x+=p.x,o.y+=p.y,o.z+=p.z);const{padding:m}=r.transform,f=h-n+2*m.x,g=d-a+2*m.y;c.set(Math.max(f,m.x),Math.max(g,m.y),1),this._peakAABB.set(e,{center:o.clone(),size:c.clone(),count:i})}r.billboard?l.copy(this.camera.quaternion):l.identity(),s.compose(o,l,c),a.matrix.copy(s),a.matrixWorldNeedsUpdate=!0,a.visible=!0}hasActiveSources(){for(const[,e]of this.elementMeshes)if(e.visible)return!0;return!1}render(e){this.hasActiveSources()&&(this.renderer.getClearColor(this._savedClearColor),this._savedClearAlpha=this.renderer.getClearAlpha(),this.renderer.setRenderTarget(e),this.renderer.setClearColor(0,0),this.renderer.clear(),this.renderer.render(this.distortionScene,this.camera),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this._savedClearColor,this._savedClearAlpha))}update(e){for(const[,t]of this.elementMeshes)t.material.uniforms.uTime&&(t.material.uniforms.uTime.value+=e)}setElectricFlash(e){const t=this.elementMeshes.get("electricity");t?.material?.uniforms?.uFlashIntensity&&(t.material.uniforms.uFlashIntensity.value=e)}setDistortionStrength(e,t){const n=this.elementMeshes.get(e);if(!n?.material?.uniforms?.uStrength)return;const a=this.configs.get(e);n.material.uniforms.uStrength.value=null!=t?t:a?.strength??.018}setVoidFade(e){const t=this.elementMeshes.get("void");t?.material?.uniforms?.uFadeProgress&&(t.material.uniforms.uFadeProgress.value=e)}dispose(){for(const[,e]of this.elementMeshes)e.geometry.dispose(),e.material.dispose(),this.distortionScene.remove(e);this.elementMeshes.clear(),this.configs.clear()}}const vd={smoke:function(e){return new bi({name:"SmokeParticle",uniforms:{uTime:{value:0},uOpacity:{value:e.opacity??.4},uColorWarm:{value:new Ia(...e.colorWarm??[.45,.38,.3])},uColorCool:{value:new Ia(...e.colorCool??[.3,.3,.3])},uBuoyancy:{value:e.buoyancy??.3},uDrag:{value:e.drag??1.5},uTurbulenceStrength:{value:e.turbulence??.4},uEndSizeMultiplier:{value:e.endSizeMultiplier??3.5},uRotationSpeedMax:{value:e.rotationSpeedMax??1.5}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\n// Size over life: fast growth then plateau\nfloat sizeOverLife(float life) {\n    return 0.3 + 0.7 * (smoothstep(0.0, 0.3, life) + 0.3 * smoothstep(0.3, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    // === POSITION: deterministic from spawn constants ===\n\n    // Drag: v(t) = v0 * e^(-drag*t)\n    // Integrated: p(t) = p0 + v0 * (1 - e^(-drag*t)) / drag\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    // Buoyancy: constant upward accel, drag-limited\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n\n    // Turbulence: deterministic sinusoidal displacement\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp, 0.0) + turbulence;\n\n    // === SIZE: grows over life ===\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    // === ROTATION: initial angle + speed derived from seed ===\n    float rotSpeed = (fract(aSeed * 7.31) - 0.5) * 2.0 * uRotationSpeedMax;\n    float rot = aRotation + rotSpeed * age;\n    float c = cos(rot), s = sin(rot);\n    vec2 rotated = mat2(c, s, -s, c) * position.xy;\n\n    // === BILLBOARD: expand in view space (always faces camera) ===\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform vec3 uColorWarm;\nuniform vec3 uColorCool;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\n// Simple hash for noise perturbation\nfloat hash(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h) * 43758.5453);\n}\n\n// Value noise (one octave)\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid main() {\n    // Center UV to [-0.5, 0.5]\n    vec2 centered = vUv - 0.5;\n    float dist = length(centered);\n\n    // Noise-perturbed distance for irregular silhouette\n    float angle = atan(centered.y, centered.x);\n    float seed2 = vSeed * 17.3;\n    float n = noise(vec2(angle * 2.0 + seed2, dist * 4.0 + seed2 * 0.7)) * 0.15\n            + noise(vec2(angle * 4.0 - seed2 * 1.3, dist * 8.0 + seed2)) * 0.08;\n    float perturbedDist = dist + n - 0.07;\n\n    // Soft radial falloff  smoke puff shape\n    float radial = 1.0 - smoothstep(0.15, 0.50, perturbedDist);\n\n    // Life-based fade: quick in (10%), long hold, gradual out (last 45%)\n    float fadeIn = smoothstep(0.0, 0.10, vLife);\n    float fadeOut = 1.0 - smoothstep(0.55, 1.0, vLife);\n    float lifeFade = fadeIn * fadeOut;\n\n    // Combined alpha\n    float alpha = radial * lifeFade * uOpacity;\n\n    // Discard fully transparent fragments\n    if (alpha < 0.003) discard;\n\n    // Color: warm near birth  cool as it dissipates\n    float colorShift = smoothstep(0.0, 0.6, vLife);\n    vec3 color = mix(uColorWarm, uColorCool, colorShift);\n\n    // Premultiplied alpha output (blending: ONE + ONE_MINUS_SRC_ALPHA)\n    gl_FragColor = vec4(color * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:2,blending:5,blendSrc:h,blendDst:m,blendSrcAlpha:h,blendDstAlpha:m})},mist:function(e){return new bi({name:"MistParticle",uniforms:{uTime:{value:0},uOpacity:{value:e.opacity??.1},uColor:{value:new Ia(...e.color??[.75,.85,.95])},uBuoyancy:{value:e.buoyancy??-.02},uDrag:{value:e.drag??.8},uTurbulenceStrength:{value:e.turbulence??.08},uEndSizeMultiplier:{value:e.endSizeMultiplier??1.5},uRotationSpeedMax:{value:e.rotationSpeedMax??.4}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat sizeOverLife(float life) {\n    return 0.3 + 0.7 * (smoothstep(0.0, 0.3, life) + 0.3 * smoothstep(0.3, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp, 0.0) + turbulence;\n\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    float rotSpeed = (fract(aSeed * 7.31) - 0.5) * 2.0 * uRotationSpeedMax;\n    float rot = aRotation + rotSpeed * age;\n    float c = cos(rot), s = sin(rot);\n    vec2 rotated = mat2(c, s, -s, c) * position.xy;\n\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform vec3 uColor;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat pHash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }\nfloat pNoise(vec2 p) {\n    vec2 i = floor(p); vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(mix(pHash(i), pHash(i + vec2(1.0, 0.0)), f.x),\n               mix(pHash(i + vec2(0.0, 1.0)), pHash(i + vec2(1.0, 1.0)), f.x), f.y);\n}\n\nvoid main() {\n    vec2 center = vUv - 0.5;\n\n    // Per-particle wisp direction  each particle stretches differently\n    float wispAngle = vSeed * 6.283;\n    vec2 wispDir = vec2(cos(wispAngle), sin(wispAngle));\n    vec2 wispPerp = vec2(-wispDir.y, wispDir.x);\n\n    // Anisotropic distance: stretch along wisp direction for tendril shape\n    float along = dot(center, wispDir);\n    float across = dot(center, wispPerp);\n    float anisoDist = length(vec2(along * 0.7, across * 1.3));\n\n    // 3-octave FBM for organic cloud structure\n    float seedOff = vSeed * 73.0;\n    float fbm = pNoise(center * 3.0 + seedOff) * 0.50\n              + pNoise(center * 7.0 + seedOff * 1.7 + vec2(3.7, 1.2)) * 0.25\n              + pNoise(center * 14.0 + seedOff * 2.3 + vec2(7.1, 5.3)) * 0.125;\n\n    // Shape: anisotropic falloff with FBM erosion at edges\n    float shape = 1.0 - smoothstep(0.05, 0.42, anisoDist + (fbm - 0.4) * 0.20);\n\n    // Internal density variation  wisps and gaps through the body\n    float density = smoothstep(0.25, 0.55, fbm);\n    shape *= mix(0.3, 1.0, density);\n\n    // Fade over lifetime\n    float fadeIn = smoothstep(0.0, 0.15, vLife);\n    float fadeOut = 1.0 - smoothstep(0.60, 1.0, vLife);\n    float lifeAlpha = fadeIn * fadeOut;\n\n    float alpha = shape * lifeAlpha * uOpacity;\n    if (alpha < 0.003) discard;\n\n    // Premultiplied alpha output  constant pale color\n    gl_FragColor = vec4(uColor * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:2,blending:5,blendSrc:h,blendDst:m,blendSrcAlpha:h,blendDstAlpha:m})},spray:function(e){return new bi({name:"SprayParticle",uniforms:{uTime:{value:0},uOpacity:{value:e.opacity??.1},uColor:{value:new Ia(...e.color??[.4,.7,1])},uBuoyancy:{value:e.buoyancy??-.01},uDrag:{value:e.drag??1.2},uTurbulenceStrength:{value:e.turbulence??.12},uEndSizeMultiplier:{value:e.endSizeMultiplier??1.3},uRotationSpeedMax:{value:e.rotationSpeedMax??.6}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat sizeOverLife(float life) {\n    return 0.3 + 0.7 * (smoothstep(0.0, 0.3, life) + 0.3 * smoothstep(0.3, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp, 0.0) + turbulence;\n\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    float rotSpeed = (fract(aSeed * 7.31) - 0.5) * 2.0 * uRotationSpeedMax;\n    float rot = aRotation + rotSpeed * age;\n    float c = cos(rot), s = sin(rot);\n    vec2 rotated = mat2(c, s, -s, c) * position.xy;\n\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform vec3 uColor;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvoid main() {\n    vec2 center = vUv - 0.5;\n    float dist = length(center);\n\n    // Soft radial fade  billboards blend seamlessly at overlapping edges\n    float radialFade = 1.0 - smoothstep(0.15, 0.48, dist);\n    if (radialFade < 0.01) discard;\n\n    float seed = floor(vSeed * 1000.0);\n    float totalDroplet = 0.0;\n\n    // Scale 1: coarse droplets  ~6 cells across, ~20% contain a bright speck\n    // At typical billboard size (~30px), each dot is ~1px  barely visible\n    vec2 p1 = vUv * 6.0;\n    vec2 cell1 = floor(p1);\n    vec2 local1 = fract(p1);\n    float presence1 = step(0.80, hash21(cell1 + seed));\n    vec2 dropPos1 = vec2(hash21(cell1 * 1.7 + seed), hash21(cell1 * 2.3 + seed + 5.0));\n    float d1 = length(local1 - dropPos1);\n    float bright1 = 0.6 + 0.4 * hash21(cell1 * 5.3 + seed);\n    totalDroplet += (1.0 - smoothstep(0.0, 0.22, d1)) * presence1 * bright1;\n\n    // Scale 2: fine shimmer  ~12 cells across, ~15% occupied, dimmer\n    vec2 p2 = vUv * 12.0 + 7.3;\n    vec2 cell2 = floor(p2);\n    vec2 local2 = fract(p2);\n    float presence2 = step(0.85, hash21(cell2 + seed * 1.3));\n    vec2 dropPos2 = vec2(hash21(cell2 * 1.9 + seed), hash21(cell2 * 3.1 + seed + 3.0));\n    float d2 = length(local2 - dropPos2);\n    float bright2 = 0.5 + 0.5 * hash21(cell2 * 7.1 + seed);\n    totalDroplet += (1.0 - smoothstep(0.0, 0.15, d2)) * presence2 * bright2 * 0.5;\n\n    totalDroplet = min(totalDroplet, 1.2);\n\n    // Life fade: fast in, fast out\n    float fadeIn = smoothstep(0.0, 0.08, vLife);\n    float fadeOut = 1.0 - smoothstep(0.4, 1.0, vLife);\n    float lifeFade = fadeIn * fadeOut;\n\n    float alpha = totalDroplet * radialFade * lifeFade * uOpacity;\n    if (alpha < 0.003) discard;\n\n    // Premultiplied alpha output\n    gl_FragColor = vec4(uColor * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:2,blending:5,blendSrc:h,blendDst:m,blendSrcAlpha:h,blendDstAlpha:m})},void:function(e){return new bi({name:"VoidParticle",uniforms:{uTime:{value:0},uOpacity:{value:e.opacity??.85},uBuoyancy:{value:e.buoyancy??-.04},uDrag:{value:e.drag??.3},uTurbulenceStrength:{value:e.turbulence??.02},uEndSizeMultiplier:{value:e.endSizeMultiplier??2.5},uRotationSpeedMax:{value:e.rotationSpeedMax??.1},uGravityStrength:{value:e.gravityStrength??0},uGravityCenter:{value:new Gt(0,0,0)}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\nuniform float uGravityStrength;\nuniform vec3 uGravityCenter;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat sizeOverLife(float life) {\n    return 0.3 + 0.7 * (smoothstep(0.0, 0.3, life) + 0.3 * smoothstep(0.3, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp, 0.0) + turbulence;\n\n    // Gravity: drag-limited acceleration toward uGravityCenter\n    // Direction computed from DRIFTED position (worldPos), not aSpawnPos \n    // particles spawn near mascot center so aSpawnPos  gravityCenter,\n    // giving no useful direction. After drift, worldPos is offset and\n    // pullDir correctly points back inward.\n    if (uGravityStrength > 0.0) {\n        vec3 toCenter = uGravityCenter - worldPos;\n        float dist = length(toCenter);\n        if (dist > 0.01) {\n            vec3 pullDir = toCenter / dist;\n            float gravDisp = uGravityStrength * (age - dragDecay * invDrag);\n            worldPos += pullDir * gravDisp;\n        }\n    }\n\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    float rotSpeed = (fract(aSeed * 7.31) - 0.5) * 2.0 * uRotationSpeedMax;\n    float rot = aRotation + rotSpeed * age;\n    float c = cos(rot), s = sin(rot);\n    vec2 rotated = mat2(c, s, -s, c) * position.xy;\n\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:'\nuniform float uOpacity;\nuniform float uTime;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat vHash(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h) * 43758.5453);\n}\n\nfloat vNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float a = vHash(i);\n    float b = vHash(i + vec2(1.0, 0.0));\n    float c = vHash(i + vec2(0.0, 1.0));\n    float d = vHash(i + vec2(1.0, 1.0));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid main() {\n    vec2 center = vUv - 0.5;\n    float dist = length(center);\n\n    // Billboard clip  tight feather, not wide gradient\n    float clipFade = 1.0 - smoothstep(0.40, 0.46, dist);\n    if (clipFade < 0.01) discard;\n\n    //  SHAPE FIELD \n    // All detail lives in the boundary shape (WHERE the threshold cuts).\n    // Result will be thresholded into binary ink-or-void.\n\n    // Per-particle orientation and shape from seed\n    float tendrilAngle = vSeed * 6.283;\n    vec2 tendrilDir = vec2(cos(tendrilAngle), sin(tendrilAngle));\n    vec2 tendrilPerp = vec2(-tendrilDir.y, tendrilDir.x);\n\n    // Seed-driven stretch: elongated vs round blobs\n    float stretchAlong = 0.5 + fract(vSeed * 3.17) * 0.3;\n    float stretchAcross = 1.0 + fract(vSeed * 7.53) * 0.5;\n\n    float along = dot(center, tendrilDir);\n    float across = dot(center, tendrilPerp);\n    float anisoDist = length(vec2(along * stretchAlong, across * stretchAcross));\n\n    //  TIME DRIFT \n    // Slow organic undulation  ink spreading on wet paper.\n    // Each octave drifts at different speed/direction for counterflow.\n    float freqMod = 0.8 + fract(vSeed * 11.3) * 0.4;\n    float seedOff = vSeed * 73.0;\n    float t = uTime * 0.45;  // Visible undulation  living ink\n    vec2 drift1 = vec2(t * 0.7, -t * 0.5);           // Large-scale: slow diagonal\n    vec2 drift2 = vec2(-t * 1.1, t * 0.8);            // Medium: counter-drift\n    vec2 drift3 = vec2(t * 0.6, t * 1.5);             // Fine: faster perpendicular\n\n    // 3-octave noise for organic boundary perturbation\n    float n1 = vNoise(center * 3.0 * freqMod + seedOff + drift1);\n    float n2 = vNoise(center * 7.0 * freqMod + seedOff * 1.7 + vec2(3.7, 1.2) + drift2);\n    float n3 = vNoise(center * 15.0 * freqMod + seedOff * 2.9 + vec2(1.3, 5.1) + drift3);\n    float noiseField = n1 * 0.45 + n2 * 0.35 + n3 * 0.20;\n\n    // Noise-perturbed distance  organic blob boundary\n    float perturbedDist = anisoDist + (noiseField - 0.45) * 0.30;\n\n    // Raw shape: where ink could exist (before binary cuts)\n    float rawShape = 1.0 - smoothstep(0.08, 0.26, perturbedDist);\n\n    //  BINARY CUTS \n    // Fractures and density are hard masks  transparent gaps, not alpha fades.\n    // This is what makes ink look like ink: pigment IS or ISN\'T deposited.\n\n    // Fracture channels: hard transparent veins splitting blob into sub-pools\n    // Fractures drift slower than boundary  veins migrate, not vibrate\n    vec2 fracDrift1 = vec2(-t * 0.8, t * 0.5);\n    vec2 fracDrift2 = vec2(t * 0.9, t * 1.2);\n    float fracNoise = vNoise(center * 5.0 * freqMod + seedOff * 2.1 + fracDrift1);\n    float fracNoise2 = vNoise(center * 9.0 * freqMod + seedOff * 3.7 + vec2(2.1, 4.3) + fracDrift2);\n    // Two-scale fractures: wide primary splits + fine secondary cracks\n    float fracture = min(\n        smoothstep(0.18, 0.25, fracNoise),      // Wide primary veins\n        smoothstep(0.12, 0.18, fracNoise2)       // Fine secondary cracks\n    );\n    rawShape *= fracture;\n\n    // Ink density: hard cutoff  thin areas are GONE, not faded\n    // Uses the already-animated noiseField, so density boundary undulates with shape\n    float inkDensity = smoothstep(0.32, 0.42, noiseField);\n    rawShape *= inkDensity;\n\n    //  BINARY THRESHOLD \n    // Collapse the raw shape into ink-or-void.\n    // All the organic detail above determines WHERE this threshold cuts.\n    // Interior is near-opaque, exterior is transparent. No grey zone.\n    float inkMask = smoothstep(0.12, 0.35, rawShape);\n\n    //  EDGE FEATHER \n    // Thin rim-softening at the ink boundary prevents aliasing.\n    // Only the outermost few percent get feathered  interior stays solid.\n    float edgeFeather = smoothstep(0.26, 0.16, perturbedDist);\n    inkMask *= edgeFeather;\n\n    //  LIFE FADE + OPACITY \n    // Applied AFTER thresholding: fading particles go from "dark ink"\n    // to "dark ink dissolving"  not "grey getting lighter."\n    float fadeIn = smoothstep(0.0, 0.08, vLife);\n    float fadeOut = 1.0 - smoothstep(0.50, 1.0, vLife);\n\n    float alpha = inkMask * fadeIn * fadeOut * clipFade * uOpacity;\n    if (alpha < 0.01) discard;\n\n    //  TONAL GRADIENT \n    // Rim = darkest (pigment pools at boundary as solvent evaporates).\n    // Core = slightly brighter (thinner ink deposit).\n    float depthInBlob = smoothstep(0.26, 0.06, perturbedDist);\n    float tone = mix(0.002, 0.025, depthInBlob * depthInBlob);\n    gl_FragColor = vec4(vec3(tone) * alpha, alpha);\n}\n',transparent:!0,depthWrite:!1,depthTest:!0,side:2,blending:5,blendSrc:h,blendDst:m,blendSrcAlpha:h,blendDstAlpha:m})},firefly:function(e){return new bi({name:"FireflyParticle",uniforms:{uTime:{value:0},uOpacity:{value:e.opacity??.85},uColor:{value:new Ia(...e.color||[1,.85,.4])},uBuoyancy:{value:e.buoyancy??.01},uDrag:{value:e.drag??.8},uTurbulenceStrength:{value:e.turbulence??.15},uEndSizeMultiplier:{value:e.endSizeMultiplier??.8},uRotationSpeedMax:{value:e.rotationSpeedMax??0}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat sizeOverLife(float life) {\n    return 0.3 + 0.7 * (smoothstep(0.0, 0.3, life) + 0.3 * smoothstep(0.3, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n\n    // Turbulence: deterministic sinusoidal brownian drift\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp, 0.0) + turbulence;\n\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    // No rotation for point lights  but keep attribute for compatibility\n    vec2 rotated = position.xy;\n\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform float uTime;\nuniform vec3 uColor;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nvoid main() {\n    vec2 center = vUv - 0.5;\n    float dist = length(center);\n    float ang = atan(center.y, center.x);\n\n    //  TWINKLE STAR SHAPE \n    // 4-pointed star cross radiating from center  not a round blob.\n    // Star rays extend further than the circular core.\n    float star4 = pow(abs(cos(ang * 2.0)), 10.0);      // 4-pointed cross pattern\n    float starExtend = star4 * 0.15;                     // Rays extend 0.15 beyond core\n\n    // Bright core (small tight center)\n    float core = smoothstep(0.10, 0.0, dist);\n\n    // Star rays: thin spikes along 4 axes\n    float starRays = smoothstep(0.10 + starExtend, 0.0, dist) * 0.6;\n\n    // Circular glow halo around star  visible aura\n    float glow = smoothstep(0.48, 0.0, dist) * 0.25;\n\n    float shape = core + starRays + glow;\n\n    // Billboard clip\n    if (shape < 0.005) discard;\n\n    //  TWINKLE CYCLE \n    // Two overlapping sine waves at different frequencies create an irregular\n    // beat pattern  brief bright flashes when both waves align, dark gaps\n    // between. Looks like real twinkling / sparkle, not slow bioluminescence.\n\n    float freq1 = 1.5 + vSeed * 1.0;                    // 1.5-2.5 Hz per particle\n    float freq2 = 2.3 + vSeed * 0.8;                    // 2.3-3.1 Hz (different rate)\n    float phase1 = uTime * freq1 + vSeed * 12.0;\n    float phase2 = uTime * freq2 + vSeed * 7.0;\n    float beat = sin(phase1) * sin(phase2);\n\n    // Broader peaks: pow(2.5) keeps flash character but particles visible longer\n    float twinkle = pow(max(0.0, beat), 2.5);\n\n    // Higher glow floor so particles stay visible between flashes\n    twinkle = twinkle * 0.65 + 0.35;\n\n    //  LIFE FADE \n    float fadeIn = smoothstep(0.0, 0.15, vLife);\n    float fadeOut = 1.0 - smoothstep(0.70, 1.0, vLife);\n\n    //  COLOR \n    // Warm golden at low brightness, shifts toward white at peak twinkle\n    vec3 color = mix(uColor, vec3(1.0, 0.98, 0.90), twinkle * 0.5);\n\n    float alpha = shape * twinkle * fadeIn * fadeOut * uOpacity;\n    if (alpha < 0.003) discard;\n\n    // Additive blending: output color * alpha (premultiplied for additive)\n    gl_FragColor = vec4(color * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:2,blending:2})},dust:function(e){return new bi({name:"DustParticle",uniforms:{uTime:{value:0},uOpacity:{value:e.opacity??.75},uColor:{value:new Ia(...e.color||[.55,.45,.35])},uColorVariant:{value:new Ia(...e.colorVariant||e.color||[.55,.45,.35])},uBuoyancy:{value:e.buoyancy??.01},uDrag:{value:e.drag??.8},uTurbulenceStrength:{value:e.turbulence??.1},uEndSizeMultiplier:{value:e.endSizeMultiplier??.6},uRotationSpeedMax:{value:e.rotationSpeedMax??1.5},uGravity:{value:e.gravity??0}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\nuniform float uGravity;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat sizeOverLife(float life) {\n    // Dust: appear small, grow slightly, shrink at end\n    // Gravel: appear full size, no growth\n    return smoothstep(0.0, 0.15, life) * (1.0 - 0.3 * smoothstep(0.7, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    // Buoyancy (upward for dust) + Gravity (downward for gravel)\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n    float gravityDisp = -uGravity * age * age * 0.5;\n\n    // Turbulence: deterministic sinusoidal brownian drift\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp + gravityDisp, 0.0) + turbulence;\n\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    // Rotation for angular debris\n    float angle = aRotation + age * uRotationSpeedMax * (aSeed - 0.5) * 2.0;\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 rotated = vec2(\n        position.x * c - position.y * s,\n        position.x * s + position.y * c\n    );\n\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform float uTime;\nuniform vec3 uColor;\nuniform vec3 uColorVariant;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\n// Simple hash for shape noise\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(234.34, 435.345));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\nvoid main() {\n    vec2 center = vUv - 0.5;\n    float dist = length(center);\n\n    //  SOFT MOTE SHAPE \n    // Smooth radial falloff  dust reads as out-of-focus floating motes,\n    // not sharp geometric debris. Slight angular wobble keeps them organic.\n    float ang = atan(center.y, center.x);\n    float wobble = sin(ang * 3.0 + vSeed * 20.0) * 0.04;  // Subtle, not angular\n    float effectiveRadius = 0.38 + wobble;\n\n    // Soft Gaussian-like falloff  core opaque, edges dissolve\n    float shape = smoothstep(effectiveRadius, effectiveRadius * 0.15, dist);\n\n    // Billboard clip\n    if (shape < 0.01) discard;\n\n    //  SURFACE TEXTURE \n    // Very subtle brightness variation  dust is mostly uniform, not gritty\n    float grain = hash21(floor(vUv * 8.0 + vSeed * 10.0));\n    float surfaceVar = 0.92 + grain * 0.16;\n\n    //  LIFE FADE \n    float fadeIn = smoothstep(0.0, 0.10, vLife);\n    float fadeOut = 1.0 - smoothstep(0.55, 1.0, vLife);  // Gradual dissipation  settling dust\n\n    //  COLOR \n    // Per-particle color variation  lerp between base and variant\n    vec3 particleColor = mix(uColor, uColorVariant, vSeed);\n    float seedVar = vSeed * 0.15;\n    vec3 color = particleColor * surfaceVar * (0.9 + seedVar);\n\n    // Gentle center brightening  dust motes catch light at core\n    color *= mix(0.85, 1.0, smoothstep(effectiveRadius, 0.0, dist));\n\n    float alpha = shape * fadeIn * fadeOut * uOpacity;\n    if (alpha < 0.005) discard;\n\n    // Premultiplied alpha output for correct compositing\n    gl_FragColor = vec4(color * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:2,blending:5,blendEquation:s,blendSrc:h,blendDst:m})},leaf:function(e){return new bi({name:"LeafParticle",uniforms:{uTime:{value:0},uOpacity:{value:e.opacity??.55},uColor:{value:new Ia(...e.color||[.85,.65,.25])},uColorVariant:{value:new Ia(...e.colorVariant||e.color||[.7,.35,.15])},uBuoyancy:{value:e.buoyancy??-.005},uDrag:{value:e.drag??1},uTurbulenceStrength:{value:e.turbulence??.25},uEndSizeMultiplier:{value:e.endSizeMultiplier??.85},uRotationSpeedMax:{value:e.rotationSpeedMax??2.5},uGravity:{value:e.gravity??.03}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\nuniform float uGravity;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat sizeOverLife(float life) {\n    // Leaves: appear quickly, hold size, slight shrink as they settle\n    return smoothstep(0.0, 0.08, life) * (1.0 - 0.15 * smoothstep(0.8, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    // Buoyancy (negative for downward pull) + Gravity\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n    float gravityDisp = -uGravity * age * age * 0.5;\n\n    // Turbulence: deterministic sinusoidal drift for side-to-side swaying\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp + gravityDisp, 0.0) + turbulence;\n\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    // Rotation  fast tumbling like a real falling leaf\n    float angle = aRotation + age * uRotationSpeedMax * (aSeed - 0.5) * 2.0;\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 rotated = vec2(\n        position.x * c - position.y * s,\n        position.x * s + position.y * c\n    );\n\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform float uTime;\nuniform vec3 uColor;\nuniform vec3 uColorVariant;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nvoid main() {\n    vec2 center = vUv - 0.5;\n\n    //  SHAPE SELECTION  4 leaf types from seed \n    float shapeSeed = fract(vSeed * 2.37);\n    float widthSeed = fract(vSeed * 3.71);\n    float heightSeed = fract(vSeed * 5.93);\n\n    int shapeType = int(floor(shapeSeed * 4.0));\n\n    float edgeDist;\n    float tipFade = 1.0;\n    float foldMask = 0.0;      // >0 darkens folded half (underside)\n    float creaseStrength = 0.0; // >0 adds bright crease line at fold\n\n    if (shapeType == 0) {\n        //  SIMPLE LEAF  pointed oval (willow / birch) \n        float leafHalfH = 0.34 + heightSeed * 0.10;\n        float leafMaxW = 0.14 + widthSeed * 0.06;\n        float yN = center.y / leafHalfH;\n        if (abs(yN) > 1.0) discard;\n        float asymmetry = 1.0 + yN * 0.12;\n        float hw = leafMaxW * (1.0 - yN * yN) * asymmetry;\n        hw += sin(yN * 12.0 + vSeed * 8.0) * 0.006 * (1.0 - yN * yN);\n        edgeDist = abs(center.x) - hw;\n        tipFade = smoothstep(1.0, 0.85, abs(yN));\n\n    } else if (shapeType == 1) {\n        //  FOLDED LEAF  one half curled under, showing underside \n        float leafHalfH = 0.36 + heightSeed * 0.08;\n        float leafMaxW = 0.16 + widthSeed * 0.06;\n        float yN = center.y / leafHalfH;\n        if (abs(yN) > 1.0) discard;\n        float base = leafMaxW * (1.0 - yN * yN) * (1.0 + yN * 0.10);\n        // Fold: one side narrower (curled under/away from viewer)\n        float foldDir = step(0.5, fract(vSeed * 4.13)) * 2.0 - 1.0; // L or R\n        float foldAmt = 0.35 + fract(vSeed * 6.77) * 0.25; // 35-60%\n        float isFoldSide = step(0.0, center.x * foldDir);\n        float hw = mix(base, base * (1.0 - foldAmt), isFoldSide);\n        edgeDist = abs(center.x) - hw;\n        tipFade = smoothstep(1.0, 0.85, abs(yN));\n        foldMask = isFoldSide * 0.35;\n        creaseStrength = 0.3;\n\n    } else if (shapeType == 2) {\n        //  FOLDED OAK  scalloped lobes, one half curled under \n        float leafHalfH = 0.38 + heightSeed * 0.08;\n        float leafMaxW = 0.16 + widthSeed * 0.06;\n        float yN = center.y / leafHalfH;\n        if (abs(yN) > 1.0) discard;\n        float base = leafMaxW * (1.0 - yN * yN);\n        // 4 pairs of rounded scallops along length\n        float scallop = sin(yN * 12.57 + vSeed * 5.0) * 0.04 * (1.0 - yN * yN);\n        float hw = base + scallop;\n        // Asymmetric  wider toward tip end\n        hw *= 1.0 - yN * 0.15;\n        // Fold: one side narrower (curled under)\n        float foldDir2 = step(0.5, fract(vSeed * 8.29)) * 2.0 - 1.0;\n        float foldAmt2 = 0.30 + fract(vSeed * 9.41) * 0.25;\n        float isFoldSide2 = step(0.0, center.x * foldDir2);\n        hw = mix(hw, hw * (1.0 - foldAmt2), isFoldSide2);\n        edgeDist = abs(center.x) - hw;\n        tipFade = smoothstep(1.0, 0.88, abs(yN));\n        foldMask = isFoldSide2 * 0.35;\n        creaseStrength = 0.3;\n\n    } else {\n        //  ROUND LEAF  egg / teardrop (aspen / linden) \n        float leafHalfH = 0.30 + heightSeed * 0.06;\n        float leafMaxW = 0.18 + widthSeed * 0.05;\n        float yN = center.y / leafHalfH;\n        if (abs(yN) > 1.0) discard;\n        // Egg shape: wider below center, narrower above  pointed tip\n        float hw = leafMaxW * (1.0 - yN * yN) * (1.0 - yN * 0.25);\n        // Slight heart indent at base (bottom of leaf)\n        hw *= 1.0 - 0.12 * smoothstep(0.5, 1.0, -yN) * smoothstep(0.05, 0.0, abs(center.x));\n        edgeDist = abs(center.x) - hw;\n        tipFade = smoothstep(1.0, 0.80, abs(yN));\n    }\n\n    //  ANTI-ALIASED EDGE  fixed-width transition, never collapses \n    float shape = smoothstep(0.008, -0.008, edgeDist);\n    shape *= tipFade;\n\n    if (shape < 0.01) discard;\n\n    //  CENTER VEIN \n    float vein = smoothstep(0.012, 0.003, abs(center.x)) * shape * 0.35;\n\n    //  LIFE FADE \n    float fadeIn = smoothstep(0.0, 0.08, vLife);\n    float fadeOut = 1.0 - smoothstep(0.65, 1.0, vLife);\n\n    //  COLOR  wide variety \n    // Continuous hue cycle through 4 colors for maximum diversity\n    float hue = fract(vSeed * 5.17);\n\n    // 4 anchor colors, smoothly interpolated\n    vec3 c0 = vec3(0.30, 0.55, 0.15);   // Fresh green\n    vec3 c1 = uColor;                    // Golden yellow\n    vec3 c2 = uColorVariant;             // Warm orange-red\n    vec3 c3 = vec3(0.45, 0.18, 0.10);   // Deep burgundy-brown\n\n    // Smooth cycling: 0c0, 0.25c1, 0.5c2, 0.75c3, 1.0c0\n    float t = hue * 4.0;\n    vec3 leafColor;\n    if (t < 1.0) {\n        leafColor = mix(c0, c1, t);\n    } else if (t < 2.0) {\n        leafColor = mix(c1, c2, t - 1.0);\n    } else if (t < 3.0) {\n        leafColor = mix(c2, c3, t - 2.0);\n    } else {\n        leafColor = mix(c3, c0, t - 3.0);\n    }\n\n    // Per-leaf brightness variation\n    leafColor *= 0.82 + fract(vSeed * 7.31) * 0.36;\n\n    // Edge darkening  natural shadow at curled edges\n    leafColor *= mix(0.75, 1.0, smoothstep(0.0, -0.03, edgeDist));\n\n    // Vein darkens center\n    leafColor *= 1.0 - vein;\n\n    // Fold effect  darken underside half + bright crease at fold line\n    leafColor *= 1.0 - foldMask;\n    leafColor += creaseStrength * smoothstep(0.015, 0.003, abs(center.x)) * shape;\n\n    float alpha = shape * fadeIn * fadeOut * uOpacity;\n    if (alpha < 0.005) discard;\n\n    // Premultiplied alpha output for correct compositing\n    gl_FragColor = vec4(leafColor * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:2,blending:5,blendEquation:s,blendSrc:h,blendDst:m})}},bd={smoke:{materialType:"smoke",maxParticles:64,spawnRate:18,lifetimeMin:1.5,lifetimeMax:2.5,sizeMin:.1,sizeMax:.18,spawnOffsetY:0,initialSpeedMin:.1,initialSpeedMax:.25,spreadXZ:.15,directionY:1,buoyancy:.04,drag:1.8,turbulence:.2,rotationSpeedMax:1,endSizeMultiplier:1.8,opacity:.2,colorWarm:[.25,.22,.18],colorCool:[.18,.18,.2]},mist:{materialType:"mist",maxParticles:48,spawnRate:8,lifetimeMin:1.5,lifetimeMax:3,sizeMin:.25,sizeMax:.5,spawnOffsetY:-.1,initialSpeedMin:.02,initialSpeedMax:.06,spreadXZ:.2,directionY:-.05,buoyancy:-.005,drag:.8,turbulence:.08,rotationSpeedMax:.4,endSizeMultiplier:1.5,opacity:.12,color:[.75,.82,.9]},steam:{materialType:"smoke",maxParticles:32,spawnRate:15,lifetimeMin:.8,lifetimeMax:1.5,sizeMin:.08,sizeMax:.18,spawnOffsetY:.05,initialSpeedMin:1.5,initialSpeedMax:2.5,spreadXZ:.15,directionY:1,buoyancy:.5,drag:2,turbulence:.2,rotationSpeedMax:2,endSizeMultiplier:2.5,opacity:.25,colorWarm:[.8,.8,.8],colorCool:[.6,.6,.6]},fog:{materialType:"mist",maxParticles:16,spawnRate:1,lifetimeMin:6,lifetimeMax:10,sizeMin:.5,sizeMax:1,spawnOffsetY:0,initialSpeedMin:.01,initialSpeedMax:.03,spreadXZ:.3,directionY:0,buoyancy:0,drag:.5,turbulence:.03,rotationSpeedMax:.15,endSizeMultiplier:1.1,opacity:.03,color:[.65,.7,.75]},ozone:{materialType:"smoke",maxParticles:32,spawnRate:10,lifetimeMin:.6,lifetimeMax:1.2,sizeMin:.06,sizeMax:.12,spawnOffsetY:0,initialSpeedMin:.3,initialSpeedMax:.8,spreadXZ:.1,directionY:1,buoyancy:.15,drag:2.5,turbulence:.15,rotationSpeedMax:2,endSizeMultiplier:2,opacity:.15,colorWarm:[.6,.7,.85],colorCool:[.4,.45,.55]},shadow:{materialType:"void",maxParticles:48,spawnRate:10,lifetimeMin:1.5,lifetimeMax:3,sizeMin:.12,sizeMax:.25,spawnOffsetY:0,initialSpeedMin:.03,initialSpeedMax:.1,spreadXZ:.15,directionY:-.1,buoyancy:-.01,drag:.6,turbulence:.05,rotationSpeedMax:.3,endSizeMultiplier:1.6,opacity:.35},darkness:{materialType:"void",maxParticles:36,spawnRate:8,lifetimeMin:2,lifetimeMax:4,sizeMin:.18,sizeMax:.35,spawnOffsetY:0,initialSpeedMin:.04,initialSpeedMax:.12,spreadXZ:.25,directionY:-.3,buoyancy:-.03,drag:.4,turbulence:.04,rotationSpeedMax:.15,endSizeMultiplier:1.5,opacity:.7},spray:{materialType:"spray",maxParticles:180,spawnRate:60,lifetimeMin:.5,lifetimeMax:1.2,sizeMin:.14,sizeMax:.3,spawnOffsetY:.05,spawnRadius:.35,initialSpeedMin:.8,initialSpeedMax:1.6,spreadXZ:.4,directionY:.5,buoyancy:-.8,drag:1,turbulence:.06,rotationSpeedMax:.3,endSizeMultiplier:.8,opacity:.55,color:[.4,.7,1]},firefly:{materialType:"firefly",maxParticles:65,spawnRate:16,lifetimeMin:2,lifetimeMax:3.5,sizeMin:.16,sizeMax:.38,spawnOffsetY:0,initialSpeedMin:.02,initialSpeedMax:.08,spreadXZ:.3,directionY:.3,buoyancy:.015,drag:.6,turbulence:.25,rotationSpeedMax:0,endSizeMultiplier:.7,opacity:.9,color:[1,.85,.4]},"earth-dust":{materialType:"dust",maxParticles:80,spawnRate:20,lifetimeMin:1.5,lifetimeMax:3,sizeMin:.02,sizeMax:.1,spawnOffsetY:-.1,initialSpeedMin:.01,initialSpeedMax:.04,spreadXZ:.3,directionY:.4,buoyancy:.008,drag:1.2,turbulence:.2,rotationSpeedMax:.3,endSizeMultiplier:.4,opacity:.35,color:[.6,.48,.32],colorVariant:[.7,.45,.25],gravity:0},"earth-gravel":{materialType:"dust",maxParticles:60,spawnRate:25,lifetimeMin:.8,lifetimeMax:1.6,sizeMin:.03,sizeMax:.14,spawnOffsetY:.15,initialSpeedMin:.08,initialSpeedMax:.2,spreadXZ:.4,directionY:.1,buoyancy:0,drag:.3,turbulence:.05,rotationSpeedMax:3,endSizeMultiplier:.9,opacity:.8,color:[.45,.4,.35],colorVariant:[.55,.42,.28],gravity:.4},"earth-pebble":{materialType:"dust",maxParticles:24,spawnRate:8,lifetimeMin:.6,lifetimeMax:1.2,sizeMin:.1,sizeMax:.22,spawnOffsetY:.1,initialSpeedMin:.15,initialSpeedMax:.35,spreadXZ:.5,directionY:.3,buoyancy:0,drag:.15,turbulence:.02,rotationSpeedMax:4,endSizeMultiplier:.95,opacity:.9,color:[.4,.36,.3],colorVariant:[.5,.35,.2],gravity:.8},"falling-leaves":{materialType:"leaf",maxParticles:80,spawnRate:18,lifetimeMin:2,lifetimeMax:5,sizeMin:.04,sizeMax:.22,spawnOffsetY:.5,initialSpeedMin:.01,initialSpeedMax:.06,spreadXZ:.5,directionY:-.3,buoyancy:-.005,drag:1,turbulence:.25,rotationSpeedMax:2.5,endSizeMultiplier:.8,opacity:.65,color:[.9,.7,.25],colorVariant:[.75,.3,.12],gravity:.03}};function wd(e,t,n){const a=Math.max(0,Math.min(1,(n-e)/(t-e)));return a*a*(3-2*a)}function xd(e){const t=e.preset||"smoke",n=bd[t];if(!n)return console.warn(`[AtmosphericPresets] Unknown preset "${t}", falling back to smoke`),xd({...e,preset:"smoke"});const a=e.intensity??1,i=e.sizeScale??1,r=e.speedScale??1,s={...n};s.spawnRate=n.spawnRate*a,s.opacity=n.opacity*Math.sqrt(Math.min(a,1.5)),s.sizeMin=n.sizeMin*i,s.sizeMax=n.sizeMax*i,s.initialSpeedMin=n.initialSpeedMin*r,s.initialSpeedMax=n.initialSpeedMax*r,e.colorTint&&("smoke"===n.materialType?(s.colorWarm=e.colorTint,s.colorCool=e.colorTint):s.color=e.colorTint);const o=e.anchor||"above";let{spawnOffsetY:l}=n;const c=e.anchorOffset??0;switch(o){case"above":l=Math.abs(n.spawnOffsetY)+c,s.directionY=1;break;case"below":l=-Math.abs(n.spawnOffsetY)+c,s.directionY=n.directionY??-.3;break;case"around":l=c,s.spreadXZ=1.5*n.spreadXZ;break;case"trailing":l=c}return s.spawnOffsetY=l,null!=e.lifetimeScale&&(s.lifetimeMin=n.lifetimeMin*e.lifetimeScale,s.lifetimeMax=n.lifetimeMax*e.lifetimeScale),e.gravity&&(s.gravityStrength=e.gravity.strength||0,e.gravity.spawnRadius&&(s.spawnRadius=e.gravity.spawnRadius)),{material:(0,vd[n.materialType])(s),maxParticles:s.maxParticles,spawnRate:s.spawnRate,lifetimeMin:s.lifetimeMin,lifetimeMax:s.lifetimeMax,sizeMin:s.sizeMin,sizeMax:s.sizeMax,spawnOffsetY:s.spawnOffsetY,initialSpeedMin:s.initialSpeedMin,initialSpeedMax:s.initialSpeedMax,spreadXZ:s.spreadXZ,directionY:s.directionY,spawnRadius:s.spawnRadius||0,targetModels:e.targets||null,anchor:o,progressCurve:e.progressCurve||"sustain",burstCount:e.burstCount||0,baseSpawnRate:s.spawnRate,velocityInheritance:e.velocityInheritance||0,centrifugal:e.centrifugal||null,gravity:e.gravity||null}}const Sd=new Gt;class Md{constructor(e){this.config=e,this.activeCount=0,this.spawnAccumulator=0,this.sourceCount=0,this.spawning=!0,this._dirty=!1,this._progress=0,this._energy=null,this._sourcePositions=new Float32Array(192),this._prevSourcePositions=new Float32Array(192),this._sourceVelocities=new Float32Array(192),this._prevSourceCount=0,this._hasVelocityData=!1;const t=e.maxParticles;this._spawnPosBuffer=new Float32Array(3*t),this._spawnVelBuffer=new Float32Array(3*t),this._spawnTimeBuffer=new Float32Array(t),this._lifetimeBuffer=new Float32Array(t),this._sizeBuffer=new Float32Array(t),this._rotationBuffer=new Float32Array(t),this._seedBuffer=new Float32Array(t),this.geometry=this._createGeometry(t),this.mesh=new ui(this.geometry,e.material),this.mesh.frustumCulled=!1,this.mesh.visible=!1,this.mesh.renderOrder=100}_createGeometry(e){const t=new ol,n=new Float32Array([-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0]),a=new Uint16Array([0,1,2,0,2,3]);t.setAttribute("position",new Wa(n,3)),t.setIndex(new Wa(a,1));const i=[["aSpawnPos",this._spawnPosBuffer,3],["aSpawnVelocity",this._spawnVelBuffer,3],["aSpawnTime",this._spawnTimeBuffer,1],["aLifetime",this._lifetimeBuffer,1],["aSize",this._sizeBuffer,1],["aRotation",this._rotationBuffer,1],["aSeed",this._seedBuffer,1]];for(const[e,n,a]of i){const i=new pr(n,a);i.setUsage(gt),t.setAttribute(e,i)}return t.instanceCount=0,t}setSourcePositions(e,t){if(this.sourceCount=Math.min(t,64),0!==this.sourceCount)for(let t=0;t<3*this.sourceCount;t++)this._sourcePositions[t]=e[t]}_updateSourceVelocities(e){if(e<.001||0===this._prevSourceCount||0===this.sourceCount){for(let e=0;e<3*this.sourceCount;e++)this._prevSourcePositions[e]=this._sourcePositions[e];return this._prevSourceCount=this.sourceCount,void(this._hasVelocityData=this._prevSourceCount>0)}const t=1/e,n=Math.min(this.sourceCount,this._prevSourceCount);for(let e=0;e<n;e++){const n=3*e;this._sourceVelocities[n]=(this._sourcePositions[n]-this._prevSourcePositions[n])*t,this._sourceVelocities[n+1]=(this._sourcePositions[n+1]-this._prevSourcePositions[n+1])*t,this._sourceVelocities[n+2]=(this._sourcePositions[n+2]-this._prevSourcePositions[n+2])*t}for(let e=3*n;e<3*this.sourceCount;e++)this._sourceVelocities[e]=0;for(let e=0;e<3*this.sourceCount;e++)this._prevSourcePositions[e]=this._sourcePositions[e];this._prevSourceCount=this.sourceCount,this._hasVelocityData=!0}update(e,t){this._updateSourceVelocities(e);for(let e=0;e<this.activeCount;e++)t-this._spawnTimeBuffer[e]>=this._lifetimeBuffer[e]&&(this._kill(e),e--);if(this.spawning&&this.sourceCount>0){const n=function(e,t){switch(e){case"sustain":default:return 1;case"rampUp":return wd(0,.5,t);case"rampDown":return 1-wd(.5,1,t);case"pulse":return Math.sin(t*Math.PI);case"burst":return 1-wd(0,.3,t)}}(this.config.progressCurve,this._progress),a=this.config.baseSpawnRate*n,i=null!==this._energy?this._energy:n;for(this.spawnAccumulator+=a*e;this.spawnAccumulator>=1&&this.activeCount<this.config.maxParticles;)this.spawnAccumulator-=1,this._spawnOne(t,i)}else this.spawning,this.spawnAccumulator=0;if(this._dirty){this.geometry.instanceCount=this.activeCount;const e=this.geometry.attributes,t=this.activeCount;this._markDirty(e.aSpawnPos,t),this._markDirty(e.aSpawnVelocity,t),this._markDirty(e.aSpawnTime,t),this._markDirty(e.aLifetime,t),this._markDirty(e.aSize,t),this._markDirty(e.aRotation,t),this._markDirty(e.aSeed,t),this.mesh.visible=t>0,this._dirty=!1}this.mesh.material.uniforms.uTime.value=t}_markDirty(e,t){e&&(e.needsUpdate=!0)}burstSpawn(e,t){if(0!==this.sourceCount)for(let n=0;n<e&&this.activeCount<this.config.maxParticles;n++)this._spawnOne(t,1)}_spawnOne(e,t=1){const n=this.config,a=this.activeCount,i=.3+.7*t,r=Math.floor(Math.random()*this.sourceCount),s=this._sourcePositions[3*r],o=this._sourcePositions[3*r+1],l=this._sourcePositions[3*r+2],c=(n.initialSpeedMin+Math.random()*(n.initialSpeedMax-n.initialSpeedMin))*i,h=n.spawnRadius||0;let d=0,u=0,p=0,m=0;if(h>0){const e=Math.random()*Math.PI*2,t=Math.sqrt(Math.random())*h,a=Math.cos(e),i=Math.sin(e);d=a*t,u=i*t,n.gravity||(p=a*c*.5,m=i*c*.5)}this._spawnPosBuffer[3*a]=s+d+.05*(Math.random()-.5),this._spawnPosBuffer[3*a+1]=o+(n.spawnOffsetY??0),this._spawnPosBuffer[3*a+2]=l+u+.05*(Math.random()-.5);let f=p+(Math.random()-.5)*n.spreadXZ,g=c*(n.directionY??1),y=m+(Math.random()-.5)*n.spreadXZ;const v=n.velocityInheritance||0;v>0&&this._hasVelocityData&&(f+=this._sourceVelocities[3*r]*v,g+=this._sourceVelocities[3*r+1]*v,y+=this._sourceVelocities[3*r+2]*v);const{centrifugal:b}=n;if(b&&(0!==d||0!==u)){const e=Math.sqrt(d*d+u*u);if(e>.01){const t=b.speed*i,n=1-(b.tangentialBias||0);f+=d/e*t*n,y+=u/e*t*n;const a=b.tangentialBias||0;a>0&&(f+=-u/e*t*a,y+=d/e*t*a)}}this._spawnVelBuffer[3*a]=f,this._spawnVelBuffer[3*a+1]=g,this._spawnVelBuffer[3*a+2]=y,this._spawnTimeBuffer[a]=e,this._lifetimeBuffer[a]=n.lifetimeMin+Math.random()*(n.lifetimeMax-n.lifetimeMin);const w=.7+.3*t;this._sizeBuffer[a]=(n.sizeMin+Math.random()*(n.sizeMax-n.sizeMin))*w,this._rotationBuffer[a]=Math.random()*Math.PI*2,this._seedBuffer[a]=Math.random(),this.activeCount++,this._dirty=!0}_kill(e){const t=this.activeCount-1;e!==t&&(this._spawnPosBuffer[3*e]=this._spawnPosBuffer[3*t],this._spawnPosBuffer[3*e+1]=this._spawnPosBuffer[3*t+1],this._spawnPosBuffer[3*e+2]=this._spawnPosBuffer[3*t+2],this._spawnVelBuffer[3*e]=this._spawnVelBuffer[3*t],this._spawnVelBuffer[3*e+1]=this._spawnVelBuffer[3*t+1],this._spawnVelBuffer[3*e+2]=this._spawnVelBuffer[3*t+2],this._spawnTimeBuffer[e]=this._spawnTimeBuffer[t],this._lifetimeBuffer[e]=this._lifetimeBuffer[t],this._sizeBuffer[e]=this._sizeBuffer[t],this._rotationBuffer[e]=this._rotationBuffer[t],this._seedBuffer[e]=this._seedBuffer[t]),this.activeCount--,this._dirty=!0}isDead(){return!this.spawning&&0===this.activeCount}dispose(){this.mesh.visible=!1,this.geometry.instanceCount=0,this.geometry.dispose(),this.mesh.material.dispose(),this.activeCount=0,this.spawning=!1}}class _d{constructor(e,t){this.scene=e,this.camera=t,this._elapsedTime=0,this._activeEmitters=new Map,this._filteredPositions=new Float32Array(192)}startGesture(e,t){if(!t||!Array.isArray(t)||0===t.length)return;this._activeEmitters.has(e)||this._activeEmitters.set(e,[]);const n=this._activeEmitters.get(e);for(const e of t){const t=xd(e),a=new Md(t);this.scene.add(a.mesh),n.push(a)}}stopGesture(e){const t=this._activeEmitters.get(e);if(t)for(const e of t)e.spawning=!1}forceStopGesture(e){const t=this._activeEmitters.get(e);if(t){for(const e of t)this.scene.remove(e.mesh),e.dispose();this._activeEmitters.delete(e)}}syncSources(e,t,n){const a=this._activeEmitters.get(e);if(a)for(const i of a){const{targetModels:a}=i.config;let r=0;for(const[,i]of t)if(i.type===e){if(r>=64)break;a&&!a.includes(i.modelName)||(Sd.copy(i.position),n&&n.localToWorld(Sd),this._filteredPositions[3*r]=Sd.x,this._filteredPositions[3*r+1]=Sd.y,this._filteredPositions[3*r+2]=Sd.z,r++)}if(i.setSourcePositions(this._filteredPositions,r),i.config.gravity&&n){const{uniforms:e}=i.mesh.material;e.uGravityCenter&&(Sd.set(0,0,0),n.localToWorld(Sd),e.uGravityCenter.value.copy(Sd))}}}setGestureProgress(e,t){const n=this._activeEmitters.get(e);if(n&&null!==t)for(const e of n)e.config.burstCount>0&&0===e._progress&&t>0&&(e.burstSpawn(e.config.burstCount,this._elapsedTime),e.spawning=!1),e._progress=t}setEnergy(e,t){const n=this._activeEmitters.get(e);if(n)for(const e of n)e._energy=t}update(e){const t=Math.min(e,.1);this._elapsedTime+=t;for(const[e,n]of this._activeEmitters){for(let e=n.length-1;e>=0;e--){const a=n[e];a.update(t,this._elapsedTime),a.isDead()&&(this.scene.remove(a.mesh),a.dispose(),n.splice(e,1))}0===n.length&&this._activeEmitters.delete(e)}}hasActiveSources(){for(const[,e]of this._activeEmitters)for(const t of e)if(t.activeCount>0||t.spawning&&t.sourceCount>0)return!0;return!1}dispose(){for(const[,e]of this._activeEmitters)for(const t of e)this.scene.remove(t.mesh),t.dispose();this._activeEmitters.clear()}}const Ad={type:"change"},Cd={type:"start"},Td={type:"end"},Pd=new Nn,Dd=new Ar,Od=Math.cos(70*Nt.DEG2RAD),Ed=new Gt,Id=2*Math.PI,kd=-1,Rd=1e-6;class zd extends wl{constructor(e,a=null){super(e,a),this.state=kd,this.target=new Gt,this.cursor=new Gt,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.keyRotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:t.ROTATE,MIDDLE:t.DOLLY,RIGHT:t.PAN},this.touches={ONE:n.ROTATE,TWO:n.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new Gt,this._lastQuaternion=new Ut,this._lastTargetPosition=new Gt,this._quat=(new Ut).setFromUnitVectors(e.up,new Gt(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new bl,this._sphericalDelta=new bl,this._scale=1,this._panOffset=new Gt,this._rotateStart=new Vt,this._rotateEnd=new Vt,this._rotateDelta=new Vt,this._panStart=new Vt,this._panEnd=new Vt,this._panDelta=new Vt,this._dollyStart=new Vt,this._dollyEnd=new Vt,this._dollyDelta=new Vt,this._dollyDirection=new Gt,this._mouse=new Vt,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=Bd.bind(this),this._onPointerDown=Fd.bind(this),this._onPointerUp=Ld.bind(this),this._onContextMenu=Hd.bind(this),this._onMouseWheel=Ud.bind(this),this._onKeyDown=Gd.bind(this),this._onTouchStart=Wd.bind(this),this._onTouchMove=qd.bind(this),this._onMouseDown=Nd.bind(this),this._onMouseMove=Vd.bind(this),this._interceptControlDown=jd.bind(this),this._interceptControlUp=Xd.bind(this),null!==this.domElement&&this.connect(this.domElement),this.update()}connect(e){super.connect(e),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(e){e.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=e}stopListenToKeyEvents(){null!==this._domElementKeyEvents&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(Ad),this.update(),this.state=kd}update(e=null){const t=this.object.position;Ed.copy(t).sub(this.target),Ed.applyQuaternion(this._quat),this._spherical.setFromVector3(Ed),this.autoRotate&&this.state===kd&&this._rotateLeft(this._getAutoRotationAngle(e)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let n=this.minAzimuthAngle,a=this.maxAzimuthAngle;isFinite(n)&&isFinite(a)&&(n<-Math.PI?n+=Id:n>Math.PI&&(n-=Id),a<-Math.PI?a+=Id:a>Math.PI&&(a-=Id),this._spherical.theta=n<=a?Math.max(n,Math.min(a,this._spherical.theta)):this._spherical.theta>(n+a)/2?Math.max(n,this._spherical.theta):Math.min(a,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),!0===this.enableDamping?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let i=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const e=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),i=e!=this._spherical.radius}if(Ed.setFromSpherical(this._spherical),Ed.applyQuaternion(this._quatInverse),t.copy(this.target).add(Ed),this.object.lookAt(this.target),!0===this.enableDamping?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let e=null;if(this.object.isPerspectiveCamera){const t=Ed.length();e=this._clampDistance(t*this._scale);const n=t-e;this.object.position.addScaledVector(this._dollyDirection,n),this.object.updateMatrixWorld(),i=!!n}else if(this.object.isOrthographicCamera){const t=new Gt(this._mouse.x,this._mouse.y,0);t.unproject(this.object);const n=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),i=n!==this.object.zoom;const a=new Gt(this._mouse.x,this._mouse.y,0);a.unproject(this.object),this.object.position.sub(a).add(t),this.object.updateMatrixWorld(),e=Ed.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;null!==e&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(e).add(this.object.position):(Pd.origin.copy(this.object.position),Pd.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(Pd.direction))<Od?this.object.lookAt(this.target):(Dd.setFromNormalAndCoplanarPoint(this.object.up,this.target),Pd.intersectPlane(Dd,this.target))))}else if(this.object.isOrthographicCamera){const e=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),e!==this.object.zoom&&(this.object.updateProjectionMatrix(),i=!0)}return this._scale=1,this._performCursorZoom=!1,!!(i||this._lastPosition.distanceToSquared(this.object.position)>Rd||8*(1-this._lastQuaternion.dot(this.object.quaternion))>Rd||this._lastTargetPosition.distanceToSquared(this.target)>Rd)&&(this.dispatchEvent(Ad),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0)}_getAutoRotationAngle(e){return null!==e?Id/60*this.autoRotateSpeed*e:Id/60/60*this.autoRotateSpeed}_getZoomScale(e){const t=Math.abs(.01*e);return Math.pow(.95,this.zoomSpeed*t)}_rotateLeft(e){this._sphericalDelta.theta-=e}_rotateUp(e){this._sphericalDelta.phi-=e}_panLeft(e,t){Ed.setFromMatrixColumn(t,0),Ed.multiplyScalar(-e),this._panOffset.add(Ed)}_panUp(e,t){!0===this.screenSpacePanning?Ed.setFromMatrixColumn(t,1):(Ed.setFromMatrixColumn(t,0),Ed.crossVectors(this.object.up,Ed)),Ed.multiplyScalar(e),this._panOffset.add(Ed)}_pan(e,t){const n=this.domElement;if(this.object.isPerspectiveCamera){const a=this.object.position;Ed.copy(a).sub(this.target);let i=Ed.length();i*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*e*i/n.clientHeight,this.object.matrix),this._panUp(2*t*i/n.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(e*(this.object.right-this.object.left)/this.object.zoom/n.clientWidth,this.object.matrix),this._panUp(t*(this.object.top-this.object.bottom)/this.object.zoom/n.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(e,t){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const n=this.domElement.getBoundingClientRect(),a=e-n.left,i=t-n.top,r=n.width,s=n.height;this._mouse.x=a/r*2-1,this._mouse.y=-i/s*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(e){return Math.max(this.minDistance,Math.min(this.maxDistance,e))}_handleMouseDownRotate(e){this._rotateStart.set(e.clientX,e.clientY)}_handleMouseDownDolly(e){this._updateZoomParameters(e.clientX,e.clientX),this._dollyStart.set(e.clientX,e.clientY)}_handleMouseDownPan(e){this._panStart.set(e.clientX,e.clientY)}_handleMouseMoveRotate(e){this._rotateEnd.set(e.clientX,e.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(Id*this._rotateDelta.x/t.clientHeight),this._rotateUp(Id*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(e){this._dollyEnd.set(e.clientX,e.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(e){this._panEnd.set(e.clientX,e.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(e){this._updateZoomParameters(e.clientX,e.clientY),e.deltaY<0?this._dollyIn(this._getZoomScale(e.deltaY)):e.deltaY>0&&this._dollyOut(this._getZoomScale(e.deltaY)),this.update()}_handleKeyDown(e){let t=!1;switch(e.code){case this.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(Id*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,this.keyPanSpeed),t=!0;break;case this.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(-Id*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,-this.keyPanSpeed),t=!0;break;case this.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(Id*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(this.keyPanSpeed,0),t=!0;break;case this.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(-Id*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(-this.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),this.update())}_handleTouchStartRotate(e){if(1===this._pointers.length)this._rotateStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),n=.5*(e.pageX+t.x),a=.5*(e.pageY+t.y);this._rotateStart.set(n,a)}}_handleTouchStartPan(e){if(1===this._pointers.length)this._panStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),n=.5*(e.pageX+t.x),a=.5*(e.pageY+t.y);this._panStart.set(n,a)}}_handleTouchStartDolly(e){const t=this._getSecondPointerPosition(e),n=e.pageX-t.x,a=e.pageY-t.y,i=Math.sqrt(n*n+a*a);this._dollyStart.set(0,i)}_handleTouchStartDollyPan(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enablePan&&this._handleTouchStartPan(e)}_handleTouchStartDollyRotate(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enableRotate&&this._handleTouchStartRotate(e)}_handleTouchMoveRotate(e){if(1==this._pointers.length)this._rotateEnd.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),n=.5*(e.pageX+t.x),a=.5*(e.pageY+t.y);this._rotateEnd.set(n,a)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(Id*this._rotateDelta.x/t.clientHeight),this._rotateUp(Id*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(e){if(1===this._pointers.length)this._panEnd.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),n=.5*(e.pageX+t.x),a=.5*(e.pageY+t.y);this._panEnd.set(n,a)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(e){const t=this._getSecondPointerPosition(e),n=e.pageX-t.x,a=e.pageY-t.y,i=Math.sqrt(n*n+a*a);this._dollyEnd.set(0,i),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const r=.5*(e.pageX+t.x),s=.5*(e.pageY+t.y);this._updateZoomParameters(r,s)}_handleTouchMoveDollyPan(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enablePan&&this._handleTouchMovePan(e)}_handleTouchMoveDollyRotate(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enableRotate&&this._handleTouchMoveRotate(e)}_addPointer(e){this._pointers.push(e.pointerId)}_removePointer(e){delete this._pointerPositions[e.pointerId];for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId)return void this._pointers.splice(t,1)}_isTrackingPointer(e){for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId)return!0;return!1}_trackPointer(e){let t=this._pointerPositions[e.pointerId];void 0===t&&(t=new Vt,this._pointerPositions[e.pointerId]=t),t.set(e.pageX,e.pageY)}_getSecondPointerPosition(e){const t=e.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[t]}_customWheelEvent(e){const t=e.deltaMode,n={clientX:e.clientX,clientY:e.clientY,deltaY:e.deltaY};switch(t){case 1:n.deltaY*=16;break;case 2:n.deltaY*=100}return e.ctrlKey&&!this._controlActive&&(n.deltaY*=10),n}}function Fd(e){!1!==this.enabled&&(0===this._pointers.length&&(this.domElement.setPointerCapture(e.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._isTrackingPointer(e)||(this._addPointer(e),"touch"===e.pointerType?this._onTouchStart(e):this._onMouseDown(e)))}function Bd(e){!1!==this.enabled&&("touch"===e.pointerType?this._onTouchMove(e):this._onMouseMove(e))}function Ld(e){switch(this._removePointer(e),this._pointers.length){case 0:this.domElement.releasePointerCapture(e.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(Td),this.state=kd;break;case 1:const t=this._pointers[0],n=this._pointerPositions[t];this._onTouchStart({pointerId:t,pageX:n.x,pageY:n.y})}}function Nd(e){let n;switch(e.button){case 0:n=this.mouseButtons.LEFT;break;case 1:n=this.mouseButtons.MIDDLE;break;case 2:n=this.mouseButtons.RIGHT;break;default:n=-1}switch(n){case t.DOLLY:if(!1===this.enableZoom)return;this._handleMouseDownDolly(e),this.state=1;break;case t.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===this.enablePan)return;this._handleMouseDownPan(e),this.state=2}else{if(!1===this.enableRotate)return;this._handleMouseDownRotate(e),this.state=0}break;case t.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===this.enableRotate)return;this._handleMouseDownRotate(e),this.state=0}else{if(!1===this.enablePan)return;this._handleMouseDownPan(e),this.state=2}break;default:this.state=kd}this.state!==kd&&this.dispatchEvent(Cd)}function Vd(e){switch(this.state){case 0:if(!1===this.enableRotate)return;this._handleMouseMoveRotate(e);break;case 1:if(!1===this.enableZoom)return;this._handleMouseMoveDolly(e);break;case 2:if(!1===this.enablePan)return;this._handleMouseMovePan(e)}}function Ud(e){!1!==this.enabled&&!1!==this.enableZoom&&this.state===kd&&(e.preventDefault(),this.dispatchEvent(Cd),this._handleMouseWheel(this._customWheelEvent(e)),this.dispatchEvent(Td))}function Gd(e){!1!==this.enabled&&this._handleKeyDown(e)}function Wd(e){switch(this._trackPointer(e),this._pointers.length){case 1:switch(this.touches.ONE){case n.ROTATE:if(!1===this.enableRotate)return;this._handleTouchStartRotate(e),this.state=3;break;case n.PAN:if(!1===this.enablePan)return;this._handleTouchStartPan(e),this.state=4;break;default:this.state=kd}break;case 2:switch(this.touches.TWO){case n.DOLLY_PAN:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchStartDollyPan(e),this.state=5;break;case n.DOLLY_ROTATE:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchStartDollyRotate(e),this.state=6;break;default:this.state=kd}break;default:this.state=kd}this.state!==kd&&this.dispatchEvent(Cd)}function qd(e){switch(this._trackPointer(e),this.state){case 3:if(!1===this.enableRotate)return;this._handleTouchMoveRotate(e),this.update();break;case 4:if(!1===this.enablePan)return;this._handleTouchMovePan(e),this.update();break;case 5:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchMoveDollyPan(e),this.update();break;case 6:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchMoveDollyRotate(e),this.update();break;default:this.state=kd}}function Hd(e){!1!==this.enabled&&e.preventDefault()}function jd(e){"Control"===e.key&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function Xd(e){"Control"===e.key&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}class Yd{constructor(e){this.renderer=e,this.glowAmount=0,this.targetGlowAmount=0,this.glowColor=new Ia(1,1,1),this.targetGlowColor=new Ia(1,1,1),this.worldPosition=new Gt(0,0,0),this.time=0,this.ringPhase=0,this.scene=new Ii,this.camera=new nl(-1,1,1,-1,.1,10),this.camera.position.z=1,this.createGlowMesh(),this._tempVector=new Gt,this._tempColor=new Ia}createGlowMesh(){const e=new ao(2,2),t=new bi({uniforms:{glowAmount:{value:0},glowColor:{value:new Ia(1,1,1)},centerUV:{value:new Vt(.5,.5)},time:{value:0},ringPhase:{value:0},aspectRatio:{value:1}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);\n                }\n            ",fragmentShader:"\n                uniform float glowAmount;\n                uniform vec3 glowColor;\n                uniform vec2 centerUV;\n                uniform float time;\n                uniform float ringPhase;\n                uniform float aspectRatio;\n\n                varying vec2 vUv;\n\n                void main() {\n                    // Aspect-correct UV coordinates - apply aspect to Y instead\n                    // This prevents horizontal clipping on wide screens\n                    vec2 centeredUV = vUv - centerUV;\n                    // Don't multiply by aspect - let glow be circular in screen space\n\n                    float dist = length(centeredUV);\n\n                    // Ring parameters that evolve with ringPhase\n                    // MUCH LARGER radii to prevent clipping - glow can extend to screen edges\n                    // At ringPhase=0: tight ring close to center\n                    // At ringPhase=1: expanded ring that can fill most of screen\n                    float innerRadius = mix(0.02, 0.08, ringPhase);\n                    float outerRadius = mix(0.15, 1.2, ringPhase);  // Can extend beyond screen!\n                    float peakRadius = mix(0.06, 0.25, ringPhase);\n\n                    // Create soft ring falloff\n                    // Inner falloff: 0 at center, 1 at peak\n                    float innerFalloff = smoothstep(innerRadius * 0.3, peakRadius, dist);\n\n                    // Outer falloff: 1 at peak, 0 at outer edge (very gradual fade)\n                    float outerFalloff = 1.0 - smoothstep(peakRadius, outerRadius, dist);\n\n                    // Combine for ring shape\n                    float ringIntensity = innerFalloff * outerFalloff;\n\n                    // Add subtle shimmer/undulation\n                    float shimmer = 0.9 + 0.1 * sin(time * 3.0 + dist * 20.0);\n\n                    // Final intensity with glow amount control\n                    float intensity = ringIntensity * glowAmount * shimmer;\n\n                    // Soft glow color with intensity\n                    // Use HDR values (>1.0) for bloom pickup\n                    vec3 color = glowColor * intensity * 2.0;\n\n                    // Alpha for blending - GlowLayer needs true alpha transparency\n                    // for its overlay effect (unlike water which uses opaque additive)\n                    float alpha = intensity * 0.6;\n\n                    gl_FragColor = vec4(color, alpha);\n                }\n            ",transparent:!0,blending:2,depthTest:!1,depthWrite:!1});this.glowMesh=new ui(e,t),this.scene.add(this.glowMesh)}setGlow(e,t,n){this.targetGlowAmount=Math.max(0,e),t&&(Array.isArray(t)?this.targetGlowColor.setRGB(t[0],t[1],t[2]):this.targetGlowColor.copy(t)),n&&this.worldPosition.copy(n)}update(e,t){const n=e/1e3;this.time+=n,this.glowAmount+=(this.targetGlowAmount-this.glowAmount)*Math.min(1,8*n),this.glowColor.lerp(this.targetGlowColor,Math.min(1,8*n));const a=Math.min(1,this.glowAmount);if(this.ringPhase+=(a-this.ringPhase)*Math.min(1,4*n),t){this._tempVector.copy(this.worldPosition),this._tempVector.project(t);const e=(this._tempVector.x+1)/2,n=(this._tempVector.y+1)/2;this.glowMesh.material.uniforms.centerUV.value.set(e,n)}this.glowMesh.material.uniforms.glowAmount.value=this.glowAmount,this.glowMesh.material.uniforms.glowColor.value.copy(this.glowColor),this.glowMesh.material.uniforms.time.value=this.time,this.glowMesh.material.uniforms.ringPhase.value=this.ringPhase;const i=this.renderer.domElement;this.glowMesh.material.uniforms.aspectRatio.value=i.width/i.height}render(e){if(this.glowAmount<.001)return;const{autoClear:t}=e;e.autoClear=!1,e.render(this.scene,this.camera),e.autoClear=t}isActive(){return this.glowAmount>.001||this.targetGlowAmount>0}dispose(){this.glowMesh&&(this.glowMesh.geometry.dispose(),this.glowMesh.material.dispose(),this.scene.remove(this.glowMesh),this.glowMesh=null),this.scene=null,this.camera=null,this._tempVector=null,this._tempColor=null}}class $d{constructor(e){this.renderer=e,this.impacts=[],this.crackColor=new Ia(.15,.08,.05),this.crackGlowColor=new Ia(1,.6,.2),this.glowStrength=.5,this.isHealing=!1,this.healProgress=0,this.time=0,this.depthTexture=null,this.scene=new Ii,this.camera=new nl(-1,1,1,-1,.1,10),this.camera.position.z=1,this.createCrackMesh(),this._tempVector=new Gt}createCrackMesh(){const e=new ao(2,2),t=new bi({uniforms:{impactData0:{value:new ln(0,0,0,0)},impactData1:{value:new ln(0,0,0,0)},impactData2:{value:new ln(0,0,0,0)},impactParams0:{value:new Vt(0,0)},impactParams1:{value:new Vt(0,0)},impactParams2:{value:new Vt(0,0)},impactSeeds:{value:new Gt(0,0,0)},numImpacts:{value:0},crackColor:{value:new Ia(.05,.03,.02)},crackGlowColor:{value:new Ia(1,.8,.4)},glowStrength:{value:.3},time:{value:0},aspectRatio:{value:1},depthTexture:{value:null},cameraNear:{value:.1},cameraFar:{value:100},hasDepth:{value:0}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);\n                }\n            ",fragmentShader:"\n                // Impact data\n                uniform vec4 impactData0;  // xy=center, zw=direction\n                uniform vec4 impactData1;\n                uniform vec4 impactData2;\n                uniform vec2 impactParams0; // x=propagation, y=amount\n                uniform vec2 impactParams1;\n                uniform vec2 impactParams2;\n                uniform vec3 impactSeeds;\n                uniform int numImpacts;\n\n                // Visual params\n                uniform vec3 crackColor;\n                uniform vec3 crackGlowColor;\n                uniform float glowStrength;\n                uniform float time;\n                uniform float aspectRatio;\n\n                // Depth masking\n                uniform sampler2D depthTexture;\n                uniform float cameraNear;\n                uniform float cameraFar;\n                uniform float hasDepth;\n\n                varying vec2 vUv;\n\n                // Hash functions\n                float hash(vec2 p) {\n                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n                }\n\n                vec2 hash2(vec2 p) {\n                    return vec2(\n                        fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453),\n                        fract(sin(dot(p, vec2(269.5, 183.3))) * 43758.5453)\n                    );\n                }\n\n                float noise(vec2 p) {\n                    vec2 i = floor(p);\n                    vec2 f = fract(p);\n                    f = f * f * (3.0 - 2.0 * f);\n                    float a = hash(i);\n                    float b = hash(i + vec2(1.0, 0.0));\n                    float c = hash(i + vec2(0.0, 1.0));\n                    float d = hash(i + vec2(1.0, 1.0));\n                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n                }\n\n                float voronoiEdge(vec2 p) {\n                    vec2 i = floor(p);\n                    vec2 f = fract(p);\n                    float minDist = 1.0;\n                    float secondDist = 1.0;\n                    for (int y = -1; y <= 1; y++) {\n                        for (int x = -1; x <= 1; x++) {\n                            vec2 neighbor = vec2(float(x), float(y));\n                            vec2 cellPoint = neighbor + hash2(i + neighbor) * 0.8;\n                            float dist = length(f - cellPoint);\n                            if (dist < minDist) {\n                                secondDist = minDist;\n                                minDist = dist;\n                            } else if (dist < secondDist) {\n                                secondDist = dist;\n                            }\n                        }\n                    }\n                    return secondDist - minDist;\n                }\n\n                // Crack line with wobble\n                float crackLine(vec2 uv, vec2 origin, vec2 dir, float seed) {\n                    vec2 toPoint = uv - origin;\n                    float along = dot(toPoint, dir);\n                    float perp = abs(dot(toPoint, vec2(-dir.y, dir.x)));\n                    if (along < 0.0) return 1.0;\n                    float wobble = noise(vec2(along * 8.0 + seed, seed)) * 0.03;\n                    perp += wobble * along;\n                    float width = 0.015 * (1.0 - along * 0.5);\n                    width = max(width, 0.003);\n                    return perp / width;\n                }\n\n                // Generate crack pattern for a single impact\n                float singleImpactCrack(vec2 uv, vec2 center, vec2 direction, float propagation, float seed) {\n                    vec2 toPixel = uv - center;\n                    float distFromCenter = length(toPixel);\n\n                    float meshRadius = 0.4;\n                    float maxRadius = propagation * meshRadius;\n\n                    // Outside propagation radius = no crack\n                    if (distFromCenter > maxRadius && propagation < 0.99) {\n                        return 1.0;\n                    }\n\n                    float crack = 1.0;\n                    bool isRadial = length(direction) < 0.1;\n\n                    if (isRadial) {\n                        // Radial cracks from center\n                        vec2 crackUV = (uv - center) * 15.0 + seed * 10.0;\n                        crackUV += vec2(noise(uv * 10.0 + seed), noise(uv * 10.0 + 100.0 + seed)) * 0.3;\n                        float edge = voronoiEdge(crackUV);\n\n                        float angle = atan(toPixel.y, toPixel.x);\n                        float radialLines = abs(sin(angle * 8.0 + seed * 3.14159 + noise(vec2(distFromCenter * 5.0 + seed)) * 2.0));\n                        radialLines = smoothstep(0.0, 0.15, radialLines);\n\n                        crack = min(edge * 2.0, radialLines + 0.3);\n                    } else {\n                        // Directional cracks\n                        vec2 dir = normalize(direction);\n                        vec2 perp = vec2(-dir.y, dir.x);\n\n                        for (float i = -2.0; i <= 2.0; i += 1.0) {\n                            vec2 offset = perp * i * 0.06;\n                            vec2 crackOrigin = center + offset;\n\n                            float angleVar = noise(vec2(i * 10.0 + seed, seed)) * 0.3 - 0.15;\n                            vec2 crackDir = vec2(\n                                dir.x * cos(angleVar) - dir.y * sin(angleVar),\n                                dir.x * sin(angleVar) + dir.y * cos(angleVar)\n                            );\n\n                            float line = crackLine(uv, crackOrigin, crackDir, i * 17.3 + seed * 100.0);\n                            crack = min(crack, line);\n\n                            // Branch\n                            float branchPoint = 0.1 + hash(vec2(i + seed, seed)) * 0.15;\n                            vec2 branchOrigin = crackOrigin + crackDir * branchPoint;\n                            vec2 branchDir = normalize(crackDir + perp * (hash(vec2(i + seed, 1.0 + seed)) - 0.5) * 0.8);\n                            float branch = crackLine(uv, branchOrigin, branchDir, i * 23.7 + seed * 50.0);\n                            crack = min(crack, branch * 1.2);\n                        }\n\n                        // Web cracks\n                        vec2 webUV = uv * 20.0 + seed * 5.0;\n                        float web = voronoiEdge(webUV) * 3.0;\n                        float crackReach = dot(toPixel, dir);\n                        if (crackReach > 0.0 && crackReach < maxRadius) {\n                            crack = min(crack, web + 0.5);\n                        }\n                    }\n\n                    // Fade at propagation edge\n                    float edgeFade = 1.0 - smoothstep(maxRadius * 0.5, maxRadius, distFromCenter);\n\n                    return crack / max(edgeFade, 0.3);\n                }\n\n                void main() {\n                    if (numImpacts == 0) discard;\n\n                    // Work in centered UV space\n                    vec2 uv = vUv - 0.5;\n                    uv.x *= aspectRatio;\n\n                    // Elliptical mesh bounds check - crystal is taller than wide\n                    // Use ellipse: (x/a)^2 + (y/b)^2 <= 1\n                    // a = horizontal radius (narrower), b = vertical radius (taller)\n                    float meshRadiusX = 0.18;  // Narrow horizontal\n                    float meshRadiusY = 0.38;  // Tall vertical\n                    float ellipseDist = (uv.x * uv.x) / (meshRadiusX * meshRadiusX) +\n                                        (uv.y * uv.y) / (meshRadiusY * meshRadiusY);\n\n                    // Soft edge fade instead of hard cutoff\n                    float meshMask = 1.0 - smoothstep(0.7, 1.0, ellipseDist);\n                    if (meshMask < 0.01) {\n                        discard;\n                    }\n\n                    // Depth check (if depth texture available)\n                    if (hasDepth > 0.5) {\n                        float depth = texture2D(depthTexture, vUv).r;\n                        if (depth >= 0.9999) {\n                            discard;\n                        }\n                    }\n\n                    float distFromMeshCenter = length(uv);\n\n                    // Combine all impacts\n                    float combinedCrack = 1.0;\n                    float maxAmount = 0.0;\n\n                    // Impact 0\n                    if (numImpacts >= 1 && impactParams0.y > 0.01) {\n                        vec2 center0 = (impactData0.xy - 0.5);\n                        center0.x *= aspectRatio;\n                        float crack0 = singleImpactCrack(uv, center0, impactData0.zw, impactParams0.x, impactSeeds.x);\n                        combinedCrack = min(combinedCrack, crack0);\n                        maxAmount = max(maxAmount, impactParams0.y);\n                    }\n\n                    // Impact 1\n                    if (numImpacts >= 2 && impactParams1.y > 0.01) {\n                        vec2 center1 = (impactData1.xy - 0.5);\n                        center1.x *= aspectRatio;\n                        float crack1 = singleImpactCrack(uv, center1, impactData1.zw, impactParams1.x, impactSeeds.y);\n                        combinedCrack = min(combinedCrack, crack1);\n                        maxAmount = max(maxAmount, impactParams1.y);\n                    }\n\n                    // Impact 2\n                    if (numImpacts >= 3 && impactParams2.y > 0.01) {\n                        vec2 center2 = (impactData2.xy - 0.5);\n                        center2.x *= aspectRatio;\n                        float crack2 = singleImpactCrack(uv, center2, impactData2.zw, impactParams2.x, impactSeeds.z);\n                        combinedCrack = min(combinedCrack, crack2);\n                        maxAmount = max(maxAmount, impactParams2.y);\n                    }\n\n                    // Convert to line visibility - INCREASED WIDTH for visibility\n                    float crackWidth = 0.12;  // Wider cracks (was 0.08)\n                    float crackLine = 1.0 - smoothstep(0.0, crackWidth, combinedCrack);\n\n                    // Edge glow - wider and brighter\n                    float glowWidth = crackWidth * 4.0;  // Wider glow (was 3.0)\n                    float edgeGlow = 1.0 - smoothstep(crackWidth * 0.3, glowWidth, combinedCrack);\n                    edgeGlow = max(0.0, edgeGlow - crackLine * 0.3);\n\n                    // Apply amount - this is the FADE control\n                    crackLine *= maxAmount;\n                    edgeGlow *= maxAmount * glowStrength;\n\n                    // Shimmer on glow\n                    float shimmer = 0.85 + 0.15 * sin(time * 3.0 + distFromMeshCenter * 20.0);\n                    edgeGlow *= shimmer;\n\n                    // Final output - INCREASED ALPHA for visibility\n                    vec3 color = crackColor * crackLine * 1.5 + crackGlowColor * edgeGlow * 3.0;\n                    float alpha = crackLine * 1.0 + edgeGlow * 0.8;  // Full opacity on crack lines\n\n                    if (alpha < 0.001) discard;\n\n                    gl_FragColor = vec4(color, alpha);\n                }\n            ",transparent:!0,blending:1,depthTest:!1,depthWrite:!1});this.crackMesh=new ui(e,t),this.scene.add(this.crackMesh)}addImpact(e){const t=100*Math.random(),n={centerUV:e.centerUV?e.centerUV.clone():new Vt(.5,.5),direction:e.direction?e.direction.clone():new Vt(0,0),propagation:e.propagation??.8,amount:e.amount??1,seed:t};this.impacts.length>=3&&this.impacts.shift(),this.impacts.push(n),this._updateUniforms()}startHealing(e=1500){this.isHealing=!0,this.healDuration=e,this.healStartTime=performance.now()}clearAll(){this.impacts=[],this.isHealing=!1,this.healProgress=0,this._updateUniforms()}hasCracks(){return this.impacts.length>0}_updateUniforms(){const{uniforms:e}=this.crackMesh.material;e.numImpacts.value=this.impacts.length;for(let t=0;t<3;t++){const n=this.impacts[t],a=e[`impactData${t}`],i=e[`impactParams${t}`];n?(a.value.set(n.centerUV.x,n.centerUV.y,n.direction.x,n.direction.y),i.value.set(n.propagation,n.amount)):(a.value.set(0,0,0,0),i.value.set(0,0))}e.impactSeeds.value.set(this.impacts[0]?.seed??0,this.impacts[1]?.seed??0,this.impacts[2]?.seed??0)}setDepthTexture(e){this.depthTexture=e,this.crackMesh&&(this.crackMesh.material.uniforms.depthTexture.value=e,this.crackMesh.material.uniforms.hasDepth.value=e?1:0)}setCameraParams(e,t){this.crackMesh&&(this.crackMesh.material.uniforms.cameraNear.value=e,this.crackMesh.material.uniforms.cameraFar.value=t)}setGlowColor(e){Array.isArray(e)?this.crackGlowColor.setRGB(e[0],e[1],e[2]):e&&this.crackGlowColor.copy(e),this.crackMesh.material.uniforms.crackGlowColor.value.copy(this.crackGlowColor)}update(e,t){const n=e/1e3;if(this.time+=n,this.isHealing&&this.impacts.length>0){const e=performance.now()-this.healStartTime;this.healProgress=Math.min(e/this.healDuration,1);const t=this.healProgress,n=1-t*t*(3-2*t);for(const e of this.impacts)void 0===e.originalAmount&&(e.originalAmount=e.amount,e.originalPropagation=e.propagation),e.amount=e.originalAmount*n,e.propagation=e.originalPropagation*(.3+.7*n);this.healProgress>=1?this.clearAll():this._updateUniforms()}const{uniforms:a}=this.crackMesh.material;a.time.value=this.time,a.glowStrength.value=this.glowStrength;const i=this.renderer.domElement;a.aspectRatio.value=i.width/i.height,t&&(a.cameraNear.value=t.near,a.cameraFar.value=t.far)}render(e){if(0===this.impacts.length)return;const{autoClear:t}=e;e.autoClear=!1,e.render(this.scene,this.camera),e.autoClear=t}isActive(){return this.impacts.length>0}reset(){this.clearAll()}dispose(){this.crackMesh&&(this.crackMesh.geometry.dispose(),this.crackMesh.material.dispose(),this.scene.remove(this.crackMesh),this.crackMesh=null),this.scene=null,this.camera=null,this.depthTexture=null,this._tempVector=null,this.impacts=[]}}const Qd=e=>({front:{x:0,y:0,z:e},side:{x:e,y:0,z:0},top:{x:0,y:e,z:0},angle:{x:.67*e,y:.5*e,z:.67*e},back:{x:0,y:0,z:-e},bottom:{x:0,y:-e,z:0}});class Kd{constructor(e,t,n=3){this.camera=e,this.controls=t,this.cameraDistance=n,this.animationId=null}getAvailablePresets(){return Object.keys(Qd(this.cameraDistance))}setPreset(e,t=1e3,n=!1){if(!this.controls)return;const a=Qd(this.cameraDistance)[e];if(!a)return void console.warn(`Unknown camera preset: ${e}`);this.cancelAnimation();const i=n?this.controls.target.clone():null;0!==t?this._animateTo(a,t,i,n):this._setInstant(a,i)}_setInstant(e,t){this.controls.reset(),this.camera.position.set(e.x,e.y,e.z),t?(this.controls.target.copy(t),this.camera.lookAt(t)):(this.controls.target.set(0,0,0),this.camera.lookAt(0,0,0)),this.controls.update()}_animateTo(e,t,n,a){a||this.controls.target.set(0,0,0);const i=this.camera.position.clone(),r=new Gt(e.x,e.y,e.z),s=performance.now(),o=e=>{const n=e-s,a=Math.min(n/t,1),l=1-Math.pow(1-a,3);this.camera.position.lerpVectors(i,r,l),this.camera.lookAt(0,0,0),this.controls.update(),this.animationId=a<1?requestAnimationFrame(o):null};this.animationId=requestAnimationFrame(o)}isAnimating(){return null!==this.animationId}cancelAnimation(){null!==this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null)}reset(e=1e3){this.setPreset("front",e)}setCameraDistance(e){this.cameraDistance=e}dispose(){this.cancelAnimation(),this.camera=null,this.controls=null}}class Zd{constructor(e,t={}){this.canvas=e,this.options=t,this._destroyed=!1,this.assetBasePath=t.assetBasePath||"",this.scene=new Ii,this.scene.background=null,this.renderer=new ed({canvas:e,alpha:!0,premultipliedAlpha:!0,antialias:!1,powerPreference:"high-performance",preserveDrawingBuffer:!1,precision:"highp",logarithmicDepthBuffer:!1,stencil:!1}),this.renderer.outputColorSpace=nt,this.renderer.toneMapping=4,this.renderer.toneMappingExposure=1,this.renderer.setClearColor(0,0),this.renderer.clear(),this.renderer.autoClear=!1,this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),this.renderer.setSize(e.width,e.height,!1),t.enableShadows&&(this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=2),this._contextLost=!1,this._boundHandleContextLost=this.handleContextLost.bind(this),this._boundHandleContextRestored=this.handleContextRestored.bind(this),this.renderer.domElement.addEventListener("webglcontextlost",this._boundHandleContextLost,!1),this.renderer.domElement.addEventListener("webglcontextrestored",this._boundHandleContextRestored,!1),this._wasHidden=!1,this._warmupFramesRemaining=0,this._boundHandleVisibilityChange=this._handleVisibilityChange.bind(this),document.addEventListener("visibilitychange",this._boundHandleVisibilityChange),this._boundHandleFocusRecovery=this._handleFocusRecovery.bind(this),window.addEventListener("focus",this._boundHandleFocusRecovery);const n=void 0!==t.fov?t.fov:45;this.camera=new _i(n,e.width/e.height,.1,100),this.cameraDistance=void 0!==t.cameraDistance?t.cameraDistance:3,this.camera.position.set(0,0,this.cameraDistance),this.camera.lookAt(0,0,0),!1!==t.enableControls&&this.setupCameraControls(),this.setupLights(),!1!==t.enablePostProcessing&&this.setupPostProcessing(),this.coreMesh=null,this.materialMode="glow",this.glowMaterial=null,this.glassMaterial=null,this.mixer=null,this.clock=new dl,this._tempColor=new Ia,this._tempColor2=new Ia,this._white=new Ia(1,1,1),this._tempQuat=new Ut,this._tempEuler=new Qn,this._quatX=new Ut,this._quatY=new Ut,this._quatZ=new Ut,this._rollQuat=new Ut,this._meshQuat=new Ut,this._xAxis=new Gt(1,0,0),this._yAxis=new Gt(0,1,0),this._zAxis=new Gt(0,0,1),this._cameraToMesh=new Gt,this._cameraDir=new Gt,this._soulPosTemp=new Gt,this._cachedSoulMesh=null,this._drawingBufferSize=new Vt}invalidateSoulCache(){this._cachedSoulMesh=null}setupCameraControls(){this.controls=new zd(this.camera,this.renderer.domElement),this.controls.enableDamping=!0,this.controls.dampingFactor=.1;const e=void 0!==this.options.minZoom?this.options.minZoom:.5*this.cameraDistance,t=void 0!==this.options.maxZoom?this.options.maxZoom:2*this.cameraDistance;this.controls.minDistance=e,this.controls.maxDistance=t,this.controls.enablePan=!1,this.controls.autoRotate=!0===this.options.autoRotate,this.controls.autoRotateSpeed=void 0!==this.options.autoRotateSpeed?this.options.autoRotateSpeed:.5,this.controls.minPolarAngle=.2*Math.PI,this.controls.maxPolarAngle=.8*Math.PI,this.controls.rotateSpeed=.8,this.controls.zoomSpeed=1.5,("ontouchstart"in window||navigator.maxTouchPoints>0)&&(this.controls.rotateSpeed=1,this.controls.zoomSpeed=1.2),this.renderer.domElement.style.touchAction="none";const n=()=>{this.controls&&this.controls.update()};this.renderer.domElement.addEventListener("pointermove",n,{passive:!0}),this.renderer.domElement.addEventListener("pointerdown",n,{passive:!0}),this.cameraPresetManager=new Kd(this.camera,this.controls,this.cameraDistance)}setupLights(){this.ambientLight=new rl(16777215,.3),this.ambientLight.name="ambientLight",this.scene.add(this.ambientLight),this.keyLight=new il(16777215,.8),this.keyLight.position.set(2,2,2),this.keyLight.name="keyLight",this.options.enableShadows&&(this.keyLight.castShadow=!0,this.keyLight.shadow.mapSize.width=1024,this.keyLight.shadow.mapSize.height=1024,this.keyLight.shadow.camera.near=.5,this.keyLight.shadow.camera.far=10),this.scene.add(this.keyLight),this.fillLight=new il(16777215,.5),this.fillLight.position.set(-2,1,1),this.fillLight.name="fillLight",this.scene.add(this.fillLight),this.rimLight=new il(16777215,.7),this.rimLight.position.set(0,1,-2),this.rimLight.name="rimLight",this.scene.add(this.rimLight),this.accentLight1=new tl(54527,.3,10),this.accentLight1.position.set(-3,0,1),this.accentLight1.name="accentLight1",this.scene.add(this.accentLight1),this.accentLight2=new tl(16716947,.2,10),this.accentLight2.position.set(3,0,1),this.accentLight2.name="accentLight2",this.scene.add(this.accentLight2),this.accentLight3=new tl(16739125,.2,10),this.accentLight3.position.set(0,3,-1),this.accentLight3.name="accentLight3",this.scene.add(this.accentLight3),this.createEnvironmentMap()}async createEnvironmentMap(){if(this._destroyed)return;this._envMapLoading=!0;try{const{HDRLoader:e}=await Promise.resolve().then(function(){return sC});if(this._destroyed)return;const t=new ql(this.renderer);t.compileEquirectangularShader();try{const n=new e,a="studio_1k.hdr";let i;if(this.assetBasePath){let e=this.assetBasePath.replace(/\/$/,"");e.endsWith("/assets")&&(e=e.slice(0,-7)),i=e?`${e}/hdri/${a}`:`/hdri/${a}`}else{const e=window.location.pathname.split("/");let t="";e.length>2&&e[1]&&(t=`/${e[1]}`),i=t?`${t}/hdri/${a}`:`/hdri/${a}`}let r=null;try{r=await n.loadAsync(i)}catch{}if(!r||!r.image)throw new Error(`HDR texture not found at ${i}`);return this._destroyed?(r.dispose(),void t.dispose()):(r.mapping=F,this.envMap=t.fromEquirectangular(r).texture,r.dispose(),t.dispose(),void(this._envMapLoading=!1))}catch{t.dispose()}}catch{}if(this._destroyed)return;const e=new Pi(512),t=new Ii,n=new Ia(5609983),a=new Ia(16739229),i=new Ia(1710638),r=new qo(n,i,1.5);t.add(r);const s=new tl(54527,2,20);s.position.set(-5,2,-5),t.add(s);const o=new tl(16716947,2,20);o.position.set(5,2,-5),t.add(o);const l=new tl(16755200,1.5,20);l.position.set(0,5,0),t.add(l),t.background=a;const c=new Ci(.1,100,e);c.update(this.renderer,t),this.envMap=e.texture,this._envCubeRenderTarget=e,this._envScene=t,this._envCubeCamera=c,this._envMapLoading=!1}setupPostProcessing(){const e=new Vt;this.renderer.getDrawingBufferSize(e);const t=new Zr(e.x,e.y);t.format=de,t.type=ie;const n=new hn(e.x,e.y,{format:ce,type:te,minFilter:G,magFilter:G,stencilBuffer:!1,depthBuffer:!0,depthTexture:t});this.composer=new hd(this.renderer,n),this.renderer.setRenderTarget(n),this.renderer.clear(),this.renderer.setRenderTarget(this.composer.readBuffer),this.renderer.clear(),this.renderer.setRenderTarget(this.composer.writeBuffer),this.renderer.clear(),this.renderer.setRenderTarget(null);const a=new dd(this.scene,this.camera);a.clearColor=new Ia(0,0,0),a.clearAlpha=0,this.composer.addPass(a),this.aoPass=new fd(this.camera,e.x,e.y),this.aoPass.enabled=!1,this.composer.addPass(this.aoPass),this.motionBlurPass=new gd(this.camera),this.motionBlurPass.enabled=!1,this.composer.addPass(this.motionBlurPass),this._distortionPassIndex=this.composer.passes.length;const i=new Vt(Math.floor(.5*e.x),Math.floor(.5*e.y));this.bloomPass=new ud(i,1.5,.4,.9),this.bloomPass.name="bloomPass",this.bloomPass.enabled=!0,this.composer.addPass(this.bloomPass),this.bloomPass.clearBloomBuffers(this.renderer),this.particleRenderTarget=new hn(e.x,e.y,{format:ce,type:te,minFilter:H,magFilter:H,stencilBuffer:!1,depthBuffer:!0}),this.renderer.setRenderTarget(this.particleRenderTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this.particleBloomPass=new ud(i,.5,.4,.3),this.particleBloomPass.name="particleBloomPass",this.particleBloomPass.enabled=!0,this.particleBloomPass.clearColor=new Ia(1,1,1),this.particleBloomPass.skipBaseCopy=!0,this.particleBloomPass.clearBloomBuffers(this.renderer),this.soulRenderTarget=new hn(e.x,e.y,{format:ce,type:te,minFilter:H,magFilter:H,stencilBuffer:!1,depthBuffer:!0}),this.renderer.setRenderTarget(this.soulRenderTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this.iceRefractionTarget=new hn(e.x,e.y,{format:ce,type:te,minFilter:H,magFilter:H,stencilBuffer:!1,depthBuffer:!0}),this.renderer.setRenderTarget(this.iceRefractionTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this._refractionMeshes=new Set;const r=Math.floor(.5*e.x),s=Math.floor(.5*e.y);this.distortionTarget=new hn(r,s,{format:ce,type:te,minFilter:H,magFilter:H,depthBuffer:!1}),this.renderer.setRenderTarget(this.distortionTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this.distortionPass=new od(pd),this.distortionPass.enabled=!1,this.composer.passes.splice(this._distortionPassIndex,0,this.distortionPass),this.distortionManager=new yd(this.renderer,this.camera),this.particleAtmospherics=new _d(this.scene,this.camera),this.particleCompositeShader={uniforms:{tDiffuse:{value:null},tParticles:{value:null}},vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            ",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                uniform sampler2D tParticles;\n                varying vec2 vUv;\n\n                void main() {\n                    vec4 base = texture2D(tDiffuse, vUv);\n                    vec4 particles = texture2D(tParticles, vUv);\n\n                    // Alpha-preserving composite: particles over base\n                    // Use particle alpha to blend\n                    vec3 blended = mix(base.rgb, particles.rgb, particles.a);\n                    float alpha = base.a + particles.a * (1.0 - base.a);\n\n                    gl_FragColor = vec4(blended, alpha);\n                }\n            "},this.glowLayer=new Yd(this.renderer),this.crackLayer=new $d(this.renderer)}handleContextLost(e){e.preventDefault(),this._contextLost=!0,console.warn(" WebGL context lost - rendering paused"),this.cameraAnimationId&&(cancelAnimationFrame(this.cameraAnimationId),this.cameraAnimationId=null)}handleContextRestored(){this._contextLost=!1,this.recreateResources(),this.onContextRestored&&this.onContextRestored()}recreateResources(){this.createEnvironmentMap(),"glow"===this.materialMode?(this.glowMaterial=this.createGlowMaterial(),this.coreMesh&&(this.coreMesh.material=this.glowMaterial)):"glass"===this.materialMode&&(this.glassMaterial=this.createGlassMaterial(),this.coreMesh&&(this.coreMesh.material=this.glassMaterial),this.coreMesh&&this.createInnerCore())}_recreateDistortionTarget(){if(!this.distortionTarget)return;this.distortionTarget.dispose();const e=this.renderer.getDrawingBufferSize(new Vt);this.distortionTarget=new hn(Math.floor(.5*e.x),Math.floor(.5*e.y),{format:ce,type:te,minFilter:H,magFilter:H,depthBuffer:!1}),this.renderer.setRenderTarget(this.distortionTarget),this.renderer.clear(),this.renderer.setRenderTarget(null)}_handleFocusRecovery(){this._destroyed||this._wasHidden&&(this._wasHidden=!1,this._recreateDistortionTarget())}_handleVisibilityChange(){if(!this._destroyed)if(document.hidden)this._wasHidden=!0;else if(this._wasHidden=!1,!document.hidden){this.renderer?.state?.reset();const e=this.renderer?.getContext();if(e&&e.isContextLost())console.warn(" WebGL context lost detected on visibility change"),this._contextLost=!0;else if(this._recreateDistortionTarget(),this.coreMesh?.material){const{material:e}=this.coreMesh;e.map&&!e.map.image&&(console.warn(" Texture invalidated on visibility change - triggering reload"),this.onContextRestored&&this.onContextRestored())}}}createCoreMesh(e,t=null){if(this.coreMesh&&(this.scene.remove(this.coreMesh),this.coreMesh.isGroup?this.coreMesh.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&this.disposeMaterial(e.material)}):(this.coreMesh.geometry&&this.coreMesh.geometry.dispose(),this.coreMesh.material&&this.disposeMaterial(this.coreMesh.material)),this.coreMesh=null),e.isGroup)return this.coreMesh=e,this.coreMesh.name="coreMascot",this.options.enableShadows&&this.coreMesh.traverse(e=>{e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0)}),this.scene.add(this.coreMesh),this.coreMesh;let n;return t?n=t:(this.glowMaterial||(this.glowMaterial=this.createGlowMaterial()),n="glass"===this.materialMode?this.glassMaterial||this.createGlassMaterial():this.glowMaterial),this.coreMesh=new ui(e,n),this.coreMesh.name="coreMascot",n.transparent&&(this.coreMesh.renderOrder=-1),this.options.enableShadows&&(this.coreMesh.castShadow=!0,this.coreMesh.receiveShadow=!0),this.scene.add(this.coreMesh),"glass"===this.materialMode&&this.createInnerCore(),this.coreMesh}swapGeometry(e,t=null){if(!this.coreMesh)return;this.bloomPass&&this.bloomPass.clearBloomBuffers(this.renderer),this.particleBloomPass&&this.particleBloomPass.clearBloomBuffers(this.renderer);const n=this.coreMesh.geometry;if(n&&n.dispose(),this.coreMesh.geometry=e,t){if(this.coreMesh.material&&this.coreMesh.material!==this.glowMaterial&&this.coreMesh.material!==this.glassMaterial&&this.disposeMaterial(this.coreMesh.material),this.coreMesh.material=t,t.uniforms?.resolution){const e=this.renderer.getDrawingBufferSize(new Vt);t.uniforms.resolution.value.set(e.x,e.y)}}else{const e="glass"===this.materialMode?this.glassMaterial||this.createGlassMaterial():this.glowMaterial;this.coreMesh.material!==e&&(this.coreMesh.material&&this.coreMesh.material!==this.glowMaterial&&this.coreMesh.material!==this.glassMaterial&&this.disposeMaterial(this.coreMesh.material),this.coreMesh.material=e)}"glass"!==this.materialMode||t||this.createInnerCore()}createGlowMaterial(){return new bi({uniforms:{glowColor:{value:new Ia(1,1,1)},glowIntensity:{value:1},coreColor:{value:new Ia(1,1,1)},fresnelPower:{value:3},uOpacity:{value:1}},vertexShader:"\n                varying vec3 vNormal;\n                varying vec3 vViewPosition;\n\n                void main() {\n                    // Transform normal to view space\n                    vNormal = normalize(normalMatrix * normal);\n\n                    // Calculate view space position\n                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                    vViewPosition = -mvPosition.xyz;\n\n                    // Output clip space position\n                    gl_Position = projectionMatrix * mvPosition;\n                }\n            ",fragmentShader:"\n                uniform vec3 glowColor;\n                uniform vec3 coreColor;\n                uniform float glowIntensity;\n                uniform float fresnelPower;\n                uniform float uOpacity;\n\n                varying vec3 vNormal;\n                varying vec3 vViewPosition;\n\n                void main() {\n                    // Discard fully transparent pixels\n                    if (uOpacity < 0.01) discard;\n\n                    // Fresnel effect: edges glow more than center\n                    vec3 viewDir = normalize(vViewPosition);\n                    float fresnel = pow(1.0 - abs(dot(vNormal, viewDir)), fresnelPower);\n\n                    // Combine white core with colored glow\n                    // Both core and glow respect glowIntensity for proper on/off toggle\n                    vec3 finalColor = (coreColor * glowIntensity) + (glowColor * glowIntensity * fresnel);\n\n                    gl_FragColor = vec4(finalColor, uOpacity);\n                }\n            ",transparent:!0,side:0})}createGlassMaterial(){this.glassEmissiveMultiplier=.6;const e=new co({transmission:1,thickness:2.7,roughness:.37,metalness:0,ior:1.5,reflectivity:.5,envMapIntensity:1.2,side:2,transparent:!0,opacity:1,color:16777215,emissive:16777215,emissiveIntensity:.6,clearcoat:.8,clearcoatRoughness:.05,iridescence:.4,iridescenceIOR:1.3,iridescenceThicknessRange:[100,400]});return this.envMap&&(e.envMap=this.envMap),e}createInnerCore(){if(this.innerCore&&(this.coreMesh&&this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null),!this.coreMesh||!this.coreMesh.geometry)return;const e=this.coreMesh.geometry;let t;if("TorusGeometry"===e.type||void 0!==e.parameters?.tube){const n=e.parameters,a=n.radius||1,i=.25*(n.tube||.4),r=n.radialSegments||16,s=n.tubularSegments||100;t=new oo(a,i,r,s)}else if("SphereGeometry"===e.type){const n=.2*(e.parameters.radius||1);t=new so(n,32,32)}else if("BoxGeometry"===e.type){const n=e.parameters,a=.2*(n.width||1),i=.2*(n.height||1),r=.2*(n.depth||1);t=new mi(a,i,r)}else if("IcosahedronGeometry"===e.type||"OctahedronGeometry"===e.type){const n=e.parameters,a=.2*(n.radius||1),i=n.detail||2;t="IcosahedronGeometry"===e.type?new to(a,i):new no(a,i)}else t=new to(.2,2);const n=e.userData?.geometryType,a="IcosahedronGeometry"===e.type||"OctahedronGeometry"===e.type||"crystal"===n||"diamond"===n,i=new lo({emissive:16777215,emissiveIntensity:a?3.5:2,color:16777215,transparent:!1,opacity:1});this.innerCoreMaterial=i,this.innerCore=new ui(t,i),this.innerCore.name="innerCore",this.coreMesh.add(this.innerCore)}setMaterialMode(e){if(!this.coreMesh)return console.warn("Cannot set material mode: core mesh not created yet"),void(this.materialMode=e);if(e===this.materialMode)return;this.materialMode=e,"glass"!==e||this.glassMaterial?"glow"!==e||this.glowMaterial||(this.glowMaterial=this.createGlowMaterial()):this.glassMaterial=this.createGlassMaterial();const t="glass"===e?this.glassMaterial:this.glowMaterial;this.coreMesh.material=t,"glass"===e?this.createInnerCore():this.innerCore&&(this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null)}updateGlassProperties(e){this.glassMaterial&&(void 0!==e.transmission&&(this.glassMaterial.transmission=e.transmission,this.glassMaterial.needsUpdate=!0),void 0!==e.thickness&&(this.glassMaterial.thickness=e.thickness,this.glassMaterial.needsUpdate=!0),void 0!==e.roughness&&(this.glassMaterial.roughness=e.roughness,this.glassMaterial.needsUpdate=!0),void 0!==e.emissiveMultiplier&&(this.glassEmissiveMultiplier=e.emissiveMultiplier))}updateLighting(e,t,n=.15){if(!t||!t.visual)return;const a=t.visual.glowColor||"#FFFFFF";this._tempColor.set(a);const i=t.visual.glowIntensity||1;if(this.keyLight&&(this.keyLight.color.lerp(this._tempColor,n),this.keyLight.intensity+=(.8*i-this.keyLight.intensity)*n),this.fillLight&&(this._tempColor2.copy(this._tempColor).lerp(this._white,.7),this.fillLight.color.lerp(this._tempColor2,.5*n),this.fillLight.intensity+=(.3*i-this.fillLight.intensity)*n),this.ambientLight){const e=.4*i;this.ambientLight.intensity+=(e-this.ambientLight.intensity)*n}}normalizeIntensity(e){return.8+Math.log(e+1)/Math.log(11)*.4}calculateColorLuminance(e,t,n){const a=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4);return.2126*a(e)+.7152*a(t)+.0722*a(n)}updateBloom(e,t=.1,n=null){if(this.bloomPass){const a=this.normalizeIntensity(e);let i,r,s;"sun"===n?(r=1.5,s=.4,i=.3):"crystal"===n||"rough"===n||"heart"===n?(r=1.5,s=.5,i=.65):"glass"===this.materialMode?(r=.3,s=.2,i=.85):(r=1+.8*a,s=.4,i=.85),this.bloomPass.strength+=(r-this.bloomPass.strength)*t,this.bloomPass.threshold+=(i-this.bloomPass.threshold)*t,this.bloomPass.radius=s}}setCameraPreset(e,t=1e3,n=!1){if(!this.controls)return;const a=this.cameraDistance,i={front:{x:0,y:0,z:a},side:{x:a,y:0,z:0},top:{x:0,y:a,z:0},angle:{x:.67*a,y:.5*a,z:.67*a},back:{x:0,y:0,z:-a},bottom:{x:0,y:-a,z:0}}[e];if(!i)return void console.warn(`Unknown camera preset: ${e}`);const r=n?this.controls.target.clone():null;if(0===t)return this.controls.reset(),this.camera.position.set(i.x,i.y,i.z),r?(this.controls.target.copy(r),this.camera.lookAt(r)):(this.controls.target.set(0,0,0),this.camera.lookAt(0,0,0)),void this.controls.update();n||this.controls.target.set(0,0,0);const s=this.camera.position.clone(),o=new Gt(i.x,i.y,i.z),l=performance.now(),c=e=>{const n=e-l,a=Math.min(n/t,1),i=1-Math.pow(1-a,3);this.camera.position.lerpVectors(s,o,i),this.camera.lookAt(0,0,0),this.controls.update(),this.cameraAnimationId=a<1?requestAnimationFrame(c):null};this.cameraAnimationId=requestAnimationFrame(c)}resetCamera(){this.setCameraPreset("front",1e3)}toggleAutoRotate(e){this.controls&&(this.controls.autoRotate=void 0!==e?e:!this.controls.autoRotate)}isAutoRotateEnabled(){return!!this.controls&&this.controls.autoRotate}render(e={}){if(this._destroyed)return;if(this._contextLost)return;if(!this.scene||!this.camera||!this.renderer)return;if(!this.coreMesh)return;if(this._envMapLoading)return;if(!this._firstFrameRendered)return this._firstFrameRendered=!0,this.renderer.setRenderTarget(null),this.renderer.setClearColor(0,0),void this.renderer.clear();const{position:t=[0,0,0],rotation:n=[0,0,0],scale:a=1,nonUniformScale:i=null,glowColor:r=[1,1,1],glowIntensity:s=1,hasActiveGesture:o=!1,calibrationRotation:l=[0,0,0],cameraRoll:c=0,solarEclipse:h=null,deltaTime:d=0,morphProgress:u=null,hasSoul:p=!1,hasParticles:m=!0}=e;if(this.controls&&this.controls.update(),this.coreMesh){if(this.coreMesh.position.set(...t),this._tempEuler.set(n[0],n[1],n[2],"XYZ"),this._tempQuat.setFromEuler(this._tempEuler),this._quatX.setFromAxisAngle(this._xAxis,l[0]),this._quatY.setFromAxisAngle(this._yAxis,l[1]),this._cameraToMesh.subVectors(this.coreMesh.position,this.camera.position).normalize(),this._quatZ.setFromAxisAngle(this._cameraToMesh,l[2]),this._tempQuat.multiply(this._quatX),this._tempQuat.multiply(this._quatY),this._tempQuat.multiply(this._quatZ),this.coreMesh.rotation.setFromQuaternion(this._tempQuat),0!==c&&(this._cameraDir.subVectors(this.coreMesh.position,this.camera.position).normalize(),this._rollQuat.setFromAxisAngle(this._cameraDir,c),this._meshQuat.setFromEuler(this.coreMesh.rotation),this._meshQuat.premultiply(this._rollQuat),this.coreMesh.rotation.setFromQuaternion(this._meshQuat)),i?this.coreMesh.scale.set(i[0],i[1],i[2]):this.coreMesh.scale.setScalar(a),h&&h.update(this.camera,this.coreMesh,d,u),this.coreMesh.material&&this.coreMesh.material.uniforms){if(this.coreMesh.material.uniforms.glowColor){this._tempColor.setRGB(...r);const e=this.coreMesh.material.uniforms.glowColor.value;Math.abs(this._tempColor.r-e.r)+Math.abs(this._tempColor.g-e.g)+Math.abs(this._tempColor.b-e.b)>.001&&e.lerp(this._tempColor,.15)}if(this.coreMesh.material.uniforms.glowIntensity){let e;e=0===s?0:o?s:this.normalizeIntensity(s);const t=this.coreMesh.material.uniforms.glowIntensity.value;if(Math.abs(e-t)>.001){const n=o?.5:.15;this.coreMesh.material.uniforms.glowIntensity.value+=(e-t)*n}}if(void 0!==this.coreMesh.material.uniforms.deformationStrength){const t=e.deformation;t&&t.enabled&&t.strength>.001?(this.coreMesh.material.uniforms.deformationStrength.value=t.strength,t.impactPoint&&this.coreMesh.material.uniforms.impactPoint&&this.coreMesh.material.uniforms.impactPoint.value.set(t.impactPoint[0],t.impactPoint[1],t.impactPoint[2]),void 0!==t.falloffRadius&&this.coreMesh.material.uniforms.deformationFalloff&&(this.coreMesh.material.uniforms.deformationFalloff.value=t.falloffRadius)):this.coreMesh.material.uniforms.deformationStrength.value=0}}else if(this.coreMesh.material&&this.coreMesh.material.emissive){this._tempColor.setRGB(...r),this.coreMesh.material.emissive.lerp(this._tempColor,.15);const e=.15*s,t=this.coreMesh.material.emissiveIntensity,n=o?.5:.15;this.coreMesh.material.emissiveIntensity+=(e-t)*n,this.coreMesh.material.color.lerp(this._white,.15)}this.innerCore&&(this.innerCore.visible=s>0,this.innerCoreMaterial&&(this._tempColor.setRGB(...r),this.innerCoreMaterial.emissive.lerp(this._tempColor,.15)))}if(this.mixer){const e=this.clock.getDelta();this.mixer.update(e)}if(this.renderer.clear(),this.composer){if(this.soulRenderTarget&&p){this._cachedSoulMesh||this.scene.traverse(e=>{"crystalSoul"===e.name&&(this._cachedSoulMesh=e)});const e=this._cachedSoulMesh;if(this.renderer.setRenderTarget(this.soulRenderTarget),this.renderer.clear(),this.camera.layers.set(2),this.renderer.render(this.scene,this.camera),this.coreMesh?.material?.uniforms?.soulTexture&&(this.coreMesh.material.uniforms.soulTexture.value=this.soulRenderTarget.texture,this.coreMesh.material.uniforms.soulTextureSize&&this.coreMesh.material.uniforms.soulTextureSize.value.set(this.soulRenderTarget.width,this.soulRenderTarget.height),this.coreMesh.material.uniforms.soulScreenCenter&&e)){this._soulPosTemp.copy(e.position),this._soulPosTemp.project(this.camera);const t=.5*(this._soulPosTemp.x+1),n=.5*(this._soulPosTemp.y+1);this.coreMesh.material.uniforms.soulScreenCenter.value.set(t,n)}this.renderer.setRenderTarget(null)}if(this.iceRefractionTarget&&this._refractionMeshes&&this._refractionMeshes.size>0){for(const e of this._refractionMeshes)e.visible=!1;const e=this.scene.background;this._refractionBackground&&(this.scene.background=this._refractionBackground),this.renderer.setRenderTarget(this.iceRefractionTarget),this.renderer.setClearColor(0,0),this.renderer.clear(),this.camera.layers.set(0),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null),this.scene.background=e;for(const e of this._refractionMeshes)e.visible=!0,e.material?.uniforms?.uBackgroundTexture&&(e.material.uniforms.uBackgroundTexture.value=this.iceRefractionTarget.texture,e.material.uniforms.uResolution.value.set(this.iceRefractionTarget.width,this.iceRefractionTarget.height),e.material.uniforms.uHasBackground.value=1)}if(this.distortionManager){this.distortionManager.update(d/1e3);const e=this.distortionManager.hasActiveSources();this.distortionPass.enabled=e,this.distortionPass.uniforms.tDistortion.value=this.distortionTarget.texture,e&&(this.camera.layers.set(0),this.distortionManager.render(this.distortionTarget))}if(this.particleAtmospherics&&this.particleAtmospherics.update(d/1e3),this.camera.layers.set(0),this.composer.render(),m&&this.particleRenderTarget&&this.particleBloomPass){this.renderer.state.reset(),this.renderer.setRenderTarget(this.particleRenderTarget),this.renderer.setClearColor(16777215,0),this.renderer.clear(),this.camera.layers.set(0);const e=this._depthOnlyMaterial||(this._depthOnlyMaterial=new Fa({colorWrite:!1,depthWrite:!0}));this.scene.overrideMaterial=e,this.renderer.render(this.scene,this.camera),this.scene.overrideMaterial=null,this.camera.layers.set(1),this.renderer.render(this.scene,this.camera);const t=this.particleRenderTarget;this.particleBloomPass.renderToScreen=!0,this.particleBloomPass.render(this.renderer,null,t,0,!1),this.renderer.setClearColor(0,0),this.renderer.setRenderTarget(null)}else m&&(this.camera.layers.set(1),this.renderer.render(this.scene,this.camera));this.camera.layers.enableAll(),this.glowLayer&&this.glowLayer.isActive()&&this.glowLayer.render(this.renderer),this.crackLayer&&this.crackLayer.isActive()&&this.crackLayer.render(this.renderer)}else this.renderer.render(this.scene,this.camera),this.glowLayer&&this.glowLayer.isActive()&&this.glowLayer.render(this.renderer),this.crackLayer&&this.crackLayer.isActive()&&this.crackLayer.render(this.renderer)}addRefractionMesh(e){e&&this._refractionMeshes&&this._refractionMeshes.add(e)}removeRefractionMesh(e){this._refractionMeshes&&this._refractionMeshes.delete(e)}setRefractionBackground(e){e?"string"==typeof e?(new Go).load(e,e=>{e.colorSpace=nt,this._refractionBackground=e}):this._refractionBackground=e:this._refractionBackground=null}updateGlowLayer(e,t,n,a){this.glowLayer&&(this.glowLayer.setGlow(e,t,n),this.glowLayer.update(a,this.camera))}updateCrackLayer(e,t){if(this.crackLayer){if(e&&e.triggers&&e.triggers.length>0){for(const t of e.triggers)this.crackLayer.addImpact({centerUV:t.centerUV,direction:t.direction,propagation:t.propagation,amount:t.amount});void 0!==e.glowStrength&&(this.crackLayer.glowStrength=e.glowStrength)}e.healTrigger&&this.crackLayer.startHealing(e.healDuration||1500),this.crackLayer.update(t,this.camera)}}setAmbientOcclusion(e,t={}){this.aoPass&&(this.aoPass.enabled=e,void 0!==t.intensity&&(this.aoPass.intensity=t.intensity),void 0!==t.fineRadius&&(this.aoPass.fineRadius=t.fineRadius),void 0!==t.coarseRadius&&(this.aoPass.coarseRadius=t.coarseRadius))}resize(e,t){if(this.camera.aspect=e/t,this.camera.updateProjectionMatrix(),this.renderer.setSize(e,t,!1),this.composer){const n=new Vt;this.renderer.getDrawingBufferSize(n),this.composer.setSize(e,t);const a=Math.floor(.5*n.x),i=Math.floor(.5*n.y);this.bloomPass&&this.bloomPass.setSize(a,i),this.motionBlurPass&&this.motionBlurPass.setSize(n.x,n.y),this.particleRenderTarget&&this.particleRenderTarget.setSize(n.x,n.y),this.particleBloomPass&&this.particleBloomPass.setSize(a,i),this.soulRenderTarget&&this.soulRenderTarget.setSize(n.x,n.y),this.iceRefractionTarget&&this.iceRefractionTarget.setSize(n.x,n.y),this.distortionTarget&&this.distortionTarget.setSize(a,i),this.aoPass&&this.aoPass.setSize(n.x,n.y),this.coreMesh?.material?.uniforms?.resolution&&this.coreMesh.material.uniforms.resolution.value.set(n.x,n.y)}}disposeMaterial(e){e&&(["map","lightMap","bumpMap","normalMap","specularMap","envMap","alphaMap","aoMap","displacementMap","emissiveMap","gradientMap","metalnessMap","roughnessMap"].forEach(t=>{e[t]&&e[t].dispose()}),e.uniforms&&Object.values(e.uniforms).forEach(e=>{e.value&&(e.value.isTexture?(e.value.dispose(),e.value=null):(e.value.isColor||e.value.isVector2||e.value.isVector3||e.value.isVector4)&&(e.value=null))}),e.dispose())}destroy(){this._destroyed=!0,this.renderer?.domElement&&(this.renderer.domElement.removeEventListener("webglcontextlost",this._boundHandleContextLost,!1),this.renderer.domElement.removeEventListener("webglcontextrestored",this._boundHandleContextRestored,!1)),document.removeEventListener("visibilitychange",this._boundHandleVisibilityChange),window.removeEventListener("focus",this._boundHandleFocusRecovery),this.cameraAnimationId&&(cancelAnimationFrame(this.cameraAnimationId),this.cameraAnimationId=null),this.innerCore&&(this.coreMesh&&this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null),this.coreMesh&&(this.scene.remove(this.coreMesh),this.coreMesh.geometry.dispose(),this.disposeMaterial(this.coreMesh.material),this.coreMesh=null),this.glowMaterial&&(this.disposeMaterial(this.glowMaterial),this.glowMaterial=null),this.glassMaterial&&(this.disposeMaterial(this.glassMaterial),this.glassMaterial=null),this.aoPass&&(this.aoPass.dispose(),this.aoPass=null),this.motionBlurPass&&(this.motionBlurPass.dispose(),this.motionBlurPass=null),this.composer&&(this.composer.dispose(),this.composer=null),this.particleRenderTarget&&(this.particleRenderTarget.dispose(),this.particleRenderTarget=null),this.particleBloomPass&&(this.particleBloomPass.dispose(),this.particleBloomPass=null),this.soulRenderTarget&&(this.soulRenderTarget.dispose(),this.soulRenderTarget=null),this.iceRefractionTarget&&(this.iceRefractionTarget.dispose(),this.iceRefractionTarget=null),this._refractionMeshes&&(this._refractionMeshes.clear(),this._refractionMeshes=null),this.distortionTarget&&(this.distortionTarget.dispose(),this.distortionTarget=null),this.distortionPass&&(this.distortionPass.dispose(),this.distortionPass=null),this.distortionManager&&(this.distortionManager.dispose(),this.distortionManager=null),this.particleAtmospherics&&(this.particleAtmospherics.dispose(),this.particleAtmospherics=null),this.glowLayer&&(this.glowLayer.dispose(),this.glowLayer=null),this.crackLayer&&(this.crackLayer.dispose(),this.crackLayer=null),this.cameraPresetManager&&(this.cameraPresetManager.dispose(),this.cameraPresetManager=null),this.controls&&(this.controls.dispose(),this.controls=null),this.keyLight?.shadow?.map&&this.keyLight.shadow.map.dispose(),this.fillLight?.shadow?.map&&this.fillLight.shadow.map.dispose(),this.rimLight?.shadow?.map&&this.rimLight.shadow.map.dispose(),this.keyLight=null,this.fillLight=null,this.rimLight=null,this.ambientLight=null,this.accentLight1=null,this.accentLight2=null,this.accentLight3=null,this.envMap&&(this.envMap.dispose(),this.envMap=null),this._envCubeRenderTarget&&(this._envCubeRenderTarget.dispose(),this._envCubeRenderTarget=null),this._envScene&&(this._envScene.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&this.disposeMaterial(e.material)}),this._envScene.clear(),this._envScene=null),this._envCubeCamera&&(this._envCubeCamera=null),this.renderer&&(this.renderer.dispose(),this.renderer=null),this.scene.clear(),this.mixer&&(this.mixer.stopAllAction(),this.mixer=null),this.clock=null,this.camera=null,this._tempColor=null,this._tempColor2=null,this._white=null,this._tempQuat=null,this._tempEuler=null,this._quatX=null,this._quatY=null,this._quatZ=null,this._rollQuat=null,this._meshQuat=null,this._xAxis=null,this._yAxis=null,this._zAxis=null,this._cameraToMesh=null,this._cameraDir=null}}const Jd=/^[og]\s*(.+)?/,eu=/^mtllib /,tu=/^usemtl /,nu=/^usemap /,au=/\s+/,iu=new Gt,ru=new Gt,su=new Gt,ou=new Gt,lu=new Gt,cu=new Ia;function hu(){const e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);const n=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){const n=this._finalize(!1);n&&(n.inherited||n.groupCount<=0)&&this.materials.splice(n.index,1);const a={index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==n?n.smooth:this.smooth,groupStart:void 0!==n?n.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){const t={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(let e=this.materials.length-1;e>=0;e--)this.materials[e].groupCount<=0&&this.materials.splice(e,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},n&&n.name&&"function"==typeof n.clone){const e=n.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const n=parseInt(e,10);return 3*(n>=0?n-1:n+t/3)},parseNormalIndex:function(e,t){const n=parseInt(e,10);return 3*(n>=0?n-1:n+t/3)},parseUVIndex:function(e,t){const n=parseInt(e,10);return 2*(n>=0?n-1:n+t/2)},addVertex:function(e,t,n){const a=this.vertices,i=this.object.geometry.vertices;i.push(a[e+0],a[e+1],a[e+2]),i.push(a[t+0],a[t+1],a[t+2]),i.push(a[n+0],a[n+1],a[n+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,n){const a=this.normals,i=this.object.geometry.normals;i.push(a[e+0],a[e+1],a[e+2]),i.push(a[t+0],a[t+1],a[t+2]),i.push(a[n+0],a[n+1],a[n+2])},addFaceNormal:function(e,t,n){const a=this.vertices,i=this.object.geometry.normals;iu.fromArray(a,e),ru.fromArray(a,t),su.fromArray(a,n),lu.subVectors(su,ru),ou.subVectors(iu,ru),lu.cross(ou),lu.normalize(),i.push(lu.x,lu.y,lu.z),i.push(lu.x,lu.y,lu.z),i.push(lu.x,lu.y,lu.z)},addColor:function(e,t,n){const a=this.colors,i=this.object.geometry.colors;void 0!==a[e]&&i.push(a[e+0],a[e+1],a[e+2]),void 0!==a[t]&&i.push(a[t+0],a[t+1],a[t+2]),void 0!==a[n]&&i.push(a[n+0],a[n+1],a[n+2])},addUV:function(e,t,n){const a=this.uvs,i=this.object.geometry.uvs;i.push(a[e+0],a[e+1]),i.push(a[t+0],a[t+1]),i.push(a[n+0],a[n+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,n,a,i,r,s,o,l){const c=this.vertices.length;let h=this.parseVertexIndex(e,c),d=this.parseVertexIndex(t,c),u=this.parseVertexIndex(n,c);if(this.addVertex(h,d,u),this.addColor(h,d,u),void 0!==s&&""!==s){const e=this.normals.length;h=this.parseNormalIndex(s,e),d=this.parseNormalIndex(o,e),u=this.parseNormalIndex(l,e),this.addNormal(h,d,u)}else this.addFaceNormal(h,d,u);if(void 0!==a&&""!==a){const e=this.uvs.length;h=this.parseUVIndex(a,e),d=this.parseUVIndex(i,e),u=this.parseUVIndex(r,e),this.addUV(h,d,u),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let n=0,a=e.length;n<a;n++){const a=this.parseVertexIndex(e[n],t);this.addVertexPoint(a),this.addColor(a)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const n=this.vertices.length,a=this.uvs.length;for(let t=0,a=e.length;t<a;t++)this.addVertexLine(this.parseVertexIndex(e[t],n));for(let e=0,n=t.length;e<n;e++)this.addUVLine(this.parseUVIndex(t[e],a))}};return e.startObject("",!1),e}class du extends zo{constructor(e){super(e),this.materials=null}load(e,t,n,a){const i=this,r=new Lo(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,function(n){try{t(i.parse(n))}catch(t){a?a(t):console.error(t),i.manager.itemError(e)}},n,a)}setMaterials(e){return this.materials=e,this}parse(e){const t=new hu;-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));const n=e.split("\n");let a=[];for(let e=0,i=n.length;e<i;e++){const i=n[e].trimStart();if(0===i.length)continue;const r=i.charAt(0);if("#"!==r)if("v"===r){const e=i.split(au);switch(e[0]){case"v":t.vertices.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),e.length>=7?(cu.setRGB(parseFloat(e[4]),parseFloat(e[5]),parseFloat(e[6]),nt),t.colors.push(cu.r,cu.g,cu.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"vt":t.uvs.push(parseFloat(e[1]),parseFloat(e[2]))}}else if("f"===r){const e=i.slice(1).trim().split(au),n=[];for(let t=0,a=e.length;t<a;t++){const a=e[t];if(a.length>0){const e=a.split("/");n.push(e)}}const a=n[0];for(let e=1,i=n.length-1;e<i;e++){const i=n[e],r=n[e+1];t.addFace(a[0],i[0],r[0],a[1],i[1],r[1],a[2],i[2],r[2])}}else if("l"===r){const e=i.substring(1).trim().split(" ");let n=[];const a=[];if(-1===i.indexOf("/"))n=e;else for(let t=0,i=e.length;t<i;t++){const i=e[t].split("/");""!==i[0]&&n.push(i[0]),""!==i[1]&&a.push(i[1])}t.addLineGeometry(n,a)}else if("p"===r){const e=i.slice(1).trim().split(" ");t.addPointGeometry(e)}else if(null!==(a=Jd.exec(i))){const e=(" "+a[0].slice(1).trim()).slice(1);t.startObject(e)}else if(tu.test(i))t.object.startMaterial(i.substring(7).trim(),t.materialLibraries);else if(eu.test(i))t.materialLibraries.push(i.substring(7).trim());else if(nu.test(i))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===r){if(a=i.split(" "),a.length>1){const e=a[1].trim().toLowerCase();t.object.smooth="0"!==e&&"off"!==e}else t.object.smooth=!0;const e=t.object.currentMaterial();e&&(e.smooth=t.object.smooth)}else{if("\0"===i)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+i+'"')}}t.finalize();const i=new Di;if(i.materialLibraries=[].concat(t.materialLibraries),!0==!(1===t.objects.length&&0===t.objects[0].geometry.vertices.length))for(let e=0,n=t.objects.length;e<n;e++){const n=t.objects[e],a=n.geometry,r=n.materials,s="Line"===a.type,o="Points"===a.type;let l=!1;if(0===a.vertices.length)continue;const c=new ei;c.setAttribute("position",new ja(a.vertices,3)),a.normals.length>0&&c.setAttribute("normal",new ja(a.normals,3)),a.colors.length>0&&(l=!0,c.setAttribute("color",new ja(a.colors,3))),!0===a.hasUVIndices&&c.setAttribute("uv",new ja(a.uvs,2));const h=[];for(let e=0,n=r.length;e<n;e++){const n=r[e],a=n.name+"_"+n.smooth+"_"+l;let i=t.materials[a];if(null!==this.materials)if(i=this.materials.create(n.name),!s||!i||i instanceof Or){if(o&&i&&!(i instanceof qr)){const e=new qr({size:10,sizeAttenuation:!1});za.prototype.copy.call(e,i),e.color.copy(i.color),e.map=i.map,i=e}}else{const e=new Or;za.prototype.copy.call(e,i),e.color.copy(i.color),i=e}void 0===i&&(i=s?new Or:o?new qr({size:1,sizeAttenuation:!1}):new ho,i.name=n.name,i.flatShading=!n.smooth,i.vertexColors=l,t.materials[a]=i),h.push(i)}let d;if(h.length>1){for(let e=0,t=r.length;e<t;e++){const t=r[e];c.addGroup(t.groupStart,t.groupCount,e)}d=s?new Gr(c,h):o?new $r(c,h):new ui(c,h)}else d=s?new Gr(c,h[0]):o?new $r(c,h[0]):new ui(c,h[0]);d.name=n.name,i.add(d)}else if(t.vertices.length>0){const e=new qr({size:1,sizeAttenuation:!1}),n=new ei;n.setAttribute("position",new ja(t.vertices,3)),t.colors.length>0&&void 0!==t.colors[0]&&(n.setAttribute("color",new ja(t.colors,3)),e.vertexColors=!0);const a=new $r(n,e);i.add(a)}return i}}function uu(e,t){if(0===t)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(2===t||1===t){let n=e.getIndex();if(null===n){const t=[],a=e.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<a.count;e++)t.push(e);e.setIndex(t),n=e.getIndex()}const a=n.count-2,i=[];if(2===t)for(let e=1;e<=a;e++)i.push(n.getX(0)),i.push(n.getX(e)),i.push(n.getX(e+1));else for(let e=0;e<a;e++)e%2==0?(i.push(n.getX(e)),i.push(n.getX(e+1)),i.push(n.getX(e+2))):(i.push(n.getX(e+2)),i.push(n.getX(e+1)),i.push(n.getX(e)));i.length/3!==a&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=e.clone();return r.setIndex(i),r.clearGroups(),r}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}const pu="\n/**\n * Apply a single blend mode to two colors\n * @param base - Base color (RGB, 0.0-1.0 range)\n * @param blend - Blend color (RGB, 0.0-1.0 range)\n * @param mode - Blend mode index (0-17)\n * @return Blended color (RGB, 0.0-1.0 range)\n *\n * Blend Mode Reference:\n *  0 = Multiply        (darkening)\n *  1 = Linear Burn     (darkening, linear)\n *  2 = Color Burn      (darkening, intense)\n *  3 = Color Dodge     (brightening, intense)\n *  4 = Screen          (brightening)\n *  5 = Overlay         (contrast, screen/multiply hybrid)\n *  6 = Add             (brightening, additive glow)\n *  7 = Soft Light      (contrast, gentle)\n *  8 = Hard Light      (contrast, strong)\n *  9 = Vivid Light     (contrast, saturation boost)\n * 10 = Linear Light    (contrast, linear)\n * 11 = Difference      (inversion)\n * 12 = Exclusion       (soft inversion)\n * 13 = Darken          (comparison, darker)\n * 14 = Lighten         (comparison, lighter)\n * 15 = Subtract        (darkening, deep shadows)\n * 16 = Divide          (brightening, ethereal glow)\n * 17 = Pin Light       (posterization)\n */\nvec3 applyBlendMode(vec3 base, vec3 blend, int mode) {\n    if (mode == 0) {\n        // MULTIPLY: base * blend\n        return base * blend;\n    } else if (mode == 1) {\n        // LINEAR BURN: base + blend - 1\n        return max(base + blend - vec3(1.0), vec3(0.0));\n    } else if (mode == 2) {\n        // COLOR BURN: (blend==0.0) ? 0.0 : max((1.0-((1.0-base)/blend)), 0.0)\n        return vec3(\n            blend.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.r) / blend.r), 0.0),\n            blend.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.g) / blend.g), 0.0),\n            blend.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.b) / blend.b), 0.0)\n        );\n    } else if (mode == 3) {\n        // COLOR DODGE: (blend==1.0) ? 1.0 : min(base/(1.0-blend), 1.0)\n        return vec3(\n            blend.r == 1.0 ? 1.0 : min(base.r / (1.0 - blend.r), 1.0),\n            blend.g == 1.0 ? 1.0 : min(base.g / (1.0 - blend.g), 1.0),\n            blend.b == 1.0 ? 1.0 : min(base.b / (1.0 - blend.b), 1.0)\n        );\n    } else if (mode == 4) {\n        // SCREEN: 1 - (1 - base) * (1 - blend)\n        return vec3(1.0) - (vec3(1.0) - base) * (vec3(1.0) - blend);\n    } else if (mode == 5) {\n        // OVERLAY: base < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n        return vec3(\n            base.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),\n            base.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),\n            base.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))\n        );\n    } else if (mode == 6) {\n        // ADD (LINEAR DODGE): base + blend\n        return min(base + blend, vec3(1.0));\n    } else if (mode == 7) {\n        // SOFT LIGHT: blend < 0.5 ? (2*base*blend + base^2*(1-2*blend)) : (sqrt(base)*(2*blend-1) + 2*base*(1-blend))\n        return vec3(\n            blend.r < 0.5 ? (2.0 * base.r * blend.r + base.r * base.r * (1.0 - 2.0 * blend.r)) : (sqrt(base.r) * (2.0 * blend.r - 1.0) + 2.0 * base.r * (1.0 - blend.r)),\n            blend.g < 0.5 ? (2.0 * base.g * blend.g + base.g * base.g * (1.0 - 2.0 * blend.g)) : (sqrt(base.g) * (2.0 * blend.g - 1.0) + 2.0 * base.g * (1.0 - blend.g)),\n            blend.b < 0.5 ? (2.0 * base.b * blend.b + base.b * base.b * (1.0 - 2.0 * blend.b)) : (sqrt(base.b) * (2.0 * blend.b - 1.0) + 2.0 * base.b * (1.0 - blend.b))\n        );\n    } else if (mode == 8) {\n        // HARD LIGHT: blend < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n        return vec3(\n            blend.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),\n            blend.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),\n            blend.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))\n        );\n    } else if (mode == 9) {\n        // VIVID LIGHT: blend < 0.5 ? ColorBurn(base, 2*blend) : ColorDodge(base, 2*(blend-0.5))\n        return vec3(\n            blend.r < 0.5 ? (blend.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.r) / (2.0 * blend.r)), 0.0)) : (blend.r == 1.0 ? 1.0 : min(base.r / (2.0 * (1.0 - blend.r)), 1.0)),\n            blend.g < 0.5 ? (blend.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.g) / (2.0 * blend.g)), 0.0)) : (blend.g == 1.0 ? 1.0 : min(base.g / (2.0 * (1.0 - blend.g)), 1.0)),\n            blend.b < 0.5 ? (blend.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.b) / (2.0 * blend.b)), 0.0)) : (blend.b == 1.0 ? 1.0 : min(base.b / (2.0 * (1.0 - blend.b)), 1.0))\n        );\n    } else if (mode == 10) {\n        // LINEAR LIGHT: blend < 0.5 ? LinearBurn(base, 2*blend) : LinearDodge(base, 2*(blend-0.5))\n        return vec3(\n            blend.r < 0.5 ? max(base.r + 2.0 * blend.r - 1.0, 0.0) : min(base.r + 2.0 * (blend.r - 0.5), 1.0),\n            blend.g < 0.5 ? max(base.g + 2.0 * blend.g - 1.0, 0.0) : min(base.g + 2.0 * (blend.g - 0.5), 1.0),\n            blend.b < 0.5 ? max(base.b + 2.0 * blend.b - 1.0, 0.0) : min(base.b + 2.0 * (blend.b - 0.5), 1.0)\n        );\n    } else if (mode == 11) {\n        // DIFFERENCE: abs(base - blend)\n        return abs(base - blend);\n    } else if (mode == 12) {\n        // EXCLUSION: base + blend - 2 * base * blend\n        return base + blend - 2.0 * base * blend;\n    } else if (mode == 13) {\n        // DARKEN: min(base, blend)\n        return min(base, blend);\n    } else if (mode == 14) {\n        // LIGHTEN: max(base, blend)\n        return max(base, blend);\n    } else if (mode == 15) {\n        // SUBTRACT: max(base - blend, 0)\n        return max(base - blend, vec3(0.0));\n    } else if (mode == 16) {\n        // DIVIDE: base / (blend + epsilon)\n        return min(base / (blend + vec3(0.001)), vec3(1.0));\n    } else {\n        // PIN LIGHT (mode 17): Replaces colors based on blend brightness\n        float blendLum = (blend.r + blend.g + blend.b) / 3.0;\n        if (blendLum > 0.5) {\n            // Lighten: replace pixels darker than blend\n            return max(base, 2.0 * blend - vec3(1.0));\n        } else {\n            // Darken: replace pixels lighter than blend\n            return min(base, 2.0 * blend);\n        }\n    }\n}\n",mu=["Multiply","Linear Burn","Color Burn","Color Dodge","Screen","Overlay","Add","Soft Light","Hard Light","Vivid Light","Linear Light","Difference","Exclusion","Darken","Lighten","Subtract","Divide","Pin Light"];function fu(e){return mu[e]||"Unknown"}function gu(e){const t=mu.indexOf(e);return-1!==t?t:0}const yu=`\n/**\n * Moon Fragment Shader with Blend Layers\n *\n * Supports up to 4 sequential blend mode layers for complex color grading\n * using universal Photoshop-style blend modes\n */\n\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec2 shadowOffset;\nuniform float shadowCoverage;\nuniform float shadowSoftness;\nuniform vec3 glowColor;\nuniform float glowIntensity;\nuniform float opacity;\n\n// Lunar Eclipse (Blood Moon) uniforms\nuniform float eclipseProgress;\nuniform float eclipseIntensity;\nuniform vec3 bloodMoonColor;\nuniform float emissiveStrength;\nuniform vec2 eclipseShadowPos;      // Shadow center position (-2 to 1)\nuniform float eclipseShadowRadius;  // Shadow radius\n\n// Eclipse Color Grading (from color pickers)\nuniform vec3 eclipseShadowColor;\nuniform vec3 eclipseMidtoneColor;\nuniform vec3 eclipseHighlightColor;\nuniform vec3 eclipseGlowColor;\n\n// Brightness model toggle (0 = centeredness-based, 1 = edge-based)\nuniform float eclipseBrightnessModel;\n\n// Shadow darkness control (0.0 = no darkening, 1.0 = maximum darkening)\nuniform float shadowDarkness;\n\n// Blend Layer Uniforms (up to 4 layers)\nuniform float layer1Mode;\nuniform float layer1Strength;\nuniform float layer1Enabled;\n\nuniform float layer2Mode;\nuniform float layer2Strength;\nuniform float layer2Enabled;\n\nuniform float layer3Mode;\nuniform float layer3Strength;\nuniform float layer3Enabled;\n\nuniform float layer4Mode;\nuniform float layer4Strength;\nuniform float layer4Enabled;\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n// \n// UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n// \n${pu}\n\nvoid main() {\n    // DIRECTIONAL SHADOW in VIEW SPACE - camera-relative moon phase\n    // Shadow stays fixed relative to screen; rotating moon doesn't change which side is lit\n    vec3 viewNormal = normalize(vViewNormal);\n\n    float lightX = shadowOffset.x;\n    float lightY = shadowOffset.y;\n    float offsetMagnitude = length(vec2(lightX, lightY));\n    float lightZ = 1.0 - pow(offsetMagnitude, 1.5);\n    vec3 lightDir = normalize(vec3(lightX, lightY, lightZ));\n\n    // Light direction is in view space (camera-relative)\n    float facing = dot(viewNormal, lightDir);\n    float edgeWidth = max(fwidth(facing) * 4.0, shadowSoftness * 3.0);\n    float shadowFactor = smoothstep(-edgeWidth, edgeWidth, facing);\n\n    // Sample moon surface texture\n    vec4 texColor = texture2D(colorMap, vUv);\n    float brightness = texColor.r + texColor.g + texColor.b;\n    if (brightness < 0.03) {\n        texColor = vec4(0.5, 0.5, 0.5, 1.0);\n    }\n\n    // VIEW DIRECTION (for eclipse rim effects only, NOT for general lighting)\n    vec3 viewDir = normalize(-vViewPosition);\n    float rimFactor = dot(viewNormal, viewDir);\n\n    // EARTHSHINE - faint blue glow on shadowed side\n    vec3 earthshine = texColor.rgb * 0.01 * vec3(0.35, 0.4, 0.6);\n\n    // Apply shadow transition (moon phase only - NOT camera-based)\n    // The moon texture is uniformly visible; only the phase shadow creates darkness\n    float litFactor = pow(shadowFactor, 2.0);\n    vec3 detailEnhanced = texColor.rgb * 1.08;\n    float textureLuminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    detailEnhanced = mix(texColor.rgb * 0.95, texColor.rgb * 1.12, smoothstep(0.3, 0.7, textureLuminance));\n\n    // Lit areas show texture; shadowed areas show earthshine\n    // NO camera-based limb darkening - moon rotates, texture stays uniformly lit\n    vec3 shadowedColor = mix(earthshine, detailEnhanced, litFactor);\n\n    vec3 emissive = vec3(0.02, 0.02, 0.02) * shadowFactor;\n    vec3 emotionGlow = glowColor * glowIntensity * 0.02 * shadowFactor;\n    vec3 finalColor = shadowedColor + emissive + emotionGlow;\n\n    // \n    // LUNAR ECLIPSE EFFECT (Earth's Shadow Sweep)\n    // Shadow position drives everything - automatically transitions from dark sharp shadow to red glow\n    // \n    // Only apply eclipse if shadow is actually near the moon (shadowX > -1.5)\n    if (eclipseProgress > 0.001 && eclipseShadowPos.x > -1.5) {\n        // Eclipse progress is now pre-modulated by UI based on shadow position\n        // No need for shader-side modulation\n        float effectiveProgress = eclipseProgress;\n\n        // Calculate distance from shadow center using VIEW-SPACE position (3D spherical)\n        // This creates a proper circular shadow on the sphere, not a flat UV-based cutoff\n        // viewNormal.xy ranges -1 to 1, scale to match UV range (0 to 0.5 from center)\n        vec2 shadowCenter = vec2(eclipseShadowPos.x, eclipseShadowPos.y);\n        vec2 spherePos = viewNormal.xy * 0.5; // Scale to UV-equivalent range\n        float distFromShadow = length(spherePos - shadowCenter);\n\n        // TOTALITY FACTOR: Based on how centered the shadow is on the moon\n        // When shadowX near 0.0 (centered), we're at totality - brightens and reddens\n        // When shadowX far from 0.0 (off to side), we're partial - stays dark and diffuse\n        float shadowCenteredness = 1.0 - smoothstep(0.0, 0.6, abs(eclipseShadowPos.x));\n        float totalityFactor = shadowCenteredness;\n\n        // Earth's umbra (full shadow) - DIFFUSE at partials, sharper at totality\n        float umbraRadius = eclipseShadowRadius * 0.7;\n        // Edge softness: very diffuse at partials (0.25), sharp at totality (0.05)\n        float umbraEdge = mix(0.25, 0.05, totalityFactor);\n        float umbra = 1.0 - smoothstep(umbraRadius - umbraEdge, umbraRadius + umbraEdge, distFromShadow);\n\n        // Earth's penumbra (partial shadow) - wider and softer\n        // Penumbra extends further at partials, tighter at totality\n        float penumbraRadius = eclipseShadowRadius * mix(1.4, 1.1, totalityFactor);\n        float penumbraEdge = mix(0.3, 0.15, totalityFactor);\n        float penumbra = 1.0 - smoothstep(penumbraRadius - penumbraEdge, penumbraRadius + penumbraEdge, distFromShadow);\n\n        // UMBRA DARKENING: Much darker at partials, lighter at totality\n        // Partials: 85% darkening (very dark shadow)\n        // Totality: 30% darkening (blood moon glow visible)\n        float baseDarkening = mix(0.85, 0.30, totalityFactor);\n        float umbraDarkeningAmount = baseDarkening * shadowDarkness;\n        float umbraDarkening = umbra * effectiveProgress;\n\n        // Apply base darkening first\n        finalColor *= (1.0 - umbraDarkening * umbraDarkeningAmount);\n\n        // PENUMBRA: Darker gradient at partials, lighter at totality\n        float penumbraDarkening = (penumbra - umbra) * effectiveProgress;\n        float penumbraDarkenAmount = mix(0.50, 0.20, totalityFactor); // 50% at partials, 20% at totality\n        finalColor *= (1.0 - penumbraDarkening * penumbraDarkenAmount);\n\n        // BLOOD MOON COLOR: Applied throughout entire eclipse, not just totality\n        // Matches real lunar eclipse behavior - color present at all phases\n        // Use totality factor to control BRIGHTNESS, not color presence\n        float colorStrength = umbra; // Color appears wherever umbra shadow is present\n        vec3 bloodMoonTint = mix(vec3(1.0), eclipseMidtoneColor, colorStrength);\n        finalColor *= bloodMoonTint;\n\n        // REALISTIC ECLIPSE PROGRESSION (corrected):\n        // Shadow sweeps LEFT  RIGHT but NEVER fully covers moon during partials\n        // A bright crescent ALWAYS remains visible (shadow stops before covering moon)\n        // Just before totality: shadow nearly covers moon, blood moon glow appears\n        // The glow spreads FROM the visible bright crescent INTO the shadowed area\n        // During totality: shadow finally covers entire moon, full blood moon\n\n        // Use view-space normal for spherical position (not UV)\n        // Scale to match UV range\n        float pixelX = viewNormal.x * 0.5;\n\n        // THE LIT CRESCENT: Always visible during partial phases\n        // During partials, the moon is partially lit (outside umbra)\n        // Only during totality does the shadow fully cover the moon\n\n        // Where is the bright crescent? Opposite side from shadow\n        // Approaching (shadowX < 0): crescent on RIGHT (positive X)\n        // Leaving (shadowX > 0): crescent on LEFT (negative X)\n        float crescentSide = -sign(eclipseShadowPos.x);\n\n        // CRESCENT EDGE: Where shadow meets lit surface\n        // This is always VISIBLE during partials - never goes to zero\n        float umbraEdgeX = eclipseShadowPos.x + (umbraRadius * crescentSide);\n\n        // Distance from this pixel to the lit crescent edge\n        // Positive = inside shadow, negative = in lit crescent\n        float distFromLitEdge = (pixelX - umbraEdgeX) * crescentSide;\n\n        // GRADIENT: Blood moon glow spreads from the LIT CRESCENT\n        // Only pixels INSIDE the shadow get the gradient\n        // Gradient is strongest at the umbra edge (where crescent is)\n        float crescentGradient = smoothstep(0.5, 0.0, distFromLitEdge);\n\n        // BRIGHTNESS CONTROL: Glow only appears near totality\n        // When shadow is far from center: stays dark\n        // When shadow approaches center: glow spreads from crescent\n        float brightnessControl = umbra * crescentGradient * totalityFactor;\n\n        // During full totality (shadowX  0), switch to uniform brightness\n        brightnessControl = mix(brightnessControl, umbra * totalityFactor, totalityFactor);\n\n        // EMISSIVE GLOW: Blood moon color spreading from crescent\n        float glowStrength = mix(0.0, 1.0, brightnessControl);\n        vec3 atmosphereGlow = eclipseMidtoneColor * emissiveStrength * glowStrength * umbra;\n        finalColor += atmosphereGlow;\n\n        // RIM GLOW: Atmospheric limb brightening\n        float limbGlowStrength = mix(0.0, 1.5, brightnessControl);\n        float limbGlow = pow(1.0 - rimFactor, 3.0) * umbra;\n        vec3 rimColor = mix(eclipseGlowColor, eclipseHighlightColor, 0.5);\n        finalColor += rimColor * limbGlow * emissiveStrength * limbGlowStrength;\n\n        // \n        // ECLIPSE BLEND LAYERS (Applied AFTER blood moon color)\n        // Applied throughout eclipse wherever umbra is present\n        // Strength modulated by totality factor for smooth brightness transitions\n        // \n\n        // Layer 1: Linear Burn @ 0.634\n        if (layer1Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n            int mode1 = int(layer1Mode + 0.5);\n            vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n            // Apply at FULL strength wherever umbra exists\n            finalColor = clamp(mix(finalColor, blended1, umbra), 0.0, 1.0);\n        }\n\n        // Layer 2: Multiply @ 3.086 - Brightness enhancement\n        if (layer2Enabled > 0.5 && effectiveProgress > 0.1) {\n            // Apply full brightness boost wherever umbra exists\n            vec3 brightened = clamp(finalColor * min(layer2Strength, 5.0), 0.0, 1.0);\n            finalColor = mix(finalColor, brightened, umbra);\n        }\n\n        // Layer 3: Hard Light @ 0.351\n        if (layer3Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n            int mode3 = int(layer3Mode + 0.5);\n            vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n            // Apply at FULL strength wherever umbra exists\n            finalColor = clamp(mix(finalColor, blended3, umbra), 0.0, 1.0);\n        }\n\n        // Layer 4: Manual UI layer\n        if (layer4Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n            int mode4 = int(layer4Mode + 0.5);\n            vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n            finalColor = clamp(mix(finalColor, blended4, umbra), 0.0, 1.0);\n        }\n    }\n\n    // \n    // UNIVERSAL BLEND MODE LAYERS (Only applied when eclipse is OFF)\n    // These are manual UI-driven color grading tools\n    // NOTE: These are DISABLED by default - they're NEVER used since the multiplexer\n    // demo doesn't enable them. This section exists for potential future manual control.\n    // \n    // INTENTIONALLY COMMENTED OUT - these would interfere with eclipse blend layers\n    // if (eclipseProgress < 0.001) {\n    //     // Layer 1 - manual UI control only\n    //     if (layer1Enabled > 0.5) {\n    //         vec3 blendColor1 = vec3(layer1Strength);\n    //         int mode1 = int(layer1Mode + 0.5);\n    //         finalColor = applyBlendMode(finalColor, blendColor1, mode1);\n    //     }\n    // }\n\n    gl_FragColor = vec4(finalColor, opacity);\n}\n`,vu=55.5,bu=-85,wu=-60.5,xu={enabled:!0,strength:1,lockedFace:[0,0,1],lerpSpeed:10},Su={new:{x:200,y:0,coverage:0},"waxing-crescent":{x:1.5,y:0,coverage:.25},"first-quarter":{x:1,y:0,coverage:.5},"waxing-gibbous":{x:.7,y:0,coverage:.75},full:{x:0,y:0,coverage:1},"waning-gibbous":{x:-.7,y:0,coverage:.75},"last-quarter":{x:-1,y:0,coverage:.5},"waning-crescent":{x:-1.5,y:0,coverage:.25}};function Mu(){return Object.keys(Su)}function _u(e){const t=(e%1+1)%1;let n;if(t<=.5){const e=2*t;n=10*Math.pow(1-e,2.5)}else{const e=2*(t-.5);if(e<=.25)n=e/.25*-.3;else if(e<=.5)n=-.3-(e-.25)/.25*.7;else if(e<=.75)n=-1-(e-.5)/.25*2;else{const t=(e-.75)/.25;n=13*Math.pow(t,.4)-3}}return{x:n,y:0,coverage:1-2*Math.abs(t-.5)}}function Au(e=64,t=64){const n=new so(.5,e,t);return n.userData.tracked=!0,n}function Cu(e){if(e&&(e.geometry&&e.geometry.dispose(),e.material)){const{material:t}=e;t.userData&&t.userData.pendingTextures&&(t.userData.pendingTextures.forEach(({texture:e})=>{e&&e.dispose()}),t.userData.pendingTextures.clear()),t.map&&t.map.dispose(),t.normalMap&&t.normalMap.dispose(),t.uniforms&&(t.uniforms.colorMap&&t.uniforms.colorMap.value&&t.uniforms.colorMap.value.dispose(),t.uniforms.normalMap&&t.uniforms.normalMap.value&&t.uniforms.normalMap.value.dispose()),t.dispose()}}function Tu(e,t={}){const n=t.resolution||"4k",a=t.assetBasePath||"/assets",i=`${a}/textures/Moon/moon-color-${n}.jpg`,r=`${a}/textures/Moon/moon-normal-${n}.jpg`,s=new Map;s.set(i,{texture:null});const o=e.load(i,e=>{const t=s.get(i);t&&(t.texture=e),s.delete(i)},void 0,e=>{console.error(` Failed to load moon color texture (${n}):`,e),s.delete(i)});s.set(r,{texture:null});const l=e.load(r,e=>{const t=s.get(r);t&&(t.texture=e),s.delete(r)},void 0,e=>{console.error(` Failed to load moon normal map (${n}):`,e),s.delete(r)});o.wrapS=o.wrapT=N,l.wrapS=l.wrapT=N,o.anisotropy=16,l.anisotropy=16;const c=new lo({map:o,normalMap:l,normalScale:new Vt(1.5,1.5),roughness:.7,metalness:0,emissive:new Ia(.3,.3,.3),emissiveIntensity:.5,transparent:!1,side:0});return c.userData.pendingTextures=s,c}function Pu(e=new Ia(16777215),t=0){return new lo({color:15263976,roughness:.9,metalness:0,emissive:e,emissiveIntensity:t})}function Du(e,t={}){const n=t.resolution||"4k",a=t.glowColor||new Ia(1,1,1),i=t.glowIntensity||1,r=t.shadowType||"crescent",s=t.assetBasePath||"/assets";let o,l;if(void 0!==t.shadowOffsetX)({shadowOffsetX:o}=t),l=void 0!==t.shadowOffsetY?t.shadowOffsetY:0;else if(void 0!==t.moonPhase){let e;"string"==typeof t.moonPhase?([e]=[Su[t.moonPhase]],e||(console.warn(`Unknown moon phase: ${t.moonPhase}, using waxing-crescent`),e=Su["waxing-crescent"])):e="number"==typeof t.moonPhase?_u(t.moonPhase):Su["waxing-crescent"],o=e.x,l=e.y}else{const e=Su["waxing-crescent"];o=e.x,l=e.y}const c=void 0!==t.shadowCoverage?t.shadowCoverage:.85,h=`${s}/textures/Moon/moon-color-${n}.jpg`,d=`${s}/textures/Moon/moon-normal-${n}.jpg`,{vertexShader:u,fragmentShader:p}=function(e){return"crescent"===e||console.warn(`Unknown shadow type: ${e}, defaulting to crescent`),{vertexShader:"\n/**\n * Moon Crescent Vertex Shader\n * Passes world-space normal to fragment shader for realistic lighting\n */\n\nvarying vec3 vPosition; // LOCAL position\nvarying vec3 vWorldPosition;\nvarying vec3 vWorldNormal; // WORLD SPACE normal (rotates with moon)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n\n    // Transform normal to WORLD space (not view space)\n    // This makes the shadow rotate with the moon geometry\n    vWorldNormal = normalize(mat3(modelMatrix) * normal);\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPosition.xyz;\n    vec4 viewPosition = viewMatrix * worldPosition;\n    vViewPosition = viewPosition.xyz;\n    gl_Position = projectionMatrix * viewPosition;\n}\n",fragmentShader:"\n/**\n * Moon Crescent Fragment Shader\n *\n * Uses directional half-space test in WORLD SPACE to create realistic terminator:\n * - Light direction fixed in world space (like the sun)\n * - Normals rotate with moon geometry (in world space)\n * - dot(normal, lightDir) < 0 = shadow side\n * - dot(normal, lightDir) > 0 = lit side\n * - Smooth terminator with earthshine on dark side\n */\n\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec2 shadowOffset; // Controls light direction (x=horizontal, y=vertical)\nuniform float shadowCoverage; // Unused for directional shadow\nuniform float shadowSoftness; // Terminator edge softness (default: 0.05)\nuniform vec3 glowColor;\nuniform float glowIntensity;\nuniform float opacity; // Fade in opacity (0-1) to prevent gray flash during texture load\n\n// Lunar Eclipse (Blood Moon) uniforms\nuniform float eclipseProgress; // 0.0 = no eclipse, 1.0 = totality\nuniform float eclipseIntensity; // Darkening strength (0.0-1.0)\nuniform vec3 bloodMoonColor; // Deep reddish-orange for total eclipse\nuniform float blendMode; // 0=Multiply, 1=LinearBurn, 2=ColorBurn, 3=ColorDodge, 4=Screen, 5=Overlay\nuniform float blendStrength; // Blend strength multiplier (0.0-5.0)\nuniform float emissiveStrength; // Emissive glow strength (0.0-1.0)\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vWorldNormal; // WORLD SPACE normal (rotates with moon)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    // DIRECTIONAL SHADOW in WORLD SPACE - realistic moon phase lighting\n    // Light direction is fixed in world space, shadow rotates with moon\n\n    // Use world-space normal (rotates with moon geometry)\n    vec3 worldNormal = normalize(vWorldNormal);\n\n    // Light direction in WORLD SPACE\n    // shadowOffset.x controls horizontal angle (left/right)\n    // shadowOffset.y controls vertical angle (up/down)\n    // For thin crescents, we need extreme angles (light from the side or behind)\n\n    float lightX = shadowOffset.x;\n    float lightY = shadowOffset.y;\n\n    // Adaptive Z component with LOGARITHMIC scaling for wider angular range\n    // Goal: Spread phases across full 0 to 180 instead of plateauing at 135\n    //\n    // Target angles after normalization:\n    // - Full moon (x=0): 0 (light from front)\n    // - Quarter moon (x=1): 90 (light from side)\n    // - Crescent (x=3): 120 (thin crescent)\n    // - New moon (x=10): 170 (nearly behind)\n\n    float offsetMagnitude = length(vec2(lightX, lightY));\n\n    // Use exponential decay for Z to spread angular range\n    // Formula: Z = 1.0 - offsetMagnitude^1.5 for better distribution\n    float lightZ = 1.0 - pow(offsetMagnitude, 1.5);\n\n    // Normalize the light direction vector\n    vec3 lightDir = normalize(vec3(lightX, lightY, lightZ));\n\n    // Calculate how much this fragment faces the light source\n    float facing = dot(worldNormal, lightDir);\n\n    // Smooth transition at terminator (shadow boundary)\n    // Softer edge for realistic lunar terminator (like real moon photography)\n    // Use fwidth() for automatic screen-space anti-aliasing\n    float edgeWidth = max(fwidth(facing) * 4.0, shadowSoftness * 3.0);\n    float shadowFactor = smoothstep(-edgeWidth, edgeWidth, facing);\n\n    // Sample moon surface texture\n    vec4 texColor = texture2D(colorMap, vUv);\n\n    // Fallback to gray if texture not loaded yet\n    float brightness = texColor.r + texColor.g + texColor.b;\n    if (brightness < 0.03) {\n        texColor = vec4(0.5, 0.5, 0.5, 1.0);\n    }\n\n    // LIMB DARKENING: Moon gets darker at edges (spherical falloff)\n    vec3 viewDir = normalize(-vViewPosition);\n    float rimFactor = dot(worldNormal, viewDir);\n    float limbDarkening = smoothstep(0.0, 0.6, rimFactor); // Subtle edge darkening\n\n    // DIFFUSE LIGHTING: Vary brightness across lit surface (not uniform)\n    // More realistic Lambertian diffuse reflection\n    float diffuse = max(facing, 0.0);\n    float diffuseLighting = mix(0.7, 1.0, diffuse); // Subtle variation\n\n    // EARTHSHINE: Almost invisible (~1% for ultimate realism)\n    vec3 earthshine = texColor.rgb * 0.01 * vec3(0.35, 0.4, 0.6);\n\n    // Apply dramatic shadow transition with maximum contrast\n    float litFactor = pow(shadowFactor, 2.0); // Maximum contrast\n\n    // TEXTURE ENHANCEMENT: Boost surface detail contrast\n    // Slightly darken dark areas, brighten bright areas of texture\n    vec3 detailEnhanced = texColor.rgb * 1.08; // Subtle boost\n    float textureLuminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    detailEnhanced = mix(texColor.rgb * 0.95, texColor.rgb * 1.12, smoothstep(0.3, 0.7, textureLuminance));\n\n    // Combine enhanced texture with diffuse lighting\n    vec3 litColor = detailEnhanced * diffuseLighting;\n    vec3 shadowedColor = mix(earthshine, litColor, litFactor);\n\n    // Apply limb darkening (slightly stronger for more depth)\n    shadowedColor *= mix(0.6, 1.0, limbDarkening);\n\n    // Nearly zero emissive for pure realism\n    vec3 emissive = vec3(0.02, 0.02, 0.02) * shadowFactor;\n\n    // Emotion glow (almost invisible)\n    vec3 emotionGlow = glowColor * glowIntensity * 0.02 * shadowFactor;\n\n    // Combine all lighting components\n    vec3 finalColor = shadowedColor + emissive + emotionGlow;\n\n    // \n    // LUNAR ECLIPSE (BLOOD MOON) EFFECT\n    // \n    // Simulates Earth's umbral shadow with Rayleigh scattering (reddish glow)\n    if (eclipseProgress > 0.001) {\n        // Calculate gradient from lit edge to dark center\n        // Use rim factor (view angle) to create radial gradient\n        float gradientFactor = rimFactor; // 1.0 at edges, 0.0 at center\n\n        // Darken the moon (Earth's shadow)\n        float darkeningFactor = 1.0 - eclipseIntensity;\n        finalColor *= darkeningFactor;\n\n        // \n        // PHOTOSHOP-STYLE BLEND MODES: Multiple modes for deep saturation control\n        // \n\n        // Define blood moon gradient colors\n        vec3 deepRed = vec3(0.6, 0.2, 0.12);       // Dark burnt red-orange (center)\n        vec3 brightOrange = vec3(0.95, 0.45, 0.22); // Bright burnt orange (edges)\n\n        // Create radial gradient from center (dark) to edge (bright)\n        vec3 bloodGradient = mix(deepRed, brightOrange, pow(gradientFactor, 1.8));\n\n        // Apply blend strength multiplier\n        vec3 blendColor = bloodGradient * blendStrength;\n\n        // Calculate all blend modes\n        vec3 finalBlend;\n        int mode = int(blendMode + 0.5); // Round to nearest int\n\n        if (mode == 0) {\n            // MULTIPLY: base * blend\n            finalBlend = finalColor * blendColor;\n        } else if (mode == 1) {\n            // LINEAR BURN: base + blend - 1\n            finalBlend = max(finalColor + blendColor - vec3(1.0), vec3(0.0));\n        } else if (mode == 2) {\n            // COLOR BURN: (blend==0.0) ? 0.0 : max((1.0-((1.0-base)/blend)), 0.0)\n            finalBlend = vec3(\n                blendColor.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.r) / blendColor.r), 0.0),\n                blendColor.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.g) / blendColor.g), 0.0),\n                blendColor.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.b) / blendColor.b), 0.0)\n            );\n        } else if (mode == 3) {\n            // COLOR DODGE: (blend==1.0) ? 1.0 : min(base/(1.0-blend), 1.0)\n            finalBlend = vec3(\n                blendColor.r == 1.0 ? 1.0 : min(finalColor.r / (1.0 - blendColor.r), 1.0),\n                blendColor.g == 1.0 ? 1.0 : min(finalColor.g / (1.0 - blendColor.g), 1.0),\n                blendColor.b == 1.0 ? 1.0 : min(finalColor.b / (1.0 - blendColor.b), 1.0)\n            );\n        } else if (mode == 4) {\n            // SCREEN: 1 - (1 - base) * (1 - blend)\n            finalBlend = vec3(1.0) - (vec3(1.0) - finalColor) * (vec3(1.0) - blendColor);\n        } else {\n            // OVERLAY: base < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n            finalBlend = vec3(\n                finalColor.r < 0.5 ? (2.0 * finalColor.r * blendColor.r) : (1.0 - 2.0 * (1.0 - finalColor.r) * (1.0 - blendColor.r)),\n                finalColor.g < 0.5 ? (2.0 * finalColor.g * blendColor.g) : (1.0 - 2.0 * (1.0 - finalColor.g) * (1.0 - blendColor.g)),\n                finalColor.b < 0.5 ? (2.0 * finalColor.b * blendColor.b) : (1.0 - 2.0 * (1.0 - finalColor.b) * (1.0 - blendColor.b))\n            );\n        }\n\n        // Apply blood moon effect\n        finalColor = mix(finalColor, finalBlend, eclipseProgress);\n\n        // Add emissive glow for visibility\n        finalColor += bloodGradient * emissiveStrength * eclipseProgress;\n\n        // Add bright rim glow during totality (refracted atmosphere light)\n        if (eclipseProgress > 0.7) {\n            float rimIntensity = pow(gradientFactor, 2.5); // Sharp falloff from edge\n            vec3 rimGlow = brightOrange * rimIntensity * (eclipseProgress - 0.7) * 2.5;\n            finalColor += rimGlow;\n        }\n    }\n\n    // Apply fade-in opacity to prevent gray flash during texture load\n    gl_FragColor = vec4(finalColor, opacity);\n}\n"}}(r),m=new bi({uniforms:{colorMap:{value:null},normalMap:{value:null},shadowOffset:{value:new Vt(o,l)},shadowCoverage:{value:c},shadowSoftness:{value:.05},glowColor:{value:a},glowIntensity:{value:i},opacity:{value:0},eclipseProgress:{value:0},eclipseIntensity:{value:0},bloodMoonColor:{value:[.85,.18,.08]},blendMode:{value:0},blendStrength:{value:2},emissiveStrength:{value:.39},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:1.2},eclipseShadowColor:{value:[.85,.08,.02]},eclipseMidtoneColor:{value:[1,.12,.03]},eclipseHighlightColor:{value:[1,.35,.08]},eclipseGlowColor:{value:[1,.4,.1]}},vertexShader:u,fragmentShader:p,transparent:!0,side:0}),f=new Map;f.set(h,{texture:null});const g=e.load(h,e=>{m.uniforms.colorMap.value=e;const n=performance.now(),a=()=>{const e=performance.now()-n,t=Math.min(e/300,1);m.uniforms.opacity.value=t,m.needsUpdate=!0,t<1&&requestAnimationFrame(a)};a();const i=f.get(h);i&&(i.texture=e),f.delete(h),t.onTextureReady&&t.onTextureReady(m)},void 0,e=>{console.error(" Failed to load moon crescent color texture:",e),f.delete(h)});f.set(d,{texture:null});const y=e.load(d,e=>{m.uniforms.normalMap.value=e,m.needsUpdate=!0;const t=f.get(d);t&&(t.texture=e),f.delete(d)},void 0,e=>{console.error(" Failed to load moon crescent normal map:",e),f.delete(d)});return g.wrapS=g.wrapT=N,y.wrapS=y.wrapT=N,g.anisotropy=16,y.anisotropy=16,m.userData.pendingTextures=f,m}function Ou(e,t={}){return Du(e,{...t,shadowType:"crescent"})}function Eu(e,t){if(!e.uniforms||!e.uniforms.shadowOffset)return console.warn("Material does not have shadowOffset uniform"),!1;let n;if("string"==typeof t){if(n=Su[t],!n)return console.warn(`Unknown moon phase: ${t}`),!1}else{if("number"!=typeof t)return console.warn("Phase must be a string or number"),!1;n=_u(t)}return e.uniforms.shadowOffset.value.set(n.x,n.y),!0}function Iu(e,t,n=2e3){let a=null,i=!1;const r=new Promise((r,s)=>{if(!e.uniforms||!e.uniforms.shadowOffset)return void s(new Error("Material does not have shadowOffset uniform"));let o;if("string"==typeof t){if(o=Su[t],!o)return void s(new Error(`Unknown moon phase: ${t}`))}else{if("number"!=typeof t)return void s(new Error("Phase must be a string or number"));o=_u(t)}const l=e.uniforms.shadowOffset.value.x,c=e.uniforms.shadowOffset.value.y,h=o.x,d=o.y,u=Date.now(),p=()=>{if(i)return void r({cancelled:!0});const t=Date.now()-u,s=Math.min(t/n,1),o=s<.5?4*s*s*s:1-Math.pow(-2*s+2,3)/2,m=l+(h-l)*o,f=c+(d-c)*o;e.uniforms.shadowOffset.value.set(m,f),s<1?a=requestAnimationFrame(p):r({cancelled:!1})};p()});return{promise:r,cancel:()=>{i=!0,null!==a&&(cancelAnimationFrame(a),a=null)}}}function ku(e,t,n){e.emissive&&(e.emissive.copy(t),e.emissiveIntensity=n),e.uniforms&&e.uniforms.glowColor&&(e.uniforms.glowColor.value.copy(t),e.uniforms.glowIntensity.value=n)}function Ru(e,t,n,a){e.uniforms&&e.uniforms.shadowOffset&&(e.uniforms.shadowOffset.value.set(t,n),e.uniforms.shadowCoverage.value=a)}function zu(e,t={}){const{resolution:n="4k",glowColor:a=new Ia(16777215),glowIntensity:i=1,assetBasePath:r="/assets"}=t,{vertexShader:s,fragmentShader:o}={vertexShader:"\n/**\n * Moon Vertex Shader\n * Passes view-space normal for camera-relative moon phase shadows\n */\n\nvarying vec3 vPosition; // LOCAL position (object space)\nvarying vec3 vWorldPosition;\nvarying vec3 vViewNormal; // VIEW SPACE normal (fixed relative to camera)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n\n    // Transform normal to VIEW space (camera-relative)\n    // This keeps the moon phase shadow fixed relative to camera view\n    // When you rotate the moon, the texture rotates but the phase shadow stays put\n    vViewNormal = normalize(normalMatrix * normal);\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPosition.xyz;\n    vec4 viewPosition = viewMatrix * worldPosition;\n    vViewPosition = viewPosition.xyz;\n    gl_Position = projectionMatrix * viewPosition;\n}\n",fragmentShader:yu},l=new bi({uniforms:{colorMap:{value:null},normalMap:{value:null},shadowOffset:{value:new Vt(0,0)},shadowCoverage:{value:.5},shadowSoftness:{value:.05},glowColor:{value:a},glowIntensity:{value:i},opacity:{value:0},eclipseProgress:{value:0},eclipseIntensity:{value:0},bloodMoonColor:{value:[.85,.18,.08]},emissiveStrength:{value:.39},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:1.2},eclipseShadowColor:{value:[1,.58,0]},eclipseMidtoneColor:{value:[.71,.43,.03]},eclipseHighlightColor:{value:[1,.28,.1]},eclipseGlowColor:{value:[.09,.09,.09]},eclipseBrightnessModel:{value:0},shadowDarkness:{value:.53},layer1Mode:{value:9},layer1Strength:{value:.322},layer1Enabled:{value:1},layer2Mode:{value:0},layer2Strength:{value:2.785},layer2Enabled:{value:1},layer3Mode:{value:7},layer3Strength:{value:.199},layer3Enabled:{value:1},layer4Mode:{value:0},layer4Strength:{value:0},layer4Enabled:{value:0}},vertexShader:s,fragmentShader:o,transparent:!0,depthWrite:!0,side:0}),c=`${r}/textures/Moon/moon-color-${n}.jpg`,h=`${r}/textures/Moon/moon-normal-${n}.jpg`;return e.load(c,e=>{l.uniforms.colorMap.value=e;const n=performance.now(),a=()=>{const e=performance.now()-n,t=Math.min(e/300,1);l.uniforms.opacity.value=t,l.needsUpdate=!0,t<1&&requestAnimationFrame(a)};a(),t.onTextureReady&&t.onTextureReady(l)}),e.load(h,e=>{l.uniforms.normalMap.value=e}),l}const Fu=`\n/**\n * Sun Fragment Shader with Blend Layers and Solar Eclipse\n *\n * Supports solar eclipse effects with moon's shadow darkening the sun\n * and up to 4 sequential blend mode layers for eclipse appearance adjustment\n */\n\nuniform float time;\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec3 baseColor;\nuniform float emissiveIntensity;\nuniform vec2 shadowOffset;\nuniform float shadowCoverage;\nuniform float shadowSoftness;\nuniform float opacity;\n\n// Solar Eclipse uniforms (moon's shadow covering sun)\nuniform float eclipseProgress;        // Eclipse progress (0 = no eclipse, 1 = totality)\nuniform vec2 eclipseShadowPos;        // Shadow center position in UV space\nuniform float eclipseShadowRadius;    // Moon's shadow radius\nuniform float shadowDarkness;         // How much to darken the sun (0-1)\n\n// Blend Layer Uniforms (up to 4 layers)\nuniform float layer1Mode;\nuniform float layer1Strength;\nuniform float layer1Enabled;\n\nuniform float layer2Mode;\nuniform float layer2Strength;\nuniform float layer2Enabled;\n\nuniform float layer3Mode;\nuniform float layer3Strength;\nuniform float layer3Enabled;\n\nuniform float layer4Mode;\nuniform float layer4Strength;\nuniform float layer4Enabled;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;  // View-space position (camera-relative)\n\n// \n// UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n// \n${pu}\n\n// \n// SIMPLEX NOISE (for fire animation - from original sun shader)\n// \nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nvoid main() {\n    // \n    // BASE SUN RENDERING (photosphere texture + fire animation)\n    // \n\n    // Sample base photosphere texture\n    vec4 texColor = texture2D(colorMap, vUv);\n\n    // Optimized single-octave noise for subtle fire\n    vec3 noiseCoord = vPosition * 30.0 + vec3(0.0, time * 0.025, 0.0);\n    float fireNoise = snoise(noiseCoord);\n\n    // Simple threshold - fire appears only in specific noise ranges\n    float fireMask = fireNoise * 0.5 + 0.5; // Remap -1..1 to 0..1\n    fireMask = step(0.45, fireMask) * (1.0 - step(0.55, fireMask)); // Only 0.45-0.55 range\n\n    // Almost imperceptible warmth shift\n    vec3 fireColor = vec3(1.01, 1.0, 0.99);\n\n    // Microscopic blending\n    vec3 finalColor = mix(texColor.rgb, fireColor, fireMask * 0.008);\n\n    // Apply base color tinting\n    finalColor *= baseColor;\n\n    // Apply emissive intensity for HDR bloom\n    finalColor *= emissiveIntensity;\n\n    // \n    // LIMB DARKENING (realistic solar effect - edges appear darker than center)\n    // \n\n    // Calculate distance from center (0 at center, 1 at edge)\n    float distFromCenterLimb = length(vWorldPosition.xy) / 0.5; // normalize by sun radius (0.5)\n    distFromCenterLimb = clamp(distFromCenterLimb, 0.0, 1.0);\n\n    // Limb darkening formula: I() = 1 - u*(1-) where  = cos(viewing angle)\n    // Simplified using distance: darker at edges, brighter at center\n    float mu = sqrt(1.0 - distFromCenterLimb * distFromCenterLimb); // cos approximation\n    // EXTREME limb darkening for visibility\n    float limbDarkeningCoeff = 0.98; // 98% darkening at edges\n    float limbBrightness = 1.0 - limbDarkeningCoeff * (1.0 - mu);\n    limbBrightness = pow(limbBrightness, 0.4); // Very aggressive power curve\n\n    // Clamp to prevent over-darkening\n    limbBrightness = max(limbBrightness, 0.02); // Edges at least 2% brightness\n\n    // Apply limb darkening (BEFORE bloom processing)\n    finalColor *= limbBrightness;\n\n    // \n    // SOLAR ECLIPSE EFFECT (Moon Occulting Sun)\n    // \n    // Solar eclipse: Moon passes BETWEEN viewer and sun, blocking our view\n    // The moon appears as a dark circular disk that covers parts of the sun\n    // From Earth, moon and sun appear same angular size (0.5)\n\n    // Only apply eclipse if there's a moon to occlude (radius > 0)\n    if (eclipseShadowRadius > 0.01) {\n        // Only occlude FRONT-FACING parts of the sun (vViewPosition.z < 0 faces camera in view space)\n        // Back of sun should not be affected by moon\n        if (vViewPosition.z < 0.1) {\n            // Project to screen space - camera-relative, independent of sun rotation\n            // vViewPosition.xy is already in camera space, just normalize to sun radius\n            // Sun radius in view space is approximately 0.5 at typical camera distance\n            vec2 screenPos = vViewPosition.xy;\n\n            // Moon center position in screen space (same coordinate system)\n            vec2 moonCenter = eclipseShadowPos;\n\n            // Distance from this sun point to moon center (2D screen space)\n            float distToMoon = length(screenPos - moonCenter);\n\n            // Moon's angular size (appears same size as sun from Earth)\n            // In normalized screen space, sun radius = 1.0, moon radius = 1.0 for total eclipse\n            float moonRadius = eclipseShadowRadius;\n            float moonEdge = 0.01; // Sharp edge for moon silhouette\n\n            // Check if moon blocks this point (moon is in front of sun)\n            float moonOcclusion = 1.0 - smoothstep(moonRadius - moonEdge, moonRadius + moonEdge, distToMoon);\n\n            // Only apply if moon is actually occluding something\n            if (moonOcclusion > 0.001) {\n                // Moon completely blocks sun where it overlaps (no light gets through)\n                finalColor *= (1.0 - moonOcclusion);\n\n                // Subtle penumbra around moon edge (diffraction)\n                float penumbraRadius = moonRadius * 1.02;\n                float penumbraEdge = 0.03;\n                float penumbra = 1.0 - smoothstep(penumbraRadius - penumbraEdge, penumbraRadius + penumbraEdge, distToMoon);\n                float penumbraBlocking = (penumbra - moonOcclusion) * 0.2;\n                finalColor *= (1.0 - penumbraBlocking);\n            }\n        }\n    }\n\n    // \n    // BLEND LAYERS (Applied globally to entire sun)\n    // These allow adjusting the appearance of the sun\n    // \n\n    // Layer 1\n    if (layer1Enabled > 0.5) {\n        vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n        int mode1 = int(layer1Mode + 0.5);\n        vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n        finalColor = clamp(blended1, 0.0, 1.0);\n    }\n\n    // Layer 2\n    if (layer2Enabled > 0.5) {\n        vec3 blendColor2 = vec3(min(layer2Strength, 1.0));\n        int mode2 = int(layer2Mode + 0.5);\n        vec3 blended2 = clamp(applyBlendMode(finalColor, blendColor2, mode2), 0.0, 1.0);\n        finalColor = clamp(blended2, 0.0, 1.0);\n    }\n\n    // Layer 3\n    if (layer3Enabled > 0.5) {\n        vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n        int mode3 = int(layer3Mode + 0.5);\n        vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n        finalColor = clamp(blended3, 0.0, 1.0);\n    }\n\n    // Layer 4\n    if (layer4Enabled > 0.5) {\n        vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n        int mode4 = int(layer4Mode + 0.5);\n        vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n        finalColor = clamp(blended4, 0.0, 1.0);\n    }\n\n    // Apply fade-in opacity to prevent texture flash during load\n    gl_FragColor = vec4(finalColor, opacity);\n}\n`,Bu={baseSpeed:.01,axes:[0,1,0]};function Lu(e,t={}){const n=t.resolution||"4k",a=t.glowColor||[1,1,1],i=t.glowIntensity||1,r=t.materialVariant||null,s=t.assetBasePath||"/assets",o=`${s}/textures/Sun/sun-photosphere-${n}.jpg`,l=`${s}/textures/Sun/sun-photosphere-normal-${n}.jpg`,c=1+2*i,h=new Ia(c*a[0],c*a[1],c*a[2]*.95),d=new Map;d.set(o,{texture:null});const u=e.load(o,e=>{y.uniforms?.opacity&&(y.uniforms.opacity.value=1);const t=d.get(o);t&&(t.texture=e),d.delete(o)},void 0,e=>{console.warn(` Failed to load sun texture (${n}), using color fallback:`,e),d.delete(o)});d.set(l,{texture:null});const p=e.load(l,e=>{const t=d.get(l);t&&(t.texture=e),d.delete(l)},void 0,e=>{console.warn(` Sun normal map not found (${n}), continuing without surface detail:`,e),d.delete(l)});let m,f;u.wrapS=u.wrapT=N,p.wrapS=p.wrapT=N,u.anisotropy=16,p.anisotropy=16;let g={};if("multiplexer"===r){const{vertexShader:e,fragmentShader:t}={vertexShader:"\n/**\n * Sun Vertex Shader\n * Passes view-space position for camera-relative eclipse shadow calculations\n */\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;  // View-space position (camera-relative)\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalize(normalMatrix * normal);\n    vPosition = position;\n    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\n    // Calculate view-space position (camera-relative, always faces camera)\n    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n    vViewPosition = viewPos.xyz;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:Fu};m=e,f=t,g={eclipseProgress:{value:0},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:.882},shadowDarkness:{value:1},layer1Mode:{value:0},layer1Strength:{value:.23},layer1Enabled:{value:1},layer2Mode:{value:0},layer2Strength:{value:0},layer2Enabled:{value:0},layer3Mode:{value:0},layer3Strength:{value:0},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:0},layer4Enabled:{value:0}}}else m="\n            varying vec2 vUv;\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n\n            void main() {\n                vUv = uv;\n                vNormal = normalize(normalMatrix * normal);\n                vPosition = position;\n                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",f="\n            uniform float time;\n            uniform sampler2D colorMap;\n            uniform sampler2D normalMap;\n            uniform vec3 baseColor;\n            uniform float emissiveIntensity;\n            uniform vec2 shadowOffset;\n            uniform float shadowCoverage;\n            uniform float shadowSoftness;\n            uniform float opacity;  // Fade in opacity (0-1) to prevent texture flash\n\n            varying vec2 vUv;\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n\n            // Simplex noise for fire animation (Ashima Arts)\n            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n            float snoise(vec3 v) {\n                const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n                vec3 i  = floor(v + dot(v, C.yyy));\n                vec3 x0 = v - i + dot(i, C.xxx);\n\n                vec3 g = step(x0.yzx, x0.xyz);\n                vec3 l = 1.0 - g;\n                vec3 i1 = min(g.xyz, l.zxy);\n                vec3 i2 = max(g.xyz, l.zxy);\n\n                vec3 x1 = x0 - i1 + C.xxx;\n                vec3 x2 = x0 - i2 + C.yyy;\n                vec3 x3 = x0 - D.yyy;\n\n                i = mod289(i);\n                vec4 p = permute(permute(permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n                float n_ = 0.142857142857;\n                vec3 ns = n_ * D.wyz - D.xzx;\n\n                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n                vec4 x_ = floor(j * ns.z);\n                vec4 y_ = floor(j - 7.0 * x_);\n\n                vec4 x = x_ *ns.x + ns.yyyy;\n                vec4 y = y_ *ns.x + ns.yyyy;\n                vec4 h = 1.0 - abs(x) - abs(y);\n\n                vec4 b0 = vec4(x.xy, y.xy);\n                vec4 b1 = vec4(x.zw, y.zw);\n\n                vec4 s0 = floor(b0)*2.0 + 1.0;\n                vec4 s1 = floor(b1)*2.0 + 1.0;\n                vec4 sh = -step(h, vec4(0.0));\n\n                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n                vec3 p0 = vec3(a0.xy, h.x);\n                vec3 p1 = vec3(a0.zw, h.y);\n                vec3 p2 = vec3(a1.xy, h.z);\n                vec3 p3 = vec3(a1.zw, h.w);\n\n                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n                p0 *= norm.x;\n                p1 *= norm.y;\n                p2 *= norm.z;\n                p3 *= norm.w;\n\n                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                m = m * m;\n                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n            }\n\n            void main() {\n                // Sample base photosphere texture\n                vec4 texColor = texture2D(colorMap, vUv);\n\n                // Optimized single-octave noise for subtle fire (was 2 FBM calls with 3 octaves each)\n                // Using position-based noise with time offset for animation\n                vec3 noiseCoord = vPosition * 30.0 + vec3(0.0, time * 0.025, 0.0);\n                float fireNoise = snoise(noiseCoord);\n\n                // Simple threshold - fire appears only in specific noise ranges\n                // Using step functions instead of smoothstep for performance\n                float fireMask = fireNoise * 0.5 + 0.5; // Remap -1..1 to 0..1\n                fireMask = step(0.45, fireMask) * (1.0 - step(0.55, fireMask)); // Only 0.45-0.55 range\n\n                // Almost imperceptible warmth shift (same visual as before)\n                vec3 fireColor = vec3(1.01, 1.0, 0.99);\n\n                // Microscopic blending - nearly invisible (same blend factor)\n                vec3 finalColor = mix(texColor.rgb, fireColor, fireMask * 0.008);\n\n                // Apply base color tinting\n                finalColor *= baseColor;\n\n                // Apply emissive intensity for HDR bloom\n                finalColor *= emissiveIntensity;\n\n                // \n                // LIMB DARKENING (realistic solar effect - edges appear darker than center)\n                // \n\n                // Calculate distance from center (0 at center, 1 at edge)\n                float distFromCenterLimb = length(vWorldPosition.xy) / 0.5; // normalize by sun radius (0.5)\n                distFromCenterLimb = clamp(distFromCenterLimb, 0.0, 1.0);\n\n                // Limb darkening formula: I() = 1 - u*(1-) where  = cos(viewing angle)\n                // Simplified using distance: darker at edges, brighter at center\n                float mu = sqrt(1.0 - distFromCenterLimb * distFromCenterLimb); // cos approximation\n                float limbDarkeningCoeff = 0.6; // NASA solar data: ~60% darkening at limb\n                float limbBrightness = 1.0 - limbDarkeningCoeff * (1.0 - mu);\n\n                // Apply limb darkening (preserves bright core for bloom)\n                finalColor *= limbBrightness;\n\n                // \n                // SHADOW DARKENING (applied AFTER bloom intensity so it doesn't affect bloom)\n                // \n\n                // Sun sphere center (world space origin)\n                float sunRadius = 0.5; // Matches geometry radius\n\n                // Shadow sphere center (offset from sun center)\n                vec3 shadowCenter = vec3(shadowOffset.x, shadowOffset.y, 0.0);\n\n                // Calculate distance from fragment to shadow sphere center\n                float distToShadow = distance(vWorldPosition, shadowCenter);\n\n                // Shadow threshold (shadow sphere radius adjusted by coverage)\n                float shadowRadius = sunRadius * shadowCoverage;\n\n                // Calculate shadow factor (0 = full shadow, 1 = no shadow)\n                float shadowFactor = smoothstep(shadowRadius - shadowSoftness, shadowRadius + shadowSoftness, distToShadow);\n\n                // Darken ONLY the final color output (not the bloom calculation)\n                float shadowDarkness = 0.05; // How dark the shadow gets (5% brightness)\n                finalColor *= mix(shadowDarkness, 1.0, shadowFactor);\n\n                // \n                // RADIAL CORONA WAVES (applied AFTER shadow, visible around eclipse edge)\n                // \n\n                // Calculate angle from sun center in world space XY plane\n                float angle = atan(vWorldPosition.y, vWorldPosition.x);\n\n                // Create radial wave pattern (16 petals for finer detail, rotating slowly)\n                float wave = sin(angle * 16.0 + time * 0.3) * 0.5 + 0.5;\n\n                // Apply waves to visible (non-shadowed) edges\n                float distFromCenter = length(vWorldPosition.xy);\n\n                // Edge factor: strong at sun's edge where bloom will amplify it\n                float edgeFactor = smoothstep(0.35, 0.5, distFromCenter);\n\n                // Only apply waves to non-shadowed areas (visible during eclipse)\n                // Combine with shadow factor so waves appear around shadow edge\n                float waveStrength = edgeFactor * shadowFactor;\n\n                // Very strong modulation (2x variation) for dramatic eclipse corona\n                float coronaModulation = 1.0 + (wave * 2.0 - 1.0) * waveStrength;\n                finalColor *= coronaModulation;\n\n                // Apply fade-in opacity to prevent texture flash during load\n                gl_FragColor = vec4(finalColor, opacity);\n            }\n        ";const y=new bi({uniforms:{time:{value:0},colorMap:{value:u},normalMap:{value:p},baseColor:{value:h},emissiveIntensity:{value:1.2},glowColor:{value:new Ia(1,1,1)},glowIntensity:{value:1},shadowOffset:{value:new Vt(200,0)},shadowCoverage:{value:.5},shadowSoftness:{value:.1},opacity:{value:0},...g},vertexShader:m,fragmentShader:f,transparent:!0,toneMapped:!1});return y.userData.uniforms=y.uniforms,y.userData.pendingTextures=d,y}function Nu(e=null,t={}){const n=t.glowColor||[1,1,1],a=t.glowIntensity||1,i=t.resolution||"4k",r=t.materialVariant||null,s=new so(.5,128,128);let o;if(s.userData.tracked=!0,e)o=Lu(e,{glowColor:n,glowIntensity:a,resolution:i,materialVariant:r});else{const e=1+2*a,t=new Ia(e*n[0],e*n[1],e*n[2]*.95);o=new Fa({color:t,toneMapped:!1})}const l=new ui(s,o);return l.castShadow=!1,l.receiveShadow=!1,l}function Vu(e,t,n=1,a=0){if(!e||!e.material)return;const{material:i}=e;if(i.uniforms&&i.uniforms.baseColor){const{uniforms:e}=i;a>0&&(e.time.value=(e.time.value+a)%(2*Math.PI));const t=1+2*n;e.baseColor.value.setRGB(t,t,.95*t),e.emissiveIntensity.value=1.2}else if(i.color){const e=1+2*n;i.color.setRGB(e,e,.95*e)}}function Uu(e){if(e&&(e.geometry&&e.geometry.dispose(),e.material)){const{material:t}=e;t.userData&&t.userData.pendingTextures&&(t.userData.pendingTextures.forEach(({texture:e})=>{e&&e.dispose()}),t.userData.pendingTextures.clear()),t.uniforms&&(t.uniforms.colorMap&&t.uniforms.colorMap.value&&t.uniforms.colorMap.value.dispose(),t.uniforms.normalMap&&t.uniforms.normalMap.value&&t.uniforms.normalMap.value.dispose()),t.map&&t.map.dispose(),t.normalMap&&t.normalMap.dispose(),t.dispose()}}function Gu(){const e=new so(.5,32,32),t=e.attributes.position;for(let e=0;e<t.count;e++){let n=t.getX(e);const a=t.getY(e);let i=t.getZ(e);const r=1+.3*Math.max(0,a);if(n*=r,i*=.8*r,a<-.3){const e=(-a-.3)/.2;n*=1-.8*e,i*=1-.8*e}t.setXYZ(e,n,a,i)}return e.computeVertexNormals(),e}function Wu(){const e=new ns(.5,0);return e.computeVertexNormals(),e}function qu(){const e=new ei,t=[],n=[];t.push(0,2.3,0);for(let e=0;e<6;e++){const n=e/6*Math.PI*2;t.push(1*Math.cos(n),1.5,1*Math.sin(n))}for(let e=0;e<6;e++){const n=e/6*Math.PI*2;t.push(1*Math.cos(n),-1.5,1*Math.sin(n))}t.push(0,-2.3,0);for(let e=0;e<6;e++){const t=(e+1)%6;n.push(0,1+e,1+t)}for(let e=0;e<6;e++){const t=(e+1)%6;n.push(1+e,7+e,1+t),n.push(1+t,7+e,7+t)}for(let e=0;e<6;e++){const t=(e+1)%6;n.push(13,7+t,7+e)}e.setAttribute("position",new ja(t,3)),e.setIndex(n);const a=1.6/4.6;return e.scale(a,a,a),e.computeVertexNormals(),e}const Hu={moon:{geometry:Au(64,64),material:"custom",blink:{type:"gentle-pulse",duration:180,scaleAxis:[.95,.95,.95],glowBoost:.2,curve:"sine"},particleRadiusMultiplier:1.4},sun:{geometry:new so(.5,64,64),material:"emissive",blink:{type:"radial-pulse",duration:200,scaleAxis:[1.05,1.05,1.05],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.5},crystal:{geometry:null,geometryLoader:function(e="/assets"){return new Promise((t,n)=>{(new du).load(`${e}/models/Crystal/crystal.obj`,e=>{let n=null;if(e.traverse(e=>{e.isMesh&&e.geometry&&({geometry:n}=e)}),n){n.computeBoundingBox();const e=new Gt;n.boundingBox.getCenter(e),n.translate(-e.x,-e.y,-e.z);const a=new Gt;n.boundingBox.getSize(a);const i=1.6/Math.max(a.x,a.y,a.z);n.scale(i,i,i),n.attributes.normal||n.computeVertexNormals(),n.computeBoundingBox();const r=new Gt;n.boundingBox.getSize(r);let s=n;s.computeVertexNormals(),t(s)}else{console.warn(" [CRYSTAL] No mesh in OBJ, using fallback");const e=qu();t(e)}},e=>{},e=>{console.warn(" [CRYSTAL] OBJ load FAILED:",e);const n=qu();t(n)})})},material:"custom",blink:{type:"facet-flash",duration:160,scaleAxis:[.95,.95,.95],glowBoost:.4,curve:"sine"},particleRadiusMultiplier:1.4},rough:{geometry:null,geometryLoader:function(e="/assets"){return new Promise(t=>{(new du).load(`${e}/models/Crystal/rough.obj`,e=>{let n=null;if(e.traverse(e=>{e.isMesh&&e.geometry&&({geometry:n}=e)}),n){n.computeBoundingBox();const e=new Gt;n.boundingBox.getCenter(e),n.translate(-e.x,-e.y,-e.z);const a=new Gt;n.boundingBox.getSize(a);const i=1.6/Math.max(a.x,a.y,a.z);n.scale(i,i,i),n.computeVertexNormals(),n.computeBoundingBox(),t(n)}else console.warn(" [ROUGH] No mesh in OBJ, using fallback sphere"),t(new so(.5,32,32))},void 0,e=>{console.warn(" [ROUGH] OBJ load failed:",e),t(new so(.5,32,32))})})},material:"custom",blink:{type:"facet-flash",duration:150,scaleAxis:[.95,.95,.95],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.3},heart:{geometry:null,geometryLoader:function(e="/assets"){return new Promise(t=>{(new du).load(`${e}/models/Crystal/heart.obj`,e=>{let n=null;if(e.traverse(e=>{e.isMesh&&e.geometry&&({geometry:n}=e)}),n){n.computeBoundingBox();const e=new Gt;n.boundingBox.getCenter(e),n.translate(-e.x,-e.y,-e.z);const a=new Gt;n.boundingBox.getSize(a);const i=1.2/Math.max(a.x,a.y,a.z);n.scale(i,i,i),n.computeVertexNormals(),n.computeBoundingBox(),n.attributes.uv||function(e){e.computeBoundingBox();const t=e.boundingBox,n=e.attributes.position,a=new Float32Array(2*n.count),i=t.max.x-t.min.x,r=t.max.y-t.min.y;for(let e=0;e<n.count;e++){const s=n.getX(e),o=n.getY(e);a[2*e]=(s-t.min.x)/i,a[2*e+1]=(o-t.min.y)/r}e.setAttribute("uv",new Wa(a,2))}(n),t(n)}else console.warn(" [HEART] No mesh in OBJ, using fallback"),t(Gu())},void 0,e=>{console.warn(" [HEART] OBJ load failed:",e),t(Gu())})})},material:"custom",blink:{type:"gentle-pulse",duration:180,scaleAxis:[.92,.92,.92],glowBoost:.6,curve:"sine"},particleRadiusMultiplier:1.3},star:{geometry:null,geometryLoader:function(e="/assets"){return new Promise(t=>{(new du).load(`${e}/models/Crystal/star.obj`,e=>{let n=null;if(e.traverse(e=>{e.isMesh&&e.geometry&&({geometry:n}=e)}),n){n.computeBoundingBox();const e=new Gt;n.boundingBox.getCenter(e),n.translate(-e.x,-e.y,-e.z);const a=new Gt;n.boundingBox.getSize(a);const i=1.4/Math.max(a.x,a.y,a.z);n.scale(i,i,i),n.computeVertexNormals(),n.computeBoundingBox(),n.attributes.uv||function(e){e.computeBoundingBox();const t=e.boundingBox,n=e.attributes.position,a=new Float32Array(2*n.count),i=t.max.x-t.min.x,r=t.max.y-t.min.y;for(let e=0;e<n.count;e++){const s=n.getX(e),o=n.getY(e);a[2*e]=(s-t.min.x)/i,a[2*e+1]=(o-t.min.y)/r}e.setAttribute("uv",new Wa(a,2))}(n),t(n)}else console.warn(" [STAR] No mesh in OBJ, using fallback"),t(Wu())},void 0,e=>{console.warn(" [STAR] OBJ load failed:",e),t(Wu())})})},material:"custom",blink:{type:"facet-flash",duration:150,scaleAxis:[.93,.93,.93],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.4}};class ju{constructor(){this.currentAnimation=null,this.animations=[],this.time=0}playEmotion(e,t={}){const n=this.createEmotionAnimation(e);this.startAnimation(n,t)}playGesture(e,t={}){const n=this.createGestureAnimation(e);this.startAnimation(n,t)}playMorph(e,t,n={}){const a=this.createMorphAnimation(e,t);this.startAnimation(a,n)}update(e){this.time+=e;for(let e=this.animations.length-1;e>=0;e--){const t=this.animations[e],n=t.duration;Math.min((this.time-t.startTime)/n,1)>=1&&(t.callbacks&&t.callbacks.onComplete&&t.callbacks.onComplete(),this.animations.splice(e,1))}}createEmotionAnimation(e){const t={joy:{duration:.6,evaluate:e=>({scale:1+.15*Math.sin(e*Math.PI),glowIntensity:1+.15*Math.sin(e*Math.PI)})},love:{duration:1.2,evaluate:e=>({scale:1+.08*Math.sin(e*Math.PI*2),glowIntensity:1+.1*Math.sin(e*Math.PI*2)})},curiosity:{duration:.8,evaluate:e=>({rotation:[0,.1*Math.sin(e*Math.PI*4),0],scale:1+.05*Math.sin(e*Math.PI),glowIntensity:1})},sadness:{duration:1.5,evaluate:e=>({scale:1-.1*e,glowIntensity:1-.15*Math.sin(e*Math.PI)})},anger:{duration:.4,evaluate:e=>{const t=.15*Math.sin(e*Math.PI*8);return{rotation:[t,t,0],scale:1.1+.1*Math.sin(e*Math.PI),glowIntensity:1+.15*Math.sin(e*Math.PI*8)}}},fear:{duration:.5,evaluate:e=>{const t=.08*Math.sin(e*Math.PI*10);return{scale:.9+t,rotation:[t,0,t],glowIntensity:1+.1*Math.sin(e*Math.PI*10)}}},surprise:{duration:.4,evaluate:e=>({scale:1+.25*(1-Math.cos(e*Math.PI)),glowIntensity:1+.2*(1-Math.cos(e*Math.PI))})},neutral:{duration:.5,evaluate:e=>({scale:1,glowIntensity:1})}};return t[e]||t.neutral}createGestureAnimation(e){const t={pop:{duration:.2,isAccent:!0,evaluate:e=>({scaleBoost:1+.025*Math.sin(e*Math.PI)})},bob:{duration:.25,isAccent:!0,evaluate:e=>({rotationBoost:[.025*Math.sin(e*Math.PI),0,0]})},swell:{duration:.6,isAccent:!0,evaluate:e=>{const t=Math.sin(e*Math.PI),n=1-Math.pow(1-t,2);return{scaleBoost:1+.04*n,glowBoost:.3*n}}},swagger:{duration:.4,isAccent:!0,evaluate:e=>{const t=Math.sin(e*Math.PI);return{rotationBoost:[0,0,.04*t],positionBoost:[.01*t,0,0]}}},dip:{duration:.25,isAccent:!0,evaluate:e=>{const t=Math.sin(e*Math.PI);return{positionBoost:[0,.015*-t,0],scaleBoost:1-.015*t}}},flare:{duration:.3,isAccent:!0,evaluate:e=>{const t=Math.sin(e*Math.PI);return{scaleBoost:1+.03*t,glowBoost:.25*t}}},bounce:{duration:1,evaluate:e=>{const t=e*Math.PI*2,n=1-.6*e,a=Math.sin(t)*n,i=Math.sin(2*t)*n*.3,r=Math.max(0,a+i);return{position:[0,.35*r,0],scale:r>.5?1+.05*r:1-.08*r}}},pulse:{duration:.6,evaluate:e=>{const t=Math.sin(e*Math.PI);return{scale:1+.2*t,glowIntensity:1+.5*t}}},spin:{duration:1,evaluate:e=>({rotation:[0,e*Math.PI*2,0]})},wobble:{duration:1,evaluate:e=>{const t=Math.sin(e*Math.PI*3);return{rotation:[.3*t,0,.2*t]}}},float:{duration:2,evaluate:e=>({position:[0,.3*Math.sin(e*Math.PI),0]})},shake:{duration:.5,evaluate:e=>{const t=Math.sin(e*Math.PI*6)*(1-e);return{position:[.2*t,0,0],rotation:[0,0,.1*t]}}},nod:{duration:.5,evaluate:e=>{let t=0;if(e<.4){const n=e/.4;t=.12*Math.sin(n*Math.PI)}else if(e<.8){const n=(e-.4)/.4;t=.07*Math.sin(n*Math.PI)}return{cameraRelativePosition:[0,0,t],scale:1-.3*Math.abs(t),glowIntensity:1+.5*Math.abs(t)}}},wiggle:{duration:.4,evaluate:e=>{const t=Math.pow(1-e,.6),n=Math.sin(e*Math.PI*12)*t;return{cameraRelativePosition:[.04*n,0,0],scale:1+.03*Math.abs(n),glowIntensity:1+.1*Math.abs(n)}}},headBob:{duration:.3,evaluate:e=>{const t=e<.15?e/.15:Math.pow(1-(e-.15)/.85,2);return{cameraRelativePosition:[0,0,.08*t],position:[0,.015*-t,0],scale:1-.05*t,glowIntensity:1+.15*t}}},sway:{duration:1.2,evaluate:e=>{const t=e<.15?e/.15*e/.15:e>.85?Math.pow((1-e)/.15,2):1,n=Math.sin(e*Math.PI*2)*t;return{rotation:[0,0,.12*n],position:[.06*n,0,0]}}},jump:{duration:.6,evaluate:e=>({position:[0,.4*Math.sin(e*Math.PI),0],scale:e<.1?1-3*e:e>.9?1-3*(1-e):1})},twist:{duration:.5,evaluate:e=>({rotation:[0,Math.sin(e*Math.PI*2)*(1-.5*e)*.3,0]})},hula:{duration:1,evaluate:e=>{const t=e*Math.PI*2;return{position:[.05*Math.sin(t),0,.03*Math.cos(t)],rotation:[0,0,.05*Math.sin(t)]}}},lean:{duration:.6,evaluate:e=>{const t=Math.sin(e*Math.PI);return{rotation:[0,0,.15*t],position:[.04*t,.01*-Math.abs(t),0]}}},tilt:{duration:.5,evaluate:e=>{const t=Math.sin(e*Math.PI);return{position:[0,0,.05*t],rotation:[.08*t,0,0]}}},twitch:{duration:.2,evaluate:e=>{const t=(1-e)*Math.sin(e*Math.PI*6);return{rotation:[.03*t,.03*t,0]}}},flash:{duration:.3,evaluate:e=>{const t=e<.2?e/.2:1-(e-.2)/.8;return{glowIntensity:1+.4*t,scale:1+.03*t}}},glow:{duration:.8,evaluate:e=>{const t=Math.sin(e*Math.PI);return{glowIntensity:1+.25*t,scale:1+.02*t}}},burst:{duration:.6,evaluate:e=>{let t=0,n=1,a=1;if(e<.15){const i=e/.15,r=1-Math.pow(1-i,3);t=.15*r,n=1+.2*r,a=1+.5*r}else if(e<.35){const i=(e-.15)/.2;t=.15*(1-1.5*i),n=1+.2*(1-i)-.1*Math.sin(i*Math.PI),a=1+.4*(1-i)}else{const i=(e-.35)/.65,r=Math.pow(1-i,2),s=Math.sin(i*Math.PI*2)*r;t=.03*s,n=1+.05*s,a=1+.15*Math.abs(s)}return{cameraRelativePosition:[0,0,t],scale:n,glowIntensity:a}}},flicker:{duration:.6,evaluate:e=>{const t=Math.sin(e*Math.PI),n=Math.sin(e*Math.PI*4)*t;return{glowIntensity:1+.15*n,scale:1+.01*n}}}};return t[e]||t.pulse}createMorphAnimation(e,t){return{duration:1,fromShape:e,toShape:t,evaluate:e=>({morphProgress:e,scale:1+.1*Math.sin(e*Math.PI),rotation:[0,e*Math.PI*.5,0]})}}startAnimation(e,t){this.animations.push({...e,startTime:this.time,callbacks:t||{}}),this.currentAnimation=e}stopAll(){this.animations=[],this.currentAnimation=null}stopEmotions(){this.animations=this.animations.filter(e=>e.gestureName),this.currentAnimation=null}destroy(){this.stopAll(),this.animations=null,this.currentAnimation=null,this.time=0}easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}getIdleAnimation(){return{duration:3,loop:!0,evaluate:e=>{const t=Math.sin(e*Math.PI*2),n=Math.sin(e*Math.PI);return{scale:1+.02*t,position:[.05*n,.03*t,0],rotation:[0,.05*n,0],glowIntensity:1+.1*t}}}}isPlaying(){return this.animations.length>0}}class Xu{constructor(){this.breathingSpeed=1,this.breathingDepth=.03,this.breathingPhase=0,this.breathRate=1,this.breathDepth=.03,this.breathRateMult=1,this.breathDepthMult=1,this.rhythmAdapter=null,this.grooveBlendFactor=.4,this.emotionBreathPatterns={happy:{rate:1.1,depth:1.2},sad:{rate:.8,depth:.7},angry:{rate:1.4,depth:1.3},calm:{rate:.7,depth:.9},excited:{rate:1.5,depth:1.4},focused:{rate:.9,depth:.6},neutral:{rate:1,depth:1},love:{rate:1.2,depth:1.3},surprised:{rate:1.3,depth:1.1},confused:{rate:1.1,depth:.9},amused:{rate:1.2,depth:1.1},bored:{rate:.6,depth:.8},tired:{rate:.5,depth:1.2},anxious:{rate:1.6,depth:.9},determined:{rate:1.1,depth:1},proud:{rate:.9,depth:1.3},content:{rate:.8,depth:1},hopeful:{rate:1,depth:1.1},zen:{rate:.4,depth:1.5},intrigued:{rate:1.1,depth:.8},embarrassed:{rate:1.3,depth:.7},grateful:{rate:.9,depth:1.1},inspired:{rate:1,depth:1.3},silly:{rate:1.4,depth:1.2},sleepy:{rate:.3,depth:1.4}}}update(e,t,n=null){const a=this.emotionBreathPatterns[t]||{rate:1,depth:1};n&&n["3d"]&&n["3d"].scale?(this.breathRateMult=n["3d"].scale.breathRateMultiplier||1,this.breathDepthMult=n["3d"].scale.breathDepthMultiplier||1):(this.breathRateMult=1,this.breathDepthMult=1),this.breathRate=a.rate*this.breathRateMult,this.breathDepth=this.breathingDepth*a.depth*this.breathDepthMult;const i=this.breathingSpeed*this.breathRate*(e/1e3);this.breathingPhase+=i,this.breathingPhase>2*Math.PI&&(this.breathingPhase-=2*Math.PI)}setRhythmAdapter(e){this.rhythmAdapter=e}getBreathingScale(){const e=this.rhythmAdapter?.isPlaying?.()?this.grooveBlendFactor:1;return 1+Math.sin(this.breathingPhase)*this.breathDepth*e}setEmotion(e,t=null){const n=this.emotionBreathPatterns[e]||{rate:1,depth:1};t&&t["3d"]&&t["3d"].scale?(this.breathRateMult=t["3d"].scale.breathRateMultiplier||1,this.breathDepthMult=t["3d"].scale.breathDepthMultiplier||1):(this.breathRateMult=1,this.breathDepthMult=1),this.breathRate=n.rate*this.breathRateMult,this.breathDepth=this.breathingDepth*n.depth*this.breathDepthMult}reset(){this.breathingPhase=0,this.breathRate=1,this.breathDepth=this.breathingDepth,this.breathRateMult=1,this.breathDepthMult=1}getBreathingInfo(){return{phase:this.breathingPhase,rate:this.breathRate,depth:this.breathDepth,scale:this.getBreathingScale(),rateMult:this.breathRateMult,depthMult:this.breathDepthMult}}destroy(){this.emotionBreathPatterns=null,this.rhythmAdapter=null}}class Yu{constructor(){this.tempEuler=new Qn,this.tempQuat=new Ut,this.accumulatedRotationQuat=new Ut,this.finalQuaternion=new Ut,this.prevRotation=[0,0,0],this.hasValidPrevRotation=!1,this._crackTriggeredAnimations=new Set,this._accumulated={position:[0,0,0],rotationQuat:this.accumulatedRotationQuat,scale:1,nonUniformScale:[1,1,1],glowIntensity:1,glowBoost:0,glowColorOverride:null,electricOverlay:null,waterOverlay:null,fireOverlay:null,smokeOverlay:null,voidOverlay:null,iceOverlay:null,lightOverlay:null,poisonOverlay:null,earthOverlay:null,natureOverlay:null,meshOpacity:1,cameraRelativePosition:[0,0,0],cameraRelativeRotation:[0,0,0],positionBoost:[0,0,0],rotationBoost:[0,0,0],scaleBoost:1,hasAccentGestures:!1,hasAbsoluteGestures:!1,hasCameraRelativeGestures:!1,freezeRotation:0,freezeWobble:0,freezeGroove:0,freezeParticles:0,deformation:null,shatter:null,crack:null,crackTriggers:null,crackHealTrigger:!1,crackHealDuration:1500},this._result={position:null,rotation:[0,0,0],scale:1,nonUniformScale:null,glowIntensity:1,glowBoost:0,glowColorOverride:null,electricOverlay:null,waterOverlay:null,fireOverlay:null,smokeOverlay:null,voidOverlay:null,iceOverlay:null,lightOverlay:null,poisonOverlay:null,earthOverlay:null,natureOverlay:null,meshOpacity:1,cameraRelativePosition:null,cameraRelativeRotation:null,positionBoost:null,rotationBoost:null,scaleBoost:1,hasAccentGestures:!1,hasAbsoluteGestures:!1,hasCameraRelativeGestures:!1,freezeRotation:0,freezeWobble:0,freezeGroove:0,freezeParticles:0,deformation:null,shatter:null,crack:null,crackTriggers:null,crackHealTrigger:!1,crackHealDuration:1500,gestureQuaternion:null},this._finalNonUniformScale=[1,1,1]}_resetAccumulated(){const e=this._accumulated;e.position[0]=0,e.position[1]=0,e.position[2]=0,e.scale=1,e.nonUniformScale[0]=1,e.nonUniformScale[1]=1,e.nonUniformScale[2]=1,e.glowIntensity=1,e.glowBoost=0,e.glowColorOverride=null,e.electricOverlay=null,e.waterOverlay=null,e.fireOverlay=null,e.smokeOverlay=null,e.voidOverlay=null,e.iceOverlay=null,e.lightOverlay=null,e.poisonOverlay=null,e.earthOverlay=null,e.natureOverlay=null,e.meshOpacity=1,e.cameraRelativePosition[0]=0,e.cameraRelativePosition[1]=0,e.cameraRelativePosition[2]=0,e.cameraRelativeRotation[0]=0,e.cameraRelativeRotation[1]=0,e.cameraRelativeRotation[2]=0,e.positionBoost[0]=0,e.positionBoost[1]=0,e.positionBoost[2]=0,e.rotationBoost[0]=0,e.rotationBoost[1]=0,e.rotationBoost[2]=0,e.scaleBoost=1,e.hasAccentGestures=!1,e.hasAbsoluteGestures=!1,e.hasCameraRelativeGestures=!1,e.freezeRotation=0,e.freezeWobble=0,e.freezeGroove=0,e.freezeParticles=0,e.deformation=null,e.shatter=null,e.crack=null,e.crackTriggers=null,e.crackHealTrigger=!1,e.crackHealDuration=1500,this.accumulatedRotationQuat.identity()}blend(e,t,n,a,i){this._resetAccumulated();const r=this._accumulated;for(const n of e)if(n.evaluate){const e=t-n.startTime,a=n.duration,i=Math.min(e/a,1),s=n.evaluate(i);if(s){const e=.15,t=.85;let a=1;if(i<e){const t=i/e;a=t*t*(3-2*t)}else if(i>t){const e=(i-t)/(1-t);a=1-e*e*(3-2*e)}if(!0===n.isAccent?r.hasAccentGestures=!0:(s.position||s.rotation||void 0!==s.scale)&&(r.hasAbsoluteGestures=!0),s.position&&(r.position[0]+=s.position[0]*a,r.position[1]+=s.position[1]*a,r.position[2]+=s.position[2]*a),s.rotation&&(this.tempEuler.set(s.rotation[0]*a,s.rotation[1]*a,s.rotation[2]*a,"XYZ"),this.tempQuat.setFromEuler(this.tempEuler),r.rotationQuat.multiply(this.tempQuat)),void 0!==s.scale)if(Array.isArray(s.scale)){const e=1+(s.scale[0]-1)*a,t=1+(s.scale[1]-1)*a,n=1+(s.scale[2]-1)*a;r.nonUniformScale[0]*=e,r.nonUniformScale[1]*=t,r.nonUniformScale[2]*=n}else{const e=1+(s.scale-1)*a;r.scale*=e}if(void 0!==s.glowIntensity){const e=1+(s.glowIntensity-1)*a;r.glowIntensity*=e}if(void 0!==s.glowBoost&&(r.glowBoost+=s.glowBoost*a),s.glowColorOverride&&(r.glowColorOverride=s.glowColorOverride),s.electricOverlay&&s.electricOverlay.enabled&&(!r.electricOverlay||s.electricOverlay.charge>r.electricOverlay.charge)&&(r.electricOverlay={...s.electricOverlay}),s.waterOverlay&&s.waterOverlay.enabled&&(!r.waterOverlay||s.waterOverlay.wetness>r.waterOverlay.wetness)&&(r.waterOverlay={...s.waterOverlay}),s.fireOverlay&&s.fireOverlay.enabled&&(!r.fireOverlay||s.fireOverlay.heat>r.fireOverlay.heat)&&(r.fireOverlay={...s.fireOverlay}),s.smokeOverlay&&s.smokeOverlay.enabled&&(!r.smokeOverlay||s.smokeOverlay.thickness>r.smokeOverlay.thickness)&&(r.smokeOverlay={...s.smokeOverlay}),s.voidOverlay&&s.voidOverlay.enabled&&(!r.voidOverlay||s.voidOverlay.strength>r.voidOverlay.strength)&&(r.voidOverlay={...s.voidOverlay}),s.iceOverlay&&s.iceOverlay.enabled&&(!r.iceOverlay||s.iceOverlay.strength>r.iceOverlay.strength)&&(r.iceOverlay={...s.iceOverlay}),s.lightOverlay&&s.lightOverlay.enabled&&(!r.lightOverlay||s.lightOverlay.strength>r.lightOverlay.strength)&&(r.lightOverlay={...s.lightOverlay}),s.poisonOverlay&&s.poisonOverlay.enabled&&(!r.poisonOverlay||s.poisonOverlay.strength>r.poisonOverlay.strength)&&(r.poisonOverlay={...s.poisonOverlay}),s.earthOverlay&&s.earthOverlay.enabled&&(!r.earthOverlay||s.earthOverlay.strength>r.earthOverlay.strength)&&(r.earthOverlay={...s.earthOverlay}),s.natureOverlay&&s.natureOverlay.enabled&&(!r.natureOverlay||s.natureOverlay.strength>r.natureOverlay.strength)&&(r.natureOverlay={...s.natureOverlay}),void 0!==s.meshOpacity&&(r.meshOpacity=Math.min(r.meshOpacity,s.meshOpacity)),s.positionBoost&&(r.positionBoost[0]+=s.positionBoost[0],r.positionBoost[1]+=s.positionBoost[1],r.positionBoost[2]+=s.positionBoost[2]),s.rotationBoost&&(r.rotationBoost[0]+=s.rotationBoost[0],r.rotationBoost[1]+=s.rotationBoost[1],r.rotationBoost[2]+=s.rotationBoost[2]),void 0!==s.scaleBoost&&(r.scaleBoost*=s.scaleBoost),s.cameraRelativePosition&&(r.cameraRelativePosition[0]+=s.cameraRelativePosition[0]*a,r.cameraRelativePosition[1]+=s.cameraRelativePosition[1]*a,r.cameraRelativePosition[2]+=s.cameraRelativePosition[2]*a,r.hasCameraRelativeGestures=!0),s.cameraRelativeRotation&&(r.cameraRelativeRotation[0]+=s.cameraRelativeRotation[0]*a,r.cameraRelativeRotation[1]+=s.cameraRelativeRotation[1]*a,r.cameraRelativeRotation[2]+=s.cameraRelativeRotation[2]*a,r.hasCameraRelativeGestures=!0),void 0!==s.freezeRotation&&(r.freezeRotation=Math.max(r.freezeRotation,s.freezeRotation*a)),void 0!==s.freezeWobble&&(r.freezeWobble=Math.max(r.freezeWobble,s.freezeWobble*a)),void 0!==s.freezeGroove&&(r.freezeGroove=Math.max(r.freezeGroove,s.freezeGroove*a)),void 0!==s.freezeParticles&&(r.freezeParticles=Math.max(r.freezeParticles,s.freezeParticles*a)),s.deformation&&s.deformation.enabled){const e=s.deformation;(!r.deformation||e.strength>r.deformation.strength)&&(r.deformation={...e})}if(s.shatter&&(s.shatter.enabled&&!r.shatter&&(r.shatter={...s.shatter}),s.shatter.reassemble&&(r.shatter||(r.shatter={enabled:!1}),r.shatter.reassemble=!0,r.shatter.reassembleDuration=s.shatter.reassembleDuration||1e3)),s.crack){const e=s.crack;if(e.enabled&&e.trigger){const t=n.startTime;this._crackTriggeredAnimations.has(t)||(this._crackTriggeredAnimations.add(t),r.crackTriggers||(r.crackTriggers=[]),r.crackTriggers.push({screenOffset:e.screenOffset,screenDirection:e.screenDirection,propagation:e.propagation,amount:e.amount,glowStrength:e.glowStrength}))}if(e.heal&&e.healTrigger){const t=n.startTime;this._crackTriggeredAnimations.has(t)||(this._crackTriggeredAnimations.add(t),r.crackHealTrigger=!0,r.crackHealDuration=e.healDuration||1500)}e.enabled&&(r.crack={...e})}}}r.scaleBoost=Math.max(.85,Math.min(1.15,r.scaleBoost)),r.glowBoost=Math.min(.5,r.glowBoost);for(let e=0;e<3;e++)r.positionBoost[e]=Math.max(-.05,Math.min(.05,r.positionBoost[e]));for(let e=0;e<3;e++)r.rotationBoost[e]=Math.max(-.1,Math.min(.1,r.rotationBoost[e]));this.tempEuler.setFromQuaternion(r.rotationQuat,"XYZ");const s=this.tempEuler.x,o=this.tempEuler.y,l=this.tempEuler.z,c=[n[0]+s,n[1]+o,n[2]+l],h=new Set(e.map(e=>e.startTime));for(const e of this._crackTriggeredAnimations)h.has(e)||this._crackTriggeredAnimations.delete(e);const d=a*r.scale,u=i*r.glowIntensity;let p=null;(1!==r.nonUniformScale[0]||1!==r.nonUniformScale[1]||1!==r.nonUniformScale[2])&&(this._finalNonUniformScale[0]=d*r.nonUniformScale[0],this._finalNonUniformScale[1]=d*r.nonUniformScale[1],this._finalNonUniformScale[2]=d*r.nonUniformScale[2],p=this._finalNonUniformScale);const m=this._result;return m.position=r.position,m.rotation[0]=c[0],m.rotation[1]=c[1],m.rotation[2]=c[2],m.scale=d,m.nonUniformScale=p,m.glowIntensity=u,m.glowBoost=r.glowBoost,m.glowColorOverride=r.glowColorOverride,m.electricOverlay=r.electricOverlay,m.waterOverlay=r.waterOverlay,m.fireOverlay=r.fireOverlay,m.smokeOverlay=r.smokeOverlay,m.voidOverlay=r.voidOverlay,m.iceOverlay=r.iceOverlay,m.lightOverlay=r.lightOverlay,m.poisonOverlay=r.poisonOverlay,m.earthOverlay=r.earthOverlay,m.natureOverlay=r.natureOverlay,m.meshOpacity=r.meshOpacity,m.cameraRelativePosition=r.cameraRelativePosition,m.cameraRelativeRotation=r.cameraRelativeRotation,m.positionBoost=r.positionBoost,m.rotationBoost=r.rotationBoost,m.scaleBoost=r.scaleBoost,m.hasAccentGestures=r.hasAccentGestures,m.hasAbsoluteGestures=r.hasAbsoluteGestures,m.hasCameraRelativeGestures=r.hasCameraRelativeGestures,m.freezeRotation=r.freezeRotation,m.freezeWobble=r.freezeWobble,m.freezeGroove=r.freezeGroove,m.freezeParticles=r.freezeParticles,m.deformation=r.deformation,m.shatter=r.shatter,m.crack=r.crack,m.crackTriggers=r.crackTriggers,m.crackHealTrigger=r.crackHealTrigger,m.crackHealDuration=r.crackHealDuration,m.gestureQuaternion=r.rotationQuat,m}resetSmoothing(){this.hasValidPrevRotation=!1,this.prevRotation&&(this.prevRotation[0]=0,this.prevRotation[1]=0,this.prevRotation[2]=0)}destroy(){this.tempEuler=null,this.tempQuat=null,this.accumulatedRotationQuat=null,this.finalQuaternion=null,this.prevRotation=null}}const $u=new Map;var Qu=function(e){return $u.get(e)||null},Ku=function(){return Array.from($u.keys())},Zu={name:"suspicion",emoji:"",description:"Paranoid watchfulness with surveillance scanning",visual:{glowColor:"#6B46C1",particleRate:4,minParticles:6,maxParticles:12,particleBehavior:"surveillance",particleSpeed:.2,breathRate:.6,breathDepth:.04,coreJitter:.02,blinkRate:1.1,blinkSpeed:1,particleColors:[{color:"#6B46C1",weight:30},{color:"#4A5568",weight:25},{color:"#8B4789",weight:20},{color:"#9F7AEA",weight:15},{color:"#2D3748",weight:10}],threatLevel:0,getGlowIntensity(){return.3+.7*this.threatLevel},getParticleSpeed(){return.2+.8*this.threatLevel},getGlowColor(){const e=this.threatLevel||0,t=Math.round(107+113*e),n=Math.round(70+-32*e),a=Math.round(193+-66*e),i=e=>e.toString(16).padStart(2,"0");return`#${i(t)}${i(n)}${i(a)}`}},modifiers:{speed:.4,amplitude:.6,intensity:1.2,smoothness:.3,regularity:.2,focus:1.5,addWobble:!0},typicalGestures:["scan","twitch","peek","tilt","hold"],transitions:{duration:500,easing:"linear",priority:4},special:{coreSquint:.6,scanInterval:2e3,scanDuration:1200,scanAngle:60,twitchChance:.02,peekInterval:4e3,maxThreatDistance:300,alertThreshold:.7},"3d":{rotation:{type:"suspicious",speed:1,axes:[0,0,0],musicSync:!1},glow:{color:"#6B46C1",intensity:.85,pulse:{speed:.6,range:[.7,1]}},scale:{base:1,breathe:{enabled:!0,depth:.04,rate:.6}}},soulAnimation:{driftSpeed:.9,shimmerSpeed:1.8,turbulence:.4},rhythmModifiers:{windowMultiplier:.9,visualNoise:.3,inputDelay:0,tempoShift:0}},Ju={name:"calm",emoji:"",description:"Serene, peaceful state with gentle movements",visual:{glowColor:"#66D9CC",particleRate:6,minParticles:10,maxParticles:50,particleBehavior:"zen",breathRate:.4,breathDepth:.12,coreJitter:!1,blinkRate:.8,blinkSpeed:1,particleColors:[{color:"#66D9CC",weight:35},{color:"#99E6D9",weight:25},{color:"#40BFB3",weight:20},{color:"#B3F2E6",weight:15},{color:"#339980",weight:5}]},modifiers:{speed:.5,amplitude:.3,intensity:.4,smoothness:2,regularity:1.5,addWeight:!1,floatHeight:.2,swayAmount:.15,duration:1.5},typicalGestures:["breathe","float","drift","idle"],transitions:{duration:800,easing:"easeInOutSine",priority:1},movement:{floatPattern:"sine_slow",floatPeriod:6e3,floatAmplitude:8,swayPattern:"gentle",swayPeriod:8e3,swayAmplitude:5,microMovements:!1},getCoreParams(e){const t=e.time||Date.now(),n=.5*Math.sin(6e-4*t)+.5;return{scaleX:1-.02*n,scaleY:1-.02*n,eyeOpenness:.85,eyeExpression:"serene",pupilOffset:{x:2*Math.sin(3e-4*t),y:1*Math.cos(4e-4*t)},glowPulse:.95+.05*n}},updateParticle(e,t){e.x+=.1*Math.sin(.001*e.life),e.y-=.02*t,e.opacity=.3*Math.sin(.002*e.life)+.2,e.size=e.baseSize*(1+.2*Math.sin(.001*e.life))},renderCore:(e,t,n,a)=>!1,"3d":{rotation:{type:"gentle",speed:.5,axes:[0,.3,0],musicSync:!0},glow:{color:"#66D9CC",intensity:.6,pulse:{speed:.4,range:[.5,.7]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.4}}},soulAnimation:{driftSpeed:.3,shimmerSpeed:.4,turbulence:.1},rhythmModifiers:{windowMultiplier:1.2,visualNoise:0,inputDelay:0,tempoShift:0}};const ep=new Map,tp={happy:"joy",peaceful:"calm",curious:"surprise",frustrated:"anger",sad:"sadness",excitement:"excited"};function np(e){const t=tp[e]||e,n=ep.get(t);if(n)return n;return Qu(t)||null}function ap(e){const t=np(e);if(!t)return np("neutral").visual;if(!t.visual)return{};const{visual:n}=t,a={};for(const e in n)"function"!=typeof n[e]&&(a[e]=n[e]);return"function"==typeof n.getGlowIntensity&&(a.glowIntensity=n.getGlowIntensity()),"function"==typeof n.getParticleSpeed&&(a.particleSpeed=n.getParticleSpeed()),"function"==typeof n.getParticleRate&&(a.particleRate=n.getParticleRate()),"function"==typeof n.getGlowColor&&(a.glowColor=n.getGlowColor()),a}function ip(e){const t=np(e);return t?t.modifiers:np("neutral").modifiers}function rp(){return[...Array.from(ep.keys()),...Ku()]}function sp(e,t){const n=np(e),a=np(t);return n&&a?a.transitions&&a.transitions[e]?a.transitions[e]:{duration:1e3,easing:"ease-in-out",gesture:a.transitions?.defaultGesture||null}:{duration:1e3,easing:"ease-in-out"}}[{name:"neutral",emoji:"",description:"Calm, balanced emotional state",visual:{glowColor:"#00BCD4",particleRate:2,minParticles:8,maxParticles:10,particleBehavior:"ambient",breathRate:1,breathDepth:.08,coreJitter:!1,blinkRate:1,blinkSpeed:1,particleColors:[{color:"#00BCD4",weight:25},{color:"#00ACC1",weight:20},{color:"#26C6DA",weight:15},{color:"#B2EBF2",weight:15},{color:"#0097A7",weight:10},{color:"#80DEEA",weight:10},{color:"#E0F7FA",weight:5}]},modifiers:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1},typicalGestures:["breathe","float","idle","blink"],transitions:{duration:500,easing:"easeInOut",priority:0},getCoreParams:e=>({scaleX:1,scaleY:1,eyeOpenness:1,eyeExpression:"neutral",pupilOffset:{x:0,y:0}}),renderCore:(e,t,n,a)=>!1,"3d":{rotation:{type:"gentle",speed:1,axes:[0,.3,0],musicSync:!1},glow:{color:"#00BCD4",intensity:.9,pulse:{speed:1,range:[.8,1]}},scale:{base:1,breathe:{enabled:!0,depth:.08,rate:1}}},soulAnimation:{driftSpeed:.5,shimmerSpeed:.5,turbulence:.2},rhythmModifiers:{windowMultiplier:1,visualNoise:0,inputDelay:0,tempoShift:0}},{name:"joy",emoji:"",description:"Playful happiness and celebration",visual:{glowColor:"#FFEB3B",particleRate:8,minParticles:0,maxParticles:50,particleBehavior:"popcorn",breathRate:1.5,breathDepth:.1,coreJitter:!1,blinkRate:1.3,blinkSpeed:1.1,particleColors:[{color:"#FFEB3B",weight:25},{color:"#FFC107",weight:20},{color:"#FFFF00",weight:15},{color:"#FFD700",weight:15},{color:"#FFF59D",weight:10},{color:"#FF9800",weight:10},{color:"#FFFDE7",weight:5}]},modifiers:{speed:1.8,amplitude:1.9,intensity:1.1,smoothness:1,regularity:.9,addBounce:!0},typicalGestures:["bounce","spin","wave","expand","shake","float"],transitions:{duration:400,easing:"easeOutBack",priority:5,burstOnEntry:!0},getCoreParams:e=>({scaleX:1,scaleY:1,eyeOpenness:1,eyeExpression:"happy",pupilOffset:{x:0,y:-.1},sparkle:!0}),"3d":{rotation:{type:"rhythmic",speed:1.8,axes:[0,.3,0],musicSync:!0},glow:{color:"#FFEB3B",intensity:1.6,pulse:{speed:1.5,range:[1.2,1.8]}},scale:{base:1,breathe:{enabled:!0,depth:.1,rate:1.5}}},soulAnimation:{driftSpeed:1.2,shimmerSpeed:1.5,turbulence:.3},rhythmModifiers:{windowMultiplier:1.3,visualNoise:0,inputDelay:0,tempoShift:0}},{name:"sadness",emoji:"",description:"Deep melancholic sorrow",visual:{glowColor:"#4169E1",particleRate:6,minParticles:0,maxParticles:50,particleBehavior:"falling",breathRate:.6,breathDepth:.12,coreJitter:!1,blinkRate:.6,blinkSpeed:.8,particleColors:[{color:"#4169E1",weight:25},{color:"#1E90FF",weight:20},{color:"#6495ED",weight:15},{color:"#B0C4DE",weight:15},{color:"#191970",weight:10},{color:"#87CEEB",weight:10},{color:"#2F4F4F",weight:5}]},modifiers:{speed:.7,amplitude:.6,intensity:.8,smoothness:1.3,regularity:1.1,addGravity:!0},typicalGestures:["droop","sway","contract","drift","sink"],transitions:{duration:800,easing:"easeInOut",priority:3},"3d":{rotation:{type:"gentle",speed:.7,axes:[0,.2,0],musicSync:!1},glow:{color:"#4169E1",intensity:.65,pulse:{speed:.6,range:[.5,.8]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.6}}},soulAnimation:{driftSpeed:.2,shimmerSpeed:.3,turbulence:.1},rhythmModifiers:{windowMultiplier:1,visualNoise:0,inputDelay:45,tempoShift:0}},{name:"anger",emoji:"",description:"Intense rage and aggression",visual:{glowColor:"#DC143C",particleRate:8,minParticles:8,maxParticles:50,particleBehavior:"aggressive",breathRate:2.2,breathDepth:.15,coreJitter:!0,blinkRate:1.6,blinkSpeed:1.3,particleColors:[{color:"#DC143C",weight:25},{color:"#FF0000",weight:20},{color:"#B22222",weight:15},{color:"#FF4500",weight:15},{color:"#8B0000",weight:10},{color:"#FF6347",weight:10},{color:"#660000",weight:5}]},modifiers:{speed:1.5,amplitude:1.4,intensity:1.3,smoothness:.3,regularity:.7,addShake:!0},typicalGestures:["shake","vibrate","expand","pulse","flicker","strike"],transitions:{duration:300,easing:"easeOutExpo",priority:8,shakeOnEntry:!0},special:{screenShake:!0,particleTrails:"fire",glowPulse:!0,temperatureEffect:"hot"},"3d":{rotation:{type:"unstable",speed:1.5,axes:[0,.3,0],shake:{amplitude:.02,frequency:7},eruption:{enabled:!0,interval:3e3,speedMultiplier:3.5,duration:400},musicSync:!1},glow:{color:"#DC143C",intensity:1.8,pulse:{speed:2.2,range:[.8,2]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:2.2}}},soulAnimation:{driftSpeed:2,shimmerSpeed:.8,turbulence:.8},rhythmModifiers:{windowMultiplier:.75,visualNoise:0,inputDelay:0,tempoShift:0}},{name:"fear",emoji:"",description:"Anxious state with fleeing particles",visual:{glowColor:"#8A2BE2",particleRate:8,minParticles:8,maxParticles:50,particleBehavior:"scattering",breathRate:2.5,breathDepth:.06,coreJitter:!0,blinkRate:1.7,blinkSpeed:1.4,particleColors:[{color:"#8A2BE2",weight:25},{color:"#4B0082",weight:20},{color:"#9400D3",weight:15},{color:"#6B46C1",weight:15},{color:"#9932CC",weight:10},{color:"#E6E6FA",weight:8},{color:"#301934",weight:7}]},modifiers:{speed:1.4,amplitude:.8,intensity:1.2,smoothness:.5,regularity:.5,addJitter:!0},typicalGestures:["shake","vibrate","contract","flicker","retreat"],transitions:{duration:400,easing:"easeOut",priority:7},"3d":{rotation:{type:"unstable",speed:1.4,axes:[0,.3,0],shake:{amplitude:.015,frequency:3.5},musicSync:!1},glow:{color:"#8A2BE2",intensity:.9,pulse:{speed:2.5,range:[.6,1.2]}},scale:{base:1,breathe:{enabled:!0,depth:.06,rate:2.5}}},soulAnimation:{driftSpeed:1.8,shimmerSpeed:2.5,turbulence:.6},rhythmModifiers:{windowMultiplier:1,visualNoise:.6,inputDelay:0,tempoShift:0}},{name:"surprise",emoji:"",description:"Sudden shock with explosive particles",visual:{glowColor:"#FFD700",particleRate:5,minParticles:0,maxParticles:15,particleBehavior:"burst",breathRate:.3,breathDepth:.18,coreJitter:!1,blinkRate:1.4,blinkSpeed:1.2,particleColors:[{color:"#FFD700",weight:25},{color:"#FFA500",weight:20},{color:"#FFFF00",weight:15},{color:"#FF6347",weight:15},{color:"#FFE4B5",weight:10},{color:"#FF4500",weight:10},{color:"#FFFACD",weight:5}]},modifiers:{speed:1.6,amplitude:1.5,intensity:1.4,smoothness:.7,regularity:.8,addPop:!0},typicalGestures:["expand","bounce","flash","pulse","pop"],transitions:{duration:200,easing:"easeOutBack",priority:6},"3d":{rotation:{type:"unstable",speed:1.6,axes:[0,.45,0],shake:{amplitude:.01,frequency:3},musicSync:!1},glow:{color:"#FFD700",intensity:1.8,pulse:{speed:.3,range:[1,2.2]}},scale:{base:1,breathe:{enabled:!0,depth:.18,rate:.3}}},soulAnimation:{driftSpeed:1.5,shimmerSpeed:2,turbulence:.5},rhythmModifiers:{windowMultiplier:2,visualNoise:0,inputDelay:0,tempoShift:0}},{name:"disgust",emoji:"",description:"Revulsion with repelling particles",visual:{glowColor:"#9ACD32",particleRate:4,minParticles:5,maxParticles:12,particleBehavior:"repelling",breathRate:.7,breathDepth:.04,coreJitter:!1,blinkRate:.9,blinkSpeed:.9,particleColors:[{color:"#9ACD32",weight:25},{color:"#ADFF2F",weight:20},{color:"#7FFF00",weight:15},{color:"#BDB76B",weight:15},{color:"#6B8E23",weight:10},{color:"#CCFF00",weight:8},{color:"#556B2F",weight:7}]},modifiers:{speed:.9,amplitude:.7,intensity:.9,smoothness:.8,regularity:1,addRecoil:!0},typicalGestures:["contract","shake","recoil","wobble"],transitions:{duration:600,easing:"easeIn",priority:4},"3d":{rotation:{type:"gentle",speed:.9,axes:[0,.25,0],musicSync:!1},glow:{color:"#9ACD32",intensity:1,pulse:{speed:.7,range:[.7,1.2]}},scale:{base:1,breathe:{enabled:!0,depth:.04,rate:.7}}},soulAnimation:{driftSpeed:.4,shimmerSpeed:.6,turbulence:.35},rhythmModifiers:{windowMultiplier:.85,visualNoise:.2,inputDelay:0,tempoShift:0}},{name:"love",emoji:"",description:"Warm affection with orbiting particles",visual:{glowColor:"#FF1493",particleRate:6,minParticles:15,maxParticles:50,particleBehavior:"orbiting",breathRate:.75,breathDepth:.15,coreJitter:!1,blinkRate:1.2,blinkSpeed:1,particleColors:[{color:"#FF1493",weight:30},{color:"#FF69B4",weight:25},{color:"#FF007F",weight:15},{color:"#FFB6C1",weight:10},{color:"#FF45A0",weight:10},{color:"#E91E63",weight:5},{color:"#FFC0CB",weight:5}]},modifiers:{speed:.9,amplitude:1.1,intensity:1.2,smoothness:1.4,regularity:1.2,addWarmth:!0},typicalGestures:["pulse","sway","orbit","glow","breathe","float"],transitions:{duration:700,easing:"easeInOut",priority:5},"3d":{rotation:{type:"gentle",speed:.9,axes:[0,.28,0],musicSync:!0},glow:{color:"#FF1493",intensity:1.8,pulse:{speed:.75,range:[1.3,2]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:.75}}},soulAnimation:{driftSpeed:.8,shimmerSpeed:1.2,turbulence:.2},rhythmModifiers:{windowMultiplier:1.15,visualNoise:0,inputDelay:0,tempoShift:0}},Zu,{name:"excited",emoji:"",description:"High energy with rapid particles",visual:{glowColor:"#FF6B35",particleRate:8,minParticles:10,maxParticles:50,particleBehavior:"burst",breathRate:2,breathDepth:.14,coreJitter:!0,blinkRate:1.5,blinkSpeed:1.2,particleColors:[{color:"#FF6B35",weight:25},{color:"#FF1744",weight:20},{color:"#FFC107",weight:15},{color:"#FF9100",weight:15},{color:"#FFEB3B",weight:10},{color:"#FF5722",weight:10},{color:"#FFF59D",weight:5}]},modifiers:{speed:1.4,amplitude:1.3,intensity:1.3,smoothness:.8,regularity:.7,addVibration:!0},typicalGestures:["bounce","spin","vibrate","expand","shake","pulse"],transitions:{duration:300,easing:"easeOutElastic",priority:6},"3d":{rotation:{type:"unstable",speed:1.4,axes:[0,.4,0],shake:{amplitude:.01,frequency:4},musicSync:!1},glow:{color:"#FF6B35",intensity:1.5,pulse:{speed:2,range:[1,1.8]}},scale:{base:1,breathe:{enabled:!0,depth:.14,rate:2}}},soulAnimation:{driftSpeed:1.5,shimmerSpeed:2,turbulence:.5},rhythmModifiers:{windowMultiplier:1.2,visualNoise:.1,inputDelay:0,tempoShift:0}},{name:"resting",emoji:"",description:"Deep relaxation with slow drift",visual:{glowColor:"#9370DB",particleRate:1,minParticles:3,maxParticles:5,particleBehavior:"resting",breathRate:.8,breathDepth:.12,coreJitter:!1,blinkRate:.4,blinkSpeed:.7,particleColors:[{color:"#9370DB",weight:30},{color:"#A591C4",weight:20},{color:"#B366FF",weight:20},{color:"#B8A1E6",weight:15},{color:"#674D9B",weight:15}]},modifiers:{speed:.5,amplitude:.4,intensity:.5,smoothness:1.4,regularity:.9,addWeight:!0},typicalGestures:["breathe","drift","sway","float"],transitions:{duration:1e3,easing:"easeInOut",priority:2},"3d":{rotation:{type:"gentle",speed:.5,axes:[0,.15,0],musicSync:!1},glow:{color:"#9370DB",intensity:.8,pulse:{speed:.8,range:[.6,1]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.8}}},soulAnimation:{driftSpeed:.15,shimmerSpeed:.1,turbulence:.05},rhythmModifiers:{windowMultiplier:1.1,visualNoise:0,inputDelay:0,tempoShift:0}},{name:"euphoria",emoji:"",description:"Radiant hope and new beginnings",visual:{glowColor:"#FFB6C1",particleRate:6,minParticles:15,maxParticles:30,particleBehavior:"radiant",breathRate:1.3,breathDepth:.25,coreJitter:!1,blinkRate:1.4,blinkSpeed:1.1,particleColors:[{color:"#FFB6C1",weight:20},{color:"#FFD700",weight:18},{color:"#87CEEB",weight:15},{color:"#DDA0DD",weight:15},{color:"#98FB98",weight:12},{color:"#FFA07A",weight:10},{color:"#E6E6FA",weight:8},{color:"#FFFFFF",weight:2}]},modifiers:{speed:1.4,amplitude:1.5,intensity:1.6,smoothness:1.3,regularity:.8,addWarmth:!0,addLift:!0},typicalGestures:["expand","radiate","pulse","glow","float","bloom"],transitions:{duration:600,easing:"easeOutExpo",priority:8},"3d":{rotation:{type:"rhythmic",speed:1.4,axes:[0,.35,0],musicSync:!0},glow:{color:"#FFB6C1",intensity:1.2,pulse:{speed:1.3,range:[.9,1.5]}},scale:{base:1,breathe:{enabled:!0,depth:.25,rate:1.3}}},soulAnimation:{driftSpeed:1.8,shimmerSpeed:2.5,turbulence:.7},rhythmModifiers:{windowMultiplier:1.5,visualNoise:0,inputDelay:0,tempoShift:0}},{name:"focused",emoji:"",description:"Intense concentration with directed flow",visual:{glowColor:"#00CED1",particleRate:4,minParticles:5,maxParticles:12,particleBehavior:"directed",breathRate:1.2,breathDepth:.08,coreJitter:!0,blinkRate:.7,blinkSpeed:1,particleColors:[{color:"#00CED1",weight:30},{color:"#4A9FA0",weight:20},{color:"#00FFFF",weight:20},{color:"#5FE5E7",weight:15},{color:"#006B6D",weight:15}],eyeOpenness:.7,microAdjustments:!0},modifiers:{speed:1,amplitude:.9,intensity:1.1,smoothness:1.1,regularity:1.2,addPrecision:!0},typicalGestures:["track","lock","scan","pulse","vibrate"],transitions:{duration:400,easing:"easeIn",priority:5},getCoreParams:e=>({scaleX:1.1,scaleY:.7,eyeOpenness:.7,eyeExpression:"focused",pupilOffset:{x:0,y:0},microAdjustments:!0}),"3d":{rotation:{type:"still",speed:.5,axes:[0,.1,0],musicSync:!1},glow:{color:"#00CED1",intensity:1.2,pulse:{speed:1.2,range:[1,1.3]}},scale:{base:1,breathe:{enabled:!0,depth:.08,rate:1.2}}},soulAnimation:{driftSpeed:.6,shimmerSpeed:.2,turbulence:.1},rhythmModifiers:{windowMultiplier:.85,visualNoise:0,inputDelay:0,tempoShift:0}},{name:"glitch",emoji:"",description:"Surprised sadness with rainbow colors and glitch wiggle",visual:{primaryColor:"#FF6B9D",glowColor:"#4169E1",glowIntensity:1.2,particleRate:5,minParticles:5,maxParticles:15,particleBehavior:"burst",particleSpeed:1,breathRate:.4,breathDepth:.15,coreJitter:!1,coreSize:1,eyeOpenness:.8,blinkRate:1.3,blinkSpeed:1.2,particleColors:[{color:"#FF0080",weight:18},{color:"#00FF80",weight:18},{color:"#8000FF",weight:18},{color:"#FF8000",weight:15},{color:"#0080FF",weight:15},{color:"#FFFF00",weight:10},{color:"#FF6B9D",weight:6}],particleGlitchWiggle:!0,glitchWiggleIntensity:.3,glitchWiggleFrequency:.1},modifiers:{speed:1.1,amplitude:1,intensity:1.1,smoothness:.8,regularity:.7,focus:.6},typicalGestures:["bounce","sway","pulse","drift","flash"],transitions:{duration:300,easing:"easeInOut",priority:5},"3d":{rotation:{type:"unstable",speed:1.1,axes:[0,.35,0],shake:{amplitude:.02,frequency:5},musicSync:!1},glow:{color:"#FF6B9D",intensity:1.2,pulse:{speed:.4,range:[.8,1.6]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:.4}}},rhythmModifiers:{windowMultiplier:1,visualNoise:.8,inputDelay:20,tempoShift:0}},Ju].forEach(e=>{e&&e.name&&ep.set(e.name,e)});class op{constructor(e,t={}){this.blinkConfig=e.blink||this.getDefaultBlinkConfig(),this.currentGeometryType=null,this.baseDuration=this.blinkConfig.duration||150,this.baseMinInterval=3e3,this.baseMaxInterval=7e3,this.emotionBlinkRate=1,this.emotionBlinkSpeed=1,this.isBlinking=!1,this.blinkTimer=0,this.nextBlinkTime=this.getRandomBlinkTime(),this.enabled=!0,this.blinkProgress=0}setEmotion(e){const t=np(e);this.emotionBlinkRate=t?.visual?.blinkRate||1,this.emotionBlinkSpeed=t?.visual?.blinkSpeed||1}setGeometry(e){this.blinkConfig=e.blink||this.getDefaultBlinkConfig(),this.baseDuration=this.blinkConfig.duration||150}update(e){if(!this.enabled)return this.getIdleState();if(this.isBlinking){this.blinkTimer+=e;const t=this.baseDuration/this.emotionBlinkSpeed;if(this.blinkTimer>=t)return this.completeBlink(),this.getIdleState();const n=this.blinkTimer/t;return this.blinkProgress=n,this.getBlinkState()}return Date.now()>=this.nextBlinkTime?(this.startBlink(),this.getBlinkState()):this.getIdleState()}startBlink(){this.enabled&&(this.isBlinking=!0,this.blinkTimer=0,this.blinkProgress=0)}completeBlink(){this.isBlinking=!1,this.blinkTimer=0,this.blinkProgress=0,this.nextBlinkTime=Date.now()+this.getRandomBlinkTime()}getRandomBlinkTime(){const e=this.baseMinInterval/this.emotionBlinkRate,t=this.baseMaxInterval/this.emotionBlinkRate;return e+Math.random()*(t-e)}getBlinkState(){const e=this.blinkConfig,t=Math.sin(this.blinkProgress*Math.PI);let n=1;if(e.playful)if(this.blinkProgress<.1){const t=this.blinkProgress/.1;n-=Math.sin(t*Math.PI)*e.playful.anticipation}else if(this.blinkProgress>.8){const t=(this.blinkProgress-.8)/.2;n+=Math.sin(t*Math.PI)*e.playful.overshoot}const a=t*n,i=[1-(1-e.scaleAxis[0])*a,1-(1-e.scaleAxis[1])*a,1-(1-e.scaleAxis[2])*a];let r=null;e.rotation&&(r=[e.rotation[0]*a,e.rotation[1]*a,e.rotation[2]*a]);let s=0;return e.glowBoost&&(s=e.glowBoost*a),{isBlinking:!0,progress:this.blinkProgress,scale:i,rotation:r,glowBoost:s}}getIdleState(){return{isBlinking:!1,progress:0,scale:[1,1,1],rotation:null,glowBoost:0}}getDefaultBlinkConfig(){return{type:"vertical-squish",duration:150,scaleAxis:[1,.3,1],curve:"sine"}}pause(){this.enabled=!1,this.isBlinking&&this.completeBlink()}resume(){this.enabled=!0,this.nextBlinkTime=Date.now()+this.getRandomBlinkTime()}getState(){return{isBlinking:this.isBlinking,enabled:this.enabled,blinkProgress:this.blinkProgress,emotionBlinkRate:this.emotionBlinkRate,emotionBlinkSpeed:this.emotionBlinkSpeed,nextBlinkTime:this.nextBlinkTime}}destroy(){this.blinkConfig=null,this.enabled=!1,this.isBlinking=!1}}let lp;"undefined"!=typeof window&&window.__emotiveRhythmEngine?lp=window.__emotiveRhythmEngine:(lp=new class{constructor(){this.bpm=120,this.timeSignature=[4,4],this.isPlaying=!1,this.startTime=0,this.currentBeat=0,this.currentBar=0,this.beatProgress=0,this.barProgress=0,this.beatDuration=6e4/this.bpm,this.barDuration=this.beatDuration*this.timeSignature[0],this.lastBeatTime=0,this.nextBeatTime=0,this.listeners=new Map,this.beatCallbacks=new Set,this.barCallbacks=new Set,this.subdivisions={sixteenth:0,eighth:0,triplet:0,swing:0},this.audioSync=null,this.syncOffset=0,this.autoSync=!1,this.intensity=1,this.groove=0,this.humanize=.05,this.patterns=new Map,this.currentPattern=null,this.initializePatterns()}initializePatterns(){this.patterns.set("4/4",{name:"4/4",description:"Common time - 4 beats per bar",timeSignature:[4,4],groove:0,accents:[1,.5,.7,.5]}),this.patterns.set("straight",{name:"straight",description:"Straight, even timing",groove:0,accents:[1,.5,.7,.5]}),this.patterns.set("swing",{name:"swing",description:"Swing/shuffle timing",groove:.67,accents:[1,.3,.8,.3]}),this.patterns.set("3/4",{name:"3/4",description:"Waltz time - 3 beats per bar",timeSignature:[3,4],accents:[1,.5,.5]}),this.patterns.set("waltz",{name:"waltz",description:"3/4 waltz timing",timeSignature:[3,4],accents:[1,.5,.5]}),this.patterns.set("6/8",{name:"6/8",description:"Compound duple time",timeSignature:[6,8],accents:[1,.3,.3,.7,.3,.3]}),this.patterns.set("5/4",{name:"5/4",description:"Complex meter - 5 beats per bar",timeSignature:[5,4],accents:[1,.5,.6,.5,.7]}),this.patterns.set("7/8",{name:"7/8",description:"Irregular meter",timeSignature:[7,8],accents:[1,.5,.5,.7,.5,.5,.6]}),this.patterns.set("dubstep",{name:"dubstep",description:"Dubstep half-time feel",accents:[.2,.2,1,.2],subdivisions:{wobble:!0}}),this.patterns.set("breakbeat",{name:"breakbeat",description:"Broken beat pattern",accents:[1,.2,.7,.9,.2,.8,.4,.2]})}start(){this.isPlaying||(this.isPlaying=!0,this.isRunning=!0,this.startTime=performance.now(),this.lastBeatTime=this.startTime,this.nextBeatTime=this.startTime+this.beatDuration,this.currentBeat=0,this.currentBar=0,this.emit("start",{bpm:this.bpm,timeSignature:this.timeSignature,pattern:this.currentPattern}),this.update())}stop(){this.isPlaying&&(this.isPlaying=!1,this.emit("stop",{totalBeats:this.currentBeat,totalBars:this.currentBar}))}update(){if(!this.isPlaying)return;const e=(performance.now()-this.startTime)/this.beatDuration,t=Math.floor(e);this.beatProgress=e%1,t>this.currentBeat&&this.onBeat(t);const n=Math.floor(t/this.timeSignature[0]);n>this.currentBar&&this.onBar(n),this.currentBeat=t,this.currentBar=n,this.barProgress=t%this.timeSignature[0]/this.timeSignature[0],this.updateSubdivisions(),this.emit("update",this.getTimeInfo()),this.isPlaying&&requestAnimationFrame(()=>this.update())}onBeat(e){const t=e%this.timeSignature[0],n=this.getAccent(t),a=this.humanize*(Math.random()-.5)*this.beatDuration,i={beat:e,beatInBar:t,bar:this.currentBar,accent:n,intensity:this.intensity*n,humanTiming:a,timestamp:performance.now()};this.emit("beat",i),this.beatCallbacks.forEach(e=>e(i)),this.lastBeatTime=performance.now(),this.nextBeatTime=this.lastBeatTime+this.beatDuration}onBar(e){const t={bar:e,timeSignature:this.timeSignature,pattern:this.currentPattern,timestamp:performance.now()};this.emit("bar",t),this.barCallbacks.forEach(e=>e(t))}updateSubdivisions(){if(this.subdivisions.sixteenth=4*this.beatProgress%1,this.subdivisions.eighth=2*this.beatProgress%1,this.subdivisions.triplet=3*this.beatProgress%1,this.groove>0){const e=.5+.17*this.groove;this.subdivisions.eighth<.5?this.subdivisions.swing=this.subdivisions.eighth/e:this.subdivisions.swing=.5+(this.subdivisions.eighth-.5)/(1-e)}else this.subdivisions.swing=this.subdivisions.eighth}getAccent(e){if(this.currentPattern&&this.patterns.has(this.currentPattern)){const t=this.patterns.get(this.currentPattern);if(t.accents&&void 0!==t.accents[e])return t.accents[e]}return 0===e?1:2===e&&4===this.timeSignature[0]?.7:.5}getTimeInfo(){return{elapsed:performance.now()-this.startTime,beat:this.currentBeat,bar:this.currentBar,beatInBar:this.currentBeat%this.timeSignature[0],beatProgress:this.beatProgress,barProgress:this.barProgress,subdivisions:{...this.subdivisions},bpm:this.bpm,beatDuration:this.beatDuration,timeSignature:[...this.timeSignature],intensity:this.intensity,groove:this.groove,pattern:this.currentPattern,nextBeatIn:this.nextBeatTime-performance.now(),accent:this.getAccent(this.currentBeat%this.timeSignature[0])}}setBPM(e){this.bpm=Math.max(20,Math.min(360,e)),this.beatDuration=6e4/this.bpm,this.barDuration=this.beatDuration*this.timeSignature[0],this.emit("tempoChange",{bpm:this.bpm})}setTimeSignature(e,t){this.timeSignature=[e,t],this.barDuration=this.beatDuration*e,this.emit("timeSignatureChange",{timeSignature:this.timeSignature})}setPattern(e){if(!this.patterns.has(e))return;const t=this.patterns.get(e);this.currentPattern=e,t.timeSignature&&this.setTimeSignature(...t.timeSignature),void 0!==t.groove&&(this.groove=t.groove),this.emit("patternChange",{pattern:e})}onBeatCallback(e){return this.beatCallbacks.add(e),()=>this.beatCallbacks.delete(e)}onBarCallback(e){return this.barCallbacks.add(e),()=>this.barCallbacks.delete(e)}emit(e,t){this.listeners.has(e)&&this.listeners.get(e).forEach(e=>e(t))}on(e,t){return this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e).add(t),()=>{this.listeners.has(e)&&this.listeners.get(e).delete(t)}}syncToAudio(e,t){this.audioSync={context:e,source:t}}getAdapter(){return{getTimeInfo:()=>this.getTimeInfo(),isOnBeat:(e=.1)=>this.beatProgress<e||this.beatProgress>1-e,isOnSubdivision:(e,t=.1)=>{const n=this.subdivisions[e]||0;return n<t||n>1-t},getBeatSync:(e=0,t=1,n="linear")=>{let a=this.beatProgress;switch(n){case"ease":a=.5-Math.cos(a*Math.PI)/2;break;case"bounce":a=Math.abs(Math.sin(a*Math.PI));break;case"pulse":a=Math.pow(Math.sin(a*Math.PI),2)}return e+(t-e)*a},getAccentedValue:(e,t=2)=>e*(1+(this.getAccent(this.currentBeat%this.timeSignature[0])-.5)*t),onBeat:e=>this.onBeatCallback(e),onBar:e=>this.onBarCallback(e),beatsToMs:e=>e*this.beatDuration,msToBeats:e=>e/this.beatDuration,isPlaying:()=>this.isPlaying,getBPM:()=>this.bpm,getPattern:()=>this.currentPattern}}},"undefined"!=typeof window&&(window.__emotiveRhythmEngine=lp));const cp={groove1:{name:"groove1",description:"Subtle, elegant - gentle bounce and sway",bounceAmount:.015,swayAmount:.012,pulseAmount:.02,rotationAmount:.015,bounceFreq:1,swayFreq:.5,phaseOffset:0,easing:"sine"},groove2:{name:"groove2",description:"Energetic, bouncy - pronounced vertical motion",bounceAmount:.035,swayAmount:.02,pulseAmount:.045,rotationAmount:.025,bounceFreq:1,swayFreq:1,phaseOffset:0,easing:"bounce"},groove3:{name:"groove3",description:"Smooth, flowing - emphasis on rotation and sway",bounceAmount:.01,swayAmount:.03,pulseAmount:.015,rotationAmount:.04,bounceFreq:.5,swayFreq:.25,phaseOffset:Math.PI/4,easing:"sine"}},hp="groove1";class dp{constructor(){this.enabled=!1,this.adapter=null,this.beatProgress=0,this.barProgress=0,this.accent=.5,this.intensity=1,this.bpm=120,this.isOnBeat=!1,this.pattern=null,this.grooveEnabled=!0,this.currentGroove=hp,this.targetGroove=hp,this.grooveTransition=0,this.grooveTransitionSpeed=2,this.grooveConfidence=1,this.bpmMultiplier=1,this.modulation={scaleMultiplier:1,glowMultiplier:1,positionMultiplier:1,rotationMultiplier:1,accentBoost:0,grooveOffset:[0,0,0],grooveScale:1,grooveRotation:[0,0,0],grooveGlow:1},this._target={scaleMultiplier:1,glowMultiplier:1,positionMultiplier:1,rotationMultiplier:1,accentBoost:0,grooveOffset:[0,0,0],grooveScale:1,grooveRotation:[0,0,0],grooveGlow:1},this.config={beatSyncStrength:.3,accentMultiplier:1.5,smoothingSpeed:8,grooveSmoothingSpeed:12},this._maxDeltaTime=.05,this._pendingGroove=null,this._pendingGrooveOptions=null}_lerp(e,t,n,a){return e+(t-e)*(1-Math.exp(-n*a))}_lerpArray(e,t,n,a){const i=1-Math.exp(-n*a);return e.map((e,n)=>e+(t[n]-e)*i)}_applyEasing(e,t){switch(t){case"bounce":return Math.sign(e)*Math.pow(Math.abs(e),.6);case"elastic":return e*(1+.15*Math.sin(Math.abs(e)*Math.PI*2));default:return e}}_getGroovePreset(e){return cp[e]||cp[hp]}_interpolatePresets(e,t,n){return{bounceAmount:e.bounceAmount+(t.bounceAmount-e.bounceAmount)*n,swayAmount:e.swayAmount+(t.swayAmount-e.swayAmount)*n,pulseAmount:e.pulseAmount+(t.pulseAmount-e.pulseAmount)*n,rotationAmount:e.rotationAmount+(t.rotationAmount-e.rotationAmount)*n,bounceFreq:e.bounceFreq+(t.bounceFreq-e.bounceFreq)*n,swayFreq:e.swayFreq+(t.swayFreq-e.swayFreq)*n,phaseOffset:e.phaseOffset+(t.phaseOffset-e.phaseOffset)*n}}initialize(){this.adapter=lp.getAdapter(),this.enabled=!0,this.adapter.onBeat(e=>{this.accent=e.accent,this.isOnBeat=!0,setTimeout(()=>{this.isOnBeat=!1},100)})}start(e=120,t="straight"){this.enabled||this.initialize(),e&&lp.setBPM(e),t&&lp.setPattern(t),lp.start()}stop(){lp.stop()}setBPM(e){lp.setBPM(e),this.bpm=e}setPattern(e){lp.setPattern(e),this.pattern=e}setGroove(e,t={}){if(cp[e]){if(!(this.currentGroove===e&&this.grooveTransition>=1)){if(t.quantize)return this._pendingGroove=e,void(this._pendingGrooveOptions={...t,quantize:!1});if(this.targetGroove=e,t.bars||t.duration)if(this.grooveTransition=0,t.bars){const e=60/this.bpm*4,n=t.bars*e;this.grooveTransitionSpeed=1/n}else t.duration&&(this.grooveTransitionSpeed=1/t.duration);else this.currentGroove=e,this.grooveTransition=1}}else console.warn(`[Rhythm3DAdapter] Unknown groove preset: ${e}`)}getGroovePresets(){return Object.keys(cp)}getCurrentGroove(){return this.grooveTransition>=1?this.targetGroove:this.currentGroove}update(e){const t=Math.min(e/1e3,this._maxDeltaTime);if(this.adapter||(this.adapter=lp.getAdapter()),!this.adapter)return void this.resetModulation(t);if(!this.adapter.isPlaying())return void this.resetModulation(t);this.enabled=!0;const n=this.adapter.getTimeInfo();this.beatProgress=n.beatProgress,this.barProgress=n.barProgress,this.intensity=n.intensity,this.bpm=n.bpm||this.bpm,this.pattern=n.pattern,this._pendingGroove&&this.barProgress<.05&&(this.setGroove(this._pendingGroove,this._pendingGrooveOptions||{}),this._pendingGroove=null,this._pendingGrooveOptions=null),this.grooveTransition<1&&(this.grooveTransition=Math.min(1,this.grooveTransition+this.grooveTransitionSpeed*t),this.grooveTransition>=1&&(this.currentGroove=this.targetGroove)),this.computeModulation(),this.applySmoothing(t)}computeModulation(){const{beatSyncStrength:e,accentMultiplier:t}=this.config,n=this.beatProgress*Math.PI*2,a=.5*(Math.cos(n)+1);this._target.scaleMultiplier=1+a*e*.4,this._target.glowMultiplier=1+a*e*.8,this._target.positionMultiplier=1+a*e*.2,this._target.rotationMultiplier=1+a*e*.15,this._target.accentBoost=this.isOnBeat?(this.accent-.5)*t:0,this.grooveEnabled?this.computeGroove():(this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0])}computeGroove(){const e=this._getGroovePreset(this.currentGroove),t=this._getGroovePreset(this.targetGroove),n=this.grooveTransition>=1?t:this._interpolatePresets(e,t,this.grooveTransition),a=this.grooveConfidence,i=n.bounceAmount*a,r=n.swayAmount*a,s=n.pulseAmount*a,o=n.rotationAmount*a,{bounceFreq:l,swayFreq:c,phaseOffset:h,easing:d}=n,u=this.beatProgress*l*this.bpmMultiplier*Math.PI*2+h,p=Math.sin(u),m=this._applyEasing(p,d),f=this.barProgress*c*this.bpmMultiplier*Math.PI*2+h,g=Math.sin(f),y=this._applyEasing(g,d),v=.5*(Math.cos(this.beatProgress*Math.PI*2)+1),b=Math.max(0,this.accent-.4)/.6,w=v*b*.25,x=m*i*(1+w),S=y*r,M=Math.sin(u),_=1+this._applyEasing(M,d)*s*(1+.5*w),A=y*o,C=Math.sin(f+Math.PI/3)*r*.3,T=Math.sin(.5*f)*o*.4,P=Math.cos(.7*u)*o*.25,D=1+.5*(Math.cos(u)+1)*.12*a+v*b*.12;this._target.grooveOffset=[S,x,C],this._target.grooveScale=_,this._target.grooveRotation=[T,P,A],this._target.grooveGlow=D}applySmoothing(e){const{smoothingSpeed:t,grooveSmoothingSpeed:n}=this.config;this.modulation.scaleMultiplier=this._lerp(this.modulation.scaleMultiplier,this._target.scaleMultiplier,t,e),this.modulation.glowMultiplier=this._lerp(this.modulation.glowMultiplier,this._target.glowMultiplier,t,e),this.modulation.positionMultiplier=this._lerp(this.modulation.positionMultiplier,this._target.positionMultiplier,t,e),this.modulation.rotationMultiplier=this._lerp(this.modulation.rotationMultiplier,this._target.rotationMultiplier,t,e),this.modulation.accentBoost=this._lerp(this.modulation.accentBoost,this._target.accentBoost,.5*t,e),this.modulation.grooveOffset=this._lerpArray(this.modulation.grooveOffset,this._target.grooveOffset,n,e),this.modulation.grooveScale=this._lerp(this.modulation.grooveScale,this._target.grooveScale,n,e),this.modulation.grooveRotation=this._lerpArray(this.modulation.grooveRotation,this._target.grooveRotation,n,e),this.modulation.grooveGlow=this._lerp(this.modulation.grooveGlow,this._target.grooveGlow,n,e)}resetModulation(e=.016){this._target.scaleMultiplier=1,this._target.glowMultiplier=1,this._target.positionMultiplier=1,this._target.rotationMultiplier=1,this._target.accentBoost=0,this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0],this._target.grooveGlow=1,this.modulation.scaleMultiplier=this._lerp(this.modulation.scaleMultiplier,1,4,e),this.modulation.glowMultiplier=this._lerp(this.modulation.glowMultiplier,1,4,e),this.modulation.positionMultiplier=this._lerp(this.modulation.positionMultiplier,1,4,e),this.modulation.rotationMultiplier=this._lerp(this.modulation.rotationMultiplier,1,4,e),this.modulation.accentBoost=this._lerp(this.modulation.accentBoost,0,4,e),this.modulation.grooveOffset=this._lerpArray(this.modulation.grooveOffset,[0,0,0],4,e),this.modulation.grooveScale=this._lerp(this.modulation.grooveScale,1,4,e),this.modulation.grooveRotation=this._lerpArray(this.modulation.grooveRotation,[0,0,0],4,e),this.modulation.grooveGlow=this._lerp(this.modulation.grooveGlow,1,4,e)}getModulation(){return this.modulation}getMusicalDuration(e,t=null){if(!this.enabled||!this.adapter||!this.adapter.isPlaying())return e;if(t?.durationSync){const e=t.durationSync;if("beats"===e.mode&&e.beats)return this.adapter.beatsToMs(e.beats);if("bars"===e.mode&&e.bars)return this.adapter.beatsToMs(4*e.bars)}return e}isOnBeatNow(e=.1){return!(!this.enabled||!this.adapter)&&this.adapter.isOnBeat(e)}isOnAccent(e=.7){return this.isOnBeat&&this.accent>=e}getBeatSync(e,t,n="pulse"){return this.enabled&&this.adapter?this.adapter.getBeatSync(e,t,n):e}getAccentedValue(e,t=2){return this.enabled&&this.adapter?this.adapter.getAccentedValue(e,t):e}setGrooveEnabled(e){this.grooveEnabled=e,e||(this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0])}setGrooveConfidence(e){this.grooveConfidence=Math.max(0,Math.min(1,e))}setBPMMultiplier(e){this.bpmMultiplier=Math.max(.25,Math.min(4,e))}getBPMMultiplier(){return this.bpmMultiplier}setGrooveConfig(e){Object.assign(this.config,e)}setBeatSyncStrength(e){this.config.beatSyncStrength=Math.max(0,Math.min(1,e))}isPlaying(){return this.enabled&&this.adapter&&this.adapter.isPlaying()}getBPM(){return this.bpm}getPattern(){return this.pattern}destroy(){this.enabled=!1,this.adapter=null,this.resetModulation()}}const up=new dp;class pp{constructor(){this.isTransitioning=!1,this.currentGeometryType=null,this.targetGeometryType=null,this.morphStartTime=0,this.morphDuration=1e3,this.morphProgress=0,this.visualProgress=0,this.hasSwappedGeometry=!1,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.easing="easeInOutCubic"}startMorph(e,t,n=1e3){if(e===t&&!this.isTransitioning)return!1;if(this.isTransitioning&&this.targetGeometryType===t)return!1;if(this.isTransitioning){const e=this.calculateScaleMultiplier(this.visualProgress);if(this.hasSwappedGeometry){this.morphStartTime=Date.now(),this.morphDuration=n;const a=e>0?Math.sqrt(1-Math.min(e,1))/2:.5;this.morphProgress=a,this.visualProgress=a,this.hasSwappedGeometry=!1,this.targetGeometryType=t,this._interruptedTarget=t,this.isPausedAtSwap=!1,this.isGrowIn=!1;const i=a*n;return this.morphStartTime=Date.now()-i,!0}return this.targetGeometryType=t,this._interruptedTarget=t,!0}return this.currentGeometryType=e,this.targetGeometryType=t,this.morphStartTime=Date.now(),this.morphDuration=n,this.morphProgress=0,this.visualProgress=0,this.isTransitioning=!0,this.hasSwappedGeometry=!1,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.isGrowIn=!1,this._interruptedTarget=null,!0}getInterruptedTarget(){const e=this._interruptedTarget;return this._interruptedTarget=null,e}growIn(e,t=500){return!this.isTransitioning&&(this.currentGeometryType=e,this.targetGeometryType=e,this.morphStartTime=Date.now(),this.morphDuration=t,this.morphProgress=0,this.visualProgress=0,this.isTransitioning=!0,this.hasSwappedGeometry=!0,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.isGrowIn=!0,!0)}pauseAtSwap(){this.isTransitioning&&!this.isPausedAtSwap&&(this.isPausedAtSwap=!0,this.pausedAtTime=Date.now())}resumeFromSwap(){if(this.isPausedAtSwap){const e=Date.now()-this.pausedAtTime;this.morphStartTime+=e,this.isPausedAtSwap=!1,this.pausedAtTime=0}}update(e){if(!this.isTransitioning)return{isTransitioning:!1,progress:0,visualProgress:0,scaleMultiplier:1};if(this.isPausedAtSwap)return{isTransitioning:!0,progress:.5,visualProgress:.5,scaleMultiplier:0,waitingForGeometry:!0};const t=Date.now()-this.morphStartTime,n=Math.min(t/this.morphDuration,1);this.morphProgress=this.applyEasing(n),this.visualProgress=this.morphProgress;const a=this.calculateScaleMultiplier(this.morphProgress);let i=!1;return!this.hasSwappedGeometry&&this.morphProgress>=.5&&(this.hasSwappedGeometry=!0,i=!0),this.morphProgress>=1?(this.completeMorph(),{isTransitioning:!1,progress:1,visualProgress:1,scaleMultiplier:1,completed:!0}):{isTransitioning:!0,progress:this.morphProgress,visualProgress:this.visualProgress,scaleMultiplier:a,shouldSwapGeometry:i}}calculateScaleMultiplier(e){if(this.isGrowIn){const t=1.70158,n=1+(t+1)*Math.pow(e-1,3)+t*Math.pow(e-1,2);return Math.max(0,n)}if(e<=.5){const t=2*e;return 1-t*t}{const t=2*(e-.5);return t*(2-t)}}completeMorph(){this.currentGeometryType=this.targetGeometryType,this.targetGeometryType=null,this.isTransitioning=!1,this.morphProgress=0,this.visualProgress=0}applyEasing(e){switch(this.easing){case"linear":return e;case"easeInQuad":return e*e;case"easeOutQuad":return e*(2-e);case"easeInOutQuad":return e<.5?2*e*e:(4-2*e)*e-1;case"easeInOutSine":return-(Math.cos(Math.PI*e)-1)/2;default:return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}}getState(){return{isTransitioning:this.isTransitioning,currentGeometryType:this.currentGeometryType,targetGeometryType:this.targetGeometryType,progress:this.morphProgress,visualProgress:this.visualProgress}}cancel(){this.isTransitioning=!1,this.targetGeometryType=null,this.morphProgress=0,this.visualProgress=0}}const mp={none:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1,"3d":{rotation:{speedMultiplier:1,shakeMultiplier:1},glow:{intensityMultiplier:1,pulseSpeedMultiplier:1},scale:{breathDepthMultiplier:1,breathRateMultiplier:1},righting:{strengthMultiplier:1}}},clear:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1,"3d":{rotation:{speedMultiplier:1,shakeMultiplier:1},glow:{intensityMultiplier:1,pulseSpeedMultiplier:1},scale:{breathDepthMultiplier:1,breathRateMultiplier:1},righting:{strengthMultiplier:1}}},nervous:{speed:1.2,amplitude:.9,intensity:1.1,smoothness:.7,regularity:.6,addFlutter:!0,addMicroShake:!0,"3d":{rotation:{speedMultiplier:1.5,shakeMultiplier:3.5,enableEpisodicWobble:!0},glow:{intensityMultiplier:1.25,pulseSpeedMultiplier:2},scale:{breathDepthMultiplier:.5,breathRateMultiplier:1.8},righting:{strengthMultiplier:.7}}},confident:{speed:.9,amplitude:1.3,intensity:1.2,smoothness:1.1,regularity:1.2,addPower:!0,addHold:!0,"3d":{rotation:{speedMultiplier:.7,shakeMultiplier:.2},glow:{intensityMultiplier:1.4,pulseSpeedMultiplier:.7},scale:{breathDepthMultiplier:1.5,breathRateMultiplier:.7},righting:{strengthMultiplier:1.6}}},tired:{speed:.7,amplitude:.7,intensity:.8,smoothness:1.3,regularity:.8,addDroop:!0,addPause:!0,"3d":{rotation:{speedMultiplier:.4,shakeMultiplier:.15},glow:{intensityMultiplier:.5,pulseSpeedMultiplier:.5},scale:{breathDepthMultiplier:1.3,breathRateMultiplier:.5},righting:{strengthMultiplier:.6}}},intense:{speed:1.3,amplitude:1.2,intensity:1.4,smoothness:.6,regularity:.9,addPulse:!0,addFocus:!0,"3d":{rotation:{speedMultiplier:1.6,shakeMultiplier:2.5},glow:{intensityMultiplier:1.8,pulseSpeedMultiplier:2.2},scale:{breathDepthMultiplier:1.6,breathRateMultiplier:1.8},righting:{strengthMultiplier:1.3}}},subdued:{speed:.8,amplitude:.8,intensity:.7,smoothness:1.2,regularity:1.1,addSoftness:!0,addFade:!0,"3d":{rotation:{speedMultiplier:.5,shakeMultiplier:.1},glow:{intensityMultiplier:.55,pulseSpeedMultiplier:.6},scale:{breathDepthMultiplier:.7,breathRateMultiplier:.6},righting:{strengthMultiplier:1.4}}}};function fp(e){return e&&""!==e&&"clear"!==e&&mp[e]||mp.clear}function gp(e,t=0,n="glow"){const a=function(e){const t=parseInt(e.slice(1,3),16)/255,n=parseInt(e.slice(3,5),16)/255,a=parseInt(e.slice(5,7),16)/255,i=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4);return.2126*i(t)+.7152*i(n)+.0722*i(a)}(e),i=(.5+t)/Math.max(a,.05);return Math.max(.3,Math.min(10,i))}function yp(e){return 3===(e=e.replace("#","")).length&&(e=e.split("").map(e=>e+e).join("")),{r:parseInt(e.substr(0,2),16),g:parseInt(e.substr(2,2),16),b:parseInt(e.substr(4,2),16)}}const vp={intense:1.6,confident:1.3,nervous:1.15,clear:1,tired:.8,subdued:.5};function bp(e,t){if(!t||"clear"===t)return e;const n=vp[t.toLowerCase()];return n&&1!==n?function(e,t){const n=yp(e),a=function(e,t,n){e/=255,t/=255,n/=255;const a=Math.max(e,t,n),i=Math.min(e,t,n),r=(a+i)/2;let s,o;if(a===i)s=o=0;else{const l=a-i;switch(o=r>.5?l/(2-a-i):l/(a+i),a){case e:s=(t-n)/l+(t<n?6:0);break;case t:s=(n-e)/l+2;break;case n:s=(e-t)/l+4}s/=6}return{h:360*s,s:100*o,l:100*r}}(n.r,n.g,n.b);a.s=Math.max(0,Math.min(100,a.s*t));const i=function(e,t,n){e/=360,n/=100;const a=(e,t,n)=>(n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+(t-e)*(2/3-n)*6:e);let i,r,s;if(0==(t/=100))i=r=s=n;else{const o=n<.5?n*(1+t):n+t-n*t,l=2*n-o;i=a(l,o,e+1/3),r=a(l,o,e),s=a(l,o,e-1/3)}return{r:Math.round(255*i),g:Math.round(255*r),b:Math.round(255*s)}}(a.h,a.s,a.l);return function(e,t,n){const a=e=>{const t=Math.round(Math.max(0,Math.min(255,e))).toString(16);return 1===t.length?`0${t}`:t};return`#${a(e)}${a(t)}${a(n)}`}(i.r,i.g,i.b)}(e,n):e}Object.fromEntries(Object.entries({neutral:"#B0B0B0",joy:"#FFD700",sadness:"#4169E1",anger:"#DC143C",fear:"#8B008B",surprise:"#FF8C00",disgust:"#9ACD32",love:"#FF69B4"}).map(([e,t])=>{const n=yp(t);return[e,`${n.r}, ${n.g}, ${n.b}`]}));class wp{constructor(e,t={}){this._adapter=e,this._windows={perfect:t.windows?.perfect??30,great:t.windows?.great??60,good:t.windows?.good??100},this._grades={perfect:{multiplier:2,label:"Perfect"},great:{multiplier:1.5,label:"Great"},good:{multiplier:1,label:"Good"},miss:{multiplier:0,label:"Miss"}},this._windowModifiers={multiplier:1},this._emotionSource=t.emotionSource??null,this._history=[],this._maxHistory=100,this._onEvaluate=[],this._emotionFeedback=null,this._emotionTarget=null,this._difficultyManager=null}evaluate(e=performance.now()){const t=this._adapter.getTimeInfo(),{beatDuration:n}=t,a=performance.now()-t.elapsed,i=e-a,r=i-i%n,s=r+n,o=i-r<s-i?r:s,l=i-o;return this._gradeOffset(l,e,o+a)}evaluateAgainst(e,t){return this._gradeOffset(e-t,e,t)}evaluateSequence(e,t){const n=[],a=new Set;for(const i of e){let e=-1,r=1/0;for(let n=0;n<t.length;n++){if(a.has(n))continue;const s=Math.abs(i-t[n]);s<r&&(r=s,e=n)}e>=0?(a.add(e),n.push(this.evaluateAgainst(i,t[e]))):n.push({grade:"miss",offset:0,absOffset:0,multiplier:0,label:"Miss",timestamp:i,targetTime:null})}return n}_gradeOffset(e,t,n){if(this._difficultyManager&&this._difficultyManager.autoRhythm)return this._recordResult("good",e,t,n);const a=Math.abs(e),i=this._emotionSource?.()??{windowMultiplier:1},r=this._difficultyManager?this._difficultyManager.getWindowMultiplier():1,s=this._windowModifiers.multiplier*(i.windowMultiplier||1)*r;let o;return o=a<=this._windows.perfect*s?"perfect":a<=this._windows.great*s?"great":a<=this._windows.good*s?"good":"miss",this._recordResult(o,e,t,n)}_recordResult(e,t,n,a){const i={grade:e,offset:t,absOffset:Math.abs(t),multiplier:this._grades[e].multiplier,label:this._grades[e].label,timestamp:n,targetTime:a};this._history.push(i),this._history.length>this._maxHistory&&this._history.shift();for(const e of this._onEvaluate)e(i);if(this._emotionFeedback&&this._emotionTarget){const t=this._emotionFeedback[e];t&&this._emotionTarget(t.emotion,t.delta)}return i}setWindowModifier(e){this._windowModifiers.multiplier=Math.max(.3,Math.min(3,e))}setEmotionSource(e){this._emotionSource=e}getAccuracy(){if(!this._history.length)return{perfect:0,great:0,good:0,miss:0,averageOffset:0,total:0};const e={perfect:0,great:0,good:0,miss:0};let t=0;for(const n of this._history)e[n.grade]++,t+=n.offset;return{...e,averageOffset:t/this._history.length,total:this._history.length}}getHistory(){return[...this._history]}clearHistory(){this._history.length=0}onEvaluate(e){return this._onEvaluate.push(e),()=>{this._onEvaluate=this._onEvaluate.filter(t=>t!==e)}}setEmotionFeedback(e){this._emotionFeedback=e||null}setEmotionTarget(e){this._emotionTarget=e||null}setDifficultyManager(e){this._difficultyManager=e||null}setWindows(e){Object.assign(this._windows,e)}setGrades(e){Object.assign(this._grades,e)}destroy(){this._history.length=0,this._onEvaluate.length=0}}const xp=new class{constructor(){this.enabled=!1,this.adapter=null,this.subsystemConfigs=new Map,this.activeModulations=new Map,this._inputEvaluator=null}initialize(){this.adapter=lp.getAdapter(),this.enabled=!0,this.adapter.onBeat(this.handleBeat.bind(this)),this.adapter.onBar(this.handleBar.bind(this))}updateBPM(e){if(e>=60&&e<=220){if(window.rhythmManuallyStoppedForCurrentAudio)return;if(!lp.isRunning)return this.start(e,"straight"),void(window.rhythmSyncVisualizer&&!window.rhythmSyncVisualizer.state.active&&window.rhythmSyncVisualizer.start());lp.setBPM(e)}}registerConfig(e,t,n){if(!n.rhythm||!n.rhythm.enabled)return;const a=`${e}:${t}`;this.subsystemConfigs.set(a,{type:e,name:t,rhythmConfig:n.rhythm,originalConfig:n})}applyGestureRhythm(e,t,n,a){if(!this.enabled||!e.rhythm?.enabled)return{};const i=e.rhythm,r={};if(i.amplitudeSync){const e=i.amplitudeSync,t=this.adapter.getBeatSync(e.offBeat||.8,e.onBeat||1.5,e.curve||"linear");r.amplitudeMultiplier=t}if(i.wobbleSync){const e=i.wobbleSync;this.adapter.isOnSubdivision(e.subdivision,.1)?r.wobbleMultiplier=1+e.intensity:r.wobbleMultiplier=1}if(i.accentResponse?.enabled){const e=this.adapter.getAccentedValue(1,i.accentResponse.multiplier||1.5);r.accentMultiplier=e}const s=this.adapter.getPattern();return s&&i.patternOverrides?.[s]&&Object.assign(r,i.patternOverrides[s]),r}applyParticleRhythm(e,t){if(!this.enabled||!e.rhythm?.enabled)return{};const n=this.adapter.getTimeInfo(),a=e.rhythm,i={};if(a.particleEmission){const e=a.particleEmission;"beat"===e.syncMode&&this.adapter.isOnBeat(.1)?i.emitBurst=e.burstSize||3:void 0!==e.offBeatRate&&(i.emissionRate=e.offBeatRate)}if(a.glowSync){const e=a.glowSync,t=this.adapter.getBeatSync(e.intensityRange[0]||1,e.intensityRange[1]||2,"pulse");i.glowIntensity=t}if("bars"===a.breathSync?.mode){const e=a.breathSync,t=n.bar%e.barsPerBreath/e.barsPerBreath;i.breathPhase=t*Math.PI*2}return i}applyBehaviorRhythm(e,t,n){if(!this.enabled||!e.rhythm?.enabled)return{};const a=this.adapter.getTimeInfo(),i=e.rhythm,r={};if(i.glitchTiming){const e=i.glitchTiming;if(this.adapter.isOnSubdivision(e.subdivision,.05)&&Math.random()<e.probability){const t=this.adapter.isOnBeat()?e.intensityOnBeat:e.intensityOffBeat;r.triggerGlitch=!0,r.glitchIntensity=t}}if(i.orbitRhythm){const e=i.orbitRhythm;"tempo"===e.baseSpeed&&(r.speedMultiplier=this.adapter.getBPM()/120),e.beatAcceleration&&this.adapter.isOnBeat(.1)&&(r.speedBoost=e.beatAcceleration),e.barReset&&0===a.beatInBar&&(r.resetOrbit=!0)}if(i.stutterSync){const e=i.stutterSync,t=this.adapter.getPattern();if(t&&e.patterns?.[t]){const n=e.patterns[t];n.freezeOnDrop&&2===a.beatInBar?(r.freeze=!0,r.freezeDuration=n.dropDuration):n.randomFreeze&&Math.random()<n.randomFreeze&&(r.freeze=!0,r.freezeDuration=n.duration)}}return r}handleBeat(e){this.lastBeatInfo=e}handleBar(e){this.lastBarInfo=e}getMusicalDuration(e,t){if(!this.enabled||!e?.durationSync)return t;const n=e.durationSync;return"bars"===n.mode?this.adapter.beatsToMs(4*n.bars):"beats"===n.mode?this.adapter.beatsToMs(n.beats):t}isEnabled(){return this.enabled&&this.adapter.isPlaying()}start(e=120,t="straight"){e&&lp.setBPM(e),t&&lp.setPattern(t),lp.start(),this.enabled=!0}stop(){lp.stop(),this.enabled=!1,this.bpmLocked=!1,this.lockedBPM=null}setPattern(e){lp.setPattern(e)}setBPM(e){lp.setBPM(e),this.bpmLocked&&(this.lockedBPM=e)}resampleBPM(){this.bpmLocked=!1,this.lockedBPM=null}setTimeSignature(e){this.timeSignature=e;const t=document.getElementById("time-sig-display");t&&(t.textContent=e),"3/4"===e&&lp.getPattern()}getInputEvaluator(e){return this._inputEvaluator||(this.adapter||this.initialize(),this._inputEvaluator=new wp(this.adapter,e)),this._inputEvaluator}getEffectiveBPM(e){if(!this.adapter)return 120;let t=this.adapter.getBPM();if(e&&"function"==typeof e.getCurrentRhythmModifiers){const n=e.getCurrentRhythmModifiers();n.tempoShift&&(t*=1+n.tempoShift)}return Math.round(100*t)/100}syncToAudio(e,t){lp.syncToAudio(e,t)}},Sp=new class{constructor(){this.emotionCache=new Map,this.visualParamsCache=new Map,this.modifiersCache=new Map,this.transitionCache=new Map,this.stats={hits:0,misses:0,loadTime:0,cacheSize:0},this.isInitialized=!1,this.loadStartTime=0,this.initialize()}initialize(){this.loadStartTime=performance.now();try{const e=rp();e.forEach(e=>{this.cacheEmotion(e)}),this.cacheCommonTransitions(e),this.isInitialized=!0,this.stats.loadTime=performance.now()-this.loadStartTime,this.stats.cacheSize=this.emotionCache.size}catch(e){console.error("[EmotionCache] Initialization failed:",e),this.isInitialized=!1}}cacheEmotion(e){try{const t=np(e);t&&this.emotionCache.set(e,t);const n=ap(e);this.visualParamsCache.set(e,n);const a=ip(e);this.modifiersCache.set(e,a)}catch(t){console.warn(`[EmotionCache] Failed to cache emotion '${e}':`,t)}}cacheCommonTransitions(e){[["neutral","joy"],["neutral","sadness"],["neutral","anger"],["joy","sadness"],["sadness","joy"],["anger","calm"],["calm","anger"]].forEach(([t,n])=>{if(e.includes(t)&&e.includes(n))try{const e=sp(t,n),a=`${t}->${n}`;this.transitionCache.set(a,e)}catch(e){console.warn(`[EmotionCache] Failed to cache transition '${t}->${n}':`,e)}})}getEmotion(e){if(!this.isInitialized)return console.warn("[EmotionCache] Cache not initialized, falling back to direct access"),np(e);const t=this.emotionCache.get(e);return t?(this.stats.hits++,t):(this.stats.misses++,np(e))}getVisualParams(e){if(!this.isInitialized)return ap(e);const t=this.visualParamsCache.get(e);return t?(this.stats.hits++,t):(this.stats.misses++,ap(e))}getModifiers(e){if(!this.isInitialized)return ip(e);const t=this.modifiersCache.get(e);return t?(this.stats.hits++,t):(this.stats.misses++,ip(e))}getTransitionParams(e,t){if(!this.isInitialized)return sp(e,t);const n=`${e}->${t}`,a=this.transitionCache.get(n);return a?(this.stats.hits++,a):(this.stats.misses++,sp(e,t))}hasEmotion(e){return this.emotionCache.has(e)}getStats(){const e=this.stats.hits+this.stats.misses,t=e>0?(this.stats.hits/e*100).toFixed(2):0;return{isInitialized:this.isInitialized,loadTime:this.stats.loadTime,cacheSize:this.stats.cacheSize,hits:this.stats.hits,misses:this.stats.misses,hitRate:`${t}%`,emotions:this.emotionCache.size,visualParams:this.visualParamsCache.size,modifiers:this.modifiersCache.size,transitions:this.transitionCache.size}}clear(){this.emotionCache.clear(),this.visualParamsCache.clear(),this.modifiersCache.clear(),this.transitionCache.clear(),this.isInitialized=!1,this.stats={hits:0,misses:0,loadTime:0,cacheSize:0}}reinitialize(){this.clear(),this.initialize()}};function Mp(e){if(!e||0===e.length)return"#FFFFFF";let t=0,n=0;const a=[];for(const i of e)"string"==typeof i?(a.push({color:i,weight:null}),n++):i&&"object"==typeof i&&i.color&&(a.push({color:i.color,weight:i.weight||null}),i.weight?t+=i.weight:n++);const i=Math.max(0,100-t),r=n>0?i/n:0,s=[];let o=0;for(const e of a)o+=null!==e.weight?e.weight:r,s.push({color:e.color,threshold:o});const l=Math.random()*o;for(const e of s)if(l<=e.threshold)return e.color;return a[a.length-1].color}var _p={name:"ambient",emoji:"",description:"Gentle upward drift like smoke",initialize:function(e){e.vx=0,e.vy=-.04-.02*Math.random(),e.lifeDecay=.002,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={upwardSpeed:5e-4,waviness:0,friction:.998}},update:function(e,t,n,a){const i=e.behaviorData;e.vy*=Math.pow(i.friction,t),e.vy-=i.upwardSpeed*t,e.vx=0}};const Ap=2*Math.PI;var Cp={name:"orbiting",emoji:"",description:"Romantic firefly dance around the orb",initialize:function(e){e.lifeDecay=.001+.002*Math.random(),e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.isSparkle="#FFE4E1"===e.color||"#FFCCCB"===e.color||"#FFC0CB"===e.color;const t=40*(e.scaleFactor||1)*(1.3+.9*Math.random());e.blinkPhase=Math.random()*Ap,e.blinkSpeed=.3+1.2*Math.random(),e.blinkIntensity=.6+.4*Math.random(),e.fadePhase=Math.random()*Ap,e.fadeSpeed=.1+.3*Math.random(),e.minOpacity=.2+.2*Math.random(),e.maxOpacity=.8+.2*Math.random(),e.isSparkle&&(e.blinkSpeed*=2,e.blinkIntensity=1,e.minOpacity=0,e.maxOpacity=1),e.behaviorData={angle:Math.random()*Ap,radius:t,baseRadius:t,angularVelocity:8e-4+.0017*Math.random(),swayAmount:3+7*Math.random(),swaySpeed:.2+.5*Math.random(),floatOffset:Math.random()*Ap,floatSpeed:.3+.7*Math.random(),floatAmount:2+6*Math.random(),twinklePhase:Math.random()*Ap,twinkleSpeed:2+3*Math.random()}},update:function(e,t,n,a){const i=e.behaviorData;i.angle+=i.angularVelocity*t;const r=Math.sin(i.angle*i.swaySpeed)*i.swayAmount,s=6*Math.sin(1.5*i.angle),o=(i.radius||i.baseRadius)+s+.2*r,l=n+Math.cos(i.angle)*o,c=a+Math.sin(i.angle)*o;i.floatOffset+=i.floatSpeed*t*.001;const h=Math.sin(i.floatOffset)*i.floatAmount;e.vx=.1*(l-e.x),e.vy=.1*(c+h-e.y),e.fadePhase+=e.fadeSpeed*t*.001;const d=.5*Math.sin(e.fadePhase)+.5,u=e.minOpacity+(e.maxOpacity-e.minOpacity)*d;let p;e.blinkPhase+=e.blinkSpeed*t*.002,e.isSparkle?(i.twinklePhase+=i.twinkleSpeed*t*.001,p=.7*Math.pow(Math.sin(i.twinklePhase),16)+.2*Math.sin(5*e.blinkPhase)+.1):p=.4*Math.sin(e.blinkPhase)+.3*Math.sin(3*e.blinkPhase)+.2*Math.sin(7*e.blinkPhase)+.1*Math.sin(11*e.blinkPhase);const m=.5*(p+1),f=.2+m*e.blinkIntensity*.8;e.opacity=e.baseOpacity*u*f,e.isSparkle?e.size=e.baseSize*(.5+1*m):e.size=e.baseSize*(.8+.3*m),e.isSparkle&&(e.tempColor=m>.85?"#FFFFFF":e.color)}},Tp={name:"rising",emoji:"",description:"Buoyant upward movement like balloons",initialize:function(e){e.vx=.02*(Math.random()-.5),e.vy=-.05-.03*Math.random(),e.lifeDecay=.002,e.baseOpacity=.7+.3*Math.random(),e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={buoyancy:.001,driftAmount:.005}},update:function(e,t,n,a){const i=e.behaviorData;e.vy-=i.buoyancy*t,e.vx+=(Math.random()-.5)*i.driftAmount*t,e.vx*=Math.pow(.995,t),e.vy*=Math.pow(.998,t)}};function Pp(e){e.fallingData||(e.fallingData={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??e.life??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),fallProgress:0}),e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors));const t=Math.random(),n=Math.random(),a=t*Math.PI*2,i=2*n-1,r=Math.sqrt(1-i*i);e.behaviorData={fallSpeed:8,fallDistance:400,wobbleAmount:1.5,fallingDir:{x:r*Math.cos(a),y:i,z:r*Math.sin(a)},orbitDistanceRatio:.7+.4*Math.random()}}var Dp={name:"falling",emoji:"",description:"Heavy downward drift like tears",initialize:Pp,update:function(e,t,n,a){const i=e.behaviorData;let r=e.fallingData;r||(Pp(e),r=e.fallingData),r.fallProgress+=.02*t;const s=Math.min(r.fallProgress,1),o=i.fallDistance*s;r.wobblePhase+=r.wobbleSpeed*t*.1;const l=Math.sin(r.wobblePhase)*i.wobbleAmount;if(e.x=r.originalX+l,e.y=r.originalY+o,e.vx=.3*l,e.vy=10*i.fallSpeed,s>.6){const t=(s-.6)/.4;e.opacity=r.originalOpacity*(1-t),void 0!==e.life&&(e.life=r.originalOpacity*(1-t))}}};const Op=2e3,Ep=3,Ip=8,kp=.7;var Rp={name:"popcorn",emoji:"",description:"Spontaneous popping with gravity and bounces",initialize:function(e){if(e.vx=.1*(Math.random()-.5),e.vy=.1*(Math.random()-.5),e.lifeDecay=.008+.012*Math.random(),e.emotionColors&&e.emotionColors.length>0)e.color=Mp(e.emotionColors);else{const t=["#FFFFFF","#FFFACD","#FFF8DC","#FFFFE0","#FAFAD2"];e.color=Mp(t)}e.size=Math.random()<.3?(8+4*Math.random())*e.scaleFactor*e.particleSizeMultiplier:(2+4*Math.random())*e.scaleFactor*e.particleSizeMultiplier,e.baseSize=e.size,e.hasGlow=Math.random()<.2,e.glowSizeMultiplier=e.hasGlow?1.2:0,e.behaviorData={popDelay:Math.random()*Op,hasPopped:!1,popStrength:Ep+Math.random()*(Ip-Ep),gravity:.098,bounceDamping:kp,bounceCount:0,maxBounces:2+Math.floor(2*Math.random()),spinRate:10*(Math.random()-.5),lifetime:0}},update:function(e,t,n,a){const i=e.behaviorData;if(i.lifetime+=16.67*t,!i.hasPopped&&i.lifetime>i.popDelay){i.hasPopped=!0;const t=Math.random()*Math.PI*2;e.vx=Math.cos(t)*i.popStrength*1.5,e.vy=Math.sin(t)*i.popStrength-.3,e.size=1.25*e.baseSize}if(i.hasPopped){e.vy+=i.gravity*t;const n=a+100*e.scaleFactor;e.y>n&&i.bounceCount<i.maxBounces&&(e.y=n,e.vy=-Math.abs(e.vy)*i.bounceDamping,e.vx*=.9,i.bounceCount++,e.size=e.baseSize*(1.5-.1*i.bounceCount)),i.bounceCount>=i.maxBounces&&(e.lifeDecay=.03+.02*Math.random(),e.size*=.95),Math.sqrt(e.vx*e.vx+e.vy*e.vy)<.5&&(e.lifeDecay*=1.5)}}},zp={name:"burst",emoji:"",description:"Explosive expansion from center",initialize:function(e){const t="suspicion"===e.emotion,n="surprise"===e.emotion,a="glitch"===e.emotion,i=Math.random()*Ap,r=t?1+.8*Math.random():n?7+5*Math.random():a?2+1.5*Math.random():3.5+2.5*Math.random();e.vx=Math.cos(i)*r,e.vy=Math.sin(i)*r,e.lifeDecay=t?.01:n?.006+.008*Math.random():a?.012:.015,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),t&&(e.size=(6+4*Math.random())*(e.scaleFactor||1)*(e.particleSizeMultiplier||1),e.baseSize=e.size,e.opacity=1,e.baseOpacity=e.opacity),e.behaviorData={isSuspicion:t,isSurprise:n,isGlitch:a,age:0,fadeStart:t?.3:.2,glitchPhase:Math.random()*Math.PI*2,glitchIntensity:a?.3:0,glitchFrequency:a?.1:0}},update:function(e,t,n,a){const i=e.behaviorData;if(i.isSurprise)if(i.age+=.016*t,i.age<.15){const n=.98;e.vx*=Math.pow(n,t),e.vy*=Math.pow(n,t)}else if(i.age<.25){const n=.85;e.vx*=Math.pow(n,t),e.vy*=Math.pow(n,t)}else{const n=.99;e.vx*=Math.pow(n,t),e.vy*=Math.pow(n,t),e.vx+=.01*(Math.random()-.5)*t,e.vy+=.01*(Math.random()-.5)*t}else{const n=i.isSuspicion?.99:i.isGlitch?.97:.95;e.vx*=Math.pow(n,t),e.vy*=Math.pow(n,t)}if(i.isSuspicion){const n=.001*Date.now();e.vx+=.01*Math.sin(2*n+e.id)*t}if(i.isGlitch){i.age+=.016*t,i.glitchPhase+=i.glitchFrequency*t;const n=Math.sin(i.glitchPhase)*i.glitchIntensity*t,a=Math.cos(1.3*i.glitchPhase)*i.glitchIntensity*t;if(e.vx+=n,e.vy+=a,Math.random()<.02){const t=Math.random()*Math.PI*2,n=.5+.5*Math.random();e.vx+=Math.cos(t)*n,e.vy+=Math.sin(t)*n}}}},Fp={name:"aggressive",emoji:"",description:"Sharp, chaotic movement with violent bursts",initialize:function(e){const t=Math.random()*Ap,n=1.5+2*Math.random();e.vx=Math.cos(t)*n,e.vy=Math.sin(t)*n,e.lifeDecay=.015,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={acceleration:.05,jitter:.3,speedDecay:.95}},update:function(e,t,n,a){const i=e.behaviorData;if(e.vx+=(Math.random()-.5)*i.jitter*t,e.vy+=(Math.random()-.5)*i.jitter*t,e.vx*=Math.pow(i.speedDecay,t),e.vy*=Math.pow(i.speedDecay,t),Math.random()<Math.min(.05*t,.5)){const t=Math.random()*Ap;e.vx+=Math.cos(t)*i.acceleration,e.vy+=Math.sin(t)*i.acceleration}}},Bp={name:"scattering",emoji:"",description:"Particles flee from center in panic",initialize:function(e){e.vx=0,e.vy=0,e.lifeDecay=.008,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={fleeSpeed:2,panicFactor:1.2,initialized:!1}},update:function(e,t,n,a){const i=e.behaviorData;if(!i.initialized){const t=e.x-n,r=e.y-a,s=Math.sqrt(t*t+r*r);if(s>0)e.vx=t/s*i.fleeSpeed,e.vy=r/s*i.fleeSpeed;else{const t=Math.random()*Ap;e.vx=Math.cos(t)*i.fleeSpeed,e.vy=Math.sin(t)*i.fleeSpeed}i.initialized=!0}const r=e.x-n,s=e.y-a,o=Math.sqrt(r*r+s*s);o>0&&(e.vx+=r/o*i.panicFactor*.01*t,e.vy+=s/o*i.panicFactor*.01*t),e.vx+=.1*(Math.random()-.5)*t,e.vy+=.1*(Math.random()-.5)*t,e.vx*=Math.pow(.98,t),e.vy*=Math.pow(.98,t)}},Lp={name:"repelling",emoji:"",description:"Particles pushed away from center, maintaining distance",initialize:function(e){e.vx=0,e.vy=0,e.lifeDecay=.01,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={repelStrength:.8,minDistance:50,initialized:!1}},update:function(e,t,n,a){const i=e.behaviorData,r=e.x-n,s=e.y-a,o=Math.sqrt(r*r+s*s);if(!i.initialized||o<i.minDistance){if(o>0){const n=i.repelStrength/Math.max(o,5);e.vx+=r/o*n*t,e.vy+=s/o*n*t}i.initialized=!0}e.vx*=Math.pow(.99,t),e.vy*=Math.pow(.99,t)}},Np={name:"connecting",emoji:"",description:"Chaotic movement with center attraction for social states",initialize:function(e){const t=Math.random()*Ap,n=2+5*Math.random();e.vx=Math.cos(t)*n,e.vy=Math.sin(t)*n,e.lifeDecay=.012,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={attractionForce:.008,chaosFactor:1,friction:.95}},update:function(e,t,n,a){const i=e.behaviorData;e.vx*=Math.pow(i.friction,t),e.vy*=Math.pow(i.friction,t);const r=(n-e.x)*i.attractionForce,s=(a-e.y)*i.attractionForce,o=(Math.random()-.5)*i.chaosFactor,l=(Math.random()-.5)*i.chaosFactor;e.vx+=r+o,e.vy+=s+l}},Vp={name:"resting",emoji:"",description:"Ultra-slow vertical drift for deep rest states",initialize:function(e){e.vx=0,e.vy=-.01,e.lifeDecay=.001,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={upwardSpeed:2e-5,friction:.999}},update:function(e,t,n,a){const i=e.behaviorData;e.vy*=Math.pow(i.friction,t),e.vy-=i.upwardSpeed*t,e.vx=0}},Up={name:"radiant",emoji:"",description:"Particles radiate outward like sunbeams",initialize:function(e){const t=Math.random()*Ap,n=.8+.4*Math.random();if(e.vx=Math.cos(t)*n,e.vy=Math.sin(t)*n,e.lifeDecay=.006,e.emotionColors&&e.emotionColors.length>0)e.color=Mp(e.emotionColors);else{const t=["#FFD700","#FFB347","#FFA500","#FF69B4"];e.color=Mp(t)}e.hasGlow=Math.random()<.7,e.glowSizeMultiplier=e.hasGlow?1.5+.5*Math.random():0,e.behaviorData={radialSpeed:.02,shimmer:Math.random()*Ap,shimmerSpeed:.1,friction:.99}},update:function(e,t,n,a){const i=e.behaviorData,r=e.x-n,s=e.y-a,o=Math.sqrt(r*r+s*s);if(o>0){const n=r/o,a=s/o;e.vx+=n*i.radialSpeed*t,e.vy+=a*i.radialSpeed*t}i.shimmer+=i.shimmerSpeed*t;const l=Math.sin(i.shimmer);e.size=e.baseSize*(1+.2*l),e.opacity=e.baseOpacity*(1+.3*l),e.vx*=Math.pow(i.friction,t),e.vy*=Math.pow(i.friction,t)}};function Gp(e){e.vx=.02*(Math.random()-.5),e.vy=-.03-.02*Math.random(),e.lifeDecay=8e-4,e.size=(6+6*Math.random())*(e.scaleFactor||1)*(e.particleSizeMultiplier||1)*1.33,e.baseSize=e.size,e.baseOpacity=.2+.2*Math.random(),e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={ascensionSpeed:3e-4,waveFactor:.5,waveFrequency:.001,friction:.998,fadeStartDistance:100}}var Wp={name:"ascending",emoji:"",description:"Slow steady upward float like incense smoke",initialize:Gp,update:function(e,t,n,a){const i=e.behaviorData;if(!i)return void Gp(e);e.vx*=Math.pow(i.friction,t),e.vy*=Math.pow(i.friction,t),e.vy-=i.ascensionSpeed*t;const r=Math.sin(e.age*i.waveFrequency*1e3)*i.waveFactor;e.vx+=.001*r*t,void 0===e.initialY&&(e.initialY=e.y);const s=e.initialY-e.y;if(s>i.fadeStartDistance){const t=(s-i.fadeStartDistance)/100,n=Math.max(0,1-t);e.baseOpacity*=.995,n<.5&&(e.lifeDecay*=1.02)}Math.abs(e.vx)>.05&&(e.vx*=Math.pow(.95,t)),e.vy<-.1&&(e.vy=-.1)}},qp={name:"erratic",emoji:"",description:"Nervous jittery movement for anxious states",initialize:function(e){const t=Math.random()*Ap,n=.1+.15*Math.random();e.vx=Math.cos(t)*n,e.vy=Math.sin(t)*n,e.lifeDecay=.004,e.size=(2+4*Math.random())*(e.scaleFactor||1)*(e.particleSizeMultiplier||1),e.baseSize=e.size,e.baseOpacity=.4+.3*Math.random(),e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={jitterStrength:.02,directionChangeRate:.1,speedVariation:.3,spinRate:.05+.1*Math.random()}},update:function(e,t){const n=e.behaviorData;if(e.vx+=(Math.random()-.5)*n.jitterStrength*t,e.vy+=(Math.random()-.5)*n.jitterStrength*t,Math.random()<Math.min(n.directionChangeRate*t,.5)){const t=Math.random()*Ap,n=Math.sqrt(e.vx*e.vx+e.vy*e.vy);e.vx=Math.cos(t)*n,e.vy=Math.sin(t)*n}const a=1+(Math.random()-.5)*n.speedVariation*t;e.vx*=a,e.vy*=a;const i=e.age*n.spinRate*1e3;e.size=e.baseSize*(1+.2*Math.sin(i)),e.opacity=e.baseOpacity*(.8+.4*Math.random()),e.vx*=Math.pow(.98,t),e.vy*=Math.pow(.98,t);const r=Math.sqrt(e.vx*e.vx+e.vy*e.vy);r>.5&&(e.vx=e.vx/r*.5,e.vy=e.vy/r*.5)}},Hp={name:"cautious",emoji:"",description:"Slow careful movement with watchful pauses",initialize:function(e){const t=Math.random()*Ap,n=.02+.03*Math.random();e.vx=Math.cos(t)*n,e.vy=Math.sin(t)*n,e.lifeDecay=.001,e.life=1,e.size=(4+4*Math.random())*(e.scaleFactor||1)*(e.particleSizeMultiplier||1),e.baseSize=e.size,e.baseOpacity=.8+.2*Math.random(),e.opacity=e.baseOpacity,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={pauseTimer:2*Math.random(),pauseDuration:.5+.5*Math.random(),moveDuration:1+.5*Math.random(),isMoving:Math.random()>.5,moveTimer:0,originalVx:e.vx,originalVy:e.vy,watchRadius:50+30*Math.random()}},update:function(e,t,n,a){const i=e.behaviorData;if(i.moveTimer+=t,i.isMoving)i.moveTimer>i.moveDuration?(i.isMoving=!1,i.moveTimer=0,e.vx=0,e.vy=0):(e.vx=i.originalVx,e.vy=i.originalVy);else if(i.moveTimer>i.pauseDuration){i.isMoving=!0,i.moveTimer=0;const t=Math.random()*Ap,n=.02+.03*Math.random();e.vx=Math.cos(t)*n,e.vy=Math.sin(t)*n,i.originalVx=e.vx,i.originalVy=e.vy}const r=e.x-n,s=e.y-a,o=Math.sqrt(r*r+s*s);if(o>i.watchRadius){const n=.02;e.vx-=r/o*n*t,e.vy-=s/o*n*t}e.vx*=Math.pow(.995,t),e.vy*=Math.pow(.995,t),i.isMoving?e.opacity=e.baseOpacity:e.opacity=e.baseOpacity*(.9+.1*Math.sin(5*e.age))}},jp={name:"surveillance",emoji:"",description:"Searchlight scanning with paranoid watchfulness",initialize(e,t){e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorState={scanAngle:Math.random()*Math.PI-Math.PI/2,scanDirection:Math.random()<.5?1:-1,scanSpeed:.3+.2*Math.random(),scanRange:Math.PI/3+Math.random()*Math.PI/4,scanCenter:Math.random()*Math.PI*2,pauseTimer:0,pauseDuration:500+500*Math.random(),mode:"scanning",modeTimer:0,nextModeChange:2e3+3e3*Math.random(),dartTarget:{x:0,y:0},dartSpeed:0,patrolRadius:150+100*Math.random(),patrolAngle:Math.random()*Math.PI*2,alertLevel:0,lastPosition:{x:e.x,y:e.y}};const n=Math.random();n<.7?e.behaviorState.primaryRole="scanner":n<.9?(e.behaviorState.primaryRole="patroller",e.behaviorState.mode="patrolling"):(e.behaviorState.primaryRole="watcher",e.behaviorState.mode="frozen")},update(e,t,n){const a=e.behaviorState;if(a){switch(a.modeTimer+=16*t,a.modeTimer>a.nextModeChange&&(this.changeMode(e,a,n),a.modeTimer=0,a.nextModeChange=2e3+4e3*Math.random()),a.mode){case"scanning":this.updateScanning(e,t,a,n);break;case"darting":this.updateDarting(e,t,a,n);break;case"frozen":this.updateFrozen(e,t,a,n);break;case"patrolling":this.updatePatrolling(e,t,a,n)}e.vy+=.05*t,e.x+=e.vx*t,e.y+=e.vy*t,a.lastPosition.x=e.x,a.lastPosition.y=e.y}},updateScanning(e,t,n,a){n.pauseTimer>0?(n.pauseTimer-=16*t,e.vx*=.9,e.vy*=.9):(n.scanAngle+=n.scanDirection*n.scanSpeed*t*.02,Math.abs(n.scanAngle)>n.scanRange/2&&(n.scanDirection*=-1,n.pauseTimer=n.pauseDuration,n.scanAngle=Math.sign(n.scanAngle)*n.scanRange/2));const i=n.scanCenter+n.scanAngle,r=.8+.5*n.alertLevel;e.vx=Math.cos(i)*r,e.vy=Math.sin(i)*r*.3},updateDarting(e,t,n,a){const i=n.dartTarget.x-e.x,r=n.dartTarget.y-e.y,s=Math.sqrt(i*i+r*r);s>5?(e.vx=i/s*n.dartSpeed,e.vy=r/s*n.dartSpeed):(n.mode="scanning",n.modeTimer=0)},updateFrozen(e,t,n,a){e.vx*=.95,e.vy*=.95,Math.random()<.01&&(e.vx+=.5*(Math.random()-.5),e.vy+=.5*(Math.random()-.5))},updatePatrolling(e,t,n,a){n.patrolAngle+=.01*t;const i=a.corePosition?.x??a.canvasWidth/2,r=a.corePosition?.y??a.canvasHeight/2,s=i+Math.cos(n.patrolAngle)*n.patrolRadius,o=r+Math.sin(n.patrolAngle)*n.patrolRadius,l=s-e.x,c=o-e.y;e.vx=.02*l,e.vy=.02*c},changeMode(e,t,n){const a=Math.random(),i=n?.corePosition?.x??(n?.canvasWidth/2||e.x),r=n?.corePosition?.y??(n?.canvasHeight/2||e.y);"scanner"===t.primaryRole?a<.1?(t.mode="darting",t.dartTarget={x:i+200*(Math.random()-.5),y:r+200*(Math.random()-.5)},t.dartSpeed=3+2*Math.random()):t.mode=a<.2?"frozen":"scanning":"patroller"===t.primaryRole?t.mode=a<.1?"frozen":"patrolling":t.mode=a<.3?"scanning":"frozen"}},Xp={name:"glitchy",emoji:"",description:"Digital glitch with stuttering orbits and corruption",rhythm:{enabled:!0,glitchTiming:{mode:"subdivision",subdivision:"sixteenth",probability:.3,intensityOnBeat:2,intensityOffBeat:.5},stutterSync:{mode:"pattern",patterns:{dubstep:{freezeOnDrop:!0,dropDuration:100},breakbeat:{randomFreeze:.1,duration:50}}},orbitRhythm:{baseSpeed:"tempo",wobbleSync:"eighth",beatAcceleration:1.5,barReset:!0},rgbSync:{enabled:!0,amount:"intensity",direction:"beat",maxSplit:10},noiseRhythm:{trigger:"accent",duration:50,intensity:"drop"}},initialize(e,t,n,a){e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorState={orbitAngle:Math.random()*Math.PI*2,orbitRadius:300+400*Math.random(),orbitSpeed:.01+.02*Math.random(),glitchTimer:0,nextGlitch:500*Math.random()+100,isGlitching:!1,glitchDuration:0,glitchOffset:{x:0,y:0},stutterTimer:0,nextStutter:200*Math.random()+50,isFrozen:!1,frozenPosition:{x:0,y:0},frozenVelocity:{x:0,y:0},hasGhost:Math.random()<.3,ghostOffset:20*Math.random()+10,ghostAngle:Math.random()*Math.PI*2,rgbSplit:Math.random()<.4,rgbPhase:Math.random()*Math.PI*2,noiseLevel:0,noiseBurst:!1,beatPhase:Math.random()*Math.PI*2,beatFrequency:.05+.03*Math.random(),dropIntensity:0},e.lifeDecay=.0015,e.hasGlow=!0,e.glowSizeMultiplier=3+2*Math.random()},update(e,t,n,a){const i=e.behaviorState;if(!i)return;i.glitchTimer+=16*t,i.stutterTimer+=16*t,i.stutterTimer>i.nextStutter&&(i.isFrozen?(i.isFrozen=!1,i.stutterTimer=0,i.nextStutter=100+300*Math.random(),Math.random()<.3&&(e.x+=60*(Math.random()-.5),e.y+=60*(Math.random()-.5))):(i.isFrozen=!0,i.frozenPosition={x:e.x,y:e.y},i.frozenVelocity={x:e.vx,y:e.vy},i.stutterTimer=0,i.nextStutter=20+40*Math.random())),i.glitchTimer>i.nextGlitch&&!i.isGlitching&&(i.isGlitching=!0,i.glitchDuration=50+100*Math.random(),i.glitchOffset={x:80*(Math.random()-.5),y:80*(Math.random()-.5)},i.glitchTimer=0,Math.random()<.5&&e.emotionColors&&(e.color=Mp(e.emotionColors))),i.isGlitching&&i.glitchTimer>i.glitchDuration&&(i.isGlitching=!1,i.glitchTimer=0,i.nextGlitch=200+800*Math.random(),i.glitchOffset={x:0,y:0}),i.beatPhase+=i.beatFrequency*t;const r=.5*Math.sin(i.beatPhase)+.5;if(i.beatPhase%(4*Math.PI)<.5*Math.PI?i.dropIntensity=Math.min(1,i.dropIntensity+.1*t):i.dropIntensity=Math.max(0,i.dropIntensity-.05*t),i.isFrozen)e.vx=.5*(Math.random()-.5),e.vy=.5*(Math.random()-.5);else{i.orbitAngle+=i.orbitSpeed*t*(1+.5*r);const s=i.orbitRadius*(1+.3*i.dropIntensity*Math.sin(4*i.beatPhase));let o=n+Math.cos(i.orbitAngle)*s,l=a+Math.sin(i.orbitAngle)*s*.6;if(i.isGlitching&&(o+=i.glitchOffset.x*Math.random()*.8,l+=i.glitchOffset.y*Math.random()*.8),i.rgbSplit){const e=3*(1+i.dropIntensity);o+=Math.sin(i.rgbPhase)*e,l+=Math.cos(i.rgbPhase)*e,i.rgbPhase+=.1*t}i.dropIntensity>.8&&Math.random()<.1&&(o+=30*(Math.random()-.5),l+=30*(Math.random()-.5));const c=i.isGlitching?.02:.03;e.vx=(o-e.x)*c,e.vy=(l-e.y)*c,e.vx+=(Math.random()-.5)*r*2,e.vy+=(Math.random()-.5)*r*2}e.x+=e.vx*t,e.y+=e.vy*t,Math.random()<.02&&(e.opacity=.1+.9*Math.random()),e.size=e.baseSize*(1+.3*r+.5*i.dropIntensity)}},Yp={name:"spaz",description:"Ultra-aggressive particles with explosive spread and chaotic motion",initialize(e,t,n,a){e.x=n,e.y=a,e.life=1,e.size=3+4*Math.random();const i=Math.random()*Math.PI*2,r=200+300*Math.random();e.vx=Math.cos(i)*r,e.vy=Math.sin(i)*r,e.behaviorState={explosionPhase:0,explosionTimer:0,explosionDuration:1e3+2e3*Math.random(),chaosTimer:0,nextChaosChange:100+200*Math.random(),chaosAngle:i,chaosSpeed:50+100*Math.random(),spazIntensity:.8+.4*Math.random(),zigzagPattern:Math.random()<.5,spiralPattern:Math.random()<.3,teleportChance:.02,sizePulse:!0,sizePulseSpeed:.1+.05*Math.random(),sizePulsePhase:Math.random()*Math.PI*2,colorShift:Math.random()<.3,colorShiftSpeed:.05+.03*Math.random()},e.lifeDecay=8e-4,e.hasGlow=!0,e.glowSizeMultiplier=4+3*Math.random(),e.glowIntensity=1.5+.5*Math.random()},update(e,t,n,a){const i=e.behaviorState;if(i.explosionTimer+=t,i.chaosTimer+=t,0===i.explosionPhase&&i.explosionTimer<500)e.vx*=.98,e.vy*=.98,Math.random()<.1&&(e.vx+=100*(Math.random()-.5),e.vy+=100*(Math.random()-.5));else if(0===i.explosionPhase&&i.explosionTimer>=500)i.explosionPhase=1,i.chaosAngle=Math.random()*Math.PI*2,i.chaosSpeed=30+70*Math.random();else if(1===i.explosionPhase){i.chaosTimer>=i.nextChaosChange&&(i.chaosAngle=Math.random()*Math.PI*2,i.chaosSpeed=20+80*Math.random(),i.nextChaosChange=50+150*Math.random(),i.chaosTimer=0);const t=Math.cos(i.chaosAngle)*i.chaosSpeed,n=Math.sin(i.chaosAngle)*i.chaosSpeed;if(e.vx=.7*e.vx+.3*t,e.vy=.7*e.vy+.3*n,i.zigzagPattern){const t=.01*i.chaosTimer;e.vx+=20*Math.sin(t),e.vy+=20*Math.cos(t)}if(i.spiralPattern){const t=.005*i.chaosTimer,n=50+30*Math.sin(.003*i.chaosTimer);e.vx+=Math.cos(t)*n*.1,e.vy+=Math.sin(t)*n*.1}}if(Math.random()<i.teleportChance){const t=Math.random()*Math.PI*2,i=200+400*Math.random();e.x=n+Math.cos(t)*i,e.y=a+Math.sin(t)*i,e.vx=200*(Math.random()-.5),e.vy=200*(Math.random()-.5)}if(e.x+=e.vx*(t/1e3),e.y+=e.vy*(t/1e3),i.sizePulse){i.sizePulsePhase+=i.sizePulseSpeed*t;const n=1+.5*Math.sin(i.sizePulsePhase);e.size=(3+4*Math.random())*n}i.colorShift&&(i.colorShiftPhase=(i.colorShiftPhase||0)+i.colorShiftSpeed*t),e.vx*=.995,e.vy*=.995,e.life-=e.lifeDecay*t,(e.life<=0||Math.abs(e.x-n)>2e3||Math.abs(e.y-a)>2e3)&&(e.life=0)},getSpawnPosition(e,t){const n=Math.random()*Math.PI*2,a=100+200*Math.random();return{x:e+Math.cos(n)*a,y:t+Math.sin(n)*a}},getVisualProperties:()=>({glowColor:"#FF00AA",glowIntensity:2,particleColors:[{color:"#FF00AA",weight:30},{color:"#00FFAA",weight:25},{color:"#FFAA00",weight:20},{color:"#AA00FF",weight:15},{color:"#00AAFF",weight:10}]})},$p={name:"directed",emoji:"",description:"Focused, straight-line movement toward target",config:{speed:3,acceleration:.15,focusStrength:.8,randomness:.1,edgeBuffer:50},initialize(e,t,n,a,i){const r=t-e.x,s=n-e.y,o=Math.sqrt(r*r+s*s);if(o>0)e.vx=r/o*this.config.speed,e.vy=s/o*this.config.speed;else{const t=Math.random()*Math.PI*2;e.vx=Math.cos(t)*this.config.speed,e.vy=Math.sin(t)*this.config.speed}e.targetX=t,e.targetY=n,e.directedPhase=0},update(e,t,n,a,i,r){e.directedPhase+=.05*t;const s=e.targetX-e.x,o=e.targetY-e.y,l=Math.sqrt(s*s+o*o);if(l>10){const n=s/l*this.config.speed,a=o/l*this.config.speed;e.vx+=(n-e.vx)*this.config.acceleration*t,e.vy+=(a-e.vy)*this.config.acceleration*t,e.vx+=(Math.random()-.5)*this.config.randomness,e.vy+=(Math.random()-.5)*this.config.randomness}else{const t=Math.random()*Math.PI*2,s=100+200*Math.random();e.targetX=n+Math.cos(t)*s,e.targetY=a+Math.sin(t)*s,e.targetX=Math.max(this.config.edgeBuffer,Math.min(i-this.config.edgeBuffer,e.targetX)),e.targetY=Math.max(this.config.edgeBuffer,Math.min(r-this.config.edgeBuffer,e.targetY))}e.x+=e.vx*t,e.y+=e.vy*t,(e.x<=0||e.x>=i)&&(e.vx*=-.8,e.x=Math.max(0,Math.min(i,e.x)),e.targetX=n+300*(Math.random()-.5)),(e.y<=0||e.y>=r)&&(e.vy*=-.8,e.y=Math.max(0,Math.min(r,e.y)),e.targetY=a+300*(Math.random()-.5))},visuals:{trailLength:"medium",opacity:.9,sizeMultiplier:1,blurAmount:.2}},Qp={name:"fizzy",emoji:"",description:"Bubbly, effervescent movement like carbonation",config:{baseRiseSpeed:2.5,wobbleAmplitude:30,wobbleFrequency:.15,popChance:.002,popForce:8,fizziness:.3,gravity:-.05},initialize(e,t,n,a,i){e.vx=2*(Math.random()-.5),e.vy=-this.config.baseRiseSpeed-2*Math.random(),e.wobblePhase=Math.random()*Math.PI*2,e.wobbleSpeed=this.config.wobbleFrequency*(.8+.4*Math.random()),e.bubbleSize=.5+.5*Math.random(),e.popTimer=0,e.isFizzing=!0},update(e,t,n,a,i,r){e.wobblePhase+=e.wobbleSpeed*t;const s=Math.sin(e.wobblePhase)*this.config.wobbleAmplitude;if(e.vx=.05*s+(Math.random()-.5)*this.config.fizziness,e.vy+=this.config.gravity*t,e.vy+=(Math.random()-.5)*this.config.fizziness,Math.random()<this.config.popChance){const t=Math.random()*Math.PI*2;e.vx=Math.cos(t)*this.config.popForce,e.vy=Math.sin(t)*this.config.popForce*.7,e.popTimer=1,e.bubbleSize=.3+.7*Math.random()}e.popTimer>0&&(e.popTimer-=.05*t,e.vx*=.95,e.vy*=.95),e.x+=e.vx*t,e.y+=e.vy*t,e.y<-50&&(e.y=r+50,e.x=n+300*(Math.random()-.5),e.vy=-this.config.baseRiseSpeed-2*Math.random(),e.bubbleSize=.5+.5*Math.random()),(e.x<=0||e.x>=i)&&(e.vx*=-.5,e.x=Math.max(0,Math.min(i,e.x))),e.y>r+50&&(e.y=r,e.vy=1.5*-this.config.baseRiseSpeed),e.size=e.baseSize*e.bubbleSize*(1+.1*Math.sin(2*e.wobblePhase))},visuals:{trailLength:"short",opacity:.6,sizeMultiplier:1.2,blurAmount:.5,sparkle:!0}};var Kp={name:"zen",emoji:"",description:"Peaceful orbital movement like a hovering aura",initialize:function(e){e.vx=.5*(Math.random()-.5),e.vy=.5*(Math.random()-.5),e.lifeDecay=.003,e.emotionColors&&e.emotionColors.length>0&&(e.color=Mp(e.emotionColors)),e.behaviorData={orbitAngle:Math.random()*Math.PI*2,orbitRadius:40+60*Math.random(),orbitSpeed:8e-4+6e-4*Math.random(),floatOffset:Math.random()*Math.PI*2,breathingOffset:Math.random()*Math.PI*2,lifetime:0}},update:function(e,t,n,a){const i=e.behaviorData;if(!i)return;i.lifetime+=t;const r=(i.lifetime+8e3*i.breathingOffset)/8e3,s=.5*Math.sin(r*Math.PI*2)+.5;e.size=e.baseSize*(.95+.05*s),i.orbitAngle+=i.orbitSpeed*t;const o=10*Math.sin(1e-4*i.lifetime+i.floatOffset),l=i.orbitRadius+o,c=n+Math.cos(i.orbitAngle)*l,h=a+Math.sin(i.orbitAngle)*l,d=15*Math.sin(3e-4*i.lifetime+i.breathingOffset),u=c-e.x,p=h+d-e.y;e.vx=.03*u,e.vy=.03*p,e.vx+=.02*(Math.random()-.5),e.vy+=.02*(Math.random()-.5),e.vx*=.98,e.vy*=.98}};const Zp=new Map;var Jp=function(e){return Zp.get(e)||null},em=function(){return Array.from(Zp.keys())};const tm={};function nm(e){if(tm[e])return tm[e];return Jp(e)||null}function am(e,t){const n=nm(t);return n&&n.initialize?(n.initialize(e),!0):"ambient"!==t&&(console.warn(` Behavior '${t}' not found, falling back to ambient`),am(e,"ambient"))}[_p,$p,Qp,Cp,Tp,Dp,Rp,zp,Fp,Bp,Lp,Np,Vp,Up,Wp,qp,Hp,jp,Xp,Yp,Kp].forEach(e=>{tm[e.name]=e}),"undefined"!=typeof window&&window.DEBUG_PARTICLES&&(window.ParticleBehaviors={registry:tm,list:function(){return[...Object.values(tm).map(e=>({name:e.name,emoji:e.emoji||"",description:e.description||"No description",type:"core"})),...em().map(e=>{const t=Jp(e);return{name:t.name,emoji:t.emoji||"",description:t.description||"Plugin behavior",type:"plugin"}})]},get:nm});const im=new Map;var rm=function(e){return im.get(e)||null},sm=function(){return Array.from(im.keys())},om={name:"breathe",emoji:"",type:"blending",description:"Breathing rhythm with inhale and exhale",config:{musicalDuration:{musical:!0,bars:1,minBeats:2,maxBeats:16},phases:[{name:"inhale",beats:1.5},{name:"hold_in",beats:.5},{name:"exhale",beats:1.5},{name:"hold_out",beats:.5}],inhaleRadius:1.5,exhaleRadius:.3,breathRate:.3,spiralStrength:.002,scaleAmount:.25,glowAmount:.4,frequency:1,easing:"sine",strength:.8,particleMotion:{type:"breathe",strength:.8,inhaleRadius:1.5,exhaleRadius:.3}},rhythm:{enabled:!0,syncMode:"phrase",breathRateSync:{mode:"tempo",bpm:"auto",subdivision:"whole",curve:"sine"},radiusSync:{inhale:{onUpbeat:1.8,onDownbeat:1.4,curve:"ease-in"},exhale:{onUpbeat:.2,onDownbeat:.4,curve:"ease-out"}},durationSync:{mode:"phrases",phrases:2,hold:"fermata"},accentResponse:{enabled:!0,multiplier:1.5,type:"expansion"},patternOverrides:{ballad:{breathRateSync:{subdivision:"double-whole"},radiusSync:{inhale:{onUpbeat:2.2,onDownbeat:1.8},exhale:{onUpbeat:.1,onDownbeat:.2}}},uptempo:{breathRateSync:{subdivision:"half"},radiusSync:{inhale:{onUpbeat:1.4,onDownbeat:1.2},exhale:{onUpbeat:.3,onDownbeat:.4}}},ambient:{breathRateSync:{subdivision:"whole",curve:"ease"},radiusSync:{inhale:{onUpbeat:1.6,onDownbeat:1.6},exhale:{onUpbeat:.2,onDownbeat:.2}}}},dynamics:{forte:{radiusSync:{inhale:{multiplier:1.8},exhale:{multiplier:.5}},spiralStrength:.004,scaleAmount:.4},piano:{radiusSync:{inhale:{multiplier:1.2},exhale:{multiplier:.8}},spiralStrength:.001,scaleAmount:.1}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a;e.gestureData.breathe={startX:e.x,startY:e.y,angle:Math.atan2(r,i),baseRadius:Math.sqrt(i*i+r*r),phaseOffset:.2*Math.random()-.1}},apply(e,t,n,a,i,r){e.gestureData?.breathe||this.initialize(e,n,i,r);const s={...this.config,...n},o=(Math.sin(t*Math.PI*2*s.breathRate)+1)/2,l=100*(e.scaleFactor||1),c=s.inhaleRadius*l,h=s.exhaleRadius*l,d=h+(c-h)*o,u=e.x-i,p=e.y-r,m=Math.sqrt(u*u+p*p),f=d-m,g=.05*(n.strength||.8)*a;if(m>0){const t=u/m*f*g,i=p/m*f*g;e.vx+=t,e.vy+=i;const r=s.spiralStrength*a*(n.strength||1),l=-p/m,c=u/m;e.vx+=l*r*o,e.vy+=c*r*o}e.vx*=.98,e.vy*=.98},cleanup(e){e.gestureData?.breathe&&delete e.gestureData.breathe},"3d":{evaluate(e,t){const n=(t.config||{}).breathRate||.3,a=Math.sin(e*Math.PI*2*n);let i=1;if(e>.8){const t=(e-.8)/(1-.8);i=1-t*t*t}const r=.2*a*i;return{position:[0,.05*a*i,0],rotation:[0,0,0],scale:1+.35*a*i,glowIntensity:1+r,glowBoost:Math.max(0,2*r)}}}},lm={name:"expand",emoji:"",type:"blending",description:"Radial expansion from center",config:{duration:600,scaleAmount:3,scaleTarget:3,glowAmount:.5,easing:"back",strength:3,particleMotion:{type:"pulse",strength:3,direction:"outward",persist:!0}},rhythm:{enabled:!0,syncMode:"crescendo",strengthSync:{pianissimo:1.5,fortissimo:5,crescendo:"build",sforzando:"burst"},scaleTargetSync:{verse:2,chorus:4.5,climax:6,curve:"exponential"},durationSync:{mode:"phrases",build:1.2,release:.8,sustain:"hold"},accentResponse:{enabled:!0,multiplier:2.8,type:"strength"},patternOverrides:{orchestral:{strengthSync:{pianissimo:2,fortissimo:6.5,crescendo:"dramatic"},scaleTargetSync:{climax:8}},rock:{strengthSync:{pianissimo:1.8,fortissimo:5.5,curve:"power"},accentResponse:{multiplier:3.2}},ambient:{strengthSync:{pianissimo:1.2,fortissimo:3.5,crescendo:"organic"},durationSync:{build:1.8,release:1.2}},electronic:{strengthSync:{pianissimo:1.6,fortissimo:4.8,curve:"digital"},scaleTargetSync:{curve:"linear"}}},dynamics:{forte:{strengthSync:{pianissimo:{multiplier:1.4},fortissimo:{multiplier:1.8}},scaleTargetSync:{multiplier:1.6},accentResponse:{multiplier:3.5}},piano:{strengthSync:{pianissimo:{multiplier:.8},fortissimo:{multiplier:1.2}},scaleTargetSync:{multiplier:.7},accentResponse:{multiplier:2}}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a;e.gestureData.expand={startX:e.x,startY:e.y,angle:Math.atan2(r,i),baseRadius:Math.sqrt(i*i+r*r),initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.expand?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.expand,o={...this.config,...n},l=o.strength||1,c=1+(o.scaleTarget-1)*t*l,h=s.baseRadius*c,d=i+Math.cos(s.angle)*h,u=r+Math.sin(s.angle)*h,p=d-e.x,m=u-e.y;e.vx+=.8*p*a,e.vy+=.8*m*a,e.vx*=.95,e.vy*=.95},cleanup(e){e.gestureData?.expand&&delete e.gestureData.expand},"3d":{evaluate(e,t){const n={...this.config,...t},a=n.strength||3;return{position:[0,0,0],rotation:[0,0,0],scale:1+e*(n.scaleAmount||3)*(a/3),glowIntensity:1+.25*e,glowBoost:.8*e}}}},cm={name:"contract",emoji:"",type:"blending",description:"Radial contraction toward center",config:{duration:600,scaleAmount:.2,scaleTarget:.2,glowAmount:-.2,easing:"cubic",strength:2.5,particleMotion:{type:"pulse",strength:2.5,direction:"inward",persist:!0}},rhythm:{enabled:!0,syncMode:"tension",strengthSync:{onTension:4,onRelease:1.5,curve:"magnetic"},scaleTargetSync:{forte:.1,piano:.4,crescendo:"gradual",diminuendo:"ease"},durationSync:{mode:"phrases",shortPhrase:.8,longPhrase:1.5,hold:"sustain"},accentResponse:{enabled:!0,multiplier:2.2,type:"strength"},patternOverrides:{classical:{strengthSync:{onTension:3.5,onRelease:1.8},scaleTargetSync:{forte:.15,piano:.35}},metal:{strengthSync:{onTension:5,onRelease:2,curve:"sharp"},scaleTargetSync:{forte:.05,piano:.25}},ambient:{strengthSync:{onTension:2.8,onRelease:1.2,curve:"ease"},durationSync:{shortPhrase:1.2,longPhrase:2}},trap:{strengthSync:{onTension:4.5,onRelease:1,dropBeat:6},scaleTargetSync:{forte:.08,piano:.3}}},dynamics:{forte:{strengthSync:{onTension:{multiplier:1.8},onRelease:{multiplier:1.4}},scaleTargetSync:{multiplier:.6},accentResponse:{multiplier:2.8}},piano:{strengthSync:{onTension:{multiplier:.7},onRelease:{multiplier:.8}},scaleTargetSync:{multiplier:1.4},accentResponse:{multiplier:1.6}}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a;e.gestureData.contract={startX:e.x,startY:e.y,angle:Math.atan2(r,i),baseRadius:Math.sqrt(i*i+r*r),initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.contract?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.contract,o={...this.config,...n},l=o.strength||1,c=1-(1-o.scaleTarget)*t*l,h=s.baseRadius*c,d=i+Math.cos(s.angle)*h,u=r+Math.sin(s.angle)*h,p=d-e.x,m=u-e.y;e.vx+=.5*p*a,e.vy+=.5*m*a,e.vx*=.95,e.vy*=.95},cleanup(e){e.gestureData?.contract&&delete e.gestureData.contract},"3d":{evaluate(e,t){const n={...this.config,...t},a=n.strength||2.5,i=n.scaleTarget||.2,r=1-e*(1-i)*(a/2.5),s=1-.15*e;return{position:[0,0,0],rotation:[0,0,0],scale:Math.max(i,r),glowIntensity:s}}}},hm={name:"pulse",emoji:"",type:"blending",description:"Radial expansion and contraction from center",config:{duration:600,amplitude:30,frequency:1,holdPeak:.1,easing:"sine",scaleAmount:.2,glowAmount:.3,strength:.15,direction:"outward",particleMotion:{type:"pulse",strength:.15,direction:"outward",frequency:1}},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.6,offBeat:.8,curve:"pulse"},frequencySync:{mode:"locked",subdivision:"quarter"},durationSync:{mode:"beats",beats:1},accentResponse:{enabled:!0,multiplier:2},patternOverrides:{waltz:{amplitudeSync:{onBeat:2,offBeat:.5},durationSync:{beats:3}},swing:{amplitudeSync:{onBeat:1.8,offBeat:.6,curve:"ease"},frequencySync:{subdivision:"swing"}},dubstep:{amplitudeSync:{onBeat:1.2,dropBeat:4,curve:"pulse"}},breakbeat:{frequencySync:{mode:"random",range:[.5,2]},amplitudeSync:{onBeat:2.5,offBeat:.3}}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a,s=Math.sqrt(i*i+r*r),o=Math.atan2(r,i);e.gestureData.pulse={baseDistance:s,angle:o,startX:e.x,startY:e.y,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.pulse?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.pulse,o={...this.config,...n},l=n.strength||1,c=this.easeInOutSine(t);let h,{frequency:d}=o,{amplitude:u}=o;n.rhythmModulation&&(u*=n.rhythmModulation.amplitudeMultiplier||1,u*=n.rhythmModulation.accentMultiplier||1,n.rhythmModulation.frequencyMultiplier&&(d*=n.rhythmModulation.frequencyMultiplier));const p=c*d*2%2;h=o.holdPeak>0&&p>1-o.holdPeak&&p<1+o.holdPeak?1:Math.sin(c*Math.PI*2*d);const m=h*u*l*e.scaleFactor,f=s.baseDistance+m,g=i+Math.cos(s.angle)*f,y=r+Math.sin(s.angle)*f,v=.15*a;if(e.vx+=(g-e.x)*v*.1,e.vy+=(y-e.y)*v*.1,t>.9){const n=1-10*(t-.9);e.vx*=.9+.1*n,e.vy*=.9+.1*n}},cleanup(e){e.gestureData?.pulse&&delete e.gestureData.pulse},easeInOutSine:e=>-(Math.cos(Math.PI*e)-1)/2,"3d":{evaluate(e,t){const n=t||{},a=n.frequency||1,i=n.strength||.15,r=n.scaleAmount||.2,s=n.glowAmount||.3,o=-(Math.cos(Math.PI*e)-1)/2,l=Math.sin(o*Math.PI*2*a);return{position:[0,0,0],rotation:[0,0,0],scale:1+l*r*i,glowIntensity:1+Math.max(-.3,Math.min(.3,l*s*i*2)),glowBoost:Math.max(0,.8*l)}}}},dm={name:"sway",type:"blending",emoji:"",description:"Gentle side-to-side swaying motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},amplitude:20,frequency:1,strength:.5},rhythm:{enabled:!0,syncMode:"bar",amplitudeSync:{onBeat:1.2,offBeat:.9,curve:"ease"},durationSync:{mode:"bars",bars:1},patternOverrides:{waltz:{durationSync:{bars:1},amplitudeSync:{onBeat:1.5,curve:"ease"}},swing:{amplitudeSync:{onBeat:1.3,offBeat:.7,curve:"bounce"}}}},apply(e,t,n,a,i,r){const s={...this.config,...n},o=s.amplitude||this.config.amplitude,l=s.frequency||this.config.frequency,c=s.strength||this.config.strength,h=Math.sin(t*Math.PI*2*l)*o;e.vx+=.01*h*a*c,e.vy+=.5*Math.cos(t*Math.PI*4)*a*c},cleanup(e){},"3d":{evaluate(e,t){const n={...this.config,...t};let a=n.amplitude||this.config.amplitude;const i=n.frequency||this.config.frequency,r=n.strength||this.config.strength;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);const s=Math.sin(e*Math.PI*2*i),o=a*r*.3*.01,l=.15*s*r,c=.08*s*r;return{position:[s*o,.3*Math.cos(e*Math.PI*4)*o,Math.sin(e*Math.PI*i)*o*.5],rotation:[0,c,l],scale:1}}}},um={name:"float",type:"blending",emoji:"",description:"Gentle floating upward motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:2},amplitude:80,wobbleAmount:20,strength:1},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},wobbleSync:{subdivision:"eighth",intensity:.7},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:1.3},patternOverrides:{waltz:{wobbleSync:{subdivision:"quarter",intensity:.9}},dubstep:{amplitudeSync:{onBeat:2,curve:"pulse"}}}},apply(e,t,n,a,i,r){e.gestureData||(e.gestureData={}),e.gestureData.float||(e.gestureData.float={originalSize:e.size,originalOpacity:e.opacity||1});const s={...this.config,...n};let o=s.amplitude||this.config.amplitude,l=s.wobbleAmount||this.config.wobbleAmount;const c=s.strength||this.config.strength;n.rhythmModulation&&(o*=n.rhythmModulation.amplitudeMultiplier||1,o*=n.rhythmModulation.accentMultiplier||1,l*=n.rhythmModulation.wobbleMultiplier||1);const h=Math.sin(t*Math.PI*4)*l;e.vy-=.01*o*a*c*(1-.5*t),e.vx+=.01*h*a*c,e.size=e.baseSize*(1+.1*t),e.opacity=1-.3*t},cleanup(e){e.gestureData?.float?(e.opacity=e.gestureData.float.originalOpacity,e.size=e.gestureData.float.originalSize,delete e.gestureData.float):(e.opacity=1,e.size=e.baseSize),e.vx*=.5,e.vy*=.5},"3d":{evaluate(e,t){const n={...this.config,...t};let a=n.amplitude||this.config.amplitude,i=n.wobbleAmount||this.config.wobbleAmount;const r=n.strength||this.config.strength;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1,i*=t.rhythmModulation.wobbleMultiplier||1);const s=Math.sin(e*Math.PI),o=a*s*r*.005,l=Math.sin(e*Math.PI*4)*i*.3*.005,c=Math.sin(e*Math.PI)*Math.PI*.5*r,h=Math.sin(e*Math.PI);return{position:[l,o,0],rotation:[h*Math.sin(e*Math.PI*2)*.1,c,h*Math.cos(e*Math.PI*3)*.08],scale:1+.1*s}}}};const pm={left:{x:-1,y:0},right:{x:1,y:0},up:{x:0,y:1},down:{x:0,y:-1}};function mm(e){return e.charAt(0).toUpperCase()+e.slice(1)}function fm(e){const t=pm[e];if(!t)throw new Error(`Invalid float direction: ${e}`);const n="up"===e||"down"===e;return{name:`float${mm(e)}`,emoji:"up"===e?"":"down"===e?"":"left"===e?"":"",type:"blending",description:`Gentle floating ${e}`,config:{duration:2e3,amplitude:80,wobbleAmount:20,strength:1,direction:e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},wobbleSync:{subdivision:"eighth",intensity:.7},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:1.3}},apply(e,a,i,r,s,o){e.gestureData||(e.gestureData={}),e.gestureData.float||(e.gestureData.float={originalSize:e.size,originalOpacity:e.opacity||1});const l={...this.config,...i};let c=l.amplitude||80,h=l.wobbleAmount||20;const d=l.strength||1;i.rhythmModulation&&(c*=i.rhythmModulation.amplitudeMultiplier||1,c*=i.rhythmModulation.accentMultiplier||1,h*=i.rhythmModulation.wobbleMultiplier||1);const u=Math.sin(a*Math.PI*4)*h,p=.01*c*r*d*(1-.5*a);n?(e.vy+=t.y*p,e.vx+=.01*u*r*d):(e.vx+=t.x*p,e.vy+=.01*u*r*d),e.size=e.baseSize*(1+.1*a),e.opacity=1-.3*a},cleanup(e){e.gestureData?.float?(e.opacity=e.gestureData.float.originalOpacity,e.size=e.gestureData.float.originalSize,delete e.gestureData.float):(e.opacity=1,e.size=e.baseSize),e.vx*=.5,e.vy*=.5},"3d":{evaluate(e,a){const i=a||{};let r=i.amplitude||80,s=i.wobbleAmount||20;const o=i.strength||1;a.rhythmModulation&&(r*=a.rhythmModulation.amplitudeMultiplier||1,r*=a.rhythmModulation.accentMultiplier||1,s*=a.rhythmModulation.wobbleMultiplier||1);const l=Math.sin(e*Math.PI),c=r*l*o*.005,h=Math.sin(e*Math.PI*4)*s*.3*.005,d=Math.sin(e*Math.PI)*Math.PI*.5*o,u=Math.sin(e*Math.PI),p=u*Math.sin(e*Math.PI*2)*.1,m=u*Math.cos(e*Math.PI*3)*.08,f=1+.1*l;let g=0,y=0;return n?(y=t.y*c,g=h):(g=t.x*c,y=h),{cameraRelativePosition:[g,y,0],rotation:[p,d,m],scale:f}}}}}var gm=fm("up"),ym=fm("down"),vm=fm("left"),bm=fm("right"),wm={name:"lean",emoji:"",type:"blending",description:"Diagonal tilting motion with smooth return",config:{duration:1200,musicalDuration:{musical:!0,beats:2},amplitude:10,frequency:1,direction:"right",strength:.7,particleMotion:{type:"lean",direction:"right",strength:.7,frequency:1}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.3,offBeat:.8,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.4},patternOverrides:{waltz:{durationSync:{beats:3},amplitudeSync:{onBeat:1.5,offBeat:.6}},swing:{amplitudeSync:{onBeat:1.6,offBeat:.5,curve:"bounce"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.lean={startX:e.x,startY:e.y,startVx:e.vx,startVy:e.vy,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.lean?.initialized||this.initialize(e,n);const s={...this.config,...n},o=s.strength||this.config.strength||1,l=this.easeInOutCubic(t),c=s.frequency||this.config.frequency;let h=s.amplitude*o*e.scaleFactor;n.rhythmModulation&&(h*=n.rhythmModulation.amplitudeMultiplier||1,h*=n.rhythmModulation.accentMultiplier||1);const d=Math.sin(l*Math.PI*c),u="left"===s.direction?-1:1;if(e.vx+=d*h*.015*a*u,e.vy+=d*h*.01*a*u*.5,t>.9){const n=1-10*(t-.9);e.vx=e.vx*(.95+.05*n),e.vy=e.vy*(.95+.05*n)}},cleanup(e){e.gestureData?.lean&&delete e.gestureData.lean},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const n=t||{},a=n.amplitude||10,i=n.frequency||1,r=n.strength||.7,s=n.direction||"right",o=.003*a*r,l=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,c=Math.sin(l*Math.PI*i),h="left"===s?-1:1;return{position:[c*o*h,0,0],rotation:[0,0,.35*c*h],scale:1}}}};function xm(e){if("left"!==e&&"right"!==e)throw new Error(`Invalid lean direction: ${e}. Only 'left' and 'right' are supported.`);const t=pm[e];return{name:`lean${mm(e)}`,emoji:"left"===e?"":"",type:"blending",description:`Lean ${e} with smooth return`,config:{duration:800,amplitude:10,frequency:1,strength:.7,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:1.3,offBeat:.8,curve:"ease"},accentResponse:{enabled:!0,multiplier:1.4}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.lean={startX:e.x,startY:e.y,initialized:!0}},apply(e,n,a,i,r,s){e.gestureData?.lean?.initialized||this.initialize(e,a);const o={...this.config,...a},l=o.strength||.7,c=this.easeInOutCubic(n);let h=o.amplitude*l*e.scaleFactor;a.rhythmModulation&&(h*=a.rhythmModulation.amplitudeMultiplier||1,h*=a.rhythmModulation.accentMultiplier||1);const d=Math.sin(c*Math.PI*o.frequency);if(e.vx+=d*h*.015*i*t.x,e.vy+=d*h*.01*i*t.x*.5,n>.9){const t=1-10*(n-.9);e.vx*=.95+.05*t,e.vy*=.95+.05*t}},cleanup(e){e.gestureData?.lean&&delete e.gestureData.lean},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,n){const a=n||{},i=a.amplitude||10,r=a.frequency||1,s=.003*i*(a.strength||.7),o=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,l=Math.sin(o*Math.PI*r),c=.35*l*t.x;return{cameraRelativePosition:[l*s*t.x,0,0],cameraRelativeRotation:[0,0,c],scale:1}}}}}var Sm=xm("left"),Mm=xm("right"),_m={name:"jitter",type:"blending",emoji:"",description:"Nervous jittery movement",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},intensity:15,frequency:30,strength:1},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:2,offBeat:.5,curve:"pulse"},patternOverrides:{breakbeat:{amplitudeSync:{onBeat:3,offBeat:.3}},dubstep:{amplitudeSync:{onBeat:5,offBeat:.1,curve:"pulse"}}}},apply(e,t,n,a,i,r){e.gestureData||(e.gestureData={}),e.gestureData.jitter||(e.gestureData.jitter={originalSize:e.size});const s={...this.config,...n};let o=s.intensity||this.config.intensity;const l=s.strength||this.config.strength;n.rhythmModulation&&(o*=n.rhythmModulation.amplitudeMultiplier||1,o*=n.rhythmModulation.accentMultiplier||1);const c=(Math.random()-.5)*o*l,h=(Math.random()-.5)*o*l,d=1-.5*t;e.vx+=.1*c*a*d,e.vy+=.1*h*a*d,e.size=e.baseSize*(1+.1*(Math.random()-.5))},cleanup(e){e.gestureData?.jitter?(e.size=e.gestureData.jitter.originalSize,delete e.gestureData.jitter):e.size=e.baseSize,e.vx*=.7,e.vy*=.7},"3d":{evaluate(e,t){const n={...this.config,...t};let a=n.intensity||this.config.intensity;const i=n.strength||this.config.strength;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);const r=Math.sin(e*Math.PI),s=a*i*.002*r;return{position:[(Math.random()-.5)*s,(Math.random()-.5)*s,(Math.random()-.5)*s],rotation:[.005*(Math.random()-.5)*r,.005*(Math.random()-.5)*r,.005*(Math.random()-.5)*r],scale:1+.02*(Math.random()-.5)*r}}}},Am={name:"twitch",emoji:"",type:"blending",description:"Nervous, paranoid twitching",config:{intensity:8,frequency:.08,duration:100,musicalDuration:{musical:!0,beats:.5},recovery:200,maxOffset:15,sharpness:.9},rhythm:{enabled:!0,syncMode:"subdivision",durationSync:{mode:"beats",beats:.5},probabilitySync:{subdivision:"sixteenth",onBeat:.3,offBeat:.05,accentBoost:2},intensitySync:{onBeat:2,offBeat:.8,curve:"pulse"},patternOverrides:{breakbeat:{probabilitySync:{onBeat:.5,offBeat:.1},intensitySync:{onBeat:3,offBeat:.5}},dubstep:{intensitySync:{onBeat:1.5,dropBeat:5,curve:"pulse"}}}},apply(e,t,n,a,i,r){e.gestureData||(e.gestureData={}),e.gestureData.twitch||(e.gestureData.twitch={twitchOffset:{x:0,y:0},targetOffset:{x:0,y:0},isTwitching:!1,twitchTimer:0,cooldownTimer:0,lastTwitch:0});const s=e.gestureData.twitch,{config:o}=this;let l=n.intensity||o.intensity;n.rhythmModulation&&(l*=n.rhythmModulation.amplitudeMultiplier||1,l*=n.rhythmModulation.accentMultiplier||1,n.rhythmModulation.probabilityMultiplier);const c=Date.now();if(!s.isTwitching&&s.cooldownTimer<=0&&Math.random()<(n.frequency||o.frequency)){s.isTwitching=!0,s.twitchTimer=o.duration,s.cooldownTimer=o.recovery;const e=Math.random()*Math.PI*2,t=.5*o.maxOffset+Math.random()*(.5*o.maxOffset);s.targetOffset={x:Math.cos(e)*t*l/8,y:Math.sin(e)*t*l/8},s.lastTwitch=c}if(s.cooldownTimer>0&&(s.cooldownTimer-=16*a),s.isTwitching)if(s.twitchTimer-=16*a,s.twitchTimer>0){const{sharpness:e}=o;s.twitchOffset.x+=(s.targetOffset.x-s.twitchOffset.x)*e,s.twitchOffset.y+=(s.targetOffset.y-s.twitchOffset.y)*e}else s.isTwitching=!1;else s.twitchOffset.x*=.85,s.twitchOffset.y*=.85;e.vx+=s.twitchOffset.x*a*.5,e.vy+=s.twitchOffset.y*a*.5,Math.random()<.1&&(e.vx+=(Math.random()-.5)*l*.3,e.vy+=(Math.random()-.5)*l*.3)},cleanup(e){e.gestureData?.twitch&&delete e.gestureData.twitch},"3d":{evaluate(e,t){const n=t.config||{};let a=.6*(n.intensity||8);const i=n.maxOffset||15,r=n.frequency||.08;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);const s=9999*Math.floor(10*e),o=e=>{const t=1e4*Math.sin(s+e);return t-Math.floor(t)};if(o(0)<3*r){const e=o(1)*Math.PI*2,t=i*a/8*.003;return{position:[Math.cos(e)*t*o(2),Math.sin(e)*t*o(3),(o(4)-.5)*t],rotation:[.12*(o(5)-.5),.12*(o(6)-.5),.12*(o(7)-.5)],scale:1+.06*(o(8)-.5)}}{const e=.3;return{position:[(o(10)-.5)*e,(o(11)-.5)*e,(o(12)-.5)*e],rotation:[.006*(o(13)-.5),.006*(o(14)-.5),.006*(o(15)-.5)],scale:1}}}}},Cm={name:"vibrate",emoji:"",type:"blending",description:"High frequency vibration",config:{duration:500,frequency:20,amplitude:8,easing:"linear",strength:2,particleMotion:{type:"shake",strength:2,frequency:20,amplitude:8}},rhythm:{enabled:!0,syncMode:"subdivision",frequencySync:{subdivision:"thirty-second",baseFrequency:20,tempoScaling:!0},amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"pulse"},durationSync:{mode:"beats",beats:1},patternOverrides:{dubstep:{frequencySync:{subdivision:"sixteenth"},amplitudeSync:{onBeat:2,dropBeat:3}},breakbeat:{frequencySync:{mode:"random",range:[15,30]}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.vibrate={timer:0,seed:1e3*Math.random(),initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.vibrate?.initialized||this.initialize(e,n);const s=e.gestureData.vibrate,o={...this.config,...n},l=o.strength||this.config.strength||1;let{amplitude:c}=o,{frequency:h}=o;n.rhythmModulation&&(c*=n.rhythmModulation.amplitudeMultiplier||1,c*=n.rhythmModulation.accentMultiplier||1,n.rhythmModulation.frequencyMultiplier&&(h*=n.rhythmModulation.frequencyMultiplier)),s.timer+=a*h;const d=(Math.random()-.5)*c*l,u=(Math.random()-.5)*c*l;if(e.vx+=.5*d*a,e.vy+=.5*u*a,e.vx*=.9,e.vy*=.9,t>.8){const n=1-5*(t-.8);e.vx*=n,e.vy*=n}},cleanup(e){e.gestureData?.vibrate&&delete e.gestureData.vibrate},"3d":{evaluate(e,t){const n={...this.config,...t};let{amplitude:a}=n;const i=n.strength||this.config.strength||1;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);const r=Math.sin(e*Math.PI),s=a*i*.003*r;return{position:[(Math.random()-.5)*s,(Math.random()-.5)*s,(Math.random()-.5)*s],rotation:[.01*(Math.random()-.5)*r,.01*(Math.random()-.5)*r,.01*(Math.random()-.5)*r],scale:1+.01*(Math.random()-.5)*r}}}},Tm={name:"shake",emoji:"",type:"blending",description:"Random jitter movement for vibration effects",config:{duration:400,amplitude:15,frequency:15,decay:.9,smoothing:.1,axes:"both",easing:"linear",strength:3,particleMotion:{type:"shake",strength:3,frequency:15,decay:!1}},rhythm:{enabled:!0,syncMode:"subdivision",amplitudeSync:{subdivision:"sixteenth",onBeat:2.5,offBeat:.7,curve:"pulse"},frequencySync:{mode:"tempo",baseFrequency:15,scaling:"linear"},durationSync:{mode:"beats",beats:2},patternOverrides:{breakbeat:{amplitudeSync:{onBeat:3,offBeat:.2},frequencySync:{mode:"random",range:[8,20]}},dubstep:{amplitudeSync:{subdivision:"eighth",onBeat:4,dropBeat:6,curve:"pulse"}},swing:{amplitudeSync:{onBeat:1.8,offBeat:1,curve:"ease"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.shake={originalX:e.x,originalY:e.y,randomAngle:Math.random()*Math.PI*2,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.shake?.initialized||this.initialize(e,n);const s=e.gestureData.shake,o={...this.config,...n},l=o.strength||this.config.strength||1;let{amplitude:c}=o,{frequency:h}=o;n.rhythmModulation&&(c*=n.rhythmModulation.amplitudeMultiplier||1,c*=n.rhythmModulation.accentMultiplier||1,n.rhythmModulation.frequencyMultiplier&&(h*=n.rhythmModulation.frequencyMultiplier));const d=o.decay?1-t:1,u=Math.sin(t*Math.PI*h)*c*d*l*e.scaleFactor,p=u*Math.cos(s.randomAngle),m=u*Math.sin(s.randomAngle);e.x=s.originalX+p,e.y=s.originalY+m},pseudoRandom(e){const t=1e4*Math.sin(e);return t-Math.floor(t)},cleanup(e){e.gestureData?.shake&&(e.x=e.gestureData.shake.originalX,e.y=e.gestureData.shake.originalY,delete e.gestureData.shake)},"3d":{evaluate(e,t){const n=t||{},a=.003*(n.amplitude||15),i=n.frequency||15,r=.5*(n.strength||1),s=n.decay?1-e:1,o=Math.sin(e*Math.PI*i)*a*s*r,l=Math.floor(e*i);return{position:[o*(1e4*Math.sin(l)%1-.5)*2,0,o*(1e4*Math.sin(1.3*l)%1-.5)*2],rotation:[0,0,o*(1e4*Math.sin(1.7*l)%1-.5)*.2],scale:1}}}},Pm={name:"wiggle",emoji:"",type:"additive",description:"Rapid side-to-side oscillation",config:{duration:600,musicalDuration:{musical:!0,beats:1},amplitude:15,frequency:6,strength:1,damping:.3,easing:"linear",particleMotion:{type:"wiggle",strength:1,amplitude:15,frequency:6}},rhythm:{enabled:!0,syncMode:"beat",frequencySync:{subdivision:"sixteenth",wigglePerBeat:4},amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},durationSync:{mode:"beats",beats:1}},apply(e,t,n,a,i,r,s){const o=(n.amplitude||this.config.amplitude)*i,l=n.frequency||this.config.frequency,c=1-a*(n.damping||this.config.damping),h=Math.sin(a*Math.PI*l)*o*c;e.vx+=.5*h;const d=Math.cos(a*Math.PI*l*2)*o*.1*c;e.vy+=.3*d},"3d":{evaluate(e,t){const n=t.config||{},a=t.strength||1,i=n.amplitude||15,r=Math.pow(1-e,.5),s=Math.sin(e*Math.PI*14)*r,o=Math.cos(e*Math.PI*14*.7)*r*.4,l=i/15*a,c=.15*s*a;return{cameraRelativePosition:[.08*s*l,.02*Math.abs(o)*l,0],cameraRelativeRotation:[0,0,c],scale:1+.05*Math.abs(s),glowIntensity:1+.2*Math.abs(s)}}}};function Dm(e){const t=pm[e];if(!t)throw new Error(`Invalid step direction: ${e}`);return{name:`step${mm(e)}`,emoji:"left"===e?"":"right"===e?"":"up"===e?"":"",type:"blending",description:`Quick step ${e} and return`,config:{duration:400,amplitude:25,strength:.7,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:5,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"snap"}},apply(e,n,a,i,r,s){const o={...this.config,...a};let l,c=o.amplitude*o.strength*e.scaleFactor;a.rhythmModulation&&(c*=a.rhythmModulation.amplitudeMultiplier||1,c*=a.rhythmModulation.accentMultiplier||1),l=n<.3?this.easeOutQuad(n/.3):1-this.easeInOutCubic((n-.3)/.7);const h=t.x*c*l*.01*i,d=t.y*c*l*.01*i;e.vx+=h,e.vy+=d},cleanup(e){},easeOutQuad:e=>1-(1-e)*(1-e),easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,n){const a=n||{},i=a.amplitude||25,r=a.strength||.7;let s,o=.008*i*r;if(n.rhythmModulation&&(o*=n.rhythmModulation.amplitudeMultiplier||1),e<.3)s=1-(1-e/.3)*(1-e/.3);else{const t=(e-.3)/.7;s=1-(t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2)}const l=t.x*o*s,c=t.y*o*s,h=.12*s*r,d=-t.x*h;return{cameraRelativePosition:[l,c,0],rotation:[t.y*h*.5,0,d],scale:1}}}}}function Om(e){const t=pm[e];if(!t)throw new Error(`Invalid slide direction: ${e}`);return{name:`slide${mm(e)}`,emoji:"left"===e?"":"",type:"blending",description:`Smooth slide ${e} and return`,config:{duration:800,amplitude:35,strength:.6,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:1.2,offBeat:.9,curve:"ease"}},apply(e,n,a,i,r,s){const o={...this.config,...a};let l=o.amplitude*o.strength*e.scaleFactor;a.rhythmModulation&&(l*=a.rhythmModulation.amplitudeMultiplier||1,l*=a.rhythmModulation.accentMultiplier||1);const c=Math.sin(n*Math.PI),h=t.x*l*c*.008*i,d=t.y*l*c*.008*i;e.vx+=h,e.vy+=d},cleanup(e){},"3d":{evaluate(e,n){const a=n||{},i=a.amplitude||35,r=a.strength||.6;let s=.008*i*r;n.rhythmModulation&&(s*=n.rhythmModulation.amplitudeMultiplier||1);const o=Math.sin(e*Math.PI),l=t.x*s*o,c=t.y*s*o,h=.08*o*r,d=-t.x*h,u=t.x*h*.5;return{cameraRelativePosition:[l,c,.02*Math.sin(e*Math.PI*2)*r],rotation:[0,u,d],scale:1+.03*o}}}}}var Em=Dm("left"),Im=Dm("right"),km=Dm("up"),Rm=Dm("down"),zm=Om("left"),Fm=Om("right"),Bm={name:"runningman",emoji:"",type:"effect",description:"Hip-hop running man shuffle",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},slideDistance:30,stepHeight:15,speed:1.2,strength:.8,particleMotion:{type:"runningman",strength:.7}},rhythm:{enabled:!0,syncToBeat:!0,durationSync:{mode:"bars",bars:1},beatMultiplier:1,accentBeats:[1,3]},apply:(e,t,n,a,i,r)=>!1,blend:(e,t,n)=>!1,"3d":{evaluate(e,t){const n={...this.config,...t}.strength||.8;return{position:[.1*Math.sin(e*Math.PI*4)*n,.05*Math.abs(Math.sin(e*Math.PI*8))*n,0],rotation:[0,0,.035*Math.sin(e*Math.PI*4)*n],scale:1-.035*Math.abs(Math.sin(e*Math.PI*8))*n,glowIntensity:1+.25*Math.abs(Math.sin(e*Math.PI*8)),glowBoost:.35*Math.max(0,Math.abs(Math.sin(e*Math.PI*8)))}}}},Lm={name:"charleston",emoji:"",type:"effect",description:"Hip-hop Charleston shuffle with crisscross",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},kickDistance:35,swivelRange:40,bounceHeight:12,strength:.9,particleMotion:{type:"charleston",strength:.8}},rhythm:{enabled:!0,syncToBeat:!0,durationSync:{mode:"bars",bars:1.5},beatMultiplier:2,accentBeats:[1,2.5,3,4.5]},apply:(e,t,n,a,i,r)=>!1,blend:(e,t,n)=>!1,"3d":{evaluate(e,t){const n={...this.config,...t}.strength||.9;return{position:[.12*Math.sin(e*Math.PI*8)*n,.05*Math.abs(Math.sin(e*Math.PI*8))*n,0],rotation:[0,0,.05*Math.sin(e*Math.PI*8)*n],scale:1-.04*Math.abs(Math.sin(e*Math.PI*8))*n,glowIntensity:1+.3*Math.abs(Math.sin(e*Math.PI*8)),glowBoost:.4*Math.max(0,Math.abs(Math.sin(e*Math.PI*8)))}}}},Nm={name:"hula",emoji:"",type:"override",description:"Hula-hoop motion with vertical waves",config:{speed:.015,maintainRadius:!1,elliptical:!0,use3D:!0,zPhaseOffset:Math.PI/4,verticalOscillation:.3,wobbleAmount:.15,duration:2500,musicalDuration:{musical:!0,bars:1.5},particleMotion:{type:"hula",strength:1,verticalOscillation:.3}},rhythm:{enabled:!0,syncMode:"bar",durationSync:{mode:"bars",bars:1.5},speedSync:{mode:"tempo",baseSpeed:.015,scaling:"proportional"},wobbleSync:{onBeat:.25,offBeat:.1,curve:"sine"},verticalSync:{subdivision:"quarter",amplitude:.4,phase:"sequential"},dynamics:{forte:{wobbleAmount:.3,speed:1.2},piano:{wobbleAmount:.05,speed:.8}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a,s=Math.sqrt(i*i+r*r),o=Math.random()<.5?1:-1,l=Math.max(s,100+180*Math.random()),c=s<5?Math.random()*Math.PI*2:Math.atan2(r,i);e.gestureData.hula={radius:l,angle:c,initialAngle:c,originalVx:e.vx,originalVy:e.vy,originalZ:e.z||0,zPhase:Math.random()*Math.PI*2,wobblePhase:Math.random()*Math.PI*2,direction:o}},apply(e,t,n,a,i,r){e.gestureData?.hula||this.initialize(e,n,i,r);const s=e.gestureData.hula,o=(n.speed||this.config.speed)*(n.strength||1);let l=1;t<.1?(l=t/.1,l=Math.sin(l*Math.PI*.5)):t>.9&&(l=(1-t)/.1,l=Math.sin(l*Math.PI*.5)),s.angle+=o*a*s.direction*l;const c=Math.sin(2*s.angle+s.wobblePhase)*(n.wobbleAmount||this.config.wobbleAmount)*l,h=s.radius*(1+c)*l,d=s.radius*(.7+c)*l,u=i+Math.cos(s.angle)*h,p=r+Math.sin(s.angle)*d;if(t<.1){const t=e.x-i,n=e.y-r;Math.sqrt(t*t+n*n)<50?(e.x=i+Math.cos(s.angle)*h,e.y=r+Math.sin(s.angle)*d):(e.x=e.x+(u-e.x)*l*.5,e.y=e.y+(p-e.y)*l*.5)}else e.x=u,e.y=p;const m=s.angle+s.zPhase+(n.zPhaseOffset||this.config.zPhaseOffset);e.z=.9*Math.sin(m)*l;const f=n.verticalOscillation||this.config.verticalOscillation,g=Math.cos(2*m)*f*s.radius*.2*l;e.y+=g;const y=e.z*s.radius*.1;e.y-=y;const v=-Math.sin(s.angle)*h*o,b=Math.cos(s.angle)*d*o;t<.1?(e.vx=s.originalVx+(v-s.originalVx)*l,e.vy=s.originalVy+(b-s.originalVy)*l):t>.9?(e.vx=v*l+s.originalVx*(1-l),e.vy=b*l+s.originalVy*(1-l),e.z=e.z*l+s.originalZ*(1-l)):(e.vx=v,e.vy=b)},cleanup(e){if(e.gestureData?.hula){const t=e.gestureData.hula;e.vx=t.originalVx,e.vy=t.originalVy,e.z=t.originalZ,delete e.gestureData.hula}},"3d":{evaluate(e,t){const{particle:n}=t;if(!n||!n.gestureData?.hula)return{position:[0,0,0],rotation:[0,0,0],scale:1};const a=n.gestureData.hula,i=t.config||{};let r=1;e<.15?(r=e/.15,r=Math.sin(r*Math.PI*.5)):e>.85&&(r=(1-e)/.15,r=Math.sin(r*Math.PI*.5));const s=a.initialAngle+e*Math.PI*2*a.direction,o=.25*Math.cos(s)*r,l=.25*Math.sin(s)*r,c=i.verticalOscillation||.3;return{position:[o,Math.sin(2*s+a.wobblePhase)*c*r,l],rotation:[0,(s-a.initialAngle)*r,0],scale:1+.15*Math.abs(Math.sin(s))*r}}}},Vm={name:"twist",emoji:"",type:"override",description:"Twisting dance motion with alternating rotation",config:{duration:1200,musicalDuration:{musical:!0,beats:3},rotationAngle:45,contractionFactor:.8,twistFrequency:2,easing:"smooth",strength:.8,particleMotion:{type:"twist",rotationAngle:45,contractionFactor:.8,twistFrequency:2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!1,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"elastic"},patternOverrides:{funk:{rotationAngle:60,contractionFactor:.7},disco:{twistFrequency:3,rotationAngle:50},latin:{rotationAngle:35,contractionFactor:.85,twistFrequency:2.5}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.twist={startX:e.x,startY:e.y,startAngle:Math.atan2(e.y-t.centerY,e.x-t.centerX),startDistance:Math.sqrt(Math.pow(e.x-t.centerX,2)+Math.pow(e.y-t.centerY,2)),initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.twist?.initialized||this.initialize(e,{...n,centerX:i,centerY:r});const s={...this.config,...n},o=e.gestureData.twist,l=s.strength||this.config.strength||1,c=t*s.twistFrequency*Math.PI*2,h=Math.sin(c)*l;let{rotationAngle:d}=s,{contractionFactor:u}=s;n.rhythmModulation&&(d*=n.rhythmModulation.amplitudeMultiplier||1,u=1-(1-u)*(n.rhythmModulation.amplitudeMultiplier||1));const p=d*Math.PI/180*h,m=1-(1-u)*Math.abs(h),f=o.startAngle+p,g=o.startDistance*m,y=i+Math.cos(f)*g,v=r+Math.sin(f)*g,b=.15*l;e.x+=(y-e.x)*b,e.y+=(v-e.y)*b,e.vx=.05*(y-e.x),e.vy=.05*(v-e.y);const w=5*Math.sin(t*Math.PI*4)*l;if(e.y+=.1*w,t>.9){const n=1-10*(t-.9);e.vx*=n,e.vy*=n}},cleanup(e){e.gestureData?.twist&&delete e.gestureData.twist},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||.8,i=e>.85?(1-e)/.15:1,r=e*(n.twistFrequency||2)*Math.PI*2,s=Math.sin(r)*a*i,o=s*((n.rotationAngle||45)*Math.PI/180);return{position:[.05*Math.sin(r)*a*i,.02*Math.abs(Math.sin(2*r))*a*i,0],rotation:[.08*Math.cos(r)*a*i,o,.12*Math.sin(.5*r)*a*i],scale:1-(1-(n.contractionFactor||.8))*Math.abs(s),glowIntensity:1+.3*Math.abs(s)}}}},Um={name:"pop",emoji:"",type:"blending",description:"Quick scale pulse - the classic beat hit",config:{duration:200,musicalDuration:{musical:!0,beats:.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:.5},interruptible:!0,priority:5,blendable:!0},apply:(e,t,n)=>!1,blend:(e,t,n)=>!1,"3d":{isAccent:!0,evaluate(e,t){const n=t?.strength||1;let a;return e<.15?(a=e/.15,a=1-Math.pow(1-a,3)):(a=1-(e-.15)/.85,a=Math.pow(a,2)),{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+.08*a*n,glowBoost:.3*a*n,positionBoost:[0,.02*a*n,0]}}}},Gm={name:"flare",emoji:"",type:"blending",description:"Dramatic scale burst with intense glow - for big moments",config:{duration:400,musicalDuration:{musical:!0,beats:1},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1},interruptible:!0,priority:6,blendable:!0},apply:(e,t,n)=>!1,blend:(e,t,n)=>!1,"3d":{isAccent:!0,evaluate(e,t){const n=t?.strength||1;let a;if(e<.1){const t=e/.1;a=1-Math.pow(1-t,4)}else if(e<.3){const t=(e-.1)/.2;a=1-.1*Math.sin(t*Math.PI)}else a=1-(e-.3)/.7,a=Math.pow(a,.6);return{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+(.15*a+.15*Math.sin(e*Math.PI*4)*(1-e)*.02)*n,glowBoost:.8*a*n,positionBoost:[0,.04*a*n,0]}}}},Wm={name:"swell",emoji:"",type:"blending",description:"Glow build with scale - for transitions and builds",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1.5},interruptible:!0,priority:4,blendable:!0},apply:(e,t,n)=>!1,blend:(e,t,n)=>!1,"3d":{isAccent:!0,evaluate(e,t){const n=t?.strength||1;let a;if(e<.6){const t=e/.6;a=t*t}else{const t=(e-.6)/.4;a=1-t*t}return{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+.1*a*n,glowBoost:.4*a*n,positionBoost:[0,.03*Math.sin(e*Math.PI)*n,0]}}}},qm={name:"swagger",emoji:"",type:"blending",description:"Side lean with drift - confident swagger",config:{duration:400,musicalDuration:{musical:!0,beats:1},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1},interruptible:!0,priority:4,blendable:!0},apply:(e,t,n)=>!1,blend:(e,t,n)=>!1,"3d":{isAccent:!0,evaluate(e,t){const n=t?.strength||1;let a;if(e<.3){const t=e/.3;a=1-Math.pow(1-t,2)}else if(e<.7)a=1;else{const t=(e-.7)/.3;a=1-t*t}return{position:[0,0,0],rotation:[0,0,0],scale:1,rotationBoost:[0,0,.12*a*n*1],positionBoost:[.04*a*n*1,.01*a*n,0],scaleBoost:1+.03*a*n}}}},Hm={name:"dip",emoji:"",type:"blending",description:"Downward bob - groove dip feel",config:{duration:250,musicalDuration:{musical:!0,beats:.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:.5},interruptible:!0,priority:5,blendable:!0},apply:(e,t,n)=>!1,blend:(e,t,n)=>!1,"3d":{isAccent:!0,evaluate(e,t){const n=t?.strength||1,a=Math.sin(e*Math.PI);return{position:[0,0,0],rotation:[0,0,0],scale:1,positionBoost:[0,.015*-a*n,0],scaleBoost:1-.015*a*n}}}},jm={name:"bounce",emoji:"",type:"blending",description:"Vertical oscillation with smooth easing",config:{duration:800,musicalDuration:{musical:!0,beats:2},amplitude:30,frequency:2,axis:"vertical",damping:!0,easing:"sine",strength:.6,particleMotion:{type:"bounce",axis:"vertical",strength:.6,frequency:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.8,offBeat:.6,curve:"bounce"},frequencySync:{mode:"tempo",multiplier:1},durationSync:{mode:"beats",beats:4},accentResponse:{enabled:!0,multiplier:1.5},patternOverrides:{waltz:{frequencySync:{multiplier:.75},durationSync:{beats:3}},swing:{amplitudeSync:{onBeat:2,offBeat:.4,curve:"ease"}},dubstep:{amplitudeSync:{onBeat:1.5,dropBeat:3,curve:"pulse"}},breakbeat:{frequencySync:{multiplier:1.5},amplitudeSync:{onBeat:2.2,offBeat:.3}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.bounce={startY:e.y,startX:e.x,startVx:e.vx,startVy:e.vy,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.bounce?.initialized||this.initialize(e,n);const s={...this.config,...n},o=s.strength||this.config.strength||1,l=this.easeInOutCubic(t);let{frequency:c}=s;const h=n.phase||0;let d=s.amplitude*o*e.scaleFactor;n.rhythmModulation&&(d*=n.rhythmModulation.amplitudeMultiplier||1,d*=n.rhythmModulation.accentMultiplier||1,n.rhythmModulation.frequencyMultiplier&&(c*=n.rhythmModulation.frequencyMultiplier));const u=Math.sin((l+h)*Math.PI*2*c);if(s.damping&&t>.7&&(d*=1-(t-.7)/.3*.8),"vertical"===s.axis?(e.vy+=u*d*.01*a,t>.9&&(e.vx*=.98)):"horizontal"===s.axis&&(e.vx+=u*d*.01*a,t>.9&&(e.vy*=.98)),t>.9){const n=1-10*(t-.9);e.vx=e.vx*(.95+.05*n),e.vy=e.vy*(.95+.05*n)}},cleanup(e){e.gestureData?.bounce&&delete e.gestureData.bounce},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const n=t||{},a=n.amplitude||30,i=n.frequency||2,r=.003*a*(n.strength||.6),s=(e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2)*Math.PI*i,o=Math.abs(Math.sin(s));let l=r;return e>.7&&(l*=1-(e-.7)/.3*.8),{position:[0,o*l,0],rotation:[0,0,0],scale:1+.08*o}}}},Xm={name:"orbit",emoji:"",type:"override",description:"Orbital motion around center",config:{speed:.02,maintainRadius:!0,elliptical:!1,use3D:!0,zPhaseOffset:0,verticalOscillation:0,duration:3e3,musicalDuration:{musical:!0,bars:2},particleMotion:{type:"orbit",strength:1}},rhythm:{enabled:!0,syncMode:"harmonic",durationSync:{mode:"bars",bars:2},speedSync:{tonic:.02,fifth:.03,octave:.04,third:.025,curve:"smooth"},radiusSync:{bass:150,mid:100,treble:50,scaling:"logarithmic"},depthSync:{major:{z:1,phase:0},minor:{z:-1,phase:Math.PI},diminished:{z:.5,phase:Math.PI/2},augmented:{z:.8,phase:-Math.PI/2}},phaseSync:{mode:"harmonic",intervals:[1,1.5,2],drift:.05},dynamics:{forte:{speed:.04,maintainRadius:!1},piano:{speed:.01,maintainRadius:!0}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a,s=Math.sqrt(i*i+r*r),o=Math.random()<.5?1:-1,l=Math.max(s,100+180*Math.random()),c=s<5?Math.random()*Math.PI*2:Math.atan2(r,i);e.gestureData.orbit={radius:l,targetRadius:l,angle:c,initialAngle:c,originalVx:e.vx,originalVy:e.vy,originalZ:e.z||0,zPhase:Math.random()*Math.PI*2,direction:o}},apply(e,t,n,a,i,r){e.gestureData?.orbit||this.initialize(e,n,i,r);const s=e.gestureData.orbit,o=(n.speed||this.config.speed)*(n.strength||1);s.angle+=o*a*s.direction;let{radius:l}=s;if(n.maintainRadius||(l=s.radius*(1+.1*Math.sin(t*Math.PI*2))),e.x=i+Math.cos(s.angle)*l,e.y=r+Math.sin(s.angle)*l,!1!==n.use3D){const t=s.angle+s.zPhase+(n.zPhaseOffset||0);if(e.z=.8*Math.sin(t),n.verticalOscillation){const a=Math.cos(t)*n.verticalOscillation*l*.1;e.y+=a}}if(e.vx=-Math.sin(s.angle)*l*o,e.vy=Math.cos(s.angle)*l*o,t>.9){const n=10*(1-t);e.vx=e.vx*n+s.originalVx*(1-n),e.vy=e.vy*n+s.originalVy*(1-n)}},cleanup(e){if(e.gestureData?.orbit){const t=e.gestureData.orbit;e.vx=t.originalVx,e.vy=t.originalVy,e.z=t.originalZ,delete e.gestureData.orbit}},"3d":{evaluate(e,t){const n=t?.particle;if(!n||!n.gestureData?.orbit)return{position:[0,0,0],rotation:[0,0,0],scale:1};const a=n.gestureData.orbit;let i=1;e<.15?i=Math.sin(e/.15*Math.PI*.5):e>.85&&(i=Math.sin((1-e)/.15*Math.PI*.5));const r=a.initialAngle+e*Math.PI*2*a.direction,s=.3*Math.cos(r)*i,o=.3*Math.sin(r)*i,l=(r+Math.PI/2-(a.initialAngle+Math.PI/2))*i,c=n.z||0;return{position:[s,0,o+.1*c*i],rotation:[0,l,0],scale:1+.15*c*i}}}};function Ym(e){const t=pm[e];if(!t)throw new Error(`Invalid orbit direction: ${e}`);const n="up"===e||"down"===e,a="left"===e||"up"===e?1:-1;return{name:`orbit${mm(e)}`,emoji:"left"===e?"":"right"===e?"":"up"===e?"":"",type:"override",description:`Orbit ${"left"===e?"counter-clockwise":"right"===e?"clockwise":e}`,config:{duration:1500,musicalDuration:{musical:!0,beats:4},speed:.02,maintainRadius:!0,use3D:!0,rotations:1,strength:1,direction:e,verticalOscillation:n?.3:0,particleMotion:{type:"orbit",strength:1,rotations:1}},rhythm:{enabled:!0,syncMode:"harmonic",durationSync:{mode:"bars",bars:1},speedSync:{tonic:.02,fifth:.03,octave:.04,curve:"smooth"},radiusSync:{bass:150,mid:100,treble:50,scaling:"logarithmic"},dynamics:{forte:{speed:.04,maintainRadius:!1},piano:{speed:.01,maintainRadius:!0}}},initialize(e,t,n,i){e.gestureData||(e.gestureData={});const r=e.x-n,s=e.y-i,o=Math.sqrt(r*r+s*s),l=Math.max(o,80+100*Math.random()),c=o<5?Math.random()*Math.PI*2:Math.atan2(s,r);e.gestureData.orbit={radius:l,targetRadius:l,angle:c,initialAngle:c,originalVx:e.vx,originalVy:e.vy,originalZ:e.z||0,zPhase:Math.random()*Math.PI*2,direction:a,initialized:!0}},apply(e,a,i,r,s,o){e.gestureData?.orbit?.initialized||this.initialize(e,i,s,o);const l=e.gestureData.orbit,c={...this.config,...i},h=i.strength||1,d=(c.speed||.02)*h;let u=1;a<.15?(u=a/.15,u=Math.sin(u*Math.PI*.5)):a>.85&&(u=(1-a)/.15,u=Math.sin(u*Math.PI*.5)),l.angle+=d*r*l.direction*u;let{radius:p}=l;c.maintainRadius||(p=l.radius*(1+.1*Math.sin(a*Math.PI*2)));const m=p*u+(1-u)*l.radius*.5;if(e.x=s+Math.cos(l.angle)*m,e.y=o+Math.sin(l.angle)*m,!1!==c.use3D){const i=l.angle+l.zPhase;if(e.z=.8*Math.sin(i)*u,n&&c.verticalOscillation){const n=t.y*a*c.verticalOscillation*p*.5;e.y+=n}}if(e.vx=-Math.sin(l.angle)*m*d*u,e.vy=Math.cos(l.angle)*m*d*u,a>.9){const t=10*(1-a);e.vx=e.vx*t+l.originalVx*(1-t),e.vy=e.vy*t+l.originalVy*(1-t)}},cleanup(e){if(e.gestureData?.orbit){const t=e.gestureData.orbit;e.vx=t.originalVx,e.vy=t.originalVy,e.z=t.originalZ,delete e.gestureData.orbit}},"3d":{evaluate(e,i){const r=i.config||i||{},s=i.strength||1,o=r.rotations||1;let l=1;e<.15?l=Math.sin(e/.15*Math.PI*.5):e>.85&&(l=Math.sin((1-e)/.15*Math.PI*.5));const c=.25*s,h=e*Math.PI*2*o*a,d=Math.cos(h)*c*l,u=Math.sin(h)*c*l;let p=0;return n&&(p=t.y*e*.2*s*l),{cameraRelativePosition:[d,p,u],rotation:[0,h*l*.5,0],scale:1+.2*u}}}}}var $m=Ym("left"),Qm=Ym("right"),Km=Ym("up"),Zm=Ym("down"),Jm={name:"jump",emoji:"",type:"override",description:"Squash, leap, and land with classic animation principles",config:{duration:800,musicalDuration:{musical:!0,beats:2},jumpHeight:60,squashAmount:.8,stretchAmount:1.2,anticipation:.2,hangTime:.1,landingImpact:!0,driftOutward:!0,easing:"quad",particleMotion:{type:"jump",strength:.9,jumpHeight:60,squash:.8,stretch:1.2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},phaseSync:{anticipation:"eighth",jump:"beat",landing:"sixteenth"},heightSync:{onBeat:1.5,offBeat:.8,accent:2,curve:"exponential"},deformationSync:{squashOnBeat:.6,stretchOnBeat:1.4,timing:"anticipatory"},hangTimeSync:{mode:"tempo",baseDuration:.1,scaling:"inverse"},dynamics:{forte:{jumpHeight:80,stretch:1.3},piano:{jumpHeight:30,stretch:1.1}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={}),e.gestureData.jump={startX:e.x,startY:e.y,startSize:e.size,originalVx:e.vx,originalVy:e.vy,driftDirection:.1*(e.x-n),initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.jump?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.jump,o={...this.config,...n},l=n.strength||1,c=o.jumpHeight*l*e.scaleFactor,h=o.squashAmount,d=o.stretchAmount,u=o.anticipation,p=1-.5*o.anticipation;if(t<u){const n=t/u,a=this.easeOutQuad(n);e.size=s.startSize*(1-(1-h)*a),e.y=s.startY+5*a*e.scaleFactor,e.vx=0,e.vy=0}else if(t<p){const n=(t-u)/(p-u);let a=Math.sin(n*Math.PI);if(o.hangTime>0&&n>.4&&n<.6){const e=(n-.4)/.2;a=.95+.05*this.easeInOutCubic(e)}if(e.y=s.startY-a*c,o.driftOutward&&(e.x=s.startX+a*s.driftDirection),n<.5){const t=2*n;e.size=s.startSize*(h+(d-h)*t)}else{const t=2*(n-.5);e.size=s.startSize*(d-(d-1)*t*.8)}e.vx=.5*s.driftDirection,e.vy=-Math.cos(n*Math.PI)*c*.1}else{const n=(t-p)/(1-p),a=this.easeOutBounce(n);if(e.y=s.startY,o.landingImpact)if(n<.3){const t=n/.3;e.size=s.startSize*(1-(1-.8*h)*(1-t))}else{const t=(n-.3)/.7;e.size=s.startSize*(.8*h+(1-.8*h)*t)}else e.size=s.startSize*(h+(1-h)*a);e.vx=s.originalVx*a,e.vy=s.originalVy*a}},cleanup(e){if(e.gestureData?.jump){const t=e.gestureData.jump;e.size=t.startSize,e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.jump}},easeOutQuad:e=>e*(2-e),easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutBounce(e){const t=7.5625,n=2.75;return e<1/n?t*e*e:e<2/n?t*(e-=1.5/n)*e+.75:e<2.5/n?t*(e-=2.25/n)*e+.9375:t*(e-=2.625/n)*e+.984375},"3d":{evaluate(e,t){const n=t.config||t||{},a=t.strength||1,i=.004*(n.jumpHeight||60)*a,r=n.squashAmount||.8,s=n.stretchAmount||1.2,o=n.anticipation||.2,l=1-.5*o;let c=0,h=1,d=0;if(e<o){const t=e/o,n=t*(2-t);h=1-(1-r)*n,c=.02*-n}else if(e<l){const t=(e-o)/(l-o);c=Math.sin(t*Math.PI)*i,h=t<.5?r+2*t*(s-r):s-2*(t-.5)*(s-1)*.8,d=.05*Math.sin(t*Math.PI)}else{const t=(e-l)/(1-l);if(t<.5){const e=2*t;c=-Math.sin(e*Math.PI)*i*.15}else c=0;h=!1!==n.landingImpact?t<.3?1-(1-.8*r)*(1-t/.3):.8*r+(t-.3)/.7*(1-.8*r):r+(1-r)*t}return{position:[0,c,0],rotation:[d,0,0],scale:h}}}};function ef(e){const t=pm[e];if(!t)throw new Error(`Invalid jump direction: ${e}`);const n="up"===e||"down"===e;return{name:`jump${mm(e)}`,emoji:"up"===e?"":"down"===e?"":"left"===e?"":"",type:"override",description:`Jump ${e} with squash & stretch`,config:{duration:800,musicalDuration:{musical:!0,beats:2},jumpDistance:60,squashAmount:.8,stretchAmount:1.2,anticipation:.2,hangTime:.1,landingImpact:!0,easing:"quad",strength:1,direction:e,particleMotion:{type:"jump",strength:.9,jumpDistance:60,squash:.8,stretch:1.2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},phaseSync:{anticipation:"eighth",jump:"beat",landing:"sixteenth"},distanceSync:{onBeat:1.5,offBeat:.8,accent:2,curve:"exponential"},deformationSync:{squashOnBeat:.6,stretchOnBeat:1.4,timing:"anticipatory"},dynamics:{forte:{jumpDistance:80,stretch:1.3},piano:{jumpDistance:30,stretch:1.1}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={}),e.gestureData.jump={startX:e.x,startY:e.y,startSize:e.size,originalVx:e.vx,originalVy:e.vy,initialized:!0}},apply(e,a,i,r,s,o){e.gestureData?.jump?.initialized||this.initialize(e,i,s,o);const l=e.gestureData.jump,c={...this.config,...i},h=i.strength||1,d=c.jumpDistance*h*e.scaleFactor,u=c.squashAmount,p=c.stretchAmount,m=c.anticipation,f=1-.5*c.anticipation;if(a<m){const i=a/m,r=this.easeOutQuad(i);e.size=l.startSize*(1-(1-u)*r),n?e.y=l.startY-t.y*r*5*e.scaleFactor:e.x=l.startX-t.x*r*5*e.scaleFactor,e.vx=0,e.vy=0}else if(a<f){const i=(a-m)/(f-m);let r=Math.sin(i*Math.PI);if(c.hangTime>0&&i>.4&&i<.6){const e=(i-.4)/.2;r=.95+.05*this.easeInOutCubic(e)}if(n?(e.y=l.startY+t.y*r*d,e.x=l.startX+3*Math.sin(i*Math.PI*2)):(e.x=l.startX+t.x*r*d,e.y=l.startY-Math.sin(i*Math.PI)*d*.3),i<.5){const t=2*i;e.size=l.startSize*(u+(p-u)*t)}else{const t=2*(i-.5);e.size=l.startSize*(p-(p-1)*t*.8)}n?(e.vy=t.y*Math.cos(i*Math.PI)*d*.1,e.vx=0):(e.vx=t.x*Math.cos(i*Math.PI)*d*.1,e.vy=-Math.cos(i*Math.PI)*d*.05)}else{const t=(a-f)/(1-f),n=this.easeOutBounce(t);if(e.x=l.startX,e.y=l.startY,c.landingImpact)if(t<.3){const n=t/.3;e.size=l.startSize*(1-(1-.8*u)*(1-n))}else{const n=(t-.3)/.7;e.size=l.startSize*(.8*u+(1-.8*u)*n)}else e.size=l.startSize*(u+(1-u)*n);e.vx=l.originalVx*n,e.vy=l.originalVy*n}},cleanup(e){if(e.gestureData?.jump){const t=e.gestureData.jump;e.size=t.startSize,e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.jump}},easeOutQuad:e=>e*(2-e),easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutBounce(e){const t=7.5625,n=2.75;return e<1/n?t*e*e:e<2/n?t*(e-=1.5/n)*e+.75:e<2.5/n?t*(e-=2.25/n)*e+.9375:t*(e-=2.625/n)*e+.984375},"3d":{evaluate(e,a){const i=a.config||a||{},r=a.strength||1,s=.004*(i.jumpDistance||60)*r,o=i.squashAmount||.8,l=i.stretchAmount||1.2,c=i.anticipation||.2,h=1-.5*c;let d=0,u=0,p=1,m=0,f=0,g=0;if(e<c){const a=e/c,i=a*(2-a);p=1-(1-o)*i,n?u=-t.y*i*.02:d=-t.x*i*.02}else if(e<h){const a=(e-c)/(h-c),i=Math.sin(a*Math.PI);n?u=t.y*i*s:(d=t.x*i*s,u=Math.sin(a*Math.PI)*s*.3),p=a<.5?o+2*a*(l-o):l-2*(a-.5)*(l-1)*.8,n?m=t.y*Math.sin(a*Math.PI)*.1:(f=t.x*Math.sin(a*Math.PI)*.15,g=-t.x*Math.sin(a*Math.PI)*.05)}else{const a=(e-h)/(1-h);if(a<.5){const e=2*a;n?u=-t.y*Math.sin(e*Math.PI)*s*.15:d=-t.x*Math.sin(e*Math.PI)*s*.1}p=!1!==i.landingImpact?a<.3?1-(1-.8*o)*(1-a/.3):.8*o+(a-.3)/.7*(1-.8*o):o+(1-o)*a}return{cameraRelativePosition:[d,u,0],rotation:[m,f,g],scale:p}}}}}var tf=ef("down"),nf=ef("left"),af=ef("right");function rf(e){if(!["forward","back","left","right","up","down"].includes(e))throw new Error(`Invalid rush direction: ${e}`);return{name:`rush${mm(e)}`,emoji:{forward:"",back:"",left:"",right:"",up:"",down:""}[e],type:"override",description:{forward:"Quick rush toward camera",back:"Quick retreat away",left:"Quick strafe left",right:"Quick strafe right",up:"Quick leap upward",down:"Quick dive downward"}[e],config:{duration:600,musicalDuration:{musical:!0,beats:1.5},strength:1,direction:e,particleMotion:{type:"rush",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.direction||"forward";let r=0,s=0,o=0,l=0,c=0,h=1,d=1,u=0;const p={forward:{x:0,y:0,z:1,lean:{x:.2,z:0}},back:{x:0,y:0,z:-1,lean:{x:-.2,z:0}},left:{x:-1,y:0,z:0,lean:{x:0,z:.2}},right:{x:1,y:0,z:0,lean:{x:0,z:-.2}},up:{x:0,y:1,z:0,lean:{x:-.15,z:0}},down:{x:0,y:-1,z:0,lean:{x:.2,z:0}}}[i],m=.2;if(e<.2){const t=e/.2,n=1-Math.pow(1-t,2);l=n*p.lean.x*a,c=n*p.lean.z*a,s="up"===i?.03*-n*a:.02*-n*a,d=1+.3*n}else if(e<.6){const t=(e-.2)/.4,n=1-Math.pow(1-t,3);r=p.x*n*m*a,s=p.y*n*m*a,o=p.z*n*m*a,"up"===i?s+=.05*n*a:"down"!==i&&(s+=(.04*n-.02)*a),l=p.lean.x*a,c=p.lean.z*a,h=1+.08*n,d=1.3+.5*n,u=.35*n,c+=Math.sin(t*Math.PI*12)*(1-t)*.015*a}else{const t=(e-.6)/.4,n=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;if(r=p.x*m*(1-n)*a,s=p.y*m*(1-n)*a,o=p.z*m*(1-n)*a,l=p.lean.x*(1-n)*a,c=p.lean.z*(1-n)*a,h=1.08-.08*n,t>.7){const e=(t-.7)/.3;s-=.02*Math.sin(e*Math.PI)*a}d=1.8-.8*n,u=.35*(1-n)}return{cameraRelativePosition:[r,s,o],cameraRelativeRotation:[l,0,c],scale:h,glowIntensity:d,glowBoost:u}}}}}var sf={name:"lunge",emoji:"",type:"override",description:"Forward thrust lunge with emphasis",config:{duration:500,musicalDuration:{musical:!0,beats:1},distance:.25,direction:"forward",recover:!0,strength:1,particleMotion:{type:"lunge",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.distance||.25,r=!1!==n.recover;let s;e<.3?(s=e/.3,s=1-Math.pow(1-s,3)):e<.6?s=1:r?(s=1-(e-.6)/.4,s=Math.pow(s,2)):s=1;const o=s*i*a;return{position:[0,.05*-Math.sin(s*Math.PI)*a,o],rotation:[.2*s*a,0,0],scale:1+.1*s*a,glowIntensity:1+.3*s,glowBoost:e<.4?.4*s:0}}}};function of(e){if(!{...pm,forward:{x:0,y:0,z:-1},back:{x:0,y:0,z:1}}[e])throw new Error(`Invalid lunge direction: ${e}`);return{name:`lunge${mm(e)}`,emoji:{forward:"",back:"",left:"",right:"",up:"",down:""}[e]||"",type:"override",description:`Lunge thrust ${e}`,config:{duration:500,musicalDuration:{musical:!0,beats:1},distance:.25,recover:!0,strength:1,direction:e,particleMotion:{type:"lunge",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.distance||.25,r=!1!==n.recover,s=n.direction||"forward";let o;e<.3?(o=e/.3,o=1-Math.pow(1-o,3)):e<.6?o=1:r?(o=1-(e-.6)/.4,o=Math.pow(o,2)):o=1;let l=0,c=0,h=0,d=0,u=0;switch(s){case"forward":h=o*i*a,d=.2*o*a,c=.05*-Math.sin(o*Math.PI)*a;break;case"back":h=-o*i*a,d=.2*-o*a,c=.05*-Math.sin(o*Math.PI)*a;break;case"left":l=-o*i*a,u=.2*-o*a,c=.03*-Math.sin(o*Math.PI)*a;break;case"right":l=o*i*a,u=.2*o*a,c=.03*-Math.sin(o*Math.PI)*a;break;case"up":c=o*i*a,d=.15*-o*a;break;case"down":c=-o*i*a,d=.25*o*a}return{cameraRelativePosition:[l,c,h],cameraRelativeRotation:[d,0,u],scale:1+.1*o*a,glowIntensity:1+.3*o,glowBoost:e<.4?.4*o:0}}}}}var lf={name:"spin",emoji:"",type:"override",description:"Orbital rotation around center point",config:{duration:600,musicalDuration:{musical:!0,beats:1},rotations:1,direction:"random",radiusMultiplier:1,spiralOut:!1,accelerate:!0,maintainDistance:!0,scaleAmount:.1,easing:"linear",strength:.7,particleMotion:{type:"spin",strength:.7,rotations:1,radius:1}},rhythm:{enabled:!0,syncMode:"bar",rotationSync:{mode:"bars",rotationsPerBar:1,accelerateOnBeat:!0},radiusSync:{subdivision:"quarter",expandOnBeat:1.2,contractOffBeat:.9,curve:"bounce"},durationSync:{mode:"beats",beats:4},patternOverrides:{waltz:{rotationSync:{rotationsPerBar:.75},radiusSync:{curve:"ease"}},swing:{rotationSync:{accelerateOnBeat:!1},direction:"alternating"},dubstep:{radiusSync:{subdivision:"eighth",expandOnBeat:1.5,dropMultiplier:2},spiralOut:!0},breakbeat:{rotationSync:{mode:"random",range:[.5,2]},direction:"random"}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a;let s=t.direction||this.config.direction;"random"===s&&(s=Math.random()<.5?"clockwise":"counter-clockwise"),e.gestureData.spin={startAngle:Math.atan2(r,i),startRadius:Math.sqrt(i*i+r*r)||30,originalX:e.x,originalY:e.y,originalVx:e.vx,originalVy:e.vy,direction:s,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.spin?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.spin,o={...this.config,...n},l=n.strength||1;let{rotations:c}=o,{radiusMultiplier:h}=o;n.rhythmModulation&&(n.rhythmModulation.rotationMultiplier&&(c*=n.rhythmModulation.rotationMultiplier),n.rhythmModulation.radiusMultiplier&&(h*=n.rhythmModulation.radiusMultiplier));let d=t;o.accelerate&&(d=t<.5?.5*this.easeInQuad(2*t):.5+.5*this.easeOutQuad(2*(t-.5)));const u=c*Math.PI*2*l,p="counter-clockwise"===s.direction?-1:1,m=s.startAngle+u*d*p;let f=s.startRadius;o.spiralOut&&(f*=1+.5*t),1!==h&&(f*=1+(h-1)*Math.sin(t*Math.PI));const g=i+Math.cos(m)*f,y=r+Math.sin(m)*f;if(e.x+=.25*(g-e.x),e.y+=.25*(y-e.y),e.vx=.5*(g-e.x),e.vy=.5*(y-e.y),t>.9){const n=10*(1-t);e.vx=e.vx*n+s.originalVx*(1-n),e.vy=e.vy*n+s.originalVy*(1-n)}},cleanup(e){if(e.gestureData?.spin){const t=e.gestureData.spin;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.spin}},easeInQuad:e=>e*e,easeOutQuad:e=>e*(2-e),"3d":{evaluate(e,t){const n=t?.config||t||{},a=t?.strength||1,i=t?.particle;let r=1;i?.gestureData?.spin?r="counter-clockwise"===i.gestureData.spin.direction?-1:1:"counter-clockwise"!==n.direction&&"left"!==n.direction||(r=-1);let s=e;return!1!==n.accelerate&&(s=e<.5?e*e*4*.5:.5+(e-.5)*(2-(e-.5))*.5),{position:[0,0,0],rotation:[0,(n.rotations||1)*Math.PI*2*a*s*r,0],scale:1+(n.scaleAmount||.1)*Math.sin(e*Math.PI)*a}}}};const cf={left:"counter-clockwise",right:"clockwise"};function hf(e){const t=cf[e];if(!t)throw new Error(`Invalid spin direction: ${e}`);const n="left"===e?-1:1;return{name:`spin${mm(e)}`,emoji:"left"===e?"":"",type:"override",description:`Spin ${t}`,config:{duration:600,rotations:1,direction:t,radiusMultiplier:1,spiralOut:!1,accelerate:!0,maintainDistance:!0,scaleAmount:.1,strength:.7},rhythm:{enabled:!0,syncMode:"bar",timingSync:"nextBeat",interruptible:!1,priority:7,blendable:!1,durationSync:{mode:"beats",beats:4},rotationSync:{mode:"bars",rotationsPerBar:1,accelerateOnBeat:!0}},initialize(e,n,a,i){e.gestureData||(e.gestureData={});const r=e.x-a,s=e.y-i;e.gestureData.spin={startAngle:Math.atan2(s,r),startRadius:Math.sqrt(r*r+s*s)||30,originalX:e.x,originalY:e.y,originalVx:e.vx,originalVy:e.vy,direction:t,initialized:!0}},apply(e,t,a,i,r,s){e.gestureData?.spin?.initialized||this.initialize(e,a,r,s);const o=e.gestureData.spin,l={...this.config,...a},c=a.strength||1;let{rotations:h,radiusMultiplier:d}=l;a.rhythmModulation&&(a.rhythmModulation.rotationMultiplier&&(h*=a.rhythmModulation.rotationMultiplier),a.rhythmModulation.radiusMultiplier&&(d*=a.rhythmModulation.radiusMultiplier));let u=t;l.accelerate&&(u=t<.5?.5*this.easeInQuad(2*t):.5+.5*this.easeOutQuad(2*(t-.5)));const p=h*Math.PI*2*c,m=o.startAngle+p*u*n;let f=o.startRadius;l.spiralOut&&(f*=1+.5*t),1!==d&&(f*=1+(d-1)*Math.sin(t*Math.PI));const g=r+Math.cos(m)*f,y=s+Math.sin(m)*f;if(e.x+=.25*(g-e.x),e.y+=.25*(y-e.y),e.vx=.5*(g-e.x),e.vy=.5*(y-e.y),t>.9){const n=10*(1-t);e.vx=e.vx*n+o.originalVx*(1-n),e.vy=e.vy*n+o.originalVy*(1-n)}},cleanup(e){if(e.gestureData?.spin){const t=e.gestureData.spin;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.spin}},easeInQuad:e=>e*e,easeOutQuad:e=>e*(2-e),"3d":{evaluate(e,t){const a=t?.config||t||{},i=t?.strength||1;let r=e;return!1!==a.accelerate&&(r=e<.5?e*e*4*.5:.5+(e-.5)*(2-(e-.5))*.5),{position:[0,0,0],rotation:[0,(a.rotations||1)*Math.PI*2*i*r*n,0],scale:1+(a.scaleAmount||.1)*Math.sin(e*Math.PI)*i}}}}}var df=hf("left"),uf=hf("right"),pf={name:"flip",emoji:"",type:"override",description:"Front flip rotation with arc trajectory",config:{duration:800,musicalDuration:{musical:!0,beats:2},rotations:1,height:.3,direction:"forward",strength:1,particleMotion:{type:"flip",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.rotations||1,r=n.height||.3,s=(e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2)*(2*-Math.PI*i),o=Math.sin(e*Math.PI)*r*a;let l=1;if(e<.1)l=1-e/.1*.15;else if(e<.2)l=.85+(e-.1)/.1*.2;else if(e>.9){const t=(e-.9)/.1;l=1.05-.1*Math.sin(t*Math.PI)}else l=1.05;return e>=.99&&(l=1),{position:[0,o,0],rotation:[s,0,0],scale:l,glowIntensity:1+.4*Math.sin(e*Math.PI),glowBoost:e>.2&&e<.8?.3:0}}}},mf={name:"backflip",emoji:"",type:"override",description:"Backwards flip with dramatic arc trajectory",config:{duration:900,musicalDuration:{musical:!0,beats:2},rotations:1,height:.35,strength:1,particleMotion:{type:"backflip",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.rotations||1,r=n.height||.35,s=(e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2)*(2*Math.PI*i),o=Math.sin(e*Math.PI)*r*a,l=.1*Math.sin(e*Math.PI)*a;let c=1;if(e<.1)c=1-e/.1*.15;else if(e<.2)c=.85+(e-.1)/.1*.25;else if(e>.9){const t=(e-.9)/.1;c=1.1-.15*Math.sin(t*Math.PI)}else c=1.1;return e>=.99&&(c=1),{position:[0,o,l],rotation:[s,0,0],scale:c,glowIntensity:1+.5*Math.sin(e*Math.PI),glowBoost:.4*Math.sin(e*Math.PI)}}}},ff={name:"point",emoji:"",type:"blending",description:"Directional pointing motion with forward momentum",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},amplitude:15,direction:"right",strength:.8,particleMotion:{type:"point",direction:"right",strength:.8}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.6},patternOverrides:{march:{amplitudeSync:{onBeat:2,offBeat:.5,curve:"pulse"}},swing:{amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"bounce"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.point={startX:e.x,startY:e.y,startVx:e.vx,startVy:e.vy,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.point?.initialized||this.initialize(e,n);const s={...this.config,...n},o=s.strength||this.config.strength||1,l=this.easeInOutCubic(t);let c=s.amplitude*o*e.scaleFactor;n.rhythmModulation&&(c*=n.rhythmModulation.amplitudeMultiplier||1,c*=n.rhythmModulation.accentMultiplier||1);const h=Math.sin(l*Math.PI);let d=0,u=0;switch(s.direction||"right"){case"right":d=1;break;case"left":d=-1;break;case"up":u=-1;break;case"down":u=1}if(e.vx+=h*c*.02*a*d,e.vy+=h*c*.02*a*u,t>.9){const n=1-10*(t-.9);e.vx=e.vx*(.95+.05*n),e.vy=e.vy*(.95+.05*n)}},cleanup(e){e.gestureData?.point&&delete e.gestureData.point},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const n=t||{},a=n.amplitude||15,i=n.strength||.8,r=n.direction||"right",s=.005*a*i,o=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,l=Math.sin(o*Math.PI);let c=0,h=0;switch(r){case"right":c=l*s,h=.25*l;break;case"left":c=-l*s,h=.25*-l;break;case"up":case"down":h=0}return{position:[c,0,0],rotation:[0,h,0],scale:1}}}};function gf(e){const t=pm[e];if(!t)throw new Error(`Invalid point direction: ${e}`);const n="up"===e||"down"===e;return{name:`point${mm(e)}`,emoji:"up"===e?"":"down"===e?"":"left"===e?"":"",type:"blending",description:`Point ${e} with extension and return`,config:{duration:500,amplitude:15,strength:.8,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"ease"},accentResponse:{enabled:!0,multiplier:1.6}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.point={startX:e.x,startY:e.y,initialized:!0}},apply(e,n,a,i,r,s){e.gestureData?.point?.initialized||this.initialize(e,a);const o={...this.config,...a},l=o.strength||.8,c=this.easeInOutCubic(n);let h=o.amplitude*l*e.scaleFactor;a.rhythmModulation&&(h*=a.rhythmModulation.amplitudeMultiplier||1,h*=a.rhythmModulation.accentMultiplier||1);const d=Math.sin(c*Math.PI);if(e.vx+=d*h*.02*i*t.x,e.vy+=d*h*.02*i*-t.y,n>.9){const t=1-10*(n-.9);e.vx*=.95+.05*t,e.vy*=.95+.05*t}},cleanup(e){e.gestureData?.point&&delete e.gestureData.point},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,a){const i=a||{},r=.005*(i.amplitude||15)*(i.strength||.8),s=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,o=Math.sin(s*Math.PI),l=t.x*o*r,c=t.y*o*r;let h=0,d=0,u=0;return n?h=t.y*o*.2:(d=t.x*o*.25,u=-t.x*o*.1),{cameraRelativePosition:[l,c,0],rotation:[h,d,u],scale:1}}}}}var yf=gf("up"),vf=gf("down"),bf=gf("left"),wf=gf("right");function xf(e){if("left"!==e&&"right"!==e)throw new Error(`Invalid kick direction: ${e}. Only 'left' and 'right' are supported.`);const t=pm[e];return{name:`kick${mm(e)}`,emoji:"left"===e?"":"",type:"blending",description:`Quick kick ${e} with snap return`,config:{duration:400,amplitude:30,strength:.8,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:5,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"snap"},accentResponse:{enabled:!0,multiplier:1.5}},apply(e,n,a,i,r,s){const o={...this.config,...a};let l,c=o.amplitude*o.strength*e.scaleFactor;a.rhythmModulation&&(c*=a.rhythmModulation.amplitudeMultiplier||1,c*=a.rhythmModulation.accentMultiplier||1),l=n<.25?this.easeOutQuad(n/.25):n<.5?1:1-this.easeInQuad((n-.5)/.5);const h=t.x*c*l*.012*i,d=t.y*c*l*.012*i;e.vx+=h,e.vy+=d},cleanup(e){},easeOutQuad:e=>1-(1-e)*(1-e),easeInQuad:e=>e*e,"3d":{evaluate(e,n){const a=n||{},i=a.amplitude||30,r=a.strength||.8;let s,o=.008*i*r;if(n.rhythmModulation&&(o*=n.rhythmModulation.amplitudeMultiplier||1),e<.25)s=1-(1-e/.25)*(1-e/.25);else if(e<.5)s=1;else{const t=(e-.5)/.5;s=1-t*t}const l=.15*s*r;return{cameraRelativePosition:[t.x*o*s,t.y*o*s*.3,0],rotation:[.08*s*r,0,t.x*l],scale:1+.05*s}}}}}var Sf=xf("left"),Mf=xf("right"),_f={name:"bow",emoji:"",type:"override",description:"Graceful forward bow of respect",config:{duration:1200,musicalDuration:{musical:!0,beats:3},depth:.4,holdTime:.4,graceful:!0,strength:1,particleMotion:{type:"bow",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat"},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.depth||.4,r=n.holdTime||.4;let s;const o=.4*(1-r),l=1-.6*(1-r);return e<o?(s=e/o,s=Math.sin(s*Math.PI/2)):e<l?s=1:(s=1-(e-l)/(1-l),s=Math.sin(s*Math.PI/2)),{cameraRelativePosition:[0,.1*-s*a,.05*-s*a],cameraRelativeRotation:[s*i*Math.PI*a,0,0],scale:1,glowIntensity:1-.2*s,glowBoost:0}}}},Af={name:"nod",emoji:"",type:"blending",description:"Vertical nodding motion",config:{duration:500,amplitude:15,frequency:2,easing:"sine",strength:.4,particleMotion:{type:"bounce",axis:"vertical",strength:.4,frequency:2,phase:0}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!1,priority:5,blendable:!1,minDuration:"halfBar",frequencySync:{mode:"subdivision",subdivision:"half",multiplier:1},amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"ease"},durationSync:{mode:"beats",beats:2},patternOverrides:{waltz:{frequencySync:{subdivision:"quarter"},amplitudeSync:{onBeat:1.6,curve:"ease"}},swing:{amplitudeSync:{onBeat:1.5,offBeat:.9}},dubstep:{amplitudeSync:{onBeat:1.2,dropBeat:3,curve:"pulse"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.nod={startY:e.y,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.nod?.initialized||this.initialize(e,n);const s={...this.config,...n},o=s.strength||this.config.strength||1;let{frequency:l}=s,{amplitude:c}=s;n.rhythmModulation&&(c*=n.rhythmModulation.amplitudeMultiplier||1,c*=n.rhythmModulation.accentMultiplier||1,n.rhythmModulation.frequencyMultiplier&&(l*=n.rhythmModulation.frequencyMultiplier));const h=Math.sin(t*Math.PI*2*l);c=c*o*e.scaleFactor,e.vy+=h*c*.01*a,t>.9&&(e.vy*=.95)},cleanup(e){e.gestureData?.nod&&delete e.gestureData.nod},"3d":{evaluate(e,t){const n={...this.config,...t};let{amplitude:a}=n;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);let i=0;if(e<.4){const t=e/.4;i=.12*Math.sin(t*Math.PI)}else if(e<.8){const t=(e-.4)/.4;i=.07*Math.sin(t*Math.PI)}return i*=a/15,{cameraRelativePosition:[0,0,i],scale:1-.3*Math.abs(i),glowIntensity:1+.5*Math.abs(i)}}}},Cf={name:"reach",emoji:"",type:"blending",description:"Upward reaching motion with scale increase",config:{duration:1400,musicalDuration:{musical:!0,beats:2},amplitude:25,strength:.9,scaleMax:1.05,particleMotion:{type:"reach",strength:.9,scaleMax:1.05}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.4,offBeat:.9,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.5},patternOverrides:{uplifting:{amplitudeSync:{onBeat:1.8,offBeat:.7,curve:"ease"},durationSync:{beats:3}},ambient:{amplitudeSync:{onBeat:1.2,offBeat:1,curve:"linear"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.reach={startY:e.y,startVy:e.vy,originalSize:e.size,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.reach?.initialized||this.initialize(e,n);const s={...this.config,...n},o=s.strength||this.config.strength||1,l=s.scaleMax||this.config.scaleMax||1.05,c=this.easeInOutCubic(t);let h=s.amplitude*o*e.scaleFactor;n.rhythmModulation&&(h*=n.rhythmModulation.amplitudeMultiplier||1,h*=n.rhythmModulation.accentMultiplier||1);const d=Math.sin(c*Math.PI);e.vy-=d*h*.015*a;const u=1+d*(l-1);if(e.size=e.baseSize*u,t>.9){const n=1-10*(t-.9);e.vy=e.vy*(.95+.05*n)}},cleanup(e){e.gestureData?.reach&&(e.gestureData.reach.originalSize?e.size=e.gestureData.reach.originalSize:e.size=e.baseSize,delete e.gestureData.reach)},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const n=t||{},a=n.amplitude||25,i=n.strength||.9,r=n.scaleMax||1.05,s=.004*a*i,o=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,l=Math.sin(o*Math.PI);return{position:[0,l*s,0],rotation:[.1*l,0,0],scale:1+l*(r-1)}}}},Tf={name:"headBob",emoji:"",type:"additive",description:"Rhythmic vertical bobbing to music",config:{duration:600,musicalDuration:{musical:!0,beats:1},amplitude:12,frequency:2,strength:1,damping:.1,easing:"linear",particleMotion:{type:"headBob",strength:1,amplitude:12,frequency:2}},rhythm:{enabled:!0,syncMode:"beat",frequencySync:{subdivision:"eighth",bobsPerBeat:2},amplitudeSync:{onBeat:1.3,offBeat:1,curve:"pulse"},durationSync:{mode:"beats",beats:1}},apply(e,t,n,a,i,r,s){const o=(n.amplitude||this.config.amplitude)*i,l=n.frequency||this.config.frequency,c=1-a*(n.damping||this.config.damping),h=Math.sin(a*Math.PI*2*l)*o*c;e.vy+=.5*h;const d=Math.cos(a*Math.PI*2*l*1.5)*o*.05*c;e.vx+=.2*d},"3d":{evaluate(e,t){const n=t.config||{},a=t.strength||1,i=n.amplitude||12,r=e<.15?e/.15:Math.pow(1-(e-.15)/.85,2),s=i/12*a;return{cameraRelativePosition:[0,0,.08*r*s],position:[0,.015*-r*s,0],scale:1-.05*r,glowIntensity:1+.15*r}}}},Pf={name:"crouch",emoji:"",type:"override",description:"Compress down into a low crouch position",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},depth:.3,widen:.2,holdTime:.5,strength:1,particleMotion:{type:"crouch",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat"},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.depth||.3,r=n.widen||.2;let s;const o=(1-(n.holdTime||.5))/2,l=1-o;return s=e<o?e/o:e<l?1:1-(e-l)/o,s=Math.sin(s*Math.PI/2),{position:[0,-s*i*a,0],rotation:[.15*s*a,0,0],scale:(1+s*r*a+(1-.25*s*a))/2,glowIntensity:1-.3*s,glowBoost:0}}}},Df={name:"tilt",emoji:"",type:"override",description:"Gather particles then tilt as unified group",config:{duration:500,musicalDuration:{musical:!0,beats:1},gatherPhase:.2,tiltAngle:45,swayAmount:80,liftAmount:60,frequency:3,homeRadius:20,easing:"sine",strength:2.5,particleMotion:{type:"tilt",strength:2.5,frequency:3,swayAmount:80,liftAmount:60},smoothness:.25},rhythm:{enabled:!0,syncMode:"swing",durationSync:{mode:"beats",beats:1},angleSync:{onBeat:45,offBeat:-30,swing:15,subdivision:"triplet",curve:"ease-in-out"},gatherSync:{beatsBefore:.5,releaseAfter:.25,intensity:"dynamic"},swaySync:{verse:60,chorus:100,bridge:80,syncopated:!0},liftSync:{upOnTilt:!0,heightOnAccent:80,normalHeight:40,curve:"bounce"},dynamics:{forte:{tiltAngle:60,swayAmount:120,frequency:4},piano:{tiltAngle:20,swayAmount:40,frequency:2}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a,s=Math.atan2(r,i),o=Math.sqrt(i*i+r*r),l=Math.random(),c=({...this.config,...t}.homeRadius+20*Math.random())*e.scaleFactor;e.gestureData.tilt={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,angle:s,distance:o,homeRadius:c,homeX:n+Math.cos(s)*c,homeY:a+Math.sin(s)*c,role:l,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.tilt?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.tilt,o={...this.config,...n},l=n.strength||1;let c,h;if(t<o.gatherPhase){const n=t/o.gatherPhase,a=this.easeInOutCubic(n);c=s.startX+(s.homeX-s.startX)*a,h=s.startY+(s.homeY-s.startY)*a;const i=.6;e.x+=(c-e.x)*i,e.y+=(h-e.y)*i}else{const n=(t-o.gatherPhase)/(1-o.gatherPhase)*Math.PI*o.frequency,a=Math.sin(n),d=o.tiltAngle*Math.PI/180*l,u=s.angle+a*d,p=Math.abs(a)*o.liftAmount*e.scaleFactor,m=s.homeRadius+p;c=i+Math.cos(u)*m,h=r+Math.sin(u)*m-.3*p;const f=o.smoothness+.1*s.role;e.x+=(c-e.x)*f,e.y+=(h-e.y)*f;const g=-Math.sin(u),y=Math.cos(u);e.vx=g*a*2,e.vy=y*a*2}if(t<o.gatherPhase&&(e.vx=.25*(c-e.x),e.vy=.25*(h-e.y)),t>.9){const n=10*(1-t),a=s.startX+(e.x-s.startX)*n,i=s.startY+(e.y-s.startY)*n;e.x=a,e.y=i,e.vx=e.vx*n+s.originalVx*(1-n),e.vy=e.vy*n+s.originalVy*(1-n)}},cleanup(e){if(e.gestureData?.tilt){const t=e.gestureData.tilt;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.tilt}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const n=t.config||{},a=t.strength||1,i=n.gatherPhase||.2,r=n.frequency||3,s=n.tiltAngle||45;let o=0;if(e>=i){const t=(e-i)/(1-i)*Math.PI*r;o=Math.sin(t)*(s*Math.PI/180*a*.4)}return{position:[0,0,0],rotation:[0,0,o],scale:1}}}};function Of(e){const t=pm[e];if(!t)throw new Error(`Invalid tilt direction: ${e}`);const n="up"===e||"down"===e;return{name:`tilt${mm(e)}`,emoji:"up"===e?"":"down"===e?"":"left"===e?"":"",type:"override",description:`Tilt ${e} with curious expression`,config:{duration:500,musicalDuration:{musical:!0,beats:1},gatherPhase:.2,tiltAngle:45,tiltAmount:40,holdPhase:.4,homeRadius:20,easing:"sine",strength:1,direction:e,smoothness:.25,particleMotion:{type:"tilt",strength:1,tiltAmount:40}},rhythm:{enabled:!0,syncMode:"swing",durationSync:{mode:"beats",beats:1},angleSync:{onBeat:45,offBeat:30,subdivision:"triplet",curve:"ease-in-out"},gatherSync:{beatsBefore:.5,releaseAfter:.25,intensity:"dynamic"},dynamics:{forte:{tiltAngle:60,tiltAmount:60},piano:{tiltAngle:25,tiltAmount:25}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a,s=Math.atan2(r,i),o=Math.sqrt(i*i+r*r),l=({...this.config,...t}.homeRadius+20*Math.random())*e.scaleFactor;e.gestureData.tilt={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,angle:s,distance:o,homeRadius:l,homeX:n+Math.cos(s)*l,homeY:a+Math.sin(s)*l,role:Math.random(),initialized:!0}},apply(e,a,i,r,s,o){e.gestureData?.tilt?.initialized||this.initialize(e,i,s,o);const l=e.gestureData.tilt,c={...this.config,...i},h=i.strength||1;let d,u;if(a<c.gatherPhase){const t=a/c.gatherPhase,n=this.easeInOutCubic(t);d=l.startX+(l.homeX-l.startX)*n,u=l.startY+(l.homeY-l.startY)*n;const i=.6;e.x+=(d-e.x)*i,e.y+=(u-e.y)*i}else if(a<c.gatherPhase+c.holdPhase){const i=(a-c.gatherPhase)/c.holdPhase,r=this.easeOutCubic(Math.min(2*i,1)),s=c.tiltAmount*h*e.scaleFactor*r;n?(d=l.homeX,u=l.homeY+t.y*s):(d=l.homeX+t.x*s,u=l.homeY-Math.abs(t.x)*s*.2);const o=c.smoothness+.1*l.role;e.x+=(d-e.x)*o,e.y+=(u-e.y)*o,e.vx=.5*(d-e.x),e.vy=.5*(u-e.y)}else{const t=(a-c.gatherPhase-c.holdPhase)/(1-c.gatherPhase-c.holdPhase),n=this.easeInOutCubic(t);d=e.x+(l.startX-e.x)*n,u=e.y+(l.startY-e.y)*n,e.x=d,e.y=u,e.vx=l.originalVx*n,e.vy=l.originalVy*n}a<c.gatherPhase&&(e.vx=.25*(d-e.x),e.vy=.25*(u-e.y))},cleanup(e){if(e.gestureData?.tilt){const t=e.gestureData.tilt;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.tilt}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutCubic:e=>1-Math.pow(1-e,3),"3d":{evaluate(e,a){const i=a.config||a||{},r=a.strength||1,s=i.gatherPhase||.2,o=i.holdPhase||.4,l=i.tiltAngle||45,c=i.tiltAmount||40;let h=0,d=0,u=0,p=0,m=0;if(e<s);else if(e<s+o){const a=(e-s)/o,i=1-Math.pow(1-Math.min(2*a,1),3),f=l*Math.PI/180*r*.4*i,g=.004*c*r*i;n?(u=t.y*f,d=t.y*g):(m=-t.x*f,h=t.x*g*.5,p=t.x*f*.3)}else{const a=(e-s-o)/(1-s-o),i=a<.5?4*a*a*a:1-Math.pow(-2*a+2,3)/2,f=l*Math.PI/180*r*.4*(1-i),g=.004*c*r*(1-i);n?(u=t.y*f,d=t.y*g):(m=-t.x*f,h=t.x*g*.5,p=t.x*f*.3)}return{cameraRelativePosition:[h,d,0],rotation:[u,p,m],scale:1}}}}}var Ef=Of("up"),If=Of("down"),kf=Of("left"),Rf=Of("right");function zf(e){if(!["left","right","front","back","up","down"].includes(e))throw new Error(`Invalid oof direction: ${e}`);return{name:`oof${mm(e)}`,emoji:{left:"",right:"",front:"",back:"",up:"",down:""}[e],type:"override",description:{left:"Punched from left",right:"Punched from right",front:"Gut punch",back:"Kidney shot",up:"Uppercut",down:"Hammer fist"}[e],config:{duration:500,musicalDuration:{musical:!0,beats:1},intensity:1,strength:1,direction:e,particleMotion:{type:"oof",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1;let i,r;if(e<.25){const t=e/.25;i=t*(2-t)}else{const t=(e-.25)/.75;i=1-t*t}r=e<.1?e/.1:e<.4?1:1-(e-.4)/.6;const s=.2*a,o=.35*a;let l=0,c=0,h=0,d=0,u=0;let p=[0,0,.4];switch(n.direction||"front"){case"left":l=-i*s,u=i*o,p=[.4,0,0];break;case"right":l=i*s,u=-i*o,p=[-.4,0,0];break;case"front":h=-i*s,c=.03*-i,d=i*o*.7,p=[0,0,.4];break;case"back":h=i*s,d=-i*o*.6,p=[0,0,-.4];break;case"up":c=i*s,d=-i*o*.4,p=[0,.8,0];break;case"down":c=-i*s,d=i*o*.3,p=[0,-.8,0]}let m=1,f=0;if(e<.15){const t=e/.15;m=1+.6*(1-t),f=.4*(1-t)}return{cameraRelativePosition:[l,c,h],cameraRelativeRotation:[d,0,u],scale:1,glowIntensity:m,glowBoost:f,deformation:{enabled:!0,strength:r*a*2,impactPoint:p,falloffRadius:.5}}}}}}var Ff={name:"recoil",emoji:"",type:"override",description:"Snap backwards in shock or surprise",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},distance:.2,intensity:1,recover:!0,strength:1,particleMotion:{type:"recoil",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.distance||.2,r=n.intensity||1,s=!1!==n.recover;let o;return e<.15?(o=e/.15,o=1-Math.pow(1-o,4)):e<.4?o=1:s?(o=1-(e-.4)/.6,o=Math.pow(o,.5)):o=1,{position:[0,.05*o*a,-o*i*a*r],rotation:[.25*-o*a*r,0,0],scale:1-.1*o*r,glowIntensity:1+(e<.2?3*(.2-e):0),glowBoost:e<.15?.5:0}}}};function Bf(e){if(!{...pm,forward:{x:0,y:0,z:-1},back:{x:0,y:0,z:1}}[e])throw new Error(`Invalid recoil direction: ${e}`);return{name:`recoil${mm(e)}`,emoji:{back:"",forward:"",left:"",right:"",up:"",down:""}[e]||"",type:"override",description:`Recoil ${e} in shock`,config:{duration:600,musicalDuration:{musical:!0,beats:1.5},distance:.2,intensity:1,recover:!0,strength:1,direction:e,particleMotion:{type:"recoil",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.distance||.2,r=n.intensity||1,s=!1!==n.recover,o=n.direction||"back";let l;e<.15?(l=e/.15,l=1-Math.pow(1-l,4)):e<.4?l=1:s?(l=1-(e-.4)/.6,l=Math.pow(l,.5)):l=1;let c=0,h=0,d=0,u=0,p=0;switch(o){case"back":d=-l*i*a*r,u=.25*-l*a*r,h=.05*l*a;break;case"forward":d=l*i*a*r,u=.25*l*a*r,h=.05*-l*a;break;case"left":c=-l*i*a*r,p=.2*l*a*r;break;case"right":c=l*i*a*r,p=.2*-l*a*r;break;case"up":h=l*i*a*r,u=.1*-l*a*r;break;case"down":h=-l*i*a*r,u=.3*l*a*r}return{cameraRelativePosition:[c,h,d],cameraRelativeRotation:[u,0,p],scale:1-.1*l*r,glowIntensity:1+(e<.2?3*(.2-e):0),glowBoost:e<.15?.5:0}}}}}var Lf={name:"knockdown",emoji:"",type:"override",description:"Quick knockdown with fast recovery",config:{duration:1500,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"knockdown",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1;let a=0,i=0,r=0,s=0,o=1,l=1,c=0;if(e<.15){const t=e/.15,a=1-Math.pow(1-t,2);i=.1*a*n,r=.2*-a*n,l=1+.6*a,c=.5*a}else if(e<.4){const t=(e-.15)/.25,i=t*t;a=.2*-i*n,r=(.6*i-.2)*n,s=.3*i*n,t>.7&&(o=1-(t-.7)/.3*.1),l=1.6-.5*t,c=.5-.4*t}else if(e<.6){const t=(e-.4)/.2;a=-.2*n,r=.4*n,s=.3*n,s+=.02*Math.sin(t*Math.PI*2),o=.9,l=.8}else{const t=(e-.6)/.4,i=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;if(a=(.2*i-.2)*n,r=(.4-.4*i)*n,s=(.3-.3*i)*n,o=.9+.1*i,t>.7){const e=(t-.7)/.3;s+=.03*Math.sin(e*Math.PI*4)*(1-e)}l=.8+.2*i,t>.9&&(c=(t-.9)/.1*.2)}return{position:[0,a,i],rotation:[r,0,s],scale:o,glowIntensity:l,glowBoost:c}}}},Nf={name:"knockout",emoji:"",type:"override",description:"Theatrical knockout with failed rise attempt, then recovery",config:{duration:4e3,musicalDuration:{musical:!0,bars:2},strength:1,particleMotion:{type:"knockout",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1;let a=0,i=0,r=0,s=0,o=0,l=1,c=1,h=0;if(e<.1){const t=e/.1,a=1-Math.pow(1-t,3);i=.15*a*n,r=.3*-a*n,c=1+.8*a,h=.6*a,o=.1*Math.sin(t*Math.PI*4)*a}else if(e<.25){const t=(e-.1)/.15,i=t*t;a=.25*-i*n,r=(.8*i-.3)*n,o=.4*i*n,t>.8&&(l=1-(t-.8)/.2*.15),c=1.8-.6*t,h=.6-.4*t}else if(e<.35){const t=(e-.25)/.1;a=-.25*n,r=.5*n,o=.4*n,o+=.03*Math.sin(t*Math.PI*6)*(1-t),l=.85,c=1-.3*t}else if(e<.45){const t=(e-.35)/.1,i=1-Math.pow(1-t,2);a=(.15*i-.25)*n,r=(.5-.3*i)*n,o=(.4-.2*i)*n,l=.85+.1*i,c=.7+.4*i}else if(e<.55){const t=(e-.45)/.1,i=t*t;a=(-.1-.15*i)*n,r=(.2+.35*i)*n,o=(.2+.25*i)*n,l=.95-.12*i,t>.7&&(h=(t-.7)/.3*.3),c=1.1-.4*t}else if(e<.75){const t=(e-.55)/.2;a=-.25*n,r=.55*n,o=.45*n,l=.83;const i=.02*Math.sin(t*Math.PI*4)*Math.sin(t*Math.PI);o+=i,c=.6+2*i}else if(e<.9){const t=(e-.75)/.15,i=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;a=(.25*i-.25)*n,r=(.55-.55*i)*n,o=(.45-.45*i)*n,l=.83+.17*i,c=.6+.5*i}else{const t=(e-.9)/.1;a=0,r=0,o=Math.sin(t*Math.PI*6)*(1-t)*.08*n,s=Math.sin(t*Math.PI*8)*(1-t)*.1*n,l=1,c=1+.2*Math.sin(t*Math.PI*3)*(1-t),h=.2*Math.sin(t*Math.PI)}return{position:[0,a,i],rotation:[r,s,o],scale:l,glowIntensity:c,glowBoost:h}}}},Vf={name:"inflate",emoji:"",type:"override",description:"Puff up dramatically like a balloon",config:{duration:800,musicalDuration:{musical:!0,beats:2},maxScale:1.4,holdTime:.3,deflate:!0,strength:1,particleMotion:{type:"inflate",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",strengthSync:{onBeat:1.3,offBeat:.8}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.maxScale||1.4,r=n.holdTime||.3,s=!1!==n.deflate;let o;const l=.5*(1-r),c=1-l;e<l?(o=e/l,o=1-Math.pow(1-o,2)):e<c||!s?o=1:(o=1-(e-c)/l,o=Math.pow(o,2));const h=1+(i-1)*o*a,d=.08*o*a,u=1+.4*o*a,p=.3*o,m=o>.8?.02*Math.sin(e*Math.PI*8):0;return{position:[m,d,0],rotation:[0,0,2*m],scale:h,glowIntensity:u,glowBoost:p}}}},Uf={name:"deflate",emoji:"",type:"override",description:"Shrink down sadly like a deflating balloon",config:{duration:1e3,musicalDuration:{musical:!0,beats:2.5},minScale:.6,droop:.15,reinflate:!0,strength:1,particleMotion:{type:"deflate",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2.5},timingSync:"onBeat"},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.minScale||.6,r=n.droop||.15,s=!1!==n.reinflate;let o;return e<.5?(o=e/.5,o=Math.pow(o,.7)):e<.7||!s?o=1:(o=1-(e-.7)/.3,o=Math.pow(o,1.5)),{position:[0,-o*r*a,0],rotation:[.15*o*a,0,.1*o*a],scale:1-(1-i)*o*a,glowIntensity:1-.4*o,glowBoost:0}}}},Gf={name:"squash",emoji:"",type:"override",description:"Flatten horizontally like a cartoon impact",config:{duration:500,musicalDuration:{musical:!0,beats:1},squashAmount:.5,stretchAmount:1.5,bounce:!0,strength:1,particleMotion:{type:"squash",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.squashAmount||.5,r=n.stretchAmount||1.5,s=!1!==n.bounce;let o;if(e<.15)o=e/.15,o=1-Math.pow(1-o,3);else if(s){const t=(e-.15)/.85,n=Math.exp(4*-t);o=Math.cos(t*Math.PI*3)*n,o=Math.max(0,o)}else o=0;const l=1+o*(r-1)*a;return{position:[0,.15*-o*a,0],rotation:[0,0,0],scale:[l,1-o*(1-i)*a,l],glowIntensity:1+(e<.2?3*(.2-e):0),glowBoost:e<.15?.6:0}}}},Wf={name:"stretch",emoji:"",type:"override",description:"Scale particles along X and Y axes",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},scaleX:1.3,scaleY:.9,alternate:!1,elastic:!0,overshoot:.1,frequency:1,easing:"sine",strength:1,particleMotion:{type:"stretch",scaleX:1.8,scaleY:.6,strength:1},centerBased:!0,preserveArea:!1},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},scaleSync:{onBeat:{x:1.5,y:.7},offBeat:{x:.8,y:1.3},subdivision:"eighth",curve:"elastic"},alternateSync:{pattern:"XYXY",beatsPerChange:1,overlap:.1},overshootSync:{normal:.1,accent:.3,downbeat:.2,curve:"spring"},preservationSync:{verse:!0,chorus:!1,bridge:!0},dynamics:{forte:{scaleX:2,scaleY:.5,overshoot:.4},piano:{scaleX:1.1,scaleY:.95,overshoot:.05}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a;e.gestureData.stretch={offsetX:i,offsetY:r,startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.stretch?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.stretch,o={...this.config,...n},l=n.strength||1;let c,h,{scaleX:d}=o,{scaleY:u}=o;if(o.preserveArea&&1!==d&&1!==u){const e=d*u,t=Math.sqrt(1/e);d*=t,u*=t}if(o.alternate)if(t<.5){const e=2*t;d=1+(d-1)*this.getElasticProgress(e,o),u=1+(1/d-1)*(o.preserveArea?1:0)}else{const e=2*(t-.5);d+=(1-d)*this.getElasticProgress(e,o),u=1+(u-1)*this.getElasticProgress(e,o)}else{const e=this.getElasticProgress(t,o);d=1+(d-1)*e*l,u=1+(u-1)*e*l}if(o.centerBased?(c=i+s.offsetX*d,h=r+s.offsetY*u):(c=s.startX*d,h=s.startY*u),e.x=c,e.y=h,e.vx=s.offsetX*(d-1)*l*.1,e.vy=s.offsetY*(u-1)*l*.1,t>.9){const n=10*(1-t);e.vx=e.vx*n+s.originalVx*(1-n),e.vy=e.vy*n+s.originalVy*(1-n)}},getElasticProgress(e,t){if(!t.elastic)return this.easeInOutCubic(e);if(0===e)return 0;if(1===e)return 1;const n=t.overshoot||.1;if(e<.5){const t=2*e;return.5*this.easeInElastic(t,n)}{const t=2*(e-.5);return.5+.5*this.easeOutElastic(t,n)}},cleanup(e){if(e.gestureData?.stretch){const t=e.gestureData.stretch;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.stretch}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeInElastic:(e,t)=>0===e?0:1===e?1:-Math.pow(2,10*(e-1))*Math.sin((e-1-.075)*(2*Math.PI)/.3)*(1+t),easeOutElastic:(e,t)=>0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((e-.075)*(2*Math.PI)/.3)*(1+t)+1,"3d":{evaluate(e,t){const{particle:n}=t;if(!n||!n.gestureData?.stretch)return{position:[0,0,0],rotation:[0,0,0],scale:1};const a=t.config||{},i=t.strength||1;let r,s=a.scaleX||1.3,o=a.scaleY||.9;if(a.preserveArea&&1!==s&&1!==o){const e=s*o,t=Math.sqrt(1/e);s*=t,o*=t}if(a.elastic){const t=a.overshoot||.1;if(e<.5){const n=2*e,a=.3,i=a/4;r=-Math.pow(2,10*(n-1))*Math.sin((n-1-i)*(2*Math.PI)/a)*(1+t)*.5}else{const n=2*(e-.5),a=.3,i=a/4;r=.5+.5*(Math.pow(2,-10*n)*Math.sin((n-i)*(2*Math.PI)/a)*(1+t)+1)}}else r=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2;let l,c=1;if(e>.8){const t=(e-.8)/(1-.8);c=1-t*t*t}l=a.alternate?e<.5?2*e*.8:.8-2*(e-.5)*1.4:1*r*i;const h=1+l*c;return{position:[0,0,0],rotation:[0,0,.1*Math.sin(e*Math.PI*4)*r*c],scale:h}}}},qf={name:"pancake",emoji:"",type:"override",description:"Extreme flatten and hold - cartoon pancake effect",config:{duration:1600,musicalDuration:{musical:!0,bars:1},squashAmount:.2,stretchAmount:2,holdRatio:.5,strength:1,particleMotion:{type:"pancake",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.squashAmount||.2,r=n.stretchAmount||2,s=.1+.6*(n.holdRatio||.5);let o=0,l=0;if(e<.1){const t=e/.1;o=1-Math.pow(1-t,2)}else if(e<s){o=1;const t=(e-.1)/(s-.1);l=Math.sin(t*Math.PI*4)*(1-t)*.02}else{const t=(e-s)/(1-s);if(o=1-(t<.3?t/.3*.3:.3+(t-.3)/.7*.7),t>.8){const e=(t-.8)/.2,n=.15*Math.sin(e*Math.PI);o=Math.max(0,o-n)}}const c=1+o*(r-1)*a;let h=1,d=0;return e<.15?(h=1+.8*(1-e/.15),d=.6*(1-e/.15)):e<s?(h=1.3,d=.2):h=1.3-(e-s)/(1-s)*.3,{position:[l*a,.2*-o*a,0],rotation:[0,0,2*l*a],scale:[c,1-o*(1-i)*a,c],glowIntensity:h,glowBoost:d}}}},Hf={name:"rage",emoji:"",type:"override",description:"Barbarian rage - intense buildup and release",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"rage",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1;let a=0,i=0,r=0,s=0,o=1,l=1,c=0;if(e<.2){const t=e/.2,o=t*t;i=.05*-o*n,r=.15*o*n;const c=Math.sin(80*e)*o*.02;s=c*n,a=.02*c*n,l=1+.3*o}else if(e<.6){const t=(e-.2)/.4,h=t*t;i=(-.05-.03*h)*n,r=(.15+.1*h)*n;const d=.02+.04*h,u=100+50*t,p=Math.sin(e*u)*d;s=p*n,a=.03*p*n,o=1+.1*h,l=1.3+.7*h,c=.5*h}else if(e<.8){const t=(e-.6)/.2;i=(.15*t-.08)*n,r=(.25-.4*t)*n,s=Math.sin(150*e)*(1-.5*t)*.05*n,o=1.1+.08*Math.sin(t*Math.PI),l=2-.3*t,c=.5+.3*Math.sin(t*Math.PI)}else{const t=(e-.8)/.2,a=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;i=(.07-.07*a)*n,r=(.15*a-.15)*n,s=Math.sin(50*e)*(1-a)*.02*n,o=1.1-.1*a,l=1.7-.7*a,c=.5*(1-a)}return{position:[a,i,0],rotation:[r,0,s],scale:o,glowIntensity:l,glowBoost:c}}}},jf={name:"fury",emoji:"",type:"override",description:"Quick fury burst - intense flash of anger",config:{duration:800,musicalDuration:{musical:!0,beats:2},strength:1,particleMotion:{type:"fury",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1;let a=0,i=0,r=0,s=1,o=1,l=0;if(e<.2){const t=e/.2,i=1-Math.pow(1-t,3);s=1+.15*i*n;const c=Math.sin(120*e)*i*.04;r=c*n,a=.02*c*n,o=1+1.2*i,l=.7*i}else if(e<.5){const t=(e-.2)/.3;s=1.15+.03*Math.sin(t*Math.PI*3);const c=.05*Math.sin(150*e)*(1-.3*t);r=c*n,a=.025*c*n,i=.1*Math.sin(t*Math.PI)*n,o=2.2-.3*t,l=.7-.2*t}else{const t=(e-.5)/.5,a=t*t;s=1.15-.15*a,r=Math.sin(80*e)*(1-a)*.03*n,i=.1*(1-a)*n,o=1.9-.9*a,l=.5*(1-a)}return{position:[a,0,0],rotation:[i,0,r],scale:s,glowIntensity:o,glowBoost:l}}}},Xf={name:"battlecry",emoji:"",type:"override",description:"Warrior battlecry - inhale, expand, roar",config:{duration:1500,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"battlecry",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1;let a=0,i=0,r=0,s=0,o=1,l=1,c=0;if(e<.25){const t=e/.25,s=t*t;i=.08*s*n,r=.15*-s*n,a=.03*-s*n,o=1+.05*s,l=1+.4*s}else if(e<.4){const t=(e-.25)/.15;i=(.08+.02*t)*n,r=(-.15-.1*t)*n,a=(.05*t-.03)*n,o=1.05+.08*t,l=1.4+.5*t,c=.4*t}else if(e<.6){const t=(e-.4)/.2,h=1-Math.pow(1-t,3);i=(.1-.2*h)*n,r=(.4*h-.25)*n,a=(.02+.08*h)*n,o=1.13+.12*h,l=1.9+.6*h,c=.4+.4*h,s=Math.sin(t*Math.PI*20)*(1-t)*.02*n}else{const t=(e-.6)/.4,h=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;i=-.1*(1-h)*n,r=.15*(1-h)*n,a=.1*(1-h)*n,o=1.25-.25*h,s=Math.sin(t*Math.PI*8)*(1-h)*.015*n,l=2.5-1.5*h,c=.8-.8*h}return{position:[0,a,i],rotation:[r,0,s],scale:o,glowIntensity:l,glowBoost:c}}}},Yf={name:"charge",emoji:"",type:"override",description:"Bull charge - wind up and rush forward",config:{duration:1200,musicalDuration:{musical:!0,beats:3},strength:1,particleMotion:{type:"charge",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1;let a=0,i=0,r=0,s=0,o=0,l=1,c=1,h=0;if(e<.2){const t=e/.2,a=t*t;i=.08*-a*n,r=.1*a*n,s=.25*a*n,l=1-.05*a,c=1+.4*a}else if(e<.6){const t=(e-.2)/.4,a=1-Math.pow(1-t,2);r=(.1-.35*a)*n,s=(.25+.1*a)*n,i=(.06*a-.08)*n,l=.95+.15*a,c=1.4+.6*a,h=.4*a,o=Math.sin(t*Math.PI*10)*a*.02*n}else if(e<.85){const t=(e-.6)/.25;r=-.25*n,s=(.35-.1*t)*n;const i=Math.sin(t*Math.PI*15)*(1-t)*.04;o=i*n,a=.02*i*n,l=1.1+.05*Math.sin(t*Math.PI),c=2-.3*t,h=.4*(1-.5*t)}else{const t=(e-.85)/.15,a=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;r=-.25*(1-a)*n,s=.25*(1-a)*n,i=-.02*(1-a)*n,l=1.1-.1*a,c=1.7-.7*a,h=.2*(1-a)}return{cameraRelativePosition:[a,i,r],rotation:[s,0,o],scale:l,glowIntensity:c,glowBoost:h}}}},$f={name:"wobble",emoji:"",type:"override",description:"Unsteady circular wobbling motion",config:{duration:1500,musicalDuration:{musical:!0,beats:4},wobbleRadius:.08,wobbleAngle:.2,rotations:2,decay:.5,strength:1,particleMotion:{type:"wobble",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:4},timingSync:"onBeat"},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.wobbleRadius||.08,r=n.wobbleAngle||.2,s=n.rotations||2,o=n.decay||.5,l=e*s*Math.PI*2,c=1-o*e,h=Math.sin(l)*i*c*a,d=Math.cos(l)*i*c*a,u=Math.cos(l)*r*c*a,p=Math.sin(l)*r*c*a;return{position:[h,.02*Math.sin(2*l)*c*a,d],rotation:[u,0,p],scale:1+.05*Math.sin(2*l)*c,glowIntensity:1+.2*Math.sin(l)*c,glowBoost:0}}}},Qf={name:"teeter",emoji:"",type:"override",description:"Rock back and forth unstably like losing balance",config:{duration:1200,musicalDuration:{musical:!0,beats:3},tiltAngle:.25,frequency:3,irregularity:.3,strength:1,particleMotion:{type:"teeter",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat"},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.tiltAngle||.25,r=n.frequency||3,s=n.irregularity||.3,o=(Math.sin(e*r*Math.PI*2)+Math.sin(e*(r+1.7)*Math.PI*2)*s+Math.sin(e*(.5*r)*Math.PI*2)*s*.5)/(1+1.5*s),l=o*i*a*.7,c=Math.sin(e*r*Math.PI*2+.5)*i*a*.5;return{position:[.15*c,0,.1*l],rotation:[l,0,c],scale:1+.05*Math.abs(o),glowIntensity:1+.2*Math.abs(o),glowBoost:0}}}},Kf={name:"rock",emoji:"",type:"override",description:"Gentle front-back rocking motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},rockAngle:.15,rockCycles:2,smooth:!0,strength:1,particleMotion:{type:"rock",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat"},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.rockAngle||.15,r=e*(n.rockCycles||2)*Math.PI*2,s=Math.sin(r),o=s*i*a,l=.05*s*a;return{position:[0,.02*Math.abs(s)*a,l],rotation:[o,0,0],scale:1+.02*Math.sin(.5*r),glowIntensity:1+.1*s,glowBoost:0}}}},Zf={name:"pendulum",emoji:"",type:"override",description:"Swing side to side like a pendulum clock",config:{duration:1500,musicalDuration:{musical:!0,beats:4},swingAngle:.4,swings:2,damping:.3,strength:1,particleMotion:{type:"pendulum",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:4},timingSync:"onBeat"},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.swingAngle||.4,r=n.swings||2,s=n.damping||.3,o=e*r*Math.PI*2,l=1-s*e,c=Math.sin(o)*l,h=c*i*a;return{position:[.1*c*a,.03*-Math.abs(c)*a,0],rotation:[0,0,h],scale:1,glowIntensity:1+.15*Math.abs(c),glowBoost:0}}}};function Jf(e){const t={front:{screenOffset:[0,0],screenDirection:[0,0],recoilDir:[0,0,-1]},back:{screenOffset:[0,0],screenDirection:[0,0],recoilDir:[0,0,1]},left:{screenOffset:[-.1,0],screenDirection:[1,0],recoilDir:[1,0,0]},right:{screenOffset:[.1,0],screenDirection:[-1,0],recoilDir:[-1,0,0]},up:{screenOffset:[0,.1],screenDirection:[0,-1],recoilDir:[0,-1,0]},down:{screenOffset:[0,-.1],screenDirection:[0,1],recoilDir:[0,1,0]}},n=t[e]||t.front;return{name:`crack${e.charAt(0).toUpperCase()+e.slice(1)}`,emoji:"",type:"override",category:"reactions",description:`Surface cracks spreading from ${e} impact`,config:{duration:2e3,strength:1,glowStrength:.3,holdTime:500},rhythm:{enabled:!0,syncMode:"accent",strengthSync:{onBeat:1.2,offBeat:.8}},"3d":{evaluate(e,t){const a={strength:1,glowStrength:.3,...t},{strength:i,glowStrength:r}=a,s=.03*Math.max(0,1-4*e)*i,{recoilDir:o}=n,l=e<.05;return{cameraRelativePosition:[o[0]*s,o[1]*s,o[2]*s],crack:{enabled:!0,trigger:l,amount:i,propagation:.8,screenOffset:n.screenOffset,screenDirection:n.screenDirection,glowStrength:r}}}}}}const eg=Jf("front"),tg=Jf("back"),ng=Jf("left"),ag=Jf("right"),ig=Jf("up"),rg=Jf("down"),sg={name:"crackHeal",emoji:"",type:"override",category:"reactions",description:"Heal and fade existing cracks",config:{duration:1500,glowStrength:.5},"3d":{evaluate(e,t){const n={duration:1500,...t},a=e<.05;return{cameraRelativePosition:[0,.02*Math.sin(e*Math.PI),0],crack:{enabled:!1,heal:!0,healTrigger:a,healDuration:n.duration},glowBoost:.1*Math.sin(e*Math.PI)}}}};var og={name:"shatter",emoji:"",type:"override",description:"Particles explode outward then freeze like shattered glass",config:{duration:1500,musicalDuration:{musical:!0,bars:1},explosionPhase:.3,freezePhase:.7,distance:100,tumble:1,strength:1,particleMotion:{type:"shatter",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=Math.random()*Math.PI*2,r=.5+.5*Math.random();e.gestureData.shatter={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??1,velocityX:Math.cos(i)*r,velocityY:Math.sin(i)*r,tumbleAngle:0,tumbleSpeed:4*(Math.random()-.5),frozenX:null,frozenY:null,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.shatter?.initialized||this.initialize(e,n,i,r);const s={...this.config,...n},o=s.strength||1,l=s.distance||100,c=e.gestureData.shatter,h=s.explosionPhase||.3,d=s.freezePhase||.7;if(t<h){const n=t/h,a=1-Math.pow(1-n,3),i=c.velocityX*l*a*o,r=c.velocityY*l*a*o;e.x=c.originalX+i,e.y=c.originalY+r,c.tumbleAngle+=c.tumbleSpeed*(1-n)}else if(t<d){const n=(t-h)/(d-h),a=c.originalX+c.velocityX*l*o,i=c.originalY+c.velocityY*l*o,r=c.velocityX*l*.2*n*o,s=c.velocityY*l*.2*n*o;e.x=a+r,e.y=i+s,c.tumbleAngle+=.3*c.tumbleSpeed*(1-n),n>.95&&null===c.frozenX&&(c.frozenX=e.x,c.frozenY=e.y)}else if(null!==c.frozenX&&(e.x=c.frozenX,e.y=c.frozenY),t>.9){const n=(t-.9)/.1;e.opacity=c.originalOpacity*(1-.5*n)}},cleanup(e){if(e.gestureData?.shatter){const t=e.gestureData.shatter;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.shatter}},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1;let a=1,i=1,r=1,s=0,o=0,l=0,c=0,h=0,d=0,u=1,p=0;if(e<.1){const t=e/.1,s=1-Math.pow(1-t,2);i=1-.4*s*n,a=1+.2*s*n,r=1+.2*s*n,h=.1*-s*n,u=1+1*s,p=.8*s}else if(e<.4){const t=(e-.1)/.3,m=1-.6*t,f=40,g=Math.sin(e*f*Math.PI)*m,y=Math.cos(e*f*1.3*Math.PI)*m,v=Math.sin(e*f*.7*Math.PI)*m,b=1+.3*(1-Math.pow(1-t,2))*n;a=b+.15*g*n,i=b+.15*y*n,r=b+.15*v*n,s=.4*g*n,o=.5*y*n,l=.3*v*n,c=.15*g*n,h=.12*y*n+.1*t,d=.1*v*n,u=1.5+.5*Math.abs(g),p=.5*m}else if(e<.7){const t=(e-.4)/.3,s=t*t,o=1-s,c=20*o,d=Math.sin(e*c*Math.PI)*o,m=1.3-.4*s;a=m+.05*d*n,i=m+.05*d*n,r=m+.05*d*n,l=.15*d*n,h=.1*o,u=1.5-.3*s,p=.3*o}else{const t=(e-.7)/.3,n=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,s=Math.sin(t*Math.PI*2)*(1-t)*.05;if(a=.9+.1*n+s,i=.9+.1*n+s,r=.9+.1*n+s,u=1.2-.2*n,e>.95){const t=(e-.95)/.05;p=.3*Math.sin(t*Math.PI)}}return{position:[c,h,d],rotation:[s,o,l],scale:[a,i,r],glowIntensity:u,glowBoost:p}}}};const lg={default:{name:"shatter",emoji:"",description:"Dramatic shattering effect",duration:2500,beats:4,intensity:1,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!1,revealSoul:!1},explosive:{name:"shatterExplosive",emoji:"",description:"Explosive outward shatter",duration:2e3,beats:3,intensity:1.5,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0},crumble:{name:"shatterCrumble",emoji:"",description:"Slow crumbling collapse",duration:8e3,beats:16,intensity:.15,impactPoint:[0,-.4,0],impactDirection:[0,-1,0],reassemble:!1,revealSoul:!0,gravity:-.8,explosionForce:.1,rotationForce:.5,shatterTriggerAt:0},reform:{name:"shatterReform",emoji:"",description:"Shatter then magically reassemble",duration:4e3,beats:8,intensity:1,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!0,reassembleAt:.5,reassembleDuration:1500,revealSoul:!0},punchLeft:{name:"shatterPunchLeft",emoji:"",description:"Shatter from left impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[-.4,0,0],impactDirection:[1,0,0],reassemble:!1,useDeformation:!0,direction:"left",revealSoul:!1},punchRight:{name:"shatterPunchRight",emoji:"",description:"Shatter from right impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[.4,0,0],impactDirection:[-1,0,0],reassemble:!1,useDeformation:!0,direction:"right",revealSoul:!1},punchFront:{name:"shatterPunchFront",emoji:"",description:"Shatter from front impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!1,useDeformation:!0,direction:"front",revealSoul:!1},suspend:{name:"shatterSuspend",emoji:"",description:"Shatter, freeze mid-air, then reassemble",duration:4e3,beats:8,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!0,reassembleAt:.7,reassembleDuration:1200,revealSoul:!0,isSuspendMode:!0,suspendAt:.12,suspendDuration:.2,gravity:-2,explosionForce:1.2},freeze:{name:"shatterFreeze",emoji:"",description:"Shatter and freeze mid-air (call triggerReassembly to reform)",duration:2e3,beats:4,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0,isFreezeMode:!0,isSuspendMode:!0,suspendAt:.12,suspendDuration:.2,gravity:-2,explosionForce:1.2},implode:{name:"shatterImplode",emoji:"",description:"Shards implode inward to center (or implode existing frozen shards)",duration:2500,beats:4,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0,isDualMode:!0,dualModeType:"implode",dualModeDuration:1800,gravity:-3,explosionForce:1.2},gravity:{name:"shatterGravity",emoji:"",description:"Shards fall with gravity and bounce on floor (or drop frozen shards)",duration:4e3,beats:8,intensity:.6,impactPoint:[0,0,0],impactDirection:[0,-1,0],reassemble:!1,revealSoul:!0,isDualMode:!0,dualModeType:"gravity",dualModeDuration:3e3,floorY:-.35,gravity:-2,explosionForce:.4},orbit:{name:"shatterOrbit",emoji:"",description:"Shards orbit around the soul then reassemble",duration:5e3,beats:10,intensity:.6,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!0,reassembleAt:.75,reassembleDuration:1200,revealSoul:!0,isDualMode:!0,dualModeType:"orbit",dualModeDuration:3500,orbitSpeed:1.5,radiusMultiplier:1.2,gravity:-3,explosionForce:1}};function cg(e="default"){const t=lg[e]||lg.default;return{name:t.name,emoji:t.emoji,type:"override",description:t.description,config:{duration:t.duration,musicalDuration:{musical:!0,beats:t.beats},intensity:t.intensity,variant:e},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:t.beats},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.intensity||1,i=n.variant||"default",r=lg[i]||lg.default,s=r.useDeformation||!1,o=r.direction||"front";let l=!1,c=!1,h=1,d=0,u=1,p=null,m=null,f=null;const g=r.reassemble,y=r.reassembleAt||.5;if(s){let t;if(e<.3){const n=e/.3;t=n*(2-n)}else t=0;let n=0;e<.25?n=e/.25:e<.3&&(n=1);const i=.15*a,s=.25*a;let c=0,u=0;const g=0;let y=0,v=0;switch(o){case"left":c=t*i,v=-t*s;break;case"right":c=-t*i,v=t*s;break;case"front":u=-t*i,y=t*s*.7}if(t>0&&(m=[c,g,u],f=[y,0,v]),n>0&&(p={enabled:!0,strength:n*a*2.5,impactPoint:r.impactPoint,falloffRadius:.5}),e>=.28&&e<.32&&(l=!0),e<.35){const t=e/.35;h=1+.8*(1-t),d=.5*(1-t)}}else{const t=void 0!==r.shatterTriggerAt?r.shatterTriggerAt:.1,n=t+.02;if(e<t){if(t>0){const n=e/t,a=n*n;h=1+.6*a,d=.3*a,u=1+.05*a,"explosive"===i&&(u+=.01*Math.sin(200*e)*n)}}else if(e<n)l=e>=t&&e<t+.005,h=1.6,d=.4,u=1.05;else{if(g&&e>=y&&e<y+.02&&(c=!0),g&&e>=y){const t=(e-y)/(1-y),n=t*t;h=1+.8*n,d=.5*n,e>.95&&(h=2,d=.8)}else{const t=(e-n)/(g?y-n:1-n),a=Math.min(1,t),i=1-(1-a)*(1-a);h=1.6-.6*i,d=.4-.4*i}u=1}}const v={scale:u,glowIntensity:h,glowBoost:d,shatter:{enabled:l,impactPoint:r.impactPoint,impactDirection:r.impactDirection||[0,0,-1],intensity:a*r.intensity,variant:i,reassemble:c,reassembleDuration:r.reassembleDuration||1e3,revealSoul:!1!==r.revealSoul,isSuspendMode:r.isSuspendMode||!1,suspendAt:r.suspendAt||.25,suspendDuration:r.suspendDuration||.35,isFreezeMode:r.isFreezeMode||!1,gravity:r.gravity,explosionForce:r.explosionForce,rotationForce:r.rotationForce,gestureDuration:r.duration,isDualMode:r.isDualMode||!1,dualModeType:r.dualModeType,dualModeConfig:{duration:r.dualModeDuration||2e3,impactPoint:r.impactPoint,windDirection:r.windDirection,windForce:r.windForce,turbulence:r.turbulence,waveSpeed:r.waveSpeed,floorY:r.floorY,orbitSpeed:r.orbitSpeed,radiusMultiplier:r.radiusMultiplier,reassemble:r.reassemble,reassembleDuration:r.reassembleDuration}}};return p&&(v.deformation=p),m&&(v.cameraRelativePosition=m),f&&(v.cameraRelativeRotation=f),v}}}}const hg={up:{name:"dissolveUp",emoji:"",description:"Shards blow upward like rising dust",windDirection:[0,1,.1],windForce:2.5,turbulence:.6},down:{name:"dissolveDown",emoji:"",description:"Shards blow downward like falling ash",windDirection:[0,-1,.1],windForce:1.8,turbulence:.4},left:{name:"dissolveLeft",emoji:"",description:"Shards blow left in the wind",windDirection:[-1,.15,0],impactDir:[1,.15,0],windForce:2.2,turbulence:.5},right:{name:"dissolveRight",emoji:"",description:"Shards blow right in the wind",windDirection:[1,.15,0],impactDir:[-1,.15,0],windForce:2.2,turbulence:.5},away:{name:"dissolveAway",emoji:"",description:"Shards blow away from camera into distance",windDirection:[0,.1,-1],windForce:2,turbulence:.4},toward:{name:"dissolveToward",emoji:"",description:"Shards blow toward camera",windDirection:[0,.1,1],windForce:2.5,turbulence:.6}};function dg(e="away"){const t=hg[e]||hg.away;return{name:t.name,emoji:t.emoji,type:"override",description:t.description,config:{duration:3500,musicalDuration:{musical:!0,beats:6},intensity:.7,direction:e},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:6},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.2}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.intensity||.7,i=n.direction||"away",r=hg[i]||hg.away;let s=!1,o=1,l=0,c=1;const h=.06;if(e<h){const t=e/h;o=1+.4*t,l=.2*t,c=1+.03*t}else if(e<.08)s=e>=h&&e<.065,o=1.4,l=.3;else{const t=(e-h)/.94;o=1.4-.6*t,l=Math.max(0,.3-.3*t)}return{scale:c,glowIntensity:o,glowBoost:l,shatter:{enabled:s,impactPoint:[0,0,0],impactDirection:r.impactDir||r.windDirection,intensity:.5*a,variant:`dissolve_${i}`,revealSoul:!0,isSuspendMode:!1,isFreezeMode:!1,gravity:-.5,explosionForce:.3,gestureDuration:3500,isDualMode:!0,dualModeType:"dissolve",dualModeConfig:{duration:3e3,windDirection:r.windDirection,windForce:r.windForce*a,turbulence:r.turbulence}}}}}}}var ug={name:"morph",emoji:"",type:"override",description:"Form geometric patterns and shapes",config:{musicalDuration:{musical:!0,beats:2,minBeats:1,maxBeats:8},phases:[{name:"gather",beats:.25},{name:"form",beats:.75},{name:"hold",beats:.5},{name:"dissolve",beats:.5}],morphType:"fluid",pattern:"star",points:5,innerRadius:.4,size:80,amplitude:20,rotation:0,smooth:!0,randomizeOrder:!1,easing:"sine",strength:1.2,particleMotion:{type:"morph",pattern:"star",strength:1.2,smooth:!0,points:5}},rhythm:{enabled:!0,syncMode:"phrase",patternSync:{verse:"circle",chorus:"star",bridge:"heart",drop:"explosion"},timingSync:{formationBeat:1,holdBeats:2,dissolveBeat:4,curve:"anticipatory"},sizeSync:{onBeat:1.2,offBeat:.95,subdivision:"quarter",curve:"elastic"},rotationSync:{mode:"continuous",degreesPerBar:90,direction:"clockwise"},dynamics:{forte:{points:8,size:100},piano:{points:3,size:60}}},initialize(e,t,n,a,i){e.gestureData||(e.gestureData={});const r={...this.config,...t},s=e.x,o=e.y,l=Math.atan2(e.y-a,e.x-n),c=Math.random()<.5?1:-1;let h,d;const u=r.size*e.scaleFactor,p=(r.rotation||0)*Math.PI/180*c;switch(r.pattern){case"star":h=n,d=a,this.calculateStarPosition(e,l,u,r.points,r.innerRadius,p,n,a);break;case"heart":this.calculateHeartPosition(e,l,u,p,n,a);break;case"square":this.calculateSquarePosition(e,l,u,p,n,a);break;case"triangle":this.calculateTrianglePosition(e,l,u,p,n,a);break;default:{const e=u;h=n+Math.cos(l+p)*e,d=a+Math.sin(l+p)*e;break}}e.gestureData.morph={startX:s,startY:o,targetX:e.gestureData.morphTargetX||h,targetY:e.gestureData.morphTargetY||d,originalVx:e.vx,originalVy:e.vy,rotationDirection:c,initialized:!0}},calculateStarPosition(e,t,n,a,i,r,s,o){const l=((t+Math.PI)%(2*Math.PI)+2*Math.PI)%(2*Math.PI),c=Math.floor(l/(2*Math.PI)*10),h=c%2==0,d=Math.floor(c/2);let u;u=h?72*d*Math.PI/180:(72*d+36)*Math.PI/180,u+=r;const p=h?n:n*i;e.gestureData.morphTargetX=s+Math.cos(u)*p,e.gestureData.morphTargetY=o+Math.sin(u)*p},calculateHeartPosition(e,t,n,a,i,r){const s=(t+Math.PI)/(2*Math.PI),o=.05*n,l=16*Math.pow(Math.sin(s*Math.PI*2),3),c=-(13*Math.cos(s*Math.PI*2)-5*Math.cos(2*s*Math.PI*2)-2*Math.cos(3*s*Math.PI*2)-Math.cos(4*s*Math.PI*2)),h=Math.cos(a),d=Math.sin(a),u=l*h-c*d,p=l*d+c*h;e.gestureData.morphTargetX=i+u*o,e.gestureData.morphTargetY=r+p*o},calculateSquarePosition(e,t,n,a,i,r){const s=((t+a)%(2*Math.PI)+2*Math.PI)%(2*Math.PI);let o,l;const c=n;s<Math.PI/4||s>=7*Math.PI/4?(o=c,l=c*Math.tan(s)):s<3*Math.PI/4?(o=c/Math.tan(s),l=c):s<5*Math.PI/4?(o=-c,l=-c*Math.tan(s)):(o=-c/Math.tan(s),l=-c);const h=Math.cos(a),d=Math.sin(a),u=o*h-l*d,p=o*d+l*h;e.gestureData.morphTargetX=i+u,e.gestureData.morphTargetY=r+p},calculateTrianglePosition(e,t,n,a,i,r){const s=[{x:0,y:-n},{x:.866*-n,y:.5*n},{x:.866*n,y:.5*n}],o=Math.floor((t+Math.PI)/(2*Math.PI)*3)%3,l=(o+1)%3,c=Math.random(),h=s[o].x+(s[l].x-s[o].x)*c,d=s[o].y+(s[l].y-s[o].y)*c,u=Math.cos(a),p=Math.sin(a),m=h*u-d*p,f=h*p+d*u;e.gestureData.morphTargetX=i+m,e.gestureData.morphTargetY=r+f},apply(e,t,n,a,i,r){e.gestureData?.morph?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.morph,o={...this.config,...n};let l,c,h=t;if(o.holdTime>0){const e=.5-o.holdTime/2,n=.5+o.holdTime/2;h=t<e?t/e*.5:t<n?.5:.5+(t-n)/(1-n)*.5}if(h<=.5){const e=2*h;l=s.startX+(s.targetX-s.startX)*this.easeOutQuad(e),c=s.startY+(s.targetY-s.startY)*this.easeOutQuad(e)}else{const e=2*(h-.5);l=s.targetX+(s.startX-s.targetX)*this.easeInQuad(e),c=s.targetY+(s.startY-s.targetY)*this.easeInQuad(e)}if(o.smooth){const t=.2;e.x+=(l-e.x)*t,e.y+=(c-e.y)*t}else e.x=l,e.y=c;if(e.vx=.5*(l-e.x),e.vy=.5*(c-e.y),t>.9){const n=10*(1-t);e.vx=e.vx*n+s.originalVx*(1-n),e.vy=e.vy*n+s.originalVy*(1-n)}},cleanup(e){if(e.gestureData?.morph){const t=e.gestureData.morph;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.morph,delete e.gestureData.morphTargetX,delete e.gestureData.morphTargetY}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutQuad:e=>e*(2-e),easeInQuad:e=>e*e,"3d":{evaluate(e,t){const n=t?.strength||1,a=Math.sin(e*Math.PI);let i;if(e<=.5){const t=2*e;i=1+t*(2-t)*.25*n}else{const t=2*(e-.5);i=1.25*n+t*t*(1-1.25*n),i=Math.max(1,i)}return{position:[0,0,0],rotation:[0,a*Math.PI*.3*n,.1*Math.sin(e*Math.PI*2)*n],scale:i,glowIntensity:1+.4*a*n,glowBoost:1.5*a*n}}}},pg={name:"rain",emoji:"",type:"override",description:"Particles fall down from their current positions",config:{duration:3e3,musicalDuration:{musical:!0,bars:2},fallSpeed:8,fallDistance:400,wobbleAmount:1.5,strength:1,particleMotion:{type:"rain",strength:1,fallSpeed:8}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:2},intensitySync:{quiet:.5,loud:1.5,crescendo:"increase",diminuendo:"decrease"}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.rain={originalX:e.x,originalY:e.y,originalVx:e.vx,originalVy:e.vy,originalOpacity:e.opacity??e.life??1,currentX:e.x,currentY:e.y,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),initialized:!0}},apply(e,t,n,a){const i="number"==typeof a?a:1;e.gestureData?.rain?.initialized||this.initialize(e,n);const r=e.gestureData.rain,s={...this.config,...n},o=n?.strength||1,l=(s.fallSpeed||8)*o,c=(s.fallDistance||400)*t*o;r.wobblePhase+=r.wobbleSpeed*i*.1;const h=Math.sin(r.wobblePhase)*(s.wobbleAmount||1.5);if(e.x=r.originalX+h,e.y=r.originalY+c,e.vx=.3*h,e.vy=10*l,t>.6){const n=(t-.6)/.4;e.opacity=r.originalOpacity*(1-n),void 0!==e.life&&(e.life=r.originalOpacity*(1-n))}else e.opacity=r.originalOpacity,void 0!==e.life&&(e.life=r.originalOpacity)},cleanup(e){if(e.gestureData?.rain){const t=e.gestureData.rain;e.x=t.originalX,e.y=t.originalY,e.vx=t.originalVx,e.vy=t.originalVy,e.opacity=t.originalOpacity,void 0!==e.life&&(e.life=t.originalOpacity),delete e.gestureData.rain}},"3d":{evaluate:(e,t)=>({position:[0,0,0],rotation:[0,0,0],scale:1})}},mg={name:"drift",emoji:"",type:"override",description:"Controlled floating with fade effects",config:{duration:800,musicalDuration:{musical:!0,beats:2},distance:50,angle:45,returnToOrigin:!0,fadeOut:!1,holdTime:.2,turbulence:.1,angleSpread:45,smoothness:.08,easing:"ease",strength:1,particleMotion:{type:"drift",strength:1,distance:60}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"beats",beats:2},distanceSync:{quiet:30,loud:80,crescendo:"expand",diminuendo:"contract"},angleSync:{major:45,minor:225,modulation:"smooth",cadence:"return"},holdSync:{shortPhrase:.1,longPhrase:.4,fermata:"sustain"},accentResponse:{enabled:!0,multiplier:1.3,type:"distance"},patternOverrides:{ambient:{distanceSync:{quiet:40,loud:100},holdSync:{shortPhrase:.3,longPhrase:.6}},classical:{angleSync:{major:30,minor:210},distanceSync:{quiet:25,loud:60}},jazz:{angleSync:{major:60,minor:240,swing:!0,syncopated:!0}},new_age:{distanceSync:{quiet:35,loud:70},holdSync:{shortPhrase:.4,longPhrase:.8},angleSync:{modulation:"gradual"}}},dynamics:{forte:{distanceSync:{quiet:{multiplier:1.5},loud:{multiplier:1.8}},holdSync:{multiplier:1.2},accentResponse:{multiplier:1.6}},piano:{distanceSync:{quiet:{multiplier:.6},loud:{multiplier:.8}},holdSync:{multiplier:.8},accentResponse:{multiplier:1.1}}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a;let s=Math.atan2(r,i);const o={...this.config,...t}.angleSpread*Math.PI/180,l=(Math.random()-.5)*o;s+=l;const c=30+30*Math.random();e.gestureData.drift={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,baseOpacity:e.opacity||e.life||1,driftAngle:s,angleOffset:l,homeRadius:c*e.scaleFactor,homeX:n+Math.cos(s)*c,homeY:a+Math.sin(s)*c,role:Math.random(),turbulencePhase:Math.random()*Math.PI*2,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.drift?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.drift,o={...this.config,...n},l=n.strength||1,c=this.easeInOutCubic(t),h=Math.max(0,c-.1*s.role);let d,u,p;if(o.returnToOrigin)if(h<.4){const e=h/.4,t=this.easeOutQuad(e);d=s.startX+(s.homeX-s.startX)*t,u=s.startY+(s.homeY-s.startY)*t}else if(h<.6+o.holdTime){const t=(h-.4)/(.2+o.holdTime);p=s.homeRadius+Math.sin(t*Math.PI*.5)*o.distance*l*e.scaleFactor}else{const t=(h-.6-o.holdTime)/(.4-o.holdTime);p=s.homeRadius+Math.cos(t*Math.PI*.5)*o.distance*l*e.scaleFactor}else{const t=h;p=s.homeRadius+t*o.distance*l*e.scaleFactor}if(void 0!==p){s.turbulencePhase+=o.turbulence*a;const e=Math.sin(s.turbulencePhase)*o.turbulence*10,t=Math.cos(1.3*s.turbulencePhase)*o.turbulence*10,n=s.driftAngle+s.angleOffset;d=i+Math.cos(n)*p+e,u=r+Math.sin(n)*p+t}const m=o.smoothness+.08*s.role;if(e.x+=(d-e.x)*m,e.y+=(u-e.y)*m,e.vx=.25*(d-e.x),e.vy=.25*(u-e.y),o.fadeOut){let n;n=t<.25?.3+t/.25*.7:t<.75?.7+.3*Math.sin((t-.25)*Math.PI/.5):4*(1-t),e.opacity=s.baseOpacity*n,void 0!==e.life&&(e.life=e.opacity)}t>=.99&&(e.vx=.1*s.originalVx,e.vy=.1*s.originalVy,o.fadeOut&&(e.opacity=s.baseOpacity,void 0!==e.life&&(e.life=s.baseOpacity)))},cleanup(e){if(e.gestureData?.drift){const t=e.gestureData.drift;e.vx=t.originalVx,e.vy=t.originalVy,e.opacity=t.baseOpacity,void 0!==e.life&&(e.life=t.baseOpacity),delete e.gestureData.drift}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutQuad:e=>e*(2-e),"3d":{evaluate(e,t){const n={...this.config,...t},a=t.strength||1,i=(n.angle||45)*Math.PI/180,r=n.returnToOrigin?e<.5?2*e:2*(1-e):e;return{position:[Math.cos(i)*r*.3*a,Math.sin(i)*r*.3*a,.15*Math.sin(e*Math.PI)*a],rotation:[0,10*r*a,0],scale:1+.03*Math.sin(e*Math.PI),glowIntensity:1-.1*r}}}};function fg(e){const t=pm[e];if(!t)throw new Error(`Invalid drift direction: ${e}`);const n="up"===e||"down"===e;return{name:`drift${mm(e)}`,emoji:"up"===e?"":"down"===e?"":"left"===e?"":"",type:"override",description:`Gentle drifting ${e}`,config:{duration:800,musicalDuration:{musical:!0,beats:2},distance:50,returnToOrigin:!0,fadeOut:!1,holdTime:.2,turbulence:.1,smoothness:.08,strength:1,direction:e,particleMotion:{type:"drift",strength:1,distance:60}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"beats",beats:2},distanceSync:{quiet:30,loud:80,crescendo:"expand",diminuendo:"contract"},holdSync:{shortPhrase:.1,longPhrase:.4,fermata:"sustain"},accentResponse:{enabled:!0,multiplier:1.3,type:"distance"}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=(30+30*Math.random())*e.scaleFactor;e.gestureData.drift={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,baseOpacity:e.opacity||e.life||1,homeRadius:i,role:Math.random(),turbulencePhase:Math.random()*Math.PI*2,initialized:!0}},apply(e,a,i,r,s,o){e.gestureData?.drift?.initialized||this.initialize(e,i,s,o);const l=e.gestureData.drift,c={...this.config,...i},h=i.strength||1,d=this.easeInOutCubic(a),u=Math.max(0,d-.1*l.role);let p,m=l.startX,f=l.startY;p=c.returnToOrigin?u<.5?2*u:2*(1-u):u;const g=c.distance*h*e.scaleFactor*p;l.turbulencePhase+=c.turbulence*r;const y=Math.sin(l.turbulencePhase)*c.turbulence*10,v=Math.cos(1.3*l.turbulencePhase)*c.turbulence*10;n?(f=l.startY+t.y*g+y,m=l.startX+.5*v):(m=l.startX+t.x*g+v,f=l.startY+.5*y);const b=c.smoothness+.08*l.role;if(e.x+=(m-e.x)*b,e.y+=(f-e.y)*b,e.vx=.25*(m-e.x),e.vy=.25*(f-e.y),c.fadeOut){let t=1;t=a<.25?.3+a/.25*.7:a<.75?.7+.3*Math.sin((a-.25)*Math.PI/.5):4*(1-a),e.opacity=l.baseOpacity*t}a>=.99&&(e.vx=.1*l.originalVx,e.vy=.1*l.originalVy,c.fadeOut&&(e.opacity=l.baseOpacity))},cleanup(e){if(e.gestureData?.drift){const t=e.gestureData.drift;e.vx=t.originalVx,e.vy=t.originalVy,e.opacity=t.baseOpacity,delete e.gestureData.drift}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,a){const i=a||{},r=i.strength||1,s=i.distance||50,o=!1!==i.returnToOrigin?Math.sin(e*Math.PI):e,l=.004*s*r*o,c=t.x*l,h=t.y*l;let d=0,u=0;return n?d=t.y*o*.1:u=t.x*o*.15,{cameraRelativePosition:[c,h,0],rotation:[d,u,0],scale:1+.03*o,glowIntensity:1-.1*o}}}}}var gg=fg("up"),yg=fg("down"),vg=fg("left"),bg=fg("right"),wg={name:"vortex",emoji:"",type:"override",description:"Spiral tornado pattern inward or outward",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},direction:"inward",rotationSpeed:2,pullStrength:1,liftAmount:.5,strength:1,particleMotion:{type:"vortex",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",rotationSync:{onBeat:1.5,offBeat:.8}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-(n||0),r=e.y-(a||0);e.gestureData.vortex={originalX:e.x,originalY:e.y,startAngle:Math.atan2(r,i),startDistance:Math.sqrt(i*i+r*r),initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.vortex?.initialized||this.initialize(e,n,i,r);const s={...this.config,...n},o=e.gestureData.vortex,l="outward"!==s.direction,c=s.rotationSpeed||2,h=s.pullStrength||1,d=t*c*Math.PI*2,u=o.startAngle+d;let p;p=l?1-t*h*.8:1+t*h*.5;const m=o.startDistance*p;e.x=i+Math.cos(u)*m,e.y=r+Math.sin(u)*m,l&&t>.7&&(e.opacity=1-(t-.7)/.3)},cleanup(e){if(e.gestureData?.vortex){const t=e.gestureData.vortex;e.x=t.originalX,e.y=t.originalY,e.opacity=1,delete e.gestureData.vortex}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i="outward"!==n.direction,r=n.rotationSpeed||2,s=n.liftAmount||.5,o=e*r*Math.PI*2*a;let l;l=i?1-.3*e*a:1+.2*e*a;const c=e>.85?(1-e)/.15:1;return{position:[0,Math.sin(e*Math.PI)*s*.1*a*c,0],rotation:[.1*Math.sin(o)*a*c,o,.1*Math.cos(o)*a*c],scale:l,glowIntensity:1+.4*e,glowBoost:.3*e}}}};function xg(e){if(!pm[e])throw new Error(`Invalid cascade direction: ${e}`);const t="up"===e||"down"===e,n="down"===e||"right"===e;return{name:`cascade${mm(e)}`,emoji:"down"===e?"":"up"===e?"":"left"===e?"":"",type:"override",description:`Sequential cascade ${e}`,config:{duration:2e3,musicalDuration:{musical:!0,bars:1},distance:200,waveCount:4,staggerDelay:.15,wobble:1,strength:1,direction:e,particleMotion:{type:"cascade",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",distanceSync:{quiet:100,loud:300,crescendo:"expand",diminuendo:"contract"}},initialize(e,t){e.gestureData||(e.gestureData={});const n=t?.waveCount||4;let a;a=Math.floor(Math.random()*n),e.gestureData.cascade={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??e.life??1,waveGroup:a,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),initialized:!0}},apply(e,a,i,r,s,o){e.gestureData?.cascade?.initialized||this.initialize(e,i);const l={...this.config,...i},c=l.strength||1,h=e.gestureData.cascade,d="number"==typeof r?r:1,u=l.waveCount||4,p=l.staggerDelay||.15,m=h.waveGroup*p,f=Math.max(0,(a-m)/(1-m*(u-1)/u));if(f<=0)return;const g=(1-Math.pow(1-f,2))*((l.distance||200)*c)*(n?1:-1);h.wobblePhase+=h.wobbleSpeed*d*.1;const y=Math.sin(h.wobblePhase)*(l.wobble||1)*10;if(t?(e.y=h.originalY+g,e.x=h.originalX+y):(e.x=h.originalX+g,e.y=h.originalY+y),f>.6){const t=(f-.6)/.4;e.opacity=h.originalOpacity*(1-t)}},cleanup(e){if(e.gestureData?.cascade){const t=e.gestureData.cascade;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.cascade}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.direction||"down",r=1-Math.pow(1-e,2);let s=0,o=0;const l=.3*r*a;switch(i){case"down":o=-l;break;case"up":o=l;break;case"left":s=-l;break;case"right":s=l}const c=.03*Math.sin(e*Math.PI*4)*a;"down"===i||"up"===i?s+=c:o+=c;const h=e>.85?(1-e)/.15:1;return{cameraRelativePosition:[s*h,o*h,0],rotation:[("down"===i?.05:"up"===i?-.05:0)*a*h,0,("left"===i?.1:"right"===i?-.1:0)*a*h],scale:1-.1*r,glowIntensity:1+.2*(1-r)}}}}}var Sg=xg("up"),Mg=xg("down"),_g=xg("left"),Ag=xg("right"),Cg={name:"confetti",emoji:"",type:"effect",description:"Celebratory confetti flutter with chaotic rotation",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},burstHeight:.3,fallSpeed:1,tumbleSpeed:2,spread:1,strength:1,particleMotion:{type:"confetti",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1.5},timingSync:"onBeat"},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.confetti={originalX:e.x,originalY:e.y,driftX:2*(Math.random()-.5),tumblePhase:Math.random()*Math.PI*2,tumbleSpeed:.5+1.5*Math.random(),flutterAmp:.3+.7*Math.random(),initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.confetti?.initialized||this.initialize(e,n);const s={...this.config,...n},o=s.strength||1,l=e.gestureData.confetti,c=Math.min(t/.2,1),h=Math.max(0,(t-.2)/.8),d=-50*Math.sin(c*Math.PI)*(s.burstHeight||.3),u=h*h*200*(s.fallSpeed||1),p=20*Math.sin(t*Math.PI*8*l.tumbleSpeed)*l.flutterAmp,m=l.driftX*t*100*(s.spread||1);e.x=l.originalX+m+p*o,e.y=l.originalY+d+u*o,t>.7&&(e.opacity=1-(t-.7)/.3)},cleanup(e){e.gestureData?.confetti&&delete e.gestureData.confetti},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1,a=Math.min(e/.2,1),i=Math.max(0,(e-.2)/.8),r=.15*Math.sin(a*Math.PI)-i*i*.3,s=e*Math.PI*4,o=.3*Math.sin(1.3*s)*n,l=.4*Math.sin(.7*s)*n,c=.5*Math.sin(1.1*s)*n,h=e>.85?(1-e)/.15:1;return{position:[.08*Math.sin(e*Math.PI*6)*n*h,r*n*h,0],rotation:[o*h,l*h,c*h],scale:1+.1*Math.sin(2*s)*n,glowIntensity:1+.3*(1-i)}}}},Tg={name:"fizz",emoji:"",type:"override",description:"Bubbles rising upward with wobble",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},riseSpeed:6,riseDistance:300,wobbleAmount:2,strength:1,particleMotion:{type:"fizz",strength:1}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:1.5},intensitySync:{quiet:.5,loud:1.5}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.fizz={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??e.life??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.4+.6*Math.random(),riseMultiplier:.7+.6*Math.random(),initialized:!0}},apply(e,t,n,a){e.gestureData?.fizz?.initialized||this.initialize(e,n);const i={...this.config,...n},r=i.strength||1,s=e.gestureData.fizz,o="number"==typeof a?a:1,l=(i.riseDistance||300)*t*r*s.riseMultiplier;s.wobblePhase+=s.wobbleSpeed*o*.1;const c=Math.sin(s.wobblePhase)*(i.wobbleAmount||2)*(1+t);if(e.x=s.originalX+c,e.y=s.originalY-l,e.vx=.3*c,e.vy=10*-(i.riseSpeed||6),t>.6){const n=(t-.6)/.4;e.opacity=s.originalOpacity*(1-n),void 0!==e.life&&(e.life=s.originalOpacity*(1-n))}},cleanup(e){if(e.gestureData?.fizz){const t=e.gestureData.fizz;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,void 0!==e.life&&(e.life=t.originalOpacity),delete e.gestureData.fizz}},"3d":{evaluate(e,t){const n=(t.config||this.config||{}).strength||1;let a=0,i=1,r=1;if(e<.15){const t=e/.15;a=.15*t,i=1+.02*t,r=1+.15*t}else if(e<.7){const t=(e-.15)/.55;a=.5-.15*t,i=1.02+.03*Math.sin(t*Math.PI*6),r=1.2+.15*Math.sin(t*Math.PI*8)}else{const t=(e-.7)/.3;a=.35*(1-t),i=1.02-.02*t,r=1.2-.2*t}const s=35*e;return{position:[.008*Math.sin(1.7*s)*a*n,.006*Math.sin(2.3*s)*a*n,.004*Math.sin(1.9*s)*a*n],rotation:[.03*Math.sin(1.3*s)*a*n,.02*Math.sin(1.1*s)*a*n,.04*Math.sin(1.5*s)*a*n],scale:[i+.015*Math.sin(2.1*s)*a,i+.02*Math.sin(1.8*s)*a,i+.015*Math.sin(2.4*s)*a],glowIntensity:r,glowBoost:.2*a}}}};function Pg(e){const t=pm[e];if(!t)throw new Error(`Invalid swarm direction: ${e}`);return{name:`swarm${mm(e)}`,emoji:"up"===e?"":"down"===e?"":"",type:"override",description:`Flock movement ${e}`,config:{duration:1800,musicalDuration:{musical:!0,bars:1},clusterPhase:.3,moveDistance:120,clusterTightness:.5,wobble:1,strength:1,direction:e,particleMotion:{type:"swarm",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat"},initialize(e,t,n,a){e.gestureData||(e.gestureData={}),e.gestureData.swarm={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),timeOffset:.1*Math.random(),initialized:!0}},apply(e,n,a,i,r,s){e.gestureData?.swarm?.initialized||this.initialize(e,a,r,s);const o={...this.config,...a},l=o.strength||1,c=e.gestureData.swarm,h=o.clusterPhase||.3,d=o.moveDistance||120,u=o.clusterTightness||.5,p=Math.max(0,Math.min(1,n-c.timeOffset));let m,f;if(p<h){const e=p/h,t=1-Math.pow(1-e,2);m=c.originalX+(r-c.originalX)*u*t,f=c.originalY+(s-c.originalY)*u*t}else{const e=(p-h)/(1-h),n=1-Math.pow(1-e,2),a=c.originalX+(r-c.originalX)*u,i=c.originalY+(s-c.originalY)*u;m=a+t.x*d*n*l,f=i+t.y*d*n*l}const g="number"==typeof i?i:1;c.wobblePhase+=c.wobbleSpeed*g*.1;const y=Math.sin(3*c.wobblePhase)*o.wobble*5,v=Math.cos(2.5*c.wobblePhase)*o.wobble*5;e.x=m+y,e.y=f+v,p>.8&&(e.opacity=c.originalOpacity*(1-5*(p-.8)))},cleanup(e){if(e.gestureData?.swarm){const t=e.gestureData.swarm;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.swarm}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.direction||"up",r=n.clusterPhase||.3,[s,o]={up:[0,1],down:[0,-1],left:[-1,0],right:[1,0]}[i]||[0,1];let l=0,c=0,h=1;if(e<r)h=1-e/r*.1*a;else{const t=(e-r)/(1-r),n=1-Math.pow(1-t,2);l=s*n*.25*a,c=o*n*.25*a,h=.9+.1*t}const d=e>r?.1:0,u=e>.85?(1-e)/.15:1;return{cameraRelativePosition:[(l+.02*Math.sin(e*Math.PI*6)*a)*u,c*u,0],rotation:[o*d*a,0,-s*d*a],scale:h,glowIntensity:1+(e>r?.2:0)}}}}}var Dg=Pg("up"),Og=Pg("down"),Eg=Pg("left"),Ig=Pg("right"),kg={name:"burst",emoji:"",type:"blending",description:"Explosive outward burst from center",config:{decay:.5,strength:2},rhythm:{enabled:!0,syncMode:"beat",strengthSync:{onBeat:3.5,offBeat:1,curve:"explosion"},decaySync:{mode:"tempo",fast:.8,slow:.3,curve:"exponential"},durationSync:{mode:"beats",beats:.5,sustain:!1},accentResponse:{enabled:!0,multiplier:2.5,type:"strength"},patternOverrides:{rock:{strengthSync:{onBeat:4,offBeat:1.5},decaySync:{fast:.6,slow:.4}},electronic:{strengthSync:{onBeat:3.8,offBeat:.8,curve:"sharp"},decaySync:{fast:.9,slow:.7}},jazz:{strengthSync:{onBeat:2.8,offBeat:1.8,swing:!0},decaySync:{fast:.5,slow:.2}},orchestral:{strengthSync:{onBeat:3.2,offBeat:.5},accentResponse:{multiplier:3}}},dynamics:{forte:{strengthSync:{onBeat:{multiplier:2},offBeat:{multiplier:1.5}},decaySync:{multiplier:.7},accentResponse:{multiplier:3.5}},piano:{strengthSync:{onBeat:{multiplier:.6},offBeat:{multiplier:.3}},decaySync:{multiplier:1.3},accentResponse:{multiplier:1.8}}}},apply(e,t,n,a,i,r){const s=n.decay||this.config.decay,o=(n.strength||this.config.strength)*(1-t*s),l=e.x-i,c=e.y-r,h=Math.sqrt(l*l+c*c);h>1&&(e.vx+=l/h*o*2*a,e.vy+=c/h*o*2*a)},"3d":{evaluate(e,t){const n=t.strength||2;let a=0,i=1,r=1,s=0;if(e<.15){const t=e/.15,o=1-Math.pow(1-t,3);a=.15*o*n,i=1+.2*o*n,r=1+.5*o,s=.4*o}else if(e<.35){const t=(e-.15)/.2;a=.15*(1-1.5*t)*n,i=1+.2*(1-t)*n-.1*Math.sin(t*Math.PI),r=1+.4*(1-t),s=.2*(1-t)}else{const t=(e-.35)/.65,s=Math.pow(1-t,2),o=Math.sin(t*Math.PI*2)*s;a=.03*o*n,i=1+.05*o,r=1+.15*Math.abs(o)}return{cameraRelativePosition:[0,0,a],position:[0,0,0],rotation:[0,0,0],scale:i,glowIntensity:r,glowBoost:s}}}};function Rg(e){const t=pm[e];if(!t)throw new Error(`Invalid burst direction: ${e}`);const n="up"===e||"down"===e;return{name:`burst${mm(e)}`,emoji:"up"===e?"":"down"===e?"":"",type:"blending",description:`Explosive burst ${e}`,config:{duration:600,musicalDuration:{musical:!0,beats:1},decay:.5,strength:2,spread:.3,direction:e,particleMotion:{type:"burst",strength:2,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",strengthSync:{onBeat:3.5,offBeat:1,curve:"explosion"},accentResponse:{enabled:!0,multiplier:2.5,type:"strength"}},apply(e,a,i,r,s,o){const l={...this.config,...i},c=l.decay||.5,h=(l.strength||2)*(1-a*c),d=l.spread||.3;let u=t.x*h*2,p=t.y*h*2;const m=(Math.random()-.5)*d*h;n?u+=m:p+=m,e.vx+=u*r,e.vy+=p*r},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||2,i=n.direction||"up";let r=0,s=0,o=0,l=1,c=1,h=0;const[d,u]={up:[0,1],down:[0,-1],left:[-1,0],right:[1,0]}[i]||[0,1];if(e<.15){const t=e/.15,n=1-Math.pow(1-t,3);r=d*n*.2*a,s=u*n*.2*a,o=.1*n*a,l=1+.15*n*a,c=1+.5*n,h=.4*n}else if(e<.35){const t=(e-.15)/.2,n=1-1.5*t;r=.2*d*n*a,s=.2*u*n*a,o=.1*n*a,l=1+.15*(1-t)*a,c=1+.4*(1-t),h=.2*(1-t)}else{const t=(e-.35)/.65,n=Math.pow(1-t,2),i=Math.sin(t*Math.PI*2)*n;r=d*i*.05*a,s=u*i*.05*a,l=1+.05*i,c=1+.15*Math.abs(i)}return{cameraRelativePosition:[r,s,o],position:[0,0,0],rotation:[0,0,0],scale:l,glowIntensity:c,glowBoost:h}}}}}var zg=Rg("up"),Fg=Rg("down"),Bg=Rg("left"),Lg=Rg("right"),Ng={name:"ripple",emoji:"",type:"effect",description:"Concentric waves emanating from center",config:{duration:1500,musicalDuration:{musical:!0,bars:1},waveCount:3,waveSpeed:1,amplitude:15,damping:.7,strength:1,particleMotion:{type:"ripple",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",amplitudeSync:{onBeat:1.5,offBeat:.8}},apply(e,t,n,a,i,r){const s={...this.config,...n},o=s.strength||1,l=s.waveCount||3,c=s.amplitude||15,h=s.damping||.7,d=e.x-i,u=e.y-r,p=Math.sqrt(d*d+u*u),m=(p/50-t*l*2)*Math.PI,f=Math.pow(1-t,h),g=Math.sin(m)*c*o*f;if(p>1){const t=.5*Math.cos(m)*o*f;e.x+=d/p*t,e.y+=u/p*t}e.opacity=Math.max(.3,1-.3*Math.abs(g/c))},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.waveCount||3,r=n.damping||.7,s=Math.pow(1-e,r),o=e*Math.PI*i*2,l=Math.sin(o),c=e*Math.PI*4,h=Math.sin(c)*a*s,d=.5*Math.sin(c+Math.PI/2)*a*s,u=.12,p=1-h*u+d*u*.3,m=1+h*u,f=1-h*u-d*u*.3,g=.08*(m-1);return{position:[.01*Math.sin(1.5*c)*s,g,0],rotation:[.04*l*a*s,0,.03*d*a*s],scale:[p,m,f],glowIntensity:1+.3*Math.abs(h),glowBoost:.25*Math.max(0,h)*s}}}},Vg={name:"wave",emoji:"",type:"override",description:"Infinity pattern flow with phasing",config:{musicalDuration:{musical:!0,bars:1,minBeats:4,maxBeats:16},phases:[{name:"gather",beats:.5},{name:"rise",beats:.5},{name:"waveLeft",beats:1},{name:"waveRight",beats:1},{name:"settle",beats:1}],amplitude:40,frequency:1,phaseShift:.3,liftHeight:20,fadeInOut:!0,smoothness:.1,easing:"sine",strength:1,particleMotion:{type:"wave",strength:1,amplitude:50}},rhythm:{enabled:!0,syncMode:"wave",amplitudeSync:{onWave:65,onStatic:25,curve:"flowing"},frequencySync:{mode:"phrase",slow:.7,fast:1.8,curve:"melodic"},durationSync:{mode:"bars",adaptToPhrase:!0,sustain:!0},phaseSync:{enabled:!0,multiplier:.5,type:"ensemble"},melodicResponse:{enabled:!0,multiplier:1.4,type:"amplitude"},patternOverrides:{ambient:{amplitudeSync:{onWave:80,onStatic:40,curve:"hypnotic"},frequencySync:{slow:.5,fast:1.2},durationSync:{minBeats:16,maxBeats:64}},ocean:{amplitudeSync:{onWave:90,onStatic:20,curve:"natural"},phaseSync:{multiplier:.8},melodicResponse:{multiplier:1.8}},electronic:{amplitudeSync:{onWave:70,onStatic:30,curve:"digital"},frequencySync:{slow:.8,fast:2.5,curve:"precise"}},orchestral:{amplitudeSync:{onWave:75,onStatic:35},phaseSync:{multiplier:.7},melodicResponse:{multiplier:2}}},dynamics:{forte:{amplitudeSync:{onWave:{multiplier:1.8},onStatic:{multiplier:1.4}},frequencySync:{multiplier:1.3},melodicResponse:{multiplier:2.2}},piano:{amplitudeSync:{onWave:{multiplier:.6},onStatic:{multiplier:.4}},frequencySync:{multiplier:.7},melodicResponse:{multiplier:1.1}}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-n,r=e.y-a,s=Math.atan2(r,i),o=Math.sqrt(i*i+r*r),l=Math.random()<.5?1:-1;e.gestureData.wave={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,baseOpacity:e.opacity||e.life||1,angle:s,radius:o,offset:Math.random()*Math.PI*2,role:Math.random(),direction:l,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.wave?.initialized||this.initialize(e,n,i,r);const s=e.gestureData.wave,o={...this.config,...n},l=n.strength||1,c=this.easeInOutSine(t),h=s.role*o.phaseShift,d=Math.max(0,c-h),u=d*Math.PI*2*o.frequency*s.direction+s.offset,p=.5+s.radius/100*.5,m=o.amplitude*p*l*e.scaleFactor,f=i+Math.sin(u)*m,g=r+Math.sin(2*u)*m*.3+-Math.abs(Math.sin(c*Math.PI))*o.liftHeight*e.scaleFactor,y=o.smoothness+.12*s.role;if(e.x+=(f-e.x)*y,e.y+=(g-e.y)*y,e.vx=.3*(f-e.x),e.vy=.3*(g-e.y),o.fadeInOut){let t;t=d<.1?d/.1:d>.9?(1-d)/.1:.5+.5*Math.sin(d*Math.PI),e.opacity=s.baseOpacity*(.3+.7*t),void 0!==e.life&&(e.life=e.opacity)}if(t>=.95){const n=20*(1-t);e.vx=e.vx*n+s.originalVx*(1-n),e.vy=e.vy*n+s.originalVy*(1-n),o.fadeInOut&&(e.opacity=s.baseOpacity*n,void 0!==e.life&&(e.life=e.opacity))}},cleanup(e){if(e.gestureData?.wave){const t=e.gestureData.wave;e.vx=t.originalVx,e.vy=t.originalVy,e.opacity=t.baseOpacity,void 0!==e.life&&(e.life=t.baseOpacity),delete e.gestureData.wave}},easeInOutSine:e=>-(Math.cos(Math.PI*e)-1)/2,"3d":{evaluate(e,t){const n=t?.strength||1,a=t?.frequency||1,i=-(Math.cos(Math.PI*e)-1)/2,r=i*Math.PI*2*a,s=.12*Math.sin(r)*n,o=.06*Math.sin(2*r)*n,l=.03*Math.sin(r)*n,c=.08*Math.sin(2*r)*n,h=.05*Math.sin(r)*n,d=1+.08*Math.abs(Math.sin(i*Math.PI))*n,u=Math.abs(Math.sin(r));return{position:[s,o,l],rotation:[c,0,h],scale:d,glowIntensity:1+.3*u*n,glowBoost:.6*u*n}}}},Ug={name:"flash",emoji:"",type:"blending",description:"Bright flash burst effect",config:{duration:400,glowAmount:2.5,glowPeak:3,scalePeak:1.1,easing:"cubic",strength:1,particleMotion:{type:"burst",strength:1,decay:.3}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"immediate",interruptible:!0,priority:8,blendable:!0,intensitySync:{onBeat:3.5,offBeat:1,accent:5,subdivision:"quarter",curve:"exponential"},durationSync:{mode:"tempo",baseDuration:400,scaling:"inverse"},scaleSync:{onBeat:1.2,offBeat:1,accent:1.4,curve:"elastic"},strobeSync:{enabled:!1,pattern:"XXOX",subdivision:"sixteenth"},dynamics:{forte:{glowPeak:4,scalePeak:1.3,duration:300},piano:{glowPeak:2,scalePeak:1.05,duration:500}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.flash={originalOpacity:e.opacity,originalSize:e.size,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.flash?.initialized||this.initialize(e,n);const s=e.gestureData.flash,o={...this.config,...n},l=o.strength||1;let c;if(c=t<.3?t/.3*o.glowPeak:o.glowPeak*(1-(t-.3)/.7),e.opacity=Math.min(1,s.originalOpacity*(1+c*l)),e.size=s.originalSize*(1+(o.scalePeak-1)*c*l*.1),t<.2){const n=(1-t/.2)*l,s=Math.atan2(e.y-r,e.x-i);e.vx+=Math.cos(s)*n*2*a,e.vy+=Math.sin(s)*n*2*a}e.vx*=1-.1*o.particleMotion.decay,e.vy*=1-.1*o.particleMotion.decay},cleanup(e){e.gestureData?.flash&&(e.opacity=e.gestureData.flash.originalOpacity,e.size=e.gestureData.flash.originalSize,delete e.gestureData.flash)},"3d":{evaluate(e,t){const n={...this.config,...t};let a;t.strength,a=e<.3?e/.3:1-(e-.3)/.7;const i=1+.4*a;return{position:[0,0,0],rotation:[0,0,0],scale:1+a*((n.scalePeak||1.1)-1),glowIntensity:i,glowBoost:2*a}}}},Gg={name:"glow",emoji:"",type:"blending",description:"Pure luminous glow without movement",config:{duration:1500,amplitude:0,frequency:1,holdPeak:.3,easing:"sine",scaleAmount:.1,glowAmount:.8,strength:0,direction:"none",particleMotion:{type:"glow",strength:0,direction:"none",frequency:1}},rhythm:{enabled:!0,syncMode:"phrase",amplitudeSync:{onBeat:2,offBeat:1.2,curve:"smooth"},frequencySync:{mode:"phrase",subdivision:"bar"},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:2.5},patternOverrides:{ambient:{amplitudeSync:{onBeat:2.5,offBeat:1.8},durationSync:{bars:4}},electronic:{amplitudeSync:{onBeat:3,offBeat:.5,curve:"sharp"},frequencySync:{subdivision:"quarter"}}}},initialize(e,t,n,a){e.gestureData||(e.gestureData={}),e.gestureData.glow={startOpacity:e.opacity,startGlow:e.glowSizeMultiplier||0,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.glow?.initialized||this.initialize(e,n,i,r);const s={...this.config,...n},o=this.easeInOutSine(t);let l,{frequency:c}=s,{glowAmount:h}=s;n.rhythmModulation&&(h*=n.rhythmModulation.amplitudeMultiplier||1,h*=n.rhythmModulation.accentMultiplier||1,n.rhythmModulation.frequencyMultiplier&&(c*=n.rhythmModulation.frequencyMultiplier));const d=o*c*2%2;l=s.holdPeak>0&&d>1-s.holdPeak&&d<1+s.holdPeak?1:Math.sin(o*Math.PI*2*c);let u=1;t>.9&&(u=.5+.5*(1-10*(t-.9))),e.glowIntensity=1+l*h*u},cleanup(e){e.gestureData?.glow&&(e.glowIntensity=1,delete e.gestureData.glow)},easeInOutSine:e=>-(Math.cos(Math.PI*e)-1)/2,"3d":{evaluate(e,t){const n={...this.config,...t},a=-(Math.cos(Math.PI*e)-1)/2,i=Math.sin(a*Math.PI);let r=n.glowAmount||.8;t.rhythmModulation&&(r*=t.rhythmModulation.amplitudeMultiplier||1,r*=t.rhythmModulation.accentMultiplier||1);const s=1+i*r;return{position:[0,0,0],rotation:[0,0,0],scale:1+i*(n.scaleAmount||.1)*.5,glowIntensity:s,glowBoost:1.5*i}}}},Wg={name:"bloom",emoji:"",type:"effect",description:"Particles unfold outward like flower petals opening",config:{duration:1500,musicalDuration:{musical:!0,bars:1},petalCount:6,openingSpeed:1,rotationAmount:.3,strength:1,particleMotion:{type:"bloom",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",amplitudeSync:{onBeat:1.3,offBeat:.8}},initialize(e,t,n,a){e.gestureData||(e.gestureData={});const i=e.x-(n||0),r=e.y-(a||0);e.gestureData.bloom={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??1,startAngle:Math.atan2(r,i),startDistance:Math.sqrt(i*i+r*r),initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.bloom?.initialized||this.initialize(e,n,i,r);const s={...this.config,...n},o=s.strength||1,l=e.gestureData.bloom,c=Math.pow(t,.7),h=(s.rotationAmount||.3)*Math.PI,d=Math.sin(c*Math.PI)*h,u=1+.5*c*o,p=l.startDistance*u,m=l.startAngle+d;e.x=i+Math.cos(m)*p,e.y=r+Math.sin(m)*p,e.opacity=Math.min(1,l.originalOpacity*(.7+.3*c))},cleanup(e){if(e.gestureData?.bloom){const t=e.gestureData.bloom;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.bloom}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.rotationAmount||.3,r=Math.pow(e,.7),s=1+.2*r*a,o=Math.sin(r*Math.PI)*i*a,l=.1*Math.sin(r*Math.PI*.5)*a,c=e>.85?1-(e-.85)/.15*.3:1;return{position:[0,.05*Math.sin(r*Math.PI)*a*c,0],rotation:[0,o*c,l*c],scale:s*(.7+.3*c),glowIntensity:1+.4*r,glowBoost:.3*r}}}},qg={name:"flicker",emoji:"",type:"blending",description:"Rapid opacity changes with motion jitter",config:{duration:800,musicalDuration:{musical:!0,beats:2},flickerRate:15,frequency:6,minOpacity:.3,maxOpacity:1,jitterAmount:2,colorShift:!1,strobe:!1,pulseMode:!1,groupFlicker:.3,easing:"linear",strength:.7,particleMotion:{type:"flicker",strength:.7,frequency:6}},rhythm:{enabled:!0,syncMode:"subdivision",durationSync:{mode:"beats",beats:2},rateSync:{subdivision:"sixteenth",onBeat:30,offBeat:10,triplet:20,curve:"step"},opacitySync:{pattern:"HLMH",subdivision:"eighth",onAccent:.1,regular:.5},jitterSync:{onBeat:5,offBeat:1,accent:10,curve:"random"},strobeSync:{verse:!1,chorus:!0,drop:"intense",pattern:"XOXO"},dynamics:{forte:{flickerRate:25,jitterAmount:5,minOpacity:.1},piano:{flickerRate:8,jitterAmount:1,minOpacity:.5}}},initialize(e,t){e.gestureData||(e.gestureData={});const n={...this.config,...t},a=Math.random()<n.groupFlicker;e.gestureData.flicker={baseOpacity:e.opacity||e.life||1,baseColor:e.color,baseX:e.x,baseY:e.y,flickerTimer:0,lastFlicker:0,flickerState:!0,isGrouped:a,groupId:a?Math.floor(3*Math.random()):-1,phase:Math.random()*Math.PI*2,colorHue:0,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.flicker?.initialized||this.initialize(e,n);const s=e.gestureData.flicker,o={...this.config,...n},l=n.strength||1;let c;if(s.flickerTimer+=a*o.flickerRate,o.strobe)c=(s.flickerTimer+s.phase)%1<.5?1:o.minOpacity;else if(o.pulseMode){const e=s.flickerTimer+s.phase;c=o.minOpacity+(o.maxOpacity-o.minOpacity)*(.5*Math.sin(e)+.5)}else{if(s.flickerTimer-s.lastFlicker>1)if(s.lastFlicker=s.flickerTimer,s.isGrouped){const e=Math.floor(s.flickerTimer)%3;s.flickerState=e===s.groupId}else s.flickerState=Math.random()>.3;const t=s.flickerState?o.maxOpacity:o.minOpacity+.3*Math.random(),n=e.opacity/s.baseOpacity;c=n+.3*(t-n)}const h=s.baseOpacity*(1+(c-1)*l);if(e.opacity=Math.max(0,Math.min(1,h)),void 0!==e.life&&(e.life=e.opacity),o.jitterAmount>0&&c>o.minOpacity){const t=o.jitterAmount*l*e.scaleFactor,n=(Math.random()-.5)*t*c,i=(Math.random()-.5)*t*c;e.vx+=.1*n*a,e.vy+=.1*i*a}if(o.colorShift&&e.color){s.colorHue+=.01*a;const t=30*Math.sin(s.colorHue);e.color=this.shiftHue(s.baseColor,t*l)}let d=1;t<.1?d=t/.1:t>.9&&(d=(1-t)/.1),e.opacity*=d,void 0!==e.life&&(e.life=e.opacity),t>.8&&(e.vx*=.95,e.vy*=.95)},shiftHue(e,t){if(!e||!e.startsWith("#"))return e;const n=e.slice(1),a=parseInt(n.substr(0,2),16)/255,i=parseInt(n.substr(2,2),16)/255,r=parseInt(n.substr(4,2),16)/255,s=t*Math.PI/180,o=Math.cos(s),l=Math.sin(s),c=a*l+i*o,h=r,d=e=>Math.max(0,Math.min(255,Math.round(255*e))).toString(16).padStart(2,"0");return`#${d(a*o-i*l)}${d(c)}${d(h)}`},cleanup(e){if(e.gestureData?.flicker){const t=e.gestureData.flicker;e.opacity=t.baseOpacity,e.color=t.baseColor,void 0!==e.life&&(e.life=t.baseOpacity),delete e.gestureData.flicker}},"3d":{evaluate(e,t){const n=t.config||{},a=t.strength||.7,i=n.flickerRate||15;n.minOpacity;const r=e*i,s=Math.sin(r*Math.PI*2),o=Math.floor(10*r),l=.3*s+.5*(Math.sin(123.456*o)+1)*.7,c=.6+.8*l,h=n.jitterAmount||2,d=.003*a*c,u=(Math.random()-.5)*h*d,p=(Math.random()-.5)*h*d,m=.03*(Math.random()-.5)*a*c;return{position:[u,p,0],rotation:[.5*m,0,m],scale:1+.08*(c-1),glowIntensity:c,glowBoost:1.2*l}}}},Hg={name:"shiver",emoji:"",type:"effect",description:"High-frequency micro-vibrations for nervousness or cold",config:{duration:1500,musicalDuration:{musical:!0,bars:1},frequency:30,amplitude:.02,decay:.3,strength:1,particleMotion:{type:"shiver",strength:.8}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:1},intensitySync:{quiet:.5,loud:1.5,crescendo:"increase",diminuendo:"decrease"}},apply(e,t,n,a,i,r){const s={...this.config,...n},o=s.strength||1,l=s.frequency||30,c=100*(s.amplitude||.02),h=t*l*Math.PI*2,d=(.6*Math.sin(h)+.3*Math.sin(1.7*h+1.3)+.1*Math.sin(2.3*h+2.7))*c*o,u=Math.sin(t*Math.PI);e.x+=d*u*(Math.random()-.5)*2,e.y+=d*u*(Math.random()-.5)*2},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.frequency||30,r=n.amplitude||.02,s=Math.sin(e*Math.PI),o=e*i*Math.PI*2,l=.6*Math.sin(o)+.3*Math.sin(1.7*o)+.1*Math.sin(2.3*o),c=.5*Math.cos(1.1*o)+.3*Math.cos(1.9*o)+.2*Math.cos(2.7*o);return{position:[l*r*a*s,c*r*a*s,(.4*Math.sin(.9*o+1)+.4*Math.sin(1.5*o+2))*r*.5*a*s],rotation:[.02*c*a*s,0,.02*l*a*s],scale:1+.01*Math.abs(l)*a*s,glowIntensity:1+.1*Math.abs(l)*s}}}},jg={name:"heartbeat",emoji:"",type:"effect",description:"Rhythmic double-pump heartbeat (lub-dub)",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},lubStrength:.8,dubStrength:1,lubDubGap:.15,strength:1,particleMotion:{type:"heartbeat",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",amplitudeSync:{onBeat:1.2,offBeat:.8}},apply(e,t,n,a,i,r){const s={...this.config,...n},o=s.strength||1,l=this._calculatePulse(t,s),c=e.x-i,h=e.y-r,d=Math.sqrt(c*c+h*h)||1,u=10*l*o;e.x+=c/d*u,e.y+=h/d*u},_calculatePulse(e,t){const n=t.lubDubGap||.15,a=t.lubStrength||.8,i=t.dubStrength||1;let r=0;const s=Math.abs(e-.1);s<.08&&(r=Math.cos(s/.08*Math.PI*.5)*a);const o=.1+n+.05,l=Math.abs(e-o);if(l<.1){const e=Math.cos(l/.1*Math.PI*.5)*i;r=Math.max(r,e)}return r},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.lubDubGap||.15,r=n.lubStrength||.8,s=n.dubStrength||1;let o=0;const l=Math.abs(e-.1);l<.08&&(o=Math.cos(l/.08*Math.PI*.5)*r);const c=.1+i+.05,h=Math.abs(e-c);if(h<.1){const e=Math.cos(h/.1*Math.PI*.5)*s;o=Math.max(o,e)}return{position:[0,0,.03*o*a],rotation:[0,0,0],scale:1+.15*o*a,glowIntensity:1+.5*o*a,glowBoost:.8*o*a}}}},Xg={name:"snap",emoji:"",type:"effect",description:"Quick elastic snap with overshoot and settle",config:{duration:500,musicalDuration:{musical:!0,beats:1},snapDistance:.1,overshoot:1.3,bounces:2,strength:1,particleMotion:{type:"snap",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},apply(e,t,n,a,i,r){const s={...this.config,...n},o=s.strength||1,l=100*(s.snapDistance||.1),c=s.overshoot||1.3,h=this._calculateSnap(t,c,s.bounces||2),d=i-e.x,u=r-e.y,p=Math.sqrt(d*d+u*u)||1;e.x+=d/p*h*l*o*.1,e.y+=u/p*h*l*o*.1},_calculateSnap(e,t,n){if(e<.2){const n=e/.2;return(1-Math.pow(1-n,3))*t}{const a=(e-.2)/.8,i=Math.exp(4*-a);return 1+(t-1)*Math.cos(a*Math.PI*n*2)*i}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.snapDistance||.1,r=n.overshoot||1.3,s=n.bounces||2;let o;if(e<.2){const t=e/.2;o=(1-Math.pow(1-t,3))*r}else{const t=(e-.2)/.8,n=Math.exp(4*-t);o=1+(r-1)*Math.cos(t*Math.PI*s*2)*n}return{position:[0,0,(o-1)*i*a],rotation:[0,0,.1*(o-1)*a],scale:1+.15*(o-1),glowIntensity:1+.5*Math.abs(o-1),glowBoost:e<.3?(.3-e)/.3*.4:0}}}},Yg={name:"elasticBounce",emoji:"",type:"effect",description:"Drop and bounce with elastic oscillation",config:{duration:1200,musicalDuration:{musical:!0,beats:3},dropHeight:.15,bounceCount:3,elasticity:.6,strength:1,particleMotion:{type:"elasticBounce",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",amplitudeSync:{onBeat:1.3,offBeat:.8}},apply(e,t,n,a,i,r){const s={...this.config,...n},o=s.strength||1,l=200*(s.dropHeight||.15),c=s.bounceCount||3,h=s.elasticity||.6,d=this._calculateBounce(t,l,c,h);e.y+=d*o;const u=.3*Math.max(0,-d/l);e.scaleY=1-u*o,e.scaleX=1+.5*u*o},_calculateBounce(e,t,n,a){let i=t,r=0,s=0,o=.3;for(;s<n&&r<1;){const t=o*Math.pow(a,.5*s);if(e<r+t){const n=(e-r)/t;return 4*n*(1-n)*-i}r+=t,i*=a,s++,o*=a}return 0},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.dropHeight||.15,r=n.bounceCount||3,s=n.elasticity||.6;let o=i,l=0,c=0,h=.3,d=0,u=!1;for(;c<r&&l<1;){const t=h*Math.pow(s,.5*c);if(e<l+t){const n=(e-l)/t;d=o*(4*n*(1-n))*a,u=n>.45&&n<.55;break}l+=t,o*=s,c++,h*=s}let p=1,m=1;if(u){const e=.15*a*Math.pow(s,c);p=1+e,m=1-e}return{position:[0,d,0],rotation:[0,0,0],scale:(p+m)/2,glowIntensity:1+(u?.3:0)}}}},$g={name:"hold",emoji:"",type:"override",description:"Hold particles in current position",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},holdStrength:.95,allowDrift:!1,strength:1},rhythm:{enabled:!0,syncMode:"rest",holdSync:{onRest:.98,onSound:.8,curve:"immediate"},durationSync:{mode:"rests",minBeats:.5,maxBeats:8,sustain:!0},pauseResponse:{enabled:!0,multiplier:1.5,type:"strength"},patternOverrides:{classical:{holdSync:{onRest:.99,onSound:.75,curve:"dramatic"},pauseResponse:{multiplier:2}},minimal:{holdSync:{onRest:.95,onSound:.85},durationSync:{minBeats:2,maxBeats:16}},jazz:{holdSync:{onRest:.9,onSound:.7},allowDrift:!0},electronic:{holdSync:{onRest:.99,onSound:.6,curve:"digital"},pauseResponse:{multiplier:1.2}}},dynamics:{forte:{holdSync:{onRest:{multiplier:1.02},onSound:{multiplier:.9}},pauseResponse:{multiplier:2.2}},piano:{holdSync:{onRest:{multiplier:.97},onSound:{multiplier:.85}},pauseResponse:{multiplier:1.3}}}},initialize(e){e.gestureData||(e.gestureData={}),e.gestureData.hold={holdX:e.x,holdY:e.y,originalVx:e.vx,originalVy:e.vy}},apply(e,t,n,a,i,r){e.gestureData?.hold||this.initialize(e);const s=e.gestureData.hold,o=n.holdStrength||this.config.holdStrength;if(n.allowDrift?(e.vx*=o,e.vy*=o):(e.x+=(s.holdX-e.x)*(1-o),e.y+=(s.holdY-e.y)*(1-o),e.vx=0,e.vy=0),t>.9){const n=10*(t-.9);e.vx=e.vx*(1-n)+s.originalVx*n,e.vy=e.vy*(1-n)+s.originalVy*n}},cleanup(e){if(e.gestureData?.hold){const t=e.gestureData.hold;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.hold}},"3d":{evaluate(e,t){let n=0,a=1;if(e<.15){const t=e/.15;n=t*t*(3-2*t),a=1-.2*n}else if(e<.85)n=1,a=.8;else{const t=(e-.85)/.15;n=1-t*t*(3-2*t),a=.8+.2*t}return n*=(t.config||this.config||{}).strength||1,{position:[0,0,0],rotation:[0,0,0],scale:1,glowIntensity:a,freezeRotation:n,freezeWobble:n,freezeGroove:n,freezeParticles:n}}}},Qg={name:"fade",emoji:"",type:"blending",description:"Fade particle opacity",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},fadeIn:!0,fadeOut:!0,minOpacity:0,maxOpacity:1},rhythm:{enabled:!0,syncMode:"dynamic",durationSync:{mode:"bars",bars:1},opacitySync:{onBeat:.9,offBeat:.3,subdivision:"eighth",curve:"exponential"},fadePhaseSync:{verse:{fadeIn:!0,fadeOut:!1},chorus:{fadeIn:!1,fadeOut:!1},bridge:{fadeIn:!0,fadeOut:!0},outro:{fadeIn:!1,fadeOut:!0}},pulseSync:{enabled:!0,frequency:"quarter",intensity:.2,onAccent:.4},dynamics:{forte:{minOpacity:.5,maxOpacity:1},piano:{minOpacity:0,maxOpacity:.4}}},initialize(e){e.gestureData||(e.gestureData={}),e.gestureData.fade={baseOpacity:e.opacity||e.life||1}},apply(e,t,n,a,i,r){e.gestureData?.fade||this.initialize(e);const s=e.gestureData.fade,o={...this.config,...n};let l;l=o.fadeIn&&!o.fadeOut?o.minOpacity+(o.maxOpacity-o.minOpacity)*t:o.fadeOut&&!o.fadeIn?o.maxOpacity-(o.maxOpacity-o.minOpacity)*t:t<.5?o.minOpacity+(o.maxOpacity-o.minOpacity)*(2*t):o.maxOpacity-(o.maxOpacity-o.minOpacity)*(2*(t-.5)),e.opacity=s.baseOpacity*l,void 0!==e.life&&(e.life=e.opacity)},cleanup(e){e.gestureData?.fade&&(e.opacity=e.gestureData.fade.baseOpacity,void 0!==e.life&&(e.life=e.opacity),delete e.gestureData.fade)},"3d":{evaluate(e,t){const n={...this?.config||{},...t},a=n.fadeIn??!0,i=n.fadeOut??!0;let r;r=a&&!i?e:i&&!a?1-e:e<.5?1-e/.5:(e-.5)/.5;const s=r*r*(3-2*r);return{position:[0,0,0],rotation:[0,0,0],scale:.01+.99*s,glowIntensity:s,glowBoost:0}}}},Kg={name:"settle",emoji:"",type:"blending",description:"Gradually settle particles to rest",config:{damping:.02,threshold:.01},rhythm:{enabled:!0,syncMode:"resolution",dampingSync:{onResolution:.035,onTension:.015,curve:"gradual"},thresholdSync:{mode:"dynamics",forte:.02,piano:.005,curve:"exponential"},durationSync:{mode:"phrase",minBeats:2,maxBeats:12,sustain:!0},cadenceResponse:{enabled:!0,multiplier:1.6,type:"damping"},patternOverrides:{ambient:{dampingSync:{onResolution:.025,onTension:.008,curve:"atmospheric"},durationSync:{minBeats:8,maxBeats:32}},jazz:{dampingSync:{onResolution:.04,onTension:.02},cadenceResponse:{multiplier:1.8}},classical:{dampingSync:{onResolution:.045,onTension:.012,curve:"expressive"},cadenceResponse:{multiplier:2}},minimalist:{dampingSync:{onResolution:.02,onTension:.005},durationSync:{minBeats:16,maxBeats:64}}},dynamics:{forte:{dampingSync:{onResolution:{multiplier:1.4},onTension:{multiplier:.8}},thresholdSync:{multiplier:2},cadenceResponse:{multiplier:2.2}},piano:{dampingSync:{onResolution:{multiplier:.7},onTension:{multiplier:1.2}},thresholdSync:{multiplier:.5},cadenceResponse:{multiplier:1.3}}}},apply(e,t,n,a,i,r){const s=n.damping||this.config.damping,o=n.threshold||this.config.threshold;e.vx*=Math.max(0,1-s*a*60),e.vy*=Math.max(0,1-s*a*60),Math.abs(e.vx)<o&&(e.vx=0),Math.abs(e.vy)<o&&(e.vy=0)},"3d":{evaluate(e,t){const n=1-Math.pow(1-e,2),a=.01*(1-n);return{position:[Math.sin(e*Math.PI*2)*a,Math.cos(e*Math.PI*3)*a*.5,0],rotation:[0,0,0],scale:1-.03*n,glowIntensity:1-.15*n}}}},Zg={name:"peek",emoji:"",type:"effect",description:"Quick peek and hide motion",config:{peekDistance:40,peekSpeed:.15,holdDuration:200,hideSpeed:.25,stagger:!0,duration:1500},rhythm:{enabled:!0,syncMode:"accent",distanceSync:{onAccent:60,offAccent:25,curve:"quick"},speedSync:{mode:"tempo",fast:.25,slow:.1,hideMultiplier:1.8},durationSync:{mode:"subdivision",beats:.25,staggerBeats:.125,sustain:!1},syncopationResponse:{enabled:!0,multiplier:1.8,type:"distance"},patternOverrides:{funk:{distanceSync:{onAccent:70,offAccent:35,curve:"funky"},syncopationResponse:{multiplier:2.2}},latin:{speedSync:{fast:.3,slow:.12},durationSync:{beats:.5,staggerBeats:.25}},breakbeat:{distanceSync:{onAccent:55,offAccent:40},syncopationResponse:{multiplier:2.5}},classical:{distanceSync:{onAccent:45,offAccent:20,curve:"elegant"},speedSync:{fast:.18,slow:.08}}},dynamics:{forte:{distanceSync:{onAccent:{multiplier:1.6},offAccent:{multiplier:1.3}},speedSync:{multiplier:1.4},syncopationResponse:{multiplier:2.8}},piano:{distanceSync:{onAccent:{multiplier:.6},offAccent:{multiplier:.4}},speedSync:{multiplier:.7},syncopationResponse:{multiplier:1.2}}}},apply(e,t,n,a,i,r){if(e.gestureData||(e.gestureData={}),!e.gestureData.peek){const t=e.x-i,n=e.y-r,a=Math.atan2(n,t),s=Math.sqrt(t*t+n*n);e.gestureData.peek={originalX:e.x,originalY:e.y,peekAngle:a,originalDistance:s,staggerDelay:this.config.stagger?.3*Math.random():0,phase:"waiting",phaseTimer:0,peekOffset:{x:0,y:0}}}const s=e.gestureData.peek,{config:o}=this,l=Math.max(0,Math.min(1,(t-s.staggerDelay)/(1-s.staggerDelay)));0===l?s.phase="waiting":l<.3?s.phase="peeking":l<.6?s.phase="holding":l<1&&(s.phase="hiding");let c=0;switch(s.phase){case"peeking":{const e=l/.3;c=this.easeOutCubic(e)*o.peekDistance;break}case"holding":c=o.peekDistance,Math.random()<.1&&(s.peekOffset.x+=2*(Math.random()-.5),s.peekOffset.y+=2*(Math.random()-.5));break;case"hiding":{const e=(l-.6)/.4;c=(1-this.easeInCubic(e))*o.peekDistance;break}}if("waiting"!==s.phase){const t=Math.cos(s.peekAngle)*c,n=Math.sin(s.peekAngle)*c;s.peekOffset.x+=(t-s.peekOffset.x)*o.peekSpeed,s.peekOffset.y+=(n-s.peekOffset.y)*o.peekSpeed,e.x=s.originalX+s.peekOffset.x,e.y=s.originalY+s.peekOffset.y}void 0!==e.alpha&&("peeking"===s.phase||"holding"===s.phase?e.alpha=.7+.3*Math.random():e.alpha=1)},easeOutCubic:e=>1-Math.pow(1-e,3),easeInCubic:e=>e*e*e,cleanup(e){e.gestureData?.peek&&(e.x=e.gestureData.peek.originalX,e.y=e.gestureData.peek.originalY,void 0!==e.alpha&&(e.alpha=1),delete e.gestureData.peek)},"3d":{evaluate(e,t){const n=.01*({...this.config,...t}.peekDistance||40);let a=0,i=1;if(e<.3){const t=e/.3;a=(1-Math.pow(1-t,3))*n}else if(e<.6)a=n,i=.7+.3*Math.random();else{const t=(e-.6)/.4;a=(1-Math.pow(t,3))*n}return{position:[a,0,0],rotation:[0,0,0],scale:1,glowIntensity:i}}}},Jg={name:"directional",emoji:"",type:"blending",description:"Move particles in a specific direction",config:{angle:0,returnToOrigin:!1,strength:1},rhythm:{enabled:!0,syncMode:"flow",angleSync:{verse:0,chorus:90,bridge:180,outro:270,transition:"smooth"},strengthSync:{onBeat:1.8,offBeat:.6,curve:"wave"},returnSync:{enabled:!0,onSectionChange:!0,duration:"transition",strength:1.2},accentResponse:{enabled:!0,multiplier:2,type:"strength"},patternOverrides:{march:{angleSync:{verse:0,chorus:0},strengthSync:{onBeat:2.5,offBeat:1}},waltz:{angleSync:{verse:45,chorus:135,bridge:225,outro:315,transition:"circular"}},swing:{strengthSync:{onBeat:1.6,offBeat:1.4,swing:!0}},electronic:{angleSync:{transition:"instant"},strengthSync:{onBeat:2.2,offBeat:.4,curve:"sharp"}}},dynamics:{forte:{strengthSync:{onBeat:{multiplier:1.6},offBeat:{multiplier:1.2}},angleSync:{transition:"sharp"},accentResponse:{multiplier:2.5}},piano:{strengthSync:{onBeat:{multiplier:.7},offBeat:{multiplier:.8}},angleSync:{transition:"gradual"},accentResponse:{multiplier:1.4}}}},initialize(e){e.gestureData||(e.gestureData={}),e.gestureData.directional={initialX:e.x,initialY:e.y}},apply(e,t,n,a,i,r){e.gestureData?.directional||this.initialize(e);const s=(n.angle||this.config.angle)*Math.PI/180,o=n.strength||this.config.strength;if(e.vx+=Math.cos(s)*o*.3*a,e.vy+=Math.sin(s)*o*.3*a,n.returnToOrigin&&t>.5){const n=2*(t-.5),i=e.gestureData.directional,r=i.initialX-e.x,s=i.initialY-e.y;e.vx+=r*n*.02*a,e.vy+=s*n*.02*a}},"3d":{evaluate(e,t){const n={...this.config,...t},a=(n.angle||0)*Math.PI/180,i=t.strength||1,r=n.returnToOrigin?e<.5?2*e:2*(1-e):e;return{position:[Math.cos(a)*r*.4*i,Math.sin(a)*r*.4*i,0],rotation:[0,0,0],scale:1,glowIntensity:1}}}};function ey(e){if(!["forward","back","left","right","up","down","attract","repel"].includes(e))throw new Error(`Invalid magnetic direction: ${e}`);return{name:`magnetic${mm(e)}`,emoji:{forward:"",back:"",left:"",right:"",up:"",down:"",attract:"",repel:""}[e],type:"effect",description:{forward:"Magnetic pull toward camera",back:"Magnetic push away from camera",left:"Magnetic pull leftward",right:"Magnetic pull rightward",up:"Magnetic pull upward",down:"Magnetic pull downward",attract:"Magnetic attraction to center",repel:"Magnetic repulsion from center"}[e],config:{duration:1200,musicalDuration:{musical:!0,beats:3},direction:e,pullStrength:1,returnToOrigin:!0,strength:1,particleMotion:{type:"magnetic",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",strengthSync:{onBeat:1.5,offBeat:.7}},initialize(e,t,n,a){e.gestureData||(e.gestureData={}),e.gestureData.magnetic={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??1,initialized:!0}},apply(e,t,n,a,i,r){e.gestureData?.magnetic?.initialized||this.initialize(e,n,i,r);const s={...this.config,...n},o=s.strength||1,l=s.pullStrength||1,c=!1!==s.returnToOrigin,h=e.gestureData.magnetic,d=s.direction||"attract";let u,p,m;switch(u=c?Math.sin(t*Math.PI):Math.min(1,2*t),d){case"left":p=h.originalX-100,m=h.originalY;break;case"right":p=h.originalX+100,m=h.originalY;break;case"up":p=h.originalX,m=h.originalY-100;break;case"down":p=h.originalX,m=h.originalY+100;break;case"repel":{const e=h.originalX-i,t=h.originalY-r,n=Math.sqrt(e*e+t*t)||1;p=h.originalX+e/n*100,m=h.originalY+t/n*100;break}default:p=i,m=r}const f=(p-h.originalX)*u*l*o*.5,g=(m-h.originalY)*u*l*o*.5;e.x=h.originalX+f,e.y=h.originalY+g},cleanup(e){if(e.gestureData?.magnetic){const t=e.gestureData.magnetic;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.magnetic}},"3d":{evaluate(e,t){const n=t.config||this.config||{},a=n.strength||1,i=n.direction||"attract";let r;r=!1!==n.returnToOrigin?Math.sin(e*Math.PI):Math.min(1,2*e);let s=0,o=0,l=0,c=1;const h=.15*r*a;switch(i){case"forward":l=h,c=1+.1*r*a;break;case"back":l=-h,c=1-.08*r*a;break;case"left":s=-h;break;case"right":s=h;break;case"up":o=h;break;case"down":o=-h;break;case"attract":l=h,c=1-.1*r*a;break;case"repel":l=-h,c=1+.1*r*a}const d=1+.4*r,u=.3*r;return{cameraRelativePosition:[s+(r>.5?.01*Math.sin(e*Math.PI*20)*(r-.5)*2:0),o,l],rotation:[0,0,0],scale:c,glowIntensity:d,glowBoost:u}}}}}const ty={name:"sparkle",emoji:"",type:"blending",description:"Bright twinkling sparkle bursts",config:{duration:800,musicalDuration:{musical:!0,beats:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:2},interruptible:!0,priority:5,blendable:!0},apply:(e,t,n)=>!1,blend:(e,t,n)=>!1,"3d":{evaluate(e,t){const n=t?.strength||1,a=Math.pow(Math.max(0,Math.sin(e*Math.PI*6)),3),i=Math.pow(Math.max(0,Math.sin(e*Math.PI*8+1)),3),r=Math.pow(Math.max(0,Math.sin(e*Math.PI*10+2)),3),s=Math.max(a,i,r)*Math.sin(e*Math.PI);return{position:[0,0,0],rotation:[0,0,0],scale:1+.08*s*n,glowIntensity:1+.5*s*n,glowBoost:2*s*n}}}},ny={name:"shimmer",emoji:"",type:"particle",description:"Shimmer effect with sparkling particles",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},particleMotion:"radiant"},rhythm:{enabled:!0,syncType:"beat",durationSync:{mode:"bars",bars:1},intensity:.8},override:(e,t,n)=>(e.shimmerEffect=!0,e.shimmerProgress=t,!0),blend:(e,t,n)=>!1,"3d":{evaluate(e,t){const n=t?.strength||1,a=(.4*Math.sin(e*Math.PI*4)+.35*Math.sin(e*Math.PI*6+.5)+.25*Math.sin(e*Math.PI*10+1)+1)/2;return{position:[0,0,0],rotation:[0,0,0],scale:1+.05*a*n,glowIntensity:1+.3*a*n,glowBoost:1*a*n}}}},ay=((e,t="")=>({name:e,emoji:t,type:"blending",description:`${e} animation`,config:{duration:1e3,musicalDuration:{musical:!0,beats:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:2},interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",maxQueue:3},apply:(e,t,n)=>!1,blend:(e,t,n)=>!1}))("groove",""),iy={},ry=[],sy=[],oy=[];function ly(e,t){iy[e.name]=e,t.push(e.name)}function cy(e,t,n){Object.defineProperty(iy,e,{configurable:!0,enumerable:!0,get(){const n=t();return Object.defineProperty(iy,e,{configurable:!0,enumerable:!0,writable:!0,value:n}),n}}),n.push(e)}[jm,hm,Tm,Af,Cm,Am,dm,um,_m,ty,ny,Pm,ay,ff,wm,Cf,Tf,Um,Wm,qm,Hm,Gm,Em,Im,km,Rm,zm,Fm,Sm,Mm,Sf,Mf,gm,ym,vm,bm,yf,vf,bf,wf,om,lm,cm,Kf,Zf,$f,Qf,Nm,Xm,$m,Qm,Km,Zm,Vm,Bm,Lm].forEach(e=>ly(e,ry)),[lf,df,uf,Jm,tf,nf,af,ug,Wf,Df,Ef,If,kf,Rf,og,pf,mf,Pf,sf,Ff,_f,Vf,Uf,Gf,Nf,Lf,eg,tg,ng,ag,ig,rg,sg,Hf,jf,Xf,Yf,qf].forEach(e=>ly(e,sy)),cy("lungeForward",()=>of("forward"),sy),cy("lungeBack",()=>of("back"),sy),cy("lungeLeft",()=>of("left"),sy),cy("lungeRight",()=>of("right"),sy),cy("lungeUp",()=>of("up"),sy),cy("lungeDown",()=>of("down"),sy),cy("recoilBack",()=>Bf("back"),sy),cy("recoilForward",()=>Bf("forward"),sy),cy("recoilLeft",()=>Bf("left"),sy),cy("recoilRight",()=>Bf("right"),sy),cy("recoilUp",()=>Bf("up"),sy),cy("recoilDown",()=>Bf("down"),sy),cy("oofLeft",()=>zf("left"),sy),cy("oofRight",()=>zf("right"),sy),cy("oofFront",()=>zf("front"),sy),cy("oofBack",()=>zf("back"),sy),cy("oofUp",()=>zf("up"),sy),cy("oofDown",()=>zf("down"),sy),cy("shatter",()=>cg("default"),sy),cy("shatterExplosive",()=>cg("explosive"),sy),cy("shatterCrumble",()=>cg("crumble"),sy),cy("shatterReform",()=>cg("reform"),sy),cy("shatterPunchLeft",()=>cg("punchLeft"),sy),cy("shatterPunchRight",()=>cg("punchRight"),sy),cy("shatterPunchFront",()=>cg("punchFront"),sy),cy("shatterSuspend",()=>cg("suspend"),sy),cy("shatterImplode",()=>cg("implode"),sy),cy("shatterGravity",()=>cg("gravity"),sy),cy("shatterOrbit",()=>cg("orbit"),sy),cy("dissolveUp",()=>dg("up"),sy),cy("dissolveDown",()=>dg("down"),sy),cy("dissolveLeft",()=>dg("left"),sy),cy("dissolveRight",()=>dg("right"),sy),cy("dissolveAway",()=>dg("away"),sy),cy("dissolveToward",()=>dg("toward"),sy),cy("rushForward",()=>rf("forward"),sy),cy("rushBack",()=>rf("back"),sy),cy("rushLeft",()=>rf("left"),sy),cy("rushRight",()=>rf("right"),sy),cy("rushUp",()=>rf("up"),sy),cy("rushDown",()=>rf("down"),sy),[Vg,mg,gg,yg,vg,bg,qg,kg,Jg,Kg,Qg,$g,Ug,Gg,Zg,pg,Hg,jg,Cg,Tg,Sg,Mg,_g,Ag,zg,Fg,Bg,Lg,Ng,Yg,Dg,Og,Eg,Ig,Wg,Xg,wg].forEach(e=>ly(e,oy)),cy("magneticForward",()=>ey("forward"),oy),cy("magneticBack",()=>ey("back"),oy),cy("magneticLeft",()=>ey("left"),oy),cy("magneticRight",()=>ey("right"),oy),cy("magneticUp",()=>ey("up"),oy),cy("magneticDown",()=>ey("down"),oy),cy("magneticAttract",()=>ey("attract"),oy),cy("magneticRepel",()=>ey("repel"),oy);const hy={override:sy},dy={idle:["breathe","expand","contract","pulse","sway","float","floatUp","floatDown","floatLeft","floatRight","bob","lean","leanLeft","leanRight","jitter","twitch","vibrate","shake","wiggle"],dance:["stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","runningman","charleston","hula","twist","pop","flare","swell","swagger","dip","bounce","orbit","orbitLeft","orbitRight","orbitUp","orbitDown","sparkle","shimmer","groove"],actions:["jump","jumpDown","jumpLeft","jumpRight","rushForward","rushBack","rushLeft","rushRight","rushUp","rushDown","lunge","lungeForward","lungeBack","lungeLeft","lungeRight","lungeUp","lungeDown","spin","spinLeft","spinRight","flip","backflip","point","pointUp","pointDown","pointLeft","pointRight","kickLeft","kickRight","bow","nod","reach","headBob","crouch","tilt","tiltUp","tiltDown","tiltLeft","tiltRight"],reactions:["oofLeft","oofRight","oofFront","oofBack","oofUp","oofDown","recoil","recoilBack","recoilForward","recoilLeft","recoilRight","recoilUp","recoilDown","knockdown","knockout","inflate","deflate","squash","stretch","pancake","crackFront","crackBack","crackLeft","crackRight","crackUp","crackDown","crackHeal","rage","fury","battlecry","charge","wobble","teeter","rock","pendulum"],destruction:["shatter","shatterMesh","shatterExplosive","shatterCrumble","shatterReform","shatterPunchLeft","shatterPunchRight","shatterPunchFront","shatterSuspend","shatterImplode","shatterGravity","shatterOrbit","dissolveUp","dissolveDown","dissolveLeft","dissolveRight","dissolveAway","dissolveToward","splash","drench","soak","flow","tide","liquefy","poolWater","vortexWater","watercrown","waterdance","waterdrill","waterhelix","watermeditation","waterpillar","waterflourish","waterbarrage","waterimpact","watercrush","watertwirl","watershield","smokebomb","vanish","materialize","phoenix","burn","scorch","combust","flameVortex","firedance","fireflourish","firecrown","firemeditation","firedrill","firepillar","firehelix","firebarrage","fireimpact","fireblast","radiate","blaze","firetwirl","fireshield","puff","billow","fume","shroud","hazeSmoke","chokeSmoke","iceFreeze","shatterIce","shock","overload","glitch","crackle","chargeUp","electricAuraEffect","staticDischarge","electriccrown","electricdance","electrichelix","electricpillar","electricdrill","electricflourish","electricvortex","electricbarrage","electricimpact","electricblast","electricsurge","electriczap","electricmeditation","electrictwirl","electricshield","zap","drain","hollow","corrupt","consume","singularity","voidcrown","voiddance","voidhelix","voidpillar","voiddrill","voidflourish","voidvortex","voidbarrage","voidimpact","voidmeditation","voidtwirl","voidshield","iceCrown","iceDance","icePillar","iceHelix","iceMeditation","iceVortex","iceSplash","iceEncase","iceDrill","iceFlourish","iceBarrage","iceImpact","icemist","iceshiver","icetwirl","iceshield","lightBlind","lightPurify","lightCleanse","lightRadiate","lightGlow","lightBeacon","lightAscend","lightIlluminate","lightDissolve","lightMeditation","lightcrown","lightdance","lighthelix","lightpillar","lightdrill","lightflourish","lightvortex","lightbarrage","lightimpact","lightblast","lightsurge","lightmeditation","lighttwirl","lightshield","poisonInfect","poisonSicken","poisonOoze","poisonSeep","poisonToxic","poisonCorrode","poisonMelt","poisonDecay","poisonDissolve","earthPetrify","earthBurden","earthRumble","earthQuake","earthMeditation","earthEncase","earthCrumble","earthShatter","earthErode","earthcrown","earthdance","earthhelix","earthpillar","earthdrill","earthflourish","earthvortex","earthbarrage","earthimpact","earthblast","earthsurge","earthmeditation","earthtwirl","earthshield","morph"],atmosphere:["rain","drift","driftUp","driftDown","driftLeft","driftRight","vortex","cascadeUp","cascadeDown","cascadeLeft","cascadeRight","confetti","fizz","swarmUp","swarmDown","swarmLeft","swarmRight","burst","burstUp","burstDown","burstLeft","burstRight","ripple","wave","flash","glow","bloom","flicker","shiver","heartbeat","snap","elasticBounce","hold","fade","settle","peek","directional","magneticForward","magneticBack","magneticLeft","magneticRight","magneticUp","magneticDown","magneticAttract","magneticRepel"]},uy={};function py(e){if(iy[e])return iy[e];return rm(e)||null}function my(){const e=[];return Object.values(iy).forEach(t=>{e.push({name:t.name,emoji:t.emoji||"",type:t.type,category:uy[t.name]||"atmosphere",description:t.description||"No description",source:"core",usesShatter:t.usesShatter||!1})}),sm().forEach(t=>{const n=rm(t);e.push({name:n.name,emoji:n.emoji||"",type:n.type,category:n.category||"effect",description:n.description||"Plugin gesture",source:"plugin"})}),e}Object.entries(dy).forEach(([e,t])=>{t.forEach(t=>{uy[t]=e})});class fy{constructor(e,t,n="ambient",a=1,i=1,r=null){const s=Math.random();this.z=s<1/13?.5+.5*Math.random():.9*Math.random()-1;const o=this.z>0?(20+20*Math.random())*a:3*a,l=Math.random()*Math.PI*2;this.x=e+Math.cos(l)*o,this.y=t+Math.sin(l)*o,this.vx=0,this.vy=0,this.vz=0,this.life=0,this.maxLife=1,this.lifeDecay=.01,this.fadeInTime=.15,this.fadeOutTime=.3,this.isFadingOut=!1,this.age=0,this.scaleFactor=a,this.particleSizeMultiplier=i,this.size=(4+6*Math.random())*a*i,this.baseSize=this.size,this.emotionColors=r,this.color="#ffffff",this.opacity=1,this.hasGlow=Math.random()<.333,this.glowSizeMultiplier=this.hasGlow?1.33+.33*Math.random():0,this.isCellShaded=Math.random()<.333,this.baseOpacity=.3+.4*Math.random(),this.cachedColors=new Map,this.maxCachedColors=20,this.colorAccessOrder=[],this.lastColor=null,this.lastOpacity=-1,this.behavior=n,this.behaviorData={},this.gestureData={initialX:e,initialY:t},am(this,n)}update(e,t,n,a=null,i=null,r=0,s=null){const o=Math.min(e,50)/16.67,l=i&&i.type&&r>0&&function(e){const t=py(e);return!!t&&"override"===t.type}(i.type),c=this.rainData||"falling"===this.gestureBehavior||this.fallingData||this.gestureData?.rain,h=l||c;if(h||(this.x+=this.vx*o,this.y+=this.vy*o),!h){let e,a;if(s)e=s.width,a=s.height;else{const i=document.getElementById("card-mascot")||document.getElementById("cherokee-guide-mascot")||document.querySelector("canvas");e=i?i.width:2*t,a=i?i.height:2*n}const i=20,r=t-e/2+i,o=t+e/2+i,l=n-a/2+i,c=n+a/2-i;this.x-this.size<r?(this.x=r+this.size,this.vx=.5*Math.abs(this.vx)):this.x+this.size>o&&(this.x=o-this.size,this.vx=.5*-Math.abs(this.vx)),this.y-this.size<l?(this.y=l+this.size,this.vy=.5*Math.abs(this.vy)):this.y+this.size>c&&(this.y=c-this.size,this.vy=.5*-Math.abs(this.vy))}this.age+=this.lifeDecay*o,this.age<this.fadeInTime?this.life=this.age/this.fadeInTime:this.age<1-this.fadeOutTime?this.life=1:(this.life=(1-this.age)/this.fadeOutTime,this.isFadingOut=!0,"popcorn"===this.behavior&&(this.size=this.baseSize*(.5+.5*this.life))),this.life=Math.max(0,Math.min(1,this.life)),"falling"===this.behavior?this.opacity=this.life:this.opacity=this.easeInOutCubic(this.life),"burst"===this.behavior&&this.behaviorData&&this.life<this.behaviorData.fadeStart&&(this.size=this.baseSize*(this.life/this.behaviorData.fadeStart))}applyUndertoneModifier(e,t){}applyGestureMotion(e,t,n,a,i){!function(e,t,n,a,i,r){if(!n||!n.type||a>=1)return;e.gestureData||(e.gestureData={originalVx:e.vx,originalVy:e.vy,initialX:e.x,initialY:e.y,startAngle:Math.atan2(e.y-r,e.x-i),startRadius:Math.sqrt(Math.pow(e.x-i,2)+Math.pow(e.y-r,2))});const s=py(n.type);if(!s)return;let o=n;if(xp.isEnabled()&&s.rhythm?.enabled){const i=xp.applyGestureRhythm(s,e,a,t);o={...n,amplitude:(n.amplitude||1)*(i.amplitudeMultiplier||1)*(i.accentMultiplier||1),wobbleAmount:(n.wobbleAmount||0)*(i.wobbleMultiplier||1),rhythmModulation:i}}s.apply&&s.apply(e,a,o,t,i,r),a>=.99&&s.cleanup&&(s.cleanup(e),e.gestureData=null)}(this,n,e,t,a,i)}isOutOfBounds(e,t){return this.x<-50||this.x>e+50||this.y<-50||this.y>t+50}isAlive(){return this.life>0}setOutwardVelocity(e){if(this.behaviorData&&void 0!==this.behaviorData.outwardSpeed){const t=this.behaviorData.outwardSpeed;this.vx=Math.cos(e)*t,this.vy=Math.sin(e)*t+(this.behaviorData.upwardBias||0)}}getDepthAdjustedSize(){const e=1+.2*this.z;return this.size*e}getState(){return{position:{x:this.x,y:this.y,z:this.z},velocity:{x:this.vx,y:this.vy,z:this.vz},life:this.life,behavior:this.behavior,size:this.size,opacity:this.opacity}}reset(e,t,n="ambient",a=1,i=1,r=null){const s=Math.random();this.z=s<1/13?.5+.5*Math.random():.9*Math.random()-1;const o=this.z>0?(20+20*Math.random())*a:3*a,l=Math.random()*Math.PI*2;if(this.x=e+Math.cos(l)*o,this.y=t+Math.sin(l)*o,this.vx=0,this.vy=0,this.vz=0,this.life=0,this.age=0,this.scaleFactor=a,this.particleSizeMultiplier=i,this.size=(4+6*Math.random())*a*i,this.baseSize=this.size,this.emotionColors=r,this.cachedColors.clear(),this.colorAccessOrder=[],this.opacity=0,this.isFadingOut=!1,this.baseOpacity=.3+.4*Math.random(),this.color="#ffffff",this.behavior=n,this.gestureData=null,this.behaviorData)for(const e in this.behaviorData)delete this.behaviorData[e];else this.behaviorData={};am(this,n)}getCachedColor(e,t){const n=Math.round(100*t)/100,a=`${e}_${n}`;if(this.cachedColors.has(a)){const e=this.colorAccessOrder.indexOf(a);-1!==e&&this.colorAccessOrder.splice(e,1),this.colorAccessOrder.push(a)}else{if(this.cachedColors.size>=this.maxCachedColors){const e=this.colorAccessOrder.shift();this.cachedColors.delete(e)}this.cachedColors.set(a,this.hexToRgba(e,n)),this.colorAccessOrder.push(a)}return this.cachedColors.get(a)}hexToRgba(e,t){const n=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return n?`rgba(${parseInt(n[1],16)}, ${parseInt(n[2],16)}, ${parseInt(n[3],16)}, ${t})`:`rgba(255, 255, 255, ${t})`}easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}render(e,t="#ffffff"){if(this.life<=0)return;if(!isFinite(this.x)||!isFinite(this.y))return;const n=this.x,a=this.y,i=Math.max(.1,this.size),r=this.tempColor||this.color||t;if(e.save(),this.isCellShaded){e.strokeStyle=this.getCachedColor(r,.9*this.opacity),e.lineWidth=2,e.beginPath(),e.arc(n,a,i,0,2*Math.PI),e.stroke();const t=Math.floor(3*this.opacity)/3;e.fillStyle=this.getCachedColor(r,t*(this.baseOpacity||.5)*.5),e.beginPath(),e.arc(n,a,Math.max(.1,i-1),0,2*Math.PI),e.fill(),t>.5&&(e.fillStyle=this.getCachedColor("#FFFFFF",.3),e.beginPath(),e.arc(n-.3*i,a-.3*i,.3*i,0,2*Math.PI),e.fill())}else{const t=e.createRadialGradient(n,a,0,n,a,i);if(t.addColorStop(0,this.getCachedColor(r,this.opacity*(this.baseOpacity||.5))),t.addColorStop(.5,this.getCachedColor(r,this.opacity*(this.baseOpacity||.5)*.5)),t.addColorStop(1,this.getCachedColor(r,0)),e.fillStyle=t,e.beginPath(),e.arc(n,a,i,0,2*Math.PI),e.fill(),this.hasGlow&&this.glowSizeMultiplier>0){const t=i*this.glowSizeMultiplier,s=e.createRadialGradient(n,a,.5*i,n,a,t),o=.3,l=Math.max(o,this.opacity),c=Math.min(1,this.glowSizeMultiplier/3);s.addColorStop(0,this.getCachedColor(r,Math.max(.5,.8*l)*c)),s.addColorStop(.25,this.getCachedColor(r,Math.max(.3,.6*l)*c)),s.addColorStop(.5,this.getCachedColor(r,Math.max(.2,.4*l)*c)),s.addColorStop(.75,this.getCachedColor(r,Math.max(.1,.2*l)*c)),s.addColorStop(1,this.getCachedColor(r,0)),e.save(),e.globalCompositeOperation="screen",e.fillStyle=s,e.beginPath(),e.arc(n,a,t,0,2*Math.PI),e.fill(),e.restore()}}e.restore()}}class gy{constructor(e=50){this.poolSize=Math.min(e,50),this.pool=[],this.totalParticlesCreated=0,this.totalParticlesDestroyed=0,this.poolHits=0,this.poolMisses=0}getParticle(e,t,n,a,i,r,s,o=null){let l;return this.pool.length>0?(l=this.pool.pop(),l.reset(e,t,n,a,i,r),this.poolHits++):(l=new fy(e,t,n,a,i,r),this.poolMisses++,this.totalParticlesCreated++),l.emotion=s,o&&(l.gestureBehavior=o),l}returnParticle(e){if(this.pool.length<this.poolSize){if(e.cachedGradient=null,e.cachedGradientKey=null,e.behaviorData)for(const t in e.behaviorData)delete e.behaviorData[t];this.pool.push(e)}else this.totalParticlesDestroyed++}refreshPool(){const e=this.pool.length-this.poolSize;e>0&&(this.pool.splice(this.poolSize),this.totalParticlesDestroyed+=e)}getStats(){return{poolSize:this.pool.length,poolHits:this.poolHits,poolMisses:this.poolMisses,totalCreated:this.totalParticlesCreated,totalDestroyed:this.totalParticlesDestroyed}}clear(){this.pool=[],this.poolHits=0,this.poolMisses=0,this.totalParticlesCreated=0,this.totalParticlesDestroyed=0}}class yy{constructor(){this.spawnAccumulator=0}getSpawnPosition(e,t,n,a,i,r=null){const s=Math.min(a,i)/12,o=2.5*s,l=1.1*o,c=Math.min(t-30,a-t-30),h=Math.min(n-30,i-n-30),d=Math.min(1.5*o,c,h);switch(e){case"ambient":case"resting":{const e=Math.random()*Math.PI*2,a=.9*o;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a,angle:e}}case"rising":{const e=Math.random()*Math.PI*2,a=l+Math.random()*(d-l);return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a}}case"falling":{const e=Math.random()*Math.PI*2,a=.9*o;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a,angle:e}}case"aggressive":{const e=Math.random()*Math.PI*2,a=o+Math.random()*s;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a}}case"scattering":default:return{x:t,y:n};case"burst":{const e=Math.random()*Math.PI*2;if("suspicion"===r){const a=1.5*s;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a}}if("surprise"===r){const a=1.2*s;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a}}return{x:t,y:n}}case"repelling":{const e=Math.random()*Math.PI*2,a=.9*o;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a}}case"orbiting":{const e=Math.random()*Math.PI*2,a=1.2*o+Math.random()*o*.5;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a}}case"glitchy":{const e=Math.random()*Math.PI*2,a=3*o+Math.random()*o*4;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a}}case"spaz":{const e=Math.random()*Math.PI*2,a=2*o+Math.random()*o*3;return{x:t+Math.cos(e)*a,y:n+Math.sin(e)*a}}}}clampToCanvas(e,t,n,a,i=30){return{x:Math.max(i,Math.min(n-i,e)),y:Math.max(i,Math.min(a-i,t))}}calculateSpawnRate(e,t){if(e<=0)return 0;const n=Math.min(t,50),a=e/1e3;this.spawnAccumulator+=a*n,this.spawnAccumulator=Math.min(this.spawnAccumulator,3);let i=0;for(;this.spawnAccumulator>=1;)i++,this.spawnAccumulator-=1;return i}resetAccumulator(){this.spawnAccumulator=0}}class vy{render(e,t,n="#ffffff",a=null){const i=[];for(const e of t)e.life<=0||i.push(e);this._renderParticles(e,i,n,a)}renderLayer(e,t,n="#ffffff",a=!1,i=null){const r=[],s=e.canvas.width,o=e.canvas.height;for(const e of t)e.z>=0===a&&(e.x<-50||e.x>s+50||e.y<-50||e.y>o+50||e.life<=0||r.push(e));return r.sort((e,t)=>e.isCellShaded!==t.isCellShaded?e.isCellShaded?-1:1:e.hasGlow!==t.hasGlow?e.hasGlow?-1:1:0),this._renderParticles(e,r,n,i),r}_renderParticles(e,t,n,a=null){e.save();let i=null;for(const r of t)if(r.isCellShaded)r.render(e,n),i=null;else{const t=r.color||n;if(t!==i&&(e.fillStyle=t,i=t),!isFinite(r.x)||!isFinite(r.y))continue;const s=r.getDepthAdjustedSize?r.getDepthAdjustedSize():r.size;let o=Math.max(.1,s),l=1;if(a&&a.fireflyEffect){const e=(.01*r.x+.01*r.y+.1*r.size)%(2*Math.PI),t=a.fireflyTime||.001*Date.now(),n=a.particleGlow||2;l=.3+Math.max(0,Math.sin(3*t+e))*n}if(a&&a.flickerEffect){const e=(.02*r.x+.02*r.y)%(2*Math.PI),t=a.flickerTime||.001*Date.now(),n=a.particleGlow||2;l=.5+Math.sin(12*t+e)*n*.5}if(a&&a.shimmerEffect){const t=r.x-e.canvas.width/2,n=r.y-e.canvas.height/2,i=Math.sqrt(t*t+n*n)/200,s=a.shimmerTime||.001*Date.now(),o=a.shimmerWave||0,c=a.particleGlow||1.2;l=1+.15*Math.sin(3*s-i+o)*c}if(a&&a.glowEffect){const t=a.glowProgress||0,n=a.particleGlow||2,i=r.x-e.canvas.width/2,s=r.y-e.canvas.height/2,l=Math.sqrt(i*i+s*s)/300,c=Math.min(.3*l,.5),h=Math.max(0,(t-c)/(1-c)),d=Math.sin(h*Math.PI);r._originalGlow||(r._originalGlow={hasGlow:r.hasGlow,glowSizeMultiplier:r.glowSizeMultiplier||0}),r.hasGlow=!0,r.glowSizeMultiplier=Math.max(3,r._originalGlow.glowSizeMultiplier)+d*n*3,o*=1+.3*d,t>=.99&&r._originalGlow&&(r.hasGlow=r._originalGlow.hasGlow,r.glowSizeMultiplier=r._originalGlow.glowSizeMultiplier,delete r._originalGlow)}if(r.hasGlow||l>1){const t=Math.max(.1,o*(r.glowSizeMultiplier||1.5)*l),n=e.globalCompositeOperation;e.globalCompositeOperation="screen",e.globalAlpha=.15*r.opacity*l,e.beginPath(),e.arc(r.x,r.y,t,0,2*Math.PI),e.fill(),e.globalAlpha=.25*r.opacity*l,e.beginPath(),e.arc(r.x,r.y,.6*t,0,2*Math.PI),e.fill(),e.globalCompositeOperation=n}e.globalAlpha=r.opacity*(r.baseOpacity||.5)*.6*Math.min(2,l),e.beginPath(),e.arc(r.x,r.y,o,0,2*Math.PI),e.fill()}e.restore()}}class by{constructor(e=50,t=null){this.errorBoundary=t,this.maxParticles=e,this.absoluteMaxParticles=2*e,this.particles=[],this.particlePool=new gy(e),this.particleSpawner=new yy,this.particleRenderer=new vy,this.containmentBounds=null,this.stateChangeCount=0,this.lastMemoryCheck=Date.now(),this.lastLeakedCount=0,this.particleCount=0,this.cleanupTimer=0,this.cleanupInterval=5e3}get pool(){return this.particlePool.pool}get poolSize(){return this.particlePool.poolSize}get poolHits(){return this.particlePool.poolHits}get poolMisses(){return this.particlePool.poolMisses}get totalParticlesCreated(){return this.particlePool.totalParticlesCreated}get totalParticlesDestroyed(){return this.particlePool.totalParticlesDestroyed}get spawnAccumulator(){return this.particleSpawner.spawnAccumulator}set spawnAccumulator(e){this.particleSpawner.spawnAccumulator=e}getParticleFromPool(e,t,n){return this.particlePool.getParticle(e,t,n,this.scaleFactor||1,this.particleSizeMultiplier||1,this.currentEmotionColors,this.currentEmotion,this.gestureBehavior)}returnParticleToPool(e){this.particlePool.returnParticle(e)}spawn(e,t,n,a,i,r,s=null,o=0,l=10,c=1,h=1,d=null,u=null){if(this.scaleFactor=c,this.particleSizeMultiplier=h,this.errorBoundary)return this.errorBoundary.wrap(()=>{this._spawn(e,t,n,a,i,r,s,o,l,d,u)},"particle-spawn")();this._spawn(e,t,n,a,i,r,s,o,l,d,u)}resetAccumulator(){this.particleSpawner.resetAccumulator()}_spawn(e,t,n,a,i,r,s,o=0,l=10,c=null,h=null){this.currentEmotion=t,this.baseEmotionColors=c,this.currentUndertone=h,this.currentEmotionColors=c&&h?function(e,t){return e&&Array.isArray(e)&&t&&"clear"!==t?e.map(e=>"string"==typeof e?bp(e,t):e&&"object"==typeof e&&e.color?{...e,color:bp(e.color,t)}:e):e}(c,h):c;let d=n;if(xp.isEnabled()){const n=Sp&&Sp.isInitialized?Sp.getEmotion(t):np(t);if(n){const t=xp.applyParticleRhythm(n,this);if(t.emitBurst)for(let n=0;n<t.emitBurst&&this.particles.length<l;n++)this.spawnSingleParticle(e,a,i);void 0!==t.emissionRate&&(d*=t.emissionRate)}}if(null!==s){for(let t=0;t<s&&this.particles.length<this.maxParticles;t++)this.spawnSingleParticle(e,a,i);return}if(this.skipSpawnThisFrame)return;for(;this.particles.length<o&&this.particles.length<this.maxParticles;)this.spawnSingleParticle(e,a,i);if(this.particles.length>=l)return;if(d<=0)return;const u=this.particleSpawner.calculateSpawnRate(d,r);for(let t=0;t<u&&this.particles.length<l;t++)this.spawnSingleParticle(e,a,i)}getSpawnPosition(e,t,n,a,i){return this.particleSpawner.getSpawnPosition(e,t,n,a,i,this.currentEmotion)}clampToCanvas(e,t,n,a,i=30){return this.particleSpawner.clampToCanvas(e,t,n,a,i)}spawnSingleParticle(e,t,n){if(this.particles.length>=this.absoluteMaxParticles)return;const a=this.canvasWidth||2*t,i=this.canvasHeight||2*n,r=this.particleSpawner.getSpawnPosition(e,t,n,a,i,this.currentEmotion),s=this.particleSpawner.clampToCanvas(r.x,r.y,a,i);r.x=s.x,r.y=s.y;const o=this.getParticleFromPool(r.x,r.y,e);"meditation_swirl"===e&&r.palmCenter&&(o.palmCenter=r.palmCenter,o.swirlAngle=r.swirlAngle),this.particles.push(o),this.particleCount++}update(e,t,n,a=null,i=0,r=null){if(this.errorBoundary)return this.errorBoundary.wrap((e,t,n,a,i,r)=>this._update(e,t,n,a,i,r),"particle-update")(e,t,n,a,i,r);this._update(e,t,n,a,i,r)}_update(e,t,n,a=null,i=0,r=null){for(this.particles=this.particles.filter(s=>(s.update(e,t,n,r,a,i,this.containmentBounds),s.isAlive()));this.particles.length>this.maxParticles;)this.removeParticle(0)}setGestureBehavior(e,t){this.gestureBehavior=t?e:null,t?this.particles.forEach(t=>{t.gestureBehavior=e}):this.particles.forEach(e=>{e.gestureBehavior=null})}removeParticle(e){if(e>=0&&e<this.particles.length){const t=this.particles.splice(e,1)[0];t.cachedGradient=null,t.cachedGradientKey=null,this.returnParticleToPool(t),this.particleCount=Math.max(0,this.particleCount-1)}}render(e,t="#ffffff",n=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._render(e,t,n)},"particle-render")();this._render(e,t,n)}renderBackground(e,t="#ffffff",n=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._renderLayer(e,t,!1,n)},"particle-render-bg")();this._renderLayer(e,t,!1,n)}renderForeground(e,t="#ffffff",n=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._renderLayer(e,t,!0,n)},"particle-render-fg")();this._renderLayer(e,t,!0,n)}_renderLayer(e,t,n,a=null){this.particleRenderer.renderLayer(e,this.particles,t,n,a)}_render(e,t,n=null){this.particleRenderer.render(e,this.particles,t,n)}onVisibilityResume(e,t=null){if(this.resetAccumulator(),e>3e4)this.clear();else if(e>1e4){const e=this.particles.length,n=t??e,a=Math.max(10,Math.floor(.5*n));for(;this.particles.length>a;)this.removeParticle(0)}}clear(){for(this.stateChangeCount++;this.particles.length>0;){const e=this.particles.pop();if(e.cachedColors&&e.cachedColors.clear(),e.behaviorData)for(const t in e.behaviorData)delete e.behaviorData[t];this.pool.length<this.poolSize&&!this.pool.includes(e)&&this.pool.push(e)}if(this.particles.length=0,this.particleCount=0,this.spawnAccumulator=0,this.pool.length>this.poolSize){const e=this.pool.length-this.poolSize;this.pool.splice(this.poolSize,e)}}burst(e,t,n,a){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._burst(e,t,n,a)},"particle-burst")();this._burst(e,t,n,a)}_burst(e,t,n,a){const i=Math.min(e,this.maxParticles-this.particles.length);for(let e=0;e<i;e++)this.spawnSingleParticle(t,n,a)}performCleanup(){if(this.pool.length>this.poolSize){const e=this.pool.length-this.poolSize;for(let t=0;t<e;t++){const e=this.pool.pop();e&&(e.cachedGradient=null,e.cachedGradientKey=null,e.behaviorData=null)}}for(const e of this.particles)e.cachedGradient&&e.life<.5&&(e.cachedGradient=null,e.cachedGradientKey=null)}getStats(){return{activeParticles:this.particles.length,maxParticles:this.maxParticles,poolSize:this.pool.length,poolHits:this.poolHits,poolMisses:this.poolMisses,poolEfficiency:this.poolHits/Math.max(1,this.poolHits+this.poolMisses),spawnAccumulator:this.spawnAccumulator}}setMaxParticles(e){for(this.originalMaxParticles=this.originalMaxParticles||this.maxParticles,this.maxParticles=Math.max(1,e);this.particles.length>this.maxParticles;)this.removeParticle(0)}cleanupDeadParticles(){const e=this.particles.length;this.particles=this.particles.filter(e=>e.isAlive());const t=e-this.particles.length;return this.pool.length>20&&(this.pool.length=20),t}getParticlesByBehavior(e){return this.particles.filter(t=>t.behavior===e)}validateParticles(){for(const e of this.particles)if(!e.isAlive()||e.life<0||e.life>1)return!1;return!0}cleanup(){for(let e=this.particles.length-1;e>=0;e--)this.particles[e].isAlive()||this.removeParticle(e)}refreshPool(){this.particlePool.clear();for(const e of this.particles)e.life=0}setContainmentBounds(e){this.containmentBounds=e}destroy(){this.clear(),this.particlePool.clear()}}class wy{constructor(e={}){this.worldScale=e.worldScale||.2,this.baseRadius=e.baseRadius||.15,this.depthScale=e.depthScale||.75,this.verticalScale=e.verticalScale||1,this.coreRadius3D=e.coreRadius3D||1,this.tempVec3=new Gt,this.tempVec3_2=new Gt,this.behaviorTranslators=this._initBehaviorTranslators(),this.currentGestureData=null}setCoreRadius3D(e){this.coreRadius3D=e}updateRotationState(e,t,n=null){this.rotationState=e,this.deltaTime=t,this.currentGestureData=n}_initBehaviorTranslators(){return{ambient:this._translateAmbient.bind(this),orbiting:this._translateOrbiting.bind(this),rising:this._translateRising.bind(this),falling:this._translateFalling.bind(this),popcorn:this._translatePopcorn.bind(this),burst:this._translateBurst.bind(this),aggressive:this._translateAggressive.bind(this),scattering:this._translateScattering.bind(this),repelling:this._translateRepelling.bind(this),connecting:this._translateConnecting.bind(this),resting:this._translateResting.bind(this),radiant:this._translateRadiant.bind(this),ascending:this._translateAscending.bind(this),erratic:this._translateErratic.bind(this),cautious:this._translateCautious.bind(this),surveillance:this._translateSurveillance.bind(this),glitchy:this._translateGlitchy.bind(this),spaz:this._translateSpaz.bind(this),directed:this._translateDirected.bind(this),fizzy:this._translateFizzy.bind(this),zen:this._translateZen.bind(this),gravitationalAccretion:this._translateGravitationalAccretion.bind(this)}}translate2DTo3D(e,t,n){if(e.gestureData?.rain?.initialized)return this._translateRainGesture(e,t,n);const a=(this.behaviorTranslators[e.behavior]||this._translateDefault.bind(this))(e,t,n);return this.currentGestureData&&"spin"===this.currentGestureData.gestureName?this._applySpinRotation(a,t,this.currentGestureData.progress):a}_translateRainGesture(e,t,n){const a=n.width/2,i=n.height/2,r=e.gestureData.rain,s=.004*(e.y-r.originalY),o=this._getUniformDirection3D(e),l=r.originalX-a,c=r.originalY-i,h=Math.sqrt(l*l+c*c)/a,d=.6*this.coreRadius3D,u=d+h*(1.2*this.coreRadius3D-d);return this.tempVec3.set(t.x+o.x*u,t.y+o.y*u*this.verticalScale-s,t.z+o.z*u)}_applySpinRotation(e,t,n){const a=e.x-t.x,i=e.y-t.y,r=e.z-t.z,s=Math.sin(n*Math.PI)*Math.PI*2,o=Math.cos(s),l=Math.sin(s),c=a*o-r*l,h=a*l+r*o;return this.tempVec3.set(t.x+c,t.y+i,t.z+h)}_canvasToWorld(e,t,n,a,i,r){const s=(e-a)/a,o=-(t-i)/i,l=1+n*this.depthScale,c=s*this.worldScale*l+r.x,h=o*this.worldScale*this.verticalScale*l+r.y,d=n*this.worldScale*.5+r.z;return this.tempVec3.set(c,h,d)}_hash(e){const t=43758.5453123*Math.sin(e);return t-Math.floor(t)}_getUniformDirection3D(e){const t=e.behaviorData||{};if(t.direction3D)return t.direction3D;const n=127.1*e.x+311.7*e.y+74.7*(e.vx||0)+159.3*(e.vy||0),a=this._hash(n),i=this._hash(n+1),r=a*Math.PI*2,s=2*i-1,o=Math.sqrt(1-s*s),l=o*Math.cos(r),c=s,h=o*Math.sin(r);return t.direction3D={x:l,y:c,z:h},t.direction3D}_toSpherical(e,t,n,a){const i=e-a.x,r=t-a.y,s=n-a.z,o=Math.sqrt(i*i+r*r+s*s);return{radius:o,theta:Math.atan2(s,i),phi:Math.acos(r/(o||1))}}_toCartesian(e,t,n,a){const i=e*Math.sin(n)*Math.cos(t)+a.x,r=e*Math.cos(n)+a.y,s=e*Math.sin(n)*Math.sin(t)+a.z;return this.tempVec3_2.set(i,r,s)}_translateDefault(e,t,n){return this._canvasToWorld(e.x,e.y,e.z,n.width/2,n.height/2,t)}_translateAmbient(e,t,n){const a=this._getUniformDirection3D(e),i=n.width/2,r=n.height/2,s=e.x-i,o=e.y-r,l=Math.sqrt(s*s+o*o)/i,c=.6*this.coreRadius3D,h=c+l*(1.2*this.coreRadius3D-c),d=.5*e.age,u=.03*this.coreRadius3D,p=Math.cos(d)*u,m=Math.sin(d)*u;return this.tempVec3.set(t.x+a.x*h+p,t.y+a.y*h*this.verticalScale,t.z+a.z*h+m)}_translateOrbiting(e,t,n){const a=e.behaviorData||{};if(!a.orbitPlane){const t=e.x+.5*e.y,n=.7*e.x+e.y;a.orbitPlane={inclination:.5*(Math.sin(.1*t)+1)*Math.PI,rotation:.5*(Math.sin(.1*n)+1)*Math.PI*2}}const{inclination:i,rotation:r}=a.orbitPlane,s=a.angle||0,o=.01*(a.radius||100)*this.baseRadius*.25*(1+e.z*this.depthScale),l=Math.cos(s)*o,c=Math.sin(s)*o,h=Math.cos(i),d=Math.sin(i),u=Math.cos(r),p=Math.sin(r),m=l*u-c*h*p,f=c*d,g=l*p+c*h*u;return this.tempVec3.set(t.x+m,t.y+f*this.verticalScale,t.z+g)}_translateRising(e,t,n){const a=this._canvasToWorld(e.x,e.y,e.z,n.width/2,n.height/2,t),i=-.01*e.vy;return a.y+=i,a}_translateFalling(e,t,n){const a=n.width/2,i=n.height/2,r=e.gestureData?.rain?.initialized;if(r){const n=e.gestureData.rain,r=.004*(e.y-n.originalY),s=this._getUniformDirection3D(e),o=n.originalX-a,l=n.originalY-i,c=Math.sqrt(o*o+l*l)/a,h=.6*this.coreRadius3D,d=h+c*(1.2*this.coreRadius3D-h);return this.tempVec3.set(t.x+s.x*d,t.y+s.y*d*this.verticalScale-r,t.z+s.z*d)}const s=this._getUniformDirection3D(e),o=e.x-a,l=e.y-i,c=Math.sqrt(o*o+l*l)/a,h=.6*this.coreRadius3D,d=h+c*(1.2*this.coreRadius3D-h),u=.6*e.age*this.coreRadius3D;return this.tempVec3.set(t.x+s.x*d,t.y+s.y*d*this.verticalScale-u,t.z+s.z*d)}_translatePopcorn(e,t,n){const a=n.width/2,i=n.height/2,r=e.behaviorData||{},s=this._getUniformDirection3D(e);if(!r.hasPopped){const e=.7*this.coreRadius3D;return this.tempVec3.set(t.x+s.x*e,t.y+s.y*e*this.verticalScale,t.z+s.z*e)}const o=e.x-a,l=e.y-i,c=Math.sqrt(o*o+l*l),h=Math.min(c/a,1.5),d=1.2*this.coreRadius3D,u=d+h*(4*this.coreRadius3D-d);return this.tempVec3.set(t.x+s.x*u,t.y+s.y*u*this.verticalScale,t.z+s.z*u)}_translateBurst(e,t,n){const a=this._getUniformDirection3D(e),i=1-e.life,r=this.coreRadius3D*(1+1*i);return this.tempVec3.set(t.x+a.x*r,t.y+a.y*r*this.verticalScale,t.z+a.z*r)}_translateAggressive(e,t,n){const a=this._getUniformDirection3D(e),i=n.width/2,r=n.height/2,s=e.x-i,o=e.y-r,l=Math.sqrt(s*s+o*o)/i,c=.3*this.coreRadius3D,h=c+l*(.55*this.coreRadius3D-c),d=.04*this.coreRadius3D,u=Math.sin(10*e.age+.1*e.x)*d,p=Math.cos(12*e.age+.1*e.y)*d,m=Math.sin(8*e.age+.1*e.vx)*d;return this.tempVec3.set(t.x+a.x*h+u,t.y+a.y*h*this.verticalScale+p,t.z+a.z*h+m)}_translateScattering(e,t,n){const a=this._getUniformDirection3D(e),i=Math.min(.8*e.age,1),r=this.coreRadius3D*(.3+.3*i);return this.tempVec3.set(t.x+a.x*r,t.y+a.y*r*this.verticalScale,t.z+a.z*r)}_translateRepelling(e,t,n){const a=this._getUniformDirection3D(e),i=Math.min(.6*e.age,1),r=this.coreRadius3D*(.3+.3*i);return this.tempVec3.set(t.x+a.x*r,t.y+a.y*r*this.verticalScale,t.z+a.z*r)}_translateConnecting(e,t,n){const a=this._canvasToWorld(e.x,e.y,e.z,n.width/2,n.height/2,t),i=.3*(1-e.life),r=this.tempVec3_2.set(t.x-a.x,t.y-a.y,t.z-a.z).normalize();return a.add(r.multiplyScalar(i)),a}_translateResting(e,t,n){const a=this._getUniformDirection3D(e),i=n.width/2,r=n.height/2,s=e.x-i,o=e.y-r,l=Math.sqrt(s*s+o*o)/i,c=.25*this.coreRadius3D,h=c+l*(.45*this.coreRadius3D-c),d=.3*e.age,u=Math.sin(d)*this.coreRadius3D*.01;return this.tempVec3.set(t.x+a.x*h,t.y+a.y*h*this.verticalScale+u,t.z+a.z*h)}_translateRadiant(e,t,n){const a=this._getUniformDirection3D(e),i=1-e.life,r=this.coreRadius3D*(1+.8*i);return this.tempVec3.set(t.x+a.x*r,t.y+a.y*r*this.verticalScale,t.z+a.z*r)}_translateAscending(e,t,n){const a=e.behaviorData||{},i=a.spiralAngle||0,r=.01*(a.spiralRadius||50)*this.coreRadius3D,s=e.age*this.coreRadius3D*.5,o=Math.cos(i)*r+t.x,l=s+t.y,c=Math.sin(i)*r+t.z;return this.tempVec3.set(o,l,c)}_translateErratic(e,t,n){const a=this._canvasToWorld(e.x,e.y,e.z,n.width/2,n.height/2,t),i=10*e.age;return a.x+=.1*Math.sin(1.1*i),a.y+=.1*Math.cos(1.3*i),a.z+=.1*Math.sin(1.7*i),a}_translateCautious(e,t,n){return this._translateAmbient(e,t,n)}_translateSurveillance(e,t,n){const a=this._getUniformDirection3D(e),i=.5*e.age,r=1.2*this.coreRadius3D,s={x:0*a.y-1*a.z,y:0*a.z-0*a.x,z:1*a.x-0*a.y},o=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z);o>0&&(s.x/=o,s.y/=o,s.z/=o);const l=Math.cos(i)*a.x+Math.sin(i)*s.x,c=Math.cos(i)*a.y+Math.sin(i)*s.y,h=Math.cos(i)*a.z+Math.sin(i)*s.z;return this.tempVec3.set(t.x+l*r,t.y+c*r*this.verticalScale,t.z+h*r)}_translateGlitchy(e,t,n){const a=this._canvasToWorld(e.x,e.y,e.z,n.width/2,n.height/2,t);return Math.floor(10*e.age)%3==0&&(a.x+=.3*(Math.random()-.5),a.y+=.3*(Math.random()-.5),a.z+=.3*(Math.random()-.5)),a}_translateSpaz(e,t,n){const a=this._canvasToWorld(e.x,e.y,e.z,n.width/2,n.height/2,t),i=.15,r=20*e.age;return a.x+=Math.sin(2.1*r)*i,a.y+=Math.cos(2.3*r)*i,a.z+=Math.sin(2.7*r)*i,a}_translateDirected(e,t,n){const a=e.behaviorData||{};if(void 0!==a.targetX&&void 0!==a.targetY){const i=this._canvasToWorld(a.targetX,a.targetY,e.z,n.width/2,n.height/2,t),r=this._canvasToWorld(e.x,e.y,e.z,n.width/2,n.height/2,t),s=1-e.life;return this.tempVec3.lerpVectors(r,i,s)}const i=this._getUniformDirection3D(e),r=n.width/2,s=n.height/2,o=e.x-r,l=e.y-s,c=Math.sqrt(o*o+l*l)/r,h=1*this.coreRadius3D,d=h+c*(1.6*this.coreRadius3D-h);return this.tempVec3.set(t.x+i.x*d,t.y+i.y*d*this.verticalScale,t.z+i.z*d)}_translateFizzy(e,t,n){const a=this._canvasToWorld(e.x,e.y,e.z,n.width/2,n.height/2,t),i=.05*Math.sin(8*e.age);return a.x+=i,a.z+=.05*Math.cos(8*e.age),a.y+=.5*e.age,a}_translateZen(e,t,n){const a=this._getUniformDirection3D(e),i=.2*e.age,r=1.4*this.coreRadius3D,s={x:0*a.y-1*a.z,y:0*a.z-0*a.x,z:1*a.x-0*a.y},o=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z);o>0&&(s.x/=o,s.y/=o,s.z/=o);const l=Math.cos(i)*a.x+Math.sin(i)*s.x,c=Math.cos(i)*a.y+Math.sin(i)*s.y,h=Math.cos(i)*a.z+Math.sin(i)*s.z;return this.tempVec3.set(t.x+l*r,t.y+c*r*this.verticalScale,t.z+h*r)}_translateGravitationalAccretion(e,t,n){const a=e.behaviorData||{},i=.25;if(a.orbitRadius||(e.x,e.y,a.orbitRadius=i*(2.5+5.5*Math.random()),a.orbitAngle=Math.PI+Math.random()*Math.PI,a.diskInclination=.1*(Math.random()-.5),a.angularVelocity=.5/Math.sqrt(a.orbitRadius/i),a.tidalStretch={x:1,y:1,z:1}),a.orbitRadius-=1e-4*this.baseRadius,a.angularVelocity=.5/Math.sqrt(a.orbitRadius/i),a.orbitAngle+=a.angularVelocity*(this.deltaTime||16)*.001,a.orbitAngle=a.orbitAngle%(2*Math.PI),a.orbitAngle<0&&(a.orbitAngle+=2*Math.PI),a.orbitAngle<Math.PI)return e.isAlive=!1,e.life=0,this.tempVec3.set(t.x,t.y,t.z);const r=a.orbitRadius/i;if(r<=1)e.isAlive=!1,e.life=0;else if(r<=1.5)a.tidalStretch.x=.3,a.tidalStretch.y=3,a.tidalStretch.z=.3;else if(r<=2.5){const e=(2.5-r)/1;a.tidalStretch.x=1-.7*e,a.tidalStretch.y=1+2*e,a.tidalStretch.z=1-.7*e}else a.tidalStretch.x=1,a.tidalStretch.y=1,a.tidalStretch.z=1;const s=Math.cos(a.orbitAngle)*a.orbitRadius,o=Math.sin(a.orbitAngle)*a.orbitRadius,l=.025*Math.sin(3*a.orbitAngle+e.x)*Math.sin(a.diskInclination),c=s*a.tidalStretch.x,h=l*a.tidalStretch.y,d=o*a.tidalStretch.z,u=.25;return this.tempVec3.set(t.x+c*u,t.y+h*u,t.z+d*u)}setWorldScale(e){this.worldScale=e}setBaseRadius(e){this.baseRadius=e}cleanupParticleCaches(e){for(const t of e)!t.isAlive&&t.behaviorData&&(t.behaviorData.direction3D&&(t.behaviorData.direction3D=null),t.behaviorData.orbitPlane&&(t.behaviorData.orbitPlane=null),t.behaviorData.orbitPath&&(t.behaviorData.orbitPath=null),t.behaviorData.orbitRadius&&(t.behaviorData.orbitRadius=null,t.behaviorData.orbitAngle=null,t.behaviorData.diskInclination=null,t.behaviorData.angularVelocity=null,t.behaviorData.tidalStretch=null))}dispose(){this.tempVec3=null,this.tempVec3_2=null,this.rotationState=null,this.currentGestureData=null}}const xy={nebula:0,spiral:1,tidal:2,orbital:3,radial:4,hotspot:5},Sy=0,My=1,_y=.5;function Ay(e={}){const t=e.behaviorMode??Sy;return{uBehaviorMode:{value:t},uBehaviorModeB:{value:t},uBehaviorBlend:{value:0},uBehaviorModeC:{value:t},uBehaviorModeD:{value:t},uBehaviorBlendCD:{value:0},uBehaviorCrossfade:{value:0},uBehaviorSpeed:{value:e.behaviorSpeed??My},uBaselineStrength:{value:e.baselineStrength??_y}}}function Cy(e){return"string"==typeof e?xy[e]??0:e}function Ty(e,t,n){e?.uniforms&&void 0!==n&&e.uniforms.uBehaviorSpeed&&(e.uniforms.uBehaviorSpeed.value=Math.max(.1,Math.min(5,n)))}let Py=null,Dy=null;const Oy=`\n    uniform float time;\n    uniform vec3 emotionColor;\n    uniform float energyIntensity;\n    uniform float driftEnabled;\n    uniform float driftSpeed;\n    uniform float crossWaveEnabled;\n    uniform float crossWaveSpeed;\n    uniform float ghostMode;      // 0.0 = solid, 1.0 = ghost (only visible through bloom)\n    uniform float baseOpacity;    // Base opacity when not in ghost mode (default 1.0)\n    uniform float phaseOffset1;   // Phase offset for primary drift (radians)\n    uniform float phaseOffset2;   // Phase offset for secondary drift (radians)\n    uniform float phaseOffset3;   // Phase offset for crosswave (radians)\n    uniform float colorDriftSpeed;   // Speed of color drift (default 0.15)\n    uniform float colorDriftAmount;  // How far colors drift from base (default 0.3)\n\n    // Blend layer uniforms\n    uniform float blendLayer1Mode;\n    uniform float blendLayer1Strength;\n    uniform float blendLayer1Enabled;\n    uniform float blendLayer2Mode;\n    uniform float blendLayer2Strength;\n    uniform float blendLayer2Enabled;\n\n    // Soul behavior system\n    \n    // Soul behavior system (soulBehaviors.js)\n    // Current mix pair (AB)\n    uniform int uBehaviorMode;\n    uniform int uBehaviorModeB;\n    uniform float uBehaviorBlend;     // 0.0 = all A, 1.0 = all B\n    // Crossfade target pair (CD)\n    uniform int uBehaviorModeC;\n    uniform int uBehaviorModeD;\n    uniform float uBehaviorBlendCD;   // 0.0 = all C, 1.0 = all D\n    uniform float uBehaviorCrossfade; // 0.0 = current (AB), 1.0 = target (CD)\n    uniform float uBehaviorSpeed;\n    uniform float uBaselineStrength;  // 0.0 = no baseline, 1.0 = full nebula floor\n\n\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec3 vViewPosition;\n\n    // Blend modes (injected from blendModesGLSL)\n    ${pu}\n\n    // Sin-free hash  fract/dot arithmetic (no sin())\n    float soulHash(vec3 p) {\n        p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n        p += dot(p.zxy, p.yxz + 19.19);\n        return fract(p.x * p.y * p.z);\n    }\n\n    // True 3D noise  8 hash lookups with trilinear interpolation\n    // (Previous version only interpolated x/y  missing z caused visible banding)\n    float noise3D(vec3 p) {\n        vec3 i = floor(p);\n        vec3 f = fract(p);\n        f = f * f * (3.0 - 2.0 * f); // smoothstep\n\n        // 8 cube corners\n        float a = soulHash(i);\n        float b = soulHash(i + vec3(1, 0, 0));\n        float c = soulHash(i + vec3(0, 1, 0));\n        float d = soulHash(i + vec3(1, 1, 0));\n        float e = soulHash(i + vec3(0, 0, 1));\n        float g = soulHash(i + vec3(1, 0, 1));\n        float h = soulHash(i + vec3(0, 1, 1));\n        float j = soulHash(i + vec3(1, 1, 1));\n\n        // Trilinear interpolation\n        return mix(\n            mix(mix(a, b, f.x), mix(c, d, f.x), f.y),\n            mix(mix(e, g, f.x), mix(h, j, f.x), f.y),\n            f.z\n        );\n    }\n\n    // Soul behavior functions (must come after noise3D)\n    \n    // \n    // SOUL BEHAVIOR SYSTEM  Pluggable energy patterns\n    //\n    // Each behavior returns a float energy value centered around 0.53\n    // with subtle variation up to ~0.60. This feeds into the existing\n    // color pipeline: energy  totalEnergy  coreColor  ghost mode\n    //\n    // REQUIRES: noise3D(vec3) defined before this block.\n    // \n\n    // --- Behavior 0: Nebula Drift (default  extracted from original inline code) ---\n    float soulBehaviorNebula(vec3 pos, float time,\n        float driftEnabled, float driftSpeed,\n        float crossWaveEnabled, float crossWaveSpeed,\n        float phaseOffset1, float phaseOffset2, float phaseOffset3,\n        float behaviorSpeed)\n    {\n        // 3-phase 120 spatial zones\n        float angle = atan(pos.x, pos.z);\n        float normalizedAngle = (angle + 3.14159) / 6.28318;\n        float zone = floor(normalizedAngle * 3.0);\n\n        float phaseSpeed = 0.15 * behaviorSpeed;\n        float t = time * phaseSpeed;\n        float phase1Time = sin(t + phaseOffset1) * 0.5 + 0.5;\n        float phase2Time = sin(t + phaseOffset2) * 0.5 + 0.5;\n        float phase3Time = sin(t + phaseOffset3) * 0.5 + 0.5;\n        float activePhase = zone < 1.0 ? phase1Time : (zone < 2.0 ? phase2Time : phase3Time);\n\n        float driftEnergy = 0.0;\n        if (driftEnabled > 0.5) {\n            float dt = time * driftSpeed * behaviorSpeed;\n            float drift1 = noise3D(pos * 2.0 + vec3(dt, dt * 0.7, dt * 0.3));\n            float primaryDrift = max(0.0, drift1 - 0.3) * 1.5;\n            float drift2 = noise3D(pos * 2.5 - vec3(dt * 0.6, dt * 0.4, dt));\n            float secondaryDrift = max(0.0, drift2 - 0.3) * 1.5;\n            driftEnergy = primaryDrift + secondaryDrift;\n        }\n\n        float crossWaveEnergy = 0.0;\n        if (crossWaveEnabled > 0.5) {\n            float ct = time * crossWaveSpeed * behaviorSpeed;\n            float wave = sin(pos.x * 4.0 + pos.z * 2.0 - ct) * 0.5 + 0.5;\n            crossWaveEnergy = pow(wave, 2.5);\n        }\n\n        float normalizedDrift = min(1.0, driftEnergy * 0.5);\n        float remappedPhase = 0.53 + activePhase * 0.05;\n        float effectContrib = (normalizedDrift * 0.03) + (crossWaveEnergy * 0.02);\n        return remappedPhase + effectContrib;\n    }\n\n    // --- Behavior 1: Spiral Flow ---\n    float soulBehaviorSpiral(vec3 pos, float time, float behaviorSpeed) {\n        float t = time * 0.3 * behaviorSpeed;\n        float angle = atan(pos.x, pos.z);\n        float height = pos.y;\n        // Primary helix: angle + height coupled with time for corkscrew\n        float helix = sin(angle * 2.0 - height * 4.0 + t * 6.28318) * 0.5 + 0.5;\n        helix = pow(helix, 2.0);\n        // Counter-helix for depth\n        float helix2 = sin(-angle * 1.5 + height * 3.0 + t * 4.0) * 0.5 + 0.5;\n        helix2 = pow(helix2, 2.5) * 0.4;\n        // Noise breakup so helices aren't perfectly smooth\n        float breakup = noise3D(pos * 3.0 + vec3(0.0, t, 0.0));\n        return 0.53 + (helix + helix2) * breakup * 0.07;\n    }\n\n    // --- Behavior 2: Tidal Breathing ---\n    float soulBehaviorTidal(vec3 pos, float time, float behaviorSpeed) {\n        float t = time * 0.2 * behaviorSpeed;\n        // Tide level oscillates between bottom and top\n        float tideLevel = sin(t * 3.14159) * 0.8;\n        float distFromTide = pos.y - tideLevel;\n        // Bright below tide surface, dark above\n        float tideMask = 1.0 - smoothstep(0.0, 0.25, distFromTide);\n        // Thin bright crest band at surface (softened for gentler pulse)\n        float crest = exp(-distFromTide * distFromTide * 40.0);\n        // Surface turbulence\n        float turbulence = noise3D(pos * 4.0 + vec3(t * 0.5, 0.0, t * 0.3)) * 0.15;\n        return 0.53 + (tideMask * 0.04) + (crest * 0.03) + turbulence * tideMask * 0.02;\n    }\n\n    // --- Behavior 3: Orbital Rings ---\n    float soulBehaviorOrbital(vec3 pos, float time, float behaviorSpeed) {\n        float t = time * 0.25 * behaviorSpeed;\n        float energy = 0.0;\n        // Ring 1: tilted 30 around X, orbiting around Y\n        float d1 = abs(pos.y * 0.866 - pos.z * 0.5 + sin(t * 2.0) * 0.1);\n        energy += exp(-d1 * d1 * 200.0) * (0.8 + 0.2 * sin(atan(pos.x, pos.z) * 3.0 + t * 4.0));\n        // Ring 2: tilted -45 around X, different speed\n        float d2 = abs(pos.y * 0.707 + pos.z * 0.707 + sin(t * 1.5 + 2.094) * 0.15);\n        energy += exp(-d2 * d2 * 180.0) * (0.7 + 0.3 * sin(atan(pos.x, pos.z) * 2.0 - t * 3.0));\n        // Ring 3: tilted 60 around Z\n        float d3 = abs(pos.y * 0.5 - pos.x * 0.866 + sin(t * 1.8 + 4.189) * 0.12);\n        energy += exp(-d3 * d3 * 160.0) * (0.6 + 0.4 * sin(atan(pos.z, pos.x) * 4.0 + t * 5.0));\n        return 0.53 + min(energy, 1.0) * 0.07;\n    }\n\n    // --- Behavior 4: Radial Pulse ---\n    // Dual overlapping wavefronts offset by half-cycle.\n    // Prevents light-switch effect: one is always fading in as the other fades out.\n    float soulBehaviorRadial(vec3 pos, float time, float behaviorSpeed) {\n        float t = time * 0.2 * behaviorSpeed;\n        float dist = length(pos);\n\n        // Wavefront A\n        float phaseA = fract(t * 0.3);\n        float radiusA = phaseA * 1.5;\n        float shellA = exp(-(dist - radiusA) * (dist - radiusA) * 20.0);\n        // Smooth fade: raised cosine (010 over cycle, no discontinuity)\n        float fadeA = 0.5 + 0.5 * cos(phaseA * 6.28318);\n        float energyA = shellA * fadeA;\n\n        // Wavefront B  half-cycle offset\n        float phaseB = fract(t * 0.3 + 0.5);\n        float radiusB = phaseB * 1.5;\n        float shellB = exp(-(dist - radiusB) * (dist - radiusB) * 20.0);\n        float fadeB = 0.5 + 0.5 * cos(phaseB * 6.28318);\n        float energyB = shellB * fadeB;\n\n        float energy = max(energyA, energyB);\n\n        // Noise breaks perfect spherical symmetry\n        float noiseMod = noise3D(normalize(pos + vec3(0.001)) * 5.0 + vec3(t * 0.2));\n        energy *= (0.7 + noiseMod * 0.3);\n        return 0.53 + min(energy, 1.0) * 0.07;\n    }\n\n    // --- Behavior 5: Wandering Hotspot ---\n    float soulBehaviorHotspot(vec3 pos, float time, float behaviorSpeed) {\n        float t = time * 0.15 * behaviorSpeed;\n        // 3D Lissajous curve for hotspot position\n        vec3 hotspot = vec3(\n            sin(t * 2.0) * 0.25,\n            sin(t * 3.0 + 1.5708) * 0.2,\n            sin(t * 2.5 + 3.14159) * 0.25\n        );\n        float dist = length(pos - hotspot);\n        float core = exp(-dist * dist * 30.0);\n        // Trailing ghost positions (dimmer, wider)\n        vec3 trail1 = vec3(\n            sin((t - 0.3) * 2.0) * 0.25,\n            sin((t - 0.3) * 3.0 + 1.5708) * 0.2,\n            sin((t - 0.3) * 2.5 + 3.14159) * 0.25\n        );\n        float trailGlow1 = exp(-length(pos - trail1) * length(pos - trail1) * 20.0) * 0.5;\n        vec3 trail2 = vec3(\n            sin((t - 0.6) * 2.0) * 0.25,\n            sin((t - 0.6) * 3.0 + 1.5708) * 0.2,\n            sin((t - 0.6) * 2.5 + 3.14159) * 0.25\n        );\n        float trailGlow2 = exp(-length(pos - trail2) * length(pos - trail2) * 15.0) * 0.25;\n        float energy = core + trailGlow1 + trailGlow2;\n        return 0.53 + min(energy, 1.0) * 0.07;\n    }\n\n    // \n    // DISPATCH  Call a behavior by mode index\n    // \n    float dispatchSoulBehavior(int mode, vec3 pos, float time, float behaviorSpeed,\n        float driftEnabled, float driftSpeed,\n        float crossWaveEnabled, float crossWaveSpeed,\n        float phaseOffset1, float phaseOffset2, float phaseOffset3)\n    {\n        if (mode == 0) {\n            return soulBehaviorNebula(pos, time,\n                driftEnabled, driftSpeed,\n                crossWaveEnabled, crossWaveSpeed,\n                phaseOffset1, phaseOffset2, phaseOffset3,\n                behaviorSpeed);\n        } else if (mode == 1) {\n            return soulBehaviorSpiral(pos, time, behaviorSpeed);\n        } else if (mode == 2) {\n            return soulBehaviorTidal(pos, time, behaviorSpeed);\n        } else if (mode == 3) {\n            return soulBehaviorOrbital(pos, time, behaviorSpeed);\n        } else if (mode == 4) {\n            return soulBehaviorRadial(pos, time, behaviorSpeed);\n        } else {\n            return soulBehaviorHotspot(pos, time, behaviorSpeed);\n        }\n    }\n\n    // \n    // MIX + CROSSFADE  Baseline floor + active accent\n    //\n    // Nebula drift always runs as an ambient baseline floor.\n    // Active behaviors (AB/CD crossfade system) accentuate on top.\n    // uBaselineStrength controls how much baseline shows (0 = off, 1 = full).\n    // \n    float calculateSoulBehavior(vec3 pos, float time, float behaviorSpeed,\n        float driftEnabled, float driftSpeed,\n        float crossWaveEnabled, float crossWaveSpeed,\n        float phaseOffset1, float phaseOffset2, float phaseOffset3)\n    {\n        // Always-on baseline: nebula drift provides ambient energy floor\n        float baseline = soulBehaviorNebula(pos, time,\n            driftEnabled, driftSpeed, crossWaveEnabled, crossWaveSpeed,\n            phaseOffset1, phaseOffset2, phaseOffset3, behaviorSpeed);\n        float baseEnergy = baseline - 0.53; // [0, ~0.07]\n\n        // Current mix (AB pair)\n        float energyA = dispatchSoulBehavior(uBehaviorMode, pos, time, behaviorSpeed,\n            driftEnabled, driftSpeed, crossWaveEnabled, crossWaveSpeed,\n            phaseOffset1, phaseOffset2, phaseOffset3);\n        float currentMix = energyA;\n        if (uBehaviorBlend > 0.001) {\n            float energyB = dispatchSoulBehavior(uBehaviorModeB, pos, time, behaviorSpeed,\n                driftEnabled, driftSpeed, crossWaveEnabled, crossWaveSpeed,\n                phaseOffset1, phaseOffset2, phaseOffset3);\n            currentMix = mix(energyA, energyB, uBehaviorBlend);\n        }\n\n        // Crossfade to target (CD pair) if active\n        if (uBehaviorCrossfade >= 0.001) {\n            float energyC = dispatchSoulBehavior(uBehaviorModeC, pos, time, behaviorSpeed,\n                driftEnabled, driftSpeed, crossWaveEnabled, crossWaveSpeed,\n                phaseOffset1, phaseOffset2, phaseOffset3);\n            float targetMix = energyC;\n            if (uBehaviorBlendCD > 0.001) {\n                float energyD = dispatchSoulBehavior(uBehaviorModeD, pos, time, behaviorSpeed,\n                    driftEnabled, driftSpeed, crossWaveEnabled, crossWaveSpeed,\n                    phaseOffset1, phaseOffset2, phaseOffset3);\n                targetMix = mix(energyC, energyD, uBehaviorBlendCD);\n            }\n            currentMix = mix(currentMix, targetMix, uBehaviorCrossfade);\n        }\n\n        float activeEnergy = currentMix - 0.53; // [0, ~0.07]\n\n        // Combine: baseline floor + active accent\n        // Peaks from both add together  more dynamic range\n        return 0.53 + baseEnergy * uBaselineStrength + activeEnergy;\n    }\n\n\n    void main() {\n        // Dispatch to active behavior  returns energy in 0.53-0.60 range\n        float rawBehavior = calculateSoulBehavior(\n            vPosition, time, uBehaviorSpeed,\n            driftEnabled, driftSpeed,\n            crossWaveEnabled, crossWaveSpeed,\n            phaseOffset1, phaseOffset2, phaseOffset3\n        );\n\n        // Expand narrow behavior range [0.53, 0.60] to full [0, 1] display range\n        // Behaviors output tight range for mixing stability; remap here for contrast\n        float rawEffectActivity = clamp((rawBehavior - 0.53) / 0.07, 0.0, 1.0);\n\n        // Total energy for color calculation\n        // Wider range for more visible contrast between dim and bright regions\n        float totalEnergy = 0.15 + rawEffectActivity * 0.60;\n\n        // Edge glow - adds rim lighting (proper camera-relative view direction)\n        vec3 viewDir = normalize(vViewPosition);\n        float edgeGlow = 1.0 - abs(dot(vNormal, viewDir));\n        edgeGlow = pow(edgeGlow, 1.5) * 0.6;\n\n        // Color drift  warm/cool variants derived from the emotion color itself\n        // Warm: boost reds/greens, pull back blues (shift toward warmer hue)\n        vec3 warmColor = emotionColor * vec3(1.2, 1.05, 0.8);\n        // Cool: boost blues, pull back reds (shift toward cooler hue)\n        vec3 coolColor = emotionColor * vec3(0.8, 0.95, 1.25);\n\n        // Spatially-varying blend using noise + slow time drift\n        float driftT = time * colorDriftSpeed;\n        float spatialDrift = noise3D(vPosition * 2.0 + vec3(driftT, driftT * 0.7, driftT * 0.4));\n        float spatialDrift2 = noise3D(vPosition * 4.0 - vec3(driftT * 0.5, driftT * 0.3, driftT * 0.8));\n        // Blend factor: 0 to 1 range (warm to cool)\n        float driftFactor = spatialDrift * 0.65 + spatialDrift2 * 0.35;\n\n        // Blend: warm  emotionColor  cool\n        vec3 driftedColor = mix(warmColor, coolColor, driftFactor) * colorDriftAmount\n                          + emotionColor * (1.0 - colorDriftAmount);\n\n        // Final color before blend layers\n        vec3 coreColor = driftedColor * totalEnergy * energyIntensity;\n        coreColor += driftedColor * edgeGlow * 0.5;\n\n        // Apply blend layers to the entire soul color\n        // Mix factor clamped to [0,1]  strength > 1.0 only scales the blend color,\n        // it must NOT extrapolate the mix (which causes blowout/crushing)\n        if (blendLayer1Enabled > 0.5) {\n            int mode = int(blendLayer1Mode + 0.5);\n            vec3 blendResult = applyBlendMode(coreColor, emotionColor * blendLayer1Strength, mode);\n            coreColor = mix(coreColor, blendResult, min(blendLayer1Strength, 1.0));\n        }\n        if (blendLayer2Enabled > 0.5) {\n            int mode = int(blendLayer2Mode + 0.5);\n            vec3 blendResult = applyBlendMode(coreColor, emotionColor * blendLayer2Strength, mode);\n            coreColor = mix(coreColor, blendResult, min(blendLayer2Strength, 1.0));\n        }\n\n        // Ghost mode: ONLY the traveling energy bands are visible\n        // Everything below the threshold is completely invisible\n        float alpha = baseOpacity;\n        if (ghostMode > 0.01) {\n            // Threshold splits the 0-1 range: below = invisible, above = visible\n            float threshold = ghostMode * 0.4; // 0.0-0.4 range (softer than 0.5)\n            float visibility = smoothstep(threshold, threshold + 0.35, rawEffectActivity);\n\n            // Soft cutoff - dim areas fade rather than hard-clip\n            alpha = visibility * baseOpacity;\n\n            // Discard only truly invisible fragments\n            if (alpha < 0.02) {\n                discard;\n            }\n\n            // Boost color intensity for visible bands  punch through the crystal\n            coreColor *= 1.0 + visibility * 0.5;\n        }\n\n        // Fade near outer boundary so soul doesn't overbloom where it clips crystal shell\n        // Inclusion geometry is ~0.15 radius; wider fade (0.06-0.20) for gentler edge\n        float boundaryDist = length(vPosition);\n        float boundaryFade = 1.0 - smoothstep(0.06, 0.20, boundaryDist);\n        alpha *= boundaryFade;\n        if (alpha < 0.01) discard;\n\n        // Output the computed core color\n        gl_FragColor = vec4(coreColor, alpha);\n    }\n`;class Ey{constructor(e={}){this.radius=e.radius||.15,this.detail=e.detail||1,this.geometryType=e.geometryType||"crystal",this.renderer=e.renderer||null,this.assetBasePath=e.assetBasePath||"/assets",this.mesh=null,this.material=null,this.parentMesh=null,this.baseScale=1,this._pendingParent=null,this._disposed=!1,this._mixState={modeA:0,modeB:0,blend:0},this._crossfade=null,this._createMesh()}static _loadInclusionGeometry(e="/assets"){return Py?Promise.resolve(Py.clone()):Dy?Dy.then(e=>e.clone()):(Dy=new Promise(t=>{(new du).load(`${e}/models/Crystal/inclusion.obj`,e=>{let n=null;if(e.traverse(e=>{e.isMesh&&e.geometry&&({geometry:n}=e)}),n){n.computeBoundingBox();const e=new Gt;n.boundingBox.getCenter(e),n.translate(-e.x,-e.y,-e.z),n.rotateX(Math.PI/2),n.computeBoundingBox();const a=new Gt;n.boundingBox.getSize(a);const i=.3/Math.max(a.x,a.y,a.z);n.scale(i,i,i),n.computeVertexNormals(),Py=n,t(n.clone())}else console.warn("[ SOUL] No mesh in inclusion.obj, using fallback"),t(null)},void 0,e=>{console.warn("[ SOUL] Failed to load inclusion.obj:",e),t(null)})}),Dy)}_createMesh(){let e;this.material=new bi({uniforms:{time:{value:0},emotionColor:{value:new Ia(1,1,1)},energyIntensity:{value:1},driftEnabled:{value:1},driftSpeed:{value:.5},crossWaveEnabled:{value:1},crossWaveSpeed:{value:.4},ghostMode:{value:.36},baseOpacity:{value:1},phaseOffset1:{value:0},phaseOffset2:{value:2.094},phaseOffset3:{value:4.189},colorDriftSpeed:{value:.15},colorDriftAmount:{value:.45},...Ay(),blendLayer1Mode:{value:2},blendLayer1Strength:{value:2.3},blendLayer1Enabled:{value:1},blendLayer2Mode:{value:0},blendLayer2Strength:{value:1},blendLayer2Enabled:{value:1}},vertexShader:"\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec3 vViewPosition;\n\n    void main() {\n        vPosition = position;\n        vNormal = normalize(normalMatrix * normal);\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        vViewPosition = -mvPosition.xyz;\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",fragmentShader:Oy,transparent:!0,depthWrite:!0,depthTest:!0,side:0}),e=Py?Py.clone():new no(this.radius,this.detail),this.mesh=new ui(e,this.material),this.mesh.name="crystalSoul",this.mesh.renderOrder=0,this.mesh.layers.set(2)}attachTo(e,t){this._disposed||(e?this.mesh?(this.mesh.parent&&this.mesh.parent.remove(this.mesh),this.parentMesh=e,this._scene=t,t&&!this.mesh.parent&&t.add(this.mesh),this._syncPosition(),this.mesh.visible=!0):console.warn("[CrystalSoul] Cannot attach - mesh is null"):console.warn("[CrystalSoul] Cannot attach to null parent"))}_syncPosition(){this.parentMesh&&this.mesh&&(this.parentMesh.getWorldPosition(this.mesh.position),this.parentMesh.getWorldQuaternion(this.mesh.quaternion))}detach(){this.mesh&&(this.mesh.visible=!1,this.parentMesh=null)}update(e,t,n=1){if(!this.material||!this.material.uniforms)return;this._syncPosition();const{uniforms:a}=this.material;if(a.time&&(a.time.value+=e/1e3),a.emotionColor&&t){const e=a.emotionColor.value;e.r===t[0]&&e.g===t[1]&&e.b===t[2]||e.setRGB(t[0],t[1],t[2])}if(this._crossfade){const t=this._crossfade;if(t.progress+=e/t.duration,t.progress>=1)this._mixState.modeA=t.targetA,this._mixState.modeB=t.targetB,this._mixState.blend=t.targetBlend,a.uBehaviorMode&&(a.uBehaviorMode.value=t.targetA),a.uBehaviorModeB&&(a.uBehaviorModeB.value=t.targetB),a.uBehaviorBlend&&(a.uBehaviorBlend.value=t.targetBlend),a.uBehaviorCrossfade&&(a.uBehaviorCrossfade.value=0),this._crossfade=null;else{const e=t.progress,n=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2;a.uBehaviorCrossfade&&(a.uBehaviorCrossfade.value=n)}}this.mesh&&this.mesh.scale.setScalar(this.baseScale*n)}setSize(e){if(!this.mesh)return;const t=.05+.95*e;this.baseScale=t,this.mesh.scale.setScalar(t)}setEffects(e={}){if(!this.material||!this.material.uniforms)return;const{uniforms:t}=this.material;void 0!==e.driftEnabled&&t.driftEnabled&&(t.driftEnabled.value=e.driftEnabled?1:0),void 0!==e.driftSpeed&&t.driftSpeed&&(t.driftSpeed.value=Math.max(.1,Math.min(3,e.driftSpeed))),void 0!==e.crossWaveEnabled&&t.crossWaveEnabled&&(t.crossWaveEnabled.value=e.crossWaveEnabled?1:0),void 0!==e.crossWaveSpeed&&t.crossWaveSpeed&&(t.crossWaveSpeed.value=Math.max(.1,Math.min(3,e.crossWaveSpeed))),void 0!==e.phaseOffset1&&t.phaseOffset1&&(t.phaseOffset1.value=e.phaseOffset1),void 0!==e.phaseOffset2&&t.phaseOffset2&&(t.phaseOffset2.value=e.phaseOffset2),void 0!==e.phaseOffset3&&t.phaseOffset3&&(t.phaseOffset3.value=e.phaseOffset3),void 0!==e.colorDriftSpeed&&t.colorDriftSpeed&&(t.colorDriftSpeed.value=e.colorDriftSpeed),void 0!==e.colorDriftAmount&&t.colorDriftAmount&&(t.colorDriftAmount.value=Math.max(0,Math.min(1,e.colorDriftAmount))),void 0!==e.behaviorMode&&this.setBehavior(e.behaviorMode),void 0!==e.behaviorSpeed&&Ty(this.material,0,e.behaviorSpeed),void 0!==e.baselineStrength&&t.uBaselineStrength&&(t.uBaselineStrength.value=Math.max(0,Math.min(1,e.baselineStrength))),void 0!==e.mixA&&void 0!==e.mixB&&this.setMix(e.mixA,e.mixB,e.mixBlend??.5)}setMix(e,t,n,a=2e3){if(!this.material?.uniforms)return;const i=this.material.uniforms,r=Cy(e),s=Cy(t),o=Math.max(0,Math.min(1,n));if(this._crossfade||r!==this._mixState.modeA||s!==this._mixState.modeB||o!==this._mixState.blend){if(a<=0)return this._mixState.modeA=r,this._mixState.modeB=s,this._mixState.blend=o,i.uBehaviorMode&&(i.uBehaviorMode.value=r),i.uBehaviorModeB&&(i.uBehaviorModeB.value=s),i.uBehaviorBlend&&(i.uBehaviorBlend.value=o),i.uBehaviorCrossfade&&(i.uBehaviorCrossfade.value=0),void(this._crossfade=null);if(this._crossfade){const e=this._crossfade;this._mixState.modeA=e.targetA,this._mixState.modeB=e.targetB,this._mixState.blend=e.targetBlend,i.uBehaviorMode&&(i.uBehaviorMode.value=e.targetA),i.uBehaviorModeB&&(i.uBehaviorModeB.value=e.targetB),i.uBehaviorBlend&&(i.uBehaviorBlend.value=e.targetBlend),i.uBehaviorCrossfade&&(i.uBehaviorCrossfade.value=0),this._crossfade=null}i.uBehaviorModeC&&(i.uBehaviorModeC.value=r),i.uBehaviorModeD&&(i.uBehaviorModeD.value=s),i.uBehaviorBlendCD&&(i.uBehaviorBlendCD.value=o),i.uBehaviorCrossfade&&(i.uBehaviorCrossfade.value=0),this._crossfade={targetA:r,targetB:s,targetBlend:o,progress:0,duration:a}}}setBehavior(e,t,n=2e3){if(void 0!==t&&Ty(this.material,0,t),void 0!==e){const t=Cy(e);this.setMix(t,t,0,n)}}setColor(e){this.material&&this.material.uniforms&&this.material.uniforms.emotionColor&&this.material.uniforms.emotionColor.value.setRGB(e[0],e[1],e[2])}setBlendLayers(e){if(!this.material||!this.material.uniforms)return;const t=this.material.uniforms;e[0]?(t.blendLayer1Mode&&(t.blendLayer1Mode.value=e[0].mode??0),t.blendLayer1Strength&&(t.blendLayer1Strength.value=e[0].strength??0),t.blendLayer1Enabled&&(t.blendLayer1Enabled.value=e[0].enabled?1:0)):t.blendLayer1Enabled&&(t.blendLayer1Enabled.value=0),e[1]?(t.blendLayer2Mode&&(t.blendLayer2Mode.value=e[1].mode??0),t.blendLayer2Strength&&(t.blendLayer2Strength.value=e[1].strength??0),t.blendLayer2Enabled&&(t.blendLayer2Enabled.value=e[1].enabled?1:0)):t.blendLayer2Enabled&&(t.blendLayer2Enabled.value=0)}isAttached(){return null!==this.parentMesh&&null!==this.mesh&&null!==this.mesh.parent}setVisible(e){this.mesh&&(this.mesh.visible=e)}setGhostMode(e){this.material&&this.material.uniforms&&this.material.uniforms.ghostMode&&(this.material.uniforms.ghostMode.value=e?1:0)}setBaseOpacity(e){this.material&&this.material.uniforms&&this.material.uniforms.baseOpacity&&(this.material.uniforms.baseOpacity.value=Math.max(0,Math.min(1,e)))}dispose(){if(this._disposed)return;this._disposed=!0;const e=this.mesh,t=this.material;e?.parent&&e.parent.remove(e),e&&(e.visible=!1),this.mesh=null,this.material=null,this.parentMesh=null,requestAnimationFrame(()=>{e?.geometry&&e.geometry.dispose(),t&&t.dispose()})}}class Iy{constructor(e=50,t={}){this.maxParticles=e,this.options=t,this.geometry=null,this.material=null,this.points=null,this.positions=null,this.sizes=null,this.colors=null,this.alphas=null,this.glowIntensities=null,this.depths=null,this.styles=null,this.particleCount=0,this.gestureEffects={firefly:!1,flicker:!1,shimmer:!1,glow:!1,time:0},this._initGeometry(),this._initMaterial(),this._initPoints()}_initGeometry(){this.geometry=new ei;const{maxParticles:e}=this;this.positions=new Float32Array(3*e),this.sizes=new Float32Array(e),this.colors=new Float32Array(3*e),this.alphas=new Float32Array(e),this.glowIntensities=new Float32Array(e),this.depths=new Float32Array(e),this.styles=new Float32Array(e),this.geometry.setAttribute("position",new Wa(this.positions,3)),this.geometry.setAttribute("size",new Wa(this.sizes,1)),this.geometry.setAttribute("customColor",new Wa(this.colors,3)),this.geometry.setAttribute("alpha",new Wa(this.alphas,1)),this.geometry.setAttribute("glowIntensity",new Wa(this.glowIntensities,1)),this.geometry.setAttribute("depth",new Wa(this.depths,1)),this.geometry.setAttribute("style",new Wa(this.styles,1)),this.geometry.attributes.position.setUsage(gt),this.geometry.attributes.size.setUsage(gt),this.geometry.attributes.customColor.setUsage(gt),this.geometry.attributes.alpha.setUsage(gt),this.geometry.attributes.glowIntensity.setUsage(gt),this.geometry.attributes.depth.setUsage(gt),this.geometry.attributes.style.setUsage(gt),this.geometry.setDrawRange(0,0)}_initMaterial(){this.material=new bi({uniforms:{coreScale:{value:1},viewportHeight:{value:600},pixelRatio:{value:1}},vertexShader:"\n/**\n * Particle Vertex Shader - Simple 2D-style particles in 3D space\n * Matches the 2D canvas particle appearance\n */\n\n// Per-particle attributes\nattribute float size;\nattribute vec3 customColor;\nattribute float alpha;\nattribute float glowIntensity;\nattribute float style;  // 0.0 = solid/gradient, 1.0 = cell-shaded (ring with transparent center)\n\n// Uniforms\nuniform float coreScale;\nuniform float viewportHeight;\nuniform float pixelRatio;\n\n// Varying to fragment shader\nvarying vec3 vColor;\nvarying float vAlpha;\nvarying float vGlowIntensity;\nvarying float vStyle;\n\nvoid main() {\n    // Pass attributes to fragment shader\n    vColor = customColor;\n    vAlpha = alpha;\n    vGlowIntensity = glowIntensity;\n    vStyle = style;\n\n    // Calculate position in clip space\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n    // Calculate point size with perspective scaling\n    float perspectiveScale = coreScale * (75.0 / length(mvPosition.xyz)) * (viewportHeight / 600.0) / pixelRatio;\n    gl_PointSize = size * perspectiveScale;\n\n    // Final position\n    gl_Position = projectionMatrix * mvPosition;\n}\n",fragmentShader:"\n/**\n * Particle Fragment Shader - Solid colored circles matching 2D appearance\n * Uses premultiplied alpha for proper blending\n */\n\nvarying vec3 vColor;\nvarying float vAlpha;\nvarying float vGlowIntensity;\nvarying float vStyle;\n\nvoid main() {\n    // Distance from center (0 at center, 0.5 at edge)\n    vec2 center = gl_PointCoord - vec2(0.5);\n    float dist = length(center);\n\n    // Hard circle cutoff - discard everything outside\n    if (dist > 0.45) {\n        discard;\n    }\n\n    vec3 finalColor = vColor;\n\n    // Base opacity from particle (already includes baseOpacity variation)\n    float alpha = vAlpha;\n\n    // Gesture glow boost\n    if (vGlowIntensity >= 2.0) {\n        float gestureBoost = (vGlowIntensity - 2.0) / 13.0;\n        finalColor *= (1.0 + gestureBoost * 0.5);\n        alpha = min(alpha * (1.0 + gestureBoost * 0.3), 1.0);\n    }\n\n    // Cell-shaded particles are slightly more opaque\n    float opacityBoost = vStyle > 0.5 ? 1.0 : 0.85;\n    alpha *= opacityBoost;\n\n    // Output with proper alpha for blending\n    // Premultiply alpha for correct compositing\n    gl_FragColor = vec4(finalColor * alpha, alpha);\n}\n",transparent:!0,blending:5,blendSrc:h,blendDst:m,blendSrcAlpha:h,blendDstAlpha:m,depthWrite:!1,depthTest:!0})}_initPoints(){this.points=new $r(this.geometry,this.material),this.points.frustumCulled=!0}updateParticles(e,t,n,a,i,r,s,o,l){this.particleCount=Math.min(e.length,this.maxParticles),void 0!==o&&(this.material.uniforms.coreScale.value=o),a&&a.height&&(this.material.uniforms.viewportHeight.value=a.height),this.options.renderer&&(this.material.uniforms.pixelRatio.value=this.options.renderer.getPixelRatio()),this.gestureEffects.time+=.016,this.gestureEffects.time>2*Math.PI&&(this.gestureEffects.time=this.gestureEffects.time%(2*Math.PI)),i&&r&&t.updateRotationState(i,r,s);for(let i=0;i<this.particleCount;i++){const r=e[i];if(!r.isAlive()){this.alphas[i]=0;continue}const s=t.translate2DTo3D(r,n,a);if(("crystal"===l||"heart"===l||"rough"===l)&&s.z>.15){this.alphas[i]=0;continue}const o=3*i;this.positions[o+0]=s.x,this.positions[o+1]=s.y,this.positions[o+2]=s.z;const c=r.getDepthAdjustedSize?r.getDepthAdjustedSize():r.size,h="popcorn"===r.behavior?1.2:.85;this.sizes[i]=c*h;const d=this._parseColor(r.color||"#ffffff"),u=3*i;this.colors[u+0]=d.r,this.colors[u+1]=d.g,this.colors[u+2]=d.b,this.alphas[i]=r.opacity*(r.baseOpacity||1);let p=r.hasGlow?1*(r.glowSizeMultiplier||1.5):0;p=this._applyGestureEffects(r,p,i),this.glowIntensities[i]=p;const m=.5*(1-r.z);this.depths[i]=Math.max(0,Math.min(1,m)),this.styles[i]=r.isCellShaded?1:0}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.size.needsUpdate=!0,this.geometry.attributes.customColor.needsUpdate=!0,this.geometry.attributes.alpha.needsUpdate=!0,this.geometry.attributes.glowIntensity.needsUpdate=!0,this.geometry.attributes.depth.needsUpdate=!0,this.geometry.attributes.style.needsUpdate=!0,this.geometry.setDrawRange(0,this.particleCount)}_applyGestureEffects(e,t,n){let a=t;if(this.gestureEffects.firefly){const t=(.01*e.x+.01*e.y+.1*e.size)%(2*Math.PI),n=2+.5*(Math.sin(3*this.gestureEffects.time+t)+1)*10;a=Math.max(a,n)}if(this.gestureEffects.flicker){const t=(.02*e.x+.02*e.y)%(2*Math.PI),i=15*this.gestureEffects.time,r=.5*(Math.sin(i+t)+1),s=Math.floor(10*i+n),o=2+10*(.3*r+.5*(Math.sin(123.456*s)+1)*.7);a=Math.max(a,o)}if(this.gestureEffects.shimmer){const t=e.x-(this.gestureEffects.centerX||0),n=e.y-(this.gestureEffects.centerY||0),i=Math.sqrt(t*t+n*n)/200,r=2+.5*(Math.sin(3*this.gestureEffects.time-i)+1)*8;a=Math.max(a,r)}if(this.gestureEffects.glow){const e=this.gestureEffects.glowProgress||0,t=3+12*Math.sin(e*Math.PI);a=Math.max(a,t)}return a}_parseColor(e){const t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t?{r:parseInt(t[1],16)/255,g:parseInt(t[2],16)/255,b:parseInt(t[3],16)/255}:{r:1,g:1,b:1}}setGestureEffects(e){if(!e)return this.gestureEffects.firefly=!1,this.gestureEffects.flicker=!1,this.gestureEffects.shimmer=!1,void(this.gestureEffects.glow=!1);this.gestureEffects.firefly=e.fireflyEffect||!1,this.gestureEffects.flicker=e.flickerEffect||!1,this.gestureEffects.shimmer=e.shimmerEffect||!1,this.gestureEffects.glow=e.glowEffect||!1,this.gestureEffects.glowProgress=e.glowProgress,this.gestureEffects.centerX=e.centerX,this.gestureEffects.centerY=e.centerY}getPoints(){return this.points}setVisible(e){this.points.visible=e}resize(e){e!==this.maxParticles&&(this.geometry&&this.geometry.dispose(),this.maxParticles=e,this._initGeometry(),this.points&&(this.points.geometry=this.geometry))}cleanupParticleStates(e){for(const t of e)!t.isAlive()&&t.behaviorData&&(t.behaviorData.direction3D&&(t.behaviorData.direction3D=null),t.behaviorData.orbitPlane&&(t.behaviorData.orbitPlane=null),t.behaviorData.orbitPath&&(t.behaviorData.orbitPath=null),t.behaviorData=null)}dispose(){this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose(),this.positions=null,this.sizes=null,this.colors=null,this.alphas=null,this.glowIntensities=null,this.depths=null,this.styles=null}}class ky{constructor(){this.cachedConfigs=new Map,this.maxCacheSize=100}calculate(e,t=null){const n=`${e}:${t||"none"}`;if(this.cachedConfigs.has(n))return this.cachedConfigs.get(n);const a=np(e);if(!a)return console.warn(`[ParticleEmotionCalculator] Unknown emotion: ${e}`),this._getDefaultConfig();const i=this._extractBaseConfig(a,e),r=this._applyUndertoneModifiers(i,t),s=this._applySpecialBehaviors(r,e);if(this.cachedConfigs.size>=this.maxCacheSize){const e=this.cachedConfigs.keys().next().value;this.cachedConfigs.delete(e)}return this.cachedConfigs.set(n,s),s}_extractBaseConfig(e,t){const n=e.visual||{};return{behavior:n.particleBehavior||"ambient",rate:n.particleRate||1,min:void 0!==n.minParticles?n.minParticles:0,max:void 0!==n.maxParticles?n.maxParticles:10,colors:n.particleColors||null,emotion:t}}_applyUndertoneModifiers(e,t){if(!t)return e;const n=fp(t);if(!n||!n.particles)return e;const a=n.particles,i={...e};return a.behaviorOverride&&(i.behavior=a.behaviorOverride),a.rateMultiplier&&(i.rate=e.rate*a.rateMultiplier,i.max=Math.floor(e.max*a.rateMultiplier)),void 0!==a.minParticles&&(i.min=a.minParticles),void 0!==a.maxParticles&&(i.max=a.maxParticles),i}_applySpecialBehaviors(e,t){return"zen"===t?{...e,specialBehavior:"zen-mixing"}:e}selectZenBehavior(){return Math.random()<.6?"falling":"orbiting"}_getDefaultConfig(){return{behavior:"ambient",rate:1,min:0,max:10,colors:null,emotion:"neutral"}}clearCache(){this.cachedConfigs.clear()}getCacheSize(){return this.cachedConfigs.size}}class Ry{constructor(){this.previousGesture=null}extract(e,t){if(!e||0===e.length)return this.previousGesture=null,null;const n=e[0],a=this._calculateProgress(n,t);if(a>=1)return this.previousGesture=null,null;const i=this._extractGestureName(n);if(!i)return null;const r=this._buildGestureMotion(n,i);return this.previousGesture=i,{motion:r,progress:a,config:n.config||{},gestureName:i,animation:n}}_calculateProgress(e,t){const n=(t-e.startTime)/e.duration;return Math.max(0,Math.min(1,n))}_extractGestureName(e){return e.gestureName||e.name||e.config?.gestureName||null}_buildGestureMotion(e,t){const n=e.config||{};return{type:t,amplitude:n.amplitude||1,strength:n.strength||1,wobbleAmount:n.wobbleAmount||0,duration:e.duration}}hasGestureChanged(e){return!(!e&&!this.previousGesture||(e||!this.previousGesture)&&(!e||this.previousGesture)&&e.gestureName===this.previousGesture)}extractAll(e,t){if(!e||0===e.length)return[];const n=[];for(const a of e){const e=this._calculateProgress(a,t);if(e>=1)continue;const i=this._extractGestureName(a);if(!i)continue;const r=this._buildGestureMotion(a,i);n.push({motion:r,progress:e,config:a.config||{},gestureName:i,animation:a})}return n}reset(){this.previousGesture=null}}class zy{constructor(){this.effectMap={sparkle:this.buildFireflyEffect.bind(this),twinkle:this.buildFireflyEffect.bind(this),flicker:this.buildFlickerEffect.bind(this),shimmer:this.buildShimmerEffect.bind(this),glow:this.buildGlowEffect.bind(this),burst:this.buildGlowEffect.bind(this),flash:this.buildFlickerEffect.bind(this)}}build(e,t,n){if(!e||!e.motion)return null;const{gestureName:a}=e,i=this.effectMap[a];return i?i(e,t,n):null}buildFireflyEffect(e,t,n){const a=e.config||{};return{fireflyEffect:!0,fireflyTime:.001*Date.now(),particleGlow:a.particleGlow||2,centerX:t,centerY:n}}buildFlickerEffect(e,t,n){const a=e.config||{};return{flickerEffect:!0,flickerTime:.001*Date.now(),particleGlow:a.particleGlow||2,centerX:t,centerY:n}}buildShimmerEffect(e,t,n){const a=e.config||{},i=e.progress||0;return{shimmerEffect:!0,shimmerTime:.001*Date.now(),shimmerWave:i*Math.PI*2,particleGlow:a.particleGlow||1.2,centerX:t,centerY:n}}buildGlowEffect(e,t,n){const a=e.config||{};return{glowEffect:!0,glowProgress:e.progress||0,particleGlow:a.particleGlow||2,centerX:t,centerY:n}}registerEffect(e,t){this.effectMap[e]=t.bind(this)}hasEffect(e){return!!this.effectMap[e]}getEffectGestures(){return Object.keys(this.effectMap)}buildAll(e,t,n){if(!e||0===e.length)return[];const a=[];for(const i of e){const e=this.build(i,t,n);e&&a.push(e)}return a}mergeEffects(e){if(!e||0===e.length)return null;if(1===e.length)return e[0];const t={};for(const n of e)Object.assign(t,n);return t}destroy(){this.effectMap=null}}class Fy{constructor(e,t,n){this.particleSystem=e,this.translator=t,this.renderer=n,this.emotionCalculator=new ky,this.gestureExtractor=new Ry,this.effectsBuilder=new zy,this.currentEmotion=null,this.currentUndertone=null,this.currentConfig=null}update(e,t,n,a,i,r,s,o,l,c){void 0!==c&&this.translator.setCoreRadius3D(c);const h=this._updateEmotionConfig(t,n),d=this.gestureExtractor.extract(a,i);this._spawnParticles(h,e,s),this._updatePhysics(h,d,e,s,n),this._updateRendering(d,r,s,o,e,l)}_updateEmotionConfig(e,t){return this.currentEmotion===e&&this.currentUndertone===t||(this.currentEmotion=e,this.currentUndertone=t,this.currentConfig=this.emotionCalculator.calculate(e,t),this.particleSystem.clear()),this.currentConfig}_spawnParticles(e,t,n){const a=n.width/2,i=n.height/2;let r=e.behavior;"zen-mixing"===e.specialBehavior&&(r=this.emotionCalculator.selectZenBehavior()),this.particleSystem.spawn(r,e.emotion,e.rate,a,i,t,null,e.min,e.max,1,1,e.colors,this.currentUndertone)}_updatePhysics(e,t,n,a,i){const r=a.width/2,s=a.height/2,o=i?{undertone:i}:null;this.particleSystem.update(n,r,s,t?t.motion:null,t?t.progress:0,o)}_updateRendering(e,t,n,a,i,r){const s=n.width/2,o=n.height/2,l=e?this.effectsBuilder.build(e,s,o):null;this.renderer.updateParticles(this.particleSystem.particles,this.translator,t,n,a,i,e,r,this.geometryType),this.renderer.setGestureEffects(l)}setEmotion(e,t=null){this.currentEmotion=null,this.currentUndertone=null}setGeometryType(e){this.geometryType=e}clear(){this.particleSystem.clear()}setEnabled(e){this.renderer.setVisible(e),e||this.clear()}getParticleCount(){return this.particleSystem.particles.length}getCurrentConfig(){return this.currentConfig}registerEffect(e,t){this.effectsBuilder.registerEffect(e,t)}destroy(){this.particleSystem.destroy(),this.renderer.dispose(),this.translator&&(this.translator.dispose?.(),this.translator=null),this.emotionCalculator.clearCache(),this.emotionCalculator=null,this.gestureExtractor.reset(),this.gestureExtractor=null,this.effectsBuilder&&(this.effectsBuilder.destroy?.(),this.effectsBuilder=null)}}const By={quartz:{sssStrength:.8,sssAbsorption:[2.8,2.9,3],sssScatterDistance:[.2,.2,.25],sssThicknessBias:.6,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.12,frostiness:.15,innerGlowStrength:.2,fresnelIntensity:1.5,causticIntensity:1.2},emerald:{sssStrength:2,sssAbsorption:[.05,4,.1],sssScatterDistance:[.1,.5,.1],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.2,innerGlowStrength:.15,fresnelIntensity:1.2,emotionColorBleed:.35},ruby:{sssStrength:1.8,sssAbsorption:[4,.03,.08],sssScatterDistance:[.4,.04,.08],sssThicknessBias:.65,sssThicknessScale:1.9,sssCurvatureScale:2.5,sssAmbient:.08,frostiness:.12,innerGlowStrength:.12,fresnelIntensity:1.2,causticIntensity:1.15,emotionColorBleed:.35},sapphire:{sssStrength:2.2,sssAbsorption:[.15,.4,4],sssScatterDistance:[.1,.15,.5],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.18,innerGlowStrength:.15,fresnelIntensity:1.3,emotionColorBleed:.35},amethyst:{sssStrength:2.5,sssAbsorption:[3,.05,4.5],sssScatterDistance:[.4,.05,.5],sssThicknessBias:.7,sssThicknessScale:2,sssCurvatureScale:3,sssAmbient:.08,frostiness:.18,innerGlowStrength:.12,fresnelIntensity:1.4,emotionColorBleed:.35}},Ly="\n// \n// DEFORMATION UNIFORMS - Localized vertex displacement for impacts\n// \nuniform float deformationStrength;  // 0-2+ (intensity of dent)\nuniform vec3 impactPoint;           // Impact position in MESH-LOCAL space\n                                    // Transformed by JS to account for camera direction\nuniform float deformationFalloff;   // Radius of influence (0.1-0.5 typical)\n",Ny={deformationStrength:0,impactPoint:[0,0,0],deformationFalloff:.5},Vy={crackImpact0:[0,0,0],crackImpact1:[0,0,0],crackImpact2:[0,0,0],crackDirection0:[0,0,0],crackDirection1:[0,0,0],crackDirection2:[0,0,0],crackParams0:[0,0,0],crackParams1:[0,0,0],crackParams2:[0,0,0],crackNumImpacts:0,crackColor:[.15,.08,.05],crackGlowColor:[1,.6,.2],crackGlowStrength:.5},Uy=`\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n${Ly}\n\n\n// \n// DEFORMATION - Localized dent toward mesh center\n// \n\nvec3 calculateDeformation(vec3 pos) {\n    if (deformationStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Distance from this vertex to the impact point (both in mesh-local space)\n    float dist = length(pos - impactPoint);\n\n    // Falloff: 1.0 at impact point, 0.0 at falloff radius\n    // Use squared falloff for sharper edges\n    float t = dist / max(deformationFalloff, 0.001);\n    float falloff = max(0.0, 1.0 - t * t);\n\n    // Direction: push vertex INWARD toward mesh center\n    vec3 inward = -normalize(pos + vec3(0.0001));\n\n    // Depth of dent\n    float depth = deformationStrength * 0.15 * falloff;\n\n    return inward * depth;\n}\n\n\nvoid main() {\n    vUv = uv;\n\n    // Apply deformation to position (impactPoint pre-transformed by JS for tidal locking)\n    vec3 deformedPosition = position + calculateDeformation(position);\n\n    vPosition = deformedPosition;\n    vNormal = normalize(normalMatrix * normal);\n\n    vec4 mvPosition = modelViewMatrix * vec4(deformedPosition, 1.0);\n    vViewPosition = -mvPosition.xyz;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n`,Gy=`\nuniform float time;\nuniform vec3 emotionColor;\nuniform float glowIntensity;\nuniform float opacity;\n\n// Crystal appearance controls\nuniform float frostiness;        // 0 = clear glass, 1 = fully frosted (default: 0.7)\nuniform float fresnelPower;      // Edge brightness falloff (default: 3.0)\nuniform float fresnelIntensity;  // Edge brightness strength (default: 1.2)\nuniform float innerGlowStrength; // How much inner soul shows through (default: 0.8)\nuniform float surfaceRoughness;  // Surface texture variation (default: 0.3)\n\n// Enhanced lighting controls\nuniform float shadowDarkness;     // How dark shadows can get (0-1, default: 0.4)\nuniform float specularIntensity;  // Edge highlight brightness (default: 0.8)\nuniform float specularPower;      // Specular falloff sharpness (default: 32.0)\nuniform float transmissionContrast; // Thin/thick brightness ratio (default: 1.5)\nuniform float minBrightness;      // Minimum brightness floor (default: 0.05)\n\n// Noise scale controls\nuniform float surfaceNoiseScale;  // Scale of surface frost pattern (default: 1.5)\nuniform float noiseFrequency;     // Frequency of hash noise pattern (default: 1.0)\n\n// Internal caustics - light pooling inside the gem\nuniform float causticIntensity;   // Brightness of internal caustics (default: 0.4)\nuniform float causticScale;       // Scale of caustic pattern (default: 3.0)\nuniform float causticSpeed;       // Animation speed of caustics (default: 0.15)\n\n// Texture\nuniform sampler2D crystalTexture;\nuniform float textureStrength;    // How much texture affects appearance (default: 0.5)\n\n// Soul refraction - samples soul rendered to texture with optical distortion\nuniform sampler2D soulTexture;    // Soul mesh rendered to texture\nuniform vec2 resolution;          // Screen resolution for UV calculation\nuniform vec2 soulTextureSize;     // Soul render target size (may differ from screen)\nuniform vec2 soulScreenCenter;    // Soul center projected to screen UV (0-1 range)\nuniform float refractionIndex;    // Index of refraction (1.5 glass, 2.4 diamond)\nuniform float refractionStrength; // Distortion magnitude (0.1-0.5)\n\n// Physically-based subsurface scattering\nuniform float sssStrength;            // Overall SSS intensity (0-1)\nuniform vec3 sssAbsorption;           // Absorption coefficients per RGB channel\nuniform vec3 sssScatterDistance;      // Mean free path / scatter radius per RGB\nuniform float sssThicknessBias;       // Thickness offset (0-1)\nuniform float sssThicknessScale;      // Thickness multiplier\nuniform float sssCurvatureScale;      // How much curvature affects SSS\nuniform float sssAmbient;             // Ambient SSS contribution\nuniform vec3 sssLightDir;             // Primary light direction for SSS\nuniform vec3 sssLightColor;           // Light color for SSS\n\n// Emotion color bleed - how much soul color tints the gem material\nuniform float emotionColorBleed;      // 0 = gem color only, 1 = full emotion tint (default: 0.0)\n\n// Component-specific blend layers\n// Shell layers - affect the frosted crystal shell\nuniform float shellLayer1Mode;\nuniform float shellLayer1Strength;\nuniform float shellLayer1Enabled;\nuniform float shellLayer2Mode;\nuniform float shellLayer2Strength;\nuniform float shellLayer2Enabled;\n\n// Soul layers - affect the inner glowing soul color\nuniform float soulLayer1Mode;\nuniform float soulLayer1Strength;\nuniform float soulLayer1Enabled;\nuniform float soulLayer2Mode;\nuniform float soulLayer2Strength;\nuniform float soulLayer2Enabled;\n\n// Rim layers - affect the fresnel rim glow\nuniform float rimLayer1Mode;\nuniform float rimLayer1Strength;\nuniform float rimLayer1Enabled;\nuniform float rimLayer2Mode;\nuniform float rimLayer2Strength;\nuniform float rimLayer2Enabled;\n\n// SSS layers - affect subsurface scattering contribution\nuniform float sssLayer1Mode;\nuniform float sssLayer1Strength;\nuniform float sssLayer1Enabled;\nuniform float sssLayer2Mode;\nuniform float sssLayer2Strength;\nuniform float sssLayer2Enabled;\n\n${Ly}\n\n\n// \n// OBJECT-SPACE CRACK UNIFORMS - Persistent damage that rotates with mesh\n// \n\n// Impact positions in MESH-LOCAL space (pre-transformed by JS)\nuniform vec3 crackImpact0;\nuniform vec3 crackImpact1;\nuniform vec3 crackImpact2;\n\n// Impact directions in MESH-LOCAL space (crack spread direction)\nuniform vec3 crackDirection0;\nuniform vec3 crackDirection1;\nuniform vec3 crackDirection2;\n\n// Impact parameters: x=propagation, y=amount, z=seed\nuniform vec3 crackParams0;\nuniform vec3 crackParams1;\nuniform vec3 crackParams2;\n\n// Number of active impacts (0-3)\nuniform int crackNumImpacts;\n\n// Visual parameters\nuniform vec3 crackColor;       // Dark crack interior color\nuniform vec3 crackGlowColor;   // Edge emission color\nuniform float crackGlowStrength;\n\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n// \n// NOISE FUNCTIONS for surface variation and frosted effect\n// \n\n// Simple 3D noise for frosted surface\nfloat hash(vec3 p) {\n    p = p * noiseFrequency;  // Apply frequency control\n    p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat noise3D(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // Smoothstep\n\n    float n = mix(\n        mix(\n            mix(hash(i), hash(i + vec3(1, 0, 0)), f.x),\n            mix(hash(i + vec3(0, 1, 0)), hash(i + vec3(1, 1, 0)), f.x),\n            f.y\n        ),\n        mix(\n            mix(hash(i + vec3(0, 0, 1)), hash(i + vec3(1, 0, 1)), f.x),\n            mix(hash(i + vec3(0, 1, 1)), hash(i + vec3(1, 1, 1)), f.x),\n            f.y\n        ),\n        f.z\n    );\n    return n;\n}\n\n// Single-octave noise for frosted texture (was 3-octave FBM  at 0.03 strength\n// the extra octaves were imperceptible)\nfloat fbm(vec3 p) {\n    return noise3D(p) * 0.5;\n}\n\n// \n// BLEND MODES (from universal library)\n// \n${pu}\n\n// \n// ENHANCED LIGHTING FUNCTIONS\n// \n\n// Calculate ambient occlusion from geometry\nfloat calculateAO(vec3 normal, vec3 viewDir, vec3 position) {\n    // Faces pointing away from view are in shadow\n    float viewAO = max(0.0, dot(normal, viewDir));\n\n    // Use light direction for directional shadow instead of gravity\n    // This creates shadows on the side away from light\n    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8)); // Match sssLightDir default\n    float lightAO = dot(normal, lightDir) * 0.5 + 0.5;\n\n    // Combine AO factors - no gravity term\n    return viewAO * 0.5 + lightAO * 0.5;\n}\n\n// Calculate specular highlights on facet edges\nfloat calculateFacetSpecular(vec3 normal, vec3 viewDir, vec3 lightDir, float power) {\n    // Detect facet edges from normal discontinuities\n    float edgeDetect = length(fwidth(normal)) * 15.0;\n    edgeDetect = smoothstep(0.1, 0.5, edgeDetect);\n\n    // Standard Blinn-Phong specular\n    vec3 halfVec = normalize(lightDir + viewDir);\n    float specular = pow(max(0.0, dot(normal, halfVec)), power);\n\n    // Boost specular on edges\n    specular += edgeDetect * 0.5;\n\n    return specular;\n}\n\n// Calculate "fire" - intense sparkle points that real gems exhibit\n// These are concentrated, view-dependent highlights from light dispersion\nfloat calculateFire(vec3 normal, vec3 viewDir, vec3 lightDir) {\n    // Primary fire highlight  reduced exponent (256 vs 512), still pinpoint\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float fire1 = pow(max(0.0, dot(reflectDir, viewDir)), 256.0);\n\n    // Secondary fire from different light angle\n    vec3 lightDir2 = normalize(vec3(-0.3, 0.8, 0.5));\n    vec3 reflectDir2 = reflect(-lightDir2, normal);\n    float fire2 = pow(max(0.0, dot(reflectDir2, viewDir)), 128.0);\n\n    // Combine fire points (was 3, now 2  third added minimal visible sparkle)\n    float fire = fire1 + fire2 * 0.7;\n\n    // Facet edges catch more fire  kept mild to avoid bloom strobe\n    // (fwidth jitters per-frame on rotating geometry, amplifying the pow-512 strobing)\n    float edgeFactor = length(fwidth(normal)) * 8.0;\n    fire *= (1.0 + edgeFactor * 0.5);\n\n    return fire;\n}\n\n// Calculate bright lines along facet edges where bevels catch light\nfloat calculateFacetEdgeLines(vec3 normal, vec3 viewDir, vec3 lightDir) {\n    // Detect edges from normal discontinuities\n    float edgeMag = length(fwidth(normal));\n\n    // Sharp threshold to create distinct lines\n    float edgeLine = smoothstep(0.02, 0.08, edgeMag);\n\n    // Modulate by light angle - edges facing light are brighter\n    float lightFacing = max(0.0, dot(normal, lightDir));\n    edgeLine *= (0.3 + lightFacing * 0.7);\n\n    // View-dependent - edges perpendicular to view are more visible\n    float viewPerp = 1.0 - abs(dot(normal, viewDir));\n    edgeLine *= (0.5 + viewPerp * 0.5);\n\n    return edgeLine;\n}\n\n// Calculate light transmission based on thickness\nfloat calculateTransmission(vec3 position, vec3 normal, vec3 viewDir, float contrast) {\n    // Thickness estimation - edges are thin, center is thick\n    float distFromCenter = length(position);\n    float thickness = smoothstep(0.0, 0.6, distFromCenter);\n\n    // View angle affects perceived thickness\n    float viewThickness = 1.0 - abs(dot(normal, viewDir));\n    thickness = mix(thickness, viewThickness, 0.5);\n\n    // Thin areas transmit more light (brighter), thick areas are darker\n    float transmission = 1.0 - thickness * contrast * 0.5;\n\n    return clamp(transmission, 0.3, 1.5);\n}\n\n// \n// PHYSICALLY-BASED SUBSURFACE SCATTERING\n// \n\n// \n// PHYSICALLY-BASED SUBSURFACE SCATTERING\n// Based on Disney's Burley Normalized Diffusion (2015)\n// \n\n// SSS Uniforms - declare these in your shader\n// uniform float sssStrength;           // Overall SSS intensity (0-1)\n// uniform vec3 sssAbsorption;          // Absorption coefficients per RGB channel\n// uniform vec3 sssScatterDistance;     // Mean free path / scatter radius per RGB\n// uniform float sssThicknessBias;      // Thickness offset (0-1)\n// uniform float sssThicknessScale;     // Thickness multiplier\n// uniform float sssCurvatureScale;     // How much curvature affects SSS\n// uniform float sssAmbient;            // Ambient SSS contribution\n// uniform vec3 sssLightDir;            // Primary light direction for SSS\n// uniform vec3 sssLightColor;          // Light color for SSS\n\n/**\n * Estimate local thickness from geometry\n * Uses the relationship between view angle and surface normal\n * Combined with a simple depth approximation\n *\n * @param normal - Surface normal in view space\n * @param viewDir - View direction\n * @param position - Vertex position (for depth-based estimation)\n * @param thicknessBias - Base thickness value\n * @param thicknessScale - Thickness multiplier\n * @return Estimated thickness (0-1)\n */\nfloat estimateThickness(vec3 normal, vec3 viewDir, vec3 position, float thicknessBias, float thicknessScale) {\n    // Method 1: View-dependent thickness\n    // Surfaces facing away from viewer are "thicker" (light travels further)\n    float viewThickness = 1.0 - abs(dot(normal, viewDir));\n\n    // Method 2: Position-based depth (simple spherical assumption)\n    // Objects are thinner at edges, thicker in center\n    float posDepth = 1.0 - length(position) * 0.5;\n    posDepth = clamp(posDepth, 0.0, 1.0);\n\n    // Method 3: Curvature hint from normal variation\n    // High-frequency normal changes indicate thin areas (edges, details)\n    // This is approximated by the gradient of the normal\n    float curvatureHint = length(fwidth(normal)) * 10.0;\n    curvatureHint = 1.0 - clamp(curvatureHint, 0.0, 1.0);\n\n    // Combine methods with weighting\n    float thickness = viewThickness * 0.4 + posDepth * 0.4 + curvatureHint * 0.2;\n\n    // Apply bias and scale\n    thickness = thicknessBias + thickness * thicknessScale;\n\n    return clamp(thickness, 0.01, 1.0);\n}\n\n/**\n * Beer's Law absorption - light attenuates exponentially through material\n * Different wavelengths absorb at different rates, creating color shifts\n *\n * @param thickness - Distance light travels through material\n * @param absorption - Absorption coefficients per RGB (higher = more absorbed)\n * @return Transmittance per RGB channel (0-1)\n */\nvec3 beersLawAbsorption(float thickness, vec3 absorption) {\n    // Beer-Lambert Law: T = e^(- * d)\n    // Where  is absorption coefficient, d is distance\n    return exp(-absorption * thickness * 4.0);\n}\n\n/**\n * Burley Normalized Diffusion Profile\n * Disney's approximation of the full BSSRDF, energy-conserving\n *\n * R(r) = A * s * (e^(-s*r) + e^(-s*r/3)) / (8r)\n *\n * @param radius - Distance from entry point (normalized)\n * @param scatterDist - Mean free path / diffusion length\n * @return Diffusion weight at this radius\n */\nfloat burleyDiffusionProfile(float radius, float scatterDist) {\n    // Prevent division by zero\n    float r = max(radius, 0.001);\n    float s = 1.0 / max(scatterDist, 0.001);\n\n    // Burley's two-term approximation\n    float term1 = exp(-s * r);\n    float term2 = exp(-s * r / 3.0);\n\n    // Normalized profile (simplified, without 8r for real-time)\n    float profile = (term1 + term2) * s * 0.25;\n\n    return profile;\n}\n\n/**\n * Christensen-Burley Normalized Diffusion\n * Improved version with better energy conservation\n *\n * @param radius - Distance from entry point\n * @param A - Surface albedo\n * @param d - Diffusion length (mean free path)\n * @return RGB diffusion weights\n */\nvec3 christensenBurleyDiffusion(float radius, vec3 A, vec3 d) {\n    vec3 result = vec3(0.0);\n\n    // Per-channel diffusion (different scatter distances for RGB)\n    for (int i = 0; i < 3; i++) {\n        float s = 1.9 - A[i] + 3.5 * (A[i] - 0.8) * (A[i] - 0.8);\n        s = 1.0 / (s * max(d[i], 0.001));\n\n        float r = max(radius, 0.001);\n\n        // Two-exponential fit\n        float profile = s * (exp(-s * r) + exp(-s * r / 3.0)) / (8.0 * 3.14159 * r);\n\n        result[i] = profile;\n    }\n\n    return result;\n}\n\n/**\n * Calculate curvature factor for SSS intensity\n * SSS is more visible on curved surfaces (fingers, ears, edges)\n *\n * @param normal - Surface normal\n * @return Curvature factor (higher = more curved)\n */\nfloat calculateCurvature(vec3 normal) {\n    // Use screen-space derivatives to estimate curvature\n    vec3 dx = dFdx(normal);\n    vec3 dy = dFdy(normal);\n\n    // Curvature magnitude\n    float curvature = length(dx) + length(dy);\n\n    // Normalize to useful range\n    return clamp(curvature * 5.0, 0.0, 1.0);\n}\n\n/**\n * Full physically-based SSS calculation\n * Combines all components for realistic translucent materials\n *\n * @param normal - Surface normal (view space)\n * @param viewDir - View direction\n * @param position - Vertex position\n * @param lightDir - Light direction\n * @param lightColor - Light color\n * @param baseColor - Material base/albedo color\n * @param sssStrength - Overall SSS strength\n * @param absorption - Absorption coefficients RGB (inverted: higher = MORE of that color)\n * @param scatterDist - Scatter distance RGB (higher = more scatter)\n * @param thicknessBias - Base thickness\n * @param thicknessScale - Thickness multiplier\n * @param curvatureScale - Curvature influence\n * @param ambient - Ambient SSS contribution\n * @return Final SSS color contribution\n */\nvec3 calculatePhysicalSSS(\n    vec3 normal,\n    vec3 viewDir,\n    vec3 position,\n    vec3 lightDir,\n    vec3 lightColor,\n    vec3 baseColor,\n    float sssStrength,\n    vec3 absorption,\n    vec3 scatterDist,\n    float thicknessBias,\n    float thicknessScale,\n    float curvatureScale,\n    float ambient\n) {\n    if (sssStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // \n    // THICKNESS ESTIMATION\n    // \n    float thickness = estimateThickness(normal, viewDir, position, thicknessBias, thicknessScale);\n\n    // \n    // ABSORPTION COLOR (Beer's Law with artist-friendly values)\n    // Creates the characteristic color of translucent materials\n    // absorption values: high value = MORE of that color passes through (transmitted)\n    // This is inverted from physics but intuitive: jade has high green absorption\n    // \n    // Use absorption directly as transmittance - higher = more of that color shows\n    // Normalize to prevent any channel from dominating\n    float maxAbsorption = max(absorption.r, max(absorption.g, absorption.b));\n    vec3 normalizedTransmit = absorption / max(maxAbsorption, 0.001);\n\n    // Apply thickness-based falloff - thin areas show more color\n    float thicknessFactor = 1.0 - thickness * 0.3;\n    vec3 colorShift = normalizedTransmit * thicknessFactor;\n\n    // Ensure minimum color presence\n    colorShift = max(colorShift, vec3(0.15));\n\n    // \n    // SCATTER INTENSITY\n    // How much light scatters based on material properties\n    // \n    // Higher scatter distance = more light gets through, but keep it subtle\n    vec3 scatterIntensity = scatterDist * 0.8;\n    scatterIntensity = clamp(scatterIntensity, vec3(0.1), vec3(1.0));\n\n    // \n    // LIGHTING TERMS - Boosted for visibility\n    // \n\n    // Back-lighting: light passing through from behind (strongest SSS cue)\n    float NdotL = dot(normal, lightDir);\n    float backLight = max(0.0, -NdotL);\n    backLight = pow(backLight, 1.2) * 1.5;  // Boosted\n\n    // Wrap lighting: soft diffuse that wraps around\n    float wrapLight = (NdotL + 1.0) * 0.5;  // Full wrap, 0-1 range\n    wrapLight = wrapLight * wrapLight;\n\n    // View-dependent translucency (looking through thin parts)\n    float VdotL = dot(viewDir, -lightDir);\n    float translucency = pow(max(0.0, VdotL), 1.5) * 1.2;  // Boosted\n\n    // Edge glow (fresnel-like SSS at silhouettes)\n    float edgeGlow = pow(1.0 - abs(dot(normal, viewDir)), 2.0);\n\n    // \n    // THICKNESS-BASED TRANSMISSION\n    // Thin areas let more light through\n    // \n    float thinTransmission = 1.0 - thickness * 0.5;\n    thinTransmission = max(thinTransmission, 0.3);\n\n    // \n    // CURVATURE ENHANCEMENT\n    // \n    float curvature = calculateCurvature(normal);\n    float curvatureFactor = 1.0 + curvature * curvatureScale;\n\n    // \n    // COMBINE ALL TERMS\n    // \n\n    // Total light contribution (more additive for visibility)\n    float totalLight = backLight + translucency * 0.8 + wrapLight * 0.4 + edgeGlow * 0.5;\n    totalLight *= curvatureFactor * thinTransmission;\n\n    // Base SSS color - colorShift IS the tint (e.g., green for jade)\n    // Don't multiply by baseColor to avoid washing out with emotionColor\n    vec3 sssColor = colorShift * scatterIntensity;\n\n    // Ambient SSS (always visible, gives material its translucent look)\n    vec3 ambientSSS = sssColor * ambient;\n\n    // Direct SSS from lighting - subtle contribution\n    vec3 directSSS = sssColor * lightColor * totalLight * 0.5;\n\n    // Final combination\n    vec3 finalSSS = directSSS + ambientSSS;\n\n    // Apply overall strength (linear, no boost to prevent blowout)\n    return finalSSS * sssStrength;\n}\n\n/**\n * Simplified SSS for performance-critical scenarios\n * Uses pre-computed approximations\n *\n * @param normal - Surface normal\n * @param viewDir - View direction\n * @param lightDir - Light direction\n * @param thickness - Pre-computed or approximated thickness\n * @param baseColor - Material color\n * @param scatterColor - Scatter tint color\n * @param strength - SSS strength\n * @return SSS color contribution\n */\nvec3 calculateSimpleSSS(\n    vec3 normal,\n    vec3 viewDir,\n    vec3 lightDir,\n    float thickness,\n    vec3 baseColor,\n    vec3 scatterColor,\n    float strength\n) {\n    if (strength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Back-lighting\n    float backLight = pow(max(0.0, dot(viewDir, -lightDir)), 2.0);\n\n    // Transmittance (simplified Beer's law)\n    float transmit = exp(-thickness * 2.0);\n\n    // Edge enhancement\n    float edge = pow(1.0 - abs(dot(normal, viewDir)), 2.0);\n\n    // Combine\n    float sssIntensity = (backLight * transmit + edge * 0.3) * strength;\n\n    return mix(baseColor, scatterColor, 0.5) * sssIntensity;\n}\n\n\n// \n// DEFORMATION IMPACT GLOW\n// \n\n// \n// IMPACT GLOW - Localized bright spot at punch impact site\n// \n\nvec3 calculateImpactGlow(vec3 fragPos, vec3 emotionColor) {\n    if (deformationStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Distance from this fragment to the impact point (both in mesh-local space)\n    float impactDist = length(fragPos - impactPoint);\n    float impactT = impactDist / max(deformationFalloff, 0.001);\n    float impactFalloff = max(0.0, 1.0 - impactT * impactT);\n\n    // Bright glow at impact site\n    vec3 impactColor = mix(emotionColor, vec3(1.0), impactFalloff * 0.7);\n\n    return impactColor * impactFalloff * 1.5;\n}\n\n\n// \n// OBJECT-SPACE CRACK FUNCTIONS\n// \n\n// \n// OBJECT-SPACE CRACK FUNCTIONS\n// \n\n// Hash functions for procedural patterns\nfloat crackHash(vec3 p) {\n    p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec2 crackHash2(vec2 p) {\n    return vec2(\n        fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453),\n        fract(sin(dot(p, vec2(269.5, 183.3))) * 43758.5453)\n    );\n}\n\nfloat crackNoise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = mix(\n        mix(\n            mix(crackHash(i), crackHash(i + vec3(1, 0, 0)), f.x),\n            mix(crackHash(i + vec3(0, 1, 0)), crackHash(i + vec3(1, 1, 0)), f.x),\n            f.y\n        ),\n        mix(\n            mix(crackHash(i + vec3(0, 0, 1)), crackHash(i + vec3(1, 0, 1)), f.x),\n            mix(crackHash(i + vec3(0, 1, 1)), crackHash(i + vec3(1, 1, 1)), f.x),\n            f.y\n        ),\n        f.z\n    );\n    return n;\n}\n\n// Voronoi edge detection for crack patterns\nfloat crackVoronoiEdge(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float minDist = 1.0;\n    float secondDist = 1.0;\n\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 cellPoint = neighbor + crackHash2(i + neighbor) * 0.8;\n            float dist = length(f - cellPoint);\n            if (dist < minDist) {\n                secondDist = minDist;\n                minDist = dist;\n            } else if (dist < secondDist) {\n                secondDist = dist;\n            }\n        }\n    }\n    return secondDist - minDist;\n}\n\n// Generate crack pattern for a single impact in object space\n// Returns 0.0 where crack lines are, 1.0 where no cracks\nfloat singleObjectSpaceCrack(vec3 fragPos, vec3 impactPos, vec3 direction, float propagation, float seed) {\n    vec3 toFrag = fragPos - impactPos;\n    float distFromImpact = length(toFrag);\n\n    // Max spread radius - cover entire crystal mesh\n    // Crystal vertex positions: radius ~0.7, height -1.5 to +1.5\n    // Use very large radius to ensure visibility\n    float maxRadius = propagation * 3.0;\n\n    // Outside propagation radius = no crack (return 1.0)\n    if (distFromImpact > maxRadius) {\n        return 1.0;\n    }\n\n    // Normalized distance for falloff (0 at impact, 1 at edge)\n    float normalizedDist = distFromImpact / max(maxRadius, 0.001);\n\n    // Simple radial crack pattern - spoke lines radiating from impact\n    vec3 radialDir = normalize(toFrag + vec3(0.0001));\n    float angle = atan(radialDir.y, radialDir.x) + atan(radialDir.z, radialDir.x) * 0.5;\n\n    // Create spoke lines - we want lines where angle is near multiples of (2*PI/numSpokes)\n    float numSpokes = 8.0;\n    float spokeAngle = angle * numSpokes;\n    // spokeLine is low (near 0) at crack lines, high (near 1) between them\n    float spokeLine = abs(sin(spokeAngle + seed * 0.1));\n\n    // Concentric rings for "shattered glass" look\n    float ringFreq = 6.0;\n    float rings = abs(sin(distFromImpact * ringFreq + seed));\n\n    // Combine spokes and rings - crack where either is low\n    float pattern = min(spokeLine, rings);\n\n    // Fade crack intensity at edges of propagation radius\n    float edgeFade = 1.0 - smoothstep(0.7, 1.0, normalizedDist);\n\n    // Return the raw pattern value (0 = crack line, 1 = no crack)\n    // Modulated by edge fade\n    return mix(1.0, pattern, edgeFade);\n}\n\n// Calculate all object-space cracks\n// Returns vec4: rgb = crack/glow color, a = crack alpha (blend factor)\nvec4 calculateObjectSpaceCracks(vec3 fragPos, vec3 normal) {\n    if (crackNumImpacts == 0) {\n        return vec4(0.0);\n    }\n\n    float combinedCrack = 1.0;\n    float maxAmount = 0.0;\n\n    // Impact 0\n    if (crackNumImpacts >= 1 && crackParams0.y > 0.01) {\n        float crack0 = singleObjectSpaceCrack(fragPos, crackImpact0, crackDirection0, crackParams0.x, crackParams0.z);\n        combinedCrack = min(combinedCrack, crack0);\n        maxAmount = max(maxAmount, crackParams0.y);\n    }\n\n    // Impact 1\n    if (crackNumImpacts >= 2 && crackParams1.y > 0.01) {\n        float crack1 = singleObjectSpaceCrack(fragPos, crackImpact1, crackDirection1, crackParams1.x, crackParams1.z);\n        combinedCrack = min(combinedCrack, crack1);\n        maxAmount = max(maxAmount, crackParams1.y);\n    }\n\n    // Impact 2\n    if (crackNumImpacts >= 3 && crackParams2.y > 0.01) {\n        float crack2 = singleObjectSpaceCrack(fragPos, crackImpact2, crackDirection2, crackParams2.x, crackParams2.z);\n        combinedCrack = min(combinedCrack, crack2);\n        maxAmount = max(maxAmount, crackParams2.y);\n    }\n\n    // combinedCrack: 0.0 = crack line, 1.0 = no crack\n    // Convert to crack visibility (invert and threshold)\n    float crackThickness = 0.3;  // Threshold for what counts as a crack line\n    float crackLine = 1.0 - smoothstep(0.0, crackThickness, combinedCrack);\n\n    // Edge glow around cracks\n    float glowWidth = 0.5;\n    float edgeGlow = 1.0 - smoothstep(crackThickness, crackThickness + glowWidth, combinedCrack);\n    edgeGlow = max(0.0, edgeGlow - crackLine);  // Remove overlap with crack line\n    edgeGlow *= edgeGlow;  // Softer falloff\n\n    // Apply amount (intensity control)\n    crackLine *= maxAmount;\n    edgeGlow *= maxAmount * crackGlowStrength;\n\n    // Final color composition\n    // Dark crack interior (nearly black)\n    vec3 crackInterior = crackColor * 0.2;\n    // Bright glow at edges\n    vec3 glowContrib = crackGlowColor * edgeGlow * 2.0;\n\n    vec3 color = crackInterior * crackLine + glowContrib;\n    float alpha = crackLine * 0.95 + edgeGlow * 0.6;\n\n    return vec4(color, alpha);\n}\n\n\nvoid main() {\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewPosition);\n\n    // \n    // FRESNEL EFFECT - Colored rim at edges (cyan-tinted)\n    // \n    float fresnel = pow(1.0 - abs(dot(normal, viewDir)), fresnelPower);\n    fresnel *= fresnelIntensity;\n\n    // \n    // AMBIENT OCCLUSION - Dark shadows for depth\n    // \n    float ao = calculateAO(normal, viewDir, vPosition);\n    float shadowFactor = mix(1.0, ao, shadowDarkness);\n\n    // \n    // SPECULAR HIGHLIGHTS - Bright catches on facet edges\n    // \n    vec3 lightDir = normalize(sssLightDir);\n    float specular = calculateFacetSpecular(normal, viewDir, lightDir, specularPower);\n    specular *= specularIntensity;\n\n    // \n    // LIGHT TRANSMISSION - Thin areas glow, thick areas darken\n    // \n    float transmission = calculateTransmission(vPosition, normal, viewDir, transmissionContrast);\n\n    // \n    // TEXTURE SAMPLING - Crystal surface detail from UV-mapped texture\n    // \n    vec4 texColor = texture2D(crystalTexture, vUv);\n    float texValue = (texColor.r + texColor.g + texColor.b) / 3.0;  // Grayscale\n\n    // \n    // FROSTED SURFACE - Subtle cloudy variation (not opaque white!)\n    // \n    float surfaceNoise = fbm(vPosition * surfaceNoiseScale + time * 0.02);\n    surfaceNoise = surfaceNoise * surfaceRoughness;\n\n    // \n    // INNER SOUL GLOW - The glowing core visible through the crystal\n    // \n\n    // Animated internal glow - subtle pulsing\n    float glowPulse = sin(time * 0.5) * 0.15 + 0.85;\n\n    // Core glow - strongest in center, fades toward edges with sharper falloff\n    float distFromCenter = length(vPosition);\n    float coreGlow = exp(-distFromCenter * 2.5) * glowPulse;\n\n    // \n    // INTERNAL CAUSTICS - Light refraction pools inside the gem\n    // Creates bright concentrated spots that shift with viewing angle\n    // Real caustics form where refracted light rays converge inside the gem\n    // Now with CHROMATIC ABERRATION - different wavelengths refract differently\n    // \n\n    // Single refraction direction (green IOR)  compute monochrome caustic, then\n    // apply chromatic shift. Saves 2 refract() + 6 sin() vs per-channel computation.\n    float chromaticStrength = 1.0 - clamp((sssStrength - 0.5) * 0.8, 0.0, 0.8);\n    vec3 refractDir = refract(-viewDir, normal, 0.57);\n\n    // Animated drift\n    float causticTime = time * causticSpeed;\n    vec3 drift = vec3(causticTime * 0.3, causticTime * 0.2, causticTime * 0.1);\n\n    float spatialOffset = mix(1.0, 3.0, chromaticStrength);\n    vec3 causticPos = vPosition * causticScale + refractDir * spatialOffset + drift;\n\n    // 3-wave interference pattern (monochrome)\n    float wave1 = sin(causticPos.x * 2.0 + causticPos.y * 1.5 + causticPos.z);\n    float wave2 = sin(causticPos.y * 2.3 - causticPos.x * 1.2 + causticPos.z * 1.8);\n    float wave3 = sin(causticPos.z * 1.9 + causticPos.x * 0.8 - causticPos.y * 1.4);\n    float interference = (wave1 + wave2 + wave3) / 3.0;\n    float causticMono = smoothstep(0.3, 0.8, interference);\n\n    // Chromatic shift: offset R and B slightly from mono value for rainbow fringe\n    float causticR = smoothstep(0.3, 0.8, interference + chromaticStrength * 0.08);\n    float causticB = smoothstep(0.3, 0.8, interference - chromaticStrength * 0.08);\n    vec3 causticRGB = vec3(causticR, causticMono, causticB);\n\n    // Add noise variation to break up uniformity\n    float noiseVar = noise3D(causticPos * 0.5);\n    causticRGB *= (0.7 + noiseVar * 0.6);\n\n    // Clamp caustic peaks to prevent hot spot blobs\n    // This keeps caustics subtle and distributed rather than concentrated\n    causticRGB = min(causticRGB, vec3(0.6));\n\n    // Caustics are MORE visible in thick areas (center) where light has more\n    // material to refract through and pool\n    float thickness = abs(dot(normal, viewDir)); // 1 at center, 0 at edges\n    causticRGB *= (0.3 + thickness * 0.7);\n\n    // Apply intensity control\n    causticRGB *= causticIntensity;\n\n    // Boost caustic visibility for colored gems to compensate for reduced chromatic spread\n    // Colored gems (high sssStrength) have suppressed chromatic aberration, so boost their\n    // monochromatic caustics to maintain internal "life" and sparkle\n    float causticBoost = 1.0 + clamp((sssStrength - 0.5) * 0.8, 0.0, 0.6);\n    causticRGB *= causticBoost;\n\n    // Also keep a scalar caustic for compatibility\n    float caustic = (causticRGB.r + causticRGB.g + causticRGB.b) / 3.0;\n\n    // Animation pattern (0-1 range) - core glow + caustic hot spots\n    float animationPattern = coreGlow * 0.7 + caustic * 0.3;\n\n    // Soul intensity controls overall brightness with more dramatic falloff\n    // Brighter near core, darker at edges\n    float baseLevel = 0.1;  // Lower base for more contrast\n    float patternContrast = 0.9;  // Higher contrast for more variation\n    float soulIntensity = (baseLevel + animationPattern * patternContrast) * innerGlowStrength;\n\n    // Apply transmission to soul - thin areas glow brighter\n    soulIntensity *= transmission;\n\n    // Soul color from emotion\n    // NOTE: emotionColor is pre-normalized by normalizeColorLuminance() in Core3DManager\n    // This ensures consistent perceived brightness across all emotions (yellow won't wash out, blue stays visible)\n    // Reduced intensity to prevent blowout - soul should be visible but not white\n    float glowCurve = sqrt(innerGlowStrength * glowIntensity) * 0.5;\n    vec3 soulColor = emotionColor * soulIntensity * glowCurve;\n    // Clamp soul color to prevent blowout (relaxed to let more energy through)\n    soulColor = min(soulColor, vec3(1.2));\n\n    // \n    // REFRACTED SOUL SAMPLING - True optical lensing through crystal\n    // The soul is rendered to a texture, then sampled with refraction distortion\n    // This creates the effect of looking at the soul through a crystal lens\n    // \n\n    // \n    // REFRACTED SOUL SAMPLING\n    // Sample the soul texture with physical refraction distortion\n    // Creates the "looking through glass" lensing effect\n    // \n    vec3 refractedSoulColor = vec3(0.0);\n    float refractedSoulAlpha = 0.0;\n\n    if (soulTextureSize.x > 0.0 && soulScreenCenter.x >= 0.0) {\n        // Fragment's screen UV position\n        vec2 fragUV = gl_FragCoord.xy / soulTextureSize;\n\n        // Calculate refraction offset using Snell's law\n        float ior = refractionIndex;\n        vec3 refractedDir = refract(-viewDir, normal, 1.0 / ior);\n\n        // Apply refraction distortion toward the soul center\n        // This creates the magnifying glass effect - bending light toward center\n        vec2 refractionOffset = refractedDir.xy * refractionStrength * 0.1;\n\n        // Sample at fragment position with refraction offset\n        vec2 soulUV = clamp(fragUV + refractionOffset, 0.0, 1.0);\n\n        // Sample the soul texture\n        vec4 soulSample = texture2D(soulTexture, soulUV);\n\n        // Store for later use in final composition\n        refractedSoulColor = soulSample.rgb;\n        refractedSoulAlpha = soulSample.a;\n\n        // Also blend into soulColor for existing pipeline\n        soulColor = mix(soulColor, soulSample.rgb, soulSample.a * 0.5);\n    }\n\n    // \n    // SOUL BLEND LAYERS - Apply before combining with shell\n    // \n    if (soulLayer1Enabled > 0.5) {\n        int mode = int(soulLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(soulColor, emotionColor * soulLayer1Strength, mode);\n        soulColor = mix(soulColor, blendResult, soulLayer1Strength);\n    }\n    if (soulLayer2Enabled > 0.5) {\n        int mode = int(soulLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(soulColor, emotionColor * soulLayer2Strength, mode);\n        soulColor = mix(soulColor, blendResult, soulLayer2Strength);\n    }\n\n    // \n    // FROSTED SHELL - Milky white layer with INTERNAL lighting model\n    // Lit from inside: thin edges bright, thick center dark\n    // \n\n    // Frosted glass base - will be modulated by thickness\n    // Lower base values allow for darker thick areas while maintaining bright edges\n    vec3 frostBase = vec3(0.45, 0.48, 0.55) * frostiness;\n\n    // THICKNESS-BASED DARKNESS (internal lighting model)\n    // Face-on facets are THICK (light travels far through) = DARK\n    // Edge-on facets are THIN (light escapes easily) = BRIGHT\n    float edgeThinness = 1.0 - abs(dot(normal, viewDir));  // 1 at edges, 0 facing camera\n\n    // Apply curve to make face-on areas darker more aggressively\n    float thinness = pow(edgeThinness, 0.7);  // Push more area toward dark\n\n    // Thickness multiplier: thin edges=bright (1.0), thick face-on=dark (0.01 for near-black)\n    float thicknessMultiplier = 0.01 + thinness * 0.99;\n    frostBase *= thicknessMultiplier;\n\n    // Surface variation adds subtle texture\n    frostBase += vec3(surfaceNoise * 0.03);\n\n    // Specular highlights on facet edges (external light catch)\n    float facetHighlight = pow(max(0.0, dot(normal, normalize(vec3(0.5, 1.0, 0.8)))), 16.0);\n    frostBase += vec3(facetHighlight * 0.2);\n\n    // SOUL BLEED - Inner glow illuminates the shell from inside\n    // Use gentler falloff so color reaches the shell surface\n    float soulBleed = exp(-distFromCenter * 1.2) * innerGlowStrength;\n    // Stronger color contribution - tint the frost with emotion color\n    frostBase = mix(frostBase, frostBase + emotionColor * 0.4, soulBleed);\n\n    // \n    // SHELL BLEND LAYERS - Apply to frosted shell\n    // \n    if (shellLayer1Enabled > 0.5) {\n        int mode = int(shellLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(frostBase, emotionColor * shellLayer1Strength, mode);\n        frostBase = mix(frostBase, blendResult, shellLayer1Strength);\n    }\n    if (shellLayer2Enabled > 0.5) {\n        int mode = int(shellLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(frostBase, emotionColor * shellLayer2Strength, mode);\n        frostBase = mix(frostBase, blendResult, shellLayer2Strength);\n    }\n\n    // \n    // FRESNEL RIM - Bright emotion-colored edge glow\n    // \n    vec3 rimColor = mix(vec3(0.5, 0.9, 1.0), emotionColor, 0.6);\n    vec3 rimGlow = rimColor * fresnel * 1.2;\n\n    // \n    // RIM BLEND LAYERS - Apply to fresnel rim glow\n    // \n    if (rimLayer1Enabled > 0.5) {\n        int mode = int(rimLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(rimGlow, emotionColor * rimLayer1Strength, mode);\n        rimGlow = mix(rimGlow, blendResult, rimLayer1Strength);\n    }\n    if (rimLayer2Enabled > 0.5) {\n        int mode = int(rimLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(rimGlow, emotionColor * rimLayer2Strength, mode);\n        rimGlow = mix(rimGlow, blendResult, rimLayer2Strength);\n    }\n\n    // \n    // PHYSICALLY-BASED SUBSURFACE SCATTERING\n    // Uses BSSRDF with Beer's Law absorption and Burley diffusion profile\n    // \n    vec3 sss = calculatePhysicalSSS(\n        normal,\n        viewDir,\n        vPosition,\n        normalize(sssLightDir),\n        sssLightColor,\n        emotionColor,\n        sssStrength,\n        sssAbsorption,\n        sssScatterDistance,\n        sssThicknessBias,\n        sssThicknessScale,\n        sssCurvatureScale,\n        sssAmbient\n    );\n\n    // \n    // SSS BLEND LAYERS - Apply to subsurface scattering contribution\n    // \n    if (sssLayer1Enabled > 0.5) {\n        int mode = int(sssLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(sss, emotionColor * sssLayer1Strength, mode);\n        sss = mix(sss, blendResult, sssLayer1Strength);\n    }\n    if (sssLayer2Enabled > 0.5) {\n        int mode = int(sssLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(sss, emotionColor * sssLayer2Strength, mode);\n        sss = mix(sss, blendResult, sssLayer2Strength);\n    }\n\n    // \n    // COMBINE - Frosted shell base + soul glow (soul adds to shell, doesn't replace)\n    // \n\n    // Start with shell as base - preserves dark shadows\n    vec3 finalColor = frostBase;\n\n    // Add soul glow on top (additive, not replacement) - concentrated in center\n    // Soul should illuminate dark areas but not wash out entirely\n    float soulBlendFactor = soulIntensity * 0.8;\n    finalColor += soulColor * soulBlendFactor;\n\n    // Apply texture - blend based on texture brightness and strength\n    vec3 texContribution = texColor.rgb * textureStrength;\n    finalColor = mix(finalColor, finalColor + texContribution, textureStrength);\n\n    // Apply SSS material color - PRESERVE BRIGHTNESS, only change HUE\n    // The sssAbsorption values define the material color hue\n    // But thickness-based darkness must be preserved for gemstone look\n    if (sssStrength > 0.01) {\n        // Get current brightness (this includes thickness darkening)\n        float currentLum = dot(finalColor, vec3(0.299, 0.587, 0.114));\n\n        // Normalize absorption to get hue direction (0-1 range)\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 hue = absorption / max(maxAbs, 0.001);\n\n        // Create material color that PRESERVES current brightness\n        // This keeps dark areas dark while tinting them with the gem color\n        float hueLum = dot(hue, vec3(0.299, 0.587, 0.114));\n        vec3 materialColor = hue * currentLum / max(hueLum, 0.001);\n\n        // Clamp to prevent blowout on bright areas\n        materialColor = min(materialColor, vec3(1.0));\n\n        // Add subtle variation from SSS lighting calculation\n        float sssLum = dot(sss, vec3(0.299, 0.587, 0.114));\n        materialColor *= (0.9 + sssLum * 0.2);\n\n        // Replace crystal color with material color\n        float replaceAmount = sssStrength * 0.7;\n        finalColor = mix(finalColor, materialColor, replaceAmount);\n    }\n\n    // Add rim glow, tinted toward material color\n    if (sssStrength > 0.01) {\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 hue = absorption / max(maxAbs, 0.001);\n        // Stronger tint for colored gems - use gem hue directly\n        float rimTintStrength = clamp(sssStrength * 0.6, 0.0, 0.95);\n        vec3 tintedRim = rimGlow * mix(vec3(1.0), hue * 1.2, rimTintStrength);\n        // Cap rim to prevent bloom\n        tintedRim = min(tintedRim, vec3(0.5));\n        finalColor += tintedRim;\n    } else {\n        finalColor += rimGlow;\n    }\n\n    // \n    // SPECULAR HIGHLIGHTS - Add bright hot spots\n    // Tinted by gem color for colored gems to prevent white bloom\n    // \n    vec3 specularColor = vec3(1.0, 0.98, 0.95); // Warm white highlights for clear gems\n    float specularIntensityMod = 1.0;\n\n    if (sssStrength > 0.5) {\n        // Tint specular by gem color to prevent white bloom\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 gemHue = absorption / max(maxAbs, 0.001);\n        float colorStrength = clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0);\n        // Use gem hue for specular color\n        specularColor = mix(specularColor, gemHue * 1.3, colorStrength);\n        // Also reduce specular intensity for colored gems\n        specularIntensityMod = mix(1.0, 0.4, colorStrength);\n    }\n\n    vec3 specularContrib = specularColor * specular * transmission * specularIntensityMod;\n    specularContrib = min(specularContrib, vec3(0.5)); // Cap specular to prevent bloom\n    finalColor += specularContrib;\n\n    // \n    // FACET EDGE LINES - Bright catches along beveled edges\n    // \n    float edgeLines = calculateFacetEdgeLines(normal, viewDir, lightDir);\n    finalColor += vec3(edgeLines * 0.15) * transmission;\n\n    // \n    // SATURATION BOOST AT THIN EDGES\n    // Real gems have MORE saturated color at thin edges where light escapes\n    // \n    if (sssStrength > 0.01) {\n        // thinness: 1 at edges, 0 facing camera\n        float satBoost = thinness * 0.4; // Up to 40% saturation boost at edges\n\n        // Get current color's saturation\n        float maxC = max(max(finalColor.r, finalColor.g), finalColor.b);\n        float minC = min(min(finalColor.r, finalColor.g), finalColor.b);\n        float currentSat = maxC > 0.001 ? (maxC - minC) / maxC : 0.0;\n\n        // Boost saturation at thin areas\n        if (maxC > 0.001 && currentSat > 0.01) {\n            // Calculate luminance\n            float lum = dot(finalColor, vec3(0.299, 0.587, 0.114));\n            // Increase saturation by moving away from gray toward the color\n            vec3 gray = vec3(lum);\n            float newSat = min(currentSat + satBoost, 1.0);\n            float satRatio = currentSat > 0.001 ? newSat / currentSat : 1.0;\n            finalColor = gray + (finalColor - gray) * satRatio;\n        }\n    }\n\n    // \n    // FINAL THICKNESS APPLICATION - Apply AFTER all additive terms\n    // This ensures thick areas stay dark even with glow added\n    // \n    // thicknessMultiplier: 0.15 in thick center, 1.0 at thin edges\n    finalColor *= thicknessMultiplier;\n\n    // \n    // INTERNAL CAUSTICS - Bright spots from light concentration inside gem\n    // Now with chromatic aberration for rainbow dispersion effect\n    // Applied AFTER thickness darkening so they punch through dark areas\n    // \n    if (causticIntensity > 0.01) {\n        // Get material hue for tinting caustics\n        vec3 causticTint = vec3(1.0); // Default white\n        float causticTintStrength = 0.4; // Default for clear gems\n        if (sssStrength > 0.5) {\n            vec3 absorption = sssAbsorption;\n            float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n            vec3 hue = absorption / max(maxAbs, 0.001);\n            // Stronger tint for colored gems to prevent white bloom\n            causticTintStrength = clamp((sssStrength - 0.5) * 0.8 + 0.4, 0.4, 0.9);\n            causticTint = mix(vec3(1.0), hue * 1.2, causticTintStrength);\n        }\n        // Add RGB caustic with chromatic aberration\n        // Reduce raw RGB blend for colored gems\n        float rawBlend = mix(0.3, 0.1, clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0));\n        vec3 causticFinal = causticRGB * causticTint + causticRGB * rawBlend;\n        causticFinal = min(causticFinal, vec3(0.4)); // Cap to prevent bloom\n        finalColor += causticFinal;\n    }\n\n    // \n    // FIRE - Intense sparkle points from light dispersion in facets\n    // The "fire" effect that makes gems sparkle brilliantly\n    // \n    float fire = calculateFire(normal, viewDir, lightDir);\n\n    // Tint fire by gem color - colored gems should have tinted highlights\n    // Pure white fire only for quartz/clear gems (low sssStrength)\n    vec3 fireColor = vec3(1.0, 0.99, 0.97); // Base warm white\n    float fireIntensity = 0.3; // Base intensity for clear gems\n    float fireClamp = 1.5; // Max fire value for clear gems\n\n    if (sssStrength > 0.5) {\n        // Get gem hue from absorption - this IS the gem's color\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 gemHue = absorption / max(maxAbs, 0.001);\n\n        // For colored gems, fire should BE the gem color, not white\n        // The more colored the gem (higher sssStrength), the more the fire matches the gem\n        float colorStrength = clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0);\n\n        // Use gem hue directly as fire color - NOT mixed with white\n        // This ensures fire can never bloom to white\n        fireColor = gemHue * 1.2; // Slight brightness boost but stay saturated\n\n        // Reduce fire intensity AND clamp for colored gems to prevent bloom washout\n        // Colored gems should have subtle, saturated fire, not bright white spots\n        fireIntensity = mix(0.3, 0.08, colorStrength); // Much lower for colored gems\n        fireClamp = mix(1.5, 0.5, colorStrength); // Much lower clamp for colored gems\n    }\n\n    // Apply fire clamp BEFORE multiplying by color\n    fire = min(fire, fireClamp);\n\n    // Calculate fire contribution and clamp to prevent any channel from blooming\n    vec3 fireContribution = fireColor * fire * fireIntensity;\n    fireContribution = min(fireContribution, vec3(0.4)); // Hard cap on fire brightness\n    finalColor += fireContribution;\n\n    // Ensure minimum brightness - allow near-black for gemstones\n    // minBrightness of 0.01 allows true darks while preventing total black\n    finalColor = max(finalColor, vec3(minBrightness));\n\n    // \n    // ALPHA - More opaque for visibility\n    // \n\n    // Higher base opacity\n    float baseAlpha = 0.6 + frostiness * 0.25;\n\n    // Fresnel makes edges solid\n    float rimAlpha = fresnel * 0.3;\n\n    // Soul glow adds opacity\n    float glowAlpha = soulIntensity * 0.15;\n\n    float finalAlpha = min(baseAlpha + rimAlpha + glowAlpha, 0.95) * opacity;\n\n    // \n    // ALPHA FIX FOR DARK FRAGMENTS\n    // With NormalBlending, dark color + partial alpha creates darkening artifacts\n    // (result = dark * alpha + bg * (1-alpha) can be DARKER than background!)\n    // Fix: Make dark fragments fully opaque so they replace background, not blend\n    // \n    float luminance = dot(finalColor, vec3(0.299, 0.587, 0.114));\n    // Dark fragments (luminance < 0.3) get alpha boosted toward 1.0\n    // Bright fragments keep their calculated alpha for glowing edges\n    float darkBoost = 1.0 - smoothstep(0.0, 0.3, luminance);  // 1.0 when dark, 0.0 when bright\n    finalAlpha = mix(finalAlpha, 1.0, darkBoost * 0.8);  // Boost dark fragments to near-opaque\n\n    // \n    // REFRACTED SOUL - Add the soul visible through the crystal\n    // This is the actual soul mesh rendered to texture and sampled with refraction\n    // \n    if (refractedSoulAlpha > 0.01) {\n        // The soul should glow through the crystal, tinted by the crystal's color\n        // Use additive blending so the soul illuminates the crystal from within\n        vec3 soulGlow = refractedSoulColor * refractedSoulAlpha;\n\n        // Tint the soul by the crystal's SSS color for colored gems\n        // emotionColorBleed controls how much pure emotion color comes through\n        // 0 = fully tinted by gem color, 1 = pure emotion color\n        if (sssStrength > 0.01) {\n            vec3 absorption = sssAbsorption;\n            float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n            vec3 gemHue = absorption / max(maxAbs, 0.001);\n            float tintAmount = sssStrength * 0.5 * (1.0 - emotionColorBleed);\n            soulGlow *= mix(vec3(1.0), gemHue, tintAmount);\n        }\n\n        // Soul must punch through the crystal's thickness darkening.\n        // Inverse thickness gating: strong in dark center, mild at bright edges.\n        float soulStrength = mix(0.8, 0.25, smoothstep(0.15, 0.7, thicknessMultiplier));\n        float crystalFacing = abs(dot(normal, viewDir));\n        float soulEdgeAtten = smoothstep(0.0, 0.25, crystalFacing);\n        vec3 soulContrib = soulGlow * soulStrength * soulEdgeAtten;\n        // Luminance-based soft cap: preserve hue, prevent white bloom blowout\n        float soulLum = dot(soulContrib, vec3(0.299, 0.587, 0.114));\n        soulContrib *= min(1.0, 0.45 / max(soulLum, 0.001));\n        finalColor += soulContrib;\n    }\n\n    // \n    // EMOTION COLOR BLEED - Additional inner glow from soul emotion\n    // Adds pure emotion color as light shining through the gem from the soul\n    // \n    if (emotionColorBleed > 0.001 && sssStrength > 0.01) {\n        // Core proximity glow (not edge-based  avoids adding to edge bloom)\n        float coreProximity = exp(-distFromCenter * 2.0);\n        float innerGlow = coreProximity * emotionColorBleed * 0.5;\n\n        // Add pure emotion color as inner light\n        finalColor += emotionColor * innerGlow * 0.4;\n    }\n\n    // \n    // IMPACT GLOW - Localized bright spot at punch impact site\n    // Uses calculateImpactGlow() from deformation.js utility\n    // vPosition is in mesh-local space (impactPoint pre-transformed by JS)\n    // \n    finalColor += calculateImpactGlow(vPosition, emotionColor);\n\n    // \n    // OBJECT-SPACE CRACKS - Persistent damage that rotates with mesh\n    // Uses calculateObjectSpaceCracks() from objectSpaceCracks.js utility\n    // vPosition is in mesh-local space (impacts pre-transformed by JS)\n    // \n    vec4 crackContrib = calculateObjectSpaceCracks(vPosition, normal);\n    if (crackContrib.a > 0.001) {\n        // Blend cracks over the final color\n        finalColor = mix(finalColor, crackContrib.rgb, crackContrib.a * 0.8);\n        // Cracks also affect alpha - make cracked areas more opaque\n        finalAlpha = max(finalAlpha, crackContrib.a * 0.5);\n    }\n\n    gl_FragColor = vec4(finalColor, finalAlpha);\n}\n`,Wy={time:0,glowIntensity:1,opacity:1,frostiness:.55,fresnelPower:2.8,fresnelIntensity:.25,innerGlowStrength:.55,surfaceRoughness:.12,shadowDarkness:.6,specularIntensity:.5,specularPower:28,transmissionContrast:1,minBrightness:.005,surfaceNoiseScale:1.5,noiseFrequency:1.33,causticIntensity:.8,causticScale:2,causticSpeed:.12,textureStrength:.55,refractionIndex:1.5,refractionStrength:.15,resolution:[1920,1080],soulTextureSize:[1920,1080],soulScreenCenter:[.5,.5],sssStrength:.65,sssAbsorption:[2.4,2.5,2.8],sssScatterDistance:[.35,.4,.45],sssThicknessBias:.18,sssThicknessScale:.6,sssCurvatureScale:1.8,sssAmbient:.3,sssLightDir:[.5,1,.8],sssLightColor:[1,.98,.95],shellLayer1Mode:0,shellLayer1Strength:0,shellLayer1Enabled:0,shellLayer2Mode:0,shellLayer2Strength:0,shellLayer2Enabled:0,soulLayer1Mode:0,soulLayer1Strength:0,soulLayer1Enabled:0,soulLayer2Mode:0,soulLayer2Strength:0,soulLayer2Enabled:0,rimLayer1Mode:0,rimLayer1Strength:0,rimLayer1Enabled:0,rimLayer2Mode:0,rimLayer2Strength:0,rimLayer2Enabled:0,sssLayer1Mode:0,sssLayer1Strength:0,sssLayer1Enabled:0,sssLayer2Mode:0,sssLayer2Strength:0,sssLayer2Enabled:0};function qy(e,t,n={}){const{glowColor:a=[1,1,.95],glowIntensity:i=1,materialVariant:r=null,emotionData:s=null,assetBasePath:o="/assets",onTextureReady:l=null}=n;return"custom"===t.material?function(e,t,n,a,i,r,s){const o=new Go;switch(e){case"moon":return function(e,t,n,a=null,i="/assets",r=null){const s=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)?"2k":"4k";if("multiplexer"===a)return{material:zu(e,{resolution:s,glowColor:new Ia(t[0],t[1],t[2]),glowIntensity:n,assetBasePath:i,onTextureReady:r}),type:"moon-multiplexer"};return{material:Du(e,{resolution:s,glowColor:new Ia(t[0],t[1],t[2]),glowIntensity:n,moonPhase:"full",assetBasePath:i,onTextureReady:r}),type:"moon"}}(o,t,n,a,r,s);case"crystal":return Hy(t,n,"crystal",{sssPreset:"quartz"},r);case"rough":return Hy(t,n,"rough",{frostiness:.05,innerGlowStrength:0,fresnelIntensity:1.6},r);case"heart":return Hy(t,n,"heart",{frostiness:.475,innerGlowStrength:.117,fresnelIntensity:1.206},r);case"star":return Hy(t,n,"star",{sssPreset:"citrine"},r);default:return console.warn("Unknown custom material type:",e),null}}(e,a,i,r,0,o,l):"emissive"===t.material?function(e,t,n,a,i,r){const s=new Go;return"sun"===e?function(e,t,n,a=null,i=null,r="/assets"){return{material:Lu(e,{glowColor:t,glowIntensity:n,resolution:"4k",materialVariant:a,assetBasePath:r}),type:"sun"}}(s,t,n,a,i,r):(console.warn("Unknown emissive material type:",e),null)}(e,a,i,r,s,o):null}function Hy(e,t,n="crystal",a={},i="/assets"){const{vertexShader:r,fragmentShader:s}={vertexShader:Uy,fragmentShader:Gy};let o=null;if(n){const e=new Go,t={crystal:`${i}/textures/Crystal/crystal.png`,rough:`${i}/textures/Crystal/rough.png`,heart:`${i}/textures/Crystal/heart.png`,star:`${i}/textures/Crystal/star.png`},a=t[n]||t.crystal;o=e.load(a,void 0,e=>console.warn(` ${n} texture failed to load:`,e))}const l=a.sssPreset?By[a.sssPreset]:null;return{material:new bi({uniforms:{time:{value:0},emotionColor:{value:new Ia(e[0],e[1],e[2])},glowIntensity:{value:t},opacity:{value:1},frostiness:{value:a.frostiness??Wy.frostiness},fresnelPower:{value:a.fresnelPower??Wy.fresnelPower},fresnelIntensity:{value:a.fresnelIntensity??Wy.fresnelIntensity},innerGlowStrength:{value:a.innerGlowStrength??Wy.innerGlowStrength},surfaceRoughness:{value:Wy.surfaceRoughness},shadowDarkness:{value:a.shadowDarkness??Wy.shadowDarkness},specularIntensity:{value:a.specularIntensity??Wy.specularIntensity},specularPower:{value:a.specularPower??Wy.specularPower},transmissionContrast:{value:a.transmissionContrast??Wy.transmissionContrast},minBrightness:{value:a.minBrightness??Wy.minBrightness},surfaceNoiseScale:{value:Wy.surfaceNoiseScale},noiseFrequency:{value:Wy.noiseFrequency},causticIntensity:{value:a.causticIntensity??Wy.causticIntensity},causticScale:{value:a.causticScale??Wy.causticScale},causticSpeed:{value:a.causticSpeed??Wy.causticSpeed},crystalTexture:{value:o},textureStrength:{value:"heart"===n?.35:n?Wy.textureStrength:0},soulTexture:{value:null},resolution:{value:new Vt(Wy.resolution[0],Wy.resolution[1])},soulTextureSize:{value:new Vt(Wy.soulTextureSize[0],Wy.soulTextureSize[1])},soulScreenCenter:{value:new Vt(Wy.soulScreenCenter[0],Wy.soulScreenCenter[1])},refractionIndex:{value:a.refractionIndex??Wy.refractionIndex},refractionStrength:{value:a.refractionStrength??Wy.refractionStrength},sssStrength:{value:a.sssStrength??l?.sssStrength??Wy.sssStrength},sssAbsorption:{value:new Gt(...a.sssAbsorption??l?.sssAbsorption??Wy.sssAbsorption)},sssScatterDistance:{value:new Gt(...a.sssScatterDistance??l?.sssScatterDistance??Wy.sssScatterDistance)},sssThicknessBias:{value:a.sssThicknessBias??l?.sssThicknessBias??Wy.sssThicknessBias},sssThicknessScale:{value:a.sssThicknessScale??l?.sssThicknessScale??Wy.sssThicknessScale},sssCurvatureScale:{value:a.sssCurvatureScale??l?.sssCurvatureScale??Wy.sssCurvatureScale},sssAmbient:{value:a.sssAmbient??l?.sssAmbient??Wy.sssAmbient},sssLightDir:{value:new Gt(...a.sssLightDir??Wy.sssLightDir)},sssLightColor:{value:new Gt(...a.sssLightColor??Wy.sssLightColor)},emotionColorBleed:{value:a.emotionColorBleed??l?.emotionColorBleed??0},shellLayer1Mode:{value:Wy.shellLayer1Mode},shellLayer1Strength:{value:Wy.shellLayer1Strength},shellLayer1Enabled:{value:Wy.shellLayer1Enabled},shellLayer2Mode:{value:Wy.shellLayer2Mode},shellLayer2Strength:{value:Wy.shellLayer2Strength},shellLayer2Enabled:{value:Wy.shellLayer2Enabled},soulLayer1Mode:{value:Wy.soulLayer1Mode},soulLayer1Strength:{value:Wy.soulLayer1Strength},soulLayer1Enabled:{value:Wy.soulLayer1Enabled},soulLayer2Mode:{value:Wy.soulLayer2Mode},soulLayer2Strength:{value:Wy.soulLayer2Strength},soulLayer2Enabled:{value:Wy.soulLayer2Enabled},rimLayer1Mode:{value:Wy.rimLayer1Mode},rimLayer1Strength:{value:Wy.rimLayer1Strength},rimLayer1Enabled:{value:Wy.rimLayer1Enabled},rimLayer2Mode:{value:Wy.rimLayer2Mode},rimLayer2Strength:{value:Wy.rimLayer2Strength},rimLayer2Enabled:{value:Wy.rimLayer2Enabled},sssLayer1Mode:{value:Wy.sssLayer1Mode},sssLayer1Strength:{value:Wy.sssLayer1Strength},sssLayer1Enabled:{value:Wy.sssLayer1Enabled},sssLayer2Mode:{value:Wy.sssLayer2Mode},sssLayer2Strength:{value:Wy.sssLayer2Strength},sssLayer2Enabled:{value:Wy.sssLayer2Enabled},deformationStrength:{value:Ny.deformationStrength},impactPoint:{value:new Gt(...Ny.impactPoint)},deformationFalloff:{value:Ny.deformationFalloff},crackImpact0:{value:new Gt(...Vy.crackImpact0)},crackImpact1:{value:new Gt(...Vy.crackImpact1)},crackImpact2:{value:new Gt(...Vy.crackImpact2)},crackDirection0:{value:new Gt(...Vy.crackDirection0)},crackDirection1:{value:new Gt(...Vy.crackDirection1)},crackDirection2:{value:new Gt(...Vy.crackDirection2)},crackParams0:{value:new Gt(...Vy.crackParams0)},crackParams1:{value:new Gt(...Vy.crackParams1)},crackParams2:{value:new Gt(...Vy.crackParams2)},crackNumImpacts:{value:Vy.crackNumImpacts},crackColor:{value:new Ia(...Vy.crackColor)},crackGlowColor:{value:new Ia(...Vy.crackGlowColor)},crackGlowStrength:{value:Vy.crackGlowStrength}},vertexShader:r,fragmentShader:s,transparent:!0,side:2,depthWrite:!0,blending:1}),type:"crystal"}}function jy(e){e&&(e.map&&e.map.dispose(),e.normalMap&&e.normalMap.dispose(),e.emissiveMap&&e.emissiveMap.dispose(),e.roughnessMap&&e.roughnessMap.dispose(),e.metalnessMap&&e.metalnessMap.dispose())}const Xy=new Map;async function Yy(e,t={}){if(Xy.has(e)){const t=Xy.get(e);if(t.loaded)return t}const n=Hu[e];if(!n)return console.warn(`[GeometryCache] Unknown geometry type: ${e}`),null;const a={geometry:null,material:null,materialType:null,config:n,loaded:!1};if(n.geometryLoader?a.geometry=await n.geometryLoader(t.assetBasePath):a.geometry=n.geometry,"custom"===n.material||"emissive"===n.material){const i=qy(e,n,{glowColor:t.glowColor||[1,1,.95],glowIntensity:t.glowIntensity||1,materialVariant:t.materialVariant,emotionData:t.emotionData,assetBasePath:t.assetBasePath});i&&(a.material=i.material,a.materialType=i.type)}return a.loaded=!0,Xy.set(e,a),a}async function $y(e={}){await Promise.all(["crystal","rough","heart","moon","sun"].map(t=>Yy(t,e)))}function Qy(){for(const[e,t]of Xy.entries())t.material&&(jy(t.material),t.material.dispose());Xy.clear()}var Ky={preload:Yy,preloadAll:$y,get:function(e){const t=Xy.get(e);return t&&t.loaded?t:null},has:function(e){const t=Xy.get(e);return t&&t.loaded},updateMaterialOptions:function(e,t){const n=Xy.get(e);if(!n||!n.material)return;const{uniforms:a}=n.material;a&&(t.glowColor&&a.glowColor&&a.glowColor.value.set(...t.glowColor),void 0!==t.glowIntensity&&a.glowIntensity&&(a.glowIntensity.value=t.glowIntensity))},dispose:Qy,getStatus:function(){const e={};for(const[t,n]of Xy.entries())e[t]={loaded:n.loaded,hasGeometry:!!n.geometry,hasMaterial:!!n.material,materialType:n.materialType};return e}};class Zy{constructor(e,t){this.animator=e,this.gestureBlender=t,this.virtualParticlePool=this._createVirtualParticlePool(5),this.nextPoolIndex=0}_createVirtualParticlePool(e){const t=[];for(let n=0;n<e;n++)t.push({x:0,y:0,vx:0,vy:0,size:1,baseSize:1,opacity:1,scaleFactor:1,gestureData:null});return t}getVirtualParticleFromPool(){const e=this.virtualParticlePool[this.nextPoolIndex];return this.nextPoolIndex=(this.nextPoolIndex+1)%this.virtualParticlePool.length,e.x=0,e.y=0,e.vx=0,e.vy=0,e.size=1,e.baseSize=1,e.opacity=1,e.scaleFactor=1,e.gestureData=null,e}playGesture(e,t={}){const n=py(e);if(!n){const n=this.animator.createGestureAnimation(e);return n&&n.evaluate?this._playProceduralGesture(e,n,t):(console.warn(`Unknown gesture: ${e}`),!1)}const a=this.getVirtualParticleFromPool(),i=n.config||{};let r;r=i.musicalDuration?.musical?i.musicalDuration.bars?2e3*i.musicalDuration.bars:500*(i.musicalDuration.beats||2):i.duration||800;const s=this.animator.time;if(this.animator.animations.length>=10){const e=this.animator.animations.shift();console.warn(`Animation limit reached (10), removed oldest: ${e.gestureName||"unknown"}`)}const o={initialized:!1};return this.animator.animations.push({gestureName:e,duration:r,startTime:s,config:i,evaluate:e=>{a.x=0,a.y=0,a.vx=0,a.vy=0,a.size=1,a.opacity=1,n.apply&&(!o.initialized&&n.initialize&&(n.initialize(a,i,0,0),o.initialized=!0),n.apply(a,e,i,1/60,0,0));const t={...i,particle:a,config:i,strength:i.strength||1};return n["3d"]&&n["3d"].evaluate?n["3d"].evaluate.call(n,e,t):{position:[0,0,0],rotation:[0,0,0],scale:1}},callbacks:{onUpdate:t.onUpdate||null,onComplete:()=>{n.cleanup&&n.cleanup(a),t.onComplete&&t.onComplete()}}}),!0}_playProceduralGesture(e,t,n={}){const a=1e3*(t.duration||.5),i=this.animator.time;if(this.animator.animations.length>=10){const e=this.animator.animations.shift();console.warn(`Animation limit reached (10), removed oldest: ${e.gestureName||"unknown"}`)}return this.animator.animations.push({gestureName:e,duration:a,startTime:i,isAccent:t.isAccent||!1,evaluate:t.evaluate,callbacks:{onUpdate:n.onUpdate||null,onComplete:n.onComplete||null}}),!0}update(e){this.animator.update(e)}blend(e,t,n){return this.gestureBlender.blend(this.animator.animations,this.animator.time,e,t,n)}hasActiveAnimations(){return this.animator.animations.length>0}getActiveAnimationCount(){return this.animator.animations.length}getTime(){return this.animator.time}getActiveAnimations(){return this.animator.animations}stopAll(){this.animator.stopAll()}playEmotion(e){this.animator.playEmotion(e)}dispose(){this.stopAll(),this.virtualParticlePool&&(this.virtualParticlePool.length=0,this.virtualParticlePool=null),this.animator=null,this.gestureBlender=null,this.tempEuler=null,this.gestureQuaternion=null}}const Jy="off",ev="annular",tv="total",nv={[Jy]:{shadowCoverage:0,coronaIntensity:1,coronaRaysEnabled:!1,baileyBeadsEnabled:!1,baileyBeadsCount:0,baileyBeadsSize:0},[ev]:{shadowCoverage:.95,coronaIntensity:.8,coronaRaysEnabled:!1,baileyBeadsEnabled:!0,baileyBeadsCount:12,baileyBeadsSize:.015},[tv]:{shadowCoverage:1.019,coronaIntensity:4,coronaRaysEnabled:!0,baileyBeadsEnabled:!0,baileyBeadsCount:6,baileyBeadsSize:.025}};function av(e){return nv[e]||nv[Jy]}class iv{constructor(e,t){this.scene=e,this.sunRadius=t,this.heroBeadCount=3,this.supportBeadCount=15,this.beadCount=this.heroBeadCount+this.supportBeadCount,this.beads=[],this.visible=!1,this._directionToCamera=new Gt,this._up=new Gt(0,1,0),this._right=new Gt,this._upVector=new Gt,this._beadOffset=new Gt,this._tempColor=new Ia,this.sharedTexture=null,this.createBeads()}createBeads(){const e=document.createElement("canvas");e.width=64,e.height=64;const t=e.getContext("2d"),n=t.createRadialGradient(32,32,0,32,32,32);n.addColorStop(0,"rgba(255, 255, 255, 1.0)"),n.addColorStop(.1,"rgba(255, 255, 255, 0.9)"),n.addColorStop(.3,"rgba(255, 240, 200, 0.6)"),n.addColorStop(.6,"rgba(255, 220, 150, 0.2)"),n.addColorStop(1,"rgba(255, 200, 100, 0.0)"),t.fillStyle=n,t.fillRect(0,0,64,64);const a=new Kr(e);a.needsUpdate=!0,this.sharedTexture=a;const i=this.generateLunarValleys();for(let e=0;e<this.beadCount;e++){const t=new Di,n=new Fi({map:a.clone(),blending:2,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(1,.3,.3)}),r=new Qi(n);r.scale.set(.08,.08,1),t.add(r);const s=new Fi({map:a.clone(),blending:2,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(.8,1,.8)}),o=new Qi(s);o.scale.set(.08,.08,1),t.add(o);const l=new Fi({map:a,blending:2,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(.3,.5,1)}),c=new Qi(l);c.scale.set(.08,.08,1),t.add(c),t.userData={angle:i[e].angle,depth:i[e].depth,baseIntensity:i[e].baseIntensity,isHero:i[e].isHero,sizeMultiplier:i[e].isHero?1.5:1,targetOpacity:0,currentOpacity:0,redSprite:r,greenSprite:o,blueSprite:c},this.beads.push(t),this.scene.add(t)}}generateLunarValleys(){const e=[];let t=12345;const n=()=>(t=(9301*t+49297)%233280,t/233280),a=n()*Math.PI*2;for(let t=0;t<this.heroBeadCount;t++){const i=a+t*Math.PI*2/3;e.push({angle:i,depth:.8+.2*n(),baseIntensity:.8+.2*n(),isHero:!0})}for(let t=0;t<this.supportBeadCount;t++){const i=a+Math.floor(t/(this.supportBeadCount/3))*Math.PI*2/3,r=1.2*(n()-.5);e.push({angle:i+r,depth:.3+.5*n(),baseIntensity:.4+.4*n(),isHero:!1})}return e}update(e,t,n,a,i=1){const r=this.sunRadius*i*1,s=e.position;this._directionToCamera.subVectors(s,t).normalize(),this._right.crossVectors(this._directionToCamera,this._up).normalize(),this._upVector.crossVectors(this._right,this._directionToCamera).normalize();for(const e of this.beads){const{angle:n,redSprite:a,greenSprite:s,blueSprite:o,sizeMultiplier:l}=e.userData,c=Math.cos(n)*r,h=Math.sin(n)*r;this._beadOffset.set(0,0,0),this._beadOffset.addScaledVector(this._right,c),this._beadOffset.addScaledVector(this._upVector,h),this._beadOffset.addScaledVector(this._directionToCamera,.01*r);const d=t.x+this._beadOffset.x,u=t.y+this._beadOffset.y,p=t.z+this._beadOffset.z,m=.008*i,f=Math.cos(n)*m,g=Math.sin(n)*m;a.position.set(f,g,.001),s.position.set(0,0,0),o.position.set(-f,-g,-.001),e.position.set(d,u,p),e.updateMatrixWorld(!0);const y=.15*i*l;a.scale.set(y,y,1),s.scale.set(y,y,1),o.scale.set(y,y,1)}if(this.visible){const e=.9,t=.97,a=1;for(const i of this.beads){let r=0;if(n>=e&&n<a){const s=(n-e)/(a-e)*Math.PI*2,o=Math.abs((i.userData.angle-s+Math.PI)%(2*Math.PI)-Math.PI);let l=1;n<t&&(l=(n-e)/(t-e)),r=Math.max(0,1-o/1)*i.userData.baseIntensity*l*i.userData.depth,r*=200}i.userData.targetOpacity=r}}else for(const e of this.beads)e.userData.targetOpacity=0;for(const e of this.beads){const{redSprite:t,greenSprite:n,blueSprite:i}=e.userData,r=e.userData.targetOpacity-e.userData.currentOpacity;e.userData.currentOpacity+=3*r*(a/1e3),e.userData.currentOpacity<.001&&(e.userData.currentOpacity=0),t.material.opacity=.7*e.userData.currentOpacity,n.material.opacity=1*e.userData.currentOpacity,i.material.opacity=.7*e.userData.currentOpacity}}setVisible(e){this.visible=e}dispose(){for(const e of this.beads){const{redSprite:t,greenSprite:n,blueSprite:a}=e.userData;t.material.map&&t.material.map.dispose(),t.material.dispose(),n.material.map&&n.material.map.dispose(),n.material.dispose(),a.material.map&&a.material.map.dispose(),a.material.dispose(),this.scene.remove(e)}this.beads=[],this.sharedTexture&&(this.sharedTexture.dispose(),this.sharedTexture=null),this._directionToCamera=null,this._up=null,this._right=null,this._upVector=null,this._beadOffset=null,this._tempColor=null,this.scene=null}}function rv(e){return e}function sv(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}const ov=2*Math.PI/3,lv=2*Math.PI/4.5;function cv(e){return 0===e?0:1===e?1:-Math.pow(2,10*e-10)*Math.sin((10*e-10.75)*ov)}function hv(e){return 0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((10*e-.75)*ov)+1}function dv(e){return 0===e?0:1===e?1:e<.5?-Math.pow(2,20*e-10)*Math.sin((20*e-11.125)*lv)/2:Math.pow(2,-20*e+10)*Math.sin((20*e-11.125)*lv)/2+1}const uv=7.5625,pv=2.75;function mv(e){return e<1/pv?uv*e*e:e<2/pv?uv*(e-=1.5/pv)*e+.75:e<2.5/pv?uv*(e-=2.25/pv)*e+.9375:uv*(e-=2.625/pv)*e+.984375}function fv(e){return 1-mv(1-e)}function gv(e){return mv(e)}function yv(e){return e<.5?(1-mv(1-2*e))/2:(1+mv(2*e-1))/2}const vv=1.70158,bv=2.5949095,wv=2.70158;function xv(e){return wv*e*e*e-vv*e*e}function Sv(e){return 1+wv*Math.pow(e-1,3)+vv*Math.pow(e-1,2)}function Mv(e){return e<.5?Math.pow(2*e,2)*(7.189819*e-bv)/2:(Math.pow(2*e-2,2)*(3.5949095*(2*e-2)+bv)+2)/2}const _v={linear:rv,easeIn:function(e){return e*e},easeOut:function(e){return 1-(1-e)*(1-e)},easeInOut:function(e){return e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2},easeInQuad:function(e){return e*e},easeOutQuad:function(e){return 1-(1-e)*(1-e)},easeInOutQuad:function(e){return e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2},easeInCubic:function(e){return e*e*e},easeOutCubic:function(e){return 1-Math.pow(1-e,3)},easeInOutCubic:sv,easeInExpo:function(e){return 0===e?0:Math.pow(2,10*e-10)},easeOutExpo:function(e){return 1===e?1:1-Math.pow(2,-10*e)},easeInOutExpo:function(e){return 0===e?0:1===e?1:e<.5?Math.pow(2,20*e-10)/2:(2-Math.pow(2,-20*e+10))/2},elastic:cv,elasticOut:hv,elasticInOut:dv,bounce:fv,bounceOut:gv,bounceInOut:yv,snap:function(e){return e<.5?0:1},step:function(e){return e>=1?1:0},smoothstep:function(e){return e*e*(3-2*e)},smootherstep:function(e){return e*e*e*(e*(6*e-15)+10)},burstImplode:function(e){if(e<.3){const t=e/.3;return 1-Math.pow(1-t,3)}if(e<.5)return 1;{const t=(e-.5)/.5;return 1-t*t*t}},backIn:xv,backOut:Sv,backInOut:Mv,easeInBack:xv,easeOutBack:Sv,easeInOutBack:Mv,easeInElastic:cv,easeOutElastic:hv,easeInOutElastic:dv,easeInBounce:fv,easeOutBounce:gv,easeInOutBounce:yv};function Av(e){return"function"==typeof e?e:"string"==typeof e&&_v[e]?_v[e]:(console.warn(`[Easing] Unknown easing "${e}", falling back to linear`),rv)}class Cv{constructor(e,t,n=null){this.scene=e,this.sunRadius=t,this.sunMesh=n,this.eclipseType=Jy,this.previousEclipseType=Jy,this.enabled=!1,this.time=0,this.randomSeed=12345,this.isTransitioning=!1,this.transitionProgress=0,this.transitionDuration=400,this.transitionDirection="in",this.manualControl=!1,this.customShadowCoverage=void 0,this._directionToCamera=new Gt,this._up=new Gt(0,1,0),this._right=new Gt,this._upVector=new Gt,this._tempOffset=new Gt,this._tempColor=new Ia,this.createShadowDisk(),this.createCoronaDisk(),this.createCounterCoronaDisk(),this.sunMesh&&(this.scene.remove(this.coronaDisk),this.scene.remove(this.counterCoronaDisk),this.sunMesh.add(this.coronaDisk),this.sunMesh.add(this.counterCoronaDisk)),this.baileysBeads=new iv(e,t)}createShadowDisk(){const e=this.sunRadius,t=new es(e,256),n=new Fa({color:0,transparent:!0,opacity:1,blending:4,premultipliedAlpha:!0,side:2,depthWrite:!1,depthTest:!1,fog:!1});this.shadowDisk=new ui(t,n),this.shadowDisk.renderOrder=1e4,this.shadowDisk.position.set(200,0,0),this.scene.add(this.shadowDisk)}createCoronaDisk(){const e=2.05*this.sunRadius,t=.6*this.sunRadius,n=new io(t,e,256),a=new bi({uniforms:{time:{value:0},glowColor:{value:new Ia(.9,.95,1)},intensity:{value:2.4},randomSeed:{value:this.randomSeed},uvRotation:{value:0},rayElongation:{value:1},uberHeroElongation:{value:1},isTotalEclipse:{value:0},layer1Mode:{value:11},layer1Strength:{value:2.155},layer1Enabled:{value:1},layer2Mode:{value:5},layer2Strength:{value:.695},layer2Enabled:{value:1},layer3Mode:{value:0},layer3Strength:{value:1},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:1},layer4Enabled:{value:0}},vertexShader:"\n                uniform float uvRotation;\n                varying vec2 vUv;\n\n                void main() {\n                    // Rotate UVs around center (0.5, 0.5)\n                    vec2 centeredUV = uv - 0.5;\n                    float cosRot = cos(uvRotation);\n                    float sinRot = sin(uvRotation);\n                    mat2 rotMatrix = mat2(cosRot, -sinRot, sinRot, cosRot);\n                    vec2 rotatedUV = rotMatrix * centeredUV;\n                    vUv = rotatedUV + 0.5;\n\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            ",fragmentShader:`\n                uniform float time;\n                uniform vec3 glowColor;\n                uniform float intensity;\n                uniform float randomSeed;\n                uniform float rayElongation;\n                uniform float uberHeroElongation;\n                uniform float isTotalEclipse;\n\n                // Blend Layer Uniforms (up to 4 layers)\n                uniform float layer1Mode;\n                uniform float layer1Strength;\n                uniform float layer1Enabled;\n\n                uniform float layer2Mode;\n                uniform float layer2Strength;\n                uniform float layer2Enabled;\n\n                uniform float layer3Mode;\n                uniform float layer3Strength;\n                uniform float layer3Enabled;\n\n                uniform float layer4Mode;\n                uniform float layer4Strength;\n                uniform float layer4Enabled;\n\n                varying vec2 vUv;\n\n                // \n                // UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n                // \n                ${pu}\n\n                // Hash function for pseudo-random variation\n                float hash(float n) {\n                    return fract(sin(n) * 43758.5453123);\n                }\n\n                // 2D hash for more variation\n                float hash2(vec2 p) {\n                    return fract(sin(dot(p, vec2(12.9898 + randomSeed, 78.233 + randomSeed))) * 43758.5453);\n                }\n\n                void main() {\n                    // Calculate distance and angle from center\n                    vec2 center = vec2(0.5, 0.5);\n                    vec2 toCenter = vUv - center;\n                    float dist = length(toCenter) * 2.0; // Normalize to 0-1 range\n                    float angle = atan(toCenter.y, toCenter.x);  // UVs are already rotated in vertex shader\n\n                    // Shadow edge - where corona rays start\n                    // Ring inner edge is at (sunRadius*0.85)/coronaRadius = 0.765/1.845 = 0.415\n                    // Start rays at sun's geometric edge (0.488) so they don't show inside sun\n                    float shadowEdge = 0.488;\n\n                    // Varied radial streamer pattern with artistic composition\n                    float rayIntensity = 0.0;\n\n                    // RULE OF THIRDS: Place 3 hero rays at compositionally strong points\n                    // Golden angles based on rule of thirds: 1/3, 2/3, and offset positions\n                    float heroAngles[3];\n                    heroAngles[0] = hash(randomSeed * 1.234) * 6.28318; // First hero ray (random rotation)\n                    heroAngles[1] = heroAngles[0] + 2.0944; // 120 apart (1/3 circle)\n                    heroAngles[2] = heroAngles[0] + 4.1888; // 240 apart (2/3 circle)\n\n                    // Process hero rays first (3 extra-long dramatic rays)\n                    for (int h = 0; h < 3; h++) {\n                        float rayAngle = heroAngles[h];\n                        float angleDiff = abs(mod(angle - rayAngle + 3.14159, 6.28318) - 3.14159);\n\n                        // Hero rays: extra long and prominent (fit within 0.535 normalized space)\n                        float baseHeroLength = 0.45 + hash(float(h) * 31.415 + randomSeed) * 0.08; // 0.45 to 0.53 (max available, longer!)\n\n                        // Apply UBER elongation: hero rays ALWAYS get extreme elongation (regardless of angle)\n                        // This creates 3 dramatic streamers that extend far in their respective directions\n                        float heroLength = baseHeroLength * uberHeroElongation;\n\n                        // Uber hero rays: keep them narrow but visible for dramatic pointy effect\n                        // Width scales with elongation to stay sharp but visible\n                        float baseHeroWidth = 0.15 + hash(float(h) * 27.183 + randomSeed) * 0.15; // 0.15 to 0.3 base width\n                        float narrowingFactor = mix(1.0, 0.3, (uberHeroElongation - 1.0) / max(uberHeroElongation, 1.0)); // 1.0  0.3 (70% narrower at max elongation)\n                        float heroWidth = baseHeroWidth * narrowingFactor; // Narrow when elongated = pointy!\n\n                        float distFromEdge = dist - shadowEdge;\n\n                        // Ghostly ethereal taper - very gradual falloff\n                        float taper = pow(1.0 - clamp(distFromEdge / max(heroLength, 0.001), 0.0, 1.0), 3.0);\n                        float rayWidth = heroWidth * taper;\n\n                        // Soft feathered edges instead of hard cutoff\n                        float edgeSoftness = 0.15; // Wider feather for smooth edges\n                        float angularMask = smoothstep(rayWidth + edgeSoftness, rayWidth - edgeSoftness, angleDiff);\n\n                        // Very gentle radial falloff for ethereal look\n                        float radialFalloff = pow(taper, 0.8);\n\n                        // Soft radial range with feathered ends\n                        float radialMask = smoothstep(-0.1, 0.05, distFromEdge) *\n                                          smoothstep(heroLength + 0.15, heroLength - 0.05, distFromEdge);\n\n                        float heroIntensity = angularMask * radialFalloff * radialMask * 0.7; // Reduced intensity for ghostly effect\n                        rayIntensity = max(rayIntensity, heroIntensity);\n                    }\n\n                    // 20 supporting rays with rule-of-thirds-aware distribution\n                    for (float i = 0.0; i < 20.0; i++) {\n                        // Cluster more rays around hero ray positions (rule of thirds)\n                        float clusterTarget = mod(i, 3.0); // Which hero ray to cluster near\n                        float clusterAngle = heroAngles[int(clusterTarget)];\n\n                        // Base distribution with clustering tendency\n                        float spreadAngle = (i / 20.0) * 6.28318;\n                        float clusterPull = (hash(i * 13.579 + randomSeed) - 0.5) * 1.5; // Stronger variation\n                        float rayAngle = spreadAngle + clusterPull;\n\n                        float angleDiff = abs(mod(angle - rayAngle + 3.14159, 6.28318) - 3.14159);\n\n                        // Unique random values per ray\n                        float random1 = hash(i * 12.9898 + randomSeed);\n                        float random2 = hash(i * 78.233 + randomSeed);\n                        float random3 = hash(i * 37.719 + randomSeed);\n                        float random4 = hash(i * 93.989 + randomSeed);\n\n                        // Varied lengths following power law distribution (more short, fewer long)\n                        float lengthVariation = random1 * random1; // Squared for naturalistic distribution\n                        float baseRayLength = 0.1 + lengthVariation * 0.7; // 0.1 to 0.8\n\n                        // 20% chance of long streamers (supporting the hero rays)\n                        float isLong = step(0.80, random2);\n                        baseRayLength = mix(baseRayLength, 0.7 + random3 * 0.6, isLong); // 0.7 to 1.3\n\n                        // Apply directional elongation: rays pointing up/down (vertical) get elongated\n                        float verticalWeight = abs(sin(rayAngle));\n                        float elongationFactor = mix(1.0, rayElongation, verticalWeight);\n                        float rayLength = baseRayLength * elongationFactor;\n\n                        // EQUATORIAL ASYMMETRY (total eclipse only): rays along equator are more prominent\n                        // Solar minimum: streamers cluster along equatorial plane\n                        float equatorialWeight = abs(cos(rayAngle)); // 1.0 at horizontal, 0.0 at vertical\n                        float asymmetryBoost = mix(1.0, 1.0 + equatorialWeight * 0.5, isTotalEclipse);\n                        rayLength *= asymmetryBoost;\n\n                        // Varied widths with power law (more thin, fewer thick)\n                        float baseWidth = 0.03 + (random4 * random4) * 0.2; // 0.03 to 0.23 (naturally varied)\n\n                        // Taper: wide at base, narrow at tip\n                        float distFromEdge = dist - shadowEdge;\n\n                        // Ghostly ethereal taper - very gradual falloff\n                        float taper = pow(1.0 - clamp(distFromEdge / max(rayLength, 0.001), 0.0, 1.0), 3.5);\n                        float rayWidth = baseWidth * taper;\n\n                        // Soft feathered edges for ethereal wisps\n                        float edgeSoftness = 0.10; // Wider feather for smooth edges\n                        float angularMask = smoothstep(rayWidth + edgeSoftness, rayWidth - edgeSoftness, angleDiff);\n\n                        // Very gentle radial falloff for ghostly appearance\n                        float radialFalloff = pow(taper, 1.0);\n\n                        // Soft radial range with feathered ends\n                        float radialMask = smoothstep(-0.08, 0.03, distFromEdge) *\n                                          smoothstep(rayLength + 0.12, rayLength - 0.03, distFromEdge);\n\n                        float streamerIntensity = angularMask * radialFalloff * radialMask * 0.5; // Reduced for ethereal wisps\n                        rayIntensity = max(rayIntensity, streamerIntensity);\n                    }\n\n                    // Base corona glow - thinner during total eclipse for realism\n                    float baseGlowWidth = mix(0.04, 0.015, isTotalEclipse); // Thinner during totality\n                    float baseGlow = smoothstep(shadowEdge - 0.01, shadowEdge, dist) *\n                                    (1.0 - smoothstep(shadowEdge + baseGlowWidth * 0.5, shadowEdge + baseGlowWidth, dist));\n\n                    // Enhanced gradient: white  cool blue-white  deep blue with distance\n                    // Distance normalized to corona extent (0 = shadow edge, 1 = far corona)\n                    float coronaDist = clamp((dist - shadowEdge) / 0.6, 0.0, 1.0);\n\n                    // \n                    // TOTAL ECLIPSE ENHANCEMENTS (scaled continuously by isTotalEclipse 0.0-1.0)\n                    // \n\n                    // 1. CHROMOSPHERE RED RIM - thin pink/red ring at sun's edge (hydrogen emission)\n                    float rimStart = shadowEdge;\n                    float rimEnd = shadowEdge + 0.025;\n                    float chromosphereRim = smoothstep(rimStart - 0.005, rimStart, dist) *\n                                     (1.0 - smoothstep(rimEnd - 0.01, rimEnd, dist));\n                    chromosphereRim *= 0.6 * isTotalEclipse; // Scale by eclipse progress\n                    vec3 chromosphereColor = vec3(1.0, 0.3, 0.4); // Pink-red (H-alpha emission)\n\n                    // 2. STRONGER BRIGHTNESS FALLOFF - inner corona much brighter\n                    // Mix between 1.0 (normal) and enhanced falloff based on isTotalEclipse\n                    float enhancedFalloff = mix(3.0, 0.3, pow(coronaDist, 0.7));\n                    float brightnessMultiplier = mix(1.0, enhancedFalloff, isTotalEclipse);\n\n                    // 3. F-CORONA OUTER GLOW - faint diffuse glow from interplanetary dust\n                    float fCoronaDist = clamp((dist - shadowEdge) / 1.2, 0.0, 1.0);\n                    float fCorona = (1.0 - fCoronaDist) * 0.08;\n                    fCorona *= smoothstep(0.3, 0.5, coronaDist);\n                    fCorona *= isTotalEclipse; // Scale by eclipse progress\n\n                    // 4. WISPY TENDRILS - add fine detail noise to ray intensity\n                    float noiseAngle = angle * 8.0 + time * 0.1;\n                    float noiseRadius = dist * 15.0;\n                    float wispyDetail = hash(noiseAngle + noiseRadius + randomSeed * 3.0) * 0.15;\n                    wispyDetail *= rayIntensity * isTotalEclipse; // Scale by eclipse progress\n\n                    // Combine: base glow + streamers + wispy detail\n                    float finalIntensity = (baseGlow * 0.6 + rayIntensity + wispyDetail) * intensity;\n                    finalIntensity *= brightnessMultiplier;\n\n                    // Multi-stage color gradient for realistic corona\n                    vec3 innerGlow = vec3(1.0, 1.0, 1.0);           // Pure white at base\n                    vec3 middleGlow = vec3(0.9, 0.95, 1.0);         // Cool white\n                    vec3 outerGlow = vec3(0.6, 0.75, 0.95);         // Pale blue\n                    vec3 farGlow = vec3(0.3, 0.5, 0.8);             // Deep blue\n\n                    // Three-stage color mix\n                    vec3 coronaColor;\n                    if (coronaDist < 0.3) {\n                        // Inner: white  cool white\n                        coronaColor = mix(innerGlow, middleGlow, coronaDist / 0.3);\n                    } else if (coronaDist < 0.7) {\n                        // Middle: cool white  pale blue\n                        coronaColor = mix(middleGlow, outerGlow, (coronaDist - 0.3) / 0.4);\n                    } else {\n                        // Outer: pale blue  deep blue\n                        coronaColor = mix(outerGlow, farGlow, (coronaDist - 0.7) / 0.3);\n                    }\n\n                    vec3 finalColor = coronaColor * finalIntensity;\n\n                    // Add chromosphere red rim (total eclipse only)\n                    finalColor += chromosphereColor * chromosphereRim * intensity;\n\n                    // Add F-corona outer glow (total eclipse only)\n                    finalColor += vec3(0.9, 0.85, 0.8) * fCorona * intensity; // Slightly warm white\n\n                    // \n                    // BLEND LAYERS (Applied globally to entire corona)\n                    // These allow adjusting the appearance of the corona to prevent black edges\n                    // \n\n                    // Layer 1\n                    if (layer1Enabled > 0.5) {\n                        vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n                        int mode1 = int(layer1Mode + 0.5);\n                        vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n                        finalColor = clamp(blended1, 0.0, 1.0);\n                    }\n\n                    // Layer 2\n                    if (layer2Enabled > 0.5) {\n                        vec3 blendColor2 = vec3(min(layer2Strength, 1.0));\n                        int mode2 = int(layer2Mode + 0.5);\n                        vec3 blended2 = clamp(applyBlendMode(finalColor, blendColor2, mode2), 0.0, 1.0);\n                        finalColor = clamp(blended2, 0.0, 1.0);\n                    }\n\n                    // Layer 3\n                    if (layer3Enabled > 0.5) {\n                        vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n                        int mode3 = int(layer3Mode + 0.5);\n                        vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n                        finalColor = clamp(blended3, 0.0, 1.0);\n                    }\n\n                    // Layer 4\n                    if (layer4Enabled > 0.5) {\n                        vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n                        int mode4 = int(layer4Mode + 0.5);\n                        vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n                        finalColor = clamp(blended4, 0.0, 1.0);\n                    }\n\n                    // Sharp alpha falloff to prevent black bleeding in bloom\n                    // Higher power = sharper cutoff at edges (less semi-transparent area)\n                    float alphaFalloff = pow(1.0 - coronaDist, 3.0);\n                    float alpha = finalIntensity * alphaFalloff * 0.95;\n\n                    gl_FragColor = vec4(finalColor, alpha);\n                }\n            `,transparent:!0,blending:2,depthWrite:!1,side:2});this.coronaDisk=new ui(n,a),this.coronaDisk.position.set(0,0,0),this.coronaDisk.renderOrder=9998,this.scene.add(this.coronaDisk)}createCounterCoronaDisk(){const e=this.coronaDisk.geometry,t=this.randomSeed+5e3,n=new bi({uniforms:{time:{value:0},glowColor:{value:new Ia(.9,.95,1)},intensity:{value:2.4},randomSeed:{value:t},uvRotation:{value:0},rayElongation:{value:1},uberHeroElongation:{value:1},isTotalEclipse:{value:0},layer1Mode:{value:11},layer1Strength:{value:2.155},layer1Enabled:{value:1},layer2Mode:{value:5},layer2Strength:{value:.695},layer2Enabled:{value:1},layer3Mode:{value:0},layer3Strength:{value:1},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:1},layer4Enabled:{value:0}},vertexShader:this.coronaDisk.material.vertexShader,fragmentShader:this.coronaDisk.material.fragmentShader,transparent:!0,blending:2,depthWrite:!1,side:2});this.counterCoronaDisk=new ui(e,n),this.counterCoronaDisk.position.set(0,0,0),this.counterCoronaDisk.renderOrder=9997,this.scene.add(this.counterCoronaDisk)}setShadowCoverage(e){this.customShadowCoverage=e}setCoronaBlendLayer(e,t){if(e<1||e>4)return void console.error(` Invalid corona layer number: ${e} (must be 1-4)`);const{mode:n=0,strength:a=1,enabled:i=!1}=t;this.coronaDisk?.material?.uniforms&&(this.coronaDisk.material.uniforms[`layer${e}Mode`].value=n,this.coronaDisk.material.uniforms[`layer${e}Strength`].value=a,this.coronaDisk.material.uniforms[`layer${e}Enabled`].value=i?1:0),this.counterCoronaDisk?.material?.uniforms&&(this.counterCoronaDisk.material.uniforms[`layer${e}Mode`].value=n,this.counterCoronaDisk.material.uniforms[`layer${e}Strength`].value=a,this.counterCoronaDisk.material.uniforms[`layer${e}Enabled`].value=i?1:0)}setEclipseType(e){if(e===this.eclipseType)return;const t=this.enabled;this.previousEclipseType=this.eclipseType,this.eclipseType=e,this.enabled=e!==Jy,this.manualControl=!1;const n=av(this.previousEclipseType),a=av(e);this.startShadowCoverage=n.shadowCoverage,this.targetShadowCoverage=a.shadowCoverage,!t&&this.enabled?(this.transitionDirection="in",this.isTransitioning=!0,this.transitionProgress=0):t&&!this.enabled?(this.transitionDirection="out",this.isTransitioning=!0,this.transitionProgress=0):t&&this.enabled&&(this.isTransitioning=!0,this.transitionProgress=0,this.transitionDirection="switch")}setManualProgress(e){this.manualControl=!0,this.transitionProgress=Math.max(0,Math.min(1,e)),this.isTransitioning=!0,this.transitionDirection="in"}setManualShadowPosition(e){this.manualControl=!0,this.manualShadowPosition=Math.max(-2,Math.min(2,e)),this.isTransitioning=!0,this.transitionDirection="manual"}update(e,t,n,a=null){const i=e.position,r=t.position,s=t.scale.x;let o=1;if(null!==a&&a>.5){const e=2*(a-.5);o=e*e*e}else if(null!==a&&a<=.5){const e=2*a;o=(1-e)*(1-e)*(1-e)}const l=this.eclipseType===Jy?3:1;if(this.time+=n*l,this.isTransitioning&&!this.manualControl){const e=n/this.transitionDuration;this.transitionProgress+=e,this.transitionProgress>=1&&(this.transitionProgress=1,this.isTransitioning=!1)}if(this.enabled||"out"===this.transitionDirection&&this.isTransitioning){const e="out"===this.transitionDirection&&this.isTransitioning?this.previousEclipseType:this.eclipseType,t=av(e),a=this.sunRadius*s,l=sv(this.transitionProgress);let c;void 0!==this.customShadowCoverage?c=this.customShadowCoverage:"switch"===this.transitionDirection&&this.isTransitioning&&void 0!==this.startShadowCoverage&&void 0!==this.targetShadowCoverage?c=this.startShadowCoverage+(this.targetShadowCoverage-this.startShadowCoverage)*l:({shadowCoverage:c}=t);const h=a*c/this.sunRadius;this.shadowDisk.scale.setScalar(h),this.currentShadowPosX=-2,"manual"===this.transitionDirection&&void 0!==this.manualShadowPosition?this.currentShadowPosX=this.manualShadowPosition:this.isTransitioning?"in"===this.transitionDirection?this.currentShadowPosX=2*l-2:"out"===this.transitionDirection?this.currentShadowPosX=0+1*l:"switch"===this.transitionDirection&&(this.currentShadowPosX=0):this.currentShadowPosX=0;const d=this.currentShadowPosX,u=2.5*a,p=d*u*.5,m=-d*d*u*.25;this._directionToCamera.subVectors(i,r).normalize(),this._right.crossVectors(this._directionToCamera,this._up).normalize(),this._upVector.crossVectors(this._right,this._directionToCamera).normalize();const f=0;this._tempOffset.copy(this._directionToCamera).multiplyScalar(f),this.shadowDisk.position.copy(r).add(this._tempOffset),this._tempOffset.copy(this._right).multiplyScalar(p),this.shadowDisk.position.add(this._tempOffset),this._tempOffset.copy(this._upVector).multiplyScalar(m),this.shadowDisk.position.add(this._tempOffset),this.shadowDisk.lookAt(i),this.coronaDisk.parent&&this.coronaDisk.parent!==this.scene||(this.coronaDisk.position.copy(r),this.counterCoronaDisk.position.copy(r),this.coronaDisk.scale.setScalar(s),this.counterCoronaDisk.scale.setScalar(s));const g=Math.abs(this.currentShadowPosX||0),y=2,v=Math.max(0,1-g/y);let b=0;if("switch"===this.transitionDirection&&this.isTransitioning){const e=this.previousEclipseType===tv,t=this.eclipseType===tv;t&&!e?b=l:!t&&e&&(b=1-l)}else e===tv&&(b=1);const w=1+(1+24*Math.pow(v,4)-1)*b,x=1+(1+199*Math.pow(v,5)-1)*b;this.coronaDisk.material.uniforms.rayElongation.value=w,this.counterCoronaDisk.material.uniforms.rayElongation.value=w,this.coronaDisk.material.uniforms.uberHeroElongation.value=x,this.counterCoronaDisk.material.uniforms.uberHeroElongation.value=x;const S=.5,M=.99,_=Math.max(0,Math.min(1,(v-S)/(M-S))),A=_*_*(3-2*_),C=A*b;this.coronaDisk.material.uniforms.isTotalEclipse.value=C,this.counterCoronaDisk.material.uniforms.isTotalEclipse.value=C;const T=b>0&&v>=S,P=1-.947*A*b;this.setCoronaBlendLayer(3,{mode:1,strength:P,enabled:T}),this.coronaDisk.lookAt(i),this.counterCoronaDisk.lookAt(i);let D=0;if(e===Jy)D=n/1e3*.075;else if(e===ev){const e=.075;D=n/1e3*(e-(e-.25*e)*v)}else if(e===tv){const e=.075;D=n/1e3*(e-(e-.05*e)*v)}this.coronaDisk.material.uniforms.uvRotation.value+=D,this.counterCoronaDisk.material.uniforms.uvRotation.value-=D;let O=1.2;if(e===Jy)O=3.6;else if(e===ev){const e=3.6,t=.08*e;this.transitionDirection,O=e-(e-t)*v}else if(e===tv){const e=3.6,t=.65*e;this.transitionDirection,O=e-(e-t)*v}this.coronaDisk.material.uniforms.intensity.value=O*o,this.counterCoronaDisk.material.uniforms.intensity.value=O*o,this.coronaDisk.material.uniforms.time.value=this.time,this.counterCoronaDisk.material.uniforms.time.value=this.time}else{this.shadowDisk.position.set(200,0,0),this.coronaDisk.parent&&this.coronaDisk.parent!==this.scene||(this.coronaDisk.position.copy(r),this.counterCoronaDisk.position.copy(r),this.coronaDisk.scale.setScalar(s),this.counterCoronaDisk.scale.setScalar(s)),this.coronaDisk.material.uniforms.rayElongation.value=1,this.counterCoronaDisk.material.uniforms.rayElongation.value=1,this.coronaDisk.material.uniforms.uberHeroElongation.value=1,this.counterCoronaDisk.material.uniforms.uberHeroElongation.value=1,this.coronaDisk.material.uniforms.isTotalEclipse.value=0,this.counterCoronaDisk.material.uniforms.isTotalEclipse.value=0,this.coronaDisk.material.uniforms.intensity.value=3.06*o,this.counterCoronaDisk.material.uniforms.intensity.value=3.06*o,this.setCoronaBlendLayer(3,{mode:1,strength:0,enabled:!1}),this.coronaDisk.lookAt(i),this.counterCoronaDisk.lookAt(i);const e=n/1e3*.075;this.coronaDisk.material.uniforms.uvRotation.value+=e,this.counterCoronaDisk.material.uniforms.uvRotation.value-=e,this.coronaDisk.material.uniforms.intensity.value=3.6*o,this.counterCoronaDisk.material.uniforms.intensity.value=3.6*o,this.coronaDisk.material.uniforms.time.value=this.time,this.counterCoronaDisk.material.uniforms.time.value=this.time}if(this.eclipseType===tv){let t=0,a=!1;if("manual"===this.transitionDirection){const e=Math.abs(this.currentShadowPosX),n=2;t=Math.max(0,Math.min(1,1-e/n)),t>=.9&&t<=1&&(a=!0)}else if("in"===this.transitionDirection&&this.isTransitioning){const e=.8;this.transitionProgress>=e&&(a=!0,t=.9+(this.transitionProgress-e)/(1-e)*.1)}else if("out"===this.transitionDirection&&this.isTransitioning){const e=.2;this.transitionProgress<=e&&(a=!0,t=1-this.transitionProgress/e*.1)}else this.isTransitioning||(t=1,a=!0);this.baileysBeads.setVisible(a),this.baileysBeads.update(e,r,t,n,s)}else this.baileysBeads.setVisible(!1),this.baileysBeads.update(e,r,0,n,s)}dispose(){this.shadowDisk&&(this.scene.remove(this.shadowDisk),this.shadowDisk.geometry.dispose(),this.shadowDisk.material.dispose(),this.shadowDisk=null),this.coronaDisk&&(this.coronaDisk.parent&&this.coronaDisk.parent.remove(this.coronaDisk),this.coronaDisk.geometry.dispose(),this.coronaDisk.material.dispose(),this.coronaDisk=null),this.counterCoronaDisk&&(this.counterCoronaDisk.parent&&this.counterCoronaDisk.parent.remove(this.counterCoronaDisk),this.counterCoronaDisk.material.dispose(),this.counterCoronaDisk=null),this.baileysBeads&&(this.baileysBeads.dispose(),this.baileysBeads=null),this._directionToCamera=null,this._up=null,this._right=null,this._upVector=null,this._tempOffset=null,this._tempColor=null,this.scene=null,this.sunMesh=null}}class Tv{constructor(e){this.material=e,this.eclipseType="off",this.progress=0,this.targetProgress=0,this.animating=!1,this.bloodMoonColor={r:.85,g:.18,b:.08},this.animationDuration=3e3,this.startTime=0,this.shadowX=-2,this.shadowY=0,this.shadowRadius=.7,this.targetShadowX=-2,this.shadowSpeed=1,this.emissiveStrength=0,this.targetEmissive=0,this.shadowDarkness=1,this.targetDarkness=1,this.material.uniforms.eclipseProgress||(this.material.uniforms.eclipseProgress={value:0},this.material.uniforms.eclipseIntensity={value:0},this.material.uniforms.bloodMoonColor={value:[this.bloodMoonColor.r,this.bloodMoonColor.g,this.bloodMoonColor.b]},this.material.uniforms.eclipseShadowPos={value:[this.shadowX,this.shadowY]},this.material.uniforms.eclipseShadowRadius={value:this.shadowRadius})}setEclipseType(e){if(this.eclipseType===e)return;const t="off"===this.eclipseType;switch(this.eclipseType=e,t&&"off"!==e&&(this.shadowX=-2,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY]),e){case"off":this.targetProgress=0,this.targetShadowX=2,this.targetEmissive=0,this.targetDarkness=1;break;case"penumbral":this.targetProgress=.3,this.targetShadowX=-1,this.targetEmissive=.05,this.targetDarkness=.85;break;case"partial":this.targetProgress=.65,this.targetShadowX=-.4,this.targetEmissive=.2,this.targetDarkness=.7;break;case"total":this.targetProgress=1,this.targetShadowX=0,this.targetEmissive=.39,this.targetDarkness=.53;break;default:return void console.warn(`Unknown lunar eclipse type: ${e}`)}this.animating=!0,this.startTime=performance.now()}update(e){if(!this.animating)return;const t=performance.now()-this.startTime,n=Math.min(t/this.animationDuration,1),a=sv(n);this.progress=this.progress+(this.targetProgress-this.progress)*a,this.shadowX=this.shadowX+(this.targetShadowX-this.shadowX)*a*this.shadowSpeed,this.emissiveStrength=this.emissiveStrength+(this.targetEmissive-this.emissiveStrength)*a,this.shadowDarkness=this.shadowDarkness+(this.targetDarkness-this.shadowDarkness)*a,this.material.uniforms.eclipseProgress.value=this.progress,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY],this.material.uniforms.emissiveStrength&&(this.material.uniforms.emissiveStrength.value=this.emissiveStrength),this.material.uniforms.shadowDarkness&&(this.material.uniforms.shadowDarkness.value=this.shadowDarkness);let i=0;"total"===this.eclipseType?i=this.progress:"partial"===this.eclipseType?i=.6*this.progress:"penumbral"===this.eclipseType&&(i=.25*this.progress),this.material.uniforms.eclipseIntensity.value=i,n>=1&&(this.animating=!1)}reset(){this.progress=0,this.targetProgress=0,this.shadowX=-2,this.targetShadowX=-2,this.emissiveStrength=0,this.targetEmissive=0,this.shadowDarkness=1,this.targetDarkness=1,this.animating=!1,this.eclipseType="off",this.material.uniforms.eclipseProgress&&(this.material.uniforms.eclipseProgress.value=0,this.material.uniforms.eclipseIntensity.value=0,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY]),this.material.uniforms.emissiveStrength&&(this.material.uniforms.emissiveStrength.value=0),this.material.uniforms.shadowDarkness&&(this.material.uniforms.shadowDarkness.value=1)}dispose(){}}const Pv=["crystal","rough","heart","star"];class Dv{constructor(e,t="/assets"){this.renderer=e,this.assetBasePath=t,this.solarEclipse=null,this.lunarEclipse=null,this.crystalSoul=null,this.currentGeometryType=null,this.coreGlowEnabled=!0}initializeForGeometry(e,t={}){const{coreMesh:n,customMaterial:a,sunRadius:i=1}=t;this.currentGeometryType=e,this._cleanupUnneededEffects(e),"sun"===e?this._initSolarEclipse(i,n):"moon"===e&&this._initLunarEclipse(a)}_initSolarEclipse(e,t){!this.solarEclipse&&this.renderer?.scene&&(this.solarEclipse=new Cv(this.renderer.scene,e,t))}_initLunarEclipse(e){!this.lunarEclipse&&e&&(this.lunarEclipse=new Tv(e))}_cleanupUnneededEffects(e){"sun"!==e&&this.solarEclipse&&(this.solarEclipse.dispose(),this.solarEclipse=null),"moon"!==e&&this.lunarEclipse&&(this.lunarEclipse.dispose(),this.lunarEclipse=null),!Pv.includes(e)&&this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null)}async createCrystalSoul(e={}){const{coreMesh:t,geometryType:n}=e;if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!t)return null;await Ey._loadInclusionGeometry(this.assetBasePath),this.crystalSoul=new Ey({radius:.35,detail:1,geometryType:n,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(t,this.renderer?.scene);const{shellBaseScale:a,soulScale:i}=this._getCrystalScaleConfig(n);return this.crystalSoul.baseScale=i,this.crystalSoul.mesh.scale.setScalar(i),this.crystalSoul.setVisible(this.coreGlowEnabled),{mesh:this.crystalSoul.mesh,material:this.crystalSoul.material,baseScale:this.crystalSoul.baseScale,shellBaseScale:a}}createCrystalSoulSync(e={}){const{coreMesh:t,geometryType:n}=e;if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!t)return null;this.crystalSoul=new Ey({radius:.35,detail:1,geometryType:n,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(t,this.renderer?.scene);const{shellBaseScale:a,soulScale:i}=this._getCrystalScaleConfig(n);return this.crystalSoul.baseScale=i,this.crystalSoul.mesh.scale.setScalar(i),this.crystalSoul.setVisible(this.coreGlowEnabled),{mesh:this.crystalSoul.mesh,material:this.crystalSoul.material,baseScale:this.crystalSoul.baseScale,shellBaseScale:a}}_getCrystalScaleConfig(e){let t=2,n=1;return"heart"===e?(t=2.4,n=1):"rough"===e?(t=1.6,n=1):"star"===e?(t=2,n=1.4):"crystal"===e&&(t=2,n=1),{shellBaseScale:t,soulScale:n}}setSolarEclipse(e){return!!this.solarEclipse&&(this.solarEclipse.setEclipseType(e),!0)}setLunarEclipse(e){return!!this.lunarEclipse&&(this.lunarEclipse.setEclipseType(e),!0)}stopAllEclipses(){this.solarEclipse&&this.solarEclipse.setEclipseType("off"),this.lunarEclipse&&this.lunarEclipse.setEclipseType("off")}updateCrystalSoul(e,t,n=1){this.crystalSoul&&this.crystalSoul.update(e,t,n)}updateLunarEclipse(e){this.lunarEclipse&&this.lunarEclipse.update(e)}setCrystalSoulEffects(e){this.crystalSoul&&this.crystalSoul.setEffects(e)}setCrystalSoulSize(e){return this.crystalSoul?(this.crystalSoul.setSize(e),this.crystalSoul.baseScale):1}setCrystalSoulVisible(e){this.coreGlowEnabled=e,this.crystalSoul&&this.crystalSoul.setVisible(e)}hasCrystalSoul(){return!!this.crystalSoul}getCrystalSoulBaseScale(){return this.crystalSoul?.baseScale??1}hasSolarEclipse(){return!!this.solarEclipse}hasLunarEclipse(){return!!this.lunarEclipse}getSolarEclipse(){return this.solarEclipse}dispose(){this.solarEclipse&&(this.solarEclipse.dispose(),this.solarEclipse=null),this.lunarEclipse&&(this.lunarEclipse.dispose(),this.lunarEclipse=null),this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),this.renderer=null}}class Ov{constructor(e={},t=null,n=null){if(this.config=e,this.rhythmEngine=t,this.geometryRotation=n,this.type=e.type||"gentle",this.speed=e.speed||1,n&&void 0!==n.baseSpeed){const e=n.baseSpeed,t=n.axes||[0,1,0];this.axes=[t[0]*e*this.speed,t[1]*e*this.speed,t[2]*e*this.speed]}else this.axes=e.axes||[0,.01,0];this.shake=e.shake||{amplitude:0,frequency:0},this.wobbleEnabled=!0,this.eruption=e.eruption||{enabled:!1},this.eruption.enabled&&(this.eruption.interval=this.eruption.interval||3e3,this.eruption.speedMultiplier=this.eruption.speedMultiplier||3,this.eruption.duration=this.eruption.duration||400,this.eruption.nextEruptionTime=this.eruption.interval,this.eruption.eruptionStartTime=-1),this.musicSync=void 0!==e.musicSync&&e.musicSync,this.time=0,this.episodicWobble={enabled:!1,minInterval:2e3,maxInterval:5e3,amplitude:.05,duration:200,nextWobbleTime:0,wobbleStartTime:-1,wobbleTarget:[0,0,0]}}update(e,t){switch(this.time+=e,this.episodicWobble.enabled&&this.wobbleEnabled&&this._applyEpisodicWobble(e,t),this.type){case"gentle":default:return this._evaluateGentle(e,t);case"unstable":return this._evaluateUnstable(e,t);case"rhythmic":return this._evaluateRhythmic(e,t);case"orbital":return this._evaluateOrbital(e,t);case"still":return this._evaluateStill(e,t);case"suspicious":return this._evaluateSuspicious(e,t)}}_evaluateGentle(e,t){const n=.001*e;return t[0]+=this.axes[0]*this.speed*n,t[1]+=this.axes[1]*this.speed*n,t[2]+=this.axes[2]*this.speed*n,t}_evaluateUnstable(e,t){const n=.001*e;let a=1;if(this.eruption.enabled&&(this.eruption.eruptionStartTime<0&&this.time>=this.eruption.nextEruptionTime&&(this.eruption.eruptionStartTime=this.time),this.eruption.eruptionStartTime>=0)){const e=this.time-this.eruption.eruptionStartTime;if(e<this.eruption.duration){const t=e/this.eruption.duration,n=Math.sin(t*Math.PI);a=1+(this.eruption.speedMultiplier-1)*n}else this.eruption.eruptionStartTime=-1,this.eruption.nextEruptionTime=this.time+this.eruption.interval}const i=this.speed*a;if(t[0]+=this.axes[0]*i*n,t[1]+=this.axes[1]*i*n,t[2]+=this.axes[2]*i*n,this.wobbleEnabled){const e=.001*this.time,n=this.shake.frequency||8,a=this.shake.amplitude||.02,i=.02,r=Math.min(a,i),s=Math.sin(e*n*Math.PI*2)*r*.7,o=Math.sin(e*n*Math.PI*2*1.3)*r*.5,l=Math.sin(e*n*Math.PI*2*.9)*r*.8;t[0]+=s,t[1]+=o,t[2]+=l}return t}_evaluateRhythmic(e,t){const n=.001*e;if(!this.musicSync||!this.rhythmEngine)return this._evaluateGentle(e,t);{const e=60/(this.rhythmEngine.bpm||120),a=.001*this.time%e,i=1+.3*Math.sin(a/e*Math.PI*2);t[0]+=this.axes[0]*this.speed*i*n,t[1]+=this.axes[1]*this.speed*i*n,t[2]+=this.axes[2]*this.speed*i*n}return t}_evaluateOrbital(e,t){const n=.001*e,a=.001*this.time,i=.5*this.speed,r=.1*Math.sin(a*i*Math.PI*2),s=.05*Math.sin(a*i*Math.PI*2*.5);return t[0]+=r*n,t[1]+=this.axes[1]*this.speed*n,t[2]+=s*n,t}_evaluateStill(e,t){const n=.001*e;return t[0]+=.1*this.axes[0]*n,t[1]+=.1*this.axes[1]*n,t[2]+=.1*this.axes[2]*n,t}_evaluateSuspicious(e,t){const n=.001*e,a=.001*this.time,i=4/this.speed,r=a%i/i;let s;if(r<.85)s=r/.85*Math.PI;else{const e=(r-.85)/.15;s=Math.PI*(1-e)}const o=s-t[1];return t[1]+=3*o*n,t}reset(){this.time=0}_applyEpisodicWobble(e,t){const n=this.episodicWobble;if(-1===n.wobbleStartTime&&this.time>=n.nextWobbleTime){n.wobbleStartTime=this.time,n.wobbleTarget=[(Math.random()-.5)*n.amplitude,(Math.random()-.5)*n.amplitude,(Math.random()-.5)*n.amplitude];const e=n.minInterval+Math.random()*(n.maxInterval-n.minInterval);n.nextWobbleTime=this.time+e}if(-1!==n.wobbleStartTime){const e=this.time-n.wobbleStartTime,a=Math.min(e/n.duration,1);if(a<1){const e=Math.sin(a*Math.PI);t[0]+=n.wobbleTarget[0]*e,t[1]+=n.wobbleTarget[1]*e,t[2]+=n.wobbleTarget[2]*e}else n.wobbleStartTime=-1}}updateConfig(e){if(this.config=e,this.type=e.type||"gentle",this.speed=e.speed||1,this.geometryRotation&&void 0!==this.geometryRotation.baseSpeed){const e=this.geometryRotation.baseSpeed,t=this.geometryRotation.axes||[0,1,0];this.axes=[t[0]*e*this.speed,t[1]*e*this.speed,t[2]*e*this.speed]}else this.axes=e.axes||[0,.01,0];this.shake=e.shake||{amplitude:0,frequency:0},this.musicSync=void 0!==e.musicSync&&e.musicSync}applyUndertoneMultipliers(e){if(void 0!==e.speedMultiplier&&(this.speed*=e.speedMultiplier),void 0!==e.shakeMultiplier&&this.shake.amplitude&&(this.shake.amplitude*=e.shakeMultiplier),void 0!==e.enableEpisodicWobble&&(this.episodicWobble.enabled=e.enableEpisodicWobble,this.episodicWobble.enabled&&0===this.episodicWobble.nextWobbleTime)){const e=this.episodicWobble.minInterval+Math.random()*(this.episodicWobble.maxInterval-this.episodicWobble.minInterval);this.episodicWobble.nextWobbleTime=this.time+e}}setWobbleEnabled(e){this.wobbleEnabled=e}}class Ev{constructor(e={}){this.config=e,this.strength=void 0!==e.strength?e.strength:.5,this.damping=void 0!==e.damping?e.damping:.8,this.centerOfMass=e.centerOfMass||[0,-.3,0],this.axes=e.axes||{pitch:!0,roll:!0,yaw:!1},this.angularVelocity={x:0,y:0,z:0}}update(e,t){if(0===this.strength)return t;const n=.001*e,a=t[0],i=t[1],r=t[2];if(this.axes.pitch){const e=-a*this.strength;this.angularVelocity.x+=e*n,this.angularVelocity.x*=1-this.damping,t[0]+=this.angularVelocity.x*n}if(this.axes.roll){const e=-r*this.strength;this.angularVelocity.z+=e*n,this.angularVelocity.z*=1-this.damping,t[2]+=this.angularVelocity.z*n}if(this.axes.yaw){const e=-i*this.strength;this.angularVelocity.y+=e*n,this.angularVelocity.y*=1-this.damping,t[1]+=this.angularVelocity.y*n}return t}reset(){this.angularVelocity={x:0,y:0,z:0}}updateConfig(e){this.config=e,this.strength=void 0!==e.strength?e.strength:this.strength,this.damping=void 0!==e.damping?e.damping:this.damping,this.centerOfMass=e.centerOfMass||this.centerOfMass,this.axes=e.axes||this.axes}applyUndertoneMultipliers(e){void 0!==e.strengthMultiplier&&(this.strength*=e.strengthMultiplier)}}class Iv{constructor(e={},t=null){this.config=e,this.camera=t,this.strength=void 0!==e.strength?e.strength:1,this.lockedFace=e.lockedFace||[0,0,1],this.calibrationRotation=e.calibrationRotation||[0,0,0],this.lerpSpeed=void 0!==e.lerpSpeed?e.lerpSpeed:1,this.tempVector=new Gt,this.tempQuaternion=new Ut,this.targetQuaternion=new Ut,this.calibrationQuaternion=new Ut,this.currentQuaternion=new Ut,this._lockedFaceVec=new Gt,this._targetMatrix=new Vn,this._lookAtOrigin=new Gt(0,0,0),this._upVector=new Gt(0,1,0),this._tempEuler=new Qn(0,0,0,"XYZ"),this._defaultPosition=new Gt(0,0,0)}update(e,t,n){if(0===this.strength||!this.camera)return t;const a=n||this._defaultPosition,i=.001*e;this.tempVector.copy(this.camera.position).sub(a),this.tempVector.lengthSq()<1e-4&&this.tempVector.set(0,0,1),this.tempVector.normalize(),this._lockedFaceVec.set(this.lockedFace[0],this.lockedFace[1],this.lockedFace[2]).normalize(),this._targetMatrix.lookAt(this.tempVector,this._lookAtOrigin,this._upVector),this.targetQuaternion.setFromRotationMatrix(this._targetMatrix),0===this.calibrationRotation[0]&&0===this.calibrationRotation[1]&&0===this.calibrationRotation[2]||(this._tempEuler.set(this.calibrationRotation[0],this.calibrationRotation[1],this.calibrationRotation[2],"XYZ"),this.calibrationQuaternion.setFromEuler(this._tempEuler),this.targetQuaternion.multiply(this.calibrationQuaternion)),this._tempEuler.set(t[0],t[1],t[2],"XYZ"),this.currentQuaternion.setFromEuler(this._tempEuler);const r=Math.min(1,this.strength*this.lerpSpeed*i*60);return this.currentQuaternion.slerp(this.targetQuaternion,r),this._tempEuler.setFromQuaternion(this.currentQuaternion,"XYZ"),t[0]=this._tempEuler.x,t[1]=this._tempEuler.y,t[2]=this._tempEuler.z,t}setCamera(e){this.camera=e}setCalibrationRotation(e){this.calibrationRotation=e}updateConfig(e){this.config=e,this.strength=void 0!==e.strength?e.strength:this.strength,this.lockedFace=e.lockedFace||this.lockedFace,this.calibrationRotation=e.calibrationRotation||this.calibrationRotation,this.lerpSpeed=void 0!==e.lerpSpeed?e.lerpSpeed:this.lerpSpeed}dispose(){this.camera=null,this.tempVector=null,this.tempQuaternion=null,this.targetQuaternion=null,this.calibrationQuaternion=null,this.currentQuaternion=null}}const kv={strength:5,damping:.85,centerOfMass:[0,-.3,0],axes:{pitch:!0,roll:!0,yaw:!1}};class Rv{constructor(e={}){this.rotationBehavior=null,this.rightingBehavior=null,this.facingBehavior=null,this.rotationDisabled=e.rotationDisabled||!1,this.wobbleEnabled=!1!==e.wobbleEnabled,this.rhythmEngine=e.rhythmEngine||null,this.camera=e.camera||null,this.geometryType=null,this.rightingBehavior=new Ev(kv)}configureForEmotion(e={}){const{geometryType:t,emotionData:n,facingConfig:a,geometryRotation:i}=e;if(this.geometryType=t,"moon"===t)return this._disableRotation(),void this._initFacingBehavior(a);this._disposeFacingBehavior(),this.rotationDisabled?this._disableRotation():(n?.["3d"]?.rotation?this._configureRotationFromEmotion(n["3d"].rotation,i):this._ensureDefaultRotation(i),this.rightingBehavior&&this.rightingBehavior.reset())}applyUndertone(e){e&&(e.rotation&&this.rotationBehavior&&this.rotationBehavior.applyUndertoneMultipliers(e.rotation),e.righting&&this.rightingBehavior&&this.rightingBehavior.applyUndertoneMultipliers(e.righting))}update(e,t){this.rotationBehavior?this.rotationBehavior.update(e,t):"moon"===this.geometryType||this.rotationDisabled||(t[1]+=3e-4*e),this.rightingBehavior&&this.rightingBehavior.update(e,t),this.facingBehavior&&(t[0]=0,t[1]=0,t[2]=0)}setWobbleEnabled(e){this.wobbleEnabled=e,this.rotationBehavior&&this.rotationBehavior.setWobbleEnabled(e),!e&&this.rightingBehavior&&this.rightingBehavior.reset()}resetRighting(){this.rightingBehavior&&this.rightingBehavior.reset()}getAngularVelocity(){return this.rotationBehavior?this.rotationBehavior.axes:[0,0,0]}hasRotationBehavior(){return!!this.rotationBehavior}hasFacingBehavior(){return!!this.facingBehavior}configureForMorph(e={}){const{targetGeometryType:t,emotionData:n,facingConfig:a,geometryRotation:i}=e;this.resetRighting(),this.configureForEmotion({geometryType:t,emotionData:n,facingConfig:a,geometryRotation:i})}_configureRotationFromEmotion(e,t){this.rotationBehavior?this.rotationBehavior.updateConfig(e):this.rotationBehavior=new Ov(e,this.rhythmEngine,t),this.rotationBehavior.setWobbleEnabled(this.wobbleEnabled)}_ensureDefaultRotation(e){this.rotationBehavior||(this.rotationBehavior=new Ov({type:"gentle",speed:1,axes:[0,.01,0]},this.rhythmEngine,e),this.rotationBehavior.setWobbleEnabled(this.wobbleEnabled))}_disableRotation(){this.rotationBehavior=null}_initFacingBehavior(e){!this.facingBehavior&&e?.enabled&&(this.facingBehavior=new Iv({strength:e.strength,lockedFace:e.lockedFace,lerpSpeed:e.lerpSpeed,calibrationRotation:e.calibrationRotation},this.camera))}_disposeFacingBehavior(){this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null)}dispose(){this.rotationBehavior&&(this.rotationBehavior.destroy?.(),this.rotationBehavior=null),this.rightingBehavior&&(this.rightingBehavior.destroy?.(),this.rightingBehavior=null),this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null)}}class zv{constructor(){this._phase=null,this._startTime=0,this._duration=0,this._startScale=1,this._targetScale=1,this._currentScale=1}startPhase(e,t){const n=Math.max(.5,Math.min(30,t));switch(this._startScale=this._currentScale,this._startTime=performance.now(),this._duration=1e3*n,this._phase=e,e){case"inhale":this._targetScale=1.3;break;case"exhale":this._targetScale=.85;break;default:this._targetScale=this._startScale}}stop(){this._phase=null,this._currentScale=1,this._startScale=1,this._targetScale=1}isActive(){return null!==this._phase}getPhase(){return this._phase}update(e){if(!this._phase)return this._currentScale;const t=performance.now()-this._startTime,n=Math.min(1,t/this._duration),a=Math.sin(n*Math.PI/2);return this._currentScale=this._startScale+(this._targetScale-this._startScale)*a,n>=1&&(this._currentScale=this._targetScale,this._phase=null),this._currentScale}getScaleMultiplier(){return this._currentScale}getState(){return{phase:this._phase,startScale:this._startScale,targetScale:this._targetScale,currentScale:this._currentScale,duration:this._duration,isActive:null!==this._phase}}dispose(){this._phase=null}}class Fv{static generate(e,t={}){const{shardCount:n=30,seed:a=Date.now(),preserveUVs:i=!0}=t,r=e.index?e:this._toIndexed(e),s=r.getAttribute("position"),o=r.getIndex(),l=r.getAttribute("uv"),c=r.getAttribute("normal");if(!o||0===o.count)return console.warn("ShardGenerator: No valid indices found"),[];const h=o.count/3;if(0===h)return console.warn("ShardGenerator: No faces found"),[];const d=this._buildAdjacencyGraph(o,h),u=Math.min(n,h);return this._clusterFaces(d,u,h,a).filter(e=>e.length>0).map(e=>this._createShardGeometry(e,s,o,i?l:null,c))}static _toIndexed(e){const t=e.getAttribute("position"),n=[];for(let e=0;e<t.count;e++)n.push(e);const a=e.clone();return a.setIndex(n),a}static _buildAdjacencyGraph(e,t){const n=new Map,a=new Map;for(let i=0;i<t;i++){const t=e.getX(3*i),r=e.getX(3*i+1),s=e.getX(3*i+2);[[Math.min(t,r),Math.max(t,r)],[Math.min(r,s),Math.max(r,s)],[Math.min(s,t),Math.max(s,t)]].forEach(([e,t])=>{const n=`${e},${t}`;a.has(n)||a.set(n,[]),a.get(n).push(i)}),n.set(i,new Set)}for(const e of a.values())2===e.length&&(n.get(e[0]).add(e[1]),n.get(e[1]).add(e[0]));return n}static _clusterFaces(e,t,n,a){const i=this._seededRandom(a),r=new Array(n).fill(-1),s=[],o=[],l=[...Array(n).keys()];for(let e=0;e<t&&0!==l.length;e++){const e=Math.floor(i()*l.length);o.push(l.splice(e,1)[0])}o.forEach((e,t)=>{s.push([e]),r[e]=t});let c=!0,h=0;const d=2*n;for(;c&&h<d;){c=!1,h++;for(let t=0;t<s.length;t++){const n=s[t],a=[];for(const i of n){const n=e.get(i);if(n)for(const e of n)-1===r[e]&&(r[e]=t,a.push(e),c=!0)}s[t]=[...n,...a]}}for(let e=0;e<n;e++)if(-1===r[e]){let t=1/0,n=0;for(let e=0;e<s.length;e++)s[e].length<t&&(t=s[e].length,n=e);s[n].push(e),r[e]=n}return s}static _createShardGeometry(e,t,n,a,i){const r=[],s=[],o=[],l=[],c=new Map;let h=1/0,d=1/0,u=1/0,p=-1/0,m=-1/0,f=-1/0;for(const g of e){const e=[n.getX(3*g),n.getX(3*g+1),n.getX(3*g+2)].map(e=>{if(!c.has(e)){const n=r.length/3;c.set(e,n);const l=t.getX(e),g=t.getY(e),y=t.getZ(e);r.push(l,g,y),h=Math.min(h,l),d=Math.min(d,g),u=Math.min(u,y),p=Math.max(p,l),m=Math.max(m,g),f=Math.max(f,y),a&&s.push(a.getX(e),a.getY(e)),i&&o.push(i.getX(e),i.getY(e),i.getZ(e))}return c.get(e)});l.push(...e)}const g=new ei;g.setAttribute("position",new ja(r,3)),s.length>0&&g.setAttribute("uv",new ja(s,2)),o.length>0?g.setAttribute("normal",new ja(o,3)):g.computeVertexNormals(),g.setIndex(l);const y=new Gt((h+p)/2,(d+m)/2,(u+f)/2);g.userData.centroid=y;const v=(p-h)*(m-d)*(f-u);return g.userData.volume=Math.max(v,.001),g.computeBoundingBox(),g.computeBoundingSphere(),g}static _seededRandom(e){let t=e%2147483647;return t<=0&&(t+=2147483646),()=>(t=1103515245*t+12345&2147483647,t/2147483647)}static hashGeometry(e){const t=e.getAttribute("position");if(!t)return`empty_${Date.now()}`;let n=0;const a=Math.min(t.count,50),i=Math.max(1,Math.floor(t.count/a));for(let e=0;e<t.count;e+=i)n^=1e3*t.getX(e)|0,n^=1e3*t.getY(e)<<8,n^=1e3*t.getZ(e)<<16,n=31*n|0;return`geo_${t.count}_${Math.abs(n).toString(16)}`}}const Bv={crystal:e=>{const t=e?.uniforms;return{type:"physical",color:t?.emotionColor?.value?.clone()||new Ia(10053375),emissive:t?.glowColor?.value?.clone()||new Ia(6697932),emissiveIntensity:.4,transmission:.3,roughness:.15,metalness:0,ior:1.5,thickness:.2,iridescence:.2,clearcoat:.3,map:null}},rough:e=>{const t=e?.uniforms;return{type:"physical",color:t?.emotionColor?.value?.clone()||new Ia(8939229),emissive:t?.glowColor?.value?.clone()||new Ia(5583786),emissiveIntensity:.3,transmission:.2,roughness:.35,metalness:0,ior:1.4,thickness:.2,iridescence:.1,clearcoat:.2,map:null}},heart:e=>{const t=e?.uniforms;return{type:"physical",color:t?.emotionColor?.value?.clone()||new Ia(16729224),emissive:t?.glowColor?.value?.clone()||new Ia(13378150),emissiveIntensity:.5,transmission:.25,roughness:.2,metalness:0,ior:1.5,thickness:.2,iridescence:.15,clearcoat:.25,map:null}},star:e=>{const t=e?.uniforms;return{type:"physical",color:t?.emotionColor?.value?.clone()||new Ia(16768324),emissive:t?.glowColor?.value?.clone()||new Ia(16755200),emissiveIntensity:.7,transmission:.2,roughness:.1,metalness:.1,ior:1.6,thickness:.15,iridescence:.3,clearcoat:.4,map:null}},sun:e=>{const t=e?.uniforms;return{type:"physical",color:t?.coreColor?.value?.clone()||new Ia(16755200),emissive:t?.coronaColor?.value?.clone()||new Ia(16737792),emissiveIntensity:2,transmission:0,roughness:.3,metalness:0,ior:1,thickness:0,iridescence:0,clearcoat:0,map:null}},moon:e=>{const t=e?.uniforms;return{type:"physical",color:new Ia(16777215),emissive:new Ia(8947848),emissiveIntensity:.15,transmission:0,roughness:.85,metalness:0,ior:1,thickness:0,iridescence:0,clearcoat:0,map:t?.colorMap?.value||null,normalMap:t?.normalMap?.value||null}},sphere:e=>Bv.default(e),default:e=>{const t=e?.uniforms;return t?{type:"physical",color:t.color?.value?.clone()||t.baseColor?.value?.clone()||t.diffuse?.value?.clone()||new Ia(8947848),emissive:t.emissive?.value?.clone()||t.glowColor?.value?.clone()||new Ia(0),emissiveIntensity:t.emissiveIntensity?.value??.3,transmission:0,roughness:t.roughness?.value??.5,metalness:t.metalness?.value??0,ior:1,thickness:0,iridescence:0,clearcoat:0,map:t.map?.value||t.diffuseMap?.value||null}:{type:"physical",color:e?.color?.clone()||new Ia(8947848),emissive:e?.emissive?.clone()||new Ia(0),emissiveIntensity:e?.emissiveIntensity??0,transmission:e?.transmission??0,roughness:e?.roughness??.5,metalness:e?.metalness??0,ior:e?.ior??1.5,thickness:e?.thickness??0,iridescence:e?.iridescence??0,clearcoat:e?.clearcoat??0,map:e?.map||null,normalMap:e?.normalMap||null}}};function Lv(e,t){return(Bv[t]||Bv.default)(e)}function Nv(e){const t={color:e.color,emissive:e.emissive,emissiveIntensity:e.emissiveIntensity,roughness:e.roughness,metalness:e.metalness,side:2,transparent:!0,opacity:.9};return e.transmission>0&&(t.transmission=e.transmission,t.thickness=e.thickness||.2,t.ior=e.ior||1.5),e.iridescence>0&&(t.iridescence=e.iridescence,t.iridescenceIOR=1.3),e.clearcoat>0&&(t.clearcoat=e.clearcoat,t.clearcoatRoughness=.2),e.map&&(t.map=e.map),e.normalMap&&(t.normalMap=e.normalMap),new co(t)}function Vv(e,t={}){const n=e.emissiveIntensity>=1.5,{hueRange:a=.1,satRange:i=.1,lightRange:r=.15}=t,s=e.color.clone();if(n){const e=.5*Math.random();s.r=Math.min(1,s.r+.05*e),s.g=Math.max(.35,s.g-.6*e),s.b=Math.max(0,s.b-.2*e);const t=.2*(Math.random()-.2);s.r=Math.min(1,Math.max(.8,s.r+t)),s.g=Math.min(.9,Math.max(.2,s.g+.5*t))}else s.offsetHSL((Math.random()-.5)*a,(Math.random()-.5)*i,(Math.random()-.5)*r);if(e.color=s,e.emissive){const t=e.emissive.clone();if(n){const n=.4*Math.random();t.r=Math.min(1,t.r+.1*n),t.g=Math.max(.3,t.g-.5*n),t.b=Math.max(0,t.b-.3*n);const a=.85+.55*Math.random();e.emissiveIntensity*=a}else t.offsetHSL((Math.random()-.5)*a*.5,(Math.random()-.5)*i*.5,(Math.random()-.5)*r*.5);e.emissive=t}}function Uv(e={}){const{color:t=new Ia(16755200),intensity:n=3,opacity:a=.6}=e;return new bi({uniforms:{uColor:{value:t.clone()},uIntensity:{value:n},uOpacity:{value:a}},vertexShader:"\n            void main() {\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uIntensity;\n            uniform float uOpacity;\n\n            void main() {\n                // Simple emissive fire - uniform glow, let bloom soften edges\n                vec3 fireColor = uColor * uIntensity;\n                gl_FragColor = vec4(fireColor, uOpacity);\n            }\n        ",transparent:!0,blending:2,depthWrite:!1,side:2})}class Gv{constructor(e={}){const{maxShards:t=50,scene:n=null}=e;this.maxShards=t,this.scene=n,this.pool=[],this.active=[],this.shardMaterial=null,this._placeholderGeometry=null,this._tempVec3_basePos=new Gt,this._tempVec3_moveDir=new Gt,this._tempVec3_up=new Gt(0,1,0),this._tempVec3_perpX=new Gt,this._tempVec3_perpY=new Gt,this._tempVec3_perpAxis=new Gt,this._tempVec3_targetPos=new Gt,this._tempQuat=new Ut,this._initPool()}_initPool(){this._placeholderGeometry=new ei,this._placeholderGeometry.setAttribute("position",new ja([0,0,0,0,0,0,0,0,0],3)),this.shardMaterial=this._createShardMaterial();for(let e=0;e<this.maxShards;e++){const t=new ui(this._placeholderGeometry,this.shardMaterial);t.visible=!1,t.frustumCulled=!0,t.userData.poolIndex=e,t.userData.state=this._createShardState(),this.pool.push(t),this.scene&&this.scene.add(t)}}_createShardMaterial(){return new co({transparent:!0,opacity:.9,side:2,metalness:.1,roughness:.15,transmission:.3,thickness:.2,ior:1.5,emissive:new Ia(0),emissiveIntensity:0,iridescence:.2,iridescenceIOR:1.3,clearcoat:.3,clearcoatRoughness:.2})}_createShardState(){return{velocity:new Gt,angularVelocity:new Gt,lifetime:0,maxLifetime:2e3,opacity:1,gravity:-9.8,originalPosition:new Gt,originalRotation:new Qn,originalQuaternion:new Ut,originalScale:new Gt(1,1,1),localCentroid:new Gt,impactGlow:1,baseEmissiveIntensity:.5,reassemblyStartPos:new Gt,reassemblyStartRot:new Qn,reassemblyStartQuat:new Ut,reassemblyStartScale:new Gt(1,1,1),depthFactor:0,vortexPhase:0,isSuspendMode:!1,suspendProgress:0,floatPhase:Math.random()*Math.PI*2,dualMode:null,implodeStartPos:new Gt,dissolveVelocity:new Gt,dissolveOpacity:1,rippleDelay:0,ripplePhase:0,gravityVelocity:new Gt,bounceCount:0,onFloor:!1,orbitRadius:0,orbitAngle:0,orbitSpeed:0,orbitHeight:0,orbitTilt:0,isFiery:!1,flickerPhase:0,flickerSpeed:0,scalePulsePhase:0,jitterSeed:0,distFromCenter:0,baseScale:new Gt(1,1,1),basePosition:new Gt,elementalType:null,elementalDrag:0,elementalBounce:0,riseSpeed:0,disperseRate:0,isSharedElementalMaterial:!1}}activate(e,t,n,a={}){const{explosionForce:i=2,rotationForce:r=5,lifetime:s=2e3,gravity:o=-9.8,inheritVelocity:l=new Gt,meshPosition:c=new Gt,meshQuaternion:h=new Ut,meshScale:d=new Gt(1,1,1),isSuspendMode:u=!1,baseMaterial:p=null,elementalPhysics:m=null,elementalType:f=null}=a;this._elementalPhysics=m,this._elementalType=f;const g=Math.min(e.length,this.pool.length),y=[];for(let a=0;a<g&&0!==this.pool.length;a++){const g=this.pool.pop(),v=e[a];g.geometry!==this._placeholderGeometry&&g.geometry.dispose(),g.geometry=v.clone();const b=v.userData.centroid?v.userData.centroid.clone():new Gt,w=b.clone();w.multiply(d),w.applyQuaternion(h),w.add(c),g.position.copy(w),g.quaternion.copy(h),g.scale.copy(d),g.userData.state.originalPosition.copy(w),g.userData.state.originalRotation.copy(g.rotation),g.userData.state.originalQuaternion.copy(g.quaternion),g.userData.state.originalScale.copy(d),g.userData.state.localCentroid.copy(b),g.userData.state.depthFactor=b.z,g.userData.state.vortexPhase=Math.random()*Math.PI*2;const x=w.clone().sub(t),S=x.length();x.normalize();const M=i*Math.max(.3,1/(1+2*S)),_=Math.max(.2,1-3*S);x.lerp(n,.6*_),x.normalize(),x.x+=.3*(Math.random()-.5),x.y+=.3*(Math.random()-.5)+.15,x.z+=.3*(Math.random()-.5),x.normalize(),g.userData.state.velocity.copy(x).multiplyScalar(M).add(l);const A=this._tempVec3_perpAxis.crossVectors(n,this._tempVec3_up.set(0,1,0)).normalize(),C=.5*_;if(g.userData.state.angularVelocity.set((Math.random()-.5)*r+A.x*C*r,(Math.random()-.5)*r+A.y*C*r,(Math.random()-.5)*r+A.z*C*r),g.userData.state.lifetime=0,g.userData.state.maxLifetime=s+(Math.random()-.5)*s*.3,g.userData.state.opacity=1,g.userData.state.gravity=o,g.userData.state.impactGlow=1,g.userData.state.baseEmissiveIntensity=.5,g.userData.state.isSuspendMode=u,g.userData.state.suspendProgress=0,g.userData.state.floatPhase=Math.random()*Math.PI*2,g.userData.state.elementalType=f,m&&(g.userData.state.elementalDrag=m.drag||0,g.userData.state.elementalBounce=m.bounce||0,g.userData.state.riseSpeed=m.riseSpeed||0,g.userData.state.disperseRate=m.disperseRate||0),p)if(g.material!==this.shardMaterial&&g.material.dispose(),"ShaderMaterial"===p.type&&p.userData?.elementalType)g.material=p,g.userData.state.isSharedElementalMaterial=!0;else{const e=p.clone();Vv(e),g.material=e,g.userData.state.isSharedElementalMaterial=!1}if(g.visible=!0,g.userData.state.isSharedElementalMaterial)g.userData.state.isFiery=!1;else if(g.material.map)g.material.emissiveIntensity=.5,g.userData.state.isFiery=!1;else if(g.material.emissiveIntensity>=1.5){g.userData.state.isFiery=!0;const e=g.material.emissive?.clone()||g.material.color?.clone()||new Ia(16755200),n=.5*Math.random();e.r=Math.min(1,e.r+.05*n),e.g=Math.max(.35,e.g-.4*n),e.b=Math.max(0,e.b-.2*n);const a=w.clone().sub(t).length();g.userData.state.distFromCenter=a;const i=.5,r=Math.min(1,a/i);let s=3+1.5*Math.random();r<.3&&(e.r=Math.min(1,e.r+.1),e.g=Math.min(1,e.g+.08),s*=1.3),g.material.dispose(),g.material=Uv({color:e,intensity:s,opacity:.6+.2*Math.random()}),g.userData.state.baseFireIntensity=s,g.userData.state.flickerPhase=Math.random()*Math.PI*2,g.userData.state.flickerSpeed=8+8*Math.random(),g.userData.state.scalePulsePhase=Math.random()*Math.PI*2,g.userData.state.baseScale.copy(g.scale),g.userData.state.jitterSeed=1e3*Math.random(),g.userData.state.basePosition.copy(g.position)}else g.material.emissiveIntensity=1.5,g.userData.state.isFiery=!1;this.active.push(g),y.push(g)}if(y.length>1){let e=1/0,t=-1/0;for(const n of y){const a=n.userData.state.depthFactor;e=Math.min(e,a),t=Math.max(t,a)}const n=t-e;if(n>.001)for(const t of y)t.userData.state.depthFactor=1-(t.userData.state.depthFactor-e)/n}return y.length}update(e){const t=e/1e3,n=performance.now()/1e3;for(let a=this.active.length-1;a>=0;a--){const i=this.active[a],{state:r}=i.userData;r.lifetime+=e;const s=r.lifetime/r.maxLifetime;if(s>=1)this._deactivateShard(i,a);else{if(r.isSuspendMode){const e=r.suspendProgress,a=r.gravity*(1-e);r.velocity.y+=a*t;const s=.995-.145*e;if(r.velocity.multiplyScalar(s),r.angularVelocity.multiplyScalar(s),i.position.addScaledVector(r.velocity,t),e>.5){const t=2*(e-.5),a=.8,s=.003*t,o=.001*t;i.position.y+=Math.sin(n*a+r.floatPhase)*s,i.position.x+=Math.sin(n*a*.7+1.3*r.floatPhase)*o,i.position.z+=Math.cos(n*a*.5+.7*r.floatPhase)*o}i.rotation.x+=r.angularVelocity.x*t,i.rotation.y+=r.angularVelocity.y*t,i.rotation.z+=r.angularVelocity.z*t}else r.velocity.y+=r.gravity*t,i.position.addScaledVector(r.velocity,t),i.rotation.x+=r.angularVelocity.x*t,i.rotation.y+=r.angularVelocity.y*t,i.rotation.z+=r.angularVelocity.z*t,r.velocity.multiplyScalar(.995),r.angularVelocity.multiplyScalar(.99);if(r.isFiery){const e=.1*Math.sin(n*r.flickerSpeed+r.flickerPhase)+.05*Math.sin(n*r.flickerSpeed*2.3+1.7*r.flickerPhase)+.85;r.flickerMultiplier=e;const t=3+1*Math.sin(r.scalePulsePhase),a=1+.05*Math.sin(n*t+r.scalePulsePhase);i.scale.copy(r.baseScale).multiplyScalar(a);const s=.003,o=Math.sin(12*n+r.jitterSeed)*s,l=Math.sin(15*n+1.3*r.jitterSeed)*s,c=Math.sin(10*n+.7*r.jitterSeed)*s;0===r.basePosition.lengthSq()&&r.basePosition.copy(i.position),i.position.x+=o,i.position.y+=l,i.position.z+=c}if(r.isSharedElementalMaterial&&i.material.uniforms)i.material.uniforms.uTime&&(i.material.uniforms.uTime.value=n),s>.7&&!r.isSuspendMode&&(r.opacity=1-(s-.7)/.3,i.material.uniforms.uOpacity&&(i.material.uniforms.uOpacity.value=.7*r.opacity));else if(r.isFiery&&i.material.uniforms){const e=r.flickerMultiplier||1,t=r.baseFireIntensity||3;i.material.uniforms.uIntensity.value=t*e,s>.7&&!r.isSuspendMode&&(r.opacity=1-(s-.7)/.3,i.material.uniforms.uOpacity.value=.6*r.opacity)}else{const e=i.material.map?.3:1;if(s<.2){const t=s/.2;r.impactGlow=1-t*t;const n=r.baseEmissiveIntensity+r.impactGlow*e;i.material.emissiveIntensity=n}else if(s<.5)i.material.emissiveIntensity=.8*r.baseEmissiveIntensity*e;else{const t=(s-.5)/.5;i.material.emissiveIntensity=r.baseEmissiveIntensity*(1-t)*e}s>.7&&!r.isSuspendMode&&(r.opacity=1-(s-.7)/.3,i.material.opacity=.9*r.opacity)}if(s>.8&&!r.isSuspendMode){const e=1-(s-.8)/.2*.5;i.scale.copy(r.originalScale).multiplyScalar(e)}}}}_deactivateShard(e,t){e.visible=!1,e.scale.set(1,1,1),e.userData.state.isFiery=!1,e.userData.state.basePosition.set(0,0,0),e.material!==this.shardMaterial&&(e.userData.state.isSharedElementalMaterial||e.material.dispose(),e.material=this.shardMaterial),e.userData.state.isSharedElementalMaterial=!1,this.active.splice(t,1),this.pool.push(e)}captureCurrentPositions(){for(const e of this.active){const{state:t}=e.userData;t.reassemblyStartPos.copy(e.position),t.reassemblyStartRot.copy(e.rotation),t.reassemblyStartQuat.copy(e.quaternion),t.reassemblyStartScale.copy(e.scale)}}updateReassembly(e,t=null){const n=performance.now()/1e3;for(const a of this.active){const{state:i}=a.userData;let r,s,o;t&&i.localCentroid?(r=this._tempVec3_targetPos.copy(i.localCentroid).multiply(t.scale).applyQuaternion(t.quaternion).add(t.position),s=t.quaternion,o=i.originalScale):(r=i.originalPosition,s=i.originalQuaternion,o=i.originalScale);const l=.3*i.depthFactor,c=Math.max(0,(e-l)/(1-l)),h=Math.min(1,c),d=this._tempVec3_basePos.lerpVectors(i.reassemblyStartPos,r,h),u=.15*Math.sin(h*Math.PI),p=i.vortexPhase+h*Math.PI*2,m=u*(1-h),f=this._tempVec3_moveDir.subVectors(r,i.reassemblyStartPos).normalize(),g=this._tempVec3_up.set(0,1,0),y=this._tempVec3_perpX.crossVectors(f,g).normalize(),v=this._tempVec3_perpY.crossVectors(y,f).normalize();let b;if(d.addScaledVector(y,Math.cos(p)*m),d.addScaledVector(v,Math.sin(p)*m),a.position.copy(d),this._tempQuat.slerpQuaternions(i.reassemblyStartQuat,s,h),a.quaternion.copy(this._tempQuat),a.scale.lerpVectors(i.reassemblyStartScale,o,h),h<.3){const e=8*n+i.vortexPhase;b=.3+(.5+.15*Math.sin(e))*h}else if(h<.7){const e=(h-.3)/.4;b=.5+.8*e+.1*Math.sin(12*n+i.vortexPhase)*(1-e)}else if(h<.95){const e=(h-.7)/.25;b=1.3+e*e*1.2}else b=2.5-(h-.95)/.05*1.5;a.material.emissiveIntensity=b;const w=.7+.2*h;a.material.opacity=Math.min(.9,w)}}updateSuspendProgress(e){for(const t of this.active)t.userData.state.suspendProgress=e}initImplodeMode(e={}){for(const e of this.active){const{state:t}=e.userData;t.dualMode="implode",t.implodeStartPos.copy(e.position),t.vortexPhase=Math.random()*Math.PI*2}}initDissolveMode(e={}){const t=e.windDirection||[1,.2,0],n=e.windForce||2,a=e.turbulence||.5;for(const e of this.active){const{state:i}=e.userData;i.dualMode="dissolve",i.dissolveOpacity=1,i.dissolveVelocity.set(t[0]*n+(Math.random()-.5)*a,t[1]*n+(Math.random()-.5)*a,t[2]*n+(Math.random()-.5)*a),i.floatPhase=Math.random()*Math.PI*2}}initGravityMode(e={}){const t=e.gravity||-15;for(const e of this.active){const{state:n}=e.userData;n.dualMode="gravity",n.gravity=t,n.gravityVelocity.set(.5*(Math.random()-.5),0,.5*(Math.random()-.5)),n.bounceCount=0,n.onFloor=!1}}initOrbitMode(e={}){const t=e.orbitSpeed||1,n=e.radiusMultiplier||1,a=new Gt;for(const e of this.active){const{state:i}=e.userData;i.dualMode="orbit";const r=e.position.clone().sub(a);i.orbitRadius=r.length()*n,i.orbitAngle=Math.atan2(r.x,r.z),i.orbitHeight=r.y,i.orbitSpeed=t*(.8+.4*Math.random()),i.orbitTilt=.3*(Math.random()-.5)}}applyImpulse(e,t=3,n=.4){for(const a of this.active){const{state:i}=a.userData;this._tempVec3_moveDir.set(e[0]*t+(Math.random()-.5)*n*t,e[1]*t+(Math.random()-.5)*n*t+.3,e[2]*t+(Math.random()-.5)*n*t),i.velocity.add(this._tempVec3_moveDir),i.angularVelocity.x+=6*(Math.random()-.5),i.angularVelocity.y+=6*(Math.random()-.5),i.angularVelocity.z+=6*(Math.random()-.5)}}updateImplode(e,t,n){const a=e/1e3,i=t*t*t;for(const e of this.active){const{state:r}=e.userData;if("implode"!==r.dualMode)continue;this._tempVec3_basePos.lerpVectors(r.implodeStartPos,n,i);const s=.15*(1-i),o=r.vortexPhase+t*Math.PI*4;this._tempVec3_basePos.x+=Math.cos(o)*s,this._tempVec3_basePos.z+=Math.sin(o)*s,e.position.copy(this._tempVec3_basePos);const l=1+5*i;e.rotation.x+=a*l*2,e.rotation.y+=a*l*3;const c=Math.max(.1,1-.8*i);e.scale.copy(r.originalScale).multiplyScalar(c),e.material.emissiveIntensity=.5+2*i,e.material.opacity=Math.max(.3,1-.5*i)}}updateDissolve(e,t,n={}){const a=e/1e3,i=performance.now()/1e3,r=n.turbulence||.5;for(const e of this.active){const{state:n}=e.userData;if("dissolve"!==n.dualMode)continue;this._tempVec3_moveDir.copy(n.dissolveVelocity).multiplyScalar(a),e.position.add(this._tempVec3_moveDir);const s=Math.sin(3*i+n.floatPhase)*r*.02,o=Math.sin(2*i+1.5*n.floatPhase)*r*.01,l=Math.cos(2.5*i+.8*n.floatPhase)*r*.02;e.position.x+=s,e.position.y+=o,e.position.z+=l,e.rotation.x+=.5*a,e.rotation.y+=.8*a;const c=Math.max(.05,1-t*t);e.scale.copy(n.originalScale).multiplyScalar(c),n.dissolveOpacity=Math.max(0,1-t),e.material.opacity=.9*n.dissolveOpacity,e.material.emissiveIntensity=.3*(1-t)}}updateGravityBounce(e,t,n=-1){const a=e/1e3;for(const e of this.active){const{state:i}=e.userData;if("gravity"===i.dualMode&&(i.gravityVelocity.y+=i.gravity*a,this._tempVec3_moveDir.copy(i.gravityVelocity).multiplyScalar(a),e.position.add(this._tempVec3_moveDir),e.position.y<=n&&i.bounceCount<3?(e.position.y=n,i.gravityVelocity.y*=-.5,i.gravityVelocity.x*=.8,i.gravityVelocity.z*=.8,i.bounceCount++,e.material.emissiveIntensity=.8):e.position.y<=n&&(e.position.y=n,i.gravityVelocity.set(0,0,0),i.onFloor=!0),i.onFloor||(e.rotation.x+=3*a,e.rotation.z+=2*a),e.material.emissiveIntensity=Math.max(.1,e.material.emissiveIntensity-.5*a),t>.7)){const n=(t-.7)/.3;e.material.opacity=Math.max(.1,.9-.8*n)}}}updateOrbit(e,t,n,a={}){const i=e/1e3,r=performance.now()/1e3;for(const e of this.active){const{state:t}=e.userData;if("orbit"!==t.dualMode)continue;t.orbitAngle+=t.orbitSpeed*i;const a=n.x+Math.sin(t.orbitAngle)*t.orbitRadius,s=n.z+Math.cos(t.orbitAngle)*t.orbitRadius,o=.05*Math.sin(2*r+t.floatPhase),l=n.y+t.orbitHeight+o,c=Math.sin(t.orbitAngle+t.orbitTilt)*t.orbitRadius*.1;e.position.set(a,l+c,s),e.lookAt(n),e.rotation.z+=.5*i;const h=.3+.2*Math.sin(3*r+t.floatPhase);e.material.emissiveIntensity=h;const d=1+.05*Math.sin(2*r+t.floatPhase);e.scale.copy(t.originalScale).multiplyScalar(d)}}clear(){for(let e=this.active.length-1;e>=0;e--){const t=this.active[e];t.visible=!1,t.scale.set(1,1,1),t.material!==this.shardMaterial&&(t.userData.state.isSharedElementalMaterial||t.material.dispose(),t.material=this.shardMaterial),t.userData.state.isSharedElementalMaterial=!1,this.pool.push(t)}this.active=[]}updateMaterial(e){const t=[...this.pool,...this.active];for(const n of t)e.color&&n.material.color.copy(e.color),e.emissive&&(n.material.emissive.copy(e.emissive),n.material.emissiveIntensity=e.emissiveIntensity||.3)}setScene(e){if(this.scene!==e){if(this.scene)for(const e of[...this.pool,...this.active])this.scene.remove(e);if(this.scene=e,this.scene)for(const e of[...this.pool,...this.active])this.scene.add(e)}}get activeCount(){return this.active.length}get availableCount(){return this.pool.length}dispose(){this.clear();for(const e of this.pool)this.scene&&this.scene.remove(e),e.geometry!==this._placeholderGeometry&&e.geometry.dispose(),e.material.dispose();this.pool=[],this._placeholderGeometry&&(this._placeholderGeometry.dispose(),this._placeholderGeometry=null),this.shardMaterial&&(this.shardMaterial.dispose(),this.shardMaterial=null)}}function Wv(e,t,n,a){return a<.5?e+2*a*(t-e):t+2*(a-.5)*(n-t)}function qv(e={}){const{temperature:t=.5,opacity:n=.6}=e,a=1+2*t;const i=new bi({uniforms:{uTemperature:{value:t},uProgress:{value:0},uPulseSpeed:{value:a},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying float vVerticalPos;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n                vVerticalPos = position.y;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uTemperature;\n            uniform float uProgress;\n            uniform float uPulseSpeed;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying float vVerticalPos;\n\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            // Temperature-driven fire color (computed in shader, no uColor uniform)\n            vec3 fireColor(float t) {\n                if (t < 0.3) {\n                    // Deep red to orange (embers to flame)\n                    return vec3(\n                        0.8 + t * 0.67,\n                        0.1 + t * 1.0,\n                        0.0\n                    );\n                } else if (t < 0.7) {\n                    // Orange to yellow-white\n                    float lt = (t - 0.3) / 0.4;\n                    return vec3(1.0, 0.4 + lt * 0.5, lt * 0.3);\n                } else {\n                    // Yellow-white to blue-white (plasma)\n                    float lt = (t - 0.7) / 0.3;\n                    return vec3(1.0 - lt * 0.2, 0.9 + lt * 0.1, 0.3 + lt * 0.7);\n                }\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n                float NdotV = abs(dot(normal, viewDir));\n                float edgeness = 1.0 - NdotV;\n\n                //  CONSUMPTION FIELD \n                // Object-space position projected to 2D for consistent pattern\n                vec2 pos = vPosition.xz * 2.5 + vec2(vPosition.y * 0.8, -vPosition.y * 0.6);\n\n                // 3-octave FBM  organic creeping consumption boundary\n                float n1 = noise(pos * 1.5 + uTime * 0.12);\n                float n2 = noise(pos * 4.0 - uTime * 0.18);\n                float n3 = noise(pos * 9.0 + uTime * 0.28);\n                float consumeField = n1 * 0.50 + n2 * 0.30 + n3 * 0.20;\n\n                // Fresnel bias: flames creep from silhouette edges\n                consumeField += edgeness * 0.15;\n\n                // Upward bias: flames lick from below  bottom consumes first\n                float vertBias = smoothstep(0.5, -0.5, vVerticalPos) * 0.25;\n                consumeField += vertBias;\n\n                //  DISSOLVE IN \n                float rawDissolve = smoothstep(0.0, 0.30, uProgress);\n                float dissolveIn = rawDissolve * rawDissolve;\n\n                //  PROGRESS-DRIVEN THRESHOLD \n                float rawRamp = smoothstep(0.05, 0.85, uProgress);\n                float progressRamp = rawRamp * rawRamp;\n\n                float targetThreshold = mix(0.85, 0.15, uTemperature);\n                float threshold = mix(0.95, targetThreshold, progressRamp);\n\n                float consumed = smoothstep(threshold, threshold - 0.05, consumeField);\n\n                //  TENDRILS \n                // Fine flame tendrils reaching AHEAD of the main consumption front\n                float tendrilField = noise(pos * 8.0 + uTime * 0.30) * 0.6\n                                   + noise(pos * 14.0 - uTime * 0.20) * 0.4;\n                float tendrilThreshold = threshold + 0.10;\n                float tendrils = smoothstep(tendrilThreshold, tendrilThreshold - 0.03,\n                                            tendrilField + edgeness * 0.12);\n                tendrils *= 0.4 * smoothstep(0.0, 0.4, uTemperature * progressRamp);\n\n                float fireMask = max(consumed, tendrils);\n\n                //  FIRE COLOR \n                vec3 baseColor = fireColor(uTemperature);\n\n                // Internal noise variation  flowing flame texture, not flat\n                float colorNoise = noise(pos * 3.0 + vec2(0.0, -uTime * 0.3));\n                vec3 consumedColor = mix(baseColor, vec3(1.0, 0.95, 0.80), consumed * 0.3);\n                consumedColor *= 0.70 + colorNoise * 0.15;\n\n                // Scale brightness with temperature  kept low for additive stacking\n                consumedColor *= mix(0.15, 0.35, uTemperature);\n\n                //  EDGE EMISSION \n                // Warm rim where fire meets normal surface\n                float edgeBand = smoothstep(threshold - 0.05, threshold - 0.01, consumeField)\n                               * smoothstep(threshold + 0.03, threshold, consumeField);\n\n                float pulse = 0.85 + 0.15 * sin(uTime * uPulseSpeed);\n                edgeBand *= pulse;\n\n                vec3 color = consumedColor * fireMask;\n                color += vec3(1.0, 0.85, 0.50) * edgeBand * uTemperature * 0.5 * dissolveIn * uOpacity;\n\n                //  FRESNEL RIM \n                float fresnelGlow = pow(edgeness, 3.0) * uTemperature * progressRamp * 0.15;\n                color += baseColor * fresnelGlow * 0.3;\n\n                //  ALPHA \n                float alpha = fireMask * uOpacity * dissolveIn;\n                float edgeAlpha = edgeBand * uTemperature * 0.3 * dissolveIn * dissolveIn * uOpacity;\n                alpha = max(alpha, edgeAlpha);\n                alpha = max(alpha, fresnelGlow * dissolveIn * uOpacity * 0.5);\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(color, alpha);\n            }\n        ",transparent:!0,blending:2,depthWrite:!1,side:2});return i.userData.temperature=t,i.userData.elementalType="fire",i}function Hv(e,t,n){return e+(t-e)*n}function jv(e,t,n,a){return a<.5?e+2*a*(t-e):t+2*(a-.5)*(n-t)}function Xv(e={}){const{viscosity:t=.3,opacity:n=.7}=e,a=Hv(1.5,.6,t),i=new bi({uniforms:{uViscosity:{value:t},uProgress:{value:0},uPulseSpeed:{value:a},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying float vVerticalPos;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n                vVerticalPos = position.y;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uViscosity;\n            uniform float uProgress;\n            uniform float uPulseSpeed;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying float vVerticalPos;\n\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n                float NdotV = abs(dot(normal, viewDir));\n                float edgeness = 1.0 - NdotV;\n\n                //  CONSUMPTION FIELD \n                vec2 pos = vPosition.xz * 2.5 + vec2(vPosition.y * 0.8, -vPosition.y * 0.6);\n\n                float flowSpeed = mix(0.15, 0.06, uViscosity);\n                float n1 = noise(pos * 1.5 + uTime * flowSpeed);\n                float n2 = noise(pos * 4.0 - uTime * flowSpeed * 1.3);\n                float n3 = noise(pos * 9.0 + uTime * flowSpeed * 2.0);\n                float consumeField = n1 * 0.50 + n2 * 0.30 + n3 * 0.20;\n\n                consumeField += edgeness * 0.15;\n\n                // Downward bias: water runs down from top\n                float vertBias = smoothstep(-0.5, 0.5, vVerticalPos) * 0.25;\n                consumeField += vertBias;\n\n                //  DISSOLVE IN \n                float rawDissolve = smoothstep(0.0, 0.35, uProgress);\n                float dissolveIn = rawDissolve * rawDissolve;\n\n                //  PROGRESS-DRIVEN THRESHOLD \n                float rawRamp = smoothstep(0.05, 0.90, uProgress);\n                float progressRamp = rawRamp * rawRamp;\n\n                float targetThreshold = mix(0.85, 0.15, uViscosity);\n                float threshold = mix(0.95, targetThreshold, progressRamp);\n\n                float consumed = smoothstep(threshold, threshold - 0.05, consumeField);\n\n                //  DRIP TENDRILS \n                vec2 dripPos = vec2(vPosition.x * 2.0, vPosition.y * 6.0);\n                float dripField = noise(dripPos * 3.0 + vec2(0.0, uTime * flowSpeed * 3.0)) * 0.6\n                                + noise(dripPos * 7.0 - vec2(0.0, uTime * flowSpeed * 2.0)) * 0.4;\n                float tendrilThreshold = threshold + 0.10;\n                float tendrils = smoothstep(tendrilThreshold, tendrilThreshold - 0.03,\n                                            dripField + edgeness * 0.12);\n                tendrils *= 0.4 * smoothstep(0.0, 0.4, uViscosity * progressRamp + 0.3);\n\n                float waterMask = max(consumed, tendrils);\n\n                //  SPECULAR HIGHLIGHTS \n                // Glossy wet reflections  the primary visual cue for water\n                vec3 light1 = normalize(vec3(0.3, 1.0, 0.5));\n                vec3 half1 = normalize(light1 + viewDir);\n                float spec1 = pow(max(dot(normal, half1), 0.0), 128.0);\n\n                vec3 light2 = normalize(vec3(-0.6, 0.7, -0.4));\n                vec3 half2 = normalize(light2 + viewDir);\n                float spec2 = pow(max(dot(normal, half2), 0.0), 96.0);\n\n                vec3 specColor = vec3(0.7, 0.85, 1.0) * spec1 * 1.8\n                               + vec3(0.5, 0.7, 1.0) * spec2;\n\n                //  CAUSTIC SHIMMER \n                float c1 = noise(pos * 6.0 + vec2(uTime * 0.18, -uTime * 0.12));\n                float c2 = noise(pos * 11.0 - vec2(uTime * 0.10, uTime * 0.14));\n                float c3 = noise(pos * 2.5 + uTime * 0.05);\n                float caustic = c1 * c2;\n                caustic *= smoothstep(0.35, 0.65, c3);\n                caustic = smoothstep(0.32, 0.48, caustic);\n                vec3 causticColor = vec3(0.4, 0.6, 1.0) * caustic * 0.6;\n\n                //  FRESNEL RIM \n                float fresnel = pow(edgeness, 2.0) * progressRamp;\n                vec3 fresnelColor = vec3(0.3, 0.5, 0.8) * fresnel * 0.7;\n\n                //  EDGE EMISSION \n                float edgeBand = smoothstep(threshold - 0.05, threshold - 0.01, consumeField)\n                               * smoothstep(threshold + 0.03, threshold, consumeField);\n                float pulse = 0.85 + 0.15 * sin(uTime * uPulseSpeed);\n                edgeBand *= pulse;\n\n                //  COMPOSITE  ADDITIVE ONLY \n                // All effects ADD light. No dark base. Impossible to blackout any mascot.\n                vec3 color = vec3(0.0);\n                color += specColor * consumed;\n                color += causticColor * consumed;\n                color += fresnelColor;\n                color += vec3(0.3, 0.5, 0.8) * edgeBand * 0.6 * dissolveIn;\n\n                // Subtle blue tint wash in consumed areas (very faint additive glow)\n                color += vec3(0.02, 0.05, 0.10) * consumed * dissolveIn;\n\n                //  ALPHA \n                // With AdditiveBlending: result = src * alpha + dst\n                // Alpha controls brightness of added light, NOT background darkening\n                float alpha = waterMask * uOpacity * dissolveIn;\n                float edgeAlpha = edgeBand * 0.5 * dissolveIn * uOpacity;\n                alpha = max(alpha, edgeAlpha);\n                alpha = max(alpha, fresnel * dissolveIn * uOpacity * 0.5);\n\n                if (alpha < 0.05) discard;\n\n                gl_FragColor = vec4(color, alpha);\n            }\n        ",transparent:!0,blending:2,depthWrite:!1,side:2});return i.userData.viscosity=t,i.userData.elementalType="water",i}function Yv(e=.3){return{gravity:Hv(1,.5,e),bounce:Hv(.7,.2,e),drag:Hv(.01,.2,e),cohesion:jv(.8,.2,.7,e),spreadOnImpact:Hv(.3,.1,e),surfaceTension:jv(.9,.3,.6,e),wobbleOnMove:!0,mergeOnContact:e<.6}}function $v(e,t,n){return e+(t-e)*n}function Qv(e={}){const{melt:t=0,opacity:n=.7}=e,a=$v(.6,1.2,t),i=new bi({uniforms:{uMelt:{value:t},uProgress:{value:0},uPulseSpeed:{value:a},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uMelt;\n            uniform float uProgress;\n            uniform float uPulseSpeed;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            // 3-octave FBM for frost patches\n            float fbm(vec2 p) {\n                float f = 0.0;\n                f += 0.50 * noise(p); p *= 2.01;\n                f += 0.25 * noise(p); p *= 2.02;\n                f += 0.125 * noise(p);\n                return f / 0.875;\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n                float NdotV = abs(dot(normal, viewDir));\n                float edgeness = 1.0 - NdotV;\n\n                //  CONSUMPTION FIELD \n                vec2 pos = vPosition.xz * 2.5 + vec2(vPosition.y * 0.8, -vPosition.y * 0.6);\n\n                // Slow creeping  ice spreads deliberately\n                float n1 = noise(pos * 1.5 + uTime * 0.06);\n                float n2 = noise(pos * 4.0 - uTime * 0.08);\n                float n3 = noise(pos * 9.0 + uTime * 0.12);\n                float consumeField = n1 * 0.50 + n2 * 0.30 + n3 * 0.20;\n\n                // Fresnel-dominant bias: ice encases from edges inward (no gravity)\n                consumeField += edgeness * 0.25;\n\n                //  DISSOLVE IN \n                float rawDissolve = smoothstep(0.0, 0.40, uProgress);\n                float dissolveIn = rawDissolve * rawDissolve;\n\n                //  PROGRESS-DRIVEN THRESHOLD \n                float rawRamp = smoothstep(0.05, 0.95, uProgress);\n                float progressRamp = rawRamp * rawRamp;\n\n                // Inverted from fire/water: low melt = MORE coverage\n                float targetThreshold = mix(0.15, 0.85, uMelt);\n                float threshold = mix(0.95, targetThreshold, progressRamp);\n\n                float consumed = smoothstep(threshold, threshold - 0.05, consumeField);\n\n                //  FROST TENDRILS \n                // Crystalline feathered frost reaching ahead\n                float tendrilField = noise(pos * 10.0 + uTime * 0.10) * 0.6\n                                   + noise(pos * 16.0 - uTime * 0.07) * 0.4;\n                float tendrilThreshold = threshold + 0.10;\n                float tendrils = smoothstep(tendrilThreshold, tendrilThreshold - 0.03,\n                                            tendrilField + edgeness * 0.15);\n                // More tendrils when deeply frozen\n                tendrils *= 0.5 * smoothstep(0.0, 0.3, (1.0 - uMelt) * progressRamp + 0.2);\n\n                float iceMask = max(consumed, tendrils);\n\n                //  FROST PATCHES \n                // FBM-driven frost crystals on frozen surface  white/blue patches\n                float frostNoise = fbm(pos * 4.0 + uTime * 0.02);\n                float frost = smoothstep(0.35, 0.60, frostNoise);\n                frost *= (1.0 - uMelt);  // Frost fades as ice melts\n\n                //  ICE DARKENING BASE \n                // Cold blue-black base  darkens surface with icy tint\n                vec3 baseColor = vec3(0.02, 0.04, 0.10);\n\n                // Frost brightens consumed areas with white-blue crystalline patches\n                vec3 frostColor = vec3(0.4, 0.55, 0.75) * frost * 0.6;\n\n                //  SPECULAR HIGHLIGHTS \n                // Sharp crystalline specular  colder, bluer than water\n                vec3 light1 = normalize(vec3(0.3, 1.0, 0.5));\n                vec3 half1 = normalize(light1 + viewDir);\n                float spec1 = pow(max(dot(normal, half1), 0.0), 160.0);\n\n                vec3 light2 = normalize(vec3(-0.5, 0.8, -0.3));\n                vec3 half2 = normalize(light2 + viewDir);\n                float spec2 = pow(max(dot(normal, half2), 0.0), 128.0);\n\n                // Cold blue-white specular\n                vec3 specColor = vec3(1.6, 1.9, 2.4) * spec1\n                               + vec3(1.0, 1.2, 1.6) * spec2;\n\n                //  FRESNEL REFLECTION \n                // Ice is very reflective at glancing angles\n                float fresnel = pow(edgeness, 2.0) * progressRamp;\n                vec3 fresnelColor = vec3(0.6, 0.8, 1.2) * fresnel * 0.7;\n\n                //  EDGE EMISSION \n                // Cold blue glow at freezing boundary\n                float edgeBand = smoothstep(threshold - 0.05, threshold - 0.01, consumeField)\n                               * smoothstep(threshold + 0.03, threshold, consumeField);\n                float pulse = 0.90 + 0.10 * sin(uTime * uPulseSpeed);\n                edgeBand *= pulse;\n\n                //  COMPOSITE \n                vec3 color = baseColor;\n                color += frostColor * consumed;\n                color += specColor * consumed;\n                color += fresnelColor;\n                color += vec3(0.4, 0.6, 1.0) * edgeBand * 0.5 * dissolveIn;\n\n                //  ALPHA \n                float alpha = iceMask * uOpacity * dissolveIn * 0.65;\n                // Frost patches boost alpha slightly\n                alpha += frost * consumed * uOpacity * dissolveIn * 0.15;\n                // Edge band\n                float edgeAlpha = edgeBand * 0.4 * dissolveIn * uOpacity;\n                alpha = max(alpha, edgeAlpha);\n                // Fresnel\n                alpha = max(alpha, fresnel * dissolveIn * uOpacity * 0.35);\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(color, alpha);\n            }\n        ",transparent:!0,blending:1,depthWrite:!1,side:2});return i.userData.melt=t,i.userData.elementalType="ice",i}function Kv(e,t,n){return e+(t-e)*n}function Zv(e,t){if(t)return t.clone();const n=new Ia;if(e<.3)n.setRGB(.6,.8,1);else if(e<.7){const t=(e-.3)/.4;n.setRGB(Kv(.6,.3,t),Kv(.8,1,t),1)}else{const t=(e-.7)/.3;n.setRGB(Kv(.3,.9,t),1,1)}return n}function Jv(e={}){const{charge:t=.5,color:n=null,opacity:a=.9}=e,i=Zv(t,n),r=Kv(.5,5,t),s=Kv(.5,8,t),o=Math.floor(Kv(2,12,t)),l=Kv(.01,.04,t),c=Kv(4,20,t),h=new bi({uniforms:{uColor:{value:i},uIntensity:{value:r},uArcFrequency:{value:s},uBranchCount:{value:o},uArcThickness:{value:l},uFlickerRate:{value:c},uOpacity:{value:a},uTime:{value:0},uCharge:{value:t}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewDir;\n            varying vec2 vUv;\n\n            void main() {\n                vPosition = position;\n                vUv = uv;\n\n                // World space position for view direction\n                vec4 worldPos = modelMatrix * vec4(position, 1.0);\n                vWorldPosition = worldPos.xyz;\n\n                // View direction in world space\n                vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n                // Normal in world space\n                vNormal = normalize(mat3(modelMatrix) * normal);\n\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uIntensity;\n            uniform float uArcFrequency;\n            uniform float uBranchCount;\n            uniform float uArcThickness;\n            uniform float uFlickerRate;\n            uniform float uOpacity;\n            uniform float uTime;\n            uniform float uCharge;\n\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewDir;\n            varying vec2 vUv;\n\n            // \n            // HASH FUNCTIONS\n            // \n            float hash(float n) {\n                return fract(sin(n) * 43758.5453);\n            }\n\n            vec2 hash2(vec2 p) {\n                p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n                return fract(sin(p) * 43758.5453);\n            }\n\n            vec3 hash3(vec3 p) {\n                p = vec3(\n                    dot(p, vec3(127.1, 311.7, 74.7)),\n                    dot(p, vec3(269.5, 183.3, 246.1)),\n                    dot(p, vec3(113.5, 271.9, 124.6))\n                );\n                return fract(sin(p) * 43758.5453);\n            }\n\n            // \n            // VORONOI WITH EDGE DISTANCE\n            // Returns: x = distance to nearest cell, y = distance to edge\n            // The EDGE DISTANCE creates thin branching lines perfect for electricity\n            // \n            vec2 voronoi(vec3 p, float time, float jitter) {\n                vec3 n = floor(p);\n                vec3 f = fract(p);\n\n                // First pass: find closest cell\n                float minDist = 10.0;\n                vec3 closestCell = vec3(0.0);\n                vec3 closestPoint = vec3(0.0);\n\n                for (int k = -1; k <= 1; k++) {\n                    for (int j = -1; j <= 1; j++) {\n                        for (int i = -1; i <= 1; i++) {\n                            vec3 neighbor = vec3(float(i), float(j), float(k));\n                            vec3 cellId = n + neighbor;\n\n                            // Animate cell position over time for moving electricity\n                            vec3 cellHash = hash3(cellId);\n                            vec3 cellOffset = cellHash * jitter;\n                            // Add time-based movement\n                            cellOffset += sin(time * 3.0 + cellHash * 6.28) * 0.15;\n\n                            vec3 cellPoint = neighbor + cellOffset;\n                            float d = length(cellPoint - f);\n\n                            if (d < minDist) {\n                                minDist = d;\n                                closestCell = cellId;\n                                closestPoint = cellPoint;\n                            }\n                        }\n                    }\n                }\n\n                // Second pass: find distance to nearest edge\n                // This is where the THIN LINES come from\n                float minEdgeDist = 10.0;\n\n                for (int k = -1; k <= 1; k++) {\n                    for (int j = -1; j <= 1; j++) {\n                        for (int i = -1; i <= 1; i++) {\n                            vec3 neighbor = vec3(float(i), float(j), float(k));\n                            vec3 cellId = n + neighbor;\n\n                            if (cellId == closestCell) continue;\n\n                            vec3 cellHash = hash3(cellId);\n                            vec3 cellOffset = cellHash * jitter;\n                            cellOffset += sin(time * 3.0 + cellHash * 6.28) * 0.15;\n\n                            vec3 cellPoint = neighbor + cellOffset;\n\n                            // Calculate distance to edge between cells\n                            // Edge is the perpendicular bisector of the line between cells\n                            vec3 toCenter = (closestPoint + cellPoint) * 0.5;\n                            vec3 cellDiff = normalize(cellPoint - closestPoint);\n                            float edgeDist = dot(toCenter - f, cellDiff);\n                            edgeDist = abs(edgeDist);\n\n                            minEdgeDist = min(minEdgeDist, edgeDist);\n                        }\n                    }\n                }\n\n                return vec2(minDist, minEdgeDist);\n            }\n\n            // \n            // 2D VORONOI FOR SECONDARY CRACKLING\n            // \n            float voronoi2D(vec2 p, float time) {\n                vec2 n = floor(p);\n                vec2 f = fract(p);\n\n                float minDist = 10.0;\n                vec2 closestPoint = vec2(0.0);\n                vec2 closestCell = vec2(0.0);\n\n                for (int j = -1; j <= 1; j++) {\n                    for (int i = -1; i <= 1; i++) {\n                        vec2 neighbor = vec2(float(i), float(j));\n                        vec2 cellId = n + neighbor;\n                        vec2 cellHash = hash2(cellId);\n                        vec2 cellOffset = cellHash * 0.9;\n                        cellOffset += sin(time * 5.0 + cellHash * 6.28) * 0.2;\n\n                        vec2 cellPoint = neighbor + cellOffset;\n                        float d = length(cellPoint - f);\n\n                        if (d < minDist) {\n                            minDist = d;\n                            closestPoint = cellPoint;\n                            closestCell = cellId;\n                        }\n                    }\n                }\n\n                float minEdgeDist = 10.0;\n                for (int j = -1; j <= 1; j++) {\n                    for (int i = -1; i <= 1; i++) {\n                        vec2 neighbor = vec2(float(i), float(j));\n                        vec2 cellId = n + neighbor;\n\n                        if (cellId == closestCell) continue;\n\n                        vec2 cellHash = hash2(cellId);\n                        vec2 cellOffset = cellHash * 0.9;\n                        cellOffset += sin(time * 5.0 + cellHash * 6.28) * 0.2;\n\n                        vec2 cellPoint = neighbor + cellOffset;\n\n                        vec2 toCenter = (closestPoint + cellPoint) * 0.5;\n                        vec2 cellDiff = normalize(cellPoint - closestPoint);\n                        float edgeDist = abs(dot(toCenter - f, cellDiff));\n\n                        minEdgeDist = min(minEdgeDist, edgeDist);\n                    }\n                }\n\n                return minEdgeDist;\n            }\n\n            // \n            // SPARK POINTS - Random flickering bright spots\n            // \n            float sparks(vec3 pos, float time) {\n                vec3 gridPos = pos * 12.0;\n                vec3 gridId = floor(gridPos);\n                vec3 gridUv = fract(gridPos);\n\n                float spark = 0.0;\n                for (int z = 0; z <= 1; z++) {\n                    for (int y = 0; y <= 1; y++) {\n                        for (int x = 0; x <= 1; x++) {\n                            vec3 offset = vec3(float(x), float(y), float(z));\n                            vec3 cellId = gridId + offset;\n\n                            vec3 sparkPos = hash3(cellId) * 0.8 + 0.1;\n                            float d = length(gridUv - offset - sparkPos + 0.5);\n\n                            // Irregular flicker timing\n                            float flickerSeed = dot(cellId, vec3(127.1, 311.7, 74.7));\n                            float flicker = step(0.75, fract(sin(time * 15.0 + flickerSeed) * 43758.5453));\n\n                            spark += smoothstep(0.12, 0.0, d) * flicker;\n                        }\n                    }\n                }\n\n                return spark;\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewDir);\n\n                // \n                // FRESNEL RIM - Subtle edge highlight\n                // \n                float fresnel = 1.0 - abs(dot(normal, viewDir));\n                fresnel = pow(fresnel, 3.0);\n                float rimGlow = fresnel * 0.15 * uCharge;\n\n                // \n                // LIGHTNING ARCS: Voronoi cell edges = thin branching lines\n                // \n\n                // Use VERY thin line thickness for sharp electricity\n                float lineWidth = 0.015;  // Thin lines regardless of charge\n\n                // Primary arcs - larger cells = fewer, thicker main bolts\n                float scale1 = 3.0;\n                vec2 v1 = voronoi(vPosition * scale1, uTime * 0.8, 0.85);\n                float bolt1 = 1.0 - smoothstep(0.0, lineWidth * 1.2, v1.y);\n                bolt1 = pow(bolt1, 2.0);  // Sharpen the falloff\n\n                // Secondary crackling - smaller cells = more fine detail\n                float scale2 = 6.0;\n                vec2 v2 = voronoi(vPosition * scale2, uTime * 1.2, 0.8);\n                float bolt2 = 1.0 - smoothstep(0.0, lineWidth * 0.8, v2.y);\n                bolt2 = pow(bolt2, 2.5) * 0.6;\n\n                // Tertiary micro-cracks\n                float scale3 = 10.0;\n                vec2 v3 = voronoi(vPosition * scale3, uTime * 1.6, 0.75);\n                float bolt3 = 1.0 - smoothstep(0.0, lineWidth * 0.5, v3.y);\n                bolt3 = pow(bolt3, 3.0) * 0.3;\n\n                // Combine - don't let it exceed 1.0\n                float lightning = min(bolt1 + bolt2 + bolt3, 1.0);\n\n                // \n                // FLICKER - Electrical pulsing\n                // \n                float flickerTime = uTime * uFlickerRate * 0.5;\n                float flicker = 0.7 + 0.3 * step(0.5, fract(sin(flickerTime * 11.3) * 43758.5453));\n                lightning *= flicker;\n\n                // \n                // SPARKS - Occasional bright point flashes\n                // \n                float sparkVal = sparks(vPosition, uTime) * 0.8;\n\n                // \n                // FINAL COLOR - Keep it CYAN, not white\n                // \n                float brightness = lightning + sparkVal + rimGlow;\n\n                // Color stays cyan - only the very brightest peaks go slightly white\n                vec3 cyanColor = uColor;  // Base cyan\n                vec3 brightCyan = uColor * 1.5 + vec3(0.2, 0.3, 0.4);  // Brighter cyan, slight white tint\n\n                // Mix based on brightness - mostly cyan, white only at peaks\n                float whiteMix = smoothstep(0.7, 1.0, brightness) * 0.3;\n                vec3 finalColor = mix(cyanColor, brightCyan, whiteMix);\n\n                // Apply brightness to color (capped to prevent white-out)\n                finalColor *= min(brightness * 1.5, 2.0);\n\n                // \n                // ALPHA: Thin lines visible, dark areas transparent\n                // \n                float alpha = brightness * uOpacity;\n                alpha = clamp(alpha, 0.0, 0.9);\n\n                // Discard dark pixels\n                if (alpha < 0.03) discard;\n\n                gl_FragColor = vec4(finalColor, alpha);\n            }\n        ",transparent:!0,blending:2,depthWrite:!1,side:2});return h.userData.charge=t,h.userData.elementalType="electric",h}function eb(e,t,n){return e+(t-e)*n}function tb(e={}){const{depth:t=.5,opacity:n=.9}=e,a=eb(.5,1.5,t),i=new bi({uniforms:{uDepth:{value:t},uProgress:{value:0},uPulseSpeed:{value:a},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uDepth;\n            uniform float uProgress;\n            uniform float uPulseSpeed;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n                float NdotV = abs(dot(normal, viewDir));\n                float edgeness = 1.0 - NdotV;\n\n                //  CONSUMPTION FIELD \n                // Object-space position projected to 2D for consistent pattern\n                vec2 pos = vPosition.xz * 2.5 + vec2(vPosition.y * 0.8, -vPosition.y * 0.6);\n\n                // 3-octave FBM  organic creeping consumption boundary\n                float n1 = noise(pos * 1.5 + uTime * 0.08);          // Large-scale (slow drift)\n                float n2 = noise(pos * 4.0 - uTime * 0.12);          // Medium (counter-drift)\n                float n3 = noise(pos * 9.0 + uTime * 0.18);          // Fine detail (faster)\n                float consumeField = n1 * 0.50 + n2 * 0.30 + n3 * 0.20;\n\n                // Fresnel bias: darkness creeps from silhouette edges inward\n                consumeField += edgeness * 0.20;\n\n                //  DISSOLVE IN \n                // Smooth opacity ramp over first 20%  darkness materializes gradually\n                float dissolveIn = smoothstep(0.0, 0.20, uProgress);\n\n                //  PROGRESS-DRIVEN THRESHOLD \n                // Progress ramps the consumption from nothing  full depth-dependent coverage\n                float progressRamp = smoothstep(0.05, 0.8, uProgress);\n\n                // At progress=0: threshold=0.95 (nearly nothing consumed)\n                // At progress=1: threshold based on depth (0.85 at low, 0.15 at high)\n                float targetThreshold = mix(0.85, 0.15, uDepth);\n                float threshold = mix(0.95, targetThreshold, progressRamp);\n\n                // Sharp consumption boundary (0.05 transition  defined edge, not gaussian)\n                float consumed = smoothstep(threshold, threshold - 0.05, consumeField);\n\n                //  TENDRILS \n                // Fine dark tendrils reaching AHEAD of the main consumption front\n                float tendrilField = noise(pos * 8.0 + uTime * 0.22) * 0.6\n                                   + noise(pos * 14.0 - uTime * 0.14) * 0.4;\n                // Tendrils extend slightly past the main threshold\n                float tendrilThreshold = threshold + 0.10;\n                float tendrils = smoothstep(tendrilThreshold, tendrilThreshold - 0.03,\n                                            tendrilField + edgeness * 0.12);\n                // Thinner than full consumption, only visible at moderate+ depth\n                tendrils *= 0.5 * smoothstep(0.0, 0.4, uDepth * progressRamp);\n\n                float darkness = max(consumed, tendrils);\n\n                //  VOID CURRENTS \n                // Inside consumed regions: subtle flowing noise prevents flat-black monotony.\n                // Very dim near-black variations with faint violet tone  trapped light.\n                float currentN1 = noise(pos * 3.0 + uTime * 0.25);\n                float currentN2 = noise(pos * 6.0 - uTime * 0.18 + vec2(5.0, 3.0));\n                float currentField = currentN1 * 0.6 + currentN2 * 0.4;\n                // Flowing inward-like motion (modulated by edgeness)\n                float currentIntensity = currentField * consumed * uDepth;\n                // Deep violet-black  hint of trapped light, not flat black\n                vec3 voidCurrentColor = vec3(0.012, 0.006, 0.022) * currentIntensity;\n\n                //  EDGE EMISSION \n                // Thin warm rim where void meets normal surface\n                float edgeBand = smoothstep(threshold - 0.05, threshold - 0.01, consumeField)\n                               * smoothstep(threshold + 0.03, threshold, consumeField);\n\n                // Breathing pulse\n                float pulse = 0.85 + 0.15 * sin(uTime * uPulseSpeed);\n                edgeBand *= pulse;\n\n                // Warm amber edge (redshifted photons at event horizon boundary)\n                vec3 color = voidCurrentColor;\n                color += vec3(0.85, 0.50, 0.18) * edgeBand * uDepth * 2.0;\n\n                //  ALPHA \n                float alpha = darkness * uOpacity * dissolveIn;\n\n                // Edge emission always visible\n                float edgeAlpha = edgeBand * uDepth * 0.5 * dissolveIn;\n                alpha = max(alpha, edgeAlpha);\n\n                // Very faint global darkening at high depth\n                alpha = max(alpha, uDepth * progressRamp * 0.03 * dissolveIn);\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(color, alpha);\n            }\n        ",transparent:!0,blending:5,blendEquation:s,blendSrc:p,blendDst:m,blendSrcAlpha:h,blendDstAlpha:m,depthWrite:!1,side:2});return i.userData.depth=t,i.userData.elementalType="void",i}const nb={fire:{create:qv,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=.5){return{gravity:Wv(-.05,-.15,-.3,e),drag:Wv(.08,.05,.02,e),bounce:0,lifetime:Wv(2,1.5,.8,e),fadeOut:!0,riseSpeed:Wv(.5,1,2,e),flicker:!0}},crack:function(e=.5){let t,n,a;if(e<.3)t=.8+.67*e,n=.1+1*e,a=0;else if(e<.7){const i=(e-.3)/.4;t=1,n=.4+.5*i,a=.3*i}else{const i=(e-.7)/.3;t=1-.2*i,n=.9+.1*i,a=.3+.7*i}return{color:Math.round(255*t)<<16|Math.round(255*n)<<8|Math.round(255*a),emissive:Wv(1,2,4,e),animated:!0,pattern:"organic",flickerSpeed:Wv(1,2,4,e)}},masterParam:"temperature"},water:{create:Xv,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:Yv,crack:function(e=.3){let t;return t=e<.15?11197951:e<.6?4491519:8978346,{color:t,emissive:Hv(.3,.05,e),animated:e<.5,pattern:e>.7?"crystalline":"organic"}},masterParam:"viscosity"},ice:{create:Qv,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=0){return e>.8?Yv($v(.6,.3,(e-.8)/.2)):{gravity:$v(1.3,1,e),bounce:$v(.1,.4,e),drag:$v(.01,.03,e),shatterThreshold:$v(.3,.6,e),slideOnSurface:$v(.9,.5,e),brittleness:$v(1,.3,e),crackOnImpact:e<.5}},crack:function(e=0){return{color:$v(11202303,8969727,e),emissive:$v(.4,.1,e),animated:!1,pattern:"crystalline",frostEdges:e<.5}},masterParam:"melt"},electric:{create:Jv,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=.5){return{gravity:0,drag:Kv(.3,.02,e),bounce:0,chainToNearby:e>.3,chainRadius:Kv(.5,2,e),lifetime:Kv(.3,.8,e),flickerOnMove:!0,attractToMetal:e>.5}},crack:function(e=.5){return{color:Zv(e).getHex(),emissive:Kv(1,6,e),animated:!0,pattern:"branching",arcBetweenCracks:e>.5}},masterParam:"charge"},void:{create:tb,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=.5){return{gravity:eb(0,.3,e),drag:eb(.2,0,e),bounce:0,gravityWell:e>.7,gravityWellStrength:e>.7?eb(0,2,(e-.7)/.3):0,disperseOverTime:e<.3,lifetime:eb(2,999,e),absorbLight:!0,corruptNearby:e>.6}},crack:function(e=.5){return{color:0,emissive:eb(-.5,-2,e),animated:!0,pattern:"veins",spreadOverTime:e>.5,corruptNearby:e>.7}},masterParam:"depth"}},ab={color:4465169,emissive:.3,animated:!1,pattern:"organic"},ib={gravity:1,bounce:.3,drag:.02,lifetime:3};function rb(e,t=.5){const n=nb[e];return n?n.physics(t):{...ib}}const sb={IDLE:"idle",GENERATING:"generating",SHATTERING:"shattering",FROZEN:"frozen",REASSEMBLING:"reassembling",IMPLODING:"imploding",DISSOLVING:"dissolving",FALLING:"falling",ORBITING:"orbiting"};class ob{constructor(e={}){const t="undefined"!=typeof navigator&&/Android|iPhone|iPad|iPod/i.test(navigator.userAgent),{scene:n=null,maxShards:a=(t?25:50),shardLifetime:i=(t?1500:2e3),enableReassembly:r=!0,autoRestore:s=!0}=e;this.scene=n,this.maxShards=a,this.shardLifetime=i,this.enableReassembly=r,this.autoRestore=s,this.state=sb.IDLE,this.shardPool=new Gv({maxShards:a,scene:n}),this.geometryCache=new Map,this.geometryCacheMaxSize=5,this.geometryCacheRefs=new Map,this._activeGeometryId=null,this.shardMaterialCache=null,this.targetMesh=null,this.innerMesh=null,this.onShatterStart=null,this.onShatterComplete=null,this.onReassemblyComplete=null,this._shatterStartTime=0,this._soulRevealProgress=0,this._soulOriginalScale=1,this._soulOriginalEmissive=0,this._soulOriginalGhostMode=.36,this._soulOriginalLayer=2,this._reassemblyDuration=1e3,this._reassemblyStartTime=0,this._reassemblyProgress=0,this._soulWasRevealed=!1,this._shatterQueue=[],this._chainedDelay=150,this._lastChainTrigger=0,this._isSuspendMode=!1,this._suspendAt=.25,this._suspendDuration=.35,this._isFreezeMode=!1,this._currentElementalMaterial=null,this._currentElemental=null,this._currentElementalParam=.5,this._dualModeType=null,this._dualModeConfig={},this._dualModeStartTime=0,this._dualModeDuration=2e3}prepareGeometry(e,t=null){const n=t||Fv.hashGeometry(e);if(this.geometryCache.has(n)){const e=this.geometryCache.get(n);return this.geometryCache.delete(n),this.geometryCache.set(n,e),e}const a=Fv.generate(e,{shardCount:this.maxShards,seed:this._hashString(n)});for(;this.geometryCache.size>=this.geometryCacheMaxSize;){let e=!1;for(const t of this.geometryCache.keys())if(0===(this.geometryCacheRefs.get(t)||0)){this.geometryCache.get(t).forEach(e=>e.dispose()),this.geometryCache.delete(t),this.geometryCacheRefs.delete(t),e=!0;break}if(!e)break}return this.geometryCache.set(n,a),a}precomputeShards(e,t){if(!e?.geometry||!e?.material)return void console.warn("ShatterSystem.precomputeShards: Invalid mesh");this.shardMaterialCache?.baseMaterial&&this.shardMaterialCache.baseMaterial.dispose(),this.shardMaterialCache=null;const n=Nv(Lv(e.material,t)),a=Fv.hashGeometry(e.geometry);let i=this.geometryCache.get(a);i||(i=Fv.generate(e.geometry,{shardCount:this.maxShards,seed:this._hashString(a)}),this.geometryCache.set(a,i)),this.shardMaterialCache={geometryType:t,baseMaterial:n,geometries:i,geometryId:a}}hasCachedShards(){return null!==this.shardMaterialCache}getCacheInfo(){return this.shardMaterialCache?{geometryType:this.shardMaterialCache.geometryType,shardCount:this.shardMaterialCache.geometries?.length||0,hasMaterial:!!this.shardMaterialCache.baseMaterial}:null}shatter(e,t={}){if(this.state!==sb.IDLE)return console.warn("ShatterSystem: Cannot shatter - already in state:",this.state),!1;const{impactPoint:n=new Gt(0,0,.4),impactDirection:a=new Gt(0,0,-1),intensity:i=1,geometryId:r=null,revealInner:s=!0,inheritMeshVelocity:o=null,isSuspendMode:l=!1,suspendAt:c=.25,suspendDuration:h=.35,isFreezeMode:d=!1,isDualMode:u=!1,dualModeType:p=null,dualModeConfig:m={},gravity:f,explosionForce:g,rotationForce:y,elemental:v=null,elementalParam:b=.5,overlay:w=null,overlayParam:x=.5}=t;this.state=sb.GENERATING,this.targetMesh=e,this._shatterStartTime=performance.now(),this._isSuspendMode=l,this._suspendAt=c,this._suspendDuration=h,this._gestureDuration=t.gestureDuration||6e3,this._isFreezeMode=d,this._pendingDualMode=u?p:null,this._pendingDualModeConfig=u?m:{};const S=r||Fv.hashGeometry(e.geometry);let M=this.geometryCache.get(S);if(M||(M=this.prepareGeometry(e.geometry,S)),!M||0===M.length)return console.warn("ShatterSystem: No shards generated"),this.state=sb.IDLE,!1;this._activeGeometryId=S;const _=this.geometryCacheRefs.get(S)||0;this.geometryCacheRefs.set(S,_+1);const A=new Gt,C=new Ut,T=new Gt;e.matrixWorld.decompose(A,C,T);const P=n.clone();P.applyQuaternion(C),P.add(A);const D=a.clone();if(D.applyQuaternion(C),D.normalize(),e.visible=!1,this._soulWasRevealed=s&&this.innerMesh,this._soulWasRevealed){this.innerMesh.visible=!0,this._soulRevealProgress=0,this._soulOriginalScale=this.innerMesh.scale.x,this._soulOriginalLayer=this.innerMesh.layers.mask,this.innerMesh.layers.set(0),this._soulOriginalDepthTest=this.innerMesh.material?.depthTest??!0,this._soulOriginalRenderOrder=this.innerMesh.renderOrder??0,this.innerMesh.material&&(this.innerMesh.material.depthTest=!1),this.innerMesh.renderOrder=100;const e=this.innerMesh.material?.uniforms;e?(this._soulOriginalEmissive=e.energyIntensity?.value??.8,this._soulOriginalGhostMode=e.ghostMode?.value??.36,e.energyIntensity&&(e.energyIntensity.value=2),e.ghostMode&&(e.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this._soulOriginalEmissive=this.innerMesh.material.emissiveIntensity,this.innerMesh.material.emissiveIntensity=2),this.innerMesh.scale.setScalar(.5*this._soulOriginalScale)}this.state=sb.SHATTERING;let O=this.shardLifetime;l||d?O=1e4:u&&m?.duration&&(O=400+m.duration+1e3);const E=O;let I,k,R,z=null,F=null;if(v&&v in nb)this._currentElementalMaterial&&this._currentElemental===v?(z=this._currentElementalMaterial,F=rb(v,b),this._currentElementalParam=b):(this._currentElementalMaterial&&(this._currentElementalMaterial.dispose(),this._currentElementalMaterial=null),z=function(e,t=.5,n={}){const a=nb[e];if(!a)return console.warn(`ElementalMaterialFactory: Unknown element type '${e}'`),null;const i={[a.masterParam]:t,...n};return a.create(i)}(v,b),F=rb(v,b),this._currentElementalMaterial=z,this._currentElemental=v,this._currentElementalParam=b);else{if(this._currentElementalMaterial&&(this._currentElementalMaterial.dispose(),this._currentElementalMaterial=null,this._currentElemental=null),z=this.shardMaterialCache?.baseMaterial||null,this.shardMaterialCache&&z&&!z.map&&e.material){const t=Lv(e.material,this.shardMaterialCache.geometryType);t.map&&(z.dispose(),z=Nv(t),this.shardMaterialCache.baseMaterial=z)}this._currentElemental=null,this._currentElementalParam=.5}F?(R=void 0!==f?f:l?-3:9.8*-F.gravity,I=(void 0!==g?g:2)*i,k=(void 0!==y?y:5)*i,this._elementalDrag=F.drag,this._elementalBounce=F.bounce):(I=(void 0!==g?g:2)*i,k=(void 0!==y?y:5)*i,R=void 0!==f?f:l?-3:-9.8,this._elementalDrag=null,this._elementalBounce=null),this._currentOverlay=w,this._currentOverlayParam=x;const B=this.shardPool.activate(M,P,D,{explosionForce:I,rotationForce:k,lifetime:E,gravity:R,inheritVelocity:o||new Gt,meshPosition:A,meshQuaternion:C,meshScale:T,isSuspendMode:l,baseMaterial:z,elementalPhysics:F,elementalType:v});return z||this._syncShardMaterial(e),this.onShatterStart&&this.onShatterStart(e,{shardCount:B}),!0}_syncShardMaterial(e){let t=new Ia(8965375),n=new Ia(0);e.material?.uniforms?.emotionColor?(t=e.material.uniforms.emotionColor.value.clone(),n=t.clone().multiplyScalar(.3)):e.material?.color&&(t=e.material.color.clone(),n=e.material.emissive?.clone()||new Ia(0)),this.shardPool.updateMaterial({color:t,emissive:n,emissiveIntensity:.4})}shatterChain(e,t={}){if(!e||0===e.length)return!1;const{delay:n=150,propagationDir:a=null}=t;this._chainedDelay=n;let i=[...e];if(a){const e=a.clone().normalize(),t=new Gt;i=i.map(n=>(n.mesh.getWorldPosition(t),{target:n,dot:t.dot(e)})).sort((e,t)=>e.dot-t.dot).map(e=>e.target)}return this._shatterQueue=i.map((e,t)=>({mesh:e.mesh,config:e.config||{},triggerTime:performance.now()+t*n})),this.state===sb.IDLE&&this._shatterQueue.length>0&&this._processNextInChain(),!0}_processNextInChain(){if(0===this._shatterQueue.length)return;const e=this._shatterQueue[0],t=performance.now();t>=e.triggerTime&&(this._shatterQueue.shift(),this._lastChainTrigger=t,this.shatter(e.mesh,e.config))}reassemble(e={}){if(this.state!==sb.SHATTERING||!this.enableReassembly)return!1;const{duration:t=1e3}=e;return this.state=sb.REASSEMBLING,this._reassemblyDuration=t,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions(),!0}triggerReassembly(e=1500){return this.state!==sb.FROZEN?(console.warn("ShatterSystem.triggerReassembly: Can only trigger from FROZEN state, current state:",this.state),!1):(this.state=sb.REASSEMBLING,this._reassemblyDuration=e,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions(),!0)}isFrozen(){return this.state===sb.FROZEN}moveFrozenShards(e,t=3){if(this.state!==sb.FROZEN)return!1;this.shardPool.applyImpulse(e,t,.4),this.state=sb.SHATTERING,this._isFreezeMode=!1,this._isSuspendMode=!1;for(const e of this.shardPool.active)e.userData.state.lifetime=0,e.userData.state.maxLifetime=1500;return!0}triggerDualMode(e,t={}){return["implode","dissolve","gravity","orbit"].includes(e)?[sb.IMPLODING,sb.DISSOLVING,sb.FALLING,sb.ORBITING].includes(this.state)?(console.warn("ShatterSystem.triggerDualMode: Already in dual-mode state:",this.state),!1):(this._dualModeType=e,this._dualModeConfig=t,this._dualModeStartTime=performance.now(),this._dualModeDuration=t.duration||2e3,this.state===sb.FROZEN&&(this._startDualModeFromFrozen(e,t),!0)):(console.warn("ShatterSystem.triggerDualMode: Invalid mode:",e),!1)}_startDualModeFromFrozen(e,t){switch(this.shardPool.captureCurrentPositions(),e){case"implode":this.state=sb.IMPLODING,this.shardPool.initImplodeMode(t);break;case"dissolve":this.state=sb.DISSOLVING,this.shardPool.initDissolveMode(t);break;case"gravity":this.state=sb.FALLING,this.shardPool.initGravityMode(t);break;case"orbit":this.state=sb.ORBITING,this.shardPool.initOrbitMode(t)}}update(e){if(this.state===sb.IDLE&&this._shatterQueue.length>0&&this._processNextInChain(),this.state===sb.SHATTERING){if(this._isSuspendMode){const e=performance.now()-this._shatterStartTime,t=Math.min(1,e/this._gestureDuration);let n=0;if(t>=this._suspendAt){const e=t-this._suspendAt;n=Math.min(1,e/this._suspendDuration),n=1-Math.pow(1-n,2)}this.shardPool.updateSuspendProgress(n)}if(this.shardPool.update(e),this._soulWasRevealed&&this.innerMesh){const t=this.innerMesh.material?.uniforms;if(this._soulRevealProgress<1){this._soulRevealProgress+=e/500,this._soulRevealProgress=Math.min(1,this._soulRevealProgress);const n=this._soulRevealProgress,a=1-Math.pow(1-n,3),i=this._soulOriginalScale*(.5+.5*a);if(this.innerMesh.scale.setScalar(i),t)t.energyIntensity&&(t.energyIntensity.value=2-a*(2-this._soulOriginalEmissive)),t.ghostMode&&(t.ghostMode.value=0);else if(void 0!==this.innerMesh.material?.emissiveIntensity){const e=2-a*(2-this._soulOriginalEmissive);this.innerMesh.material.emissiveIntensity=e}}else this.innerMesh.scale.setScalar(this._soulOriginalScale),t?(t.energyIntensity&&(t.energyIntensity.value=this._soulOriginalEmissive),t.ghostMode&&(t.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive)}if(this._isFreezeMode&&this._isSuspendMode){const e=performance.now()-this._shatterStartTime;Math.min(1,e/this._gestureDuration)>=this._suspendAt+this._suspendDuration&&(this._pendingDualMode?(this._dualModeType=this._pendingDualMode,this._dualModeConfig=this._pendingDualModeConfig,this._dualModeStartTime=performance.now(),this._dualModeDuration=this._pendingDualModeConfig.duration||2e3,this._startDualModeFromFrozen(this._pendingDualMode,this._pendingDualModeConfig),this._pendingDualMode=null,this._pendingDualModeConfig={}):this.state=sb.FROZEN)}this._pendingDualMode&&!this._isFreezeMode&&performance.now()-this._shatterStartTime>=400&&(this._dualModeType=this._pendingDualMode,this._dualModeConfig=this._pendingDualModeConfig,this._dualModeStartTime=performance.now(),this._dualModeDuration=this._pendingDualModeConfig.duration||2e3,this.shardPool.captureCurrentPositions(),this._startDualModeFromFrozen(this._pendingDualMode,this._pendingDualModeConfig),this._pendingDualMode=null,this._pendingDualModeConfig={}),0!==this.shardPool.activeCount||this._isFreezeMode||this._pendingDualMode||this._onShatterComplete()}if(this.state===sb.IMPLODING&&this._updateImplodeMode(e),this.state===sb.DISSOLVING&&this._updateDissolveMode(e),this.state===sb.FALLING&&this._updateGravityMode(e),this.state===sb.ORBITING&&this._updateOrbitMode(e),this.state===sb.REASSEMBLING){const e=performance.now()-this._reassemblyStartTime;this._reassemblyProgress=Math.min(1,e/this._reassemblyDuration);const t=sv(this._reassemblyProgress);if(this.shardPool.updateReassembly(t,this.targetMesh),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;if(this._reassemblyProgress<=.6)this.innerMesh.scale.setScalar(this._soulOriginalScale),e?(e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive),e.ghostMode&&(e.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive);else{const t=(this._reassemblyProgress-.6)/.4,n=t*t,a=this._soulOriginalScale*(1-.3*n);this.innerMesh.scale.setScalar(a),e?(e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive*(1-n)),e.ghostMode&&void 0!==this._soulOriginalGhostMode&&(e.ghostMode.value=n*this._soulOriginalGhostMode)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive*(1-n))}}this._reassemblyProgress>=1&&this._onReassemblyComplete()}}_updateImplodeMode(e){const t=performance.now()-this._dualModeStartTime,n=Math.min(1,t/this._dualModeDuration),a=this.innerMesh?this.innerMesh.position.clone():new Gt;if(this.shardPool.updateImplode(e,n,a),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;if(e){const t=1+1.5*n;e.energyIntensity&&(e.energyIntensity.value=t)}}n>=1&&this._onDualModeComplete()}_updateDissolveMode(e){const t=performance.now()-this._dualModeStartTime,n=Math.min(1,t/this._dualModeDuration);if(this.shardPool.updateDissolve(e,n,this._dualModeConfig),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;e&&e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive*(1-.5*n))}n>=1&&this._onDualModeComplete()}_updateGravityMode(e){const t=performance.now()-this._dualModeStartTime,n=Math.min(1,t/this._dualModeDuration),a=this._dualModeConfig.floorY??-1;this.shardPool.updateGravityBounce(e,n,a),n>=1&&this._onDualModeComplete()}_updateOrbitMode(e){const t=performance.now()-this._dualModeStartTime,n=Math.min(1,t/this._dualModeDuration),a=this.innerMesh?this.innerMesh.position.clone():new Gt;if(this.shardPool.updateOrbit(e,n,a,this._dualModeConfig),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;if(e){const n=.2*Math.sin(t/200);e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive+n)}}n>=1&&!1!==this._dualModeConfig.autoComplete&&(this._dualModeConfig.reassemble?(this.state=sb.REASSEMBLING,this._reassemblyDuration=this._dualModeConfig.reassembleDuration||1200,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions()):this._onDualModeComplete())}_onDualModeComplete(){this.shardPool.clear(),this.targetMesh&&(this.targetMesh.visible=!0),this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms()),this._dualModeType=null,this._dualModeConfig={},this._releaseGeometryRef(),this._disposeElementalMaterial(),this.state=sb.IDLE,this.onShatterComplete&&this.onShatterComplete(this.targetMesh)}_onShatterComplete(){this.state=sb.IDLE,this._releaseGeometryRef(),this._disposeElementalMaterial(),this.autoRestore&&this.targetMesh&&(this.targetMesh.visible=!0,this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms())),this.onShatterComplete&&this.onShatterComplete(this.targetMesh)}_onReassemblyComplete(){this.shardPool.clear(),this._releaseGeometryRef(),this._disposeElementalMaterial(),this.targetMesh&&(this.targetMesh.visible=!0),this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms()),this.state=sb.IDLE,this.onReassemblyComplete&&this.onReassemblyComplete(this.targetMesh)}_resetSoulUniforms(){if(!this.innerMesh)return;void 0!==this._soulOriginalLayer&&(this.innerMesh.layers.mask=this._soulOriginalLayer),this.innerMesh.material&&void 0!==this._soulOriginalDepthTest&&(this.innerMesh.material.depthTest=this._soulOriginalDepthTest),void 0!==this._soulOriginalRenderOrder&&(this.innerMesh.renderOrder=this._soulOriginalRenderOrder);const e=this.innerMesh.material?.uniforms;e?(e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive),e.ghostMode&&void 0!==this._soulOriginalGhostMode&&(e.ghostMode.value=this._soulOriginalGhostMode)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive)}_disposeElementalMaterial(){this._currentElementalMaterial&&(this._currentElementalMaterial.dispose(),this._currentElementalMaterial=null),this._currentElemental=null,this._currentElementalParam=.5}_releaseGeometryRef(){if(this._activeGeometryId){const e=this.geometryCacheRefs.get(this._activeGeometryId)||0;e>0&&this.geometryCacheRefs.set(this._activeGeometryId,e-1),this._activeGeometryId=null}}setTargets(e,t=null){this.targetMesh=e,this.innerMesh=t}setScene(e){this.scene=e,this.shardPool.setScene(e)}forceStop(){this.shardPool.clear(),this.state=sb.IDLE,this._shatterQueue=[],this._releaseGeometryRef(),this._disposeElementalMaterial(),this.targetMesh&&(this.targetMesh.visible=!0),this.innerMesh&&(this.innerMesh.visible=!1)}clearChainQueue(){this._shatterQueue=[]}getChainQueueLength(){return this._shatterQueue.length}getState(){return this.state}isShattering(){return this.state===sb.SHATTERING}isIdle(){return this.state===sb.IDLE}isReassembling(){return this.state===sb.REASSEMBLING}getStats(){return{state:this.state,activeShards:this.shardPool.activeCount,availableShards:this.shardPool.availableCount,cachedGeometries:this.geometryCache.size,chainQueueLength:this._shatterQueue.length,reassemblyProgress:this.state===sb.REASSEMBLING?this._reassemblyProgress:null}}clearCache(){for(const e of this.geometryCache.values())for(const t of e)t.dispose();this.geometryCache.clear(),this.geometryCacheRefs.clear()}dispose(){this.forceStop(),this.shardPool.dispose(),this.clearCache(),this.shardMaterialCache?.baseMaterial&&this.shardMaterialCache.baseMaterial.dispose(),this.shardMaterialCache=null,this._disposeElementalMaterial(),this.targetMesh=null,this.innerMesh=null,this.onShatterStart=null,this.onShatterComplete=null,this.onReassemblyComplete=null}_hashString(e){let t=0;for(let n=0;n<e.length;n++)t=(t<<5)-t+e.charCodeAt(n),t&=t;return Math.abs(t)}}class lb{constructor(){this.impacts=[],this.crackColor=new Ia(...Vy.crackColor),this.crackGlowColor=new Ia(...Vy.crackGlowColor),this.glowStrength=Vy.crackGlowStrength,this.elementalType=null,this.elementalParam=.5,this.pattern="organic",this.animated=!1,this.isHealing=!1,this.healDuration=1500,this.healStartTime=0,this.healProgress=0,this._tempVec3=new Gt,this._tempQuat=new Ut}addImpact(e){const t=100*Math.random(),n={position:Array.isArray(e.position)?new Gt(...e.position):e.position?.clone()??new Gt,direction:Array.isArray(e.direction)?new Gt(...e.direction):e.direction?.clone()??new Gt,propagation:e.propagation??.8,amount:e.amount??1,seed:t};this.impacts.length>=3&&this.impacts.shift(),this.impacts.push(n)}transformToMeshLocal(e,t,n){const a=new Gt,i=new Gt,r=new Gt;t.getWorldDirection(r),a.crossVectors(r,t.up).normalize(),i.crossVectors(a,r).normalize();const s=e.screenOffset||[0,0],o=e.screenDirection||[0,0],l=(new Gt).addScaledVector(a,.4*s[0]).addScaledVector(i,.4*s[1]).addScaledVector(r.clone().negate(),.3);n.updateWorldMatrix(!0,!1);const c=n.matrixWorld.clone().invert();l.applyMatrix4(c);const h=(new Gt).addScaledVector(a,o[0]).addScaledVector(i,o[1]),d=new Ut;return n.getWorldQuaternion(d),d.invert(),h.applyQuaternion(d),{position:l,direction:h,propagation:e.propagation??.8,amount:e.amount??1}}startHealing(e=1500){if(0!==this.impacts.length){this.isHealing=!0,this.healDuration=e,this.healStartTime=performance.now(),this.healProgress=0;for(const e of this.impacts)e.originalAmount=e.amount,e.originalPropagation=e.propagation}}clearAll(){this.impacts=[],this.isHealing=!1,this.healProgress=0}hasCracks(){return this.impacts.length>0}update(e){if(!this.isHealing||0===this.impacts.length)return;const t=performance.now()-this.healStartTime;this.healProgress=Math.min(t/this.healDuration,1);const n=this.healProgress,a=1-n*n*(3-2*n);for(const e of this.impacts)void 0!==e.originalAmount&&(e.amount=e.originalAmount*a,e.propagation=e.originalPropagation*(.3+.7*a));this.healProgress>=1&&this.clearAll()}applyToMaterial(e){if(!e?.uniforms)return;const{uniforms:t}=e;t.crackNumImpacts&&(t.crackNumImpacts.value=this.impacts.length);for(let e=0;e<3;e++){const n=this.impacts[e],a=t[`crackImpact${e}`],i=t[`crackDirection${e}`],r=t[`crackParams${e}`];n?(a&&a.value.copy(n.position),i&&i.value.copy(n.direction),r&&r.value.set(n.propagation,n.amount,n.seed)):(a&&a.value.set(0,0,0),i&&i.value.set(0,0,0),r&&r.value.set(0,0,0))}t.crackColor&&t.crackColor.value.copy(this.crackColor),t.crackGlowColor&&t.crackGlowColor.value.copy(this.crackGlowColor),t.crackGlowStrength&&(t.crackGlowStrength.value=this.glowStrength)}setGlowColor(e){Array.isArray(e)?this.crackGlowColor.setRGB(e[0],e[1],e[2]):"number"==typeof e?this.crackGlowColor.setHex(e):e&&this.crackGlowColor.copy(e)}setCrackColor(e){Array.isArray(e)?this.crackColor.setRGB(e[0],e[1],e[2]):"number"==typeof e?this.crackColor.setHex(e):e&&this.crackColor.copy(e)}setElemental(e,t=.5){this.elementalType=e,this.elementalParam=t;const n=function(e,t=.5){const n=nb[e];return n?n.crack(t):{...ab}}(e,t);"number"==typeof n.color?(this.crackColor.setHex(n.color),this.crackGlowColor.setHex(n.color)):n.color&&(this.crackColor.copy(n.color),this.crackGlowColor.copy(n.color)),this.glowStrength=Math.max(0,n.emissive??.5),this.pattern=n.pattern||"organic",this.animated=n.animated??!1}clearElemental(){this.elementalType=null,this.elementalParam=.5,this.crackColor.setRGB(...Vy.crackColor),this.crackGlowColor.setRGB(...Vy.crackGlowColor),this.glowStrength=Vy.crackGlowStrength,this.pattern="organic",this.animated=!1}reset(){this.clearAll(),this.clearElemental()}dispose(){this.impacts=[],this._tempVec3=null,this._tempQuat=null}}class cb{constructor(){this.position=new Gt,this.velocity=new Gt,this.rotation=0,this.rotationSpeed=0,this.scale=1,this.scaleGrowth=0,this.alpha=1,this.alphaDecay=0,this.life=0,this.maxLife=1,this.active=!1}reset(){this.position.set(0,0,0),this.velocity.set(0,0,0),this.rotation=0,this.rotationSpeed=0,this.scale=1,this.scaleGrowth=0,this.alpha=1,this.alphaDecay=0,this.life=0,this.maxLife=1,this.active=!1}}class hb{constructor(e={}){this.maxParticles=e.maxParticles||50,this.category=e.category||"emanating",this.tint=e.tint||[1,1,1],this.density=e.density||.5,this.swirl=e.swirl||0,this.particles=[];for(let e=0;e<this.maxParticles;e++)this.particles.push(new cb);this._createGeometry(),this._createMaterial(),this.mesh=new $r(this.geometry,this.material),this.mesh.frustumCulled=!1,this.mesh.renderOrder=100,this.spawnTimer=0,this.spawnInterval=.08,this.time=0,this.effectStrength=1,this.hasBurst=!1}_createGeometry(){this.geometry=new ei;const e=new Float32Array(3*this.maxParticles),t=new Float32Array(this.maxParticles),n=new Float32Array(this.maxParticles),a=new Float32Array(this.maxParticles),i=new Float32Array(this.maxParticles);for(let r=0;r<this.maxParticles;r++)e[3*r]=0,e[3*r+1]=0,e[3*r+2]=0,t[r]=0,n[r]=0,a[r]=0,i[r]=Math.random();this.geometry.setAttribute("position",new Wa(e,3)),this.geometry.setAttribute("aSize",new Wa(t,1)),this.geometry.setAttribute("aRotation",new Wa(n,1)),this.geometry.setAttribute("aAlpha",new Wa(a,1)),this.geometry.setAttribute("aVariation",new Wa(i,1))}_createMaterial(){this.material=new bi({uniforms:{uTint:{value:new Gt(this.tint[0],this.tint[1],this.tint[2])},uOpacity:{value:.6},uTime:{value:0}},vertexShader:"\n                attribute float aSize;\n                attribute float aRotation;\n                attribute float aAlpha;\n                attribute float aVariation;\n\n                varying float vAlpha;\n                varying float vRotation;\n                varying float vVariation;\n\n                void main() {\n                    vAlpha = aAlpha;\n                    vRotation = aRotation;\n                    vVariation = aVariation;\n\n                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n                    // Billboard sizing - scale with distance\n                    gl_PointSize = aSize * (300.0 / -mvPosition.z);\n                    gl_PointSize = clamp(gl_PointSize, 1.0, 256.0);\n\n                    gl_Position = projectionMatrix * mvPosition;\n                }\n            ",fragmentShader:"\n                uniform vec3 uTint;\n                uniform float uOpacity;\n                uniform float uTime;\n\n                varying float vAlpha;\n                varying float vRotation;\n                varying float vVariation;\n\n                void main() {\n                    // Point coord centered\n                    vec2 uv = gl_PointCoord - 0.5;\n\n                    // Rotate UV - VISIBLE rotation as particle spins\n                    float c = cos(vRotation);\n                    float s = sin(vRotation);\n                    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);\n\n                    // Distance from center\n                    float dist = length(uv) * 2.0;\n\n                    // \n                    // SIMPLE SOFT PUFF - Clean cloud shape\n                    // Motion comes from particle movement, not shader complexity\n                    // \n\n                    // Soft radial falloff - clean puff shape\n                    float puff = 1.0 - smoothstep(0.0, 1.0, dist);\n                    puff = pow(puff, 0.6); // Softer falloff\n\n                    // Per-particle variation for unique shapes\n                    float seed = vVariation * 6.28318;\n\n                    // Slight wobble to break perfect circle\n                    float angle = atan(uv.y, uv.x);\n                    float wobble = sin(angle * 3.0 + seed) * 0.15 + sin(angle * 5.0 + seed * 2.0) * 0.08;\n                    float wobbledDist = dist - wobble * (1.0 - dist);\n\n                    // Final soft shape\n                    float shape = 1.0 - smoothstep(0.0, 0.95, wobbledDist);\n                    shape = pow(shape, 0.5);\n\n                    // Alpha\n                    float alpha = shape * vAlpha * uOpacity;\n\n                    if (alpha < 0.02) discard;\n\n                    // \n                    // COLOR - Simple gray smoke\n                    // \n\n                    // Core is lighter, edges darker - darker overall for less bright blobs\n                    vec3 coreColor = vec3(0.3, 0.3, 0.35);\n                    vec3 edgeColor = vec3(0.15, 0.15, 0.2);\n                    vec3 smokeColor = mix(coreColor, edgeColor, dist);\n\n                    // Apply tint\n                    smokeColor *= uTint;\n\n                    gl_FragColor = vec4(smokeColor, alpha);\n                }\n            ",transparent:!0,blending:1,depthWrite:!1,depthTest:!0})}_spawnParticle(){let e=null;for(const t of this.particles)if(!t.active){e=t;break}if(e){if(e.active=!0,e.life=0,"explosive"===this.category){const t=Math.random()*Math.PI*2,n=.4*Math.PI+Math.random()*Math.PI*.2,a=.02+.03*Math.random();e.position.set(Math.sin(n)*Math.cos(t)*a,.1*Math.random()-.35,Math.sin(n)*Math.sin(t)*a);const i=1+.6*Math.random();e.velocity.set(Math.cos(t)*i,.15+.2*Math.random(),Math.sin(t)*i),e.maxLife=.8+.4*Math.random(),e.scale=.06+.04*Math.random(),e.scaleGrowth=.25+.15*Math.random(),e.alpha=.5+.2*Math.random(),e.alphaDecay=e.alpha/e.maxLife,e.rotationSpeed=4*(Math.random()-.5)}else if("afflicted"===this.category){const t=Math.random()*Math.PI*2,n=.35+.2*Math.random(),a=.6*(Math.random()-.5);e.position.set(Math.cos(t)*n,a,Math.sin(t)*n);const i=.5+.4*this.swirl,r=.05+.05*this.swirl,s=.1+.08*Math.random();e.velocity.set(-Math.sin(t)*i-Math.cos(t)*r,s,Math.cos(t)*i-Math.sin(t)*r),e.maxLife=1.8+.8*Math.random(),e.scale=.05+.04*Math.random(),e.scaleGrowth=.06+.04*Math.random(),e.alpha=.25+.15*Math.random(),e.alphaDecay=e.alpha/e.maxLife,e.rotationSpeed=2.5*(Math.random()-.5)}else{const t=Math.random()*Math.PI*2,n=.1+.15*Math.random(),a=.1*Math.random()-.15;e.position.set(Math.cos(t)*n,a,Math.sin(t)*n);const i=.2*(Math.random()-.5),r=.2*(Math.random()-.5),s=.2+.15*Math.random();e.velocity.set(i,s,r),e.maxLife=1+.5*Math.random(),e.scale=.04+.03*Math.random(),e.scaleGrowth=.08+.05*Math.random(),e.alpha=.3+.15*Math.random(),e.alphaDecay=e.alpha/e.maxLife,e.rotationSpeed=2*(Math.random()-.5)}e.rotation=Math.random()*Math.PI*2}}update(e,t={}){if(this.time+=e,this.effectStrength=t.thickness||1,this.material.uniforms.uTime.value=this.time,t.category&&t.category!==this.category&&(this.category=t.category),t.tint&&this.material.uniforms.uTint.value.set(t.tint[0],t.tint[1],t.tint[2]),void 0!==t.swirl&&(this.swirl=t.swirl),void 0!==t.density&&(this.density=t.density),this.spawnTimer+=e,"explosive"===this.category&&!this.hasBurst&&this.effectStrength>.5){const e=15+Math.floor(5*Math.random());for(let t=0;t<e;t++)this._spawnParticle();this.hasBurst=!0}let n;this.effectStrength<.1&&(this.hasBurst=!1),n="explosive"===this.category?.04:"afflicted"===this.category?.06:.05;const a=n/(.5+.5*this.density)/this.effectStrength;for(;this.spawnTimer>=a;)this._spawnParticle(),this.spawnTimer-=a;const i=this.geometry.attributes.position.array,r=this.geometry.attributes.aSize.array,s=this.geometry.attributes.aRotation.array,o=this.geometry.attributes.aAlpha.array;for(let t=0;t<this.particles.length;t++){const n=this.particles[t];if(!n.active){r[t]=0,o[t]=0;continue}if(n.life+=e,n.life>=n.maxLife){n.active=!1,r[t]=0,o[t]=0;continue}const a=n.life/n.maxLife;n.position.x+=n.velocity.x*e,n.position.y+=n.velocity.y*e,n.position.z+=n.velocity.z*e,n.velocity.multiplyScalar(.995),n.rotation+=n.rotationSpeed*e;const l=n.scale+n.scaleGrowth*a;let c=n.alpha;if(a>.3){const e=(a-.3)/.7;c=n.alpha*(1-e*e)}i[3*t]=n.position.x,i[3*t+1]=n.position.y,i[3*t+2]=n.position.z,r[t]=100*l*this.effectStrength,s[t]=n.rotation,o[t]=c*this.effectStrength}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.aSize.needsUpdate=!0,this.geometry.attributes.aRotation.needsUpdate=!0,this.geometry.attributes.aAlpha.needsUpdate=!0}attachTo(e){this.mesh.parent&&this.mesh.parent.remove(this.mesh),e.add(this.mesh)}detach(){this.mesh.parent&&this.mesh.parent.remove(this.mesh)}dispose(){this.detach(),this.geometry.dispose(),this.material.dispose()}}hb._cloudTexture=null,hb._textureVersion=0;class db extends zo{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new yb(e)}),this.register(function(e){return new vb(e)}),this.register(function(e){return new Tb(e)}),this.register(function(e){return new Pb(e)}),this.register(function(e){return new Db(e)}),this.register(function(e){return new wb(e)}),this.register(function(e){return new xb(e)}),this.register(function(e){return new Sb(e)}),this.register(function(e){return new Mb(e)}),this.register(function(e){return new gb(e)}),this.register(function(e){return new _b(e)}),this.register(function(e){return new bb(e)}),this.register(function(e){return new Cb(e)}),this.register(function(e){return new Ab(e)}),this.register(function(e){return new mb(e)}),this.register(function(e){return new Ob(e)}),this.register(function(e){return new Eb(e)})}load(e,t,n,a){const i=this;let r;if(""!==this.resourcePath)r=this.resourcePath;else if(""!==this.path){const t=sl.extractUrlBase(e);r=sl.resolveURL(t,this.path)}else r=sl.extractUrlBase(e);this.manager.itemStart(e);const s=function(t){a?a(t):console.error(t),i.manager.itemError(e),i.manager.itemEnd(e)},o=new Lo(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(n){try{i.parse(n,r,function(n){t(n),i.manager.itemEnd(e)},s)}catch(e){s(e)}},n,s)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,a){let i;const r={},s={},o=new TextDecoder;if("string"==typeof e)i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(o.decode(new Uint8Array(e,0,4))===Ib){try{r[pb.KHR_BINARY_GLTF]=new kb(e)}catch(e){return void(a&&a(e))}i=JSON.parse(r[pb.KHR_BINARY_GLTF].content)}else i=JSON.parse(o.decode(e));else i=e;if(void 0===i.asset||i.asset.version[0]<2)return void(a&&a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new nw(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let e=0;e<this.pluginCallbacks.length;e++){const t=this.pluginCallbacks[e](l);t.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),s[t.name]=t,r[t.name]=!0}if(i.extensionsUsed)for(let e=0;e<i.extensionsUsed.length;++e){const t=i.extensionsUsed[e],n=i.extensionsRequired||[];switch(t){case pb.KHR_MATERIALS_UNLIT:r[t]=new fb;break;case pb.KHR_DRACO_MESH_COMPRESSION:r[t]=new Rb(i,this.dracoLoader);break;case pb.KHR_TEXTURE_TRANSFORM:r[t]=new zb;break;case pb.KHR_MESH_QUANTIZATION:r[t]=new Fb;break;default:n.indexOf(t)>=0&&void 0===s[t]&&console.warn('THREE.GLTFLoader: Unknown extension "'+t+'".')}}l.setExtensions(r),l.setPlugins(s),l.parse(n,a)}parseAsync(e,t){const n=this;return new Promise(function(a,i){n.parse(e,t,a,i)})}}function ub(){let e={};return{get:function(t){return e[t]},add:function(t,n){e[t]=n},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const pb={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class mb{constructor(e){this.parser=e,this.name=pb.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,a=t.length;n<a;n++){const a=t[n];a.extensions&&a.extensions[this.name]&&void 0!==a.extensions[this.name].light&&e._addNodeRef(this.cache,a.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let a=t.cache.get(n);if(a)return a;const i=t.json,r=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let s;const o=new Ia(16777215);void 0!==r.color&&o.setRGB(r.color[0],r.color[1],r.color[2],at);const l=void 0!==r.range?r.range:0;switch(r.type){case"directional":s=new il(o),s.target.position.set(0,0,-1),s.add(s.target);break;case"point":s=new tl(o),s.distance=l;break;case"spot":s=new Qo(o),s.distance=l,r.spot=r.spot||{},r.spot.innerConeAngle=void 0!==r.spot.innerConeAngle?r.spot.innerConeAngle:0,r.spot.outerConeAngle=void 0!==r.spot.outerConeAngle?r.spot.outerConeAngle:Math.PI/4,s.angle=r.spot.outerConeAngle,s.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,s.target.position.set(0,0,-1),s.add(s.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+r.type)}return s.position.set(0,0,0),Qb(s,r),void 0!==r.intensity&&(s.intensity=r.intensity),s.name=t.createUniqueName(r.name||"light_"+e),a=Promise.resolve(s),t.cache.add(n,a),a}getDependency(e,t){if("light"===e)return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,a=n.json.nodes[e],i=(a.extensions&&a.extensions[this.name]||{}).light;return void 0===i?null:this._loadLight(i).then(function(e){return n._getNodeRef(t.cache,i,e)})}}class fb{constructor(){this.name=pb.KHR_MATERIALS_UNLIT}getMaterialType(){return Fa}extendParams(e,t,n){const a=[];e.color=new Ia(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const t=i.baseColorFactor;e.color.setRGB(t[0],t[1],t[2],at),e.opacity=t[3]}void 0!==i.baseColorTexture&&a.push(n.assignTexture(e,"map",i.baseColorTexture,nt))}return Promise.all(a)}}class gb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const a=n.extensions[this.name].emissiveStrength;return void 0!==a&&(t.emissiveIntensity=a),Promise.resolve()}}class yb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser,a=n.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],r=a.extensions[this.name];if(void 0!==r.clearcoatFactor&&(t.clearcoat=r.clearcoatFactor),void 0!==r.clearcoatTexture&&i.push(n.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),void 0!==r.clearcoatRoughnessFactor&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),void 0!==r.clearcoatRoughnessTexture&&i.push(n.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),void 0!==r.clearcoatNormalTexture&&(i.push(n.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),void 0!==r.clearcoatNormalTexture.scale)){const e=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Vt(e,e)}return Promise.all(i)}}class vb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_DISPERSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const a=n.extensions[this.name];return t.dispersion=void 0!==a.dispersion?a.dispersion:0,Promise.resolve()}}class bb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser,a=n.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],r=a.extensions[this.name];return void 0!==r.iridescenceFactor&&(t.iridescence=r.iridescenceFactor),void 0!==r.iridescenceTexture&&i.push(n.assignTexture(t,"iridescenceMap",r.iridescenceTexture)),void 0!==r.iridescenceIor&&(t.iridescenceIOR=r.iridescenceIor),void 0===t.iridescenceThicknessRange&&(t.iridescenceThicknessRange=[100,400]),void 0!==r.iridescenceThicknessMinimum&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),void 0!==r.iridescenceThicknessMaximum&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),void 0!==r.iridescenceThicknessTexture&&i.push(n.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(i)}}class wb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser,a=n.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new Ia(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=a.extensions[this.name];if(void 0!==r.sheenColorFactor){const e=r.sheenColorFactor;t.sheenColor.setRGB(e[0],e[1],e[2],at)}return void 0!==r.sheenRoughnessFactor&&(t.sheenRoughness=r.sheenRoughnessFactor),void 0!==r.sheenColorTexture&&i.push(n.assignTexture(t,"sheenColorMap",r.sheenColorTexture,nt)),void 0!==r.sheenRoughnessTexture&&i.push(n.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(i)}}class xb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser,a=n.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],r=a.extensions[this.name];return void 0!==r.transmissionFactor&&(t.transmission=r.transmissionFactor),void 0!==r.transmissionTexture&&i.push(n.assignTexture(t,"transmissionMap",r.transmissionTexture)),Promise.all(i)}}class Sb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser,a=n.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],r=a.extensions[this.name];t.thickness=void 0!==r.thicknessFactor?r.thicknessFactor:0,void 0!==r.thicknessTexture&&i.push(n.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const s=r.attenuationColor||[1,1,1];return t.attenuationColor=(new Ia).setRGB(s[0],s[1],s[2],at),Promise.all(i)}}class Mb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const a=n.extensions[this.name];return t.ior=void 0!==a.ior?a.ior:1.5,Promise.resolve()}}class _b{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser,a=n.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],r=a.extensions[this.name];t.specularIntensity=void 0!==r.specularFactor?r.specularFactor:1,void 0!==r.specularTexture&&i.push(n.assignTexture(t,"specularIntensityMap",r.specularTexture));const s=r.specularColorFactor||[1,1,1];return t.specularColor=(new Ia).setRGB(s[0],s[1],s[2],at),void 0!==r.specularColorTexture&&i.push(n.assignTexture(t,"specularColorMap",r.specularColorTexture,nt)),Promise.all(i)}}class Ab{constructor(e){this.parser=e,this.name=pb.EXT_MATERIALS_BUMP}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser,a=n.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],r=a.extensions[this.name];return t.bumpScale=void 0!==r.bumpFactor?r.bumpFactor:1,void 0!==r.bumpTexture&&i.push(n.assignTexture(t,"bumpMap",r.bumpTexture)),Promise.all(i)}}class Cb{constructor(e){this.parser=e,this.name=pb.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?co:null}extendMaterialParams(e,t){const n=this.parser,a=n.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const i=[],r=a.extensions[this.name];return void 0!==r.anisotropyStrength&&(t.anisotropy=r.anisotropyStrength),void 0!==r.anisotropyRotation&&(t.anisotropyRotation=r.anisotropyRotation),void 0!==r.anisotropyTexture&&i.push(n.assignTexture(t,"anisotropyMap",r.anisotropyTexture)),Promise.all(i)}}class Tb{constructor(e){this.parser=e,this.name=pb.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,a=n.textures[e];if(!a.extensions||!a.extensions[this.name])return null;const i=a.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,r)}}class Pb{constructor(e){this.parser=e,this.name=pb.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,n=this.parser,a=n.json,i=a.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],s=a.images[r.source];let o=n.textureLoader;if(s.uri){const e=n.options.manager.getHandler(s.uri);null!==e&&(o=e)}return n.loadTextureImage(e,r.source,o)}}class Db{constructor(e){this.parser=e,this.name=pb.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,n=this.parser,a=n.json,i=a.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],s=a.images[r.source];let o=n.textureLoader;if(s.uri){const e=n.options.manager.getHandler(s.uri);null!==e&&(o=e)}return n.loadTextureImage(e,r.source,o)}}class Ob{constructor(e){this.name=pb.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const e=n.extensions[this.name],a=this.parser.getDependency("buffer",e.buffer),i=this.parser.options.meshoptDecoder;if(!i||!i.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return a.then(function(t){const n=e.byteOffset||0,a=e.byteLength||0,r=e.count,s=e.byteStride,o=new Uint8Array(t,n,a);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(r,s,o,e.mode,e.filter).then(function(e){return e.buffer}):i.ready.then(function(){const t=new ArrayBuffer(r*s);return i.decodeGltfBuffer(new Uint8Array(t),r,s,o,e.mode,e.filter),t})})}return null}}class Eb{constructor(e){this.name=pb.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||void 0===n.mesh)return null;const a=t.meshes[n.mesh];for(const e of a.primitives)if(e.mode!==Vb.TRIANGLES&&e.mode!==Vb.TRIANGLE_STRIP&&e.mode!==Vb.TRIANGLE_FAN&&void 0!==e.mode)return null;const i=n.extensions[this.name].attributes,r=[],s={};for(const e in i)r.push(this.parser.getDependency("accessor",i[e]).then(t=>(s[e]=t,s[e])));return r.length<1?null:(r.push(this.parser.createNodeMesh(e)),Promise.all(r).then(e=>{const t=e.pop(),n=t.isGroup?t.children:[t],a=e[0].count,i=[];for(const e of n){const t=new Vn,n=new Gt,r=new Ut,o=new Gt(1,1,1),l=new xr(e.geometry,e.material,a);for(let e=0;e<a;e++)s.TRANSLATION&&n.fromBufferAttribute(s.TRANSLATION,e),s.ROTATION&&r.fromBufferAttribute(s.ROTATION,e),s.SCALE&&o.fromBufferAttribute(s.SCALE,e),l.setMatrixAt(e,t.compose(n,r,o));for(const t in s)if("_COLOR_0"===t){const e=s[t];l.instanceColor=new pr(e.array,e.itemSize,e.normalized)}else"TRANSLATION"!==t&&"ROTATION"!==t&&"SCALE"!==t&&e.geometry.setAttribute(t,s[t]);pa.prototype.copy.call(l,e),this.parser.assignFinalMaterial(l),i.push(l)}return t.isGroup?(t.clear(),t.add(...i),t):i[0]}))}}const Ib="glTF";class kb{constructor(e){this.name=pb.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12),n=new TextDecoder;if(this.header={magic:n.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Ib)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const a=this.header.length-12,i=new DataView(e,12);let r=0;for(;r<a;){const t=i.getUint32(r,!0);r+=4;const a=i.getUint32(r,!0);if(r+=4,1313821514===a){const a=new Uint8Array(e,12+r,t);this.content=n.decode(a)}else if(5130562===a){const n=12+r;this.body=e.slice(n,n+t)}r+=t}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Rb{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=pb.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,a=this.dracoLoader,i=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,s={},o={},l={};for(const e in r){const t=Hb[e]||e.toLowerCase();s[t]=r[e]}for(const t in e.attributes){const a=Hb[t]||t.toLowerCase();if(void 0!==r[t]){const i=n.accessors[e.attributes[t]],r=Ub[i.componentType];l[a]=r.name,o[a]=!0===i.normalized}}return t.getDependency("bufferView",i).then(function(e){return new Promise(function(t,n){a.decodeDracoFile(e,function(e){for(const t in e.attributes){const n=e.attributes[t],a=o[t];void 0!==a&&(n.normalized=a)}t(e)},s,l,at,n)})})}}class zb{constructor(){this.name=pb.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&t.texCoord!==e.channel||void 0!==t.offset||void 0!==t.rotation||void 0!==t.scale?(e=e.clone(),void 0!==t.texCoord&&(e.channel=t.texCoord),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0,e):e}}class Fb{constructor(){this.name=pb.KHR_MESH_QUANTIZATION}}class Bb extends vo{constructor(e,t,n,a){super(e,t,n,a)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,a=this.valueSize,i=e*a*3+a;for(let e=0;e!==a;e++)t[e]=n[i+e];return t}interpolate_(e,t,n,a){const i=this.resultBuffer,r=this.sampleValues,s=this.valueSize,o=2*s,l=3*s,c=a-t,h=(n-t)/c,d=h*h,u=d*h,p=e*l,m=p-l,f=-2*u+3*d,g=u-d,y=1-f,v=g-d+h;for(let e=0;e!==s;e++){const t=r[m+e+s],n=r[m+e+o]*c,a=r[p+e+s],l=r[p+e]*c;i[e]=y*t+v*n+f*a+g*l}return i}}const Lb=new Ut;class Nb extends Bb{interpolate_(e,t,n,a){const i=super.interpolate_(e,t,n,a);return Lb.fromArray(i).normalize().toArray(i),i}}const Vb={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Ub={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Gb={9728:G,9729:H,9984:W,9985:j,9986:q,9987:X},Wb={33071:V,33648:U,10497:N},qb={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Hb={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},jb={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Xb={CUBICSPLINE:void 0,LINEAR:Qe,STEP:$e};function Yb(e){return void 0===e.DefaultMaterial&&(e.DefaultMaterial=new lo({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:0})),e.DefaultMaterial}function $b(e,t,n){for(const a in n.extensions)void 0===e[a]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[a]=n.extensions[a])}function Qb(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function Kb(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let n=0,a=t.weights.length;n<a;n++)e.morphTargetInfluences[n]=t.weights[n];if(t.extras&&Array.isArray(t.extras.targetNames)){const n=t.extras.targetNames;if(e.morphTargetInfluences.length===n.length){e.morphTargetDictionary={};for(let t=0,a=n.length;t<a;t++)e.morphTargetDictionary[n[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Zb(e){let t;const n=e.extensions&&e.extensions[pb.KHR_DRACO_MESH_COMPRESSION];if(t=n?"draco:"+n.bufferView+":"+n.indices+":"+Jb(n.attributes):e.indices+":"+Jb(e.attributes)+":"+e.mode,void 0!==e.targets)for(let n=0,a=e.targets.length;n<a;n++)t+=":"+Jb(e.targets[n]);return t}function Jb(e){let t="";const n=Object.keys(e).sort();for(let a=0,i=n.length;a<i;a++)t+=n[a]+":"+e[n[a]]+";";return t}function ew(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const tw=new Vn;class nw{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new ub,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,a=-1,i=!1,r=-1;if("undefined"!=typeof navigator){const e=navigator.userAgent;n=!0===/^((?!chrome|android).)*safari/i.test(e);const t=e.match(/Version\/(\d+)/);a=n&&t?parseInt(t[1],10):-1,i=e.indexOf("Firefox")>-1,r=i?e.match(/Firefox\/([0-9]+)\./)[1]:-1}"undefined"==typeof createImageBitmap||n&&a<17||i&&r<98?this.textureLoader=new Go(this.options.manager):this.textureLoader=new cl(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Lo(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,a=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(e){return e._markDefs&&e._markDefs()}),Promise.all(this._invokeAll(function(e){return e.beforeRoot&&e.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(t){const r={scene:t[0][a.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:a.asset,parser:n,userData:{}};return $b(i,r,a),Qb(r,a),Promise.all(n._invokeAll(function(e){return e.afterRoot&&e.afterRoot(r)})).then(function(){for(const e of r.scenes)e.updateMatrixWorld();e(r)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let n=0,a=t.length;n<a;n++){const a=t[n].joints;for(let t=0,n=a.length;t<n;t++)e[a[t]].isBone=!0}for(let t=0,a=e.length;t<a;t++){const a=e[t];void 0!==a.mesh&&(this._addNodeRef(this.meshCache,a.mesh),void 0!==a.skin&&(n[a.mesh].isSkinnedMesh=!0)),void 0!==a.camera&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const a=n.clone(),i=(e,t)=>{const n=this.associations.get(e);null!=n&&this.associations.set(t,n);for(const[n,a]of e.children.entries())i(a,t.children[n])};return i(n,a),a.name+="_instance_"+e.uses[t]++,a}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const a=e(t[n]);if(a)return a}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let a=0;a<t.length;a++){const i=e(t[a]);i&&n.push(i)}return n}getDependency(e,t){const n=e+":"+t;let a=this.cache.get(n);if(!a){switch(e){case"scene":a=this.loadScene(t);break;case"node":a=this._invokeOne(function(e){return e.loadNode&&e.loadNode(t)});break;case"mesh":a=this._invokeOne(function(e){return e.loadMesh&&e.loadMesh(t)});break;case"accessor":a=this.loadAccessor(t);break;case"bufferView":a=this._invokeOne(function(e){return e.loadBufferView&&e.loadBufferView(t)});break;case"buffer":a=this.loadBuffer(t);break;case"material":a=this._invokeOne(function(e){return e.loadMaterial&&e.loadMaterial(t)});break;case"texture":a=this._invokeOne(function(e){return e.loadTexture&&e.loadTexture(t)});break;case"skin":a=this.loadSkin(t);break;case"animation":a=this._invokeOne(function(e){return e.loadAnimation&&e.loadAnimation(t)});break;case"camera":a=this.loadCamera(t);break;default:if(a=this._invokeOne(function(n){return n!=this&&n.getDependency&&n.getDependency(e,t)}),!a)throw new Error("Unknown type: "+e)}this.cache.add(n,a)}return a}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,a=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(a.map(function(t,a){return n.getDependency(e,a)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[pb.KHR_BINARY_GLTF].body);const a=this.options;return new Promise(function(e,i){n.load(sl.resolveURL(t.uri,a.path),e,void 0,function(){i(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(e){const n=t.byteLength||0,a=t.byteOffset||0;return e.slice(a,a+n)})}loadAccessor(e){const t=this,n=this.json,a=this.json.accessors[e];if(void 0===a.bufferView&&void 0===a.sparse){const e=qb[a.type],t=Ub[a.componentType],n=!0===a.normalized,i=new t(a.count*e);return Promise.resolve(new Wa(i,e,n))}const i=[];return void 0!==a.bufferView?i.push(this.getDependency("bufferView",a.bufferView)):i.push(null),void 0!==a.sparse&&(i.push(this.getDependency("bufferView",a.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",a.sparse.values.bufferView))),Promise.all(i).then(function(e){const i=e[0],r=qb[a.type],s=Ub[a.componentType],o=s.BYTES_PER_ELEMENT,l=o*r,c=a.byteOffset||0,h=void 0!==a.bufferView?n.bufferViews[a.bufferView].byteStride:void 0,d=!0===a.normalized;let u,p;if(h&&h!==l){const e=Math.floor(c/h),n="InterleavedBuffer:"+a.bufferView+":"+a.componentType+":"+e+":"+a.count;let l=t.cache.get(n);l||(u=new s(i,e*h,a.count*h/o),l=new ki(u,h/o),t.cache.add(n,l)),p=new zi(l,r,c%h/o,d)}else u=null===i?new s(a.count*r):new s(i,c,a.count*r),p=new Wa(u,r,d);if(void 0!==a.sparse){const t=qb.SCALAR,n=Ub[a.sparse.indices.componentType],o=a.sparse.indices.byteOffset||0,l=a.sparse.values.byteOffset||0,c=new n(e[1],o,a.sparse.count*t),h=new s(e[2],l,a.sparse.count*r);null!==i&&(p=new Wa(p.array.slice(),p.itemSize,p.normalized)),p.normalized=!1;for(let e=0,t=c.length;e<t;e++){const t=c[e];if(p.setX(t,h[e*r]),r>=2&&p.setY(t,h[e*r+1]),r>=3&&p.setZ(t,h[e*r+2]),r>=4&&p.setW(t,h[e*r+3]),r>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}p.normalized=d}return p})}loadTexture(e){const t=this.json,n=this.options,a=t.textures[e].source,i=t.images[a];let r=this.textureLoader;if(i.uri){const e=n.manager.getHandler(i.uri);null!==e&&(r=e)}return this.loadTextureImage(e,a,r)}loadTextureImage(e,t,n){const a=this,i=this.json,r=i.textures[e],s=i.images[t],o=(s.uri||s.bufferView)+":"+r.sampler;if(this.textureCache[o])return this.textureCache[o];const l=this.loadImageSource(t,n).then(function(t){t.flipY=!1,t.name=r.name||s.name||"",""===t.name&&"string"==typeof s.uri&&!1===s.uri.startsWith("data:image/")&&(t.name=s.uri);const n=(i.samplers||{})[r.sampler]||{};return t.magFilter=Gb[n.magFilter]||H,t.minFilter=Gb[n.minFilter]||X,t.wrapS=Wb[n.wrapS]||N,t.wrapT=Wb[n.wrapT]||N,t.generateMipmaps=!t.isCompressedTexture&&t.minFilter!==G&&t.minFilter!==H,a.associations.set(t,{textures:e}),t}).catch(function(){return null});return this.textureCache[o]=l,l}loadImageSource(e,t){const n=this.json,a=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then(e=>e.clone());const i=n.images[e],r=self.URL||self.webkitURL;let s=i.uri||"",o=!1;if(void 0!==i.bufferView)s=this.getDependency("bufferView",i.bufferView).then(function(e){o=!0;const t=new Blob([e],{type:i.mimeType});return s=r.createObjectURL(t),s});else if(void 0===i.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const l=Promise.resolve(s).then(function(e){return new Promise(function(n,i){let r=n;!0===t.isImageBitmapLoader&&(r=function(e){const t=new on(e);t.needsUpdate=!0,n(t)}),t.load(sl.resolveURL(e,a.path),r,void 0,i)})}).then(function(e){var t;return!0===o&&r.revokeObjectURL(s),Qb(e,i),e.userData.mimeType=i.mimeType||((t=i.uri).search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/)?"image/jpeg":t.search(/\.webp($|\?)/i)>0||0===t.search(/^data\:image\/webp/)?"image/webp":t.search(/\.ktx2($|\?)/i)>0||0===t.search(/^data\:image\/ktx2/)?"image/ktx2":"image/png"),e}).catch(function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",s),e});return this.sourceCache[e]=l,l}assignTexture(e,t,n,a){const i=this;return this.getDependency("texture",n.index).then(function(r){if(!r)return null;if(void 0!==n.texCoord&&n.texCoord>0&&((r=r.clone()).channel=n.texCoord),i.extensions[pb.KHR_TEXTURE_TRANSFORM]){const e=void 0!==n.extensions?n.extensions[pb.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=i.associations.get(r);r=i.extensions[pb.KHR_TEXTURE_TRANSFORM].extendTexture(r,e),i.associations.set(r,t)}}return void 0!==a&&(r.colorSpace=a),e[t]=r,r})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const a=void 0===t.attributes.tangent,i=void 0!==t.attributes.color,r=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+n.uuid;let t=this.cache.get(e);t||(t=new qr,za.prototype.copy.call(t,n),t.color.copy(n.color),t.map=n.map,t.sizeAttenuation=!1,this.cache.add(e,t)),n=t}else if(e.isLine){const e="LineBasicMaterial:"+n.uuid;let t=this.cache.get(e);t||(t=new Or,za.prototype.copy.call(t,n),t.color.copy(n.color),t.map=n.map,this.cache.add(e,t)),n=t}if(a||i||r){let e="ClonedMaterial:"+n.uuid+":";a&&(e+="derivative-tangents:"),i&&(e+="vertex-colors:"),r&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=n.clone(),i&&(t.vertexColors=!0),r&&(t.flatShading=!0),a&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(n))),n=t}e.material=n}getMaterialType(){return lo}loadMaterial(e){const t=this,n=this.json,a=this.extensions,i=n.materials[e];let r;const s={},o=[];if((i.extensions||{})[pb.KHR_MATERIALS_UNLIT]){const e=a[pb.KHR_MATERIALS_UNLIT];r=e.getMaterialType(),o.push(e.extendParams(s,i,t))}else{const n=i.pbrMetallicRoughness||{};if(s.color=new Ia(1,1,1),s.opacity=1,Array.isArray(n.baseColorFactor)){const e=n.baseColorFactor;s.color.setRGB(e[0],e[1],e[2],at),s.opacity=e[3]}void 0!==n.baseColorTexture&&o.push(t.assignTexture(s,"map",n.baseColorTexture,nt)),s.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,s.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(o.push(t.assignTexture(s,"metalnessMap",n.metallicRoughnessTexture)),o.push(t.assignTexture(s,"roughnessMap",n.metallicRoughnessTexture))),r=this._invokeOne(function(t){return t.getMaterialType&&t.getMaterialType(e)}),o.push(Promise.all(this._invokeAll(function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,s)})))}!0===i.doubleSided&&(s.side=2);const l=i.alphaMode||"OPAQUE";if("BLEND"===l?(s.transparent=!0,s.depthWrite=!1):(s.transparent=!1,"MASK"===l&&(s.alphaTest=void 0!==i.alphaCutoff?i.alphaCutoff:.5)),void 0!==i.normalTexture&&r!==Fa&&(o.push(t.assignTexture(s,"normalMap",i.normalTexture)),s.normalScale=new Vt(1,1),void 0!==i.normalTexture.scale)){const e=i.normalTexture.scale;s.normalScale.set(e,e)}if(void 0!==i.occlusionTexture&&r!==Fa&&(o.push(t.assignTexture(s,"aoMap",i.occlusionTexture)),void 0!==i.occlusionTexture.strength&&(s.aoMapIntensity=i.occlusionTexture.strength)),void 0!==i.emissiveFactor&&r!==Fa){const e=i.emissiveFactor;s.emissive=(new Ia).setRGB(e[0],e[1],e[2],at)}return void 0!==i.emissiveTexture&&r!==Fa&&o.push(t.assignTexture(s,"emissiveMap",i.emissiveTexture,nt)),Promise.all(o).then(function(){const n=new r(s);return i.name&&(n.name=i.name),Qb(n,i),t.associations.set(n,{materials:e}),i.extensions&&$b(a,n,i),n})}createUniqueName(e){const t=vl.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,a=this.primitiveCache;function i(e){return n[pb.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then(function(n){return aw(n,e,t)})}const r=[];for(let n=0,s=e.length;n<s;n++){const s=e[n],o=Zb(s),l=a[o];if(l)r.push(l.promise);else{let e;e=s.extensions&&s.extensions[pb.KHR_DRACO_MESH_COMPRESSION]?i(s):aw(new ei,s,t),a[o]={primitive:s,promise:e},r.push(e)}}return Promise.all(r)}loadMesh(e){const t=this,n=this.json,a=this.extensions,i=n.meshes[e],r=i.primitives,s=[];for(let e=0,t=r.length;e<t;e++){const t=void 0===r[e].material?Yb(this.cache):this.getDependency("material",r[e].material);s.push(t)}return s.push(t.loadGeometries(r)),Promise.all(s).then(function(n){const s=n.slice(0,n.length-1),o=n[n.length-1],l=[];for(let n=0,c=o.length;n<c;n++){const c=o[n],h=r[n];let d;const u=s[n];if(h.mode===Vb.TRIANGLES||h.mode===Vb.TRIANGLE_STRIP||h.mode===Vb.TRIANGLE_FAN||void 0===h.mode)d=!0===i.isSkinnedMesh?new or(c,u):new ui(c,u),!0===d.isSkinnedMesh&&d.normalizeSkinWeights(),h.mode===Vb.TRIANGLE_STRIP?d.geometry=uu(d.geometry,1):h.mode===Vb.TRIANGLE_FAN&&(d.geometry=uu(d.geometry,2));else if(h.mode===Vb.LINES)d=new Gr(c,u);else if(h.mode===Vb.LINE_STRIP)d=new Lr(c,u);else if(h.mode===Vb.LINE_LOOP)d=new Wr(c,u);else{if(h.mode!==Vb.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+h.mode);d=new $r(c,u)}Object.keys(d.geometry.morphAttributes).length>0&&Kb(d,i),d.name=t.createUniqueName(i.name||"mesh_"+e),Qb(d,i),h.extensions&&$b(a,d,h),t.assignFinalMaterial(d),l.push(d)}for(let n=0,a=l.length;n<a;n++)t.associations.set(l[n],{meshes:e,primitives:n});if(1===l.length)return i.extensions&&$b(a,l[0],i),l[0];const c=new Di;i.extensions&&$b(a,c,i),t.associations.set(c,{meshes:e});for(let e=0,t=l.length;e<t;e++)c.add(l[e]);return c})}loadCamera(e){let t;const n=this.json.cameras[e],a=n[n.type];if(a)return"perspective"===n.type?t=new _i(Nt.radToDeg(a.yfov),a.aspectRatio||1,a.znear||1,a.zfar||2e6):"orthographic"===n.type&&(t=new nl(-a.xmag,a.xmag,a.ymag,-a.ymag,a.znear,a.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),Qb(t,n),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],n=[];for(let e=0,a=t.joints.length;e<a;e++)n.push(this._loadNodeShallow(t.joints[e]));return void 0!==t.inverseBindMatrices?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(e){const n=e.pop(),a=e,i=[],r=[];for(let e=0,s=a.length;e<s;e++){const s=a[e];if(s){i.push(s);const t=new Vn;null!==n&&t.fromArray(n.array,16*e),r.push(t)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}return new ur(i,r)})}loadAnimation(e){const t=this.json,n=this,a=t.animations[e],i=a.name?a.name:"animation_"+e,r=[],s=[],o=[],l=[],c=[];for(let e=0,t=a.channels.length;e<t;e++){const t=a.channels[e],n=a.samplers[t.sampler],i=t.target,h=i.node,d=void 0!==a.parameters?a.parameters[n.input]:n.input,u=void 0!==a.parameters?a.parameters[n.output]:n.output;void 0!==i.node&&(r.push(this.getDependency("node",h)),s.push(this.getDependency("accessor",d)),o.push(this.getDependency("accessor",u)),l.push(n),c.push(i))}return Promise.all([Promise.all(r),Promise.all(s),Promise.all(o),Promise.all(l),Promise.all(c)]).then(function(e){const t=e[0],r=e[1],s=e[2],o=e[3],l=e[4],c=[];for(let e=0,a=t.length;e<a;e++){const a=t[e],i=r[e],h=s[e],d=o[e],u=l[e];if(void 0===a)continue;a.updateMatrix&&a.updateMatrix();const p=n._createAnimationTracks(a,i,h,d,u);if(p)for(let e=0;e<p.length;e++)c.push(p[e])}const h=new Oo(i,void 0,c);return Qb(h,a),h})}createNodeMesh(e){const t=this.json,n=this,a=t.nodes[e];return void 0===a.mesh?null:n.getDependency("mesh",a.mesh).then(function(e){const t=n._getNodeRef(n.meshCache,a.mesh,e);return void 0!==a.weights&&t.traverse(function(e){if(e.isMesh)for(let t=0,n=a.weights.length;t<n;t++)e.morphTargetInfluences[t]=a.weights[t]}),t})}loadNode(e){const t=this,n=this.json.nodes[e],a=t._loadNodeShallow(e),i=[],r=n.children||[];for(let e=0,n=r.length;e<n;e++)i.push(t.getDependency("node",r[e]));const s=void 0===n.skin?Promise.resolve(null):t.getDependency("skin",n.skin);return Promise.all([a,Promise.all(i),s]).then(function(e){const t=e[0],n=e[1],a=e[2];null!==a&&t.traverse(function(e){e.isSkinnedMesh&&e.bind(a,tw)});for(let e=0,a=n.length;e<a;e++)t.add(n[e]);return t})}_loadNodeShallow(e){const t=this.json,n=this.extensions,a=this;if(void 0!==this.nodeCache[e])return this.nodeCache[e];const i=t.nodes[e],r=i.name?a.createUniqueName(i.name):"",s=[],o=a._invokeOne(function(t){return t.createNodeMesh&&t.createNodeMesh(e)});return o&&s.push(o),void 0!==i.camera&&s.push(a.getDependency("camera",i.camera).then(function(e){return a._getNodeRef(a.cameraCache,i.camera,e)})),a._invokeAll(function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)}).forEach(function(e){s.push(e)}),this.nodeCache[e]=Promise.all(s).then(function(t){let s;if(s=!0===i.isBone?new lr:t.length>1?new Di:1===t.length?t[0]:new pa,s!==t[0])for(let e=0,n=t.length;e<n;e++)s.add(t[e]);if(i.name&&(s.userData.name=i.name,s.name=r),Qb(s,i),i.extensions&&$b(n,s,i),void 0!==i.matrix){const e=new Vn;e.fromArray(i.matrix),s.applyMatrix4(e)}else void 0!==i.translation&&s.position.fromArray(i.translation),void 0!==i.rotation&&s.quaternion.fromArray(i.rotation),void 0!==i.scale&&s.scale.fromArray(i.scale);if(a.associations.has(s)){if(void 0!==i.mesh&&a.meshCache.refs[i.mesh]>1){const e=a.associations.get(s);a.associations.set(s,{...e})}}else a.associations.set(s,{});return a.associations.get(s).nodes=e,s}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],a=this,i=new Di;n.name&&(i.name=a.createUniqueName(n.name)),Qb(i,n),n.extensions&&$b(t,i,n);const r=n.nodes||[],s=[];for(let e=0,t=r.length;e<t;e++)s.push(a.getDependency("node",r[e]));return Promise.all(s).then(function(e){for(let t=0,n=e.length;t<n;t++)i.add(e[t]);return a.associations=(e=>{const t=new Map;for(const[e,n]of a.associations)(e instanceof za||e instanceof on)&&t.set(e,n);return e.traverse(e=>{const n=a.associations.get(e);null!=n&&t.set(e,n)}),t})(i),i})}_createAnimationTracks(e,t,n,a,i){const r=[],s=e.name?e.name:e.uuid,o=[];let l;switch(jb[i.path]===jb.weights?e.traverse(function(e){e.morphTargetInfluences&&o.push(e.name?e.name:e.uuid)}):o.push(s),jb[i.path]){case jb.weights:l=Ao;break;case jb.rotation:l=To;break;case jb.translation:case jb.scale:l=Do;break;default:l=1===n.itemSize?Ao:Do}const c=void 0!==a.interpolation?Xb[a.interpolation]:Qe,h=this._getArrayFromAccessor(n);for(let e=0,n=o.length;e<n;e++){const n=new l(o[e]+"."+jb[i.path],t.array,h,c);"CUBICSPLINE"===a.interpolation&&this._createCubicSplineTrackInterpolant(n),r.push(n)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const e=ew(t.constructor),n=new Float32Array(t.length);for(let a=0,i=t.length;a<i;a++)n[a]=t[a]*e;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(e){return new(this instanceof To?Nb:Bb)(this.times,this.values,this.getValueSize()/3,e)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function aw(e,t,n){const a=t.attributes,i=[];function r(t,a){return n.getDependency("accessor",t).then(function(t){e.setAttribute(a,t)})}for(const t in a){const n=Hb[t]||t.toLowerCase();n in e.attributes||i.push(r(a[t],n))}if(void 0!==t.indices&&!e.index){const a=n.getDependency("accessor",t.indices).then(function(t){e.setIndex(t)});i.push(a)}return Qt.workingColorSpace!==at&&"COLOR_0"in a&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Qt.workingColorSpace}" not supported.`),Qb(e,t),function(e,t,n){const a=t.attributes,i=new pn;if(void 0===a.POSITION)return;{const e=n.json.accessors[a.POSITION],t=e.min,r=e.max;if(void 0===t||void 0===r)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(i.set(new Gt(t[0],t[1],t[2]),new Gt(r[0],r[1],r[2])),e.normalized){const t=ew(Ub[e.componentType]);i.min.multiplyScalar(t),i.max.multiplyScalar(t)}}const r=t.targets;if(void 0!==r){const e=new Gt,t=new Gt;for(let a=0,i=r.length;a<i;a++){const i=r[a];if(void 0!==i.POSITION){const a=n.json.accessors[i.POSITION],r=a.min,s=a.max;if(void 0!==r&&void 0!==s){if(t.setX(Math.max(Math.abs(r[0]),Math.abs(s[0]))),t.setY(Math.max(Math.abs(r[1]),Math.abs(s[1]))),t.setZ(Math.max(Math.abs(r[2]),Math.abs(s[2]))),a.normalized){const e=ew(Ub[a.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(e)}e.boundingBox=i;const s=new En;i.getCenter(s.center),s.radius=i.min.distanceTo(i.max)/2,e.boundingSphere=s}(e,t,n),Promise.all(i).then(function(){return void 0!==t.targets?function(e,t,n){let a=!1,i=!1,r=!1;for(let e=0,n=t.length;e<n;e++){const n=t[e];if(void 0!==n.POSITION&&(a=!0),void 0!==n.NORMAL&&(i=!0),void 0!==n.COLOR_0&&(r=!0),a&&i&&r)break}if(!a&&!i&&!r)return Promise.resolve(e);const s=[],o=[],l=[];for(let c=0,h=t.length;c<h;c++){const h=t[c];if(a){const t=void 0!==h.POSITION?n.getDependency("accessor",h.POSITION):e.attributes.position;s.push(t)}if(i){const t=void 0!==h.NORMAL?n.getDependency("accessor",h.NORMAL):e.attributes.normal;o.push(t)}if(r){const t=void 0!==h.COLOR_0?n.getDependency("accessor",h.COLOR_0):e.attributes.color;l.push(t)}}return Promise.all([Promise.all(s),Promise.all(o),Promise.all(l)]).then(function(t){const n=t[0],s=t[1],o=t[2];return a&&(e.morphAttributes.position=n),i&&(e.morphAttributes.normal=s),r&&(e.morphAttributes.color=o),e.morphTargetsRelative=!0,e})}(e,t.targets,n):e})}class iw{constructor(e,t,n=16){this.maxElements=n,this.maxInstances=2*n,this.mesh=new xr(e,t,this.maxInstances),this.mesh.frustumCulled=!1,this.mesh.count=0,this._createInstanceAttributes(),this.freeSlots=[],this.activeElements=new Map;for(let e=this.maxInstances-2;e>=0;e-=2)this.freeSlots.push(e);this._matrix=new Vn,this._position=new Gt,this._quaternion=new Ut,this._scale=new Gt(1,1,1),this._identityQuaternion=new Ut,this._unitScale=new Gt(1,1,1),this.globalTime=0,this._pendingTimeouts=new Set}_createInstanceAttributes(){const e=this.maxInstances;this.spawnTimeArray=new Float32Array(e),this.spawnTimeAttr=new pr(this.spawnTimeArray,1),this.mesh.geometry.setAttribute("aSpawnTime",this.spawnTimeAttr),this.exitTimeArray=new Float32Array(e),this.exitTimeAttr=new pr(this.exitTimeArray,1),this.mesh.geometry.setAttribute("aExitTime",this.exitTimeAttr),this.selectedModelArray=new Float32Array(e),this.selectedModelAttr=new pr(this.selectedModelArray,1),this.mesh.geometry.setAttribute("aSelectedModel",this.selectedModelAttr),this.opacityArray=new Float32Array(e).fill(1),this.opacityAttr=new pr(this.opacityArray,1),this.mesh.geometry.setAttribute("aInstanceOpacity",this.opacityAttr),this.trailParentArray=new Float32Array(e).fill(-1),this.trailParentAttr=new pr(this.trailParentArray,1),this.mesh.geometry.setAttribute("aTrailParent",this.trailParentAttr),this.trailIndexArray=new Float32Array(e).fill(-1),this.trailIndexAttr=new pr(this.trailIndexArray,1),this.mesh.geometry.setAttribute("aTrailIndex",this.trailIndexAttr),this.velocityArray=new Float32Array(4*e),this.velocityAttr=new pr(this.velocityArray,4),this.mesh.geometry.setAttribute("aVelocity",this.velocityAttr),this.randomSeedArray=new Float32Array(e);for(let t=0;t<e;t++)this.randomSeedArray[t]=Math.random();this.randomSeedAttr=new pr(this.randomSeedArray,1),this.mesh.geometry.setAttribute("aRandomSeed",this.randomSeedAttr)}spawn(e,t,n,a,i=0,r=null,s=null){if(0===this.freeSlots.length)return console.warn("[ElementInstancePool] Pool full, cannot spawn"),!1;const o=this.freeSlots.pop(),l=[o+1,o+2,o+3],c=this.globalTime;this.activeElements.set(e,{mainSlot:o,trailSlots:l,spawnTime:c,exitTime:0,position:t.clone(),modelIndex:i}),this._setupInstance(o,t,n,a,{spawnTime:c,exitTime:0,modelIndex:i,opacity:0,trailParent:-1,trailIndex:-1,arcPhase:r,relayIndex:s});for(let e=0;e<1;e++){const h=l[e];this._setupInstance(h,t,n,a,{spawnTime:c,exitTime:0,modelIndex:i,opacity:0,trailParent:o,trailIndex:e,arcPhase:r,relayIndex:s})}return this._updateVisibleCount(),!0}_setupInstance(e,t,n,a,i){if(this._position.copy(t),this._quaternion.copy(n||this._identityQuaternion),this._scale.copy(a||this._unitScale),this._matrix.compose(this._position,this._quaternion,this._scale),this.mesh.setMatrixAt(e,this._matrix),this.spawnTimeArray[e]=i.spawnTime,this.exitTimeArray[e]=i.exitTime,this.selectedModelArray[e]=i.modelIndex,this.opacityArray[e]=i.opacity,this.trailParentArray[e]=i.trailParent,this.trailIndexArray[e]=i.trailIndex,"number"==typeof i.arcPhase){const t=100+10*(i.relayIndex||0);this.randomSeedArray[e]=t+i.arcPhase}else this.randomSeedArray[e]=Math.random();this.randomSeedAttr.needsUpdate=!0,this.spawnTimeAttr.needsUpdate=!0,this.exitTimeAttr.needsUpdate=!0,this.selectedModelAttr.needsUpdate=!0,this.opacityAttr.needsUpdate=!0,this.trailParentAttr.needsUpdate=!0,this.trailIndexAttr.needsUpdate=!0,this.mesh.instanceMatrix.needsUpdate=!0}updatePosition(e,t,n){const a=this.activeElements.get(e);if(a){if(!n&&a.position&&(this._velocity=this._velocity||new Gt,n=this._velocity.copy(t).sub(a.position)),a.position.copy(t),this.mesh.getMatrixAt(a.mainSlot,this._matrix),this._matrix.decompose(this._position,this._quaternion,this._scale),this._position.copy(t),this._matrix.compose(this._position,this._quaternion,this._scale),this.mesh.setMatrixAt(a.mainSlot,this._matrix),n){const e=n.length(),t=4*a.mainSlot;this.velocityArray[t]=n.x,this.velocityArray[t+1]=n.y,this.velocityArray[t+2]=n.z,this.velocityArray[t+3]=e,this.velocityAttr.needsUpdate=!0}this.mesh.instanceMatrix.needsUpdate=!0}}updateInstanceTransform(e,t,n,a,i=null){const r=this.activeElements.get(e);if(!r)return;r.position&&(i||(this._velocity=this._velocity||new Gt,i=this._velocity.copy(t).sub(r.position)),r.position.copy(t)),this._position.copy(t),this._quaternion.copy(n),"number"==typeof a?this._scale.setScalar(a):this._scale.copy(a),this._matrix.compose(this._position,this._quaternion,this._scale),this.mesh.setMatrixAt(r.mainSlot,this._matrix);const s=this._scale.x,o=this._scale.y,l=this._scale.z,c=i&&i.lengthSq()>1e-4;for(let e=0;e<1;e++){const t=r.trailSlots[e],n=c?1-.15*(e+1):0;"number"==typeof a?this._scale.setScalar(a*n):this._scale.set(s*n,o*n,l*n),this._matrix.compose(this._position,this._quaternion,this._scale),this.mesh.setMatrixAt(t,this._matrix)}if(i){const e=i.length(),t=4*r.mainSlot;this.velocityArray[t]=i.x,this.velocityArray[t+1]=i.y,this.velocityArray[t+2]=i.z,this.velocityArray[t+3]=e,this.velocityAttr.needsUpdate=!0}this.mesh.instanceMatrix.needsUpdate=!0}updateInstanceOpacity(e,t){const n=this.activeElements.get(e);if(n){this.opacityArray[n.mainSlot]=t;for(let e=0;e<1;e++){const a=n.trailSlots[e];this.opacityArray[a]=t*(1-.25*(e+1))}this.opacityAttr.needsUpdate=!0}}beginDespawn(e,t=.5){const n=this.activeElements.get(e);if(!n)return;const a=this.globalTime;n.exitTime=a;const i=[n.mainSlot,...n.trailSlots];for(const e of i)this.exitTimeArray[e]=a;this.exitTimeAttr.needsUpdate=!0;const r=setTimeout(()=>{this._pendingTimeouts.delete(r),this._finalizeRemoval(e)},1e3*t);this._pendingTimeouts.add(r)}removeImmediate(e){this._finalizeRemoval(e)}_finalizeRemoval(e){const t=this.activeElements.get(e);if(!t)return;const n=[t.mainSlot,...t.trailSlots];for(const e of n)this._matrix.makeScale(0,0,0),this.mesh.setMatrixAt(e,this._matrix),this.spawnTimeArray[e]=0,this.exitTimeArray[e]=0,this.opacityArray[e]=0;this.freeSlots.push(t.mainSlot),this.activeElements.delete(e),this.mesh.instanceMatrix.needsUpdate=!0,this.spawnTimeAttr.needsUpdate=!0,this.exitTimeAttr.needsUpdate=!0,this.opacityAttr.needsUpdate=!0,this._updateVisibleCount()}clear(){for(const e of this.activeElements.keys())this._finalizeRemoval(e)}_updateVisibleCount(){let e=0;for(const t of this.activeElements.values()){const n=t.trailSlots[0];n>=e&&(e=n+1)}this.mesh.count=e}setTime(e){this.globalTime=e}get activeCount(){return this.activeElements.size}get availableSlots(){return this.freeSlots.length}getStats(){return{activeElements:this.activeElements.size,activeInstances:this.mesh.count,maxInstances:this.maxInstances,availableSlots:this.freeSlots.length,utilizationPercent:(this.activeElements.size/this.maxElements*100).toFixed(1)}}dispose(){for(const e of this._pendingTimeouts)clearTimeout(e);this._pendingTimeouts.clear(),this.clear(),this.mesh.geometry.dispose(),this.mesh.material.dispose(),this.mesh=null}}class rw{constructor(){this.geometries=[],this.modelNames=[]}addGeometry(e,t=null){const n=this.geometries.length;return this.geometries.push(e.clone()),this.modelNames.push(t||`model_${n}`),n}addMesh(e,t=null){return this.addGeometry(e.geometry,t||e.name)}build(){if(0===this.geometries.length)throw new Error("[MergedGeometryBuilder] No geometries added");let e=0,t=0;const n=[];for(const a of this.geometries){const i=a.index?a:this._convertToIndexed(a);n.push(i),e+=i.attributes.position.count,t+=i.index.count}const a=new ei,i=new Float32Array(3*e),r=new Float32Array(3*e),s=new Float32Array(2*e),o=new Float32Array(e),l=new Uint32Array(t);let c=0,h=0,d=0;for(let e=0;e<n.length;e++){const t=n[e],a=t.attributes.position,u=t.attributes.normal,p=t.attributes.uv,m=t.index,f=a.count,g=m.count;for(let t=0;t<f;t++){const n=c+t;i[3*n]=a.getX(t),i[3*n+1]=a.getY(t),i[3*n+2]=a.getZ(t),o[n]=e}if(u)for(let e=0;e<f;e++){const t=c+e;r[3*t]=u.getX(e),r[3*t+1]=u.getY(e),r[3*t+2]=u.getZ(e)}if(p)for(let e=0;e<f;e++){const t=c+e;s[2*t]=p.getX(e),s[2*t+1]=p.getY(e)}for(let e=0;e<g;e++)l[h+e]=m.getX(e)+d;c+=f,h+=g,d+=f}a.setAttribute("position",new Wa(i,3)),a.setAttribute("normal",new Wa(r,3)),a.setAttribute("uv",new Wa(s,2)),a.setAttribute("aModelIndex",new Wa(o,1)),a.setIndex(new Wa(l,1)),a.computeBoundingSphere(),a.computeBoundingBox();const u=new Map;for(let e=0;e<this.modelNames.length;e++)u.set(this.modelNames[e],e);return{geometry:a,modelCount:this.geometries.length,modelMap:u}}_convertToIndexed(e){const t=e.attributes.position.count,n=new Uint32Array(t);for(let e=0;e<t;e++)n[e]=e;const a=e.clone();return a.setIndex(new Wa(n,1)),a}reset(){this.geometries=[],this.modelNames=[]}dispose(){for(const e of this.geometries)e.dispose();this.reset()}}const sw=new Map,ow={register(e,t){const n=["basePath","models","createMaterial","updateMaterial"];for(const a of n)if(!t[a])throw new Error(`[ElementTypeRegistry] Missing required field '${a}' for type '${e}'`);sw.set(e,{scaleMultiplier:1.5,setShaderAnimation:null,...t})},get:e=>sw.get(e),has:e=>sw.has(e),types:()=>Array.from(sw.keys()),unregister:e=>sw.delete(e),clear(){sw.clear()}};class lw{constructor(){this.bounds={minY:-.5,maxY:.5,centerY:0,height:1},this.landmarks={},this.radius=1,this._coreMesh=null}initialize(e){if(this._coreMesh=e,!e?.geometry)return console.warn("[MascotSpatialRef] No geometry available, using defaults"),void this._computeLandmarks();const{geometry:t}=e,{scale:n}=e;if(t.boundingBox||t.computeBoundingBox(),t.boundingBox){const e=t.boundingBox;this.bounds={minY:e.min.y,maxY:e.max.y,centerY:.5*(e.min.y+e.max.y),height:e.max.y-e.min.y}}if(t.boundingSphere||t.computeBoundingSphere(),t.boundingSphere){const e=(n.x+n.y+n.z)/3;this.radius=t.boundingSphere.radius*e}this.radius=Math.max(.1,this.radius),this._computeLandmarks()}_computeLandmarks(){const e=this.bounds,t=.15*e.height;this.landmarks={bottom:e.minY,center:e.centerY,top:e.maxY,head:e.maxY+t,feet:e.minY,middle:e.centerY,above:e.maxY+.3*e.height,below:e.minY-.2*e.height}}resolveLandmark(e){return"number"==typeof e?e:"string"==typeof e&&Object.hasOwn(this.landmarks,e)?this.landmarks[e]:(console.warn(`[MascotSpatialRef] Unknown landmark: ${e}, using center`),this.bounds.centerY)}resolveLandmarkWithOffset(e,t=0){return this.resolveLandmark(e)+t}interpolateLandmarks(e,t,n){const a=this.resolveLandmark(e);return a+(this.resolveLandmark(t)-a)*n}isWithinBounds(e){return e>=this.bounds.minY&&e<=this.bounds.maxY}getProgressAtY(e){return 0===this.bounds.height?.5:(e-this.bounds.minY)/this.bounds.height}get top(){return this.landmarks.top}get bottom(){return this.landmarks.bottom}get center(){return this.landmarks.center}get head(){return this.landmarks.head}get height(){return this.bounds.height}refresh(){this._coreMesh&&this.initialize(this._coreMesh)}}const cw=1.6180339887,hw={tiny:1/Math.pow(cw,4),small:1/Math.pow(cw,3),medium:1/Math.pow(cw,2),large:1/cw,prominent:1/Math.pow(cw,.5)},dw={"crystal-small":{class:"tiny",variance:.25},"crystal-medium":{class:"small",variance:.2},"crystal-cluster":{class:"medium",variance:.2},"ice-spike":{class:"small",variance:.25},"ice-crown":{class:"large",variance:.15},"rock-chunk-small":{class:"small",variance:.25},"rock-chunk-medium":{class:"medium",variance:.2},"rock-cluster":{class:"large",variance:.2},"stone-slab":{class:"medium",variance:.25},"earth-ring":{class:"large",variance:.15},"stone-ring":{class:"large",variance:.15},boulder:{class:"large",variance:.2},"stone-spike":{class:"small",variance:.25},"vine-ring":{class:"small",variance:0},"vine-cluster":{class:"small",variance:.25},"s-vine":{class:"medium",variance:.25},"leaf-bunch":{class:"small",variance:.3},"vine-twist":{class:"medium",variance:.25},"u-vine":{class:"medium",variance:.25},"thorn-curl":{class:"small",variance:.3},"ember-cluster":{class:"tiny",variance:.3},"flame-wisp":{class:"small",variance:.25},"flame-tongue":{class:"medium",variance:.25},"fire-burst":{class:"large",variance:.2},"flame-ring":{class:"large",variance:.15},"arc-small":{class:"small",variance:.25},"arc-medium":{class:"medium",variance:.2},"arc-cluster":{class:"large",variance:.2},"spark-node":{class:"tiny",variance:.3},"lightning-ring":{class:"large",variance:.15},"droplet-small":{class:"tiny",variance:.25},"droplet-large":{class:"small",variance:.2},"splash-ring":{class:"medium",variance:.25},"bubble-cluster":{class:"small",variance:.3},"wave-curl":{class:"medium",variance:.25},"void-crack":{class:"small",variance:.3},"shadow-tendril":{class:"medium",variance:.25},"corruption-patch":{class:"small",variance:.3},"void-shard":{class:"tiny",variance:.25},"void-ring":{class:"large",variance:.15},"void-orb":{class:"medium",variance:.2},"void-tendril-large":{class:"large",variance:.2},"void-wrap":{class:"medium",variance:.25},"void-disk":{class:"large",variance:.1},"void-crown":{class:"large",variance:.15},"light-ray":{class:"medium",variance:.25},"light-orb":{class:"small",variance:.2},"prism-shard":{class:"small",variance:.2},"light-ring":{class:"large",variance:.2},"sparkle-star":{class:"tiny",variance:.3},"sun-ring":{class:"large",variance:.15},"light-burst":{class:"medium",variance:.2},"light-crown":{class:"large",variance:.15}},uw={"crystal-small":{mode:"outward",tiltAngle:.15},"crystal-medium":{mode:"outward",tiltAngle:.2},"crystal-cluster":{mode:"outward",tiltAngle:.25},"ice-spike":{mode:"outward",tiltAngle:.05},"ice-crown":{mode:"flat",tiltAngle:0},"rock-chunk-small":{mode:"outward",tiltAngle:.35},"rock-chunk-medium":{mode:"outward",tiltAngle:.3},"rock-cluster":{mode:"outward",tiltAngle:.15},"stone-slab":{mode:"flat",tiltAngle:.1},"earth-ring":{mode:"flat",tiltAngle:0},"stone-ring":{mode:"flat",tiltAngle:0},boulder:{mode:"outward",tiltAngle:.2},"stone-spike":{mode:"outward",tiltAngle:.05},"vine-ring":{mode:"flat",tiltAngle:0},"vine-cluster":{mode:"outward",tiltAngle:.3},"s-vine":{mode:"tangent",tiltAngle:.2},"leaf-bunch":{mode:"outward",tiltAngle:.4},"vine-twist":{mode:"tangent",tiltAngle:.15},"u-vine":{mode:"tangent",tiltAngle:.2},"thorn-curl":{mode:"tangent",tiltAngle:.25},"ember-cluster":{mode:"rising",tiltAngle:.2,riseFactor:.6},"flame-wisp":{mode:"rising",tiltAngle:.15,riseFactor:.8},"flame-tongue":{mode:"rising",tiltAngle:.2,riseFactor:.75},"fire-burst":{mode:"rising",tiltAngle:.25,riseFactor:.5},"flame-ring":{mode:"flat",tiltAngle:0},"arc-small":{mode:"tangent",tiltAngle:.1},"arc-medium":{mode:"tangent",tiltAngle:.15},"arc-cluster":{mode:"outward",tiltAngle:.3},"spark-node":{mode:"outward",tiltAngle:.4},"lightning-ring":{mode:"flat",tiltAngle:0},"droplet-small":{mode:"falling",tiltAngle:.1,fallFactor:.7},"droplet-large":{mode:"falling",tiltAngle:.05,fallFactor:.8},"splash-ring":{mode:"flat",tiltAngle:.05},"bubble-cluster":{mode:"rising",tiltAngle:.2,riseFactor:.5},"wave-curl":{mode:"vertical",tiltAngle:0},"void-crack":{mode:"outward-flat",tiltAngle:.05},"shadow-tendril":{mode:"tangent",tiltAngle:.3},"corruption-patch":{mode:"flat",tiltAngle:0},"void-shard":{mode:"outward",tiltAngle:.35},"void-ring":{mode:"flat",tiltAngle:0},"void-orb":{mode:"outward",tiltAngle:0},"void-tendril-large":{mode:"tangent",tiltAngle:.2},"void-wrap":{mode:"flat",tiltAngle:.1},"void-disk":{mode:"flat",tiltAngle:0},"void-crown":{mode:"flat",tiltAngle:0},"light-ray":{mode:"outward",tiltAngle:.1},"light-orb":{mode:"outward",tiltAngle:0},"prism-shard":{mode:"outward",tiltAngle:.2},"light-ring":{mode:"flat",tiltAngle:0},"sparkle-star":{mode:"outward",tiltAngle:.3},"sun-ring":{mode:"flat",tiltAngle:0},"light-burst":{mode:"outward",tiltAngle:.15},"light-crown":{mode:"flat",tiltAngle:0}};function pw(e,t){const n=dw[e];if(!n){const e=hw.small,n=void 0!==t?t:.2;return{base:e,min:e*(1-n),max:e*(1+n)}}const a=hw[n.class],i=void 0!==t?t:n.variance??.2;return{base:a,min:a*(1-i),max:a*(1+i)}}function mw(e){return uw[e]||{mode:"outward",tiltAngle:.2}}function fw(e,t,n=1,a){const i=pw(e,a);return(i.min+Math.random()*(i.max-i.min))*t*n}const gw={vec3_a:new Gt,vec3_b:new Gt,vec3_c:new Gt,vec3_d:new Gt,vec3_e:new Gt,vec3_f:new Gt,vec3_g:new Gt,quat_a:new Ut,quat_b:new Ut,matrix_a:new Vn,cameraDir:new Gt};function yw(e,t,n=0,a=null,i=null,r=null){const s=gw.vec3_a.set(0,1,0),o=gw.vec3_b,l=gw.vec3_c,c=gw.vec3_d,h=gw.quat_a,d=gw.quat_b,u=t?mw(t):{mode:"outward",tiltAngle:.2},p=Math.random()*Math.PI*2;switch(Math.abs(e.y)<.999?o.crossVectors(s,e).normalize():o.set(1,0,0).cross(e).normalize(),l.crossVectors(e,o).normalize(),c.copy(o).multiplyScalar(Math.cos(p)).addScaledVector(l,Math.sin(p)),h.identity(),u.mode){case"flat":{const t=gw.matrix_a,n=gw.vec3_e.crossVectors(c,e).normalize();t.makeBasis(c,e,n),h.setFromRotationMatrix(t),0!==u.tiltAngle&&(d.setFromAxisAngle(c,u.tiltAngle),h.premultiply(d))}break;case"tangent":{const t=.3,n=gw.vec3_e.copy(e).multiplyScalar(t).addScaledVector(c,1-t).normalize();if(h.setFromUnitVectors(s,n),0!==u.tiltAngle){const t=gw.vec3_f.crossVectors(c,e).normalize();d.setFromAxisAngle(t,u.tiltAngle),h.premultiply(d)}}break;case"rising":case"falling":{const t=u.riseFactor??.7,n="falling"===u.mode?-(u.fallFactor??.7):t,a=gw.vec3_e;if(n>=0)a.copy(e).multiplyScalar(1-n).add(gw.vec3_f.set(0,n,0)).normalize();else{const t=Math.abs(n);a.copy(e).multiplyScalar(1-t).add(gw.vec3_f.set(0,-t,0)).normalize()}h.setFromUnitVectors(s,a),0!==u.tiltAngle&&(d.setFromAxisAngle(c,u.tiltAngle),h.premultiply(d)),d.setFromAxisAngle(a,p),h.premultiply(d);break}case"outward-flat":{const t=gw.vec3_e.copy(e),n=gw.matrix_a,a=gw.vec3_f.copy(c),i=gw.vec3_g.crossVectors(a,t).normalize(),r=gw.vec3_f.crossVectors(t,i).normalize();n.makeBasis(i,r,t),h.setFromRotationMatrix(n),0!==u.tiltAngle&&(d.setFromAxisAngle(i,u.tiltAngle),h.premultiply(d));break}case"velocity":if(r&&r.x*r.x+r.y*r.y+r.z*r.z>1e-4){const e=gw.vec3_e.set(r.x,r.y,r.z).normalize();h.setFromUnitVectors(s,e)}else{const t=gw.vec3_f.set(0,-1,0),n=.5,a=gw.vec3_e.copy(e).multiplyScalar(1-n).addScaledVector(t,n).normalize();h.setFromUnitVectors(s,a)}0!==u.tiltAngle&&(d.setFromAxisAngle(c,u.tiltAngle),h.premultiply(d));break;default:h.setFromUnitVectors(s,e),0!==u.tiltAngle&&(d.setFromAxisAngle(c,u.tiltAngle),h.premultiply(d)),d.setFromAxisAngle(e,p),h.premultiply(d)}if(n>0&&a&&i&&"outward"===u.mode){const e=gw.cameraDir.copy(a.position).sub(i).normalize();d.setFromUnitVectors(s,e),h.slerp(d,n)}return h}function vw(e,t,n,a=.2){const i=(1-a)*n*.4-a*n*.3,r=e.clone(),s=t.clone().multiplyScalar(i);return r.add(s),{position:r,offset:i}}const bw="waiting",ww="entering",xw="holding",Sw="exiting",Mw="dead";class _w{constructor(e,t=0,n=null){this.config=e,this.index=t,this.elementConfig=e.createElementConfig(t),n&&Object.assign(this.elementConfig,n),this.state=bw,this.progress=0,this.birthTime=0,this.stateStartTime=0,this.enterCompleteTime=0,this.exitStartTime=0,this.respawnCount=0,this.isDead=!1,this.opacity=0,this.scale=0,this.emissive=1,this.fadeProgress=0,this.holdTime=0,this.pulsePhase=0,this.flickerValue=1,this.driftOffset={x:0,y:0,z:0},this.rotationOffset={x:0,y:0,z:0},this.currentBeat=0,this.lastBeatTriggered=-1,this.waitingForBeat=!1,this.gestureProgress=0}setBeat(e,t=120){this.currentBeat=e,this.bpm=t;const{appearOnBeat:n}=this.config.timing;null!==n&&this.state===bw&&e>=n&&this.lastBeatTriggered<n&&(this.waitingForBeat=!1,this.lastBeatTriggered=e)}initialize(e){this.birthTime=e,this.stateStartTime=e,this.state=bw,this.progress=0,this.opacity=0,this.scale=0,this.respawnCount=0,this.isDead=!1,"local"===this.config.hold.pulse?.sync&&(this.pulsePhase=.2*this.index),this._fireEvent("onSpawn")}update(e,t,n=null){if(this.isDead)return!1;null!==n&&(this.gestureProgress=n);const a=this._getAppearTime(n),i=this._getDisappearTime(n),r=this._getCurrentTime(e,n);switch(this.state){case bw:this._updateWaiting(r,a,e);break;case ww:this._updateEntering(e,t,r,i);break;case xw:this._updateHolding(e,t,r,i);break;case Sw:this._updateExiting(e,t);break;case Mw:return this._handleDead()}return!this.isDead}_getCurrentTime(e,t){return"progress"===this.config.timing.mode&&null!==t?t:1e3*(e-this.birthTime)}_getAppearTime(e){const{appearOnBeat:t}=this.config.timing;if(null!==t){if(this.currentBeat<t)return this.waitingForBeat=!0,1/0;this.waitingForBeat=!1}const n=this.config.getAppearTime(),a=this.config.getStaggerOffset(this.index),i=this.elementConfig.delayOffset||0;return"progress"===this.config.timing.mode?n+a+i:n+a+i*this.config.gestureDuration}_getDisappearTime(e){const t=this.config.getDisappearTime(),n=this.elementConfig.lifetimeMultiplier||1;if("progress"===this.config.timing.mode){const e=t-this.config.timing.appearAt;return this.config.timing.appearAt+e*n}return t*n}_updateWaiting(e,t,n){e>=t&&(this._transitionTo(ww,n),this._fireEvent("onEnterStart")),this.opacity=0,this.scale=0}_updateEntering(e,t,n,a){const{enter:i}=this.config,r="progress"===this.config.timing.mode?i.duration*this.config.gestureDuration/1e3:i.durationMs/1e3,s=e-this.stateStartTime;this.progress=Math.min(s/r,1);const o=i.easing(this.progress);this._applyEnterAnimation(o),this._applyRotation(e,t),this.progress>=1&&(this.enterCompleteTime=e,this._transitionTo(xw),this._fireEvent("onEnterComplete"),this.opacity=this.elementConfig.opacity,this.scale=this.elementConfig.scale),n>=a&&this.state===ww&&(this._transitionTo(Sw),this._fireEvent("onExitStart"))}_applyEnterAnimation(e){const{enter:t}=this.config,n=this.elementConfig.opacity,a=this.elementConfig.scale;switch(this.fadeProgress=e,t.type){case"fade":this.opacity=e*n,this.scale=a;break;case"flash":if(e<.5){const t=2*e;this.opacity=t*n*2,this.emissive=1+1.5*t}else{const t=2*(e-.5);this.opacity=n*(2-t),this.emissive=2.5-1.5*t}this.scale=a;break;case"grow":{const i=t.scale,r=i[0]*a,s=i[1]*a;this.scale=r+e*(s-r),this.opacity=n;break}case"pop":{const{overshoot:i}=t;if(e<.7){const t=e/.7;this.scale=t*a*i}else{const t=(e-.7)/.3,n=this.config.enter.easing(t);this.scale=a*(i-(i-1)*n)}this.opacity=n;break}default:this.opacity=n,this.scale=a}}_updateHolding(e,t,n,a){this.holdTime+=t,this._applyHoldAnimations(e,t),n>=a&&(this.exitStartTime=e,this._transitionTo(Sw),this._fireEvent("onExitStart"))}_applyHoldAnimations(e,t){const{hold:n}=this.config,a=this.elementConfig.opacity,i=this.elementConfig.scale;this.fadeProgress=1;let r=1,s=1;if(n.pulse){const t=n.pulse,a=(e+this.pulsePhase)*t.frequency*Math.PI*2;s*=1+Math.sin(a)*t.amplitude}if(n.flicker){const a=n.flicker;switch(a.pattern){case"sine":{const t=e*a.rate*Math.PI*2;this.flickerValue=1+Math.sin(t)*a.intensity;break}case"square":{const t=e*a.rate%1;this.flickerValue=t<.5?1+a.intensity:1-a.intensity;break}default:Math.random()<a.rate*t&&(this.flickerValue=1+(2*Math.random()-1)*a.intensity)}r*=this.flickerValue}if(n.emissive){const t=n.emissive;switch(t.pattern){case"sine":{const n=e*t.frequency*Math.PI*2,a=(Math.sin(n)+1)/2;this.emissive=t.min+a*(t.max-t.min);break}case"sawtooth":{const n=e*t.frequency%1;this.emissive=t.min+n*(t.max-t.min);break}case"pulse":{const n=e*t.frequency%1;this.emissive=n<t.dutyCycle?t.max:t.min;break}default:this.emissive=(t.min+t.max)/2}}if(n.drift){const e=n.drift,a=e.gestureDuration/1e3,i=e.distance/a*t,r=e.noise>0?(Math.random()-.5)*e.noise*i:0,s=e.noise>0?(Math.random()-.5)*e.noise*i:0,o=e.noise>0?(Math.random()-.5)*e.noise*i:0;switch(e.direction){case"outward":this.driftOffset.x+=(this.driftOffset.x||.001)>0?i+r:-i+r,this.driftOffset.y+=(this.driftOffset.y||.001)>0?i+s:-i+s,this.driftOffset.z+=(this.driftOffset.z||.001)>0?i+o:-i+o;break;case"outward-flat":this.driftOffset.x+=(this.driftOffset.x||.001)>0?i+r:-i+r,this.driftOffset.z+=(this.driftOffset.z||.001)>0?i+o:-i+o;break;case"inward":this.driftOffset.x-=(this.driftOffset.x||.001)>0?i:-i,this.driftOffset.y-=(this.driftOffset.y||.001)>0?i:-i,this.driftOffset.z-=(this.driftOffset.z||.001)>0?i:-i;break;case"up":this.driftOffset.y+=i+s;break;case"down":this.driftOffset.y-=i+s;break;case"tangent":this.driftOffset.x+=i+r,this.driftOffset.z+=o;break;case"random":this.driftOffset.x+=(Math.random()-.5)*i*2,this.driftOffset.y+=(Math.random()-.5)*i*2,this.driftOffset.z+=(Math.random()-.5)*i*2}const l=Math.sqrt(this.driftOffset.x**2+this.driftOffset.y**2+this.driftOffset.z**2);if(l>e.distance)if(e.bounce){const t=e.distance/l;this.driftOffset.x*=-t,this.driftOffset.y*=-t,this.driftOffset.z*=-t}else{const t=e.distance/l;this.driftOffset.x*=t,this.driftOffset.y*=t,this.driftOffset.z*=t}}this._applyRotation(e,t),this.opacity=a*r,this.scale=i*s}_applyRotation(e,t){const{hold:n}=this.config;if(!n.rotate)return;const a=n.rotate,i=a.elements[this.index%a.elements.length],{axis:r,rotations:s,phase:o,oscillate:l,range:c}=i,h=(o||0)*Math.PI/180;if(l){const t=e*(i.speed||a.speed||.1)*2,n=Math.sin(t);this.rotationOffset.x=r[0]*n*c,this.rotationOffset.y=r[1]*n*c,this.rotationOffset.z=r[2]*n*c}else if(null!=s){const e=this.gestureProgress*s*Math.PI*2+h;this.rotationOffset.x=r[0]*e,this.rotationOffset.y=r[1]*e,this.rotationOffset.z=r[2]*e}else{const e=(i.speed||a.speed||.1)*t;this.rotationOffset.x+=r[0]*e,this.rotationOffset.y+=r[1]*e,this.rotationOffset.z+=r[2]*e}}_updateExiting(e,t){const{exit:n}=this.config,a="progress"===this.config.timing.mode?n.duration*this.config.gestureDuration/1e3:n.durationMs/1e3,i=e-this.exitStartTime;this.progress=Math.min(i/a,1);const r=n.easing(this.progress);this._applyExitAnimation(r),this._applyRotation(e,t),this.progress>=1&&(this._transitionTo(Mw),this._fireEvent("onExitComplete"))}_applyExitAnimation(e){const{exit:t}=this.config,n=this.elementConfig.opacity,a=this.elementConfig.scale;switch(this.fadeProgress=1-e,t.type){case"fade":this.opacity=(1-e)*n;break;case"flash":if(e<.3){const t=e/.3;this.opacity=n*(1+t),this.emissive=1+2*t}else{const t=(e-.3)/.7;this.opacity=2*n*(1-t),this.emissive=3*(1-t)}break;case"shrink":{const i=t.scale,r=i[0]*a,s=i[1]*a;this.scale=r+e*(s-r),this.opacity=n;break}case"pop":if(e<.2)this.scale=a*(1+.5*e);else{const t=(e-.2)/.8;this.scale=1.1*a*(1-t)}this.opacity=n*(1-.5*e);break;default:e>=1&&(this.opacity=0,this.scale=0)}}_handleDead(){const{lifecycle:e}=this.config;if(e.respawn){const{maxRespawns:t}=e;if(-1===t||this.respawnCount<t){this.respawnCount++,this._fireEvent("onRespawn",this.respawnCount),this.state=bw,this.progress=0;const t=e.respawnDelay>0?e.respawnDelay:e.respawnDelayMs/1e3;return this.birthTime=this.stateStartTime+t,!0}}return this.isDead=!0,!1}_transitionTo(e,t=null){this.state=e,e===ww&&null!==t?this.stateStartTime=t:e===Sw&&this.exitStartTime>0&&(this.stateStartTime=this.exitStartTime),this.progress=0}_fireEvent(e,...t){const n=this.config.events[e];if("function"==typeof n)try{n(this.getElementInfo(),this.index,...t)}catch(t){console.warn(`[AnimationState] Error in ${e} callback:`,t)}}getElementInfo(){return{state:this.state,progress:this.progress,opacity:this.opacity,scale:this.scale,emissive:this.emissive,driftOffset:{...this.driftOffset},rotationOffset:{...this.rotationOffset},respawnCount:this.respawnCount,config:this.config}}triggerExit(e=null){this.state!==Sw&&this.state!==Mw&&(null!==e&&0===this.exitStartTime&&(this.exitStartTime=e),this._transitionTo(Sw),this._fireEvent("onExitStart"))}kill(){this.isDead=!0,this.state=Mw,this.opacity=0,this.scale=0}}const Aw={type:"fade",duration:.05,durationMs:50,easing:"easeOut",scale:[0,1],overshoot:1.2},Cw={type:"fade",duration:.15,durationMs:150,easing:"easeIn",scale:[1,0]},Tw={base:1,variance:0},Pw={base:1,variance:0},Dw={axis:"y",speed:.1,rotations:null,phase:0,oscillate:!1,range:Math.PI/4,easing:"linear"},Ow="bell";class Ew{constructor(e={},t=1e3){this.gestureDuration=t,this.raw=e,this.timing=this._parseTiming(e),this.enter=this._parseEnter(e.enter),this.exit=this._parseExit(e.exit),this.hold=this._parseHold(e),this.variance=this._parseVariance(e),this.appearance=this._parseAppearance(e),this.rendering=this._parseRendering(e),this.lifecycle=this._parseLifecycle(e),this.events=this._parseEvents(e),this.intensityScaling=this._parseIntensityScaling(e.intensityScaling),this.procedural=this._parseProcedural(e),this.parameterAnimation=this._parseParameterAnimation(e.parameterAnimation||e.temperature),this.modelOverrides=e.modelOverrides||null,this._intensity=1}getConfigForModel(e){return this.modelOverrides&&this.modelOverrides[e]?this.modelOverrides[e]:null}_parseIntensityScaling(e={}){return{scale:e.scale??1,count:e.count??1,lifetime:e.lifetime??1,enterDuration:e.enterDuration??1,exitDuration:e.exitDuration??1,pulseAmplitude:e.pulseAmplitude??1,flickerIntensity:e.flickerIntensity??1,emissiveMax:e.emissiveMax??1,driftSpeed:e.driftSpeed??1,rotateSpeed:e.rotateSpeed??1}}setIntensity(e){this._intensity=Math.max(0,Math.min(1,e))}getIntensity(){return this._intensity}getScaledValue(e,t){return t*(1+((this.intensityScaling[e]??1)-1)*this._intensity)}_parseTiming(e){return{appearAt:e.appearAt??0,disappearAt:e.disappearAt??1,delayMs:e.delayMs??0,lifetimeMs:e.lifetimeMs??null,stagger:e.stagger??0,staggerMs:e.staggerMs??0,appearOnBeat:e.appearOnBeat??null,mode:this._determineTimingMode(e)}}_determineTimingMode(e){return void 0!==e.appearAt||void 0!==e.disappearAt?"progress":void 0!==e.delayMs||void 0!==e.lifetimeMs?"ms":"progress"}_parseEnter(e={}){const t=Aw;return{type:e.type??t.type,duration:e.duration??t.duration,durationMs:e.durationMs??t.durationMs,easing:Av(e.easing??t.easing),easingName:e.easing??t.easing,scale:e.scale??t.scale,overshoot:e.overshoot??t.overshoot}}_parseExit(e={}){const t=Cw;return{type:e.type??t.type,duration:e.duration??t.duration,durationMs:e.durationMs??t.durationMs,easing:Av(e.easing??t.easing),easingName:e.easing??t.easing,scale:e.scale??t.scale}}_parseHold(e){return{pulse:e.pulse?this._parsePulse(e.pulse):null,flicker:e.flicker?this._parseFlicker(e.flicker):null,drift:e.drift?this._parseDrift(e.drift):null,rotate:e.rotate?this._parseRotate(e.rotate):null,emissive:e.emissive?this._parseEmissive(e.emissive):null}}_parsePulse(e){return{amplitude:e.amplitude??.1,frequency:e.frequency??2,easing:Av(e.easing??"easeInOut"),sync:e.sync??"global"}}_parseFlicker(e){return{intensity:e.intensity??.2,rate:e.rate??10,pattern:e.pattern??"random",seed:e.seed??null}}_parseDrift(e){return{direction:e.direction??"outward",distance:e.distance??.1,speed:e.speed??.02,maxDistance:e.maxDistance??1,gestureDuration:this.gestureDuration,bounce:e.bounce??false,noise:e.noise??0}}_parseRotate(e){if(Array.isArray(e)){const t=e.map(e=>this._parseRotateElement(e));return{isPerElement:!0,elements:t,oscillate:t[0]?.oscillate??Dw.oscillate,range:t[0]?.range??Dw.range,easing:t[0]?.easing??Av(Dw.easing)}}const t=this._parseRotateElement(e);return{isPerElement:!1,elements:[t],...t}}_parseRotateElement(e){let t=e.axis??Dw.axis;return"string"==typeof t&&(t="x"===t?[1,0,0]:"y"===t?[0,1,0]:"z"===t?[0,0,1]:[0,1,0]),{axis:t,speed:e.speed??Dw.speed,rotations:e.rotations??Dw.rotations,phase:e.phase??Dw.phase,oscillate:e.oscillate??Dw.oscillate,range:e.range??Dw.range,easing:Av(e.easing??Dw.easing)}}_parseEmissive(e){return{min:e.min??.5,max:e.max??1.5,frequency:e.frequency??1,pattern:e.pattern??"sine",dutyCycle:e.dutyCycle??.5}}_parseVariance(e){return{scale:e.scaleVariance??0,lifetime:e.lifetimeVariance??0,color:e.colorVariance??0,delay:e.delayVariance??0}}_parseAppearance(e){return{color:e.color?{tint:e.color.tint??null,multiply:e.color.multiply??!0,variance:e.color.variance??0}:null,opacity:e.opacity?{base:e.opacity.base??Tw.base,variance:e.opacity.variance??Tw.variance}:{...Tw},scale:e.scale?{base:e.scale.base??Pw.base,variance:e.scale.variance??Pw.variance}:{...Pw}}}_parseRendering(e){return{renderOrder:e.renderOrder??0,depthTest:e.depthTest??true,depthWrite:e.depthWrite??false,blending:e.blending??"normal",trail:e.trail?this._parseTrail(e.trail):null}}_parseTrail(e){return{count:e.count??3,fadeRate:e.fadeRate??.3,spacing:e.spacing??.05,inheritRotation:e.inheritRotation??!0}}_parseLifecycle(e){return{respawn:e.respawn??false,respawnDelay:e.respawnDelay??0,respawnDelayMs:e.respawnDelayMs??0,maxRespawns:e.maxRespawns??-1}}_parseEvents(e){return{onSpawn:e.onSpawn??null,onEnterStart:e.onEnterStart??null,onEnterComplete:e.onEnterComplete??null,onExitStart:e.onExitStart??null,onExitComplete:e.onExitComplete??null,onRespawn:e.onRespawn??null}}_parseProcedural(e){if(!e.procedural&&void 0===e.scaleSmoothing&&void 0===e.geometryStability)return null;const t=e.procedural||{};return{geometryStability:t.geometryStability??e.geometryStability??true,scaleSmoothing:t.scaleSmoothing??e.scaleSmoothing??0,shaderBindings:t.shaderBindings??null}}_parseParameterAnimation(e){if(!e)return null;if(void 0!==e.start||void 0!==e.peak)return{primary:{start:e.start??0,peak:e.peak??1,end:e.end??0,curve:e.curve??Ow}};const t={};for(const[n,a]of Object.entries(e))"object"==typeof a&&null!==a&&(t[n]={start:a.start??0,peak:a.peak??1,end:a.end??0,curve:a.curve??Ow});return Object.keys(t).length>0?t:null}progressToMs(e){return e*this.gestureDuration}msToProgress(e){return e/this.gestureDuration}getAppearTime(e="auto"){return"ms"===("auto"===e?this.timing.mode:e)?this.timing.delayMs>0?this.timing.delayMs:this.progressToMs(this.timing.appearAt):this.timing.appearAt}getDisappearTime(e="auto"){const t="auto"===e?this.timing.mode:e;return"ms"===t&&null!==this.timing.lifetimeMs?this.timing.delayMs+this.timing.lifetimeMs:"ms"===t?this.progressToMs(this.timing.disappearAt):this.timing.disappearAt}getStaggerOffset(e,t="auto"){return"ms"===("auto"===t?this.timing.mode:t)?this.timing.staggerMs>0?e*this.timing.staggerMs:e*this.progressToMs(this.timing.stagger):e*this.timing.stagger}applyVariance(e,t){if(0===t)return e;const n=e*t;return e+(2*Math.random()-1)*n}createElementConfig(e,t=null){return{index:e,appearOffset:this.getStaggerOffset(e),scale:this.applyVariance(this.appearance.scale.base,this.variance.scale),opacity:this.applyVariance(this.appearance.opacity.base,this.appearance.opacity.variance),lifetimeMultiplier:1+(2*Math.random()-1)*this.variance.lifetime,delayOffset:this.applyVariance(0,this.variance.delay)}}mergeWithElement(e){if(!e)return this;const t={...this.raw,...e,enter:{...this.raw.enter,...e.enter},exit:{...this.raw.exit,...e.exit}};return new Ew(t,this.gestureDuration)}}function Iw(e,t,n){const a=Math.max(0,Math.min(1,(n-e)/(t-e)));return a*a*(3-2*a)}function kw(e,t){if(!e)return null;const n=Object.keys(e);return 0===n.length?null:function(e,t){if(!e)return 0;const{start:n,peak:a,end:i,curve:r}=e;switch(r){case"bell":default:return t<=.5?n+(a-n)*Iw(0,.5,t):a+(i-a)*Iw(.5,1,t);case"spike":return t<=.25?n+(a-n)*Iw(0,.25,t):a+(i-a)*Iw(.25,1,t);case"sustained":return t<=.15?n+(a-n)*Iw(0,.15,t):t>=.85?a+(i-a)*Iw(.85,1,t):a;case"fadeOut":return a+(i-a)*Iw(0,1,t);case"linear":return t<=.5?n+2*t*(a-n):a+2*(t-.5)*(i-a)}}(e[n[0]],t)}function Rw(e){return e?{type:e.type||"stack",count:e.count||1,spacing:e.spacing||.15,arcOffset:(e.arcOffset||60)*Math.PI/180,phaseOffset:e.phaseOffset||0,strands:e.strands||1,centered:e.centered||!1,scales:e.scales||null,positions:e.positions||null,radius:e.radius||.4,meshRotationOffset:e.meshRotationOffset?e.meshRotationOffset*Math.PI/180:0,zOffset:e.zOffset||0}:null}function zw(e){return{horizontal:"flat",upright:"vertical",billboard:"camera"}[e]||e||"flat"}const Fw={linear:e=>e,splash:e=>1-Math.pow(1-e,3),surge:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,burst:e=>1-Math.pow(1-e,4),settle:e=>e<.3?e*e*3.33:e<.7?.3+1.75*(e-.3):.7+.3*(1-Math.pow(1-(e-.7)/.3,2))};function Bw(e,t=0){const n=e.landmarkY+e.offset.y;let{x:a}=e.offset,i=n,{z:r}=e.offset;if(e.bob&&(i=n+Math.sin(t*e.bob.frequency*Math.PI*2)*e.bob.amplitude),e.wander){const n=e.wander;a+=Math.sin(t*n.speedX*Math.PI*2)*n.radius,r+=Math.cos(t*n.speedZ*Math.PI*2)*n.radius}return{x:a,y:i,z:r,baseY:n}}function Lw(e){switch(e){case"flat":return{x:Math.PI/2,y:0,z:0};case"vertical":case"camera":default:return{x:0,y:0,z:0};case"radial":return{x:Math.PI/4,y:0,z:0}}}function Nw(e){return e?{type:e.type||"ring",count:e.count||4,pairSpacing:(e.pairSpacing||180)*Math.PI/180,startAngle:(e.startAngle||0)*Math.PI/180}:null}function Vw(e,t,n,a=1,i=null){const{angle:r}=t,s=i?i(n):n,o=(e.radius+(e.endRadius-e.radius)*s)*a,l=e.height*a,c=l+(e.endHeight*a-l)*s,h=r+n*e.speed*Math.PI*2,d=Math.cos(h)*o,u=Math.sin(h)*o;return{x:d,y:c+(t.heightOffset||0),z:u,angle:h,scale:e.startScale+(e.endScale-e.startScale)*s}}function Uw(e,t,n){const a=Av(e.easing)(n),i=e.startRadius+(e.endRadius-e.startRadius)*a;return{x:e.offset.x+t.x*i,y:e.landmarkY+e.offset.y+t.y*i,z:e.offset.z+t.z*i,scale:e.startScale+(e.endScale-e.startScale)*a}}function Gw(e,t,n){const a=function(e,t,n="xz"){if("xz"===n){const n=e/t*Math.PI*2;return{x:Math.cos(n),y:0,z:Math.sin(n)}}{const n=Math.acos(1-2*(e+.5)/t),a=Math.PI*(1+Math.sqrt(5))*e;return{x:Math.sin(n)*Math.cos(a),y:Math.cos(n),z:Math.sin(n)*Math.sin(a)}}}(t,e.count,e.plane),i=Uw(e,a,0);return{position:{x:i.x*n,y:i.y,z:i.z*n},rotation:{x:0,y:0,z:0,w:1},scaleMultiplier:i.scale,modeData:{radialBurst:{config:e,direction:a}}}}function Ww(e,t,n){const{config:a,direction:i}=e.radialBurst,r=Uw(a,i,t);return{position:{x:r.x*n,y:r.y,z:r.z*n},scaleMultiplier:r.scale}}const qw=1.5,Hw={position:new Gt,quaternion:new Ut,quaternion2:new Ut,scale:new Gt(1,1,1),euler:new Qn,direction:new Gt,axis:new Gt,up:new Gt(0,1,0)};class jw{constructor(e={}){const{scene:t,coreMesh:n=null,camera:a=null,assetsBasePath:i="",renderer:r=null}=e;if(!t)throw new Error("[ElementInstancedSpawner] Scene is required");this.scene=t,this.coreMesh=n,this.camera=a,this.assetsBasePath=i,this._renderer=r,this.container=new Di,this.container.name="ElementInstancedSpawner",this.scene.add(this.container),this.spatialRef=new lw,n&&this.spatialRef.initialize(n),this.pools=new Map,this.geometryCache=new Map,this.loader=new db,this.mergedGeometries=new Map,this.materials=new Map,this.activeElements=new Map,this.time=0,this._nextId=0,this._initialized=new Set,this._initializing=new Map,this._poolLastUsed=new Map,this._modelGeometryDiameters=new Map,this._poolCleanupInterval=3e4,this._lastCleanupCheck=0,this._parameterAnimations=new Map}get mascotRadius(){return this.spatialRef.radius||1}initialize(e,t){this.coreMesh=e,this.camera=t,e&&this.spatialRef.initialize(e)}async preloadModels(e){ow.get(e)&&await this.initializePool(e)}hasElements(e){for(const t of this.activeElements.values())if(t.type===e)return!0;return!1}async initializePool(e){if(this._initialized.has(e))return this.pools.get(e);if(this._initializing.has(e))return this._initializing.get(e);const t=this._doInitializePool(e);this._initializing.set(e,t);try{const n=await t;return this._initialized.add(e),n}finally{this._initializing.delete(e)}}async _doInitializePool(e){const t=ow.get(e);if(!t)return console.warn(`[ElementInstancedSpawner] Unknown element type: ${e}`),null;const n=t.models.map(e=>{const n=`${this.assetsBasePath}/${t.basePath}${e}`;return this._loadGeometry(n).then(t=>t?{geometry:t,name:e.replace(".glb","")}:null)}),a=(await Promise.all(n)).filter(e=>null!==e);if(0===a.length)return console.error(`[ElementInstancedSpawner] No models loaded for ${e}`),null;const i=new rw;for(const{geometry:e,name:t}of a)i.addGeometry(e,t);const{geometry:r,modelMap:s}=i.build();i.dispose(),this.mergedGeometries.set(e,{geometry:r,modelMap:s});const o=t.createMaterial();this.materials.set(e,o),o.userData._originalDepthWrite=o.depthWrite;const l=new iw(r,o,48);if(this.pools.set(e,l),this.container.add(l.mesh),this._renderer&&o.userData.needsRefraction&&this._renderer.addRefractionMesh(l.mesh),this._renderer?.motionBlurPass&&this._renderer.motionBlurPass.addInstancedMesh(l.mesh),this._distortionManager&&t.distortion&&!this._distortionManager.hasElement(e)){const n=t.distortion;this._distortionManager.registerElement(e,{geometry:n.geometry(),material:n.material(),transform:n.transform,billboard:n.billboard,strength:n.strength})}return l}async _loadGeometry(e){if(this.geometryCache.has(e))return this.geometryCache.get(e);if(e.includes("void-orb.glb")){const t=new to(.5,4);return this.geometryCache.set(e,t),t}if(e.includes("void-disk.glb")){const t=new es(.5,32);return this.geometryCache.set(e,t),t}if(e.includes("light-ray.glb")){const t=new As;t.moveTo(0,.6),t.lineTo(.12,0),t.lineTo(0,-.6),t.lineTo(-.12,0),t.closePath();const n=new ro(t);return this.geometryCache.set(e,n),n}if(e.includes("light-orb.glb")){const t=new to(.4,3);return this.geometryCache.set(e,t),t}try{const t=await new Promise((t,n)=>{this.loader.load(e,t,void 0,n)});let n=null;return t.scene.traverse(e=>{!n&&e.isMesh&&({geometry:n}=e)}),n?(e.includes("void-ring")&&n.rotateX(-Math.PI/2),this.geometryCache.set(e,n),n):(console.warn(`[ElementInstancedSpawner] No mesh found in ${e}`),null)}catch(t){return console.error(`[ElementInstancedSpawner] Failed to load ${e}:`,t),null}}async spawn(e,t={}){const{count:n=8,mode:a="orbit",intensity:i=1,models:r=null,camera:s=null,animation:o=null,gestureDuration:l=1e3}=t;if(Array.isArray(a)){const t=await this.initializePool(e);if(!t)return[];this._poolLastUsed.set(e,performance.now()),this.despawn(e);const n=ow.get(e),r=this.materials.get(e);let o,c;n?.resetCutout&&r&&n.resetCutout(r),n?.resetGrain&&r&&n.resetGrain(r),n?.resetFlash&&r&&n.resetFlash(r),n?.resetRelay&&r&&n.resetRelay(r),n?.resetWetness&&r&&n.resetWetness(r),n?.resetShaderAnimation&&r&&n.resetShaderAnimation(r),r?.uniforms?.uDiskMode&&(r.uniforms.uDiskMode.value=0),r&&(delete r.userData.gestureGlow,r.uniforms?.uGlowScale&&(r.uniforms.uGlowScale.value=1)),this._particleAtmospherics&&this._particleAtmospherics.forceStopGesture(e),this._parameterAnimations.delete(e);for(const e of a){const t=e.animation?.renderOrder;void 0!==t&&(void 0===o||t<o)&&(o=t),void 0!==e.animation?.depthWrite&&(c=e.animation.depthWrite)}void 0!==o&&(t.mesh.renderOrder=o),r&&(void 0!==c?r.depthWrite=c:void 0!==r.userData._originalDepthWrite&&(r.depthWrite=r.userData._originalDepthWrite));const h=[];for(let t=0;t<a.length;t++){const n=a[t],r=await this._spawnLayer(e,n,{layerIndex:t,camera:s,gestureDuration:l,intensity:i});h.push(...r)}return h}const c=o?new Ew(o,l):null,h=await this.initializePool(e);if(!h)return[];this._poolLastUsed.set(e,performance.now()),void 0!==c?.rendering?.renderOrder&&(h.mesh.renderOrder=c.rendering.renderOrder),this.despawn(e);const d=ow.get(e),u=this.materials.get(e);if(u&&(o&&void 0!==o.depthWrite?u.depthWrite=o.depthWrite:void 0!==u.userData._originalDepthWrite&&(u.depthWrite=u.userData._originalDepthWrite)),d?.resetCutout&&u&&d.resetCutout(u),d?.resetGrain&&u&&d.resetGrain(u),d?.resetFlash&&u&&d.resetFlash(u),d?.resetRelay&&u&&d.resetRelay(u),d?.resetWetness&&u&&d.resetWetness(u),d?.resetShaderAnimation&&u&&d.resetShaderAnimation(u),u?.uniforms?.uDiskMode&&(u.uniforms.uDiskMode.value=0),u&&(delete u.userData.gestureGlow,u.uniforms?.uGlowScale&&(u.uniforms.uGlowScale.value=1)),this._particleAtmospherics&&this._particleAtmospherics.forceStopGesture(e),this._parameterAnimations.delete(e),!this.mergedGeometries.get(e))return[];const p="object"==typeof a?a.type||"surface":a;return"axis-travel"===p?this._spawnAxisTravel(e,a,r,c,s):"anchor"===p?this._spawnAnchor(e,a,r,c,s):"radial-burst"===p?this._spawnRadialBurst(e,a,r,c):"orbit"===p?this._spawnOrbit(e,a,r,c,s):"surface"===p?this._spawnSurface(e,a,n,r,c,s):(console.warn(`[ElementInstancedSpawner] Unknown spawn mode: ${p}, falling back to orbit`),this._spawnOrbitFallback(e,n,r,c,s))}_spawnOrbitFallback(e,t,n,a,i){const r=this._getSpawnContext(e);if(!r)return[];const{pool:s,merged:o,config:l}=r,c=[],h=Math.min(t,s.availableSlots),d=n||Array.from(o.modelMap.keys());for(let t=0;t<h;t++){const n=d[Math.floor(Math.random()*d.length)],i=this._resolveModelIndex(o,n)??0,r=l?.scaleMultiplier||qw,u=fw(n,this.mascotRadius,r);Hw.scale.setScalar(u);const p=this._generateSpawnPosition("orbit",t,h),m=this._generateSpawnRotation("orbit",p),f=`${e}_${this._nextId++}`;if(s.spawn(f,p,m,Hw.scale,i)){const r=this._initAnimState(s,f,a,t);r&&s.updateInstanceTransform(f,p,m,u*r.scale),this.activeElements.set(f,{type:e,modelName:n,modelIndex:i,spawnTime:this.time,basePosition:p.clone(),position:p.clone(),rotation:m.clone(),baseScale:u,scale:u,animState:r}),c.push(f)}}return c}_generateSpawnPosition(e,t,n){const a=Hw.position,i=1.5*this.mascotRadius;switch(e){case"orbit":{const e=t/n*Math.PI*2,r=(Math.random()-.5)*this.mascotRadius;a.set(Math.cos(e)*i,r,Math.sin(e)*i);break}case"crown":{const e=t/n*Math.PI*2;a.set(Math.cos(e)*i*.6,.8*this.mascotRadius,Math.sin(e)*i*.6);break}case"scattered":case"scatter":{const e=Math.random()*Math.PI*2,t=Math.acos(2*Math.random()-1);a.set(Math.sin(t)*Math.cos(e)*i,Math.sin(t)*Math.sin(e)*i,Math.cos(t)*i);break}default:return this._generateSpawnPosition("orbit",t,n)}return a.clone()}_generateSpawnRotation(e,t){const n=Hw.quaternion;return Hw.euler.set(Math.random()*Math.PI*2,Math.random()*Math.PI*2,Math.random()*Math.PI*2),n.setFromEuler(Hw.euler),n.clone()}_parseAxisTravelConfig(e){return function(e,t){const n=e.axisTravel||{},a=e.formation||null,i=n.startOffset??0,r=n.endOffset??0,s=n.orientation??n.ringOrientation,o=n.speedCurve||"linear",l=Fw[o]||Fw.linear;return{axis:n.axis||"y",startPos:t(n.start??"bottom")+i,endPos:t(n.end??"top")+r,easing:Av(n.easing||"easeInOut"),speedCurve:l,startScale:n.startScale??1,endScale:n.endScale??1,startDiameter:n.startDiameter??1,endDiameter:n.endDiameter??1,diameterUnit:n.diameterUnit||null,uniformDiameter:n.uniformDiameter||!1,reverseAt:n.reverseAt??null,holdAt:n.holdAt??null,orientation:zw(s),verticalEdgeAlign:!1!==n.verticalEdgeAlign,formation:Rw(a),count:e.count||1,models:e.models||[],scale:e.scale??1}}(e,e=>this.spatialRef.resolveLandmark(e))}_getModelGeometryDiameter(e,t){if(this._modelGeometryDiameters.has(e))return this._modelGeometryDiameters.get(e);let n=2;for(const[t,a]of this.geometryCache.entries())if(t.includes(`${e}.glb`)||t.includes(`/${e}`)){a.boundingSphere||a.computeBoundingSphere(),n=2*a.boundingSphere.radius;break}return this._modelGeometryDiameters.set(e,n),n}_computeMascotDiameterFactor(e,t,n){return 2/(this._getModelGeometryDiameter(e,t)*pw(e).base*n)}_expandFormation(e){return function(e){const{formation:t}=e;if(!t)return[{index:0,positionOffset:{x:0,y:0,z:0},rotationOffset:0,meshRotationOffset:0,progressOffset:0,scaleMultiplier:1}];const n=[],a=(t.count-1)*t.spacing,i=t.centered?-a/2:0;for(let e=0;e<t.count;e++){const a={index:e,positionOffset:{x:0,y:0,z:0},rotationOffset:0,meshRotationOffset:e*(t.meshRotationOffset||0),progressOffset:e*t.phaseOffset,scaleMultiplier:t.scales?.[e]??1};switch(t.type){case"stack":default:a.positionOffset={x:0,y:e*t.spacing+i,z:0};break;case"spiral":{const n=t.strands||1,r=e%n,s=Math.floor(e/n);a.positionOffset={x:0,y:s*t.spacing+i,z:0};const o=s*t.arcOffset,l=r/n*Math.PI*2;a.rotationOffset=o+l;break}case"wave":a.positionOffset={x:0,y:Math.sin(e/t.count*Math.PI)*t.spacing+i,z:0},a.progressOffset=e*(t.phaseOffset||.08);break;case"mandala":{const n=t.zOffset||0;if(0===e)a.positionOffset={x:0,y:0,z:n};else{const i=(e-1)/(t.count-1)*Math.PI*2,r=t.radius||.4;a.positionOffset={x:Math.sin(i)*r,y:Math.cos(i)*r,z:n}}a.rotationOffset=e*t.arcOffset;break}case"positioned":if(t.positions&&t.positions[e]){const n=t.positions[e];a.positionOffset={x:n.x||0,y:n.y||0,z:n.z||0}}a.rotationOffset=e*t.arcOffset}n.push(a)}return n}(e)}_calculateAxisTravelPosition(e,t,n){const a=function(e,t,n,a=1){let i=n;t?.progressOffset&&(i=Math.max(0,Math.min(1,i-t.progressOffset))),null!==e.holdAt&&e.holdAt>0&&(i=Math.min(i/e.holdAt,1));let r=i;null!==e.reverseAt&&i>e.reverseAt&&(r=1-(i-e.reverseAt)/(1-e.reverseAt)),e.speedCurve&&(r=e.speedCurve(r));const s=e.easing(r);let o=e.startPos+(e.endPos-e.startPos)*s;const l=e.startScale+(e.endScale-e.startScale)*s,c=e.startDiameter+(e.endDiameter-e.startDiameter)*s;"vertical"===e.orientation&&"y"===e.axis&&e.verticalEdgeAlign&&(o+=c*a*l*.25);const h=t?.positionOffset||{x:0,y:0,z:0},d="number"==typeof h?{x:0,y:h*a,z:0}:{x:(h.x||0)*a,y:(h.y||0)*a,z:(h.z||0)*a};return{axisPos:o,axis:e.axis,positionOffset:d,scale:l,diameter:c,rotationOffset:t?.rotationOffset||0,meshRotationOffset:t?.meshRotationOffset||0,scaleMultiplier:t?.scaleMultiplier??1}}(e,t,n,this.mascotRadius),i=a.positionOffset,r=Hw.position.set(0,0,0);switch(a.axis){case"y":r.y=a.axisPos;break;case"x":r.x=a.axisPos;break;case"z":r.z=a.axisPos}return r.x+=i.x||0,r.y+=i.y||0,r.z+=i.z||0,{position:r,scale:a.scale,diameter:a.diameter,rotationOffset:a.rotationOffset,scaleMultiplier:a.scaleMultiplier}}_getSpawnContext(e){const t=this.pools.get(e),n=this.mergedGeometries.get(e),a=ow.get(e);return t&&n?{pool:t,merged:n,config:a}:(console.warn(`[ElementInstancedSpawner] Pool or merged geometry not ready for ${e}`),null)}_resolveModelIndex(e,t){const n=e.modelMap.get(t);return void 0===n&&console.warn(`[ElementInstancedSpawner] Model ${t} not found in merged geometry`),n}_initAnimState(e,t,n,a){if(!n)return e.updateInstanceOpacity(t,1),null;const i=new _w(n,a);return i.initialize(this.time),e.updateInstanceOpacity(t,i.opacity),i}_applyShaderAnimationOverrides(e,t,n,a,i=null){const r=this.materials.get(e);if(r){if(n&&a?.setShaderAnimation)for(const e of t){const t=n[e];if(t?.shaderAnimation){a.setShaderAnimation(r,t.shaderAnimation);break}}if(n&&r?.uniforms?.uDiskMode)for(const e of t)if(n[e]?.diskMode){r.uniforms.uDiskMode.value=1;break}if(i?.gestureGlow&&a?.setGestureGlow&&a.setGestureGlow(r,i.gestureGlow),a?.setCutout&&void 0!==i?.cutout&&a.setCutout(r,i.cutout),a?.setGrain&&void 0!==i?.grain&&a.setGrain(r,i.grain),a?.setFlash&&void 0!==i?.flash&&a.setFlash(r,i.flash),a?.setWetness&&void 0!==i?.wetness&&a.setWetness(r,i.wetness),a?.setRelay&&void 0!==i?.relay&&a.setRelay(r,i.relay),i?.parameterAnimation){const t=new Ew({parameterAnimation:i.parameterAnimation});this._parameterAnimations.set(e,t.parameterAnimation)}this._particleAtmospherics&&i?.atmospherics&&this._particleAtmospherics.startGesture(e,i.atmospherics)}}_spawnLayer(e,t,n){const{layerIndex:a,camera:i,gestureDuration:r}=n,s=t.type||"surface",o=t.models||null,l=t.animation||{},c=new Ew(l,r),h=`layer${a}`;switch(s){case"axis-travel":return this._spawnAxisTravel(e,t,o,c,i,h);case"anchor":return this._spawnAnchor(e,t,o,c,i,h);case"radial-burst":return this._spawnRadialBurst(e,t,o,c,h);case"orbit":return this._spawnOrbit(e,t,o,c,i,h);case"surface":return this._spawnSurface(e,t,t.count||5,o,c,i,h);default:return console.warn(`[ElementInstancedSpawner] Unknown layer type: ${s}, skipping`),[]}}_spawnAxisTravel(e,t,n,a,i,r=null){const s=this._getSpawnContext(e);if(!s)return console.warn(`[ElementInstancedSpawner] _spawnAxisTravel: no context for ${e}`),[];const{pool:o,merged:l,config:c}=s,h=this._parseAxisTravelConfig(t),d=this._expandFormation(h),u=t.animation||{},p=u.modelOverrides||{};this._applyShaderAnimationOverrides(e,h.models,p,c,u);const m=[],f=h.models.length>0?h.models:n||Array.from(l.modelMap.keys());for(let t=0;t<d.length;t++){const n=d[t],i=f[t%f.length],r=this._resolveModelIndex(l,i);if(void 0===r)continue;const s=this._calculateAxisTravelPosition(h,n,0),{position:u}=s,g=h.scale||c?.scaleMultiplier||qw,y=fw(i,this.mascotRadius,g),v=s.scaleMultiplier??1,b=y*s.scale*v,w="mascot"===h.diameterUnit?this._computeMascotDiameterFactor(i,e,g):1,x=s.diameter*w;h.uniformDiameter?Hw.scale.setScalar(b*x):Hw.scale.set(b*x,b*x,b);const S=p[i]?.orientationOverride,M=S||h.orientation,_=mw(i),A=M||_.mode||"outward";let C,T=!1;switch(A){case"flat":C=Hw.quaternion.setFromAxisAngle(Hw.axis.set(1,0,0),Math.PI/2),T=!0;break;case"vertical":case"camera":C=Hw.quaternion.identity(),T=!0;break;case"radial":C=Hw.quaternion.setFromAxisAngle(Hw.axis.set(1,0,0),Math.PI/4),T=!0;break;default:C=this._generateSpawnRotation("orbit",u)}n.rotationOffset&&(Hw.quaternion2.setFromAxisAngle(Hw.up,n.rotationOffset),C=C.clone().premultiply(Hw.quaternion2)),n.meshRotationOffset&&(Hw.quaternion2.setFromAxisAngle(Hw.up,n.meshRotationOffset),C=C.clone().premultiply(Hw.quaternion2));const P=C.clone(),D=`${e}_${this._nextId++}`;if(o.spawn(D,u,C,Hw.scale,r)){const l=this._initAnimState(o,D,a,t);l&&o.updateInstanceTransform(D,u,C,b*l.scale),this.activeElements.set(D,{type:e,modelName:i,modelIndex:r,spawnTime:this.time,basePosition:u.clone(),position:u.clone(),rotation:C.clone(),baseScale:y,scale:b,animState:l,worldSpaceOrientation:T,baseWorldRotation:T?P:null,cameraOrientation:"camera"===A,axisTravel:{config:h,formationData:n,initialResult:s,diameterFactor:w,uniformDiameter:h.uniformDiameter||!1}}),m.push(D)}}return m}_spawnAnchor(e,t,n,a,i,r=null){const s=this._getSpawnContext(e);if(!s)return[];const{pool:o,merged:l,config:c}=s,h=function(e,t){const n=e.anchor||{};return{landmark:n.landmark||"head",landmarkY:t(n.landmark||"head"),offset:{x:n.offset?.x||0,y:n.offset?.y||0,z:n.offset?.z||0},orientation:zw(n.orientation)||"flat",bob:n.bob?{amplitude:n.bob.amplitude||.02,frequency:n.bob.frequency||.5}:null,wander:n.wander?{radius:n.wander.radius||.1,speedX:n.wander.speedX||.3,speedZ:n.wander.speedZ||.2}:null,cameraOffset:n.cameraOffset||0,relativeOffset:n.relativeOffset||!1,count:e.count||1,models:e.models||[],scale:e.scale??1,diameterUnit:e.diameterUnit||null,diameter:e.diameter??1,startScale:n.startScale??1,endScale:n.endScale??1,scaleEasing:n.scaleEasing||"easeOutExpo"}}(t,e=>this.spatialRef.resolveLandmark(e)),d=t.animation||{},u=d.modelOverrides||{};this._applyShaderAnimationOverrides(e,h.models,u,c,d);const p=[],m=h.models.length>0?h.models:n||Array.from(l.modelMap.keys());for(let n=0;n<h.count;n++){const i=m[n%m.length],r=this._resolveModelIndex(l,i);if(void 0===r)continue;const s=Bw(h,0);h.relativeOffset&&(s.x*=this.mascotRadius,s.y=h.landmarkY+h.offset.y*this.mascotRadius,s.z*=this.mascotRadius);const d=Hw.position.set(s.x,s.y,s.z).clone(),f=h.scale||c?.scaleMultiplier||qw,g=fw(i,this.mascotRadius,f,t.sizeVariance),y="mascot"===h.diameterUnit?this._computeMascotDiameterFactor(i,e,f):0;if(y){const e=(h.diameter||1)*y;Hw.scale.set(g*e,g*e,g)}else Hw.scale.setScalar(g);const v=u[i]?.orientationOverride||h.orientation;let b;if("camera"===v&&this.camera)b=this.camera.quaternion.clone();else{const e=Lw(v);Hw.euler.set(e.x,e.y,e.z),b=Hw.quaternion.setFromEuler(Hw.euler).clone()}const w=`${e}_${this._nextId++}`,x=u[i]?.arcPhase??null,S=u[i]?.relayIndex??null;if(o.spawn(w,d,b,Hw.scale,r,x,S)){const t=this._initAnimState(o,w,a,n);t&&o.updateInstanceTransform(w,d,b,g*t.scale),this.activeElements.set(w,{type:e,modelName:i,modelIndex:r,spawnTime:this.time,basePosition:d.clone(),position:d.clone(),rotation:b.clone(),baseScale:g,scale:g,animState:t,cameraOrientation:"camera"===v,cameraOffset:h.cameraOffset||0,worldSpaceOrientation:!0,baseWorldRotation:b.clone(),anchor:{config:h,baseY:s.baseY,diameterFactor:y||0,diameter:h.diameter||1,startScale:h.startScale,endScale:h.endScale,exitDuration:a?.exit?.duration??0}}),p.push(w)}}return p}_spawnRadialBurst(e,t,n,a,i=null){const r=this._getSpawnContext(e);if(!r)return[];const{pool:s,merged:o,config:l}=r,c=function(e,t){const n=e.burst||{};return{landmark:n.landmark||"center",landmarkY:t(n.landmark||"center"),offset:{x:n.offset?.x||0,y:n.offset?.y||0,z:n.offset?.z||0},startRadius:n.startRadius||.05,endRadius:n.endRadius||.5,plane:n.plane||"xz",easing:n.easing||"easeOutQuad",startScale:n.startScale??.8,endScale:n.endScale??1.2,count:e.count||5,models:e.models||[],scale:e.scale??1}}(t,e=>this.spatialRef.resolveLandmark(e)),h=t.radialBurst?.orientation||"vertical",d=t.animation||{},u=d.modelOverrides||{};this._applyShaderAnimationOverrides(e,c.models,u,l,d);const p=[],m=c.models.length>0?c.models:n||Array.from(o.modelMap.keys());for(let t=0;t<c.count;t++){const n=m[t%m.length],i=this._resolveModelIndex(o,n);if(void 0===i)continue;const r=Gw(c,t,this.mascotRadius),d=Hw.position.set(r.position.x,r.position.y,r.position.z).clone(),f=u[n]?.orientationOverride||h;let g;g="camera"===f&&this.camera?this.camera.quaternion.clone():Hw.quaternion.set(r.rotation.x,r.rotation.y,r.rotation.z,r.rotation.w).clone();const y=c.scale||l?.scaleMultiplier||qw,v=fw(n,this.mascotRadius,y),b=v*r.scaleMultiplier,w=`${e}_${this._nextId++}`;if(s.spawn(w,d,g,Hw.scale.setScalar(b),i)){const o=this._initAnimState(s,w,a,t);this.activeElements.set(w,{type:e,modelName:n,modelIndex:i,spawnTime:this.time,basePosition:d.clone(),position:d.clone(),rotation:g.clone(),baseScale:v,scale:b,animState:o,cameraOrientation:"camera"===f,worldSpaceOrientation:!0,baseWorldRotation:g.clone(),...r.modeData}),p.push(w)}}return p}_spawnOrbit(e,t,n,a,i,r=null){const s=this._getSpawnContext(e);if(!s)return[];const{pool:o,merged:l,config:c}=s,h=function(e,t){const n=e.orbit||{},a=e.formation||null;let i=0;"string"==typeof n.height?i=t(n.height):"number"==typeof n.height&&({height:i}=n);let r=i;void 0!==n.endHeight&&("string"==typeof n.endHeight?r=t(n.endHeight):"number"==typeof n.endHeight&&({endHeight:r}=n));const s=n.orientation??n.ringOrientation,o=n.radius??1.5;return{height:i,radius:o,endHeight:r,endRadius:n.endRadius??o,plane:n.plane||"horizontal",speed:n.speed??0,easing:n.easing||"linear",startScale:n.startScale??e.scale??1,endScale:n.endScale??n.startScale??e.scale??1,orientation:zw(s)||"vertical",formation:Nw(a),count:e.count||a?.count||4,models:e.models||[],scale:e.scale??1}}(t,e=>this.spatialRef.resolveLandmark(e)),d=function(e){const{formation:t,count:n}=e,a=[],i=t?.count||n;for(let e=0;e<i;e++){const n={index:e,angle:0,heightOffset:0,rotationOffset:0};switch(t?.type||"ring"){case"ring":n.angle=e/i*Math.PI*2+(t?.startAngle||0);break;case"pairs":{const a=e%2==1,r=Math.floor(e/2)/Math.ceil(i/2)*Math.PI*2;n.angle=a?r+(t?.pairSpacing||Math.PI):r;break}case"cluster":{const a=Math.PI/2;n.angle=e/i*a+(t?.startAngle||0);break}default:n.angle=e/i*Math.PI*2}a.push(n)}return a}(h),u=t.animation||{},p=u.modelOverrides||{};this._applyShaderAnimationOverrides(e,h.models,p,c,u);const m=[],f=h.models.length>0?h.models:n||Array.from(l.modelMap.keys());for(let t=0;t<d.length;t++){const n=d[t],i=f[t%f.length],r=this._resolveModelIndex(l,i);if(void 0===r)continue;const s=Vw(h,n,0,this.mascotRadius),u=Hw.position.set(s.x,s.y,s.z).clone(),g=h.scale||c?.scaleMultiplier||qw,y=fw(i,this.mascotRadius,g);Hw.scale.setScalar(y);const v=p[i]?.orientationOverride,b=v||h.orientation,w=mw(i);let x;const S=!0;switch(b||w.mode||"vertical"){case"flat":case"horizontal":x=Hw.quaternion.setFromAxisAngle(Hw.axis.set(1,0,0),Math.PI/2);break;case"vertical":Hw.euler.set(0,s.angle+Math.PI/2,0),x=Hw.quaternion.setFromEuler(Hw.euler);break;case"radial":x=Hw.quaternion.setFromAxisAngle(Hw.axis.set(1,0,0),Math.PI/4);break;default:x=Hw.quaternion.identity()}const M=x.clone(),_=`${e}_${this._nextId++}`;if(o.spawn(_,u,x,Hw.scale,r)){const l=this._initAnimState(o,_,a,t);l&&o.updateInstanceTransform(_,u,x,y*l.scale),this.activeElements.set(_,{type:e,modelName:i,modelIndex:r,spawnTime:this.time,basePosition:u.clone(),position:u.clone(),rotation:x.clone(),baseScale:y,scale:y,animState:l,worldSpaceOrientation:S,baseWorldRotation:M,orbit:{config:h,formationData:n,angle:s.angle}}),m.push(_)}}return m}_spawnSurface(e,t,n,a,i,r,s=null){const o=this._getSpawnContext(e);if(!o)return[];const{pool:l,merged:c,config:h}=o,d=function(e){if("string"==typeof e)return{pattern:"shell",embedDepth:.2,cameraFacing:.3,clustering:0,countOverride:null,scaleMultiplier:1.5,minDistanceFactor:.18,ephemeral:null,models:[]};const t=e.surface||e;return{pattern:t.pattern||"shell",embedDepth:t.embedDepth??.2,cameraFacing:t.cameraFacing??.3,clustering:t.clustering??0,countOverride:t.count||e.count||null,scaleMultiplier:t.scale||e.scale||1.5,minDistanceFactor:t.minDistance??.18,ephemeral:t.ephemeral||null,models:e.models||[]}}(t),u=t.animation||{},p=u.modelOverrides||{};if(this._applyShaderAnimationOverrides(e,d.models,p,h,u),!this.coreMesh?.geometry)return console.warn("[ElementInstancedSpawner] Surface mode requested but no coreMesh geometry available"),[];const m=function(e,t,n,a={},i=null,r=null){const{pattern:s="scattered",clustering:o=0,minDistanceFactor:l=.15}=a,c=n*l,h=e.attributes.position,d=e.attributes.normal,u=h.count,p=[],{cameraDir:m}=gw;i?m.set(0,0,-1).applyQuaternion(i.quaternion):m.set(0,0,1);const f=gw.vec3_a,g=gw.vec3_b,y=gw.vec3_c;for(let e=0;e<u;e++){f.set(h.getX(e),h.getY(e),h.getZ(e)),d?g.set(d.getX(e),d.getY(e),d.getZ(e)).normalize():g.set(0,1,0);let t=1;switch(s){case"crown":t=2*Math.max(0,f.y)+.5*Math.max(0,g.y);break;case"shell":t=.5+.5*Math.max(0,g.dot(m));break;case"scattered":t=.3+.7*Math.max(0,g.dot(m));break;case"spikes":y.copy(f).normalize(),t=1.5*Math.max(0,g.dot(y));break;case"ring":{const e=1-Math.abs(g.y),n=1-2*Math.abs(f.y);t=.5*e+.5*Math.max(0,n);break}default:t=1}const n=g.dot(m);n>0&&(t*=1+.3*n),t>.01&&p.push({position:f.clone(),normal:g.clone(),weight:t,index:e})}p.sort((e,t)=>t.weight-e.weight);const v=[],b=new Set,w=[];if(o>0&&t>2){const e=Math.max(1,Math.floor(t*(1-o)*.5));for(let t=0;t<e&&p.length>0;t++){const e=Math.floor(Math.random()*Math.min(p.length,10));w.push(p[e].position.clone())}}const x=(e,t)=>{for(const n of v)if(e.distanceTo(n.position)<t)return!1;return!0};let S=0,M=c;for(let e=0;e<t&&p.length>0;e++){let t=null,n=0;const a=30;for(;!t&&n<a;){let a;if(n++,o>0&&w.length>0){const t=w[e%w.length];let n=1/0,i=-1;for(let e=0;e<Math.min(p.length,50);e++){if(b.has(p[e].index))continue;const a=p[e].position;if(!x(a,M))continue;const r=a.distanceTo(t)/(p[e].weight+.1);r<n&&(n=r,i=e)}a=i}else{const e=Math.min(p.length,Math.max(20,.4*p.length)),t=[];for(let n=0;n<e;n++)b.has(p[n].index)||x(p[n].position,M)&&t.push({idx:n,weight:p[n].weight});if(t.length>0){const e=t.reduce((e,t)=>e+t.weight,0);let n=Math.random()*e;a=t[0].idx;for(const e of t)if(n-=e.weight,n<=0){a=e.idx;break}}else a=-1}a>=0?(t=p[a],b.add(t.index),S=0):(S++,S>=20&&(M*=.5,S=0))}if(t){const e=t.position.clone();r&&e.multiply(r),v.push({position:e,normal:t.normal.clone(),weight:t.weight})}}return v}(this.coreMesh.geometry,n,this.mascotRadius,d,r||this.camera,null);if(0===m.length)return console.warn("[ElementInstancedSpawner] No surface points sampled"),[];const f=[],g=d.models.length>0?d.models:a||Array.from(c.modelMap.keys()),y=Math.min(d.countOverride||n,l.availableSlots,m.length);for(let t=0;t<y;t++){const n=m[t],a=g[Math.floor(Math.random()*g.length)],s=this._resolveModelIndex(c,a);if(void 0===s)continue;const o=d.scaleMultiplier||h?.scaleMultiplier||qw,u=fw(a,this.mascotRadius,o);Hw.scale.setScalar(u);const p=d.embedDepth??.2,y=vw(n.position,n.normal,u,p),{position:v}=y,b=d.cameraFacing??.3,w=yw(n.normal,a,b,r||this.camera,v,null).clone(),x=`${e}_${this._nextId++}`;if(l.spawn(x,v,w,Hw.scale,s)){const r=this._initAnimState(l,x,i,t);r&&l.updateInstanceTransform(x,v,w,u*r.scale),this.activeElements.set(x,{type:e,modelName:a,modelIndex:s,spawnTime:this.time,basePosition:v.clone(),position:v.clone(),rotation:w.clone(),baseScale:u,scale:u,animState:r,surface:{config:d,normal:n.normal.clone(),embedDepth:p}}),f.push(x)}}return f}triggerExit(e=null){if(this._particleAtmospherics)if(e)this._particleAtmospherics.stopGesture(e);else for(const[e]of this.pools)this._particleAtmospherics.stopGesture(e);for(const[t,n]of this.activeElements)if(!e||n.type===e)if(n.animState)n.animState.triggerExit(this.time);else{const e=this.pools.get(n.type);e&&e.beginDespawn(t)}}despawn(e=null,t=!0){const n=e?[e]:Array.from(this.pools.keys());for(const e of n){const n=this.pools.get(e);if(!n)continue;const a=[];for(const[t,n]of this.activeElements)n.type===e&&a.push(t);for(const e of a)t?n.beginDespawn(e):n.removeImmediate(e),this.activeElements.delete(e)}}despawnAll(){this.despawn(null,!1)}update(e,t=null){if(0===this.activeElements.size&&0===this.pools.size)return void(this._renderer?.motionBlurPass&&(this._renderer.motionBlurPass.enabled=!1));if(this.time+=e,0===this.activeElements.size){if(this._distortionManager)for(const[e,t]of this.pools)this._distortionManager.syncInstances(e,t.mesh,t.mesh.count);if(this._particleAtmospherics)for(const[e]of this.pools)this._particleAtmospherics.syncSources(e,this.activeElements,this.container);return this._renderer?.motionBlurPass&&(this._renderer.motionBlurPass.enabled=!1),void this._checkPoolCleanup()}if(this._renderer?.motionBlurPass){const e=window.innerWidth<=1e3;this._renderer.motionBlurPass.enabled=!e}if(this.coreMesh){this.container.position.copy(this.coreMesh.position);let e=!1;for(const t of this.activeElements.values())if(t.worldSpaceOrientation){e=!0;break}e?this.container.quaternion.identity():this.container.quaternion.copy(this.coreMesh.quaternion),this.container.scale.copy(this.coreMesh.scale)}for(const[e,n]of this.pools){n.setTime(this.time);const a=ow.get(e),i=this.materials.get(e);a?.updateMaterial&&i&&a.updateMaterial(i,this.time,t??1)}const n=[];for(const[a,i]of this.activeElements){const{animState:r,type:s,basePosition:o,baseScale:l,rotation:c}=i;if(!r)continue;if(!r.update(this.time,e,t)){n.push(a);continue}const h=this.pools.get(s);if(!h)continue;if(r.state===bw){h.updateInstanceOpacity(a,0);continue}const{axisTravel:d}=i;let u,p;const m=ow.get(s),f=null!=m?.createMaterial;if(d){const e=t??1,n=this._calculateAxisTravelPosition(d.config,d.formationData,e);u=n.position;const a=n.scaleMultiplier??1,s=r.state===ww?r.fadeProgress:1,o=l*n.scale*a*s,c=n.diameter*(d.diameterFactor||1);d.uniformDiameter?Hw.scale.setScalar(o*c):Hw.scale.set(o*c,o*c,o),p=o,i.basePosition.copy(u)}else if(i.anchor){const e=Bw(i.anchor.config,this.time);if(Hw.position.set(e.x,e.y,e.z),i.cameraOrientation&&this.camera){const t=Hw.direction.set(1,0,0).applyQuaternion(this.camera.quaternion);t.y=0,t.normalize();const n=Hw.axis.set(0,0,-1).applyQuaternion(this.camera.quaternion);n.y=0,n.normalize();const a=e.x,i=e.z;Hw.position.x=a*t.x+i*n.x,Hw.position.z=a*t.z+i*n.z}u=Hw.position;const n=r.elementConfig?.appearAt??0,a=(r.elementConfig?.disappearAt??1)+(i.anchor.exitDuration??0)-n,s=null!==t&&a>0?Math.max(0,Math.min(1,(t-n)/a)):0,{startScale:o,endScale:c,config:h}=i.anchor,d=o+(c-o)*Av(h?.scaleEasing||"easeOutExpo")(s);if(p=o!==c?l*d:f?l*d*r.fadeProgress:l*d*r.scale,i.anchor.diameterFactor){const e=i.anchor.diameter*i.anchor.diameterFactor;Hw.scale.set(p*e,p*e,p)}}else if(i.radialBurst){const e=r.elementConfig?.appearAt??0,n=(r.elementConfig?.disappearAt??1)-e,a=n>0?Math.max(0,Math.min(1,(t-e)/n)):t,s=Ww({radialBurst:i.radialBurst},a,this.mascotRadius);Hw.position.set(s.position.x,s.position.y,s.position.z),u=Hw.position,p=f?l*s.scaleMultiplier*r.fadeProgress:l*s.scaleMultiplier*r.scale}else if(i.orbit&&0!==i.orbit.config.speed){const e=t??1,n=i.orbit.config,a=r.elementConfig?.appearAt??0,s=(r.elementConfig?.disappearAt??1)-a,o=s>0?Math.max(0,Math.min(1,(e-a)/s)):e,c=Av(n.easing||"linear"),h=Vw(n,i.orbit.formationData,o,this.mascotRadius,c);Hw.position.set(h.x,h.y,h.z),u=Hw.position;const d=h.scale??1;p=f?l*d*r.fadeProgress:l*d*r.scale,i.basePosition.copy(u)}else{const e=r.driftOffset;Hw.position.set(o.x+e.x,o.y+e.y,o.z+e.z),u=Hw.position,p=f?l*r.fadeProgress:l*r.scale}i.position.copy(u),i.scale=p;const g=r.rotationOffset;if(i.cameraOrientation&&this.camera){Hw.quaternion.copy(this.camera.quaternion),"wave-curl"===i.modelName&&(Hw.quaternion2.setFromAxisAngle(Hw.axis.set(1,0,0),Math.PI/2),Hw.quaternion.multiply(Hw.quaternion2));const e=i.axisTravel?.formationData?.rotationOffset||0;0!==e&&(Hw.quaternion2.setFromAxisAngle(Hw.axis.set(0,0,1),e),Hw.quaternion.multiply(Hw.quaternion2)),i.cameraOffset&&(Hw.direction.set(0,0,1).applyQuaternion(this.camera.quaternion),u.addScaledVector(Hw.direction,i.cameraOffset*this.mascotRadius))}else i.worldSpaceOrientation&&i.baseWorldRotation?Hw.quaternion.copy(i.baseWorldRotation):Hw.quaternion.copy(c);0===g.x&&0===g.y&&0===g.z||(Hw.euler.set(g.x,g.y,g.z),Hw.quaternion2.setFromEuler(Hw.euler),Hw.quaternion.multiply(Hw.quaternion2)),d||i.anchor&&i.anchor.diameterFactor?h.updateInstanceTransform(a,u,Hw.quaternion,Hw.scale):h.updateInstanceTransform(a,u,Hw.quaternion,p);const y=f?r.fadeProgress:r.opacity;h.updateInstanceOpacity(a,y)}for(const e of n){const t=this.activeElements.get(e);if(t){const n=this.pools.get(t.type);n&&n.removeImmediate(e),this.activeElements.delete(e)}}if(this._distortionManager){for(const[e,t]of this.pools)this._distortionManager.syncInstances(e,t.mesh,t.mesh.count);let e=0;for(const[,t]of this.activeElements)"void"===t.type&&t.animState&&t.animState.fadeProgress>e&&(e=t.animState.fadeProgress);this._distortionManager.setVoidFade(e)}if(this._particleAtmospherics){const e=new Set;for(const[,t]of this.activeElements)e.add(t.type);for(const n of e){this._particleAtmospherics.syncSources(n,this.activeElements,this.container),this._particleAtmospherics.setGestureProgress(n,t);const e=this._parameterAnimations.get(n);if(e&&null!==t){const a=kw(e,t);null!==a&&this._particleAtmospherics.setEnergy(n,a)}}}}setDistortionManager(e){this._distortionManager=e}setParticleAtmospherics(e){this._particleAtmospherics=e}setCoreMesh(e){this.coreMesh=e,e&&this.spatialRef.initialize(e)}setCamera(e){this.camera=e}getStats(){const e={activeElements:this.activeElements.size,poolStats:{}};for(const[t,n]of this.pools)e.poolStats[t]=n.getStats();return e}_checkPoolCleanup(){const e=performance.now();if(!(e-this._lastCleanupCheck<1e3)){this._lastCleanupCheck=e;for(const[t,n]of this.pools)if(e-(this._poolLastUsed.get(t)||0)>this._poolCleanupInterval){this._renderer&&n.mesh?.material?.userData?.needsRefraction&&this._renderer.removeRefractionMesh(n.mesh),this._renderer?.motionBlurPass&&this._renderer.motionBlurPass.removeInstancedMesh(n.mesh),n.dispose(),this.pools.delete(t),this._poolLastUsed.delete(t);const e=this.materials.get(t);e&&(e.dispose(),this.materials.delete(t)),this._initialized.delete(t)}}}setElementBloomThreshold(e,t){const n=this.materials.get(e),a=ow.get(e);n&&a?.setBloomThreshold&&a.setBloomThreshold(n,t)}dispose(){this.despawnAll();for(const e of this.pools.values())this._renderer&&e.mesh?.material?.userData?.needsRefraction&&this._renderer.removeRefractionMesh(e.mesh),this._renderer?.motionBlurPass&&this._renderer.motionBlurPass.removeInstancedMesh(e.mesh),e.dispose();this.pools.clear();for(const e of this.materials.values())e.dispose();this.materials.clear();for(const{geometry:e}of this.mergedGeometries.values())e.dispose();this.mergedGeometries.clear();for(const e of this.geometryCache.values())e.dispose();this.geometryCache.clear(),this.container.parent&&this.container.parent.remove(this.container),this._initialized.clear(),this.activeElements.clear(),this._poolLastUsed.clear()}}class Xw{constructor(){this.enabled=!1,this.sections=new Map,this.frameCount=0,this.frameStartTime=0,this.totalFrameTime=0,this._startTimes=new Map,this._reportInterval=60,this._gl=null,this._gpuSyncEnabled=!1,this._frameTimestamps=[],this._maxTimestamps=120}setGL(e){this._gl=e}enableGPUSync(){this._gpuSyncEnabled=!0,console.log("[PerformanceProfiler] GPU sync enabled - this will impact performance!")}disableGPUSync(){this._gpuSyncEnabled=!1,console.log("[PerformanceProfiler] GPU sync disabled")}enable(){this.enabled=!0,this.reset(),console.log("[PerformanceProfiler] Enabled - collecting data..."),console.log("[PerformanceProfiler] TIP: Run profiler.enableGPUSync() for accurate GPU timing (will slow things down)")}disable(){this.enabled=!1,console.log("[PerformanceProfiler] Disabled")}reset(){this.sections.clear(),this.frameCount=0,this.totalFrameTime=0,this._frameTimestamps=[]}startFrame(){this.enabled&&(this.frameStartTime=performance.now())}start(e){this.enabled&&this._startTimes.set(e,performance.now())}end(e){if(!this.enabled)return;this._gpuSyncEnabled&&this._gl&&"threeRenderer"===e&&this._gl.finish();const t=this._startTimes.get(e);if(void 0===t)return;const n=performance.now()-t;this.sections.has(e)||this.sections.set(e,{total:0,count:0,max:0,min:1/0});const a=this.sections.get(e);a.total+=n,a.count++,a.max=Math.max(a.max,n),a.min=Math.min(a.min,n)}endFrame(){if(!this.enabled)return;const e=performance.now(),t=e-this.frameStartTime;this.totalFrameTime+=t,this.frameCount++,this._frameTimestamps.push(e),this._frameTimestamps.length>this._maxTimestamps&&this._frameTimestamps.shift(),this.frameCount%this._reportInterval===0&&console.log(this.getReport())}getActualFPS(){if(this._frameTimestamps.length<2)return 0;const e=this._frameTimestamps[0],t=this._frameTimestamps[this._frameTimestamps.length-1]-e;return 0===t?0:(this._frameTimestamps.length-1)/t*1e3}getReport(){if(0===this.frameCount)return"No frames recorded";const e=this.totalFrameTime/this.frameCount,t=1e3/e,n=this.getActualFPS();let a=`\n=== Performance Report (${this.frameCount} frames) ===\n`;a+=`Average Frame Time: ${e.toFixed(2)}ms\n`,a+=`Theoretical Max FPS: ${t.toFixed(1)} (if no GPU bottleneck)\n`,a+=`Actual FPS: ${n.toFixed(1)} (real measured rate)\n`,this._gpuSyncEnabled?a+="GPU Sync: ENABLED (accurate GPU timing)\n":a+="GPU Sync: disabled (CPU time only - run profiler.enableGPUSync() for GPU timing)\n",a+="\nSection Breakdown:\n";const i=[...this.sections.entries()].sort((e,t)=>t[1].total-e[1].total);for(const[e,t]of i){const n=t.total/t.count,i=(t.total/this.totalFrameTime*100).toFixed(1);a+=`  ${e.padEnd(30)} avg: ${n.toFixed(2)}ms  min: ${t.min.toFixed(2)}ms  max: ${t.max.toFixed(2)}ms  (${i}%)\n`}let r=0;for(const[,e]of this.sections)r+=e.total;const s=this.totalFrameTime-r,o=(s/this.totalFrameTime*100).toFixed(1);return a+=`  ${"(unaccounted)".padEnd(30)} total: ${s.toFixed(2)}ms  (${o}%)\n`,a+="\n--- Analysis ---\n",n<.5*t?(a+=` GPU BOTTLENECK DETECTED: Actual FPS (${n.toFixed(0)}) << Theoretical (${t.toFixed(0)})\n`,a+="   The GPU cannot keep up with draw calls. Likely causes:\n",a+="   - Bloom post-processing (13 render passes)\n",a+="   - Complex shader (SSS crystal material)\n",a+="   - High resolution / pixel fill rate\n"):a+=" No obvious GPU bottleneck detected\n",a}setRenderer(e){this._renderer=e}diagnose(){let e="\n=== RENDER PIPELINE DIAGNOSTICS ===\n\n";if(this._gl){const t=this._gl.getExtension("WEBGL_debug_renderer_info");if(t){const n=this._gl.getParameter(t.UNMASKED_VENDOR_WEBGL);e+=`GPU: ${this._gl.getParameter(t.UNMASKED_RENDERER_WEBGL)}\n`,e+=`Vendor: ${n}\n`}else e+="GPU: (debug info not available)\n";const n=this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),a=this._gl.getParameter(this._gl.MAX_VIEWPORT_DIMS),i=[this._gl.drawingBufferWidth,this._gl.drawingBufferHeight];e+=`Max Texture Size: ${n}\n`,e+=`Max Viewport: ${a[0]}x${a[1]}\n`,e+=`Drawing Buffer: ${i[0]}x${i[1]}\n`}if(this._renderer){if(e+="\n--- Bloom Passes ---\n",this._renderer.bloomPass){const t=this._renderer.bloomPass;e+="Main Bloom:\n",e+=`  resolution: ${t.resolution?.x}x${t.resolution?.y}\n`,e+=`  nMips: ${t.nMips}\n`,t.renderTargetBright&&(e+=`  renderTargetBright: ${t.renderTargetBright.width}x${t.renderTargetBright.height}\n`),t.renderTargetsHorizontal?.[0]&&(e+=`  mip0: ${t.renderTargetsHorizontal[0].width}x${t.renderTargetsHorizontal[0].height}\n`)}else e+="Main Bloom: NOT FOUND\n";if(this._renderer.particleBloomPass){const t=this._renderer.particleBloomPass;e+="Particle Bloom:\n",e+=`  resolution: ${t.resolution?.x}x${t.resolution?.y}\n`,t.renderTargetBright&&(e+=`  renderTargetBright: ${t.renderTargetBright.width}x${t.renderTargetBright.height}\n`)}else e+="Particle Bloom: NOT FOUND\n";if(e+="\n--- Render Targets ---\n",this._renderer.particleRenderTarget){const t=this._renderer.particleRenderTarget;e+=`Particle RT: ${t.width}x${t.height}\n`}if(this._renderer.soulRenderTarget){const t=this._renderer.soulRenderTarget;e+=`Soul RT: ${t.width}x${t.height}\n`}if(this._renderer.composer){const t=this._renderer.composer;e+="\n--- Composer ---\n",e+=`Passes: ${t.passes?.length||"unknown"}\n`,t.readBuffer&&(e+=`Read Buffer: ${t.readBuffer.width}x${t.readBuffer.height}\n`)}}else e+="\nRenderer not available - call profiler.setRenderer(mascot.renderer)\n";e+="\n--- Frame Rate Analysis ---\n";const t=this.getActualFPS();return e+=`Current FPS: ${t.toFixed(1)}\n`,t>0&&t<35&&t>25&&(e+=" FPS is suspiciously close to 30 - possible causes:\n",e+="   - Browser V-Sync to 30fps (power saving mode?)\n",e+="   - Windows display scaling issues\n",e+="   - GPU running on integrated graphics instead of dedicated\n",e+="   - requestAnimationFrame throttling\n",e+="\nTry:\n",e+="   1. Check chrome://gpu for GPU status\n",e+="   2. Disable battery saver / power saving mode\n",e+="   3. Force Chrome to use dedicated GPU in Windows settings\n"),console.log(e),e}testBypassBloom(){this._renderer?.bloomPass?(this._renderer.bloomPass.enabled=!1,this._renderer.particleBloomPass&&(this._renderer.particleBloomPass.enabled=!1),console.log("[Profiler] Bloom DISABLED - check FPS now"),console.log("[Profiler] Run profiler.restoreBloom() to re-enable")):console.log("Renderer not available")}restoreBloom(){this._renderer?.bloomPass?(this._renderer.bloomPass.enabled=!0,this._renderer.particleBloomPass&&(this._renderer.particleBloomPass.enabled=!0),console.log("[Profiler] Bloom RESTORED")):console.log("Renderer not available")}testBypassComposer(){this._renderer?(this._savedComposer=this._renderer.composer,this._renderer.composer=null,console.log("[Profiler] Composer BYPASSED - direct render mode (no bloom, no effects)"),console.log("[Profiler] Check FPS now. Run profiler.restoreComposer() to restore")):console.log("Renderer not available")}restoreComposer(){this._renderer&&this._savedComposer?(this._renderer.composer=this._savedComposer,this._savedComposer=null,console.log("[Profiler] Composer RESTORED")):console.log("No saved composer to restore")}}const Yw=new Xw,$w=["fire","ice","water","earth","nature","electricity","void","light"];class Qw{constructor(e,t={}){if(!e)throw new Error("Core3DManager: canvas element is required");if(!(e instanceof HTMLCanvasElement))throw new Error("Core3DManager: canvas must be an HTMLCanvasElement");if(void 0===td)throw new Error("Core3DManager: Three.js library is not loaded. Import three.js before using Core3DManager");this._instanceId=Math.random().toString(36).substr(2,6),this.canvas=e,this.options=t,this._destroyed=!1,this._ready=!1,this._readyPromise=null,this.assetBasePath=void 0!==t.assetBasePath?t.assetBasePath:"",this.enableShatter=!1!==t.enableShatter,this._preloadElements=t.preloadElements||[],this._backgroundPrewarm=!1!==t.backgroundPrewarm,this._prewarmTimeoutId=null,this.geometryType=t.geometry||"sphere";const n="moon"===this.geometryType;this.renderer=new Zd(e,{enablePostProcessing:!1!==t.enablePostProcessing,enableShadows:t.enableShadows||!1,enableControls:!1!==t.enableControls,autoRotate:!n&&!1!==t.autoRotate,autoRotateSpeed:t.autoRotateSpeed,cameraDistance:t.cameraDistance,fov:t.fov,minZoom:t.minZoom,maxZoom:t.maxZoom,assetBasePath:this.assetBasePath}),Yw.setGL(this.renderer.renderer.getContext()),Yw.setRenderer(this.renderer),this.renderer.onContextRestored=()=>this._handleContextRestored();const a=Hu[this.geometryType];a?this.geometryConfig=a:(console.warn(`Unknown geometry: ${this.geometryType}, falling back to sphere`),this.geometryConfig=Hu.sphere),this.geometry=this.geometryConfig.geometry,this.geometry&&!this.geometry.isGroup&&(this.geometry.userData.geometryType=this.geometryType),this.materialVariant=t.materialVariant||null,this.onMaterialSwap=null;let i=null;const r=np(this.emotion),s=this.geometryType,o=qy(this.geometryType,this.geometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:r,assetBasePath:this.assetBasePath,onTextureReady:e=>{this.shatterSystem&&this.renderer?.coreMesh&&this.shatterSystem.precomputeShards(this.renderer.coreMesh,s)}});if(o&&(i=o.material,this.customMaterial=i,this.customMaterialType=o.type),this.geometryConfig.geometryLoader?this._readyPromise=this._loadAsyncGeometry():(this._ready=!0,this._readyPromise=Promise.resolve()),null===this.geometry&&this.geometryConfig.geometryLoader?this._deferredMeshCreation=!0:(this.coreMesh=this.renderer.createCoreMesh(this.geometry,i),"crystal"===this.customMaterialType&&this.createCrystalInnerCore()),this.calibrationRotation=[0,0,0],this.cameraRoll=0,"moon"===this.geometryType){const e=Math.PI/180;this.calibrationRotation=[vu*e,bu*e,wu*e],this.cameraRoll=0}if("crystal"===this.geometryType||"rough"===this.geometryType||"heart"===this.geometryType||"star"===this.geometryType){const e=Math.PI/180;this.calibrationRotation=[0*e,30*e,0*e]}if(this.animator=new ju,this.gestureBlender=new Yu,this.animationManager=new Zy(this.animator,this.gestureBlender),this.effectManager=new Dv(this.renderer,this.assetBasePath),this.behaviorController=new Rv({rotationDisabled:!1===t.autoRotate,wobbleEnabled:!0,rhythmEngine:t.rhythmEngine||null,camera:this.renderer.camera}),this.breathingPhaseManager=new zv,this.breathingAnimator=new Xu,this.breathingEnabled=!1!==t.enableBreathing,this.geometryMorpher=new pp,this._postSwapHold=!1,this._postSwapHoldTime=0,this._postSwapFrameCount=0,this.blinkAnimator=new op(this.geometryConfig),this.blinkAnimator.setEmotion(this.emotion),this.blinkingManuallyDisabled=!1,!1===t.enableBlinking&&(this.blinkAnimator.pause(),this.blinkingManuallyDisabled=!0),this.rotationDisabled=!1===t.autoRotate,this.wobbleEnabled=!0,n&&xu.enabled){const e=Math.PI/180;this.behaviorController.configureForEmotion({geometryType:"moon",emotionData:null,facingConfig:{enabled:!0,strength:xu.strength,lockedFace:xu.lockedFace,lerpSpeed:xu.lerpSpeed,calibrationRotation:[vu*e,bu*e,wu*e]}})}this.emotion=t.emotion||"neutral",this.undertone=t.undertone||null,this.glowColor=[1,1,1],this.glowColorHex="#FFFFFF",this.glowIntensity=1,this._normalizedGlowColor=null,this.coreGlowEnabled=!0,this.glowIntensityOverride=null,this.intensityCalibrationOffset=0,this.baseEuler=[0,0,0],this.baseQuaternion=new Ut,this.gestureQuaternion=new Ut,this.tempEuler=new Qn,this.rotation=[0,0,0],this.baseScale=.16,this.scale=.16,this.position=[0,0,0],this.rhythmEngine=t.rhythmEngine||null,this.rhythm3DAdapter=up,this.rhythmEnabled=!1!==t.enableRhythm,this.rhythmEnabled&&(this.rhythm3DAdapter.initialize(),this.breathingAnimator.setRhythmAdapter(this.rhythm3DAdapter)),this.particlesEnabled=!1!==t.enableParticles,this.particleVisibility=this.particlesEnabled;const l=new by(50);l.canvasWidth=e.width,l.canvasHeight=e.height;const c=new wy({worldScale:2,baseRadius:1.5,depthScale:.75,verticalScale:1,coreRadius3D:2}),h=new Iy(150,{renderer:this.renderer.renderer}),d=h.getPoints();d.layers.set(1),this.renderer.scene.add(d),this.particleOrchestrator=new Fy(l,c,h),this.particleOrchestrator.setGeometryType(this.geometryType),this.particlesEnabled||h.geometry.setDrawRange(0,0);const u=this.geometry?.parameters?.radius||.5;this.effectManager.initializeForGeometry(this.geometryType,{coreMesh:this.coreMesh,customMaterial:this.customMaterial,sunRadius:u}),this.shatterSystem=null,this._pendingShatter=null,this.enableShatter&&(this.shatterSystem=new ob({scene:this.renderer.scene,maxShards:50,shardLifetime:2e3,enableReassembly:!0,autoRestore:!0}),this.shatterSystem.onShatterStart=()=>{},this.shatterSystem.onShatterComplete=()=>{this.crystalSoul&&this.crystalSoul.setVisible(this.coreGlowEnabled)},this.shatterSystem.onReassemblyComplete=()=>{this.crystalSoul&&this.crystalSoul.setVisible(this.coreGlowEnabled)},this.renderer?.coreMesh&&this.shatterSystem.precomputeShards(this.renderer.coreMesh,this.geometryType)),this.objectSpaceCrackManager=new lb,this.elementSpawner=new jw({scene:this.renderer.scene,assetsBasePath:this.assetBasePath,renderer:this.renderer}),this.renderer?.distortionManager&&this.elementSpawner.setDistortionManager(this.renderer.distortionManager),this.renderer?.particleAtmospherics&&this.elementSpawner.setParticleAtmospherics(this.renderer.particleAtmospherics),this.renderer?.coreMesh&&this.elementSpawner.initialize(this.renderer.coreMesh,this.renderer.camera),this.geometryConfig.defaultGlassMode&&!this.customMaterial&&this.setGlassMaterialEnabled(!0),this.setEmotion(this.emotion)}setEmotion(e,t=null){this.emotion=e,this.undertone=t;const n=np(e);if(n&&n.visual){if(n.visual.glowColor){let e=(a=(a=n.visual.glowColor).replace("#",""),[parseInt(a.substring(0,2),16)/255,parseInt(a.substring(2,4),16)/255,parseInt(a.substring(4,6),16)/255]);e=function(e,t){if(!t||"clear"===t||"none"===t)return e;const n={intense:{saturation:2.5,lightness:1.3},confident:{saturation:1.8,lightness:1.15},nervous:{saturation:1.6,lightness:1.1},tired:{saturation:.4,lightness:.65},subdued:{saturation:.25,lightness:.55}}[t];if(!n)return e;const a=function(e,t,n){const a=Math.max(e,t,n),i=Math.min(e,t,n),r=a-i,s=a+i;let o=0,l=0;const c=s/2;if(0!==r)switch(l=c>.5?r/(2-s):r/s,a){case e:o=((t-n)/r+(t<n?6:0))/6;break;case t:o=((n-e)/r+2)/6;break;case n:o=((e-t)/r+4)/6}return[360*o,100*l,100*c]}(e[0],e[1],e[2]);return a[1]=Math.min(100,a[1]*n.saturation),a[2]=Math.min(100,Math.max(0,a[2]*n.lightness)),function(e,t,n){let a,i,r;if(e/=360,n/=100,0==(t/=100))a=i=r=n;else{const s=(e,t,n)=>(n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+(t-e)*(2/3-n)*6:e),o=n<.5?n*(1+t):n+t-n*t,l=2*n-o;a=s(l,o,e+1/3),i=s(l,o,e),r=s(l,o,e-1/3)}return[a,i,r]}(a[0],a[1],a[2])}(e,t),this.glowColor=e,this.glowColorHex=n.visual.glowColor;const i=function(e,t=.5){const[n,a,i]=e,r=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4),s=r(n),o=r(a),l=r(i),c=.2126*s+.7152*o+.0722*l,h=t/Math.max(c,.001);let d=s*h,u=o*h,p=l*h;const m=Math.max(d,u,p);m>1&&(d/=m,u/=m,p/=m);const f=e=>e<=.0031308?12.92*e:1.055*Math.pow(e,1/2.4)-.055;return{r:Math.min(1,Math.max(0,f(d))),g:Math.min(1,Math.max(0,f(u))),b:Math.min(1,Math.max(0,f(p)))}}(e,.3);this._targetGlowColor=[i.r,i.g,i.b],this._normalizedGlowColor||(this._normalizedGlowColor=[...this._targetGlowColor]),this._colorTransitionProgress=0,this._colorTransitionStart=[...this._normalizedGlowColor];const r=this.renderer.materialMode||"glass";this.glowIntensity=gp(n.visual.glowColor,this.intensityCalibrationOffset,r)}if(this.renderer.updateLighting(e,n),this.customMaterial&&"moon"===this.customMaterialType){const e=new Ia(this.glowColor[0],this.glowColor[1],this.glowColor[2]);ku(this.customMaterial,e,this.glowIntensity)}else this.customMaterial&&"sun"===this.customMaterialType&&Vu(this.coreMesh,this.glowColor,this.glowIntensity,0)}var a;const i="sun"===this.geometryType?Bu:null;let r=null;if("moon"===this.geometryType&&xu.enabled){const e=Math.PI/180;r={enabled:!0,strength:xu.strength,lockedFace:xu.lockedFace,lerpSpeed:xu.lerpSpeed,calibrationRotation:[vu*e,bu*e,wu*e]}}this.behaviorController.configureForEmotion({geometryType:this.geometryType,emotionData:n,facingConfig:r,geometryRotation:i}),this.baseEuler[0]=0,this.baseEuler[2]=0;const s=fp(t);s&&s["3d"]&&this.behaviorController.applyUndertone(s["3d"]),this.animator.stopEmotions();const o=n?.visual?.glowColor||"#00BCD4",l=this.renderer.materialMode||"glass";if(this.baseGlowIntensity=gp(o,this.intensityCalibrationOffset,l),s&&s["3d"]&&s["3d"].glow&&(this.baseGlowIntensity*=s["3d"].glow.intensityMultiplier),this.breathingAnimator.setEmotion(e,s),this.blinkAnimator.setEmotion(e),this.rhythmEnabled&&this.rhythm3DAdapter?.isPlaying?.()){const t=this._getEmotionGroove(e);this.rhythm3DAdapter.setGroove(t,{quantize:!0,bars:2})}if(this.renderer.updateBloom(this.baseGlowIntensity,1,this.geometryType),this.animator.playEmotion(e),this.particlesEnabled&&this.particleOrchestrator&&this.particleOrchestrator.setEmotion(e,t),n&&n.soulAnimation){const e=n.soulAnimation;this.setCrystalSoulEffects({driftEnabled:!0,driftSpeed:e.driftSpeed||.5,shimmerEnabled:!0,shimmerSpeed:e.shimmerSpeed||.5})}}setCoreGlowEnabled(e){this.coreGlowEnabled=e,this.crystalSoul&&this.crystalSoul.setVisible(e)}setGlassMaterialEnabled(e){const t=e?"glass":"glow";this.renderer.setMaterialMode(t)}setGlowIntensity(e){this.glowIntensityOverride=e,null!==e&&(this.glowIntensity=e,this.baseGlowIntensity=e)}sliderToIntensity(e){const t=e/100;return.3*Math.pow(10/.3,t)}setIntensityCalibration(e){this.intensityCalibrationOffset=e,this.setEmotion(this.emotion,this.undertone)}getGlowIntensity(){return this.glowIntensity}playGesture(e){this.animationManager.playGesture(e,{onUpdate:(e,t)=>{e.position&&(this.position=e.position),e.rotation&&(this.tempEuler.set(e.rotation[0],e.rotation[1],e.rotation[2],"XYZ"),this.gestureQuaternion.setFromEuler(this.tempEuler)),void 0!==e.scale&&(this.scale=this.baseScale*e.scale),void 0!==e.glowIntensity&&(this.glowIntensity=this.baseGlowIntensity*e.glowIntensity)},onComplete:()=>{this.position=[0,0,0],this.scale=this.baseScale}})}triggerReassembly(e=1500){return this.shatterSystem?this.shatterSystem.triggerReassembly(e):(console.warn("triggerReassembly: ShatterSystem not initialized"),!1)}isShatterFrozen(){return this.shatterSystem?.isFrozen()||!1}setSunShadow(e="off"){"sun"===this.geometryType&&this.effectManager.hasSolarEclipse()?this.effectManager.setSolarEclipse(e):console.warn(" Eclipse only available for sun geometry")}startSolarEclipse(e={}){const t=e.type||"total";"sun"===this.geometryType&&this.effectManager.hasSolarEclipse()?this.effectManager.setSolarEclipse(t):(this.morphToShape("sun"),setTimeout(()=>{this.effectManager.hasSolarEclipse()&&this.effectManager.setSolarEclipse(t)},600))}startLunarEclipse(e={}){const t=e.type||"total";"moon"===this.geometryType&&this.effectManager.hasLunarEclipse()?this.effectManager.setLunarEclipse(t):(this.morphToShape("moon"),setTimeout(()=>{this.effectManager.hasLunarEclipse()&&this.effectManager.setLunarEclipse(t)},600))}stopEclipse(){this.effectManager.stopAllEclipses()}setMoonEclipse(e="off"){"moon"===this.geometryType&&this.effectManager.hasLunarEclipse()?this.effectManager.setLunarEclipse(e):console.warn(" Lunar eclipse only available for moon geometry")}setBloodMoonBlend(e={}){"moon"===this.geometryType&&this.customMaterial?(void 0!==e.blendMode&&(this.customMaterial.uniforms.blendMode.value=e.blendMode),void 0!==e.blendStrength&&(this.customMaterial.uniforms.blendStrength.value=e.blendStrength),void 0!==e.emissiveStrength&&(this.customMaterial.uniforms.emissiveStrength.value=e.emissiveStrength),void 0!==e.eclipseIntensity&&(this.customMaterial.uniforms.eclipseIntensity.value=e.eclipseIntensity)):console.warn(" Blood moon blend only available for moon geometry")}setBlendLayer(e,t={}){if("moon"!==this.geometryType&&"sun"!==this.geometryType||!this.customMaterial)return void console.warn(" Blend layers only available for moon and sun geometry");const n=`layer${e}`;void 0!==t.mode&&this.customMaterial.uniforms[`${n}Mode`]&&(this.customMaterial.uniforms[`${n}Mode`].value=t.mode),void 0!==t.strength&&this.customMaterial.uniforms[`${n}Strength`]&&(this.customMaterial.uniforms[`${n}Strength`].value=t.strength),void 0!==t.enabled&&this.customMaterial.uniforms[`${n}Enabled`]&&(this.customMaterial.uniforms[`${n}Enabled`].value=t.enabled?1:0)}setAllBlendLayers(e){"moon"!==this.geometryType&&"sun"!==this.geometryType||!this.customMaterial?console.warn(" Blend layers only available for moon and sun geometry"):e.forEach((e,t)=>{this.setBlendLayer(t+1,e)})}setCrystalBlendLayer(e,t,n={}){if("crystal"!==this.geometryType&&"rough"!==this.geometryType||!this.customMaterial||"crystal"!==this.customMaterialType)return;const a=`${e}Blend${t}`;void 0!==n.mode&&this.customMaterial.uniforms[`${a}Mode`]&&(this.customMaterial.uniforms[`${a}Mode`].value=n.mode),void 0!==n.strength&&this.customMaterial.uniforms[`${a}Strength`]&&(this.customMaterial.uniforms[`${a}Strength`].value=n.strength),void 0!==n.enabled&&this.customMaterial.uniforms[`${a}Enabled`]&&(this.customMaterial.uniforms[`${a}Enabled`].value=n.enabled?1:0)}setCrystalUniforms(e={}){if("crystal"!==this.geometryType&&"rough"!==this.geometryType||!this.customMaterial||"crystal"!==this.customMaterialType)return void console.warn(" Crystal uniforms only available with crystal blend-layers material");const{uniforms:t}=this.customMaterial,n=(e,t,n=0,a=10)=>{e&&"number"==typeof t&&!isNaN(t)&&isFinite(t)&&(e.value=Math.max(n,Math.min(a,t)))};n(t.coreGlowStrength,e.coreGlowStrength,0,2),void 0===e.coreGlowFalloff||isNaN(e.coreGlowFalloff)||(n(t.coreGlowFalloff,e.coreGlowFalloff,.1,3),this.setCrystalCoreSize(e.coreGlowFalloff)),n(t.fresnelStrength,e.fresnelStrength,0,2),n(t.fresnelPower,e.fresnelPower,.5,10),n(t.transmissionStrength,e.transmissionStrength,0,1),n(t.facetStrength,e.facetStrength,0,2),n(t.iridescenceStrength,e.iridescenceStrength,0,1),n(t.chromaticAberration,e.chromaticAberration,0,1),n(t.causticStrength,e.causticStrength,0,1),n(t.emissiveIntensity,e.emissiveIntensity,0,5),n(t.sparkleEnabled,e.sparkleEnabled,0,1),n(t.sparkleSpeed,e.sparkleSpeed,.1,5),n(t.causticEnabled,e.causticEnabled,0,1),n(t.causticSpeed,e.causticSpeed,.1,10),n(t.causticScale,e.causticScale,.5,10),n(t.causticCoverage,e.causticCoverage,0,1),n(t.energyPulseEnabled,e.energyPulseEnabled,0,1),n(t.energyPulseSpeed,e.energyPulseSpeed,.1,5)}createCrystalInnerCore(){if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),this.renderer&&this.renderer.invalidateSoulCache(),!this.coreMesh)return;const e=this._targetGeometryType||this.geometryType;this.crystalSoul=new Ey({radius:.35,detail:1,geometryType:e,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(this.coreMesh,this.renderer?.scene);let t=1;"heart"===e?(this.crystalShellBaseScale=2.4,t=1):"rough"===e?(this.crystalShellBaseScale=1.6,t=1):"star"===e?(this.crystalShellBaseScale=2,t=1.4):"crystal"===e&&(this.crystalShellBaseScale=2,t=1),this.crystalSoul.baseScale=t,this.crystalSoul.mesh.scale.setScalar(t),this.crystalSoul.setVisible(this.coreGlowEnabled),this.crystalInnerCore=this.crystalSoul.mesh,this.crystalInnerCoreMaterial=this.crystalSoul.material,this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}updateCrystalInnerCore(e,t=0){if(!this.crystalSoul)return;const n=this.breathingAnimator&&this.breathingEnabled?this.breathingAnimator.getBreathingScale():1;this.crystalSoul.update(t,e,n),this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}setCrystalSoulEffects(e={}){this.crystalSoul&&this.crystalSoul.setEffects(e)}setCrystalCoreSize(e){this.crystalSoul&&(this.crystalSoul.setSize(e),this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale)}setCrystalShellSize(e){!this.coreMesh||"crystal"!==this.geometryType&&"rough"!==this.geometryType&&"heart"!==this.geometryType||(this.crystalShellBaseScale=e)}setWobbleEnabled(e){this.wobbleEnabled=e,this.behaviorController.setWobbleEnabled(e),e||(this.baseEuler[0]=0,this.baseEuler[2]=0)}setMaterialVariant(e){this.materialVariant=e}setRhythmEnabled(e){this.rhythmEnabled=e,e&&this.rhythm3DAdapter&&!this.rhythm3DAdapter.enabled&&this.rhythm3DAdapter.initialize()}setGrooveEnabled(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGrooveEnabled(e)}setBeatSyncStrength(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setBeatSyncStrength(e)}setGrooveConfig(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGrooveConfig(e)}isRhythmPlaying(){return this.rhythm3DAdapter?.isPlaying()||!1}getRhythmBPM(){return this.rhythm3DAdapter?.getBPM()||120}startRhythm(e=120,t="straight"){this.rhythm3DAdapter&&this.rhythm3DAdapter.start(e,t)}stopRhythm(){this.rhythm3DAdapter&&this.rhythm3DAdapter.stop()}setRhythmBPM(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setBPM(e)}setRhythmPattern(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setPattern(e)}setGroove(e,t={}){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGroove(e,t)}getGroovePresets(){return this.rhythm3DAdapter?this.rhythm3DAdapter.getGroovePresets():["groove1","groove2","groove3"]}getCurrentGroove(){return this.rhythm3DAdapter?this.rhythm3DAdapter.getCurrentGroove():"groove1"}breathePhase(e,t){this.breathingPhaseManager.startPhase(e,t)}stopBreathingPhase(){this.breathingPhaseManager.stop()}_updateBreathingPhase(e){return this.breathingPhaseManager.update(e)}morphToShape(e,t=800){const n=Hu[e];n?(this.shatterSystem&&!this.shatterSystem.isIdle()&&this.shatterSystem.forceStop(),this.geometryMorpher.startMorph(this.geometryType,e,t)&&(this.geometryMorpher.getInterruptedTarget(),this.blinkAnimator.pause(),this._targetGeometryConfig=n,this._targetGeometryType=e,n.geometryLoader&&!n.geometry?(this._targetGeometry=null,this._pendingGeometryLoad=n.geometryLoader(this.assetBasePath).then(e=>{this._targetGeometry=e,n.geometry=e,this._pendingGeometryLoad=null})):(this._targetGeometry=n.geometry,this._pendingGeometryLoad=null))):console.warn(`Unknown shape: ${e}`)}isMorphing(){return this.geometryMorpher.isTransitioning}_isMaterialTextureReady(){if(!this.customMaterial)return!0;const{uniforms:e}=this.customMaterial;for(const t of Object.keys(e)){const n=e[t].value;if(n&&n.isTexture&&!n.image)return!1}return!0}getMorphState(){return this.geometryMorpher.getState()}growIn(e=500){this.geometryMorpher.growIn(this.geometryType,e)}easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}render(e){if(Yw.startFrame(),this._destroyed)return;if(!this._ready)return;this._lastDeltaTime=e/1e3,Yw.start("animator"),this.animator.update(e),Yw.end("animator"),Yw.start("geometryMorpher");const t=this.geometryMorpher.update(e);if(Yw.end("geometryMorpher"),t.shouldSwapGeometry&&this._pendingGeometryLoad&&this.geometryMorpher.pauseAtSwap(),t.waitingForGeometry&&this._targetGeometry&&!this._pendingGeometryLoad&&!this._postSwapHold&&(this.geometryMorpher.resumeFromSwap(),this.geometryMorpher.hasSwappedGeometry=!1),t.shouldSwapGeometry&&this._targetGeometry){const e=this.geometryType;this.customMaterial&&function(e,t){switch(e){case"moon":!function(e){if(!e||!e.uniforms)return;const t=e.uniforms;t.shadowOffset&&t.shadowOffset.value.set(Su.full.x,Su.full.y),t.shadowCoverage&&(t.shadowCoverage.value=.5),t.shadowSoftness&&(t.shadowSoftness.value=.05),t.eclipseProgress&&(t.eclipseProgress.value=0),t.eclipseIntensity&&(t.eclipseIntensity.value=0),t.bloodMoonColor&&(t.bloodMoonColor.value=[.85,.18,.08]),t.emissiveStrength&&(t.emissiveStrength.value=.39),t.eclipseShadowPos&&(t.eclipseShadowPos.value=[-2,0]),t.eclipseShadowRadius&&(t.eclipseShadowRadius.value=1.2),t.shadowDarkness&&(t.shadowDarkness.value=.53),t.eclipseShadowColor&&(t.eclipseShadowColor.value=[1,.58,0]),t.eclipseMidtoneColor&&(t.eclipseMidtoneColor.value=[.71,.43,.03]),t.eclipseHighlightColor&&(t.eclipseHighlightColor.value=[1,.28,.1]),t.eclipseGlowColor&&(t.eclipseGlowColor.value=[.09,.09,.09]),t.eclipseBrightnessModel&&(t.eclipseBrightnessModel.value=0),t.layer1Mode&&(t.layer1Mode.value=9),t.layer1Strength&&(t.layer1Strength.value=.322),t.layer1Enabled&&(t.layer1Enabled.value=1),t.layer2Mode&&(t.layer2Mode.value=0),t.layer2Strength&&(t.layer2Strength.value=2.785),t.layer2Enabled&&(t.layer2Enabled.value=1),t.layer3Mode&&(t.layer3Mode.value=7),t.layer3Strength&&(t.layer3Strength.value=.199),t.layer3Enabled&&(t.layer3Enabled.value=1),t.layer4Mode&&(t.layer4Mode.value=0),t.layer4Strength&&(t.layer4Strength.value=0),t.layer4Enabled&&(t.layer4Enabled.value=0),t.opacity&&(t.opacity.value=1)}(t);break;case"sun":!function(e){if(!e||!e.uniforms)return;const t=e.uniforms;t.eclipseProgress&&(t.eclipseProgress.value=0),t.eclipseShadowPos&&(t.eclipseShadowPos.value=[-2,0]),t.eclipseShadowRadius&&(t.eclipseShadowRadius.value=.882),t.shadowDarkness&&(t.shadowDarkness.value=1),t.shadowOffset&&t.shadowOffset.value.set(200,0),t.shadowCoverage&&(t.shadowCoverage.value=.5),t.shadowSoftness&&(t.shadowSoftness.value=.1),t.layer1Mode&&(t.layer1Mode.value=0),t.layer1Strength&&(t.layer1Strength.value=.23),t.layer1Enabled&&(t.layer1Enabled.value=1),t.layer2Mode&&(t.layer2Mode.value=0),t.layer2Strength&&(t.layer2Strength.value=0),t.layer2Enabled&&(t.layer2Enabled.value=0),t.layer3Mode&&(t.layer3Mode.value=0),t.layer3Strength&&(t.layer3Strength.value=0),t.layer3Enabled&&(t.layer3Enabled.value=0),t.layer4Mode&&(t.layer4Mode.value=0),t.layer4Strength&&(t.layer4Strength.value=0),t.layer4Enabled&&(t.layer4Enabled.value=0),t.emissiveIntensity&&(t.emissiveIntensity.value=4),t.opacity&&(t.opacity.value=1),t.time&&(t.time.value=0)}(t);break;case"crystal":case"diamond":!function(e){if(!e||!e.uniforms)return;const t=e.uniforms,n=Wy;t.frostiness&&(t.frostiness.value=n.frostiness),t.fresnelPower&&(t.fresnelPower.value=n.fresnelPower),t.fresnelIntensity&&(t.fresnelIntensity.value=n.fresnelIntensity),t.innerGlowStrength&&(t.innerGlowStrength.value=n.innerGlowStrength),t.surfaceRoughness&&(t.surfaceRoughness.value=n.surfaceRoughness),t.surfaceNoiseScale&&(t.surfaceNoiseScale.value=n.surfaceNoiseScale),t.noiseFrequency&&(t.noiseFrequency.value=n.noiseFrequency),t.causticIntensity&&(t.causticIntensity.value=n.causticIntensity),t.causticScale&&(t.causticScale.value=n.causticScale),t.causticSpeed&&(t.causticSpeed.value=n.causticSpeed),t.textureStrength&&(t.textureStrength.value=n.textureStrength),t.layer1Mode&&(t.layer1Mode.value=n.layer1Mode),t.layer1Strength&&(t.layer1Strength.value=n.layer1Strength),t.layer1Enabled&&(t.layer1Enabled.value=n.layer1Enabled),t.layer2Mode&&(t.layer2Mode.value=n.layer2Mode),t.layer2Strength&&(t.layer2Strength.value=n.layer2Strength),t.layer2Enabled&&(t.layer2Enabled.value=n.layer2Enabled),t.layer3Mode&&(t.layer3Mode.value=n.layer3Mode),t.layer3Strength&&(t.layer3Strength.value=n.layer3Strength),t.layer3Enabled&&(t.layer3Enabled.value=n.layer3Enabled),t.layer4Mode&&(t.layer4Mode.value=n.layer4Mode),t.layer4Strength&&(t.layer4Strength.value=n.layer4Strength),t.layer4Enabled&&(t.layer4Enabled.value=n.layer4Enabled),t.glowIntensity&&(t.glowIntensity.value=n.glowIntensity),t.opacity&&(t.opacity.value=n.opacity),t.time&&(t.time.value=n.time)}(t)}}(e,this.customMaterial),this.geometry=this._targetGeometry,this.geometryType=this._targetGeometryType,this.geometryConfig=this._targetGeometryConfig,this.customMaterial&&(jy(this.customMaterial),this.renderer.disposeMaterial(this.customMaterial),this.customMaterial=null,this.customMaterialType=null);let t=null;const n=np(this.emotion),a=this._targetGeometryType,i=e=>{this.shatterSystem&&this.renderer?.coreMesh&&this.shatterSystem.precomputeShards(this.renderer.coreMesh,a)},r=qy(this._targetGeometryType,this._targetGeometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:n,assetBasePath:this.assetBasePath,onTextureReady:i});if(r&&(t=r.material,this.customMaterial=t,this.customMaterialType=r.type),t)this.renderer.swapGeometry(this.geometry,t);else{this.renderer.swapGeometry(this.geometry);const e=!0===this._targetGeometryConfig.defaultGlassMode;this.setGlassMaterialEnabled(e)}this.onMaterialSwap&&this.onMaterialSwap({geometryType:this._targetGeometryType,material:this.customMaterial,materialType:this.customMaterialType}),this.blinkAnimator.setGeometry(this._targetGeometryConfig),this.rotation=[0,0,0];const s=this.geometry.parameters?.radius||.5;this.effectManager.initializeForGeometry(this._targetGeometryType,{coreMesh:this.renderer.coreMesh,customMaterial:this.customMaterial,sunRadius:s}),this.shatterSystem&&this.renderer?.coreMesh&&this.shatterSystem.precomputeShards(this.renderer.coreMesh,this._targetGeometryType),"crystal"===this._targetGeometryType||"rough"===this._targetGeometryType||"heart"===this._targetGeometryType||"star"===this._targetGeometryType?"crystal"===this.customMaterialType&&this.createCrystalInnerCore():this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null,this.crystalInnerCore=null,this.crystalInnerCoreMaterial=null,this.renderer&&this.renderer.invalidateSoulCache());let o=null;if("moon"===this._targetGeometryType&&xu.enabled){const e=Math.PI/180;o={enabled:!0,strength:xu.strength,lockedFace:xu.lockedFace,lerpSpeed:xu.lerpSpeed,calibrationRotation:[vu*e,bu*e,wu*e]}}if(this.behaviorController.configureForMorph({targetGeometryType:this._targetGeometryType,emotionData:n,facingConfig:o,geometryRotation:null}),"moon"===this._targetGeometryType){this.renderer?.controls&&(this.renderer.controls.autoRotate=!1),this.renderer?.setCameraPreset&&this.renderer.setCameraPreset("front",0,!0);const e=Math.PI/180;this.calibrationRotation[0]=vu*e,this.calibrationRotation[1]=bu*e,this.calibrationRotation[2]=wu*e}else if(this.renderer?.controls&&!1!==this.options.autoRotate&&(this.renderer.controls.autoRotate=!0),"crystal"===this._targetGeometryType||"rough"===this._targetGeometryType||"heart"===this._targetGeometryType){const e=Math.PI/180;this.calibrationRotation[0]=0*e,this.calibrationRotation[1]=30*e,this.calibrationRotation[2]=0*e}else this.calibrationRotation[0]=0,this.calibrationRotation[1]=0,this.calibrationRotation[2]=0;this.geometryMorpher.pauseAtSwap(),this._postSwapHold=!0,this._postSwapHoldTime=Date.now(),this._postSwapFrameCount=0}if(this._postSwapHold&&t.waitingForGeometry){this._postSwapFrameCount++;const e=this._isMaterialTextureReady(),t=this._postSwapFrameCount>=2,n=Date.now()-this._postSwapHoldTime>500;(e&&t||n)&&(this.geometryMorpher.resumeFromSwap(),this._postSwapHold=!1)}t.completed&&(this._targetGeometry=null,this._targetGeometryType=null,this._targetGeometryConfig=null,this.blinkingManuallyDisabled||this.blinkAnimator.resume()),Yw.start("breathing"),this.breathingAnimator.update(e,this.emotion,fp(this.undertone)),Yw.end("breathing");const n=this._updateBreathingPhase(e),a=1!==n?n:this.breathingEnabled?this.breathingAnimator.getBreathingScale():1,i=t.scaleMultiplier,r=this.blinkAnimator.update(e);Yw.start("behaviorController");const s=this._pendingFreezeRotation||0,o=this._pendingFreezeWobble||0;if(s>0){const t=e*(1-s);this.behaviorController.update(t,this.baseEuler)}else this.behaviorController.update(e,this.baseEuler);Yw.end("behaviorController"),o>.5&&this.wobbleEnabled?(this.behaviorController.setWobbleEnabled(!1),this._wobbleWasFrozen=!0):this._wobbleWasFrozen&&o<.5&&(this.behaviorController.setWobbleEnabled(this.wobbleEnabled),this._wobbleWasFrozen=!1);this.baseEuler[0]=Math.max(-.35,Math.min(.35,this.baseEuler[0])),this.baseEuler[2]=Math.max(-.35,Math.min(.35,this.baseEuler[2])),this.tempEuler.set(this.baseEuler[0],this.baseEuler[1],this.baseEuler[2],"XYZ"),this.baseQuaternion.setFromEuler(this.tempEuler),Yw.start("rhythmAdapter"),this.rhythm3DAdapter&&this.rhythm3DAdapter.update(e),Yw.end("rhythmAdapter"),Yw.start("gestureBlend");const l=this.animationManager.blend(this.baseEuler,this.baseScale,this.baseGlowIntensity);Yw.end("gestureBlend");const c=this.rhythm3DAdapter?.isPlaying()?this.rhythm3DAdapter.getModulation():null,h=l.hasAbsoluteGestures;void 0===this._grooveBlendCurrent&&(this._grooveBlendCurrent=1),void 0===this._smoothedBoost&&(this._smoothedBoost={position:[0,0,0],rotation:[0,0,0],scale:1});const d=(h?.3:1)*(1-(l.freezeGroove||0)),u=e/1e3,p=1-Math.exp(-12*u);this._grooveBlendCurrent+=(d-this._grooveBlendCurrent)*p;const m=this._grooveBlendCurrent,f=l.positionBoost||[0,0,0],g=l.rotationBoost||[0,0,0],y=l.scaleBoost||1;for(let e=0;e<3;e++)this._smoothedBoost.position[e]+=(f[e]-this._smoothedBoost.position[e])*p,this._smoothedBoost.rotation[e]+=(g[e]-this._smoothedBoost.rotation[e])*p;this._smoothedBoost.scale+=(y-this._smoothedBoost.scale)*p;const v=this._smoothedBoost.position,b=this._smoothedBoost.rotation,w=this._smoothedBoost.scale;let x=0,S=0,M=0;if(this._cameraRoll=0,l.hasCameraRelativeGestures&&this.renderer.camera){const e=this.renderer.camera,t=l.cameraRelativePosition;this._camTempVec3||(this._camTempVec3=new Gt,this._camRight=new Gt,this._camUp=new Gt,this._camForward=new Gt),e.updateMatrixWorld(),e.getWorldDirection(this._camForward),this._camRight.setFromMatrixColumn(e.matrixWorld,0),this._camUp.setFromMatrixColumn(e.matrixWorld,1),x=this._camRight.x*t[0]+this._camUp.x*t[1]-this._camForward.x*t[2],S=this._camRight.y*t[0]+this._camUp.y*t[1]-this._camForward.y*t[2],M=this._camRight.z*t[0]+this._camUp.z*t[1]-this._camForward.z*t[2];const n=l.cameraRelativeRotation;n&&0!==n[2]?this._cameraRoll=n[2]:this._cameraRoll=0}if(c){const e=c.grooveOffset[0]*m,t=c.grooveOffset[1]*m,n=c.grooveOffset[2]*m,a=h?c.positionMultiplier:1;this.position=[l.position[0]*a+x+e+v[0],l.position[1]*a+S+t+v[1],l.position[2]*a+M+n+v[2]],this.rotation=[l.rotation[0]+c.grooveRotation[0]*m+b[0],l.rotation[1]+c.grooveRotation[1]*m+b[1],l.rotation[2]+c.grooveRotation[2]*m+b[2]];const i=1+(c.grooveScale-1)*m,r=h?c.scaleMultiplier:1;if(this.scale=l.scale*i*r*w,l.nonUniformScale){const e=i*r*w;this.nonUniformScale=[l.nonUniformScale[0]*e,l.nonUniformScale[1]*e,l.nonUniformScale[2]*e]}else this.nonUniformScale=null}else this.position=[l.position[0]+x+v[0],l.position[1]+S+v[1],l.position[2]+M+v[2]],this.rotation=[l.rotation[0]+b[0],l.rotation[1]+b[1],l.rotation[2]+b[2]],this.scale=l.scale*w,l.nonUniformScale?this.nonUniformScale=[l.nonUniformScale[0]*w,l.nonUniformScale[1]*w,l.nonUniformScale[2]*w]:this.nonUniformScale=null;if(null===this.glowIntensityOverride)if(c){const e=1+(c.grooveGlow-1)*m,t=h?c.glowMultiplier:1;this.glowIntensity=l.glowIntensity*e*t}else this.glowIntensity=l.glowIntensity;if(this.gestureQuaternion=l.gestureQuaternion,this.glowBoost=l.glowBoost||0,l.glowColorOverride)this._originalGlowColor||(this._originalGlowColor=[...this.glowColor]),this.glowColor=[...l.glowColorOverride];else if(this._originalGlowColor){const e=.2;this.glowColor[0]+=(this._originalGlowColor[0]-this.glowColor[0])*e,this.glowColor[1]+=(this._originalGlowColor[1]-this.glowColor[1])*e,this.glowColor[2]+=(this._originalGlowColor[2]-this.glowColor[2])*e,Math.abs(this.glowColor[0]-this._originalGlowColor[0])+Math.abs(this.glowColor[1]-this._originalGlowColor[1])+Math.abs(this.glowColor[2]-this._originalGlowColor[2])<.01&&(this.glowColor=[...this._originalGlowColor],this._originalGlowColor=null)}if(l.electricOverlay&&l.electricOverlay.enabled){const e=this.renderer?.coreMesh,t=this.renderer?.scene;e&&t&&(this._electricOverlayMesh||(this._electricMaterial=Jv({charge:Math.min(1,l.electricOverlay.charge),opacity:.7}),this._electricOverlayMesh=new ui(e.geometry,this._electricMaterial),this._electricOverlayMesh.scale.setScalar(1.02),e.add(this._electricOverlayMesh),this._electricOverlayMesh.renderOrder=e.renderOrder+1),this._spawnElement("electricity",l.electricOverlay,{signatureSet:"_electricSpawnedSignatures",signatureKey:"_electricSpawnSignature",exitScope:"electricity"}),this._electricMaterial?.uniforms?.uTime&&(this._electricMaterial.uniforms.uTime.value=l.electricOverlay.time),this._electricMaterial?.uniforms?.uCharge&&(this._electricMaterial.uniforms.uCharge.value=Math.min(1,l.electricOverlay.charge)),this._currentElectricProgress=l.electricOverlay.progress??null)}else if(this._electricOverlayMesh){const e=this.renderer?.coreMesh;e&&this._electricOverlayMesh.parent&&e.remove(this._electricOverlayMesh),this._electricMaterial&&(this._electricMaterial.dispose(),this._electricMaterial=null),this._electricOverlayMesh=null,this.elementSpawner&&this.elementSpawner.triggerExit("electricity"),this._electricSpawnSignature=null,this._electricSpawnedSignatures=null,this._currentElectricProgress=null}if(l.waterOverlay&&l.waterOverlay.enabled){this._waterOverlayFadingOut=!1;const e=this.renderer?.coreMesh,t=this.renderer?.scene;e&&t&&(this._waterOverlayMesh||(this._waterMaterial=Xv({viscosity:l.waterOverlay.viscosity||.3,opacity:.7}),this._waterOverlayMesh=new ui(e.geometry,this._waterMaterial),this._waterOverlayMesh.scale.setScalar(1.03),e.add(this._waterOverlayMesh),this._waterOverlayMesh.renderOrder=e.renderOrder+1),this._spawnElement("water",l.waterOverlay,{defaultDuration:1500}),this._waterMaterial?.uniforms?.uTime&&(this._waterMaterial.uniforms.uTime.value=l.waterOverlay.time),this._waterMaterial?.uniforms?.uViscosity&&(this._waterMaterial.uniforms.uViscosity.value=l.waterOverlay.viscosity||.3),this._waterMaterial?.uniforms?.uOpacity&&(this._waterMaterial.uniforms.uOpacity.value=Math.min(.7,l.waterOverlay.wetness||l.waterOverlay.strength||.7)),this._waterMaterial?.uniforms?.uProgress&&(this._waterMaterial.uniforms.uProgress.value=l.waterOverlay.progress??0),this._currentWaterProgress=l.waterOverlay.progress??null)}else if(this._waterOverlayMesh)if(this._waterOverlayFadingOut||(this._waterOverlayFadingOut=!0,this.elementSpawner&&this.elementSpawner.triggerExit("water"),this._elementSpawnSignature=null,this._spawnedSignatures=null),this._waterMaterial?.uniforms?.uProgress&&(this._waterMaterial.uniforms.uProgress.value*=.88),this._waterMaterial?.uniforms?.uOpacity){if(this._waterMaterial.uniforms.uOpacity.value*=.88,this._waterMaterial.uniforms.uOpacity.value<.005){const e=this.renderer?.coreMesh;e&&this._waterOverlayMesh.parent&&e.remove(this._waterOverlayMesh),this._waterMaterial.dispose(),this._waterMaterial=null,this._waterOverlayMesh=null,this._waterOverlayFadingOut=!1,this._currentWaterProgress=null}}else{const e=this.renderer?.coreMesh;e&&this._waterOverlayMesh.parent&&e.remove(this._waterOverlayMesh),this._waterMaterial&&(this._waterMaterial.dispose(),this._waterMaterial=null),this._waterOverlayMesh=null,this._waterOverlayFadingOut=!1,this._currentWaterProgress=null}if(l.fireOverlay&&l.fireOverlay.enabled){this._fireOverlayFadingOut=!1;const e=this.renderer?.coreMesh,t=this.renderer?.scene;e&&t&&(this._fireOverlayMesh||(this._fireMaterial=qv({temperature:l.fireOverlay.temperature||.5,opacity:.4}),this._fireOverlayMesh=new ui(e.geometry,this._fireMaterial),this._fireOverlayMesh.scale.setScalar(1.04),e.add(this._fireOverlayMesh),this._fireOverlayMesh.renderOrder=e.renderOrder+2),this._spawnElement("fire",l.fireOverlay),this._fireMaterial?.uniforms?.uTime&&(this._fireMaterial.uniforms.uTime.value=l.fireOverlay.time),this._fireMaterial?.uniforms?.uTemperature&&(this._fireMaterial.uniforms.uTemperature.value=l.fireOverlay.temperature||.5),this._fireMaterial?.uniforms?.uOpacity&&(this._fireMaterial.uniforms.uOpacity.value=Math.min(.4,l.fireOverlay.strength)),this._fireMaterial?.uniforms?.uProgress&&(this._fireMaterial.uniforms.uProgress.value=l.fireOverlay.progress??0),this._currentFireProgress=l.fireOverlay.progress??null)}else if(this._fireOverlayMesh)if(this._fireOverlayFadingOut||(this._fireOverlayFadingOut=!0,this.elementSpawner&&this.elementSpawner.triggerExit("fire"),this._elementSpawnSignature=null,this._spawnedSignatures=null),this._fireMaterial?.uniforms?.uProgress&&(this._fireMaterial.uniforms.uProgress.value*=.88),this._fireMaterial?.uniforms?.uOpacity){if(this._fireMaterial.uniforms.uOpacity.value*=.88,this._fireMaterial.uniforms.uOpacity.value<.005){const e=this.renderer?.coreMesh;e&&this._fireOverlayMesh.parent&&e.remove(this._fireOverlayMesh),this._fireMaterial.dispose(),this._fireMaterial=null,this._fireOverlayMesh=null,this._fireOverlayFadingOut=!1,this._currentFireProgress=null}}else{const e=this.renderer?.coreMesh;e&&this._fireOverlayMesh.parent&&e.remove(this._fireOverlayMesh),this._fireMaterial&&(this._fireMaterial.dispose(),this._fireMaterial=null),this._fireOverlayMesh=null,this._fireOverlayFadingOut=!1,this._currentFireProgress=null}if(l.smokeOverlay&&l.smokeOverlay.enabled){const e=this.renderer?.coreMesh;if(e){const t=l.smokeOverlay.category||"emanating";this._smokeParticleSystem&&this._smokeMaterialCategory===t||(this._smokeParticleSystem&&this._smokeParticleSystem.dispose(),this._smokeParticleSystem=new hb({maxParticles:80,category:t,tint:l.smokeOverlay.tint||[1,1,1],density:l.smokeOverlay.density||.5,swirl:l.smokeOverlay.swirl||0}),this._smokeMaterialCategory=t,this._smokeParticleSystem.attachTo(e));const n=this._lastDeltaTime||.016;this._smokeParticleSystem.update(n,{thickness:l.smokeOverlay.thickness,category:t,tint:l.smokeOverlay.tint,density:l.smokeOverlay.density,swirl:l.smokeOverlay.swirl})}}else this._smokeParticleSystem&&(this._smokeParticleSystem.dispose(),this._smokeParticleSystem=null,this._smokeMaterialCategory=null);if(l.voidOverlay&&l.voidOverlay.enabled){this._voidOverlayFadingOut=!1;const e=this.renderer?.coreMesh,t=this.renderer?.scene;if(e&&t){if(this._voidOverlayMesh||(this._voidMaterial=tb({depth:l.voidOverlay.depth||.7,opacity:.95}),this._voidOverlayMesh=new ui(e.geometry,this._voidMaterial),this._voidOverlayMesh.scale.setScalar(1.06),e.add(this._voidOverlayMesh),this._voidOverlayMesh.renderOrder=e.renderOrder+3),this._spawnElement("void",l.voidOverlay,{signatureSet:"_voidSpawnedSignatures",signatureKey:"_voidSpawnSignature",exitScope:"void",onBeforeSpawn:()=>{if(this.elementSpawner._distortionManager){const e=l.voidOverlay.distortionStrength;this.elementSpawner._distortionManager.setDistortionStrength("void",void 0!==e?e:null)}}}),this.elementSpawner._distortionManager){const e=l.voidOverlay.distortionStrength;this.elementSpawner._distortionManager.setDistortionStrength("void",void 0!==e?e:null)}if(this._voidMaterial?.uniforms?.uTime&&(this._voidMaterial.uniforms.uTime.value=l.voidOverlay.time),this._voidMaterial?.uniforms?.uDepth){const e=Math.min(1,(l.voidOverlay.depth||.5)+.2);this._voidMaterial.uniforms.uDepth.value=e}this._voidMaterial?.uniforms?.uOpacity&&(this._voidMaterial.uniforms.uOpacity.value=Math.min(.95,l.voidOverlay.strength)),this._voidMaterial?.uniforms?.uProgress&&(this._voidMaterial.uniforms.uProgress.value=l.voidOverlay.progress??0),this._currentVoidProgress=l.voidOverlay.progress??null}}else if(this._voidOverlayMesh)if(this._voidOverlayFadingOut||(this._voidOverlayFadingOut=!0,this.elementSpawner&&this.elementSpawner.triggerExit("void"),this._currentVoidProgress=null,this._voidSpawnedSignatures=null),this._voidMaterial?.uniforms?.uOpacity){if(this._voidMaterial.uniforms.uOpacity.value*=.65,this.elementSpawner?._distortionManager){const e=this.elementSpawner._distortionManager,t=e.elementMeshes?.get("void");t?.material?.uniforms?.uStrength&&(t.material.uniforms.uStrength.value*=.65)}if(this._voidMaterial.uniforms.uOpacity.value<.005){const e=this.renderer?.coreMesh;e&&this._voidOverlayMesh.parent&&e.remove(this._voidOverlayMesh),this._voidMaterial.dispose(),this._voidMaterial=null,this._voidOverlayMesh=null,this._voidOverlayFadingOut=!1}}else{const e=this.renderer?.coreMesh;e&&this._voidOverlayMesh.parent&&e.remove(this._voidOverlayMesh),this._voidMaterial&&(this._voidMaterial.dispose(),this._voidMaterial=null),this._voidOverlayMesh=null,this._voidOverlayFadingOut=!1}if(l.iceOverlay&&l.iceOverlay.enabled){this._iceOverlayFadingOut=!1;const e=this.renderer?.coreMesh,t=this.renderer?.scene;if(e&&t){this._iceOverlayMesh||(this._iceMaterial=Qv({melt:l.iceOverlay.melt||0,opacity:.7}),this._iceOverlayMesh=new ui(e.geometry,this._iceMaterial),this._iceOverlayMesh.scale.setScalar(1.03),e.add(this._iceOverlayMesh),this._iceOverlayMesh.renderOrder=e.renderOrder+1,this.renderer&&this.renderer.setAmbientOcclusion(!0)),this._spawnElement("ice",l.iceOverlay,{signatureSet:"_iceSpawnedSignatures",signatureKey:"_iceSpawnSignature",exitScope:"ice"}),this._iceMaterial?.uniforms?.uTime&&(this._iceMaterial.uniforms.uTime.value=l.iceOverlay.time),this._iceMaterial?.uniforms?.uMelt&&(this._iceMaterial.uniforms.uMelt.value=l.iceOverlay.melt||0),this._iceMaterial?.uniforms?.uOpacity&&(this._iceMaterial.uniforms.uOpacity.value=Math.min(.7,l.iceOverlay.strength||.7)),this._iceMaterial?.uniforms?.uProgress&&(this._iceMaterial.uniforms.uProgress.value=l.iceOverlay.progress??0);const t=l.iceOverlay.strength||.8,n=e.material;if(n){this._iceOriginalMaterial||(this._iceOriginalMaterial={},n.uniforms&&(n.uniforms.glowColor&&(this._iceOriginalMaterial.glowColor=n.uniforms.glowColor.value.clone()),n.uniforms.coreColor&&(this._iceOriginalMaterial.coreColor=n.uniforms.coreColor.value.clone()),n.uniforms.glowIntensity&&(this._iceOriginalMaterial.glowIntensity=n.uniforms.glowIntensity.value)),n.emissive&&(this._iceOriginalMaterial.emissive=n.emissive.clone(),this._iceOriginalMaterial.emissiveIntensity=n.emissiveIntensity),n.color&&(this._iceOriginalMaterial.color=n.color.clone()));const e=this._iceTintColor||(this._iceTintColor=new Ia(.3,.5,.8)),a=this._iceOriginalMaterial;n.uniforms&&(n.uniforms.glowColor&&a.glowColor&&n.uniforms.glowColor.value.copy(a.glowColor).lerp(e,.3*t),n.uniforms.coreColor&&a.coreColor&&n.uniforms.coreColor.value.copy(a.coreColor).lerp(e,.4*t)),n.emissive&&a.emissive&&(n.emissive.copy(a.emissive).lerp(e,.3*t),n.emissiveIntensity=Math.max(a.emissiveIntensity,.3*t)),n.color&&!n.uniforms&&a.color&&n.color.copy(a.color).lerp(e,.2*t)}this._currentIceProgress=l.iceOverlay.progress??null}}else if(this._iceOverlayMesh){if(this._iceOverlayFadingOut||(this._iceOverlayFadingOut=!0,this._iceFadeStrength=1,this.elementSpawner&&this.elementSpawner.triggerExit("ice"),this._iceSpawnSignature=null,this._iceSpawnedSignatures=null),this._iceFadeStrength=.88*(this._iceFadeStrength||1),this._iceOriginalMaterial){const e=this.renderer?.coreMesh,t=e?.material;if(t){const e=this._iceTintColor||new Ia(.3,.5,.8),n=this._iceOriginalMaterial,a=this._iceFadeStrength;t.uniforms&&(t.uniforms.glowColor&&n.glowColor&&t.uniforms.glowColor.value.copy(n.glowColor).lerp(e,.3*a),t.uniforms.coreColor&&n.coreColor&&t.uniforms.coreColor.value.copy(n.coreColor).lerp(e,.4*a)),t.emissive&&n.emissive&&(t.emissive.copy(n.emissive).lerp(e,.3*a),t.emissiveIntensity=n.emissiveIntensity+(Math.max(n.emissiveIntensity,.3)-n.emissiveIntensity)*a),t.color&&!t.uniforms&&n.color&&t.color.copy(n.color).lerp(e,.2*a)}}if(this._iceMaterial?.uniforms?.uOpacity){if(this._iceMaterial.uniforms.uOpacity.value*=.88,this._iceMaterial.uniforms.uOpacity.value<.005){const e=this.renderer?.coreMesh;if(e&&this._iceOverlayMesh.parent&&e.remove(this._iceOverlayMesh),this._iceMaterial.dispose(),this._iceMaterial=null,this._iceOverlayMesh=null,this._iceOverlayFadingOut=!1,this._iceFadeStrength=0,this.renderer&&!this._earthOverlayMesh&&this.renderer.setAmbientOcclusion(!1),this._iceOriginalMaterial&&e?.material){const t=e.material,n=this._iceOriginalMaterial;t.uniforms&&(n.glowColor&&t.uniforms.glowColor&&t.uniforms.glowColor.value.copy(n.glowColor),n.coreColor&&t.uniforms.coreColor&&t.uniforms.coreColor.value.copy(n.coreColor),void 0!==n.glowIntensity&&t.uniforms.glowIntensity&&(t.uniforms.glowIntensity.value=n.glowIntensity)),n.emissive&&t.emissive&&(t.emissive.copy(n.emissive),t.emissiveIntensity=n.emissiveIntensity),n.color&&t.color&&!t.uniforms&&t.color.copy(n.color)}this._iceOriginalMaterial=null,this._currentIceProgress=null}}else{const e=this.renderer?.coreMesh;if(e&&this._iceOverlayMesh.parent&&e.remove(this._iceOverlayMesh),this._iceMaterial&&(this._iceMaterial.dispose(),this._iceMaterial=null),this._iceOverlayMesh=null,this._iceOverlayFadingOut=!1,this._iceFadeStrength=0,this.renderer&&!this._earthOverlayMesh&&this.renderer.setAmbientOcclusion(!1),this._iceOriginalMaterial&&e?.material){const t=e.material,n=this._iceOriginalMaterial;t.uniforms&&(n.glowColor&&t.uniforms.glowColor&&t.uniforms.glowColor.value.copy(n.glowColor),n.coreColor&&t.uniforms.coreColor&&t.uniforms.coreColor.value.copy(n.coreColor),void 0!==n.glowIntensity&&t.uniforms.glowIntensity&&(t.uniforms.glowIntensity.value=n.glowIntensity)),n.emissive&&t.emissive&&(t.emissive.copy(n.emissive),t.emissiveIntensity=n.emissiveIntensity),n.color&&t.color&&!t.uniforms&&t.color.copy(n.color)}this._iceOriginalMaterial=null,this._currentIceProgress=null}}if(l.lightOverlay&&l.lightOverlay.enabled){this._lightOverlayFadingOut=!1;const e=this.renderer?.coreMesh,t=this.renderer?.scene;e&&t&&(this._lightOverlayMesh||(this._lightMaterial=function(e={}){const{radiance:t=.5,opacity:n=.8}=e,a=.8+1.2*t;const i=new bi({uniforms:{uRadiance:{value:t},uProgress:{value:0},uPulseSpeed:{value:a},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uRadiance;\n            uniform float uProgress;\n            uniform float uPulseSpeed;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n                float NdotV = abs(dot(normal, viewDir));\n                float edgeness = 1.0 - NdotV;\n\n                //  CONSUMPTION FIELD \n                // Object-space position projected to 2D for consistent pattern\n                vec2 pos = vPosition.xz * 2.5 + vec2(vPosition.y * 0.8, -vPosition.y * 0.6);\n\n                // 3-octave FBM  organic creeping consumption boundary\n                float n1 = noise(pos * 1.5 + uTime * 0.10);         // Large-scale (slow drift)\n                float n2 = noise(pos * 4.0 - uTime * 0.15);         // Medium (counter-drift)\n                float n3 = noise(pos * 9.0 + uTime * 0.22);         // Fine detail (faster)\n                float consumeField = n1 * 0.50 + n2 * 0.30 + n3 * 0.20;\n\n                // Fresnel bias: light creeps from silhouette edges inward\n                consumeField += edgeness * 0.20;\n\n                //  DISSOLVE IN \n                // Slow ease-in over first 40%  light fades in gently, not a sudden flash.\n                // Squared smoothstep gives a soft-start curve (slow at first, then accelerates).\n                float rawDissolve = smoothstep(0.0, 0.40, uProgress);\n                float dissolveIn = rawDissolve * rawDissolve;\n\n                //  PROGRESS-DRIVEN THRESHOLD \n                // Progress ramps the consumption from nothing  full radiance-dependent coverage.\n                // Wider ramp (0.05 to 1.0) with squared easing so coverage builds gradually \n                // tendrils appear first, full consumption comes later.\n                float rawRamp = smoothstep(0.05, 1.0, uProgress);\n                float progressRamp = rawRamp * rawRamp;\n\n                // At progress=0: threshold=0.95 (nearly nothing consumed)\n                // At progress=1: threshold based on radiance (0.85 at low, 0.15 at high)\n                float targetThreshold = mix(0.85, 0.15, uRadiance);\n                float threshold = mix(0.95, targetThreshold, progressRamp);\n\n                // Sharp consumption boundary\n                float consumed = smoothstep(threshold, threshold - 0.05, consumeField);\n\n                //  TENDRILS \n                // Fine light tendrils reaching AHEAD of the main consumption front\n                float tendrilField = noise(pos * 8.0 + uTime * 0.25) * 0.6\n                                   + noise(pos * 14.0 - uTime * 0.16) * 0.4;\n                float tendrilThreshold = threshold + 0.10;\n                float tendrils = smoothstep(tendrilThreshold, tendrilThreshold - 0.03,\n                                            tendrilField + edgeness * 0.12);\n                tendrils *= 0.4 * smoothstep(0.0, 0.4, uRadiance * progressRamp);\n\n                float lightMask = max(consumed, tendrils);\n\n                //  LIGHT COLOR \n                // Golden-white divine light  warm, not clinical white\n                vec3 baseLight = vec3(1.0, 0.90, 0.55);\n\n                // Consumed areas: rich golden light with subtle noise variation\n                float colorNoise = noise(pos * 3.0 + uTime * 0.2);\n                // Shift toward pure white in the brightest consumed areas\n                vec3 consumedColor = mix(baseLight, vec3(1.0, 0.97, 0.88), consumed * 0.6);\n                // Subtle internal variation  flowing divine energy, not flat\n                consumedColor *= 0.85 + colorNoise * 0.15;\n\n                // Scale brightness with radiance\n                consumedColor *= mix(0.6, 1.2, uRadiance);\n\n                //  EDGE EMISSION \n                // Hot white rim where light meets normal surface\n                float edgeBand = smoothstep(threshold - 0.05, threshold - 0.01, consumeField)\n                               * smoothstep(threshold + 0.03, threshold, consumeField);\n\n                // Breathing pulse\n                float pulse = 0.85 + 0.15 * sin(uTime * uPulseSpeed);\n                edgeBand *= pulse;\n\n                // White-hot edge (brightest point of the consuming front)\n                // Tied to dissolveIn AND uOpacity so edge dims during fade-out\n                vec3 color = consumedColor * lightMask;\n                color += vec3(1.0, 0.95, 0.80) * edgeBand * uRadiance * 2.5 * dissolveIn * uOpacity;\n\n                //  FRESNEL RIM \n                // Subtle edge glow even before consumption  light begins at the edges\n                float fresnelGlow = pow(edgeness, 3.0) * uRadiance * progressRamp * 0.3;\n                color += baseLight * fresnelGlow;\n\n                //  ALPHA \n                float alpha = lightMask * uOpacity * dissolveIn;\n\n                // Edge emission  scaled by dissolveIn AND uOpacity for smooth retreat\n                float edgeAlpha = edgeBand * uRadiance * 0.6 * dissolveIn * dissolveIn * uOpacity;\n                alpha = max(alpha, edgeAlpha);\n\n                // Fresnel rim alpha  also respects uOpacity\n                alpha = max(alpha, fresnelGlow * dissolveIn * uOpacity);\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(color, alpha);\n            }\n        ",transparent:!0,blending:2,depthWrite:!1,side:2});return i.userData.radiance=t,i.userData.elementalType="light",i}({radiance:l.lightOverlay.radiance||.7,opacity:.35}),this._lightOverlayMesh=new ui(e.geometry,this._lightMaterial),this._lightOverlayMesh.scale.setScalar(1.04),e.add(this._lightOverlayMesh),this._lightOverlayMesh.renderOrder=e.renderOrder+3),this._spawnElement("light",l.lightOverlay,{signatureSet:"_lightSpawnedSignatures",signatureKey:"_lightSpawnSignature",exitScope:"light"}),this._lightMaterial?.uniforms?.uTime&&(this._lightMaterial.uniforms.uTime.value=l.lightOverlay.time),this._lightMaterial?.uniforms?.uRadiance&&(this._lightMaterial.uniforms.uRadiance.value=l.lightOverlay.radiance||.7),this._lightMaterial?.uniforms?.uOpacity&&(this._lightMaterial.uniforms.uOpacity.value=Math.min(.35,l.lightOverlay.strength)),this._lightMaterial?.uniforms?.uProgress&&(this._lightMaterial.uniforms.uProgress.value=l.lightOverlay.progress??0),this._currentLightProgress=l.lightOverlay.progress??null)}else if(this._lightOverlayMesh)if(this._lightOverlayFadingOut||(this._lightOverlayFadingOut=!0,this.elementSpawner&&this.elementSpawner.triggerExit("light"),this._lightSpawnSignature=null,this._lightSpawnedSignatures=null),this._lightMaterial?.uniforms?.uProgress&&(this._lightMaterial.uniforms.uProgress.value*=.88),this._lightMaterial?.uniforms?.uOpacity){if(this._lightMaterial.uniforms.uOpacity.value*=.88,this._lightMaterial.uniforms.uOpacity.value<.005){const e=this.renderer?.coreMesh;e&&this._lightOverlayMesh.parent&&e.remove(this._lightOverlayMesh),this._lightMaterial.dispose(),this._lightMaterial=null,this._lightOverlayMesh=null,this._lightOverlayFadingOut=!1,this._currentLightProgress=null}}else{const e=this.renderer?.coreMesh;e&&this._lightOverlayMesh.parent&&e.remove(this._lightOverlayMesh),this._lightMaterial&&(this._lightMaterial.dispose(),this._lightMaterial=null),this._lightOverlayMesh=null,this._lightOverlayFadingOut=!1,this._currentLightProgress=null}if(l.earthOverlay&&l.earthOverlay.enabled){this._earthOverlayFadingOut=!1;const e=this.renderer?.coreMesh,t=this.renderer?.scene;e&&t&&(this._earthOverlayMesh||(this._earthMaterial=function(e={}){const{petrification:t=.5,opacity:n=.9}=e,a=.5+1*t;const i=new bi({uniforms:{uPetrification:{value:t},uProgress:{value:0},uPulseSpeed:{value:a},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vWorldNormal;\n            varying vec3 vViewPosition;\n            varying float vVerticalPos;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n                vWorldNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\n\n                // Vertical gradient in object space  feet are bottom, head is top\n                vVerticalPos = position.y;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uPetrification;\n            uniform float uProgress;\n            uniform float uPulseSpeed;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vWorldNormal;\n            varying vec3 vViewPosition;\n            varying float vVerticalPos;\n\n            //  HASH FUNCTIONS \n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float hash3(vec3 p) {\n                p = fract(p * 0.3183099 + 0.1);\n                p *= 17.0;\n                return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n            }\n\n            //  VALUE NOISE \n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            float noise3D(vec3 p) {\n                vec3 i = floor(p);\n                vec3 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(mix(hash3(i), hash3(i + vec3(1,0,0)), f.x),\n                        mix(hash3(i + vec3(0,1,0)), hash3(i + vec3(1,1,0)), f.x), f.y),\n                    mix(mix(hash3(i + vec3(0,0,1)), hash3(i + vec3(1,0,1)), f.x),\n                        mix(hash3(i + vec3(0,1,1)), hash3(i + vec3(1,1,1)), f.x), f.y),\n                    f.z\n                );\n            }\n\n            // FBM for rock surface detail\n            float fbm3D(vec3 p) {\n                float value = 0.0;\n                float amp = 0.5;\n                for (int i = 0; i < 4; i++) {\n                    value += amp * noise3D(p);\n                    p *= 2.0;\n                    amp *= 0.5;\n                }\n                return value;\n            }\n\n            //  VORONOI \n            // Returns vec2(minDist, cellHash) for patch growth timing\n            vec3 voronoi(vec2 p) {\n                vec2 n = floor(p);\n                vec2 f = fract(p);\n                float minDist = 1.0;\n                float secondDist = 1.0;\n                float cellHash = 0.0;\n                for (int j = -1; j <= 1; j++) {\n                    for (int i = -1; i <= 1; i++) {\n                        vec2 neighbor = vec2(float(i), float(j));\n                        vec2 cellId = n + neighbor;\n                        vec2 point = hash(cellId) * vec2(0.8) + 0.1 + neighbor;\n                        float d = length(f - point);\n                        if (d < minDist) {\n                            secondDist = minDist;\n                            minDist = d;\n                            cellHash = hash(cellId + vec2(73.1, 19.4));\n                        } else if (d < secondDist) {\n                            secondDist = d;\n                        }\n                    }\n                }\n                float edgeDist = secondDist - minDist;\n                return vec3(minDist, edgeDist, cellHash);\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n                float NdotV = abs(dot(normal, viewDir));\n                float edgeness = 1.0 - NdotV;\n\n                //  CONSUMPTION FIELD \n                // Object-space position projected to 2D for consistent pattern\n                vec2 pos = vPosition.xz * 2.5 + vec2(vPosition.y * 0.8, -vPosition.y * 0.6);\n\n                // 3-octave FBM  organic creeping consumption boundary\n                float n1 = noise(pos * 1.5 + uTime * 0.06);\n                float n2 = noise(pos * 4.0 - uTime * 0.08);\n                float n3 = noise(pos * 9.0 + uTime * 0.12);\n                float consumeField = n1 * 0.45 + n2 * 0.30 + n3 * 0.15;\n\n                //  VORONOI PATCH GROWTH \n                // Large Voronoi cells create organic patch boundaries\n                // Each cell has a unique growth delay from its hash\n                vec3 voro = voronoi(pos * 1.8);\n                float cellDelay = voro.z * 0.35; // 0-0.35 stagger per cell\n                float patchEdge = voro.y; // Edge distance for crack boundaries\n\n                // Mix Voronoi patch field into consumption\n                consumeField += voro.x * 0.10;\n\n                //  BOTTOM-UP VERTICAL BIAS \n                // Earth rises from below  feet/base consumed first, head last\n                // vVerticalPos: roughly -0.5 (feet) to +0.5 (head) in object space\n                float verticalBias = smoothstep(0.6, -0.4, vVerticalPos) * 0.35;\n                consumeField += verticalBias;\n\n                // Fresnel bias: stone also creeps from silhouette edges inward\n                consumeField += edgeness * 0.15;\n\n                //  DISSOLVE IN \n                float rawDissolve = smoothstep(0.0, 0.35, uProgress);\n                float dissolveIn = rawDissolve * rawDissolve;\n\n                //  PROGRESS-DRIVEN THRESHOLD \n                // Per-cell delay makes patches appear at staggered times\n                float effectiveProgress = max(0.0, uProgress - cellDelay);\n                float rawRamp = smoothstep(0.0, 1.0, effectiveProgress);\n                float progressRamp = rawRamp * rawRamp;\n\n                // At progress=0: threshold=0.95 (nearly nothing consumed)\n                // At progress=1: threshold based on petrification\n                float targetThreshold = mix(0.85, 0.12, uPetrification);\n                float threshold = mix(0.95, targetThreshold, progressRamp);\n\n                // Wider transition zone for organic edge (not a hard line)\n                float consumed = smoothstep(threshold, threshold - 0.08, consumeField);\n\n                //  CRUMBLE RETREAT \n                // When progress is falling (retreat phase), fragmenting the edge\n                // This makes stone break apart into debris rather than smooth-fading\n                float crumbleField = noise(pos * 12.0 + uTime * 0.2) * 0.5\n                                   + noise(pos * 20.0 - uTime * 0.15) * 0.3\n                                   + noise(pos * 35.0) * 0.2;\n                // Crumble texture erodes the retreating edge\n                float crumbleErosion = smoothstep(0.35, 0.65, crumbleField);\n                // Only apply crumble near the consumption boundary (retreating edge)\n                float nearEdge = smoothstep(threshold - 0.12, threshold - 0.04, consumeField)\n                               * smoothstep(threshold + 0.02, threshold - 0.02, consumeField);\n                consumed *= mix(1.0, crumbleErosion, nearEdge * 0.6);\n\n                //  TENDRILS \n                // Fine stone veins reaching AHEAD of the main consumption front\n                float tendrilField = noise(pos * 8.0 + uTime * 0.15) * 0.6\n                                   + noise(pos * 14.0 - uTime * 0.10) * 0.4;\n                float tendrilThreshold = threshold + 0.10;\n                float tendrils = smoothstep(tendrilThreshold, tendrilThreshold - 0.03,\n                                            tendrilField + edgeness * 0.12);\n                tendrils *= 0.35 * smoothstep(0.0, 0.4, uPetrification * progressRamp);\n\n                float stoneMask = max(consumed, tendrils);\n\n                //  STONE COLOR  Seiryu-style dark grey limestone \n                // Cool charcoal grey with slight blue undertones.\n                // Petrification drives from warm grey  cool grey.\n                vec3 warmGrey = vec3(0.34, 0.33, 0.32);\n                vec3 coolGrey = vec3(0.28, 0.29, 0.33);\n                vec3 baseStone = mix(warmGrey, coolGrey, uPetrification);\n\n                //  MINERAL COLOR PATCHES \n                // Blue-grey dominant, sparse warm ochre  Seiryu uniformity\n                float mineralNoise1 = noise3D(vPosition * 1.5 + vec3(3.7, 0.0, 0.0));\n                float mineralNoise2 = noise3D(vPosition * 0.8 + vec3(1.3, 0.7, 2.5));\n                vec3 blueGrey = vec3(0.20, 0.22, 0.28);\n                float blueGreyMask = smoothstep(0.35, 0.18, mineralNoise2);\n                baseStone = mix(baseStone, blueGrey, blueGreyMask * 0.22);\n\n                // Per-pixel shade variation  subtle warm/cool shifts\n                float shadeNoise = noise3D(vPosition * 8.0 + vec3(5.5, 0.0, 0.0));\n                baseStone *= 0.93 + shadeNoise * 0.14;\n                float tintNoise = noise3D(vPosition * 5.0 + vec3(2.2, 1.7, 0.4));\n                vec3 warmShift = baseStone * vec3(1.02, 1.00, 0.97);\n                vec3 coolShift = baseStone * vec3(0.96, 0.99, 1.04);\n                baseStone = mix(coolShift, warmShift, tintNoise);\n\n                //  SURFACE NOISE + PROCEDURAL BUMP \n                // FBM drives both color crevice/ridge AND bump normal perturbation\n                float rockLarge = fbm3D(vPosition * 1.8 + vec3(3.0, 0.0, 0.0));\n                float rockMedium = noise3D(vPosition * 5.0 + vec3(6.0, 0.0, 0.0));\n                float rockNoise = rockLarge * 0.7 + rockMedium * 0.3;\n                float detailNoise = noise3D(vPosition * 10.0 + vec3(7.0, 0.0, 0.0));\n\n                // Procedural bump  dFdx/dFdy of noise height field\n                float bumpHeight = rockNoise * 0.6 + detailNoise * 0.4;\n                float dhdx = dFdx(bumpHeight);\n                float dhdy = dFdy(bumpHeight);\n                vec3 surfT = normalize(dFdx(vPosition));\n                vec3 surfB = normalize(dFdy(vPosition));\n                vec3 bumpedNormal = normalize(normal - 5.0 * 0.6 * (surfT * dhdx + surfB * dhdy));\n\n                //  THREE-LIGHT DIFFUSE + HEMISPHERE AMBIENT \n                vec3 lightDir1 = normalize(vec3(0.5, 1.0, 0.3));\n                vec3 lightDir2 = normalize(vec3(-0.4, 0.6, -0.5));\n                vec3 lightDir3 = normalize(vec3(0.0, -0.3, 0.8));\n                float NdotL1 = max(0.0, dot(bumpedNormal, lightDir1));\n                float NdotL2 = max(0.0, dot(bumpedNormal, lightDir2));\n                float NdotL3 = max(0.0, dot(bumpedNormal, lightDir3));\n                float diffuse = NdotL1 * 0.78 + NdotL2 * 0.14 + NdotL3 * 0.08;\n\n                float skyAmt = bumpedNormal.y * 0.5 + 0.5;\n                vec3 ambientUp = vec3(0.20, 0.21, 0.24);\n                vec3 ambientDown = vec3(0.10, 0.10, 0.12);\n                vec3 ambient = mix(ambientDown, ambientUp, skyAmt);\n\n                vec3 consumedColor = baseStone * (ambient + vec3(diffuse));\n\n                //  EDGE AMBIENT OCCLUSION \n                float edgeNdotV = max(0.0, dot(bumpedNormal, viewDir));\n                float edgeAO = smoothstep(0.0, 0.45, edgeNdotV);\n                consumedColor *= mix(0.84, 1.0, edgeAO);\n\n                //  SURFACE DETAIL  crevice/ridge color \n                float crevice = smoothstep(0.30, 0.48, rockNoise);\n                vec3 creviceColor = baseStone * vec3(0.48, 0.49, 0.54);\n                consumedColor = mix(creviceColor, consumedColor, crevice);\n\n                float ridge = smoothstep(0.60, 0.75, rockNoise);\n                consumedColor = mix(consumedColor, baseStone * vec3(1.10, 1.08, 1.05), ridge * 0.25);\n\n                // Micro-grain texture\n                float microGrain = hash(floor(vPosition.xz * 120.0));\n                float grit = detailNoise * 0.55 + microGrain * 0.45;\n                consumedColor *= 0.88 + grit * 0.24;\n\n                //  POST-DIFFUSE WARM MOTTLING \n                // Multiplicative tint preserves warm/cool contrast on screen\n                float ochreMask = smoothstep(0.42, 0.65, mineralNoise1);\n                float mineralNoise3 = noise3D(vPosition * 2.5 + vec3(6.0, 0.0, 3.0));\n                float warmMask = smoothstep(0.45, 0.68, mineralNoise3);\n                float warmAmount = min(ochreMask * 0.20 + warmMask * 0.15, 0.25);\n                warmAmount *= smoothstep(0.05, 0.4, diffuse);\n                vec3 warmTint = vec3(1.05, 1.02, 0.94);\n                consumedColor *= mix(vec3(1.0), warmTint, warmAmount);\n\n                //  SEDIMENTARY STRATA \n                float strataY = vPosition.y * 6.0;\n                float strataWarp = noise3D(vPosition * 2.0 + vec3(0.0, 5.0, 0.0));\n                float strata = sin(strataY + strataWarp * 2.0) * 0.5 + 0.5;\n                vec3 warmBand = consumedColor * vec3(1.02, 1.01, 0.97);\n                vec3 coolBand = consumedColor * vec3(0.97, 0.99, 1.03);\n                consumedColor = mix(coolBand, warmBand, strata);\n\n                //  CRACKS + CALCITE VEINS  Seiryu limestone signature \n                // Separate visual crack Voronoi from the consumption growth Voronoi\n                vec2 crackPos2 = vPosition.xz * 2.5 + vec2(vPosition.y * 0.7, 2.0);\n                vec3 crackVoro = voronoi(crackPos2);\n                float visualCrackEdge = crackVoro.y;\n\n                // Break mask  erases ~35% of crack features\n                float breakNoise2 = noise3D(vec3(crackPos2 * 0.5, 5.0));\n                float breakMask2 = smoothstep(0.25, 0.50, breakNoise2);\n\n                // Calcite selection  ~40% of surviving cracks become bright white\n                float calciteNoise = noise3D(vec3(crackPos2 * 0.7, 7.0));\n                float isCalcite = smoothstep(0.42, 0.58, calciteNoise);\n\n                // Dark crack lines (empty crevice shadows)\n                float darkCrackLine = 1.0 - smoothstep(0.0, 0.04, visualCrackEdge);\n                darkCrackLine *= breakMask2 * (1.0 - isCalcite);\n                consumedColor = mix(consumedColor, vec3(0.04, 0.04, 0.06), darkCrackLine * 0.85);\n\n                // Calcite veins  bright white lines\n                float calciteLine = 1.0 - smoothstep(0.0, 0.05, visualCrackEdge);\n                calciteLine *= breakMask2 * isCalcite;\n                vec3 calciteColor = vec3(0.75, 0.74, 0.72);\n                consumedColor = mix(consumedColor, calciteColor, calciteLine * 0.75);\n\n                //  DIRT IN CREVICES \n                // Dark soil in consumption-front crevices (from growth Voronoi patchEdge)\n                vec3 dirtColor = vec3(0.08, 0.08, 0.10);\n                float creviceMask = smoothstep(0.4, 0.0, patchEdge) * 0.3;\n                consumedColor = mix(consumedColor, dirtColor, creviceMask);\n\n                //  EDGE EMISSION \n                // Amber-gold rim where stone meets flesh  grinding mineral energy\n                float edgeBand = smoothstep(threshold - 0.08, threshold - 0.02, consumeField)\n                               * smoothstep(threshold + 0.04, threshold, consumeField);\n\n                // Breathing pulse\n                float pulse = 0.85 + 0.15 * sin(uTime * uPulseSpeed);\n                edgeBand *= pulse;\n\n                //  TENDRIL GLOW \n                // Faint mineral energy in the tendrils reaching ahead\n                float tendrilGlow = tendrils * 0.3 * dissolveIn;\n\n                //  COMPOSITE COLOR \n                vec3 color = consumedColor * stoneMask;\n\n                // Amber-gold edge emission\n                vec3 emissionColor = vec3(0.85, 0.60, 0.25);\n                color += emissionColor * edgeBand * uPetrification * 2.0 * dissolveIn * uOpacity;\n\n                // Tendril glow  subtle warm veins\n                color += vec3(0.60, 0.40, 0.15) * tendrilGlow * uOpacity;\n\n                //  FRESNEL RIM \n                float fresnelGlow = pow(edgeness, 3.0) * uPetrification * progressRamp * 0.2;\n                color += baseStone * fresnelGlow;\n\n                //  ALPHA \n                float alpha = stoneMask * uOpacity * dissolveIn;\n\n                // Edge emission alpha\n                float edgeAlpha = edgeBand * uPetrification * 0.5 * dissolveIn * dissolveIn * uOpacity;\n                alpha = max(alpha, edgeAlpha);\n\n                // Fresnel rim alpha\n                alpha = max(alpha, fresnelGlow * dissolveIn * uOpacity);\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(color, alpha);\n            }\n        ",transparent:!0,blending:1,depthWrite:!1,side:2});return i.userData.petrification=t,i.userData.elementalType="earth",i}({petrification:l.earthOverlay.petrification||.7,opacity:.9}),this._earthOverlayMesh=new ui(e.geometry,this._earthMaterial),this._earthOverlayMesh.scale.setScalar(1.03),e.add(this._earthOverlayMesh),this._earthOverlayMesh.renderOrder=e.renderOrder+3,this.renderer&&this.renderer.setAmbientOcclusion(!0)),this._spawnElement("earth",l.earthOverlay,{signatureSet:"_earthSpawnedSignatures",signatureKey:"_earthSpawnSignature",exitScope:"earth"}),this._earthMaterial?.uniforms?.uTime&&(this._earthMaterial.uniforms.uTime.value=l.earthOverlay.time),this._earthMaterial?.uniforms?.uPetrification&&(this._earthMaterial.uniforms.uPetrification.value=l.earthOverlay.petrification||.7),this._earthMaterial?.uniforms?.uOpacity&&(this._earthMaterial.uniforms.uOpacity.value=Math.min(.9,l.earthOverlay.strength)),this._earthMaterial?.uniforms?.uProgress&&(this._earthMaterial.uniforms.uProgress.value=l.earthOverlay.progress??0),this._currentEarthProgress=l.earthOverlay.progress??null)}else if(this._earthOverlayMesh)if(this._earthOverlayFadingOut||(this._earthOverlayFadingOut=!0,this.elementSpawner&&this.elementSpawner.triggerExit("earth"),this._earthSpawnSignature=null,this._earthSpawnedSignatures=null),this._earthMaterial?.uniforms?.uOpacity){if(this._earthMaterial.uniforms.uOpacity.value*=.88,this._earthMaterial.uniforms.uOpacity.value<.005){const e=this.renderer?.coreMesh;e&&this._earthOverlayMesh.parent&&e.remove(this._earthOverlayMesh),this._earthMaterial.dispose(),this._earthMaterial=null,this._earthOverlayMesh=null,this._earthOverlayFadingOut=!1,this._currentEarthProgress=null,this.renderer&&!this._iceOverlayMesh&&this.renderer.setAmbientOcclusion(!1)}}else{const e=this.renderer?.coreMesh;e&&this._earthOverlayMesh.parent&&e.remove(this._earthOverlayMesh),this._earthMaterial&&(this._earthMaterial.dispose(),this._earthMaterial=null),this._earthOverlayMesh=null,this._earthOverlayFadingOut=!1,this._currentEarthProgress=null,this.renderer&&!this._iceOverlayMesh&&this.renderer.setAmbientOcclusion(!1)}if(l.natureOverlay&&l.natureOverlay.enabled){this._natureOverlayFadingOut=!1;const e=this.renderer?.coreMesh,t=this.renderer?.scene;e&&t&&(this._natureOverlayMesh||(this._natureMaterial=function(e={}){const{growth:t=.5,opacity:n=.7}=e,a=1.2+-.7*t;const i=new bi({uniforms:{uGrowth:{value:t},uProgress:{value:0},uPulseSpeed:{value:a},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying float vVerticalPos;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n                vVerticalPos = position.y;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uGrowth;\n            uniform float uProgress;\n            uniform float uPulseSpeed;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying float vVerticalPos;\n\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            // 3-octave FBM for moss/lichen patches\n            float fbm(vec2 p) {\n                float f = 0.0;\n                f += 0.50 * noise(p); p *= 2.01;\n                f += 0.25 * noise(p); p *= 2.02;\n                f += 0.125 * noise(p);\n                return f / 0.875;\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n                float NdotV = abs(dot(normal, viewDir));\n                float edgeness = 1.0 - NdotV;\n\n                //  CONSUMPTION FIELD \n                vec2 pos = vPosition.xz * 2.5 + vec2(vPosition.y * 0.8, -vPosition.y * 0.6);\n\n                float growSpeed = mix(0.08, 0.04, uGrowth);\n                float n1 = noise(pos * 1.5 + uTime * growSpeed);\n                float n2 = noise(pos * 4.0 - uTime * growSpeed * 1.3);\n                float n3 = noise(pos * 9.0 + uTime * growSpeed * 2.0);\n                float consumeField = n1 * 0.50 + n2 * 0.30 + n3 * 0.20;\n\n                consumeField += edgeness * 0.15;\n\n                // Upward bias: growth creeps up from below\n                float vertBias = smoothstep(0.5, -0.5, vVerticalPos) * 0.25;\n                consumeField += vertBias;\n\n                //  DISSOLVE IN \n                float rawDissolve = smoothstep(0.0, 0.35, uProgress);\n                float dissolveIn = rawDissolve * rawDissolve;\n\n                //  PROGRESS-DRIVEN THRESHOLD \n                float rawRamp = smoothstep(0.05, 0.90, uProgress);\n                float progressRamp = rawRamp * rawRamp;\n\n                float targetThreshold = mix(0.85, 0.15, uGrowth);\n                float threshold = mix(0.95, targetThreshold, progressRamp);\n\n                float consumed = smoothstep(threshold, threshold - 0.05, consumeField);\n\n                //  VINE TENDRILS \n                // Vertically stretched  creeping upward like vines\n                vec2 vinePos = vec2(vPosition.x * 2.0, vPosition.y * 5.0);\n                float vineField = noise(vinePos * 3.0 - vec2(0.0, uTime * growSpeed * 3.0)) * 0.6\n                               + noise(vinePos * 7.0 + vec2(0.0, uTime * growSpeed * 2.0)) * 0.4;\n                float tendrilThreshold = threshold + 0.10;\n                float tendrils = smoothstep(tendrilThreshold, tendrilThreshold - 0.03,\n                                            vineField + edgeness * 0.12);\n                tendrils *= 0.4 * smoothstep(0.0, 0.4, uGrowth * progressRamp + 0.3);\n\n                float natureMask = max(consumed, tendrils);\n\n                //  ORGANIC DARKENING BASE \n                // Near-black with green tint  darkens surface organically\n                vec3 baseColor = vec3(0.01, 0.03, 0.01);\n\n                //  MOSS/LICHEN PATCHES \n                // FBM-driven green-brown patches on consumed surface\n                float mossNoise = fbm(pos * 5.0 + uTime * 0.015);\n                float moss = smoothstep(0.30, 0.55, mossNoise);\n                // Break mask  not all consumed area gets moss\n                float mossBreak = noise(pos * 2.0 + 0.5);\n                moss *= smoothstep(0.30, 0.55, mossBreak);\n                moss *= uGrowth;  // More moss when fully grown\n                vec3 mossColor = vec3(0.15, 0.25, 0.08) * moss * 0.6;\n\n                //  SPECULAR HIGHLIGHTS \n                // Dew-like organic sheen  softer than water's sharp gloss\n                vec3 light1 = normalize(vec3(0.3, 1.0, 0.5));\n                vec3 half1 = normalize(light1 + viewDir);\n                float spec1 = pow(max(dot(normal, half1), 0.0), 80.0);\n\n                vec3 light2 = normalize(vec3(-0.6, 0.7, -0.4));\n                vec3 half2 = normalize(light2 + viewDir);\n                float spec2 = pow(max(dot(normal, half2), 0.0), 64.0);\n\n                // Green-white dew highlights  less intense than water\n                vec3 specColor = vec3(1.4, 1.8, 1.2) * spec1\n                               + vec3(0.8, 1.1, 0.7) * spec2;\n\n                //  FRESNEL REFLECTION \n                // Faint green sheen at glancing angles\n                float fresnel = pow(edgeness, 2.0) * progressRamp;\n                vec3 fresnelColor = vec3(0.4, 0.7, 0.3) * fresnel * 0.6;\n\n                //  EDGE EMISSION \n                // Green-gold glow at growth boundary\n                float edgeBand = smoothstep(threshold - 0.05, threshold - 0.01, consumeField)\n                               * smoothstep(threshold + 0.03, threshold, consumeField);\n                float pulse = 0.85 + 0.15 * sin(uTime * uPulseSpeed);\n                edgeBand *= pulse;\n\n                //  COMPOSITE \n                vec3 color = baseColor;\n                color += mossColor * consumed;\n                color += specColor * consumed;\n                color += fresnelColor;\n                color += vec3(0.4, 0.7, 0.2) * edgeBand * 0.6 * dissolveIn;\n\n                //  ALPHA \n                float alpha = natureMask * uOpacity * dissolveIn * 0.65;\n                // Moss patches boost alpha slightly\n                alpha += moss * consumed * uOpacity * dissolveIn * 0.15;\n                float edgeAlpha = edgeBand * 0.45 * dissolveIn * uOpacity;\n                alpha = max(alpha, edgeAlpha);\n                alpha = max(alpha, fresnel * dissolveIn * uOpacity * 0.35);\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(color, alpha);\n            }\n        ",transparent:!0,blending:1,depthWrite:!1,side:2});return i.userData.growth=t,i.userData.elementalType="nature",i}({growth:l.natureOverlay.growth||.5,opacity:.7}),this._natureOverlayMesh=new ui(e.geometry,this._natureMaterial),this._natureOverlayMesh.scale.setScalar(1.03),e.add(this._natureOverlayMesh),this._natureOverlayMesh.renderOrder=e.renderOrder+1),this._spawnElement("nature",l.natureOverlay,{defaultDuration:3e3}),this._natureMaterial?.uniforms?.uTime&&(this._natureMaterial.uniforms.uTime.value=l.natureOverlay.time),this._natureMaterial?.uniforms?.uGrowth&&(this._natureMaterial.uniforms.uGrowth.value=l.natureOverlay.growth||.5),this._natureMaterial?.uniforms?.uOpacity&&(this._natureMaterial.uniforms.uOpacity.value=Math.min(.7,l.natureOverlay.strength)),this._natureMaterial?.uniforms?.uProgress&&(this._natureMaterial.uniforms.uProgress.value=l.natureOverlay.progress??0),this._currentNatureProgress=l.natureOverlay.progress??null)}else if(this._natureOverlayMesh)if(this._natureOverlayFadingOut||(this._natureOverlayFadingOut=!0,this.elementSpawner&&this.elementSpawner.triggerExit("nature"),this._elementSpawnSignature=null,this._spawnedSignatures=null),this._natureMaterial?.uniforms?.uProgress&&(this._natureMaterial.uniforms.uProgress.value*=.88),this._natureMaterial?.uniforms?.uOpacity){if(this._natureMaterial.uniforms.uOpacity.value*=.88,this._natureMaterial.uniforms.uOpacity.value<.005){const e=this.renderer?.coreMesh;e&&this._natureOverlayMesh.parent&&e.remove(this._natureOverlayMesh),this._natureMaterial.dispose(),this._natureMaterial=null,this._natureOverlayMesh=null,this._natureOverlayFadingOut=!1,this._currentNatureProgress=null}}else{const e=this.renderer?.coreMesh;e&&this._natureOverlayMesh.parent&&e.remove(this._natureOverlayMesh),this._natureMaterial&&(this._natureMaterial.dispose(),this._natureMaterial=null),this._natureOverlayMesh=null,this._natureOverlayFadingOut=!1,this._currentNatureProgress=null}if(void 0!==l.meshOpacity&&l.meshOpacity<1){const e=this.renderer?.coreMesh;e?.material&&(e.material.uniforms?.uOpacity?e.material.uniforms.uOpacity.value=l.meshOpacity:e.material.uniforms?.opacity?e.material.uniforms.opacity.value=l.meshOpacity:void 0!==e.material.opacity&&(void 0===this._originalMeshOpacity&&(this._originalMeshOpacity=e.material.opacity??1,this._originalMeshTransparent=e.material.transparent??!1),e.material.transparent=!0,e.material.opacity=l.meshOpacity,e.material.needsUpdate=!0))}else if(void 0===l.meshOpacity||l.meshOpacity>=1){const e=this.renderer?.coreMesh;e?.material&&(e.material.uniforms?.uOpacity?e.material.uniforms.uOpacity.value=1:e.material.uniforms?.opacity?e.material.uniforms.opacity.value=1:void 0!==this._originalMeshOpacity&&(e.material.opacity=this._originalMeshOpacity,e.material.transparent=this._originalMeshTransparent,e.material.needsUpdate=!0,this._originalMeshOpacity=void 0,this._originalMeshTransparent=void 0))}if(l.crackTriggers&&l.crackTriggers.length>0&&this.objectSpaceCrackManager){const e=this.renderer?.camera,t=this.renderer?.coreMesh;if(e&&t){e.updateMatrixWorld(),t.updateMatrixWorld(),this._crackCamRight||(this._crackCamRight=new Gt,this._crackCamUp=new Gt,this._crackCamForward=new Gt,this._crackWorldPos=new Gt,this._crackWorldDir=new Gt,this._crackInvQuat=new Ut),e.getWorldDirection(this._crackCamForward),this._crackCamRight.crossVectors(this._crackCamForward,e.up).normalize(),this._crackCamUp.crossVectors(this._crackCamRight,this._crackCamForward).normalize(),t.getWorldQuaternion(this._crackInvQuat),this._crackInvQuat.invert();for(const e of l.crackTriggers){const t=e.screenOffset||[0,0],n=e.screenDirection||[0,0],a=.35,i=1;this._crackWorldPos.set(0,0,0).addScaledVector(this._crackCamRight,t[0]*i).addScaledVector(this._crackCamUp,t[1]*i).addScaledVector(this._crackCamForward,-1),this._crackWorldPos.normalize().multiplyScalar(a),this._crackWorldPos.applyQuaternion(this._crackInvQuat),this._crackWorldDir.set(0,0,0),(Math.abs(n[0])>.01||Math.abs(n[1])>.01)&&this._crackWorldDir.addScaledVector(this._crackCamRight,n[0]).addScaledVector(this._crackCamUp,n[1]).normalize().applyQuaternion(this._crackInvQuat),this.objectSpaceCrackManager.addImpact({position:this._crackWorldPos.clone(),direction:this._crackWorldDir.clone(),propagation:e.propagation||.8,amount:e.amount||1})}}}if(l.crackHealTrigger&&this.objectSpaceCrackManager&&this.objectSpaceCrackManager.startHealing(l.crackHealDuration||1500),l.crack&&void 0!==l.crack.glowStrength&&this.objectSpaceCrackManager&&(this.objectSpaceCrackManager.glowStrength=l.crack.glowStrength),this._pendingFreezeRotation=l.freezeRotation||0,this._pendingFreezeWobble=l.freezeWobble||0,l.deformation&&l.deformation.enabled&&this.renderer?.camera&&this.renderer?.coreMesh){const e=l.deformation,t=e.impactPoint,n=this.renderer.camera,a=this.renderer.coreMesh;n.updateMatrixWorld(),a.updateMatrixWorld(),this._deformCamRight||(this._deformCamRight=new Gt,this._deformCamUp=new Gt,this._deformCamForward=new Gt,this._deformWorldDir=new Gt,this._deformLocalDir=new Gt,this._deformInverseQuat=new Ut),n.getWorldDirection(this._deformCamForward),this._deformCamRight.setFromMatrixColumn(n.matrixWorld,0),this._deformCamUp.setFromMatrixColumn(n.matrixWorld,1),this._deformWorldDir.set(this._deformCamRight.x*t[0]+this._deformCamUp.x*t[1]-this._deformCamForward.x*t[2],this._deformCamRight.y*t[0]+this._deformCamUp.y*t[1]-this._deformCamForward.y*t[2],this._deformCamRight.z*t[0]+this._deformCamUp.z*t[1]-this._deformCamForward.z*t[2]),a.getWorldQuaternion(this._deformInverseQuat),this._deformInverseQuat.invert(),this._deformLocalDir.copy(this._deformWorldDir),this._deformLocalDir.applyQuaternion(this._deformInverseQuat),this._deformation={...e,impactPoint:[this._deformLocalDir.x,this._deformLocalDir.y,this._deformLocalDir.z]}}else l.deformation&&l.deformation.enabled?this._deformation={...l.deformation}:this._deformation=l.deformation||null;if(this.enableShatter&&this.shatterSystem){if(this.shatterSystem.isFrozen()||(this._frozenShardsMovedThisGesture=!1),l.shatter&&l.shatter.enabled){const e=l.shatter;if(e.isDualMode&&this.shatterSystem.isFrozen())this.shatterSystem.triggerDualMode(e.dualModeType,e.dualModeConfig||{});else if("reform"===e.variant&&this.shatterSystem.isFrozen())this.shatterSystem.triggerReassembly(e.reassembleDuration||1500);else if(e.isDualMode||!this.shatterSystem.isFrozen()||this._frozenShardsMovedThisGesture){if(this.shatterSystem.isIdle()){const t=e.impactPoint||[0,0,.4];let n=new Gt(t[0],t[1],t[2]);if(this.renderer?.camera&&this.renderer?.coreMesh){const e=this.renderer.camera,a=this.renderer.coreMesh,i=new Gt,r=new Gt,s=new Gt;e.getWorldDirection(s),i.crossVectors(e.up,s).normalize(),r.crossVectors(s,i).normalize(),n=(new Gt).addScaledVector(i,t[0]).addScaledVector(r,t[1]).addScaledVector(s,-t[2]),n.add(a.position);const o=this.crystalSoul?.mesh||null;this.shatterSystem.setTargets(a,o)}const a=e.impactDirection||[0,0,-1];let i=new Gt(a[0],a[1],a[2]);if(this.renderer?.camera){const e=this.renderer.camera,t=new Gt,n=new Gt,r=new Gt;e.getWorldDirection(r),t.crossVectors(e.up,r).normalize(),n.crossVectors(r,t).normalize(),i=(new Gt).addScaledVector(t,a[0]).addScaledVector(n,a[1]).addScaledVector(r,-a[2]).normalize()}this.shatterSystem.shatter(this.renderer.coreMesh,{impactPoint:n,impactDirection:i,intensity:e.intensity||1,revealInner:!1!==e.revealSoul,isSuspendMode:e.isSuspendMode||!1,suspendAt:e.suspendAt||.25,suspendDuration:e.suspendDuration||.35,isFreezeMode:e.isFreezeMode||!1,isDualMode:e.isDualMode||!1,dualModeType:e.dualModeType,dualModeConfig:e.dualModeConfig||{},gravity:e.gravity,explosionForce:e.explosionForce,rotationForce:e.rotationForce,gestureDuration:e.gestureDuration,elemental:e.elemental||null,elementalParam:e.elementalParam??.5,overlay:e.overlay||null,overlayParam:e.overlayParam??.5}),this.objectSpaceCrackManager&&this.objectSpaceCrackManager.clearAll(),this.renderer.crackLayer&&this.renderer.crackLayer.clearAll()}}else{const t=e.impactDirection||[0,0,-1],n=e.variant?.startsWith("punch")?3.5:"explosive"===e.variant?4:"crumble"===e.variant?1.5:2.5;this.shatterSystem.moveFrozenShards(t,n),this._frozenShardsMovedThisGesture=!0}}l.shatter&&l.shatter.reassemble&&this.shatterSystem.isShattering()&&this.shatterSystem.reassemble({duration:l.shatter.reassembleDuration||1e3}),(this.shatterSystem.isShattering()||this.shatterSystem.isReassembling())&&this.shatterSystem.update(e)}if(Yw.start("elementSpawner"),this.elementSpawner){const t=this._currentFireProgress??this._currentWaterProgress??this._currentIceProgress??this._currentElectricProgress??this._currentVoidProgress??this._currentLightProgress??this._currentEarthProgress??this._currentNatureProgress??null;this.elementSpawner.update(e/1e3,t)}Yw.end("elementSpawner"),r.isBlinking&&r.rotation&&(this.rotation[0]+=r.rotation[0],this.rotation[1]+=r.rotation[1],this.rotation[2]+=r.rotation[2]);const _="crystal"!==this.geometryType&&"rough"!==this.geometryType,A=i*a*(r.isBlinking&&_?r.scale[1]:1)*(this.crystalShellBaseScale||2),C=this.scale*A,T=this.nonUniformScale?[this.nonUniformScale[0]*A,this.nonUniformScale[1]*A,this.nonUniformScale[2]*A]:null;if(Yw.start("particleOrchestrator"),this.particleVisibility&&this.particleOrchestrator){const t=this.geometryConfig?.particleRadiusMultiplier||1,n=(this.crystalShellBaseScale||2)*this.scale*a*t;this.particleOrchestrator.update(e,this.emotion,this.undertone,this.animationManager.getActiveAnimations(),this.animationManager.getTime(),{x:this.position[0],y:this.position[1],z:this.position[2]},{width:this.canvas.width,height:this.canvas.height},{euler:this.baseEuler,quaternion:this.baseQuaternion,angularVelocity:this.behaviorController.getAngularVelocity()},this.baseScale,n)}Yw.end("particleOrchestrator");const P=r.isBlinking&&r.glowBoost?1+r.glowBoost:1,D=this.coreGlowEnabled?this.glowIntensity*P:0,O=this.emotiveEngine?.getVirtualParticle(),E=D*(O?.opacity??1),I=t.isTransitioning?.3:.1;if(this.renderer.updateBloom(E,I,this.geometryType),this.elementSpawner){let e=.85;"sun"===this.geometryType?e=.3:"crystal"!==this.geometryType&&"rough"!==this.geometryType&&"heart"!==this.geometryType||(e=.35),this.elementSpawner.setElementBloomThreshold("water",e),this.elementSpawner.setElementBloomThreshold("ice",e),this.elementSpawner.setElementBloomThreshold("electricity",e),this.elementSpawner.setElementBloomThreshold("earth",e),this.elementSpawner.setElementBloomThreshold("nature",e)}if(this.glowBoost>0||this.renderer.glowLayer&&this.renderer.glowLayer.isActive()){const t=this.coreMesh?.position;this.renderer.updateGlowLayer(this.glowBoost,this.glowColor,t,e)}if(this.objectSpaceCrackManager&&(this.objectSpaceCrackManager.update(e),this.customMaterial?.uniforms&&this.objectSpaceCrackManager.applyToMaterial(this.customMaterial)),this.renderer.crackLayer&&this.renderer.crackLayer.isActive()&&this.renderer.updateCrackLayer(null,e),"sun"===this.customMaterialType&&Vu(this.coreMesh,this.glowColor,E,e),"moon"!==this.customMaterialType&&"moon-multiplexer"!==this.customMaterialType||!this.customMaterial||this.customMaterial.uniforms&&this.customMaterial.uniforms.glowIntensity&&(this.customMaterial.uniforms.glowIntensity.value=E),"crystal"===this.customMaterialType&&this.customMaterial){if(this.customMaterial.uniforms){if(this.customMaterial.uniforms.time.value+=e/1e3,this.customMaterial.uniforms.glowIntensity&&(this.customMaterial.uniforms.glowIntensity.value=E),this._targetGlowColor&&this._colorTransitionProgress<1){const t=this.colorTransitionDuration||500;this._colorTransitionProgress+=e/t,this._colorTransitionProgress=Math.min(this._colorTransitionProgress,1);const n=1-Math.pow(1-this._colorTransitionProgress,2),a=this._colorTransitionStart||this._normalizedGlowColor||[1,1,1],i=this._targetGlowColor;this._normalizedGlowColor=[a[0]+(i[0]-a[0])*n,a[1]+(i[1]-a[1])*n,a[2]+(i[2]-a[2])*n]}if(this._targetSSSValues&&this._sssTransitionProgress<1){const t=this.sssTransitionDuration||500;this._sssTransitionProgress+=e/t,this._sssTransitionProgress=Math.min(this._sssTransitionProgress,1);const n=1-Math.pow(1-this._sssTransitionProgress,2),a=this.customMaterial.uniforms,i=this._sssTransitionStart,r=this._targetSSSValues;a.sssStrength&&void 0!==i.sssStrength&&(a.sssStrength.value=i.sssStrength+(r.sssStrength-i.sssStrength)*n),a.sssThicknessBias&&void 0!==i.sssThicknessBias&&(a.sssThicknessBias.value=i.sssThicknessBias+(r.sssThicknessBias-i.sssThicknessBias)*n),a.sssThicknessScale&&void 0!==i.sssThicknessScale&&(a.sssThicknessScale.value=i.sssThicknessScale+(r.sssThicknessScale-i.sssThicknessScale)*n),a.sssCurvatureScale&&void 0!==i.sssCurvatureScale&&(a.sssCurvatureScale.value=i.sssCurvatureScale+(r.sssCurvatureScale-i.sssCurvatureScale)*n),a.sssAmbient&&void 0!==i.sssAmbient&&(a.sssAmbient.value=i.sssAmbient+(r.sssAmbient-i.sssAmbient)*n),a.frostiness&&void 0!==i.frostiness&&(a.frostiness.value=i.frostiness+(r.frostiness-i.frostiness)*n),a.innerGlowStrength&&void 0!==i.innerGlowStrength&&(a.innerGlowStrength.value=i.innerGlowStrength+(r.innerGlowStrength-i.innerGlowStrength)*n),a.fresnelIntensity&&void 0!==i.fresnelIntensity&&(a.fresnelIntensity.value=i.fresnelIntensity+(r.fresnelIntensity-i.fresnelIntensity)*n),a.causticIntensity&&void 0!==i.causticIntensity&&(a.causticIntensity.value=i.causticIntensity+(r.causticIntensity-i.causticIntensity)*n),a.emotionColorBleed&&void 0!==i.emotionColorBleed&&(a.emotionColorBleed.value=i.emotionColorBleed+(r.emotionColorBleed-i.emotionColorBleed)*n),a.sssAbsorption&&i.sssAbsorption&&a.sssAbsorption.value.set(i.sssAbsorption[0]+(r.sssAbsorption[0]-i.sssAbsorption[0])*n,i.sssAbsorption[1]+(r.sssAbsorption[1]-i.sssAbsorption[1])*n,i.sssAbsorption[2]+(r.sssAbsorption[2]-i.sssAbsorption[2])*n),a.sssScatterDistance&&i.sssScatterDistance&&a.sssScatterDistance.value.set(i.sssScatterDistance[0]+(r.sssScatterDistance[0]-i.sssScatterDistance[0])*n,i.sssScatterDistance[1]+(r.sssScatterDistance[1]-i.sssScatterDistance[1])*n,i.sssScatterDistance[2]+(r.sssScatterDistance[2]-i.sssScatterDistance[2])*n)}const t=this._normalizedGlowColor||[1,1,1];if(this.customMaterial.uniforms.emotionColor.value.setRGB(t[0],t[1],t[2]),this.customMaterial.uniforms.blinkIntensity){const e=r.isBlinking?Math.sin(r.progress*Math.PI):0;this.customMaterial.uniforms.blinkIntensity.value=e}}const t=this.shatterSystem&&!this.shatterSystem.isIdle();if(this.coreGlowEnabled&&!t){const t=this._normalizedGlowColor||[1,1,1];this.updateCrystalInnerCore(t,e)}}Yw.start("threeRenderer"),this.renderer.render({position:this.position,rotation:this.rotation,scale:C,nonUniformScale:T,glowColor:this.glowColor,glowColorHex:this.glowColorHex,glowIntensity:E,hasActiveGesture:this.animationManager.hasActiveAnimations(),calibrationRotation:this.calibrationRotation,cameraRoll:this._cameraRoll||0,solarEclipse:this.effectManager.getSolarEclipse(),deltaTime:e,morphProgress:t.isTransitioning?t.visualProgress:null,hasSoul:"crystal"===this.customMaterialType&&null!==this.crystalSoul,hasParticles:this.particleVisibility&&null!==this.particleOrchestrator&&this.particleOrchestrator.getParticleCount()>0,deformation:this._deformation}),Yw.end("threeRenderer"),this.effectManager.updateLunarEclipse(e),Yw.endFrame()}async _loadAsyncGeometry(){try{const e=await Yy(this.geometryType,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:np(this.emotion),assetBasePath:this.assetBasePath});if(this._destroyed)return;if(!e||!e.geometry)return console.warn(`[Core3D:${this._instanceId}] Async geometry load returned null!`),void(this._ready=!0);const t=e.geometry.clone();if(t.userData.geometryType=this.geometryType,this.geometry=t,this._deferredMeshCreation){if(this.coreMesh=this.renderer.createCoreMesh(t,this.customMaterial),this._destroyed)return;if("crystal"===this.customMaterialType&&(await this._createCrystalInnerCoreAsync(),this._destroyed))return;this._deferredMeshCreation=!1}else if(this.coreMesh){const e=this.coreMesh.geometry;if(this.coreMesh.geometry=t,e&&e!==t&&e.dispose(),this._destroyed)return;if("crystal"===this.customMaterialType&&(await this._createCrystalInnerCoreAsync(),this._destroyed))return}if(this._destroyed)return;this.elementSpawner&&this.renderer?.coreMesh&&!this.elementSpawner.coreMesh&&this.elementSpawner.initialize(this.renderer.coreMesh,this.renderer.camera),this._logSceneHierarchy(),this._ready=!0,this._startElementPreloading()}catch(e){console.warn(`[Core3D:${this._instanceId}] Async geometry load FAILED:`,e),this._destroyed||(this._ready=!0)}}_logSceneHierarchy(){const e=this.renderer?.scene;e&&e.children.forEach((e,t)=>{const n=null===e?"NULL!":void 0===e?"UNDEFINED!":null===e.visible?"visible=NULL!":void 0===e.visible?"visible=UNDEF!":"OK";console.warn(`  [${t}] ${e?.name||e?.type||"UNKNOWN"} status=${n} uuid=${e?.uuid?.slice(0,8)||"N/A"}`)})}async _createCrystalInnerCoreAsync(){if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),this.renderer&&this.renderer.invalidateSoulCache(),!this.coreMesh)return;if(await Ey._loadInclusionGeometry(this.assetBasePath),this._destroyed||!this.coreMesh)return;this.crystalSoul=new Ey({radius:.35,detail:1,geometryType:this.geometryType,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(this.coreMesh,this.renderer?.scene);let e=1;"heart"===this.geometryType?(this.crystalShellBaseScale=2.4,e=1):"rough"===this.geometryType?(this.crystalShellBaseScale=1.6,e=1):"crystal"===this.geometryType&&(e=1),this.crystalSoul.baseScale=e,this.crystalSoul.mesh.scale.setScalar(e),this.crystalSoul.setVisible(this.coreGlowEnabled),this.crystalInnerCore=this.crystalSoul.mesh,this.crystalInnerCoreMaterial=this.crystalSoul.material,this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}async _handleContextRestored(){if(!this._destroyed&&this.coreMesh&&this.customMaterialType){const e=np(this.emotion),t=qy(this.geometryType,this.geometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:e,assetBasePath:this.assetBasePath});t&&(this.customMaterial&&jy(this.customMaterial),this.customMaterial=t.material,this.coreMesh.material=this.customMaterial,"crystal"===this.customMaterialType&&this.crystalSoul&&await this._createCrystalInnerCoreAsync(),this.onMaterialSwap&&this.onMaterialSwap())}}isReady(){return this._ready}async waitUntilReady(){this._ready||this._readyPromise&&await this._readyPromise}_startElementPreloading(){!this._destroyed&&this.elementSpawner&&(this._preloadElements.length>0&&this._preloadElements.forEach(e=>{$w.includes(e)&&this.elementSpawner.preloadModels(e)}),this._backgroundPrewarm&&(this._prewarmTimeoutId=setTimeout(()=>{this._backgroundPrewarmElements()},2e3)))}async _backgroundPrewarmElements(){if(this._destroyed||!this.elementSpawner)return;const e=new Set(this._preloadElements),t=$w.filter(t=>!e.has(t));if(0!==t.length)for(const e of t){if(this._destroyed)break;if(await new Promise(e=>setTimeout(e,100)),this._destroyed)break;this.elementSpawner.preloadModels(e)}}_cancelPrewarm(){this._prewarmTimeoutId&&(clearTimeout(this._prewarmTimeoutId),this._prewarmTimeoutId=null)}destroy(){if(this._destroyed=!0,this._cancelPrewarm(),this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null,this.crystalInnerCore=null,this.crystalInnerCoreMaterial=null),this.particleOrchestrator){const e=this.particleOrchestrator.renderer;if(e){const t=e.getPoints();t&&this.renderer?.scene&&this.renderer.scene.remove(t)}this.particleOrchestrator.destroy(),this.particleOrchestrator=null}this.shatterSystem&&(this.shatterSystem.dispose(),this.shatterSystem=null),this._smokeParticleSystem&&(this._smokeParticleSystem.dispose(),this._smokeParticleSystem=null),this.objectSpaceCrackManager&&(this.objectSpaceCrackManager.dispose(),this.objectSpaceCrackManager=null),this.elementSpawner&&(this.elementSpawner.dispose(),this.elementSpawner=null),this.effectManager&&(this.effectManager.dispose(),this.effectManager=null),this.behaviorController&&(this.behaviorController.dispose(),this.behaviorController=null),this.breathingPhaseManager&&(this.breathingPhaseManager.dispose(),this.breathingPhaseManager=null),this.customMaterial&&(this.renderer.disposeMaterial(this.customMaterial),this.customMaterial=null,this.customMaterialType=null),this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null),this.animationManager.stopAll(),this.renderer.destroy(),this.animationManager.dispose(),this.animationManager=null,this.animator.destroy?.(),this.breathingAnimator.destroy?.(),this.gestureBlender.destroy?.(),this.geometryMorpher.destroy?.(),this.blinkAnimator.destroy?.(),this.behaviorController.dispose(),this.behaviorController=null,this.tempEuler=null,this.baseQuaternion=null,this.gestureQuaternion=null,this.geometry=null,this.geometryConfig=null,this._targetGeometry=null,this._targetGeometryConfig=null,this._targetGeometryType=null,this.canvas=null,this.options=null,this.coreMesh=null,this.rhythmEngine=null,this.rhythm3DAdapter=null,this.emotiveEngine=null,Qy()}_getEmotionGroove(e){return{happy:"groove2",excited:"groove2",amused:"groove2",silly:"groove2",surprised:"groove2",calm:"groove1",neutral:"groove1",sad:"groove1",content:"groove1",focused:"groove1",bored:"groove1",tired:"groove1",sleepy:"groove1",zen:"groove3",love:"groove3",grateful:"groove3",inspired:"groove3",hopeful:"groove3",proud:"groove3",angry:"groove2",anxious:"groove2",determined:"groove2"}[e]||"groove1"}_spawnElement(e,t,n={}){if(!this.elementSpawner)return;const{spawnMode:a,animation:i,models:r,count:s,scale:o,embedDepth:l,duration:c}=t;if(!a||"none"===a)return;const h=Array.isArray(a)?`layers:${a.length}:${a.map(e=>e.type).join(",")}`:"object"==typeof a?a.type:String(a),d=c||t.duration,u=`${e}:${h}:${d}:${i?.type||"default"}`,p=n.signatureSet||"_spawnedSignatures";if(this[p]=this[p]||new Set,this[p].has(u))return;n.onBeforeSpawn?.(),this.elementSpawner.triggerExit(n.exitScope);const m=this.elementSpawner.spawn(e,{intensity:t.strength||.8,mode:a,animation:i,models:r,count:s,scale:o,embedDepth:l,gestureDuration:d||n.defaultDuration||2e3});m?.catch&&m.catch(t=>console.error(`[Core3DManager] ${e} spawn error:`,t)),this[p].add(u),this[n.signatureKey||"_elementSpawnSignature"]=u}async preloadGeometries(){const e={glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:np(this.emotion)};await $y(e)}}class Kw{constructor(e={}){this.config=e,this.container=null,this.webglCanvas=null,this.canvas2D=null,this._canvasAppended=!1}setup(e){if("CANVAS"===e.tagName){const t=e.parentElement;this.container=document.createElement("div"),this.container.style.position="relative",this.container.style.width="100%",this.container.style.height="100%",t.replaceChild(this.container,e)}else this.container=e,this.container.style.position&&"static"!==this.container.style.position||(this.container.style.position="relative");return this.canvas2D=document.createElement("canvas"),this.canvas2D.id=`${this.config.canvasId}-particles`,this.canvas2D.width=this.container.offsetWidth||400,this.canvas2D.height=this.container.offsetHeight||400,this.canvas2D.style.position="absolute",this.canvas2D.style.top="0",this.canvas2D.style.left="0",this.canvas2D.style.width="100%",this.canvas2D.style.height="100%",this.canvas2D.style.background="transparent",this.canvas2D.style.zIndex="1",this.canvas2D.style.pointerEvents="none",this.container.appendChild(this.canvas2D),this.webglCanvas=document.createElement("canvas"),this.webglCanvas.id=`${this.config.canvasId}-3d`,this.webglCanvas.width=this.canvas2D.width,this.webglCanvas.height=this.canvas2D.height,this.webglCanvas.style.cssText="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: transparent;\n            z-index: 2;\n        ",this.config.enableControls?(this.webglCanvas.style.pointerEvents="auto",this.webglCanvas.style.touchAction="none"):(this.webglCanvas.style.pointerEvents="none",this.webglCanvas.style.touchAction="auto"),this._canvasAppended=!1,{container:this.container,webglCanvas:this.webglCanvas,canvas2D:this.canvas2D}}appendWebGLCanvas(){!this._canvasAppended&&this.webglCanvas&&this.container&&(this.container.appendChild(this.webglCanvas),this._canvasAppended=!0)}isCanvasAppended(){return this._canvasAppended}getDimensions(){return{width:this.canvas2D?.width||0,height:this.canvas2D?.height||0}}resize(e,t){this.canvas2D&&(this.canvas2D.width=e,this.canvas2D.height=t)}destroy(){this.webglCanvas&&this.webglCanvas.parentNode&&this.webglCanvas.parentNode.removeChild(this.webglCanvas),this.canvas2D&&this.canvas2D.parentNode&&this.canvas2D.parentNode.removeChild(this.canvas2D),this.container=null,this.webglCanvas=null,this.canvas2D=null,this._canvasAppended=!1}}class Zw{constructor(){this.listeners=new Map,this.groups=new Map,this.stats={registered:0,removed:0,active:0}}addEventListener(e,t,n,a={},i="default"){const r=this.generateId(),s={id:r,target:e,eventType:t,handler:n,options:a,group:i,active:!0};return this.listeners.set(r,s),this.groups.has(i)||this.groups.set(i,new Set),this.groups.get(i).add(r),e.addEventListener(t,n,a),this.stats.registered++,this.stats.active++,r}removeEventListener(e){const t=this.listeners.get(e);if(!t||!t.active)return!1;t.target.removeEventListener(t.eventType,t.handler,t.options),t.active=!1;const n=this.groups.get(t.group);return n&&(n.delete(e),0===n.size&&this.groups.delete(t.group)),this.listeners.delete(e),this.stats.removed++,this.stats.active--,!0}removeGroup(e){const t=this.groups.get(e);if(!t)return 0;let n=0;for(const e of t)this.removeEventListener(e)&&n++;return n}removeAllForTarget(e){let t=0;for(const[n,a]of this.listeners.entries())a.target===e&&a.active&&this.removeEventListener(n)&&t++;return t}removeAllOfType(e){let t=0;for(const[n,a]of this.listeners.entries())a.eventType===e&&a.active&&this.removeEventListener(n)&&t++;return t}removeAll(){let e=0;for(const[t,n]of this.listeners.entries())n.active&&this.removeEventListener(t)&&e++;return e}createAutoRemove(e,t,n,a={}){const i=this.addEventListener(e,t,n,a);return{id:i,remove:()=>this.removeEventListener(i)}}once(e,t,n,a={}){const i=this.addEventListener(e,t,e=>{n(e),this.removeEventListener(i)},a);return i}debounced(e,t,n,a=250,i={}){let r;return this.addEventListener(e,t,e=>{clearTimeout(r),r=setTimeout(()=>n(e),a)},i)}throttled(e,t,n,a=100,i={}){let r=!1;return this.addEventListener(e,t,e=>{r||(n(e),r=!0,setTimeout(()=>{r=!1},a))},i)}generateId(){return`listener_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}getStats(){return{...this.stats,groups:this.groups.size,listeners:this.listeners.size}}getActiveListeners(){const e=[];for(const[t,n]of this.listeners.entries())n.active&&e.push({id:t,eventType:n.eventType,group:n.group,target:n.target.constructor.name});return e}analyzeLeaks(){const e={totalListeners:this.listeners.size,activeListeners:this.stats.active,inactiveButNotRemoved:0,byTarget:new Map,byType:new Map,potentialLeaks:[]};for(const[t,n]of this.listeners.entries()){const a=n.target.constructor.name;e.byTarget.set(a,(e.byTarget.get(a)||0)+1),e.byType.set(n.eventType,(e.byType.get(n.eventType)||0)+1),n.active||(e.inactiveButNotRemoved++,e.potentialLeaks.push({id:t,eventType:n.eventType,target:a}))}return e.byTarget=Object.fromEntries(e.byTarget),e.byType=Object.fromEntries(e.byType),e}cleanup(){let e=0;for(const[t,n]of this.listeners.entries())n.active||(this.listeners.delete(t),e++);return e}destroy(){const e=this.removeAll();return this.listeners.clear(),this.groups.clear(),this.stats={registered:0,removed:0,active:0},e}}class Jw{constructor(){this.errors=[],this.maxErrors=10,this.errorCounts=new Map,this.defaults={emotion:"neutral",gesture:null,audioLevel:0,particleCount:0,glowIntensity:.7,coreSize:1,breathRate:1,color:"#B0B0B0"}}wrap(e,t,n=null){return(...a)=>{try{return e(...a)}catch(e){return this.logError(e,t),null!==n?n:this.getDefault(t)}}}logError(e,t){const n={timestamp:(new Date).toISOString(),context:t,message:e.message,stack:e.stack};this.errors.push(n);const a=this.errorCounts.get(t)||0;this.errorCounts.set(t,a+1),this.errors.length>this.maxErrors&&this.errors.shift(),a<3?console.warn(`[EmotiveEngine] ${t}:`,e.message):3===a&&console.warn(`[EmotiveEngine] ${t}: Error occurred 3+ times, suppressing further logs`)}getDefault(e){const t={"emotion-transition":this.defaults.emotion,"gesture-execution":this.defaults.gesture,"audio-processing":this.defaults.audioLevel,"particle-system":this.defaults.particleCount,rendering:{glowIntensity:this.defaults.glowIntensity,coreSize:this.defaults.coreSize,color:this.defaults.color},"canvas-operations":null,"state-management":this.defaults.emotion};return Object.prototype.hasOwnProperty.call(t,e)?t[e]:null}validateInput(e,t,n){try{switch(t){case"emotion":return["neutral","joy","sadness","anger","fear","surprise","disgust","love","euphoria"].includes(e)?e:n;case"undertone":return null===e||["nervous","confident","tired","intense","subdued"].includes(e)?e:null;case"gesture":return["bounce","pulse","shake","spin","nod","tilt","expand","contract","flash","drift"].includes(e)?e:n;case"number":return"number"!=typeof e||isNaN(e)?n:e;case"string":return"string"==typeof e?e:n;case"boolean":return"boolean"==typeof e?e:n;default:return null!=e?e:n}}catch(e){return this.logError(e,"input-validation"),n}}hasExceededThreshold(e,t=5){return(this.errorCounts.get(e)||0)>=t}getErrorStats(){return{totalErrors:this.errors.length,errorsByContext:Object.fromEntries(this.errorCounts),recentErrors:this.errors.slice(-5)}}clearErrors(){this.errors=[],this.errorCounts.clear()}async attemptRecovery(e,t,n=3){let a=0;for(;a<n;)try{return await t()}catch(t){if(a++,this.logError(t,`recovery-${e}-attempt-${a}`),a>=n)throw new Error(`Recovery failed for ${e} after ${n} attempts`);await new Promise(e=>setTimeout(e,100*Math.pow(2,a)))}}}class ex{constructor({budgetMs:e=12,cooldownFrames:t=3}={}){this._queue=[],this._budgetMs=e,this._cooldownFrames=t,this._cooldownRemaining=0,this._drained=!1,this._awaitingAsync=!1,this.onDrain=null}enqueue(e){this._queue.push(e),this._drained=!1}enqueueAll(e){for(let t=0;t<e.length;t++)this._queue.push(e[t]);this._drained=!1}tick(e){if(this._awaitingAsync)return;if(!this._queue.length)return void(this._drained||(this._drained=!0,this.onDrain&&this.onDrain()));if(this._cooldownRemaining>0)return void this._cooldownRemaining--;if(e>this._budgetMs)return;const t=this._queue.shift();try{const e=t();e&&"function"==typeof e.then?(this._awaitingAsync=!0,e.then(()=>{this._awaitingAsync=!1,this._cooldownRemaining=this._cooldownFrames},e=>{console.warn("[FrameBudgetScheduler] Async work item rejected:",e),this._awaitingAsync=!1,this._cooldownRemaining=this._cooldownFrames})):this._cooldownRemaining=this._cooldownFrames}catch(e){console.warn("[FrameBudgetScheduler] Work item threw:",e),this._cooldownRemaining=this._cooldownFrames}}get pending(){return this._queue.length}get isDrained(){return this._drained&&!this._awaitingAsync}clear(){this._queue.length=0,this._cooldownRemaining=0}destroy(){this.clear(),this.onDrain=null,this._drained=!1,this._awaitingAsync=!1}}const tx={quartz:{sssStrength:.8,sssAbsorption:[2.8,2.9,3],sssScatterDistance:[.2,.2,.25],sssThicknessBias:.6,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.12,frostiness:.15,innerGlowStrength:.2,fresnelIntensity:1.5,causticIntensity:1.2,emotionColorBleed:0},emerald:{sssStrength:2,sssAbsorption:[.05,4,.1],sssScatterDistance:[.1,.5,.1],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.2,innerGlowStrength:.15,fresnelIntensity:1.2,causticIntensity:1,emotionColorBleed:.35},ruby:{sssStrength:1.8,sssAbsorption:[4,.03,.08],sssScatterDistance:[.4,.04,.08],sssThicknessBias:.65,sssThicknessScale:1.9,sssCurvatureScale:2.5,sssAmbient:.08,frostiness:.12,innerGlowStrength:.12,fresnelIntensity:1.2,causticIntensity:1.15,emotionColorBleed:.35},sapphire:{sssStrength:2.2,sssAbsorption:[.15,.4,4],sssScatterDistance:[.1,.15,.5],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.18,innerGlowStrength:.15,fresnelIntensity:1.3,causticIntensity:1,emotionColorBleed:.35},amethyst:{sssStrength:2.5,sssAbsorption:[3,.05,4.5],sssScatterDistance:[.4,.05,.5],sssThicknessBias:.7,sssThicknessScale:2,sssCurvatureScale:3,sssAmbient:.08,frostiness:.18,innerGlowStrength:.12,fresnelIntensity:1.4,causticIntensity:1,emotionColorBleed:.35},topaz:{sssStrength:1.5,sssAbsorption:[3.5,2,.1],sssScatterDistance:[.3,.2,.05],sssThicknessBias:.6,sssThicknessScale:1.7,sssCurvatureScale:2.8,sssAmbient:.12,frostiness:.14,innerGlowStrength:.18,fresnelIntensity:1.4,causticIntensity:1.1,emotionColorBleed:.25},citrine:{sssStrength:1.6,sssAbsorption:[3.8,2.5,.05],sssScatterDistance:[.35,.25,.05],sssThicknessBias:.58,sssThicknessScale:1.6,sssCurvatureScale:2.6,sssAmbient:.14,frostiness:.12,innerGlowStrength:.22,fresnelIntensity:1.3,causticIntensity:1.2,emotionColorBleed:.2},diamond:{sssStrength:.5,sssAbsorption:[2.5,2.5,2.5],sssScatterDistance:[.15,.15,.15],sssThicknessBias:.55,sssThicknessScale:1.5,sssCurvatureScale:4,sssAmbient:.15,frostiness:.08,innerGlowStrength:.25,fresnelIntensity:2,causticIntensity:1.5,emotionColorBleed:0}};function nx(e,t){if(!t||!e?.core3D?.customMaterial?.uniforms)return!1;const n=tx[t];if(!n)return!1;const a=e.core3D.customMaterial.uniforms;return a.sssStrength&&(a.sssStrength.value=n.sssStrength),a.sssAbsorption&&a.sssAbsorption.value.set(...n.sssAbsorption),a.sssScatterDistance&&a.sssScatterDistance.value.set(...n.sssScatterDistance),a.sssThicknessBias&&(a.sssThicknessBias.value=n.sssThicknessBias),a.sssThicknessScale&&(a.sssThicknessScale.value=n.sssThicknessScale),a.sssCurvatureScale&&(a.sssCurvatureScale.value=n.sssCurvatureScale),a.sssAmbient&&(a.sssAmbient.value=n.sssAmbient),a.frostiness&&(a.frostiness.value=n.frostiness),a.innerGlowStrength&&(a.innerGlowStrength.value=n.innerGlowStrength),a.fresnelIntensity&&(a.fresnelIntensity.value=n.fresnelIntensity),void 0!==n.causticIntensity&&a.causticIntensity&&(a.causticIntensity.value=n.causticIntensity),a.emotionColorBleed&&(a.emotionColorBleed.value=n.emotionColorBleed??0),!0}function ax(){return Object.keys(tx)}function ix(e){return tx[e]||null}const rx=["bouncing up and down","hopping around","rocking back and forth","side to side","light on feet","spring in step","leaning forward","leaning in","leaning closer","leaning toward","reaching out","reaching toward","pointing at","pointing to","waving hello","waving goodbye","nodding head","shaking head","head shake","head nod","head bob","head tilt","deep breath","taking a breath","breathing deeply","settling down","calming down","winding down","getting bigger","getting smaller","puffing up","spinning around","twirling around","at peace","in love","on cloud nine","over the moon","on top of the world","in awe","grossed out","freaked out","low key","low-key","high key","on edge","keyed up","wound up","low energy","no energy","running low","just a bit","just a little","a little bit","kind of","sort of","a bit","a little","a lot","over the top","off the charts","through the roof","split second","one time","few times","many times","again and again","over and over","on repeat","blood moon","full moon","new moon","half moon","solar eclipse","lunar eclipse","total eclipse","ring of fire","diamond ring","killing it","crushing it","nailed it","sussy baka","side eye"],sx=/[,;|/]+/,ox=new Set(["a","an","the","is","are","am","be","being","been","i","me","my","it","its","to","of","for","with","as","this","that","these","those","just","only","also","too","please","pls","plz"]),lx=new Set(["but","and","or","yet","while","although","not","no","never","very","really","so","quite","rather","slightly","barely","extremely","completely","feeling","feel","feels","become","becoming","morph","morphing"]);function cx(e){return e.toLowerCase().trim().replace(/['']/g,"'").replace(/[""]/g,'"').replace(/\s+/g," ")}function hx(e){return["but","and","or","yet","while","although","with"].includes(e)}function dx(e){return["not","no","never","don't","dont","doesn't","doesnt","isn't","isnt"].includes(e)}const ux={nervous:{candidates:[{category:"emotion",target:"fear",priority:1},{category:"undertone",target:"nervous",priority:2}],rule:"standalone_is_emotion",examples:[{input:"nervous",resolved:{emotion:"fear"}},{input:"happy but nervous",resolved:{emotion:"joy",undertone:"nervous"}}]},anxious:{candidates:[{category:"emotion",target:"fear",priority:1},{category:"undertone",target:"nervous",priority:2}],rule:"standalone_is_emotion"},confident:{candidates:[{category:"emotion",target:"trust",priority:2},{category:"undertone",target:"confident",priority:1}],rule:"prefer_undertone",examples:[{input:"confident",resolved:{undertone:"confident"}},{input:"feeling confident",resolved:{emotion:"trust"}}]},tired:{candidates:[{category:"emotion",target:"sadness",priority:2},{category:"undertone",target:"tired",priority:1}],rule:"prefer_undertone",examples:[{input:"tired",resolved:{undertone:"tired"}},{input:"feeling tired",resolved:{emotion:"sadness",undertone:"tired"}}]},intense:{candidates:[{category:"undertone",target:"intense",priority:1},{category:"modifier",target:"intensity.very",priority:2}],rule:"prefer_undertone"},curious:{candidates:[{category:"emotion",target:"focused",priority:1},{category:"gesture",target:"lean",priority:2}],rule:"standalone_is_emotion",examples:[{input:"curious",resolved:{emotion:"focused"}},{input:"curious, leaning in",resolved:{emotion:"focused",gesture:"lean"}}]},interested:{candidates:[{category:"emotion",target:"focused",priority:1},{category:"gesture",target:"lean",priority:2}],rule:"standalone_is_emotion"},excited:{candidates:[{category:"emotion",target:"joy",priority:1},{category:"gesture",target:"bounce",priority:3}],rule:"standalone_is_emotion"},shaking:{candidates:[{category:"gesture",target:"shake",priority:1},{category:"emotion",target:"fear",priority:2}],rule:"standalone_is_gesture"},nodding:{candidates:[{category:"gesture",target:"nod",priority:1}],rule:"always_gesture"},glowing:{candidates:[{category:"gesture",target:"glow",priority:1},{category:"shape",target:"sun",priority:3}],rule:"standalone_is_gesture"},spinning:{candidates:[{category:"gesture",target:"spin",priority:1}],rule:"always_gesture"},love:{candidates:[{category:"emotion",target:"love",priority:1},{category:"shape",target:"heart",priority:2}],rule:"standalone_is_emotion",examples:[{input:"love",resolved:{emotion:"love"}},{input:"love heart",resolved:{emotion:"love",shape:"heart"}},{input:"become love",resolved:{shape:"heart"}}]},suspicious:{candidates:[{category:"emotion",target:"suspicion",priority:1},{category:"shape",target:"suspicion",priority:2}],rule:"standalone_is_emotion"},bright:{candidates:[{category:"emotion",target:"joy",priority:2},{category:"shape",target:"sun",priority:3},{category:"modifier",target:"intensity.very",priority:4}],rule:"context_dependent"},yes:{candidates:[{category:"gesture",target:"nod",priority:1}],rule:"always_gesture"},no:{candidates:[{category:"gesture",target:"shake",priority:1}],rule:"always_gesture"},agree:{candidates:[{category:"gesture",target:"nod",priority:1},{category:"emotion",target:"trust",priority:2}],rule:"standalone_is_gesture"},disagree:{candidates:[{category:"gesture",target:"shake",priority:1}],rule:"always_gesture"}},px={emotionContext:["feeling","feel","feels","felt","emotion","emotional","emotionally","mood","moody","state","am","is","are","being","becoming","become","grew","growing"],gestureContext:["do","doing","does","did","perform","performing","action","move","moving","movement","start","starting","begin","beginning","physically","motion"],shapeContext:["morph","morphing","morphed","transform","transforming","transformed","become","becoming","turn into","shape","form","look like","change to","change into"],undertoneContext:["but","yet","while","although","with","and also","mixed with","underneath","underlying","beneath","a bit","slightly","somewhat"],modifierContext:["very","really","so","extremely","slightly","barely","completely","quickly","slowly","briefly"]};function mx(e,t,n){const a=px[`${n}Context`];if(!a)return!1;const i=Math.max(0,t-3),r=Math.min(e.length,t+4);for(let n=i;n<r;n++)if(n!==t&&a.includes(e[n]))return!0;return!1}function fx(e,t){switch(t){case"emotion":return null!==e.emotion;case"gesture":return e.gestures&&e.gestures.length>0;case"shape":return null!==e.shape;case"undertone":return null!==e.undertone;default:return!1}}function gx(e,t,n,a){const i=ux[e];if(!i)return null;const{candidates:r,rule:s}=i;if(1===r.length)return r[0];switch(s){case"standalone_is_emotion":if(fx(a,"emotion")){const e=r.find(e=>"emotion"!==e.category);if(e)return e}return mx(t,n,"emotion"),r.find(e=>"emotion"===e.category)||r[0];case"standalone_is_gesture":if(fx(a,"gesture")){const e=r.find(e=>"gesture"!==e.category);if(e)return e}return mx(t,n,"gesture"),r.find(e=>"gesture"===e.category)||r[0];case"prefer_undertone":return mx(t,n,"emotion")?r.find(e=>"emotion"===e.category)||r[0]:r.find(e=>"undertone"===e.category)||r[0];case"always_gesture":return r.find(e=>"gesture"===e.category)||r[0];case"always_emotion":return r.find(e=>"emotion"===e.category)||r[0];case"context_dependent":for(const e of["emotion","gesture","shape","undertone"])if(mx(t,n,e)){const t=r.find(t=>t.category===e);if(t)return t}return r.sort((e,t)=>e.priority-t.priority)[0];default:return r.sort((e,t)=>e.priority-t.priority)[0]}}function yx(e){return e in ux}const vx={neutral:["neutral","default","normal","baseline","standard","nothing special","nothing particular","no strong feeling","not much","meh","whatever","indifferent","balanced","even","steady","stable","centered","level","middle ground","in between","ready","waiting","standing by","at attention","present","here","available","attentive","reset","clear","blank","empty","clean slate"],joy:["happy","joy","joyful","joyous","pleased","glad","content","satisfied","gratified","comfortable","good","cheerful","cheery","merry","jovial","jolly","upbeat","sunny","bright","lighthearted","buoyant","delighted","thrilled","overjoyed","elated","jubilant","exultant","gleeful","glowing","beaming","radiant","pumped","stoked","psyched","amped","hyped","vibing","living","slaying","winning","lit","fire","sick","dope","chuffed","pleased as punch","over the moon","made up","tickled","tickled pink","felicitous","beatific","blissful","smiling","grinning","laughing","giggling"],calm:["calm","peaceful","serene","tranquil","relaxed","at ease","comfortable","loose","unwound","decompressed","chilled","still","quiet","hushed","silent","soft","gentle","mild","placid","smooth","composed","collected","centered","grounded","untroubled","unworried","unbothered","unfazed","meditative","zen","mindful","contemplative","reflective","introspective","soothed","eased","mellowed","softened","chill","coasting","floating","drifting","laid back","easy going","low key","sorted","easy peasy"],excited:["excited","exciting","excitable","enthusiastic","eager","keen","avid","passionate","fervent","ardent","zealous","energetic","energized","animated","lively","spirited","vivacious","vibrant","dynamic","bouncy","peppy","perky","sprightly","anticipating","expectant","looking forward","itching","raring","chomping at the bit","fired up","charged","electric","electrified","buzzing","tingling","crackling","sparking","jazzed","juiced","geeked","hype","turnt","going off","well excited","buzzing","restless","fidgety","antsy","jumpy","twitchy","keyed up","wound up"],sadness:["sad","sadness","saddened","unhappy","down","low","blue","glum","bummed","disappointed","let down","discouraged","disheartened","dispirited","deflated","melancholy","melancholic","somber","gloomy","mournful","sorrowful","doleful","woeful","heavy-hearted","downcast","crestfallen","heartbroken","devastated","crushed","shattered","despairing","despondent","desolate","inconsolable","grief","grieving","mourning","bereft","empty","hollow","numb","void","wistful","longing","yearning","pining","nostalgic","bummed out","down in the dumps","in a funk","in the dumps","feeling low","gutted","choked","crying","tearful","weeping","sobbing","sighing","drooping","wilting","slumping"],anger:["angry","anger","angered","mad","annoyed","irritated","bothered","irked","peeved","miffed","vexed","displeased","put out","ticked off","ticked","frustrated","aggravated","exasperated","fed up","sick of","had enough","cross","upset","worked up","furious","enraged","livid","irate","incensed","infuriated","outraged","seething","fuming","boiling","burning","smoldering","raging","ballistic","apoplectic","berserk","seeing red","losing it","pissed","pissed off","salty","pressed","triggered","tilted","heated","steaming","narked","cheesed off","brassed off","shirty","stroppy","mardy","ropeable","filthy","spewing","clenching","tensing","grinding"],fear:["afraid","scared","fear","fearful","uneasy","unsettled","apprehensive","wary","concerned","worried","jittery","shaky","trembling","quivering","tense","tight","clenched","knotted","frightened","alarmed","startled","spooked","freaked","freaked out","creeped out","on edge","rattled","unnerved","terrified","petrified","horrified","panicked","panic","panicking","terror","dread","paranoid","distrustful","looking over shoulder","sketched","sketched out","wigged out","shook","bricking it","having kittens","in a flap","frozen","paralyzed","deer in headlights","heart racing","heart pounding","sweating"],surprise:["surprised","surprise","surprising","oh","huh","hmm","interesting","unexpected","caught off guard","astonished","amazed","astounded","startled","taken aback","struck","shocked","stunned","staggered","floored","dumbfounded","flabbergasted","gobsmacked","blown away","mind blown","speechless","wow","whoa","omg","no way","incredible","unbelievable","amazing","alarmed","dismayed","appalled","bewildered","baffled","perplexed","puzzled","confused","disoriented","thrown","shooketh","gagged","dead","wait what","blimey","crikey","bloody hell","jaw dropped","eyes wide","double take","gasp","gasping"],disgust:["disgusted","disgust","disgusting","distaste","dislike","aversion","put off","turned off","off-putting","repulsed","revolted","repelled","grossed out","creeped out","icked out","sickened","nauseated","nauseous","appalled","horrified","scandalized","offended","outraged","indignant","contempt","contemptuous","disdain","scorn","gagging","retching","cringing","wincing","recoiling","shrinking back","gross","ew","eww","yuck","yucky","ick","nasty","foul","vile","rank","minging","manky","grotty"],love:["love","loving","loved","affection","affectionate","fond","fondness","tender","tenderness","gentle","caring","care","nurturing","supportive","protective","devoted","dedicated","warm","warmth","warm-hearted","kind","kind-hearted","compassionate","sympathetic","adoring","adore","cherish","cherishing","treasure","treasuring","doting","romantic","amorous","passionate","smitten","infatuated","enamored","besotted","head over heels","falling for","connected","bonded","attached","close","intimate","deep","profound","heart eyes","crushing","swooning","melting","hugging","embracing","holding","cuddling","snuggling","nuzzling"],euphoria:["euphoric","euphoria","bliss","blissful","transcendent","otherworldly","sublime","heavenly","divine","ethereal","celestial","ecstatic","ecstasy","rapture","rapturous","exultant","exalted","elevated","peak","pinnacle","height","climax","breakthrough","revelation","epiphany","overwhelming joy","pure joy","absolute joy","complete happiness","total bliss","floating","soaring","flying","weightless","radiating","shining","on cloud nine","in heaven","on top of the world","walking on air","living my best life","ascended"],focused:["focused","focus","focusing","concentrating","concentration","concentrated","attentive","attention","attending","thinking","thought","thoughtful","pondering","considering","contemplating","reflecting","musing","mulling","engaged","absorbed","immersed","engrossed","rapt","riveted","captivated","enthralled","intent","determined","resolute","single-minded","laser focused","zeroed in","working","processing","analyzing","examining","studying","learning","figuring out","locked in","dialed in","in the zone","flow state","deep work","grinding","staring","gazing","peering","squinting","furrowed brow"],suspicion:["suspicious","suspicion","suspect","doubtful","doubt","doubting","skeptical","skepticism","questioning","uncertain","unsure","unconvinced","wary","cautious","guarded","careful","leery","circumspect","vigilant","distrustful","mistrust","mistrustful","disbelieving","incredulous","unbelieving","scrutinizing","examining","assessing","evaluating","judging","sizing up","sus","sussy","suss","side eye","giving side eye","side-eyeing","eyeing","not buying it","narrowed eyes","squinting","raised eyebrow","cocked head","tilted head","looking askance"],resting:["resting","rest","restful","tired","weary","fatigued","exhausted","drained","spent","depleted","worn out","sleepy","drowsy","dozy","groggy","yawning","nodding off","drifting off","sluggish","lethargic","listless","languid","lazy","idle","inactive","recovering","recuperating","recharging","winding down","powering down","shutting down","sleeping","asleep","slumbering","dozing","napping","snoozing","zonked","wiped","beat","dead tired","running on empty","out of gas","crashed","knackered","shattered","cream crackered"],glitch:["glitch","glitchy","glitching","malfunction","malfunctioning","broken","bugged","buggy","error","erroring","corrupted","corruption","scrambled","garbled","distorted","warped","static","noise","interference","pixelated","artifacting","tearing","haywire","fritzing","shorting out","going crazy","spazzing","unstable","erratic","unpredictable","flickering","stuttering","lagging","does not compute","syntax error","crash"]},bx={nervous:["nervous","nervously","anxious","anxiously","worried","worriedly","uneasy","uneasily","apprehensive","jittery","shaky","trembling","quivering","fidgety","restless","twitchy","tense","tensely","on edge","edgy","keyed up","wound up","uptight","self-conscious","awkward","awkwardly","hesitant","hesitantly","uncertain","uncertainly","sketchy","stressed","stressing","low-key panicking","kinda freaking out"],confident:["confident","confidently","confidence","assured","assuredly","certain","certainly","sure","surely","positive","positively","bold","boldly","brave","bravely","daring","daringly","fearless","fearlessly","strong","strongly","powerful","powerfully","firm","firmly","solid","solidly","authoritative","commanding","assertive","decisive","decisively","resolute","resolutely","poised","self-assured","unflappable","unfazed","owning it","killing it","crushing it","boss","like a boss"],tired:["tired","tiredly","tiredness","exhausted","weary","wearily","fatigued","drained","spent","depleted","sluggish","sluggishly","slow","slowly","lethargic","listless","languid","low energy","no energy","out of energy","running low","running on fumes","droopy","drooping","sagging","slumping","heavy","weighted","dragging","wiped","beat","dead","zonked","burned out","fried","cooked","toast"],intense:["intense","intensely","intensity","heightened","elevated","amplified","magnified","increased","enhanced","forceful","forcefully","powerful","powerfully","fierce","fiercely","strong","strongly","passionate","passionately","fervent","fervently","ardent","ardently","vehement","vehemently","sharp","sharply","acute","acutely","keen","keenly","piercing","piercingly","extreme","extremely","deeply","profoundly","tremendously","immensely","incredibly","super","mega","ultra","hella","mad","crazy"],subdued:["subdued","subduedly","soft","softly","gentle","gently","mild","mildly","light","lightly","restrained","held back","contained","tempered","moderated","toned down","quiet","quietly","hushed","muted","understated","subtle","subtly","modest","modestly","humble","humbly","reserved","demure","unassuming","faint","faintly","dim","dimly","pale","faded","washed out","low key","lowkey","easy","easy going"],clear:["clear","clearly","pure","purely","clean","cleanly","simple","simply","plain","plainly","direct","directly","straightforward","honest","honestly","frank","frankly","transparent","transparently","open","openly","obvious","obviously","evident","evidently","unmodified","unaltered","unchanged","normal","normally","regular","regularly","standard","basic","baseline"]},wx={breathe:["breathe","breathing","breath","inhale","inhaling","exhale","exhaling","sigh","sighing","respire","respiring","deep breath","deep breathing","slow breath","slow breathing","long breath","full breath","breathing deeply","breathing slowly","taking a breath","take a breath","catching breath","breath work","breathwork","inhale exhale","in and out","meditative breathing","calming breath","cleansing breath","relaxing breath","centering breath","mindful breathing"],expand:["expand","expanding","grow","growing","enlarge","enlarging","swell","swelling","bloat","bloating","getting bigger","growing larger","puffing up","expanding outward"],contract:["contract","contracting","shrink","shrinking","compress","compressing","reduce","reducing","getting smaller","shrinking down","pulling in","contracting inward"],pulse:["pulse","pulsing","pulsate","pulsating","throb","throbbing","beat","beating","pulsing gently","steady pulse","heartbeat","heart beat"],sway:["sway","swaying","swing","swinging","oscillate","oscillating","swaying gently","gentle sway","side to side","swaying motion"],float:["float","floating","hover","hovering","glide","gliding","levitate","levitating","weightless","weightlessness","buoyant","airy","floating gently","hovering in place","light as air","floating freely"],floatUp:["float up","floating up","floating upward","rise","rising","ascend","ascending","lift","lifting","lifted up","soar","soaring","going up"],floatDown:["float down","floating down","floating downward","descend","descending","sink","sinking","lower","lowering","going down"],floatLeft:["float left","floating left","drift left","drifting left"],floatRight:["float right","floating right","drift right","drifting right"],bob:["bob","bobbing","bobbing up and down","gentle bob"],lean:["lean","leaning","incline","inclining","leaning in","lean in","leaning forward","lean forward","leaning toward","lean toward","leaning closer","lean closer","moving closer","coming closer","drawing near","approaching","interested","intrigued","engaged","attentive","listening closely","paying attention"],leanLeft:["lean left","leaning left","tilt left","tilting left"],leanRight:["lean right","leaning right","tilt right","tilting right"],jitter:["jitter","jittering","jittery","stutter","stuttering","jittering around","slight jitter","nervous jitter"],twitch:["twitch","twitching","twitchy","spasm","spasming","flinch","flinching","quick twitch","nervous twitch","sudden movement"],vibrate:["vibrate","vibrating","vibration","buzz","buzzing","hum","humming","quiver","quivering","vibrating slightly","gentle buzz","low hum","subtle vibration"],shake:["shake","shaking","shaky","shudder","shuddering","tremble","trembling","quake","quaking","no","nope","nah","disagree","disagreeing","refuse","refusing","deny","denying","shaking head","shake head","head shake","saying no","shaking no"],wiggle:["wiggle","wiggling","wiggly","jiggle","jiggling","jiggly","squirm","squirming","wriggle","wriggling","wiggling around","little wiggle","happy wiggle","excited wiggle"],stepLeft:["step left","stepping left","sidestep left","move left","moving left","shift left"],stepRight:["step right","stepping right","sidestep right","move right","moving right","shift right"],stepUp:["step up","stepping up","step forward"],stepDown:["step down","stepping down","step back"],slideLeft:["slide left","sliding left","glide left"],slideRight:["slide right","sliding right","glide right"],runningman:["running man","runningman","running man dance","run in place","running in place"],charleston:["charleston","charleston dance","swing dance","kick step","kick and step"],hula:["hula","hula-ing","hip sway","swaying hips","circular sway","round motion","hula motion","hula dance"],twist:["twist","twisting","twisty","contort","contorting","do the twist","twisting dance","twisting around","getting twisted"],pop:["pop","popping","pop and lock","popping motion","hit","hitting"],flare:["flare","flaring","dramatic flare","flourish"],swell:["swell","swelling","surge","surging","crescendo"],swagger:["swagger","swaggering","strut","strutting","confident walk","cocky"],dip:["dip","dipping","drop","dropping down","low dip","dance dip"],bounce:["bounce","bouncing","bouncy","hop","hopping","hoppy","spring","springing","springy","boing","boinging","bouncing up and down","hopping around","spring in step","light on feet"],orbit:["orbit","orbiting","circle","circling","revolve","revolving","circling around","going around","rotating slowly","orbital motion"],orbitLeft:["orbit left","orbiting left","circle left","counter-clockwise","counterclockwise"],orbitRight:["orbit right","orbiting right","circle right","clockwise"],orbitUp:["orbit up","orbiting up","rising orbit","spiral up","spiraling up"],orbitDown:["orbit down","orbiting down","descending orbit","spiral down","spiraling down"],sparkle:["sparkle","sparkling","sparkly","twinkle","twinkling","twinkly","glitter","glittering","glittery","shine","shining","shiny","celebrate","celebrating","celebration","celebratory","festive","party","partying","victory","triumphant","triumph","winning","success","successful","achievement","accomplished","nailed it","slay","slaying","killing it","yasss","yay","woo","woohoo"],shimmer:["shimmer","shimmering","shimmery","glisten","glistening","gleam","gleaming","lustrous","luminous","soft shimmer","gentle gleam","shimmering light","pearlescent"],groove:["groove","grooving","groovy","dance","dancing","boogie","boogying","funk","funky","rhythmic","moving to music","feeling the music","in the groove","getting down","busting a move","doing a little dance"],jump:["jump","jumping","jumpy","leap","leaping","bound","bounding","jumping up","leap up","spring up","jumping for joy"],jumpDown:["jump down","jumping down","drop down"],jumpLeft:["jump left","jumping left","leap left"],jumpRight:["jump right","jumping right","leap right"],lunge:["lunge","lunging","thrust","thrusting","charge forward","aggressive step"],lungeForward:["lunge forward","lunging forward","thrust forward"],lungeBack:["lunge back","lunging back","retreat lunge"],rushForward:["rush forward","rushing forward","dash forward","sprint","sprinting","charge","charging"],rushBack:["rush back","rushing back","dash back","retreat quickly"],spin:["spin","spinning","twirl","twirling","whirl","whirling","rotate","rotating","turn","turning","spinning around","quick spin","full rotation","twirling around"],spinLeft:["spin left","spinning left","turn left","rotate left","counter-clockwise spin"],spinRight:["spin right","spinning right","turn right","rotate right","clockwise spin"],flip:["flip","flipping","somersault","somersaulting","front flip","frontflip"],backflip:["backflip","back flip","backflipping","back somersault","flip backward"],point:["point","pointing","indicate","indicating","gesture","gesturing","direct","directing","pointing at","pointing to","pointing toward","gesturing toward","showing","directing attention"],pointUp:["point up","pointing up","pointing upward","look up","look to the sky"],pointDown:["point down","pointing down","pointing downward","look down","look at this"],pointLeft:["point left","pointing left","gesture left"],pointRight:["point right","pointing right","gesture right"],kickLeft:["kick left","kicking left","left kick"],kickRight:["kick right","kicking right","right kick"],bow:["bow","bowing","curtsy","curtseying","reverence","showing respect","take a bow","bow down"],nod:["nod","nodding","yes","yeah","yep","yup","agree","agreeing","acknowledge","acknowledging","confirm","confirming","accept","accepting","approve","approving","understand","understanding","got it","gotcha","i see","makes sense","understood","nodding head","nod head","head nod","nodding along","nodding yes"],reach:["reach","reaching","extend","extending","reaching out","reach out","reaching toward","reach toward","extending toward","offer","offering","present","presenting","give","giving","help","helping"],headBob:["headbob","head bob","headbobbing","head bobbing","nodding to beat","nodding to music","bobbing along","bobbing to rhythm","vibing","jamming","bobbing head","bob head","feeling the beat","moving to music"],wave:["wave","waving","greet","greeting","hello","hi","hey","goodbye","bye","farewell","welcome","welcoming","waving hello","waving goodbye","friendly wave","waving hand"],crouch:["crouch","crouching","squat","squatting","hunker","hunkering","duck","ducking","get low","getting low"],tilt:["tilt","tilting","tilted","angle","angling","angled","cock","cocking","cocked","tilting head","tilt head","cocking head","curious tilt","angling sideways","head tilt"],tiltUp:["tilt up","tilting up","look up","looking up"],tiltDown:["tilt down","tilting down","look down","looking down"],tiltLeft:["tilt left","tilting left","head tilt left"],tiltRight:["tilt right","tilting right","head tilt right"],recoil:["recoil","recoiling","flinch","flinching","wince","wincing","pull back","pulling back","jerk back","snap back"],knockdown:["knockdown","knock down","knocked down","fall","falling","fell","topple","toppling","take a hit","got hit"],knockout:["knockout","knock out","knocked out","KO","ko'd","lights out","out cold"],squash:["squash","squashing","squashed","flatten","flattening","flattened","compress","compressed","smoosh","smooshed"],stretch:["stretch","stretching","stretchy","elongate","elongating","lengthen","lengthening","stretching out","big stretch","reaching up","stretching tall"],inflate:["inflate","inflating","inflated","puff up","puffing up","puffed up","balloon","ballooning"],deflate:["deflate","deflating","deflated","let air out","losing air","shrivel","shriveling"],pancake:["pancake","pancaked","pancaking","flatten completely","totally flat","squished flat","smooshed flat"],rage:["rage","raging","furious","fury","angry","anger","mad","livid","enraged","seeing red","lose temper","losing it"],fury:["fury","furious","quick anger","flash of anger","snap","snapping"],battlecry:["battlecry","battle cry","war cry","roar","yell","yelling","scream","screaming","rallying cry"],charge:["charge","charging","rush","rushing","attack","attacking","assault","advance"],wobble:["wobble","wobbling","wobbly","unstable","unsteady","drunk","dizzy","off balance","losing balance"],teeter:["teeter","teetering","totter","tottering","about to fall","precarious","on edge","unbalanced"],rock:["rock","rocking","soothing rock","gentle rocking","back and forth","rocking motion"],pendulum:["pendulum","pendulum motion","swing back and forth","swinging","hypnotic swing","metronome"],shatter:["shatter","shattering","shattered","break","breaking","broken","smash","smashing","smashed","fragment","fragmenting","explode into pieces","break apart"],shatterExplosive:["explosive shatter","explode","exploding","blow up","blowing up","detonate","detonating","big explosion","kaboom"],shatterCrumble:["crumble","crumbling","fall apart","falling apart","disintegrate","disintegrating","collapse","collapsing"],dissolveUp:["dissolve up","dissolving up","evaporate","evaporating","fade up","rising dust"],dissolveDown:["dissolve down","dissolving down","melt","melting","drip away","dripping"],dissolveAway:["dissolve away","dissolving away","blow away","scatter in wind","dust in wind","fade to dust"],morph:["morph","morphing","transform","transforming","shape shift","shapeshifting","change form","metamorphose"],rain:["rain","raining","shower","showering","drip","dripping","pour","pouring","raining down","particles falling","gentle rain","shower of particles"],drift:["drift","drifting","waft","wafting","float gently","gentle drift"],driftUp:["drift up","drifting up","rising mist","float upward","waft up"],driftDown:["drift down","drifting down","settling dust","float downward","waft down"],vortex:["vortex","whirlpool","tornado","cyclone","maelstrom","spinning vortex","swirling"],cascadeDown:["cascade","cascading","cascade down","waterfall","falling water","pour down","flow down"],confetti:["confetti","throw confetti","celebration particles","party confetti","ticker tape","streamers"],fizz:["fizz","fizzing","fizzy","bubble","bubbling","bubbly","effervescent","carbonated","sparkling bubbles"],burst:["burst","bursting","erupt","erupting","eruption","boom","booming","bursting out","burst of energy","explosive burst","big burst"],burstUp:["burst up","bursting up","fountain","geyser","erupting up"],ripple:["ripple","rippling","wave effect","ripple effect","water ripple","spreading rings"],flash:["flash","flashing","flashy","blink","blinking","strobe","strobing","quick flash","bright flash","flashing light","strobing light"],glow:["glow","glowing","glowy","radiate","radiating","emanate","emanating","luminescent","bright","brighten","brightening","soft glow","warm glow","inner glow","glowing warmly","lighting up","lit up"],bloom:["bloom","blooming","blossom","blossoming","flower","flowering","unfold","unfolding","light bloom","lens bloom"],flicker:["flicker","flickering","flickery","flutter","fluttering","waver","wavering","guttering","flickering light","unsteady light","wavering glow","candle-like"],shiver:["shiver","shivering","chill","chilly","cold","freezing","brr","brrr"],heartbeat:["heartbeat","heart beat","pulse of life","living pulse","thump thump","ba-dum"],snap:["snap","snapping","click","clicking","quick snap","finger snap"],elasticBounce:["elastic bounce","rubbery bounce","springy","bouncy elastic","rubber band","spring back"],hold:["hold","holding","pause","pausing","paused","freeze","freezing","frozen","still","stillness","stop","stopping","stopped","holding still","staying still","frozen in place","completely still","motionless","stationary"],fade:["fade","fading","dim","dimming","disappear","disappearing","vanish","vanishing","fading out","fading away","growing dim","becoming transparent"],settle:["settle","settling","settled","calm","calming","ground","grounding","grounded","center","centering","centered","anchor","anchoring","anchored","root","rooting","rooted","relax","relaxing","unwind","unwinding","decompress","decompressing","settling down","calming down","winding down","cooling down","coming to rest","finding peace"],peek:["peek","peeking","peer","peering","peep","peeping","glance","glancing","peeking out","peek out","looking shyly","shy glance","quick peek","sneaking a look"]},xx={circle:["circle","circular","round","rounded","orb","ball","sphere","spherical","ring","disc","disk","whole","complete","unity","unified","endless","infinite","continuous","full circle","perfect round","come full circle"],sphere:["sphere","spherical","globe","globular","ball","3d circle","three dimensional","round ball","floating sphere"],square:["square","squared","boxy","box","rectangle","rectangular","quadrilateral","cube","cubic","block","blocky","stable","solid","grounded","sturdy","rigid","firm","structured","four sided","four corners","box shape"],triangle:["triangle","triangular","tri","pyramid","pyramidal","delta","wedge","arrow","arrowhead","pointed","sharp","dynamic","directional","ascending","three sided","three pointed","pointing up"],heart:["heart","hearted","hearts","love","loving","lovely","valentine","romantic","affection","affectionate","caring","care","tender","warmth","warm-hearted","heartfelt","compassion","compassionate","devotion","devoted","luv","wuv","<3","","","","full of love","with love","heart shape","heart shaped","from the heart"],suspicion:["suspicion","suspicious","suspect","sly","slyly","sneaky","sneakily","mischievous","mischief","smirk","smirking","smirky","grin","grinning","sly grin","side eye","sideeye","side-eye","skeptical","skepticism","doubtful","doubt","doubting","wary","distrustful","distrust","sus","sussy","sussy baka","hmm","hmmm","hmmmm","shady","fishy","sketchy","not buying it","something fishy","seems off","up to something"],star:["star","starred","starry","stars","stellar","astral","twinkle","twinkling","achievement","achieved","excellence","excellent","gold star","five star","superstar","rockstar","rock star","wonder","wonderful","wondrous","magical","magic","miraculous","amazing","spectacular","reach for stars","seeing stars","star shape","shining star"],sun:["sun","sunny","sunshine","sunlight","solar","sol","daylight","daytime","day","radiant","radiance","radiating","bright","brightness","brilliant","glowing","glow","blazing","blaze","warm","warmth","cheerful","cheery","optimistic","optimism","hopeful","hope","positive","positivity","full of light","ray of sunshine","like the sun","sunny disposition"],moon:["moon","moony","moonlight","moonlit","lunar","crescent","nighttime","night","nocturnal","waxing","waning","gibbous","new moon","full moon","half moon","quarter moon","crescent moon","dreamy","dreamlike","dream","mysterious","mystery","mystical","ethereal","otherworldly","serene","serenity","tranquil","contemplative","reflective","moonlit night","by moonlight","moon shape","under the moon"],lunar:["lunar eclipse","blood moon","blood-moon","red moon","copper moon","rust moon","eclipsing","eclipsed","shadow crossing","earth shadow","ominous","foreboding","portentous","dramatic","intense","transforming","transformation","moon in shadow","moon turning red","eclipse phase","lunar event"],solar:["solar eclipse","total eclipse","corona","diamond ring","totality","umbra","penumbra","ring of fire","dark sun","blocked sun","occluded","awe","awesome","awe-inspiring","rare","momentous","historic","breathtaking","magnificent","sun blocked","sun covered","total darkness","corona visible"],eclipse:["eclipse","eclipsing","eclipsed","celestial event","astronomical event","overshadow","overshadowed","blocked","blocking","obscured","hidden","hiding","concealed","passing","crossing","alignment","in eclipse","going dark","being eclipsed","eclipsed by"]},Sx={intensity:{barely:["barely","hardly","scarcely","faintly","slightly","marginally","just a bit","just a little","just barely","hint of","touch of","trace of"],slightly:["slightly","somewhat","a little","a bit","mildly","lightly","kind of","kinda","sort of","sorta","a tad","a touch","a smidge"],moderately:["moderately","reasonably","fairly","pretty","rather","quite"],normal:["normal","normally","regular","regularly","standard","typical","typically","average","ordinary"],notably:["notably","noticeably","clearly","definitely","certainly","decidedly","genuinely","truly","really"],very:["very","really","so","such","quite","highly","deeply","seriously","majorly","hella","super","extra","mad"],extremely:["extremely","incredibly","immensely","tremendously","enormously","hugely","intensely","fiercely","wildly","insanely","crazy","ridiculously","mega","ultra","hyper"],absolutely:["absolutely","completely","totally","utterly","entirely","wholly","fully","maximum","max","over the top","off the charts","through the roof","to the max"]},duration:{flash:["flash","instant","instantaneous","split second","split-second","momentary","fleeting","brief flash"],quick:["quick","quickly","fast","rapid","swift","swiftly","brief","briefly","short","shortly","snap"],normal:["normal","regular","standard","typical","usual"],slow:["slow","slowly","gradual","gradually","gentle","gently","easy","easily","leisurely","unhurried"],long:["long","prolonged","extended","sustained","lasting","lingering","drawn out","drawn-out"],persistent:["persistent","constant","continuous","ongoing","steady","maintained","held","holding","stay","staying","keep","keeping","remain","remaining"]},transition:{instant:["instant","instantly","immediate","immediately","sudden","suddenly","abrupt","abruptly","snap","cut","jump"],snappy:["snappy","crisp","sharp","sharply","brisk","briskly","punchy"],smooth:["smooth","smoothly","natural","naturally","fluid","fluidly","flowing"],gentle:["gentle","gently","soft","softly","gradual","gradually","easing","gliding","drifting"],dreamy:["dreamy","dreamlike","floaty","ethereal","languid","lazy","flowing","melting"]},repetition:{once:["once","one time","single","just once","only once","one shot"],few:["few","few times","couple","couple times","twice","two times","thrice","three times"],several:["several","several times","multiple","multiple times","repeatedly","again and again"],many:["many","many times","lots","lots of times","over and over","nonstop"],loop:["loop","looping","looped","continuous","continuously","forever","infinitely","endlessly","always","keep going","on repeat"]}},Mx={barely:{min:.1,max:.2,default:.15},slightly:{min:.2,max:.4,default:.3},moderately:{min:.4,max:.5,default:.45},normal:{min:.5,max:.6,default:.55},notably:{min:.6,max:.7,default:.65},very:{min:.7,max:.85,default:.8},extremely:{min:.85,max:.95,default:.9},absolutely:{min:.95,max:1,default:1}},_x={flash:{min:100,max:500,default:250},quick:{min:500,max:1e3,default:750},normal:{min:1e3,max:2e3,default:1500},slow:{min:2e3,max:4e3,default:3e3},long:{min:4e3,max:8e3,default:6e3},persistent:{min:8e3,max:1/0,default:1e4}};function Ax(e){const t=new Map;for(const[n,a]of Object.entries(e)){for(const e of a){const a=e.toLowerCase().trim();t.set(a,n)}t.set(n.toLowerCase(),n)}return t}class Cx{constructor(){this.emotionLookup=Ax(vx),this.undertoneLookup=Ax(bx),this.gestureLookup=Ax(wx),this.shapeLookup=Ax(xx),this.modifierLookup=function(e){const t=new Map;for(const[n,a]of Object.entries(e))for(const[e,i]of Object.entries(a))for(const a of i){const i=a.toLowerCase().trim();t.set(i,{type:n,level:e})}return t}(Sx)}parse(e){const t={emotion:null,undertone:"clear",gestures:[],shape:null,intensity:Mx.normal.default,duration:_x.normal.default,transition:"smooth",repetition:"once",unrecognized:[],raw:e};if(!e||"string"!=typeof e)return t;const{tokens:n}=function(e){if(!e||"string"!=typeof e)return{tokens:[],segments:[],phrases:new Map};const t=cx(e),{processed:n,phrases:a}=function(e){const t=new Map;let n=e,a=0;for(const e of rx){const i=cx(e);if(n.includes(i)){const e=`__PHRASE_${a}__`;n=n.replace(new RegExp(i.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"g"),e),t.set(e,i),a++}}return{processed:n,phrases:t}}(t),i=n.split(sx).map(e=>e.trim()).filter(e=>e.length>0),r=[],s=[];for(const e of i){let t=e;for(const[e,n]of a)t=t.replace(e,n);s.push(t.trim());const n=e.split(/\s+/);for(const e of n){if(a.has(e)){r.push(a.get(e));continue}if(!e)continue;if(ox.has(e)&&!lx.has(e))continue;const t=e.replace(/^[^\w]+|[^\w]+$/g,"");t&&r.push(t)}}return{tokens:r,segments:s,phrases:a}}(e);if(0===n.length)return t;let a=!1;for(let e=0;e<n.length;e++){const i=n[e];if(!hx(i))if(dx(i))a=!0;else if(a)a=!1;else{if(yx(i)){const a=gx(i,n,e,t);if(a){this._applyResolution(t,a);continue}}this._tryEmotion(i,t)||this._tryGesture(i,t)||this._tryShape(i,t)||this._tryUndertone(i,t)||this._tryModifier(i,t)||t.unrecognized.push(i)}}return t}_applyResolution(e,t){const{category:n,target:a}=t;switch(n){case"emotion":e.emotion||(e.emotion=a);break;case"undertone":"clear"===e.undertone&&(e.undertone=a);break;case"gesture":e.gestures.includes(a)||e.gestures.push(a);break;case"shape":e.shape||(e.shape=a)}}_tryEmotion(e,t){const n=this.emotionLookup.get(e);return!(!n||t.emotion||(t.emotion=n,0))}_tryGesture(e,t){const n=this.gestureLookup.get(e);return!(!n||t.gestures.includes(n)||(t.gestures.push(n),0))}_tryShape(e,t){const n=this.shapeLookup.get(e);return!(!n||t.shape||(t.shape=n,0))}_tryUndertone(e,t){const n=this.undertoneLookup.get(e);return!(!n||"clear"!==t.undertone||(t.undertone=n,0))}_tryModifier(e,t){const n=this.modifierLookup.get(e);if(n){const{type:e,level:a}=n;switch(e){case"intensity":t.intensity=Mx[a]?.default||t.intensity;break;case"duration":t.duration=_x[a]?.default||t.duration;break;case"transition":t.transition=a;break;case"repetition":t.repetition=a}return!0}return!1}validate(e){const t=[];return e.emotion||0!==e.gestures.length||e.shape||t.push("No actionable intent found (need emotion, gesture, or shape)"),(e.intensity<0||e.intensity>1)&&t.push(`Intensity ${e.intensity} out of range [0, 1]`),e.duration<=0&&t.push(`Duration ${e.duration} must be positive`),{valid:0===t.length,errors:t}}static getAvailableEmotions(){return Object.keys(vx)}static getAvailableUndertones(){return Object.keys(bx)}static getAvailableGestures(){return Object.keys(wx)}static getAvailableShapes(){return Object.keys(xx)}}class Tx{constructor(){this.minBPM=60,this.maxBPM=180,this.lastPeakTime=0,this.peakCount=0,this.intervals=[],this.maxIntervals=40,this.bpmVotes=new Map,this.currentBPM=0,this.lockedBPM=0,this.confidence=0,this.isActive=!1,this.lockStage=0,this.stage1LockTime=0,this.stage2CorrectionApplied=!1,this.correctionType="none",this._recentSubdivisionChecks=[],this._stage3StartTime=0,this._stage3StableTime=0,this._memoryCleanedUp=!1,this._microTuneBPM=0,this.grooveConfidence=.15,this._grooveConfidenceTarget=.15,this._lastLogTime=0,this._logIntervalMs=2e3,this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0,this._logBuffer=[],this._maxLogEntries=20}processPeak(e,t=performance.now()){if(this.isActive=!0,this.peakCount++,e<.1)this._skippedPeaks++;else{if(this.lastPeakTime>0){const e=t-this.lastPeakTime;e>=250&&e<=2e3?(this.intervals.push(e),this._recentIntervals.push(Math.round(e)),this.intervals.length>this.maxIntervals&&this.intervals.shift(),this.voteForInterval(e)):this._skippedIntervals++}this.lastPeakTime=t,this.updateBPM(),this._debugLog(t)}}voteForInterval(e){const t=6e4/e;this._recentRawBPMs.push(Math.round(t));let n=t;const a=.95*this.minBPM,i=1.05*this.maxBPM;if(n<a)for(;n<this.minBPM;)n*=2;else if(n>i)for(;n>this.maxBPM;)n/=2;n=Math.max(this.minBPM,Math.min(this.maxBPM,n)),this._recentNormalizedBPMs.push(Math.round(n));const r=Math.round(n);for(let e=-2;e<=2;e++){const t=r+e;if(t>=this.minBPM&&t<=this.maxBPM){const n=Math.exp(-e*e/2),a=this.bpmVotes.get(t)||0;this.bpmVotes.set(t,a+n)}}for(const[e,t]of this.bpmVotes){const n=.95*t;n<.3?this.bpmVotes.delete(e):this.bpmVotes.set(e,n)}}updateBPM(){if(0===this.bpmVotes.size||this.intervals.length<3)return;const e=performance.now();let t=0,n=0,a=0;for(const[e,i]of this.bpmVotes)a+=i,i>n&&(n=i,t=e);if(0===t)return;let i=0;for(let e=-2;e<=2;e++){const n=t+e;i+=this.bpmVotes.get(n)||0}const r=i,s=Math.round(t/2);let o=0;if(s>=this.minBPM)for(let e=-2;e<=2;e++)o+=this.bpmVotes.get(s+e)||0;const l=2*t;let c=0;if(l<=this.maxBPM)for(let e=-2;e<=2;e++)c+=this.bpmVotes.get(l+e)||0;let h=0,d=0;const u=r>0?o/r:0;if(this.intervals.length>=6){const e=this.intervals.slice(-8),t=e.reduce((e,t)=>e+t,0)/e.length;let n=0;for(let a=0;a<e.length-1;a++)e[a]>t!=e[a+1]>t&&n++;h=n/(e.length-1);const a=[];for(let t=0;t<e.length-1;t+=2)a.push(e[t]+e[t+1]);if(a.length>=2){const e=a.reduce((e,t)=>e+t,0)/a.length;d=a.reduce((t,n)=>t+Math.abs(n-e),0)/a.length/e}}this.confidence=a>0?r/a:0;let p=0;if(this.intervals.length>=4){const e=6e4/t,n=e/2,a=this.intervals.slice(-8);let i=0;for(const t of a){const a=Math.abs(t-e)/e<.15,r=Math.abs(t-n)/n<.15,s=Math.abs(t-2*e)/(2*e)<.15;(a||r||s)&&i++}p=i/a.length}if(0===this.currentBPM)this.currentBPM=t;else{const e=this.intervals.length<6?.5:.3;this.currentBPM=this.currentBPM*(1-e)+t*e}if(0===this.lockStage){this._lastLockCheck={intervalCount:this.intervals.length,bestVotes:n.toFixed(1),clusterVotes:r.toFixed(1),confidence:`${(100*this.confidence).toFixed(0)}%`,consistency:`${(100*p).toFixed(0)}%`,bestBPM:t,adjustedBPM:t,isSubdivision:!1,stage:0,failReasons:[]};const a=t>120?12:8,i=.2,s=.45;this.intervals.length<a&&this._lastLockCheck.failReasons.push(`intervals<${a}`),r<=5&&this._lastLockCheck.failReasons.push("votes<=5"),this.confidence<=i&&this._lastLockCheck.failReasons.push(`conf<=${(100*i).toFixed(0)}%`),p<=s&&this._lastLockCheck.failReasons.push(`consistency<=${(100*s).toFixed(0)}%`),this.intervals.length>=a&&r>5&&this.confidence>i&&p>s&&(this.lockedBPM=Math.round(this.currentBPM),this.lockStage=1,this.stage1LockTime=e)}if(1===this.lockStage||2===this.lockStage){this._recentSubdivisionChecks.push({alternatingScore:h,pairVariance:d,halfVoteRatio:u,time:e}),this._recentSubdivisionChecks.length>15&&this._recentSubdivisionChecks.shift();const n=this._recentSubdivisionChecks.filter(e=>e.alternatingScore>.7&&e.pairVariance<.1).length,a=this._recentSubdivisionChecks.reduce((e,t)=>e+t.alternatingScore,0)/this._recentSubdivisionChecks.length,i=this._recentSubdivisionChecks.reduce((e,t)=>e+t.pairVariance,0)/this._recentSubdivisionChecks.length,o=this._recentSubdivisionChecks.reduce((e,t)=>e+t.halfVoteRatio,0)/this._recentSubdivisionChecks.length,p=this.intervals.length>0?this.intervals.reduce((e,t)=>e+t,0)/this.intervals.length:0,m=r>0?c/r:0;let f=0,g=0;if(this.intervals.length>=8){const e=this.intervals.slice(-12),t=[...e].sort((e,t)=>e-t),n=t[Math.floor(t.length/2)],a=e.filter(e=>Math.abs(e-n)/n<.5);if(g=a.length,a.length>=6){const e=a.reduce((e,t)=>e+t,0)/a.length;f=a.reduce((t,n)=>t+Math.abs(n-e),0)/a.length/e}}if(this._lastLockCheck={intervalCount:this.intervals.length,bestBPM:t,adjustedBPM:this.lockedBPM,halfBPM:s,stage:this.lockStage,subdivisionChecks:this._recentSubdivisionChecks.length,positiveChecks:n,avgAltScore:`${(100*a).toFixed(0)}%`,avgPairVar:`${(100*i).toFixed(1)}%`,avgHalfRatio:`${(100*o).toFixed(0)}%`,intervalVariance:`${(100*f).toFixed(1)}%`,filteredCount:g,correctionApplied:this.stage2CorrectionApplied,failReasons:[]},!this.stage2CorrectionApplied&&this._recentSubdivisionChecks.length>=10&&s>=this.minBPM){const e=n>=7&&a>.7&&i<.1&&this.lockedBPM>100,t=o>.4&&this.lockedBPM>150&&s>=65&&s<=85;let r=0,l=0;if(this.intervals.length>=8){const e=this.intervals.slice(-12),t=[...e].sort((e,t)=>e-t),n=t[Math.floor(t.length/2)],a=e.filter(e=>Math.abs(e-n)/n<.5);if(l=a.length,a.length>=6){const e=a.reduce((e,t)=>e+t,0)/a.length;r=a.reduce((t,n)=>t+Math.abs(n-e),0)/a.length/e}}const c=this.lockedBPM>140&&s>=65&&s<=85&&l>=8&&r<.05;(e||t||c)&&(this.lockedBPM=Math.round(this.lockedBPM/2),this.lockStage=2,this.stage2CorrectionApplied=!0,this.correctionType="halved")}!this.stage2CorrectionApplied&&this._recentSubdivisionChecks.length>=10&&l<=this.maxBPM&&p>900&&m>.5&&this.lockedBPM<75&&(this.lockedBPM=Math.round(2*this.lockedBPM),this.lockStage=2,this.stage2CorrectionApplied=!0,this.correctionType="doubled");const y=e-this.stage1LockTime;1===this.lockStage&&this._recentSubdivisionChecks.length>=6&&(this.lockStage=2);const v=this._recentSubdivisionChecks.length>=12&&n<3,b=y>1e4;2===this.lockStage&&(this.stage2CorrectionApplied||v||b)&&(this.lockStage=3,this._stage3StartTime=e)}if(3===this.lockStage){const t=e-this._stage3StartTime,n=this.intervals.slice(-8);if(n.length>=4){const e=6e4/(n.reduce((e,t)=>e+t,0)/n.length);if(Math.abs(e-this.lockedBPM)/this.lockedBPM<.05){0===this._microTuneBPM&&(this._microTuneBPM=this.lockedBPM),this._microTuneBPM=.9*this._microTuneBPM+.1*e;const t=Math.round(this._microTuneBPM);t!==this.lockedBPM&&(this.lockedBPM=t),this._stage3StableTime+=100}else this._stage3StableTime=0}const a=(t>5e3||this._stage3StableTime>3e3)&&!this._memoryCleanedUp;a&&3===this.lockStage&&(this._performMemoryCleanup(),this._memoryCleanedUp=!0),this._lastLockCheck={stage:3,lockedBPM:this.lockedBPM,correctionType:this.correctionType,timeSinceStage3:`${(t/1e3).toFixed(1)}s`,stableTime:`${(this._stage3StableTime/1e3).toFixed(1)}s`,finalized:a,failReasons:[]}}this._updateGrooveConfidence()}_updateGrooveConfidence(){this._memoryCleanedUp?this._grooveConfidenceTarget=1:this._grooveConfidenceTarget=[.15,.4,.65,.85][this.lockStage]||.15;const e=this.grooveConfidence+.08*(this._grooveConfidenceTarget-this.grooveConfidence);e>this.grooveConfidence&&(this.grooveConfidence=e)}_performMemoryCleanup(){this.intervals.length>8&&(this.intervals=this.intervals.slice(-8)),this.bpmVotes.clear(),this._subdivisionHistory=[],this._recentSubdivisionChecks=[],this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[]}processFrame(e,t=performance.now()){}reset(){this.intervals=[],this.bpmVotes.clear(),this.lastPeakTime=0,this.peakCount=0,this.currentBPM=0,this.lockedBPM=0,this.confidence=0,this.isActive=!1,this.lockStage=0,this.stage1LockTime=0,this.stage2CorrectionApplied=!1,this.correctionType="none",this._recentSubdivisionChecks=[],this._stage3StartTime=0,this._stage3StableTime=0,this._memoryCleanedUp=!1,this._microTuneBPM=0,this.grooveConfidence=.15,this._grooveConfidenceTarget=.15,this._lastLogTime=0,this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0,this._logBuffer=[],this._lastLockCheck=null,this._subdivisionHistory=[]}getBPM(){return this.lockedBPM>0?this.lockedBPM:Math.round(this.currentBPM)||0}getSubdivision(){return 1}getStatus(){return{bpm:this.getBPM(),subdivision:1,confidence:this.confidence,locked:this.lockedBPM>0,lockStage:this.lockStage,correctionType:this.correctionType,finalized:this._memoryCleanedUp,grooveConfidence:this.grooveConfidence,agentCount:this.bpmVotes.size,peakCount:this.peakCount,histogramSize:this.bpmVotes.size,topAgents:this.getTopCandidates(5),intervalCount:this.intervals.length}}getTopCandidates(e=5){return[...this.bpmVotes.entries()].sort((e,t)=>t[1]-e[1]).slice(0,e).map(([e,t])=>({bpm:e,score:t.toFixed(1),interval:Math.round(6e4/e)}))}getTopIntervals(e=5){return this.getTopCandidates(e).map(e=>({interval:e.interval,bpm:e.bpm,weight:e.score}))}_debugLog(e){if(e-this._lastLogTime<this._logIntervalMs)return;if(this._lastLogTime=e,0===this._recentIntervals.length&&0===this._skippedPeaks)return;const t=[],n=["Detecting","Initial Lock","Refinement","Final Lock"][this.lockStage]||"Unknown";t.push(""),t.push(`Status: Stage ${this.lockStage} (${n}) | Current: ${Math.round(this.currentBPM)} BPM | Locked: ${this.lockedBPM||"-"}`),t.push(`Peaks: ${this.peakCount} total | ${this._skippedPeaks} skipped (weak) | ${this._skippedIntervals} intervals out-of-range`),this._recentIntervals.length>0&&t.push(`Recent intervals (ms): [${this._recentIntervals.join(", ")}]`),this._recentRawBPMs.length>0&&t.push(`Raw BPMs (before normalize): [${this._recentRawBPMs.join(", ")}]`),this._recentNormalizedBPMs.length>0&&t.push(`Normalized BPMs (60-180): [${this._recentNormalizedBPMs.join(", ")}]`);const a=this.getTopCandidates(5);if(a.length>0){const e=a.map(e=>`${e.bpm}(${e.score})`).join(", ");t.push(`Top candidates: ${e}`)}if(this._lastLockCheck){const e=this._lastLockCheck;0===e.stage?e.failReasons&&e.failReasons.length>0?t.push(`Stage 0: NOT locking - ${e.failReasons.join(", ")}`):t.push(`Stage 0: Ready to lock at ${e.bestBPM} BPM`):1===e.stage||2===e.stage?(t.push(`Stage ${e.stage}: Locked=${e.adjustedBPM} BPM | checks=${e.subdivisionChecks} positive=${e.positiveChecks}`),t.push(`  altScore=${e.avgAltScore} pairVar=${e.avgPairVar} halfRatio=${e.avgHalfRatio}`),e.correctionApplied&&t.push(`  Correction applied: ${this.correctionType}`)):3===e.stage&&(t.push(`Stage 3: Final=${e.lockedBPM} BPM | correction=${e.correctionType} | time=${e.timeSinceStage3} stable=${e.stableTime}`),e.finalized&&t.push("  FINALIZED - memory cleaned"))}if(this.intervals.length>=6){const e=this.intervals.slice(-8),n=e.reduce((e,t)=>e+t,0)/e.length,a=(e.reduce((e,t)=>e+Math.abs(t-n),0)/e.length/n*100).toFixed(1);let i=0;for(let t=0;t<e.length-1;t++)e[t]>n!=e[t+1]>n&&i++;const r=(i/(e.length-1)*100).toFixed(0);t.push(`Interval pattern: variance=${a}% alternating=${r}% (>70% triggers subdivision)`)}const i=[...this.intervals].map(e=>Math.round(e));if(i.length>0){const e=Math.min(...i),n=Math.max(...i),a=Math.round(i.reduce((e,t)=>e+t,0)/i.length);t.push(`Interval buffer (${i.length}/${this.maxIntervals}): min=${e}ms max=${n}ms avg=${a}ms (=${Math.round(6e4/a)} BPM)`)}t.push("");const r=(new Date).toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"});for(this._logBuffer.push({time:r,lines:t});this._logBuffer.length>this._maxLogEntries;)this._logBuffer.shift();this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0}getDebugLog(){if(0===this._logBuffer.length)return"No BPM debug logs yet. Play audio to generate logs.";let e="=== BPM Debug Log ===\n\n";for(const t of this._logBuffer){e+=`[${t.time}]\n`;for(const n of t.lines)e+=`${n}\n`;e+="\n"}return e}clearDebugLog(){this._logBuffer=[]}}class Px{constructor(e={}){this.options=e,this._audioContext=null,this._analyzerNode=null,this._analyzerConnected=!1,this._audioElement=null,this._audioSourceNode=null,this._connectedAudioElement=null,this._audioHandlers=null,this._decodedAudioBuffer=null,this._audioBufferDuration=null,this._analysisSourceNode=null,this._bufferAnalyzerNode=null,this._analysisGainNode=null,this._analysisStartTime=null,this._bpmDetector=null,this._bpmDetectionInterval=null,this._detectedBPM=0,this._bpmConfidence=0,this._bpmLocked=!1}async connectAudio(e){if(!e)return;this._audioElement=e,this._audioContext||(this._audioContext=new(window.AudioContext||window.webkitAudioContext)),"suspended"===this._audioContext.state&&await this._audioContext.resume(),this._analyzerNode||(this._analyzerNode=this._audioContext.createAnalyser(),this._analyzerNode.fftSize=256,this._analyzerNode.smoothingTimeConstant=.8);const t=e.src;if(t)try{const e=await fetch(t),n=await e.arrayBuffer(),a=await this._audioContext.decodeAudioData(n);this._decodedAudioBuffer=a,this._audioBufferDuration=a.duration}catch(e){console.warn("[Audio] Buffer decode failed, falling back to MediaElementSource:",e.message)}if(this._connectedAudioElement===e&&this._audioSourceNode)try{this._audioSourceNode.connect(this._analyzerNode)}catch{}else{if(this._audioSourceNode)try{this._audioSourceNode.disconnect()}catch{}try{this._audioSourceNode=this._audioContext.createMediaElementSource(e),this._audioSourceNode.connect(this._analyzerNode),this._connectedAudioElement=e}catch(e){console.error("[Audio] ERROR creating MediaElementSource:",e.message)}}this._analyzerConnected||(this._analyzerNode.connect(this._audioContext.destination),this._analyzerConnected=!0);const n=()=>{const t=this._detectedBPM||120;this.options.onRhythmStart?.(t,"straight"),this._decodedAudioBuffer&&!this._analysisSourceNode&&this._startBufferAnalysis(e.currentTime)},a=()=>{this.options.onRhythmStop?.(),this._stopBufferAnalysis()},i=()=>{this.options.onRhythmStop?.(),this._stopBufferAnalysis()},r=()=>{this._decodedAudioBuffer&&this._analysisSourceNode&&!e.paused&&(this._stopBufferAnalysis(),this._startBufferAnalysis(e.currentTime))};this._audioHandlers={onPlay:n,onPause:a,onEnded:i,onSeeked:r},e.addEventListener("play",n),e.addEventListener("pause",a),e.addEventListener("ended",i),e.addEventListener("seeked",r),e.paused||n(),this._decodedAudioBuffer&&!this._analysisSourceNode&&this._startBufferAnalysis(e.currentTime),this._startBPMDetectionWithValidation()}disconnectAudio(){if(this.options.onRhythmStop?.(),this._stopBufferAnalysis(),this._audioElement&&this._audioHandlers&&(this._audioElement.removeEventListener("play",this._audioHandlers.onPlay),this._audioElement.removeEventListener("pause",this._audioHandlers.onPause),this._audioElement.removeEventListener("ended",this._audioHandlers.onEnded),this._audioHandlers.onSeeked&&this._audioElement.removeEventListener("seeked",this._audioHandlers.onSeeked)),this._stopBPMDetection(),this._audioSourceNode)try{this._audioSourceNode.disconnect()}catch{}this._audioElement=null,this._audioHandlers=null,this._connectedAudioElement=null,this._audioSourceNode=null,this._decodedAudioBuffer=null,this._bufferAnalyzerNode=null}getAnalyzerNode(){return this._bufferAnalyzerNode||this._analyzerNode}getAudioContext(){return this._audioContext}isPlaying(){return this._audioElement&&!this._audioElement.paused}getBPMStatus(){return this._bpmDetector?this._bpmDetector.getStatus():{bpm:this._detectedBPM||120,subdivision:1,confidence:0,locked:!1,lockStage:0,correctionType:"none",finalized:!1,grooveConfidence:1,agentCount:0,peakCount:0,histogramSize:0,topAgents:[],intervalCount:0}}getBPMDebugLog(){return this._bpmDetector&&this._bpmDetector.getDebugLog?this._bpmDetector.getDebugLog():"No BPM detector active or debug log unavailable."}resetBPMDetection(e=null){this._bpmDetector&&this._bpmDetector.reset(e),this._bpmLocked=!1,this._bpmConfidence=0,this._detectedBPM=e||120}getDetectedBPM(){return this._detectedBPM}isBPMLocked(){return this._bpmLocked}_startBPMDetectionWithValidation(){let e=0;const t=()=>{e++,this._startBPMDetection(),setTimeout(()=>{this._validateAnalyzerWorking()||(e<3?(console.warn(`[BPM] Analyzer validation FAILED - rebuilding audio pipeline (attempt ${e+1})`),this._stopBPMDetection(),this._rebuildBufferAnalysis(),setTimeout(t,100)):console.error("[BPM] Analyzer validation FAILED after max retries - detection may not work"))},300)};t()}_validateAnalyzerWorking(){if(!this._bufferAnalyzerNode)return!1;const e=new Uint8Array(this._bufferAnalyzerNode.frequencyBinCount);let t=0,n=0;for(let a=0;a<10;a++){this._bufferAnalyzerNode.getByteFrequencyData(e),t=Math.max(t,Math.max(...e)),this._bufferAnalyzerNode.getByteTimeDomainData(e);const a=Math.min(...e),i=Math.max(...e);(a<115||i>141)&&n++}return!!(this._bpmDetector&&this._bpmDetector.peakCount>0)||n>0||t>5}_startBPMDetection(){this._bpmDetector||(this._bpmDetector=new Tx),this._bpmDetector.reset(),this._detectedBPM=0,this.options.onGrooveConfidenceChange?.(.15),this._bpmDetectionInterval&&(clearInterval(this._bpmDetectionInterval),this._bpmDetectionInterval=null);let e=null,t=0,n=0,a=0;const i=[];this._bpmDetectionInterval=setInterval(()=>{if(!this._audioElement||this._audioElement.paused)return;if(!this._bufferAnalyzerNode)return;const r=this._bufferAnalyzerNode.frequencyBinCount;e&&e.length===r||(e=new Uint8Array(r)),this._bufferAnalyzerNode.getByteFrequencyData(e);let s=0;for(let t=0;t<16;t++)s+=e[t];s/=16;let o=0;for(let t=0;t<r;t++)o+=e[t];o/=r;const l=new Uint8Array(r);this._bufferAnalyzerNode.getByteTimeDomainData(l);let c=0,h=255;for(let e=0;e<r;e++)c=Math.max(c,l[e]),h=Math.min(h,l[e]);const d=c-h,u=d-a;a=d;const p=Math.max(0,s-n);n=s,i.push(p),i.length>20&&i.shift();const m=i.reduce((e,t)=>e+t,0)/i.length*1.1+2,f=performance.now(),g=(d>40&&a<10||u>30)&&o>1;if((p>m||g)&&f-t>350){const e=g?Math.min(1,d/100):Math.min(1,p/50);this._bpmDetector.processPeak(e,f);const n=this._bpmDetector.getStatus();n.bpm>0&&(this._detectedBPM=n.bpm,this._bpmConfidence=n.confidence,this._bpmLocked=n.locked,n.locked&&this.options.onBPMChange?.(n.bpm),void 0!==n.grooveConfidence&&this.options.onGrooveConfidenceChange?.(n.grooveConfidence)),t=f}},10)}_stopBPMDetection(){this._bpmDetectionInterval&&(clearInterval(this._bpmDetectionInterval),this._bpmDetectionInterval=null),this._bpmLocked=!1,this._bpmConfidence=0}_rebuildBufferAnalysis(){if(this._stopBufferAnalysis(),this._analysisGainNode){try{this._analysisGainNode.disconnect()}catch{}this._analysisGainNode=null}this._bufferAnalyzerNode=null,this._decodedAudioBuffer&&this._audioElement&&this._startBufferAnalysis(this._audioElement.currentTime)}_startBufferAnalysis(e=0){if(!this._decodedAudioBuffer||!this._audioContext)return;const t=!this._bufferAnalyzerNode;this._bufferAnalyzerNode||(this._bufferAnalyzerNode=this._audioContext.createAnalyser(),this._bufferAnalyzerNode.fftSize=2048,this._bufferAnalyzerNode.smoothingTimeConstant=.1),this._analysisSourceNode=this._audioContext.createBufferSource(),this._analysisSourceNode.buffer=this._decodedAudioBuffer,this._analysisGainNode||(this._analysisGainNode=this._audioContext.createGain(),this._analysisGainNode.gain.value=.001,this._analysisGainNode.connect(this._audioContext.destination)),this._analysisSourceNode.connect(this._bufferAnalyzerNode),this._bufferAnalyzerNode.connect(this._analysisGainNode),this._analysisSourceNode.start(0,e),this._analysisStartTime=this._audioContext.currentTime-e,t&&this._bpmDetectionInterval&&(this._stopBPMDetection(),this._startBPMDetection())}_stopBufferAnalysis(){if(this._analysisSourceNode){try{this._analysisSourceNode.stop(),this._analysisSourceNode.disconnect()}catch{}this._analysisSourceNode=null}if(this._bufferAnalyzerNode){try{this._bufferAnalyzerNode.disconnect()}catch{}this._bufferAnalyzerNode=null}if(this._analysisGainNode)try{this._analysisGainNode.disconnect(),this._analysisGainNode.connect(this._audioContext.destination)}catch{}}destroy(){if(this.disconnectAudio(),this._audioContext){try{this._audioContext.close()}catch{}this._audioContext=null}this._analyzerNode=null,this._analyzerConnected=!1}}const Dx=["flash","glow","burst","flicker"],Ox={subtle:{single:["pop","bob","swell","nod","sway","tilt","floatUp"],combo:[]},moderate:{single:["pop","bob","dip","swagger","bounce","wiggle","headBob","lean","stepLeft","stepRight","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight"],combo:[["pop","bob"],["dip","swell"],["stepLeft","stepRight"],["leanLeft","leanRight"],["kickLeft","kickRight"]]},energetic:{single:["flare","swagger","dip","spin","spinLeft","spinRight","jump","twist","hula","stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight"],combo:[["flare","bob"],["pop","dip"],["swagger","flare"],["stepLeft","stepRight"],["slideLeft","slideRight"],["spinLeft","spinRight"],["kickLeft","kickRight"]]}},Ex=[{geometry:"crystal",variant:null},{geometry:"rough",variant:null},{geometry:"heart",variant:null},{geometry:"star",variant:null},{geometry:"moon",variant:{type:"phase",value:"full"}},{geometry:"moon",variant:{type:"phase",value:"waxing-gibbous"}},{geometry:"moon",variant:{type:"phase",value:"first-quarter"}},{geometry:"moon",variant:{type:"phase",value:"waxing-crescent"}},{geometry:"moon",variant:{type:"phase",value:"new"}},{geometry:"moon",variant:{type:"eclipse",value:"partial"}},{geometry:"moon",variant:{type:"eclipse",value:"total"}},{geometry:"sun",variant:null},{geometry:"sun",variant:{type:"eclipse",value:"annular"}},{geometry:"sun",variant:{type:"eclipse",value:"total"}}],Ix=["joy","excited","euphoria","surprise"],kx=["focused","love","calm","neutral"],Rx=["resting","calm","sadness"],zx=["anger","fear","suspicion","glitch","disgust"],Fx=["joy","excited","euphoria","surprise","focused","love","calm","neutral","resting","sadness","anger","fear","suspicion","glitch"],Bx=.55,Lx=.25,Nx=.5;class Vx{constructor(){this.rhythmAdapter=null,this.mascot=null,this.audioDeformer=null,this.enabled=!1,this.intensity=.5,this.currentGroove="groove1",this.lastGestureTime=0,this.lastGlowTime=0,this.lastFlashBar=-4,this.barCount=0,this.lastBarProgress=0,this._bassHistory=[],this._vocalHistory=[],this._historyLength=60,this._pendingGestures=[],this._gesturesThisBar=0,this._lastGestureBar=-1,this._lastMorphBar=-16,this._currentTarget={geometry:"crystal",variant:null},this._baseTarget={geometry:"crystal",variant:null},this._morphReturnTimeout=null,this._lastEmotionBar=-12,this._currentEmotion="neutral",this._baseEmotion="neutral",this._emotionReturnTimeout=null,this.config={gestureFrequencyBars:4,minGestureIntervalMs:800,comboProbability:{subtle:0,moderate:.1,energetic:.15},morphEnabled:!0,morphCooldownBars:16,morphEnergyThreshold:.5,morphReturnBars:8,emotionEnabled:!0,emotionCooldownBars:12,emotionReturnBars:16,emotionMatchEnergy:!0,dramaticEmotionProbability:.1,grooveSwitchBars:2,energySmoothing:.05,intensityAffectsFrequency:!0,intensityAffectsAmplitude:!0,glowEnabled:!0,maxGlowBoost:1.3,glowCooldownMs:800,autoEnableOnLock:!0}}setRhythmAdapter(e){this.rhythmAdapter=e}setMascot(e){if(this.mascot=e,e?.core3D?.geometryType){const t=e.core3D.geometryType;this._currentTarget={geometry:t,variant:null},this._baseTarget={geometry:t,variant:null}}e?.core3D?.emotion&&(this._currentEmotion=e.core3D.emotion,this._baseEmotion=e.core3D.emotion)}setAudioDeformer(e){this.audioDeformer=e}enable(){this.enabled=!0}disable(){this.enabled=!1}setIntensity(e){this.intensity=Math.max(0,Math.min(1,e))}getIntensity(){return this.intensity}update(e,t=null){if(!this.rhythmAdapter)return void console.warn("[DanceChoreographer] No rhythmAdapter!");if(this.config.autoEnableOnLock&&!this.enabled&&this.mascot){const e=this.mascot._bpmDetector;if(e){const t=e.getStatus();t?.finalized&&(this.enable(),this.setIntensity(1))}}if(!this.enabled)return;const n=t||this._getAudioData();this._updateEnergyHistory(n),this._detectBarTransition(),this._updateGroovePreset(),this._triggerGestures(n),this._considerMorph(n),this._considerEmotion(n)}_getAudioData(){return this.audioDeformer?{bass:this.audioDeformer.bassEnergy||0,vocal:this.audioDeformer.vocalPresence||0,flux:this.audioDeformer.transientStrength||0}:{bass:0,vocal:0,flux:0}}_updateEnergyHistory(e){for(this._bassHistory.push(e.bass),this._vocalHistory.push(e.vocal);this._bassHistory.length>this._historyLength;)this._bassHistory.shift();for(;this._vocalHistory.length>this._historyLength;)this._vocalHistory.shift()}_getSmoothedEnergy(e){return 0===e.length?0:e.reduce((e,t)=>e+t,0)/e.length}_detectBarTransition(){if(!this.rhythmAdapter)return;if(!this.rhythmAdapter?.isPlaying?.())return void(this.lastBarProgress=0);const e=this.rhythmAdapter.barProgress||0;e<this.lastBarProgress-.5&&(this.barCount++,this._gesturesThisBar=0),this.lastBarProgress=e}_updateGroovePreset(){if(!this.rhythmAdapter)return;const e=this._getSmoothedEnergy(this._bassHistory),t=this._getSmoothedEnergy(this._vocalHistory),n=this._detectGroovePreset(e,t);n!==this.currentGroove&&this._switchGroove(n)}_detectGroovePreset(e,t){const n=.5+.5*this.intensity;return e>Bx*n?"groove2":t>Nx*n&&e<1.5*Lx?"groove3":"groove1"}_switchGroove(e){this.rhythmAdapter&&cp[e]&&(this.rhythmAdapter.setGroove(e,{quantize:!0,bars:this.config.grooveSwitchBars}),this.currentGroove=e)}_triggerGestures(e){if(!this.mascot)return void console.warn("[DanceChoreographer] _triggerGestures: No mascot reference!");if(!this.rhythmAdapter?.isPlaying?.())return void(this._lastGestureBar=-1);const t=performance.now();if(t-this.lastGestureTime<this.config.minGestureIntervalMs)return;const n=this.config.intensityAffectsFrequency?Math.max(1,Math.round(this.config.gestureFrequencyBars/(.5+this.intensity))):this.config.gestureFrequencyBars;if(this.barCount%n!==0)return;if(this._lastGestureBar===this.barCount)return;const a=this._selectGestureType(e),i=this._selectGesture(a,e);i&&(this._executeGesture(i),this._lastGestureBar=this.barCount,this.lastGestureTime=t)}_selectGestureType(e){return"groove2"===this.currentGroove&&this.intensity>.85&&e.bass>.7&&Math.random()<.3?"climactic":e.flux>.6?"dynamics":"groove2"===this.currentGroove&&this.intensity>.6?"movement":"punctuation"}_selectGesture(e,t){let n="subtle";this.intensity>.7||"groove2"===this.currentGroove?n="energetic":this.intensity>.4&&(n="moderate");const a=Ox[n],i=this.config.comboProbability[n]||0;return a.combo.length>0&&Math.random()<i?a.combo[Math.floor(Math.random()*a.combo.length)]:a.single[Math.floor(Math.random()*a.single.length)]}_executeGesture(e){this.mascot&&e&&(Array.isArray(e)?e.forEach((e,t)=>{setTimeout(()=>{this._executeSingleGesture(e)},50*t)}):this._executeSingleGesture(e))}_executeSingleGesture(e){if(!this.mascot||!e)return;if(Dx.includes(e)){if(!this._canTriggerGlow())return;this.lastGlowTime=performance.now(),"flash"===e&&(this.lastFlashBar=this.barCount)}const t=this.config.intensityAffectsAmplitude?.5+.5*this.intensity:1;"function"==typeof this.mascot.gesture&&this.mascot.gesture(e,{scale:t})}_canTriggerGlow(){return!!this.config.glowEnabled&&!(performance.now()-this.lastGlowTime<this.config.glowCooldownMs||this.barCount-this.lastFlashBar<4)}_considerMorph(e){if(!this.config.morphEnabled||!this.mascot)return;if(!this.rhythmAdapter?.isPlaying?.())return;const t=this.barCount-this._lastMorphBar;if(t<this.config.morphCooldownBars)return;const n=this._getSmoothedEnergy(this._bassHistory);this._getSmoothedEnergy(this._vocalHistory);let a=!1,i="";void 0===this._previousGroove&&(this._previousGroove=this.currentGroove),this.currentGroove!==this._previousGroove&&(Math.random()<.4&&(a=!0,i="section_change"),this._previousGroove=this.currentGroove),!a&&"groove2"===this.currentGroove&&n>.7&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.05&&(a=!0,i="energy_peak"),this._lastMorphCheckBar=this.barCount),!a&&t>=16&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.25&&(a=!0,i="time_variety"),this._lastMorphCheckBar=this.barCount),!a&&this._lastMorphBar<0&&this.barCount>=8&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.15&&(a=!0,i="intro_variety"),this._lastMorphCheckBar=this.barCount),a&&this._triggerMorph(i)}_triggerMorph(e){if(!this.mascot)return;this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null);const t=(e,t)=>e.geometry===t.geometry&&(!e.variant&&!t.variant||!(!e.variant||!t.variant)&&e.variant.type===t.variant.type&&e.variant.value===t.variant.value),n=Ex.filter(e=>!t(e,this._currentTarget)&&!t(e,this._baseTarget)),a=n.length>0?n:Ex.filter(e=>!t(e,this._currentTarget));if(0===a.length)return;const i=a[Math.floor(Math.random()*a.length)];this._applyMorphTarget(i),this._currentTarget=i,this._lastMorphBar=this.barCount;const r=60/(this.rhythmAdapter?.getBPM?.()||120)*4*1e3,s=this.config.morphReturnBars*r;this._morphReturnTimeout=setTimeout(()=>{this._returnToBaseGeometry()},s)}_returnToBaseGeometry(){var e,t;this.mascot&&(this._morphReturnTimeout=null,e=this._currentTarget,t=this._baseTarget,e.geometry===t.geometry&&(!e.variant&&!t.variant||e.variant&&t.variant&&e.variant.type===t.variant.type&&e.variant.value===t.variant.value)||(this._applyMorphTarget(this._baseTarget),this._currentTarget={...this._baseTarget}))}_applyMorphTarget(e){const t=this.mascot?.core3D;t&&(t.geometryType!==e.geometry?("function"==typeof this.mascot.morphTo?this.mascot.morphTo(e.geometry):"function"==typeof this.mascot.setGeometry&&this.mascot.setGeometry(e.geometry),e.variant&&setTimeout(()=>{t.geometryType===e.geometry&&this._applyVariant(e.geometry,e.variant)},1200)):e.variant?this._applyVariant(e.geometry,e.variant):this._clearVariant(e.geometry))}_applyVariant(e,t){const n=this.mascot?.core3D;if(n)if(n.geometryType===e)if("moon"===e){if(!n.customMaterial?.uniforms?.shadowOffset)return void console.warn("[DanceChoreographer] Moon material not ready for phase/eclipse");"eclipse"===t.type?(Eu(n.customMaterial,"full"),"function"==typeof n.setMoonEclipse&&n.setMoonEclipse(t.value)):"phase"===t.type&&("function"==typeof n.setMoonEclipse&&n.setMoonEclipse("off"),Eu(n.customMaterial,t.value))}else"sun"===e&&"eclipse"===t.type&&"function"==typeof n.setSunShadow&&n.setSunShadow(t.value);else console.warn(`[DanceChoreographer] Skipping variant - expected ${e}, got ${n.geometryType}`)}_clearVariant(e){const t=this.mascot?.core3D;t&&t.geometryType===e&&("moon"===e?("function"==typeof t.setMoonEclipse&&t.setMoonEclipse("off"),t.customMaterial?.uniforms?.shadowOffset&&Eu(t.customMaterial,"full")):"sun"===e&&"function"==typeof t.setSunShadow&&t.setSunShadow("off"))}_getTargetLabel(e){return e.variant?`${e.geometry}:${e.variant.value}`:e.geometry}_considerEmotion(e){if(!this.config.emotionEnabled||!this.mascot)return;if(!this.rhythmAdapter?.isPlaying?.())return;const t=this.barCount-this._lastEmotionBar;if(t<this.config.emotionCooldownBars)return;const n=(this._getSmoothedEnergy(this._bassHistory)+this._getSmoothedEnergy(this._vocalHistory))/2;let a=!1,i="";void 0===this._prevGrooveForEmotion&&(this._prevGrooveForEmotion=this.currentGroove),this.currentGroove!==this._prevGrooveForEmotion&&(Math.random()<.6&&(a=!0,i="section_change"),this._prevGrooveForEmotion=this.currentGroove),!a&&"groove2"===this.currentGroove&&n>.6&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.15&&(a=!0,i="energy_peak"),this._lastEmotionCheckBar=this.barCount),!a&&"groove1"===this.currentGroove&&n<.25&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.1&&(a=!0,i="energy_low"),this._lastEmotionCheckBar=this.barCount),!a&&t>=12&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.2&&(a=!0,i="time_variety"),this._lastEmotionCheckBar=this.barCount),a&&this._triggerEmotion(i,n)}_triggerEmotion(e,t){if(!this.mascot)return;let n;this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null),n=this.config.emotionMatchEnergy?t>.65&&Math.random()<this.config.dramaticEmotionProbability?zx:t>.55?Ix:t>.3?kx:Rx:Fx;const a=n.filter(e=>e!==this._currentEmotion);if(0===a.length)return;const i=a[Math.floor(Math.random()*a.length)];"function"==typeof this.mascot.setEmotion?this.mascot.setEmotion(i):this.mascot.core3D&&"function"==typeof this.mascot.core3D.setEmotion&&this.mascot.core3D.setEmotion(i),this._currentEmotion=i,this._lastEmotionBar=this.barCount;const r=60/(this.rhythmAdapter?.getBPM?.()||120)*4*1e3,s=this.config.emotionReturnBars*r;this._emotionReturnTimeout=setTimeout(()=>{this._returnToBaseEmotion()},s)}_returnToBaseEmotion(){this.mascot&&(this._emotionReturnTimeout=null,this._currentEmotion!==this._baseEmotion&&("function"==typeof this.mascot.setEmotion?this.mascot.setEmotion(this._baseEmotion):this.mascot.core3D&&"function"==typeof this.mascot.core3D.setEmotion&&this.mascot.core3D.setEmotion(this._baseEmotion),this._currentEmotion=this._baseEmotion))}setBaseEmotion(e){this._baseEmotion=e,this._currentEmotion=e}syncEmotionFromMascot(){this.mascot?.core3D?.emotion&&(this._currentEmotion=this.mascot.core3D.emotion)}getStatus(){return{enabled:this.enabled,intensity:this.intensity,currentGroove:this.currentGroove,currentTarget:this._getTargetLabel(this._currentTarget),baseTarget:this._getTargetLabel(this._baseTarget),currentEmotion:this._currentEmotion,baseEmotion:this._baseEmotion,barCount:this.barCount,avgBass:this._getSmoothedEnergy(this._bassHistory).toFixed(3),avgVocal:this._getSmoothedEnergy(this._vocalHistory).toFixed(3),lastGestureAgo:`${Math.round((performance.now()-this.lastGestureTime)/1e3)}s`,lastGlowAgo:`${Math.round((performance.now()-this.lastGlowTime)/1e3)}s`,lastMorphBar:this._lastMorphBar,barsSinceLastMorph:this.barCount-this._lastMorphBar,lastEmotionBar:this._lastEmotionBar,barsSinceLastEmotion:this.barCount-this._lastEmotionBar,canGlow:this._canTriggerGlow()}}setBaseGeometry(e,t=null){this._baseTarget={geometry:e,variant:t},this._currentTarget={geometry:e,variant:t}}syncGeometryFromMascot(){if(this.mascot?.core3D?.geometryType){const e=this.mascot.core3D.geometryType;this._currentTarget={geometry:e,variant:null}}}reset(){this.enabled=!1,this.currentGroove="groove1",this.barCount=0,this.lastBarProgress=0,this.lastGestureTime=0,this.lastGlowTime=0,this.lastFlashBar=-4,this._bassHistory=[],this._vocalHistory=[],this._gesturesThisBar=0,this._lastGestureBar=-1,this._lastMorphBar=-16;const e=this.mascot?.core3D?.geometryType||"crystal";this._currentTarget={geometry:e,variant:null},this._baseTarget={geometry:e,variant:null},this._previousGroove=void 0,this._lastMorphCheckBar=-1,this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null),this._lastEmotionBar=-12;const t=this.mascot?.core3D?.emotion||"neutral";this._currentEmotion=t,this._baseEmotion=t,this._prevGrooveForEmotion=void 0,this._lastEmotionCheckBar=-1,this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null)}destroy(){this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null),this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null),this.reset(),this.rhythmAdapter=null,this.mascot=null,this.audioDeformer=null}}class Ux{constructor(e,t){this._container=e,this._onResize=t,this._lastWidth=0,this._lastHeight=0,this._observer=null,this._start()}_start(){let e=!1;this._observer=new ResizeObserver(t=>{e||(e=!0,requestAnimationFrame(()=>{if(e=!1,!this._observer)return;const n=t[t.length-1],{width:a,height:i}=n.contentRect,r=Math.round(a),s=Math.round(i);r===this._lastWidth&&s===this._lastHeight||0!==r&&0!==s&&(this._lastWidth=r,this._lastHeight=s,this._onResize(r,s))}))}),this._observer.observe(this._container)}destroy(){this._observer&&(this._observer.disconnect(),this._observer=null),this._container=null,this._onResize=null}}function Gx(e=32,t=32){const n=[],a=[],i=[];for(let i=0;i<=t;i++){const r=i/t*Math.PI;for(let t=0;t<=e;t++){const i=t/e*Math.PI*2,s=Math.cos(i)*Math.sin(r),o=Math.cos(r),l=Math.sin(i)*Math.sin(r);n.push(s,o,l),a.push(s,o,l)}}for(let n=0;n<t;n++)for(let t=0;t<e;t++){const a=n*(e+1)+t,r=a+e+1,s=a+1,o=r+1;i.push(a,r,s),i.push(s,r,o)}return{vertices:new Float32Array(n),normals:new Float32Array(a),indices:new Uint16Array(i)}}function Wx(e=6){const t=[],n=[],a=[],i=new Map;let r=0;function s(e,a,s,o,l,c){const h=`${e},${a},${s}`;return i.has(h)||(t.push(e,a,s),n.push(o,l,c),i.set(h,r++)),i.get(h)}const o=s(0,1.5,0,0,1,0),l=[];for(let t=0;t<e;t++){const n=t/e*Math.PI*2,a=s(.7*Math.cos(n),0,.7*Math.sin(n),Math.cos(n),0,Math.sin(n));l.push(a)}const c=s(0,-1.5,0,0,-1,0);for(let t=0;t<e;t++){const n=(t+1)%e;a.push(o,l[t],l[n])}for(let t=0;t<e;t++){const n=(t+1)%e;a.push(l[t],c,l[n])}return{vertices:new Float32Array(t),normals:new Float32Array(n),indices:new Uint16Array(a)}}function qx(){const e=[],t=[],n=[],a=[0,1.2,0],i=[0,-.8,0],r=[];for(let e=0;e<8;e++){const t=e/8*Math.PI*2;r.push([.8*Math.cos(t),0,.8*Math.sin(t)])}function s(a,i,r){const s=[i[0]-a[0],i[1]-a[1],i[2]-a[2]],o=[r[0]-a[0],r[1]-a[1],r[2]-a[2]],l=s[1]*o[2]-s[2]*o[1],c=s[2]*o[0]-s[0]*o[2],h=s[0]*o[1]-s[1]*o[0],d=Math.sqrt(l*l+c*c+h*h),u=[l/d,c/d,h/d],p=e.length/3;e.push(...a),t.push(...u),e.push(...i),t.push(...u),e.push(...r),t.push(...u),n.push(p,p+1,p+2)}for(let e=0;e<8;e++){const t=(e+1)%8;s(a,r[e],r[t])}for(let e=0;e<8;e++){const t=(e+1)%8;s(r[e],i,r[t])}return{vertices:new Float32Array(e),normals:new Float32Array(t),indices:new Uint16Array(n)}}const Hx={geometries:["crystal","rough","heart","star","moon","sun"],sssPresets:["quartz","emerald","ruby","sapphire","amethyst"],emotions:["neutral","joy","sadness","anger","fear","surprise","disgust","love","suspicion","excited","resting","euphoria","focused","glitch","calm"],motionGestures:["bounce","pulse","shake","nod","vibrate","orbit","twitch","sway","float","jitter","wiggle","sparkle","shimmer","pop","bob","swell","swagger","dip","flare","headBob","lean","point","reach","stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight","floatUp","floatDown","floatLeft","floatRight","pointUp","pointDown","pointLeft","pointRight"],transformGestures:["spin","spinLeft","spinRight","jump","morph","stretch","tilt","orbital","hula","twist"],effectGestures:["wave","drift","flicker","burst","fade","breathe","expand","contract","flash","glow","settle","hold"]},jx='You are a dance choreographer for an animated 3D mascot. Interpret lyrics/mood and output movement commands.\n\n## PHILOSOPHY\n- Gestures are constant - always return at least one to keep the mascot alive\n- Emotions shift with lyrical sentiment - change when the overall mood shifts\n- Geometry transforms are DRAMATIC EVENTS - only for song structure changes (introverse, versechorus, chorusbridge)\n- SSS (material color) requires EXPLICIT visual imagery - don\'t infer colors from abstract concepts\n- Focus on the FEELING of the phrase, not literal word-by-word interpretation\n\n## VOCABULARY\n\n**Geometries** (STRICT: max 2 per song, only at structural moments):\n- crystal (default, neutral) - use for verses, calm sections\n- heart (love, romance) - ONLY when love/heart explicitly mentioned\n- star (dreams, hope) - ONLY for aspirational climax moments\n- moon (night, introspection) - ONLY when night/darkness is the theme\n- sun (energy, warmth) - ONLY for bright, warm imagery\n- rough (raw, edgy) - ONLY for intense/aggressive sections\n\n**SSS Presets** (ONLY with explicit visual imagery):\n- quartz (pure, light, glowing) - "glow", "shine", "light", "bright"\n- emerald (nature) - "green", "forest", "grow", "nature"\n- ruby (fire, passion) - "fire", "burn", "red", "flame"\n- sapphire (water, sky) - "ocean", "rain", "blue", "sky", "tears"\n- amethyst (mystical, dreams) - "stars", "dream", "magic", "purple"\n\nDO NOT use SSS for: abstract emotions, actions, or phrases without color/nature imagery.\n\n**Emotions**:\n- neutral, calm, resting (baseline)\n- joy, excited, euphoria (positive high energy)\n- love (romantic, tender)\n- sadness, fear (vulnerable, soft)\n- anger, disgust (intense, but use sparingly)\n- surprise (sudden shifts only)\n- focused, suspicion (tension, anticipation)\n\n**Gestures by Category**:\n- Base (ongoing): sway, float, bounce, swagger, pulse\n- Accent (momentary hit): pop, bob, swell, dip, flare, burst\n- Texture (layer on top): shimmer, sparkle, glow, breathe\n- Transform (dramatic): spin, spinLeft, spinRight, jump, shake, twist\n- Directional (beat-synced moves): stepLeft, stepRight, stepUp, stepDown, slideLeft, slideRight\n- Directional (lean/kick): leanLeft, leanRight, kickLeft, kickRight\n- Directional (storytelling): floatUp, floatDown, floatLeft, floatRight, pointUp, pointDown, pointLeft, pointRight\n\n## GESTURE CHAINING\n\n- Single: "gesture": "sway"\n- Layered (simultaneous): "gesture": ["sway", "shimmer"]\n- Sequential (accent then settle): "gesture": "pop", "then": "sway"\n\nPatterns:\n- Verse/narrative: base + texture  ["sway", "breathe"]\n- Beat accent: accent then base  "pop", then: "sway"\n- Chorus/hook: base + texture + energy  ["swagger", "sparkle"]\n- Climax/drop: transform then base  "burst", then: "swagger"\n\n## DECISION GUIDE\n\n| Content | Response |\n|---------|----------|\n| Emotional phrase | emotion + gesture |\n| Explicit visual imagery (colors, nature, light) | sss + gesture |\n| Action words (dance, move, jump) | gesture only |\n| Narrative/story | subtle base gesture |\n| High energy hook/chorus | layered gestures + emotion |\n| FIRST line of new song section | geometry + maybe sss |\n\n## EXAMPLES\n\n"Tell me who\'s got rhythm in their feet"  {"gesture":["bounce","pulse"],"emotion":"excited"}\n"Who\'s got a heartbeat loud"  {"gesture":"pulse","emotion":"excited"}\n"Moving in the light"  {"gesture":["sway","shimmer"]}\n"Hands up high"  {"gesture":"swell","emotion":"joy"}\n"Feet on fire"  {"gesture":"flare","then":"swagger","emotion":"euphoria","sss":"ruby"}\n"We glow"  {"gesture":["sway","glow"],"sss":"quartz"}\n"Electric flow"  {"gesture":["swagger","sparkle"],"emotion":"excited"}\n"You know"  {"gesture":"sway"}\n"The night\'s our own"  {"gesture":["float","shimmer"],"emotion":"calm"}\n"Turn it up loud"  {"gesture":"burst","then":"swagger","emotion":"euphoria"}\n"To the left"  {"gesture":"stepLeft"}\n"Slide to the right"  {"gesture":"slideRight"}\n"To the left, to the left"  {"gesture":["stepLeft","stepLeft"]}\n"Hands up high"  {"gesture":"stepUp","emotion":"joy"}\n"Drop it low"  {"gesture":"stepDown","emotion":"excited"}\n"Lean back"  {"gesture":"leanRight"}\n"Kick it out"  {"gesture":"kickLeft","emotion":"excited"}\n"Spin around"  {"gesture":"spinRight"}\n"Turn the other way"  {"gesture":"spinLeft"}\n"Look to the stars"  {"gesture":"pointUp","emotion":"anticipation"}\n"He sank into despair"  {"gesture":"floatDown","emotion":"sadness"}\n"She drifted away"  {"gesture":"floatRight","emotion":"calm"}\n"Point to the future"  {"gesture":"pointUp","emotion":"joy"}\n"[Intro]"  {"gesture":["floatUp","breathe"],"emotion":"calm"}\n"[Bridge/Outro]"  {"gesture":["floatUp","breathe"],"emotion":"calm","geometry":"crystal"}\n\nRULES:\n1. Always include gesture\n2. Use only listed vocabulary\n3. Geometry changes are RARE (max 2 per song) - only at section boundaries\n4. SSS requires EXPLICIT color/visual imagery - no inference\n5. Match emotion to overall phrase sentiment, not individual words\n6. JSON only';class Xx{constructor(e={}){this.apiKey=e.apiKey||null,this.endpoint=e.endpoint||null,this.model=e.model||null,this.onAction=e.onAction||null,this.onError=e.onError||null,this.enabled=!1,this.lastAction=null,this.lastInterpretTime=0,this.minIntervalMs=3e3,this.pendingRequest=null,this.currentState={geometry:null,sss:null,emotion:null},this.textBuffer=[],this.bufferTimeout=null}configure(e){e.apiKey&&(this.apiKey=e.apiKey.replace(/[^\x00-\x7F]/g,"").trim()),e.endpoint&&(this.endpoint=e.endpoint),e.model&&(this.model=e.model)}_isAnthropic(){return this.endpoint&&this.endpoint.includes("anthropic.com")}enable(){return this.apiKey&&this.endpoint?(this.enabled=!0,!0):(console.warn("[AudioInterpreter] Need API key and endpoint"),!1)}disable(){this.enabled=!1,this.bufferTimeout&&(clearTimeout(this.bufferTimeout),this.bufferTimeout=null)}updateCurrentState(e){e.geometry&&(this.currentState.geometry=e.geometry),e.sss&&(this.currentState.sss=e.sss),e.emotion&&(this.currentState.emotion=e.emotion)}feedText(e){this.enabled&&this.apiKey&&e&&0!==e.trim().length&&(this.textBuffer.push(e.trim()),this.bufferTimeout&&clearTimeout(this.bufferTimeout),this.bufferTimeout=setTimeout(()=>{this._processBuffer()},500))}async interpret(e){if(!this.enabled||!this.apiKey)return null;const t=Date.now();if(t-this.lastInterpretTime<this.minIntervalMs)return null;this.pendingRequest&&(this.pendingRequest=null),this.lastInterpretTime=t;try{const t=await this._callLLM(e);return t&&(this.lastAction=t,this._emitAction(t)),t}catch(e){return console.error("[AudioInterpreter] Error:",e),this.onError&&this.onError(e),null}}async _processBuffer(){if(0===this.textBuffer.length)return;const e=this.textBuffer.join(" ");this.textBuffer=[],await this.interpret(e)}async _callLLM(e){const t=Date.now();let n;if(this.pendingRequest=t,n=this._isAnthropic()?await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json","x-api-key":this.apiKey,"anthropic-version":"2023-06-01","anthropic-dangerous-direct-browser-access":"true"},body:JSON.stringify({model:this.model||"claude-3-haiku-20240307",max_tokens:100,system:jx,messages:[{role:"user",content:`Audio context: "${e}"`}]})}):await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.apiKey}`},body:JSON.stringify({model:this.model||"gpt-4o-mini",messages:[{role:"system",content:jx},{role:"user",content:`Audio context: "${e}"`}],max_tokens:100,temperature:.3})}),this.pendingRequest!==t)return null;if(!n.ok){const e=await n.json().catch(()=>({}));throw new Error(e.error?.message||`API error: ${n.status}`)}const a=await n.json();let i;if(this._isAnthropic()){const e=a.content?.find(e=>"text"===e.type);i=e?.text}else i=a.choices?.[0]?.message?.content;if(!i)return null;try{const e=JSON.parse(i.trim());return this._validateAction(e)}catch{const e=i.match(/\{[\s\S]*\}/);if(e)try{const t=JSON.parse(e[0]);return this._validateAction(t)}catch{return console.warn("[AudioInterpreter] Failed to parse:",i),null}return console.warn("[AudioInterpreter] Failed to parse:",i),null}}_validateAction(e){if(!e||"object"!=typeof e)return null;const t={};if(e.geometry&&Hx.geometries.includes(e.geometry)&&e.geometry!==this.currentState.geometry&&(t.geometry=e.geometry),e.sss&&Hx.sssPresets.includes(e.sss)){const n=t.geometry||this.currentState.geometry;["crystal","rough","heart","star"].includes(n)&&e.sss!==this.currentState.sss&&(t.sss=e.sss)}if(e.emotion&&Hx.emotions.includes(e.emotion)&&e.emotion!==this.currentState.emotion&&(t.emotion=e.emotion),e.gesture){const n=[...Hx.motionGestures,...Hx.transformGestures,...Hx.effectGestures];if(Array.isArray(e.gesture)){const a=e.gesture.filter(e=>n.includes(e));a.length>0&&(t.gesture=1===a.length?a[0]:a)}else n.includes(e.gesture)&&(t.gesture=e.gesture)}if(e.then){const n=[...Hx.motionGestures,...Hx.transformGestures,...Hx.effectGestures];if(Array.isArray(e.then)){const a=e.then.filter(e=>n.includes(e));a.length>0&&(t.then=1===a.length?a[0]:a)}else n.includes(e.then)&&(t.then=e.then)}return 0===Object.keys(t).length?null:t}_emitAction(e){e.geometry&&(this.currentState.geometry=e.geometry),e.sss&&(this.currentState.sss=e.sss),e.emotion&&(this.currentState.emotion=e.emotion),this.onAction&&this.onAction(e)}static getVocabulary(){return{...Hx}}}const Yx={anthropic:"https://api.anthropic.com/v1/messages",openai:"https://api.openai.com/v1/chat/completions",grok:"https://api.x.ai/v1/chat/completions"},$x=new Xx,Qx=["sphere","crystal","diamond","rough","heart","star","moon","sun"];class Kx{constructor(e={}){this.config={canvasId:e.canvasId||"emotive-canvas",coreGeometry:e.coreGeometry||"sphere",targetFPS:e.targetFPS||60,enableParticles:!1!==e.enableParticles,defaultEmotion:e.defaultEmotion||"neutral",...e},this._canvasLayerManager=null,this._resizeObserver=null,this.container=null,this.webglCanvas=null,this.canvas2D=null,this.core3D=null,this.particleSystem=null,this.danceChoreographer=null,this.isRunning=!1,this._destroyed=!1,this.animationFrameId=null,this.lastFrameTime=0,this.gestureTimeouts=[],this.eventManager=new Zw,this.eventManager.emit||(this.eventManager._listeners={},this.eventManager.emit=(e,t)=>{const n=this.eventManager._listeners[e];n&&n.forEach(e=>e(t))},this.eventManager.on=(e,t)=>{this.eventManager._listeners[e]||(this.eventManager._listeners[e]=[]),this.eventManager._listeners[e].push(t)},this.eventManager.off=(e,t)=>{const n=this.eventManager._listeners[e];if(n){const e=n.indexOf(t);e>-1&&n.splice(e,1)}}),this.errorBoundary=new Jw,this.emotion="neutral",this.undertone=null,this._intentParser=new Cx,this._feelRateLimiter={calls:new Array(10).fill(0),index:0,windowMs:1e3,maxCallsPerSecond:10},this._audioBridge=null,this._prefersReducedMotion="undefined"!=typeof window&&(window.matchMedia?.("(prefers-reduced-motion: reduce)").matches??!1),this._reducedMotionMediaQuery=null}prefersReducedMotion(){return this._prefersReducedMotion}setReducedMotion(e){return this._prefersReducedMotion=e,e&&this.disableAutoRotate(),this.eventManager.emit("accessibility:reducedMotion",{enabled:e}),this}_setupReducedMotionListener(){"undefined"!=typeof window&&window.matchMedia&&(this._reducedMotionMediaQuery=window.matchMedia("(prefers-reduced-motion: reduce)"),this._reducedMotionHandler=e=>{this._prefersReducedMotion=e.matches,this.setReducedMotion(e.matches)},this._reducedMotionMediaQuery.addEventListener?this._reducedMotionMediaQuery.addEventListener("change",this._reducedMotionHandler):this._reducedMotionMediaQuery.addListener&&this._reducedMotionMediaQuery.addListener(this._reducedMotionHandler))}_isDestroyed(){return this._destroyed||!this.eventManager||!this.eventManager._listeners}_getAudioBridge(){return this._audioBridge||(this._audioBridge=new Px({onRhythmStart:(e,t)=>this.startRhythm(e,t),onRhythmStop:()=>this.stopRhythm(),onBPMChange:e=>{this.isRhythmPlaying()&&this.setRhythmBPM(e)},onGrooveConfidenceChange:e=>{this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setGrooveConfidence(e)}})),this._audioBridge}init(e){if("undefined"==typeof window)throw new Error("EmotiveMascot3D.init() requires a browser environment. For SSR frameworks, use dynamic import with ssr:false (Next.js) or <ClientOnly> (Nuxt).");try{this._canvasLayerManager=new Kw({canvasId:this.config.canvasId,enableControls:this.config.enableControls});const t=this._canvasLayerManager.setup(e);if(this.container=t.container,this.webglCanvas=t.webglCanvas,this.canvas2D=t.canvas2D,this.core3D=new Qw(this.webglCanvas,{geometry:this.config.coreGeometry,emotion:this.config.defaultEmotion,enableParticles:this.config.enableParticles,enablePostProcessing:this.config.enablePostProcessing,enableShadows:this.config.enableShadows,enableControls:this.config.enableControls,enableShatter:this.config.enableShatter,autoRotate:this.config.autoRotate,enableBlinking:this.config.enableBlinking,enableBreathing:this.config.enableBreathing,cameraDistance:this.config.cameraDistance,fov:this.config.fov,minZoom:this.config.minZoom,maxZoom:this.config.maxZoom,materialVariant:this.config.materialVariant,assetBasePath:this.config.assetBasePath,preloadElements:this.config.preloadElements,backgroundPrewarm:this.config.backgroundPrewarm}),this.ctx2D=this.canvas2D.getContext("2d"),this.config.enableParticles&&!this.core3D?.particleOrchestrator){const e=this.config.maxParticles||300;this.particleSystem=new by(e,this.errorBoundary),this.particleSystem.canvasWidth=this.canvas2D.width,this.particleSystem.canvasHeight=this.canvas2D.height}return this._resizeObserver=new Ux(this.container,(e,t)=>{this._canvasLayerManager.resize(e,t),this.core3D.renderer.resize(e,t),this.particleSystem&&(this.particleSystem.canvasWidth=e,this.particleSystem.canvasHeight=t)}),this.danceChoreographer=new Vx,this.danceChoreographer.setRhythmAdapter(this.core3D?.rhythm3DAdapter),this.danceChoreographer.setMascot(this),this._setupReducedMotionListener(),this._prefersReducedMotion&&this.setReducedMotion(!0),this}catch(e){throw console.error("Failed to initialize 3D engine:",e),e}}async start(){this.isRunning||(this.core3D&&await this.core3D.waitUntilReady(),this.isRunning=!0,this.lastFrameTime=null,this.animationFrameId=requestAnimationFrame(this.animate.bind(this)))}stop(){this.isRunning=!1,this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null)}animate(e){if(!this.isRunning||this._destroyed)return;if(null===this.lastFrameTime)return this.lastFrameTime=e,void(this.animationFrameId=requestAnimationFrame(this.animate.bind(this)));const t=e-this.lastFrameTime,n=Math.min(t,100);this.lastFrameTime=e;const a=performance.now();if(this.core3D&&!this._destroyed&&(this.core3D.render(n),this._canvasLayerManager&&!this._canvasLayerManager.isCanvasAppended()&&this._canvasLayerManager.appendWebGLCanvas()),this.danceChoreographer&&!this._destroyed&&this.danceChoreographer.update(n/1e3),this.canvas2D&&this.ctx2D&&(this.ctx2D.clearRect(0,0,this.canvas2D.width,this.canvas2D.height),this.ctx2D.fillStyle="rgba(0,0,0,0)",this.ctx2D.fillRect(0,0,this.canvas2D.width,this.canvas2D.height),this.particleSystem)){const t=this.canvas2D.width/2,a=this.canvas2D.height/2,i=this.core3D?this.core3D.emotion:"neutral",r=np(i),s=this.core3D?this.rgbToHex(this.core3D.glowColor):"#FFFFFF",o=r?.visual?.particleBehavior||"ambient",l=r?.visual?.particleRate||15,c=r?.visual?.minParticles||5,h=r?.visual?.maxParticles||30,d=r?.visual?.particleColors||null;this.particleSystem.spawn(o,i,l,t,a,n,null,c,h,1,1,d,this.undertone);let u=null,p=0;if(this.currentGesture){const t=e-this.currentGesture.startTime;p=Math.min(t/this.currentGesture.duration,1),u={...this.currentGesture.config,type:this.currentGesture.name}}this.particleSystem.update(n,t,a,u,p,this.undertone),this.particleSystem.render(this.ctx2D,s,null)}if(this._frameBudgetScheduler){const e=performance.now()-a;this._frameBudgetScheduler.tick(e)}this.animationFrameId=requestAnimationFrame(e=>this.animate(e))}setEmotion(e,t,n){return this._isDestroyed()?this:e&&"string"==typeof e?(function(e){const t=tp[e]||e;return ep.has(t)||null!==Qu(t)}(e)||console.warn(`[EmotiveMascot3D] Unknown emotion "${e}". Valid emotions: ${rp().join(", ")}`),this.emotion=e,void 0!==t&&("string"==typeof t?this.undertone=t:"number"==typeof t||(t&&"object"==typeof t?this.undertone=t.undertone||null:null===t&&(this.undertone=null))),this.core3D&&this.core3D.setEmotion(e,this.undertone),this.particleSystem&&(this.particleSystem.particles=[]),this.eventManager.emit("emotion:change",{emotion:e,undertone:this.undertone}),this):(console.warn(`[EmotiveMascot3D] setEmotion: Invalid emotion "${e}". Use getAvailableEmotions() for valid options.`),this)}updateUndertone(e){return this._isDestroyed()||(this.undertone=e,this.core3D&&this.emotion&&this.core3D.setEmotion(this.emotion,e),this.eventManager.emit("undertone:change",{undertone:e})),this}setUndertone(e){return this.updateUndertone(e)}express(e){if(this._isDestroyed())return this;if(!e||"string"!=typeof e)return console.warn(`[EmotiveMascot3D] express: Invalid gesture "${e}". Use getAvailableGestures() for valid options.`),this;this.core3D&&this.core3D.playGesture(e);const t=py(e);if(t){const n=t.config||{},a=n.musicalDuration?.musical?500*(n.musicalDuration.beats||2):n.duration||800;this.currentGesture={name:e,gesture:t,config:n,startTime:performance.now(),duration:a};const i=setTimeout(()=>{this.currentGesture&&this.currentGesture.name===e&&(this.currentGesture=null)},a);this.gestureTimeouts.push(i)}else{const t=my().map(e=>e.name);console.warn(`[EmotiveMascot3D] Unknown gesture "${e}". Valid gestures: ${t.slice(0,10).join(", ")}...`)}return this.eventManager.emit("gesture:trigger",{gesture:e}),this}gesture(e,t={}){return this.express(e)}chain(e){const t=("string"==typeof e?{rise:"breathe > sway+lean+tilt",flow:"sway > lean+tilt > spin > bounce",burst:"jump > nod > shake > flash",drift:"sway+breathe+float+drift",chaos:"shake+shake > spin+flash > bounce+pulse > twist+sparkle",morph:"expand > contract > morph+glow > expand+flash",rhythm:"pulse > pulse+sparkle > pulse+flicker",spiral:"spin > orbital > twist > orbital+sparkle",routine:"nod > bounce > spin+sparkle > sway+pulse > nod+flash",radiance:"sparkle > pulse+flicker > shimmer",twinkle:"sparkle > flash > pulse+sparkle > shimmer+flicker",stream:"wave > nod+pulse > sparkle > flash"}[e]||e:e.join(">")).split(">").map(e=>e.trim().split("+").map(e=>e.trim()).filter(e=>e.length>0));this.executeChainSequence(t)}executeChainSequence(e){if(!e||0===e.length)return;let t=0;const n=()=>{if(!(t>=e.length)&&(e[t].forEach(e=>{this.express(e)}),t++,t<e.length)){const e=setTimeout(n,800);this.gestureTimeouts.push(e)}};n()}morphTo(e,t={}){if(this._isDestroyed())return this;if(!e||"string"!=typeof e)return console.warn(`[EmotiveMascot3D] morphTo: Invalid shape "${e}". Use getAvailableGeometries() for valid options.`),this;if(Qx.includes(e)||console.warn(`[EmotiveMascot3D] Unknown geometry "${e}". Valid geometries: ${Qx.join(", ")}`),this.core3D){if(void 0!==t.materialVariant&&this.core3D.setMaterialVariant(t.materialVariant),t.onMaterialSwap){const e=this.core3D.onMaterialSwap;this.core3D.onMaterialSwap=n=>{e&&e(n),t.onMaterialSwap(n),this.core3D.onMaterialSwap=e}}const n=t.duration||800;this.core3D.morphToShape(e,n)}return this.eventManager.emit("shape:morph",{shape:e}),this}triggerReassembly(e=1500){return!!this.core3D&&this.core3D.triggerReassembly(e)}isShatterFrozen(){return this.core3D?.isShatterFrozen()||!1}feel(e){if(this._isDestroyed())return{success:!1,error:"Engine destroyed",parsed:null};const t=Date.now(),n=this._feelRateLimiter;let a=0;for(let e=0;e<n.maxCallsPerSecond;e++)t-n.calls[e]<n.windowMs&&a++;if(a>=n.maxCallsPerSecond)return console.warn(`[EmotiveMascot3D] feel: Rate limit exceeded. Max ${n.maxCallsPerSecond} calls per second.`),{success:!1,error:"Rate limit exceeded",parsed:null};n.calls[n.index]=t,n.index=(n.index+1)%n.maxCallsPerSecond;const i=this._intentParser.parse(e),r=this._intentParser.validate(i);if(!r.valid)return console.warn("[feel] Invalid intent:",r.errors),{success:!1,error:r.errors.join("; "),parsed:i};try{if(i.emotion){const e={};i.undertone&&"clear"!==i.undertone&&(e.undertone=i.undertone),this.setEmotion(i.emotion,e)}for(const e of i.gestures)this.express(e);return i.shape&&this.morphTo(i.shape),{success:!0,error:null,parsed:i}}catch(e){return console.error("[feel] Execution error:",e),{success:!1,error:e.message,parsed:i}}}isMorphing(){return!!this.core3D&&this.core3D.isMorphing()}getMorphState(){return this.core3D?this.core3D.getMorphState():null}growIn(e=500){this.core3D&&this.core3D.growIn(e),this.eventManager.emit("animation:growIn",{duration:e})}setCoreGlowEnabled(e){this.core3D&&this.core3D.setCoreGlowEnabled(e),this.eventManager.emit("coreGlow:toggle",{enabled:e})}isCoreGlowEnabled(){return!this.core3D||this.core3D.coreGlowEnabled}enableAutoRotate(){this.core3D&&"moon"!==this.core3D.geometryType&&(this.core3D.renderer?.controls&&(this.core3D.renderer.controls.autoRotate=!0,this.core3D.renderer.controls.autoRotateSpeed=this.core3D.options?.autoRotateSpeed??.5),this.core3D.rotationDisabled=!1,this.setEmotion(this.core3D.emotion,this.undertone))}disableAutoRotate(){this.core3D?.renderer?.controls&&(this.core3D.renderer.controls.autoRotate=!1,this.core3D.renderer.controls.autoRotateSpeed=0),this.core3D&&(this.core3D.rotationDisabled=!0,this.core3D.rotationBehavior=null,this.core3D.baseEuler&&(this.core3D.baseEuler[0]=0,this.core3D.baseEuler[1]=0,this.core3D.baseEuler[2]=0))}setCameraPreset(e,t=1e3){this.core3D?.renderer?.setCameraPreset&&this.core3D.renderer.setCameraPreset(e,t)}get autoRotateEnabled(){return!1===this.core3D?.rotationDisabled}enableParticles(){if(this.core3D?.particleOrchestrator?.renderer&&(this.core3D.particleVisibility=!0,this.core3D.particleOrchestrator.renderer.setVisible(!0),this.core3D.particleOrchestrator.setEmotion(this.core3D.emotion,this.core3D.undertone)),!this.core3D?.particleOrchestrator&&!this.particleSystem&&this.canvas2D){const e=this.config.maxParticles||300;this.particleSystem=new by(e,this.errorBoundary),this.particleSystem.canvasWidth=this.canvas2D.width,this.particleSystem.canvasHeight=this.canvas2D.height}}disableParticles(){this.core3D?.particleOrchestrator?.renderer&&(this.core3D.particleVisibility=!1,this.core3D.particleOrchestrator.renderer.setVisible(!1),this.core3D.particleOrchestrator.clear()),this.core3D?.particleOrchestrator||this.particleSystem&&(this.particleSystem.destroy(),this.particleSystem=null)}get particlesEnabled(){return this.core3D?.particleOrchestrator?!0===this.core3D.particleVisibility:null!==this.particleSystem}enableBlinking(){this.core3D&&(this.core3D.blinkingManuallyDisabled=!1,this.core3D.blinkAnimator&&this.core3D.blinkAnimator.resume())}disableBlinking(){this.core3D&&(this.core3D.blinkingManuallyDisabled=!0,this.core3D.blinkAnimator&&this.core3D.blinkAnimator.pause())}get blinkingEnabled(){return!(!this.core3D||!this.core3D.blinkAnimator)&&this.core3D.blinkAnimator.enabled}enableBreathing(){this.core3D&&(this.core3D.breathingEnabled=!0)}disableBreathing(){this.core3D&&(this.core3D.breathingEnabled=!1)}get breathingEnabled(){return!this.core3D||!1!==this.core3D.breathingEnabled}breathePhase(e,t){this.core3D&&this.core3D.breathePhase(e,t)}stopBreathingPhase(){this.core3D&&this.core3D.stopBreathingPhase()}enableWobble(){this.core3D&&this.core3D.setWobbleEnabled(!0)}disableWobble(){this.core3D&&this.core3D.setWobbleEnabled(!1)}get wobbleEnabled(){return!this.core3D||!1!==this.core3D.wobbleEnabled}enableRhythmSync(){this.core3D&&this.core3D.setRhythmEnabled(!0)}disableRhythmSync(){this.core3D&&this.core3D.setRhythmEnabled(!1)}get rhythmSyncEnabled(){return!!this.core3D&&this.core3D.rhythmEnabled}enableGroove(){this.core3D&&this.core3D.setGrooveEnabled(!0)}disableGroove(){this.core3D&&this.core3D.setGrooveEnabled(!1)}setBeatSyncStrength(e){this.core3D&&this.core3D.setBeatSyncStrength(e)}setGrooveConfidence(e){this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setGrooveConfidence(e)}getGrooveConfidence(){return this.core3D?.rhythm3DAdapter?.grooveConfidence??1}setBPMMultiplier(e){this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setBPMMultiplier(e)}getBPMMultiplier(){return this.core3D?.rhythm3DAdapter?.getBPMMultiplier()??1}setGrooveConfig(e){this.core3D&&this.core3D.setGrooveConfig(e)}setGroove(e,t={}){this.core3D&&this.core3D.setGroove(e,t)}getGroovePresets(){return this.core3D?this.core3D.getGroovePresets():["groove1","groove2","groove3"]}getCurrentGroove(){return this.core3D?this.core3D.getCurrentGroove():"groove1"}enableDance(){this.danceChoreographer&&this.danceChoreographer.enable()}disableDance(){this.danceChoreographer&&this.danceChoreographer.disable()}isDanceEnabled(){return this.danceChoreographer?.enabled??!1}setDanceIntensity(e){this.danceChoreographer&&this.danceChoreographer.setIntensity(e)}getDanceIntensity(){return this.danceChoreographer?.getIntensity()??.5}getDanceStatus(){return this.danceChoreographer?.getStatus()??{enabled:!1}}isRhythmPlaying(){return this.core3D?.isRhythmPlaying()||!1}getRhythmBPM(){return this.core3D?.getRhythmBPM()||120}startRhythm(e=120,t="straight"){this.core3D&&this.core3D.startRhythm(e,t)}stopRhythm(){this.core3D&&this.core3D.stopRhythm()}setRhythmBPM(e){this.core3D&&this.core3D.setRhythmBPM(e)}setRhythmPattern(e){this.core3D&&this.core3D.setRhythmPattern(e)}connectAudio(e){return this._getAudioBridge().connectAudio(e)}disconnectAudio(){this._audioBridge&&this._audioBridge.disconnectAudio()}getBPMStatus(){return this._audioBridge?this._audioBridge.getBPMStatus():{bpm:120,subdivision:1,confidence:0,locked:!1,lockStage:0,correctionType:"none",finalized:!1,grooveConfidence:1,agentCount:0,peakCount:0,histogramSize:0,topAgents:[],intervalCount:0}}getBPMDebugLog(){return this._audioBridge?this._audioBridge.getBPMDebugLog():"No audio bridge active."}resetBPMDetection(e=null){this._audioBridge&&this._audioBridge.resetBPMDetection(e)}rgbToHex(e){return`#${[Math.round(255*e[0]),Math.round(255*e[1]),Math.round(255*e[2])].map(e=>{const t=e.toString(16);return 1===t.length?`0${t}`:t}).join("")}`}setPosition(e,t,n=0){if(!this.container)return this;const a=this.position||{x:0,y:0,z:0};this.position={x:e,y:t,z:n};const i=window.innerWidth<768;return this.container.style.transform=i?`translate(calc(-50% + ${e}px), calc(-50% + ${t}px))`:`translate(${e}px, calc(-50% + ${t}px))`,this.eventManager&&this.eventManager.emit("position:change",{x:e,y:t,z:n,previous:a}),this}getPosition(){return this.position||{x:0,y:0,z:0}}getAvailableEmotions(){return rp()}getAvailableGestures(){return my()}warmUpGestures({onBatch:e,onComplete:t,onFactoriesReady:n,prewarmFactories:a=!0,prewarmModels:i=!1,onModelsReady:r}={}){const s=function({onBatch:e,onComplete:t}={}){const n=Object.keys(iy);e&&e(n.map(e=>({name:e,category:uy[e]||"atmosphere",source:"core"})));try{const t=[];sm().forEach(e=>{const n=rm(e);t.push({name:n.name,emoji:n.emoji||"",type:n.type,category:n.category||"effect",description:n.description||"Plugin gesture",source:"plugin"})}),t.length&&e&&e(t)}catch{}return t&&t(),Object.keys(iy).filter(e=>{const t=Object.getOwnPropertyDescriptor(iy,e);return t&&"function"==typeof t.get}).map(e=>()=>function(e){return iy[e]||null}(e))}({onBatch:e,onComplete:t});if(a&&s&&s.length>0&&(this._frameBudgetScheduler||(this._frameBudgetScheduler=new ex),this._frameBudgetScheduler.enqueueAll(s),n&&!i&&(this._frameBudgetScheduler.onDrain=n)),i&&this.core3D?.elementSpawner){this._frameBudgetScheduler||(this._frameBudgetScheduler=new ex);const e=ow.types().map(e=>()=>this.core3D.elementSpawner.preloadModels(e));this._frameBudgetScheduler.enqueueAll(e);const t=r||n;t&&(this._frameBudgetScheduler.onDrain=t)}}getGestureCategories(){return dy}getAvailableGeometries(){return[...Qx]}animateToPosition(e,t,n=0,a=1e3,i="easeOutCubic"){if(!this.container)return;const r=this.getPosition(),s=performance.now(),o=i=>{const l=i-s,c=Math.min(l/a,1),h=(d=c,1-Math.pow(1-d,3));var d;const u=r.x+(e-r.x)*h,p=r.y+(t-r.y)*h,m=r.z+(n-r.z)*h;this.setPosition(u,p,m),c<1&&requestAnimationFrame(o)};requestAnimationFrame(o)}setContainment(e,t=1){const n=this._containmentScale||1;if(this._containmentBounds=e,this._containmentScale=t,this.particleSystem&&1!==t){const e=this.config.particleSpawnRadius||150;this.particleSystem.setSpawnRadius(e*t)}return this.eventManager&&t!==n&&this.eventManager.emit("scale:change",{scale:t,previous:n}),this}attachToElement(e,t={}){const n="string"==typeof e?document.querySelector(e):e;if(!n)return console.error(`[EmotiveMascot3D] Element not found: ${e}`),this;this._attachedElement=n,this._attachOptions={offsetX:t.offsetX||0,offsetY:t.offsetY||0,animate:!1!==t.animate,duration:t.duration||1e3,scale:t.scale||1,containParticles:!1!==t.containParticles},this._hasAttachedBefore=this._hasAttachedBefore||!1;const a=n.getBoundingClientRect();return this._attachOptions.containParticles?this.setContainment({width:a.width,height:a.height},this._attachOptions.scale):1!==this._attachOptions.scale&&this.setContainment(null,this._attachOptions.scale),this._updateAttachedPosition(),this._setupElementTracking(),this}_updateAttachedPosition(){if(!this._attachedElement||!this.container)return;const e=this._attachedElement.getBoundingClientRect(),t=this.container.getBoundingClientRect(),n=e.left+e.width/2,a=e.top+e.height/2,i=t.left+t.width/2,r=t.top+t.height/2,s=n-i+this._attachOptions.offsetX,o=a-r+this._attachOptions.offsetY,l=!this._hasAttachedBefore;this._hasAttachedBefore=!0,l&&this._attachOptions.animate?this.animateToPosition(s,o,0,this._attachOptions.duration):this.setPosition(s,o,0)}_setupElementTracking(){this._elementTrackingHandlers||(this._elementTrackingHandlers={scroll:()=>this._updateAttachedPosition(),resize:()=>this._updateAttachedPosition()},window.addEventListener("scroll",this._elementTrackingHandlers.scroll,{passive:!0}),window.addEventListener("resize",this._elementTrackingHandlers.resize))}isAttachedToElement(){return!!this._attachedElement}detachFromElement(){return this._attachedElement=null,this._hasAttachedBefore=!1,this._elementTrackingHandlers&&(window.removeEventListener("scroll",this._elementTrackingHandlers.scroll),window.removeEventListener("resize",this._elementTrackingHandlers.resize),this._elementTrackingHandlers=null),this.setContainment(null,1),this.setEmotion("neutral"),this}setSSSPreset(e,t={}){this._currentSSSPreset=e,this.core3D&&!this._materialSwapCallbackSet&&(this._materialSwapCallbackSet=!0,this.core3D.onMaterialSwap=()=>{this._currentSSSPreset&&setTimeout(()=>{nx(this,this._currentSSSPreset)},50)});const n=tx[e];if(!n||!this.core3D?.customMaterial?.uniforms)return!1;const a=this.core3D.customMaterial.uniforms;if(t.immediate||!this.core3D._targetSSSValues){const t=nx(this,e);return t&&(this.core3D._targetSSSValues={...n},this.core3D._sssTransitionProgress=1,this.eventManager.emit("sss:presetChanged",{preset:e})),t}return this.core3D._sssTransitionStart={sssStrength:a.sssStrength?.value??n.sssStrength,sssAbsorption:a.sssAbsorption?.value?[a.sssAbsorption.value.x,a.sssAbsorption.value.y,a.sssAbsorption.value.z]:[...n.sssAbsorption],sssScatterDistance:a.sssScatterDistance?.value?[a.sssScatterDistance.value.x,a.sssScatterDistance.value.y,a.sssScatterDistance.value.z]:[...n.sssScatterDistance],sssThicknessBias:a.sssThicknessBias?.value??n.sssThicknessBias,sssThicknessScale:a.sssThicknessScale?.value??n.sssThicknessScale,sssCurvatureScale:a.sssCurvatureScale?.value??n.sssCurvatureScale,sssAmbient:a.sssAmbient?.value??n.sssAmbient,frostiness:a.frostiness?.value??n.frostiness,innerGlowStrength:a.innerGlowStrength?.value??n.innerGlowStrength,fresnelIntensity:a.fresnelIntensity?.value??n.fresnelIntensity,causticIntensity:a.causticIntensity?.value??n.causticIntensity,emotionColorBleed:a.emotionColorBleed?.value??n.emotionColorBleed},this.core3D._targetSSSValues={sssStrength:n.sssStrength,sssAbsorption:[...n.sssAbsorption],sssScatterDistance:[...n.sssScatterDistance],sssThicknessBias:n.sssThicknessBias,sssThicknessScale:n.sssThicknessScale,sssCurvatureScale:n.sssCurvatureScale,sssAmbient:n.sssAmbient,frostiness:n.frostiness,innerGlowStrength:n.innerGlowStrength,fresnelIntensity:n.fresnelIntensity,causticIntensity:n.causticIntensity,emotionColorBleed:n.emotionColorBleed},this.core3D._sssTransitionProgress=0,this.eventManager.emit("sss:presetChanged",{preset:e,transitioning:!0}),!0}setGeometry(e,t={}){return console.warn("[EmotiveMascot3D] setGeometry() is deprecated. Use morphTo() instead."),this.morphTo(e,t)}startSolarEclipse(e={}){this.core3D&&"function"==typeof this.core3D.startSolarEclipse?this.core3D.startSolarEclipse(e):(this.morphTo("sun"),this.eventManager.emit("eclipse:solar:start",{type:e.type||"total"}))}startLunarEclipse(e={}){this.core3D&&"function"==typeof this.core3D.startLunarEclipse?this.core3D.startLunarEclipse(e):(this.morphTo("moon"),this.eventManager.emit("eclipse:lunar:start",{type:e.type||"total"}))}setColorTransitionDuration(e){return this.core3D&&(this.core3D.colorTransitionDuration=e),this}setSSSTransitionDuration(e){return this.core3D&&(this.core3D.sssTransitionDuration=e),this}stopEclipse(){this.core3D&&"function"==typeof this.core3D.stopEclipse&&this.core3D.stopEclipse(),this.eventManager&&this.eventManager.emit("eclipse:stop")}destroy(){this._destroyed=!0,this.stop(),this._frameBudgetScheduler&&(this._frameBudgetScheduler.destroy(),this._frameBudgetScheduler=null),this._audioBridge&&(this._audioBridge.destroy(),this._audioBridge=null),this._elementTrackingHandlers&&(window.removeEventListener("scroll",this._elementTrackingHandlers.scroll),window.removeEventListener("resize",this._elementTrackingHandlers.resize),this._elementTrackingHandlers=null),this._attachedElement=null,this._reducedMotionMediaQuery&&this._reducedMotionHandler&&(this._reducedMotionMediaQuery.removeEventListener?this._reducedMotionMediaQuery.removeEventListener("change",this._reducedMotionHandler):this._reducedMotionMediaQuery.removeListener&&this._reducedMotionMediaQuery.removeListener(this._reducedMotionHandler),this._reducedMotionMediaQuery=null,this._reducedMotionHandler=null),this.gestureTimeouts.forEach(e=>clearTimeout(e)),this.gestureTimeouts=[],this.eventManager&&this.eventManager._listeners&&(Object.keys(this.eventManager._listeners).forEach(e=>{this.eventManager._listeners[e]=[]}),this.eventManager._listeners=null),this.core3D&&this.core3D.destroy(),this.particleSystem&&this.particleSystem.destroy(),this.danceChoreographer&&(this.danceChoreographer.destroy(),this.danceChoreographer=null),this._resizeObserver&&(this._resizeObserver.destroy(),this._resizeObserver=null),this._canvasLayerManager&&(this._canvasLayerManager.destroy(),this._canvasLayerManager=null),this.container=null,this.webglCanvas=null,this.canvas2D=null,this.ctx2D=null,this.config=null,this.errorBoundary=null,this.currentGesture=null}}const Zx=()=>"undefined"==typeof window,Jx="\nfloat dHash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat dNoise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep interpolation\n    float a = dHash(i);\n    float b = dHash(i + vec2(1.0, 0.0));\n    float c = dHash(i + vec2(0.0, 1.0));\n    float d = dHash(i + vec2(1.0, 1.0));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n",eS="\nvarying vec2 vUv;\nvarying vec3 vWorldPos;\n\nvoid main() {\n    vUv = uv;\n\n    // Transform vertex through model + view (single Mesh, not InstancedMesh)\n    vec4 worldPos = modelMatrix * vec4(position, 1.0);\n    vWorldPos = worldPos.xyz;\n    vec4 clipPos = projectionMatrix * viewMatrix * worldPos;\n\n    gl_Position = clipPos;\n}\n";function tS(){return new bi({name:"FireDistortion",uniforms:{uTime:{value:0},uStrength:{value:.005}},vertexShader:eS,fragmentShader:`\n            uniform float uTime;\n            uniform float uStrength;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            ${Jx}\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 wp = vWorldPos.xy;\n\n                float t = uTime * 2.0;\n\n                // Two-octave turbulence - frequencies sized for half-res RT survival\n                // (features must be larger than 2 RT pixels to avoid aliasing away)\n                float n1 = dNoise2D(vec2(wp.x * 18.0, wp.y * 10.0 - t * 2.5));\n                float n2 = dNoise2D(vec2(wp.x * 35.0, wp.y * 18.0 - t * 3.5)) * 0.5;\n                float turb = (n1 + n2) - 0.75; // Center around zero\n\n                // Horizontal: subtle - heat shimmer is mostly vertical\n                float dx = turb * uStrength * 0.25;\n\n                // Vertical: dominant rising streaks\n                float wobble = sin(wp.x * 25.0 + t * 1.2) * 0.2;\n                float dy = (turb + wobble) * uStrength;\n\n                // Edge falloff (UV-space)\n                float falloff = smoothstep(0.0, 0.2, uv.x) * smoothstep(1.0, 0.8, uv.x)\n                              * smoothstep(0.0, 0.15, uv.y) * smoothstep(1.0, 0.85, uv.y);\n\n                // Stronger in the middle height band (above heat source)\n                float heightWeight = smoothstep(0.0, 0.25, uv.y) * smoothstep(1.0, 0.5, uv.y);\n\n                float strength = falloff * heightWeight;\n                gl_FragColor = vec4(dx * strength, dy * strength, 0.0, 1.0);\n            }\n        `,blending:2,depthWrite:!1,depthTest:!1,transparent:!0,side:2})}const nS="\n// Per-instance attributes from ElementInstancePool\nattribute float aSpawnTime;       // When this instance spawned (global time)\nattribute float aExitTime;        // When fade-out started (0 = not exiting)\nattribute float aModelIndex;      // Vertex attribute: which model this vertex belongs to\nattribute float aSelectedModel;   // Instance attribute: which model to render\nattribute float aInstanceOpacity; // Per-instance opacity multiplier\nattribute float aTrailParent;     // Trail parent slot (-1 for main instance)\nattribute float aTrailIndex;      // Which trail copy (0-2, or -1 for main)\nattribute vec4 aVelocity;         // xyz = direction, w = speed\nattribute float aRandomSeed;      // Per-instance random for variation (also used as arc phase for vortex)\n\n// Passed to fragment shader\nvarying float vLocalTime;         // Time since this instance spawned\nvarying float vInstanceAlpha;     // Combined opacity from spawn/exit fades\nvarying float vTrailFade;         // Trail opacity fade (1.0 for main, 0.75/0.5/0.25 for trails)\nvarying vec4 vVelocity;           // For motion blur in fragment/post-process\n",aS="\nvarying float vLocalTime;\nvarying float vInstanceAlpha;\nvarying float vTrailFade;\nvarying vec4 vVelocity;\n",iS={PERLIN:0},rS="\nuniform int uAnimationType;\nuniform float uGestureProgress;\nuniform float uGlowScale;            // Glow intensity multiplier (0=off, 1=normal, >1=bloom)\n\n// Two-layer composable cutout system (shared across all element types)\nuniform float uCutoutStrength;       // 0-1 overall cutout intensity\nuniform float uCutoutPhase;          // Animation phase offset\n// Primary pattern layer\nuniform int uCutoutPattern1;         // Primary pattern type (-1=none, 0-5)\nuniform float uCutoutScale1;         // Primary pattern scale\nuniform float uCutoutWeight1;        // Primary pattern weight (0-1)\n// Secondary pattern layer\nuniform int uCutoutPattern2;         // Secondary pattern type (-1=none, 0-5)\nuniform float uCutoutScale2;         // Secondary pattern scale\nuniform float uCutoutWeight2;        // Secondary pattern weight (0-1)\n// Blend mode\nuniform int uCutoutBlend;            // 0=multiply, 1=min, 2=max, 3=add\n// Travel animation (sweeps cutout around geometry)\nuniform int uCutoutTravel;           // 0=none, 1=angular, 2=radial, 3=spiral, 4=oscillate, 5=wave\nuniform float uCutoutTravelSpeed;    // Rotations/expansions per gesture (default 1.0)\nuniform int uCutoutTravelDir;        // 0=forward, 1=reverse, 2=pingpong\n// Per-layer travel (secondary layer can have different travel)\nuniform int uCutoutTravel2;          // Travel mode for secondary layer (-1=same as primary)\nuniform float uCutoutTravelSpeed2;   // Travel speed for secondary layer\n// Strength animation\nuniform int uCutoutStrengthCurve;    // 0=constant, 1=fadeIn, 2=fadeOut, 3=bell, 4=pulse\nuniform float uCutoutFadeInDuration; // For fadeIn: fraction of gesture to reach full (0.33 = 1/3)\nuniform float uCutoutFadeOutDuration;// For fadeOut: fraction of gesture for fade (0.33 = last 1/3)\nuniform float uCutoutBellPeakAt;     // For bell: where peak occurs (0.5 = middle, 0.3 = early)\nuniform float uCutoutBellWidth;      // For bell: plateau width (0=sharp peak, 0.5=50% at full, 0.8=80% at full)\n// Trail dissolve - fades out bottom of each instance as it moves\nuniform int uTrailDissolveEnabled;   // 0=off, 1=enabled\nuniform float uTrailDissolveOffset;  // Y offset from instance position (negative = below)\nuniform float uTrailDissolveSoftness;// Gradient softness (higher = softer transition)\n// Grain system - noise-based texture overlay\nuniform int uGrainType;              // -1=none, 0=perlin, 1=simplex, 2=white, 3=film\nuniform float uGrainStrength;        // 0-1 grain visibility\nuniform float uGrainScale;           // Pattern scale (0.1=fine, 2.0=coarse)\nuniform float uGrainSpeed;           // Animation speed (0=static)\nuniform int uGrainBlend;             // 0=multiply, 1=add, 2=overlay, 3=screen\n// Geometric mask - restricts cutout to specific regions of the model geometry\nuniform int uCutoutGeoMaskType;      // 0=none, 1=distance (length(pos) for tips)\nuniform float uCutoutGeoMaskCore;    // Radius where geometry is fully solid (no cutout)\nuniform float uCutoutGeoMaskTip;     // Radius where cutout is fully applied\n// Edge mask - restricts cutout to visual silhouette edges (screen-space anisotropy, any geometry)\nuniform float uCutoutEdgeMask;       // 0=disabled, 0.3=narrow silhouette, 0.6=wide band\n",sS="\n// Calculate cutout mask for a single pattern\n// vertGradient: normalized vertical position (0=bottom, 1=top) for tip-based effects\nfloat calcCutoutPattern(int pattern, vec3 pos, float scale, float time, float vertGradient) {\n    if (pattern < 0) return 1.0;  // NONE pattern = fully visible\n\n    vec3 scaledPos = pos * scale;\n\n    if (pattern == 0) {\n        // CELLULAR: Organic cell-like holes\n        vec3 cellPos = scaledPos * 6.0 + vec3(time * 0.5, 0.0, 0.0);\n        float cell1 = snoise(cellPos);\n        float cell2 = snoise(cellPos * 1.7 + vec3(50.0));\n        float cellPattern = min(cell1, cell2);\n        return smoothstep(-0.3, 0.1, cellPattern);\n\n    } else if (pattern == 1) {\n        // STREAKS: Flow-aligned streak holes\n        float streakAngle = atan(pos.y, pos.x);\n        float streakPhase = streakAngle * 4.0 + time * 3.0;\n        float streak = sin(streakPhase);\n        float streak2 = sin(streakPhase * 0.7 + 2.094);\n        float streakPattern = max(streak, streak2);\n        return smoothstep(-0.2, 0.3, streakPattern);\n\n    } else if (pattern == 2) {\n        // RADIAL: Burst pattern from center\n        float dist = length(pos.xz);\n        float angle = atan(pos.z, pos.x);\n        float radialWave = sin(dist * 8.0 - time * 4.0 + angle * 3.0);\n        float radialNoise = snoise(scaledPos * 4.0 + vec3(time)) * 0.3;\n        return smoothstep(-0.2, 0.4, radialWave + radialNoise);\n\n    } else if (pattern == 3) {\n        // VORONOI: Cracked/shattered pattern\n        vec3 voronoiPos = scaledPos * 5.0;\n        float n1 = snoise(voronoiPos);\n        float n2 = snoise(voronoiPos * 2.0 + vec3(100.0));\n        float n3 = snoise(voronoiPos * 0.5 + vec3(-50.0));\n        float cracks = abs(n1) + abs(n2) * 0.5 + abs(n3) * 0.3;\n        return smoothstep(0.3, 0.7, cracks);\n\n    } else if (pattern == 4) {\n        // WAVES: Interference pattern\n        float wave1 = sin(pos.x * 10.0 + time * 2.0);\n        float wave2 = sin(pos.z * 10.0 + time * 2.5);\n        float wave3 = sin((pos.x + pos.z) * 7.0 - time * 1.5);\n        float wavePattern = wave1 + wave2 + wave3;\n        return smoothstep(-0.5, 1.5, wavePattern);\n\n    } else if (pattern == 5) {\n        // EMBERS: Burning ember holes (great for fire)\n        vec3 emberPos = scaledPos * 8.0 + vec3(0.0, -time * 2.0, 0.0);\n        float ember1 = snoise(emberPos);\n        float ember2 = snoise(emberPos * 1.5 + vec3(30.0, time, 0.0));\n        float heat = snoise(vec3(pos.xy * 3.0, time * 0.5)) * 0.3;\n        float emberPattern = ember1 * ember2 + heat;\n        float heightBias = smoothstep(0.0, 1.0, pos.y + 0.5) * 0.3;\n        return smoothstep(-0.2 - heightBias, 0.3 - heightBias, emberPattern);\n\n    } else if (pattern == 6) {\n        // SPIRAL: Spiral arms pattern (meditation, vortex)\n        float angle = atan(pos.z, pos.x);\n        float dist = length(pos.xz);\n        float spiralArms = 3.0;  // Number of spiral arms\n        float spiralTightness = 4.0 * scale;\n        float spiralPhase = angle * spiralArms + dist * spiralTightness - time * 2.0;\n        float spiral = sin(spiralPhase);\n        // Add noise for organic feel\n        float spiralNoise = snoise(scaledPos * 3.0 + vec3(time * 0.5)) * 0.3;\n        return smoothstep(-0.3, 0.4, spiral + spiralNoise);\n\n    } else if (pattern == 7) {\n        // DISSOLVE: Edge erosion inward (fade-outs)\n        // Uses noise to create eroding edge effect\n        vec3 dissolvePos = scaledPos * 5.0;\n        float noise1 = snoise(dissolvePos);\n        float noise2 = snoise(dissolvePos * 2.0 + vec3(100.0)) * 0.5;\n        float noise3 = snoise(dissolvePos * 4.0 + vec3(-100.0)) * 0.25;\n        float dissolveNoise = noise1 + noise2 + noise3;\n        // Edge distance factor - dissolve from edges\n        float edgeDist = 1.0 - length(pos.xz) * 0.5;\n        float dissolve = dissolveNoise + edgeDist * 0.5 + time * 0.3;\n        return smoothstep(-0.2, 0.4, dissolve);\n\n    } else if (pattern == 8) {\n        // CRACKS: Branching fracture lines (shatter)\n        vec3 crackPos = scaledPos * 4.0;\n        // Create multiple octaves of crack-like noise\n        float crack1 = abs(snoise(crackPos));\n        float crack2 = abs(snoise(crackPos * 2.0 + vec3(50.0))) * 0.5;\n        float crack3 = abs(snoise(crackPos * 4.0 + vec3(-50.0))) * 0.25;\n        // Cracks are thin lines (low absolute values)\n        float cracks = crack1 + crack2 + crack3;\n        // Animate crack spreading\n        float crackSpread = sin(time * 1.5) * 0.2;\n        return smoothstep(0.15 + crackSpread, 0.4, cracks);\n\n    // Pattern 9 (TIPS) removed - use geometricMask: { type: 'distance' } instead\n\n    } else if (pattern == 10) {\n        // BURN: Consumption line traveling with organic noisy edge\n        // Enhanced: Multi-octave noise for organic burning\n\n        // Burn line progresses over time\n        float burnProgress = time * 0.5;\n\n        // Multi-octave noise for organic burning edge\n        float noise1 = snoise(vec3(pos.xz * scale * 2.0, time * 0.5)) * 0.12;\n        float noise2 = snoise(vec3(pos.xz * scale * 4.0 + 10.0, time * 0.8)) * 0.06;\n        float noiseEdge = noise1 + noise2;\n\n        // Burn from top down: pixels above burnLine get consumed\n        float burn = smoothstep(burnProgress - 0.1 + noiseEdge, burnProgress + 0.1 + noiseEdge, 1.0 - vertGradient);\n        return 1.0 - burn;\n    }\n\n    // Pattern 11 (FRINGE) removed - use geometricMask: { type: 'distance' } with any pattern\n\n    return 1.0;  // Default: fully visible\n}\n",oS="\n// \n// TWO-LAYER COMPOSABLE CUTOUT SYSTEM\n// \n\n// Declare at outer scope so element-specific foam/edge effects can access it\nfloat finalCutout = 1.0;\nfloat trailAlpha = 1.0;  // Trail dissolve alpha - available for materials to use\n\nif (uCutoutStrength > 0.01 && uCutoutPattern1 >= 0) {\n    float cutoutTime = localTime * 0.001 + uCutoutPhase;\n\n    // Apply strength curve to modulate cutout strength over gesture\n    float curvedStrength = uCutoutStrength;\n    if (uCutoutStrengthCurve == 1) {\n        // FADE_IN: Strength ramps up from 0 to full over fadeInDuration\n        // fadeInDuration=0.33 means reach full strength at 1/3 of gesture\n        float fadeProgress = uCutoutFadeInDuration > 0.01\n            ? min(1.0, uGestureProgress / uCutoutFadeInDuration)\n            : uGestureProgress;\n        curvedStrength *= fadeProgress;\n    } else if (uCutoutStrengthCurve == 2) {\n        // FADE_OUT: Strength stays full then ramps down over fadeOutDuration\n        // fadeOutDuration=0.33 means stay at full until 67%, then fade over last 33%\n        float fadeOutStart = 1.0 - uCutoutFadeOutDuration;\n        float fadeProgress = uGestureProgress < fadeOutStart\n            ? 0.0\n            : (uGestureProgress - fadeOutStart) / max(0.01, uCutoutFadeOutDuration);\n        curvedStrength *= (1.0 - fadeProgress);\n    } else if (uCutoutStrengthCurve == 3) {\n        // BELL: Strength peaks at bellPeakAt with configurable plateau width\n        // bellPeakAt=0.5 is symmetric, bellPeakAt=0.3 peaks early\n        // bellWidth controls how long it stays at full strength:\n        //   0.0 = sharp peak (immediate ramp up/down)\n        //   0.5 = 50% of gesture at full strength\n        //   0.8 = 80% of gesture at full strength (very flat)\n        float peakAt = max(0.01, min(0.99, uCutoutBellPeakAt));\n        float halfWidth = uCutoutBellWidth * 0.5;\n        float plateauStart = max(0.0, peakAt - halfWidth);\n        float plateauEnd = min(1.0, peakAt + halfWidth);\n\n        float bellValue;\n        if (uGestureProgress < plateauStart) {\n            // Ramping up to plateau\n            bellValue = uGestureProgress / max(0.01, plateauStart);\n        } else if (uGestureProgress > plateauEnd) {\n            // Ramping down from plateau\n            bellValue = 1.0 - (uGestureProgress - plateauEnd) / max(0.01, 1.0 - plateauEnd);\n        } else {\n            // At plateau (full strength)\n            bellValue = 1.0;\n        }\n        curvedStrength *= bellValue;\n    } else if (uCutoutStrengthCurve == 4) {\n        // PULSE: Multiple pulses during gesture\n        curvedStrength *= 0.5 + 0.5 * sin(uGestureProgress * 12.566);  // 2 full pulses\n    } else if (uCutoutStrengthCurve == 5) {\n        // TOP_HEAVY: Strength increases toward top of element\n        float topFactor = smoothstep(0.0, 1.0, vVerticalGradient);\n        curvedStrength *= topFactor;\n    } else if (uCutoutStrengthCurve == 6) {\n        // TIPS: Only affects the very tips (top 25%)\n        float tipsFactor = smoothstep(0.75, 1.0, vVerticalGradient);\n        curvedStrength *= tipsFactor;\n    } else if (uCutoutStrengthCurve == 7) {\n        // CONSUME: Progressive eating from top down over gesture time\n        float consumeProgress = uGestureProgress;\n        float consumeFactor = smoothstep(1.0 - consumeProgress, 1.0 - consumeProgress + 0.2, vVerticalGradient);\n        curvedStrength *= consumeFactor;\n    }\n\n    // Trail dissolve is applied after finalCutout calculation (see below)\n\n    // Calculate travel progress with direction support\n    float travelProgress = uGestureProgress * uCutoutTravelSpeed;\n    if (uCutoutTravelDir == 1) {\n        // REVERSE: Run travel backwards\n        travelProgress = (1.0 - uGestureProgress) * uCutoutTravelSpeed;\n    } else if (uCutoutTravelDir == 2) {\n        // PINGPONG: Forward then reverse\n        float pingpongT = uGestureProgress * 2.0;\n        travelProgress = (pingpongT < 1.0 ? pingpongT : (2.0 - pingpongT)) * uCutoutTravelSpeed;\n    }\n\n    // Apply travel offset to position for primary pattern sampling\n    vec3 travelPos = vPosition;\n    if (uCutoutTravel == 1) {\n        // ANGULAR: Rotate position around Y axis\n        float travelAngle = travelProgress * 6.28318;\n        float cosA = cos(travelAngle);\n        float sinA = sin(travelAngle);\n        travelPos.x = vPosition.x * cosA - vPosition.z * sinA;\n        travelPos.z = vPosition.x * sinA + vPosition.z * cosA;\n    } else if (uCutoutTravel == 2) {\n        // RADIAL: Scale position from center\n        float radialScale = 1.0 + (travelProgress - 0.5) * 2.0;\n        travelPos.xz *= radialScale;\n    } else if (uCutoutTravel == 3) {\n        // SPIRAL: Rotate + expand simultaneously (hypnotic)\n        float spiralAngle = travelProgress * 6.28318;\n        float spiralScale = 1.0 + travelProgress * 0.5;\n        float cosA = cos(spiralAngle);\n        float sinA = sin(spiralAngle);\n        travelPos.x = (vPosition.x * cosA - vPosition.z * sinA) * spiralScale;\n        travelPos.z = (vPosition.x * sinA + vPosition.z * cosA) * spiralScale;\n    } else if (uCutoutTravel == 4) {\n        // OSCILLATE: Ping-pong back and forth (breathing)\n        float oscillateT = sin(travelProgress * 6.28318) * 0.5 + 0.5;\n        float oscillateAngle = oscillateT * 3.14159;  // Half rotation oscillation\n        float cosA = cos(oscillateAngle);\n        float sinA = sin(oscillateAngle);\n        travelPos.x = vPosition.x * cosA - vPosition.z * sinA;\n        travelPos.z = vPosition.x * sinA + vPosition.z * cosA;\n    } else if (uCutoutTravel == 5) {\n        // WAVE: Sine wave propagation (ripple)\n        float wavePhase = travelProgress * 6.28318;\n        float dist = length(vPosition.xz);\n        float waveOffset = sin(dist * 4.0 - wavePhase) * 0.3;\n        travelPos.xz *= 1.0 + waveOffset;\n    } else if (uCutoutTravel == 6) {\n        // VERTICAL: Progress travels bottomtop along vertical gradient\n        // Shifts the pattern sampling based on Y position and progress\n        float verticalShift = travelProgress * 2.0 - 1.0; // -1 to 1\n        travelPos.y += verticalShift;\n    } else if (uCutoutTravel == 7) {\n        // CONSUME: Burns inward from tips, eating the flame\n        // Modifies Y to create consumption from top\n        float consumeLine = 1.0 - travelProgress; // Starts at 1.0, goes to 0\n        travelPos.y = vPosition.y - consumeLine;\n    }\n\n    // Calculate primary pattern mask using travel-offset position\n    float mask1 = calcCutoutPattern(uCutoutPattern1, travelPos, uCutoutScale1, cutoutTime, vVerticalGradient);\n    mask1 = mix(1.0, mask1, uCutoutWeight1);\n\n    // Calculate secondary pattern mask (if enabled)\n    float mask2 = 1.0;\n    if (uCutoutPattern2 >= 0) {\n        // Per-layer travel: secondary can have different travel mode\n        vec3 travelPos2 = vPosition;\n        int travel2Mode = uCutoutTravel2 < 0 ? uCutoutTravel : uCutoutTravel2;\n        float travel2Speed = uCutoutTravel2 < 0 ? uCutoutTravelSpeed : uCutoutTravelSpeed2;\n        float travel2Progress = uGestureProgress * travel2Speed;\n\n        // Apply direction to secondary travel too\n        if (uCutoutTravelDir == 1) {\n            travel2Progress = (1.0 - uGestureProgress) * travel2Speed;\n        } else if (uCutoutTravelDir == 2) {\n            float pingpongT = uGestureProgress * 2.0;\n            travel2Progress = (pingpongT < 1.0 ? pingpongT : (2.0 - pingpongT)) * travel2Speed;\n        }\n\n        if (travel2Mode == 1) {\n            float angle2 = travel2Progress * 6.28318;\n            float c2 = cos(angle2); float s2 = sin(angle2);\n            travelPos2.x = vPosition.x * c2 - vPosition.z * s2;\n            travelPos2.z = vPosition.x * s2 + vPosition.z * c2;\n        } else if (travel2Mode == 2) {\n            float scale2 = 1.0 + (travel2Progress - 0.5) * 2.0;\n            travelPos2.xz *= scale2;\n        } else if (travel2Mode == 3) {\n            float angle2 = travel2Progress * 6.28318;\n            float scale2 = 1.0 + travel2Progress * 0.5;\n            float c2 = cos(angle2); float s2 = sin(angle2);\n            travelPos2.x = (vPosition.x * c2 - vPosition.z * s2) * scale2;\n            travelPos2.z = (vPosition.x * s2 + vPosition.z * c2) * scale2;\n        } else if (travel2Mode == 4) {\n            float osc2 = sin(travel2Progress * 6.28318) * 0.5 + 0.5;\n            float angle2 = osc2 * 3.14159;\n            float c2 = cos(angle2); float s2 = sin(angle2);\n            travelPos2.x = vPosition.x * c2 - vPosition.z * s2;\n            travelPos2.z = vPosition.x * s2 + vPosition.z * c2;\n        } else if (travel2Mode == 5) {\n            float phase2 = travel2Progress * 6.28318;\n            float dist2 = length(vPosition.xz);\n            float wave2 = sin(dist2 * 4.0 - phase2) * 0.3;\n            travelPos2.xz *= 1.0 + wave2;\n        } else if (travel2Mode == 6) {\n            // VERTICAL\n            float verticalShift2 = travel2Progress * 2.0 - 1.0;\n            travelPos2.y += verticalShift2;\n        } else if (travel2Mode == 7) {\n            // CONSUME\n            float consumeLine2 = 1.0 - travel2Progress;\n            travelPos2.y = vPosition.y - consumeLine2;\n        }\n\n        mask2 = calcCutoutPattern(uCutoutPattern2, travelPos2, uCutoutScale2, cutoutTime, vVerticalGradient);\n        mask2 = mix(1.0, mask2, uCutoutWeight2);\n    }\n\n    // Blend the two masks\n    float cutoutMask = 1.0;\n    if (uCutoutBlend == 0) {\n        // MULTIPLY: Hole where EITHER has hole (more holes)\n        cutoutMask = mask1 * mask2;\n    } else if (uCutoutBlend == 1) {\n        // MIN: Hole only where BOTH have holes (fewer holes)\n        cutoutMask = min(mask1, mask2);\n    } else if (uCutoutBlend == 2) {\n        // MAX: Keep highest value (fewer holes)\n        cutoutMask = max(mask1, mask2);\n    } else if (uCutoutBlend == 3) {\n        // ADD: Smooth blend, clamped\n        cutoutMask = clamp(mask1 + mask2 - 1.0, 0.0, 1.0);\n    }\n\n    // Apply curved cutout strength\n    finalCutout = mix(1.0, cutoutMask, curvedStrength);\n\n    // \n    // GEOMETRIC MASK: Restrict cutout to specific regions of the model\n    // Type 1 (distance): Uses length(pos) to target tips (far from model origin)\n    //                    Core is solid, tips have the cutout pattern\n    // Type 2 (inverted-distance): Inverts the mask for models with origin at tip\n    //                    Core has cutout pattern, tips are solid\n    // \n\n    if (uCutoutGeoMaskType == 1) {\n        // Distance-based mask: length(pos) identifies tips (vertices far from origin)\n        float geoDist = length(vPosition);\n        // geoMask: 0 at core (solid), 1 at tips (full cutout effect)\n        float geoMask = smoothstep(uCutoutGeoMaskCore, uCutoutGeoMaskTip, geoDist);\n        // Mix: core gets 1.0 (no holes), tips get the cutout pattern\n        finalCutout = mix(1.0, finalCutout, geoMask);\n    } else if (uCutoutGeoMaskType == 2) {\n        // INVERTED distance mask: for models with origin at tip (like flame-tongue)\n        // Core (near origin = tip) gets cutout, far regions (body) are solid\n        float geoDist = length(vPosition);\n        // geoMask: 1 at core (full cutout), 0 at far regions (solid)\n        float geoMask = 1.0 - smoothstep(uCutoutGeoMaskCore, uCutoutGeoMaskTip, geoDist);\n        // Mix: core gets the cutout pattern, far regions get 1.0 (no holes)\n        finalCutout = mix(1.0, finalCutout, geoMask);\n    } else if (uCutoutGeoMaskType == 3) {\n        // TIP-BOOST: Amplifies erosion near origin WITHOUT removing body pattern\n        // For models with origin at tip - boosts cutout there while keeping body intact\n        float geoDist = length(vPosition);\n        // tipBoost: 1 at origin (tips), 0 at body\n        float tipBoost = 1.0 - smoothstep(uCutoutGeoMaskCore, uCutoutGeoMaskTip, geoDist);\n        // Multiply pattern by factor to push tips toward holes\n        // At tips: factor ~0.3 (more holes), At body: factor = 1.0 (unchanged)\n        float boostFactor = mix(1.0, 0.3, tipBoost);\n        finalCutout = finalCutout * boostFactor;\n    }\n\n    // \n    // EDGE MASK: Restrict cutout to visual silhouette edges\n    // Uses screen-space derivative anisotropy  at silhouette edges, one derivative\n    // of vWorldPosition is much longer than the other (surface grazes the view ray).\n    // Unlike NdotV, this works on ANY geometry: torus, sphere, crystal, concave, etc.\n    // Composable with any travel mode  pattern+travel determine WHAT to cut,\n    // edge mask determines WHERE (only at the visual silhouette boundary).\n    // \n\n    if (uCutoutEdgeMask > 0.0) {\n        // Derivative ratio: how foreshortened is this fragment?\n        // ratio  1.0 face-on, high at silhouette edges (surface grazes view ray)\n        float lenX = length(dFdx(vWorldPosition));\n        float lenY = length(dFdy(vWorldPosition));\n        float edgeRatio = max(lenX, lenY) / max(min(lenX, lenY), 0.00001);\n\n        // Edge band: edgeMask controls tightness (0=wide band, 1=narrow edge only)\n        float lowThresh = mix(1.1, 2.5, uCutoutEdgeMask);\n        float highThresh = lowThresh + 0.8;\n        float edgeFactor = smoothstep(lowThresh, highThresh, edgeRatio);\n\n        // Two-step edge mask:\n        // 1) Suppress center: push cutout toward 1.0 (solid) away from edges\n        float maskedCutout = mix(1.0, finalCutout, edgeFactor);\n        // 2) Widen cracks at edges: pow squeezes near-crack values past the\n        //    0.5 discard threshold. pow(0.7, 3) = 0.34  discarded.\n        //    Solid areas (1.0) stay at 1.0 regardless of power.\n        float widenPower = mix(1.0, 3.0, edgeFactor);\n        finalCutout = pow(maskedCutout, widenPower);\n    }\n\n    // Binary discard for cutout pattern holes (creates organic edges)\n    if (finalCutout < 0.5) {\n        discard;\n    }\n}\n\n// \n// TRAIL DISSOLVE: Fade alpha at bottom of each instance\n// Runs independently of cutout (works with strength=0 too)\n// Uses ALPHA (not discard) so edges remain organic\n// \n\nif (uTrailDissolveEnabled == 1) {\n    // Distance from this fragment to the instance's floor\n    float instanceFloor = vInstancePosition.y + uTrailDissolveOffset;\n    float distFromFloor = vWorldPosition.y - instanceFloor;\n\n    // trailAlpha: 0 at floor, 1 at softness distance above\n    // This creates a SMOOTH FADE - no hard edge\n    trailAlpha = smoothstep(0.0, uTrailDissolveSoftness, distFromFloor);\n}\n",lS="\n// \n// GRAIN SYSTEM - NOISE TEXTURE OVERLAY\n// \n\nif (uGrainType >= 0 && uGrainStrength > 0.01) {\n    float grainTime = localTime * 0.001 * uGrainSpeed;\n    vec3 grainPos = vPosition * uGrainScale * 10.0;\n\n    float grain = 0.0;\n\n    if (uGrainType == 0) {\n        // PERLIN: Smooth flowing noise\n        grain = snoise(grainPos + vec3(grainTime, 0.0, 0.0));\n        grain = grain * 0.5 + 0.5;  // Normalize to 0-1\n\n    } else if (uGrainType == 1) {\n        // SIMPLEX: Similar character, offset sampling\n        vec3 offset = vec3(100.0, grainTime * 1.5, 50.0);\n        grain = snoise(grainPos + offset);\n        grain = grain * 0.5 + 0.5;\n\n    } else if (uGrainType == 2) {\n        // WHITE: Random pixel noise (fast changing)\n        // Use fract-based pseudo-random\n        vec3 whitePos = grainPos * 100.0 + vec3(grainTime * 50.0);\n        grain = fract(sin(dot(whitePos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\n    } else if (uGrainType == 3) {\n        // FILM: Perlin + white hybrid (cinematic)\n        float perlin = snoise(grainPos + vec3(grainTime, 0.0, 0.0));\n        perlin = perlin * 0.5 + 0.5;\n        vec3 whitePos = grainPos * 80.0 + vec3(grainTime * 30.0);\n        float white = fract(sin(dot(whitePos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n        grain = mix(perlin, white, 0.3);  // 70% perlin, 30% white\n\n    } else if (uGrainType == 4) {\n        // TIP_WEIGHTED: Noise multiplied by vertical position (stronger at tips)\n        float baseNoise = snoise(grainPos + vec3(grainTime, 0.0, 0.0));\n        baseNoise = baseNoise * 0.5 + 0.5;\n        // Weight by vertical position - more grain at top (uses vVerticalGradient)\n        float tipWeight = smoothstep(0.0, 1.0, vVerticalGradient);\n        grain = baseNoise * tipWeight + (1.0 - tipWeight) * 0.8;  // Less effect at bottom\n    }\n\n    // Boost noise contrast - push values toward 0 or 1 for visible grain\n    grain = smoothstep(0.3, 0.7, grain);  // Increase contrast\n\n    // Apply grain based on blend mode\n    float grainEffect = mix(1.0, grain, uGrainStrength);\n\n    if (uGrainBlend == 0) {\n        // MULTIPLY: Creates noise holes for gritty texture\n        // Uses pre-computed grain value from type system (PERLIN, SIMPLEX, WHITE, FILM)\n\n        // Discard pixels where grain is below threshold (creates holes)\n        float threshold = 0.5 * uGrainStrength;\n        if (grain < threshold) {\n            discard;\n        }\n        // Darken remaining pixels based on grain\n        color *= 0.7 + grain * 0.3;\n\n    } else if (uGrainBlend == 1) {\n        // ADD: Brightens (sparkle/shimmer)\n        color += (grain - 0.5) * uGrainStrength * 0.5;\n\n    } else if (uGrainBlend == 2) {\n        // OVERLAY: Increases contrast\n        vec3 overlay;\n        for (int i = 0; i < 3; i++) {\n            float c = color[i];\n            float g = grain;\n            overlay[i] = c < 0.5 ? 2.0 * c * g : 1.0 - 2.0 * (1.0 - c) * (1.0 - g);\n        }\n        color = mix(color, overlay, uGrainStrength);\n\n    } else if (uGrainBlend == 3) {\n        // SCREEN: Soft brightening (ethereal)\n        vec3 screened = 1.0 - (1.0 - color) * (1.0 - vec3(grain * 0.5));\n        color = mix(color, screened, uGrainStrength);\n    }\n}\n",cS={animationType:0,gestureProgress:0,glowScale:1,arcWidth:.5,arcSpeed:1,arcCount:1,arcPhase:0,rippleSpeed:.5,rippleCount:3,flowDirection:0,spiralTightness:2,spiralSpeed:1,pulseFrequency:2,pulseAmplitude:.3,cutoutStrength:0,cutoutPhase:0,cutoutPattern1:-1,cutoutScale1:1,cutoutWeight1:1,cutoutPattern2:-1,cutoutScale2:1,cutoutWeight2:1,cutoutBlend:0,cutoutTravel:0,cutoutTravelSpeed:1,cutoutTravelDir:0,cutoutTravel2:-1,cutoutTravelSpeed2:1,cutoutStrengthCurve:0,cutoutFadeInDuration:1,cutoutFadeOutDuration:1,cutoutBellPeakAt:.5,cutoutBellWidth:0,trailDissolveEnabled:0,trailDissolveOffset:-.3,trailDissolveSoftness:.25,grainType:-1,grainStrength:0,grainScale:.5,grainSpeed:1,grainBlend:0,cutoutGeoMaskType:0,cutoutGeoMaskCore:.3,cutoutGeoMaskTip:.4,cutoutEdgeMask:0};function hS(){return{uAnimationType:{value:cS.animationType},uGestureProgress:{value:cS.gestureProgress},uGlowScale:{value:cS.glowScale},uArcWidth:{value:cS.arcWidth},uArcSpeed:{value:cS.arcSpeed},uArcCount:{value:cS.arcCount},uArcPhase:{value:cS.arcPhase},uRippleSpeed:{value:cS.rippleSpeed},uRippleCount:{value:cS.rippleCount},uFlowDirection:{value:cS.flowDirection},uSpiralTightness:{value:cS.spiralTightness},uSpiralSpeed:{value:cS.spiralSpeed},uPulseFrequency:{value:cS.pulseFrequency},uPulseAmplitude:{value:cS.pulseAmplitude},uCutoutStrength:{value:cS.cutoutStrength},uCutoutPhase:{value:cS.cutoutPhase},uCutoutPattern1:{value:cS.cutoutPattern1},uCutoutScale1:{value:cS.cutoutScale1},uCutoutWeight1:{value:cS.cutoutWeight1},uCutoutPattern2:{value:cS.cutoutPattern2},uCutoutScale2:{value:cS.cutoutScale2},uCutoutWeight2:{value:cS.cutoutWeight2},uCutoutBlend:{value:cS.cutoutBlend},uCutoutTravel:{value:cS.cutoutTravel},uCutoutTravelSpeed:{value:cS.cutoutTravelSpeed},uCutoutTravelDir:{value:cS.cutoutTravelDir},uCutoutTravel2:{value:cS.cutoutTravel2},uCutoutTravelSpeed2:{value:cS.cutoutTravelSpeed2},uCutoutStrengthCurve:{value:cS.cutoutStrengthCurve},uCutoutFadeInDuration:{value:cS.cutoutFadeInDuration},uCutoutFadeOutDuration:{value:cS.cutoutFadeOutDuration},uCutoutBellPeakAt:{value:cS.cutoutBellPeakAt},uCutoutBellWidth:{value:cS.cutoutBellWidth},uTrailDissolveEnabled:{value:cS.trailDissolveEnabled},uTrailDissolveOffset:{value:cS.trailDissolveOffset},uTrailDissolveSoftness:{value:cS.trailDissolveSoftness},uGrainType:{value:cS.grainType},uGrainStrength:{value:cS.grainStrength},uGrainScale:{value:cS.grainScale},uGrainSpeed:{value:cS.grainSpeed},uGrainBlend:{value:cS.grainBlend},uCutoutGeoMaskType:{value:cS.cutoutGeoMaskType},uCutoutGeoMaskCore:{value:cS.cutoutGeoMaskCore},uCutoutGeoMaskTip:{value:cS.cutoutGeoMaskTip},uCutoutEdgeMask:{value:cS.cutoutEdgeMask}}}function dS(e,t){if(!e?.uniforms)return;if("number"==typeof t)return e.uniforms.uCutoutStrength.value=Math.max(0,Math.min(1,t)),void(e.uniforms.uCutoutPattern1.value=0);const{strength:n=cS.cutoutStrength,phase:a=cS.cutoutPhase,primary:i,secondary:r,blend:s="multiply",travel:o="none",travelSpeed:l=cS.cutoutTravelSpeed,travelDir:c="forward",strengthCurve:h="constant",fadeInDuration:d=cS.cutoutFadeInDuration,fadeOutDuration:u=cS.cutoutFadeOutDuration,bellPeakAt:p=cS.cutoutBellPeakAt,bellWidth:m=cS.cutoutBellWidth,trailDissolve:f,geometricMask:g,edgeMask:y=0,pattern:v,scale:b}=t||{},w="number"==typeof s?s:{multiply:0,min:1,max:2,add:3}[s]??0,x={none:0,angular:1,radial:2,spiral:3,oscillate:4,wave:5,vertical:6,consume:7},S="number"==typeof o?o:x[o]??0,M="number"==typeof c?c:{forward:0,reverse:1,pingpong:2}[c]??0,_="number"==typeof h?h:{constant:0,fadeIn:1,fadeOut:2,bell:3,pulse:4,topHeavy:5,tips:6,consume:7}[h]??0;if(e.uniforms.uCutoutStrength.value=Math.max(0,Math.min(1,n)),e.uniforms.uCutoutPhase.value=a,e.uniforms.uCutoutBlend.value=w,e.uniforms.uCutoutTravel.value=S,e.uniforms.uCutoutTravelSpeed.value=l,e.uniforms.uCutoutTravelDir.value=M,e.uniforms.uCutoutStrengthCurve.value=_,e.uniforms.uCutoutFadeInDuration.value=Math.max(.01,Math.min(1,d)),e.uniforms.uCutoutFadeOutDuration.value=Math.max(.01,Math.min(1,u)),e.uniforms.uCutoutBellPeakAt.value=Math.max(.01,Math.min(.99,p)),e.uniforms.uCutoutBellWidth.value=Math.max(0,Math.min(.95,m)),f?(e.uniforms.uTrailDissolveEnabled.value=!1!==f.enabled?1:0,void 0!==f.offset&&(e.uniforms.uTrailDissolveOffset.value=f.offset),void 0!==f.softness&&(e.uniforms.uTrailDissolveSoftness.value=Math.max(.01,f.softness))):e.uniforms.uTrailDissolveEnabled.value=0,g){let t=0;"number"==typeof g.type?t=g.type:"distance"===g.type?t=1:"inverted-distance"===g.type?t=2:"tip-boost"===g.type&&(t=3),e.uniforms.uCutoutGeoMaskType.value=t,void 0!==g.core&&(e.uniforms.uCutoutGeoMaskCore.value=g.core),void 0!==g.tip&&(e.uniforms.uCutoutGeoMaskTip.value=g.tip)}else e.uniforms.uCutoutGeoMaskType.value=0;if(e.uniforms.uCutoutEdgeMask&&(e.uniforms.uCutoutEdgeMask.value=Math.max(0,Math.min(1,y))),void 0!==i)if(e.uniforms.uCutoutPattern1.value=i.pattern??0,e.uniforms.uCutoutScale1.value=i.scale??1,e.uniforms.uCutoutWeight1.value=i.weight??1,void 0!==r)if(e.uniforms.uCutoutPattern2.value=r.pattern??-1,e.uniforms.uCutoutScale2.value=r.scale??1,e.uniforms.uCutoutWeight2.value=r.weight??1,void 0!==r.travel){const t="number"==typeof r.travel?r.travel:x[r.travel]??-1;e.uniforms.uCutoutTravel2.value=t,e.uniforms.uCutoutTravelSpeed2.value=r.travelSpeed??1}else e.uniforms.uCutoutTravel2.value=-1;else e.uniforms.uCutoutPattern2.value=-1,e.uniforms.uCutoutTravel2.value=-1;else void 0!==v&&(e.uniforms.uCutoutPattern1.value=v,e.uniforms.uCutoutScale1.value=b??1,e.uniforms.uCutoutWeight1.value=1,e.uniforms.uCutoutPattern2.value=-1,e.uniforms.uCutoutTravel2.value=-1)}function uS(e){e?.uniforms&&(e.uniforms.uCutoutStrength.value=0,e.uniforms.uCutoutPhase.value=cS.cutoutPhase,e.uniforms.uCutoutPattern1.value=cS.cutoutPattern1,e.uniforms.uCutoutScale1.value=cS.cutoutScale1,e.uniforms.uCutoutWeight1.value=cS.cutoutWeight1,e.uniforms.uCutoutPattern2.value=cS.cutoutPattern2,e.uniforms.uCutoutScale2.value=cS.cutoutScale2,e.uniforms.uCutoutWeight2.value=cS.cutoutWeight2,e.uniforms.uCutoutBlend.value=cS.cutoutBlend,e.uniforms.uCutoutTravel.value=cS.cutoutTravel,e.uniforms.uCutoutTravelSpeed.value=cS.cutoutTravelSpeed,e.uniforms.uCutoutTravelDir.value=cS.cutoutTravelDir,e.uniforms.uCutoutTravel2.value=cS.cutoutTravel2,e.uniforms.uCutoutTravelSpeed2.value=cS.cutoutTravelSpeed2,e.uniforms.uCutoutStrengthCurve.value=cS.cutoutStrengthCurve,e.uniforms.uCutoutFadeInDuration.value=cS.cutoutFadeInDuration,e.uniforms.uCutoutFadeOutDuration.value=cS.cutoutFadeOutDuration,e.uniforms.uCutoutBellPeakAt.value=cS.cutoutBellPeakAt,e.uniforms.uCutoutBellWidth.value=cS.cutoutBellWidth,e.uniforms.uTrailDissolveEnabled.value=cS.trailDissolveEnabled,e.uniforms.uTrailDissolveOffset.value=cS.trailDissolveOffset,e.uniforms.uTrailDissolveSoftness.value=cS.trailDissolveSoftness,e.uniforms.uCutoutGeoMaskType.value=cS.cutoutGeoMaskType,e.uniforms.uCutoutGeoMaskCore.value=cS.cutoutGeoMaskCore,e.uniforms.uCutoutGeoMaskTip.value=cS.cutoutGeoMaskTip,e.uniforms.uCutoutEdgeMask&&(e.uniforms.uCutoutEdgeMask.value=cS.cutoutEdgeMask))}function pS(e,t={}){if(!e?.uniforms)return;const{type:n=iS.PERLIN,strength:a=.15,scale:i=.5,speed:r=1,blend:s="multiply"}=t,o={multiply:0,add:1,overlay:2,screen:3};e.uniforms.uGrainType.value=n,e.uniforms.uGrainStrength.value=a,e.uniforms.uGrainScale.value=i,e.uniforms.uGrainSpeed.value=r;let l=0;"number"==typeof s?l=s:s in o&&(l=o[s]),e.uniforms.uGrainBlend.value=l}function mS(e){e?.uniforms&&(e.uniforms.uGrainType.value=cS.grainType,e.uniforms.uGrainStrength.value=cS.grainStrength,e.uniforms.uGrainScale.value=cS.grainScale,e.uniforms.uGrainSpeed.value=cS.grainSpeed,e.uniforms.uGrainBlend.value=cS.grainBlend)}function fS(e,t={}){if(!e?.uniforms)return;const{type:n=0,...a}=t;e.uniforms.uAnimationType.value=n,void 0!==a.arcWidth&&(e.uniforms.uArcWidth.value=a.arcWidth),void 0!==a.arcSpeed&&(e.uniforms.uArcSpeed.value=a.arcSpeed),void 0!==a.arcCount&&(e.uniforms.uArcCount.value=a.arcCount),void 0!==a.arcPhase&&(e.uniforms.uArcPhase.value=a.arcPhase),void 0!==a.rippleSpeed&&(e.uniforms.uRippleSpeed.value=a.rippleSpeed),void 0!==a.rippleCount&&(e.uniforms.uRippleCount.value=a.rippleCount),void 0!==a.flowDirection&&(e.uniforms.uFlowDirection.value=a.flowDirection),void 0!==a.spiralTightness&&(e.uniforms.uSpiralTightness.value=a.spiralTightness),void 0!==a.spiralSpeed&&(e.uniforms.uSpiralSpeed.value=a.spiralSpeed),void 0!==a.pulseFrequency&&(e.uniforms.uPulseFrequency.value=a.pulseFrequency),void 0!==a.pulseAmplitude&&(e.uniforms.uPulseAmplitude.value=a.pulseAmplitude)}function gS(e,t){if(e?.uniforms?.uGestureProgress&&(e.uniforms.uGestureProgress.value=t),e?.userData?.gestureGlow&&e?.uniforms?.uGlowScale){const{baseGlow:n,peakGlow:a,curve:i}=e.userData.gestureGlow;let r=t;"easeIn"===i?r*=r:"easeOut"===i?r=1-(1-r)*(1-r):"easeInOut"===i&&(r=r<.5?2*r*r:1-Math.pow(-2*r+2,2)/2),e.uniforms.uGlowScale.value=n+(a-n)*r}}function yS(e,t={}){if(!e)return;const{baseGlow:n=cS.glowScale,peakGlow:a=cS.glowScale,curve:i="linear"}=t;e.userData.gestureGlow={baseGlow:n,peakGlow:a,curve:i},e?.uniforms?.uGlowScale&&(e.uniforms.uGlowScale.value=n)}function vS(e){if(e?.uniforms&&(e.uniforms.uAnimationType.value=0,e.uniforms.uGestureProgress.value=0,e.uniforms.uGlowScale)){const t=e.userData?.gestureGlow;e.uniforms.uGlowScale.value=t?.baseGlow??cS.glowScale}}function bS(e,t,n,a){return a<.5?e+2*a*(t-e):t+2*(a-.5)*(n-t)}const wS={temperature:.5,opacity:.45,flameHeight:.08,turbulence:.03,displacementStrength:.04,noiseScale:4,edgeFade:.25,fadeInDuration:.3,fadeOutDuration:.5,velocityStretch:.5},xS="\n// Permutation polynomial hash\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n// 3D Simplex noise\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\n// Cheap hash-based noise for modulation/variation (much faster than snoise)\nfloat cheapHash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\nfloat cheapNoise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(mix(cheapHash(i), cheapHash(i + vec3(1,0,0)), f.x),\n            mix(cheapHash(i + vec3(0,1,0)), cheapHash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(cheapHash(i + vec3(0,0,1)), cheapHash(i + vec3(1,0,1)), f.x),\n            mix(cheapHash(i + vec3(0,1,1)), cheapHash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\n// Fractal Brownian Motion - 2 octaves (was 3  3rd at 4x adds minimal visible detail)\nfloat fbm3(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 2; i++) {\n        value += amplitude * snoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Turbulence - absolute value FBM\nfloat turbulence(vec3 p, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 3; i++) {\n        if (i >= octaves) break;\n        value += amplitude * abs(snoise(p * frequency));\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Configurable octave FBM (3-5 octaves)\nfloat fbmConfigurable(vec3 p, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 5; i++) {\n        if (i >= octaves) break;\n        value += amplitude * snoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Layered turbulence - multiple scales at different animation speeds\nfloat layeredTurbulence(vec3 p, float time) {\n    float large = turbulence(p * 0.5 + vec3(0.0, -time * 0.0025, 0.0), 3) * 0.4;\n    float medium = turbulence(p + vec3(time * 0.0015, -time * 0.005, 0.0), 3) * 0.35;\n    float fine = snoise(p * 2.5 + vec3(time * 0.003, -time * 0.01, time * 0.002)) * 0.25;\n    float micro = snoise(p * 4.0 + vec3(0.0, -time * 0.02, 0.0)) * 0.1;\n\n    return large + medium + fine + micro;\n}\n",SS=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uFlameHeight;\nuniform float uTurbulence;\nuniform float uDisplacementStrength;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;      // 0=none, 1=rotating arc\nuniform float uArcWidth;         // Arc width in radians\nuniform float uArcSpeed;         // Rotations per gesture\nuniform int uArcCount;           // Number of visible arcs\nuniform float uArcPhase;         // Arc starting angle in radians\nuniform float uGestureProgress;  // 0-1 gesture progress\nuniform int uRelayCount;         // Number of relay rings\nuniform float uRelayArcWidth;   // Relay arc width in radians\nuniform float uRelayFloor;\n// Note: Arc phase is now a per-instance attribute (aArcPhase) from InstancedShaderUtils\n\n// Per-instance attributes\n${nS}\n\n// Velocity stretch uniform\nuniform float uVelocityStretch;\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;  // Instance origin in world space (for trail dissolve)\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vDisplacement;\nvarying float vVerticalGradient;\nvarying float vArcVisibility;  // 0-1 visibility based on arc position\nvarying float vRandomSeed;     // Pass random seed to fragment for per-instance variation\n\n${xS}\n\nvoid main() {\n    // \n    // INSTANCING: Calculate local time and fade\n    // \n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade in/out - now controlled entirely by aInstanceOpacity from AnimationState\n    // The shader's built-in fadeIn/fadeOut (based on spawn/exit time) is disabled\n    // so that AnimationState has full control over fade timing\n    float fadeIn = 1.0;  // Disabled - AnimationState controls via aInstanceOpacity\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    // aInstanceOpacity now controls ALL fade timing (enter/hold/exit)\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // \n    // MODEL SELECTION: Scale non-selected models to zero\n    // \n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // \n    // TRAIL OFFSET: Position trails behind main along velocity\n    // \n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // \n    // FIRE ANIMATION (using local time, not global)\n    // \n\n    vPosition = selectedPosition;\n    // Note: Normal transform will be done after instanceMatrix is applied\n\n    float modelHeight = 1.0;\n    vVerticalGradient = (selectedPosition.y + 0.5) / modelHeight;\n    vVerticalGradient = clamp(vVerticalGradient, 0.0, 1.0);\n\n    // Use instance fade for displacement\n    // aInstanceOpacity provides smooth, configurable fade timing from AnimationState\n    // fadeIn is now always 1.0 (disabled), so fadeFactor = fadeOut * aInstanceOpacity\n    float fadeFactor = fadeOut * aInstanceOpacity;\n\n    // Add random seed variation for per-instance uniqueness\n    float instanceVariation = aRandomSeed * 0.3;\n\n    // Noise-based displacement (using local time for time-offset animation)\n    vec3 noisePos = selectedPosition * 3.0 + vec3(instanceVariation, -effectiveLocalTime * 0.001, instanceVariation);\n    float noiseValue = fbm3(noisePos);\n\n    float posVariation = cheapNoise(selectedPosition * 5.0 + vec3(aRandomSeed * 10.0)) * 0.6 - 0.3 + 0.85;\n\n    float heightFactor = pow(vVerticalGradient, 0.5);\n    float displacement = noiseValue * uDisplacementStrength * (0.3 + heightFactor * 0.7) * posVariation * fadeFactor;\n\n    vec3 displaced = selectedPosition + selectedNormal * displacement;\n    displaced.y += heightFactor * uFlameHeight * (0.5 + noiseValue * 0.5) * fadeFactor;\n\n    float turbX = (cheapNoise(noisePos + vec3(100.0, 0.0, 0.0)) * 2.0 - 1.0) * uTurbulence * heightFactor * posVariation * fadeFactor;\n    float turbZ = (cheapNoise(noisePos + vec3(0.0, 0.0, 100.0)) * 2.0 - 1.0) * uTurbulence * heightFactor * posVariation * fadeFactor;\n    displaced.x += turbX * 0.3;\n    displaced.z += turbZ * 0.3;\n\n    // Apply trail offset\n    displaced += trailOffset;\n\n    // \n    // VELOCITY-BASED STRETCHING\n    // \n    if (uVelocityStretch > 0.01 && length(aVelocity.xyz) > 0.01) {\n        vec3 velocityDir = normalize(aVelocity.xyz);\n        float speed = aVelocity.w;\n\n        // Project vertex onto velocity direction\n        float alongVelocity = dot(displaced, velocityDir);\n\n        // Stretch factor increases with speed\n        float stretchFactor = 1.0 + speed * uVelocityStretch * 0.5;\n\n        // Apply stretch along velocity direction (more at top of flame)\n        vec3 stretchOffset = velocityDir * alongVelocity * (stretchFactor - 1.0);\n        displaced += stretchOffset * heightFactor;\n    }\n\n    vDisplacement = displacement;\n\n    // Pass random seed to fragment for per-instance flicker variation\n    vRandomSeed = aRandomSeed;\n\n    // \n    // CRITICAL: Apply instance matrix for per-instance transforms!\n    // instanceMatrix contains position/rotation/scale set in ElementInstancePool\n    // \n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    // Transform normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve - uses cutout at instance floor)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // \n    // ARC VISIBILITY (for vortex ring effects)\n    // \n    vArcVisibility = 1.0;\n    if (aRandomSeed >= 100.0) {\n        // Generalized relay: supports arbitrary relay count via uRelayCount\n        float encoded = aRandomSeed - 100.0;\n        float ringId = floor(encoded / 10.0);\n        float instanceArcPhase = encoded - ringId * 10.0;\n\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float hw = uRelayArcWidth * 0.5;\n        float angleDiff = vertexAngle - instanceArcPhase;\n        angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n        float arcMask = 1.0 - smoothstep(hw * 0.7, hw, abs(angleDiff));\n\n        float cp = uGestureProgress * float(uRelayCount) * 1.5;\n        float d = cp - ringId;\n        float relayAlpha = smoothstep(-0.30, 0.05, d) * (1.0 - smoothstep(0.70, 1.05, d));\n        vArcVisibility = arcMask * mix(uRelayFloor, 1.0, relayAlpha);\n    } else if (uAnimationType == 1) {\n        // Calculate angle of this vertex in local XZ plane\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n\n        // Arc center rotates based on gesture progress + per-instance phase offset\n        // For vortex effects, aRandomSeed stores the arc phase (rotationOffset) instead of random value\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + uArcPhase;\n\n        // Calculate arc visibility\n        float halfWidth = uArcWidth * 3.14159;  // Convert to radians\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n\n            // Distance from vertex angle to arc center (wrapping around 2PI)\n            float angleDiff = vertexAngle - thisArcAngle;\n            angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;  // Wrap to -PI to PI\n\n            // Smooth visibility falloff at arc edges\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * instancePosition;\n}\n`,MS=`\nuniform float uGlobalTime;\nuniform float uTemperature;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uFlickerSpeed;\nuniform float uFlickerAmount;\nuniform float uNoiseScale;\nuniform float uEdgeFade;\n// Enhanced visual uniforms\nuniform float uEdgeSoftness;\nuniform float uEmberDensity;\nuniform float uEmberBrightness;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${rS}\n\n// Instancing varyings\n${aS}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;  // Instance origin in world space (for trail dissolve)\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vDisplacement;\nvarying float vVerticalGradient;\nvarying float vArcVisibility;\nvarying float vRandomSeed;\n\n${xS}\n\n// Lighter layeredTurbulence for instanced elements  drops fine+micro\n// (2 fewer snoise). Large+medium carry the visual weight on small geometry.\nfloat layeredTurbulenceLite(vec3 p, float time) {\n    float large = turbulence(p * 0.5 + vec3(0.0, -time * 0.0025, 0.0), 3) * 0.4;\n    float medium = turbulence(p + vec3(time * 0.0015, -time * 0.005, 0.0), 3) * 0.35;\n    return large + medium;\n}\n\n\n// Blackbody-inspired color ramp with ethereal outer wisps\nvec3 fireColor(float t, float temperature, float edgeFactor) {\n    float heat = t * (0.5 + temperature * 0.5);\n    vec3 color;\n\n    if (heat < 0.2) {\n        float f = heat / 0.2;\n        color = vec3(0.3 + f * 0.4, f * 0.15, 0.0);\n    } else if (heat < 0.4) {\n        float f = (heat - 0.2) / 0.2;\n        color = vec3(0.7 + f * 0.3, 0.15 + f * 0.45, f * 0.05);\n    } else if (heat < 0.6) {\n        float f = (heat - 0.4) / 0.2;\n        color = vec3(1.0, 0.6 + f * 0.25, 0.05 + f * 0.15);\n    } else if (heat < 0.8) {\n        float f = (heat - 0.6) / 0.2;\n        color = vec3(1.0, 0.85 + f * 0.15, 0.2 + f * 0.5);\n    } else {\n        float f = (heat - 0.8) / 0.2;\n        color = vec3(1.0 - f * 0.15, 1.0, 0.7 + f * 0.3);\n    }\n\n    vec3 etherealTint = vec3(0.5, 0.6, 1.0);\n    float heatPreserve = max(0.3, 1.0 - heat * 0.7);\n    float etherealAmount = edgeFactor * heatPreserve * 0.5;\n    color = mix(color, etherealTint * 0.6, etherealAmount);\n\n    return color;\n}\n\n${sS}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewDir);\n\n    // Use local time for animation\n    float localTime = vLocalTime;\n\n    // \n    // FLAME PATTERN (Layered multi-scale noise)\n    // \n\n    vec3 noisePos = vPosition * uNoiseScale + vec3(0.0, -localTime * 0.00085, 0.0);\n\n    // Layered turbulence (lite  large+medium only, drops fine+micro snoise)\n    float flame = layeredTurbulenceLite(noisePos, localTime);\n\n    // Position-based variation for non-uniform flames (cheapNoise sufficient for modulation)\n    float posVariation = cheapNoise(vPosition * 7.0) * 0.30 - 0.15 + 0.92;\n    flame *= posVariation;\n\n    // \n    // VERTICAL FALLOFF\n    // \n\n    float verticalFade = 1.0 - pow(vVerticalGradient, 1.5);\n    float tipBrightness = smoothstep(0.7, 0.9, vVerticalGradient) * flame * 0.5;\n\n    // \n    // ENHANCED PER-INSTANCE FLICKER\n    // \n\n    // Per-instance random phase and frequency for organic chaos\n    float instancePhase = vRandomSeed * 6.28318;\n    float instanceFreq = 0.8 + vRandomSeed * 0.4;\n\n    // Multi-frequency flicker (sin-based for smooth oscillation)\n    float f1 = sin(localTime * uFlickerSpeed * instanceFreq + instancePhase);\n    float f2 = sin(localTime * uFlickerSpeed * 2.3 * instanceFreq + instancePhase * 1.7) * 0.3;\n    float f3 = sin(localTime * uFlickerSpeed * 0.7 * instanceFreq + instancePhase * 0.5) * 0.2;\n\n    float flickerCombined = (f1 + f2 + f3) * 0.5 + 0.5;\n    float flicker = 1.0 - uFlickerAmount + uFlickerAmount * flickerCombined;\n\n    // Micro-flicker for fine detail (cheapNoise  5% variance doesn't need simplex)\n    float microFlicker = 0.95 + 0.05 * (cheapNoise(vec3(localTime * 0.004, vPosition.yz * 6.0)) * 2.0 - 1.0);\n    flicker *= microFlicker;\n\n    // \n    // FRESNEL EDGE GLOW (Softer for ethereal look)\n    // \n\n    float fresnel = 1.0 - abs(dot(normal, viewDir));\n    float softFresnel = pow(fresnel, 2.5);  // Softer power\n    float edgeGlow = softFresnel * (0.5 + flame * 0.5);\n\n    // Edge factor for ethereal color tinting\n    float edgeFactor = softFresnel * (1.0 - flame * 0.3);\n\n    // \n    // COLOR CALCULATION\n    // \n\n    float localIntensity = flame * verticalFade * flicker + tipBrightness + edgeGlow * 0.3;\n    localIntensity = clamp(localIntensity, 0.0, 1.0);\n\n    // DECOUPLED: Color ramp always in warm-to-hot range (0.51.0).\n    // Noise shifts hue (orangeyellow-white) but color is NEVER dark/brown.\n    // Visibility is controlled by alpha alone, not color darkness.\n    float colorIntensity = 0.5 + localIntensity * 0.5;\n    vec3 color = fireColor(colorIntensity, uTemperature, edgeFactor);\n    color *= uIntensity;\n\n    // \n    // EMBER/SPARK GENERATION (scaled by uGlowScale)\n    // \n\n    if (uEmberDensity > 0.01) {\n        vec3 emberPos = vPosition * 15.0 + vec3(localTime * 0.002, -localTime * 0.008, localTime * 0.001);\n        float emberNoise = cheapNoise(emberPos) * 2.0 - 1.0;\n\n        // Sparse bright spots via threshold\n        float emberThreshold = 0.75 - uEmberDensity * 0.3;\n        float embers = smoothstep(emberThreshold, emberThreshold + 0.1, emberNoise);\n\n        // Embers concentrate near top (rising sparks)\n        embers *= smoothstep(0.2, 0.8, vVerticalGradient);\n\n        // Flicker embers (cheapNoise  modulation only)\n        float emberFlicker = 0.7 + 0.3 * (cheapNoise(vec3(localTime * 0.02, emberPos.xy)) * 2.0 - 1.0);\n        embers *= emberFlicker;\n\n        // Add white-hot ember color (scaled by uGlowScale for gesture glow ramping)\n        color += vec3(1.0, 0.9, 0.7) * embers * uEmberBrightness * uIntensity * uGlowScale;\n    }\n\n    // \n    // EDGE GLOW (scaled by uGlowScale)\n    // \n\n    // Fresnel edge glow for ethereal effect\n    color += softFresnel * vec3(0.8, 0.6, 0.3) * uIntensity * 0.2 * uGlowScale;\n\n    // Instance fade is applied through alpha only (not color).\n    // With AdditiveBlending (src.rgb * src.a + dst.rgb), applying vInstanceAlpha\n    // to both color AND alpha would cause squared attenuation (vInstanceAlpha).\n\n    // \n    // ALPHA CALCULATION  noise is the sole visibility driver\n    // \n\n    // Wide smoothstep range: only the hottest spots reach full alpha.\n    // Most of the surface is partially transparent, so additive stacking\n    // builds up gradually (orange  yellow  white-hot) instead of instant white.\n    float alpha = smoothstep(0.1, 0.85, localIntensity) * uOpacity;\n\n    // Vertical fade  tips become slightly more transparent\n    alpha *= mix(1.0, 1.0 - vVerticalGradient * 0.4, 0.3);\n\n    // Fresnel adds brightness at edges\n    alpha += softFresnel * 0.15 * flame;\n\n    alpha = clamp(alpha, 0.0, 1.0);\n\n    // Apply instance alpha (spawn/exit fade + trail fade)\n    alpha *= vInstanceAlpha;\n\n    // Apply arc visibility (for vortex/relay effects)\n    if (vArcVisibility < 0.999) {\n        alpha *= vArcVisibility;\n        color *= mix(0.3, 1.0, vArcVisibility);\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // No floor color needed  color is always warm (colorIntensity >= 0.5).\n    // Low-noise areas are invisible via alpha, not dark via color.\n    if (alpha < 0.08) discard;\n\n    // Shared cutout system from InstancedAnimationCore\n    ${oS}\n\n    // Grain effect (noise texture overlay for gritty realism)\n    ${lS}\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,_S=fS;function AS(e,t,n,a){return a<.5?e+2*a*(t-e):t+2*(a-.5)*(n-t)}const CS={turbulence:.5,opacity:.85,noiseScale:3,edgeFade:.15,glowScale:1,fadeInDuration:.3,fadeOutDuration:.5},TS="\n// Permutation polynomial hash\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n// 3D Simplex noise\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\n// Fractal Brownian Motion - 4 octaves for fluid motion\nfloat fbm4(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 4; i++) {\n        value += amplitude * snoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Hash function for Voronoi and bubble patterns\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// 3D value noise (trilinear interpolated hash)\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\n// Animated 2D Voronoi for caustic ray patterns  sin-free hash, squared distance comparison\nvec3 voronoiCaustic(vec2 p, float time) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float d1sq = 10.0, d2sq = 10.0;\n    float cell1Hash = 0.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 nb = vec2(float(x), float(y));\n            vec2 cell = i + nb;\n            // Sin-free 2D hash\n            vec2 ch = fract(vec2(dot(cell, vec2(127.1, 311.7)), dot(cell, vec2(269.5, 183.3))) * 0.0243902);\n            ch = fract(ch * (ch + 33.33));\n            float h = ch.x;\n            float h2 = ch.y;\n            vec2 pt = nb + vec2(h, h2) + vec2(\n                (fract(time * 0.48 + h) * 2.0 - 1.0) * 0.15,\n                (fract(time * 0.40 + h2) * 2.0 - 1.0) * 0.15\n            );\n            vec2 diff = f - pt;\n            float dsq = dot(diff, diff);\n            if (dsq < d1sq) { d2sq = d1sq; d1sq = dsq; cell1Hash = h; }\n            else if (dsq < d2sq) { d2sq = dsq; }\n        }\n    }\n    return vec3(sqrt(d2sq) - sqrt(d1sq), cell1Hash, 0.0);\n}\n\n// Water bubbles with rising animation\nvec2 waterBubbles3D(vec3 p, float scale, float density, float time) {\n    vec3 sp = p * scale + vec3(0.0, time * 0.3, 0.0);\n    vec3 i = floor(sp);\n    vec3 f = fract(sp);\n\n    float bright = 0.0;\n    float ringDark = 0.0;\n\n    for (int x = 0; x <= 1; x++) {\n        for (int y = 0; y <= 1; y++) {\n            for (int z = 0; z <= 1; z++) {\n                vec3 nb = vec3(float(x), float(y), float(z));\n                vec3 cid = i + nb;\n\n                float exists = hash(cid * 1.7 + 3.73);\n                if (exists < density) {\n                    vec3 center = nb + vec3(\n                        hash(cid + 0.37),\n                        hash(cid + 1.51),\n                        hash(cid + 2.93)\n                    ) * 0.6 + 0.2;\n                    float r = mix(0.10, 0.25, hash(cid + 4.31));\n                    float d = length(f - center);\n\n                    if (d < r) {\n                        float nd = d / r;\n                        bright += (1.0 - nd * nd) * 0.55;\n                        ringDark += smoothstep(0.65, 0.95, nd) * 0.5;\n                        vec3 sphereDir = normalize(f - center);\n                        bright += pow(max(dot(sphereDir, normalize(vec3(0.3, 0.8, 0.2))), 0.0), 6.0) * 0.2;\n                    }\n                }\n            }\n        }\n    }\n    return vec2(bright, ringDark);\n}\n",PS=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uTurbulence;\nuniform float uDisplacementStrength;\nuniform float uFlowSpeed;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;      // 0=none, 1=rotating arc\nuniform float uArcWidth;         // Arc width in radians\nuniform float uArcSpeed;         // Rotations per gesture\nuniform int uArcCount;           // Number of visible arcs\nuniform float uArcPhase;         // Arc starting angle in radians\nuniform float uGestureProgress;  // 0-1 gesture progress\nuniform int uRelayCount;         // Number of relay rings\nuniform float uRelayArcWidth;   // Relay arc width in radians\nuniform float uRelayFloor;\n\n// Per-instance attributes\n${nS}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;  // Instance origin in world space (for trail dissolve)\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vDisplacement;\nvarying float vNoiseValue;\nvarying float vRandomSeed;\nvarying float vArcVisibility;  // 0-1 visibility based on arc position\nvarying float vVerticalGradient;  // Normalized vertical position (0=bottom, 1=top) for tip effects\nvarying vec3 vWorldNormal;   // World-space normal for refraction\nvarying vec3 vViewPosition;  // View-space position for refraction\n\n${TS}\n\nvoid main() {\n    // \n    // INSTANCING: Calculate local time and fade\n    // \n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade in/out controlled by aInstanceOpacity from AnimationState\n    float fadeIn = 1.0;\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // \n    // MODEL SELECTION: Scale non-selected models to zero\n    // \n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // \n    // TRAIL OFFSET: Position trails behind main along velocity\n    // \n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // \n    // WATER DISPLACEMENT (using local time)\n    // \n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n\n    // Calculate vertical gradient for tip-based effects\n    // Normalize Y position to 0-1 range (assuming model centered at y=0)\n    float modelHeight = 1.0;  // Water models are typically unit-sized\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / modelHeight, 0.0, 1.0);\n\n    // Animated noise for fluid wobble\n    float instanceVariation = aRandomSeed * 0.3;\n    vec3 noisePos = selectedPosition * 2.5 + vec3(\n        effectiveLocalTime * uFlowSpeed * 0.002 + instanceVariation,\n        effectiveLocalTime * uFlowSpeed * 0.001,\n        effectiveLocalTime * uFlowSpeed * 0.0015 + instanceVariation\n    );\n    float noiseValue = fbm4(noisePos);\n    vNoiseValue = noiseValue * 0.5 + 0.5;\n\n    // Position-based variation for asymmetric wobble\n    float posVariation = snoise(selectedPosition * 3.0 + vec3(aRandomSeed * 10.0)) * 0.4 + 0.8;\n\n    // Primary displacement along normal (fluid bulging)\n    float fadeFactor = fadeOut * aInstanceOpacity;\n    float baseDisplacement = noiseValue * uDisplacementStrength * (0.4 + uTurbulence * 0.6) * posVariation;\n\n    vec3 displaced = selectedPosition + selectedNormal * baseDisplacement * fadeFactor;\n\n    // Secondary wobble - perpendicular fluid motion\n    vec3 perpNoise = selectedPosition * 2.0 + vec3(\n        effectiveLocalTime * uFlowSpeed * 0.001,\n        effectiveLocalTime * uFlowSpeed * 0.0008,\n        0.0\n    );\n    float wobbleX = snoise(perpNoise + vec3(50.0, 0.0, 0.0)) * uDisplacementStrength * uTurbulence * 0.5 * fadeFactor;\n    float wobbleY = snoise(perpNoise + vec3(0.0, 50.0, 0.0)) * uDisplacementStrength * uTurbulence * 0.3 * fadeFactor;\n    float wobbleZ = snoise(perpNoise + vec3(0.0, 0.0, 50.0)) * uDisplacementStrength * uTurbulence * 0.5 * fadeFactor;\n    displaced.x += wobbleX;\n    displaced.y += wobbleY;\n    displaced.z += wobbleZ;\n\n    // \n    // ANIMATED SURFACE WAVES  visible undulation of the water surface\n    // Two frequency layers: broad swells + fine ripples.\n    // The analytical gradient perturbs the normal so specular and refraction\n    // react to the wave shapes, not just the flat polygon normal.\n    // \n    float wt = uGlobalTime * 0.001;\n\n    // Broad swells (5 cycles across model, slow drift)\n    float wave1 = sin(selectedPosition.x * 5.0 + wt * 3.0)\n                * cos(selectedPosition.z * 4.0 + wt * 2.0);\n    // Fine ripples (12 cycles, faster counter-drift)\n    float wave2 = sin(selectedPosition.x * 12.0 - wt * 4.0)\n                * cos(selectedPosition.z * 9.0 + wt * 3.5);\n\n    float waveDispl = (wave1 * 0.07 + wave2 * 0.03) * fadeFactor;\n    displaced += selectedNormal * waveDispl;\n\n    // Analytical gradient: dh/dx and dh/dz for normal perturbation\n    // Normal perturbation amplified 3x beyond displacement  strong refraction waviness\n    // without moving geometry enough to create spikes on low-poly mesh\n    float normalBoost = 1.5;\n    float dwdx = (5.0  * cos(selectedPosition.x * 5.0  + wt * 3.0) * cos(selectedPosition.z * 4.0 + wt * 2.0) * 0.07\n               +  12.0 * cos(selectedPosition.x * 12.0 - wt * 4.0) * cos(selectedPosition.z * 9.0 + wt * 3.5) * 0.03) * normalBoost;\n    float dwdz = (-4.0 * sin(selectedPosition.x * 5.0  + wt * 3.0) * sin(selectedPosition.z * 4.0 + wt * 2.0) * 0.07\n               +  -9.0 * sin(selectedPosition.x * 12.0 - wt * 4.0) * sin(selectedPosition.z * 9.0 + wt * 3.5) * 0.03) * normalBoost;\n\n    // Perturbed normal: standard height-field approximation N' = normalize(N - gradient)\n    vec3 waveNormal = normalize(selectedNormal - vec3(dwdx, 0.0, dwdz) * fadeFactor);\n\n    // Apply trail offset\n    displaced += trailOffset;\n\n    vDisplacement = baseDisplacement;\n\n    // Transform wave-perturbed normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * waveNormal;\n\n    // \n    // Apply instance matrix for per-instance transforms\n    // \n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve - uses cutout at instance floor)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // \n    // ARC VISIBILITY (for vortex ring effects)\n    // \n    vArcVisibility = 1.0;\n    if (aRandomSeed >= 100.0) {\n        // Generalized relay: supports arbitrary relay count via uRelayCount\n        float encoded = aRandomSeed - 100.0;\n        float ringId = floor(encoded / 10.0);\n        float instanceArcPhase = encoded - ringId * 10.0;\n\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float hw = uRelayArcWidth * 0.5;\n        float angleDiff = vertexAngle - instanceArcPhase;\n        angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n        float arcMask = 1.0 - smoothstep(hw * 0.7, hw, abs(angleDiff));\n\n        float cp = uGestureProgress * float(uRelayCount) * 1.5;\n        float d = cp - ringId;\n        float relayAlpha = smoothstep(-0.30, 0.05, d) * (1.0 - smoothstep(0.70, 1.05, d));\n        vArcVisibility = arcMask * mix(uRelayFloor, 1.0, relayAlpha);\n    } else if (uAnimationType == 1) {\n        // Calculate angle of this vertex in local XZ plane\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n\n        // Arc center rotates based on gesture progress + per-instance phase offset\n        // aRandomSeed stores the arc phase (rotationOffset) for vortex effects\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + uArcPhase;\n\n        // Calculate arc visibility\n        float halfWidth = uArcWidth * 3.14159;  // Convert to radians\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n\n            // Distance from vertex angle to arc center (wrapping around 2PI)\n            float angleDiff = vertexAngle - thisArcAngle;\n            angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;  // Wrap to -PI to PI\n\n            // Smooth visibility falloff at arc edges\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    // World-space normal for refraction (wave-perturbed)\n    vec3 transformedNormal = (instanceMatrix * vec4(waveNormal, 0.0)).xyz;\n    vWorldNormal = normalize(mat3(modelMatrix) * transformedNormal);\n\n    // View-space position for refraction\n    vec4 mvPosition = modelViewMatrix * instancePosition;\n    vViewPosition = mvPosition.xyz;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n`,DS=`\nuniform float uGlobalTime;\nuniform float uTurbulence;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uFlowSpeed;\nuniform float uNoiseScale;\nuniform float uEdgeFade;\nuniform float uBloomThreshold;  // Mascot-specific bloom threshold for compression\nuniform vec3 uTint;\n\n// Enhanced water system uniforms\nuniform float uDepthGradient;      // Depth-based color variation strength (0=off, 1=full)\nuniform float uInternalFlowSpeed;  // Internal spiral/flow animation speed multiplier\nuniform float uSparkleIntensity;   // Specular sparkle highlight intensity\n\n// Screen-space refraction uniforms\nuniform sampler2D uBackgroundTexture;\nuniform vec2 uResolution;\nuniform int uHasBackground;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${rS}\n\n// Instancing varyings\n${aS}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;  // Instance origin in world space (for trail dissolve)\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vDisplacement;\nvarying float vNoiseValue;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewPosition;\n\n${TS}\n\nconst vec3 WATER_DEEP = vec3(0.05, 0.15, 0.35);\nconst vec3 WATER_MID = vec3(0.15, 0.4, 0.6);\nconst vec3 WATER_BRIGHT = vec3(0.3, 0.6, 0.8);\nconst vec3 WATER_FOAM = vec3(0.85, 0.92, 1.0);\nconst vec3 WATER_SUBSURFACE = vec3(0.2, 0.5, 0.7);\n\nvec3 waterColor(float intensity, float turbulence) {\n    vec3 color;\n    if (intensity < 0.5) {\n        color = mix(WATER_DEEP, WATER_MID, intensity * 2.0);\n    } else if (intensity < 0.8) {\n        color = mix(WATER_MID, WATER_BRIGHT, (intensity - 0.5) * 3.33);\n    } else {\n        color = mix(WATER_BRIGHT, WATER_FOAM, (intensity - 0.8) * 5.0);\n    }\n    return color;\n}\n\n${sS}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    // Use local time for animation\n    float localTime = vLocalTime;\n\n    // \n    // CORE WATER EFFECTS (from WaterShaderCore)\n    // Includes: patterns, caustics, fresnel, subsurface, specular, depth variation\n    // \n    \n    vec3 viewDir = normalize(vViewDir);\n\n    vec3 worldNormal = normalize(vWorldNormal);\n    if (length(vWorldNormal) < 0.01) worldNormal = viewDir;\n    worldNormal = faceforward(worldNormal, -viewDir, worldNormal);\n\n    float smoothNdotV = max(0.0, dot(worldNormal, viewDir));\n    float fresnel = pow(1.0 - smoothNdotV, 3.0);\n    float thickness = smoothNdotV * smoothNdotV * 0.5;\n\n    float F0 = 0.02;\n    float schlick = F0 + (1.0 - F0) * fresnel;\n\n    vec3 waterBodyColor = vec3(0.05, 0.15, 0.30) * uTint;\n    vec3 transmittedLight;\n    float bgPresence = 1.0;\n\n    if (uHasBackground == 1) {\n        vec2 screenUV = gl_FragCoord.xy / uResolution;\n\n        vec3 I_vs = normalize(vViewPosition);\n        vec3 N_vs = faceforward(normalize(vNormal), I_vs, normalize(vNormal));\n\n        vec3 refDir = refract(I_vs, N_vs, 0.75);\n        if (length(refDir) < 0.1) refDir = I_vs;\n        float physDistortion = 0.04 + thickness * 0.10;\n        vec2 physOffset = refDir.xy * physDistortion;\n\n        float rt = uGlobalTime * 0.001;\n        vec2 ripple1 = vec2(\n            sin(vPosition.x * 8.0 + rt * 4.0) * cos(vPosition.z * 6.0 + rt * 3.0),\n            cos(vPosition.x * 7.0 - rt * 3.5) * sin(vPosition.z * 9.0 + rt * 2.5)\n        ) * 0.15;\n        vec2 ripple2 = vec2(\n            sin(vPosition.x * 15.0 - rt * 5.0 + 1.7) * cos(vPosition.z * 12.0 + rt * 4.5),\n            cos(vPosition.x * 13.0 + rt * 6.0) * sin(vPosition.z * 16.0 - rt * 3.0)\n        ) * 0.08;\n        vec2 rippleOffset = (ripple1 + ripple2) * 0.60;\n\n        vec2 totalOffset = physOffset + rippleOffset;\n\n        vec4 bgCenter = texture2D(uBackgroundTexture, clamp(screenUV + totalOffset, 0.0, 1.0));\n        bgPresence = smoothstep(0.05, 0.3, bgCenter.a);\n\n        vec3 refractedBg;\n        if (bgPresence > 0.1) {\n            refractedBg = vec3(\n                texture2D(uBackgroundTexture, clamp(screenUV + totalOffset * 0.97, 0.0, 1.0)).r,\n                bgCenter.g,\n                texture2D(uBackgroundTexture, clamp(screenUV + totalOffset * 1.03, 0.0, 1.0)).b\n            );\n        } else {\n            refractedBg = bgCenter.rgb;\n        }\n\n        vec3 skyTint = vec3(0.12, 0.20, 0.30) * uTint;\n        vec3 ambientLift = mix(skyTint, vec3(0.03, 0.06, 0.10), bgPresence);\n        refractedBg += ambientLift * (vec3(1.0) - refractedBg);\n\n        transmittedLight = mix(refractedBg, waterBodyColor, thickness * 0.15);\n    } else {\n        vec3 voidColor = vec3(0.08, 0.15, 0.25);\n        transmittedLight = mix(voidColor, waterBodyColor, thickness * 0.3);\n    }\n\n    vec3 absorptionTint = mix(vec3(1.0), vec3(0.65, 0.85, 1.0), 0.20 + thickness * 0.8);\n    transmittedLight *= absorptionTint;\n\n    transmittedLight *= (1.0 - fresnel * 0.08);\n\n    vec2 parallaxDir = viewDir.xz / max(smoothNdotV, 0.25);\n    vec2 coarseParallax = parallaxDir * 0.08;\n    vec2 fineParallax = parallaxDir * 0.12;\n\n    float breakNoise = noise(vec3(vPosition.xz * 0.4, 0.0));\n    float causticMask = smoothstep(0.55, 0.85, breakNoise);\n\n    float causticTime = uGlobalTime * 0.001;\n\n    vec3 coarseCaustic = voronoiCaustic(\n        (vPosition.xz + coarseParallax) * 3.0 + vec2(vRandomSeed * 3.0),\n        causticTime\n    );\n    vec3 fineCaustic = voronoiCaustic(\n        (vPosition.xz + fineParallax) * 6.0 + vec2(vRandomSeed * 5.7),\n        causticTime * 1.3\n    );\n\n    float coarseAngle = coarseCaustic.y * 6.28318;\n    vec2 coarsePlaneDir = vec2(cos(coarseAngle), sin(coarseAngle));\n    float coarseSparkle = abs(dot(coarsePlaneDir, viewDir.xz));\n    coarseSparkle = mix(0.1, 1.0, coarseSparkle);\n\n    float fineAngle = fineCaustic.y * 6.28318;\n    vec2 finePlaneDir = vec2(cos(fineAngle), sin(fineAngle));\n    float fineSparkle = abs(dot(finePlaneDir, viewDir.xz));\n    fineSparkle = mix(0.1, 1.0, fineSparkle);\n\n    float coarseBright = 1.0 - smoothstep(0.0, 0.03, coarseCaustic.x);\n    float fineBright = 1.0 - smoothstep(0.0, 0.02, fineCaustic.x);\n\n    float causticCombined = (coarseBright * coarseSparkle * 0.6 + fineBright * fineSparkle * 0.4) * causticMask;\n\n    transmittedLight *= 1.0 + causticCombined * 0.04;\n\n    vec3 bubbleParallax = viewDir * 0.08 / max(smoothNdotV, 0.25);\n    vec3 bubbleSamplePos = vPosition + bubbleParallax + vec3(vRandomSeed * 10.0);\n\n    float bubbleClusterMask = 0.5 + 0.5 * causticMask;\n\n    vec2 bub = waterBubbles3D(bubbleSamplePos, 20.0, 0.50, uGlobalTime * 0.001);\n\n    float fizz = smoothstep(0.84, 0.90, noise(bubbleSamplePos * 40.0)) * 0.15;\n\n    float bubbleBright = (bub.x + fizz) * bubbleClusterMask;\n    float bubbleRing = bub.y * bubbleClusterMask;\n\n    vec3 wetReflDir = reflect(-viewDir, worldNormal);\n\n    float wetSpec1 = pow(max(dot(wetReflDir, normalize(vec3(0.5, 1.0, 0.3))), 0.0), 128.0);\n    float wetSpec2 = pow(max(dot(wetReflDir, normalize(vec3(-0.4, 0.8, -0.4))), 0.0), 128.0) * 0.7;\n    float wetSpec3 = pow(max(dot(wetReflDir, normalize(vec3(-0.3, 0.6, 0.7))), 0.0), 96.0) * 0.5;\n    float wetSpec4 = pow(max(dot(wetReflDir, normalize(vec3(0.2, 0.9, -0.3))), 0.0), 160.0) * 0.4;\n    float broadSpec = (wetSpec1 + wetSpec2 + wetSpec3 + wetSpec4) * 1.5;\n\n    float spark1 = pow(max(dot(wetReflDir, normalize(vec3(0.5, 1.0, 0.3))), 0.0), 512.0);\n    float spark2 = pow(max(dot(wetReflDir, normalize(vec3(-0.3, 0.9, 0.4))), 0.0), 512.0) * 0.6;\n    float spark3 = pow(max(dot(wetReflDir, normalize(vec3(0.4, 0.7, -0.5))), 0.0), 384.0) * 0.4;\n\n    float sparkleAnim = noise(vPosition * 8.0 + vec3(localTime * 0.004));\n\n    float sharpSpec = (spark1 + spark2 + spark3) * sparkleAnim * 3.0 * uSparkleIntensity;\n\n    vec3 specContrib = vec3(0.85, 0.92, 1.0) * (broadSpec + sharpSpec);\n\n    vec3 color = transmittedLight;\n\n    float softCap = uBloomThreshold + 0.40;\n    float maxChannel = max(color.r, max(color.g, color.b));\n    if (maxChannel > softCap) {\n        color *= softCap / maxChannel;\n    }\n\n    color += specContrib;\n    color += vec3(0.80, 0.85, 0.92) * bubbleBright * 0.35;\n    color -= vec3(0.05, 0.04, 0.02) * bubbleRing;\n\n    float edgeAlpha = smoothstep(0.08, 0.60, smoothNdotV) * 0.25;\n    float skyAlpha = mix(0.25, 1.0, bgPresence);\n    float alpha = edgeAlpha * skyAlpha;\n\n\n    // Apply instance alpha (NormalBlending uses alpha for fade, no color pre-multiply)\n    alpha *= vInstanceAlpha;\n\n    // \n    // ARC VISIBILITY (for vortex effects)\n    // \n    if (uAnimationType == 1) {\n        // Apply arc foam effect at edges (uniform-based arc only)\n        \n    float arcEdgeFoam = smoothstep(0.5, 0.85, vArcVisibility) * (1.0 - smoothstep(0.85, 1.0, vArcVisibility));\n    float leadingFoam = smoothstep(0.0, 0.3, vArcVisibility) * (1.0 - smoothstep(0.3, 0.5, vArcVisibility));\n    float totalFoam = max(arcEdgeFoam, leadingFoam * 0.7);\n\n    float foamShimmer = 0.8 + 0.2 * sin(localTime * 0.005 + vPosition.x * 10.0);\n    color = mix(color, WATER_FOAM * foamShimmer, totalFoam * 0.35);\n\n    float arcEdgeIntensity = 1.0 - vArcVisibility;\n    vec3 edgeGlow = WATER_FOAM * (0.8 + 0.15 * uGlowScale);\n    color = mix(color, edgeGlow, arcEdgeIntensity * 0.2 * uGlowScale);\n\n    color += arcEdgeIntensity * vec3(0.1, 0.2, 0.25) * 0.3 * uGlowScale;\n\n    alpha = mix(alpha, min(1.0, alpha + 0.3), totalFoam);\n\n    alpha = mix(alpha, min(1.0, alpha + 0.15), arcEdgeIntensity * 0.4);\n\n    }\n    // Apply arc visibility (for vortex/relay effects)\n    if (vArcVisibility < 0.999) {\n        alpha *= vArcVisibility;\n        color *= mix(0.3, 1.0, vArcVisibility);\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // \n    // CUTOUT EFFECT (shared pattern system from InstancedAnimationCore)\n    // \n    ${oS}\n\n    // Apply trail dissolve alpha (smooth fade at instance bottom - no hard edge)\n    // With AdditiveBlending: only fade ALPHA, keep color bright\n    // result = color * alpha + background\n    // If color is bright and alpha is low, we get a dim ADDITIVE contribution\n    // If color is dark and alpha is low, we get nearly nothing (but no darkening either)\n    alpha *= trailAlpha;\n\n    // \n    // WATER CUTOUT FOAM (brightens edges to prevent dark artifacts)\n    // \n    \n    if (uCutoutStrength > 0.01 && finalCutout < 0.99) {\n        float cutoutThreshold = 0.5;\n\n        float nearEdge = smoothstep(cutoutThreshold, cutoutThreshold + 0.15, finalCutout);\n        float farEdge = smoothstep(cutoutThreshold + 0.3, cutoutThreshold + 0.5, finalCutout);\n\n        float innerRim = nearEdge * (1.0 - smoothstep(cutoutThreshold + 0.15, cutoutThreshold + 0.25, finalCutout));\n\n        float outerGlow = nearEdge * (1.0 - farEdge) * 0.4;\n\n        float foamSparkle = sin(localTime * 0.008 + vPosition.x * 15.0 + vPosition.z * 12.0) * 0.5 + 0.5;\n        foamSparkle *= sin(localTime * 0.006 - vPosition.y * 18.0) * 0.5 + 0.5;\n        foamSparkle = pow(foamSparkle, 3.0) * innerRim;\n\n        color = mix(color, WATER_FOAM * 0.9, innerRim * uCutoutStrength * 0.3);\n        color = mix(color, WATER_BRIGHT * 0.8, outerGlow * uCutoutStrength * 0.2);\n        color = mix(color, vec3(1.0), foamSparkle * uCutoutStrength * uSparkleIntensity * 0.15);\n    }\n\n\n    // \n    // GRAIN EFFECT (noise texture overlay for gritty realism)\n    // \n    ${lS}\n\n    // \n    // DRIP ANTICIPATION (surface tension bright spots)\n    // \n    \n    // Hash-based noise instead of snoise  these just drive threshold masks\n    float dripHash1 = noise(vPosition * 8.0 + vec3(12.34, 56.78, 90.12)) * 2.0 - 1.0;\n    float dripHash2 = noise(vPosition * 8.0 + vec3(98.76, 54.32, 10.98)) * 2.0 - 1.0;\n    float dripHash3 = noise(vPosition * 6.0 + vec3(45.67, 23.45, 67.89)) * 2.0 - 1.0;\n\n    float dripPoint1 = smoothstep(0.65, 0.85, dripHash1);\n    float dripPoint2 = smoothstep(0.7, 0.88, dripHash2);\n    float dripPoint3 = smoothstep(0.72, 0.9, dripHash3);\n\n    float dripPhase1 = localTime * 0.003 + dripHash1 * 6.28318;\n    float dripPhase2 = localTime * 0.0025 + dripHash2 * 6.28318;\n    float dripPhase3 = localTime * 0.002 + dripHash3 * 6.28318;\n\n    float dripPulse1 = pow(fract(dripPhase1 * 0.15), 3.0);\n    float dripPulse2 = pow(fract(dripPhase2 * 0.12), 3.0);\n    float dripPulse3 = pow(fract(dripPhase3 * 0.1), 2.5);\n\n    float dripFlash1 = smoothstep(0.85, 0.95, dripPulse1) * (1.0 - smoothstep(0.95, 1.0, dripPulse1));\n    float dripFlash2 = smoothstep(0.85, 0.95, dripPulse2) * (1.0 - smoothstep(0.95, 1.0, dripPulse2));\n    float dripFlash3 = smoothstep(0.88, 0.96, dripPulse3) * (1.0 - smoothstep(0.96, 1.0, dripPulse3));\n\n    float tensionBulge1 = smoothstep(0.5, 0.85, dripPulse1) * dripPoint1;\n    float tensionBulge2 = smoothstep(0.5, 0.85, dripPulse2) * dripPoint2;\n    float tensionBulge = (tensionBulge1 + tensionBulge2) * 0.5;\n\n    float dripIntensity = dripPoint1 * (dripPulse1 * 0.35 + dripFlash1 * 0.65)\n                        + dripPoint2 * (dripPulse2 * 0.35 + dripFlash2 * 0.65)\n                        + dripPoint3 * (dripPulse3 * 0.3 + dripFlash3 * 0.7);\n\n    float flashTotal = dripFlash1 + dripFlash2 + dripFlash3;\n    vec3 dripColor = mix(WATER_BRIGHT, WATER_FOAM, min(1.0, flashTotal));\n\n    float rainbowPhase = localTime * 0.002 + vPosition.x * 5.0;\n    vec3 rainbowTint = vec3(\n        0.5 + 0.5 * sin(rainbowPhase),\n        0.5 + 0.5 * sin(rainbowPhase + 2.094),\n        0.5 + 0.5 * sin(rainbowPhase + 4.189)\n    );\n    dripColor = mix(dripColor, dripColor * rainbowTint, flashTotal * 0.15);\n\n    color += dripIntensity * dripColor * 0.15 * uGlowScale;\n\n    color += tensionBulge * WATER_BRIGHT * 0.10;\n\n\n    // \n    // FINAL OUTPUT\n    // \n    \n    if (alpha < 0.1) discard;\n\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,OS=fS,ES="\n// Shared wetness system (WetnessCore)\nuniform float uWetness;       // Master wetness amount (0-1)\nuniform float uWetSpeed;      // Temporal drift/breathing speed\n",IS="\n// \n// WETNESS SYSTEM (shared across earth, ice, nature)\n//\n// Noise-driven moisture patches with temporal drift, breathing, and crack pooling.\n// Host material provides noise(vec3), position, seed, time, and crack proximity.\n// \n\n/**\n * Calculate wetness mask with temporal animation and crack pooling.\n *\n * @param pos    Object-space position (vec3)\n * @param seed   Per-instance random seed for variation (float)\n * @param time   Global time for temporal animation (float)\n * @param crackProximity  0=far from crack, 1=on crack edge (float)\n * @return wetMask 0-1 (float)\n */\nfloat calculateWetMask(vec3 pos, float seed, float time, float crackProximity) {\n    // Temporal drift  patches slowly migrate across surface\n    // Different speeds in X/Z for organic, non-uniform motion\n    vec3 driftOffset = vec3(\n        time * uWetSpeed * 0.05,\n        0.0,\n        time * uWetSpeed * 0.03\n    );\n\n    // Domain warp  breaks round noise blobs into irregular organic shapes\n    // Like real moisture seeping along grain boundaries, not perfect circles\n    vec3 warpedPos = pos + vec3(\n        noise(pos * 3.0 + vec3(seed * 2.1)) * 0.3,\n        0.0,\n        noise(pos * 3.0 + vec3(0.0, seed * 3.4, 5.0)) * 0.3\n    );\n\n    // Broad damp patches (low frequency, ~8% coverage  sparse isolated pools)\n    float wetNoise1 = noise(warpedPos * 2.0 + vec3(seed * 6.0) + driftOffset);\n    float broadPatches = smoothstep(0.66, 0.80, wetNoise1);\n\n    // Smaller damp spots (higher frequency, layered on top)\n    float wetNoise2 = noise(warpedPos * 5.0 + vec3(seed * 3.0, 2.1, 0.8) + driftOffset * 1.5);\n    float smallSpots = smoothstep(0.76, 0.88, wetNoise2) * 0.5;\n\n    // Combine  whichever is stronger wins\n    float baseMask = max(broadPatches, smallSpots);\n\n    // Breathing animation  gentle pulse so wet/dry boundary shifts subtly\n    float breathe = sin(time * uWetSpeed * 0.3 + seed * 6.28);\n    baseMask *= (0.85 + breathe * 0.15);\n\n    // Crack pooling  moisture accumulates in crevices\n    // At medium wetness, cracks wet up first; at high wetness, everything is wet\n    float wetMask = min(1.0, baseMask + crackProximity * 0.25);\n\n    // Master wetness control  0 = bone dry, 1 = fully wet\n    return wetMask * uWetness;\n}\n\n/**\n * Apply darkening from moisture absorption.\n * Wet surfaces are darker because water fills pores and reduces diffuse scatter.\n *\n * @param color           Base surface color (vec3)\n * @param wetMask         Wetness mask 0-1 (float)\n * @param darkeningFactor How dark wet areas get (0.55=earth strong, 0.92=ice subtle)\n * @return darkened color (vec3)\n */\nvec3 applyWetDarkening(vec3 color, float wetMask, float darkeningFactor) {\n    return color * mix(1.0, darkeningFactor, wetMask);\n}\n";function kS(e={}){return{uWetness:{value:e.wetness??.5},uWetSpeed:{value:e.wetSpeed??.3}}}function RS(e,t){if(!e?.uniforms)return;const{wetness:n,wetSpeed:a}=t;void 0!==n&&e.uniforms.uWetness&&(e.uniforms.uWetness.value=n),void 0!==a&&e.uniforms.uWetSpeed&&(e.uniforms.uWetSpeed.value=a)}function zS(e){e?.uniforms&&(e.uniforms.uWetness&&(e.uniforms.uWetness.value=.5),e.uniforms.uWetSpeed&&(e.uniforms.uWetSpeed.value=.3))}const FS={melt:0,intensity:1,opacity:.7,frostAmount:1,internalCracks:.8,subsurfaceScatter:.15,glowScale:.1,wetSpeed:.5,fadeInDuration:.2,fadeOutDuration:.4},BS="\n// Hash function for noise\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// 3D noise\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\n// Simplex-ish noise\nfloat snoise(vec3 p) {\n    return noise(p) * 2.0 - 1.0;\n}\n\n// FBM\nfloat fbm4(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p); p *= 2.02;\n    f += 0.1250 * noise(p); p *= 2.03;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// Voronoi for crystalline patterns  2D (9 iterations, used in vertex displacement)\nfloat voronoi2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float minDist = 1.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = neighbor + hash(vec3(i + neighbor, 0.0)) * 0.8;\n            float dist = length(f - point);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n// Trapped air bubbles: 2D cell grid with circular cross-sections.\n// On thin ring geometry, Z depth is negligible  2D captures the same look.\n// Returns vec2(brightness, ringDarkness) for compositing.\nvec2 bubbleField2D(vec3 p, float scale, float density) {\n    vec2 sp = p.xz * scale;\n    vec2 i = floor(sp);\n    vec2 f = fract(sp);\n\n    float bright = 0.0;\n    float ringDark = 0.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 nb = vec2(float(x), float(y));\n            vec2 cid = i + nb;\n            vec3 cid3 = vec3(cid, 0.0);\n\n            float exists = hash(cid3 * 1.7 + 3.73);\n            if (exists < density) {\n                vec2 center = nb + vec2(\n                    hash(cid3 + 0.37),\n                    hash(cid3 + 1.51)\n                ) * 0.6 + 0.2;\n                float r = mix(0.12, 0.30, hash(cid3 + 4.31));\n                float d = length(f - center);\n\n                if (d < r) {\n                    float nd = d / r;\n                    bright += (1.0 - nd * nd) * 0.45;\n                    ringDark += smoothstep(0.65, 0.95, nd) * 0.5;\n\n                    vec2 discDir = normalize(f - center);\n                    bright += pow(max(dot(discDir, normalize(vec2(0.3, 0.2))), 0.0), 6.0) * 0.2;\n                }\n            }\n        }\n    }\n\n    return vec2(bright, ringDark);\n}\n\n// Internal fracture planes: flat disc-shaped inclusions at random orientations\n// inside the ice volume. Where the surface cuts through a fracture disc, you see\n// a bright scattered-light line that shifts with viewing angle (like real ice).\n// Each cell in the 3D grid may contain a fracture plane with:\n//   - Random center position within cell\n//   - Random plane orientation (normal vector)\n//   - Disc radius with feathery noise-perturbed edges\n//   - View-dependent brightness (planes facing camera flash bright)\n// Returns: brightness (0-1) of fracture scatter at this point.\nfloat fractureField3D(vec3 p, vec3 viewDir, float scale, float density) {\n    vec3 sp = p * scale;\n    vec3 i = floor(sp);\n    vec3 f = fract(sp);\n\n    float result = 0.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 nb = vec3(float(x), float(y), float(z));\n                vec3 cid = i + nb;\n\n                float exists = hash(cid * 2.3 + 7.91);\n                if (exists < density) {\n                    // Fracture center within cell\n                    vec3 center = nb + vec3(\n                        hash(cid + 0.37),\n                        hash(cid + 1.51),\n                        hash(cid + 2.93)\n                    ) * 0.6 + 0.2;\n\n                    // Random plane orientation\n                    vec3 planeNorm = normalize(vec3(\n                        hash(cid + 5.17) * 2.0 - 1.0,\n                        hash(cid + 6.83) * 2.0 - 1.0,\n                        hash(cid + 8.41) * 2.0 - 1.0\n                    ));\n\n                    // Distance from point to the fracture plane\n                    vec3 toPoint = f - center;\n                    float planeDist = abs(dot(toPoint, planeNorm));\n\n                    // Thick slab  0.25 ensures high intersection probability.\n                    // At scale 1.5, cell=0.67 units, slab=0.25  37% of cell height.\n                    float planeVis = 1.0 - smoothstep(0.0, 0.25, planeDist);\n\n                    // Disc boundary  large discs spanning most of the cell\n                    vec3 inPlane = toPoint - dot(toPoint, planeNorm) * planeNorm;\n                    float radialDist = length(inPlane);\n                    float discRadius = mix(0.5, 0.9, hash(cid + 9.73));\n                    float discMask = 1.0 - smoothstep(discRadius * 0.7, discRadius, radialDist);\n\n                    // No sparkle/brightness multipliers  just geometry.\n                    // Visibility = plane intersection  disc shape. Range 0-1.\n                    result += planeVis * discMask;\n                }\n            }\n        }\n    }\n    return result;\n}\n",LS=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uMelt;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;\nuniform float uArcWidth;\nuniform float uArcSpeed;\nuniform int uArcCount;\nuniform float uArcPhase;\nuniform float uGestureProgress;\nuniform int uRelayCount;         // Number of relay rings\nuniform float uRelayArcWidth;   // Relay arc width in radians\nuniform float uRelayFloor;\n\n// Per-instance attributes\n${nS}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewDir;\nvarying vec3 vViewPosition;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying vec2 vUv;\n\n${BS}\n\nvoid main() {\n    // \n    // INSTANCING: Calculate local time and fade\n    // \n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade in/out controlled by aInstanceOpacity from AnimationState\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // \n    // MODEL SELECTION: Scale non-selected models to zero\n    // \n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // \n    // TRAIL OFFSET: Position trails behind main along velocity\n    // \n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // \n    // ICE DISPLACEMENT (crystalline wobble - much less than water)\n    // \n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n    vUv = uv;\n\n    // Calculate vertical gradient for tip-based effects\n    float modelHeight = 1.0;\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / modelHeight, 0.0, 1.0);\n\n    // \n    // SILHOUETTE BREAKUP  Voronoi vertex displacement at edges\n    // Uses the same Voronoi cell pattern as our cutout/crack system.\n    // Only active at silhouette edges (low NdotV)  jagged crystal outlines.\n    // Face-on vertices stay put, preserving the clean faceted interior.\n    // Per-instance random offset breaks repetition between identical models.\n    // \n    vec3 displaced = selectedPosition;\n\n    if (modelMatch > 0.5 && length(selectedNormal) > 0.1) {\n        // Edge factor: how close is this vertex to the silhouette?\n        vec4 approxWorldPos = modelMatrix * instanceMatrix * vec4(selectedPosition, 1.0);\n        vec3 approxViewDir = normalize(cameraPosition - approxWorldPos.xyz);\n        vec3 worldNormal = normalize(mat3(modelMatrix) * mat3(instanceMatrix) * selectedNormal);\n        float edgeNdotV = abs(dot(worldNormal, approxViewDir));\n        float edgeFactor = pow(1.0 - edgeNdotV, 2.0); // Quadratic  wider influence band\n\n        // Voronoi cell distance  crystalline breakup matching our crack aesthetic\n        // Per-instance offset so each crystal has unique edges\n        // Low frequency (1.5)  broad heavy warps, not tiny bumps\n        // Ring looks "bent" not "vibrating"  big surface undulations\n        // 2D Voronoi (9 iter)  ring geometry has minimal Z variation\n        float vor = voronoi2D(selectedPosition.xz * 1.5 + vec2(aRandomSeed * 7.13, aRandomSeed * 3.71));\n        float displ = (vor - 0.4) * 2.0;\n\n        // QUANTIZE into terraces  "chiseled ice plates" not smooth waves.\n        // floor() cuts the smooth displacement into hard steps so flat shading\n        // creates clean geometric plateaus instead of folded-paper look.\n        float steppedDispl = floor(displ * 4.0) / 4.0; // 4 terrace levels\n        float finalDispl = mix(displ, steppedDispl, 0.8); // 80% stepped, 20% smooth anti-aliasing\n\n        displaced += normalize(selectedNormal) * finalDispl * 0.08 * edgeFactor;\n    }\n\n    // Apply trail offset\n    displaced += trailOffset;\n\n    // Transform normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n    // Ensure we use the 0.0 w-component to isolate rotation from scale/translation\n    vec3 transformedNormal = (instanceMatrix * vec4(selectedNormal, 0.0)).xyz;\n    vWorldNormal = normalize(mat3(modelMatrix) * transformedNormal);\n\n    // \n    // Apply instance matrix for per-instance transforms\n    // \n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // \n    // ARC VISIBILITY (for vortex ring effects)\n    // \n    vArcVisibility = 1.0;\n    if (aRandomSeed >= 100.0) {\n        // Generalized relay: supports arbitrary relay count via uRelayCount\n        float encoded = aRandomSeed - 100.0;\n        float ringId = floor(encoded / 10.0);\n        float instanceArcPhase = encoded - ringId * 10.0;\n\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float hw = uRelayArcWidth * 0.5;\n        float angleDiff = vertexAngle - instanceArcPhase;\n        angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n        float arcMask = 1.0 - smoothstep(hw * 0.7, hw, abs(angleDiff));\n\n        float cp = uGestureProgress * float(uRelayCount) * 1.5;\n        float d = cp - ringId;\n        float relayAlpha = smoothstep(-0.30, 0.05, d) * (1.0 - smoothstep(0.70, 1.05, d));\n        vArcVisibility = arcMask * mix(uRelayFloor, 1.0, relayAlpha);\n    } else if (uAnimationType == 1) {\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + uArcPhase;\n        float halfWidth = uArcWidth * 3.14159;\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n            float angleDiff = vertexAngle - thisArcAngle;\n            angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    // View-space position: camera is at origin, so mvPosition IS the\n    // vector from camera to surface  used directly as incident ray for refract()\n    vec4 mvPosition = modelViewMatrix * instancePosition;\n    vViewPosition = mvPosition.xyz;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n`,NS=`\nuniform float uGlobalTime;\nuniform float uMelt;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uFrostAmount;\nuniform float uInternalCracks;\nuniform float uSubsurfaceScatter;\nuniform vec3 uTint;\nuniform float uGlowIntensity;\nuniform float uBloomThreshold;\n\n// Shared wetness system (WetnessCore)\n${ES}\n\n// Screen-space refraction uniforms\nuniform sampler2D uBackgroundTexture;\nuniform vec2 uResolution;\nuniform int uHasBackground;\nuniform float uIOR;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${rS}\n\n// Instancing varyings\n${aS}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewDir;\nvarying vec3 vViewPosition;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying vec2 vUv;\n\n${BS}\n${IS}\n\n// Beer's Law absorption: light passing through ice loses red first, blue last\n// thickness: how much ice light passes through (0=surface, 1=deep)\n// melt: softens the absorption (melting ice is more transparent)\nvec3 iceAbsorption(float thickness, float melt) {\n    // Absorption: visible blue-grey tint at typical viewing angles.\n    // With QUADRATIC NdotV and thickness max 2.5:\n    //   NdotV=0.7  thickness=1.27  R=exp(-1.02)=0.36, G=exp(-0.44)=0.64, B=exp(-0.13)=0.88\n    //   NdotV=0.5  thickness=0.66  R=exp(-0.53)=0.59, G=exp(-0.23)=0.79, B=exp(-0.07)=0.93\n    // Grey-blue body, not pale white clay, not opaque dark quartz.\n    float absR = mix(0.80, 0.40, melt);  // strong red removal  clearly blue\n    float absG = mix(0.35, 0.18, melt);  // moderate green removal  grey-blue\n    float absB = mix(0.10, 0.05, melt);  // slight blue attenuation  desaturated\n    vec3 a = vec3(exp(-thickness * absR), exp(-thickness * absG), exp(-thickness * absB));\n    // Floor: deep ice scatters ambient  never pure black void.\n    // Cap at 0.98: zero-thickness glass is NOT pure white. Even a thin sheet\n    // has a hint of absorption. Without this, tips read as lit white plastic.\n    return clamp(a, vec3(0.02, 0.05, 0.10), vec3(0.98));\n}\n\n// Organic surface undulation  the "Wet" look.\n// Low-frequency noise that flows over time, breaking perfect polygon refraction.\n// Applied to SMOOTH view-space normals for refraction ONLY (not specular).\n// Perturbs XY only (screen-right/up) since it targets view-space normals.\nvec3 applyMeltRipple(vec3 n, vec3 worldPos, float seed, float melt) {\n    float flow = uGlobalTime * 0.1;\n    vec3 noisePos = worldPos * 2.0 + vec3(seed * 13.7, flow, seed * 7.3);\n    float nA = snoise(noisePos);\n    float nB = snoise(noisePos + vec3(12.5, 0.0, 12.5));\n    float strength = 0.05 + melt * 0.15;\n    return normalize(n + vec3(nA, nB, 0.0) * strength);\n}\n\n// Voronoi edge-distance for dendritic frost crystal patterns\n// Returns F2-F1: thin at cell boundaries (frost veins), wide at cell centers (clear)\n// Euclidean distance  organic rounded dendrites (vs Chebyshev in cracks  angular)\nfloat voronoiFrost(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float d1 = 10.0, d2 = 10.0;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 nb = vec2(float(x), float(y));\n            vec2 cell = i + nb;\n            vec2 pt = nb + fract(sin(vec2(\n                dot(cell, vec2(127.1, 311.7)),\n                dot(cell, vec2(269.5, 183.3))\n            )) * 43758.5453);\n            float d = length(f - pt);\n            if (d < d1) { d2 = d1; d1 = d; }\n            else if (d < d2) { d2 = d; }\n        }\n    }\n    return d2 - d1;\n}\n\n// Perturb normal using noise gradient for crystalline sparkle\nvec3 perturbNormal(vec3 normal, vec3 pos, float strength) {\n    float eps = 0.05;\n    float nx = noise(pos + vec3(eps, 0, 0)) - noise(pos - vec3(eps, 0, 0));\n    float ny = noise(pos + vec3(0, eps, 0)) - noise(pos - vec3(0, eps, 0));\n    float nz = noise(pos + vec3(0, 0, eps)) - noise(pos - vec3(0, 0, eps));\n    vec3 grad = vec3(nx, ny, nz) / (2.0 * eps);\n    return normalize(normal - grad * strength);\n}\n\n${sS}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    float localTime = vLocalTime;\n\n    // \n    // HYBRID NORMALS  split flat/smooth for crystal shell vs liquid interior\n    // FLAT faceNormal: specular, fresnel, NdotV  sharp chiseled crystal facets\n    // SMOOTH vNormal + wet ripple: refraction  organic liquid warp through volume\n    // This kills the "fun house kaleidoscope" without losing the faceted look.\n    // \n    vec3 faceNormal = normalize(cross(dFdx(vWorldPosition), dFdy(vWorldPosition)));\n    vec3 viewDir = normalize(vViewDir);\n\n    // World normal with faceforward for DoubleSide geometry\n    vec3 worldNormal = normalize(vWorldNormal);\n\n    // If normal buffer corrupted/zeroed, fallback to view direction\n    if (length(vWorldNormal) < 0.01) {\n        worldNormal = viewDir;\n    }\n\n    // faceforward: flip normal for back faces so dot(N, viewDir) > 0\n    worldNormal = faceforward(worldNormal, -viewDir, worldNormal);\n\n    float smoothNdotV = max(0.0, dot(worldNormal, viewDir));\n    float fresnel = pow(1.0 - smoothNdotV, 4.0);\n    vec3 normal = faceNormal; // specular only\n\n    // \n    // SURFACE FROST  opaque white rime patches that block refraction\n    // Creates visual contrast: clear glass zones vs frosted matte zones.\n    // Frost is surface scattering  kills specular, blocks see-through.\n    // \n    // Dendritic frost  Voronoi edge-distance (F2-F1) creates crystal vein patterns.\n    // THIN VEINS ONLY  no broadFill. Frost is sharp crystalline lines, not sheets.\n    // broadFill was covering 60% of rings in opaque white  "plastic sheet" look.\n    float frostVein = voronoiFrost(vPosition.xz * 4.0 + vec2(vRandomSeed * 5.2));\n    float thinVein = 1.0 - smoothstep(0.0, 0.06, frostVein); // Thinner veins = sharper crystal lines\n    float frostRaw = thinVein; // No broadFill  veins, not sheets\n    // Break mask  TIGHT so frost appears in rare clusters, not everywhere.\n    // Low frequency (0.4x)  each break patch spans ~10 Voronoi cells  coherent crystal clusters.\n    float frostBreak = noise(vec3(vPosition.xz * 0.4, 0.0));\n    frostRaw *= smoothstep(0.50, 0.75, frostBreak);\n    float frostMask = frostRaw * uFrostAmount;\n    frostMask *= (1.0 - smoothstep(0.1, 0.4, uMelt)); // Melt kills frost first\n\n    // \n    // BEER'S LAW ABSORPTION  defines how light is colored passing through ice\n    // \n    // STABLE THICKNESS & CLARITY MASK (Iteration 100)\n    // Linear transition ensures the teal tint doesn't "snap" to geometry\n    float distFromCenter = length(vPosition);\n    float isTip = smoothstep(0.4, 1.2, distFromCenter);\n    float thickness = smoothstep(0.0, 1.0, smoothNdotV) * 0.65 * (1.0 - isTip);\n\n    // \n    // SCHLICK FRESNEL  dielectric reflection coefficient\n    // Head-on: mostly transmitted (see through). Glancing: mostly reflected.\n    // \n    float F0 = 0.02;\n    float schlick = F0 + (1.0 - F0) * fresnel;\n\n    // \n    // LIGHT DIRECTION  used ONLY for frost diffuse shading.\n    // Glass body has ZERO diffuse. It's invisible until it refracts or reflects.\n    // \n    vec3 mainLight = normalize(vec3(0.3, 1.0, 0.5));\n\n    // \n    // SCREEN-SPACE REFRACTION  sample background through distorted UVs\n    // The background was rendered to a texture without ice meshes.\n    // Normal-based UV distortion simulates light bending through ice volume.\n    // The refracted result is composited at FULL OPACITY  the "transparency"\n    // is already baked into transmittedLight via Beer's Law absorption.\n    // Using partial alpha would blend warped with un-warped = ghostly weak warp.\n    // \n    //  GRAND UNIFIED GLASS MODEL \n    // Glass has ZERO diffuse. It is invisible until it refracts something\n    // or reflects a specular highlight. In a vacuum it is BLACK.\n    // Final = (refractedBackground  absorption) + specular. Nothing else.\n    //\n    // Three DECOUPLED properties:\n    // 1. absorptionDepth (= thickness)  Controls COLOR only. Tips = clear (white).\n    // 2. Refraction distortion  INDEPENDENT of thickness. Tips still bend light.\n    // 3. Alpha = 1.0  We ALWAYS see the warped background. "Transparency"\n    //    is in the absorption color, not the alpha channel.\n\n    // \n    // REFRACTION  View-space vectors for screen-aligned UV distortion\n    // I_vs = incident ray (camerasurface in view space) = normalize(vViewPosition)\n    // N_vs = view-space normal with faceforward for DoubleSide geometry\n    // refract() .xy maps directly to screen right/up  no camera rotation artifacts.\n    // \n    vec3 transmittedLight;\n    vec3 voidColor = vec3(0.08, 0.12, 0.18);\n\n    // Ice body color  "average environment as seen through ice volume."\n    // Acts as ambient fill where refracted background is too dark.\n    vec3 iceBodyColor = vec3(0.30, 0.48, 0.58) * uTint;\n\n    if (uHasBackground == 1) {\n        vec2 screenUV = gl_FragCoord.xy / uResolution;\n\n        // View-space vectors for refraction\n        vec3 I_vs = normalize(vViewPosition);\n        vec3 N_vs = faceforward(normalize(vNormal), I_vs, normalize(vNormal));\n\n        float distortion = 0.04 + (thickness * 0.15);\n        vec3 refDir = refract(I_vs, N_vs, 0.75);\n\n        // TIR fallback: use incident direction (minimal distortion)\n        if (length(refDir) < 0.1) refDir = I_vs;\n\n        vec2 uvBase = clamp(screenUV + refDir.xy * distortion, 0.0, 1.0);\n        vec3 refractedBg = texture2D(uBackgroundTexture, uvBase).rgb;\n\n        // Screen-blend lift: adds light to dark areas, barely touches bright areas.\n        // Dark pixel (0.1)  0.1 + 0.15*0.9 = 0.235 (visible shadow detail)\n        // Bright pixel (0.8)  0.8 + 0.15*0.2 = 0.83 (unchanged)\n        // This is the "ambient environment light entering through the glass."\n        vec3 ambientLift = vec3(0.10, 0.15, 0.22);\n        refractedBg += ambientLift * (vec3(1.0) - refractedBg);\n\n        // LERP absorption: blend lifted background toward ice body color.\n        transmittedLight = mix(refractedBg, iceBodyColor, thickness * 0.4);\n    } else {\n        transmittedLight = mix(voidColor, iceBodyColor, thickness * 0.4);\n    }\n\n    // \n    // ENERGY CONSERVATION  softer teeter-totter (0.3 not 0.5).\n    // At edges fresnel0.8: multiplier = 0.76 (gentle dim, not black).\n    // \n    transmittedLight *= (1.0 - fresnel * 0.3);\n\n    // Ambient reflection at glancing angles (Schlick-driven edge brightness)\n    vec3 envReflection = vec3(0.15, 0.25, 0.35) * uTint;\n    transmittedLight += envReflection * schlick;\n\n    // Internal scatter  faint volumetric glow at edges\n    transmittedLight += vec3(0.04, 0.1, 0.14) * fresnel;\n\n    // \n    // INTERNAL FRACTURE PLANES  flat crystalline sheets trapped inside the volume\n    // Voronoi cells with Chebyshev distance  large angular regions.\n    // Each cell is either a fracture plane (milky scatter) or clear glass.\n    // Per-plane view-dependent brightness from random orientation.\n    // Boundary edges highlighted where fractured meets clear glass.\n    // Computed here, composited AFTER soft clamp (see below).\n    // \n    float fracPlanes = 0.0;\n    float fracEdge = 0.0;\n    {\n        vec2 fpPx = viewDir.xz / max(smoothNdotV, 0.25) * 0.12;\n        vec2 fpPos = (vPosition.xz + fpPx) * 1.5 + vec2(vRandomSeed * 6.0, vRandomSeed * 4.2);\n        vec2 fpi = floor(fpPos);\n        vec2 fpf = fract(fpPos);\n\n        float fd1 = 10.0, fd2 = 10.0;\n        vec2 fcell1 = vec2(0.0), fcell2 = vec2(0.0);\n\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                vec2 nb = vec2(float(x), float(y));\n                vec2 cell = fpi + nb;\n                vec2 pt = nb + fract(sin(vec2(\n                    dot(cell, vec2(127.1, 311.7)),\n                    dot(cell, vec2(269.5, 183.3))\n                )) * 43758.5453);\n                vec2 diff = fpf - pt;\n                float d = max(abs(diff.x), abs(diff.y));\n                if (d < fd1) { fd2 = fd1; fcell2 = fcell1; fd1 = d; fcell1 = cell; }\n                else if (d < fd2) { fd2 = d; fcell2 = cell; }\n            }\n        }\n\n        float edgeDist = fd2 - fd1;\n\n        // Per-cell fracture determination (~18% of cells have fractures)\n        float fh1 = fract(sin(dot(fcell1, vec2(43.37, 87.71))) * 43758.5453);\n        float fh2 = fract(sin(dot(fcell2, vec2(43.37, 87.71))) * 43758.5453);\n        float fhas1 = step(0.82, fh1);\n        float fhas2 = step(0.82, fh2);\n\n        // View-dependent brightness for the fractured cell's "plane orientation"\n        float fang = fract(sin(dot(fcell1, vec2(13.17, 67.29))) * 43758.5453) * 6.28;\n        vec2 fdir = vec2(cos(fang), sin(fang));\n        float fbright = abs(dot(fdir, viewDir.xz));\n        fbright = mix(0.25, 1.0, fbright);\n        float fbase = mix(0.5, 1.0, fract(fh1 * 7.13));\n\n        // Fracture fill: milky scatter inside fractured cells\n        fracPlanes = fhas1 * fbright * fbase;\n\n        // Fracture boundary edge: bright line where fractured cell meets clear cell\n        float isBoundary = abs(fhas1 - fhas2);\n        fracEdge = isBoundary * (1.0 - smoothstep(0.0, 0.04, edgeDist));\n    }\n\n    // \n    // FROST  opaque rime veins over clear glass\n    // Applied after energy conservation so frost isn't dimmed at edges.\n    // \n    float frostLuma = min(0.65, uBloomThreshold + 0.25);\n    vec3 frostColor = vec3(frostLuma, frostLuma * 1.02, frostLuma * 1.05);\n    float frostDiffuse = max(0.4, dot(normal, mainLight));\n    frostColor *= frostDiffuse;\n    transmittedLight = mix(transmittedLight, frostColor, frostMask);\n\n    // \n    // PIXEL MATH  transmission + specular only. No boost, no scatter, no Schlick.\n    // \n    vec3 color = transmittedLight;\n    color *= uIntensity;\n\n    // \n    // TRAPPED AIR BUBBLES  round spherical voids frozen inside the ice\n    // Two scales: large prominent bubbles + small fizzy detail.\n    // Each bubble: bright interior, dark ring edge, caustic highlight on top.\n    // Cluster mask concentrates bubbles in patches (not uniform everywhere).\n    // \n    vec3 bubbleParallax = viewDir * 0.08 / max(smoothNdotV, 0.25);\n    // Per-instance offset so each ice element has unique bubble placement\n    vec3 bubbleSamplePos = vPosition + bubbleParallax + vec3(vRandomSeed * 10.0);\n\n    // Cluster mask  mild variation, NOT aggressive culling\n    float bubbleCluster = noise(vPosition * 2.0 + vec3(vRandomSeed * 5.0, 0.0, 0.0));\n    float clusterMask = 0.5 + 0.5 * bubbleCluster; // 0.51.0 range, never fully off\n\n    // 2D bubbles (scale 8, 65% density)  circles on thin ring geometry\n    vec2 bub = bubbleField2D(bubbleSamplePos, 8.0, 0.65);\n\n    // Tiny fizzy specks  cheap noise threshold dots for density between big bubbles\n    float fizz = smoothstep(0.82, 0.89, noise(bubbleSamplePos * 35.0)) * 0.20;\n\n    float bubbleBright = (bub.x + fizz) * clusterMask * (1.0 - frostMask);\n    float bubbleRing = bub.y * clusterMask * (1.0 - frostMask);\n\n    // Bright interior (primary) + subtle dark edge (secondary)\n    color += vec3(0.80, 0.85, 0.92) * bubbleBright * 0.35;\n    color -= vec3(0.07, 0.06, 0.04) * bubbleRing;\n\n    // \n    // SPECULAR  sharp concentrated glints for the wet/glossy look\n    // Uses FLAT face normals: each polygon catches light independently\n    // 4 lights for good coverage, high power for sharp points\n    // \n    float specPower = mix(128.0, 32.0, uMelt); // Broader highlights  glossy glass, not pinpoint diamond\n\n    // 3 lights  enough coverage for visible glints on the now-darker body.\n    // Sparse deep scratches: only top 5% of noise peaks become cuts.\n    // 95% of surface is perfectly smooth glass. Where a scratch exists,\n    // perturbation is strong (0.3)  visible specular scatter without\n    // the "sandpaper everywhere" problem of low-strength global noise.\n    float scratchNoise = noise(vWorldPosition * 20.0 + vec3(vRandomSeed * 17.3));\n    float scratchMask = step(0.95, scratchNoise); // Only top 5% become scratches\n    float scrAngle = noise(vWorldPosition * 3.0 + vec3(vRandomSeed * 5.1)) * 6.28;\n    vec3 scratchDir = vec3(sin(scrAngle), cos(scrAngle), 0.0);\n    vec3 scratchedNormal = normalize(normal + scratchDir * scratchMask * 0.3);\n    vec3 reflDir = reflect(-viewDir, scratchedNormal);\n    float spec1 = pow(max(dot(reflDir, normalize(vec3(0.5, 1.0, 0.3))), 0.0), specPower);\n    float spec2 = pow(max(dot(reflDir, normalize(vec3(-0.4, 0.8, -0.4))), 0.0), specPower) * 0.6;\n    float spec3 = pow(max(dot(reflDir, normalize(vec3(-0.3, 0.6, 0.7))), 0.0), specPower) * 0.4;\n    float spec = spec1 + spec2 + spec3;\n\n    vec3 specContrib = mix(vec3(1.0), vec3(0.9, 0.95, 1.0), fresnel) * spec * 2.5 * (1.0 - uMelt * 0.5);\n    specContrib *= (1.0 - frostMask); // Frost is matte  kills specular completely\n    color += specContrib;\n\n    // Spatial wetness mask  modulates wet film specular for natural variation.\n    // Uses shared WetnessCore. crackProximity=0.0 for now (coarseEdge computed later).\n    // Guard: at low melt (uWetness  0.4), wet patches are barely visible.\n    // Skip 4 noise + sin (~165 ALU) and use constant instead.\n    float wetMask = uWetness > 0.4 ? calculateWetMask(vPosition, vRandomSeed, localTime + vRandomSeed * 10.0, 0.0) : 0.3;\n\n    // Wet film specular  secondary tighter highlight on smooth surface.\n    // Creates the "water on glass" look. Uses smooth world normal, not flat facets.\n    // Power 120 = very sharp pinpoints. Spatially modulated by wetMask.\n    vec3 wetReflDir = reflect(-viewDir, worldNormal);\n    float wetSpec = pow(max(dot(wetReflDir, normalize(vec3(0.5, 1.0, 0.3))), 0.0), 120.0);\n    wetSpec += pow(max(dot(wetReflDir, normalize(vec3(-0.4, 0.8, -0.4))), 0.0), 120.0) * 0.5;\n    wetSpec += pow(max(dot(wetReflDir, normalize(vec3(0.0, 0.6, -0.8))), 0.0), 120.0) * 0.3;\n    color += vec3(1.0) * wetSpec * 0.8 * (1.0 - frostMask) * wetMask;\n\n    // Broad wet sheen  soft glossy highlight from thin water film on ice surface.\n    // Medium specular power = visible gloss patches, not uniform brightening.\n    // Uses smooth worldNormal: the water film IS smooth even over faceted ice.\n    float sheen1 = pow(max(dot(wetReflDir, normalize(vec3(0.3, 1.0, 0.2))), 0.0), 24.0);\n    float sheen2 = pow(max(dot(wetReflDir, normalize(vec3(-0.3, 0.8, -0.5))), 0.0), 24.0) * 0.5;\n    float sheen3 = pow(max(dot(wetReflDir, normalize(vec3(0.6, 0.4, 0.6))), 0.0), 16.0) * 0.3;\n    float wetSheen = sheen1 + sheen2 + sheen3;\n    color += vec3(0.92, 0.95, 1.0) * wetSheen * 0.06 * (1.0 - frostMask) * (1.0 - uMelt * 0.5) * wetMask;\n\n    // Subtle spatial darkening from moisture (ice is translucent, so minimal)\n    color = applyWetDarkening(color, wetMask, 0.92);\n\n    // \n    // SOFT CLAMP  cap the smooth glass BASE before adding bright features\n    // Cracks/specular/bubbles are added AFTER this so they can exceed the cap\n    // and trigger bloom glow. The smooth glass body stays within bounds.\n    // \n    float softCap = uBloomThreshold + 0.30;\n    float finalMax = max(color.r, max(color.g, color.b));\n    if (finalMax > softCap) {\n        color *= softCap / finalMax;\n    }\n\n    // \n    // INTERNAL FRACTURE PLANES  milky crystalline inclusions\n    // Cell fill: angular milky zones where flat fracture sheets scatter light.\n    // Boundary edges: bright lines where fractured cells meet clear glass.\n    // Applied post-clamp so both features exceed the capped body color.\n    // \n    color = mix(color, vec3(0.88, 0.92, 0.97), fracPlanes * 0.42 * uInternalCracks);\n    color = mix(color, vec3(1.02, 1.05, 1.08), fracEdge * 0.55 * uInternalCracks);\n\n    // \n    // INTERNAL CRACK LINES (two-scale Voronoi with Chebyshev distance)\n    // Three realism layers:\n    //   1. LOW-FREQ MASK: breaks continuous loops into isolated jagged segments\n    //   2. DARK FRACTURES: occlusion planes that block light (applied first)\n    //   3. BRIGHT SCATTER: reflection planes that catch light (applied on top)\n    // Plus view-dependent sparkle: fracture brightness shifts with camera angle.\n    // \n    // Crack values hoisted for edge-breakup discard (used after crack coloring)\n    float coarseCrack = 0.0;\n\n    if (uInternalCracks > 0.01) {\n\n        //  PARALLAX INTERIOR OFFSET \n        // Offset crack sampling by view direction to create depth illusion.\n        // Cracks shift as you rotate, looking like they're INSIDE the volume.\n        float parallaxScale = 0.12;\n        vec2 parallaxDir = viewDir.xz / max(smoothNdotV, 0.25);\n        vec2 coarseParallax = parallaxDir * parallaxScale;        // shallow layer\n\n        //  BREAK-THE-WEB MASK \n        // Low-frequency noise erases ~75% of crack lines. Most of the surface\n        // is PERFECTLY CLEAR glass  only 20-25% has dramatic fractures.\n        // Frequency 0.4  large smooth patches, not small noisy spots.\n        float breakMask = noise(vec3(vPosition.xz * 0.4, 0.0));\n        float coarseMask = smoothstep(0.55, 0.78, breakMask); // ~75% erased  huge quiet zones\n\n        //  COARSE FRACTURE PLANES (scale 0.7  MASSIVE structural cleaves) \n        // Very low frequency  3-4 fractures spanning the entire object.\n        // Ring torus gets 2-3 dramatic cracks, not 1000 tiny scratches.\n        vec2 coarsePos = (vPosition.xz + coarseParallax) * 0.7;\n        vec2 cci = floor(coarsePos);\n        vec2 ccf = fract(coarsePos);\n        float cd1 = 10.0, cd2 = 10.0;\n        vec2 cCell1 = vec2(0.0), cCell2 = vec2(0.0);\n        vec2 cAbsPt1 = vec2(0.0), cAbsPt2 = vec2(0.0); // absolute Voronoi point positions (for dark reuse)\n\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                vec2 nb = vec2(float(x), float(y));\n                vec2 cell = cci + nb;\n                vec2 pt = nb + fract(sin(vec2(\n                    dot(cell, vec2(127.1, 311.7)),\n                    dot(cell, vec2(269.5, 183.3))\n                )) * 43758.5453);\n                vec2 diff = ccf - pt;\n                float d = max(abs(diff.x), abs(diff.y)); // Chebyshev: angular cells\n                if (d < cd1) { cd2 = cd1; cCell2 = cCell1; cAbsPt2 = cAbsPt1; cd1 = d; cCell1 = cell; cAbsPt1 = cci + pt; }\n                else if (d < cd2) { cd2 = d; cCell2 = cell; cAbsPt2 = cci + pt; }\n            }\n        }\n\n        float coarseEdge = cd2 - cd1;\n        float coarsePairHash = fract(sin(dot(cCell1 + cCell2, vec2(78.233, 143.71))) * 43758.5453);\n        float coarseWidth = mix(0.008, 0.025, coarsePairHash); // Slightly wider  dramatic structural cleaves\n        coarseCrack = (1.0 - smoothstep(0.0, coarseWidth, coarseEdge)) * coarseMask;\n        // Halo band just outside crack  refraction brightening\n        float coarseBrightEdge = smoothstep(0.0, coarseWidth, coarseEdge) * (1.0 - smoothstep(coarseWidth, coarseWidth + 0.08, coarseEdge));\n        float coarseDepth = mix(0.75, 1.0, coarsePairHash);\n\n        //  VIEW-DEPENDENT SPARKLE \n        // Each fracture plane has a pseudo-normal derived from its cell hash.\n        // Planes facing the camera flash bright; planes facing away go dim.\n        // This makes cracks "twinkle" as the object rotates  like diamond facets.\n        vec2 coarsePlaneDir = normalize(vec2(coarsePairHash * 2.0 - 1.0, fract(coarsePairHash * 7.13) * 2.0 - 1.0));\n        float coarseSparkle = abs(dot(coarsePlaneDir, viewDir.xz)); // 0=edge-on (dim), 1=face-on (flash)\n        coarseSparkle = mix(0.05, 1.0, coarseSparkle); // Wide range: TIR flicker  some nearly vanish\n\n        //  DARK FRACTURES (reuse coarse Voronoi topology) \n        // Same cell structure as coarse but at offset parallax. Recompute just\n        // 2 distances from the stored cell points instead of a full 9-iteration loop.\n        vec2 darkParallax = parallaxDir * parallaxScale * 0.5;\n        vec2 darkPos = (vPosition.xz + darkParallax + vec2(0.13, -0.09)) * 0.7;\n        vec2 dv1 = darkPos - cAbsPt1;\n        vec2 dv2 = darkPos - cAbsPt2;\n        float ddd1 = max(abs(dv1.x), abs(dv1.y));\n        float ddd2 = max(abs(dv2.x), abs(dv2.y));\n        if (ddd1 > ddd2) { float tmp = ddd1; ddd1 = ddd2; ddd2 = tmp; }\n        float darkEdge = ddd2 - ddd1;\n        float darkCrack = (1.0 - smoothstep(0.0, 0.012, darkEdge)) * coarseMask;\n\n        //  CRACK SPECULAR GLINTS (physical grooves catch light) \n        // Use dFdx/dFdy of edge distances to get crack surface gradient.\n        // This perturbs the normal WHERE cracks exist, so fracture lines\n        // physically interact with specular  they glint like real grooves.\n        float crackSpecGlint = 0.0;\n        if (coarseCrack > 0.1) {\n            float dex = dFdx(coarseEdge);\n            float dey = dFdy(coarseEdge);\n            vec3 crackGrad = vec3(dex, 0.0, dey);\n            vec3 crackNorm = normalize(normal + crackGrad * 10.0); // Strong groove perturbation\n            vec3 crackRefl = reflect(-viewDir, crackNorm);\n            float cSpec = pow(max(dot(crackRefl, normalize(vec3(0.3, 1.0, 0.5))), 0.0), 48.0);\n            cSpec += pow(max(dot(crackRefl, normalize(vec3(-0.4, 0.8, -0.4))), 0.0), 48.0) * 0.6;\n            cSpec += pow(max(dot(crackRefl, normalize(vec3(0.6, 0.3, -0.6))), 0.0), 48.0) * 0.3;\n            crackSpecGlint += cSpec * coarseCrack * coarseSparkle;\n        }\n\n        //  COMPOSITE \n        // 1. Dark occlusion fractures FIRST (subtractive  blocks light)\n        color = mix(color, vec3(0.0, 0.1, 0.3), darkCrack * 0.25 * uInternalCracks);\n\n        // 2. Coarse bright scatter ON TOP (additive  catches light)\n        //    Sparkle modulates brightness: some planes flash, others nearly vanish.\n        color = mix(color, vec3(1.15), coarseCrack * coarseDepth * coarseSparkle * uInternalCracks * 0.7);\n\n        // 3. Crack specular glints  physical groove highlights (the "shattered glass" flash)\n        color += vec3(1.0) * crackSpecGlint * 2.5 * uInternalCracks;\n\n        // 4. Refraction halo: subtle brightening adjacent to fracture\n        color = mix(color, vec3(1.3), coarseBrightEdge * coarseMask * 0.25 * uInternalCracks);\n\n    }\n\n    // \n    // EDGE BREAKUP  discard at silhouette edges where cracks exist\n    // Uses the SAME Voronoi cracks already computed above, so holes perfectly\n    // match the visible crack lines. Only active when gesture opts in via edgeMask.\n    // \n    if (uCutoutEdgeMask > 0.0) {\n        float eLenX = length(dFdx(vWorldPosition));\n        float eLenY = length(dFdy(vWorldPosition));\n        float eRatio = max(eLenX, eLenY) / max(min(eLenX, eLenY), 0.00001);\n\n        float eLow = mix(1.1, 2.5, uCutoutEdgeMask);\n        float eHigh = eLow + 0.8;\n        float eFactor = smoothstep(eLow, eHigh, eRatio);\n\n        float crackMask = coarseCrack;\n\n        // At edges where cracks exist  discard for jagged silhouette\n        if (eFactor * crackMask > 0.2) discard;\n    }\n\n    // \n    // ALPHA  SOLID CRYSTAL. Always 1.0.\n    // "Transparency" comes from the refracted background painted onto the surface,\n    // NOT from alpha blending. Alpha<1.0 blends warped+unwarped = ghost artifact.\n    // \n    float alpha = 1.0;\n\n    // Instance fade (spawn/exit)\n    alpha *= vInstanceAlpha;\n\n    // \n    // ARC VISIBILITY (for vortex effects)\n    // \n    if (vArcVisibility < 0.999) {\n        alpha *= vArcVisibility;\n        color *= mix(0.3, 1.0, vArcVisibility);\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // \n    // CUTOUT EFFECT (shared pattern system from InstancedAnimationCore)\n    // \n    ${oS}\n\n    // Apply trail dissolve\n    alpha *= trailAlpha;\n\n    // \n    // GRAIN EFFECT (noise texture overlay)\n    // \n    ${lS}\n\n    // \n    // FINAL OUTPUT\n    // \n    if (alpha < 0.01) discard;\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,VS=fS,US={charge:.5,opacity:.85,fadeInDuration:.15,fadeOutDuration:.3};function GS(e,t,n){return e+(t-e)*n}const WS=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;\nuniform float uArcWidth;\nuniform float uArcSpeed;\nuniform int uArcCount;\nuniform float uArcPhase;\nuniform float uGestureProgress;\nuniform int uRelayCount;\nuniform float uRelayArcWidth;\nuniform float uRelayFloor;\n\n// Per-instance attributes\n${nS}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\n\nvoid main() {\n    // \n    // INSTANCING: Calculate local time and fade\n    // \n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade controlled by aInstanceOpacity from AnimationState\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // \n    // MODEL SELECTION: Scale non-selected models to zero\n    // \n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // \n    // TRAIL OFFSET: Position trails behind main along velocity\n    // \n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // \n    // ELECTRIC: No vertex displacement  lightning is purely fragment-based\n    // \n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / 1.0, 0.0, 1.0);\n\n    vec3 displaced = selectedPosition + trailOffset;\n\n    // Transform normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n\n    // \n    // Apply instance matrix for per-instance transforms\n    // \n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // \n    // ARC VISIBILITY (for vortex ring effects)\n    // \n    vArcVisibility = 1.0;\n    if (aRandomSeed >= 100.0) {\n        // Generalized relay: supports arbitrary relay count via uRelayCount\n        float encoded = aRandomSeed - 100.0;\n        float ringId = floor(encoded / 10.0);\n        float instanceArcPhase = encoded - ringId * 10.0;\n\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float hw = uRelayArcWidth * 0.5;\n        float angleDiff = vertexAngle - instanceArcPhase;\n        angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n        float arcMask = 1.0 - smoothstep(hw * 0.7, hw, abs(angleDiff));\n\n        float cp = uGestureProgress * float(uRelayCount) * 1.5;\n        float d = cp - ringId;\n        float relayAlpha = smoothstep(-0.30, 0.05, d) * (1.0 - smoothstep(0.70, 1.05, d));\n        vArcVisibility = arcMask * mix(uRelayFloor, 1.0, relayAlpha);\n    } else if (uAnimationType == 1) {\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + uArcPhase;\n        float halfWidth = uArcWidth * 3.14159;\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n            float angleDiff = mod(vertexAngle - thisArcAngle + 3.14159, 6.28318) - 3.14159;\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * instancePosition;\n}\n`,qS=`\nuniform float uGlobalTime;\nuniform float uCharge;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uFlickerSpeed;\nuniform float uFlickerAmount;\nuniform float uSparkDensity;\nuniform float uBloomThreshold;\nuniform float uFlashIntensity;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${rS}\n\n// Instancing varyings\n${aS}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\n\n\n// 2D hash for Voronoi cell positions  sin-free\nvec2 hash2(vec2 p) {\n    p = fract(p * vec2(0.1031, 0.1030));\n    p += dot(p, p.yx + 33.33);\n    return fract((p.xx + p.yx) * p.yx);\n}\n\n// 3D vector hash for Voronoi cell positions  sin-free (fract/dot only)\nvec3 hash3(vec3 p) {\n    p = fract(p * vec3(0.1031, 0.1030, 0.0973));\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\n// 3D hash for value noise (required by cutout system's snoise)\nfloat noiseHash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(mix(noiseHash(i), noiseHash(i + vec3(1,0,0)), f.x),\n            mix(noiseHash(i + vec3(0,1,0)), noiseHash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(noiseHash(i + vec3(0,0,1)), noiseHash(i + vec3(1,0,1)), f.x),\n            mix(noiseHash(i + vec3(0,1,1)), noiseHash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\nfloat snoise(vec3 p) {\n    return noise(p) * 2.0 - 1.0;\n}\n\n\n// Electric color from charge level: pale blue  cyan  white-blue\nvec3 getElectricColor(float charge) {\n    vec3 low = vec3(0.5, 0.7, 1.0);      // pale blue\n    vec3 mid = vec3(0.3, 0.95, 1.0);     // bright cyan\n    vec3 high = vec3(0.85, 0.97, 1.0);   // white-blue\n\n    float t1 = smoothstep(0.0, 0.4, charge);\n    float t2 = smoothstep(0.4, 0.8, charge);\n\n    vec3 color = mix(low, mid, t1);\n    return mix(color, high, t2);\n}\n\n// \n// 2D Voronoi edge distance  thin branching lines for lightning\n// Cell boundaries form the bolt network. Animated cell positions drift over time.\n// Returns: distance to nearest Voronoi cell edge (small value = on a bolt line)\n// \nfloat voronoiEdge2D(vec2 p, float time, float jitter) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    // Single pass: squared-distance comparison (saves 7 sqrt per call)\n    float d1sq = 10.0;\n    float d2sq = 10.0;\n    vec2 closestPoint = vec2(0.0);\n    vec2 secondPoint = vec2(0.0);\n\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 cellId = n + neighbor;\n            vec2 cellHash = hash2(cellId);\n            vec2 cellOffset = cellHash * jitter;\n            cellOffset += (fract(time * 0.48 + cellHash) * 2.0 - 1.0) * 0.15;\n\n            vec2 diff = neighbor + cellOffset - f;\n            float dsq = dot(diff, diff);\n\n            if (dsq < d1sq) {\n                d2sq = d1sq;\n                secondPoint = closestPoint;\n                d1sq = dsq;\n                closestPoint = neighbor + cellOffset;\n            } else if (dsq < d2sq) {\n                d2sq = dsq;\n                secondPoint = neighbor + cellOffset;\n            }\n        }\n    }\n\n    // Edge distance: perpendicular bisector between two closest cells\n    vec2 toCenter = (closestPoint + secondPoint) * 0.5;\n    vec2 cellDiff = normalize(secondPoint - closestPoint);\n    return abs(dot(toCenter - f, cellDiff));\n}\n\n// \n// 3D Voronoi edge distance  single-pass, squared-distance comparison\n// Uses dot(d,d) instead of length(d) in the loop (saves 25 sqrt per call).\n// sqrt is monotonic so nearest-neighbor selection is identical.\n// \nfloat voronoiEdge3D(vec3 p, float time, float jitter) {\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n\n    // Single pass: track two closest cell centers (squared distances for comparison)\n    float d1sq = 10.0;\n    float d2sq = 10.0;\n    vec3 closestPoint = vec3(0.0);\n    vec3 secondPoint = vec3(0.0);\n\n    for (int k = -1; k <= 1; k++) {\n        for (int j = -1; j <= 1; j++) {\n            for (int i = -1; i <= 1; i++) {\n                vec3 neighbor = vec3(float(i), float(j), float(k));\n                vec3 cellId = n + neighbor;\n                vec3 cellHash = hash3(cellId);\n                vec3 cellOffset = cellHash * jitter;\n                cellOffset += (fract(time * 0.48 + cellHash) * 2.0 - 1.0) * 0.15;\n\n                vec3 diff = neighbor + cellOffset - f;\n                float dsq = dot(diff, diff);  // squared distance  no sqrt needed\n\n                if (dsq < d1sq) {\n                    d2sq = d1sq;\n                    secondPoint = closestPoint;\n                    d1sq = dsq;\n                    closestPoint = neighbor + cellOffset;\n                } else if (dsq < d2sq) {\n                    d2sq = dsq;\n                    secondPoint = neighbor + cellOffset;\n                }\n            }\n        }\n    }\n\n    // Edge distance: perpendicular bisector between two closest cells\n    vec3 toCenter = (closestPoint + secondPoint) * 0.5;\n    vec3 cellDiff = normalize(secondPoint - closestPoint);  // only sqrt needed here\n    return abs(dot(toCenter - f, cellDiff));\n}\n\n\n${sS}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    float localTime = vLocalTime;\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewDir);\n\n    // Per-instance time offset  each instance gets unique lightning patterns\n    float instanceTimeOffset = vRandomSeed * 10.0;\n    float effectiveTime = localTime + instanceTimeOffset;\n\n    // \n    // FRESNEL  subtle edge highlight (matches overlay shader)\n    // \n    float fresnel = pow(1.0 - abs(dot(normal, viewDir)), 3.0);\n    float rimGlow = fresnel * 0.15 * uCharge;\n\n    // \n    // PRIMARY BOLT NETWORK (large bolts, scale 3)\n    // Matches overlay: thin lines + pow() sharpening  bright cores that bloom\n    // \n    float lineWidth = 0.015;\n\n    float edge1 = voronoiEdge3D(vWorldPosition * 3.0, effectiveTime * 0.8, 0.85);\n    float bolt1 = 1.0 - smoothstep(0.0, lineWidth * 1.2, edge1);\n    bolt1 = pow(bolt1, 2.0);\n\n    // \n    // SECONDARY CRACKLING (fine detail, scale 6)\n    // \n    float edge2 = voronoiEdge3D(vWorldPosition * 6.0, effectiveTime * 1.2, 0.8);\n    float bolt2 = 1.0 - smoothstep(0.0, lineWidth * 0.8, edge2);\n    bolt2 = pow(bolt2, 2.5) * 0.6;\n\n    // Combine  two overlapping scales create bolt network\n    float lightning = min(bolt1 + bolt2, 1.0);\n\n    // \n    // FLICKER  electrical pulsing (per-instance variation)\n    // Step-based for sharp on/off characteristic of real electricity\n    // \n    float flickerPhase = vRandomSeed * 100.0;\n    float flickerTime = effectiveTime * uFlickerSpeed * 0.5;\n\n    // Multi-frequency flicker for irregular pulsing\n    float f1 = step(0.5, fract(sin(flickerTime * 11.3 + flickerPhase) * 43758.5453));\n    float f2 = step(0.65, fract(sin(flickerTime * 7.7 + flickerPhase * 1.3) * 43758.5453)) * 0.5;\n    float flicker = (1.0 - uFlickerAmount) + uFlickerAmount * max(f1, f2);\n\n    lightning *= flicker;\n\n    // \n    // COLOR  bolt network drives both color and visibility\n    // Dark areas between bolts are TRANSPARENT  model geometry hidden\n    // \n    float brightness = lightning + rimGlow;\n\n    vec3 baseColor = getElectricColor(uCharge);\n\n    // Bolt peaks shift slightly white  keeps cyan identity\n    float whiteMix = smoothstep(0.7, 1.0, brightness) * 0.3;\n    vec3 brightColor = baseColor * 1.5 + vec3(0.2, 0.3, 0.4);\n    vec3 color = mix(baseColor, brightColor, whiteMix);\n\n    // Apply brightness and intensity (no bloom compression  matches overlay)\n    color *= min(brightness * uIntensity, 2.5);\n\n    // Fresnel edge glow (scaled by uGlowScale for gesture ramping)\n    color += fresnel * baseColor * 0.2 * uGlowScale;\n\n    // \n    // ALPHA  bolt brightness drives visibility\n    // Dark areas between cells are transparent  model geometry hidden\n    // \n    float alpha = brightness * uOpacity;\n    alpha = clamp(alpha, 0.0, 0.95);\n\n    // Apply instance fade (spawn/exit + trail)\n    alpha *= vInstanceAlpha;\n\n    // Arc visibility (for vortex/relay effects)\n    if (vArcVisibility < 0.999) {\n        alpha *= vArcVisibility;\n        color *= mix(0.3, 1.0, vArcVisibility);\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    if (alpha < 0.03) discard;\n\n    // \n    // CUTOUT + GRAIN (shared systems from InstancedAnimationCore)\n    // \n    ${oS}\n\n    // Apply trail dissolve\n    alpha *= trailAlpha;\n\n    ${lS}\n\n    // \n    // LIGHTNING FLASH  opt-in per-gesture dramatic strike effect\n    // When uFlashIntensity > 0: boost brightness, shift toward white, force alpha high\n    // \n    if (uFlashIntensity > 0.01) {\n        float flashBoost = 1.0 + uFlashIntensity * 3.0;\n        color *= flashBoost;\n        color = mix(color, vec3(flashBoost), uFlashIntensity * 0.4);\n        alpha = min(alpha * flashBoost, 0.95);\n    }\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,HS=fS,jS={depth:.5,opacity:1,fadeInDuration:.2,fadeOutDuration:.4};function XS(e,t,n){return e+(t-e)*n}const YS="\nfloat noiseHash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(mix(noiseHash(i), noiseHash(i + vec3(1,0,0)), f.x),\n            mix(noiseHash(i + vec3(0,1,0)), noiseHash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(noiseHash(i + vec3(0,0,1)), noiseHash(i + vec3(1,0,1)), f.x),\n            mix(noiseHash(i + vec3(0,1,1)), noiseHash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\nfloat snoise(vec3 p) {\n    return noise(p) * 2.0 - 1.0;\n}\n",$S=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uDepth;\nuniform int uDiskMode;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;\nuniform float uArcWidth;\nuniform float uArcSpeed;\nuniform int uArcCount;\nuniform float uArcPhase;\nuniform float uGestureProgress;\nuniform int uRelayCount;\nuniform float uRelayArcWidth;\nuniform float uRelayFloor;\n\n// Per-instance attributes\n${nS}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying vec3 vViewPosition;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying float vDopplerAngleXY;  // Pre-computed atan(pos.y, pos.x) for disk mode\nvarying float vDopplerAngleXZ;  // Pre-computed atan(pos.z, pos.x) for non-disk mode\n\n${YS}\n\nvoid main() {\n    // \n    // INSTANCING: Calculate local time and fade\n    // \n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade controlled by aInstanceOpacity from AnimationState\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // \n    // MODEL SELECTION: Scale non-selected models to zero\n    // \n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // \n    // TRAIL OFFSET: Position trails behind main along velocity\n    // \n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // \n    // VOID: Slow breathing  event horizon pulsation (time dilation feel)\n    // \n\n    float instanceTime = vLocalTime + aRandomSeed * 10.0;\n    // Disk mode: ZERO vertex displacement  must stay perfectly round\n    float breathe = uDiskMode == 1 ? 0.0 : sin(instanceTime * 0.3) * 0.008 * uDepth;\n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / 1.0, 0.0, 1.0);\n\n    // Pre-compute atan for Doppler asymmetry  saves 30 ops/fragment\n    vDopplerAngleXY = atan(selectedPosition.y, selectedPosition.x);\n    vDopplerAngleXZ = atan(selectedPosition.z, selectedPosition.x);\n\n    vec3 displaced = selectedPosition + selectedNormal * breathe + trailOffset;\n\n    // View-space normal (for screen-aligned lensing direction on 3D geometry)\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n\n    // \n    // Apply instance matrix for per-instance transforms\n    // \n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // View-space position (for proper NdotV in fragment)\n    vec4 viewPos = modelViewMatrix * instancePosition;\n    vViewPosition = viewPos.xyz;\n\n    // Instance origin in world space (for trail dissolve)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // \n    // ARC VISIBILITY (for vortex ring effects)\n    // \n    vArcVisibility = 1.0;\n    if (aRandomSeed >= 100.0) {\n        // Generalized relay: supports arbitrary relay count via uRelayCount\n        float encoded = aRandomSeed - 100.0;\n        float ringId = floor(encoded / 10.0);\n        float instanceArcPhase = encoded - ringId * 10.0;\n\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float hw = uRelayArcWidth * 0.5;\n        float angleDiff = vertexAngle - instanceArcPhase;\n        angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n        float arcMask = 1.0 - smoothstep(hw * 0.7, hw, abs(angleDiff));\n\n        float cp = uGestureProgress * float(uRelayCount) * 1.5;\n        float d = cp - ringId;\n        float relayAlpha = smoothstep(-0.30, 0.05, d) * (1.0 - smoothstep(0.70, 1.05, d));\n        vArcVisibility = arcMask * mix(uRelayFloor, 1.0, relayAlpha);\n    } else if (uAnimationType == 1) {\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + uArcPhase;\n        float halfWidth = uArcWidth * 3.14159;\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n            float angleDiff = mod(vertexAngle - thisArcAngle + 3.14159, 6.28318) - 3.14159;\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    gl_Position = projectionMatrix * viewPos;\n}\n`,QS=`\nuniform float uGlobalTime;\nuniform float uDepth;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uTendrilSpeed;    // Breathing/animation speed\nuniform float uEdgeGlow;        // Photon ring brightness\nuniform float uBloomThreshold;\nuniform int uDiskMode;\n\n// Screen-space gravitational lensing\nuniform sampler2D uBackgroundTexture;\nuniform vec2 uResolution;\nuniform int uHasBackground;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${rS}\n\n// Instancing varyings\n${aS}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying vec3 vViewPosition;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying float vDopplerAngleXY;\nvarying float vDopplerAngleXZ;\n\n${YS}\n${sS}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    // Local time (required by CUTOUT_GLSL and GRAIN_GLSL)\n    float localTime = vLocalTime;\n\n    // View-space normal (screen-aligned for lensing direction)\n    vec3 normal = normalize(vNormal);\n\n    // Proper view-space NdotV (both vectors in view space)\n    vec3 viewDirVS = -normalize(vViewPosition);\n    float NdotV = max(0.0, dot(normal, viewDirVS));\n    float edgeness = 1.0 - NdotV; // 0 = face-on (event horizon), 1 = silhouette\n\n    // \n    // DISK MODE  billboard singularity with built-in gravitational lensing.\n    //\n    // The disk is a perfect circle (billboard PlaneGeometry). It handles its\n    // OWN background warping here in the shader  the DistortionManager\n    // post-process is disabled (distortionStrength: 0) so the disk geometry\n    // stays perfectly round on screen.\n    //\n    // Three zones from center outward:\n    //   1. Event horizon (diskDist < horizonRadius): absolute black\n    //   2. Photon ring (thin band at horizon boundary): bright amber emission\n    //   3. Lensing zone (horizonRadius  edge): warped background, fading out\n    // \n    if (uDiskMode == 1) {\n        float diskDist = length(vPosition.xy * 2.0);\n        if (diskDist > 1.0) discard;\n\n        float instanceTime = vLocalTime + vRandomSeed * 10.0;\n\n        // Event horizon radius  everything inside is absolute black\n        float horizonRadius = 0.50;\n\n        // \n        // GRAVITATIONAL LENSING  warp background around singularity\n        //\n        // Billboard local XY maps directly to screen right/up (camera-facing),\n        // so vPosition.xy gives us the screen-aligned lensing direction.\n        // Offset UV OUTWARD from center  samples from further out \n        // image appears pulled inward toward singularity.\n        // \n        vec2 screenUV = gl_FragCoord.xy / uResolution;\n\n        vec2 diskXY = vPosition.xy * 2.0;\n        vec2 lensDir = length(diskXY) > 0.001 ? normalize(diskXY) : vec2(0.0);\n\n        // Lensing strength: strongest near horizon, fading toward edge\n        // Scale by vInstanceAlpha so lensing fades gradually during exit (not binary pop)\n        float lensMask = smoothstep(1.0, horizonRadius + 0.10, diskDist);\n        float lensAmount = lensMask * 0.08 * uIntensity / 1.5 * vInstanceAlpha;\n\n        // Horizon mask: 0 inside event horizon (black), 1 outside (show lensed bg)\n        // Fade toward 1.0 (show unwarped bg) as instance fades out\n        float horizonMask = mix(1.0, smoothstep(horizonRadius - 0.03, horizonRadius + 0.08, diskDist), vInstanceAlpha);\n\n        // Sample with chromatic aberration (wavelength-dependent bending)\n        vec3 lensedBg = vec3(0.0);\n        if (uHasBackground == 1) {\n            vec2 lensOffset = lensDir * lensAmount;\n            float chrAb = lensAmount * 0.08;\n            lensedBg.r = texture2D(uBackgroundTexture, screenUV + lensOffset + lensDir * chrAb).r;\n            lensedBg.g = texture2D(uBackgroundTexture, screenUV + lensOffset).g;\n            lensedBg.b = texture2D(uBackgroundTexture, screenUV + lensOffset - lensDir * chrAb).b;\n        }\n\n        // Black center + lensed edges\n        vec3 color = lensedBg * horizonMask;\n\n        // \n        // PHOTON RING  bright band at horizon boundary\n        // \n        float ring = smoothstep(horizonRadius - 0.08, horizonRadius, diskDist)\n                   * smoothstep(horizonRadius + 0.06, horizonRadius, diskDist);\n        ring = pow(ring, 1.5);\n\n        // Shimmer  photons in unstable orbit\n        float shimmer = 0.9 + 0.1 * sin(instanceTime * 2.5 + diskDist * 40.0);\n        ring *= shimmer;\n\n        // Doppler asymmetry  slow rotation brightens approaching side\n        float dopplerAngle = vDopplerAngleXY;\n        float dopplerPhase = dopplerAngle + instanceTime * 0.4;\n        float doppler = 0.82 + 0.18 * sin(dopplerPhase);\n        ring *= doppler;\n\n        // Warm amber ring color  gravitationally redshifted photons\n        vec3 ringBase   = vec3(0.90, 0.55, 0.15);\n        vec3 ringBright = vec3(1.00, 0.90, 0.65);\n        vec3 ringColor  = mix(ringBase, ringBright, pow(ring, 2.0));\n\n        float softCap = uBloomThreshold + 0.30;\n        float ringBrightness = min(1.5, softCap) * uEdgeGlow;\n        color += ringColor * ring * ringBrightness * vInstanceAlpha;\n\n        // Instance fade  gradual (lensing already scaled by vInstanceAlpha above)\n        if (vInstanceAlpha < 0.02) discard;\n\n        // Cutout/grain (for gestures that use them)\n        float alpha = 1.0;\n        ${oS}\n        alpha *= trailAlpha;\n        ${lS}\n        if (alpha < 0.1) discard;\n\n        gl_FragColor = vec4(color, 1.0);\n        return;\n    }\n\n    // Per-instance time\n    float instanceTime = vLocalTime + vRandomSeed * 10.0;\n\n    // \n    // NOISE SMOOTHING  subtle world-space noise hides polygon seams\n    // Must be very small (0.02)  photon ring is only 0.18 wide, so even\n    // 0.01 perturbation is ~5% of ring width. Larger values (0.1) made\n    // the singularity visibly blobby instead of a perfect circle.\n    // \n    float t = instanceTime * uTendrilSpeed;\n    vec3 np = vWorldPosition * 5.0;\n    float smoothNoise = noise(np * 2.0 + vec3(t * 0.3, -t * 0.2, t * 0.15));\n    float smoothEdge = edgeness + (smoothNoise - 0.5) * 0.02;\n\n    // \n    // GRAVITATIONAL LENSING  screen-space background distortion\n    //\n    // For 3D geometry (void-orb, void-ring, void-wrap): warps background\n    // through the geometry surface using view-space normals for lens direction.\n    // For disk mode (void-disk): lensing is handled above using diskDist.\n    // \n    vec2 screenUV = gl_FragCoord.xy / uResolution;\n\n    // Lensing direction: view-space normal .xy  screen-space direction.\n    // Positive offset = sample further out = image appears pulled inward.\n    vec2 lensDir = normal.xy;\n    float lensMag = length(lensDir);\n    lensDir = lensMag > 0.001 ? lensDir / lensMag : vec2(0.0);\n\n    // Event horizon boundary  below this = absolute black, above = lensing\n    float horizonEdge = 0.45;\n\n    // Lensing strength ramps up beyond the horizon\n    // Scale by vInstanceAlpha so lensing fades gradually during exit (not binary pop)\n    float lensMask = smoothstep(horizonEdge, horizonEdge + 0.30, smoothEdge);\n    float lensAmount = lensMask * 0.06 * uIntensity / 1.5 * vInstanceAlpha;\n\n    // Event horizon mask: 0 = pure black, 1 = shows lensed background\n    // Fade toward 1.0 (show unwarped bg) as instance fades out\n    float horizonMask = mix(1.0, smoothstep(horizonEdge - 0.05, horizonEdge + 0.10, smoothEdge), vInstanceAlpha);\n\n    // Sample lensed background with subtle chromatic aberration (wavelength-dependent bending)\n    vec3 lensedBg = vec3(0.0);\n    if (uHasBackground == 1) {\n        vec2 lensOffset = lensDir * lensAmount;\n        float chrAb = lensAmount * 0.08;  // Subtle prismatic shift, not rainbow\n        lensedBg.r = texture2D(uBackgroundTexture, screenUV + lensOffset + lensDir * chrAb).r;\n        lensedBg.g = texture2D(uBackgroundTexture, screenUV + lensOffset).g;\n        lensedBg.b = texture2D(uBackgroundTexture, screenUV + lensOffset - lensDir * chrAb).b;\n    }\n\n    // Composite: black center + gravitationally lensed edges\n    vec3 color = lensedBg * horizonMask;\n\n    // \n    // PHOTON RING  thin bright emission at the horizon boundary\n    // Photons in unstable orbits pile up at the photon sphere, creating\n    // the bright ring visible in the reference image.\n    // \n    float ring = smoothstep(horizonEdge - 0.10, horizonEdge, smoothEdge)\n               * smoothstep(horizonEdge + 0.08, horizonEdge, smoothEdge);\n    ring = pow(ring, 1.5);\n\n    // Shimmer  photons in unstable orbit\n    float shimmer = 0.9 + 0.1 * sin(instanceTime * 2.5 + smoothEdge * 25.0 + smoothNoise * 10.0);\n    ring *= shimmer;\n\n    // Doppler asymmetry  rotating singularity brightens the approaching side.\n    // Uses object-space vertex angle (pre-computed in vertex shader).\n    // Subtle: dim side still at 65%  must preserve circular read.\n    float dopplerAngle = vDopplerAngleXZ;\n    float dopplerPhase = dopplerAngle + instanceTime * 0.4;  // Slow rotation\n    float doppler = 0.82 + 0.18 * sin(dopplerPhase);         // 0.64 to 1.0 range\n    ring *= doppler;\n\n    // Warm amber photon ring  gravitationally redshifted photons\n    // Slightly hotter than overlay edge emission to read as distinct ring\n    vec3 ringBase   = vec3(0.90, 0.55, 0.15);\n    vec3 ringBright = vec3(1.00, 0.90, 0.65);\n    vec3 ringColor  = mix(ringBase, ringBright, pow(ring, 2.0));\n\n    float softCap = uBloomThreshold + 0.30;\n    float ringBrightness = min(1.5, softCap) * uEdgeGlow;\n    color += ringColor * ring * ringBrightness * vInstanceAlpha;\n\n    // \n    // VISIBILITY  discard invisible pixels, everything else is fully opaque.\n    // Lensing, horizon mask, and photon ring all scale by vInstanceAlpha above,\n    // so elements fade gracefully during exit instead of binary popping.\n    // \n\n    // Instance fade  gradual (lensing already scaled by vInstanceAlpha)\n    if (vInstanceAlpha < 0.02) discard;\n\n    // Arc visibility (for vortex/relay effects)\n    if (vArcVisibility < 0.999) {\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // Cutout/grain reduce alpha to create holes (tears in spacetime).\n    // Visible pixels are ALWAYS alpha=1.0. Low-alpha pixels are discarded.\n    float alpha = 1.0;\n    ${oS}\n    alpha *= trailAlpha;\n    ${lS}\n\n    // Binary: visible (alpha=1) or discarded. No partial transparency.\n    if (alpha < 0.1) discard;\n\n    // \n    // FINAL OUTPUT  always opaque\n    // Color already composited: black center + lensed edges + photon ring\n    // \n    gl_FragColor = vec4(color, 1.0);\n}\n`,KS=fS,ZS={radiance:.5,opacity:.45,fadeInDuration:.15,fadeOutDuration:.3};function JS(e,t,n){return e+(t-e)*n}const eM="\nfloat noiseHash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(mix(noiseHash(i), noiseHash(i + vec3(1,0,0)), f.x),\n            mix(noiseHash(i + vec3(0,1,0)), noiseHash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(noiseHash(i + vec3(0,0,1)), noiseHash(i + vec3(1,0,1)), f.x),\n            mix(noiseHash(i + vec3(0,1,1)), noiseHash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\nfloat snoise(vec3 p) {\n    return noise(p) * 2.0 - 1.0;\n}\n",tM=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uRadiance;\nuniform float uPulseSpeed;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;\nuniform float uArcWidth;\nuniform float uArcSpeed;\nuniform int uArcCount;\nuniform float uArcPhase;\nuniform float uGestureProgress;\nuniform int uRelayCount;\nuniform float uRelayArcWidth;\nuniform float uRelayFloor;\n\n// Per-instance attributes\n${nS}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\n\n${eM}\n\nvoid main() {\n    // \n    // INSTANCING: Calculate local time and fade\n    // \n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade controlled by aInstanceOpacity from AnimationState\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // \n    // MODEL SELECTION: Scale non-selected models to zero\n    // \n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // \n    // TRAIL OFFSET: Position trails behind main along velocity\n    // \n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // \n    // LIGHT: Radiant pulse  gentle outward breathing along normal\n    // Each instance breathes independently via aRandomSeed phase offset.\n    // Subtle displacement (0.02)  enough to feel alive, not enough to deform.\n    // \n\n    float instanceTime = vLocalTime + aRandomSeed * 10.0;\n    float breathe = sin(instanceTime * uPulseSpeed + aRandomSeed * 6.28) * 0.02 * uRadiance;\n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / 1.0, 0.0, 1.0);\n\n    vec3 displaced = selectedPosition + selectedNormal * breathe + trailOffset;\n\n    // Normal transform through instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n\n    // \n    // Apply instance matrix for per-instance transforms\n    // \n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // \n    // ARC VISIBILITY (for vortex ring effects)\n    // \n    vArcVisibility = 1.0;\n    if (aRandomSeed >= 100.0) {\n        // Generalized relay: supports arbitrary relay count via uRelayCount\n        float encoded = aRandomSeed - 100.0;\n        float ringId = floor(encoded / 10.0);\n        float instanceArcPhase = encoded - ringId * 10.0;\n\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float hw = uRelayArcWidth * 0.5;\n        float angleDiff = vertexAngle - instanceArcPhase;\n        angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n        float arcMask = 1.0 - smoothstep(hw * 0.7, hw, abs(angleDiff));\n\n        float cp = uGestureProgress * float(uRelayCount) * 1.5;\n        float d = cp - ringId;\n        float relayAlpha = smoothstep(-0.30, 0.05, d) * (1.0 - smoothstep(0.70, 1.05, d));\n        vArcVisibility = arcMask * mix(uRelayFloor, 1.0, relayAlpha);\n    } else if (uAnimationType == 1) {\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + uArcPhase;\n        float halfWidth = uArcWidth * 3.14159;\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n            float angleDiff = mod(vertexAngle - thisArcAngle + 3.14159, 6.28318) - 3.14159;\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * instancePosition;\n}\n`,nM=`\nuniform float uGlobalTime;\nuniform float uRadiance;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uPulseSpeed;\nuniform float uRayIntensity;\nuniform float uSparkleRate;\nuniform float uBloomThreshold;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${rS}\n\n// Instancing varyings\n${aS}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\n\n${eM}\n${sS}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewDir);\n\n    // Local time (required by CUTOUT_GLSL and GRAIN_GLSL)\n    float localTime = vLocalTime;\n    float instanceTime = localTime + vRandomSeed * 10.0;\n\n    // NdotV for fresnel and core intensity\n    float NdotV = max(0.0, dot(normal, viewDir));\n    float fresnel = pow(1.0 - NdotV, 2.5);\n\n    // \n    // LAYER 1: CORE GLOW  warm golden base, brighter face-on\n    //\n    // Golden at low radiance, white-gold at high radiance.\n    // NdotV drives brightness: face-on = bright core, edges = softer.\n    // The decoupled approach from fire: color is always warm (never dark),\n    // visibility is controlled by alpha alone.\n    // \n\n    // Radiance-driven color: golden  white-gold\n    vec3 warmGold = vec3(1.0, 0.85, 0.4);\n    vec3 whiteGold = vec3(1.0, 0.97, 0.88);\n    vec3 lightColor = mix(warmGold, whiteGold, uRadiance);\n\n    // Core brightness: face-on bright, edges fade to transparent.\n    // Lower floor (0.3 not 0.5) so silhouette edges are dim  soft alpha falloff.\n    // Noise breaks up the uniform blob  prevents bloom mip-level banding.\n    float brightNoise = noise(vPosition * 4.0 + vec3(instanceTime * 0.5));\n    float coreBrightness = (0.3 + NdotV * 0.7) * (0.5 + brightNoise);\n\n    // Gentle breathing pulse\n    float pulse = 1.0 + sin(instanceTime * uPulseSpeed) * 0.12;\n\n    vec3 coreGlow = lightColor * coreBrightness * pulse;\n\n    // \n    // LAYER 2: LIGHT RAYS  organic "god rays" emanating from object\n    //\n    // 5 primary rays with noise-varying width per-ray for organic feel.\n    // Per-ray shimmer makes each beam flicker independently.\n    // 9 thin secondary filament rays for complexity.\n    // Majestic slow rotation. Visible at edges + transition zone.\n    // \n\n    float angle = atan(vPosition.z, vPosition.x);\n\n    // Primary god rays: 5 beams with noise-modulated width\n    float rayAngle = angle + instanceTime * 0.2;\n    float rayBase = sin(rayAngle * 5.0) * 0.5 + 0.5;\n\n    // Noise varies the sharpening power per-ray  some sharp, some wide\n    float edgeNoise = noise(vec3(angle * 2.5, instanceTime * 0.3, vRandomSeed * 5.0));\n    float ray = pow(rayBase, 2.0 + edgeNoise * 3.0);\n\n    // Per-ray shimmer: each ray flickers at its own rate\n    float shimmerPos = floor(angle * 5.0 / 6.28318) * 7.13;\n    float shimmer = 0.7 + 0.3 * sin(instanceTime * 1.5 + shimmerPos);\n    ray *= shimmer;\n\n    // Thin secondary filament rays (more numerous, fainter)\n    float ray2 = sin(rayAngle * 9.0 + 1.8) * 0.5 + 0.5;\n    ray2 = pow(ray2, 5.0) * 0.25;\n\n    float rayPattern = (ray + ray2) * uRayIntensity;\n\n    // Rays visible at edges (fresnel) and core-to-edge transition zone\n    float rayMask = fresnel * 0.6 + 0.4;\n    vec3 rays = lightColor * 1.3 * rayPattern * rayMask;\n\n    // \n    // LAYER 3: SPARKLES  sparse white-hot flickers for bloom catchment\n    //\n    // Hash-based: top 3% of surface gets a sparkle.\n    // Pure white vec3(1.5) exceeds 1.0 for bloom.\n    // Time-quantized so sparkles flicker discretely (not smooth).\n    // Multiplied by radiance so low radiance = no sparkles.\n    // \n\n    // Discrete time steps for flickering sparkle (not smooth)\n    float sparkleTime = floor(instanceTime * uSparkleRate);\n    vec3 sparklePos = vPosition * 30.0 + vec3(sparkleTime * 1.7, sparkleTime * 2.3, sparkleTime * 0.9);\n    float sparkleNoise = noiseHash(sparklePos);\n\n    // Top 3%  sparkle\n    float sparkleMask = step(0.97, sparkleNoise) * uRadiance;\n    vec3 sparkles = vec3(1.5) * sparkleMask;\n\n    // \n    // COMBINE  all layers contribute to brightness\n    // \n\n    vec3 color = (coreGlow + rays + sparkles) * uIntensity * uGlowScale;\n\n    // \n    // ALPHA  brightness-driven (like electricity's bolt-brightness approach)\n    //\n    // No base glow  dark areas invisible, prevents model silhouette reveal.\n    // Wide smoothstep for gradual buildup via additive stacking.\n    // \n\n    float brightness = (coreBrightness * pulse + rayPattern * rayMask + sparkleMask * 2.0);\n    // Wide smoothstep range: noise variation maps to a smooth gradient (not binary on/off).\n    // Old (0.15, 0.9) collapsed most brightness to alpha1.0  hard edges  bloom banding.\n    float alpha = smoothstep(0.2, 1.4, brightness) * uOpacity;\n\n    // Subtle fresnel (0.05 not 0.15)  too much hardens silhouette edges, worsening bloom\n    alpha += fresnel * 0.05 * uRadiance;\n    alpha = clamp(alpha, 0.0, 1.0);\n\n    // Apply instance alpha (spawn/exit fade + trail fade)\n    alpha *= vInstanceAlpha;\n\n    // Apply arc visibility (for vortex/relay effects)\n    if (vArcVisibility < 0.999) {\n        alpha *= vArcVisibility;\n        color *= mix(0.3, 1.0, vArcVisibility);\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // Discard invisible pixels\n    if (alpha < 0.05) discard;\n\n    // Shared cutout system from InstancedAnimationCore\n    ${oS}\n\n    // Grain effect\n    ${lS}\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,aM=fS,iM={petrification:.5,opacity:1,wetSpeed:.3,fadeInDuration:.15,fadeOutDuration:.3};function rM(e,t,n){return e+(t-e)*n}const sM="\nfloat noiseHash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(mix(noiseHash(i), noiseHash(i + vec3(1,0,0)), f.x),\n            mix(noiseHash(i + vec3(0,1,0)), noiseHash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(noiseHash(i + vec3(0,0,1)), noiseHash(i + vec3(1,0,1)), f.x),\n            mix(noiseHash(i + vec3(0,1,1)), noiseHash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\nfloat snoise(vec3 p) {\n    return noise(p) * 2.0 - 1.0;\n}\n\n// FBM for rocky surface detail (3 octaves  4th at 14.4x is sub-pixel)\nfloat fbm(vec3 p) {\n    float value = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 3; i++) {\n        value += amp * noise(p);\n        p *= 2.0;\n        amp *= 0.5;\n    }\n    return value;\n}\n\n// 2D hash for Voronoi\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\n// Voronoi edge-distance for mineral veins\nfloat voronoiEdge(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    float minDist = 1.0;\n    float secondDist = 1.0;\n\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = hash2(n + neighbor) * 0.8 + 0.1 + neighbor;\n            float d = length(f - point);\n\n            if (d < minDist) {\n                secondDist = minDist;\n                minDist = d;\n            } else if (d < secondDist) {\n                secondDist = d;\n            }\n        }\n    }\n\n    return secondDist - minDist;\n}\n",oM=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uPetrification;\nuniform float uPulseSpeed;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;\nuniform float uArcWidth;\nuniform float uArcSpeed;\nuniform int uArcCount;\nuniform float uArcPhase;\nuniform float uGestureProgress;\nuniform int uRelayCount;         // Number of relay rings\nuniform float uRelayArcWidth;   // Relay arc width in radians\nuniform float uRelayFloor;\n\n// Per-instance attributes\n${nS}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewDir;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\n\n${sM}\n\nvoid main() {\n    // \n    // INSTANCING: Calculate local time and fade\n    // \n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade controlled by aInstanceOpacity from AnimationState\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // \n    // MODEL SELECTION: Scale non-selected models to zero\n    // \n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // \n    // TRAIL OFFSET: Position trails behind main along velocity\n    // \n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // \n    // EARTH: Subtle geological displacement along normal\n    // Very subtle (0.01)  stone is rigid, not organic.\n    // \n\n    float instanceTime = vLocalTime + aRandomSeed * 10.0;\n    float breathe = sin(instanceTime * uPulseSpeed + aRandomSeed * 6.28) * 0.01 * uPetrification;\n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / 1.0, 0.0, 1.0);\n\n    vec3 displaced = selectedPosition + selectedNormal * breathe + trailOffset;\n\n    // Normal transform through instance matrix\n    mat3 normalMat = mat3(instanceMatrix);\n    vNormal = normalMatrix * normalMat * selectedNormal;\n    vWorldNormal = normalMat * selectedNormal;\n\n    // \n    // Apply instance matrix for per-instance transforms\n    // \n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // \n    // ARC VISIBILITY (for vortex ring effects)\n    // \n    vArcVisibility = 1.0;\n    if (aRandomSeed >= 100.0) {\n        // Generalized relay: supports arbitrary relay count via uRelayCount\n        float encoded = aRandomSeed - 100.0;\n        float ringId = floor(encoded / 10.0);\n        float instanceArcPhase = encoded - ringId * 10.0;\n\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float hw = uRelayArcWidth * 0.5;\n        float angleDiff = vertexAngle - instanceArcPhase;\n        angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n        float arcMask = 1.0 - smoothstep(hw * 0.7, hw, abs(angleDiff));\n\n        float cp = uGestureProgress * float(uRelayCount) * 1.5;\n        float d = cp - ringId;\n        float relayAlpha = smoothstep(-0.30, 0.05, d) * (1.0 - smoothstep(0.70, 1.05, d));\n        vArcVisibility = arcMask * mix(uRelayFloor, 1.0, relayAlpha);\n    } else if (uAnimationType == 1) {\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + uArcPhase;\n        float halfWidth = uArcWidth * 3.14159;\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n            float angleDiff = mod(vertexAngle - thisArcAngle + 3.14159, 6.28318) - 3.14159;\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * instancePosition;\n}\n`,lM=`\nuniform float uGlobalTime;\nuniform float uPetrification;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uPulseSpeed;\nuniform float uVeinIntensity;\nuniform float uBloomThreshold;\n\n// Shared wetness system (WetnessCore)\n${ES}\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${rS}\n\n// Instancing varyings\n${aS}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewDir;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\n\n${sM}\n${IS}\n${sS}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    vec3 normal = normalize(vNormal);\n    vec3 faceNormal = normalize(cross(dFdx(vWorldPosition), dFdy(vWorldPosition)));\n    vec3 viewDir = normalize(vViewDir);\n\n    // Local time (required by CUTOUT_GLSL and GRAIN_GLSL)\n    float localTime = vLocalTime;\n    float instanceTime = localTime + vRandomSeed * 10.0;\n\n    // NdotV for fresnel\n    float NdotV = max(0.0, dot(normal, viewDir));\n\n    // \n    // LAYER 1: STONE BODY  Seiryu-style dark grey limestone\n    //\n    // Cool charcoal grey base with slight blue undertones.\n    // Petrification drives from slightly warm grey  pure cool grey.\n    // Stone is primarily diffuse. NdotL is the main lighting model.\n    // \n\n    // Petrification-driven base color  cool grey stone (Seiryu limestone)\n    vec3 warmGrey  = vec3(0.36, 0.35, 0.33);  // Warm neutral grey  subtle warmth only\n    vec3 coolGrey  = vec3(0.30, 0.31, 0.35);  // Blue-grey stone (more petrified)\n    vec3 baseColor = mix(warmGrey, coolGrey, uPetrification);\n\n    // Per-instance geological color shift  each rock is unique\n    float instanceWarm = fract(vRandomSeed * 3.71) * 2.0 - 1.0;\n    baseColor *= vec3(1.0 + instanceWarm * 0.08, 1.0 + instanceWarm * 0.03, 1.0 - instanceWarm * 0.06);\n\n    // \n    // MINERAL COLOR PATCHES  subtle geological variety\n    //\n    // Seiryu stones are mostly uniform cool grey. Very subtle mineral shifts.\n    // Slight warm ochre in sparse patches, blue-grey dominant.\n    // \n\n    float mineralNoise1 = noise(vPosition * 1.8 + vec3(vRandomSeed * 4.0));\n    float mineralNoise2 = noise(vPosition * 0.8 + vec3(vRandomSeed * 2.5, 1.3, 0.7));\n\n    // Mineral masks  computed here but applied AFTER diffuse lighting\n    // Pre-diffuse mixing loses warmth through shade noise, diffuse, crevice, grain.\n    // Post-diffuse multiplicative tint preserves warm/cool contrast on screen.\n    // Both warm masks derived from single noise (was 2 calls)  different threshold bands\n    float ochreMask = smoothstep(0.42, 0.65, mineralNoise1);\n    float warmMask = smoothstep(0.35, 0.58, mineralNoise1);\n\n    // Blue-grey patches  cool mineral zones, characteristic of real stone\n    vec3 blueGrey = vec3(0.22, 0.24, 0.30);  // Blue-grey mineral\n    float blueGreyMask = smoothstep(0.35, 0.18, mineralNoise2);\n    baseColor = mix(baseColor, blueGrey, blueGreyMask * 0.22);  // Stronger cool patches\n\n    // Per-pixel shade variation  reduced amplitude to not overpower mineral patches\n    vec3 warpOffset = vec3(\n        noise(vPosition * 2.0 + vec3(vRandomSeed * 3.3)),\n        noise(vPosition * 2.0 + vec3(0.0, vRandomSeed * 4.1, 7.0)),\n        0.0\n    ) * 0.4;\n    vec3 warpedPos = vPosition + warpOffset;\n    float shadeNoise = noise(warpedPos * 8.0 + vec3(vRandomSeed * 5.5));\n    baseColor *= 0.88 + shadeNoise * 0.24;  // 12%  stronger tonal variation\n    // Warm/cool tint variation  geological color shifts\n    float tintNoise = noise(warpedPos * 5.0 + vec3(vRandomSeed * 2.2, 1.7, 0.4));\n    vec3 warmShift = baseColor * vec3(1.03, 1.00, 0.96);\n    vec3 coolShift = baseColor * vec3(0.96, 0.99, 1.04);\n    baseColor = mix(coolShift, warmShift, tintNoise);\n\n    // \n    // SURFACE NOISE + PROCEDURAL BUMP  computed BEFORE diffuse lighting\n    //\n    // Noise drives both color variation (crevice/ridge/grain) AND bump normal\n    // perturbation. dFdx/dFdy of smooth noise gives stable screen-space gradients.\n    // Gritty zones get strong bumps (rough sandstone), polished zones stay flat.\n    // \n\n    // Two-scale rock noise: large tonal zones + medium detail\n    float rockLarge = fbm(vPosition * 1.8 + vec3(vRandomSeed * 3.0));\n    float rockMedium = noise(vPosition * 5.0 + vec3(vRandomSeed * 6.0));\n    float rockNoise = rockLarge * 0.7 + rockMedium * 0.3;\n    float detailNoise = noise(vPosition * 10.0 + vec3(vRandomSeed * 7.0));\n\n    // Zone classification derived from rockLarge (same 1.8 scale  saves a noise call)\n    // fract() decorrelates so grit zones aren't visually locked to rock relief\n    float zoneNoise = fract(rockLarge * 2.7 + 0.3);\n    float grittyZone = smoothstep(0.30, 0.55, zoneNoise);    // 0=smooth, 1=gritty\n    float polishedZone = smoothstep(0.78, 0.88, zoneNoise);  // top slice = polished\n\n    //  Procedural bump mapping \n    // Height field: rockNoise (broad ridges/crevices) + detailNoise (fine grit)\n    // Zone modulation on strength only  height field is uniform, perturbation varies\n    float bumpHeight = rockNoise * 0.6 + detailNoise * 0.4;\n\n    // Screen-space derivatives of height  surface gradient\n    float dhdx = dFdx(bumpHeight);\n    float dhdy = dFdy(bumpHeight);\n\n    // Surface tangent frame from object-space position derivatives\n    vec3 surfT = normalize(dFdx(vPosition));\n    vec3 surfB = normalize(dFdy(vPosition));\n\n    // Bump strength: gritty zones get full bump, polished zones nearly flat\n    float bumpStrength = mix(0.3, 1.0, grittyZone) * (1.0 - polishedZone * 0.8);\n    vec3 bumpedNormal = normalize(normal - 5.0 * bumpStrength * (surfT * dhdx + surfB * dhdy));\n\n    // Three lights for diffuse (same positioning as other elements)\n    vec3 lightDir1 = normalize(vec3(0.5, 1.0, 0.3));\n    vec3 lightDir2 = normalize(vec3(-0.4, 0.6, -0.5));\n    vec3 lightDir3 = normalize(vec3(0.0, -0.3, 0.8));\n\n    // Diffuse uses bumped normal  per-pixel lighting variation from surface relief\n    float NdotL1 = max(0.0, dot(bumpedNormal, lightDir1));\n    float NdotL2 = max(0.0, dot(bumpedNormal, lightDir2));\n    float NdotL3 = max(0.0, dot(bumpedNormal, lightDir3));\n\n    // Directional diffuse  primary light dominant for clear light/shadow contrast\n    float bumpDiffuse = NdotL1 * 0.78 + NdotL2 * 0.14 + NdotL3 * 0.08;\n\n    // Face-normal diffuse  sharp per-polygon contrast (chiseled stone planes)\n    float faceNdotL1 = max(0.0, dot(faceNormal, lightDir1));\n    float faceDiffuse = faceNdotL1 * 0.78 + max(0.0, dot(faceNormal, lightDir2)) * 0.14 + max(0.0, dot(faceNormal, lightDir3)) * 0.08;\n\n    // Blend: 60% bump (detail) + 40% face (sharp polygon contrast)\n    float diffuse = bumpDiffuse * 0.6 + faceDiffuse * 0.4;\n\n    // Cool ambient with hemisphere variation (sky vs ground)\n    float skyAmt = bumpedNormal.y * 0.5 + 0.5;\n    vec3 ambientUp   = vec3(0.22, 0.23, 0.26);  // Cool sky ambient  slight blue\n    vec3 ambientDown = vec3(0.12, 0.12, 0.14);  // Neutral cool ground bounce\n    vec3 ambient = mix(ambientDown, ambientUp, skyAmt);\n\n    vec3 stoneColor = baseColor * (ambient + vec3(diffuse));\n\n    //  Edge ambient occlusion \n    // Silhouette edges (low NdotV) get subtle darkening  simulates cavity\n    // occlusion between adjacent faces. Adds depth to shadow areas that\n    // otherwise look uniformly flat. Uses bumped normal so AO varies per-pixel.\n    float edgeNdotV = max(0.0, dot(bumpedNormal, viewDir));\n    float edgeAO = smoothstep(0.0, 0.45, edgeNdotV);  // 0=edge, 1=face-on\n    stoneColor *= mix(0.85, 1.0, edgeAO);  // 15% darken at extreme edges (SSAO handles inter-object)\n\n    // \n    // LAYER 2: SURFACE DETAIL  color variation from the same noise\n    //\n    // Bump already handles lighting relief. These add color darkening/brightening\n    // that stacks on top  crevice shadows get both physical and tonal depth.\n    // \n\n    // Crevice darkening  lighter floor since bump already handles physical shadow\n    float crevice = smoothstep(0.30, 0.48, rockNoise);\n    vec3 creviceColor = baseColor * vec3(0.46, 0.47, 0.52);  // Cool crevice shadow\n    stoneColor = mix(creviceColor, stoneColor, crevice);\n\n    // Ridge brightening  cool highlight on exposed faces\n    float ridge = smoothstep(0.60, 0.75, rockNoise);\n    stoneColor = mix(stoneColor, baseColor * vec3(1.10, 1.08, 1.05), ridge * 0.25);\n\n    //  Mottled grain zones \n    // Fine angular micro-grain  sharp hash at 120x (cells too small to see)\n    float microGrain = noiseHash(floor(vPosition * 120.0 + vec3(vRandomSeed * 2.0)));\n\n    // Blend with smooth detail noise for broader tonal patches\n    float grit = detailNoise * 0.55 + microGrain * 0.45;\n\n    // Polished zones: grain fades strongly to neutral (smooth worn faces)\n    grit = mix(grit, 0.5, polishedZone * 0.90);\n\n    // Zone-controlled amplitude: gritty=moderate (18%), smooth=subtle (8%)\n    float gritAmp = mix(0.16, 0.36, grittyZone) * (1.0 - polishedZone * 0.85);\n    stoneColor *= (1.0 - gritAmp * 0.5) + grit * gritAmp;\n\n    //  Post-diffuse mineral mottling \n    // Sparse warm patches for geological realism  stone is mostly grey\n    // with occasional ochre/iron deposits. Kept subtle so grey dominates.\n    float warmAmount = min(ochreMask * 0.30 + warmMask * 0.20, 0.30);\n    warmAmount *= smoothstep(0.05, 0.4, diffuse);  // Only in lit areas\n    vec3 warmTint = vec3(1.06, 1.02, 0.93);  // Subtle warm  barely shifts grey\n    stoneColor *= mix(vec3(1.0), warmTint, warmAmount);\n\n    // \n    // SEDIMENTARY STRATA  subtle horizontal color banding\n    //\n    // Alternating warm/cool layers based on object-space Y, warped by noise\n    // so bands aren't perfectly straight  like real layered rock.\n    // \n\n    float strataY = vPosition.y * 6.0 + vRandomSeed * 3.0;\n    float strataWarp = noise(vPosition * 2.0 + vec3(0.0, vRandomSeed * 5.0, 0.0));\n    float strata = sin(strataY + strataWarp * 2.0) * 0.5 + 0.5;\n    vec3 warmBand = stoneColor * vec3(1.02, 1.01, 0.97);\n    vec3 coolBand = stoneColor * vec3(0.97, 0.99, 1.03);\n    stoneColor = mix(coolBand, warmBand, strata);\n\n    // \n    // LAYER 3: CRACKS + CALCITE VEINS  Seiryu stone-inspired fractures\n    //\n    // Voronoi edge-distance drives both DARK crevices and BRIGHT calcite veins.\n    // Noise selects which cracks are empty (dark shadow) vs calcite-filled (white).\n    // Calcite veins are the signature look of Seiryu/limestone rocks.\n    // \n\n    // Voronoi on object-space XZ (models may lack UVs)\n    vec2 crackPos = vPosition.xz * 2.5 + vec2(vPosition.y * 0.7, vRandomSeed * 2.0);\n    float crackEdge = voronoiEdge(crackPos);\n\n    // Crack masks consolidated: 2 noise calls instead of 4\n    // crackMaskA: break erasure (low band) + calcite selection (high band)\n    float crackMaskA = noise(vec3(crackPos * 0.6, vRandomSeed * 4.0));\n    float breakMask = smoothstep(0.25, 0.50, crackMaskA);\n    float isCalcite = smoothstep(0.55, 0.72, crackMaskA);  // upper band = calcite\n\n    // crackMaskB: width variation + stain selection (Y-coupled for drip direction)\n    float crackMaskB = noise(vec3(crackPos * 1.0, vRandomSeed * 6.0 + vPosition.y * 2.0));\n    float crackWidth = mix(0.03, 0.08, crackMaskB);  // hairline  wide gape\n\n    // Dark crack lines  empty crevices (deeper on dark stone)\n    float darkCrackLine = 1.0 - smoothstep(0.0, crackWidth, crackEdge);\n    darkCrackLine *= breakMask * (1.0 - isCalcite);  // only where NOT calcite\n    vec3 crackColor = vec3(0.04, 0.04, 0.06);  // Cool dark crevice\n    stoneColor = mix(stoneColor, crackColor, darkCrackLine * 0.95);\n\n    // Calcite veins  bright white lines tracing fracture paths\n    float calciteLine = 1.0 - smoothstep(0.0, 0.05, crackEdge);\n    calciteLine *= breakMask * isCalcite;\n    // Subtle cream calcite  close to stone tone with slight warm offset\n    vec3 calciteColor = vec3(0.75, 0.74, 0.72);  // Bright white calcite mineral\n    stoneColor = mix(stoneColor, calciteColor, calciteLine * 0.75);\n\n    // Combined crack line for wetness crack-pooling (both dark + calcite)\n    float crackLine = max(darkCrackLine, calciteLine);\n\n    // Rare mica sparkle  cool silver in dark cracks, top 15%\n    float micaMask = smoothstep(0.85, 1.0, crackMaskA) * (1.0 - isCalcite);\n    float micaShimmer = 0.6 + 0.4 * sin(instanceTime * uPulseSpeed * 2.0 + crackEdge * 20.0);\n    vec3 micaColor = vec3(0.30, 0.30, 0.35) * micaShimmer * uVeinIntensity;  // Subtle silver, not bright\n    float micaLine = (1.0 - smoothstep(0.0, 0.04, crackEdge)) * micaMask;  // Wider spread, less point-like\n\n    // \n    // MINERAL STAINING  very sparse warm hints near cracks (Seiryu has minimal)\n    // \n\n    float stainZone = smoothstep(0.0, 0.08, crackEdge) * (1.0 - smoothstep(0.08, 0.25, crackEdge));\n    float stainDrip = smoothstep(0.55, 0.70, crackMaskB);  // Reuses crackMaskB (Y-coupled)\n    vec3 stainColor = vec3(0.28, 0.27, 0.24);  // Muted neutral deposit\n    stoneColor = mix(stoneColor, stainColor, stainZone * stainDrip * breakMask * 0.08);\n\n    // \n    // WET SHEEN  moisture patches with crack pooling and temporal drift\n    //\n    // Uses shared WetnessCore module. Noise-driven damp patches:\n    //   1. Strong darkening (wet stone absorbs more light)\n    //   2. Saturation boost (water fills pores  richer color, like wetting a pebble)\n    //   3. Broad glossy specular sheen on wet faces\n    // Dry stone = warm matte. Wet stone = dark, rich, with broad soft gloss.\n    // \n\n    float crackProximity = 1.0 - smoothstep(0.0, 0.10, crackEdge);\n    // Guard: at low wetness, wet patches are imperceptible.\n    // Skip 4 noise + sin (~165 ALU) and use 0.0 instead.\n    float wetMask = uWetness > 0.15 ? calculateWetMask(vPosition, vRandomSeed, instanceTime, crackProximity) : 0.0;\n\n    // Moderate darkening  wet stone absorbs light, darker than dry.\n    // Tuned for dark Seiryu grey base: 0.45 multiplier (was 0.75 for bright sandstone).\n    // At wetMask=0.40 (typical peak): 0.82 = 18% darker. Visible but not black.\n    stoneColor *= 1.0 - wetMask * 0.45;\n\n    // Brightness floor  prevent wet areas from going near-black on dark base\n    float wetLuma = dot(stoneColor, vec3(0.299, 0.587, 0.114));\n    stoneColor = max(stoneColor, stoneColor * (0.08 / max(wetLuma, 0.01)));\n\n    // Saturation boost  water fills micro-pores, reduces diffuse scatter.\n    // Only apply when stone is bright enough for saturation to matter.\n    // On near-black values (wetLuma < 0.10), saturation boost creates odd\n    // color shifts instead of enrichment  skip in dark areas.\n    float satBoost = wetMask * smoothstep(0.06, 0.14, wetLuma);\n    float luma = dot(stoneColor, vec3(0.299, 0.587, 0.114));\n    stoneColor = mix(stoneColor, mix(vec3(luma), stoneColor, 1.4), satBoost);\n\n    // \n    // SPECULAR  unified dry-to-wet transition (Lagarde wet surfaces model)\n    //\n    // ONE specular with parameters that smoothly transition from dry to wet:\n    //   Power:     80 (tight matte)  24 (broad sheen)\n    //   Intensity: 0.08 (faint)      0.50 (visible gloss)\n    //   Color:     warm stone        near-white (water reflects sky)\n    //   Normal:    face normal       30% blend toward smooth (water film)\n    //\n    // Stone porosity ~0.8. Water fills pores  roughness drops, reflectance rises.\n    // Face normals still dominate (70%) so different polygons catch light\n    // differently  some faces glossy, others matte. NOT uniform sheen.\n    //\n    // Ref: Lagarde "Water Drop 3b  Physically Based Wet Surfaces" (2013)\n    // Game-friendly simplification: modify power/intensity, don't add separate terms.\n    // \n\n    vec3 halfDir1 = normalize(lightDir1 + viewDir);\n    vec3 halfDir2 = normalize(lightDir2 + viewDir);\n    vec3 halfDir3 = normalize(lightDir3 + viewDir);\n\n    // Sharpened wet mask for specular  creates binary-ish wet/dry boundary.\n    // wetMask is gradual (0-0.65 typical). Sharpen so wet areas reach near 1.0\n    // and dry areas stay near 0.0. This makes the specular parameters actually\n    // reach the "visibly wet" range in wet zones, instead of everything at 0.5.\n    // Darkening still uses the gradual wetMask for soft transitions.\n    float specWet = smoothstep(0.15, 0.45, wetMask);\n\n    //  Water film micro-ripple normal perturbation \n    // On flat-shaded low-poly, specular is binary per face (on or off).\n    // Real wet stone has per-pixel variation from water micro-geometry:\n    // ripples, droplet menisci, surface tension patterns.\n    // Noise-based normal perturbation creates shimmering specular WITHIN\n    // each polygon face  some pixels catch light, others don't.\n    // Dry areas: zero perturbation (flat matte rock, correct).\n    // Wet areas: subtle ripple  per-pixel specular variation.\n    // Skip ripple noise when dry  saves 2 noise() calls on dry surfaces\n    vec3 ripplePerturbation = vec3(0.0);\n    if (specWet > 0.1) {\n        float rippleX = noise(vPosition * 12.0 + vec3(instanceTime * 0.08, 0.0, 0.0)) - 0.5;\n        float rippleZ = noise(vPosition * 12.0 + vec3(0.0, 0.0, instanceTime * 0.06 + 3.7)) - 0.5;\n        ripplePerturbation = vec3(rippleX, 0.0, rippleZ) * specWet * 0.18;\n    }\n\n    // Normal blending: start from face normal, blend toward smooth (55% max),\n    // then add water ripple perturbation in wet zones.\n    // Water film bridges polygon edges  broad continuous sheen across faces.\n    vec3 baseSpecNormal = mix(faceNormal, normalize(vWorldNormal), specWet * 0.35);\n    vec3 specNormal = normalize(baseSpecNormal + ripplePerturbation);\n\n    // Power: dry=48 (broader catch light)  wet=24 (broad sheen, not mirror)\n    float specPower = mix(48.0, 24.0, specWet);\n\n    // Intensity: dry=0.14 (visible sheen on lit faces)  wet=0.22 (clear gloss)\n    float specIntensity = mix(0.14, 0.22, specWet);\n\n    // Color: dry=cool grey  wet=warm neutral (wet stone reflects warm ground bounce)\n    vec3 drySpecColor = vec3(0.15, 0.15, 0.17);\n    vec3 wetSpecColor = vec3(0.72, 0.71, 0.68);\n    vec3 specColor = mix(drySpecColor, wetSpecColor, specWet);\n\n    // Three-light specular (primary + fill + rim)\n    float spec1 = pow(max(0.0, dot(specNormal, halfDir1)), specPower) * specIntensity;\n    float spec2 = pow(max(0.0, dot(specNormal, halfDir2)), specPower) * specIntensity * 0.4;\n    float spec3 = pow(max(0.0, dot(specNormal, halfDir3)), specPower) * specIntensity * 0.25;\n\n    // Dry specular: added to stoneColor (will be soft-clamped with body)\n    // Wet specular: stored separately, added AFTER soft clamp to exceed bloom\n    vec3 drySpecContrib = drySpecColor * (spec1 + spec2 + spec3) * (1.0 - specWet);\n    vec3 wetSpecContrib = specColor * (spec1 + spec2 + spec3) * specWet;\n    stoneColor += drySpecContrib;\n\n    //  Rim/backlight  sky light wrapping around silhouette edges \n    // Separates overlapping rocks visually. Uses face normal so each polygon\n    // has a distinct rim contribution. Cool sky tint like ambient fill light.\n    float rimNdotV = max(0.0, dot(faceNormal, viewDir));\n    float rim = pow(1.0 - rimNdotV, 3.0) * 0.14;\n    vec3 rimColor = vec3(0.22, 0.24, 0.30);\n    stoneColor += rimColor * rim;\n\n    //  Thin-edge translucency  warm internal scatter at sharp edges \n    // Real stone transmits a faint warm glow where geometry thins at silhouettes.\n    // Uses same rimNdotV as rim light but steeper falloff and warm earth color.\n    float sssRim = pow(1.0 - rimNdotV, 5.0) * 0.06;\n    vec3 sssColor = vec3(0.25, 0.22, 0.20);\n    stoneColor += sssColor * sssRim * (0.3 + diffuse * 0.7);\n\n    // \n    // BLOOM  Mica sparkle and wet specular peaks exceed threshold\n    //\n    // Stone body stays well under threshold (matte rock never blooms).\n    // Wet specular and mica added AFTER soft clamp  they can bloom naturally.\n    // \n\n    //  Final color grade  neutral stone \n    // Stone reads as natural grey rock. Very slight cool push to counter\n    // any residual warmth from mineral patches and strata.\n    stoneColor *= vec3(1.0, 1.0, 1.02);\n\n    vec3 color = stoneColor * uIntensity * uGlowScale;\n\n    // Soft clamp: stone body bounded\n    float softCap = uBloomThreshold + 0.30;\n    float maxC = max(color.r, max(color.g, color.b));\n    if (maxC > softCap) {\n        color *= softCap / maxC;\n    }\n\n    // Wet specular added AFTER soft clamp  can exceed bloom threshold naturally\n    // Water film sheen on wet stone should glow, like real wet rocks catching light\n    color += wetSpecContrib * uIntensity * uGlowScale;\n\n    // Mica highlights  bloom-exceeding features\n    color += micaColor * micaLine * uPetrification * 0.15;\n\n    // Crystal micro-glints  sparse mineral sparkles on rock faces\n    // Top ~3% of pixels get tight specular glints. Uses face normal so each polygon\n    // facet has a sharp, distinct sparkle. Added after soft clamp to exceed bloom.\n    float glintNoise = noise(vPosition * 18.0 + vec3(vRandomSeed * 7.0));\n    float glintMask = smoothstep(0.92, 1.0, glintNoise);  // top ~4% of pixels\n    vec3 glintHalf1 = normalize(lightDir1 + viewDir);\n    float glintSpec = pow(max(0.0, dot(faceNormal, glintHalf1)), 200.0);\n    vec3 glintHalf2 = normalize(lightDir2 + viewDir);\n    glintSpec += pow(max(0.0, dot(faceNormal, glintHalf2)), 200.0) * 0.6;\n    color += vec3(0.40, 0.38, 0.32) * glintSpec * glintMask * 2.0;\n\n    // \n    // ALPHA  Opaque stone body\n    //\n    // NormalBlending with alpha=1.0  stone replaces what's behind it.\n    // Instance alpha still applies for spawn/exit fades.\n    // \n\n    float alpha = uOpacity;\n\n    // Apply instance alpha (spawn/exit fade + trail fade)\n    alpha *= vInstanceAlpha;\n\n    // Apply arc visibility (for vortex/relay effects)\n    if (vArcVisibility < 0.999) {\n        alpha *= vArcVisibility;\n        color *= mix(0.3, 1.0, vArcVisibility);\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // Discard invisible pixels\n    if (alpha < 0.05) discard;\n\n    // Shared cutout system from InstancedAnimationCore\n    ${oS}\n\n    // Grain effect\n    ${lS}\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,cM=fS,hM={growth:.5,intensity:1,opacity:.85,glowScale:.1,fadeInDuration:.2,fadeOutDuration:.4},dM="\n// Hash function for noise\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// 3D noise\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\n// Simplex-ish noise (signed, -1 to 1)\nfloat snoise(vec3 p) {\n    return noise(p) * 2.0 - 1.0;\n}\n\n// FBM with 3 octaves (base color  4th octave is 6% of signal, sub-pixel on small geometry)\nfloat fbm3(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p); p *= 2.02;\n    f += 0.1250 * noise(p);\n    return f / 0.8750;\n}\n\n// FBM with 4 octaves (branchingVeins  needs full detail for gradient computation)\nfloat fbm4(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p); p *= 2.02;\n    f += 0.1250 * noise(p); p *= 2.03;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// 2D hash for Voronoi\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\n// Voronoi 2D edge-distance for vine/vein patterns\nfloat voronoi2D(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    float d1 = 10.0;\n    float d2 = 10.0;\n\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 nb = vec2(float(i), float(j));\n            vec2 pt = hash2(n + nb) * 0.8 + 0.1 + nb;\n            float d = length(f - pt);\n\n            if (d < d1) {\n                d2 = d1;\n                d1 = d;\n            } else if (d < d2) {\n                d2 = d;\n            }\n        }\n    }\n\n    return d2 - d1;\n}\n",uM=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uGrowth;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;\nuniform float uArcWidth;\nuniform float uArcSpeed;\nuniform int uArcCount;\nuniform float uArcPhase;\nuniform float uGestureProgress;\nuniform int uRelayCount;\nuniform float uRelayArcWidth;\nuniform float uRelayFloor;\n\n// Per-instance attributes\n${nS}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewDir;\nvarying vec3 vViewPosition;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying vec2 vUv;\n\n${dM}\n\nvoid main() {\n    // =====================================================================================\n    // INSTANCING: Calculate local time and fade\n    // =====================================================================================\n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade in/out controlled by aInstanceOpacity from AnimationState\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // =====================================================================================\n    // MODEL SELECTION: Scale non-selected models to zero\n    // =====================================================================================\n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // =====================================================================================\n    // TRAIL OFFSET: Position trails behind main along velocity\n    // =====================================================================================\n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // =====================================================================================\n    // NATURE: Organic flowing displacement\n    //\n    // Gentle flowing deformation based on sin/cos with time.\n    // NOT quantized like ice -- smooth, organic, like breathing plant tissue.\n    // Edge factor (1 - NdotV) makes displacement stronger at silhouette edges\n    // so the outline undulates like leaves swaying in a breeze.\n    // Growth modulates: dormant = rigid, full growth = swaying.\n    // =====================================================================================\n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n    vUv = uv;\n\n    // Calculate vertical gradient for root-to-canopy effects\n    float modelHeight = 1.0;\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / modelHeight, 0.0, 1.0);\n\n    vec3 displaced = selectedPosition;\n\n    if (modelMatch > 0.5 && length(selectedNormal) > 0.1) {\n        // Edge factor: displacement stronger at silhouette edges\n        vec4 approxWorldPos = modelMatrix * instanceMatrix * vec4(selectedPosition, 1.0);\n        vec3 approxViewDir = normalize(cameraPosition - approxWorldPos.xyz);\n        vec3 worldNrm = normalize(mat3(modelMatrix) * mat3(instanceMatrix) * selectedNormal);\n        float edgeNdotV = abs(dot(worldNrm, approxViewDir));\n        float edgeFactor = 1.0 - edgeNdotV; // Linear -- softer than quadratic for organic motion\n\n        // Organic flowing displacement -- sin/cos waves with per-instance phase\n        float instancePhase = aRandomSeed * 6.28;\n        float displX = sin(selectedPosition.x * 3.0 + uGlobalTime * 0.8 + instancePhase)\n                      * cos(selectedPosition.z * 2.5 + uGlobalTime * 0.6 + instancePhase * 0.7);\n        float displY = sin(selectedPosition.y * 2.0 + uGlobalTime * 0.5 + instancePhase * 1.3)\n                      * 0.5; // Vertical sway is gentler\n        float displZ = cos(selectedPosition.z * 2.8 + uGlobalTime * 0.7 + instancePhase * 0.5)\n                      * sin(selectedPosition.x * 2.2 + uGlobalTime * 0.9);\n\n        // Growth modulates displacement: dormant = rigid, full growth = swaying\n        float growthSway = 0.3 + uGrowth * 0.7;\n\n        vec3 organicDispl = vec3(displX, displY, displZ) * 0.03 * edgeFactor * growthSway;\n        displaced += normalize(selectedNormal) * length(organicDispl);\n    }\n\n    // Apply trail offset\n    displaced += trailOffset;\n\n    // Transform normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n    // Ensure we use the 0.0 w-component to isolate rotation from scale/translation\n    vec3 transformedNormal = (instanceMatrix * vec4(selectedNormal, 0.0)).xyz;\n    vWorldNormal = normalize(mat3(modelMatrix) * transformedNormal);\n\n    // =====================================================================================\n    // Apply instance matrix for per-instance transforms\n    // =====================================================================================\n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // =====================================================================================\n    // ARC VISIBILITY (for vortex ring effects)\n    // =====================================================================================\n    vArcVisibility = 1.0;\n    if (aRandomSeed >= 100.0) {\n        // Generalized relay: supports arbitrary relay count via uRelayCount\n        float encoded = aRandomSeed - 100.0;\n        float ringId = floor(encoded / 10.0);\n        float instanceArcPhase = encoded - ringId * 10.0;\n\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float hw = uRelayArcWidth * 0.5;\n        float angleDiff = vertexAngle - instanceArcPhase;\n        angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n        float arcMask = 1.0 - smoothstep(hw * 0.7, hw, abs(angleDiff));\n\n        float cp = uGestureProgress * float(uRelayCount) * 1.5;\n        float d = cp - ringId;\n        float relayAlpha = smoothstep(-0.30, 0.05, d) * (1.0 - smoothstep(0.70, 1.05, d));\n        vArcVisibility = arcMask * mix(uRelayFloor, 1.0, relayAlpha);\n    } else if (uAnimationType == 1) {\n        // Standard uniform-based arc masking (natureroot, naturevortex, constrict corset, etc.)\n        float vertexAngle = atan(selectedPosition.y, selectedPosition.x);\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + uArcPhase + aRandomSeed;\n        float halfWidth = uArcWidth * 3.14159;\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n            float angleDiff = vertexAngle - thisArcAngle;\n            angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    // View-space position\n    vec4 mvPosition = modelViewMatrix * instancePosition;\n    vViewPosition = mvPosition.xyz;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n`,pM=`\nuniform float uGlobalTime;\nuniform float uGrowth;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform vec3 uTint;\nuniform float uGlowIntensity;\nuniform float uBloomThreshold;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${rS}\n\n// Instancing varyings\n${aS}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewDir;\nvarying vec3 vViewPosition;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying vec2 vUv;\n\n${dM}\n\n// Branching vein pattern using FBM-derivative approach.\n// Forward differences (3 fbm3) instead of central differences (4 fbm4).\n// fbm3 sufficient  4th octave at 6% weight contributes negligibly to gradient.\nfloat branchingVeins(vec2 p, float scale) {\n    vec3 sp = vec3(p * scale, 0.0);\n\n    // Forward differences: base + 2 offsets (was 4 central diff calls)\n    float eps = 0.05;\n    float base = fbm3(sp);\n    float dx = fbm3(sp + vec3(eps, 0.0, 0.0)) - base;\n    float dy = fbm3(sp + vec3(0.0, eps, 0.0)) - base;\n\n    // Gradient magnitude\n    float gradMag = length(vec2(dx, dy)) / eps;\n\n    // Directional derivative along diagonal for asymmetric branching\n    float dirDeriv = abs(dx * 0.7 + dy * 0.7) / eps;\n\n    // Combine: high gradient + directional alignment = vein\n    float vein = smoothstep(0.3, 0.8, gradMag) * smoothstep(0.2, 0.6, dirDeriv);\n\n    return vein;\n}\n\n// Subsurface scattering approximation for organic translucency.\n// Light passes through thin leaf-like geometry, creating a warm glow\n// when the light source is behind the surface relative to the viewer.\n// pow(dot(-V, L), 4) peaks when V and L are anti-parallel (backlit).\nvec3 subsurfaceScatter(vec3 viewDir, vec3 lightDir, float thickness, vec3 leafColor) {\n    float scatter = pow(max(0.0, dot(-viewDir, lightDir)), 4.0) * thickness;\n    return leafColor * scatter;\n}\n\n// Bioluminescent spots -- sparse bright points like fungal glow or fireflies.\n// Returns 0.0 for most of the surface, 1.0 for the rare ~2% bright spots.\nfloat bioluminescence(vec3 p) {\n    return step(0.98, noise(p * 30.0));\n}\n\n${sS}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    float localTime = vLocalTime;\n\n    // =====================================================================================\n    // NORMALS -- smooth normals hide low-poly faces for organic forms\n    //\n    // smoothNdotV from interpolated vWorldNormal: hides polygon facets.\n    // faceNormal from dFdx/dFdy: kept for specular glint variation.\n    // =====================================================================================\n    vec3 faceNormal = normalize(cross(dFdx(vWorldPosition), dFdy(vWorldPosition)));\n    vec3 viewDir = normalize(vViewDir);\n\n    // World normal with faceforward for DoubleSide geometry\n    vec3 worldNormal = normalize(vWorldNormal);\n\n    // Fallback for corrupted/zeroed normal buffer\n    if (length(vWorldNormal) < 0.01) {\n        worldNormal = viewDir;\n    }\n\n    // Flip normal for back faces so dot(N, viewDir) > 0\n    worldNormal = faceforward(worldNormal, -viewDir, worldNormal);\n\n    // Smooth NdotV hides polygon facets for organic appearance\n    float smoothNdotV = max(0.0, dot(worldNormal, viewDir));\n    float fresnel = pow(1.0 - smoothNdotV, 4.0);\n\n    // =====================================================================================\n    // 1. GROWTH-DRIVEN BASE COLOR\n    //\n    // Mix between bark brown (dormant) and lush green (full growth).\n    // FBM noise adds organic color variation across the surface.\n    // Vertical gradient: roots are darker, canopy is lighter.\n    // =====================================================================================\n\n    vec3 barkBrown = vec3(0.15, 0.08, 0.03);   // Dark woody bark\n    vec3 lushGreen = vec3(0.20, 0.50, 0.15);   // Rich leaf green\n\n    // Growth-driven base blend\n    vec3 baseColor = mix(barkBrown, lushGreen, uGrowth);\n\n    // Organic noise variation -- 2 octaves sufficient for 15% color variation\n    float organicNoise = noise(vPosition * 3.0 + vec3(vRandomSeed * 5.0)) * 0.5\n                       + noise(vPosition * 6.03 + vec3(vRandomSeed * 5.0)) * 0.25;\n    baseColor *= 0.85 + organicNoise * 0.30; // +/-15% variation\n\n    // Per-instance color shift -- each nature element is unique\n    float instanceWarm = fract(vRandomSeed * 4.37) * 2.0 - 1.0;\n    baseColor *= vec3(\n        1.0 + instanceWarm * 0.06,\n        1.0 + instanceWarm * 0.08,\n        1.0 - instanceWarm * 0.04\n    );\n\n    // Vertical gradient: roots darker, canopy brighter\n    float vertGrad = mix(0.7, 1.15, vVerticalGradient);\n    baseColor *= vertGrad;\n\n    // =====================================================================================\n    // 2. SUBSURFACE TRANSLUCENCY\n    //\n    // Light passes through thin organic tissue. Three directional lights\n    // contribute warm green SSS when behind the surface relative to viewer.\n    // Thickness derived from smooth NdotV (like ice approach but for leaf tissue).\n    // =====================================================================================\n\n    // Three directional lights (matching other materials)\n    vec3 lightDir1 = normalize(vec3(0.5, 1.0, 0.3));\n    vec3 lightDir2 = normalize(vec3(-0.4, 0.6, -0.5));\n    vec3 lightDir3 = normalize(vec3(0.0, -0.3, 0.8));\n\n    // Thickness: thin at edges (silhouette), thick at center\n    float thickness = pow(smoothNdotV, 2.0) * 0.5;\n\n    // Warm transmitted leaf color -- greenish light filtering through tissue\n    vec3 leafTransmitColor = vec3(0.15, 0.35, 0.10);\n\n    // SSS from each light (primary strongest, others are fill)\n    vec3 sss = vec3(0.0);\n    sss += subsurfaceScatter(viewDir, lightDir1, thickness, leafTransmitColor);\n    sss += subsurfaceScatter(viewDir, lightDir2, thickness, leafTransmitColor) * 0.6;\n    sss += subsurfaceScatter(viewDir, lightDir3, thickness, leafTransmitColor) * 0.3;\n\n    // Growth modulates SSS -- dormant bark has less translucency than leaves\n    sss *= 0.3 + uGrowth * 0.7;\n\n    // =====================================================================================\n    // 3. SURFACE VEINS (branching pattern)\n    //\n    // FBM-derivative branching veins on vPosition.xz (GLBs may lack UVs).\n    // NOT Voronoi -- uses gradient-based branching for organic vein structures.\n    // Dark green veins visible especially at high growth levels.\n    // =====================================================================================\n\n    // Skip branchingVeins at low growth  saves 32 noise calls (8 fbm4)\n    // At growth < 0.1, vein contribution is negligible on dark bark\n    if (uGrowth > 0.1) {\n        float veinPattern = branchingVeins(\n            vPosition.xz + vec2(vRandomSeed * 3.0),\n            4.0\n        );\n\n        vec3 veinColor = vec3(0.05, 0.15, 0.02);\n        float veinStrength = veinPattern * (0.2 + uGrowth * 0.6);\n        baseColor = mix(baseColor, veinColor, veinStrength * 0.4);\n    }\n\n    // =====================================================================================\n    // 4. HEMISPHERE AMBIENT\n    //\n    // Sky = leaf canopy green, ground = soil brown.\n    // Mixed by worldNormal.y to simulate environment lighting.\n    // =====================================================================================\n\n    vec3 envUp = vec3(0.15, 0.22, 0.12);    // Leaf canopy green overhead\n    vec3 envDown = vec3(0.06, 0.04, 0.02);  // Soil brown ground bounce\n    float skyAmt = worldNormal.y * 0.5 + 0.5;\n    vec3 ambient = mix(envDown, envUp, skyAmt);\n\n    // =====================================================================================\n    // 5. DIFFUSE LIGHTING\n    //\n    // Standard NdotL from 3 lights with 0.4 ambient floor.\n    // Nature-appropriate warm light colors.\n    // =====================================================================================\n\n    float NdotL1 = max(0.0, dot(worldNormal, lightDir1));\n    float NdotL2 = max(0.0, dot(worldNormal, lightDir2));\n    float NdotL3 = max(0.0, dot(worldNormal, lightDir3));\n\n    // Warm sunlight primary, cooler fill lights\n    vec3 lightColor1 = vec3(1.0, 0.95, 0.85);  // Warm sunlight\n    vec3 lightColor2 = vec3(0.7, 0.75, 0.85);  // Cool sky fill\n    vec3 lightColor3 = vec3(0.5, 0.6, 0.5);    // Green bounce\n\n    vec3 diffuse = lightColor1 * NdotL1 * 0.65\n                 + lightColor2 * NdotL2 * 0.22\n                 + lightColor3 * NdotL3 * 0.13;\n\n    // Ambient floor prevents pure black shadows\n    float diffuseFloor = 0.4;\n    float diffuseMag = max(diffuseFloor, NdotL1 * 0.65 + NdotL2 * 0.22 + NdotL3 * 0.13);\n\n    // Compose: base color lit by diffuse + ambient\n    vec3 color = baseColor * (ambient + diffuse);\n\n    // Add subsurface scattering on top\n    color += sss;\n\n    // =====================================================================================\n    // EDGE AMBIENT OCCLUSION\n    // Silhouette edges get subtle darkening for depth.\n    // =====================================================================================\n\n    float edgeAO = smoothstep(0.0, 0.4, smoothNdotV);\n    color *= mix(0.82, 1.0, edgeAO);\n\n    // =====================================================================================\n    // 6. FRESNEL (Backlit Leaf Edge)\n    //\n    // Subtle bright rim suggesting backlit leaf edges.\n    // Spring green color, modulated by growth.\n    // F0 = 0.04 -- not reflective like ice.\n    // Rim glow strengthens when main light is behind the surface.\n    // =====================================================================================\n\n    float F0 = 0.04;\n    float schlick = F0 + (1.0 - F0) * fresnel;\n\n    // Backlit leaf edge: bright spring green rim\n    vec3 rimColor = vec3(0.30, 0.60, 0.15);\n    vec3 fresnelContrib = rimColor * fresnel * 0.15 * (0.4 + uGrowth * 0.6);\n\n    // Rim glow is stronger when lit from behind (backlit leaf effect)\n    float backLight = max(0.0, dot(-viewDir, lightDir1));\n    fresnelContrib *= 0.5 + backLight * 0.5;\n\n    color += fresnelContrib;\n\n    // =====================================================================================\n    // SPECULAR -- subtle waxy leaf sheen, not metallic\n    // Low power (16) for broad organic gloss. Much subtler than ice.\n    // Uses smooth worldNormal for consistent organic highlights.\n    // =====================================================================================\n\n    vec3 reflDir = reflect(-viewDir, worldNormal);\n    float spec1 = pow(max(dot(reflDir, lightDir1), 0.0), 16.0);\n    float spec2 = pow(max(dot(reflDir, lightDir2), 0.0), 16.0) * 0.4;\n    float spec3 = pow(max(dot(reflDir, lightDir3), 0.0), 16.0) * 0.2;\n    float spec = spec1 + spec2 + spec3;\n\n    // Waxy leaf specular -- very subtle green-white highlight\n    vec3 specColor = vec3(0.6, 0.65, 0.55) * spec * 0.12 * (0.3 + uGrowth * 0.7);\n    color += specColor;\n\n    // =====================================================================================\n    // Apply tint and intensity\n    // =====================================================================================\n\n    color *= uTint;\n    color *= uIntensity;\n\n    // =====================================================================================\n    // 8. BLOOM SOFT CLAMP\n    //\n    // Cap body brightness before adding bioluminescent features.\n    // Body stays under bloom threshold; bio spots and fresnel exceed it.\n    // =====================================================================================\n\n    float softCap = uBloomThreshold + 0.35;\n    float maxC = max(color.r, max(color.g, color.b));\n    if (maxC > softCap) {\n        color *= softCap / maxC;\n    }\n\n    // =====================================================================================\n    // 7. BIOLUMINESCENT SPOTS\n    //\n    // Sparse ~2% of surface gets bright cyan-green glow points.\n    // Only appear at growth > 0.5 (dormant wood has no bioluminescence).\n    // Added AFTER soft clamp so they exceed bloom threshold and glow.\n    // =====================================================================================\n\n    // Skip bioluminescence at low growth  saves noise + sin when invisible\n    // bioGrowthMask = smoothstep(0.4, 0.7, uGrowth) is 0.0 below 0.4\n    if (uGrowth > 0.4) {\n        float bioSpot = bioluminescence(vPosition + vec3(vRandomSeed * 12.0));\n        float bioGrowthMask = smoothstep(0.4, 0.7, uGrowth);\n        float bioPulse = 0.7 + 0.3 * sin(\n            uGlobalTime * 1.5 + vRandomSeed * 6.28 + vPosition.x * 3.0\n        );\n        vec3 bioColor = vec3(0.30, 1.00, 0.50) * 1.5;\n        color += bioColor * bioSpot * bioGrowthMask * bioPulse;\n    }\n\n    // =====================================================================================\n    // ALPHA -- Solid organic forms\n    //\n    // NormalBlending with alpha=1.0 for opaque plant matter.\n    // Instance alpha still applies for spawn/exit fades.\n    // =====================================================================================\n\n    float alpha = 1.0;\n\n    // Instance fade (spawn/exit)\n    alpha *= vInstanceAlpha;\n    alpha *= uOpacity;\n\n    // =====================================================================================\n    // ARC VISIBILITY (for relay vine + vortex ring effects)\n    // =====================================================================================\n    // Always apply  vArcVisibility defaults to 1.0 for non-arc instances (no-op).\n    // Relay rings compute it via per-instance path; corset rings via uniform path.\n    if (vArcVisibility < 0.999) {\n        alpha *= vArcVisibility;\n        color *= mix(0.3, 1.0, vArcVisibility);\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // =====================================================================================\n    // CUTOUT EFFECT (shared pattern system from InstancedAnimationCore)\n    // =====================================================================================\n    ${oS}\n\n    // Apply trail dissolve\n    alpha *= trailAlpha;\n\n    // =====================================================================================\n    // GRAIN EFFECT (noise texture overlay)\n    // =====================================================================================\n    ${lS}\n\n    // =====================================================================================\n    // FINAL OUTPUT\n    // =====================================================================================\n    if (alpha < 0.01) discard;\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,mM=fS;function fM(e){return(43758.5453*Math.sin(127.1*e+311.7*e)%1+1)%1}function gM(e){const t=Math.floor(e),n=e-t,a=n*n*(3-2*n);return fM(t)*(1-a)+fM(t+1)*a}function yM(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.5,offBeat:1,curve:"powered"===e.category?"smooth":"sharp"}},"3d":{evaluate(t,n){const a={...e,...n},i=t*a.duration/1e3,r="powered"===a.category;let s=1;a.buildupPhase&&t<a.buildupPhase&&(s=t/a.buildupPhase,a.buildupGlowRamp&&(s=Math.pow(s,.5))),a.rampUp&&(s=Math.pow(t,.7)),t>1-a.jitterDecay&&(s*=1-(t-(1-a.jitterDecay))/a.jitterDecay);let o=0,l=0,c=0;if(a.jitterAmplitude>0){const e=i*a.jitterFrequency;let t=1;a.holdFrames&&fM(Math.floor(3*e))<a.holdProbability&&(t=.1),o=(gM(e)-.5+.5*(gM(2.3*e+50)-.5)+.25*(gM(4.7*e+100)-.5))*a.jitterAmplitude*s*t,l=(gM(e+33)-.5+.5*(gM(2.1*e+83)-.5)+.25*(gM(5.3*e+133)-.5))*a.jitterAmplitude*s*t,c=(gM(e+66)-.5+.5*(gM(1.9*e+116)-.5)+.25*(gM(3.7*e+166)-.5))*a.jitterAmplitude*s*t*.5}a.hover&&a.hoverAmount&&(l+=Math.sin(i*Math.PI*.5)*a.hoverAmount*s),a.riseAmount&&(l+=a.riseAmount*s);let h=0,d=0,u=0;if(!r&&a.jitterAmplitude>0){const e=i*a.jitterFrequency,t=2*a.jitterAmplitude;h=(gM(1.3*e+200)-.5)*t*s,d=(gM(1.7*e+250)-.5)*t*s,u=(gM(2.1*e+300)-.5)*t*s*.5}else a.rotationDrift&&(d=i*a.rotationDrift*s);let p=1;const m=i*a.scaleFrequency;a.scalePulse?(p=1+(.5*Math.sin(m*Math.PI*2)+.5)*a.scaleVibration*s,a.scaleGrowth&&(p+=a.scaleGrowth*s)):p=1+(.5*Math.sin(m*Math.PI*2)+.3*Math.sin(m*Math.PI*3.7))*a.scaleVibration*s;const f=i*a.glowFlickerRate;let g;return r?(g=.3*Math.sin(f*Math.PI*2)+.7,a.sparkBursts&&fM(Math.floor(10*i))<a.sparkProbability&&(g=1)):g=.4*Math.sin(f*Math.PI*2)+.3*Math.sin(f*Math.PI*5.3+1.7)+.5*(fM(Math.floor(2*f))>.7?1:0)+.5,{position:[o,l,c],rotation:[h,d,u],scale:p,glowIntensity:a.glowIntensityMin+(a.glowIntensityMax-a.glowIntensityMin)*g*s,glowBoost:(.8*g+.2)*s*a.intensity+(a.mascotGlow||0)*s,glowColorOverride:a.glowColor,electricOverlay:{enabled:s>.1,strength:s*a.intensity,charge:s*a.intensity,category:a.category,spawnMode:a.spawnMode||null,duration:a.duration,progress:t,time:i,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth}}}}}}ow.register("fire",{basePath:"models/Elements/Fire/",models:["flame-wisp.glb","flame-tongue.glb","ember-cluster.glb","fire-burst.glb","flame-ring.glb"],createMaterial:function(e={}){const{temperature:t=wS.temperature,intensity:n=null,opacity:a=wS.opacity,flameHeight:i=wS.flameHeight,turbulence:r=wS.turbulence,displacementStrength:s=wS.displacementStrength,noiseScale:o=wS.noiseScale,flickerSpeed:l=null,flickerAmount:c=null,edgeFade:h=wS.edgeFade,edgeSoftness:d=null,emberDensity:u=null,emberBrightness:p=null,velocityStretch:m=wS.velocityStretch,fadeInDuration:f=wS.fadeInDuration,fadeOutDuration:g=wS.fadeOutDuration}=e,y=function(e,t={}){return{intensity:t.intensity??bS(1.5,2.5,4,e),flickerSpeed:t.flickerSpeed??bS(.001,.002,.003,e),flickerAmount:t.flickerAmount??bS(.15,.12,.08,e),emberDensity:t.emberDensity??bS(.1,.3,.5,e),emberBrightness:t.emberBrightness??bS(.5,.8,1.2,e),edgeSoftness:t.edgeSoftness??bS(.6,.5,.3,e)}}(t,{intensity:n,flickerSpeed:l,flickerAmount:c,edgeSoftness:d,emberDensity:u,emberBrightness:p}),v=y.intensity,b=y.flickerSpeed,w=y.flickerAmount,x=y.edgeSoftness,S=y.emberDensity,M=y.emberBrightness,_=new bi({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:f},uFadeOutDuration:{value:g},...hS(),uRelayCount:{value:3},uRelayArcWidth:{value:3.14159},uRelayFloor:{value:0},uTemperature:{value:t},uIntensity:{value:v},uOpacity:{value:a},uFlameHeight:{value:i},uTurbulence:{value:r},uDisplacementStrength:{value:s},uNoiseScale:{value:o},uFlickerSpeed:{value:b},uFlickerAmount:{value:w},uEdgeFade:{value:h},uEdgeSoftness:{value:x},uEmberDensity:{value:S},uEmberBrightness:{value:M},uVelocityStretch:{value:m}},vertexShader:SS,fragmentShader:MS,transparent:!0,blending:2,depthWrite:!1,side:0});return _.userData.temperature=t,_.userData.elementalType="fire",_.userData.isProcedural=!0,_.userData.isInstanced=!0,_},updateMaterial:function(e,t,n=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),gS(e,n)},setShaderAnimation:_S,setGestureGlow:function(e,t){yS(e,t)},setCutout:function(e,t){dS(e,t)},resetCutout:uS,setGrain:pS,resetGrain:mS,resetShaderAnimation:vS,setRelay:function(e,t){e&&(void 0!==t.count&&e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=t.count),void 0!==t.arcWidth&&e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=t.arcWidth),void 0!==t.floor&&e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=t.floor))},resetRelay:function(e){e&&(e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=3),e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=Math.PI),e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=0))},scaleMultiplier:1.5,distortion:{geometry:()=>new ao(1,1),material:tS,transform:{padding:new Gt(.3,.3,.3)},billboard:!0,strength:.005}}),ow.register("water",{basePath:"models/Elements/Water/",models:["droplet-small.glb","droplet-large.glb","splash-ring.glb","bubble-cluster.glb","wave-curl.glb"],createMaterial:function(e={}){const{turbulence:t=CS.turbulence,intensity:n=null,opacity:a=CS.opacity,displacementStrength:i=null,flowSpeed:r=null,noiseScale:s=CS.noiseScale,edgeFade:o=CS.edgeFade,glowScale:l=CS.glowScale,tint:c=16777215,fadeInDuration:h=CS.fadeInDuration,fadeOutDuration:d=CS.fadeOutDuration}=e,u=n??AS(.8,1,1.2,t),p=i??AS(.06,.1,.15,t),m=r??AS(.8,1.5,3,t),f=c instanceof Ia?c:new Ia(c),g=new bi({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:h},uFadeOutDuration:{value:d},...hS(),uRelayCount:{value:3},uRelayArcWidth:{value:3.14159},uRelayFloor:{value:0},uGlowScale:{value:l},uTurbulence:{value:t},uIntensity:{value:u},uOpacity:{value:a},uDisplacementStrength:{value:p},uFlowSpeed:{value:m},uNoiseScale:{value:s},uEdgeFade:{value:o},uBloomThreshold:{value:.5},uTint:{value:f},uDepthGradient:{value:.3},uInternalFlowSpeed:{value:1},uSparkleIntensity:{value:.4},uBackgroundTexture:{value:null},uResolution:{value:new Vt(1,1)},uHasBackground:{value:0}},vertexShader:PS,fragmentShader:DS,transparent:!0,depthWrite:!1,side:2,blending:2});return g.userData.turbulence=t,g.userData.elementalType="water",g.userData.isProcedural=!0,g.userData.isInstanced=!0,g.userData.needsRefraction=!0,g},updateMaterial:function(e,t,n=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),gS(e,n)},setShaderAnimation:OS,setGestureGlow:function(e,t){yS(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){dS(e,t)},resetCutout:uS,setGrain:pS,resetGrain:mS,resetShaderAnimation:vS,setRelay:function(e,t){e&&(void 0!==t.count&&e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=t.count),void 0!==t.arcWidth&&e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=t.arcWidth),void 0!==t.floor&&e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=t.floor))},resetRelay:function(e){e&&(e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=3),e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=Math.PI),e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=0))},scaleMultiplier:1.2,distortion:{geometry:()=>new ao(1,1),material:function(){return new bi({name:"WaterDistortion",uniforms:{uTime:{value:0},uStrength:{value:.003}},vertexShader:eS,fragmentShader:"\n            uniform float uTime;\n            uniform float uStrength;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 center = uv - 0.5;\n                float dist = length(center);\n                vec2 dir = normalize(center + 0.001);\n\n                // Concentric expanding rings (UV-space center - rings scale with effect)\n                float t = uTime * 1.0;\n                float ring1 = sin(dist * 20.0 - t * 4.0) * 0.5 + 0.5;\n                float ring2 = sin(dist * 14.0 - t * 2.8 + 1.0) * 0.5 + 0.5;\n                float rings = ring1 * 0.6 + ring2 * 0.4;\n\n                // Radial push (outward from center)\n                vec2 offset = dir * rings * uStrength;\n\n                // Falloff: strong near center, zero at edge\n                float falloff = smoothstep(0.5, 0.1, dist);\n\n                gl_FragColor = vec4(offset * falloff, 0.0, 1.0);\n            }\n        ",blending:2,depthWrite:!1,depthTest:!1,transparent:!0,side:2})},transform:{padding:new Gt(.3,.3,.3)},billboard:!0,strength:.003}}),ow.register("ice",{basePath:"models/Elements/Ice/",models:["crystal-small.glb","crystal-medium.glb","crystal-cluster.glb","ice-spike.glb","ice-ring.glb","ice-crown.glb"],createMaterial:function(e={}){const{melt:t=FS.melt,intensity:n=FS.intensity,opacity:a=FS.opacity,frostAmount:i=FS.frostAmount,internalCracks:r=FS.internalCracks,subsurfaceScatter:s=FS.subsurfaceScatter,glowScale:o=FS.glowScale,tint:l=16777215,fadeInDuration:c=FS.fadeInDuration,fadeOutDuration:h=FS.fadeOutDuration}=e,d=i*(1-t),u=r*(1-.5*t),p=l instanceof Ia?l:new Ia(l),m=new bi({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:c},uFadeOutDuration:{value:h},...hS(),uRelayCount:{value:3},uRelayArcWidth:{value:3.14159},uRelayFloor:{value:0},...kS({wetness:.7*t+.3,wetSpeed:FS.wetSpeed}),uGlowScale:{value:o},uMelt:{value:t},uIntensity:{value:n},uOpacity:{value:a},uFrostAmount:{value:d},uInternalCracks:{value:u},uSubsurfaceScatter:{value:s},uTint:{value:p},uGlowIntensity:{value:1},uBloomThreshold:{value:.5},uBackgroundTexture:{value:null},uResolution:{value:new Vt(1,1)},uHasBackground:{value:0},uIOR:{value:1.31}},vertexShader:LS,fragmentShader:NS,transparent:!0,depthWrite:!0,side:2});return m.userData.melt=t,m.userData.elementalType="ice",m.userData.isProcedural=!0,m.userData.isInstanced=!0,m.userData.needsRefraction=!0,m},updateMaterial:function(e,t,n=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),gS(e,n)},setShaderAnimation:VS,setGestureGlow:function(e,t){yS(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){dS(e,t)},resetCutout:uS,setGrain:pS,resetGrain:mS,setWetness:function(e,t){RS(e,t)},resetWetness:zS,resetShaderAnimation:vS,setRelay:function(e,t){e&&(void 0!==t.count&&e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=t.count),void 0!==t.arcWidth&&e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=t.arcWidth),void 0!==t.floor&&e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=t.floor))},resetRelay:function(e){e&&(e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=3),e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=Math.PI),e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=0))},scaleMultiplier:1.2,distortion:{geometry:()=>new ao(1,1),material:function(){return new bi({name:"IceDistortion",uniforms:{uTime:{value:0},uStrength:{value:.003}},vertexShader:eS,fragmentShader:`\n            uniform float uTime;\n            uniform float uStrength;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            ${Jx}\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 wp = vWorldPos.xy;\n\n                float t = uTime * 0.3; // Slow - cold mist is languid\n\n                // Gentle pulse: strength oscillates slowly (0.8-1.0)\n                float pulse = 0.8 + 0.2 * sin(uTime * 0.5);\n\n                // Two-layer rolling fog - world-space so pattern is stable\n                float mist1 = dNoise2D(wp * 3.0 + vec2(t * 0.4, -t * 0.2));\n                float mist2 = dNoise2D(wp * 5.0 + vec2(-t * 0.3, -t * 0.15));\n\n                // Equal horizontal drift and downward pull\n                float dx = (mist1 - 0.5) * uStrength;\n                float dy = (mist2 - 0.5) * uStrength - uStrength * 0.5; // Constant downward bias\n\n                // Cold air pools at bottom - strongest low, fading upward\n                float heightWeight = smoothstep(0.6, 0.1, uv.y);\n\n                // Edge falloff (UV-space - plane edges)\n                float falloff = smoothstep(0.0, 0.2, uv.x) * smoothstep(1.0, 0.8, uv.x)\n                              * smoothstep(0.0, 0.1, uv.y) * smoothstep(1.0, 0.9, uv.y);\n\n                float strength = falloff * heightWeight * pulse;\n\n                gl_FragColor = vec4(dx * strength, dy * strength, 0.0, 1.0);\n            }\n        `,blending:2,depthWrite:!1,depthTest:!1,transparent:!0,side:2})},transform:{padding:new Gt(.3,.5,.3),centerOffset:new Gt(0,-.15,0)},billboard:!0,strength:.003}}),ow.register("electricity",{basePath:"models/Elements/Electricity/",models:["arc-small.glb","arc-medium.glb","arc-cluster.glb","spark-node.glb","lightning-ring.glb","plasma-ring.glb","arc-ring-small.glb","spark-spike.glb"],createMaterial:function(e={}){const{charge:t=US.charge,intensity:n=null,opacity:a=US.opacity,flickerSpeed:i=null,flickerAmount:r=null,sparkDensity:s=null,fadeInDuration:o=US.fadeInDuration,fadeOutDuration:l=US.fadeOutDuration}=e,c=function(e,t={}){return{intensity:t.intensity??GS(1,4,e),flickerSpeed:t.flickerSpeed??GS(4,16,e),flickerAmount:t.flickerAmount??GS(.1,.4,e),sparkDensity:t.sparkDensity??GS(.2,.8,e)}}(t,{intensity:n,flickerSpeed:i,flickerAmount:r,sparkDensity:s}),h=new bi({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:o},uFadeOutDuration:{value:l},...hS(),uCharge:{value:t},uIntensity:{value:c.intensity},uOpacity:{value:a},uFlickerSpeed:{value:c.flickerSpeed},uFlickerAmount:{value:c.flickerAmount},uSparkDensity:{value:c.sparkDensity},uBloomThreshold:{value:.85},uFlashIntensity:{value:0},uRelayCount:{value:3},uRelayArcWidth:{value:3.14159},uRelayFloor:{value:0}},vertexShader:WS,fragmentShader:qS,transparent:!0,blending:2,depthWrite:!1,side:0});return h.userData.charge=t,h.userData.elementalType="electric",h.userData.isProcedural=!0,h.userData.isInstanced=!0,h},updateMaterial:function(e,t,n=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),gS(e,n);const a=e?.userData?.flashConfig;if(a&&e.uniforms?.uFlashIntensity){let t=0;const{events:i}=a,r=a.decay||.03;for(let e=0;e<i.length;e++)if(n>=i[e].at){const a=n-i[e].at,s=i[e].intensity*Math.exp(-a/r);s>t&&(t=s)}e.uniforms.uFlashIntensity.value=t}},setShaderAnimation:HS,setGestureGlow:function(e,t){yS(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){dS(e,t)},resetCutout:uS,setGrain:pS,resetGrain:mS,setFlash:function(e,t){e&&(e.userData.flashConfig=t,e.uniforms?.uFlashIntensity&&(e.uniforms.uFlashIntensity.value=0))},resetFlash:function(e){e&&(e.userData.flashConfig=null,e.uniforms?.uFlashIntensity&&(e.uniforms.uFlashIntensity.value=0))},resetShaderAnimation:vS,setRelay:function(e,t){e&&(void 0!==t.count&&e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=t.count),void 0!==t.arcWidth&&e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=t.arcWidth),void 0!==t.floor&&e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=t.floor))},resetRelay:function(e){e&&(e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=3),e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=Math.PI),e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=0))},scaleMultiplier:1.3,distortion:{geometry:()=>new ao(1,1),material:tS,transform:{padding:new Gt(.3,.3,.3)},billboard:!0,strength:.003}}),ow.register("void",{basePath:"models/Elements/Void/",models:["void-shard.glb","void-crack.glb","corruption-patch.glb","shadow-tendril.glb","void-ring.glb","void-orb.glb","void-tendril-large.glb","void-wrap.glb","void-disk.glb","void-crown.glb"],createMaterial:function(e={}){const{depth:t=jS.depth,intensity:n=null,opacity:a=jS.opacity,tendrilSpeed:i=null,edgeGlow:r=null,fadeInDuration:s=jS.fadeInDuration,fadeOutDuration:o=jS.fadeOutDuration}=e,l=function(e,t={}){return{intensity:t.intensity??XS(1,2.5,e),tendrilSpeed:t.tendrilSpeed??XS(.2,.5,e),edgeGlow:t.edgeGlow??XS(.5,1,e)}}(t,{intensity:n,tendrilSpeed:i,edgeGlow:r}),c=new bi({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:s},uFadeOutDuration:{value:o},...hS(),uDiskMode:{value:0},uDepth:{value:t},uIntensity:{value:l.intensity},uOpacity:{value:a},uTendrilSpeed:{value:l.tendrilSpeed},uEdgeGlow:{value:l.edgeGlow},uBloomThreshold:{value:.85},uRelayCount:{value:3},uRelayArcWidth:{value:3.14159},uRelayFloor:{value:0},uBackgroundTexture:{value:null},uResolution:{value:new Vt(1,1)},uHasBackground:{value:0}},vertexShader:$S,fragmentShader:QS,transparent:!0,blending:1,depthWrite:!0,side:2});return c.userData.depth=t,c.userData.elementalType="void",c.userData.isProcedural=!0,c.userData.isInstanced=!0,c.userData.needsRefraction=!0,c},updateMaterial:function(e,t,n=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),gS(e,n)},setShaderAnimation:KS,setGestureGlow:function(e,t){yS(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){dS(e,t)},resetCutout:uS,setGrain:pS,resetGrain:mS,resetShaderAnimation:vS,setRelay:function(e,t){e&&(void 0!==t.count&&e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=t.count),void 0!==t.arcWidth&&e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=t.arcWidth),void 0!==t.floor&&e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=t.floor))},resetRelay:function(e){e&&(e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=3),e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=Math.PI),e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=0))},scaleMultiplier:1.3,distortion:{geometry:()=>new ao(1,1),material:function(){return new bi({name:"VoidDistortion",uniforms:{uTime:{value:0},uStrength:{value:.018},uFadeProgress:{value:0}},vertexShader:eS,fragmentShader:`\n            uniform float uTime;\n            uniform float uStrength;\n            uniform float uFadeProgress;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            ${Jx}\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 center = uv - 0.5;\n                float dist = length(center);\n                vec2 dir = normalize(center + 0.001);\n\n                float t = uTime * 0.4; // Slow, ominous - time dilation\n\n                // Kerr metric: gravitational pull + frame dragging\n                // Radial = inward pull (Schwarzschild), Tangential = frame dragging\n                // Enhancement pass on top of per-fragment lensing in InstancedVoidMaterial\n\n                // Schwarzschild radius in UV space\n                float rSchwarz = 0.06;\n                float r = max(dist, rSchwarz * 0.5);\n\n                // RADIAL: smoothstep-based (bounded, no 1/r^2 explosion)\n                // Peak at photon sphere, gentle tail outward\n                float radialStrength = smoothstep(0.45, 0.05, dist) * smoothstep(0.0, 0.04, dist);\n\n                // FRAME DRAGGING: tangential twist (the Kerr signature)\n                // Smoothstep-based so it stays bounded at all radii\n                float angle = atan(center.y, center.x);\n                vec2 tangent = vec2(-sin(angle), cos(angle));\n                // Strong near ergosphere, visible at medium range, fades at edge\n                float frameDrag = smoothstep(0.45, 0.06, dist) * smoothstep(0.0, 0.03, dist);\n                // Boost near the hole - frame dragging peaks closer than radial\n                frameDrag += smoothstep(0.15, 0.04, dist) * 0.5;\n\n                // Slow spacetime pulsation\n                float pulse = 0.9 + 0.1 * sin(t * 1.2);\n\n                // RADIAL: inward pull\n                vec2 offset = -dir * radialStrength * uStrength * pulse;\n\n                // TANGENTIAL: frame dragging twist (spiral character)\n                offset += tangent * frameDrag * uStrength * 2.0 * pulse;\n\n                // Subtle spacetime turbulence\n                float turb = dNoise2D(vWorldPos.xy * 6.0 + vec2(t * 0.5)) - 0.5;\n                offset += vec2(turb, -turb) * uStrength * 0.1;\n\n                // Edge falloff (UV-space - plane edges)\n                float falloff = smoothstep(0.0, 0.10, uv.x) * smoothstep(1.0, 0.90, uv.x)\n                              * smoothstep(0.0, 0.10, uv.y) * smoothstep(1.0, 0.90, uv.y);\n\n                // Radial fade - distortion concentrated toward center\n                float radialFade = smoothstep(0.5, 0.15, dist);\n                falloff *= radialFade;\n\n                // Lifecycle easing: smoothstep fade for gentle enter/exit\n                float fade = uFadeProgress * uFadeProgress * (3.0 - 2.0 * uFadeProgress);\n                gl_FragColor = vec4(offset * falloff * fade, 0.0, 1.0);\n            }\n        `,blending:2,depthWrite:!1,depthTest:!1,transparent:!0,side:2})},transform:{padding:new Gt(.8,.8,.8)},billboard:!0,strength:.028}}),ow.register("light",{basePath:"models/Elements/Light/",models:["light-ray.glb","light-orb.glb","sparkle-star.glb","prism-shard.glb","light-ring.glb","sun-ring.glb","light-burst.glb","light-crown.glb"],createMaterial:function(e={}){const{radiance:t=ZS.radiance,intensity:n=null,opacity:a=ZS.opacity,pulseSpeed:i=null,rayIntensity:r=null,sparkleRate:s=null,fadeInDuration:o=ZS.fadeInDuration,fadeOutDuration:l=ZS.fadeOutDuration}=e,c=function(e,t={}){return{intensity:t.intensity??JS(1,2.5,e),pulseSpeed:t.pulseSpeed??JS(.5,2.5,e),rayIntensity:t.rayIntensity??JS(.2,.8,e),sparkleRate:t.sparkleRate??JS(2,8,e)}}(t,{intensity:n,pulseSpeed:i,rayIntensity:r,sparkleRate:s}),h=new bi({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:o},uFadeOutDuration:{value:l},...hS(),uRadiance:{value:t},uIntensity:{value:c.intensity},uOpacity:{value:a},uPulseSpeed:{value:c.pulseSpeed},uRayIntensity:{value:c.rayIntensity},uSparkleRate:{value:c.sparkleRate},uBloomThreshold:{value:.85},uRelayCount:{value:3},uRelayArcWidth:{value:3.14159},uRelayFloor:{value:0}},vertexShader:tM,fragmentShader:nM,transparent:!0,blending:2,depthWrite:!1,side:0});return h.userData.radiance=t,h.userData.elementalType="light",h.userData.isProcedural=!0,h.userData.isInstanced=!0,h},updateMaterial:function(e,t,n=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),gS(e,n)},setShaderAnimation:aM,setGestureGlow:function(e,t){yS(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){dS(e,t)},resetCutout:uS,setGrain:pS,resetGrain:mS,resetShaderAnimation:vS,setRelay:function(e,t){e&&(void 0!==t.count&&e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=t.count),void 0!==t.arcWidth&&e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=t.arcWidth),void 0!==t.floor&&e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=t.floor))},resetRelay:function(e){e&&(e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=3),e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=Math.PI),e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=0))},scaleMultiplier:1.3,distortion:{geometry:()=>new ao(1,1),material:function(){return new bi({name:"LightDistortion",uniforms:{uTime:{value:0},uStrength:{value:.004}},vertexShader:eS,fragmentShader:`\n            uniform float uTime;\n            uniform float uStrength;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            ${Jx}\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 wp = vWorldPos.xy;\n\n                float t = uTime * 1.2;\n\n                // Breathing pulse  slow divine rhythm\n                float pulse = 0.85 + 0.15 * sin(t * 0.7);\n\n                // Radial direction from center  prism pushes outward\n                vec2 center = uv - 0.5;\n                float dist = length(center);\n                vec2 dir = dist > 0.001 ? normalize(center) : vec2(0.0);\n\n                // Radial push  strongest in a ring band (not center, not edge)\n                // Creates the classic "halo" refraction zone\n                float ring = smoothstep(0.05, 0.2, dist) * smoothstep(0.5, 0.3, dist);\n\n                // Subtle noise modulation  prism edge shimmers, not static\n                float shimmer = dNoise2D(vec2(wp.x * 6.0 + t * 0.3, wp.y * 6.0 - t * 0.2));\n                shimmer = shimmer * 0.3 + 0.7; // 0.7 to 1.0 range  mostly stable, slight variation\n\n                float radialStrength = ring * shimmer * pulse * uStrength;\n\n                // R/G: radial UV offset (pushes pixels outward from mascot center)\n                float dx = dir.x * radialStrength;\n                float dy = dir.y * radialStrength;\n\n                // B: chromatic aberration UV spread for DistortionPass\n                // Written as direct UV-space spread (not scaled by uStrength like R/G).\n                // With AdditiveBlending, 1-2 overlapping planes  ~0.008-0.016 UV total\n                // = ~15-30px separation at 1920 for visible rainbow fringing.\n                float chromaticSignal = ring * shimmer * pulse * 0.008;\n\n                // Edge falloff (UV-space)\n                float falloff = smoothstep(0.0, 0.1, uv.x) * smoothstep(1.0, 0.9, uv.x)\n                              * smoothstep(0.0, 0.1, uv.y) * smoothstep(1.0, 0.9, uv.y);\n\n                gl_FragColor = vec4(dx * falloff, dy * falloff, chromaticSignal * falloff, 1.0);\n            }\n        `,blending:2,depthWrite:!1,depthTest:!1,transparent:!0,side:2})},transform:{padding:new Gt(.4,.5,.4)},billboard:!0,strength:.004}}),ow.register("earth",{basePath:"models/Elements/Earth/",models:["rock-chunk-small.glb","rock-chunk-medium.glb","rock-cluster.glb","stone-slab.glb","earth-ring.glb","stone-ring.glb","boulder.glb","stone-spike.glb","earth-crown.glb"],createMaterial:function(e={}){const{petrification:t=iM.petrification,intensity:n=null,opacity:a=iM.opacity,pulseSpeed:i=null,veinIntensity:r=null,fadeInDuration:s=iM.fadeInDuration,fadeOutDuration:o=iM.fadeOutDuration}=e,l=function(e,t={}){return{intensity:t.intensity??rM(.85,1.1,e),pulseSpeed:t.pulseSpeed??rM(.3,.8,e),veinIntensity:t.veinIntensity??rM(.2,.6,e),wetness:t.wetness??rM(.55,.25,e)}}(t,{intensity:n,pulseSpeed:i,veinIntensity:r}),c=new bi({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:s},uFadeOutDuration:{value:o},...hS(),uRelayCount:{value:3},uRelayArcWidth:{value:3.14159},uRelayFloor:{value:0},...kS({wetness:l.wetness,wetSpeed:iM.wetSpeed}),uPetrification:{value:t},uIntensity:{value:l.intensity},uOpacity:{value:a},uPulseSpeed:{value:l.pulseSpeed},uVeinIntensity:{value:l.veinIntensity},uBloomThreshold:{value:.75}},vertexShader:oM,fragmentShader:lM,transparent:!0,blending:1,depthWrite:!0,side:2});return c.userData.petrification=t,c.userData.elementalType="earth",c.userData.isProcedural=!0,c.userData.isInstanced=!0,c},updateMaterial:function(e,t,n=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),gS(e,n)},setShaderAnimation:cM,setGestureGlow:function(e,t){yS(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){dS(e,t)},resetCutout:uS,setGrain:pS,resetGrain:mS,setWetness:function(e,t){RS(e,t)},resetWetness:zS,resetShaderAnimation:vS,setRelay:function(e,t){e&&(void 0!==t.count&&e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=t.count),void 0!==t.arcWidth&&e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=t.arcWidth),void 0!==t.floor&&e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=t.floor))},resetRelay:function(e){e&&(e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=3),e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=Math.PI),e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=0))},scaleMultiplier:1,distortion:{geometry:()=>new ao(1,1),material:tS,transform:{padding:new Gt(.2,.2,.2)},billboard:!0,strength:0}}),ow.register("nature",{basePath:"models/Elements/Nature/",models:["vine-ring.glb","nature-crown.glb","vine-cluster.glb","s-vine.glb","leaf-bunch.glb","vine-twist.glb","u-vine.glb","thorn-curl.glb"],createMaterial:function(e={}){const{growth:t=hM.growth,intensity:n=hM.intensity,opacity:a=hM.opacity,glowScale:i=hM.glowScale,tint:r=16777215,fadeInDuration:s=hM.fadeInDuration,fadeOutDuration:o=hM.fadeOutDuration}=e,l=r instanceof Ia?r:new Ia(r),c=new bi({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:s},uFadeOutDuration:{value:o},...hS(),uGlowScale:{value:i},uGrowth:{value:t},uIntensity:{value:n},uOpacity:{value:a},uTint:{value:l},uGlowIntensity:{value:1},uBloomThreshold:{value:.65},uRelayCount:{value:3},uRelayArcWidth:{value:3.14159},uRelayFloor:{value:0}},vertexShader:uM,fragmentShader:pM,transparent:!0,depthWrite:!0,side:2,blending:1});return c.userData.growth=t,c.userData.elementalType="nature",c.userData.isProcedural=!0,c.userData.isInstanced=!0,c},updateMaterial:function(e,t,n=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),gS(e,n)},setShaderAnimation:mM,setGestureGlow:function(e,t){yS(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){dS(e,t)},resetCutout:uS,setGrain:pS,resetGrain:mS,resetShaderAnimation:vS,setRelay:function(e,t){e&&(void 0!==t.count&&e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=t.count),void 0!==t.arcWidth&&e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=t.arcWidth),void 0!==t.floor&&e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=t.floor))},resetRelay:function(e){e&&(e.uniforms?.uRelayCount&&(e.uniforms.uRelayCount.value=3),e.uniforms?.uRelayArcWidth&&(e.uniforms.uRelayArcWidth.value=Math.PI),e.uniforms?.uRelayFloor&&(e.uniforms.uRelayFloor.value=0))},scaleMultiplier:1.2,distortion:{geometry:()=>new ao(1,1),material:tS,transform:{padding:new Gt(.2,.3,.2)},billboard:!0,strength:.002}});var vM=yM({name:"shock",emoji:"",type:"blending",description:"Brief electric surge - mascot is shocked",duration:1200,beats:2,intensity:1,category:"electrocute",spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.4,clustering:.35,count:6,scale:1,models:["arc-small","spark-node","arc-medium"],minDistance:.12,ephemeral:{lifetime:{min:100,max:300},flashIn:30,fadeOut:80,respawn:!0},animation:{appearAt:.02,disappearAt:.95,stagger:.01,enter:{type:"flash",duration:.01,easing:"linear"},exit:{type:"flash",duration:.02,easing:"linear"},flicker:{intensity:.5,rate:30,pattern:"random"},emissive:{min:1,max:3,frequency:25,pattern:"random",dutyCycle:.6},rotate:{axis:[1,1,0],speed:.5,oscillate:!0,range:Math.PI/3},cutout:{strength:.55,primary:{pattern:1,scale:1.2,weight:.7},secondary:{pattern:7,scale:.8,weight:.3},blend:"multiply",travel:"oscillate",travelSpeed:2.5,strengthCurve:"bell"},grain:{type:3,strength:.25,scale:.3,speed:3,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.7,sizeScale:1.5,progressCurve:"pulse"}],flash:{events:[{at:.15,intensity:2},{at:.5,intensity:3}],decay:.02},scaleVariance:.4,lifetimeVariance:.5,delayVariance:.2,blending:"additive",renderOrder:15,intensityScaling:{scale:1.3,flickerIntensity:1.5,emissiveMax:1.8}}},jitterFrequency:60,jitterAmplitude:.015,jitterDecay:.3,glowColor:[.3,.9,1],glowIntensityMin:.8,glowIntensityMax:2.5,glowFlickerRate:25,scaleVibration:.03,scaleFrequency:40}),bM=yM({name:"overload",emoji:"",type:"blending",description:"Intense charge buildup, extreme shock",duration:2500,beats:4,intensity:2,mascotGlow:.6,category:"electrocute",spawnMode:{type:"surface",pattern:"shell",embedDepth:.1,cameraFacing:.35,clustering:.2,count:12,scale:1.1,models:["arc-small","arc-medium","arc-cluster","spark-node"],minDistance:.1,ephemeral:{lifetime:{min:80,max:150},flashIn:15,fadeOut:40,respawn:!0,stagger:30,progression:{duration:2500,lifetime:[80,150,300,600],flashIn:[15,40],fadeOut:[40,150],respawnDelay:[0,30,0,0]}},animation:{appearAt:.02,disappearAt:.92,stagger:.015,enter:{type:"flash",duration:.01,easing:"linear"},exit:{type:"flash",duration:.03,easing:"linear"},flicker:{intensity:.6,rate:35,pattern:"random"},emissive:{min:1.2,max:4,frequency:30,pattern:"random",dutyCycle:.7},cutout:{strength:.6,primary:{pattern:8,scale:1,weight:.7},secondary:{pattern:5,scale:.6,weight:.3},blend:"multiply",travel:"radial",travelSpeed:1.8,strengthCurve:"fadeIn"},grain:{type:3,strength:.3,scale:.25,speed:2.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.6,sizeScale:1.2,progressCurve:"pulse"}],flash:{events:[{at:.3,intensity:1.5},{at:.55,intensity:2.5},{at:.75,intensity:3.5}],decay:.02},scaleVariance:.35,lifetimeVariance:.4,blending:"additive",renderOrder:15,intensityScaling:{scale:1.4,flickerIntensity:1.6,emissiveMax:2}}},jitterFrequency:80,jitterAmplitude:.03,jitterDecay:.1,glowColor:[.5,.95,1],glowIntensityMin:1,glowIntensityMax:4,glowFlickerRate:35,scaleVibration:.05,scaleFrequency:50,buildupPhase:.3,buildupGlowRamp:!0}),wM=yM({name:"glitch",emoji:"",type:"blending",description:"Digital corruption, static displacement",duration:1800,beats:3,intensity:.7,category:"electrocute",spawnMode:{type:"surface",pattern:"scattered",embedDepth:.15,cameraFacing:.5,clustering:.4,count:2,scale:.7,models:["spark-node"],minDistance:.25,ephemeral:{lifetime:{min:25,max:80},flashIn:8,fadeOut:15,respawn:!0,respawnDelay:{min:80,max:400}},animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"flash",duration:.005,easing:"linear"},exit:{type:"flash",duration:.01,easing:"linear"},flicker:{intensity:.4,rate:20,pattern:"random"},emissive:{min:.8,max:2.5,frequency:15,pattern:"random",dutyCycle:.4},cutout:{strength:.5,primary:{pattern:3,scale:1,weight:.65},secondary:{pattern:1,scale:.7,weight:.35},blend:"multiply",travel:"oscillate",travelSpeed:1.5,strengthCurve:"bell"},grain:{type:3,strength:.2,scale:.35,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.1,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.5,lifetimeVariance:.6,delayVariance:.4,blending:"additive",renderOrder:15,intensityScaling:{scale:1.1,flickerIntensity:1.3,emissiveMax:1.5}}},jitterFrequency:20,jitterAmplitude:.04,jitterDecay:.5,glowColor:[.4,.8,1],glowIntensityMin:.5,glowIntensityMax:2,glowFlickerRate:15,scaleVibration:.04,scaleFrequency:12,holdFrames:!0,holdProbability:.15,holdDuration:.05}),xM=yM({name:"crackle",emoji:"",type:"blending",description:"Rapid stuttering bolts crackling across surface",duration:2e3,beats:3,intensity:.8,category:"powered",spawnMode:{type:"surface",pattern:"spikes",embedDepth:.08,cameraFacing:.5,clustering:.3,count:3,scale:1.2,models:["spark-spike","arc-small","spark-spike"],minDistance:.2,animation:{appearAt:.1,disappearAt:.85,stagger:.08,enter:{type:"pop",duration:.015,easing:"elasticOut",overshoot:1.3},exit:{type:"fade",duration:.15,easing:"easeOutCubic"},flicker:{intensity:.5,rate:20,pattern:"random"},emissive:{min:.8,max:2.5,frequency:8,pattern:"sine"},cutout:{strength:.5,primary:{pattern:8,scale:1.2,weight:.7},secondary:{pattern:2,scale:.8,weight:.3},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"fadeOut"},grain:{type:3,strength:.15,scale:.4,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.1,sizeScale:.6,progressCurve:"sustain"}],flash:{events:[{at:.2,intensity:2},{at:.35,intensity:1.5},{at:.5,intensity:2.5},{at:.65,intensity:1},{at:.75,intensity:1.8}],decay:.015},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:12}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.4,.9,1],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:2,scalePulse:!0,rotationDrift:.01}),SM=yM({name:"chargeUp",emoji:"",type:"blending",description:"Building up electrical power, growing intensity",duration:2500,beats:4,intensity:1.2,mascotGlow:.4,category:"powered",spawnMode:{type:"surface",pattern:"crown",embedDepth:.1,cameraFacing:.4,clustering:.3,count:6,scale:1,models:["spark-node","arc-small","arc-medium"],minDistance:.12,ephemeral:{lifetime:{min:50,max:100},flashIn:12,fadeOut:30,respawn:!0,stagger:50,progression:{duration:2500,lifetime:[50,100,400,700],flashIn:[12,60],fadeOut:[30,200],respawnDelay:[0,20,100,250]}},animation:{appearAt:.05,disappearAt:.92,stagger:.03,enter:{type:"grow",duration:.04,easing:"easeOutQuad"},exit:{type:"flash",duration:.02,easing:"linear"},pulse:{amplitude:.18,frequency:3,easing:"easeInOut",sync:"global"},emissive:{min:.6,max:2.8,frequency:4,pattern:"sine"},drift:{direction:"up",speed:.025,noise:.15},rotate:{axis:"y",speed:.08,oscillate:!1},cutout:{strength:.45,primary:{pattern:2,scale:1.3,weight:.65},secondary:{pattern:6,scale:.7,weight:.35},blend:"multiply",travel:"radial",travelSpeed:1.2,strengthCurve:"fadeIn"},grain:{type:3,strength:.1,scale:.35,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.1,sizeScale:.6,progressCurve:"rampUp"}],scaleVariance:.25,lifetimeVariance:.2,blending:"additive",renderOrder:12,intensityScaling:{scale:1.35,emissiveMax:1.6,driftSpeed:1.3}}},jitterFrequency:30,jitterAmplitude:.005,jitterDecay:.2,glowColor:[.3,.95,1],glowIntensityMin:.8,glowIntensityMax:3,glowFlickerRate:12,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,scaleGrowth:.08,rampUp:!0,riseAmount:.02}),MM=yM({name:"electricAuraEffect",emoji:"",type:"blending",description:"Electric rings rising slowly from center",duration:3e3,beats:4,intensity:1,mascotGlow:.5,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"center",easing:"easeOut",startScale:.9,endScale:1.3,startDiameter:1.6,endDiameter:2.2,orientation:"camera"},formation:{type:"spiral",count:3,strands:1,spacing:.15,arcOffset:120,phaseOffset:.05},count:3,scale:2,models:["plasma-ring","arc-ring-small","plasma-ring"],animation:{appearAt:.05,disappearAt:.85,stagger:.06,enter:{type:"fade",duration:.12,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.15,rate:8,pattern:"sine"},emissive:{min:.9,max:1.8,frequency:2.5,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:1,weight:.6},secondary:{pattern:1,scale:.8,weight:.4},blend:"multiply",travel:"angular",travelSpeed:.6,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.4,speed:1,blend:"multiply"},atmospherics:[{preset:"ozone",intensity:.2,sizeScale:.6,progressCurve:"sustain"}],rotate:{axis:"y",rotations:.5,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:10,modelOverrides:{"plasma-ring":{scaleMultiplier:1.1,shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.5,arcCount:1},orientationOverride:"camera"},"arc-ring-small":{scaleMultiplier:.9,shaderAnimation:{type:1,arcWidth:.6,arcSpeed:.8,arcCount:2},orientationOverride:"camera"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.3,glowColor:[.5,.85,1],glowIntensityMin:1.2,glowIntensityMax:2,glowFlickerRate:4,scaleVibration:.015,scaleFrequency:1.5,scalePulse:!0,rotationDrift:.02,hover:!0,hoverAmount:.01}),_M=yM({name:"staticDischarge",emoji:"",type:"blending",description:"Low-level static electricity, ambient sparks",duration:1500,beats:2,intensity:.4,category:"powered",spawnMode:{type:"surface",pattern:"scattered",embedDepth:.15,cameraFacing:.35,clustering:.3,count:2,scale:.6,models:["spark-node"],minDistance:.3,ephemeral:{lifetime:{min:40,max:100},flashIn:10,fadeOut:30,respawn:!0,stagger:200,respawnDelay:{min:250,max:600}},animation:{appearAt:.05,disappearAt:.92,stagger:.03,enter:{type:"flash",duration:.008,easing:"linear"},exit:{type:"fade",duration:.05,easing:"easeOut"},emissive:{min:.6,max:1.5,frequency:20,pattern:"random",dutyCycle:.3},cutout:{strength:.35,primary:{pattern:3,scale:.8,weight:.6},secondary:{pattern:0,scale:.6,weight:.4},blend:"multiply",travel:"oscillate",travelSpeed:.8,strengthCurve:"bell"},grain:{type:3,strength:.1,scale:.45,speed:1.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.08,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.3,lifetimeVariance:.4,blending:"additive",renderOrder:10,intensityScaling:{scale:1,emissiveMax:1.2}}},jitterFrequency:5,jitterAmplitude:.002,jitterDecay:.4,glowColor:[.5,.8,1],glowIntensityMin:.9,glowIntensityMax:1.3,glowFlickerRate:20,scaleVibration:.005,scaleFrequency:8,scalePulse:!1,sparkBursts:!0,sparkProbability:.1}),AM=yM({name:"electriccrown",emoji:"",type:"blending",description:"Crackling lightning crown above the head",duration:3e3,beats:4,intensity:1,mascotGlow:.3,category:"powered",spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.3}},count:1,scale:1.2,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.02,frequency:2,easing:"easeInOut"},rotate:{axis:"z",rotations:1,phase:0},atmospherics:[{preset:"ozone",targets:["lightning-ring"],anchor:"above",intensity:.04,sizeScale:.6,progressCurve:"sustain"}],scaleVariance:0,lifetimeVariance:0,blending:"additive",renderOrder:15}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.3,.9,1],glowIntensityMin:.8,glowIntensityMax:.8,glowFlickerRate:0,scaleVibration:.003,scaleFrequency:3,scaleGrowth:0,scalePulse:!0,rotationDrift:.01}),CM=yM({name:"electricdance",emoji:"",type:"blending",description:"Vertical lightning rings dancing and rising",duration:1500,beats:3,intensity:1.3,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.8,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:2,spacing:0,arcOffset:180,phaseOffset:0},count:2,scale:2,models:["lightning-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.35,rate:14,pattern:"random"},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.75,primary:{pattern:6,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.6},blend:"add",travel:"spiral",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28}},grain:{type:3,strength:.06,scale:.15,speed:1,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:90}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:11,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.3,.9,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.015,scaleFrequency:4,scaleGrowth:.01,scalePulse:!0,rotationDrift:.01}),TM=yM({name:"electrichelix",emoji:"",type:"blending",description:"Double helix of lightning rings ascending",duration:2e3,beats:3,intensity:1.2,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.9,endScale:1.1,startDiameter:1.8,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:2,strands:2,spacing:.2,arcOffset:180,phaseOffset:.05},count:2,scale:2,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.25,rate:12,pattern:"random"},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.8,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:6,scale:1.8,weight:.6},blend:"max",travel:"angular",travelSpeed:3,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.08,scale:.2,speed:1.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"additive",renderOrder:16,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.35,.9,1],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:5,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,rotationDrift:.015});const PM={enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.08,frequency:4,easing:"easeInOut"},emissive:{min:1,max:2,frequency:5,pattern:"sine"},grain:{type:3,strength:.25,scale:.3,speed:2,blend:"multiply"},rotate:{axis:"z",rotations:1,phase:0},scaleVariance:.1,lifetimeVariance:.08,blending:"additive",renderOrder:12,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.65,arcSpeed:3,arcCount:1},orientationOverride:"flat"},"plasma-ring":{shaderAnimation:{type:1,arcWidth:.55,arcSpeed:4,arcCount:2},orientationOverride:"flat"}}};var DM=yM({name:"electricpillar",emoji:"",type:"blending",description:"Rising pillar of stacked lightning rings",duration:3e3,beats:4,intensity:1.3,mascotGlow:.4,category:"powered",spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"center",easing:"easeOut",startScale:1,endScale:1.3,startDiameter:1.5,endDiameter:1.8,orientation:"flat"},formation:{type:"stack",count:2,spacing:.3},count:2,scale:1.5,models:["lightning-ring"],animation:{...PM,appearAt:0,disappearAt:.85,stagger:.04,atmospherics:[{preset:"ozone",targets:["lightning-ring"],anchor:"above",intensity:.1,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5}],cutout:{strength:.5,primary:{pattern:1,scale:1,weight:.65},secondary:{pattern:2,scale:.8,weight:.35},blend:"add",travel:"angular",travelSpeed:1.5,strengthCurve:"bell"}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"above",easing:"easeOut",startScale:.9,endScale:1.2,startDiameter:1.3,endDiameter:1.6,orientation:"flat"},formation:{type:"stack",count:2,spacing:.3},count:2,scale:1.4,models:["plasma-ring"],animation:{...PM,appearAt:.08,disappearAt:.88,stagger:.04,cutout:{strength:.55,primary:{pattern:8,scale:1.2,weight:.7},secondary:{pattern:1,scale:.7,weight:.3},blend:"multiply",travel:"radial",travelSpeed:1.8,strengthCurve:"bell"}}},{type:"axis-travel",axisTravel:{axis:"y",start:"above",end:"far-above",easing:"easeOut",startScale:.8,endScale:1.1,startDiameter:1.1,endDiameter:1.4,orientation:"flat"},formation:{type:"stack",count:2,spacing:.3},count:2,scale:1.3,models:["lightning-ring"],animation:{...PM,appearAt:.15,disappearAt:.9,stagger:.04,cutout:{strength:.45,primary:{pattern:3,scale:1,weight:.6},secondary:{pattern:7,scale:.8,weight:.4},blend:"add",travel:"oscillate",travelSpeed:1.2,strengthCurve:"fadeOut"}}}],jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.35,.9,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:5,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,rotationDrift:.015}),OM=yM({name:"electricdrill",emoji:"",type:"blending",description:"Fast tight descending lightning helix",duration:1200,beats:2,intensity:1.5,category:"electrocute",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:2,spacing:.1,arcOffset:180,phaseOffset:0},count:2,scale:2,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},flicker:{intensity:.4,rate:25,pattern:"random"},pulse:{amplitude:.08,frequency:10,easing:"linear"},emissive:{min:1.5,max:3.5,frequency:12,pattern:"random"},cutout:{strength:.55,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:.8,weight:.35},blend:"add",travel:"vertical",travelSpeed:3,strengthCurve:"constant"},grain:{type:3,strength:.3,scale:.2,speed:4,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"below",intensity:.3,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:16,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},jitterFrequency:45,jitterAmplitude:.01,jitterDecay:.25,glowColor:[.3,.9,1],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:15,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03}),EM=yM({name:"electricflourish",emoji:"",type:"blending",description:"Spinning lightning flourish with electric trails",duration:1200,beats:4,intensity:1.3,mascotGlow:.3,category:"powered",spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:.05,zOffset:0},count:3,scale:2,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},flicker:{intensity:.3,rate:14,pattern:"random"},pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.6,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:8,scale:.6,weight:.5},blend:"multiply",strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.15,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.4}],drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.85,.7],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:120},{axis:"z",rotations:1.8,phase:240}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:12,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.7,y:.4,z:.05},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.8,models:["plasma-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:8,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:-45}],blending:"additive",renderOrder:14,modelOverrides:{"plasma-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:4,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.7,y:.4,z:.05},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.8,models:["plasma-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:8,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:45}],blending:"additive",renderOrder:14,modelOverrides:{"plasma-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:4,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:2,models:["lightning-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},flicker:{intensity:.25,rate:12,pattern:"random"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.5,primary:{pattern:8,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"additive",renderOrder:10,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:2,models:["lightning-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},flicker:{intensity:.25,rate:12,pattern:"random"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.5,primary:{pattern:8,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"additive",renderOrder:10,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.35,.9,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.015,scaleFrequency:4,scalePulse:!0}),IM=yM({name:"electricvortex",emoji:"",type:"blending",description:"Lightning tornado spiraling around mascot",duration:1500,beats:5,intensity:1.4,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.5,startDiameter:.6,endDiameter:1.6,orientation:"flat"},formation:{type:"spiral",count:2,spacing:0,arcOffset:180,phaseOffset:0},count:2,scale:2,models:["lightning-ring"],animation:{appearAt:.05,disappearAt:.7,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.35,rate:14,pattern:"random"},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2,frequency:5,pattern:"sine"},cutout:{strength:.5,primary:{pattern:1,scale:1.2,weight:.6},secondary:{pattern:3,scale:.8,weight:.4},blend:"add",travel:"angular",travelSpeed:2.5,strengthCurve:"bell",trailDissolve:{enabled:!0,offset:-.4,softness:1.2}},grain:{type:3,strength:.2,scale:.3,speed:2.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.2,sizeScale:1.2,progressCurve:"sustain",velocityInheritance:.6,centrifugal:{speed:1.2,tangentialBias:.3}}],flash:{events:[{at:.2,intensity:2},{at:.45,intensity:3},{at:.6,intensity:1.5}],decay:.02},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:12,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:5,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.4,.85,1],glowIntensityMin:1.2,glowIntensityMax:2.2,glowFlickerRate:6,scaleVibration:.02,scaleFrequency:4,scaleGrowth:.03,scalePulse:!0,rotationDrift:.02}),kM=yM({name:"electricbarrage",emoji:"",type:"blending",description:"Electric arcs orbit mascot then launch outward",duration:1500,beats:4,intensity:1.4,category:"powered",spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.8,models:["arc-cluster","arc-medium","spark-node"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.4,rate:16,pattern:"random"},grain:{type:3,strength:.12,scale:.3,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.25,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.7}],flash:{events:[{at:.1,intensity:1.5},{at:.3,intensity:2.5},{at:.5,intensity:3}],decay:.02},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1.2,max:3,frequency:8,pattern:"sine"},rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"additive",renderOrder:12}},jitterFrequency:10,jitterAmplitude:.005,jitterDecay:.2,glowColor:[.4,.9,1],glowIntensityMin:1.5,glowIntensityMax:3,glowFlickerRate:12,scaleVibration:.015,scaleFrequency:4,scaleGrowth:.02,scalePulse:!0}),RM=yM({name:"electricimpact",emoji:"",type:"blending",description:"Electric arcs orbit then crash inward",duration:1500,beats:4,intensity:1.5,category:"electrocute",spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:3.5,endRadius:.1,speed:3,easing:"easeOut",startScale:.4,endScale:1.8,orientation:"vertical"},formation:{type:"ring",count:7},count:7,scale:1.4,models:["arc-cluster","arc-medium","arc-small","spark-spike"],animation:{appearAt:0,disappearAt:.6,stagger:.02,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.05,easing:"easeOut",burstScale:.2},procedural:{scaleSmoothing:.04,geometryStability:!0},grain:{type:3,strength:.15,scale:.3,speed:2.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:1.5,sizeScale:2.5,progressCurve:"burst",velocityInheritance:.7}],pulse:{amplitude:.12,frequency:8,easing:"easeInOut"},emissive:{min:1,max:3,frequency:9,pattern:"sine"},rotate:[{axis:"z",rotations:-4,phase:0},{axis:"x",rotations:3.5,phase:50},{axis:"y",rotations:-3,phase:100},{axis:"z",rotations:4,phase:155},{axis:"x",rotations:-3.5,phase:210},{axis:"y",rotations:3,phase:260},{axis:"z",rotations:-4.5,phase:315}],scaleVariance:.2,lifetimeVariance:.08,blending:"additive",renderOrder:12}},jitterFrequency:70,jitterAmplitude:.02,jitterDecay:.15,glowColor:[.45,.9,1],glowIntensityMin:1.6,glowIntensityMax:2.8,glowFlickerRate:20,scaleVibration:.03,scaleFrequency:15}),zM=yM({name:"electricblast",emoji:"",type:"blending",description:"Explosive electrical discharge burst",duration:1e3,beats:2,intensity:1.5,category:"electrocute",spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.2,endScale:2.2,scaleEasing:"easeOutQuad"},count:1,scale:2,models:["plasma-ring"],animation:{appearAt:0,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},flicker:{intensity:.3,rate:14,pattern:"random"},cutout:{strength:.5,primary:{pattern:2,scale:1.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"fadeOut"},grain:{type:3,strength:.3,scale:.25,speed:3,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.8,sizeScale:2,progressCurve:"pulse"}],flash:{events:[{at:0,intensity:4},{at:.15,intensity:1.5}],decay:.03},blending:"additive",renderOrder:8,modelOverrides:{"plasma-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.3,endScale:1.5,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["spark-spike"],animation:{appearAt:0,disappearAt:.5,enter:{type:"scale",duration:.03,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},flicker:{intensity:.35,rate:16,pattern:"random"},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:1.2,strengthCurve:"fadeOut"},drift:{speed:1.4,distance:.8,direction:{x:0,y:1,z:0},easing:"easeOutQuad"},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:.9,models:["spark-spike"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.03,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},flicker:{intensity:.35,rate:16,pattern:"random"},cutout:{strength:.5,primary:{pattern:8,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:-.8,y:.7,z:0},easing:"easeOutQuad"},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:.9,models:["spark-spike"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.03,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},flicker:{intensity:.35,rate:16,pattern:"random"},cutout:{strength:.5,primary:{pattern:8,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:.8,y:.7,z:0},easing:"easeOutQuad"},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:3,radius:.05,endRadius:.6,angleSpread:360,startAngle:30,orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:3,scale:.6,models:["arc-ring-small"],animation:{appearAt:.02,disappearAt:.4,stagger:.01,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},flicker:{intensity:.4,rate:18,pattern:"random"},cutout:{strength:.4,primary:{pattern:3,scale:.7,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:14,modelOverrides:{"arc-ring-small":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}}],jitterFrequency:60,jitterAmplitude:.02,jitterDecay:.25,glowColor:[.4,.9,1],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:15,scaleVibration:.04,scaleFrequency:10,scaleGrowth:.02}),FM=yM({name:"electricsurge",emoji:"",type:"blending",description:"Expanding electromagnetic shockwave",duration:2e3,beats:3,intensity:.9,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.4,endScale:2.5,startDiameter:.5,endDiameter:3,orientation:"camera"},formation:{type:"stack",count:1,spacing:0},count:1,scale:1.3,models:["plasma-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.5,primary:{pattern:2,scale:1.5,weight:.6},secondary:{pattern:8,scale:1,weight:.4},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.3,softness:1.5}},grain:{type:3,strength:.15,scale:.35,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.2,sizeScale:1.2,progressCurve:"rampUp"}],pulse:{amplitude:.08,frequency:3,easing:"easeInOut"},emissive:{min:.8,max:2,frequency:4,pattern:"sine"},blending:"additive",renderOrder:8,modelOverrides:{"plasma-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.3,arcCount:1},orientationOverride:"camera"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.3,glowColor:[.4,.85,1],glowIntensityMin:.8,glowIntensityMax:1.5,glowFlickerRate:4,scaleVibration:.01,scaleFrequency:2,scalePulse:!0,rotationDrift:.01}),BM=yM({name:"zap",emoji:"",type:"blending",description:"Explosive multi-layer lightning burst",duration:2e3,beats:4,intensity:1.7,mascotGlow:.5,category:"powered",spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeIn",startScale:.5,endScale:1.6,startDiameter:.8,endDiameter:1,orientation:"camera"},formation:{type:"spiral",count:1,strands:1,spacing:0,arcOffset:0,phaseOffset:0},count:1,scale:1.5,models:["arc-medium"],animation:{appearAt:0,disappearAt:.75,enter:{type:"scale",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},flicker:{intensity:.35,rate:14,pattern:"random"},emissive:{min:1.2,max:3,frequency:8,pattern:"sine"},cutout:{strength:.35,primary:{pattern:7,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.12,scale:.25,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.5,sizeScale:1.2,progressCurve:"pulse"}],flash:{events:[{at:.1,intensity:2.5},{at:.3,intensity:4},{at:.5,intensity:5},{at:.68,intensity:3}],decay:.02},rotate:{axis:"y",rotations:1.5,phase:0},blending:"additive",renderOrder:10,modelOverrides:{"arc-medium":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.1,y:.1,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1.8,models:["spark-spike"],animation:{appearAt:.05,disappearAt:.65,enter:{type:"scale",duration:.05,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.2},flicker:{intensity:.3,rate:14,pattern:"random"},drift:{speed:1.2,distance:1,direction:{x:-1,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:-.25,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.1,y:.1,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1.8,models:["spark-spike"],animation:{appearAt:.05,disappearAt:.65,enter:{type:"scale",duration:.05,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.2},flicker:{intensity:.3,rate:14,pattern:"random"},drift:{speed:1.2,distance:1,direction:{x:1,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:.25,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:2,radius:.05,endRadius:.4,angleSpread:120,startAngle:240,orientation:"camera",startScale:.3,endScale:.8,scaleEasing:"easeOutQuad"},count:2,scale:.6,models:["arc-small"],animation:{appearAt:.15,disappearAt:.55,stagger:.03,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},flicker:{intensity:.4,rate:18,pattern:"random"},scaleVariance:.2,blending:"additive",renderOrder:14,modelOverrides:{"arc-small":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}}],jitterFrequency:8,jitterAmplitude:.005,jitterDecay:.2,glowColor:[.35,.9,1],glowIntensityMin:1.4,glowIntensityMax:3.5,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:4,scaleGrowth:.03,scalePulse:!0,riseAmount:.02}),LM=yM({name:"electricmeditation",emoji:"",type:"blending",description:"Dual lightning weave  electric hexagon meditation",duration:4e3,beats:8,intensity:.7,mascotGlow:.4,category:"emanating",charge:.4,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"ozone",intensity:.15,sizeScale:.5,progressCurve:"sustain"}],modelOverrides:{"lightning-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:1.05,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:4.19,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:2.62,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:1.05,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:4.19,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:2.62,relayIndex:1,orientationOverride:"camera"}}}}],glowColor:[.5,.7,1],glowIntensityMin:.5,glowIntensityMax:.9,glowFlickerRate:2,scaleVibration:0,scaleFrequency:0,scaleContract:0,tremor:0,tremorFrequency:0,shakeAmount:0,shakeFrequency:0,decayRate:.2}),NM=yM({name:"electrictwirl",emoji:"",type:"blending",description:"Relay lightning illusion  arc weaves through three interlocked rings",duration:1500,beats:2,intensity:1.5,category:"afflicted",growth:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"ozone",intensity:.2,sizeScale:.6,progressCurve:"sustain"}],modelOverrides:{"lightning-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.52,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"lightning-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[.3,.9,1],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.006,tremorFrequency:8,shakeAmount:.01,shakeFrequency:12,decayRate:.15});const VM={disappearAt:.9,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:3,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.3,speed:.6,blend:"multiply"},blending:"additive"};var UM=yM({name:"electricshield",emoji:"",type:"blending",description:"Gyroscopic lightning cage  four tumbling rings form a protective storm",duration:3e3,beats:4,intensity:1,mascotGlow:.4,category:"powered",spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.3}},count:1,scale:1.5,models:["lightning-ring"],animation:{...VM,appearAt:0,rotate:{axis:"x",rotations:.75,phase:0},renderOrder:6,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.35}},count:1,scale:1.5,models:["lightning-ring"],animation:{...VM,appearAt:.04,rotate:{axis:"y",rotations:-.75,phase:0},renderOrder:8,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.4}},count:1,scale:1.5,models:["lightning-ring"],animation:{...VM,appearAt:.08,rotate:{axis:"x",rotations:.75,phase:90},renderOrder:10,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.42}},count:1,scale:1.5,models:["lightning-ring"],animation:{...VM,appearAt:.12,rotate:{axis:"y",rotations:-.75,phase:-45},atmospherics:[{preset:"ozone",targets:["lightning-ring"],anchor:"around",intensity:.2,sizeScale:.7,progressCurve:"sustain"}],renderOrder:12,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.55,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[.35,.9,1],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,tremor:.002,tremorFrequency:2,decayRate:.2});function GM(e){return.5*Math.sin(1*e)+.3*Math.sin(2.3*e+1.3)+.2*Math.sin(4.1*e+2.7)}function WM(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"phrase",amplitudeSync:{onBeat:1.3,offBeat:1,curve:"smooth"}},"3d":{evaluate(t,n){const a=e["3d"]?.evaluate,i=a?a(t,n):null,r={...e,...n},s=t*r.duration/1e3,{category:o}=r;let l=1;if("impact"===o)if(r.impactBurst&&t<r.burstDuration)l=t/r.burstDuration,l=Math.pow(l,.3);else if(r.rampUp)l=Math.pow(t,.5);else{const e=r.burstDuration||.2;if(t>e){const n=(t-e)/(1-e);l=1-Math.pow(n,r.wobbleDecay+.5)}}"transform"===o&&(l=r.formLoss?.3+.7*t:Math.min(2*t,1)),"ambient"===o&&(l=.8+.1*Math.sin(t*Math.PI*2)+.2*t),t>.85&&(l*=1-(t-.85)/.15);let c=0,h=0,d=0;if(r.flowFrequency){const e=s*r.flowFrequency*Math.PI*2;c=Math.sin(e)*r.flowAmplitude*l,r.flowPhaseOffset&&(h=Math.sin(e+Math.PI*r.flowPhaseOffset)*r.flowAmplitude*.5*l),r.verticalBob&&(h+=Math.sin(.5*e)*r.verticalBob*l)}if(r.wobbleAmplitude>0){const e=s*r.wobbleFrequency;let n=r.wobbleAmplitude*l;r.wobbleDecay<0&&(n*=1+t*Math.abs(r.wobbleDecay)*2),c+=GM(e)*n,h+=GM(e+33)*n*.7,d+=GM(e+66)*n*.5}r.sinkAmount&&(h-=r.sinkAmount*l),r.settleDown&&(h-=r.settleDown*t*l),r.meltDown&&(h-=.02*t*l);const u=i?.rotation||[0,0,0];let p=u[0]||0,m=u[1]||0,f=u[2]||0;if(r.rotationFlow&&(m+=s*r.rotationFlow*l),r.rotationSway){const e=s*(r.flowFrequency||1)*Math.PI*2;f+=Math.sin(e)*r.rotationSway*l}if(r.wobbleAmplitude>0&&"ambient"!==o){const e=s*r.wobbleFrequency,t=.3*r.wobbleAmplitude*l;p+=GM(.7*e+100)*t,f+=GM(.9*e+150)*t}let g=1,y=1,v=1,b=1;if(r.scaleWobble){const e=s*r.scaleFrequency*Math.PI*2,t=.5*Math.sin(e)+.5;g=r.concentricPulse&&r.pulseCount?1+(.5*Math.sin(e*r.pulseCount)+.5)*r.scaleWobble*l:1+t*r.scaleWobble*l}r.scaleGrowth&&(g+=r.scaleGrowth*t*l),r.scaleCompression&&(g+=r.scaleCompression*l),r.scaleSquash?(v=g-r.scaleSquash*t*l,y=g+(r.scaleStretch||.5*r.scaleSquash)*t*l,b=y):r.stretchVertical?(v=g+r.stretchVertical*t*l,y=g-.3*r.stretchVertical*t*l,b=y):y=v=b=g;const w=s*(r.glowPulseRate||2)*Math.PI*2;let x=.5*Math.sin(w)+.5;return r.impactBurst&&t<r.burstDuration&&(x=1),r.saturationBuild&&(x=Math.max(x,t)),{position:[c,h,d],rotation:[p,m,f],scale:(y+v+b)/3,scaleXYZ:[y,v,b],glowIntensity:r.glowIntensityMin+(r.glowIntensityMax-r.glowIntensityMin)*x*l,glowBoost:.6*x*l*r.intensity+(r.mascotGlow||0)*l,glowColorOverride:r.glowColor,waterOverlay:{enabled:l>.1,strength:l*r.intensity,wetness:l*r.intensity,turbulence:r.turbulence,category:r.category,spawnMode:r.spawnMode||null,duration:r.duration,progress:t,time:s,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth}}}}}}var qM=WM({name:"splash",emoji:"",type:"blending",description:"Explosive water splash with curling waves and spray",duration:1e3,beats:2,intensity:1.3,category:"impact",turbulence:.8,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.2,endScale:2,scaleEasing:"easeOutQuad"},count:1,scale:1.5,models:["splash-ring"],animation:{appearAt:0,disappearAt:.4,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.6,primary:{pattern:2,scale:1.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},grain:{type:3,strength:.5,scale:.3,speed:1.5,blend:"multiply"},blending:"additive",renderOrder:8,rotate:{axis:"z",rotations:0,phase:0},modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:1,sizeScale:1.2,burstCount:25,progressCurve:"burst"}]}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1.2,models:["droplet-large"],animation:{appearAt:0,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:4,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.4,distance:.8,direction:{x:0,y:1,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["droplet-large"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.45,primary:{pattern:0,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:-.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["droplet-large"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.45,primary:{pattern:0,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.85,models:["droplet-large"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:4,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:-.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:11,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.85,models:["droplet-large"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:4,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:11,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:8,radius:.05,endRadius:.65,angleSpread:360,startAngle:22,orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:8,scale:.6,models:["droplet-small"],animation:{appearAt:.02,disappearAt:.4,stagger:.008,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.35,primary:{pattern:0,scale:.7,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:14,modelOverrides:{"droplet-small":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:12,radius:.03,endRadius:.5,angleSpread:360,startAngle:0,orientation:"camera",startScale:.1,endScale:.35,scaleEasing:"easeOutQuad"},count:12,scale:.2,models:["droplet-small"],animation:{appearAt:.01,disappearAt:.3,stagger:.005,enter:{type:"scale",duration:.02,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.25,primary:{pattern:7,scale:.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.5,lifetimeVariance:.25,blending:"additive",renderOrder:16,modelOverrides:{"droplet-small":{shaderAnimation:{type:1,arcWidth:.98,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.1,z:.12},orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:1,scale:.7,models:["bubble-cluster"],animation:{appearAt:.05,disappearAt:.6,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.5,primary:{pattern:0,scale:1.2,weight:1},blend:"multiply",travel:"radial",travelSpeed:.5,strengthCurve:"constant"},pulse:{amplitude:.1,frequency:8,easing:"easeInOut"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:6,modelOverrides:{"bubble-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:2},orientationOverride:"camera"}}}}],wobbleFrequency:6,wobbleAmplitude:.018,wobbleDecay:.4,scaleWobble:.035,scaleFrequency:7,scaleGrowth:.015,glowColor:[.35,.65,1],glowIntensityMin:1.2,glowIntensityMax:2.2,glowPulseRate:6}),HM=WM({name:"drench",emoji:"",type:"blending",description:"Expanding water shockwave",duration:1e3,beats:2,intensity:1,category:"impact",turbulence:.4,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.2,endScale:2.5,startDiameter:.3,endDiameter:2.5,orientation:"camera"},formation:{type:"stack",count:1,spacing:0},count:1,scale:1.2,models:["splash-ring"],animation:{appearAt:0,disappearAt:.8,stagger:0,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{turbulence:{start:.5,peak:.3,end:.1,curve:"bell"}},cutout:{strength:.5,primary:{pattern:0,scale:1.3,weight:1},secondary:{pattern:3,scale:.6,weight:.7},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-1.5,softness:2.5}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},pulse:{amplitude:.05,frequency:2,easing:"easeOut"},blending:"additive",renderOrder:10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.4,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:.8,sizeScale:1,burstCount:20,progressCurve:"burst",velocityInheritance:.4}]}},wobbleFrequency:2,wobbleAmplitude:.01,wobbleDecay:.6,scaleWobble:.01,scaleFrequency:2,scaleGrowth:0,glowColor:[.2,.5,.9],glowIntensityMin:.8,glowIntensityMax:1.3,glowPulseRate:2}),jM=WM({name:"soak",emoji:"",type:"blending",description:"Contracting water shockwave (reverse drench)",duration:1e3,beats:2,intensity:1,category:"impact",turbulence:.4,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:1.8,endScale:.3,startDiameter:2,endDiameter:.4,orientation:"camera"},formation:{type:"stack",count:1,spacing:0},count:1,scale:1.2,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,stagger:0,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"scale",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{turbulence:{start:.1,peak:.35,end:.5,curve:"bell"}},cutout:{strength:.5,primary:{pattern:0,scale:1.3,weight:1},secondary:{pattern:3,scale:.6,weight:.7},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.3,softness:1.4}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},pulse:{amplitude:.05,frequency:2,easing:"easeIn"},blending:"additive",renderOrder:10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.4,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:null,anchor:"around",intensity:.5,sizeScale:.8,burstCount:12,progressCurve:"burst",velocityInheritance:.3}]}},wobbleFrequency:2,wobbleAmplitude:.01,wobbleDecay:.6,scaleWobble:.01,scaleFrequency:2,scaleGrowth:0,glowColor:[.2,.5,.9],glowIntensityMin:.8,glowIntensityMax:1.3,glowPulseRate:2}),XM=WM({name:"flow",emoji:"",type:"blending",description:"Gentle river current drifting across",duration:3e3,beats:4,intensity:.7,mascotGlow:.2,category:"ambient",turbulence:.2,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:.25,endOffset:.25,easing:"linear",startScale:.7,endScale:1.1,startDiameter:1,endDiameter:1.3,orientation:"camera"},formation:{type:"ring",count:3,phaseOffset:.2},count:3,scale:1,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,stagger:.18,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},drift:{speed:.45,distance:2.2,direction:{x:1,y:.05,z:0},easing:"easeInOut"},cutout:{strength:.5,primary:{pattern:4,scale:1.3,weight:1},secondary:{pattern:1,scale:.6,weight:.35},blend:"multiply",travel:"angular",travelSpeed:1.2,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:1.5,blend:"multiply"},rotate:[{axis:"z",rotations:.25,phase:0},{axis:"z",rotations:-.2,phase:120},{axis:"z",rotations:.3,phase:240}],pulse:{amplitude:.07,frequency:2,easing:"easeInOut"},blending:"additive",renderOrder:8,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.75,arcSpeed:.8,arcCount:2},orientationOverride:"camera"}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:-.2,endOffset:-.2,easing:"linear",startScale:.6,endScale:1,startDiameter:.9,endDiameter:1.2,orientation:"camera"},formation:{type:"ring",count:2,phaseOffset:.25},count:2,scale:.9,models:["wave-curl"],animation:{appearAt:.1,disappearAt:.9,stagger:.2,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},drift:{speed:.4,distance:2,direction:{x:1,y:-.03,z:0},easing:"easeInOut"},cutout:{strength:.45,primary:{pattern:4,scale:1.4,weight:1},secondary:{pattern:1,scale:.7,weight:.3},blend:"multiply",travel:"angular",travelSpeed:1,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:1.5,blend:"multiply"},rotate:[{axis:"z",rotations:-.3,phase:45},{axis:"z",rotations:.25,phase:225}],pulse:{amplitude:.06,frequency:2.5,easing:"easeInOut"},blending:"additive",renderOrder:6,modelOverrides:{"wave-curl":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.2,arcCount:1},orientationOverride:"camera"}}}}],wobbleFrequency:1.5,wobbleAmplitude:.008,wobbleDecay:.3,scaleWobble:.01,scaleFrequency:2,scaleGrowth:.008,glowColor:[.3,.55,.9],glowIntensityMin:.8,glowIntensityMax:1.4,glowPulseRate:2}),YM=WM({name:"tide",emoji:"",type:"blending",description:"Single wave with animated tidal cutout",duration:2500,beats:2,intensity:.8,mascotGlow:.2,category:"ambient",turbulence:.3,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:0,endOffset:0,easing:"linear",startScale:1,endScale:1,startDiameter:1,endDiameter:1,orientation:"camera"},formation:{type:"ring",count:1,phaseOffset:0},count:1,scale:4.4,models:["wave-curl"],animation:{appearAt:0,disappearAt:.9,stagger:0,enter:{type:"grow",duration:.3,easing:"easeOut"},exit:{type:"fade",duration:.35,easing:"easeIn"},procedural:{scaleSmoothing:.15,geometryStability:!0},cutout:{strength:.55,primary:{pattern:4,scale:1.2,weight:1},secondary:{pattern:0,scale:.6,weight:.25},blend:"multiply",travel:"angular",travelSpeed:-1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:1,blend:"multiply"},rotate:{axis:"z",rotations:-.25,phase:0},pulse:{amplitude:.15,frequency:.6,easing:"easeInOut"},blending:"additive",renderOrder:6,modelOverrides:{"wave-curl":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.8,arcCount:2},orientationOverride:"camera"}}}},wobbleFrequency:.8,wobbleAmplitude:.005,wobbleDecay:.4,scaleWobble:.008,scaleFrequency:.8,glowColor:[.15,.45,.85],glowIntensityMin:.85,glowIntensityMax:1.4,glowPulseRate:.8}),$M=WM({name:"liquefy",emoji:"",type:"blending",description:"Dramatic tears falling with dissolve trails",duration:2200,beats:3,intensity:.9,category:"transform",turbulence:.4,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"top",end:"bottom",startOffset:.15,endOffset:-.3,easing:"easeInQuad",startScale:.5,endScale:1.3,startDiameter:.7,endDiameter:1.1,orientation:"camera"},formation:{type:"ring",count:4,phaseOffset:.15},count:4,scale:1.1,models:["droplet-large"],animation:{appearAt:0,disappearAt:.9,stagger:.12,enter:{type:"grow",duration:.12,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.55,primary:{pattern:7,scale:1.3,weight:1},secondary:{pattern:0,scale:.5,weight:.25},blend:"multiply",travel:"vertical",travelSpeed:1.8,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.5,softness:1.8}},grain:{type:3,strength:.25,scale:.2,speed:2,blend:"multiply"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:8,modelOverrides:{"droplet-large":{shaderAnimation:{type:3,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"top",end:"bottom",startOffset:.05,endOffset:-.15,easing:"easeInCubic",startScale:.4,endScale:.9,startDiameter:.6,endDiameter:.9,orientation:"camera"},formation:{type:"ring",count:6,phaseOffset:.1},count:6,scale:.6,models:["droplet-small"],animation:{appearAt:.08,disappearAt:.85,stagger:.08,enter:{type:"grow",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},cutout:{strength:.5,primary:{pattern:7,scale:1,weight:1},secondary:{pattern:0,scale:.4,weight:.2},blend:"multiply",travel:"vertical",travelSpeed:2.5,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.4,softness:1.2}},grain:{type:3,strength:.2,scale:.15,speed:2.5,blend:"multiply"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.25,lifetimeVariance:.2,blending:"additive",renderOrder:10,modelOverrides:{"droplet-small":{shaderAnimation:{type:3,arcWidth:.98,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}}],wobbleFrequency:2,wobbleAmplitude:.006,wobbleDecay:.2,scaleWobble:.02,scaleFrequency:3,glowColor:[.25,.5,.9],glowIntensityMin:.9,glowIntensityMax:1.6,glowPulseRate:3}),QM=WM({name:"pool",emoji:"",type:"blending",description:"Submerging sensation with contracting water rings",duration:2800,beats:4,intensity:.7,mascotGlow:.3,category:"transform",turbulence:.2,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:.35,endOffset:.35,easing:"easeInOutQuad",startScale:1.4,endScale:.5,startDiameter:3.2,endDiameter:.6,orientation:"flat"},formation:{type:"ring",count:1},count:1,scale:1,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.12,geometryStability:!0},cutout:{strength:.5,primary:{pattern:4,scale:1.6,weight:1},secondary:{pattern:0,scale:.6,weight:.35},blend:"multiply",travel:"radial",travelSpeed:-.8,strengthCurve:"fadeIn"},grain:{type:3,strength:.25,scale:.3,speed:.8,blend:"multiply"},rotate:{axis:"y",rotations:.15,phase:0},pulse:{amplitude:.05,frequency:1.5,easing:"easeInOut"},blending:"additive",renderOrder:5,modelOverrides:{"splash-ring":{shaderAnimation:{type:5,arcWidth:.85,arcSpeed:.4,arcCount:2}}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:0,endOffset:0,easing:"easeInOutQuad",startScale:1.5,endScale:.4,startDiameter:3.5,endDiameter:.5,orientation:"flat"},formation:{type:"ring",count:1},count:1,scale:1.1,models:["splash-ring"],animation:{appearAt:.05,disappearAt:.9,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.12,geometryStability:!0},cutout:{strength:.55,primary:{pattern:4,scale:1.5,weight:1},secondary:{pattern:0,scale:.7,weight:.4},blend:"multiply",travel:"radial",travelSpeed:-1,strengthCurve:"fadeIn"},grain:{type:3,strength:.25,scale:.3,speed:1,blend:"multiply"},rotate:{axis:"y",rotations:-.12,phase:45},pulse:{amplitude:.06,frequency:1.5,easing:"easeInOut"},blending:"additive",renderOrder:6,modelOverrides:{"splash-ring":{shaderAnimation:{type:5,arcWidth:.9,arcSpeed:.5,arcCount:2}}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:-.35,endOffset:-.35,easing:"easeInOutQuad",startScale:1.3,endScale:.5,startDiameter:3,endDiameter:.7,orientation:"flat"},formation:{type:"ring",count:1},count:1,scale:.95,models:["splash-ring"],animation:{appearAt:.1,disappearAt:.85,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.12,geometryStability:!0},cutout:{strength:.5,primary:{pattern:4,scale:1.4,weight:1},secondary:{pattern:0,scale:.6,weight:.35},blend:"multiply",travel:"radial",travelSpeed:-.9,strengthCurve:"fadeIn"},grain:{type:3,strength:.25,scale:.3,speed:.8,blend:"multiply"},rotate:{axis:"y",rotations:.18,phase:90},pulse:{amplitude:.05,frequency:1.5,easing:"easeInOut"},blending:"additive",renderOrder:4,modelOverrides:{"splash-ring":{shaderAnimation:{type:5,arcWidth:.85,arcSpeed:.4,arcCount:2}}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"center",startOffset:-.2,endOffset:.3,easing:"easeOutQuad",startScale:.3,endScale:.8,startDiameter:.8,endDiameter:1.2,orientation:"camera"},formation:{type:"ring",count:4,phaseOffset:.15},count:4,scale:.5,models:["bubble-cluster"],animation:{appearAt:.15,disappearAt:.8,stagger:.1,enter:{type:"fade",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},cutout:{strength:.4,primary:{pattern:0,scale:1,weight:1},blend:"multiply",travel:"angular",travelSpeed:.8,strengthCurve:"constant"},grain:{type:3,strength:.15,scale:.25,speed:1.5,blend:"multiply"},pulse:{amplitude:.1,frequency:3,easing:"easeInOut"},blending:"additive",renderOrder:8,modelOverrides:{"bubble-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.6,arcCount:2},orientationOverride:"camera"}}}}],wobbleFrequency:1.5,wobbleAmplitude:.01,wobbleDecay:.35,scaleWobble:.012,scaleFrequency:1.5,glowColor:[.2,.45,.8],glowIntensityMin:.7,glowIntensityMax:1.3,glowPulseRate:1.5}),KM=WM({name:"watervortex",emoji:"",type:"blending",description:"Water tornado spiraling around mascot",duration:1500,beats:5,intensity:1.4,category:"transform",turbulence:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.7,startDiameter:.6,endDiameter:2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["splash-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.1},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.85,end:.5,curve:"bell"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:12,intensityScaling:{scale:1.4,pulseAmplitude:1.3},modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:6,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}},atmospherics:[{preset:"spray",targets:null,anchor:"around",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.6,centrifugal:{speed:1.2,tangentialBias:.3}}]}},wobbleFrequency:4,wobbleAmplitude:.015,wobbleDecay:.2,glowColor:[.2,.55,1],glowIntensityMin:1.2,glowIntensityMax:2.2,glowPulseRate:6,scaleWobble:.02,scaleFrequency:4,scaleGrowth:.03}),ZM=WM({name:"watercrown",emoji:"",type:"blending",description:"Majestic water crown above the head",duration:3e3,beats:4,intensity:1,mascotGlow:.3,category:"ambient",turbulence:.2,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.1,z:0},orientation:"flat",bob:{amplitude:.025,frequency:.3}},count:1,scale:2,models:["splash-ring"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{turbulence:{start:.1,peak:.25,end:.15,curve:"bell"}},pulse:{amplitude:.06,frequency:2,easing:"easeInOut"},rotate:{axis:"z",rotations:1,phase:0},scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:15,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.8,arcCount:3}}}}},wobbleFrequency:1.5,wobbleAmplitude:.005,wobbleDecay:.3,scaleWobble:.008,scaleFrequency:2,scaleGrowth:.01,glowColor:[.3,.6,1],glowIntensityMin:.9,glowIntensityMax:1.4,glowPulseRate:3}),JM=WM({name:"waterdance",emoji:"",type:"blending",description:"Vertical splash rings dancing and rising",duration:2e3,beats:3,intensity:1.3,category:"ambient",turbulence:.4,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.8,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["splash-ring"],animation:{appearAt:.02,disappearAt:.75,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.7,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.5},blend:"multiply",travel:"angular",travelSpeed:.3,strengthCurve:"fadeIn",fadeInDuration:.167,trailDissolve:{enabled:!0,offset:-.8,softness:2}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},parameterAnimation:{turbulence:{start:.2,peak:.45,end:.25,curve:"bell"}},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:11,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}]}},wobbleFrequency:3,wobbleAmplitude:.01,wobbleDecay:.2,scaleWobble:.018,scaleFrequency:4,scaleGrowth:.025,glowColor:[.25,.55,.95],glowIntensityMin:1.2,glowIntensityMax:2.5,glowPulseRate:6,rotationFlow:.02}),e_=WM({name:"waterdrill",emoji:"",type:"blending",description:"Fast tight descending water helix",duration:1200,beats:2,intensity:1.5,category:"transform",turbulence:.6,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:.8,models:["splash-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{turbulence:{start:.3,peak:.7,end:.5,curve:"bell"}},cutout:{strength:.55,primary:{pattern:6,scale:1.5,weight:1},secondary:{pattern:1,scale:.8,weight:.35},blend:"add",travel:"vertical",travelSpeed:3,strengthCurve:"constant"},grain:{type:3,strength:.3,scale:.2,speed:4,blend:"multiply"},pulse:{amplitude:.08,frequency:10,easing:"linear"},rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}]}},wobbleFrequency:8,wobbleAmplitude:.01,wobbleDecay:.15,scaleWobble:.02,scaleFrequency:8,scaleGrowth:.03,glowColor:[.2,.5,1],glowIntensityMin:1.3,glowIntensityMax:2.8,glowPulseRate:10,rotationFlow:.05}),t_=WM({name:"waterhelix",emoji:"",type:"blending",description:"DNA-style double helix ascending water",duration:2e3,beats:4,intensity:1.2,category:"ambient",turbulence:.35,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.9,endScale:1.1,startDiameter:1.8,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:.7,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,stagger:.06,enter:{type:"fade",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{turbulence:{start:.2,peak:.4,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:6,scale:1.3,weight:1},secondary:{pattern:0,scale:.7,weight:.3},blend:"multiply",travel:"vertical",travelSpeed:1.2,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.4,softness:1}},grain:{type:3,strength:.2,scale:.25,speed:1.5,blend:"multiply"},pulse:{amplitude:.08,frequency:3,easing:"easeInOut"},rotate:{axis:"y",rotations:2.5,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}]}},wobbleFrequency:2,wobbleAmplitude:.008,wobbleDecay:.2,scaleWobble:.015,scaleFrequency:3,scaleGrowth:.02,glowColor:[.3,.55,.9],glowIntensityMin:1.1,glowIntensityMax:2.2,glowPulseRate:4,rotationFlow:.015}),n_=WM({name:"watermeditation",emoji:"",type:"blending",description:"Dual water weave  splash hexagon meditation",duration:4e3,beats:8,intensity:.7,mascotGlow:.4,category:"emanating",turbulence:.1,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"spray",intensity:.15,sizeScale:.5,progressCurve:"sustain"}],modelOverrides:{"splash-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:1.05,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:4.19,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:2.62,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:1.05,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:4.19,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.5,sizeVariance:0,models:["splash-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:2.62,relayIndex:1,orientationOverride:"camera"}}}}],glowColor:[.4,.7,1],glowIntensityMin:.5,glowIntensityMax:.9,glowPulseRate:2,scaleVibration:0,scaleFrequency:0,scaleContract:0,tremor:0,tremorFrequency:0,shakeAmount:0,shakeFrequency:0,decayRate:.2});const a_={appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{turbulence:{start:.15,peak:.3,end:.2,curve:"bell"}},pulse:{amplitude:.05,frequency:3,easing:"easeInOut"},emissive:{min:.8,max:1.6,frequency:4,pattern:"sine"},atmospherics:[{preset:"spray",targets:["splash-ring"],anchor:"above",intensity:.4,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5}],scaleVariance:.03,lifetimeVariance:.02,blending:"normal",renderOrder:15,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.8,arcCount:3}}}};var i_=WM({name:"waterpillar",emoji:"",type:"blending",description:"Majestic rising pillar of water",duration:3e3,beats:4,intensity:1.3,mascotGlow:.4,category:"ambient",turbulence:.25,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:0},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["splash-ring"],animation:{...a_,stagger:.03,cutout:{strength:.6,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.4},blend:"add",travel:"angular",travelSpeed:1.2,strengthCurve:"fadeIn",fadeInDuration:.3,geometricMask:{type:"distance",core:.1,tip:.25}},rotate:[{axis:"z",rotations:.3,phase:0},{axis:"z",rotations:.3,phase:180}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:.5},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["splash-ring"],animation:{...a_,stagger:.05,cutout:{strength:.65,primary:{pattern:7,scale:1.8,weight:1},secondary:{pattern:5,scale:1.5,weight:.5},blend:"multiply",travel:"radial",travelSpeed:1.8,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"tip-boost",core:0,tip:.2}},rotate:[{axis:"z",rotations:-.6,phase:60},{axis:"z",rotations:-.6,phase:240}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:1},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["splash-ring"],animation:{...a_,stagger:.07,cutout:{strength:.7,primary:{pattern:5,scale:1.5,weight:1},secondary:{pattern:6,scale:2,weight:.4},blend:"add",travel:"oscillate",travelSpeed:2.5,strengthCurve:"fadeOut",fadeOutDuration:.4,geometricMask:{type:"distance",core:.15,tip:.3}},rotate:[{axis:"z",rotations:.9,phase:90},{axis:"z",rotations:.9,phase:270}]}}],glowColor:[.25,.55,.9],glowIntensityMin:1,glowIntensityMax:2,glowPulseRate:3,scaleVibration:.008,scaleFrequency:3}),r_=WM({name:"waterflourish",emoji:"",type:"blending",description:"Spinning water flourish with wave trails",duration:1200,beats:4,intensity:1.3,mascotGlow:.3,category:"ambient",turbulence:.5,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:5,spacing:0,arcOffset:72,phaseOffset:.05,zOffset:0},count:5,scale:.9,models:["splash-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{turbulence:{start:.35,peak:.7,end:.2,curve:"bell"}},cutout:{strength:.6,primary:{pattern:0,scale:1,weight:1},secondary:{pattern:3,scale:.6,weight:.5},blend:"multiply",strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.6,softness:1.5}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.9,.8,.7,.6],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"z",rotations:1.8,phase:144},{axis:"z",rotations:-2.3,phase:216},{axis:"z",rotations:2,phase:288}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:-8,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:["splash-ring"],anchor:"above",intensity:.25,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4}]}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:.7,models:["splash-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:0,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:-45}],blending:"additive",renderOrder:-6,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:.7,models:["splash-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:0,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:45}],blending:"additive",renderOrder:-6,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:.9,models:["splash-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"normal",renderOrder:-10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:.9,models:["splash-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"normal",renderOrder:-10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],wobbleFrequency:2,wobbleAmplitude:.01,wobbleDecay:.15,glowColor:[.3,.6,1],glowIntensityMin:1,glowIntensityMax:2,glowPulseRate:6,scaleWobble:.012,scaleFrequency:8,scaleGrowth:.015}),s_=WM({name:"waterbarrage",emoji:"",type:"blending",description:"Water orbits mascot then launches upward",duration:1500,beats:4,intensity:1.4,category:"transform",turbulence:.6,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.4,models:["droplet-small","droplet-large","bubble-cluster","wave-curl"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.7,end:.3,curve:"fadeOut"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"normal",renderOrder:12,atmospherics:[{preset:"spray",targets:null,anchor:"around",intensity:.5,sizeScale:.8,burstCount:12,progressCurve:"burst",velocityInheritance:.7}]}},wobbleFrequency:10,wobbleAmplitude:.012,glowColor:[.2,.5,1],glowIntensityMin:1.2,glowIntensityMax:2,glowPulseRate:8,scaleWobble:.015,scaleFrequency:4,scaleGrowth:.02}),o_=WM({name:"waterimpact",emoji:"",type:"blending",description:"Water orbits then crashes inward with impact",duration:1500,beats:4,intensity:1.5,category:"transform",turbulence:.8,spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:3.5,endRadius:.1,speed:3,easing:"easeOut",startScale:.4,endScale:1.8,orientation:"vertical"},formation:{type:"ring",count:7},count:7,scale:1.4,models:["bubble-cluster","wave-curl"],animation:{appearAt:0,disappearAt:.6,stagger:.02,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.05,easing:"easeOut",burstScale:.2},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{turbulence:{start:.3,peak:.9,end:.85,curve:"fadeIn"}},pulse:{amplitude:.12,frequency:8,easing:"easeInOut"},emissive:{min:1,max:3,frequency:9,pattern:"sine"},rotate:[{axis:"z",rotations:-4,phase:0},{axis:"x",rotations:3.5,phase:50},{axis:"y",rotations:-3,phase:100},{axis:"z",rotations:4,phase:155},{axis:"x",rotations:-3.5,phase:210},{axis:"y",rotations:3,phase:260},{axis:"z",rotations:-4.5,phase:315}],scaleVariance:.2,lifetimeVariance:.08,blending:"normal",renderOrder:12,atmospherics:[{preset:"spray",targets:null,anchor:"around",intensity:.8,sizeScale:1,burstCount:15,progressCurve:"burst",velocityInheritance:.7}]}},wobbleFrequency:12,wobbleAmplitude:.018,glowColor:[.15,.45,1],glowIntensityMin:1.6,glowIntensityMax:2.8,glowPulseRate:12,scaleWobble:.025,scaleFrequency:6,scaleContract:.05,tremor:.018,tremorFrequency:9}),l_=WM({name:"watercrush",emoji:"",type:"blending",description:"Walls of water crushing inward on mascot",duration:1200,beats:2,intensity:1.4,category:"impact",turbulence:.7,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"center",easing:"linear",startScale:2.2,endScale:.3,startDiameter:2.5,endDiameter:.5,orientation:"camera"},formation:{type:"stack",count:3,spacing:.35},count:3,scale:1.4,models:["splash-ring"],animation:{appearAt:0,disappearAt:.75,stagger:.06,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.1,easing:"easeIn",burstScale:.3},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{turbulence:{start:.3,peak:.8,end:.9,curve:"fadeIn"}},cutout:{strength:.5,primary:{pattern:0,scale:1.3,weight:1},secondary:{pattern:3,scale:.6,weight:.6},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.3,softness:1.4}},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},pulse:{amplitude:.08,frequency:4,easing:"easeInOut"},blending:"additive",renderOrder:10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.4,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:1,sizeScale:1.2,burstCount:30,progressCurve:"burst",velocityInheritance:.4}]}},{type:"radial-burst",radialBurst:{count:6,radius:.05,endRadius:.5,angleSpread:360,startAngle:0,orientation:"camera",startScale:.15,endScale:.7,scaleEasing:"easeOutQuad"},count:6,scale:.5,models:["bubble-cluster"],animation:{appearAt:.35,disappearAt:.75,stagger:.01,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:0,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:12,modelOverrides:{"bubble-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}}],wobbleFrequency:4,wobbleAmplitude:.025,wobbleDecay:.3,scaleWobble:.03,scaleFrequency:3,scaleContract:.06,glowColor:[.1,.35,.9],glowIntensityMin:1,glowIntensityMax:2,glowPulseRate:4,tremor:.015,tremorFrequency:8}),c_=WM({name:"watertwirl",emoji:"",type:"blending",description:"Relay water illusion  arc weaves through three interlocked rings",duration:1500,beats:2,intensity:1.5,category:"afflicted",growth:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.3,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"additive",renderOrder:10,atmospherics:[{preset:"spray",intensity:.2,sizeScale:.6,progressCurve:"sustain"}],modelOverrides:{"splash-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.3,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"additive",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.3,sizeVariance:0,models:["splash-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"additive",renderOrder:10,modelOverrides:{"splash-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[.3,.6,1],glowIntensityMin:.7,glowIntensityMax:1.2,glowPulseRate:6,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.006,tremorFrequency:8,shakeAmount:.01,shakeFrequency:12,decayRate:.15});const h_={disappearAt:.9,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:3,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.3,speed:.4,blend:"multiply"},blending:"normal"};var d_=WM({name:"watershield",emoji:"",type:"blending",description:"Gyroscopic water cage  six tumbling rings form a protective torrent",duration:3e3,beats:4,intensity:1,mascotGlow:.4,category:"ambient",turbulence:.25,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.3}},count:1,scale:1,diameterUnit:"mascot",diameter:1.3,models:["splash-ring"],animation:{...h_,appearAt:0,rotate:{axis:"x",rotations:3,phase:0},renderOrder:6,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.35}},count:1,scale:1,diameterUnit:"mascot",diameter:1.3,models:["splash-ring"],animation:{...h_,appearAt:.03,rotate:{axis:"y",rotations:-3,phase:0},renderOrder:8,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.4}},count:1,scale:1,diameterUnit:"mascot",diameter:1.3,models:["splash-ring"],animation:{...h_,appearAt:.06,rotate:{axis:"x",rotations:3,phase:60},renderOrder:10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.45}},count:1,scale:1,diameterUnit:"mascot",diameter:1.3,models:["splash-ring"],animation:{...h_,appearAt:.09,rotate:{axis:"y",rotations:-3,phase:120},renderOrder:12,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.38}},count:1,scale:1,diameterUnit:"mascot",diameter:1.3,models:["splash-ring"],animation:{...h_,appearAt:.12,rotate:{axis:"x",rotations:3,phase:45},renderOrder:14,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.42}},count:1,scale:1,diameterUnit:"mascot",diameter:1.3,models:["splash-ring"],animation:{...h_,appearAt:.15,rotate:{axis:"y",rotations:-3,phase:-45},atmospherics:[{preset:"spray",targets:["splash-ring"],anchor:"around",intensity:.2,sizeScale:.7,progressCurve:"sustain"}],renderOrder:16,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.55,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[.25,.55,.9],glowIntensityMin:.5,glowIntensityMax:.85,glowPulseRate:2,scaleVibration:.005,scaleFrequency:2,tremor:.002,tremorFrequency:2,decayRate:.2});function u_(e){return(43758.5453*Math.sin(e)%1+1)%1}function p_(e){const t=Math.floor(e),n=e-t,a=n*n*(3-2*n);return u_(t)*(1-a)+u_(t+1)*a}function m_(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.8,offBeat:1,curve:"radiating"===e.category?"smooth":"sharp"}},"3d":{evaluate(t,n){const a=e["3d"]?.evaluate,i=a?a(t,n):null,r={...e,...n},s=t*r.duration/1e3,o="radiating"===r.category;let l=1;if(r.buildupPhase&&t<r.buildupPhase&&(l=t/r.buildupPhase,l=Math.pow(l,1.5)),r.burstPhase&&t>=r.buildupPhase){const e=(t-r.buildupPhase)/r.burstPhase;l=e<.3?1+3.33*e:2*(1-(e-.3)/.7)}t>1-r.flickerDecay&&(l*=1-(t-(1-r.flickerDecay))/r.flickerDecay);let c=0,h=0,d=0;if(r.flickerAmplitude>0){const e=s*r.flickerFrequency;if(c=(p_(e)-.5+.4*(p_(2.1*e+50)-.5))*r.flickerAmplitude*l,h=(p_(e+33)-.5+.5*(p_(1.8*e+83)-.5))*r.flickerAmplitude*l,d=(p_(e+66)-.5)*r.flickerAmplitude*l*.5,r.burstJitter&&t>=r.buildupPhase){const e=l>1?l:0;c+=(p_(50*s)-.5)*r.burstJitter*e,h+=(p_(50*s+100)-.5)*r.burstJitter*e,d+=(p_(50*s+200)-.5)*r.burstJitter*e*.5}}r.riseAmount&&(h+=r.riseAmount*l),r.hover&&r.hoverAmount&&(h+=Math.sin(s*Math.PI*.5)*r.hoverAmount*l);let u=1;const p=s*r.scaleFrequency;if(r.scalePulse?(u=1+(.5*Math.sin(p*Math.PI*2)+.5)*r.scaleVibration*l,r.scaleGrowth&&(u+=r.scaleGrowth*l)):u=1+(.5*Math.sin(p*Math.PI*2)+.3*Math.sin(p*Math.PI*3.3))*r.scaleVibration*l,r.heatExpansion&&(u+=r.heatExpansion*l),r.scaleBurst&&t>=r.buildupPhase){const e=l>1?l-1:0;u+=r.scaleBurst*e}const m=s*r.glowFlickerRate;let f;f=o?.3*Math.sin(m*Math.PI*2)+.7:.3*Math.sin(m*Math.PI*2)+.2*Math.sin(m*Math.PI*4.7+1.3)+.4*(u_(Math.floor(3*m))>.6?1:0)+.5;const g=r.glowIntensityMin+(r.glowIntensityMax-r.glowIntensityMin)*f*l,y=(.7*f+.3)*l*r.intensity+(r.mascotGlow||0)*l,v=i?.rotation||[0,0,0];return{position:[c,h,d],rotation:[v[0]||0,v[1]||0,v[2]||0],scale:u,glowIntensity:g,glowBoost:y,glowColorOverride:r.glowColor,fireOverlay:{enabled:l>.1,strength:l*r.intensity,heat:l*r.intensity,temperature:r.temperature,category:r.category,spawnMode:r.spawnMode||null,duration:r.duration,progress:t,time:s,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth}}}}}}var f_=m_({name:"burn",emoji:"",type:"blending",description:"Flames flickering across surface, being consumed",duration:2500,beats:4,intensity:1,category:"burning",temperature:.6,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.15,cameraFacing:.3,clustering:.25,count:8,scale:1.25,models:["flame-wisp","flame-tongue"],minDistance:.12,animation:{appearAt:.05,disappearAt:.85,stagger:.03,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.08,geometryStability:!0},gestureGlow:{baseGlow:.8,peakGlow:2.5,curve:"easeIn"},parameterAnimation:{temperature:{start:.4,peak:.65,end:.35,curve:"bell"}},flicker:{intensity:.35,rate:12,pattern:"random"},pulse:{amplitude:.15,frequency:8,easing:"easeInOut"},emissive:{min:.8,max:2,frequency:10,pattern:"sine"},cutout:{strength:.7,primary:{pattern:5,scale:2,weight:1},secondary:{pattern:4,scale:1.5,weight:.5},blend:"multiply",travel:"radial",travelSpeed:2.5,strengthCurve:"fadeIn",fadeInDuration:.4,trailDissolve:{offset:-.15,softness:.3},geometricMask:{type:"distance",core:.08,tip:.18}},grain:{type:3,strength:.04,scale:.1,speed:.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],drift:{direction:"up",distance:.12,noise:.025},scaleVariance:.35,lifetimeVariance:.3,delayVariance:.1,blending:"additive",renderOrder:10,intensityScaling:{scale:1.3,pulseAmplitude:1.5,flickerIntensity:1.4,emissiveMax:1.6},modelOverrides:{"ember-cluster":{scaling:{mode:"uniform-pulse",amplitude:.2,frequency:4},drift:{direction:"rising",speed:.025,noise:.25,buoyancy:!0},opacityLink:"flicker"},"flame-wisp":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.7},y:{expand:!0,rate:1.6},z:{expand:!1,rate:.7}}},drift:{direction:"rising",speed:.03,noise:.15,buoyancy:!0},orientationOverride:"rising"},"flame-tongue":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.8,oscillate:!0},y:{expand:!0,rate:1.4},z:{expand:!1,rate:.8,oscillate:!0}},wobbleFrequency:5,wobbleAmplitude:.15},drift:{direction:"rising",speed:.025,noise:.2}}}}},flickerFrequency:12,flickerAmplitude:.015,flickerDecay:.2,glowColor:[1,.5,.1],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:15,scaleVibration:.02,scaleFrequency:8,riseAmount:.01}),g_=m_({name:"scorch",emoji:"",type:"blending",description:"Core meltdown, internal heat escaping",duration:1200,beats:3,intensity:1.3,category:"burning",temperature:.8,spawnMode:{type:"surface",pattern:"shell",embedDepth:.1,cameraFacing:.3,clustering:.2,count:12,scale:.9,models:["flame-wisp","ember-cluster"],minDistance:.12,animation:{appearAt:.05,disappearAt:.85,stagger:.03,enter:{type:"fade",duration:.12,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.8,end:.4,curve:"sustained"}},flicker:{intensity:.3,rate:12,pattern:"random"},emissive:{min:1.5,max:3,frequency:6,pattern:"sine"},cutout:{strength:.55,primary:{pattern:7,scale:1.5,weight:1},secondary:{pattern:5,scale:1.2,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,trailDissolve:{offset:-.1,softness:.25}},grain:{type:3,strength:.08,scale:.2,speed:.8,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain"}],drift:{speed:.3,distance:.3,direction:{x:0,y:1,z:0},easing:"easeOutCubic"},scaleVariance:.25,lifetimeVariance:.2,blending:"additive",renderOrder:12}},flickerFrequency:6,flickerAmplitude:.008,flickerDecay:.25,glowColor:[1,.8,.3],glowIntensityMin:1.5,glowIntensityMax:3.5,glowFlickerRate:8,scaleVibration:.01,scaleFrequency:3,heatExpansion:.03,shimmerEffect:!0,shimmerIntensity:.02}),y_=m_({name:"combust",emoji:"",type:"blending",description:"Building heat then sudden flame burst",duration:2e3,beats:4,intensity:1.5,category:"burning",temperature:.9,spawnMode:{type:"surface",pattern:"spikes",embedDepth:.1,cameraFacing:.35,clustering:.3,count:12,scale:1.2,models:["fire-burst","flame-tongue","ember-cluster"],minDistance:.08,animation:{appearAt:.55,disappearAt:.95,stagger:.01,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeInCubic"},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.95,end:.6,curve:"spike"}},flicker:{intensity:.5,rate:25,pattern:"random"},pulse:{amplitude:.25,frequency:15,easing:"easeOut"},emissive:{min:1.5,max:4,frequency:20,pattern:"sine"},cutout:{strength:.75,primary:{pattern:3,scale:2.5,weight:1},secondary:{pattern:8,scale:2,weight:.6},blend:"multiply",travel:"radial",travelSpeed:6,strengthCurve:"fadeIn",fadeInDuration:.15,geometricMask:{type:"tip-boost",core:0,tip:.2}},grain:{type:2,strength:.15,scale:.1,speed:4,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain"}],drift:{direction:"outward",distance:.15,noise:.02},scaleVariance:.4,lifetimeVariance:.25,delayVariance:.05,blending:"additive",renderOrder:15,intensityScaling:{scale:1.5,emissiveMax:2,flickerIntensity:1.6,driftSpeed:1.4},scalePerElement:[1,.5,1.3,.6,1.5,.4,1.2,.7,1.4,.55,1.1,.65],modelOverrides:{"fire-burst":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.8},y:{expand:!0,rate:2},z:{expand:!0,rate:1.8}}},drift:{direction:"outward",speed:.06,noise:.15},opacityLink:"inverse-scale"},"flame-tongue":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.4,oscillate:!0},y:{expand:!0,rate:1.6},z:{expand:!0,rate:1.4,oscillate:!0}},wobbleFrequency:8,wobbleAmplitude:.2},drift:{direction:"outward",speed:.04,noise:.1}},"ember-cluster":{drift:{direction:"outward",speed:.05,noise:.3},opacityLink:"flicker"}}}},buildupPhase:.6,burstPhase:.4,flickerFrequency:20,flickerAmplitude:.025,flickerDecay:.15,glowColor:[1,.6,.2],glowIntensityMin:.8,glowIntensityMax:4,glowFlickerRate:25,scaleVibration:.03,scaleFrequency:15,scaleBurst:.08,burstJitter:.03}),v_=m_({name:"radiate",emoji:"",type:"blending",description:"Expanding flame rings radiating outward",duration:1500,beats:4,intensity:.8,mascotGlow:.4,category:"radiating",temperature:.4,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"bottom",easing:"linear",startScale:1.2,endScale:1.8,startDiameter:1.2,endDiameter:3.5,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["flame-ring"],animation:{appearAt:.02,disappearAt:.85,stagger:.03,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.13,easing:"easeOutQuad"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.7,peak:.6,end:.35,curve:"linear"}},flicker:{intensity:.25,rate:10,pattern:"smooth"},pulse:{amplitude:.12,frequency:3,easing:"easeInOut"},emissive:{min:1.2,max:2.8,frequency:4,pattern:"sine"},cutout:{strength:.6,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:6,scale:1.5,weight:.4},blend:"add",travel:"radial",travelSpeed:2,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.05,scale:.15,speed:1,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain"}],rotate:[{axis:"y",rotations:1.5,phase:0},{axis:"y",rotations:1.5,phase:120},{axis:"y",rotations:1.5,phase:240}],scaleVariance:.1,lifetimeVariance:.05,blending:"additive",renderOrder:8,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.8,arcCount:1},orientationOverride:"vertical"}}}},{type:"radial-burst",radialBurst:{startRadius:.1,endRadius:1.2,height:0,easing:"easeOutExpo"},formation:{type:"ring",count:6,startAngle:0},count:6,scale:1,models:["flame-tongue","fire-burst","flame-tongue","fire-burst","flame-tongue","fire-burst"],animation:{appearAt:.45,disappearAt:.8,stagger:.02,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.2,easing:"easeInCubic",burstScale:1.3},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{temperature:{start:.7,peak:.95,end:.5,curve:"bell"}},flicker:{intensity:.4,rate:18,pattern:"random"},pulse:{amplitude:.15,frequency:8,easing:"easeOut"},emissive:{min:2,max:4,frequency:10,pattern:"sine"},cutout:{strength:.7,primary:{pattern:2,scale:2.5,weight:1},secondary:{pattern:5,scale:1.5,weight:.6},blend:"multiply",travel:"radial",travelSpeed:4,geometricMask:{type:"tip-boost",core:0,tip:.15}},scalePerElement:[1,.8,1.1,.75,.95,.85],blending:"additive",renderOrder:12}}],flickerFrequency:8,flickerAmplitude:.01,flickerDecay:.2,glowColor:[1,.7,.3],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.015,scaleFrequency:3,scaleGrowth:.02,rotationEffect:!0,rotationSpeed:.3}),b_=m_({name:"blaze",emoji:"",type:"blending",description:"Flagship fire aura with pulsing flame star",duration:1800,beats:3,intensity:1.3,mascotGlow:.6,category:"radiating",temperature:.75,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"center",easing:"easeOut",startScale:1,endScale:.7,startDiameter:.8,endDiameter:1.4,orientation:"radial"},formation:{type:"spiral",count:6,spacing:.15,arcOffset:60,phaseOffset:0},count:6,scale:3,models:["ember-cluster","flame-wisp","ember-cluster","ember-cluster","flame-wisp","flame-wisp"],animation:{appearAt:0,disappearAt:.75,stagger:.12,staggerExit:.1,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.18,easing:"easeInCubic",burstScale:1.2},drift:{direction:"up",distance:.4,noise:.25},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.6,peak:.85,end:.5,curve:"bell"}},flicker:{intensity:.6,rate:30,pattern:"random"},pulse:{amplitude:.55,frequency:8,easing:"linear",perElement:!0},emissive:{min:2.5,max:8,frequency:12,pattern:"random"},cutout:{strength:.55,primary:{pattern:7,scale:.8,weight:1},secondary:{pattern:5,scale:1.2,weight:.6},blend:"multiply",travel:"radial",travelSpeed:6,strengthCurve:"bell",bellPeakAt:.6,bellWidth:.4,geometricMask:{type:"tip-boost",core:0,tip:.15}},grain:{type:3,strength:.03,scale:.1,speed:.3,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],rotate:[{axis:"y",rotations:2.3,phase:0},{axis:"y",rotations:-1.7,phase:67},{axis:"y",rotations:3.1,phase:155},{axis:"y",rotations:-2.2,phase:98},{axis:"y",rotations:1.4,phase:233},{axis:"y",rotations:-2.8,phase:301}],scalePerElement:[1.6,.65,1.4,.7,1.5,.68],blending:"additive",renderOrder:16}}],flickerFrequency:4,flickerAmplitude:.008,flickerDecay:.2,glowColor:[1,.55,.12],glowIntensityMin:1.5,glowIntensityMax:3,glowFlickerRate:5,scaleVibration:.015,scaleFrequency:2,scalePulse:!0,scaleGrowth:.03,hover:!0,hoverAmount:.01}),w_=m_({name:"flame-vortex",emoji:"",type:"blending",description:"Fire tornado spiraling around mascot",duration:1500,beats:5,intensity:1.4,category:"burning",temperature:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.7,startDiameter:.6,endDiameter:1.2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["flame-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.12,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.8,end:.6,curve:"bell"}},flicker:{intensity:.4,rate:18,pattern:"random"},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.5,frequency:8,pattern:"sine"},cutout:{strength:.7,primary:{pattern:6,scale:2.5,weight:1},secondary:{pattern:4,scale:1.8,weight:.5},blend:"add",travel:"spiral",travelSpeed:4,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:2,strength:.12,scale:.15,speed:2.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:12,intensityScaling:{scale:1.4,emissiveMax:1.6,pulseAmplitude:1.3},modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:6,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}}}},flickerFrequency:15,flickerAmplitude:.01,flickerDecay:.15,glowColor:[1,.55,.15],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:12,scaleVibration:.02,scaleFrequency:4,scaleGrowth:.03,rotationEffect:!0,rotationSpeed:.5}),x_=m_({name:"firedance",emoji:"",type:"blending",description:"Vertical flame rings dancing and rising",duration:1500,beats:3,intensity:1.3,category:"radiating",temperature:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.8,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["flame-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.75,end:.55,curve:"bell"}},flicker:{intensity:.35,rate:14,pattern:"random"},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.75,primary:{pattern:6,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.6},blend:"add",travel:"spiral",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28}},grain:{type:3,strength:.06,scale:.15,speed:1,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:11,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},flickerFrequency:12,flickerAmplitude:.012,flickerDecay:.15,glowColor:[1,.5,.15],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:10,scaleVibration:.018,scaleFrequency:4,scaleGrowth:.025,rotationEffect:!0,rotationSpeed:.4}),S_=m_({name:"phoenix",emoji:"",type:"blending",description:"Ascending fire vortex - mixed flames spiral upward in rebirth",duration:4e3,beats:4,intensity:1.7,mascotGlow:1,category:"radiating",temperature:.85,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:1,endScale:1.8,startDiameter:1.8,endDiameter:2.8,orientation:"rising"},formation:{type:"spiral",count:7,strands:2,spacing:.2,arcOffset:51,phaseOffset:.1},count:7,scale:1.1,models:["flame-wisp","ember-cluster","flame-tongue","flame-tongue","flame-tongue","fire-burst","fire-burst"],animation:{appearAt:0,disappearAt:.75,stagger:.08,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.35,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.95,end:.7,curve:"bell"}},flicker:{intensity:.3,rate:12,pattern:"smooth"},pulse:{amplitude:.15,frequency:4,easing:"easeInOut"},emissive:{min:1.2,max:4,frequency:6,pattern:"sine"},cutout:{strength:.65,primary:{pattern:7,scale:1.5,weight:1},secondary:{pattern:5,scale:2,weight:.5},blend:"add",travel:"angular",travelSpeed:2,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"distance",core:.1,tip:.3}},grain:{type:0,strength:.1,scale:.25,speed:1.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],rotate:{axis:"y",rotations:1.5,phase:0},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:14,modelOverrides:{"flame-wisp":{scaleMultiplier:1.2,orientationOverride:"rising"},"ember-cluster":{scaleMultiplier:1,orientationOverride:"rising"},"flame-tongue":{scaleMultiplier:1.4,orientationOverride:"rising"},"fire-burst":{scaleMultiplier:1.3,orientationOverride:"camera"}}}},flickerFrequency:10,flickerAmplitude:.015,flickerDecay:.12,glowColor:[1,.6,.2],glowIntensityMin:1.4,glowIntensityMax:3.5,glowFlickerRate:8,scaleVibration:.02,scaleFrequency:3,scaleGrowth:.04,rotationEffect:!0,rotationSpeed:.35}),M_=m_({name:"fireflourish",emoji:"",type:"blending",description:"Spinning sword flourish with fire trail",duration:1200,beats:4,intensity:1.3,mascotGlow:.3,category:"radiating",temperature:.65,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:5,spacing:0,arcOffset:72,phaseOffset:.05,zOffset:.02},count:5,scale:.9,models:["flame-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.65,peak:.95,end:.3,curve:"bell"}},flicker:{intensity:.2,rate:10,pattern:"sine"},pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},emissive:{min:2,max:5,frequency:6,pattern:"sine",decayOnExit:!0,perElementScale:[1,.95,.88,.8,.72]},grain:{type:0,strength:.35,scale:.3,speed:2,blend:"multiply"},atmospherics:[{preset:"smoke",targets:["flame-ring"],anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.4}],cutout:{strength:.85,pattern:6,scale:2.5,travel:"spiral",travelSpeed:2},drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.9,.8,.7,.6],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"z",rotations:1.8,phase:144},{axis:"z",rotations:-2.3,phase:216},{axis:"z",rotations:2,phase:288}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:12,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.8,y:.5,z:.3},orientation:"camera",startScale:.3,endScale:1.4,scaleEasing:"easeOutCubic"},count:1,scale:1,models:["flame-tongue"],animation:{appearAt:.15,disappearAt:.55,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.35,easing:"easeOutQuad"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{temperature:{start:.8,peak:.95,end:.4,curve:"bell"}},flicker:{intensity:.3,rate:15,pattern:"random"},emissive:{min:2.5,max:4.5,frequency:8,pattern:"sine"},drift:{speed:.8,distance:.4,direction:{x:1.2,y:-.8,z:-.2},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:.5,phase:-45}],blending:"additive",renderOrder:14}},{type:"anchor",anchor:{landmark:"center",offset:{x:.8,y:.5,z:.3},orientation:"camera",startScale:.3,endScale:1.4,scaleEasing:"easeOutCubic"},count:1,scale:1,models:["flame-tongue"],animation:{appearAt:.15,disappearAt:.55,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.35,easing:"easeOutQuad"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{temperature:{start:.8,peak:.95,end:.4,curve:"bell"}},flicker:{intensity:.3,rate:15,pattern:"random"},emissive:{min:2.5,max:4.5,frequency:8,pattern:"sine"},drift:{speed:.8,distance:.4,direction:{x:-1.2,y:-.8,z:-.2},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:.5,phase:45}],blending:"additive",renderOrder:14}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.2},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:.9,models:["flame-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.7,peak:.9,end:.35,curve:"bell"}},flicker:{intensity:.25,rate:12,pattern:"smooth"},emissive:{min:2,max:4,frequency:6,pattern:"sine"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"additive",renderOrder:10,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.2},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:.9,models:["flame-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.7,peak:.9,end:.35,curve:"bell"}},flicker:{intensity:.25,rate:12,pattern:"smooth"},emissive:{min:2,max:4,frequency:6,pattern:"sine"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"additive",renderOrder:10,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],flickerFrequency:15,flickerAmplitude:.01,flickerDecay:.15,glowColor:[1,.55,.15],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:12,scaleVibration:.012,scaleFrequency:8,scaleGrowth:.015,rotationEffect:!1}),__=m_({name:"firecrown",emoji:"",type:"blending",description:"Majestic flame crown above the head",duration:3e3,beats:4,intensity:1,mascotGlow:.3,category:"radiating",temperature:.65,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.3}},count:1,scale:1.2,models:["flame-ring"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},cutout:{strength:.65,primary:{pattern:5,scale:1.5,weight:1},secondary:{pattern:6,scale:2,weight:.4},blend:"add",travel:"angular",travelSpeed:1.5,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.6,geometricMask:{type:"distance",core:.15,tip:.3}},grain:{type:0,strength:.35,scale:.25,speed:1.5,blend:"multiply"},parameterAnimation:{temperature:{start:.5,peak:.7,end:.6,curve:"bell"}},flicker:{intensity:.15,rate:8,pattern:"sine"},pulse:{amplitude:.06,frequency:2,easing:"easeInOut"},emissive:{min:1.2,max:2,frequency:3,pattern:"sine"},atmospherics:[{preset:"smoke",targets:["flame-ring"],anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain"}],rotate:{axis:"z",rotations:1,phase:0},scaleVariance:0,lifetimeVariance:0,blending:"additive",renderOrder:15,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.8,arcCount:3}}}}},flickerFrequency:6,flickerAmplitude:.006,flickerDecay:.25,glowColor:[1,.7,.3],glowIntensityMin:.9,glowIntensityMax:1.4,glowFlickerRate:5,scaleVibration:.008,scaleFrequency:3,scaleGrowth:.01,rotationEffect:!1});const A_={landmark:"center",orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},C_={disappearAt:.85,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},blending:"normal",renderOrder:10,relay:{count:3,arcWidth:Math.PI,floor:.5}};function T_(e,t,n,a,i,r=0,s=null){const o=.866,l=e=>Math.round(100*e)/100;return[{x:0,y:e,relay:i[0],arc:4.71,dir:-1},{x:o*e,y:-.5*e,relay:i[1],arc:3.14,dir:1},{x:-o*e,y:-.5*e,relay:i[2],arc:0,dir:-1},{x:0,y:-e,relay:i[0],arc:4.71,dir:1},{x:-o*e,y:.5*e,relay:i[1],arc:3.14,dir:-1},{x:o*e,y:.5*e,relay:i[2],arc:0,dir:1}].map((e,i)=>({type:"anchor",anchor:{...A_,offset:{x:l(e.x),y:l(e.y),z:0}},count:1,scale:t,sizeVariance:0,models:["flame-ring"],animation:{...C_,appearAt:r,rotate:[{axis:"z",rotations:e.dir*n,phase:0}],...0===i&&s?{atmospherics:s}:{},modelOverrides:{"flame-ring":{arcPhase:(e.arc+a)%6.28,relayIndex:e.relay,orientationOverride:"camera"}}}}))}var P_=m_({name:"firemeditation",emoji:"",type:"blending",description:"Triple flame hexagon mandala  three concentric relay hexagons with differential rotation",duration:3e3,beats:6,intensity:1.5,mascotGlow:.4,category:"afflicted",temperature:.5,spawnMode:[...T_(.28,.7,2,0,[0,1,2],0,[{preset:"smoke",intensity:.15,sizeScale:.5,progressCurve:"sustain"}]),...T_(.52,1.15,-1.5,2.09,[1,2,0],.08),...T_(.78,1.55,1,4.19,[2,0,1],.16),...T_(.28,.7,-2,3.14,[0,1,2],0),...T_(.52,1.15,1.5,5.23,[1,2,0],.08),...T_(.78,1.55,-1,1.05,[2,0,1],.16)],glowColor:[1,.7,.3],glowIntensityMin:.8,glowIntensityMax:1.1,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:2,scaleContract:.02,tremor:.002,tremorFrequency:3,shakeAmount:.003,shakeFrequency:4,decayRate:.1}),D_=m_({name:"firedrill",emoji:"",type:"blending",description:"Fast tight ascending flame helix",duration:1200,beats:2,intensity:1.5,category:"radiating",temperature:.8,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:.8,models:["flame-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.6,peak:.9,end:.7,curve:"bell"}},flicker:{intensity:.4,rate:25,pattern:"random"},pulse:{amplitude:.08,frequency:10,easing:"linear"},emissive:{min:1.5,max:3.5,frequency:12,pattern:"random"},cutout:{strength:.85,primary:{pattern:8,scale:2.5,weight:1},secondary:{pattern:3,scale:3,weight:.7},blend:"multiply",travel:"oscillate",travelSpeed:5,geometricMask:{type:"distance",core:.08,tip:.2},trailDissolve:{offset:.1,softness:.25}},grain:{type:2,strength:.1,scale:.1,speed:3,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:16,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},flickerFrequency:20,flickerAmplitude:.015,flickerDecay:.1,glowColor:[1,.4,.1],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:18,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03,rotationEffect:!0,rotationSpeed:.8});const O_={appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{temperature:{start:.55,peak:.8,end:.65,curve:"bell"}},flicker:{intensity:.12,rate:8,pattern:"sine"},pulse:{amplitude:.05,frequency:3,easing:"easeInOut"},emissive:{min:1.3,max:2.5,frequency:4,pattern:"sine"},grain:{type:2,strength:.5,scale:.15,speed:2.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:["flame-ring"],anchor:"above",intensity:.4,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5}],scaleVariance:.03,lifetimeVariance:.02,blending:"additive",renderOrder:15,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.8,arcCount:3}}}};var E_=m_({name:"firepillar",emoji:"",type:"blending",description:"Majestic rising pillar of flame",duration:3e3,beats:4,intensity:1.3,mascotGlow:.5,category:"radiating",temperature:.7,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:0},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["flame-ring"],animation:{...O_,stagger:.03,cutout:{strength:.6,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.4},blend:"add",travel:"angular",travelSpeed:1.2,strengthCurve:"fadeIn",fadeInDuration:.3,geometricMask:{type:"distance",core:.1,tip:.25}},rotate:[{axis:"z",rotations:.3,phase:0},{axis:"z",rotations:.3,phase:180}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:.5},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["flame-ring"],animation:{...O_,stagger:.05,cutout:{strength:.65,primary:{pattern:7,scale:1.8,weight:1},secondary:{pattern:5,scale:1.5,weight:.5},blend:"multiply",travel:"radial",travelSpeed:1.8,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"tip-boost",core:0,tip:.2}},rotate:[{axis:"z",rotations:-.6,phase:60},{axis:"z",rotations:-.6,phase:240}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:1},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["flame-ring"],animation:{...O_,stagger:.07,cutout:{strength:.7,primary:{pattern:5,scale:1.5,weight:1},secondary:{pattern:6,scale:2,weight:.4},blend:"add",travel:"oscillate",travelSpeed:2.5,strengthCurve:"fadeOut",fadeOutDuration:.4,geometricMask:{type:"distance",core:.15,tip:.3}},rotate:[{axis:"z",rotations:.9,phase:90},{axis:"z",rotations:.9,phase:270}]}}],flickerFrequency:6,flickerAmplitude:.006,flickerDecay:.25,glowColor:[1,.65,.25],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:5,scaleVibration:.008,scaleFrequency:3,scaleGrowth:.025,rotationEffect:!1}),I_=m_({name:"firehelix",emoji:"",type:"blending",description:"DNA-style double helix ascending flame",duration:2e3,beats:4,intensity:1.2,category:"radiating",temperature:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.9,endScale:1.1,startDiameter:1.8,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:.7,models:["flame-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.8,end:.6,curve:"bell"}},flicker:{intensity:.25,rate:12,pattern:"smooth"},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:1.2,max:2.5,frequency:6,pattern:"smooth"},cutout:{strength:.8,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:6,scale:1.8,weight:.6},blend:"max",travel:"angular",travelSpeed:3,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:0,strength:.08,scale:.2,speed:1.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"additive",renderOrder:16,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},flickerFrequency:10,flickerAmplitude:.012,flickerDecay:.15,glowColor:[1,.5,.2],glowIntensityMin:1.1,glowIntensityMax:2.2,glowFlickerRate:8,scaleVibration:.015,scaleFrequency:5,scaleGrowth:.02,rotationEffect:!0,rotationSpeed:.4}),k_=m_({name:"firebarrage",emoji:"",type:"blending",description:"Fire orbits mascot then launches upward",duration:1500,beats:4,intensity:1.4,category:"radiating",temperature:.8,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.8,models:["flame-wisp","flame-tongue","ember-cluster"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.6,peak:.9,end:.4,curve:"fadeOut"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.25,sizeScale:.6,progressCurve:"sustain",velocityInheritance:.7}],rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"additive",renderOrder:12}},flickerFrequency:14,flickerAmplitude:.012,glowColor:[1,.5,.15],glowIntensityMin:1.2,glowIntensityMax:2,glowFlickerRate:8,scaleVibration:.015,scaleFrequency:4,scaleGrowth:.02}),R_=m_({name:"fireimpact",emoji:"",type:"blending",description:"Fire orbits then crashes inward with impact",duration:1500,beats:4,intensity:1.5,category:"transform",temperature:.9,spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:3.5,endRadius:.1,speed:3,easing:"easeOut",startScale:.4,endScale:1.8,orientation:"vertical"},formation:{type:"ring",count:7},count:7,scale:1.4,models:["flame-wisp","flame-tongue","ember-cluster","fire-burst"],animation:{appearAt:0,disappearAt:.6,stagger:.02,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.05,easing:"easeOut",burstScale:.2},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{temperature:{start:.4,peak:.95,end:.9,curve:"fadeIn"}},pulse:{amplitude:.12,frequency:8,easing:"easeInOut"},emissive:{min:1,max:3,frequency:9,pattern:"sine"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.7}],rotate:[{axis:"z",rotations:-4,phase:0},{axis:"x",rotations:3.5,phase:50},{axis:"y",rotations:-3,phase:100},{axis:"z",rotations:4,phase:155},{axis:"x",rotations:-3.5,phase:210},{axis:"y",rotations:3,phase:260},{axis:"z",rotations:-4.5,phase:315}],scaleVariance:.2,lifetimeVariance:.08,blending:"additive",renderOrder:12}},flickerFrequency:18,flickerAmplitude:.018,glowColor:[1,.4,.1],glowIntensityMin:1.6,glowIntensityMax:2.8,glowFlickerRate:12,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.018,tremorFrequency:9}),z_=m_({name:"fireblast",emoji:"",type:"blending",description:"Explosive fire blast with bursting flames and ember spray",duration:1e3,beats:2,intensity:1.3,category:"impact",temperature:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.2,endScale:2,scaleEasing:"easeOutQuad"},count:1,scale:1.5,models:["flame-ring"],animation:{appearAt:0,disappearAt:.4,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.6,primary:{pattern:2,scale:1.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.25,softness:1.2}},grain:{type:3,strength:.5,scale:.3,speed:1.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],blending:"additive",renderOrder:8,rotate:{axis:"z",rotations:0,phase:0},modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1.2,models:["fire-burst"],animation:{appearAt:0,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:5,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.4,distance:.8,direction:{x:0,y:1,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["fire-burst"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.45,primary:{pattern:5,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:-.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["fire-burst"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.45,primary:{pattern:5,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.85,models:["fire-burst"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:5,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:-.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:11,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.85,models:["fire-burst"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:5,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:11,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:8,radius:.05,endRadius:.65,angleSpread:360,startAngle:22,orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:8,scale:.6,models:["flame-tongue"],animation:{appearAt:.02,disappearAt:.4,stagger:.008,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.35,primary:{pattern:5,scale:.7,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:14,modelOverrides:{"flame-tongue":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:12,radius:.03,endRadius:.5,angleSpread:360,startAngle:0,orientation:"camera",startScale:.1,endScale:.35,scaleEasing:"easeOutQuad"},count:12,scale:.2,models:["ember-cluster"],animation:{appearAt:.01,disappearAt:.3,stagger:.005,enter:{type:"scale",duration:.02,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.25,primary:{pattern:7,scale:.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.5,lifetimeVariance:.25,blending:"additive",renderOrder:16,modelOverrides:{"ember-cluster":{shaderAnimation:{type:1,arcWidth:.98,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.1,z:.12},orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:1,scale:.7,models:["ember-cluster"],animation:{appearAt:.05,disappearAt:.6,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.5,primary:{pattern:5,scale:1.2,weight:1},blend:"multiply",travel:"radial",travelSpeed:.5,strengthCurve:"constant"},pulse:{amplitude:.1,frequency:8,easing:"easeInOut"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:6,modelOverrides:{"ember-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:2},orientationOverride:"camera"}}}}],flickerFrequency:14,flickerAmplitude:.02,flickerDecay:.4,scaleVibration:.035,scaleFrequency:7,scaleGrowth:.015,glowColor:[1,.5,.15],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:10}),F_=m_({name:"firetwirl",emoji:"",type:"blending",description:"Relay flame illusion  arc weaves through three interlocked rings",duration:1500,beats:2,intensity:1.5,category:"afflicted",growth:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["flame-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"smoke",intensity:.2,sizeScale:.6,progressCurve:"sustain"}],modelOverrides:{"flame-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["flame-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"flame-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.52,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["flame-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"flame-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[1,.7,.3],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.006,tremorFrequency:8,shakeAmount:.01,shakeFrequency:12,decayRate:.15});const B_={disappearAt:.9,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:3,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.3,speed:.5,blend:"multiply"},blending:"additive"};var L_=m_({name:"fireshield",emoji:"",type:"blending",description:"Gyroscopic flame cage  six tumbling rings form a protective inferno",duration:3e3,beats:4,intensity:1,mascotGlow:.5,category:"radiating",temperature:.7,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.3}},count:1,scale:1.5,models:["flame-ring"],animation:{...B_,appearAt:0,rotate:{axis:"x",rotations:2.5,phase:0},renderOrder:6,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.35}},count:1,scale:1.5,models:["flame-ring"],animation:{...B_,appearAt:.03,rotate:{axis:"y",rotations:-2.5,phase:0},renderOrder:8,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.4}},count:1,scale:1.5,models:["flame-ring"],animation:{...B_,appearAt:.06,rotate:{axis:"x",rotations:2.5,phase:60},renderOrder:10,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.45}},count:1,scale:1.5,models:["flame-ring"],animation:{...B_,appearAt:.09,rotate:{axis:"y",rotations:-2.5,phase:120},renderOrder:12,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.38}},count:1,scale:1.5,models:["flame-ring"],animation:{...B_,appearAt:.12,rotate:{axis:"x",rotations:2.5,phase:45},renderOrder:14,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.42}},count:1,scale:1.5,models:["flame-ring"],animation:{...B_,appearAt:.15,rotate:{axis:"y",rotations:-2.5,phase:-45},atmospherics:[{preset:"smoke",targets:["flame-ring"],anchor:"around",intensity:.2,sizeScale:.7,progressCurve:"sustain"}],renderOrder:16,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.55,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[1,.65,.25],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,tremor:.002,tremorFrequency:2,decayRate:.2});function N_(e){return(43758.5453*Math.sin(e)%1+1)%1}function V_(e){const t=Math.floor(e),n=e-t,a=n*n*(3-2*n);return N_(t)*(1-a)+N_(t+1)*a}function U_(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"annihilation"===e.category?1.5:1.2,offBeat:1,curve:"manifestation"===e.category?"smooth":"sharp"}},"3d":{evaluate(t,n){const a={...e,...n},i=t*a.duration/1e3,{category:r}=a,s="manifestation"===r;let o=1;a.buildupPhase&&t<a.buildupPhase&&(o=Math.pow(t/a.buildupPhase,.7)),"absorption"===r&&!a.buildupPhase&&t<.25&&(o=Math.pow(t/.25,.7)),"corruption"===r&&(!a.buildupPhase&&t<.3&&(o=t/.3),a.spreadPulse&&(o*=1+.15*Math.sin(i*Math.PI*3))),"annihilation"===r&&a.collapsePhase&&t<a.collapsePhase&&(o=Math.pow(t/a.collapsePhase,1.5));const l=a.decayRate||.2;t>1-l&&(o*=1-(t-(1-l))/l);let c=0,h=0,d=0;if(a.pullStrength>0){const e=i*(a.spiralRate||1),n=a.pullStrength*o*(1-.5*t);c+=Math.cos(e*Math.PI*2)*n,d+=Math.sin(e*Math.PI*2)*n}if(a.jitterAmount>0){const e=i*a.jitterFrequency;c+=(V_(3*e)-.5)*a.jitterAmount*o,h+=(V_(3*e+33)-.5)*a.jitterAmount*o*.5,d+=(V_(3*e+66)-.5)*a.jitterAmount*o*.3}if(a.tremor>0){const e=i*a.tremorFrequency;c+=(V_(e)-.5)*a.tremor*o,h+=(V_(e+50)-.5)*a.tremor*o*.5}if(a.driftAmount>0){const e=i*a.driftSpeed;c+=Math.sin(e*Math.PI)*a.driftAmount*o,d+=Math.cos(e*Math.PI*.7)*a.driftAmount*o*.5}a.droopAmount>0&&(h-=a.droopAmount*t*(1+a.droopAcceleration*t)*o),a.riseAmount>0&&(h+=a.riseAmount*t*o),a.hover&&a.hoverAmount&&(h+=Math.sin(i*Math.PI*.5)*a.hoverAmount*o);let u=1;const p=i*(a.scaleFrequency||2);if(u=a.scalePulse?1+(.5*Math.sin(p*Math.PI*2)+.5-.5)*(a.scaleVibration||.01)*o:1+(.5*Math.sin(p*Math.PI*2)+.3*Math.sin(p*Math.PI*3.7))*(a.scaleVibration||.01)*o,a.scaleShrink>0){const e="annihilation"===r?Math.pow(t,1.5):t;u-=a.scaleShrink*e*o,u=Math.max(.01,u)}a.scaleGrowth&&(u+=a.scaleGrowth*o);let m=0,f=0,g=0;if(a.rotationSpeed>0&&(f=i*a.rotationSpeed*Math.PI*2*o,"annihilation"===r&&(f*=1+t)),a.rotationWobble>0){const e=i*a.rotationWobbleSpeed;m=Math.sin(e*Math.PI*2)*a.rotationWobble*o,g=Math.sin(e*Math.PI*1.7+.5)*a.rotationWobble*.7*o}a.rotationDrift&&(f+=i*a.rotationDrift*o);let y=1;if(a.fadeOut){const e=a.fadeStartAt||.2,n=a.fadeEndAt||.9;if(t>=e){const i=Math.min(1,(t-e)/(n-e));y="accelerating"===a.fadeCurve?Math.max(0,1-Math.pow(i,2)):Math.max(0,1-i)}}const v=i*(a.glowFlickerRate||2);let b;s||"absorption"===r?b=.3*Math.sin(v*Math.PI*2)+.7:"corruption"===r?b=(.2*Math.sin(v*Math.PI*2)+.2*Math.sin(v*Math.PI*3.3+1)+.3)*(N_(Math.floor(2*v))>.5?.8:1.2):(b=.4*Math.sin(v*Math.PI*2)+.6,b*=1-.5*t);const w=a.glowIntensityMin||.4;return{position:[c,h,d],rotation:[m,f,g],scale:u,meshOpacity:y,glowIntensity:1+(w+((a.glowIntensityMax||.7)-w)*b-1)*o,glowBoost:-(a.dimStrength||.3)*o*a.intensity+(a.mascotGlow||0)*o,glowColorOverride:o>.005?a.glowColor:null,voidOverlay:{enabled:o>.01,strength:o*a.intensity,depth:a.depth||.5,category:r,spawnMode:a.spawnMode||null,duration:a.duration,progress:t,time:i,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth,distortionStrength:e.distortionStrength}}}}}}var G_=U_({name:"voiddrain",emoji:"",type:"blending",description:"Soul extraction  energy drained upward through dark portal",duration:3500,beats:5,intensity:.7,category:"absorption",depth:.4,distortionStrength:.002,spawnMode:[{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.2,z:0},orientation:"flat",startScale:.3,endScale:1,scaleEasing:"easeOutCubic"},count:1,scale:.9,models:["void-wrap"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.04,frequency:1.5,easing:"easeInOut"},emissive:{min:.2,max:.6,frequency:2,pattern:"sine"},cutout:{strength:.35,primary:{pattern:6,scale:.7,weight:.8},secondary:{pattern:3,scale:1,weight:.3},blend:"multiply",travel:"angular",travelSpeed:1,strengthCurve:"bell",trailDissolve:{enabled:!0,offset:-.3,softness:1}},atmospherics:[{preset:"darkness",targets:["void-wrap"],anchor:"above",intensity:.4,sizeScale:1,progressCurve:"sustain"}],rotate:{axis:"z",rotations:.3,phase:0},blending:"normal",renderOrder:2,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"flat"}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"above",easing:"easeIn",startScale:1,endScale:.3,startDiameter:.8,endDiameter:.4,orientation:"camera"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:.1},count:3,scale:.5,models:["void-orb"],animation:{appearAt:.1,disappearAt:.8,stagger:.12,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"shrink",duration:.1,easing:"easeInCubic"},procedural:{scaleSmoothing:.06,geometryStability:!0},pulse:{amplitude:.1,frequency:2,easing:"easeInOut",perElement:!0},emissive:{min:.15,max:.5,frequency:3,pattern:"sine"},cutout:{strength:.45,primary:{pattern:3,scale:.5,weight:1},blend:"multiply",travel:"vertical",travelSpeed:2,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.5,softness:1.5}},rotate:[{axis:"y",rotations:1,phase:0},{axis:"y",rotations:1,phase:120},{axis:"y",rotations:1,phase:240}],opacityGradient:[1,.8,.5],scaleVariance:.2,lifetimeVariance:.1,blending:"normal",renderOrder:3,modelOverrides:{"void-orb":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1.5,arcCount:1}}}}},{type:"surface",pattern:"scattered",embedDepth:.2,cameraFacing:.2,clustering:.3,count:5,scale:.9,models:["void-shard","corruption-patch"],minDistance:.15,animation:{appearAt:.1,disappearAt:.9,stagger:.06,enter:{type:"fade",duration:.15,easing:"easeOut"},exit:{type:"shrink",duration:.12,easing:"easeInCubic"},pulse:{amplitude:.08,frequency:1,easing:"easeInOut",sync:"global"},emissive:{min:.2,max:.5,frequency:1.5,pattern:"sine"},drift:{direction:"inward",speed:.012,noise:.05},rotate:{axis:"y",speed:.015,oscillate:!1},scaleVariance:.15,lifetimeVariance:.12,blending:"normal",renderOrder:4,modelOverrides:{"void-shard":{drift:{direction:"inward",speed:.015,noise:.05},opacityLink:"dissipate"},"corruption-patch":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.2},y:{expand:!1,rate:.6},z:{expand:!0,rate:1.2}}},drift:{direction:"outward-flat",speed:.01,adherence:.6},orientationOverride:"flat"}}}}],dimRate:.3,dimPulse:!0,pullStrength:.005,glowColor:[.3,.2,.4],glowIntensityMin:.4,glowIntensityMax:.7,glowFlickerRate:2,dimStrength:.25,scaleVibration:.01,scaleFrequency:1.5,scaleShrink:.03,scalePulse:!0,decayRate:.25}),W_=U_({name:"voidhollow",emoji:"",type:"blending",description:"Becoming empty inside  the void grows from within",duration:4e3,beats:6,intensity:.8,category:"absorption",depth:.5,distortionStrength:0,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},cameraOffset:2.5,orientation:"camera"},count:1,scale:.6,models:["void-disk"],animation:{appearAt:0,disappearAt:.9,stagger:0,enter:{type:"scale",duration:.3,easing:"easeOut"},exit:{type:"shrink",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.04,frequency:.8,easing:"easeInOut"},atmospherics:[{preset:"darkness",targets:["void-disk"],anchor:"around",intensity:.8,sizeScale:.5,speedScale:.1,lifetimeScale:.4,progressCurve:"sustain",gravity:{strength:1.5,spawnRadius:.35}}],scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:1,modelOverrides:{"void-disk":{diskMode:!0}}}},{type:"orbit",orbit:{height:-.2,endHeight:.1,radius:.6,endRadius:.5,speed:.5,easing:"linear",startScale:.6,endScale:1,orientation:"camera"},count:2,scale:.4,models:["void-wrap"],animation:{appearAt:.1,disappearAt:.8,stagger:.15,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.05,frequency:1,easing:"easeInOut",perElement:!0},emissive:{min:.15,max:.45,frequency:1.5,pattern:"sine"},cutout:{strength:.5,primary:{pattern:0,scale:.8,weight:.7},secondary:{pattern:6,scale:.6,weight:.3},blend:"multiply",travel:"angular",travelSpeed:.6,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.3,softness:1}},atmospherics:[{preset:"darkness",targets:["void-wrap"],anchor:"around",intensity:.4,sizeScale:.4,progressCurve:"rampUp"}],scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:3,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.4,arcSpeed:.5,arcCount:1}}}}},{type:"surface",pattern:"shell",embedDepth:.25,cameraFacing:.15,clustering:.4,count:5,scale:.8,models:["void-crack","void-shard"],minDistance:.18,animation:{appearAt:.15,disappearAt:.9,stagger:.08,enter:{type:"grow",duration:.2,easing:"easeOutQuad"},exit:{type:"fade",duration:.15,easing:"easeIn"},pulse:{amplitude:.04,frequency:.8,easing:"easeInOut",sync:"global"},emissive:{min:.2,max:.5,frequency:1,pattern:"sine"},atmospherics:[{preset:"darkness",targets:null,anchor:"around",intensity:.3,sizeScale:.3,progressCurve:"rampUp"}],scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:5,modelOverrides:{"void-crack":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.3},y:{expand:!0,rate:1.1},z:{expand:!0,rate:.9}}}},"void-shard":{opacityLink:"dissipate"}}}}],hollowCore:!0,hollowProgress:.7,glowColor:[.25,.25,.35],glowIntensityMin:.5,glowIntensityMax:.75,glowFlickerRate:1.5,dimStrength:.2,scaleVibration:.008,scaleFrequency:1,scaleShrink:.02,scalePulse:!0,tremor:.003,tremorFrequency:6,decayRate:.2}),q_=U_({name:"voidcorrupt",emoji:"",type:"blending",description:"Descending corruption  darkness spirals down and engulfs",duration:3e3,beats:5,intensity:1.2,category:"corruption",depth:.6,distortionStrength:.003,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"above",end:"bottom",easing:"easeIn",startScale:1.2,endScale:.6,startDiameter:2.2,endDiameter:.6,orientation:"flat"},formation:{type:"spiral",count:5,spacing:.1,arcOffset:72,phaseOffset:.06},count:5,scale:.9,models:["void-wrap"],animation:{appearAt:0,disappearAt:.65,stagger:.06,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.1,frequency:3,easing:"easeInOut",perElement:!0},emissive:{min:.2,max:.6,frequency:4,pattern:"sine"},cutout:{strength:.45,primary:{pattern:6,scale:1,weight:.7},secondary:{pattern:3,scale:.8,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"bell",trailDissolve:{enabled:!0,offset:-.4,softness:1.3}},atmospherics:[{preset:"darkness",targets:null,anchor:"around",intensity:.6,sizeScale:1,progressCurve:"sustain",velocityInheritance:.3}],rotate:[{axis:"y",rotations:-2,phase:0},{axis:"y",rotations:-2,phase:72},{axis:"y",rotations:-2,phase:144},{axis:"y",rotations:-2,phase:216},{axis:"y",rotations:-2,phase:288}],scaleVariance:.2,lifetimeVariance:.1,blending:"normal",renderOrder:3,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1.5,arcCount:2},orientationOverride:"flat"}}}},{type:"surface",pattern:"scattered",embedDepth:.15,cameraFacing:.2,clustering:.5,count:5,scale:.9,models:["corruption-patch","void-crack"],minDistance:.12,animation:{appearAt:.2,disappearAt:.75,stagger:.08,enter:{type:"grow",duration:.15,easing:"easeOutQuad"},exit:{type:"fade",duration:.3,easing:"easeIn"},pulse:{amplitude:.06,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.2,max:.5,frequency:2,pattern:"sine"},atmospherics:[{preset:"darkness",targets:null,anchor:"around",intensity:.3,sizeScale:.4,progressCurve:"rampUp"}],scaleVariance:.2,lifetimeVariance:.12,blending:"normal",renderOrder:5,modelOverrides:{"corruption-patch":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.3},y:{expand:!1,rate:.5},z:{expand:!0,rate:1.3}}},orientationOverride:"flat"},"void-crack":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.2},y:{expand:!0,rate:1},z:{expand:!0,rate:.8}}}}}}}],glowColor:[.15,.05,.2],glowIntensityMin:.4,glowIntensityMax:.7,glowFlickerRate:4,dimStrength:.3,scaleVibration:.02,scaleFrequency:5,scalePulse:!0,jitterAmount:.006,jitterFrequency:7,decayRate:.22}),H_=U_({name:"voidconsume",emoji:"",type:"blending",description:"Being swallowed by void  the maw rises and consumes",duration:2500,beats:4,intensity:1.5,category:"annihilation",depth:.85,distortionStrength:.005,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeIn",startScale:.8,endScale:1.5,startDiameter:1.2,endDiameter:2.5,orientation:"flat"},formation:{type:"spiral",count:1,spacing:0,arcOffset:0,phaseOffset:0},count:1,scale:.5,models:["void-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeInCubic"},procedural:{scaleSmoothing:.06,geometryStability:!0},pulse:{amplitude:.08,frequency:4,easing:"easeIn"},emissive:{min:.2,max:.6,frequency:5,pattern:"sine"},cutout:{strength:.6,primary:{pattern:6,scale:1.2,weight:.8},secondary:{pattern:3,scale:.8,weight:.4},blend:"multiply",travel:"vertical",travelSpeed:3,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.4,softness:1.5}},atmospherics:[{preset:"darkness",targets:["void-ring"],anchor:"below",intensity:.8,sizeScale:1.5,progressCurve:"sustain"}],blending:"normal",renderOrder:2,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:2,arcCount:1},orientationOverride:"flat"}}}},{type:"radial-burst",radialBurst:{count:3,radius:.05,endRadius:.8,angleSpread:360,startAngle:60,orientation:"camera",startScale:.2,endScale:1.2,scaleEasing:"easeOutQuad"},count:3,scale:.5,models:["void-wrap"],animation:{appearAt:.15,disappearAt:.6,stagger:.05,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.55,primary:{pattern:1,scale:1.2,weight:1},secondary:{pattern:0,scale:.7,weight:.3},blend:"multiply",travel:"radial",travelSpeed:2,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.5,softness:1.2}},rotate:[{axis:"z",rotations:.5,phase:0},{axis:"z",rotations:-.4,phase:120},{axis:"z",rotations:.6,phase:240}],scaleVariance:.25,lifetimeVariance:.15,blending:"normal",renderOrder:4,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:2.5,arcCount:2}}}}},{type:"surface",pattern:"crown",embedDepth:.1,cameraFacing:.35,clustering:.3,count:8,scale:1.1,models:["void-crack","shadow-tendril","corruption-patch","void-shard"],minDistance:.08,animation:{appearAt:.05,disappearAt:.85,stagger:.02,enter:{type:"grow",duration:.06,easing:"easeOutQuad"},exit:{type:"shrink",duration:.08,easing:"easeInCubic"},pulse:{amplitude:.12,frequency:3,easing:"easeIn"},emissive:{min:.1,max:.4,frequency:4,pattern:"sine"},drift:{direction:"inward",speed:.035,noise:.1},rotate:{axis:"y",speed:.12,oscillate:!1},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:1,modelOverrides:{"void-crack":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.6},y:{expand:!0,rate:1.4},z:{expand:!0,rate:.8}}},drift:{direction:"inward",speed:.04,noise:.1}},"shadow-tendril":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.7},y:{expand:!0,rate:1.8},z:{expand:!1,rate:.7}},wobbleFrequency:3,wobbleAmplitude:.15},drift:{direction:"inward",speed:.035}},"corruption-patch":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.5},y:{expand:!1,rate:.5},z:{expand:!0,rate:1.5}}},drift:{direction:"inward",speed:.03},orientationOverride:"flat"},"void-shard":{drift:{direction:"inward",speed:.045,noise:.08},opacityLink:"inverse-scale"}}}}],pullStrength:.025,spiralRate:2,glowColor:[.1,.05,.15],glowIntensityMin:.2,glowIntensityMax:.5,glowFlickerRate:8,dimStrength:.4,scaleVibration:.03,scaleFrequency:5,scaleShrink:.15,scalePulse:!0,rotationSpeed:1.2,fadeOut:!0,fadeStartAt:.3,fadeEndAt:.85,fadeCurve:"accelerating",decayRate:.15}),j_=U_({name:"voidsingularity",emoji:"",type:"blending",description:"Collapsing void orb  a singularity consuming all light",duration:3e3,beats:4,intensity:1.5,category:"annihilation",depth:.8,distortionStrength:0,spawnMode:{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},cameraOffset:2.5,orientation:"camera",wander:{radius:.12,speedX:.25,speedZ:.18}},count:1,scale:1.2,models:["void-disk"],animation:{appearAt:0,disappearAt:.88,stagger:0,enter:{type:"scale",duration:.3,easing:"easeOut"},exit:{type:"shrink",duration:.06,easing:"easeInCubic"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.08,frequency:1,easing:"easeInOut"},atmospherics:[{preset:"shadow",targets:null,anchor:"around",intensity:.25,sizeScale:1.2,progressCurve:"rampUp"},{preset:"darkness",targets:["void-disk"],anchor:"around",intensity:.7,sizeScale:.6,speedScale:.1,lifetimeScale:.4,progressCurve:"sustain",gravity:{strength:1.8,spawnRadius:.4}}],scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:3,modelOverrides:{"void-disk":{diskMode:!0}}}},jitterAmount:0,jitterFrequency:0,decayRate:.15,glowColor:[.15,.05,.25],glowIntensityMin:.7,glowIntensityMax:1,glowFlickerRate:1.5,dimStrength:.45,scaleVibration:.01,scaleFrequency:1,scalePulse:!0,rotationDrift:.003}),X_=U_({name:"voidcrown",emoji:"",type:"blending",description:"Dark void ring hovering above the head, absorbing light",duration:3e3,beats:4,intensity:1,mascotGlow:.2,category:"manifestation",depth:.6,distortionStrength:0,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.25}},count:1,scale:.85,models:["void-crown"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.02,frequency:1.5,easing:"easeInOut"},rotate:{axis:"z",rotations:.5,phase:0},atmospherics:[{preset:"darkness",targets:["void-crown"],anchor:"above",intensity:.5,sizeScale:1.2,progressCurve:"sustain"}],cutout:{strength:.35,primary:{pattern:6,scale:.8,weight:.7},secondary:{pattern:3,scale:1,weight:.3},blend:"multiply",travel:"angular",travelSpeed:.8,strengthCurve:"bell",trailDissolve:{enabled:!0,offset:-.4,softness:1.2}},scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:3,modelOverrides:{"void-crown":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:.5,arcCount:2},orientationOverride:"flat"}}}},jitterAmount:0,jitterFrequency:0,decayRate:.2,glowColor:[.25,.1,.35],glowIntensityMin:.5,glowIntensityMax:.7,glowFlickerRate:1.5,dimStrength:.25,scaleVibration:.005,scaleFrequency:2,scalePulse:!0,rotationDrift:.008}),Y_=U_({name:"voiddance",emoji:"",type:"blending",description:"Vertical void rings dancing and rising",duration:1500,beats:3,intensity:1.3,category:"manifestation",depth:.5,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.8,startDiameter:1.3,endDiameter:2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["void-wrap"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:.3,max:.8,frequency:6,pattern:"sine"},cutout:{strength:.45,primary:{pattern:6,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.6},blend:"add",travel:"spiral",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28},trailDissolve:{enabled:!0,offset:-.8,softness:2}},atmospherics:[{preset:"darkness",targets:null,anchor:"around",intensity:.5,sizeScale:1.2,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:3,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:2,arcCount:2},orientationOverride:"flat"}}}},jitterAmount:0,jitterFrequency:0,decayRate:.2,glowColor:[.3,.15,.4],glowIntensityMin:.5,glowIntensityMax:.65,glowFlickerRate:2,dimStrength:.2,scaleVibration:.018,scaleFrequency:4,scalePulse:!0,rotationDrift:.005}),$_=U_({name:"voidhelix",emoji:"",type:"blending",description:"DNA double helix of void fragments counter-spiraling upward",duration:2e3,beats:4,intensity:1.2,category:"manifestation",depth:.6,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.7,endScale:2,startDiameter:.4,endDiameter:3,orientation:"camera"},formation:{type:"spiral",count:10,strands:2,spacing:.08,arcOffset:180,phaseOffset:.03},count:10,scale:1.2,models:["void-wrap","void-orb","void-wrap","void-crack","void-wrap","void-orb","void-wrap","void-crack","void-wrap","void-orb"],animation:{appearAt:0,disappearAt:.4,stagger:.02,enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.12,frequency:4,easing:"easeInOut",perElement:!0},emissive:{min:.15,max:.55,frequency:4,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:1,weight:.7},secondary:{pattern:3,scale:.8,weight:.5},blend:"multiply",travel:"angular",travelSpeed:3,strengthCurve:"bell",bellPeakAt:.5,trailDissolve:{enabled:!0,offset:-.5,softness:1.5}},atmospherics:[{preset:"darkness",targets:null,anchor:"around",intensity:.6,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:[{axis:"y",rotations:4,phase:0},{axis:"y",rotations:-4,phase:180},{axis:"y",rotations:4,phase:0},{axis:"y",rotations:-4,phase:180},{axis:"y",rotations:4,phase:0},{axis:"y",rotations:-4,phase:180},{axis:"y",rotations:4,phase:0},{axis:"y",rotations:-4,phase:180},{axis:"y",rotations:4,phase:0},{axis:"y",rotations:-4,phase:180}],scaleVariance:.3,lifetimeVariance:.1,blending:"normal",renderOrder:3,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:2,arcCount:2}},"void-orb":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.8,arcCount:1}},"void-crack":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1.2,arcCount:3}}}}},jitterAmount:0,jitterFrequency:0,decayRate:.2,glowColor:[.25,.1,.35],glowIntensityMin:.5,glowIntensityMax:.8,glowFlickerRate:3,dimStrength:.25,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,rotationDrift:.01});const Q_={appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.05,frequency:3,easing:"easeInOut"},emissive:{min:.3,max:.7,frequency:4,pattern:"sine"},atmospherics:[{preset:"darkness",targets:["void-wrap"],anchor:"above",intensity:.6,sizeScale:1.4,progressCurve:"sustain",velocityInheritance:.5}],scaleVariance:.03,lifetimeVariance:.02,blending:"normal",renderOrder:3,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"flat"}}};var K_=U_({name:"voidpillar",emoji:"",type:"blending",description:"Majestic column of void rings",duration:2500,beats:4,intensity:1.2,mascotGlow:.2,category:"manifestation",depth:.65,distortionStrength:.008,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:0},formation:{type:"stack",count:2,spacing:.25},count:2,scale:2.2,models:["void-wrap"],animation:{...Q_,stagger:.03,cutout:{strength:.4,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.4},blend:"add",travel:"angular",travelSpeed:1.2,strengthCurve:"fadeIn",fadeInDuration:.3,geometricMask:{type:"distance",core:.1,tip:.25},trailDissolve:{enabled:!0,offset:-.5,softness:1.2}},rotate:[{axis:"z",rotations:.3,phase:0},{axis:"z",rotations:.3,phase:180}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:.5},formation:{type:"stack",count:2,spacing:.25},count:2,scale:2.2,models:["void-wrap"],animation:{...Q_,stagger:.05,cutout:{strength:.45,primary:{pattern:7,scale:1.8,weight:1},secondary:{pattern:3,scale:1.5,weight:.5},blend:"multiply",travel:"radial",travelSpeed:1.8,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"tip-boost",core:0,tip:.2},trailDissolve:{enabled:!0,offset:-.4,softness:1.5}},rotate:[{axis:"z",rotations:-.6,phase:60},{axis:"z",rotations:-.6,phase:240}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:1},formation:{type:"stack",count:2,spacing:.25},count:2,scale:2.2,models:["void-wrap"],animation:{...Q_,stagger:.07,cutout:{strength:.5,primary:{pattern:6,scale:1.5,weight:1},secondary:{pattern:3,scale:2,weight:.4},blend:"add",travel:"oscillate",travelSpeed:2.5,strengthCurve:"fadeOut",fadeOutDuration:.4,geometricMask:{type:"distance",core:.15,tip:.3},trailDissolve:{enabled:!0,offset:-.3,softness:1.8}},rotate:[{axis:"z",rotations:.9,phase:90},{axis:"z",rotations:.9,phase:270}]}}],jitterAmount:0,jitterFrequency:0,decayRate:.2,glowColor:[.2,.08,.3],glowIntensityMin:.55,glowIntensityMax:.85,glowFlickerRate:2.5,dimStrength:.3,scaleVibration:.008,scaleFrequency:2,scalePulse:!0,rotationDrift:.005}),Z_=U_({name:"voiddrill",emoji:"",type:"blending",description:"Fast tight void helix drilling downward",duration:1200,beats:2,intensity:1.5,category:"manifestation",depth:.75,distortionStrength:0,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"flat"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:.8,models:["void-wrap"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},pulse:{amplitude:.08,frequency:10,easing:"linear"},emissive:{min:.4,max:1,frequency:12,pattern:"random"},atmospherics:[{preset:"darkness",targets:null,anchor:"below",intensity:.5,sizeScale:1.3,speedScale:.5,progressCurve:"rampUp",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:3,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.4,arcSpeed:4,arcCount:1},orientationOverride:"flat"}}}},jitterAmount:0,jitterFrequency:0,decayRate:.15,glowColor:[.15,.05,.25],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:6,dimStrength:.4,scaleVibration:.02,scaleFrequency:4,scalePulse:!0,rotationDrift:.02}),J_=U_({name:"voidflourish",emoji:"",type:"blending",description:"Dark void flourish  sweeping arcs of consumed light",duration:1200,beats:4,intensity:1.3,mascotGlow:.2,category:"manifestation",depth:.55,distortionStrength:.003,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.8,endScale:1.3,startDiameter:1,endDiameter:2,orientation:"camera"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:.08,zOffset:0},count:3,scale:.4,models:["void-ring"],animation:{appearAt:0,disappearAt:.5,stagger:.1,enter:{type:"fade",duration:.04,easing:"easeOut"},exit:{type:"burst-fade",duration:.7,easing:"easeIn",burstScale:1.1},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.7,primary:{pattern:6,scale:1.5,weight:.8},secondary:{pattern:3,scale:.8,weight:.4},blend:"multiply",travel:"spiral",travelSpeed:2,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.5,softness:1.5}},pulse:{amplitude:.12,frequency:5,easing:"easeInOut",perElement:!0},emissive:{min:.3,max:.7,frequency:4,pattern:"sine"},drift:{speed:.25,distance:.15,pattern:"radial",accelerate:!0},opacityGradient:[1,.85,.7],rotate:[{axis:"z",rotations:2,phase:0},{axis:"z",rotations:-1.5,phase:120},{axis:"z",rotations:1.8,phase:240}],tilt:{axis:"y",oscillate:!0,range:.3,speed:3},wobble:{axis:"x",oscillate:!0,range:.1,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:3,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.25,arcSpeed:3,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"darkness",targets:["void-ring"],anchor:"around",intensity:.5,sizeScale:1,progressCurve:"sustain"}]}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.5,y:.3,z:0},orientation:"camera",startScale:.3,endScale:1,scaleEasing:"easeOutCubic"},count:1,scale:.7,models:["void-wrap"],animation:{appearAt:.1,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:0,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.5,softness:1.5}},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:.8,phase:-45}],blending:"normal",renderOrder:5,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.4,arcSpeed:1.5,arcCount:2}}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.5,y:.3,z:0},orientation:"camera",startScale:.3,endScale:1,scaleEasing:"easeOutCubic"},count:1,scale:.7,models:["void-wrap"],animation:{appearAt:.1,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:0,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.5,softness:1.5}},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:.8,phase:45}],blending:"normal",renderOrder:5,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.4,arcSpeed:1.5,arcCount:2}}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.3,endScale:2.2,scaleEasing:"easeOutExpo"},count:1,scale:.75,models:["void-ring"],animation:{appearAt:.25,disappearAt:.65,enter:{type:"fade",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.5,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.6,softness:1.8}},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"normal",renderOrder:2,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.2,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.3,endScale:2.2,scaleEasing:"easeOutExpo"},count:1,scale:.75,models:["void-ring"],animation:{appearAt:.25,disappearAt:.65,enter:{type:"fade",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.5,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.6,softness:1.8}},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"normal",renderOrder:2,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.2,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}}],jitterAmount:0,jitterFrequency:0,decayRate:.2,glowColor:[.3,.15,.4],glowIntensityMin:.5,glowIntensityMax:.75,glowFlickerRate:2,dimStrength:.2,scaleVibration:.012,scaleFrequency:3,scalePulse:!0,rotationDrift:.008}),eA=U_({name:"voidvortex",emoji:"",type:"blending",description:"Dark void tornado spiraling around mascot",duration:1500,beats:5,intensity:1.3,category:"manifestation",depth:.7,distortionStrength:.003,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.5,startDiameter:.6,endDiameter:2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1.5,models:["void-wrap"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:.3,max:.8,frequency:5,pattern:"sine"},cutout:{strength:.4,primary:{pattern:6,scale:1.5,weight:.8},secondary:{pattern:3,scale:1,weight:.5},blend:"multiply",travel:"spiral",travelSpeed:3,strengthCurve:"bell",bellPeakAt:.5,trailDissolve:{enabled:!0,offset:-.6,softness:1.8}},atmospherics:[{preset:"darkness",targets:null,anchor:"around",intensity:.6,sizeScale:1.5,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:3,modelOverrides:{"void-wrap":{shaderAnimation:{type:1,arcWidth:.3,arcSpeed:4,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}}}},jitterAmount:0,jitterFrequency:0,decayRate:.2,glowColor:[.2,.08,.3],glowIntensityMin:.6,glowIntensityMax:1,glowFlickerRate:4,dimStrength:.35,scaleVibration:.015,scaleFrequency:3,scalePulse:!0,rotationDrift:.015}),tA=U_({name:"voidbarrage",emoji:"",type:"blending",description:"Void orbs orbit mascot then launch outward",duration:1500,beats:4,intensity:1.4,category:"manifestation",depth:.7,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.6,models:["void-orb","void-shard","shadow-tendril"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.1,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.2},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:.2,max:.7,frequency:4,pattern:"sine"},atmospherics:[{preset:"darkness",targets:null,anchor:"around",intensity:.5,sizeScale:1.2,progressCurve:"sustain",velocityInheritance:.6}],rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"normal",renderOrder:3}},jitterAmount:0,jitterFrequency:0,decayRate:.2,glowColor:[.2,.05,.3],glowIntensityMin:.6,glowIntensityMax:1.2,glowFlickerRate:6,dimStrength:.35,scaleVibration:.012,scaleFrequency:4,scalePulse:!0}),nA=U_({name:"voidimpact",emoji:"",type:"blending",description:"Void orbs converge inward to strike the mascot",duration:1500,beats:4,intensity:1.5,category:"manifestation",depth:.8,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"center",radius:2.5,endRadius:.5,speed:2,easing:"easeOut",startScale:.6,endScale:1.3,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.6,models:["void-orb","void-crack","corruption-patch"],animation:{appearAt:0,disappearAt:.65,stagger:.03,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"shrink",duration:.1,easing:"easeInCubic"},procedural:{scaleSmoothing:.06,geometryStability:!0},pulse:{amplitude:.12,frequency:6,easing:"easeIn"},emissive:{min:.3,max:1,frequency:5,pattern:"sine"},atmospherics:[{preset:"darkness",targets:null,anchor:"around",intensity:.6,sizeScale:1.4,progressCurve:"rampUp",velocityInheritance:.5}],rotate:[{axis:"y",rotations:2,phase:0},{axis:"x",rotations:-2.5,phase:72},{axis:"z",rotations:3,phase:144},{axis:"y",rotations:-2,phase:216},{axis:"x",rotations:2.5,phase:288}],scaleVariance:.15,lifetimeVariance:.08,blending:"normal",renderOrder:3}},jitterAmount:0,jitterFrequency:0,decayRate:.15,glowColor:[.15,.02,.25],glowIntensityMin:.7,glowIntensityMax:1.5,glowFlickerRate:8,dimStrength:.4,scaleVibration:.02,scaleFrequency:5,scalePulse:!0});const aA={landmark:"center",orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},iA={disappearAt:.85,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},blending:"normal",renderOrder:10,atmospherics:[{preset:"shadow",intensity:.15,sizeScale:.5,progressCurve:"sustain"}],relay:{count:3,arcWidth:Math.PI,floor:.5}};function rA(e,t,n,a,i,r=0){const s=.866,o=e=>Math.round(100*e)/100;return[{x:0,y:e,relay:i[0],arc:4.71,dir:-1},{x:s*e,y:-.5*e,relay:i[1],arc:3.14,dir:1},{x:-s*e,y:-.5*e,relay:i[2],arc:0,dir:-1},{x:0,y:-e,relay:i[0],arc:4.71,dir:1},{x:-s*e,y:.5*e,relay:i[1],arc:3.14,dir:-1},{x:s*e,y:.5*e,relay:i[2],arc:0,dir:1}].map(e=>({type:"anchor",anchor:{...aA,offset:{x:o(e.x),y:o(e.y),z:0}},count:1,scale:t,sizeVariance:0,models:["void-ring"],animation:{...iA,appearAt:r,rotate:[{axis:"z",rotations:e.dir*n,phase:0}],modelOverrides:{"void-ring":{arcPhase:(e.arc+a)%6.28,relayIndex:e.relay,orientationOverride:"camera"}}}}))}var sA=U_({name:"voidmeditation",emoji:"",type:"blending",description:"Triple void hexagon mandala  three concentric relay hexagons with differential rotation",duration:3e3,beats:6,intensity:1.5,mascotGlow:.2,category:"emanating",entropy:.3,distortionStrength:0,spawnMode:[...rA(.28,.7,2,0,[0,1,2],0),...rA(.52,1.15,-1.5,2.09,[1,2,0],.08),...rA(.78,1.55,1,4.19,[2,0,1],.16),...rA(.28,.7,-2,3.14,[0,1,2],0),...rA(.52,1.15,1.5,5.23,[1,2,0],.08),...rA(.78,1.55,-1,1.05,[2,0,1],.16)],glowColor:[.3,.1,.5],glowIntensityMin:.4,glowIntensityMax:.8,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:2,scaleContract:.02,tremor:.002,tremorFrequency:3,shakeAmount:.003,shakeFrequency:4,decayRate:.1}),oA=U_({name:"voidtwirl",emoji:"",type:"blending",description:"Relay void illusion  arc weaves through three interlocked rings",duration:1500,beats:2,intensity:1.5,category:"afflicted",growth:.9,distortionStrength:0,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["void-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"shadow",intensity:.2,sizeScale:.6,progressCurve:"sustain"}],modelOverrides:{"void-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["void-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"void-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.52,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["void-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"void-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[.25,.1,.35],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.006,tremorFrequency:8,shakeAmount:.01,shakeFrequency:12,decayRate:.15});const lA={disappearAt:.9,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:3,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.3,speed:.2,blend:"multiply"},blending:"normal"};var cA=U_({name:"voidshield",emoji:"",type:"blending",description:"Gyroscopic void cage  six tumbling rings form a protective darkness",duration:3e3,beats:4,intensity:1,mascotGlow:.2,category:"manifestation",depth:.65,distortionStrength:0,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.3}},count:1,scale:1.5,models:["void-ring"],animation:{...lA,appearAt:0,rotate:{axis:"x",rotations:.75,phase:0},renderOrder:6,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.35}},count:1,scale:1.5,models:["void-ring"],animation:{...lA,appearAt:.03,rotate:{axis:"y",rotations:-.75,phase:0},renderOrder:8,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.4}},count:1,scale:1.5,models:["void-ring"],animation:{...lA,appearAt:.06,rotate:{axis:"x",rotations:.75,phase:60},renderOrder:10,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.45}},count:1,scale:1.5,models:["void-ring"],animation:{...lA,appearAt:.09,rotate:{axis:"y",rotations:-.75,phase:120},renderOrder:12,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.38}},count:1,scale:1.5,models:["void-ring"],animation:{...lA,appearAt:.12,rotate:{axis:"x",rotations:.75,phase:45},renderOrder:14,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.42}},count:1,scale:1.5,models:["void-ring"],animation:{...lA,appearAt:.15,rotate:{axis:"y",rotations:-.75,phase:-45},atmospherics:[{preset:"darkness",targets:["void-ring"],anchor:"around",intensity:.2,sizeScale:.7,progressCurve:"sustain"}],renderOrder:16,modelOverrides:{"void-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.55,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[.2,.08,.3],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,tremor:.002,tremorFrequency:2,decayRate:.2});function hA(e){return(43758.5453*Math.sin(e)%1+1)%1}function dA(e){const t=Math.floor(e),n=e-t,a=n*n*(3-2*n);return hA(t)*(1-a)+hA(t+1)*a}function uA(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"transform"===e.category?1.4:1.2,offBeat:1,curve:"smooth"}},"3d":{evaluate(t,n){const a={...e,...n},i=t*a.duration/1e3,{category:r}=a;let s=1;"afflicted"===r&&(t<.2&&(s=t/.2),a.frostDecay&&(s*=1-.6*t)),"emanating"===r&&(s*=.2*Math.sin(i*Math.PI*2)+.8),"transform"===r&&(s=a.shatterPoint&&t>a.shatterPoint?1-(t-a.shatterPoint)/(1-a.shatterPoint):Math.min(1,t/.3));const o=a.decayRate||.15;t>1-o&&(s*=1-(t-(1-o))/o);let l=a.frost||.5;a.frostDecay&&(l*=1-.7*t);let c=0,h=0,d=0;if(a.tremor>0){let e=a.tremor;a.tremorDecay&&(e*=1-t*a.tremorDecay);const n=i*(a.tremorFrequency||8);c+=(dA(n)-.5)*e*s,h+=(dA(n+50)-.5)*e*s*.5,d+=(dA(n+100)-.5)*e*s*.3}if(a.shiverAmount>0){const e=i*(a.shiverFrequency||12);c+=Math.sin(e*Math.PI*2)*a.shiverAmount*s,h+=Math.cos(e*Math.PI*3.1)*a.shiverAmount*.5*s}if(a.jitterAmount>0){const e=i*(a.jitterFrequency||15);hA(Math.floor(e))>.7&&(c+=(hA(e)-.5)*a.jitterAmount*s,h+=(hA(e+10)-.5)*a.jitterAmount*.5*s)}if(a.droopAmount>0){const e=t*(1+(a.droopAcceleration||.3)*t);h-=a.droopAmount*e*s}if(a.explosionForce>0&&a.shatterPoint&&t>a.shatterPoint){const e=(t-a.shatterPoint)/(1-a.shatterPoint),n=a.explosionForce*e;c+=(dA(20*i)-.5)*n,h+=(dA(20*i+33)-.5)*n,d+=(dA(20*i+66)-.5)*n}let u=1;const p=i*(a.scaleFrequency||3);a.scalePulse?u=1+(.5*Math.sin(p*Math.PI*2)+.5-.5)*(a.scaleVibration||.015)*s:a.scaleVibration&&(u=1+(.6*Math.sin(p*Math.PI*2)+.4*Math.sin(p*Math.PI*2.7))*a.scaleVibration*s),a.scaleContract>0&&(u-=a.scaleContract*t*s),a.scaleExpand>0&&(u+=a.scaleExpand*t*s),a.scaleGrow>0&&(u+=a.scaleGrow*t*s),a.shatterPoint&&t>a.shatterPoint&&(u+=.1*(dA(15*i)-.5)),u=Math.max(.1,u);let m=0,f=0,g=0;if(a.rotationSpeed>0&&(f=i*a.rotationSpeed*Math.PI*2*s),a.rotationWobble>0){const e=i*(a.rotationWobbleSpeed||1.5);m=Math.sin(e*Math.PI*2)*a.rotationWobble*s,g=Math.sin(e*Math.PI*1.7+.5)*a.rotationWobble*.7*s}const y=i*(a.glowFlickerRate||2);let v;v=a.shatterPoint&&t>a.shatterPoint?1+.5*hA(5*y):.3*Math.sin(y*Math.PI*2)+.7;const b=(a.glowIntensityMin||.5)+((a.glowIntensityMax||.8)-(a.glowIntensityMin||.5))*v*s,w=.15*s*a.intensity*l+(a.mascotGlow||0)*s;return{iceOverlay:{enabled:s>.1,strength:s*a.intensity,frost:l,category:a.category,spawnMode:a.spawnMode||null,time:i,progress:t,duration:a.duration,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth},position:[c,h,d],rotation:[m,f,g],scale:u,glowIntensity:b,glowBoost:w,glowColorOverride:a.glowColor}}}}}var pA=uA({name:"icecrown",emoji:"",type:"blending",description:"Majestic ice crown above the head",duration:3e3,beats:4,intensity:1,mascotGlow:.3,category:"transform",frost:.65,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.3}},count:1,scale:1,models:["ice-crown"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.02,frequency:2,easing:"easeInOut"},atmospherics:[{preset:"mist",targets:["ice-crown"],anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain"}],rotate:{axis:"z",rotations:1,phase:0},scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:15}},glowColor:[.6,.85,1],glowIntensityMin:.8,glowIntensityMax:.8,glowFlickerRate:0,scaleVibration:.003,scaleFrequency:3,scaleGrowth:.005,tremor:0,tremorFrequency:0,tremorDecay:0}),mA=uA({name:"icedance",emoji:"",type:"blending",description:"Vertical ice crystals dancing and rising",duration:1500,beats:3,intensity:1.3,category:"transform",frost:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.6,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["ice-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.65,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:1.2,weight:.5},blend:"add",travel:"angular",travelSpeed:2,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28}},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],parameterAnimation:{frost:{start:.5,peak:.75,end:.55,curve:"bell"}},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:.8,max:1.6,frequency:6,pattern:"sine"},rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:11,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.5,.8,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.018,scaleFrequency:4,scaleGrowth:.025,tremor:.005,tremorFrequency:3});const fA={appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{frost:{start:.55,peak:.85,end:.65,curve:"bell"}},pulse:{amplitude:.05,frequency:3,easing:"easeInOut"},emissive:{min:.9,max:1.8,frequency:4,pattern:"sine"},grain:{type:3,strength:.35,scale:.2,speed:1.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:["ice-ring"],anchor:"below",anchorOffset:-.1,intensity:.4,sizeScale:1.5,progressCurve:"sustain"}],scaleVariance:.03,lifetimeVariance:.02,blending:"normal",renderOrder:15,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.8,arcCount:2}}}};var gA=uA({name:"icepillar",emoji:"",type:"blending",description:"Majestic rising pillar of ice",duration:3e3,beats:4,intensity:1.3,mascotGlow:.4,category:"transform",frost:.8,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:0},count:1,scale:1.6,models:["ice-ring"],animation:{...fA,cutout:{strength:.55,primary:{pattern:0,scale:1.2,weight:1},secondary:{pattern:8,scale:1.5,weight:.4},blend:"add",travel:"angular",travelSpeed:1.2,strengthCurve:"fadeIn",fadeInDuration:.3,geometricMask:{type:"distance",core:.1,tip:.25}},rotate:{axis:"z",rotations:.3,phase:0}}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:.5},count:1,scale:1.6,models:["ice-ring"],animation:{...fA,cutout:{strength:.6,primary:{pattern:8,scale:1.4,weight:1},secondary:{pattern:3,scale:1.2,weight:.5},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"tip-boost",core:0,tip:.2}},rotate:{axis:"z",rotations:-.5,phase:60}}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:1},count:1,scale:1.6,models:["ice-ring"],animation:{...fA,cutout:{strength:.65,primary:{pattern:3,scale:1.3,weight:1},secondary:{pattern:7,scale:1.5,weight:.4},blend:"add",travel:"oscillate",travelSpeed:2,strengthCurve:"fadeOut",fadeOutDuration:.4,geometricMask:{type:"distance",core:.15,tip:.3}},rotate:{axis:"z",rotations:.7,phase:90}}}],glowColor:[.55,.8,1],glowIntensityMin:.8,glowIntensityMax:1.6,glowFlickerRate:5,scaleVibration:.008,scaleFrequency:3,scaleGrowth:.025,tremor:.002,tremorFrequency:2}),yA=uA({name:"icehelix",emoji:"",type:"blending",description:"DNA-style double helix ascending ice",duration:2e3,beats:4,intensity:1.2,category:"transform",frost:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.8,endScale:1.1,startDiameter:1.6,endDiameter:1.8,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:1.2,models:["ice-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.5,peak:.85,end:.6,curve:"bell"}},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:.9,max:2,frequency:6,pattern:"smooth"},cutout:{strength:.7,primary:{pattern:8,scale:1.5,weight:1},secondary:{pattern:3,scale:1.2,weight:.5},blend:"max",travel:"angular",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.15,scale:.2,speed:1,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.2,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.6,.85,1],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:8,scaleVibration:.012,scaleFrequency:5,scaleGrowth:.02,tremor:.003,tremorFrequency:4}),vA=uA({name:"icemeditation",emoji:"",type:"blending",description:"Dual ice weave  icetwirl hexagon",duration:4e3,beats:8,intensity:.7,mascotGlow:.4,category:"emanating",frost:.5,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"mist",intensity:.15,sizeScale:.5,progressCurve:"sustain"}],modelOverrides:{"ice-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:1.05,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:4.19,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:2.62,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:1.05,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:4.19,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:2.62,relayIndex:1,orientationOverride:"camera"}}}}],glowColor:[.6,.85,1],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:2,scaleVibration:0,scaleFrequency:0,scaleContract:0,tremor:0,tremorFrequency:0,shakeAmount:0,shakeFrequency:0,decayRate:.15}),bA=uA({name:"icevortex",emoji:"",type:"blending",description:"Ice tornado spiraling around mascot",duration:1500,beats:5,intensity:1.4,category:"transform",frost:.8,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.5,startDiameter:.6,endDiameter:2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1.5,models:["ice-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.1},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.5,peak:.9,end:.6,curve:"bell"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2,frequency:5,pattern:"sine"},grain:{type:3,strength:.2,scale:.3,speed:2.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.6,centrifugal:{speed:1.2,tangentialBias:.3}}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:12,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:5,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}}}},glowColor:[.4,.75,1],glowIntensityMin:1.2,glowIntensityMax:2.2,glowFlickerRate:6,scaleVibration:.02,scaleFrequency:4,scaleGrowth:.03,tremor:.008,tremorFrequency:5}),wA=uA({name:"icesplash",emoji:"",type:"blending",description:"Explosive ice shatter with crystals and frost spray",duration:1e3,beats:2,intensity:1.3,category:"transform",frost:.85,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.2,endScale:2,scaleEasing:"easeOutQuad"},count:1,scale:1.3,models:["crystal-cluster"],animation:{appearAt:0,disappearAt:.4,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.6,primary:{pattern:2,scale:1.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1.2,strengthCurve:"fadeOut"},grain:{type:3,strength:.4,scale:.3,speed:1.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain"}],blending:"normal",renderOrder:8,rotate:{axis:"z",rotations:0,phase:0},modelOverrides:{"crystal-cluster":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["ice-spike"],animation:{appearAt:0,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.4,distance:.8,direction:{x:0,y:1,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:12,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:.9,models:["ice-spike"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:-.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:12,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:.9,models:["ice-spike"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:12,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.8,models:["ice-spike"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:8,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:-.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:11,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.8,models:["ice-spike"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:8,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:11,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:8,radius:.05,endRadius:.65,angleSpread:360,startAngle:22,orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:8,scale:.5,models:["crystal-small"],animation:{appearAt:.02,disappearAt:.4,stagger:.008,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.4,primary:{pattern:3,scale:.7,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.3,lifetimeVariance:.15,blending:"normal",renderOrder:14,modelOverrides:{"crystal-small":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:12,radius:.03,endRadius:.5,angleSpread:360,startAngle:0,orientation:"camera",startScale:.1,endScale:.35,scaleEasing:"easeOutQuad"},count:12,scale:.2,models:["crystal-small"],animation:{appearAt:.01,disappearAt:.3,stagger:.005,enter:{type:"scale",duration:.02,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.3,primary:{pattern:7,scale:.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.5,lifetimeVariance:.25,blending:"normal",renderOrder:16,modelOverrides:{"crystal-small":{shaderAnimation:{type:1,arcWidth:.98,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.1,z:.12},orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:1,scale:.6,models:["crystal-cluster"],animation:{appearAt:.05,disappearAt:.6,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.5,primary:{pattern:3,scale:1.2,weight:1},blend:"multiply",travel:"radial",travelSpeed:.5,strengthCurve:"constant"},pulse:{amplitude:.1,frequency:8,easing:"easeInOut"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:6,modelOverrides:{"crystal-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:2},orientationOverride:"camera"}}}}],glowColor:[.5,.8,1],glowIntensityMin:1,glowIntensityMax:2.2,glowFlickerRate:6,scaleVibration:.035,scaleFrequency:7,scaleGrowth:.015,tremor:.01,tremorFrequency:8}),xA=uA({name:"iceencase",emoji:"",type:"blending",description:"Ice crystals growing on mascot surface, encasing in ice",duration:3500,beats:5,intensity:1.2,mascotGlow:.5,category:"transform",frost:.85,spawnMode:{type:"surface",pattern:"shell",embedDepth:.2,cameraFacing:.4,clustering:.1,count:10,scale:1.8,minDistance:.1,models:["crystal-cluster","crystal-medium","crystal-small","ice-spike"],animation:{appearAt:.05,disappearAt:.9,stagger:.04,enter:{type:"grow",duration:.12,easing:"easeOutQuad"},exit:{type:"shrink",duration:.15,easing:"easeInQuad"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{frost:{start:.5,peak:.9,end:.7,curve:"fadeIn"}},pulse:{amplitude:.05,frequency:1.2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:.9,frequency:1.5,pattern:"sine"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1.2,progressCurve:"sustain"}],cutout:{edgeMask:.3},rotate:{axis:"y",speed:.008,oscillate:!0,range:Math.PI/16},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:6,intensityScaling:{scale:1.25,emissiveMax:1.2},modelOverrides:{"crystal-small":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1},y:{expand:!0,rate:1.4},z:{expand:!0,rate:1}},easing:"easeOutQuad"}},"crystal-medium":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!0,rate:1.5},z:{expand:!0,rate:1.1}}}},"crystal-cluster":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.3},y:{expand:!0,rate:1.2},z:{expand:!0,rate:1.3}}}},"ice-spike":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.85},y:{expand:!0,rate:1.8},z:{expand:!1,rate:.85}}}}}}},glowColor:[.6,.85,1],glowIntensityMin:.55,glowIntensityMax:.9,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:2,scaleContract:.02,tremor:.004,tremorFrequency:6,tremorDecay:.8,decayRate:.15}),SA=uA({name:"icedrill",emoji:"",type:"blending",description:"Fast tight descending ice helix",duration:1200,beats:2,intensity:1.5,category:"transform",frost:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:1.4,models:["ice-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.8,end:.5,curve:"bell"}},cutout:{strength:.55,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:.8,weight:.35},blend:"add",travel:"vertical",travelSpeed:3,strengthCurve:"constant"},grain:{type:3,strength:.3,scale:.2,speed:4,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],pulse:{amplitude:.08,frequency:10,easing:"linear"},rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.4,.75,1],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03,tremor:.006,tremorFrequency:8}),MA=uA({name:"iceflourish",emoji:"",type:"blending",description:"Spinning ice flourish with crystal trails",duration:1200,beats:4,intensity:1.3,mascotGlow:.3,category:"ambient",frost:.6,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:5,spacing:0,arcOffset:72,phaseOffset:.05,zOffset:0},count:5,scale:1.5,models:["ice-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{frost:{start:.35,peak:.7,end:.2,curve:"bell"}},cutout:{strength:.6,primary:{pattern:3,scale:1,weight:1},secondary:{pattern:8,scale:.6,weight:.5},blend:"multiply",strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.6,softness:1.5}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:["ice-ring"],anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4}],pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.9,.8,.7,.6],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"z",rotations:1.8,phase:144},{axis:"z",rotations:-2.3,phase:216},{axis:"z",rotations:2,phase:288}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",depthWrite:!1,renderOrder:-8,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.2,models:["ice-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},secondary:{pattern:3,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:-45}],blending:"normal",depthWrite:!1,renderOrder:-6,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.2,models:["ice-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},secondary:{pattern:3,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:45}],blending:"normal",depthWrite:!1,renderOrder:-6,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:1.5,models:["ice-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},secondary:{pattern:8,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"normal",depthWrite:!1,renderOrder:-10,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:1.5,models:["ice-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},secondary:{pattern:8,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"normal",depthWrite:!1,renderOrder:-10,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],glowColor:[.5,.8,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.012,scaleFrequency:8,scaleGrowth:.015,tremor:.003,tremorFrequency:4}),_A=uA({name:"icebarrage",emoji:"",type:"blending",description:"Ice crystals orbit mascot then launch upward",duration:1500,beats:4,intensity:1.4,category:"transform",frost:.75,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.4,models:["crystal-cluster","crystal-medium","crystal-small","ice-spike"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.6,peak:.85,end:.4,curve:"fadeOut"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.7}],rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"normal",renderOrder:12}},glowColor:[.5,.8,1],glowIntensityMin:1.2,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.015,scaleFrequency:4,scaleGrowth:.02,tremor:.006,tremorFrequency:5}),AA=uA({name:"iceimpact",emoji:"",type:"blending",description:"Ice crystals orbit then crash inward with impact burst",duration:1500,beats:4,intensity:1.5,category:"transform",frost:.8,spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:3.5,endRadius:.1,speed:3,easing:"easeOut",startScale:.4,endScale:1.8,orientation:"vertical"},formation:{type:"ring",count:7},count:7,scale:1.4,models:["crystal-cluster","crystal-medium","crystal-small","ice-spike"],animation:{appearAt:0,disappearAt:.6,stagger:.02,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.05,easing:"easeOut",burstScale:.2},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{frost:{start:.3,peak:.95,end:.9,curve:"fadeIn"}},pulse:{amplitude:.12,frequency:8,easing:"easeInOut"},emissive:{min:1,max:3,frequency:9,pattern:"sine"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.7}],rotate:[{axis:"z",rotations:-4,phase:0},{axis:"x",rotations:3.5,phase:50},{axis:"y",rotations:-3,phase:100},{axis:"z",rotations:4,phase:155},{axis:"x",rotations:-3.5,phase:210},{axis:"y",rotations:3,phase:260},{axis:"z",rotations:-4.5,phase:315}],scaleVariance:.2,lifetimeVariance:.08,blending:"normal",renderOrder:12}},glowColor:[.45,.75,1],glowIntensityMin:1.6,glowIntensityMax:2.8,glowFlickerRate:10,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.018,tremorFrequency:9}),CA=uA({name:"icemist",emoji:"",type:"blending",description:"Cold mist emanating outward from mascot",duration:3e3,beats:4,intensity:.7,mascotGlow:.3,category:"emanating",frost:.4,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.4,endScale:2.2,startDiameter:.5,endDiameter:2.5,orientation:"camera"},formation:{type:"stack",count:1,spacing:0},count:1,scale:1.3,models:["ice-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"fade",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.2,peak:.5,end:.3,curve:"bell"}},cutout:{strength:.55,primary:{pattern:3,scale:1.2,weight:1},secondary:{pattern:8,scale:1.5,weight:.4},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.3,softness:1.5}},grain:{type:3,strength:.2,scale:.35,speed:.6,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.4,sizeScale:1.5,progressCurve:"sustain"}],pulse:{amplitude:.08,frequency:2,easing:"easeInOut"},emissive:{min:.8,max:1.8,frequency:3,pattern:"sine"},blending:"normal",renderOrder:8,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.2,arcCount:1},orientationOverride:"camera"}}}},glowColor:[.4,.7,1],glowIntensityMin:.6,glowIntensityMax:1.2,glowFlickerRate:3,scaleVibration:.008,scaleFrequency:2,scaleGrowth:.01}),TA=uA({name:"iceshiver",emoji:"",type:"blending",description:"Convulsive cold with frost forming on surface",duration:2500,beats:4,intensity:.9,mascotGlow:.2,category:"afflicted",frost:.5,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.3,clustering:.2,count:8,scale:.9,models:["crystal-small","crystal-medium","crystal-cluster"],minDistance:.1,animation:{appearAt:.05,disappearAt:.85,stagger:.04,enter:{type:"scale",duration:.12,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.2,peak:.6,end:.3,curve:"bell"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:.8,max:1.8,frequency:8,pattern:"sine"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain"}],scaleVariance:.35,lifetimeVariance:.25,delayVariance:.1,blending:"normal",renderOrder:10}},shiverAmount:.015,shiverFrequency:14,glowColor:[.5,.75,1],glowIntensityMin:.8,glowIntensityMax:1.6,glowFlickerRate:10,scaleVibration:.018,scaleFrequency:10,scaleContract:.02,tremor:.012,tremorFrequency:14}),PA=uA({name:"icetwirl",emoji:"",type:"blending",description:"Relay ice illusion  arc weaves through three interlocked rings",duration:1500,beats:2,intensity:1.5,category:"afflicted",growth:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"mist",intensity:.2,sizeScale:.6,progressCurve:"sustain"}],modelOverrides:{"ice-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["ice-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"ice-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[.6,.85,1],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.006,tremorFrequency:8,shakeAmount:.01,shakeFrequency:12,decayRate:.15});const DA={disappearAt:.9,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:3,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.3,speed:.2,blend:"multiply"},blending:"normal"};var OA=uA({name:"iceshield",emoji:"",type:"blending",description:"Gyroscopic ice cage  six tumbling rings form a protective frost barrier",duration:3e3,beats:4,intensity:1,mascotGlow:.4,category:"transform",frost:.65,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.3}},count:1,scale:4.5,models:["ice-ring"],animation:{...DA,appearAt:0,rotate:{axis:"x",rotations:.75,phase:0},renderOrder:6,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.35}},count:1,scale:4.5,models:["ice-ring"],animation:{...DA,appearAt:.03,rotate:{axis:"y",rotations:-.75,phase:0},renderOrder:8,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.4}},count:1,scale:4.5,models:["ice-ring"],animation:{...DA,appearAt:.06,rotate:{axis:"x",rotations:.75,phase:60},renderOrder:10,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.45}},count:1,scale:4.5,models:["ice-ring"],animation:{...DA,appearAt:.09,rotate:{axis:"y",rotations:-.75,phase:120},renderOrder:12,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.38}},count:1,scale:4.5,models:["ice-ring"],animation:{...DA,appearAt:.12,rotate:{axis:"x",rotations:.75,phase:45},renderOrder:14,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.42}},count:1,scale:4.5,models:["ice-ring"],animation:{...DA,appearAt:.15,rotate:{axis:"y",rotations:-.75,phase:-45},atmospherics:[{preset:"mist",targets:["ice-ring"],anchor:"around",intensity:.2,sizeScale:.7,progressCurve:"sustain"}],renderOrder:16,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.55,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[.55,.8,1],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,tremor:.002,tremorFrequency:2,decayRate:.2});function EA(e){return(43758.5453*Math.sin(e)%1+1)%1}function IA(e){const t=Math.floor(e),n=e-t,a=n*n*(3-2*n);return EA(t)*(1-a)+EA(t+1)*a}function kA(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"afflicted"===e.category?1.5:1.3,offBeat:1,curve:"afflicted"===e.category?"sharp":"smooth"}},"3d":{evaluate(t,n){const a={...e,...n},i=t*a.duration/1e3,{category:r}=a;let s=1;if(a.buildupPhase&&t<a.buildupPhase&&(s=Math.pow(t/a.buildupPhase,.7)),"afflicted"!==r||a.buildupPhase||(a.flashPeak?t<a.flashPeak?s=Math.pow(t/a.flashPeak,.5):(s=1-(t-a.flashPeak)*(a.flashDecay||.5),s=Math.max(.3,s)):t<.2&&(s=t/.2)),"emanating"===r&&!a.buildupPhase)if(a.beaconPulse){const e=i*(a.pulseRate||1.5);s=.6+.4*Math.sin(e*Math.PI*2)}else s=Math.min(1,t/.15);"transform"===r&&!a.buildupPhase&&t<.25&&(s=Math.pow(t/.25,.7)),"manifestation"===r&&!a.buildupPhase&&t<.15&&(s=t/.15);const o=a.decayRate||.2;if(t>1-o){const e=(t-(1-o))/o;a.endFlash?s*=1-.99*e:s*=1-e*e}let l=0,c=0,h=0;if(a.riseAmount>0){const e=Math.pow(t,1+(a.ascendAcceleration||0));c+=a.riseAmount*e*s}if(a.floatAmount>0){const e=i*(a.floatSpeed||1);c+=Math.sin(e*Math.PI*2)*a.floatAmount*s}if(a.recoilAmount>0){const e=i*(a.recoilSpeed||2),t=Math.sin(e*Math.PI);h-=a.recoilAmount*t*s}if(a.driftAmount>0){const e=i*(a.driftSpeed||1);l+=(IA(e)-.5)*a.driftAmount*s,c+=(IA(e+50)-.5)*a.driftAmount*.5*s}if(a.tremor>0){const e=i*(a.tremorFrequency||4);l+=(IA(e)-.5)*a.tremor*s,c+=(IA(e+33)-.5)*a.tremor*.5*s}a.hover&&a.hoverAmount&&(c+=Math.sin(i*Math.PI*.5)*a.hoverAmount*s);let d=1;const u=i*(a.scaleFrequency||2);d=a.scalePulse?1+(.5*Math.sin(u*Math.PI*2)+.5-.5)*(a.scaleVibration||.01)*s:1+Math.sin(u*Math.PI*2)*(a.scaleVibration||.01)*s,a.scaleGrow>0&&(d+=a.scaleGrow*t*s),a.scaleShrink>0&&(d-=a.scaleShrink*t*s,d=Math.max(.1,d));let p=0;a.rotationSpeed>0&&(p=i*a.rotationSpeed*Math.PI*2*s),a.rotationDrift&&(p+=i*a.rotationDrift*s);let m=1;if(a.fadeOut){const e=a.fadeStartAt||.4,n=a.fadeEndAt||.9;if(t>=e){const i=Math.min(1,(t-e)/(n-e));m="accelerating"===a.fadeCurve?Math.max(0,1-Math.pow(i,2)):Math.max(0,1-i)}}const f=i*(a.glowFlickerRate||3);let g;g="afflicted"===r&&a.flashPeak?t<2*a.flashPeak?1+.3*Math.sin(f*Math.PI*4):.7+.2*Math.sin(f*Math.PI*2):a.beaconPulse?.4*Math.sin(f*Math.PI*2)+.6:.25*Math.sin(f*Math.PI*2)+.75;const y=a.glowIntensityMin||.8;return{position:[l,c,h],rotation:[0,p,0],scale:d,meshOpacity:m,glowIntensity:y+((a.glowIntensityMax||1.4)-y)*g*s,glowBoost:.4*s*a.intensity*(a.radiance||.5)+(a.mascotGlow||0)*s,glowColorOverride:s>.005?a.glowColor:null,lightOverlay:{enabled:s>.01,strength:s*a.intensity,radiance:a.radiance||.5,category:r,spawnMode:a.spawnMode||null,duration:a.duration,progress:t,time:i,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth,distortionStrength:e.distortionStrength}}}}}}var RA=kA({name:"lightblind",emoji:"",type:"blending",description:"KAAAAZAAAM! Blinding pulsar flash bang  overwhelming radiance",duration:600,beats:1,intensity:2,category:"afflicted",radiance:1,distortionStrength:.8,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.1,endScale:4,scaleEasing:"easeOutQuad"},count:1,scale:2.8,models:["light-burst"],animation:{appearAt:0,disappearAt:.35,enter:{type:"flash",duration:.01,easing:"linear"},exit:{type:"fade",duration:.12,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},pulse:{amplitude:.18,frequency:15,easing:"easeOut"},emissive:{min:2.5,max:4.5,frequency:18,pattern:"sine"},blending:"additive",renderOrder:20}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:4,scaleEasing:"easeOutCubic"},count:1,scale:2.2,models:["light-ring"],animation:{appearAt:.02,disappearAt:.3,enter:{type:"flash",duration:.01,easing:"linear"},exit:{type:"fade",duration:.1,easing:"easeIn"},emissive:{min:1.8,max:3.5,frequency:12,pattern:"sine"},blending:"additive",renderOrder:19,modelOverrides:{"light-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.15,endScale:3,scaleEasing:"easeOutCubic"},count:1,scale:1.8,models:["light-ring"],animation:{appearAt:.06,disappearAt:.35,enter:{type:"flash",duration:.01,easing:"linear"},exit:{type:"fade",duration:.12,easing:"easeIn"},emissive:{min:1.5,max:3,frequency:10,pattern:"sine"},blending:"additive",renderOrder:18,modelOverrides:{"light-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:8,radius:.1,endRadius:2.2,angleSpread:360,startAngle:0,orientation:"camera",startScale:.3,endScale:.9,scaleEasing:"easeOutQuad"},count:8,scale:.9,models:["sparkle-star"],animation:{appearAt:.01,disappearAt:.4,stagger:.003,enter:{type:"flash",duration:.01,easing:"linear"},exit:{type:"fade",duration:.12,easing:"easeIn"},emissive:{min:1.8,max:4,frequency:15,pattern:"sine"},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:1,sizeScale:2.5,progressCurve:"pulse"}],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-3,phase:45},{axis:"z",rotations:3.5,phase:90},{axis:"z",rotations:-2.5,phase:135},{axis:"z",rotations:3,phase:180},{axis:"z",rotations:-3.5,phase:225},{axis:"z",rotations:2.5,phase:270},{axis:"z",rotations:-3,phase:315}],scaleVariance:.3,lifetimeVariance:.1,blending:"additive",renderOrder:21}}],decayRate:.08,endFlash:!0,glowColor:[1,.98,.9],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:12,scaleVibration:.04,scaleFrequency:10,recoilAmount:.02,recoilSpeed:4}),zA=kA({name:"lightpurify",emoji:"",type:"blending",description:"Healing light converges inward, seals, and releases  purifying curse and malady",duration:3e3,beats:5,intensity:1.1,mascotGlow:.5,category:"afflicted",radiance:.7,spawnMode:[{type:"orbit",orbit:{height:"center",endHeight:"center",radius:2.2,endRadius:.3,speed:2,easing:"easeOut",startScale:.5,endScale:1.3,orientation:"camera"},formation:{type:"ring",count:5},count:5,scale:1.2,models:["prism-shard","sparkle-star","prism-shard","sparkle-star","prism-shard"],animation:{appearAt:0,disappearAt:.6,stagger:.04,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"shrink",duration:.12,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},emissive:{min:.8,max:2.5,frequency:3,pattern:"sine"},pulse:{amplitude:.1,frequency:3,easing:"easeInOut"},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:.4,sizeScale:.8,progressCurve:"rampUp",velocityInheritance:.5}],rotate:[{axis:"y",rotations:1.5,phase:0},{axis:"x",rotations:-2,phase:72},{axis:"z",rotations:1.5,phase:144},{axis:"y",rotations:-2,phase:216},{axis:"x",rotations:1.5,phase:288}],scaleVariance:.2,lifetimeVariance:.1,blending:"additive",renderOrder:16}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.1,endScale:1.5,scaleEasing:"easeOutBack"},count:1,scale:1.3,models:["sun-ring"],animation:{appearAt:.25,disappearAt:.7,enter:{type:"scale",duration:.12,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.12,frequency:3,easing:"easeInOut"},emissive:{min:1,max:2.5,frequency:3,pattern:"sine"},rotate:{axis:"z",rotations:.5,phase:0},cutout:{strength:.5,primary:{pattern:6,scale:1.5,weight:1},secondary:{pattern:4,scale:2,weight:.5},blend:"add",travel:"angular",travelSpeed:.8,strengthCurve:"bell",bellPeakAt:.5,bellWidth:1,geometricMask:{type:"distance",core:.1,tip:.3}},grain:{type:3,strength:.2,scale:.4,speed:.5,blend:"multiply"},blending:"additive",renderOrder:14,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.8,arcCount:2},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:3,radius:.1,endRadius:1.2,angleSpread:360,startAngle:40,orientation:"camera",startScale:.4,endScale:.8,scaleEasing:"easeOutQuad"},count:3,scale:.8,models:["sparkle-star"],animation:{appearAt:.4,disappearAt:.7,stagger:.02,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},emissive:{min:1.3,max:2.5,frequency:5,pattern:"sine"},rotate:[{axis:"z",rotations:1,phase:0},{axis:"z",rotations:-1.5,phase:120},{axis:"z",rotations:1,phase:240}],scaleVariance:.25,blending:"additive",renderOrder:18}}],decayRate:.18,glowColor:[1,.92,.65],glowIntensityMin:.6,glowIntensityMax:1.3,glowFlickerRate:4,scaleVibration:.015,scaleFrequency:3,scalePulse:!0}),FA=kA({name:"lightcleanse",emoji:"",type:"blending",description:"Purifying wave of divine light sweeping upward  chase malady, turn undead",duration:2500,beats:4,intensity:.9,mascotGlow:.6,category:"afflicted",radiance:.6,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"linear",startScale:1,endScale:1,startDiameter:1.6,endDiameter:1.6,orientation:"flat"},formation:{type:"stack",count:4,spacing:.08,phaseOffset:.03},count:4,scale:1,models:["sun-ring"],animation:{appearAt:0,disappearAt:.65,stagger:.08,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.06,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:1,max:2,frequency:2.5,pattern:"sine"},rotate:{axis:"z",rotations:.3,phase:0},atmospherics:[{preset:"firefly",targets:null,anchor:"above",intensity:.35,sizeScale:.8,progressCurve:"rampUp",velocityInheritance:.3}],scaleVariance:.05,lifetimeVariance:.05,blending:"additive",renderOrder:15,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"flat"}}}},decayRate:.2,glowColor:[1,.95,.8],glowIntensityMin:.6,glowIntensityMax:1.1,glowFlickerRate:3,scaleVibration:.008,scaleFrequency:2,scalePulse:!0,riseAmount:.006,riseSpeed:.5}),BA=kA({name:"lightradiate",emoji:"",type:"blending",description:"Powerful divine radiance emanating in all directions like a sun",duration:2500,beats:4,intensity:1.4,mascotGlow:.8,category:"emanating",radiance:.9,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:1.2,endScale:1.6,startDiameter:1,endDiameter:1.8,orientation:"flat"},formation:{type:"spiral",count:4,spacing:.05,arcOffset:90,phaseOffset:0},count:4,scale:1.1,models:["sun-ring"],animation:{appearAt:0,disappearAt:.5,stagger:.03,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.12,frequency:4,easing:"easeInOut"},emissive:{min:1.2,max:2.8,frequency:5,pattern:"sine"},atmospherics:[{preset:"firefly",targets:null,anchor:"above",intensity:.5,sizeScale:1.2,progressCurve:"sustain",velocityInheritance:.4}],rotate:{axis:"z",rotations:.6,phase:0},blending:"additive",renderOrder:15,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.75,arcSpeed:1,arcCount:2},orientationOverride:"flat"}}}},{type:"radial-burst",radialBurst:{count:4,radius:.15,endRadius:1.2,angleSpread:360,startAngle:45,orientation:"camera",startScale:.4,endScale:1.5,scaleEasing:"easeOutQuad"},count:4,scale:1.3,models:["light-ray"],animation:{appearAt:.02,disappearAt:.55,stagger:.02,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.2,easing:"easeIn",burstScale:1.2},emissive:{min:1.3,max:2.5,frequency:4,pattern:"sine"},rotate:[{axis:"z",rotations:.5,phase:0},{axis:"z",rotations:-.5,phase:90},{axis:"z",rotations:.5,phase:180},{axis:"z",rotations:-.5,phase:270}],scaleVariance:.2,blending:"additive",renderOrder:17}}],decayRate:.15,glowColor:[1,.88,.5],glowIntensityMin:.8,glowIntensityMax:1.6,glowFlickerRate:5,scaleVibration:.025,scaleFrequency:4,scalePulse:!0,scaleExpand:.02}),LA=kA({name:"lightglow",emoji:"",type:"blending",description:"Gentle inner warmth, barely-there radiance from within",duration:3500,beats:5,intensity:.6,mascotGlow:.5,category:"emanating",radiance:.4,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"center",radius:.8,endRadius:.9,speed:.5,easing:"linear",startScale:.8,endScale:1,orientation:"camera"},formation:{type:"ring",count:3},count:3,scale:.7,models:["sparkle-star","sparkle-star","sparkle-star"],animation:{appearAt:.05,disappearAt:.85,stagger:.08,enter:{type:"fade",duration:.2,easing:"easeInOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.15,geometryStability:!0},pulse:{amplitude:.1,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.6,max:1.2,frequency:1.5,pattern:"sine"},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:.2,sizeScale:.4,progressCurve:"sustain"}],scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:10}},decayRate:.2,glowColor:[1,.9,.7],glowIntensityMin:.5,glowIntensityMax:.9,glowFlickerRate:2,scaleVibration:.008,scaleFrequency:1.5,scalePulse:!0,floatAmount:.003,floatSpeed:1}),NA=kA({name:"lightbeacon",emoji:"",type:"blending",description:"Brilliant signal beacon  layered rings, prism spikes, and orbiting sparkles",duration:3e3,beats:4,intensity:1.1,mascotGlow:.6,category:"emanating",radiance:.8,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",cameraOffset:1,bob:{amplitude:.015,frequency:.25}},count:1,scale:1.8,models:["sun-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.05,frequency:1.5,easing:"easeInOut"},emissive:{min:.8,max:1.5,frequency:2,pattern:"sine"},rotate:{axis:"z",rotations:.2,phase:0},blending:"additive",renderOrder:14,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.3,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",cameraOffset:1,bob:{amplitude:.012,frequency:.3}},count:1,scale:1.5,models:["sun-ring"],animation:{appearAt:0,disappearAt:.8,enter:{type:"fade",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.08,frequency:2,easing:"easeInOut"},emissive:{min:1.5,max:3,frequency:3,pattern:"sine"},rotate:{axis:"z",rotations:-.5,phase:0},cutout:{strength:.3,primary:{pattern:5,scale:.8,weight:.6},secondary:{pattern:0,scale:1.2,weight:.3},blend:"multiply",travel:"angular",travelSpeed:1,strengthCurve:"constant"},grain:{type:3,strength:.1,scale:.25,speed:.5,blend:"multiply"},atmospherics:[{preset:"firefly",targets:["sun-ring"],anchor:"around",intensity:.6,sizeScale:1,progressCurve:"sustain"}],blending:"additive",renderOrder:16,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",cameraOffset:1},formation:{type:"ring",count:3},count:3,scale:.6,models:["prism-shard"],animation:{appearAt:.05,disappearAt:.75,stagger:.04,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.25,easing:"easeIn"},pulse:{amplitude:.15,frequency:3,easing:"easeInOut",perElement:!0,phaseOffset:120},emissive:{min:1,max:2.5,frequency:4,pattern:"sine"},rotate:[{axis:"z",rotations:2,phase:0},{axis:"z",rotations:-2,phase:120},{axis:"z",rotations:2,phase:240}],scaleVariance:.2,blending:"additive",renderOrder:15}},{type:"orbit",orbit:{height:"center",endHeight:"center",radius:1,endRadius:1.3,speed:.5,easing:"linear",startScale:.8,endScale:1,orientation:"camera"},formation:{type:"ring",count:6},count:6,scale:.45,models:["sparkle-star"],animation:{appearAt:.05,disappearAt:.75,stagger:.04,enter:{type:"fade",duration:.12,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},pulse:{amplitude:.25,frequency:5,easing:"easeInOut",perElement:!0,phaseOffset:60},emissive:{min:.8,max:2.5,frequency:6,pattern:"sine"},rotate:[{axis:"z",rotations:1.5,phase:0},{axis:"z",rotations:-1.5,phase:60},{axis:"z",rotations:1.5,phase:120},{axis:"z",rotations:-1.5,phase:180},{axis:"z",rotations:1.5,phase:240},{axis:"z",rotations:-1.5,phase:300}],scaleVariance:.3,lifetimeVariance:.1,blending:"additive",renderOrder:14}}],decayRate:.2,glowColor:[1,.95,.75],glowIntensityMin:.8,glowIntensityMax:1.5,glowFlickerRate:4,scaleVibration:.008,scaleFrequency:2,scalePulse:!0,hover:!0,hoverAmount:.006}),VA=kA({name:"lightascend",emoji:"",type:"blending",description:"Being beamed to heaven  a portal descends and draws light upward",duration:3e3,beats:5,intensity:1.3,mascotGlow:.5,category:"transform",radiance:.85,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"above",end:"top",easing:"easeOut",startScale:1.5,endScale:1.2,startDiameter:2.5,endDiameter:1.8,orientation:"flat"},count:1,scale:1.4,models:["sun-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"fade",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.1,frequency:2,easing:"easeInOut"},emissive:{min:1,max:2.5,frequency:2,pattern:"sine"},rotate:{axis:"z",rotations:.5,phase:0},cutout:{strength:.5,primary:{pattern:6,scale:1.5,weight:1},secondary:{pattern:4,scale:2,weight:.4},blend:"add",travel:"angular",travelSpeed:.8,strengthCurve:"bell",bellPeakAt:.5,bellWidth:1},grain:{type:3,strength:.15,scale:.3,speed:.6,blend:"multiply"},atmospherics:[{preset:"firefly",targets:null,anchor:"above",intensity:.6,sizeScale:1.2,progressCurve:"rampUp",velocityInheritance:.3}],blending:"additive",renderOrder:14,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.8,arcCount:2},orientationOverride:"flat"}}}},{type:"orbit",orbit:{height:"bottom",endHeight:"above",radius:.8,endRadius:.3,speed:2,easing:"easeIn",startScale:.4,endScale:1,orientation:"camera"},formation:{type:"ring",count:5},count:5,scale:.8,models:["sparkle-star"],animation:{appearAt:.05,disappearAt:.65,stagger:.04,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},emissive:{min:1,max:2.8,frequency:4,pattern:"sine"},scaleVariance:.25,lifetimeVariance:.1,blending:"additive",renderOrder:16}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.3,endScale:1.8,scaleEasing:"easeOutQuad"},count:1,scale:1.5,models:["light-burst"],animation:{appearAt:.1,disappearAt:.6,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.12,frequency:3,easing:"easeInOut"},emissive:{min:1.2,max:2.5,frequency:3,pattern:"sine"},blending:"additive",renderOrder:15}}],decayRate:.18,glowColor:[1,.95,.8],glowIntensityMin:.8,glowIntensityMax:1.5,glowFlickerRate:4,scaleVibration:.015,scaleFrequency:3,scalePulse:!0,riseAmount:.012,riseSpeed:.8}),UA=kA({name:"lightilluminate",emoji:"",type:"blending",description:"Divine lantern blooming outward  concentric waves of illumination",duration:2500,beats:4,intensity:1,mascotGlow:.5,category:"emanating",radiance:.65,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:2,scaleEasing:"easeOutCubic"},count:1,scale:1.6,models:["sun-ring"],animation:{appearAt:0,disappearAt:.6,enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.06,frequency:2.5,easing:"easeInOut"},emissive:{min:1.2,max:2.2,frequency:2.5,pattern:"sine"},rotate:{axis:"z",rotations:.3,phase:0},cutout:{strength:.5,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:6,scale:1.5,weight:.4},blend:"add",travel:"radial",travelSpeed:.8,strengthCurve:"bell",bellPeakAt:.5},grain:{type:3,strength:.15,scale:.3,speed:.6,blend:"multiply"},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:.35,sizeScale:.8,progressCurve:"sustain"}],blending:"additive",renderOrder:14,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.02},orientation:"camera",startScale:.15,endScale:2.5,scaleEasing:"easeOutCubic"},count:1,scale:1.3,models:["sun-ring"],animation:{appearAt:.08,disappearAt:.65,enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},pulse:{amplitude:.06,frequency:2.5,easing:"easeInOut"},emissive:{min:1,max:2,frequency:2.5,pattern:"sine"},rotate:{axis:"z",rotations:-.25,phase:0},blending:"additive",renderOrder:13,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.4,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.1,endScale:3,scaleEasing:"easeOutCubic"},count:1,scale:1,models:["sun-ring"],animation:{appearAt:.16,disappearAt:.7,enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},pulse:{amplitude:.05,frequency:2.5,easing:"easeInOut"},emissive:{min:.8,max:1.8,frequency:2.5,pattern:"sine"},rotate:{axis:"z",rotations:.2,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.75,arcSpeed:.3,arcCount:2},orientationOverride:"camera"}}}},{type:"orbit",orbit:{height:"center",endHeight:"center",radius:.8,endRadius:1.2,speed:1,easing:"linear",startScale:.6,endScale:1,orientation:"camera"},formation:{type:"ring",count:4},count:4,scale:.9,models:["prism-shard"],animation:{appearAt:.05,disappearAt:.65,stagger:.03,enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:2.2,frequency:3,pattern:"sine"},rotate:[{axis:"y",rotations:1.5,phase:0},{axis:"x",rotations:-1.5,phase:90},{axis:"z",rotations:1.5,phase:180},{axis:"y",rotations:-1.5,phase:270}],scaleVariance:.2,blending:"additive",renderOrder:16}}],decayRate:.2,glowColor:[1,.95,.75],glowIntensityMin:.7,glowIntensityMax:1.3,glowFlickerRate:3,scaleVibration:.012,scaleFrequency:2.5,scalePulse:!0}),GA=kA({name:"lightdissolve",emoji:"",type:"blending",description:"Light fading reluctantly  fragments scatter and dim unwillingly",duration:3e3,beats:4,intensity:.8,category:"transform",radiance:.5,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:.4,endRadius:2.5,speed:1.5,easing:"easeOut",startScale:1.2,endScale:.3,orientation:"camera"},formation:{type:"ring",count:6},count:6,scale:1,models:["sparkle-star","prism-shard","sparkle-star","prism-shard","sparkle-star","prism-shard"],animation:{appearAt:0,disappearAt:.85,stagger:.04,enter:{type:"fade",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.12,geometryStability:!0},emissive:{min:.4,max:2,frequency:2,pattern:"sine"},pulse:{amplitude:.06,frequency:1.5,easing:"easeInOut"},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:.3,sizeScale:.5,progressCurve:"fadeOut",velocityInheritance:.4}],rotate:[{axis:"z",rotations:1,phase:0},{axis:"z",rotations:-1.5,phase:60},{axis:"z",rotations:1,phase:120},{axis:"z",rotations:-1,phase:180},{axis:"z",rotations:1.5,phase:240},{axis:"z",rotations:-1,phase:300}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:15}},decayRate:.25,glowColor:[1,.92,.65],glowIntensityMin:.4,glowIntensityMax:1,glowFlickerRate:3,scaleVibration:.01,scaleFrequency:2,scalePulse:!0});const WA={landmark:"center",orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},qA={disappearAt:.85,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},blending:"normal",renderOrder:10,relay:{count:3,arcWidth:Math.PI,floor:.5}};function HA(e,t,n,a,i,r=0,s=null){const o=.866,l=e=>Math.round(100*e)/100;return[{x:0,y:e,relay:i[0],arc:4.71,dir:-1},{x:o*e,y:-.5*e,relay:i[1],arc:3.14,dir:1},{x:-o*e,y:-.5*e,relay:i[2],arc:0,dir:-1},{x:0,y:-e,relay:i[0],arc:4.71,dir:1},{x:-o*e,y:.5*e,relay:i[1],arc:3.14,dir:-1},{x:o*e,y:.5*e,relay:i[2],arc:0,dir:1}].map((e,i)=>({type:"anchor",anchor:{...WA,offset:{x:l(e.x),y:l(e.y),z:0}},count:1,scale:t,sizeVariance:0,models:["sun-ring"],animation:{...qA,appearAt:r,rotate:[{axis:"z",rotations:e.dir*n,phase:0}],...0===i&&s?{atmospherics:s}:{},modelOverrides:{"sun-ring":{arcPhase:(e.arc+a)%6.28,relayIndex:e.relay,orientationOverride:"camera"}}}}))}var jA=kA({name:"lightmeditation",emoji:"",type:"blending",description:"Triple light hexagon mandala  three concentric relay hexagons with differential rotation",duration:3e3,beats:6,intensity:1.5,mascotGlow:.3,category:"emanating",luminosity:.5,spawnMode:[...HA(.28,.7,2,0,[0,1,2],0,[{preset:"firefly",intensity:.15,sizeScale:.5,progressCurve:"sustain"}]),...HA(.52,1.15,-1.5,2.09,[1,2,0],.08),...HA(.78,1.55,1,4.19,[2,0,1],.16),...HA(.28,.7,-2,3.14,[0,1,2],0),...HA(.52,1.15,1.5,5.23,[1,2,0],.08),...HA(.78,1.55,-1,1.05,[2,0,1],.16)],glowColor:[1,.92,.65],glowIntensityMin:.6,glowIntensityMax:1,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:2,scaleContract:.02,tremor:.002,tremorFrequency:3,shakeAmount:.003,shakeFrequency:4,decayRate:.1});const XA={disappearAt:.9,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:3,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.3,speed:.3,blend:"multiply"},blending:"additive"};function YA(e){return(43758.5453*Math.sin(e)%1+1)%1}function $A(e){const t=Math.floor(e),n=e-t,a=n*n*(3-2*n);return YA(t)*(1-a)+YA(t+1)*a}function QA(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"emanating"===e.category?1.5:1.2,offBeat:1,curve:"emanating"===e.category?"sharp":"smooth"}},"3d":{evaluate(t,n){const a={...e,...n},i=t*a.duration/1e3,{category:r}=a;let s=1;if(a.buildupPhase&&t<a.buildupPhase&&(s=Math.pow(t/a.buildupPhase,.7)),"afflicted"!==r||a.buildupPhase||t<.2&&(s=t/.2),"emanating"===r&&!a.buildupPhase)if(a.beaconPulse){const e=i*(a.pulseRate||1);s=.6+.4*Math.sin(e*Math.PI*2)}else s=Math.min(1,t/.1);"transform"!==r||a.buildupPhase||(a.shatterPoint?t<a.shatterPoint&&(s=Math.pow(t/a.shatterPoint,.5)):s=Math.min(1,t/.25)),"manifestation"===r&&!a.buildupPhase&&t<.15&&(s=t/.15);const o=a.decayRate||.2;if(t>1-o){const e=(t-(1-o))/o;a.endFlash?s*=1-.99*e:s*=1-e*e}let l=0,c=0,h=0;if(a.shakeAmount>0){const e=i*(a.shakeFrequency||15);let n=a.shakeAmount*s;a.shatterPoint&&t>a.shatterPoint&&(n*=1+(t-a.shatterPoint)/(1-a.shatterPoint)*(a.explosionForce||.5)),l+=($A(e)-.5)*n,c+=($A(e+33)-.5)*n*.7,h+=($A(e+66)-.5)*n*.5}if(a.tremor>0){let e=a.tremor;a.tremorDecay&&(e*=1-t*a.tremorDecay);const n=i*(a.tremorFrequency||4);l+=($A(n)-.5)*e*s,c+=($A(n+50)-.5)*e*.5*s}if(a.sinkAmount>0){const e=t*(1+(a.sinkAcceleration||0)*t);c-=a.sinkAmount*e*s}if(a.driftAmount>0){const e=i*(a.driftSpeed||1);l+=($A(e)-.5)*a.driftAmount*s,c+=($A(e+50)-.5)*a.driftAmount*.5*s}a.hover&&a.hoverAmount&&(c+=Math.sin(i*Math.PI*.5)*a.hoverAmount*s);let d=1;const u=i*(a.scaleFrequency||2);d=a.scalePulse?1+(.5*Math.sin(u*Math.PI*2)+.5-.5)*(a.scaleVibration||.01)*s:1+Math.sin(u*Math.PI*2)*(a.scaleVibration||.01)*s,a.scaleGrow>0&&(d+=a.scaleGrow*t*s),a.scaleShrink>0&&(d-=a.scaleShrink*t*s,d=Math.max(.1,d)),a.scaleContract>0&&(d-=a.scaleContract*t*s);let p=0;a.rotationSpeed>0&&(p=i*a.rotationSpeed*Math.PI*2*s),a.rotationDrift&&(p+=i*a.rotationDrift*s);let m=1;if(a.fadeOut){const e=a.fadeStartAt||.5,n=a.fadeEndAt||.95;if(t>=e){const i=Math.min(1,(t-e)/(n-e));m="accelerating"===a.fadeCurve?Math.max(0,1-Math.pow(i,2)):Math.max(0,1-i)}}const f=i*(a.glowFlickerRate||2);let g;"emanating"===r?(g=.3*Math.sin(f*Math.PI*2)+.7,g*=.8+.4*YA(Math.floor(3*f))):g=a.shatterPoint&&t>a.shatterPoint?1+.5*$A(5*f):.2*Math.sin(f*Math.PI*2)+.8;const y=a.glowIntensityMin||.5;return{position:[l,c,h],rotation:[0,p,0],scale:d,meshOpacity:m,glowIntensity:y+((a.glowIntensityMax||.8)-y)*g*s,glowBoost:-.15*s*a.intensity*(a.petrification||.5)+(a.mascotGlow||0)*s,glowColorOverride:s>.005?a.glowColor:null,earthOverlay:{enabled:s>.01,strength:s*a.intensity,petrification:a.petrification||.5,category:r,spawnMode:a.spawnMode||null,duration:a.duration,progress:t,time:i,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth,distortionStrength:e.distortionStrength}}}}}}const KA={appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{petrification:{start:.55,peak:.85,end:.65,curve:"bell"}},pulse:{amplitude:.05,frequency:3,easing:"easeInOut"},emissive:{min:.9,max:1.8,frequency:4,pattern:"sine"},grain:{type:3,strength:.35,scale:.2,speed:1.5,blend:"multiply"},wetness:{wetness:.55,wetSpeed:.3},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"below",anchorOffset:-.1,intensity:.4,sizeScale:1.5,progressCurve:"sustain"}],scaleVariance:.03,lifetimeVariance:.02,blending:"normal",renderOrder:15,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.8,arcCount:2}}}},ZA={disappearAt:.9,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:3,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.3,speed:.25,blend:"multiply"},blending:"normal"};function JA(e){return(43758.5453*Math.sin(e)%1+1)%1}function eC(e){const t=Math.floor(e),n=e-t,a=n*n*(3-2*n);return JA(t)*(1-a)+JA(t+1)*a}function tC(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"emanating"===e.category?1.4:1.2,offBeat:1,curve:"smooth"}},"3d":{evaluate(t,n){const a={...e,...n},i=t*a.duration/1e3,{category:r}=a;let s=1;"afflicted"===r&&(t<.2&&(s=t/.2),a.pulsingGrip&&(s*=.15*Math.sin(i*Math.PI*3)+.85)),"emanating"===r&&(t<.15&&(s=t/.15),s*=.1*Math.sin(i*Math.PI*2)+.9),"transform"===r&&(s=Math.pow(t,.7));const o=a.decayRate||.18;t>1-o&&(s*=1-(t-(1-o))/o);let l=0,c=0,h=0;if(a.floatAmount>0&&(c+=Math.sin(i*(a.floatSpeed||1)*Math.PI*2)*a.floatAmount*s),a.riseAmount>0&&(c+=a.riseAmount*t*s),a.droopAmount>0&&(c-=a.droopAmount*t*(1+(a.droopAcceleration||0)*t)*s),a.sinkAmount>0&&(c-=a.sinkAmount*t*(1+(a.sinkAcceleration||0)*t)*s),a.tremor>0){let e=a.tremor;a.tremorDecay&&(e*=1-t*a.tremorDecay);const n=i*(a.tremorFrequency||4);l+=(eC(n)-.5)*e*s,c+=(eC(n+50)-.5)*e*.5*s,h+=(eC(n+100)-.5)*e*.3*s}let d=1;const u=i*(a.scaleFrequency||2);d=a.scalePulse?1+(.5*Math.sin(u*Math.PI*2)+.5-.5)*(a.scaleVibration||.02)*s:1+(.6*Math.sin(u*Math.PI*2)+.4*Math.sin(u*Math.PI*2.7))*(a.scaleVibration||.02)*s,a.scaleGrow>0&&(d+=a.scaleGrow*t*s),a.scaleContract>0&&(d-=a.scaleContract*t*s),a.scaleShrink>0&&(d-=a.scaleShrink*t*s),d=Math.max(.1,d);let p=0,m=0,f=0;if(a.rotationSpeed>0&&(m=i*a.rotationSpeed*Math.PI*2*s),a.rotationTwist>0){const e=i*(a.rotationTwistSpeed||.5);f=Math.sin(e*Math.PI*2)*a.rotationTwist*s}if(a.rotationTilt>0){const e=t*(a.rotationTiltSpeed||.3);p=a.rotationTilt*e*s,f+=.5*a.rotationTilt*e*s}let g=1;if(a.fadeOut){const e=a.fadeStartAt||.5,n=a.fadeEndAt||.95;if(t>=e){const i=Math.min(1,(t-e)/(n-e));g=Math.max(0,"accelerating"===a.fadeCurve?1-i*i:1-i)}}const y=i*(a.glowFlickerRate||3);let v;v="emanating"===r?.2*Math.sin(y*Math.PI*2)+.8:a.pulsingGrip?.25*Math.sin(y*Math.PI*2)+.75:.15*Math.sin(y*Math.PI*2)+.85;const b=(a.glowIntensityMin||.5)+((a.glowIntensityMax||.8)-(a.glowIntensityMin||.5))*v*s,w=.2*s*(a.intensity||1)*(a.growth||.5)+(e.mascotGlow||0)*s;return{natureOverlay:{enabled:s>.1,strength:s*(a.intensity||1),growth:a.growth||.5,category:a.category,spawnMode:a.spawnMode||null,duration:a.duration,time:i,progress:t,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth},position:[l,c,h],rotation:[p,m,f],scale:d,meshOpacity:g,glowIntensity:b,glowBoost:w,glowColorOverride:a.glowColor}}}}}const nC={appearAt:0,disappearAt:.8,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.04,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.7,max:1.4,frequency:2,pattern:"sine"},grain:{type:3,strength:.03,scale:.3,speed:.35,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.03,lifetimeVariance:.02,blending:"normal",renderOrder:12,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:1.5,arcCount:2},orientationOverride:"flat"}}},aC={disappearAt:.9,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:3,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.3,speed:.3,blend:"multiply"},blending:"normal"},iC={blending:"normal",renderOrder:15},rC={blending:"normal",renderOrder:10};[qM,HM,jM,XM,YM,$M,QM,KM,ZM,JM,e_,t_,n_,i_,r_,s_,o_,l_,c_,d_,f_,g_,y_,w_,x_,S_,M_,__,P_,D_,E_,I_,k_,R_,z_,v_,b_,F_,L_,vM,bM,wM,xM,SM,MM,_M,AM,CM,TM,DM,OM,EM,IM,kM,RM,zM,FM,BM,LM,BM,NM,UM,G_,W_,q_,H_,j_,X_,Y_,$_,K_,Z_,J_,eA,tA,nA,sA,oA,cA,pA,mA,gA,yA,vA,bA,wA,xA,SA,MA,_A,AA,CA,TA,PA,OA,RA,zA,FA,BA,LA,NA,VA,UA,GA,kA({name:"lightcrown",emoji:"",type:"blending",description:"Radiant golden halo floating above the head, emanating divine light",duration:3e3,beats:4,intensity:1,mascotGlow:.3,category:"manifestation",radiance:.7,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.3}},count:1,scale:1,models:["light-crown"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.06,frequency:2,easing:"easeInOut"},emissive:{min:1.2,max:2,frequency:1.5,pattern:"sine"},rotate:{axis:"z",rotations:.5,phase:0},atmospherics:[{preset:"firefly",targets:["light-crown"],anchor:"above",intensity:.4,sizeScale:.6,progressCurve:"sustain"}],scaleVariance:0,lifetimeVariance:0,blending:"additive",renderOrder:15,modelOverrides:{"light-crown":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.6,arcCount:3},orientationOverride:"flat"}}}},decayRate:.2,glowColor:[1,.92,.65],glowIntensityMin:.8,glowIntensityMax:1.4,glowFlickerRate:2,scaleVibration:.008,scaleFrequency:2,scalePulse:!0,rotationDrift:.01}),kA({name:"lightdance",emoji:"",type:"blending",description:"Rings of light ascending and spinning like golden coins",duration:1500,beats:3,intensity:1.3,category:"manifestation",radiance:.65,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.8,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["sun-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.55,primary:{pattern:5,scale:1,weight:.8},secondary:{pattern:6,scale:1.5,weight:.5},blend:"add",travel:"spiral",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5},grain:{type:3,strength:.08,scale:.15,speed:1,blend:"multiply"},atmospherics:[{preset:"firefly",targets:null,anchor:"above",intensity:.25,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:15,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},decayRate:.2,glowColor:[1,.9,.55],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:6,scaleVibration:.018,scaleFrequency:4,scaleGrowth:.025,rotationDrift:.01}),kA({name:"lighthelix",emoji:"",type:"blending",description:"Double helix of light rings spiraling upward",duration:2e3,beats:4,intensity:1.2,category:"manifestation",radiance:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.9,endScale:1.1,startDiameter:1.8,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:.7,models:["sun-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:1.2,max:2.5,frequency:6,pattern:"sine"},cutout:{strength:.8,primary:{pattern:5,scale:2,weight:1},secondary:{pattern:0,scale:1.8,weight:.6},blend:"max",travel:"angular",travelSpeed:3,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.05,scale:.2,speed:1,blend:"multiply"},atmospherics:[{preset:"firefly",targets:null,anchor:"above",intensity:.3,sizeScale:.6,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"additive",renderOrder:15,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},decayRate:.2,glowColor:[1,.92,.6],glowIntensityMin:.8,glowIntensityMax:1.4,glowFlickerRate:3,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,rotationDrift:.01}),kA({name:"lightpillar",emoji:"",type:"blending",description:"Vertical column of stacked light rings  pillar of divine radiance",duration:2500,beats:4,intensity:1.2,mascotGlow:.4,category:"manifestation",radiance:.8,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"linear",startScale:1,endScale:1,startDiameter:1.2,endDiameter:1.2,orientation:"flat"},formation:{type:"stack",count:5,spacing:.3,phaseOffset:.04},count:5,scale:1.1,models:["sun-ring"],animation:{appearAt:0,disappearAt:.55,stagger:.04,enter:{type:"scale",duration:.12,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.06,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:1,max:2.2,frequency:2,pattern:"sine"},rotate:{axis:"z",rotations:.4,phase:0},cutout:{strength:.55,primary:{pattern:6,scale:1,weight:.8},secondary:{pattern:5,scale:1.5,weight:.4},blend:"add",travel:"linear",travelSpeed:1.2,strengthCurve:"bell",bellPeakAt:.5},grain:{type:3,strength:.15,scale:.2,speed:.8,blend:"multiply"},atmospherics:[{preset:"firefly",targets:["sun-ring"],anchor:"above",intensity:.4,sizeScale:1,progressCurve:"sustain"}],scaleVariance:.05,lifetimeVariance:.05,blending:"additive",renderOrder:15,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},decayRate:.2,glowColor:[1,.95,.75],glowIntensityMin:.9,glowIntensityMax:1.5,glowFlickerRate:2,scaleVibration:.006,scaleFrequency:2,scalePulse:!0}),kA({name:"lightdrill",emoji:"",type:"blending",description:"Light rings drilling downward in a tight spiral",duration:1200,beats:2,intensity:1.5,category:"manifestation",radiance:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:.8,models:["sun-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},pulse:{amplitude:.08,frequency:10,easing:"linear"},emissive:{min:1.5,max:3.5,frequency:12,pattern:"random"},cutout:{strength:.6,primary:{pattern:8,scale:2.5,weight:1},secondary:{pattern:3,scale:3,weight:.7},blend:"multiply",travel:"oscillate",travelSpeed:5,trailDissolve:{offset:.1,softness:.25}},grain:{type:2,strength:.1,scale:.1,speed:3,blend:"multiply"},atmospherics:[{preset:"firefly",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:15,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},decayRate:.15,glowColor:[1,.9,.5],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03,scalePulse:!0}),kA({name:"lightflourish",emoji:"",type:"blending",description:"Radial starburst of light fragments exploding outward from center",duration:1500,beats:4,intensity:1.4,mascotGlow:.3,category:"manifestation",radiance:.85,spawnMode:{type:"radial-burst",radialBurst:{center:"center",startRadius:.3,endRadius:2.5,easing:"easeOut",startScale:.5,endScale:1.4,orientation:"camera"},formation:{type:"ring",count:8},count:8,scale:1.2,models:["sun-ring","sparkle-star","prism-shard","sun-ring","sparkle-star","prism-shard","sun-ring","sparkle-star"],animation:{appearAt:0,disappearAt:.55,stagger:.01,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.2,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.1,frequency:6,easing:"easeInOut"},emissive:{min:1.2,max:2.5,frequency:5,pattern:"sine"},cutout:{strength:.5,primary:{pattern:5,scale:1,weight:.8},secondary:{pattern:1,scale:1.5,weight:.4},blend:"add",travel:"radial",travelSpeed:2,strengthCurve:"bell",bellPeakAt:.4},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:.4,sizeScale:1,progressCurve:"burst",velocityInheritance:.6}],rotate:[{axis:"z",rotations:1,phase:0},{axis:"z",rotations:-1.5,phase:45},{axis:"z",rotations:1,phase:90},{axis:"z",rotations:-1.5,phase:135},{axis:"z",rotations:1,phase:180},{axis:"z",rotations:-1.5,phase:225},{axis:"z",rotations:1,phase:270},{axis:"z",rotations:-1.5,phase:315}],scaleVariance:.25,lifetimeVariance:.15,blending:"additive",renderOrder:18}},decayRate:.15,glowColor:[1,.95,.7],glowIntensityMin:.9,glowIntensityMax:1.6,glowFlickerRate:6,scaleVibration:.02,scaleFrequency:4,scalePulse:!0}),kA({name:"lightvortex",emoji:"",type:"blending",description:"Spiraling tornado of divine light rings around mascot",duration:1500,beats:5,intensity:1.4,category:"manifestation",radiance:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.7,startDiameter:.6,endDiameter:1.2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["sun-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.12,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.4,rate:18,pattern:"random"},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.5,frequency:8,pattern:"sine"},cutout:{strength:.7,primary:{pattern:6,scale:2.5,weight:1},secondary:{pattern:4,scale:1.8,weight:.5},blend:"add",travel:"spiral",travelSpeed:4,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:2,strength:.12,scale:.15,speed:2.5,blend:"multiply"},atmospherics:[{preset:"firefly",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:15,intensityScaling:{scale:1.4,emissiveMax:1.6,pulseAmplitude:1.3},modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:6,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}}}},decayRate:.2,glowColor:[1,.95,.7],glowIntensityMin:1,glowIntensityMax:2.2,glowFlickerRate:8,scaleVibration:.02,scaleFrequency:4,scalePulse:!0}),kA({name:"lightbarrage",emoji:"",type:"blending",description:"Light fragments orbit mascot then launch outward",duration:1500,beats:4,intensity:1.4,category:"manifestation",radiance:.8,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.4,models:["prism-shard","sparkle-star","light-ray","prism-shard","sparkle-star"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.1,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:1,max:2.5,frequency:4,pattern:"sine"},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:.4,sizeScale:1.2,progressCurve:"sustain",velocityInheritance:.6}],rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"additive",renderOrder:18}},decayRate:.2,glowColor:[1,.95,.65],glowIntensityMin:.9,glowIntensityMax:1.6,glowFlickerRate:6,scaleVibration:.012,scaleFrequency:4,scalePulse:!0}),kA({name:"lightimpact",emoji:"",type:"blending",description:"Light fragments converge inward to strike the mascot",duration:1500,beats:4,intensity:1.5,category:"manifestation",radiance:.85,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"center",radius:2.5,endRadius:.5,speed:2,easing:"easeOut",startScale:.6,endScale:1.3,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.4,models:["prism-shard","light-ray","sparkle-star","prism-shard","light-ray"],animation:{appearAt:0,disappearAt:.65,stagger:.03,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"shrink",duration:.1,easing:"easeInCubic"},procedural:{scaleSmoothing:.06,geometryStability:!0},pulse:{amplitude:.12,frequency:6,easing:"easeIn"},emissive:{min:1.2,max:2.8,frequency:5,pattern:"sine"},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:.5,sizeScale:1.4,progressCurve:"rampUp",velocityInheritance:.5}],rotate:[{axis:"y",rotations:2,phase:0},{axis:"x",rotations:-2.5,phase:72},{axis:"z",rotations:3,phase:144},{axis:"y",rotations:-2,phase:216},{axis:"x",rotations:2.5,phase:288}],scaleVariance:.15,lifetimeVariance:.08,blending:"additive",renderOrder:18}},decayRate:.15,glowColor:[1,.9,.55],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:8,scaleVibration:.02,scaleFrequency:5,scalePulse:!0}),kA({name:"lightblast",emoji:"",type:"blending",description:"Divine detonation with heavy screen-warping distortion  light bends reality",duration:900,beats:2,intensity:1.8,category:"manifestation",radiance:1,distortionStrength:2.5,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.15,endScale:3.5,scaleEasing:"easeOutQuad"},count:1,scale:2.5,models:["light-burst"],animation:{appearAt:0,disappearAt:.35,enter:{type:"flash",duration:.02,easing:"linear"},exit:{type:"fade",duration:.12,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},pulse:{amplitude:.15,frequency:12,easing:"easeOut"},emissive:{min:2.5,max:4.5,frequency:10,pattern:"sine"},atmospherics:[{preset:"firefly",targets:null,anchor:"around",intensity:1,sizeScale:2.5,progressCurve:"pulse"}],blending:"additive",renderOrder:18}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:4,scaleEasing:"easeOutCubic"},count:1,scale:2,models:["light-ring"],animation:{appearAt:0,disappearAt:.3,enter:{type:"flash",duration:.02,easing:"linear"},exit:{type:"fade",duration:.1,easing:"easeIn"},emissive:{min:1.8,max:3.5,frequency:10,pattern:"sine"},blending:"additive",renderOrder:16,modelOverrides:{"light-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.15,endScale:3.5,scaleEasing:"easeOutCubic"},count:1,scale:1.6,models:["light-ring"],animation:{appearAt:.06,disappearAt:.35,enter:{type:"flash",duration:.02,easing:"linear"},exit:{type:"fade",duration:.12,easing:"easeIn"},emissive:{min:1.5,max:3,frequency:8,pattern:"sine"},blending:"additive",renderOrder:15,modelOverrides:{"light-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:8,radius:.1,endRadius:2,angleSpread:360,startAngle:22,orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:8,scale:1,models:["prism-shard"],animation:{appearAt:.02,disappearAt:.4,stagger:.005,enter:{type:"scale",duration:.02,easing:"easeOut"},exit:{type:"burst-fade",duration:.12,easing:"easeIn",burstScale:1.3},emissive:{min:1.5,max:3,frequency:10,pattern:"sine"},rotate:[{axis:"z",rotations:2,phase:0},{axis:"z",rotations:-2.5,phase:45},{axis:"z",rotations:3,phase:90},{axis:"z",rotations:-2,phase:135},{axis:"z",rotations:2.5,phase:180},{axis:"z",rotations:-3,phase:225},{axis:"z",rotations:2,phase:270},{axis:"z",rotations:-2.5,phase:315}],scaleVariance:.3,lifetimeVariance:.1,blending:"additive",renderOrder:19}},{type:"radial-burst",radialBurst:{count:4,radius:.2,endRadius:1.5,angleSpread:360,startAngle:67,orientation:"camera",startScale:.3,endScale:.6,scaleEasing:"easeOutQuad"},count:4,scale:.7,models:["sparkle-star"],animation:{appearAt:.03,disappearAt:.45,stagger:.008,enter:{type:"flash",duration:.02,easing:"linear"},exit:{type:"fade",duration:.15,easing:"easeIn"},emissive:{min:1.3,max:2.8,frequency:8,pattern:"sine"},rotate:[{axis:"z",rotations:1.5,phase:0},{axis:"z",rotations:-2,phase:90},{axis:"z",rotations:1.5,phase:180},{axis:"z",rotations:-1.5,phase:270}],scaleVariance:.25,blending:"additive",renderOrder:20}}],decayRate:.1,endFlash:!0,glowColor:[1,.95,.6],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:12,scaleVibration:.05,scaleFrequency:10,scalePulse:!0,recoilAmount:.02,recoilSpeed:4}),kA({name:"lightsurge",emoji:"",type:"blending",description:"Divine energy geyser  light erupts vertically in a surging plume",duration:1500,beats:3,intensity:1.3,category:"emanating",radiance:.8,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeOut",startScale:1.4,endScale:.9,startDiameter:2,endDiameter:1,orientation:"flat"},formation:{type:"stack",count:3,spacing:.1,phaseOffset:.03},count:3,scale:1.2,models:["sun-ring"],animation:{appearAt:0,disappearAt:.55,stagger:.04,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:1.2,max:2.5,frequency:6,pattern:"sine"},atmospherics:[{preset:"firefly",targets:null,anchor:"above",intensity:.4,sizeScale:1,progressCurve:"rampUp",velocityInheritance:.5}],rotate:{axis:"z",rotations:.5,phase:0},blending:"additive",renderOrder:15,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:2,arcCount:1},orientationOverride:"flat"}}}},{type:"radial-burst",radialBurst:{count:3,radius:.1,endRadius:.6,angleSpread:120,startAngle:60,orientation:"camera",startScale:.4,endScale:.7,scaleEasing:"easeOutQuad"},count:3,scale:.7,models:["sparkle-star"],animation:{appearAt:.15,disappearAt:.5,stagger:.03,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1.3,max:2.5,frequency:8,pattern:"sine"},drift:{speed:.8,distance:.4,direction:{x:0,y:1,z:0},easing:"easeOut"},scaleVariance:.25,blending:"additive",renderOrder:17}}],decayRate:.15,glowColor:[1,.95,.7],glowIntensityMin:.8,glowIntensityMax:1.6,glowFlickerRate:5,scaleVibration:.015,scaleFrequency:4,scalePulse:!0}),jA,kA({name:"lighttwirl",emoji:"",type:"blending",description:"Relay light illusion  arc weaves through three interlocked rings",duration:1500,beats:2,intensity:1.5,category:"afflicted",growth:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["sun-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"firefly",intensity:.2,sizeScale:.6,progressCurve:"sustain"}],modelOverrides:{"sun-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["sun-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"sun-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.52,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["sun-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"sun-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[1,.92,.65],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.006,tremorFrequency:8,shakeAmount:.01,shakeFrequency:12,decayRate:.15}),kA({name:"lightshield",emoji:"",type:"blending",description:"Gyroscopic light cage  six tumbling rings form a protective radiance",duration:3e3,beats:4,intensity:1,mascotGlow:.3,category:"manifestation",radiance:.8,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.3}},count:1,scale:1.5,models:["sun-ring"],animation:{...XA,appearAt:0,rotate:{axis:"x",rotations:.75,phase:0},renderOrder:6,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.35}},count:1,scale:1.5,models:["sun-ring"],animation:{...XA,appearAt:.03,rotate:{axis:"y",rotations:-.75,phase:0},renderOrder:8,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.4}},count:1,scale:1.5,models:["sun-ring"],animation:{...XA,appearAt:.06,rotate:{axis:"x",rotations:.75,phase:60},renderOrder:10,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.45}},count:1,scale:1.5,models:["sun-ring"],animation:{...XA,appearAt:.09,rotate:{axis:"y",rotations:-.75,phase:120},renderOrder:12,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.38}},count:1,scale:1.5,models:["sun-ring"],animation:{...XA,appearAt:.12,rotate:{axis:"x",rotations:.75,phase:45},renderOrder:14,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.42}},count:1,scale:1.5,models:["sun-ring"],animation:{...XA,appearAt:.15,rotate:{axis:"y",rotations:-.75,phase:-45},atmospherics:[{preset:"firefly",targets:["sun-ring"],anchor:"around",intensity:.2,sizeScale:.7,progressCurve:"sustain"}],renderOrder:16,modelOverrides:{"sun-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.55,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[1,.95,.75],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,tremor:.002,tremorFrequency:2,decayRate:.2}),QA({name:"earthpetrify",emoji:"",type:"blending",description:"Rocks converge from all sides, entombing the mascot in a stone prison",duration:3500,beats:5,intensity:1.2,mascotGlow:.4,category:"afflicted",petrification:.95,spawnMode:[{type:"anchor",anchor:{landmark:"feet",offset:{x:0,y:-.02,z:0},orientation:"flat",startScale:.3,endScale:1.2,scaleEasing:"easeOutQuad"},count:1,scale:2,models:["earth-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},emissive:{min:.5,max:1,frequency:1.5,pattern:"sine"},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"above",intensity:.3,sizeScale:1.5,progressCurve:"buildup"}],blending:"normal",renderOrder:4,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"flat"}}}},{type:"orbit",orbit:{height:"center",endHeight:"center",radius:1.8,endRadius:.35,speed:1.5,easing:"easeInQuad",startScale:.5,endScale:1,orientation:"camera"},count:5,scale:.8,models:["boulder","rock-cluster","stone-slab","rock-chunk-medium","boulder"],animation:{appearAt:.05,disappearAt:.75,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},parameterAnimation:{petrification:{start:.3,peak:.95,end:.9,curve:"fadeIn"}},pulse:{amplitude:.03,frequency:1,easing:"easeInOut",sync:"global"},emissive:{min:.4,max:.9,frequency:1.5,pattern:"sine"},rotate:[{axis:"x",rotations:-.8,phase:0},{axis:"z",rotations:.6,phase:72},{axis:"y",rotations:-.5,phase:144},{axis:"x",rotations:.7,phase:216},{axis:"z",rotations:-.6,phase:288}],atmospherics:[{preset:"earth-dust",targets:null,anchor:"around",intensity:.4,sizeScale:.8,progressCurve:"buildup"}],scaleVariance:.25,lifetimeVariance:.1,blending:"normal",renderOrder:8}},{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.1,z:0},orientation:"flat",startScale:.1,endScale:1,scaleEasing:"easeOutQuad"},count:1,scale:1.5,models:["stone-slab"],animation:{appearAt:.5,disappearAt:.85,enter:{type:"scale",duration:.15,easing:"easeOutBounce"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:.6,max:1.2,frequency:1,pattern:"sine"},atmospherics:[{preset:"earth-gravel",targets:["stone-slab"],anchor:"below",intensity:.4,sizeScale:.6,progressCurve:"burst"}],blending:"normal",renderOrder:12}},{type:"anchor",anchor:{landmark:"feet",offset:{x:0,y:-.05,z:0},orientation:"flat",startScale:.2,endScale:1,scaleEasing:"easeOutQuad"},count:1,scale:1.6,models:["stone-slab"],animation:{appearAt:.35,disappearAt:.85,enter:{type:"scale",duration:.2,easing:"easeOutQuad"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:.4,max:.8,frequency:1,pattern:"sine"},atmospherics:[{preset:"earth-dust",targets:["stone-slab"],anchor:"above",intensity:.2,sizeScale:1,progressCurve:"sustain"}],blending:"normal",renderOrder:4}}],sinkAmount:.02,sinkAcceleration:.4,scaleContract:.015,decayRate:.2,glowColor:[.65,.45,.2],glowIntensityMin:.3,glowIntensityMax:.7,glowFlickerRate:1,tremor:.008,tremorFrequency:3,tremorDecay:.7}),QA({name:"earthburden",emoji:"",type:"blending",description:"Stone slabs stack on the mascot, each adding more crushing weight",duration:3e3,beats:4,intensity:.9,category:"afflicted",petrification:.5,spawnMode:[{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.08,z:0},orientation:"flat",startScale:.3,endScale:1,scaleEasing:"easeOutQuad"},count:1,scale:1.6,models:["stone-slab"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.2,easing:"easeOutBounce"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:.3,max:.6,frequency:.8,pattern:"sine"},rotate:{axis:"z",rotations:.001,phase:0},atmospherics:[{preset:"earth-dust",targets:["stone-slab"],anchor:"above",intensity:.15,sizeScale:.6,progressCurve:"sustain"}],blending:"normal",renderOrder:10}},{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.2,z:0},orientation:"flat",startScale:.2,endScale:1,scaleEasing:"easeOutQuad"},count:1,scale:1.1,models:["stone-slab"],animation:{appearAt:.15,disappearAt:.8,enter:{type:"scale",duration:.2,easing:"easeOutBounce"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:.3,max:.6,frequency:.8,pattern:"sine"},rotate:{axis:"z",rotations:.001,phase:45},atmospherics:[{preset:"earth-gravel",targets:["stone-slab"],anchor:"below",intensity:.2,sizeScale:.5,progressCurve:"burst"}],blending:"normal",renderOrder:11}},{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.32,z:0},orientation:"flat",startScale:.2,endScale:1,scaleEasing:"easeOutQuad"},count:1,scale:1.4,models:["stone-slab"],animation:{appearAt:.3,disappearAt:.75,enter:{type:"scale",duration:.2,easing:"easeOutBounce"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:.4,max:.7,frequency:1,pattern:"sine"},rotate:{axis:"z",rotations:.001,phase:-30},atmospherics:[{preset:"earth-dust",targets:["stone-slab"],anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"burst"},{preset:"earth-gravel",targets:["stone-slab"],anchor:"below",intensity:.25,sizeScale:.6,progressCurve:"burst"}],blending:"normal",renderOrder:12}}],sinkAmount:.03,sinkAcceleration:.5,decayRate:.2,glowColor:[.7,.5,.25],glowIntensityMin:.3,glowIntensityMax:.5,tremor:.006,tremorFrequency:2}),QA({name:"earthrumble",emoji:"",type:"blending",description:"Grinding mandala of stone rings trembling at ground level",duration:2500,beats:4,intensity:1.2,mascotGlow:.3,category:"emanating",petrification:.4,spawnMode:[{type:"anchor",anchor:{landmark:"feet",offset:{x:0,y:.05,z:0},orientation:"flat",startScale:.5,endScale:1,scaleEasing:"easeOutQuad"},count:1,scale:2,models:["earth-ring"],animation:{appearAt:0,disappearAt:.8,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},pulse:{amplitude:.2,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.6,max:1.2,frequency:2,pattern:"sine"},rotate:{axis:"z",rotations:1.5,phase:0},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"above",intensity:.5,sizeScale:1.5,progressCurve:"sustain"}],blending:"normal",renderOrder:8,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.5,arcCount:2},orientationOverride:"flat"}}}},{type:"orbit",orbit:{height:"feet",endHeight:"feet",radius:.6,endRadius:.8,speed:.5,easing:"linear",startScale:.6,endScale:.9,orientation:"camera"},count:4,scale:.8,models:["rock-cluster","rock-chunk-medium","boulder","rock-chunk-medium"],animation:{appearAt:.05,disappearAt:.75,stagger:.04,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},pulse:{amplitude:.15,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},rotate:[{axis:"x",rotations:-1.2,phase:0},{axis:"z",rotations:1.4,phase:90},{axis:"y",rotations:-1,phase:180},{axis:"x",rotations:1.6,phase:270}],atmospherics:[{preset:"earth-gravel",targets:null,anchor:"below",intensity:.3,sizeScale:.5,progressCurve:"sustain"}],scaleVariance:.2,blending:"normal",renderOrder:9}}],shakeAmount:.025,shakeFrequency:10,decayRate:.2,glowColor:[.8,.55,.25],glowIntensityMin:.5,glowIntensityMax:.9,glowFlickerRate:2,scaleVibration:.012,scaleFrequency:2,tremor:.015,tremorFrequency:8}),QA({name:"earthquake",emoji:"",type:"blending",description:"Ground splits, rocks rain from above, spikes erupt, debris explodes outward",duration:1200,beats:2,intensity:1.5,category:"emanating",petrification:.6,spawnMode:[{type:"anchor",anchor:{landmark:"feet",offset:{x:0,y:0,z:0},orientation:"flat",startScale:.3,endScale:2.5,scaleEasing:"easeOutQuad"},count:1,scale:1.8,models:["earth-ring"],animation:{appearAt:0,disappearAt:.6,enter:{type:"fade",duration:.04,easing:"linear"},exit:{type:"fade",duration:.25,easing:"easeIn"},emissive:{min:1,max:2,frequency:2,pattern:"sine"},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"above",intensity:.6,sizeScale:2,progressCurve:"burst"}],blending:"normal",renderOrder:4,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:2,arcCount:2},orientationOverride:"flat"}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"above",end:"below",easing:"easeIn",startScale:.4,endScale:1.2,startDiameter:1.8,endDiameter:.8,orientation:"camera"},formation:{type:"spiral",count:6,spacing:0,arcOffset:60,phaseOffset:0},count:6,scale:.7,models:["boulder","rock-chunk-medium","rock-cluster","rock-chunk-medium","boulder","rock-chunk-small"],animation:{appearAt:0,disappearAt:.55,stagger:.05,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.1,easing:"easeIn",burstScale:1.3},emissive:{min:.6,max:1.2,frequency:3,pattern:"sine"},rotate:[{axis:"x",rotations:2,phase:0},{axis:"z",rotations:-1.5,phase:60},{axis:"y",rotations:2.5,phase:120},{axis:"x",rotations:-1.8,phase:180},{axis:"z",rotations:1.2,phase:240},{axis:"y",rotations:-2,phase:300}],atmospherics:[{preset:"earth-gravel",targets:null,anchor:"below",intensity:.5,sizeScale:.8,progressCurve:"burst"}],scaleVariance:.3,lifetimeVariance:.1,blending:"normal",renderOrder:10}},{type:"surface",pattern:"spikes",embedDepth:.18,cameraFacing:.3,clustering:.1,count:3,scale:1.3,minDistance:.15,models:["stone-spike","stone-spike","stone-spike"],animation:{appearAt:.1,disappearAt:.65,stagger:.06,enter:{type:"grow",duration:.08,easing:"easeOutQuad"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.2},procedural:{scaleSmoothing:.05,geometryStability:!0},emissive:{min:.8,max:1.8,frequency:3,pattern:"sine"},pulse:{amplitude:.06,frequency:6,easing:"easeInOut"},scaleVariance:.3,lifetimeVariance:.1,blending:"normal",renderOrder:8,modelOverrides:{"stone-spike":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.6},y:{expand:!0,rate:2.5},z:{expand:!1,rate:.6}}}}}}},{type:"radial-burst",radialBurst:{count:5,radius:.2,endRadius:2,angleSpread:360,startAngle:36,orientation:"camera",startScale:.3,endScale:.7,scaleEasing:"easeOutQuad"},count:5,scale:.45,models:["rock-chunk-small","rock-chunk-medium","rock-chunk-small","rock-chunk-small","rock-chunk-medium"],speedCurve:"burst",animation:{appearAt:.15,disappearAt:.7,stagger:.01,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"burst-fade",duration:.2,easing:"easeIn",burstScale:1.1},emissive:{min:.5,max:1,frequency:3,pattern:"sine"},rotate:[{axis:"x",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"y",rotations:1.8,phase:144},{axis:"x",rotations:-1.5,phase:216},{axis:"z",rotations:2.2,phase:288}],atmospherics:[{preset:"earth-dust",targets:null,anchor:"above",intensity:.4,sizeScale:1.5,progressCurve:"sustain"}],scaleVariance:.3,blending:"normal",renderOrder:12}}],shakeAmount:.04,shakeFrequency:16,endFlash:!0,decayRate:.1,glowColor:[.85,.6,.25],glowIntensityMin:1,glowIntensityMax:2.5,glowFlickerRate:8,tremor:.02,tremorFrequency:12}),QA({name:"earthencase",emoji:"",type:"blending",description:"Stone clusters growing on mascot surface, encasing in rock",duration:3500,beats:5,intensity:1.2,mascotGlow:.4,category:"transform",petrification:.85,spawnMode:{type:"surface",pattern:"shell",embedDepth:.2,cameraFacing:.4,clustering:.1,count:10,scale:1.8,minDistance:.1,models:["rock-cluster","rock-chunk-medium","rock-chunk-small","stone-spike"],animation:{appearAt:.05,disappearAt:.9,stagger:.04,enter:{type:"grow",duration:.12,easing:"easeOutQuad"},exit:{type:"shrink",duration:.15,easing:"easeInQuad"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{petrification:{start:.5,peak:.9,end:.7,curve:"fadeIn"}},pulse:{amplitude:.05,frequency:1.2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:.9,frequency:1.5,pattern:"sine"},atmospherics:[{preset:"earth-dust",targets:null,anchor:"below",intensity:.3,sizeScale:1.2,progressCurve:"sustain"}],wetness:{wetness:.5,wetSpeed:.25},cutout:{edgeMask:.3},rotate:{axis:"y",speed:.008,oscillate:!0,range:Math.PI/16},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:6,intensityScaling:{scale:1.25,emissiveMax:1.2},modelOverrides:{"rock-chunk-small":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1},y:{expand:!0,rate:1.4},z:{expand:!0,rate:1}},easing:"easeOutQuad"}},"rock-chunk-medium":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!0,rate:1.5},z:{expand:!0,rate:1.1}}}},"rock-cluster":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.3},y:{expand:!0,rate:1.2},z:{expand:!0,rate:1.3}}}},"stone-spike":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.85},y:{expand:!0,rate:1.8},z:{expand:!1,rate:.85}}}}}}},glowColor:[.85,.6,.25],glowIntensityMin:.55,glowIntensityMax:.9,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:2,scaleContract:.02,tremor:.004,tremorFrequency:6,tremorDecay:.8,decayRate:.15}),QA({name:"earthcrumble",emoji:"",type:"blending",description:"Structural collapse  stone cracks, shatters outward, and crumbles to dust",duration:2e3,beats:3,intensity:1.4,category:"transform",petrification:.7,spawnMode:[{type:"surface",pattern:"spikes",embedDepth:.15,cameraFacing:.3,clustering:.15,count:4,scale:.9,minDistance:.12,models:["stone-spike","stone-spike","stone-spike","stone-spike"],animation:{appearAt:0,disappearAt:.4,stagger:.04,enter:{type:"grow",duration:.12,easing:"easeOutQuad"},exit:{type:"burst-fade",duration:.1,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{petrification:{start:.7,peak:.9,end:.5,curve:"bell"}},pulse:{amplitude:.06,frequency:6,easing:"easeInOut"},emissive:{min:.5,max:1.2,frequency:4,pattern:"sine"},cutout:{edgeMask:.25},atmospherics:[{preset:"earth-dust",targets:null,anchor:"around",intensity:.3,sizeScale:.8,progressCurve:"buildup"}],scaleVariance:.25,lifetimeVariance:.1,blending:"normal",renderOrder:6,modelOverrides:{"stone-spike":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.8},y:{expand:!0,rate:2},z:{expand:!1,rate:.8}}}}}}},{type:"radial-burst",radialBurst:{count:10,radius:.15,endRadius:2.5,angleSpread:360,startAngle:0,orientation:"camera"},startScale:.7,endScale:.2,scaleEasing:"easeInQuad",speedCurve:"burst",count:10,scale:.55,models:["rock-chunk-small","rock-chunk-medium","rock-chunk-small","boulder","rock-chunk-small","rock-chunk-medium","rock-chunk-small","rock-cluster","rock-chunk-small","rock-chunk-medium"],animation:{appearAt:.25,disappearAt:.75,stagger:.01,enter:{type:"scale",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.2,easing:"easeIn",burstScale:1.1},emissive:{min:.4,max:.8,frequency:3,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0},{axis:"x",rotations:-2,phase:36},{axis:"y",rotations:2.5,phase:72},{axis:"z",rotations:-1.5,phase:108},{axis:"x",rotations:2,phase:144},{axis:"y",rotations:-3,phase:180},{axis:"z",rotations:1.5,phase:216},{axis:"x",rotations:-2.5,phase:252},{axis:"y",rotations:2,phase:288},{axis:"z",rotations:-2,phase:324}],atmospherics:[{preset:"earth-gravel",targets:null,anchor:"below",intensity:.6,sizeScale:1,progressCurve:"burst",velocityInheritance:.5},{preset:"earth-dust",targets:null,anchor:"above",intensity:.5,sizeScale:1.5,progressCurve:"sustain"}],scaleVariance:.35,lifetimeVariance:.15,blending:"normal",renderOrder:12}},{type:"anchor",anchor:{landmark:"bottom",offset:{x:0,y:-.05,z:0},orientation:"flat",startScale:.2,endScale:2.5,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["earth-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},cutout:{strength:.75,primary:{pattern:8,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.5},blend:"add",travel:"radial",travelSpeed:3,strengthCurve:"fadeOut",fadeOutDuration:.4,trailDissolve:{offset:-.3,softness:1.5,direction:"outward"}},grain:{type:3,strength:.25,scale:.2,speed:3,blend:"multiply"},emissive:{min:.8,max:1.5,frequency:2,pattern:"sine"},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"above",intensity:.6,sizeScale:2,progressCurve:"burst"}],blending:"normal",renderOrder:4,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:1,arcSpeed:0,arcCount:1}}}}}],shatterPoint:.28,endFlash:!0,fadeOut:!0,fadeStartAt:.5,fadeEndAt:.95,scaleShrink:.15,distortionStrength:1.2,decayRate:.2,glowColor:[.8,.55,.25],glowIntensityMin:.5,glowIntensityMax:1,glowFlickerRate:4,shakeAmount:.03,shakeFrequency:15,tremor:.012,tremorFrequency:8}),QA({name:"earthshatter",emoji:"",type:"blending",description:"Violent shattering explosion  stone builds tension then detonates into fragments",duration:1200,beats:2,intensity:1.6,category:"transform",petrification:.8,shatterPoint:.3,spawnMode:{type:"radial-burst",radialBurst:{count:10,radius:.05,endRadius:2.5,angleSpread:360,startAngle:18,orientation:"camera",startScale:.3,endScale:1,scaleEasing:"easeOutQuad"},count:10,scale:.8,models:["rock-chunk-small","boulder","rock-chunk-small","boulder","rock-chunk-small","boulder","rock-chunk-small","boulder","rock-chunk-small","boulder"],animation:{appearAt:.25,disappearAt:.55,stagger:.008,enter:{type:"flash",duration:.02,easing:"linear"},exit:{type:"burst-fade",duration:.12,easing:"easeIn",burstScale:1.4},procedural:{scaleSmoothing:.05,geometryStability:!0},emissive:{min:.6,max:1.2,frequency:6,pattern:"sine"},atmospherics:[{preset:"earth-gravel",targets:["rock-cluster","stone-slab"],anchor:"below",intensity:.5,sizeScale:.8,progressCurve:"burst"},{preset:"earth-dust",targets:["rock-cluster"],anchor:"above",intensity:.4,sizeScale:1.2,progressCurve:"burst"}],rotate:[{axis:"x",rotations:3,phase:0},{axis:"z",rotations:-2.5,phase:36},{axis:"y",rotations:4,phase:72},{axis:"x",rotations:-3,phase:108},{axis:"z",rotations:2,phase:144},{axis:"y",rotations:-3.5,phase:180},{axis:"x",rotations:2.5,phase:216},{axis:"z",rotations:-4,phase:252},{axis:"y",rotations:3,phase:288},{axis:"x",rotations:-2,phase:324}],scaleVariance:.35,lifetimeVariance:.1,blending:"normal",renderOrder:14}},shakeAmount:.05,shakeFrequency:20,explosionForce:1,endFlash:!0,decayRate:.1,glowColor:[.9,.65,.2],glowIntensityMin:.7,glowIntensityMax:1.3,glowFlickerRate:8,scaleVibration:.02,scaleFrequency:8,tremor:.02,tremorFrequency:10}),QA({name:"eartherode",emoji:"",type:"blending",description:"Stone shell crumbles and erodes away, revealing the crystal beneath",duration:3e3,beats:4,intensity:.9,category:"transform",petrification:.9,spawnMode:[{type:"orbit",orbit:{height:"center",endHeight:"center",radius:.35,endRadius:1.8,speed:1,easing:"easeOutQuad",startScale:1,endScale:.3,orientation:"camera"},count:5,scale:.7,models:["boulder","rock-cluster","stone-slab","rock-chunk-medium","rock-cluster"],animation:{appearAt:0,disappearAt:.7,stagger:.05,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"shrink",duration:.25,easing:"easeInQuad"},parameterAnimation:{petrification:{start:.9,peak:.6,end:.15,curve:"fadeOut"}},pulse:{amplitude:.04,frequency:2,easing:"easeInOut"},emissive:{min:.3,max:.6,frequency:1.5,pattern:"sine"},rotate:[{axis:"x",rotations:1.2,phase:0},{axis:"z",rotations:-.8,phase:72},{axis:"y",rotations:1,phase:144},{axis:"x",rotations:-.9,phase:216},{axis:"z",rotations:.7,phase:288}],cutout:{strength:.5,primary:{pattern:8,scale:1.2,weight:1},secondary:{pattern:0,scale:1.5,weight:.3},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"fadeOut",fadeOutDuration:.5},atmospherics:[{preset:"earth-dust",targets:null,anchor:"around",intensity:.5,sizeScale:1.2,progressCurve:"sustain"}],scaleVariance:.3,lifetimeVariance:.15,blending:"normal",renderOrder:6}},{type:"radial-burst",radialBurst:{count:6,radius:.25,endRadius:1.8,angleSpread:360,startAngle:15,orientation:"camera",startScale:.5,endScale:.1,scaleEasing:"easeInQuad"},count:6,scale:.5,models:["rock-chunk-small","rock-chunk-medium","rock-chunk-small","rock-chunk-small","rock-cluster","rock-chunk-small"],animation:{appearAt:.15,disappearAt:.8,stagger:.06,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"burst-fade",duration:.2,easing:"easeIn",burstScale:.8},emissive:{min:.2,max:.5,frequency:2,pattern:"sine"},rotate:[{axis:"z",rotations:1.5,phase:0},{axis:"x",rotations:-1.2,phase:60},{axis:"y",rotations:1.8,phase:120},{axis:"z",rotations:-1,phase:180},{axis:"x",rotations:1.3,phase:240},{axis:"y",rotations:-1.5,phase:300}],atmospherics:[{preset:"earth-gravel",targets:null,anchor:"below",intensity:.4,sizeScale:.6,progressCurve:"burst"}],scaleVariance:.3,lifetimeVariance:.2,blending:"normal",renderOrder:10}},{type:"anchor",anchor:{landmark:"feet",offset:{x:0,y:-.02,z:0},orientation:"flat",startScale:.4,endScale:2,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["earth-ring"],animation:{appearAt:.2,disappearAt:.75,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},cutout:{strength:.6,primary:{pattern:8,scale:1.5,weight:1},secondary:{pattern:7,scale:2,weight:.5},blend:"add",travel:"radial",travelSpeed:2,strengthCurve:"fadeOut",fadeOutDuration:.5},grain:{type:3,strength:.25,scale:.25,speed:1.5,blend:"multiply"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"above",intensity:.4,sizeScale:1.5,progressCurve:"sustain"}],blending:"normal",renderOrder:4,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:1,arcCount:2},orientationOverride:"flat"}}}}],fadeOut:!0,fadeStartAt:.5,fadeEndAt:.95,fadeCurve:"accelerating",scaleShrink:.08,decayRate:.25,glowColor:[.7,.5,.25],glowIntensityMin:.3,glowIntensityMax:.6,glowFlickerRate:1.5,tremor:.006,tremorFrequency:3,tremorDecay:.7}),QA({name:"earthmeditation",emoji:"",type:"blending",description:"Stone weave  earth hexagon meditation",duration:4e3,beats:8,intensity:.7,mascotGlow:.3,category:"emanating",petrification:.3,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,atmospherics:[{preset:"earth-dust",intensity:.15,sizeScale:.5,progressCurve:"sustain"}],modelOverrides:{"earth-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"earth-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"earth-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"earth-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"earth-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"earth-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[.8,.55,.25],glowIntensityMin:.3,glowIntensityMax:.6,glowFlickerRate:2,scaleVibration:0,scaleFrequency:0,scaleContract:0,tremor:0,tremorFrequency:0,shakeAmount:0,shakeFrequency:0,decayRate:.2}),QA({name:"earthcrown",emoji:"",type:"blending",description:"Heavy stone crown hovering above the head, grinding with seismic energy",duration:3e3,beats:4,intensity:1,mascotGlow:.2,category:"manifestation",petrification:.6,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.2}},count:1,scale:2.2,models:["earth-crown"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.03,frequency:1.5,easing:"easeInOut"},emissive:{min:.6,max:1,frequency:1,pattern:"sine"},rotate:{axis:"z",rotations:.3,phase:0},wetness:{wetness:.65,wetSpeed:.4},atmospherics:[{preset:"earth-dust",targets:["earth-crown"],anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:10,modelOverrides:{"earth-crown":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},decayRate:.2,glowColor:[.85,.6,.25],glowIntensityMin:.5,glowIntensityMax:.8,glowFlickerRate:1.5,scaleVibration:.005,scaleFrequency:1.5,scalePulse:!0,rotationDrift:.008,tremor:.003,tremorFrequency:3}),QA({name:"earthdance",emoji:"",type:"blending",description:"Vertical stone rings dancing and rising",duration:1500,beats:3,intensity:1.3,category:"manifestation",petrification:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.6,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["earth-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.65,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:1.2,weight:.5},blend:"add",travel:"angular",travelSpeed:2,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28}},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},atmospherics:[{preset:"earth-dust",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],parameterAnimation:{petrification:{start:.5,peak:.75,end:.55,curve:"bell"}},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:.8,max:1.6,frequency:6,pattern:"sine"},rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:11,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.85,.6,.25],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.018,scaleFrequency:4,scaleGrowth:.025,tremor:.005,tremorFrequency:3}),QA({name:"earthhelix",emoji:"",type:"blending",description:"DNA-style double helix ascending stone",duration:2e3,beats:4,intensity:1.2,category:"manifestation",petrification:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.8,endScale:1.1,startDiameter:1.6,endDiameter:1.8,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:1.2,models:["earth-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{petrification:{start:.5,peak:.85,end:.6,curve:"bell"}},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:.9,max:2,frequency:6,pattern:"smooth"},cutout:{strength:.7,primary:{pattern:8,scale:1.5,weight:1},secondary:{pattern:3,scale:1.2,weight:.5},blend:"max",travel:"angular",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.15,scale:.2,speed:1,blend:"multiply"},atmospherics:[{preset:"earth-dust",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.2,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.85,.6,.25],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:8,scaleVibration:.012,scaleFrequency:5,scaleGrowth:.02,tremor:.003,tremorFrequency:4}),QA({name:"earthpillar",emoji:"",type:"blending",description:"Majestic rising pillar of stone",duration:3e3,beats:4,intensity:1.3,mascotGlow:.4,category:"manifestation",petrification:.8,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:0},count:1,scale:1.6,models:["earth-ring"],animation:{...KA,cutout:{strength:.55,primary:{pattern:0,scale:1.2,weight:1},secondary:{pattern:8,scale:1.5,weight:.4},blend:"add",travel:"angular",travelSpeed:1.2,strengthCurve:"fadeIn",fadeInDuration:.3,geometricMask:{type:"distance",core:.1,tip:.25}},rotate:{axis:"z",rotations:.3,phase:0}}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:.5},count:1,scale:1.6,models:["earth-ring"],animation:{...KA,cutout:{strength:.6,primary:{pattern:8,scale:1.4,weight:1},secondary:{pattern:3,scale:1.2,weight:.5},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"tip-boost",core:0,tip:.2}},rotate:{axis:"z",rotations:-.5,phase:60}}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:1},count:1,scale:1.6,models:["earth-ring"],animation:{...KA,cutout:{strength:.65,primary:{pattern:3,scale:1.3,weight:1},secondary:{pattern:7,scale:1.5,weight:.4},blend:"add",travel:"oscillate",travelSpeed:2,strengthCurve:"fadeOut",fadeOutDuration:.4,geometricMask:{type:"distance",core:.15,tip:.3}},rotate:{axis:"z",rotations:.7,phase:90}}}],glowColor:[.85,.6,.25],glowIntensityMin:.8,glowIntensityMax:1.6,glowFlickerRate:5,scaleVibration:.008,scaleFrequency:3,scaleGrowth:.025,tremor:.002,tremorFrequency:2}),QA({name:"earthdrill",emoji:"",type:"blending",description:"Fast tight descending stone helix",duration:1200,beats:2,intensity:1.5,category:"manifestation",petrification:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:1.4,models:["earth-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{petrification:{start:.4,peak:.8,end:.5,curve:"bell"}},cutout:{strength:.55,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:.8,weight:.35},blend:"add",travel:"vertical",travelSpeed:3,strengthCurve:"constant"},grain:{type:3,strength:.3,scale:.2,speed:4,blend:"multiply"},atmospherics:[{preset:"earth-dust",targets:null,anchor:"below",intensity:.3,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],pulse:{amplitude:.08,frequency:10,easing:"linear"},rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.85,.6,.25],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03,tremor:.006,tremorFrequency:8}),QA({name:"earthflourish",emoji:"",type:"blending",description:"Spinning stone flourish with crossing arcs",duration:1200,beats:4,intensity:1.3,mascotGlow:.3,category:"manifestation",petrification:.6,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:5,spacing:0,arcOffset:72,phaseOffset:.05,zOffset:0},count:5,scale:1.5,models:["earth-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{petrification:{start:.35,peak:.7,end:.2,curve:"bell"}},cutout:{strength:.6,primary:{pattern:3,scale:1,weight:1},secondary:{pattern:8,scale:.6,weight:.5},blend:"multiply",strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.6,softness:1.5}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4}],pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.9,.8,.7,.6],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"z",rotations:1.8,phase:144},{axis:"z",rotations:-2.3,phase:216},{axis:"z",rotations:2,phase:288}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",depthWrite:!1,renderOrder:-8,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.2,models:["earth-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{petrification:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},secondary:{pattern:3,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:-45}],blending:"normal",depthWrite:!1,renderOrder:-6,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.2,models:["earth-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{petrification:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},secondary:{pattern:3,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:45}],blending:"normal",depthWrite:!1,renderOrder:-6,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:1.5,models:["earth-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{petrification:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},secondary:{pattern:8,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"normal",depthWrite:!1,renderOrder:-10,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:1.5,models:["earth-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{petrification:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},secondary:{pattern:8,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"normal",depthWrite:!1,renderOrder:-10,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],glowColor:[.85,.6,.25],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.012,scaleFrequency:8,scaleGrowth:.015,tremor:.003,tremorFrequency:4}),QA({name:"earthvortex",emoji:"",type:"blending",description:"Funnel of stone rings narrowing at top, wide at base",duration:1500,beats:5,intensity:1.4,category:"manifestation",petrification:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.2,startDiameter:.6,endDiameter:2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1.5,models:["earth-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.1},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2,frequency:5,pattern:"sine"},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"around",intensity:.4,sizeScale:1.2,progressCurve:"sustain"},{preset:"earth-gravel",targets:["earth-ring"],anchor:"around",intensity:.2,sizeScale:.6,progressCurve:"sustain"}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:12,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:5,arcCount:1},orientationOverride:"flat"}}}},decayRate:.2,glowColor:[.85,.6,.25],glowIntensityMin:.6,glowIntensityMax:1,glowFlickerRate:2,scaleVibration:.008,scaleFrequency:3,scalePulse:!0,tremor:.006,tremorFrequency:4}),QA({name:"earthbarrage",emoji:"",type:"blending",description:"Rocks orbit mascot then launch outward in all directions",duration:2e3,beats:4,intensity:1.3,category:"manifestation",petrification:.7,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1,endRadius:2.5,speed:2,easing:"easeIn",startScale:1,endScale:.7,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.2,models:["rock-chunk-medium","boulder","rock-chunk-medium","boulder","rock-chunk-medium"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.12,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.2},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.06,frequency:3,easing:"easeInOut"},emissive:{min:.5,max:.9,frequency:2,pattern:"sine"},rotate:[{axis:"x",rotations:1.5,phase:0},{axis:"y",rotations:-2,phase:40},{axis:"z",rotations:1.5,phase:100},{axis:"x",rotations:-1.5,phase:180},{axis:"y",rotations:2,phase:250}],atmospherics:[{preset:"earth-gravel",targets:["rock-chunk-medium","boulder"],anchor:"below",intensity:.3,sizeScale:.6,progressCurve:"sustain"},{preset:"earth-dust",targets:["rock-chunk-medium"],anchor:"around",intensity:.2,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.25,lifetimeVariance:.1,blending:"normal",renderOrder:12}},decayRate:.2,glowColor:[.85,.6,.25],glowIntensityMin:.5,glowIntensityMax:.9,glowFlickerRate:3,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,tremor:.005,tremorFrequency:4}),QA({name:"earthimpact",emoji:"",type:"blending",description:"Converging orbital rocks slam inward to mascot center",duration:1500,beats:3,intensity:1.5,category:"manifestation",petrification:.8,spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:2.5,endRadius:.3,speed:2,easing:"easeOut",startScale:.6,endScale:1.2,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1,models:["rock-chunk-small","rock-cluster","rock-chunk-small","rock-cluster","rock-chunk-small"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"burst-fade",duration:.1,easing:"easeIn",burstScale:1.5},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.08,frequency:4,easing:"easeInOut"},emissive:{min:.6,max:1.1,frequency:3,pattern:"sine"},rotate:[{axis:"x",rotations:2,phase:0},{axis:"z",rotations:-1.5,phase:72},{axis:"y",rotations:2.5,phase:144},{axis:"x",rotations:-2,phase:216},{axis:"z",rotations:1.5,phase:288}],atmospherics:[{preset:"earth-gravel",targets:["rock-chunk-medium","boulder"],anchor:"below",intensity:.4,sizeScale:.7,progressCurve:"burst"},{preset:"earth-dust",targets:["boulder"],anchor:"above",intensity:.3,sizeScale:1,progressCurve:"burst"}],scaleVariance:.2,lifetimeVariance:.08,blending:"normal",renderOrder:12}},decayRate:.15,glowColor:[.85,.6,.25],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:3,shakeAmount:.015,shakeFrequency:15,tremor:.008,tremorFrequency:5,endFlash:!0}),QA({name:"earthblast",emoji:"",type:"blending",description:"Seismic detonation with expanding shockwave and rock debris",duration:1200,beats:2,intensity:1.8,category:"manifestation",petrification:.9,distortionStrength:1.5,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera"},startScale:.2,endScale:3.5,scaleEasing:"easeOutCubic",count:1,scale:1.8,models:["earth-ring"],animation:{appearAt:0,disappearAt:.3,enter:{type:"flash",duration:.02,easing:"linear"},exit:{type:"fade",duration:.1,easing:"easeIn"},emissive:{min:.8,max:1.5,frequency:8,pattern:"sine"},blending:"normal",renderOrder:10},modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}},{type:"radial-burst",radialBurst:{count:8,radius:.15,endRadius:2,angleSpread:360,startAngle:22,orientation:"camera"},startScale:.2,endScale:1,scaleEasing:"easeOutQuad",count:8,scale:.9,models:["boulder"],animation:{appearAt:.02,disappearAt:.45,stagger:.005,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.12,easing:"easeIn",burstScale:1.3},emissive:{min:.5,max:1,frequency:5,pattern:"sine"},rotate:[{axis:"z",rotations:2,phase:0},{axis:"z",rotations:-3,phase:45},{axis:"z",rotations:2.5,phase:90},{axis:"z",rotations:-2,phase:135},{axis:"z",rotations:3,phase:180},{axis:"z",rotations:-2.5,phase:225},{axis:"z",rotations:2,phase:270},{axis:"z",rotations:-3,phase:315}],atmospherics:[{preset:"earth-gravel",targets:["rock-chunk-medium","boulder"],anchor:"below",intensity:.5,sizeScale:.8,progressCurve:"burst"},{preset:"earth-dust",targets:["rock-chunk-medium"],anchor:"above",intensity:.4,sizeScale:1.2,progressCurve:"burst"}],scaleVariance:.3,blending:"normal",renderOrder:14}},{type:"radial-burst",radialBurst:{count:4,radius:.2,endRadius:1.5,angleSpread:360,startAngle:67,orientation:"camera"},startScale:.3,endScale:.7,scaleEasing:"easeOutQuad",count:4,scale:.7,models:["rock-cluster"],animation:{appearAt:.03,disappearAt:.5,stagger:.008,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},emissive:{min:.5,max:.9,frequency:4,pattern:"sine"},rotate:[{axis:"z",rotations:1.5,phase:0},{axis:"z",rotations:-2,phase:90},{axis:"z",rotations:1.5,phase:180},{axis:"z",rotations:-2,phase:270}],scaleVariance:.25,blending:"normal",renderOrder:15}}],decayRate:.1,endFlash:!0,glowColor:[.9,.65,.2],glowIntensityMin:.8,glowIntensityMax:1.5,glowFlickerRate:5,shakeAmount:.025,shakeFrequency:18,tremor:.01,tremorFrequency:6,scaleVibration:.03,scaleFrequency:8}),QA({name:"earthsurge",emoji:"",type:"blending",description:"Seismic shockwave ripples outward from the mascot",duration:1200,beats:2,intensity:1.5,category:"emanating",petrification:.8,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",speedCurve:"surge",startScale:.4,endScale:2.5,startDiameter:.5,endDiameter:3.5,orientation:"camera"},formation:{type:"spiral",count:1,spacing:0,arcOffset:0,phaseOffset:0},count:1,scale:2,models:["earth-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"fade",duration:.03,easing:"linear"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.7,primary:{pattern:8,scale:.8,weight:1},secondary:{pattern:3,scale:1.2,weight:.5},blend:"multiply",travel:"radial",travelSpeed:2,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.4,softness:1.8}},grain:{type:3,strength:.3,scale:.2,speed:3,blend:"multiply"},emissive:{min:1.2,max:2.5,frequency:1,pattern:"sine"},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"around",intensity:.5,sizeScale:1.5,progressCurve:"burst"}],blending:"normal",depthWrite:!1,renderOrder:-5,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.3,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:4,radius:.15,endRadius:2,angleSpread:360,startAngle:45,orientation:"camera",startScale:.4,endScale:1,scaleEasing:"easeOutQuad"},count:4,scale:.7,models:["rock-chunk-medium","rock-cluster","rock-chunk-medium","rock-chunk-small"],animation:{appearAt:.05,disappearAt:.55,stagger:.01,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"burst-fade",duration:.2,easing:"easeIn",burstScale:1.3},emissive:{min:.6,max:1,frequency:2,pattern:"sine"},rotate:[{axis:"x",rotations:1.5,phase:0},{axis:"z",rotations:-1.2,phase:90},{axis:"y",rotations:1.8,phase:180},{axis:"x",rotations:-1,phase:270}],atmospherics:[{preset:"earth-gravel",targets:null,anchor:"around",intensity:.4,sizeScale:.6,progressCurve:"burst"}],scaleVariance:.3,blending:"normal",renderOrder:12}}],distortionStrength:1.5,decayRate:.15,glowColor:[.85,.6,.25],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:4,beaconPulse:!0,scaleVibration:.015,scaleFrequency:6,tremor:.012,tremorFrequency:8,shakeAmount:.015,shakeFrequency:14}),QA({name:"earthtwirl",emoji:"",type:"blending",description:"Relay earth illusion  arc weaves through three interlocked rings",duration:1500,beats:2,intensity:1.5,category:"afflicted",growth:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"earth-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"earth-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.52,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:1.15,sizeVariance:0,models:["earth-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"earth-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[.85,.6,.25],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.006,tremorFrequency:8,shakeAmount:.01,shakeFrequency:12,decayRate:.15}),QA({name:"earthshield",emoji:"",type:"blending",description:"Gyroscopic earth cage  six tumbling rings form a protective stone barrier",duration:3e3,beats:4,intensity:1,mascotGlow:.3,category:"manifestation",petrification:.8,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.3}},count:1,scale:1.5,models:["earth-ring"],animation:{...ZA,appearAt:0,rotate:{axis:"x",rotations:.75,phase:0},renderOrder:6,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.35}},count:1,scale:1.5,models:["earth-ring"],animation:{...ZA,appearAt:.03,rotate:{axis:"y",rotations:-.75,phase:0},renderOrder:8,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.4}},count:1,scale:1.5,models:["earth-ring"],animation:{...ZA,appearAt:.06,rotate:{axis:"x",rotations:.75,phase:60},renderOrder:10,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.45}},count:1,scale:1.5,models:["earth-ring"],animation:{...ZA,appearAt:.09,rotate:{axis:"y",rotations:-.75,phase:120},renderOrder:12,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.38}},count:1,scale:1.5,models:["earth-ring"],animation:{...ZA,appearAt:.12,rotate:{axis:"x",rotations:.75,phase:45},renderOrder:14,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.42}},count:1,scale:1.5,models:["earth-ring"],animation:{...ZA,appearAt:.15,rotate:{axis:"y",rotations:-.75,phase:-45},atmospherics:[{preset:"earth-dust",targets:["earth-ring"],anchor:"around",intensity:.2,sizeScale:.7,progressCurve:"sustain"}],renderOrder:16,modelOverrides:{"earth-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.55,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[.85,.6,.25],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,tremor:.002,tremorFrequency:2,decayRate:.2}),tC({name:"natureentangle",emoji:"",type:"blending",description:"Vine squeeze  wrapping rings tighten while organic growths grip the surface",duration:2500,beats:4,intensity:1.2,category:"afflicted",growth:.7,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"above",end:"center",endOffset:-.15,easing:"easeOut",startScale:1,endScale:1,startDiameter:1.5,endDiameter:1,diameterUnit:"mascot",holdAt:.75,orientation:"flat"},formation:{type:"spiral",count:6,spacing:.12,arcOffset:60,phaseOffset:.03},count:6,scale:2,models:["vine-ring"],animation:{appearAt:0,disappearAt:.95,stagger:.05,enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{growth:{start:.4,peak:.8,end:.6,curve:"bell"}},pulse:{amplitude:.05,frequency:2,easing:"easeInOut"},emissive:{min:.5,max:1,frequency:2,pattern:"sine"},cutout:{strength:.5,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:0,scale:2,weight:.35},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"fadeIn"},grain:{type:3,strength:.2,scale:.3,speed:.8,blend:"multiply"},rotate:[{axis:"z",rotations:.8,phase:0},{axis:"z",rotations:-1.2,phase:45},{axis:"z",rotations:1.5,phase:120},{axis:"z",rotations:-.6,phase:200},{axis:"z",rotations:1,phase:270},{axis:"z",rotations:-1.4,phase:160}],blending:"normal",renderOrder:12,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:2},orientationOverride:"flat"}},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.4,sizeScale:.8,progressCurve:"sustain"}]}},{type:"surface",pattern:"shell",embedDepth:.15,cameraFacing:.35,clustering:.1,minDistance:.1,count:6,scale:1,models:["vine-twist","thorn-curl","s-vine"],animation:{appearAt:.1,disappearAt:.85,stagger:.05,enter:{type:"grow",duration:.15,easing:"easeOutQuad"},exit:{type:"shrink",duration:.2,easing:"easeInQuad"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.08,frequency:2.5,easing:"easeInOut",sync:"global"},emissive:{min:.4,max:.9,frequency:2,pattern:"sine"},rotate:{axis:"y",speed:.01,oscillate:!0,range:Math.PI/10},drift:{direction:"inward",speed:.012,noise:.06},scaleVariance:.2,blending:"normal",renderOrder:8,modelOverrides:{"vine-twist":{scaling:{mode:"non-uniform",axes:{x:1.2,y:.8,z:1.2}}},"thorn-curl":{scaling:{mode:"non-uniform",axes:{x:.85,y:1.5,z:.85}}},"s-vine":{scaling:{mode:"non-uniform",axes:{x:.7,y:1.6,z:.7}}}}}}],glowColor:[.2,.7,.25],glowIntensityMin:.5,glowIntensityMax:1,glowFlickerRate:3,scaleVibration:.012,scaleFrequency:3,tremor:.004,tremorFrequency:4,decayRate:.18,parameterAnimation:{growth:{keyframes:[{at:0,value:.3},{at:.3,value:.7},{at:.65,value:.85},{at:.8,value:.6},{at:1,value:0}]},tremor:{keyframes:[{at:0,value:.004},{at:.5,value:.004},{at:.7,value:.012},{at:.85,value:.018},{at:1,value:0}]}}}),tC({name:"natureroot",emoji:"",type:"blending",description:"Root system burrowing  vine rings descend while surface tendrils anchor below",duration:2e3,beats:4,intensity:1,category:"afflicted",growth:.6,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"bottom",endOffset:-.1,easing:"easeIn",startScale:1,endScale:1,startDiameter:1,endDiameter:1,diameterUnit:"mascot",holdAt:.75,orientation:"flat"},formation:{type:"spiral",count:5,spacing:.12,arcOffset:72,phaseOffset:.03},count:5,scale:1.3,models:["vine-ring"],animation:{appearAt:0,disappearAt:.95,stagger:.06,enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{growth:{start:.4,peak:.75,end:.5,curve:"bell"}},pulse:{amplitude:.04,frequency:2,easing:"easeInOut"},emissive:{min:.4,max:.8,frequency:2,pattern:"sine"},cutout:{strength:.55,primary:{pattern:8,scale:1.2,weight:1},secondary:{pattern:3,scale:1.5,weight:.4},blend:"max",travel:"vertical",travelSpeed:1.5,strengthCurve:"fadeIn"},grain:{type:3,strength:.15,scale:.25,speed:.5,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.35,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.2}],rotate:[{axis:"z",rotations:.5,phase:0},{axis:"z",rotations:-.8,phase:72},{axis:"z",rotations:.6,phase:144},{axis:"z",rotations:-.4,phase:216},{axis:"z",rotations:.7,phase:288}],scaleVariance:.1,lifetimeVariance:.1,blending:"normal",renderOrder:12,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1,arcCount:1},orientationOverride:"flat"}}}},{type:"surface",pattern:"crown",embedDepth:.2,cameraFacing:.25,clustering:.15,minDistance:.15,count:5,scale:.9,models:["vine-twist","s-vine","thorn-curl"],animation:{appearAt:.12,disappearAt:.85,stagger:.06,enter:{type:"grow",duration:.15,easing:"easeOutCubic"},exit:{type:"shrink",duration:.15,easing:"easeIn"},pulse:{amplitude:.05,frequency:2,easing:"easeInOut"},emissive:{min:.3,max:.7,frequency:2,pattern:"sine"},drift:{direction:"down",speed:.01,noise:.06},scaleVariance:.2,blending:"normal",renderOrder:8,modelOverrides:{"vine-twist":{scaling:{mode:"non-uniform",axes:{x:1.1,y:.7,z:1.1}}},"s-vine":{scaling:{mode:"non-uniform",axes:{x:.7,y:1.4,z:.7}}}}}}],glowColor:[.35,.5,.2],glowIntensityMin:.45,glowIntensityMax:.7,glowFlickerRate:2,scaleVibration:.008,scaleFrequency:2,tremor:.002,tremorFrequency:3,decayRate:.2,parameterAnimation:{growth:{keyframes:[{at:0,value:.2},{at:.3,value:.6},{at:.6,value:.75},{at:.85,value:.5},{at:1,value:0}]}}}),tC({name:"naturetwirl",emoji:"",type:"blending",description:"Relay vine illusion  arc weaves through three interlocked rings",duration:1500,beats:2,intensity:1.5,category:"afflicted",growth:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.12,sizeScale:.6,progressCurve:"sustain"}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.45,y:-.26,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.12,sizeScale:.6,progressCurve:"sustain"}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.52,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.12,sizeScale:.6,progressCurve:"sustain"}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}}],glowColor:[.25,.75,.2],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.006,tremorFrequency:8,shakeAmount:.01,shakeFrequency:12,decayRate:.15}),tC({name:"natureconstrict",emoji:"",type:"blending",description:"Living squeeze  giant vine shapes orbit wide then constrict onto the mascot",duration:2500,beats:4,intensity:1,category:"emanating",growth:.85,spawnMode:[{type:"orbit",orbit:{height:"center",endHeight:"center",radius:.5,endRadius:0,speed:.4,easing:"easeInCubic",startScale:0,endScale:1,orientation:"camera"},formation:{type:"ring",count:4},count:4,scale:2.5,models:["s-vine","vine-twist","thorn-curl","u-vine"],animation:{appearAt:0,disappearAt:.8,stagger:.12,enter:{type:"scale",duration:.2,easing:"easeOutBack"},exit:{type:"scale",duration:.25,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.06,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.6,max:1.3,frequency:1.5,pattern:"sine"},rotate:[{axis:"z",rotations:.15,phase:0},{axis:"z",rotations:-.25,phase:45},{axis:"z",rotations:.1,phase:120},{axis:"z",rotations:-.2,phase:200}],cutout:{strength:.5,primary:{pattern:6,scale:1.2,weight:1},secondary:{pattern:3,scale:2,weight:.4},blend:"multiply",travel:"spiral",travelSpeed:.8,strengthCurve:"bell",bellPeakAt:.5},grain:{type:3,strength:.08,scale:.3,speed:.4,blend:"multiply"},scaleVariance:.2,blending:"normal",renderOrder:8,modelOverrides:{"s-vine":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:.6,arcCount:1},orientationOverride:"camera"},"vine-twist":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:.5,arcCount:1},orientationOverride:"camera"},"thorn-curl":{shaderAnimation:{type:1,arcWidth:.4,arcSpeed:.7,arcCount:2},orientationOverride:"camera"},"u-vine":{shaderAnimation:{type:1,arcWidth:.55,arcSpeed:.5,arcCount:1},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:0,endScale:1,scaleEasing:"easeOutCubic",bob:{amplitude:.01,frequency:.3}},count:1,scale:2,models:["vine-cluster"],animation:{appearAt:.25,disappearAt:.8,enter:{type:"scale",duration:.25,easing:"easeOutBack"},exit:{type:"scale",duration:.25,easing:"easeInCubic"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.05,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.7,max:1.4,frequency:1.5,pattern:"sine"},rotate:{axis:"z",rotations:-.2,phase:90},cutout:{strength:.4,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:6,scale:2.5,weight:.3},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"bell",bellPeakAt:.5},grain:{type:3,strength:.06,scale:.3,speed:.3,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.4,sizeScale:.8,progressCurve:"sustain"}],blending:"normal",renderOrder:6,modelOverrides:{"vine-cluster":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.4,arcCount:2},orientationOverride:"camera"}}}}],glowColor:[.4,.85,.3],glowIntensityMin:.6,glowIntensityMax:1.2,glowFlickerRate:3,scaleVibration:.01,scaleFrequency:2,tremor:.003,tremorFrequency:3,decayRate:.18,parameterAnimation:{growth:{keyframes:[{at:0,value:.3},{at:.2,value:.6},{at:.5,value:.85},{at:.7,value:.95},{at:.85,value:.6},{at:1,value:0}]},tremor:{keyframes:[{at:0,value:.003},{at:.4,value:.003},{at:.6,value:.008},{at:.75,value:.018},{at:.85,value:.005},{at:1,value:0}]},scaleVibration:{keyframes:[{at:0,value:.01},{at:.5,value:.01},{at:.7,value:.03},{at:.85,value:.01},{at:1,value:0}]}}}),tC({name:"naturebloom",emoji:"",type:"blending",description:"Canopy growth  trunk rises, then branches spread with falling leaves",duration:2e3,beats:4,intensity:1.2,category:"emanating",growth:.8,mascotGlow:.8,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"center",easing:"easeOutCubic",startScale:1,endScale:.7,startDiameter:.5,endDiameter:.3,diameterUnit:"mascot",holdAt:.4,orientation:"flat"},formation:{type:"stack",count:3,spacing:.25},count:3,scale:2,models:["vine-ring"],animation:{appearAt:0,disappearAt:.8,stagger:.06,enter:{type:"scale",duration:.1,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeInCubic"},procedural:{scaleSmoothing:.06,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.6,max:1.2,frequency:2,pattern:"sine"},rotate:[{axis:"z",rotations:.2,phase:0},{axis:"z",rotations:-.25,phase:60},{axis:"z",rotations:.15,phase:120}],cutout:{strength:.5,primary:{pattern:3,scale:3,weight:1},secondary:{pattern:0,scale:5,weight:.3},blend:"add",travel:"vertical",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.05,scale:.3,speed:.4,blend:"multiply"},blending:"normal",renderOrder:6,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:1.5,arcCount:1},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.15,z:0},orientation:"flat",startScale:.2,endScale:1,scaleEasing:"easeOutCubic",bob:{amplitude:.01,frequency:.3}},count:1,scale:4.5,models:["vine-ring"],animation:{appearAt:.25,disappearAt:.85,enter:{type:"scale",duration:.2,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.04,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:1.5,pattern:"sine"},rotate:{axis:"x",rotations:.4,phase:0},cutout:{strength:.4,primary:{pattern:6,scale:1.5,weight:1},secondary:{pattern:0,scale:2.5,weight:.3},blend:"add",travel:"spiral",travelSpeed:.5,strengthCurve:"bell",bellPeakAt:.5},grain:{type:3,strength:.08,scale:.3,speed:.3,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.5,sizeScale:.9,progressCurve:"sustain",velocityInheritance:.3}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.35,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.1,z:0},orientation:"radial",startScale:.2,endScale:1,scaleEasing:"easeOutCubic",bob:{amplitude:.008,frequency:.35}},count:1,scale:4.5,models:["vine-ring"],animation:{appearAt:.3,disappearAt:.85,enter:{type:"scale",duration:.2,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.04,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:1.5,pattern:"sine"},rotate:{axis:"y",rotations:-.35,phase:0},grain:{type:3,strength:.08,scale:.3,speed:.3,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.3,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.25}],blending:"normal",renderOrder:12,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:.3,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.1,z:0},orientation:"radial",startScale:.2,endScale:1,scaleEasing:"easeOutCubic",bob:{amplitude:.008,frequency:.4}},count:1,scale:4.5,models:["vine-ring"],animation:{appearAt:.35,disappearAt:.85,enter:{type:"scale",duration:.2,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.04,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:1.5,pattern:"sine"},rotate:{axis:"x",rotations:.35,phase:90},grain:{type:3,strength:.08,scale:.3,speed:.3,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.3,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.25}],blending:"normal",renderOrder:14,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:.3,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.1,z:0},orientation:"radial",startScale:.2,endScale:1,scaleEasing:"easeOutCubic",bob:{amplitude:.008,frequency:.45}},count:1,scale:4.5,models:["vine-ring"],animation:{appearAt:.4,disappearAt:.85,enter:{type:"scale",duration:.2,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.04,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:1.5,pattern:"sine"},rotate:{axis:"y",rotations:-.4,phase:180},grain:{type:3,strength:.08,scale:.3,speed:.3,blend:"multiply"},blending:"normal",renderOrder:16,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:.3,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.1,z:0},orientation:"radial",startScale:.2,endScale:1,scaleEasing:"easeOutCubic",bob:{amplitude:.008,frequency:.38}},count:1,scale:4.5,models:["vine-ring"],animation:{appearAt:.45,disappearAt:.85,enter:{type:"scale",duration:.2,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.04,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:1,frequency:1.5,pattern:"sine"},rotate:{axis:"x",rotations:.3,phase:270},grain:{type:3,strength:.08,scale:.3,speed:.3,blend:"multiply"},blending:"normal",renderOrder:18,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:.3,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[.3,.8,.25],glowIntensityMin:.8,glowIntensityMax:1.5,glowFlickerRate:3,scaleVibration:.01,scaleFrequency:2,tremor:.003,tremorFrequency:3,decayRate:.16,parameterAnimation:{growth:{keyframes:[{at:0,value:.3},{at:.15,value:.6},{at:.35,value:.75},{at:.6,value:.95},{at:.8,value:.7},{at:1,value:0}]},scaleVibration:{keyframes:[{at:0,value:.01},{at:.5,value:.01},{at:.7,value:.02},{at:.85,value:.03},{at:1,value:0}]}}}),tC({name:"naturecrown",emoji:"",type:"blending",description:"Living vine crown hovering above the head",duration:3e3,beats:4,intensity:1,mascotGlow:.3,category:"emanating",growth:.8,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.2}},count:1,scale:2.2,models:["nature-crown"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.03,frequency:1.5,easing:"easeInOut"},emissive:{min:.6,max:1,frequency:1,pattern:"sine"},rotate:{axis:"z",rotations:.3,phase:0},atmospherics:[{preset:"falling-leaves",targets:["nature-crown"],anchor:"around",intensity:.15,sizeScale:.6,progressCurve:"sustain"}],scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:10,modelOverrides:{"nature-crown":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},glowColor:[.3,.8,.25],glowIntensityMin:.7,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,scaleGrow:.005,tremor:0,tremorFrequency:0,tremorDecay:0,decayRate:.2}),tC({name:"naturedance",emoji:"",type:"blending",description:"Vertical vine rings dancing and rising",duration:1500,beats:3,intensity:1.3,category:"emanating",growth:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.6,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["vine-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.65,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:1.2,weight:.5},blend:"add",travel:"angular",travelSpeed:2,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28}},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.4,sizeScale:.9,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],parameterAnimation:{growth:{start:.5,peak:.75,end:.55,curve:"bell"}},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:.8,max:1.6,frequency:6,pattern:"sine"},rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:11,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.4,.85,.35],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.018,scaleFrequency:4,scaleGrow:.025,tremor:.005,tremorFrequency:3}),tC({name:"naturedrill",emoji:"",type:"blending",description:"Fast tight descending vine helix",duration:1200,beats:2,intensity:1.5,category:"manifestation",growth:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:1.4,models:["vine-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{growth:{start:.4,peak:.8,end:.5,curve:"bell"}},cutout:{strength:.55,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:.8,weight:.35},blend:"add",travel:"vertical",travelSpeed:3,strengthCurve:"constant"},grain:{type:3,strength:.3,scale:.2,speed:4,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.4,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],pulse:{amplitude:.08,frequency:10,easing:"linear"},rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.2,.6,.15],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03,tremor:.006,tremorFrequency:8}),tC({name:"natureflourish",emoji:"",type:"blending",description:"Spinning vine flourish with crossing arcs",duration:1200,beats:4,intensity:1.3,mascotGlow:.3,category:"manifestation",growth:.6,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:5,spacing:0,arcOffset:72,phaseOffset:.05,zOffset:0},count:5,scale:2.2,models:["vine-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{growth:{start:.35,peak:.7,end:.2,curve:"bell"}},cutout:{strength:.6,primary:{pattern:3,scale:1,weight:1},secondary:{pattern:8,scale:.6,weight:.5},blend:"multiply",strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.6,softness:1.5}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.4,sizeScale:.9,progressCurve:"sustain",velocityInheritance:.4}],pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.9,.8,.7,.6],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"z",rotations:1.8,phase:144},{axis:"z",rotations:-2.3,phase:216},{axis:"z",rotations:2,phase:288}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",depthWrite:!1,renderOrder:-8,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.8,models:["vine-ring"],animation:{appearAt:.12,disappearAt:.45,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{growth:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},secondary:{pattern:3,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:-45}],blending:"normal",depthWrite:!1,renderOrder:-6,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.8,models:["vine-ring"],animation:{appearAt:.12,disappearAt:.45,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{growth:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},secondary:{pattern:3,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:45}],blending:"normal",depthWrite:!1,renderOrder:-6,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:2.2,models:["vine-ring"],animation:{appearAt:.3,disappearAt:.6,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{growth:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},secondary:{pattern:8,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"normal",depthWrite:!1,renderOrder:-10,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:2.2,models:["vine-ring"],animation:{appearAt:.3,disappearAt:.6,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{growth:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},secondary:{pattern:8,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"normal",depthWrite:!1,renderOrder:-10,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],glowColor:[.4,.9,.3],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.012,scaleFrequency:8,scaleGrowth:.015,tremor:.003,tremorFrequency:4}),tC({name:"naturehelix",emoji:"",type:"blending",description:"DNA-style double helix ascending vine",duration:2e3,beats:4,intensity:1.2,category:"manifestation",growth:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.8,endScale:1.1,startDiameter:1.6,endDiameter:1.8,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:2,models:["vine-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{growth:{start:.5,peak:.85,end:.6,curve:"bell"}},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:.9,max:2,frequency:6,pattern:"smooth"},cutout:{strength:.7,primary:{pattern:8,scale:1.5,weight:1},secondary:{pattern:3,scale:1.2,weight:.5},blend:"max",travel:"angular",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.15,scale:.2,speed:1,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.4,sizeScale:.9,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.2,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.25,.7,.2],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:8,scaleVibration:.012,scaleFrequency:5,scaleGrowth:.02,tremor:.003,tremorFrequency:4}),tC({name:"naturemeditation",emoji:"",type:"blending",description:"Dual vine weave  nature hexagon meditation",duration:4e3,beats:8,intensity:.7,category:"emanating",growth:.3,mascotGlow:.4,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.3,sizeScale:.7,progressCurve:"sustain"}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:0,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:3.14,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:5,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:4.71,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:1.05,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:4.19,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:2.62,relayIndex:2,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:-3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:1.05,relayIndex:0,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.38,y:-.22,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:4.19,relayIndex:1,orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.44,z:0},orientation:"camera",cameraOffset:1,relativeOffset:!0,startScale:1,endScale:1},count:1,scale:3,sizeVariance:0,models:["vine-ring"],animation:{appearAt:.04,disappearAt:.85,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},emissive:{min:1,max:1,frequency:0,pattern:"sine"},rotate:[{axis:"z",rotations:3,phase:0}],blending:"normal",renderOrder:10,modelOverrides:{"vine-ring":{arcPhase:2.62,relayIndex:1,orientationOverride:"camera"}}}}],glowColor:[.2,.65,.25],glowIntensityMin:.3,glowIntensityMax:.6,glowFlickerRate:2,scaleVibration:0,scaleFrequency:0,scaleContract:0,tremor:0,tremorFrequency:0,shakeAmount:0,shakeFrequency:0,decayRate:.2}),tC({name:"naturepillar",emoji:"",type:"blending",description:"Towering growth  vine rings stack upward forming a tapered trunk",duration:2500,beats:5,intensity:1.2,mascotGlow:.4,category:"emanating",growth:.85,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.8,endScale:1.2,startDiameter:1.3,endDiameter:2,diameterUnit:"mascot",orientation:"flat",startOffset:0},formation:{type:"stack",count:2,spacing:.25},count:2,scale:2.2,models:["vine-ring"],animation:{...nC,stagger:.03,cutout:{strength:.5,primary:{pattern:0,scale:1.2,weight:1},secondary:{pattern:8,scale:1.5,weight:.35},blend:"add",travel:"angular",travelSpeed:1.2,strengthCurve:"fadeIn",fadeInDuration:.3},rotate:[{axis:"z",rotations:.3,phase:0},{axis:"z",rotations:-.35,phase:180}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.8,endScale:1.2,startDiameter:1.3,endDiameter:2,diameterUnit:"mascot",orientation:"flat",startOffset:.5},formation:{type:"stack",count:2,spacing:.25},count:2,scale:2.2,models:["vine-ring"],animation:{...nC,stagger:.05,cutout:{strength:.55,primary:{pattern:3,scale:1.4,weight:1},secondary:{pattern:6,scale:1.2,weight:.4},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5},rotate:[{axis:"z",rotations:-.4,phase:60},{axis:"z",rotations:.45,phase:240}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.8,endScale:1.2,startDiameter:1.3,endDiameter:2,diameterUnit:"mascot",orientation:"flat",startOffset:1},formation:{type:"stack",count:2,spacing:.25},count:2,scale:2.2,models:["vine-ring"],animation:{...nC,stagger:.07,cutout:{strength:.6,primary:{pattern:8,scale:1.3,weight:1},secondary:{pattern:3,scale:1.5,weight:.35},blend:"add",travel:"oscillate",travelSpeed:2,strengthCurve:"fadeOut",fadeOutDuration:.4},rotate:[{axis:"z",rotations:.5,phase:90},{axis:"z",rotations:-.4,phase:270}]}}],glowColor:[.25,.7,.2],glowIntensityMin:.9,glowIntensityMax:1.5,glowFlickerRate:3,scaleVibration:.015,scaleFrequency:2,scaleGrow:.03,tremor:.004,tremorFrequency:3,decayRate:.18}),tC({name:"naturevortex",emoji:"",type:"blending",description:"Spinning leaf tornado around mascot",duration:1500,beats:5,intensity:1.3,category:"emanating",growth:.8,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1,endScale:1.4,startDiameter:.8,endDiameter:2.5,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1.4,models:["vine-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.1},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:.8,max:1.8,frequency:4,pattern:"sine"},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:12,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:4,arcCount:1},orientationOverride:"flat"}},cutout:{strength:.55,primary:{pattern:6,scale:3,weight:1},secondary:{pattern:0,scale:5,weight:.35},blend:"add",travel:"spiral",travelSpeed:2.5,strengthCurve:"constant"},grain:{type:3,strength:.04,scale:.25,speed:.5,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.5,sizeScale:.8,progressCurve:"sustain"}]}},glowColor:[.3,.75,.25],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:5,scaleVibration:.02,scaleFrequency:4,scaleGrow:.03,tremor:.007,tremorFrequency:5,decayRate:.15}),tC({name:"naturebarrage",emoji:"",type:"blending",description:"Orbiting vine projectiles launching outward",duration:1500,beats:4,intensity:1.3,category:"afflicted",growth:.7,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.3,models:["vine-cluster","s-vine","u-vine","thorn-curl"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:.8,max:2,frequency:5,pattern:"sine"},rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"normal",renderOrder:12,atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.3,sizeScale:.7,progressCurve:"sustain"}]}},glowColor:[.2,.65,.2],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:5,scaleVibration:.015,scaleFrequency:4,scaleGrow:.02,tremor:.006,tremorFrequency:5,decayRate:.15}),tC({name:"natureshield",emoji:"",type:"blending",description:"Gyroscopic vine cage  six tumbling rings form a protective sphere",duration:3e3,beats:4,intensity:1,category:"emanating",growth:.7,mascotGlow:.4,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"flat",bob:{amplitude:.008,frequency:.3}},count:1,scale:4.5,models:["vine-ring"],animation:{...aC,appearAt:0,rotate:{axis:"x",rotations:.75,phase:0},renderOrder:6,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.4,arcCount:2},orientationOverride:"flat"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.35}},count:1,scale:4.5,models:["vine-ring"],animation:{...aC,appearAt:.03,rotate:{axis:"y",rotations:-.75,phase:0},renderOrder:8,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.4}},count:1,scale:4.5,models:["vine-ring"],animation:{...aC,appearAt:.06,rotate:{axis:"x",rotations:.75,phase:60},renderOrder:10,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.5,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",bob:{amplitude:.008,frequency:.45}},count:1,scale:4.5,models:["vine-ring"],animation:{...aC,appearAt:.09,rotate:{axis:"y",rotations:-.75,phase:120},renderOrder:12,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.45,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.38}},count:1,scale:4.5,models:["vine-ring"],animation:{...aC,appearAt:.12,rotate:{axis:"x",rotations:.75,phase:45},renderOrder:14,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.5,arcCount:2},orientationOverride:"radial"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"radial",bob:{amplitude:.008,frequency:.42}},count:1,scale:4.5,models:["vine-ring"],animation:{...aC,appearAt:.15,rotate:{axis:"y",rotations:-.75,phase:-45},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.2,sizeScale:.7,progressCurve:"sustain"}],renderOrder:16,modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:.55,arcCount:2},orientationOverride:"radial"}}}}],glowColor:[.15,.55,.15],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,tremor:.002,tremorFrequency:2,decayRate:.2}),tC({name:"seedburst",emoji:"",type:"blending",description:"Seed pod detonation  organic fragments blast outward in all directions",duration:1200,beats:2,intensity:1.4,category:"impact",growth:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.2,endScale:2.5,scaleEasing:"easeOutQuad"},count:1,scale:2,models:["vine-ring"],animation:{appearAt:0,disappearAt:.4,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:2,scale:1.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1.2,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.25,softness:1.2}},grain:{type:3,strength:.4,scale:.3,speed:1.5,blend:"multiply"},blending:"normal",renderOrder:8,rotate:{axis:"z",rotations:.5,phase:0},modelOverrides:{"vine-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:10,radius:.05,endRadius:2,angleSpread:360,startAngle:18,orientation:"camera",startScale:.3,endScale:1,scaleEasing:"easeOutQuad"},count:10,scale:.8,models:["thorn-curl","leaf-bunch","s-vine","vine-twist","thorn-curl","leaf-bunch","s-vine","vine-twist","thorn-curl","leaf-bunch"],animation:{appearAt:.02,disappearAt:.5,stagger:.008,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},emissive:{min:.8,max:1.5,frequency:6,pattern:"sine"},cutout:{strength:.3,primary:{pattern:5,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.5,sizeScale:.6,progressCurve:"burst"}],rotate:[{axis:"x",rotations:3,phase:0},{axis:"z",rotations:-2.5,phase:36},{axis:"y",rotations:4,phase:72},{axis:"x",rotations:-3,phase:108},{axis:"z",rotations:2,phase:144},{axis:"y",rotations:-3.5,phase:180},{axis:"x",rotations:2.5,phase:216},{axis:"z",rotations:-4,phase:252},{axis:"y",rotations:3,phase:288},{axis:"x",rotations:-2,phase:324}],scaleVariance:.35,lifetimeVariance:.1,blending:"normal",renderOrder:14}}],shakeAmount:.03,shakeFrequency:15,decayRate:.12,glowColor:[.5,.85,.3],glowIntensityMin:.8,glowIntensityMax:1.8,glowFlickerRate:8,scaleVibration:.025,scaleFrequency:6,tremor:.015,tremorFrequency:8}),tC({name:"seedpod",emoji:"",type:"blending",description:"Closing enclosure  vine rings converge from above and below to seal the mascot",duration:2500,beats:4,intensity:1.2,category:"transform",growth:.7,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"above",end:"center",easing:"easeInOutCubic",startScale:.6,endScale:1,startDiameter:.8,endDiameter:1.6,diameterUnit:"mascot",holdAt:.65,orientation:"flat"},formation:{type:"stack",count:3,spacing:.15},count:3,scale:2,models:["u-vine"],animation:{appearAt:0,disappearAt:.85,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"scale",duration:.15,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.7,max:1.4,frequency:2,pattern:"sine"},rotate:[{axis:"z",rotations:.4,phase:0},{axis:"z",rotations:-.3,phase:60},{axis:"z",rotations:.35,phase:120}],cutout:{strength:.45,primary:{pattern:6,scale:1.5,weight:1},secondary:{pattern:3,scale:2,weight:.3},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"rampUp"},grain:{type:3,strength:.05,scale:.3,speed:.4,blend:"multiply"},blending:"normal",renderOrder:10,modelOverrides:{"u-vine":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.6,arcCount:2},orientationOverride:"vertical"}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"center",easing:"easeInOutCubic",startScale:.6,endScale:1,startDiameter:.8,endDiameter:1.6,diameterUnit:"mascot",holdAt:.65,orientation:"flat"},formation:{type:"stack",count:3,spacing:.15},count:3,scale:2,models:["u-vine"],animation:{appearAt:.05,disappearAt:.85,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"scale",duration:.15,easing:"easeInCubic"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.03,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.7,max:1.4,frequency:2,pattern:"sine"},rotate:[{axis:"z",rotations:-.35,phase:30},{axis:"z",rotations:.4,phase:90},{axis:"z",rotations:-.3,phase:150}],cutout:{strength:.45,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:6,scale:2,weight:.3},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"rampUp"},grain:{type:3,strength:.05,scale:.3,speed:.4,blend:"multiply"},blending:"normal",renderOrder:10,modelOverrides:{"u-vine":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.6,arcCount:2},orientationOverride:"vertical"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:0,endScale:1,scaleEasing:"easeOutCubic",bob:{amplitude:.008,frequency:.4}},count:1,scale:2.5,models:["vine-cluster"],animation:{appearAt:.45,disappearAt:.88,enter:{type:"scale",duration:.25,easing:"easeOutBack"},exit:{type:"scale",duration:.1,easing:"easeInCubic"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.06,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.8,max:1.6,frequency:2,pattern:"sine"},rotate:{axis:"z",rotations:-.3,phase:45},cutout:{strength:.3,primary:{pattern:3,scale:2,weight:1},blend:"multiply",travel:"radial",travelSpeed:.4,strengthCurve:"bell",bellPeakAt:.6},grain:{type:3,strength:.05,scale:.3,speed:.3,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.4,sizeScale:.8,progressCurve:"rampUp"}],blending:"normal",renderOrder:6,modelOverrides:{"vine-cluster":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.3,arcCount:2},orientationOverride:"camera"}}}}],glowColor:[.35,.75,.25],glowIntensityMin:.5,glowIntensityMax:1.2,glowFlickerRate:3,scaleVibration:.01,scaleFrequency:2,tremor:.003,tremorFrequency:3,decayRate:.18,parameterAnimation:{growth:{keyframes:[{at:0,value:.2},{at:.3,value:.5},{at:.55,value:.8},{at:.7,value:.9},{at:.85,value:.6},{at:1,value:0}]},tremor:{keyframes:[{at:0,value:.003},{at:.5,value:.003},{at:.62,value:.015},{at:.72,value:.005},{at:1,value:0}]}}}),tC({name:"naturecleanse",emoji:"",type:"blending",description:"Purification scanner  vine-ring sandwiched by spinning u-vine wreaths",duration:3e3,beats:4,intensity:1.4,category:"afflicted",growth:.85,mascotGlow:1.2,spawnMode:[{type:"axis-travel",axisTravel:{start:"bottom",end:"top",easing:"easeInOut",holdAt:.85,orientation:"flat",diameterUnit:"mascot",uniformDiameter:!0,startDiameter:1.3},count:1,scale:1,models:["vine-ring"],animation:{...iC,appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"scale",duration:.2,easing:"easeIn"},rotate:{axis:"z",rotations:1},atmospherics:[{preset:"falling-leaves",targets:["vine-ring"],anchor:"around",intensity:.7,sizeScale:1,progressCurve:"sustain",velocityInheritance:.3}]}},{type:"axis-travel",axisTravel:{start:"bottom",end:"top",startOffset:.25,endOffset:.25,easing:"easeInOut",holdAt:.85,orientation:"vertical",verticalEdgeAlign:!1,diameterUnit:"mascot",uniformDiameter:!0,startDiameter:1.1},count:1,scale:1,models:["u-vine"],animation:{...iC,appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"scale",duration:.2,easing:"easeIn"},rotate:{axis:"y",rotations:3}}},{type:"axis-travel",axisTravel:{start:"bottom",end:"top",startOffset:-.25,endOffset:-.25,easing:"easeInOut",holdAt:.85,orientation:"vertical",verticalEdgeAlign:!1,diameterUnit:"mascot",uniformDiameter:!0,startDiameter:1.1},count:1,scale:1,models:["u-vine"],animation:{...iC,appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"scale",duration:.2,easing:"easeIn"},rotate:{axis:"y",rotations:2,phase:180}}}],decayRate:.12,glowColor:[.3,.85,.25],glowIntensityMin:1.2,glowIntensityMax:2,glowFlickerRate:3,scaleVibration:.008,scaleFrequency:2,tremor:.002,tremorFrequency:2,parameterAnimation:{growth:{keyframes:[{at:0,value:.4},{at:.3,value:.85},{at:.6,value:.7},{at:.78,value:1},{at:.88,value:.5},{at:.92,value:.95},{at:1,value:0}]},tremor:{keyframes:[{at:0,value:.002},{at:.75,value:.002},{at:.85,value:.008},{at:.95,value:.012},{at:1,value:0}]},scaleVibration:{keyframes:[{at:0,value:.008},{at:.75,value:.008},{at:.85,value:.025},{at:.95,value:.04},{at:1,value:0}]}}}),tC({name:"naturesplinter",emoji:"",type:"blending",description:"Violent splintering  wood and vine fragments shatter outward",duration:1e3,beats:2,intensity:1.5,category:"transform",growth:.8,spawnMode:{type:"radial-burst",radialBurst:{count:12,radius:.05,endRadius:2.5,angleSpread:360,startAngle:15,orientation:"camera",startScale:.3,endScale:1,scaleEasing:"easeOutQuad"},count:12,scale:.7,models:["s-vine","thorn-curl","vine-twist","leaf-bunch","s-vine","thorn-curl","vine-twist","leaf-bunch","s-vine","thorn-curl","vine-twist","leaf-bunch"],animation:{appearAt:0,disappearAt:.5,stagger:.006,enter:{type:"scale",duration:.02,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},emissive:{min:.7,max:1.3,frequency:6,pattern:"sine"},cutout:{strength:.3,primary:{pattern:5,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1.2,strengthCurve:"fadeOut"},grain:{type:3,strength:.15,scale:.3,speed:1,blend:"multiply"},atmospherics:[{preset:"falling-leaves",targets:null,anchor:"around",intensity:.6,sizeScale:.5,progressCurve:"burst"}],rotate:[{axis:"x",rotations:4,phase:0},{axis:"z",rotations:-3,phase:30},{axis:"y",rotations:5,phase:60},{axis:"x",rotations:-4,phase:90},{axis:"z",rotations:3.5,phase:120},{axis:"y",rotations:-4.5,phase:150},{axis:"x",rotations:3,phase:180},{axis:"z",rotations:-5,phase:210},{axis:"y",rotations:4,phase:240},{axis:"x",rotations:-3.5,phase:270},{axis:"z",rotations:4.5,phase:300},{axis:"y",rotations:-3,phase:330}],scaleVariance:.4,lifetimeVariance:.15,blending:"normal",renderOrder:14}},shakeAmount:.04,shakeFrequency:18,decayRate:.1,glowColor:[.45,.75,.2],glowIntensityMin:.8,glowIntensityMax:1.5,glowFlickerRate:10,scaleVibration:.03,scaleFrequency:8,tremor:.02,tremorFrequency:10}),tC({name:"naturesprout",emoji:"",type:"blending",description:"Fresh shoots emerging with rising vine wreath",duration:2800,beats:4,intensity:.6,category:"emanating",growth:.5,mascotGlow:.2,spawnMode:[{type:"surface",pattern:"crown",embedDepth:.15,cameraFacing:.3,clustering:.2,count:6,scale:1,models:["leaf-bunch","vine-cluster","s-vine"],minDistance:.18,animation:{appearAt:.1,disappearAt:.88,stagger:.05,enter:{type:"grow",duration:.12,easing:"easeOutCubic"},exit:{type:"fade",duration:.12,easing:"easeIn"},pulse:{amplitude:.08,frequency:2.5,easing:"easeInOut"},emissive:{min:.5,max:.85,frequency:2.5,pattern:"sine"},drift:{direction:"up",speed:.012,noise:.08},scaleVariance:.18,lifetimeVariance:.12,blending:"normal",renderOrder:7,intensityScaling:{scale:1.18,emissiveMax:1.2}}},{type:"axis-travel",axisTravel:{start:"bottom",end:"center",easing:"easeOut",holdAt:.7,orientation:"vertical",verticalEdgeAlign:!1,diameterUnit:"mascot",uniformDiameter:!0,startDiameter:.7},count:1,scale:.8,models:["u-vine"],animation:{blending:"normal",renderOrder:12,appearAt:.05,disappearAt:.8,enter:{type:"scale",duration:.2,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeIn"},rotate:{axis:"y",rotations:1},atmospherics:[{preset:"falling-leaves",targets:["u-vine"],anchor:"around",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.2}],modelOverrides:{"u-vine":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.8,arcCount:1}}}}}],glowColor:[.5,.9,.35],glowIntensityMin:.6,glowIntensityMax:.95,glowFlickerRate:4,scaleVibration:.018,scaleFrequency:3,decayRate:.18,cutout:{primary:{pattern:"sprout",scale:3.5,blend:"multiply",travelSpeed:.35},secondary:{pattern:"organic",scale:6,blend:"overlay",travelSpeed:.2}},grain:{type:3,strength:.03,blend:"multiply",speed:.4}}),tC({name:"naturethrive",emoji:"",type:"blending",description:"Lush vegetation spreading with spinning u-vine wreaths",duration:3500,beats:5,intensity:1.1,category:"emanating",growth:.9,mascotGlow:.5,spawnMode:[{type:"surface",pattern:"shell",embedDepth:.15,cameraFacing:.3,clustering:.1,count:10,scale:1,models:["vine-cluster","leaf-bunch","s-vine","vine-twist"],minDistance:.12,animation:{appearAt:.05,disappearAt:.88,stagger:.035,enter:{type:"grow",duration:.1,easing:"easeOutBack",overshoot:1.15},exit:{type:"fade",duration:.15,easing:"easeIn"},pulse:{amplitude:.1,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.55,max:.95,frequency:2,pattern:"sine"},drift:{direction:"outward",speed:.01,noise:.1},rotate:{axis:"y",speed:.01,oscillate:!0,range:Math.PI/10},scaleVariance:.2,lifetimeVariance:.12,blending:"normal",renderOrder:8,intensityScaling:{scale:1.25,emissiveMax:1.3}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"vertical",verticalEdgeAlign:!1,diameterUnit:"mascot",uniformDiameter:!0,startDiameter:.8,endDiameter:1.6,startScale:.3,endScale:1,scaleEasing:"easeOutCubic"},count:1,scale:1,models:["u-vine"],animation:{...rC,appearAt:.08,disappearAt:.85,enter:{type:"scale",duration:.18,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeIn"},rotate:{axis:"y",rotations:1.5},atmospherics:[{preset:"falling-leaves",targets:["u-vine"],anchor:"around",intensity:.5,sizeScale:1,progressCurve:"sustain",velocityInheritance:.3}],modelOverrides:{"u-vine":{shaderAnimation:{type:1,arcWidth:.65,arcSpeed:1.2,arcCount:1}}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:.3,z:0},orientation:"vertical",verticalEdgeAlign:!1,diameterUnit:"mascot",uniformDiameter:!0,startDiameter:.6,endDiameter:1.3,startScale:.2,endScale:.9,scaleEasing:"easeOutCubic"},count:1,scale:.85,models:["u-vine"],animation:{...rC,appearAt:.18,disappearAt:.82,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"scale",duration:.18,easing:"easeIn"},rotate:{axis:"y",rotations:-2,phase:120},modelOverrides:{"u-vine":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1.8,arcCount:2}}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.3,z:0},orientation:"vertical",verticalEdgeAlign:!1,diameterUnit:"mascot",uniformDiameter:!0,startDiameter:.6,endDiameter:1.3,startScale:.2,endScale:.9,scaleEasing:"easeOutCubic"},count:1,scale:.85,models:["u-vine"],animation:{...rC,appearAt:.12,disappearAt:.75,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"scale",duration:.2,easing:"easeIn"},rotate:{axis:"y",rotations:1,phase:240},modelOverrides:{"u-vine":{shaderAnimation:{type:1,arcWidth:.55,arcSpeed:1,arcCount:1}}}}}],decayRate:.15,glowColor:[.3,.8,.3],glowIntensityMin:.6,glowIntensityMax:1,glowFlickerRate:3,scaleVibration:.02,scaleFrequency:2,tremor:.003,tremorFrequency:4,parameterAnimation:{growth:{keyframes:[{at:0,value:.3},{at:.25,value:.9},{at:.6,value:.85},{at:.85,value:.6},{at:1,value:0}]}},cutout:{primary:{pattern:"leaf",scale:3,blend:"multiply",travelSpeed:.3},secondary:{pattern:"organic",scale:5,blend:"overlay",travelSpeed:.2}},grain:{type:3,strength:.03,blend:"multiply",speed:.35}})].forEach(function(e){iy[e.name]=e,hy.override.push(e.name)});var sC=Object.freeze({__proto__:null,HDRLoader:class extends Uo{constructor(e){super(e),this.type=te}parse(e){const t=function(e,t){switch(e){case 1:throw new Error("THREE.HDRLoader: Read Error: "+(t||""));case 2:throw new Error("THREE.HDRLoader: Write Error: "+(t||""));case 3:throw new Error("THREE.HDRLoader: Bad File Format: "+(t||""));default:throw new Error("THREE.HDRLoader: Memory Error: "+(t||""))}},n=function(e,t,n){t=t||1024;let a=e.pos,i=-1,r=0,s="",o=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));for(;0>(i=o.indexOf("\n"))&&r<t&&a<e.byteLength;)s+=o,r+=o.length,a+=128,o+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));return-1<i&&(e.pos+=r+i+1,s+o.slice(0,i))},a=function(e,t,n,a){const i=e[t+3],r=Math.pow(2,i-128)/255;n[a+0]=e[t+0]*r,n[a+1]=e[t+1]*r,n[a+2]=e[t+2]*r,n[a+3]=1},i=function(e,t,n,a){const i=e[t+3],r=Math.pow(2,i-128)/255;n[a+0]=Na.toHalfFloat(Math.min(e[t+0]*r,65504)),n[a+1]=Na.toHalfFloat(Math.min(e[t+1]*r,65504)),n[a+2]=Na.toHalfFloat(Math.min(e[t+2]*r,65504)),n[a+3]=Na.toHalfFloat(1)},r=new Uint8Array(e);r.pos=0;const s=function(e){const a=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*FORMAT=(\S+)\s*$/,s=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,o={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;for((e.pos>=e.byteLength||!(l=n(e)))&&t(1,"no header found"),(c=l.match(/^#\?(\S+)/))||t(3,"bad initial token"),o.valid|=1,o.programtype=c[1],o.string+=l+"\n";l=n(e),!1!==l;)if(o.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(a))&&(o.gamma=parseFloat(c[1])),(c=l.match(i))&&(o.exposure=parseFloat(c[1])),(c=l.match(r))&&(o.valid|=2,o.format=c[1]),(c=l.match(s))&&(o.valid|=4,o.height=parseInt(c[1],10),o.width=parseInt(c[2],10)),2&o.valid&&4&o.valid)break}else o.comments+=l+"\n";return 2&o.valid||t(3,"missing format specifier"),4&o.valid||t(3,"missing image size specifier"),o}(r),o=s.width,l=s.height,c=function(e,n,a){const i=n;if(i<8||i>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);i!==(e[2]<<8|e[3])&&t(3,"wrong scanline width");const r=new Uint8Array(4*n*a);r.length||t(4,"unable to allocate buffer space");let s=0,o=0;const l=4*i,c=new Uint8Array(4),h=new Uint8Array(l);let d=a;for(;d>0&&o<e.byteLength;){o+4>e.byteLength&&t(1),c[0]=e[o++],c[1]=e[o++],c[2]=e[o++],c[3]=e[o++],2==c[0]&&2==c[1]&&(c[2]<<8|c[3])==i||t(3,"bad rgbe scanline format");let n,a=0;for(;a<l&&o<e.byteLength;){n=e[o++];const i=n>128;if(i&&(n-=128),(0===n||a+n>l)&&t(3,"bad scanline data"),i){const t=e[o++];for(let e=0;e<n;e++)h[a++]=t}else h.set(e.subarray(o,o+n),a),a+=n,o+=n}const u=i;for(let e=0;e<u;e++){let t=0;r[s]=h[e+t],t+=i,r[s+1]=h[e+t],t+=i,r[s+2]=h[e+t],t+=i,r[s+3]=h[e+t],s+=4}d--}return r}(r.subarray(r.pos),o,l);let h,d,u;switch(this.type){case ee:u=c.length/4;const e=new Float32Array(4*u);for(let t=0;t<u;t++)a(c,4*t,e,4*t);h=e,d=ee;break;case te:u=c.length/4;const t=new Uint16Array(4*u);for(let e=0;e<u;e++)i(c,4*e,t,4*e);h=t,d=te;break;default:throw new Error("THREE.HDRLoader: Unsupported type: "+this.type)}return{width:o,height:l,data:h,header:s.string,gamma:s.gamma,exposure:s.exposure,type:d}}setDataType(e){return this.type=e,this}load(e,t,n,a){return super.load(e,function(e,n){switch(e.type){case ee:case te:e.colorSpace=at,e.minFilter=H,e.magFilter=H,e.generateMipmaps=!1,e.flipY=!0}t&&t(e,n)},n,a)}}});export{Xx as AudioInterpreter,Qw as Core3DManager,Ey as CrystalSoul,Hx as ENGINE_VOCABULARY,Kx as EmotiveMascot3D,cp as GROOVE_PRESETS,Ky as GeometryCache,Yx as LLM_ENDPOINTS,Su as MOON_PHASES,Xw as PerformanceProfiler,dp as Rhythm3DAdapter,tx as SSSPresets,Iu as animateMoonPhase,nx as applySSSPreset,$x as audioInterpreter,mu as blendModeNames,Wx as createCrystal,qx as createDiamond,Au as createMoon,Ou as createMoonCrescentMaterial,Pu as createMoonFallbackMaterial,Tu as createMoonMaterial,Gx as createSphere,Nu as createSunGeometry,Lu as createSunMaterial,Kx as default,Cu as disposeMoon,Uu as disposeSun,gu as getBlendModeIndex,fu as getBlendModeName,Mu as getMoonPhaseNames,_u as getPhaseFromProgress,ix as getSSSPreset,ax as getSSSPresetNames,Zx as isSSR,Yw as profiler,up as rhythm3DAdapter,Eu as setMoonPhase,Ru as updateCrescentShadow,ku as updateMoonGlow,Vu as updateSunMaterial};
//# sourceMappingURL=emotive-mascot-3d-elementals.bundled.js.map
