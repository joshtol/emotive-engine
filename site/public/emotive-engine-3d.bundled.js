const t="181",e={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},i={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},n=0,s=1,a=2,r=100,o=101,l=102,h=200,c=201,u=202,d=203,p=204,m=205,g=206,f=207,y=208,v=209,b=210,M=211,_=212,x=213,w=214,S=0,T=1,C=2,E=3,A=4,P=5,D=6,R=7,I="attached",B="detached",L=300,k=301,O=302,z=303,F=304,U=306,N=1e3,G=1001,V=1002,H=1003,W=1004,j=1005,X=1006,q=1007,Y=1008,$=1009,Z=1010,J=1011,Q=1012,K=1013,tt=1014,et=1015,it=1016,nt=1017,st=1018,at=1020,rt=35902,ot=35899,lt=1021,ht=1022,ct=1023,ut=1026,dt=1027,pt=1028,mt=1029,gt=1030,ft=1031,yt=1033,vt=33776,bt=33777,Mt=33778,_t=33779,xt=35840,wt=35841,St=35842,Tt=35843,Ct=36196,Et=37492,At=37496,Pt=37808,Dt=37809,Rt=37810,It=37811,Bt=37812,Lt=37813,kt=37814,Ot=37815,zt=37816,Ft=37817,Ut=37818,Nt=37819,Gt=37820,Vt=37821,Ht=36492,Wt=36494,jt=36495,Xt=36283,qt=36284,Yt=36285,$t=36286,Zt=2300,Jt=2301,Qt=2302,Kt=2400,te=2401,ee=2402,ie=2501,ne="",se="srgb",ae="srgb-linear",re="linear",oe="srgb",le=7680,he=512,ce=513,ue=514,de=515,pe=516,me=517,ge=518,fe=519,ye=35044,ve=35048,be="300 es",Me=2e3,_e=2001;function xe(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}const we={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function Se(t,e){return new we[t](e)}function Te(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function Ce(){const t=Te("canvas");return t.style.display="block",t}const Ee={};let Ae=null;function Pe(...t){const e="THREE."+t.shift();Ae?Ae("log",e,...t):console.log(e,...t)}function De(...t){const e="THREE."+t.shift();Ae?Ae("warn",e,...t):console.warn(e,...t)}function Re(...t){const e="THREE."+t.shift();Ae?Ae("error",e,...t):console.error(e,...t)}function Ie(...t){const e=t.join(" ");e in Ee||(Ee[e]=!0,De(...t))}class Be{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const i=this._listeners;void 0===i[t]&&(i[t]=[]),-1===i[t].indexOf(e)&&i[t].push(e)}hasEventListener(t,e){const i=this._listeners;return void 0!==i&&void 0!==i[t]&&-1!==i[t].indexOf(e)}removeEventListener(t,e){const i=this._listeners;if(void 0===i)return;const n=i[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){const e=this._listeners;if(void 0===e)return;const i=e[t.type];if(void 0!==i){t.target=this;const e=i.slice(0);for(let i=0,n=e.length;i<n;i++)e[i].call(this,t);t.target=null}}}const Le=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let ke=1234567;const Oe=Math.PI/180,ze=180/Math.PI;function Fe(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(Le[255&t]+Le[t>>8&255]+Le[t>>16&255]+Le[t>>24&255]+"-"+Le[255&e]+Le[e>>8&255]+"-"+Le[e>>16&15|64]+Le[e>>24&255]+"-"+Le[63&i|128]+Le[i>>8&255]+"-"+Le[i>>16&255]+Le[i>>24&255]+Le[255&n]+Le[n>>8&255]+Le[n>>16&255]+Le[n>>24&255]).toLowerCase()}function Ue(t,e,i){return Math.max(e,Math.min(i,t))}function Ne(t,e){return(t%e+e)%e}function Ge(t,e,i){return(1-i)*t+i*e}function Ve(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function He(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const We={DEG2RAD:Oe,RAD2DEG:ze,generateUUID:Fe,clamp:Ue,euclideanModulo:Ne,mapLinear:function(t,e,i,n,s){return n+(t-e)*(s-n)/(i-e)},inverseLerp:function(t,e,i){return t!==e?(i-t)/(e-t):0},lerp:Ge,damp:function(t,e,i,n){return Ge(t,e,1-Math.exp(-i*n))},pingpong:function(t,e=1){return e-Math.abs(Ne(t,2*e)-e)},smoothstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*(3-2*t)},smootherstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(ke=t);let e=ke+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*Oe},radToDeg:function(t){return t*ze},isPowerOfTwo:function(t){return!(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))},setQuaternionFromProperEuler:function(t,e,i,n,s){const a=Math.cos,r=Math.sin,o=a(i/2),l=r(i/2),h=a((e+n)/2),c=r((e+n)/2),u=a((e-n)/2),d=r((e-n)/2),p=a((n-e)/2),m=r((n-e)/2);switch(s){case"XYX":t.set(o*c,l*u,l*d,o*h);break;case"YZY":t.set(l*d,o*c,l*u,o*h);break;case"ZXZ":t.set(l*u,l*d,o*c,o*h);break;case"XZX":t.set(o*c,l*m,l*p,o*h);break;case"YXY":t.set(l*p,o*c,l*m,o*h);break;case"ZYZ":t.set(l*m,l*p,o*c,o*h);break;default:De("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}},normalize:He,denormalize:Ve};class je{constructor(t=0,e=0){je.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6],this.y=n[1]*e+n[4]*i+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Ue(this.x,t.x,e.x),this.y=Ue(this.y,t.y,e.y),this}clampScalar(t,e){return this.x=Ue(this.x,t,e),this.y=Ue(this.y,t,e),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Ue(i,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(Ue(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),n=Math.sin(e),s=this.x-t.x,a=this.y-t.y;return this.x=s*i-a*n+t.x,this.y=s*n+a*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Xe{constructor(t=0,e=0,i=0,n=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=n}static slerpFlat(t,e,i,n,s,a,r){let o=i[n+0],l=i[n+1],h=i[n+2],c=i[n+3],u=s[a+0],d=s[a+1],p=s[a+2],m=s[a+3];if(r<=0)return t[e+0]=o,t[e+1]=l,t[e+2]=h,void(t[e+3]=c);if(r>=1)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=m);if(c!==m||o!==u||l!==d||h!==p){let t=o*u+l*d+h*p+c*m;t<0&&(u=-u,d=-d,p=-p,m=-m,t=-t);let e=1-r;if(t<.9995){const i=Math.acos(t),n=Math.sin(i);e=Math.sin(e*i)/n,o=o*e+u*(r=Math.sin(r*i)/n),l=l*e+d*r,h=h*e+p*r,c=c*e+m*r}else{o=o*e+u*r,l=l*e+d*r,h=h*e+p*r,c=c*e+m*r;const t=1/Math.sqrt(o*o+l*l+h*h+c*c);o*=t,l*=t,h*=t,c*=t}}t[e]=o,t[e+1]=l,t[e+2]=h,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,n,s,a){const r=i[n],o=i[n+1],l=i[n+2],h=i[n+3],c=s[a],u=s[a+1],d=s[a+2],p=s[a+3];return t[e]=r*p+h*c+o*d-l*u,t[e+1]=o*p+h*u+l*c-r*d,t[e+2]=l*p+h*d+r*u-o*c,t[e+3]=h*p-r*c-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,n){return this._x=t,this._y=e,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,n=t._y,s=t._z,a=t._order,r=Math.cos,o=Math.sin,l=r(i/2),h=r(n/2),c=r(s/2),u=o(i/2),d=o(n/2),p=o(s/2);switch(a){case"XYZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"YXZ":this._x=u*h*c+l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"ZXY":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c-u*d*p;break;case"ZYX":this._x=u*h*c-l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c+u*d*p;break;case"YZX":this._x=u*h*c+l*d*p,this._y=l*d*c+u*h*p,this._z=l*h*p-u*d*c,this._w=l*h*c-u*d*p;break;case"XZY":this._x=u*h*c-l*d*p,this._y=l*d*c-u*h*p,this._z=l*h*p+u*d*c,this._w=l*h*c+u*d*p;break;default:De("Quaternion: .setFromEuler() encountered an unknown order: "+a)}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,n=Math.sin(i);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],n=e[4],s=e[8],a=e[1],r=e[5],o=e[9],l=e[2],h=e[6],c=e[10],u=i+r+c;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(h-o)*t,this._y=(s-l)*t,this._z=(a-n)*t}else if(i>r&&i>c){const t=2*Math.sqrt(1+i-r-c);this._w=(h-o)/t,this._x=.25*t,this._y=(n+a)/t,this._z=(s+l)/t}else if(r>c){const t=2*Math.sqrt(1+r-i-c);this._w=(s-l)/t,this._x=(n+a)/t,this._y=.25*t,this._z=(o+h)/t}else{const t=2*Math.sqrt(1+c-i-r);this._w=(a-n)/t,this._x=(s+l)/t,this._y=(o+h)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<1e-8?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Ue(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(0===i)return this;const n=Math.min(1,e/i);return this.slerp(t,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,n=t._y,s=t._z,a=t._w,r=e._x,o=e._y,l=e._z,h=e._w;return this._x=i*h+a*r+n*l-s*o,this._y=n*h+a*o+s*r-i*l,this._z=s*h+a*l+i*o-n*r,this._w=a*h-i*r-n*o-s*l,this._onChangeCallback(),this}slerp(t,e){if(e<=0)return this;if(e>=1)return this.copy(t);let i=t._x,n=t._y,s=t._z,a=t._w,r=this.dot(t);r<0&&(i=-i,n=-n,s=-s,a=-a,r=-r);let o=1-e;if(r<.9995){const t=Math.acos(r),l=Math.sin(t);o=Math.sin(o*t)/l,e=Math.sin(e*t)/l,this._x=this._x*o+i*e,this._y=this._y*o+n*e,this._z=this._z*o+s*e,this._w=this._w*o+a*e,this._onChangeCallback()}else this._x=this._x*o+i*e,this._y=this._y*o+n*e,this._z=this._z*o+s*e,this._w=this._w*o+a*e,this.normalize();return this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),n=Math.sqrt(1-i),s=Math.sqrt(i);return this.set(n*Math.sin(t),n*Math.cos(t),s*Math.sin(e),s*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class qe{constructor(t=0,e=0,i=0){qe.prototype.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return void 0===i&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion($e.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion($e.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,n=this.z,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6]*n,this.y=s[1]*e+s[4]*i+s[7]*n,this.z=s[2]*e+s[5]*i+s[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,s=t.elements,a=1/(s[3]*e+s[7]*i+s[11]*n+s[15]);return this.x=(s[0]*e+s[4]*i+s[8]*n+s[12])*a,this.y=(s[1]*e+s[5]*i+s[9]*n+s[13])*a,this.z=(s[2]*e+s[6]*i+s[10]*n+s[14])*a,this}applyQuaternion(t){const e=this.x,i=this.y,n=this.z,s=t.x,a=t.y,r=t.z,o=t.w,l=2*(a*n-r*i),h=2*(r*e-s*n),c=2*(s*i-a*e);return this.x=e+o*l+a*c-r*h,this.y=i+o*h+r*l-s*c,this.z=n+o*c+s*h-a*l,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,n=this.z,s=t.elements;return this.x=s[0]*e+s[4]*i+s[8]*n,this.y=s[1]*e+s[5]*i+s[9]*n,this.z=s[2]*e+s[6]*i+s[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Ue(this.x,t.x,e.x),this.y=Ue(this.y,t.y,e.y),this.z=Ue(this.z,t.z,e.z),this}clampScalar(t,e){return this.x=Ue(this.x,t,e),this.y=Ue(this.y,t,e),this.z=Ue(this.z,t,e),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Ue(i,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,n=t.y,s=t.z,a=e.x,r=e.y,o=e.z;return this.x=n*o-s*r,this.y=s*a-i*o,this.z=i*r-n*a,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return Ye.copy(this).projectOnVector(t),this.sub(Ye)}reflect(t){return this.sub(Ye.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(Ue(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,n=this.z-t.z;return e*e+i*i+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const n=Math.sin(e)*t;return this.x=n*Math.sin(i),this.y=Math.cos(e)*t,this.z=n*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=n,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=2*Math.random()-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Ye=new qe,$e=new Xe;class Ze{constructor(t,e,i,n,s,a,r,o,l){Ze.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,i,n,s,a,r,o,l)}set(t,e,i,n,s,a,r,o,l){const h=this.elements;return h[0]=t,h[1]=n,h[2]=r,h[3]=e,h[4]=s,h[5]=o,h[6]=i,h[7]=a,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,s=this.elements,a=i[0],r=i[3],o=i[6],l=i[1],h=i[4],c=i[7],u=i[2],d=i[5],p=i[8],m=n[0],g=n[3],f=n[6],y=n[1],v=n[4],b=n[7],M=n[2],_=n[5],x=n[8];return s[0]=a*m+r*y+o*M,s[3]=a*g+r*v+o*_,s[6]=a*f+r*b+o*x,s[1]=l*m+h*y+c*M,s[4]=l*g+h*v+c*_,s[7]=l*f+h*b+c*x,s[2]=u*m+d*y+p*M,s[5]=u*g+d*v+p*_,s[8]=u*f+d*b+p*x,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],a=t[4],r=t[5],o=t[6],l=t[7],h=t[8];return e*a*h-e*r*l-i*s*h+i*r*o+n*s*l-n*a*o}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],a=t[4],r=t[5],o=t[6],l=t[7],h=t[8],c=h*a-r*l,u=r*o-h*s,d=l*s-a*o,p=e*c+i*u+n*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=c*m,t[1]=(n*l-h*i)*m,t[2]=(r*i-n*a)*m,t[3]=u*m,t[4]=(h*e-n*o)*m,t[5]=(n*s-r*e)*m,t[6]=d*m,t[7]=(i*o-l*e)*m,t[8]=(a*e-i*s)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,n,s,a,r){const o=Math.cos(s),l=Math.sin(s);return this.set(i*o,i*l,-i*(o*a+l*r)+a+t,-n*l,n*o,-n*(-l*a+o*r)+r+e,0,0,1),this}scale(t,e){return this.premultiply(Je.makeScale(t,e)),this}rotate(t){return this.premultiply(Je.makeRotation(-t)),this}translate(t,e){return this.premultiply(Je.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let t=0;t<9;t++)if(e[t]!==i[t])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const Je=new Ze,Qe=(new Ze).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Ke=(new Ze).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function ti(){const t={enabled:!0,workingColorSpace:ae,spaces:{},convert:function(t,e,i){return!1!==this.enabled&&e!==i&&e&&i?(this.spaces[e].transfer===oe&&(t.r=ii(t.r),t.g=ii(t.g),t.b=ii(t.b)),this.spaces[e].primaries!==this.spaces[i].primaries&&(t.applyMatrix3(this.spaces[e].toXYZ),t.applyMatrix3(this.spaces[i].fromXYZ)),this.spaces[i].transfer===oe&&(t.r=ni(t.r),t.g=ni(t.g),t.b=ni(t.b)),t):t},workingToColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},colorSpaceToWorking:function(t,e){return this.convert(t,e,this.workingColorSpace)},getPrimaries:function(t){return this.spaces[t].primaries},getTransfer:function(t){return t===ne?re:this.spaces[t].transfer},getToneMappingMode:function(t){return this.spaces[t].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(t,e=this.workingColorSpace){return t.fromArray(this.spaces[e].luminanceCoefficients)},define:function(t){Object.assign(this.spaces,t)},_getMatrix:function(t,e,i){return t.copy(this.spaces[e].toXYZ).multiply(this.spaces[i].fromXYZ)},_getDrawingBufferColorSpace:function(t){return this.spaces[t].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(t=this.workingColorSpace){return this.spaces[t].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(e,i){return Ie("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),t.workingToColorSpace(e,i)},toWorkingColorSpace:function(e,i){return Ie("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),t.colorSpaceToWorking(e,i)}},e=[.64,.33,.3,.6,.15,.06],i=[.2126,.7152,.0722],n=[.3127,.329];return t.define({[ae]:{primaries:e,whitePoint:n,transfer:re,toXYZ:Qe,fromXYZ:Ke,luminanceCoefficients:i,workingColorSpaceConfig:{unpackColorSpace:se},outputColorSpaceConfig:{drawingBufferColorSpace:se}},[se]:{primaries:e,whitePoint:n,transfer:oe,toXYZ:Qe,fromXYZ:Ke,luminanceCoefficients:i,outputColorSpaceConfig:{drawingBufferColorSpace:se}}}),t}const ei=ti();function ii(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function ni(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}let si;class ai{static getDataURL(t,e="image/png"){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let i;if(t instanceof HTMLCanvasElement)i=t;else{void 0===si&&(si=Te("canvas")),si.width=t.width,si.height=t.height;const e=si.getContext("2d");t instanceof ImageData?e.putImageData(t,0,0):e.drawImage(t,0,0,t.width,t.height),i=si}return i.toDataURL(e)}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=Te("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const n=i.getImageData(0,0,t.width,t.height),s=n.data;for(let t=0;t<s.length;t++)s[t]=255*ii(s[t]/255);return i.putImageData(n,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*ii(e[t]/255)):e[t]=ii(e[t]);return{data:e,width:t.width,height:t.height}}return De("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let ri=0;class oi{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:ri++}),this.uuid=Fe(),this.data=t,this.dataReady=!0,this.version=0}getSize(t){const e=this.data;return"undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement?t.set(e.videoWidth,e.videoHeight,0):e instanceof VideoFrame?t.set(e.displayHeight,e.displayWidth,0):null!==e?t.set(e.width,e.height,e.depth||0):t.set(0,0,0),t}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const i={uuid:this.uuid,url:""},n=this.data;if(null!==n){let t;if(Array.isArray(n)){t=[];for(let e=0,i=n.length;e<i;e++)n[e].isDataTexture?t.push(li(n[e].image)):t.push(li(n[e]))}else t=li(n);i.url=t}return e||(t.images[this.uuid]=i),i}}function li(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?ai.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(De("Texture: Unable to serialize Texture."),{})}let hi=0;const ci=new qe;class ui extends Be{constructor(t=ui.DEFAULT_IMAGE,e=ui.DEFAULT_MAPPING,i=1001,n=1001,s=1006,a=1008,r=1023,o=1009,l=ui.DEFAULT_ANISOTROPY,h=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:hi++}),this.uuid=Fe(),this.name="",this.source=new oi(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=i,this.wrapT=n,this.magFilter=s,this.minFilter=a,this.anisotropy=l,this.format=r,this.internalFormat=null,this.type=o,this.offset=new je(0,0),this.repeat=new je(1,1),this.center=new je(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ze,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(t&&t.depth&&t.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(ci).x}get height(){return this.source.getSize(ci).y}get depth(){return this.source.getSize(ci).z}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.renderTarget=t.renderTarget,this.isRenderTargetTexture=t.isRenderTargetTexture,this.isArrayTexture=t.isArrayTexture,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}setValues(t){for(const e in t){const i=t[e];if(void 0===i){De(`Texture.setValues(): parameter '${e}' has value of undefined.`);continue}const n=this[e];void 0!==n?n&&i&&n.isVector2&&i.isVector2||n&&i&&n.isVector3&&i.isVector3||n&&i&&n.isMatrix3&&i.isMatrix3?n.copy(i):this[e]=i:De(`Texture.setValues(): property '${e}' does not exist.`)}}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const i={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==L)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case N:t.x=t.x-Math.floor(t.x);break;case G:t.x=t.x<0?0:1;break;case V:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case N:t.y=t.y-Math.floor(t.y);break;case G:t.y=t.y<0?0:1;break;case V:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){!0===t&&this.pmremVersion++}}ui.DEFAULT_IMAGE=null,ui.DEFAULT_MAPPING=L,ui.DEFAULT_ANISOTROPY=1;class di{constructor(t=0,e=0,i=0,n=1){di.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=n}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,n){return this.x=t,this.y=e,this.z=i,this.w=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,s=this.w,a=t.elements;return this.x=a[0]*e+a[4]*i+a[8]*n+a[12]*s,this.y=a[1]*e+a[5]*i+a[9]*n+a[13]*s,this.z=a[2]*e+a[6]*i+a[10]*n+a[14]*s,this.w=a[3]*e+a[7]*i+a[11]*n+a[15]*s,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,n,s;const a=.01,r=.1,o=t.elements,l=o[0],h=o[4],c=o[8],u=o[1],d=o[5],p=o[9],m=o[2],g=o[6],f=o[10];if(Math.abs(h-u)<a&&Math.abs(c-m)<a&&Math.abs(p-g)<a){if(Math.abs(h+u)<r&&Math.abs(c+m)<r&&Math.abs(p+g)<r&&Math.abs(l+d+f-3)<r)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,y=(f+1)/2,v=(h+u)/4,b=(c+m)/4,M=(p+g)/4;return t>o&&t>y?t<a?(i=0,n=.707106781,s=.707106781):(i=Math.sqrt(t),n=v/i,s=b/i):o>y?o<a?(i=.707106781,n=0,s=.707106781):(n=Math.sqrt(o),i=v/n,s=M/n):y<a?(i=.707106781,n=.707106781,s=0):(s=Math.sqrt(y),i=b/s,n=M/s),this.set(i,n,s,e),this}let y=Math.sqrt((g-p)*(g-p)+(c-m)*(c-m)+(u-h)*(u-h));return Math.abs(y)<.001&&(y=1),this.x=(g-p)/y,this.y=(c-m)/y,this.z=(u-h)/y,this.w=Math.acos((l+d+f-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Ue(this.x,t.x,e.x),this.y=Ue(this.y,t.y,e.y),this.z=Ue(this.z,t.z,e.z),this.w=Ue(this.w,t.w,e.w),this}clampScalar(t,e){return this.x=Ue(this.x,t,e),this.y=Ue(this.y,t,e),this.z=Ue(this.z,t,e),this.w=Ue(this.w,t,e),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Ue(i,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class pi extends Be{constructor(t=1,e=1,i={}){super(),i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:X,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},i),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=i.depth,this.scissor=new di(0,0,t,e),this.scissorTest=!1,this.viewport=new di(0,0,t,e);const n={width:t,height:e,depth:i.depth},s=new ui(n);this.textures=[];const a=i.count;for(let t=0;t<a;t++)this.textures[t]=s.clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;this._setTextureOptions(i),this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.resolveDepthBuffer=i.resolveDepthBuffer,this.resolveStencilBuffer=i.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=i.depthTexture,this.samples=i.samples,this.multiview=i.multiview}_setTextureOptions(t={}){const e={minFilter:X,generateMipmaps:!1,flipY:!1,internalFormat:null};void 0!==t.mapping&&(e.mapping=t.mapping),void 0!==t.wrapS&&(e.wrapS=t.wrapS),void 0!==t.wrapT&&(e.wrapT=t.wrapT),void 0!==t.wrapR&&(e.wrapR=t.wrapR),void 0!==t.magFilter&&(e.magFilter=t.magFilter),void 0!==t.minFilter&&(e.minFilter=t.minFilter),void 0!==t.format&&(e.format=t.format),void 0!==t.type&&(e.type=t.type),void 0!==t.anisotropy&&(e.anisotropy=t.anisotropy),void 0!==t.colorSpace&&(e.colorSpace=t.colorSpace),void 0!==t.flipY&&(e.flipY=t.flipY),void 0!==t.generateMipmaps&&(e.generateMipmaps=t.generateMipmaps),void 0!==t.internalFormat&&(e.internalFormat=t.internalFormat);for(let t=0;t<this.textures.length;t++)this.textures[t].setValues(e)}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}set depthTexture(t){null!==this._depthTexture&&(this._depthTexture.renderTarget=null),null!==t&&(t.renderTarget=this),this._depthTexture=t}get depthTexture(){return this._depthTexture}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let n=0,s=this.textures.length;n<s;n++)this.textures[n].image.width=t,this.textures[n].image.height=e,this.textures[n].image.depth=i,!0!==this.textures[n].isData3DTexture&&(this.textures[n].isArrayTexture=this.textures[n].image.depth>1);this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let e=0,i=t.textures.length;e<i;e++){this.textures[e]=t.textures[e].clone(),this.textures[e].isRenderTargetTexture=!0,this.textures[e].renderTarget=this;const i=Object.assign({},t.textures[e].image);this.textures[e].source=new oi(i)}return this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class mi extends pi{constructor(t=1,e=1,i={}){super(t,e,i),this.isWebGLRenderTarget=!0}}class gi extends ui{constructor(t=null,e=1,i=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:i,depth:n},this.magFilter=H,this.minFilter=H,this.wrapR=G,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class fi extends ui{constructor(t=null,e=1,i=1,n=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:i,depth:n},this.magFilter=H,this.minFilter=H,this.wrapR=G,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class yi{constructor(t=new qe(1/0,1/0,1/0),e=new qe(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e+=3)this.expandByPoint(bi.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,i=t.count;e<i;e++)this.expandByPoint(bi.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=bi.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(void 0!==i){const n=i.getAttribute("position");if(!0===e&&void 0!==n&&!0!==t.isInstancedMesh)for(let e=0,i=n.count;e<i;e++)!0===t.isMesh?t.getVertexPosition(e,bi):bi.fromBufferAttribute(n,e),bi.applyMatrix4(t.matrixWorld),this.expandByPoint(bi);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),Mi.copy(t.boundingBox)):(null===i.boundingBox&&i.computeBoundingBox(),Mi.copy(i.boundingBox)),Mi.applyMatrix4(t.matrixWorld),this.union(Mi)}const n=t.children;for(let t=0,i=n.length;t<i;t++)this.expandByObject(n[t],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,bi),bi.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Ei),Ai.subVectors(this.max,Ei),_i.subVectors(t.a,Ei),xi.subVectors(t.b,Ei),wi.subVectors(t.c,Ei),Si.subVectors(xi,_i),Ti.subVectors(wi,xi),Ci.subVectors(_i,wi);let e=[0,-Si.z,Si.y,0,-Ti.z,Ti.y,0,-Ci.z,Ci.y,Si.z,0,-Si.x,Ti.z,0,-Ti.x,Ci.z,0,-Ci.x,-Si.y,Si.x,0,-Ti.y,Ti.x,0,-Ci.y,Ci.x,0];return!!Ri(e,_i,xi,wi,Ai)&&(e=[1,0,0,0,1,0,0,0,1],!!Ri(e,_i,xi,wi,Ai)&&(Pi.crossVectors(Si,Ti),e=[Pi.x,Pi.y,Pi.z],Ri(e,_i,xi,wi,Ai)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,bi).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(bi).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(vi[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),vi[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),vi[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),vi[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),vi[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),vi[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),vi[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),vi[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(vi)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(t){return this.min.fromArray(t.min),this.max.fromArray(t.max),this}}const vi=[new qe,new qe,new qe,new qe,new qe,new qe,new qe,new qe],bi=new qe,Mi=new yi,_i=new qe,xi=new qe,wi=new qe,Si=new qe,Ti=new qe,Ci=new qe,Ei=new qe,Ai=new qe,Pi=new qe,Di=new qe;function Ri(t,e,i,n,s){for(let a=0,r=t.length-3;a<=r;a+=3){Di.fromArray(t,a);const r=s.x*Math.abs(Di.x)+s.y*Math.abs(Di.y)+s.z*Math.abs(Di.z),o=e.dot(Di),l=i.dot(Di),h=n.dot(Di);if(Math.max(-Math.max(o,l,h),Math.min(o,l,h))>r)return!1}return!0}const Ii=new yi,Bi=new qe,Li=new qe;class ki{constructor(t=new qe,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;void 0!==e?i.copy(e):Ii.setFromPoints(t).getCenter(i);let n=0;for(let e=0,s=t.length;e<s;e++)n=Math.max(n,i.distanceToSquared(t[e]));return this.radius=Math.sqrt(n),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Bi.subVectors(t,this.center);const e=Bi.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),i=.5*(t-this.radius);this.center.addScaledVector(Bi,i/t),this.radius+=i}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(Li.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Bi.copy(t.center).add(Li)),this.expandByPoint(Bi.copy(t.center).sub(Li))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(t){return this.radius=t.radius,this.center.fromArray(t.center),this}}const Oi=new qe,zi=new qe,Fi=new qe,Ui=new qe,Ni=new qe,Gi=new qe,Vi=new qe;class Hi{constructor(t=new qe,e=new qe(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Oi)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Oi.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Oi.copy(this.origin).addScaledVector(this.direction,e),Oi.distanceToSquared(t))}distanceSqToSegment(t,e,i,n){zi.copy(t).add(e).multiplyScalar(.5),Fi.copy(e).sub(t).normalize(),Ui.copy(this.origin).sub(zi);const s=.5*t.distanceTo(e),a=-this.direction.dot(Fi),r=Ui.dot(this.direction),o=-Ui.dot(Fi),l=Ui.lengthSq(),h=Math.abs(1-a*a);let c,u,d,p;if(h>0)if(c=a*o-r,u=a*r-o,p=s*h,c>=0)if(u>=-p)if(u<=p){const t=1/h;c*=t,u*=t,d=c*(c+a*u+2*r)+u*(a*c+u+2*o)+l}else u=s,c=Math.max(0,-(a*u+r)),d=-c*c+u*(u+2*o)+l;else u=-s,c=Math.max(0,-(a*u+r)),d=-c*c+u*(u+2*o)+l;else u<=-p?(c=Math.max(0,-(-a*s+r)),u=c>0?-s:Math.min(Math.max(-s,-o),s),d=-c*c+u*(u+2*o)+l):u<=p?(c=0,u=Math.min(Math.max(-s,-o),s),d=u*(u+2*o)+l):(c=Math.max(0,-(a*s+r)),u=c>0?s:Math.min(Math.max(-s,-o),s),d=-c*c+u*(u+2*o)+l);else u=a>0?-s:s,c=Math.max(0,-(a*u+r)),d=-c*c+u*(u+2*o)+l;return i&&i.copy(this.origin).addScaledVector(this.direction,c),n&&n.copy(zi).addScaledVector(Fi,u),d}intersectSphere(t,e){Oi.subVectors(t.center,this.origin);const i=Oi.dot(this.direction),n=Oi.dot(Oi)-i*i,s=t.radius*t.radius;if(n>s)return null;const a=Math.sqrt(s-n),r=i-a,o=i+a;return o<0?null:r<0?this.at(o,e):this.at(r,e)}intersectsSphere(t){return!(t.radius<0)&&this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return null===i?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,n,s,a,r,o;const l=1/this.direction.x,h=1/this.direction.y,c=1/this.direction.z,u=this.origin;return l>=0?(i=(t.min.x-u.x)*l,n=(t.max.x-u.x)*l):(i=(t.max.x-u.x)*l,n=(t.min.x-u.x)*l),h>=0?(s=(t.min.y-u.y)*h,a=(t.max.y-u.y)*h):(s=(t.max.y-u.y)*h,a=(t.min.y-u.y)*h),i>a||s>n?null:((s>i||isNaN(i))&&(i=s),(a<n||isNaN(n))&&(n=a),c>=0?(r=(t.min.z-u.z)*c,o=(t.max.z-u.z)*c):(r=(t.max.z-u.z)*c,o=(t.min.z-u.z)*c),i>o||r>n?null:((r>i||i!=i)&&(i=r),(o<n||n!=n)&&(n=o),n<0?null:this.at(i>=0?i:n,e)))}intersectsBox(t){return null!==this.intersectBox(t,Oi)}intersectTriangle(t,e,i,n,s){Ni.subVectors(e,t),Gi.subVectors(i,t),Vi.crossVectors(Ni,Gi);let a,r=this.direction.dot(Vi);if(r>0){if(n)return null;a=1}else{if(!(r<0))return null;a=-1,r=-r}Ui.subVectors(this.origin,t);const o=a*this.direction.dot(Gi.crossVectors(Ui,Gi));if(o<0)return null;const l=a*this.direction.dot(Ni.cross(Ui));if(l<0)return null;if(o+l>r)return null;const h=-a*Ui.dot(Vi);return h<0?null:this.at(h/r,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Wi{constructor(t,e,i,n,s,a,r,o,l,h,c,u,d,p,m,g){Wi.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,i,n,s,a,r,o,l,h,c,u,d,p,m,g)}set(t,e,i,n,s,a,r,o,l,h,c,u,d,p,m,g){const f=this.elements;return f[0]=t,f[4]=e,f[8]=i,f[12]=n,f[1]=s,f[5]=a,f[9]=r,f[13]=o,f[2]=l,f[6]=h,f[10]=c,f[14]=u,f[3]=d,f[7]=p,f[11]=m,f[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Wi).fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,n=1/ji.setFromMatrixColumn(t,0).length(),s=1/ji.setFromMatrixColumn(t,1).length(),a=1/ji.setFromMatrixColumn(t,2).length();return e[0]=i[0]*n,e[1]=i[1]*n,e[2]=i[2]*n,e[3]=0,e[4]=i[4]*s,e[5]=i[5]*s,e[6]=i[6]*s,e[7]=0,e[8]=i[8]*a,e[9]=i[9]*a,e[10]=i[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,n=t.y,s=t.z,a=Math.cos(i),r=Math.sin(i),o=Math.cos(n),l=Math.sin(n),h=Math.cos(s),c=Math.sin(s);if("XYZ"===t.order){const t=a*h,i=a*c,n=r*h,s=r*c;e[0]=o*h,e[4]=-o*c,e[8]=l,e[1]=i+n*l,e[5]=t-s*l,e[9]=-r*o,e[2]=s-t*l,e[6]=n+i*l,e[10]=a*o}else if("YXZ"===t.order){const t=o*h,i=o*c,n=l*h,s=l*c;e[0]=t+s*r,e[4]=n*r-i,e[8]=a*l,e[1]=a*c,e[5]=a*h,e[9]=-r,e[2]=i*r-n,e[6]=s+t*r,e[10]=a*o}else if("ZXY"===t.order){const t=o*h,i=o*c,n=l*h,s=l*c;e[0]=t-s*r,e[4]=-a*c,e[8]=n+i*r,e[1]=i+n*r,e[5]=a*h,e[9]=s-t*r,e[2]=-a*l,e[6]=r,e[10]=a*o}else if("ZYX"===t.order){const t=a*h,i=a*c,n=r*h,s=r*c;e[0]=o*h,e[4]=n*l-i,e[8]=t*l+s,e[1]=o*c,e[5]=s*l+t,e[9]=i*l-n,e[2]=-l,e[6]=r*o,e[10]=a*o}else if("YZX"===t.order){const t=a*o,i=a*l,n=r*o,s=r*l;e[0]=o*h,e[4]=s-t*c,e[8]=n*c+i,e[1]=c,e[5]=a*h,e[9]=-r*h,e[2]=-l*h,e[6]=i*c+n,e[10]=t-s*c}else if("XZY"===t.order){const t=a*o,i=a*l,n=r*o,s=r*l;e[0]=o*h,e[4]=-c,e[8]=l*h,e[1]=t*c+s,e[5]=a*h,e[9]=i*c-n,e[2]=n*c-i,e[6]=r*h,e[10]=s*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(qi,t,Yi)}lookAt(t,e,i){const n=this.elements;return Ji.subVectors(t,e),0===Ji.lengthSq()&&(Ji.z=1),Ji.normalize(),$i.crossVectors(i,Ji),0===$i.lengthSq()&&(1===Math.abs(i.z)?Ji.x+=1e-4:Ji.z+=1e-4,Ji.normalize(),$i.crossVectors(i,Ji)),$i.normalize(),Zi.crossVectors(Ji,$i),n[0]=$i.x,n[4]=Zi.x,n[8]=Ji.x,n[1]=$i.y,n[5]=Zi.y,n[9]=Ji.y,n[2]=$i.z,n[6]=Zi.z,n[10]=Ji.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,s=this.elements,a=i[0],r=i[4],o=i[8],l=i[12],h=i[1],c=i[5],u=i[9],d=i[13],p=i[2],m=i[6],g=i[10],f=i[14],y=i[3],v=i[7],b=i[11],M=i[15],_=n[0],x=n[4],w=n[8],S=n[12],T=n[1],C=n[5],E=n[9],A=n[13],P=n[2],D=n[6],R=n[10],I=n[14],B=n[3],L=n[7],k=n[11],O=n[15];return s[0]=a*_+r*T+o*P+l*B,s[4]=a*x+r*C+o*D+l*L,s[8]=a*w+r*E+o*R+l*k,s[12]=a*S+r*A+o*I+l*O,s[1]=h*_+c*T+u*P+d*B,s[5]=h*x+c*C+u*D+d*L,s[9]=h*w+c*E+u*R+d*k,s[13]=h*S+c*A+u*I+d*O,s[2]=p*_+m*T+g*P+f*B,s[6]=p*x+m*C+g*D+f*L,s[10]=p*w+m*E+g*R+f*k,s[14]=p*S+m*A+g*I+f*O,s[3]=y*_+v*T+b*P+M*B,s[7]=y*x+v*C+b*D+M*L,s[11]=y*w+v*E+b*R+M*k,s[15]=y*S+v*A+b*I+M*O,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],n=t[8],s=t[12],a=t[1],r=t[5],o=t[9],l=t[13],h=t[2],c=t[6],u=t[10],d=t[14];return t[3]*(+s*o*c-n*l*c-s*r*u+i*l*u+n*r*d-i*o*d)+t[7]*(+e*o*d-e*l*u+s*a*u-n*a*d+n*l*h-s*o*h)+t[11]*(+e*l*c-e*r*d-s*a*c+i*a*d+s*r*h-i*l*h)+t[15]*(-n*r*h-e*o*c+e*r*u+n*a*c-i*a*u+i*o*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=e,n[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],s=t[3],a=t[4],r=t[5],o=t[6],l=t[7],h=t[8],c=t[9],u=t[10],d=t[11],p=t[12],m=t[13],g=t[14],f=t[15],y=c*g*l-m*u*l+m*o*d-r*g*d-c*o*f+r*u*f,v=p*u*l-h*g*l-p*o*d+a*g*d+h*o*f-a*u*f,b=h*m*l-p*c*l+p*r*d-a*m*d-h*r*f+a*c*f,M=p*c*o-h*m*o-p*r*u+a*m*u+h*r*g-a*c*g,_=e*y+i*v+n*b+s*M;if(0===_)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const x=1/_;return t[0]=y*x,t[1]=(m*u*s-c*g*s-m*n*d+i*g*d+c*n*f-i*u*f)*x,t[2]=(r*g*s-m*o*s+m*n*l-i*g*l-r*n*f+i*o*f)*x,t[3]=(c*o*s-r*u*s-c*n*l+i*u*l+r*n*d-i*o*d)*x,t[4]=v*x,t[5]=(h*g*s-p*u*s+p*n*d-e*g*d-h*n*f+e*u*f)*x,t[6]=(p*o*s-a*g*s-p*n*l+e*g*l+a*n*f-e*o*f)*x,t[7]=(a*u*s-h*o*s+h*n*l-e*u*l-a*n*d+e*o*d)*x,t[8]=b*x,t[9]=(p*c*s-h*m*s-p*i*d+e*m*d+h*i*f-e*c*f)*x,t[10]=(a*m*s-p*r*s+p*i*l-e*m*l-a*i*f+e*r*f)*x,t[11]=(h*r*s-a*c*s-h*i*l+e*c*l+a*i*d-e*r*d)*x,t[12]=M*x,t[13]=(h*m*n-p*c*n+p*i*u-e*m*u-h*i*g+e*c*g)*x,t[14]=(p*r*n-a*m*n-p*i*o+e*m*o+a*i*g-e*r*g)*x,t[15]=(a*c*n-h*r*n+h*i*o-e*c*o-a*i*u+e*r*u)*x,this}scale(t){const e=this.elements,i=t.x,n=t.y,s=t.z;return e[0]*=i,e[4]*=n,e[8]*=s,e[1]*=i,e[5]*=n,e[9]*=s,e[2]*=i,e[6]*=n,e[10]*=s,e[3]*=i,e[7]*=n,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,n))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),n=Math.sin(e),s=1-i,a=t.x,r=t.y,o=t.z,l=s*a,h=s*r;return this.set(l*a+i,l*r-n*o,l*o+n*r,0,l*r+n*o,h*r+i,h*o-n*a,0,l*o-n*r,h*o+n*a,s*o*o+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,n,s,a){return this.set(1,i,s,0,t,1,a,0,e,n,1,0,0,0,0,1),this}compose(t,e,i){const n=this.elements,s=e._x,a=e._y,r=e._z,o=e._w,l=s+s,h=a+a,c=r+r,u=s*l,d=s*h,p=s*c,m=a*h,g=a*c,f=r*c,y=o*l,v=o*h,b=o*c,M=i.x,_=i.y,x=i.z;return n[0]=(1-(m+f))*M,n[1]=(d+b)*M,n[2]=(p-v)*M,n[3]=0,n[4]=(d-b)*_,n[5]=(1-(u+f))*_,n[6]=(g+y)*_,n[7]=0,n[8]=(p+v)*x,n[9]=(g-y)*x,n[10]=(1-(u+m))*x,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,e,i){const n=this.elements;let s=ji.set(n[0],n[1],n[2]).length();const a=ji.set(n[4],n[5],n[6]).length(),r=ji.set(n[8],n[9],n[10]).length();this.determinant()<0&&(s=-s),t.x=n[12],t.y=n[13],t.z=n[14],Xi.copy(this);const o=1/s,l=1/a,h=1/r;return Xi.elements[0]*=o,Xi.elements[1]*=o,Xi.elements[2]*=o,Xi.elements[4]*=l,Xi.elements[5]*=l,Xi.elements[6]*=l,Xi.elements[8]*=h,Xi.elements[9]*=h,Xi.elements[10]*=h,e.setFromRotationMatrix(Xi),i.x=s,i.y=a,i.z=r,this}makePerspective(t,e,i,n,s,a,r=2e3,o=!1){const l=this.elements,h=2*s/(e-t),c=2*s/(i-n),u=(e+t)/(e-t),d=(i+n)/(i-n);let p,m;if(o)p=s/(a-s),m=a*s/(a-s);else if(r===Me)p=-(a+s)/(a-s),m=-2*a*s/(a-s);else{if(r!==_e)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+r);p=-a/(a-s),m=-a*s/(a-s)}return l[0]=h,l[4]=0,l[8]=u,l[12]=0,l[1]=0,l[5]=c,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=m,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(t,e,i,n,s,a,r=2e3,o=!1){const l=this.elements,h=2/(e-t),c=2/(i-n),u=-(e+t)/(e-t),d=-(i+n)/(i-n);let p,m;if(o)p=1/(a-s),m=a/(a-s);else if(r===Me)p=-2/(a-s),m=-(a+s)/(a-s);else{if(r!==_e)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+r);p=-1/(a-s),m=-s/(a-s)}return l[0]=h,l[4]=0,l[8]=0,l[12]=u,l[1]=0,l[5]=c,l[9]=0,l[13]=d,l[2]=0,l[6]=0,l[10]=p,l[14]=m,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let t=0;t<16;t++)if(e[t]!==i[t])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const ji=new qe,Xi=new Wi,qi=new qe(0,0,0),Yi=new qe(1,1,1),$i=new qe,Zi=new qe,Ji=new qe,Qi=new Wi,Ki=new Xe;class tn{constructor(t=0,e=0,i=0,n=tn.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=n}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,n=this._order){return this._x=t,this._y=e,this._z=i,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const n=t.elements,s=n[0],a=n[4],r=n[8],o=n[1],l=n[5],h=n[9],c=n[2],u=n[6],d=n[10];switch(e){case"XYZ":this._y=Math.asin(Ue(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(-h,d),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Ue(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(r,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-c,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ue(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-c,d),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(o,s));break;case"ZYX":this._y=Math.asin(-Ue(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,s)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(Ue(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-h,l),this._y=Math.atan2(-c,s)):(this._x=0,this._y=Math.atan2(r,d));break;case"XZY":this._z=Math.asin(-Ue(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(r,s)):(this._x=Math.atan2(-h,d),this._y=0);break;default:De("Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return Qi.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Qi,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Ki.setFromEuler(this),this.setFromQuaternion(Ki,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}tn.DEFAULT_ORDER="XYZ";class en{constructor(){this.mask=1}set(t){this.mask=1<<t>>>0}enable(t){this.mask|=1<<t}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t}disable(t){this.mask&=~(1<<t)}disableAll(){this.mask=0}test(t){return 0!==(this.mask&t.mask)}isEnabled(t){return!!(this.mask&1<<t)}}let nn=0;const sn=new qe,an=new Xe,rn=new Wi,on=new qe,ln=new qe,hn=new qe,cn=new Xe,un=new qe(1,0,0),dn=new qe(0,1,0),pn=new qe(0,0,1),mn={type:"added"},gn={type:"removed"},fn={type:"childadded",child:null},yn={type:"childremoved",child:null};class vn extends Be{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:nn++}),this.uuid=Fe(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=vn.DEFAULT_UP.clone();const t=new qe,e=new tn,i=new Xe,n=new qe(1,1,1);e._onChange(function(){i.setFromEuler(e,!1)}),i._onChange(function(){e.setFromQuaternion(i,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new Wi},normalMatrix:{value:new Ze}}),this.matrix=new Wi,this.matrixWorld=new Wi,this.matrixAutoUpdate=vn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new en,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return an.setFromAxisAngle(t,e),this.quaternion.multiply(an),this}rotateOnWorldAxis(t,e){return an.setFromAxisAngle(t,e),this.quaternion.premultiply(an),this}rotateX(t){return this.rotateOnAxis(un,t)}rotateY(t){return this.rotateOnAxis(dn,t)}rotateZ(t){return this.rotateOnAxis(pn,t)}translateOnAxis(t,e){return sn.copy(t).applyQuaternion(this.quaternion),this.position.add(sn.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(un,t)}translateY(t){return this.translateOnAxis(dn,t)}translateZ(t){return this.translateOnAxis(pn,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(rn.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?on.copy(t):on.set(t,e,i);const n=this.parent;this.updateWorldMatrix(!0,!1),ln.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?rn.lookAt(ln,on,this.up):rn.lookAt(on,ln,this.up),this.quaternion.setFromRotationMatrix(rn),n&&(rn.extractRotation(n.matrixWorld),an.setFromRotationMatrix(rn),this.quaternion.premultiply(an.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(Re("Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(mn),fn.child=t,this.dispatchEvent(fn),fn.child=null):Re("Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(gn),yn.child=t,this.dispatchEvent(yn),yn.child=null),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),rn.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),rn.multiply(t.parent.matrixWorld)),t.applyMatrix4(rn),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(mn),fn.child=t,this.dispatchEvent(fn),fn.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,n=this.children.length;i<n;i++){const n=this.children[i].getObjectByProperty(t,e);if(void 0!==n)return n}}getObjectsByProperty(t,e,i=[]){this[t]===e&&i.push(this);const n=this.children;for(let s=0,a=n.length;s<a;s++)n[s].getObjectsByProperty(t,e,i);return i}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ln,t,hn),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ln,cn,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(!0===t&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===e){const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const n={};function s(e,i){return void 0===e[i.uuid]&&(e[i.uuid]=i.toJSON(t)),i.uuid}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),!0===this.castShadow&&(n.castShadow=!0),!0===this.receiveShadow&&(n.receiveShadow=!0),!1===this.visible&&(n.visible=!1),!1===this.frustumCulled&&(n.frustumCulled=!1),0!==this.renderOrder&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.geometryInfo=this._geometryInfo.map(t=>({...t,boundingBox:t.boundingBox?t.boundingBox.toJSON():void 0,boundingSphere:t.boundingSphere?t.boundingSphere.toJSON():void 0})),n.instanceInfo=this._instanceInfo.map(t=>({...t})),n.availableInstanceIds=this._availableInstanceIds.slice(),n.availableGeometryIds=this._availableGeometryIds.slice(),n.nextIndexStart=this._nextIndexStart,n.nextVertexStart=this._nextVertexStart,n.geometryCount=this._geometryCount,n.maxInstanceCount=this._maxInstanceCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.matricesTexture=this._matricesTexture.toJSON(t),n.indirectTexture=this._indirectTexture.toJSON(t),null!==this._colorsTexture&&(n.colorsTexture=this._colorsTexture.toJSON(t)),null!==this.boundingSphere&&(n.boundingSphere=this.boundingSphere.toJSON()),null!==this.boundingBox&&(n.boundingBox=this.boundingBox.toJSON())),this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(n.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=s(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const i=e.shapes;if(Array.isArray(i))for(let e=0,n=i.length;e<n;e++){const n=i[e];s(t.shapes,n)}else s(t.shapes,i)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(s(t.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let i=0,n=this.material.length;i<n;i++)e.push(s(t.materials,this.material[i]));n.material=e}else n.material=s(t.materials,this.material);if(this.children.length>0){n.children=[];for(let e=0;e<this.children.length;e++)n.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){n.animations=[];for(let e=0;e<this.animations.length;e++){const i=this.animations[e];n.animations.push(s(t.animations,i))}}if(e){const e=a(t.geometries),n=a(t.materials),s=a(t.textures),r=a(t.images),o=a(t.shapes),l=a(t.skeletons),h=a(t.animations),c=a(t.nodes);e.length>0&&(i.geometries=e),n.length>0&&(i.materials=n),s.length>0&&(i.textures=s),r.length>0&&(i.images=r),o.length>0&&(i.shapes=o),l.length>0&&(i.skeletons=l),h.length>0&&(i.animations=h),c.length>0&&(i.nodes=c)}return i.object=n,i;function a(t){const e=[];for(const i in t){const n=t[i];delete n.metadata,e.push(n)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const i=t.children[e];this.add(i.clone())}return this}}vn.DEFAULT_UP=new qe(0,1,0),vn.DEFAULT_MATRIX_AUTO_UPDATE=!0,vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const bn=new qe,Mn=new qe,_n=new qe,xn=new qe,wn=new qe,Sn=new qe,Tn=new qe,Cn=new qe,En=new qe,An=new qe,Pn=new di,Dn=new di,Rn=new di;class In{constructor(t=new qe,e=new qe,i=new qe){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,n){n.subVectors(i,e),bn.subVectors(t,e),n.cross(bn);const s=n.lengthSq();return s>0?n.multiplyScalar(1/Math.sqrt(s)):n.set(0,0,0)}static getBarycoord(t,e,i,n,s){bn.subVectors(n,e),Mn.subVectors(i,e),_n.subVectors(t,e);const a=bn.dot(bn),r=bn.dot(Mn),o=bn.dot(_n),l=Mn.dot(Mn),h=Mn.dot(_n),c=a*l-r*r;if(0===c)return s.set(0,0,0),null;const u=1/c,d=(l*o-r*h)*u,p=(a*h-r*o)*u;return s.set(1-d-p,p,d)}static containsPoint(t,e,i,n){return null!==this.getBarycoord(t,e,i,n,xn)&&xn.x>=0&&xn.y>=0&&xn.x+xn.y<=1}static getInterpolation(t,e,i,n,s,a,r,o){return null===this.getBarycoord(t,e,i,n,xn)?(o.x=0,o.y=0,"z"in o&&(o.z=0),"w"in o&&(o.w=0),null):(o.setScalar(0),o.addScaledVector(s,xn.x),o.addScaledVector(a,xn.y),o.addScaledVector(r,xn.z),o)}static getInterpolatedAttribute(t,e,i,n,s,a){return Pn.setScalar(0),Dn.setScalar(0),Rn.setScalar(0),Pn.fromBufferAttribute(t,e),Dn.fromBufferAttribute(t,i),Rn.fromBufferAttribute(t,n),a.setScalar(0),a.addScaledVector(Pn,s.x),a.addScaledVector(Dn,s.y),a.addScaledVector(Rn,s.z),a}static isFrontFacing(t,e,i,n){return bn.subVectors(i,e),Mn.subVectors(t,e),bn.cross(Mn).dot(n)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,n){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[n]),this}setFromAttributeAndIndices(t,e,i,n){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return bn.subVectors(this.c,this.b),Mn.subVectors(this.a,this.b),.5*bn.cross(Mn).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return In.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return In.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,i,n,s){return In.getInterpolation(t,this.a,this.b,this.c,e,i,n,s)}containsPoint(t){return In.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return In.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,n=this.b,s=this.c;let a,r;wn.subVectors(n,i),Sn.subVectors(s,i),Cn.subVectors(t,i);const o=wn.dot(Cn),l=Sn.dot(Cn);if(o<=0&&l<=0)return e.copy(i);En.subVectors(t,n);const h=wn.dot(En),c=Sn.dot(En);if(h>=0&&c<=h)return e.copy(n);const u=o*c-h*l;if(u<=0&&o>=0&&h<=0)return a=o/(o-h),e.copy(i).addScaledVector(wn,a);An.subVectors(t,s);const d=wn.dot(An),p=Sn.dot(An);if(p>=0&&d<=p)return e.copy(s);const m=d*l-o*p;if(m<=0&&l>=0&&p<=0)return r=l/(l-p),e.copy(i).addScaledVector(Sn,r);const g=h*p-d*c;if(g<=0&&c-h>=0&&d-p>=0)return Tn.subVectors(s,n),r=(c-h)/(c-h+(d-p)),e.copy(n).addScaledVector(Tn,r);const f=1/(g+m+u);return a=m*f,r=u*f,e.copy(i).addScaledVector(wn,a).addScaledVector(Sn,r)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const Bn={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ln={h:0,s:0,l:0},kn={h:0,s:0,l:0};function On(t,e,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t}class zn{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,i)}set(t,e,i){if(void 0===e&&void 0===i){const e=t;e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e)}else this.setRGB(t,e,i);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=se){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,ei.colorSpaceToWorking(this,e),this}setRGB(t,e,i,n=ei.workingColorSpace){return this.r=t,this.g=e,this.b=i,ei.colorSpaceToWorking(this,n),this}setHSL(t,e,i,n=ei.workingColorSpace){if(t=Ne(t,1),e=Ue(e,0,1),i=Ue(i,0,1),0===e)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+e):i+e-i*e,s=2*i-n;this.r=On(s,n,t+1/3),this.g=On(s,n,t),this.b=On(s,n,t-1/3)}return ei.colorSpaceToWorking(this,n),this}setStyle(t,e=se){function i(e){void 0!==e&&parseFloat(e)<1&&De("Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(t)){let s;const a=n[1],r=n[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,e);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,e);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return i(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,e);break;default:De("Color: Unknown color model "+t)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const i=n[1],s=i.length;if(3===s)return this.setRGB(parseInt(i.charAt(0),16)/15,parseInt(i.charAt(1),16)/15,parseInt(i.charAt(2),16)/15,e);if(6===s)return this.setHex(parseInt(i,16),e);De("Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=se){const i=Bn[t.toLowerCase()];return void 0!==i?this.setHex(i,e):De("Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=ii(t.r),this.g=ii(t.g),this.b=ii(t.b),this}copyLinearToSRGB(t){return this.r=ni(t.r),this.g=ni(t.g),this.b=ni(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=se){return ei.workingToColorSpace(Fn.copy(this),t),65536*Math.round(Ue(255*Fn.r,0,255))+256*Math.round(Ue(255*Fn.g,0,255))+Math.round(Ue(255*Fn.b,0,255))}getHexString(t=se){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=ei.workingColorSpace){ei.workingToColorSpace(Fn.copy(this),e);const i=Fn.r,n=Fn.g,s=Fn.b,a=Math.max(i,n,s),r=Math.min(i,n,s);let o,l;const h=(r+a)/2;if(r===a)o=0,l=0;else{const t=a-r;switch(l=h<=.5?t/(a+r):t/(2-a-r),a){case i:o=(n-s)/t+(n<s?6:0);break;case n:o=(s-i)/t+2;break;case s:o=(i-n)/t+4}o/=6}return t.h=o,t.s=l,t.l=h,t}getRGB(t,e=ei.workingColorSpace){return ei.workingToColorSpace(Fn.copy(this),e),t.r=Fn.r,t.g=Fn.g,t.b=Fn.b,t}getStyle(t=se){ei.workingToColorSpace(Fn.copy(this),t);const e=Fn.r,i=Fn.g,n=Fn.b;return t!==se?`color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*i)},${Math.round(255*n)})`}offsetHSL(t,e,i){return this.getHSL(Ln),this.setHSL(Ln.h+t,Ln.s+e,Ln.l+i)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(Ln),t.getHSL(kn);const i=Ge(Ln.h,kn.h,e),n=Ge(Ln.s,kn.s,e),s=Ge(Ln.l,kn.l,e);return this.setHSL(i,n,s),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,i=this.g,n=this.b,s=t.elements;return this.r=s[0]*e+s[3]*i+s[6]*n,this.g=s[1]*e+s[4]*i+s[7]*n,this.b=s[2]*e+s[5]*i+s[8]*n,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Fn=new zn;zn.NAMES=Bn;let Un=0;class Nn extends Be{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Un++}),this.uuid=Fe(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=p,this.blendDst=m,this.blendEquation=r,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new zn(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=le,this.stencilZFail=le,this.stencilZPass=le,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const i=t[e];if(void 0===i){De(`Material: parameter '${e}' has value of undefined.`);continue}const n=this[e];void 0!==n?n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[e]=i:De(`Material: '${e}' is not a property of THREE.${this.type}.`)}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const i={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};function n(t){const e=[];for(const i in t){const n=t[i];delete n.metadata,e.push(n)}return e}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),void 0!==this.sheen&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearcoat&&(i.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.sheenColorMap&&this.sheenColorMap.isTexture&&(i.sheenColorMap=this.sheenColorMap.toJSON(t).uuid),this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture&&(i.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(t).uuid),void 0!==this.dispersion&&(i.dispersion=this.dispersion),void 0!==this.iridescence&&(i.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(i.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(i.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(i.combine=this.combine)),void 0!==this.envMapRotation&&(i.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(i.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(i.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(i.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(i.size=this.size),null!==this.shadowSide&&(i.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(i.blending=this.blending),0!==this.side&&(i.side=this.side),!0===this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=!0),this.blendSrc!==p&&(i.blendSrc=this.blendSrc),this.blendDst!==m&&(i.blendDst=this.blendDst),this.blendEquation!==r&&(i.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(i.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(i.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(i.blendAlpha=this.blendAlpha),3!==this.depthFunc&&(i.depthFunc=this.depthFunc),!1===this.depthTest&&(i.depthTest=this.depthTest),!1===this.depthWrite&&(i.depthWrite=this.depthWrite),!1===this.colorWrite&&(i.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(i.stencilWriteMask=this.stencilWriteMask),519!==this.stencilFunc&&(i.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(i.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==le&&(i.stencilFail=this.stencilFail),this.stencilZFail!==le&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==le&&(i.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(i.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(i.rotation=this.rotation),!0===this.polygonOffset&&(i.polygonOffset=!0),0!==this.polygonOffsetFactor&&(i.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(i.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),!0===this.alphaHash&&(i.alphaHash=!0),!0===this.alphaToCoverage&&(i.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=!0),!0===this.forceSinglePass&&(i.forceSinglePass=!0),!0===this.wireframe&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(i.flatShading=!0),!1===this.visible&&(i.visible=!1),!1===this.toneMapped&&(i.toneMapped=!1),!1===this.fog&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData),e){const e=n(t.textures),s=n(t.images);e.length>0&&(i.textures=e),s.length>0&&(i.images=s)}return i}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(null!==e){const t=e.length;i=new Array(t);for(let n=0;n!==t;++n)i[n]=e[n].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}class Gn extends Nn{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new zn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new tn,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const Vn=Hn();function Hn(){const t=new ArrayBuffer(4),e=new Float32Array(t),i=new Uint32Array(t),n=new Uint32Array(512),s=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(n[t]=0,n[256|t]=32768,s[t]=24,s[256|t]=24):e<-14?(n[t]=1024>>-e-14,n[256|t]=1024>>-e-14|32768,s[t]=-e-1,s[256|t]=-e-1):e<=15?(n[t]=e+15<<10,n[256|t]=e+15<<10|32768,s[t]=13,s[256|t]=13):e<128?(n[t]=31744,n[256|t]=64512,s[t]=24,s[256|t]=24):(n[t]=31744,n[256|t]=64512,s[t]=13,s[256|t]=13)}const a=new Uint32Array(2048),r=new Uint32Array(64),o=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,i=0;for(;!(8388608&e);)e<<=1,i-=8388608;e&=-8388609,i+=947912704,a[t]=e|i}for(let t=1024;t<2048;++t)a[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)r[t]=t<<23;r[31]=1199570944,r[32]=2147483648;for(let t=33;t<63;++t)r[t]=2147483648+(t-32<<23);r[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(o[t]=1024);return{floatView:e,uint32View:i,baseTable:n,shiftTable:s,mantissaTable:a,exponentTable:r,offsetTable:o}}function Wn(t){Math.abs(t)>65504&&De("DataUtils.toHalfFloat(): Value out of range."),t=Ue(t,-65504,65504),Vn.floatView[0]=t;const e=Vn.uint32View[0],i=e>>23&511;return Vn.baseTable[i]+((8388607&e)>>Vn.shiftTable[i])}function jn(t){const e=t>>10;return Vn.uint32View[0]=Vn.mantissaTable[Vn.offsetTable[e]+(1023&t)]+Vn.exponentTable[e],Vn.floatView[0]}class Xn{static toHalfFloat(t){return Wn(t)}static fromHalfFloat(t){return jn(t)}}const qn=new qe,Yn=new je;let $n=0;class Zn{constructor(t,e,i=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:$n++}),this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=i,this.usage=ye,this.updateRanges=[],this.gpuType=et,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let n=0,s=this.itemSize;n<s;n++)this.array[t+n]=e.array[i+n];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,i=this.count;e<i;e++)Yn.fromBufferAttribute(this,e),Yn.applyMatrix3(t),this.setXY(e,Yn.x,Yn.y);else if(3===this.itemSize)for(let e=0,i=this.count;e<i;e++)qn.fromBufferAttribute(this,e),qn.applyMatrix3(t),this.setXYZ(e,qn.x,qn.y,qn.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)qn.fromBufferAttribute(this,e),qn.applyMatrix4(t),this.setXYZ(e,qn.x,qn.y,qn.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)qn.fromBufferAttribute(this,e),qn.applyNormalMatrix(t),this.setXYZ(e,qn.x,qn.y,qn.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)qn.fromBufferAttribute(this,e),qn.transformDirection(t),this.setXYZ(e,qn.x,qn.y,qn.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let i=this.array[t*this.itemSize+e];return this.normalized&&(i=Ve(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=He(i,this.array)),this.array[t*this.itemSize+e]=i,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Ve(e,this.array)),e}setX(t,e){return this.normalized&&(e=He(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Ve(e,this.array)),e}setY(t,e){return this.normalized&&(e=He(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Ve(e,this.array)),e}setZ(t,e){return this.normalized&&(e=He(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Ve(e,this.array)),e}setW(t,e){return this.normalized&&(e=He(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=He(e,this.array),i=He(i,this.array)),this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,n){return t*=this.itemSize,this.normalized&&(e=He(e,this.array),i=He(i,this.array),n=He(n,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this}setXYZW(t,e,i,n,s){return t*=this.itemSize,this.normalized&&(e=He(e,this.array),i=He(i,this.array),n=He(n,this.array),s=He(s,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==ye&&(t.usage=this.usage),t}}class Jn extends Zn{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class Qn extends Zn{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class Kn extends Zn{constructor(t,e,i){super(new Float32Array(t),e,i)}}let ts=0;const es=new Wi,is=new vn,ns=new qe,ss=new yi,as=new yi,rs=new qe;class os extends Be{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:ts++}),this.uuid=Fe(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(xe(t)?Qn:Jn)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(void 0!==i){const e=(new Ze).getNormalMatrix(t);i.applyNormalMatrix(e),i.needsUpdate=!0}const n=this.attributes.tangent;return void 0!==n&&(n.transformDirection(t),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return es.makeRotationFromQuaternion(t),this.applyMatrix4(es),this}rotateX(t){return es.makeRotationX(t),this.applyMatrix4(es),this}rotateY(t){return es.makeRotationY(t),this.applyMatrix4(es),this}rotateZ(t){return es.makeRotationZ(t),this.applyMatrix4(es),this}translate(t,e,i){return es.makeTranslation(t,e,i),this.applyMatrix4(es),this}scale(t,e,i){return es.makeScale(t,e,i),this.applyMatrix4(es),this}lookAt(t){return is.lookAt(t),is.updateMatrix(),this.applyMatrix4(is.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ns).negate(),this.translate(ns.x,ns.y,ns.z),this}setFromPoints(t){const e=this.getAttribute("position");if(void 0===e){const e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i];e.push(n.x,n.y,n.z||0)}this.setAttribute("position",new Kn(e,3))}else{const i=Math.min(t.length,e.count);for(let n=0;n<i;n++){const i=t[n];e.setXYZ(n,i.x,i.y,i.z||0)}t.length>e.count&&De("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new yi);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return Re("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new qe(-1/0,-1/0,-1/0),new qe(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++){const i=e[t];ss.setFromBufferAttribute(i),this.morphTargetsRelative?(rs.addVectors(this.boundingBox.min,ss.min),this.boundingBox.expandByPoint(rs),rs.addVectors(this.boundingBox.max,ss.max),this.boundingBox.expandByPoint(rs)):(this.boundingBox.expandByPoint(ss.min),this.boundingBox.expandByPoint(ss.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&Re('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new ki);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return Re("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new qe,1/0);if(t){const i=this.boundingSphere.center;if(ss.setFromBufferAttribute(t),e)for(let t=0,i=e.length;t<i;t++){const i=e[t];as.setFromBufferAttribute(i),this.morphTargetsRelative?(rs.addVectors(ss.min,as.min),ss.expandByPoint(rs),rs.addVectors(ss.max,as.max),ss.expandByPoint(rs)):(ss.expandByPoint(as.min),ss.expandByPoint(as.max))}ss.getCenter(i);let n=0;for(let e=0,s=t.count;e<s;e++)rs.fromBufferAttribute(t,e),n=Math.max(n,i.distanceToSquared(rs));if(e)for(let s=0,a=e.length;s<a;s++){const a=e[s],r=this.morphTargetsRelative;for(let e=0,s=a.count;e<s;e++)rs.fromBufferAttribute(a,e),r&&(ns.fromBufferAttribute(t,e),rs.add(ns)),n=Math.max(n,i.distanceToSquared(rs))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&Re('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void Re("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const i=e.position,n=e.normal,s=e.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Zn(new Float32Array(4*i.count),4));const a=this.getAttribute("tangent"),r=[],o=[];for(let t=0;t<i.count;t++)r[t]=new qe,o[t]=new qe;const l=new qe,h=new qe,c=new qe,u=new je,d=new je,p=new je,m=new qe,g=new qe;function f(t,e,n){l.fromBufferAttribute(i,t),h.fromBufferAttribute(i,e),c.fromBufferAttribute(i,n),u.fromBufferAttribute(s,t),d.fromBufferAttribute(s,e),p.fromBufferAttribute(s,n),h.sub(l),c.sub(l),d.sub(u),p.sub(u);const a=1/(d.x*p.y-p.x*d.y);isFinite(a)&&(m.copy(h).multiplyScalar(p.y).addScaledVector(c,-d.y).multiplyScalar(a),g.copy(c).multiplyScalar(d.x).addScaledVector(h,-p.x).multiplyScalar(a),r[t].add(m),r[e].add(m),r[n].add(m),o[t].add(g),o[e].add(g),o[n].add(g))}let y=this.groups;0===y.length&&(y=[{start:0,count:t.count}]);for(let e=0,i=y.length;e<i;++e){const i=y[e],n=i.start;for(let e=n,s=n+i.count;e<s;e+=3)f(t.getX(e+0),t.getX(e+1),t.getX(e+2))}const v=new qe,b=new qe,M=new qe,_=new qe;function x(t){M.fromBufferAttribute(n,t),_.copy(M);const e=r[t];v.copy(e),v.sub(M.multiplyScalar(M.dot(e))).normalize(),b.crossVectors(_,e);const i=b.dot(o[t])<0?-1:1;a.setXYZW(t,v.x,v.y,v.z,i)}for(let e=0,i=y.length;e<i;++e){const i=y[e],n=i.start;for(let e=n,s=n+i.count;e<s;e+=3)x(t.getX(e+0)),x(t.getX(e+1)),x(t.getX(e+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let i=this.getAttribute("normal");if(void 0===i)i=new Zn(new Float32Array(3*e.count),3),this.setAttribute("normal",i);else for(let t=0,e=i.count;t<e;t++)i.setXYZ(t,0,0,0);const n=new qe,s=new qe,a=new qe,r=new qe,o=new qe,l=new qe,h=new qe,c=new qe;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),m=t.getX(u+2);n.fromBufferAttribute(e,d),s.fromBufferAttribute(e,p),a.fromBufferAttribute(e,m),h.subVectors(a,s),c.subVectors(n,s),h.cross(c),r.fromBufferAttribute(i,d),o.fromBufferAttribute(i,p),l.fromBufferAttribute(i,m),r.add(h),o.add(h),l.add(h),i.setXYZ(d,r.x,r.y,r.z),i.setXYZ(p,o.x,o.y,o.z),i.setXYZ(m,l.x,l.y,l.z)}else for(let t=0,r=e.count;t<r;t+=3)n.fromBufferAttribute(e,t+0),s.fromBufferAttribute(e,t+1),a.fromBufferAttribute(e,t+2),h.subVectors(a,s),c.subVectors(n,s),h.cross(c),i.setXYZ(t+0,h.x,h.y,h.z),i.setXYZ(t+1,h.x,h.y,h.z),i.setXYZ(t+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)rs.fromBufferAttribute(t,e),rs.normalize(),t.setXYZ(e,rs.x,rs.y,rs.z)}toNonIndexed(){function t(t,e){const i=t.array,n=t.itemSize,s=t.normalized,a=new i.constructor(e.length*n);let r=0,o=0;for(let s=0,l=e.length;s<l;s++){r=t.isInterleavedBufferAttribute?e[s]*t.data.stride+t.offset:e[s]*n;for(let t=0;t<n;t++)a[o++]=i[r++]}return new Zn(a,n,s)}if(null===this.index)return De("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new os,i=this.index.array,n=this.attributes;for(const s in n){const a=t(n[s],i);e.setAttribute(s,a)}const s=this.morphAttributes;for(const n in s){const a=[],r=s[n];for(let e=0,n=r.length;e<n;e++){const n=t(r[e],i);a.push(n)}e.morphAttributes[n]=a}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let t=0,i=a.length;t<i;t++){const i=a[t];e.addGroup(i.start,i.count,i.materialIndex)}return e}toJSON(){const t={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const i in e)void 0!==e[i]&&(t[i]=e[i]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const e in i){const n=i[e];t.data.attributes[e]=n.toJSON(t.data)}const n={};let s=!1;for(const e in this.morphAttributes){const i=this.morphAttributes[e],a=[];for(let e=0,n=i.length;e<n;e++){const n=i[e];a.push(n.toJSON(t.data))}a.length>0&&(n[e]=a,s=!0)}s&&(t.data.morphAttributes=n,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const r=this.boundingSphere;return null!==r&&(t.data.boundingSphere=r.toJSON()),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;null!==i&&this.setIndex(i.clone());const n=t.attributes;for(const t in n){const i=n[t];this.setAttribute(t,i.clone(e))}const s=t.morphAttributes;for(const t in s){const i=[],n=s[t];for(let t=0,s=n.length;t<s;t++)i.push(n[t].clone(e));this.morphAttributes[t]=i}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let t=0,e=a.length;t<e;t++){const e=a[t];this.addGroup(e.start,e.count,e.materialIndex)}const r=t.boundingBox;null!==r&&(this.boundingBox=r.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const ls=new Wi,hs=new Hi,cs=new ki,us=new qe,ds=new qe,ps=new qe,ms=new qe,gs=new qe,fs=new qe,ys=new qe,vs=new qe;class bs extends vn{constructor(t=new os,e=new Gn){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=i.length;t<e;t++){const e=i[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const i=this.geometry,n=i.attributes.position,s=i.morphAttributes.position,a=i.morphTargetsRelative;e.fromBufferAttribute(n,t);const r=this.morphTargetInfluences;if(s&&r){fs.set(0,0,0);for(let i=0,n=s.length;i<n;i++){const n=r[i],o=s[i];0!==n&&(gs.fromBufferAttribute(o,t),a?fs.addScaledVector(gs,n):fs.addScaledVector(gs.sub(e),n))}e.add(fs)}return e}raycast(t,e){const i=this.geometry,n=this.material,s=this.matrixWorld;if(void 0!==n){if(null===i.boundingSphere&&i.computeBoundingSphere(),cs.copy(i.boundingSphere),cs.applyMatrix4(s),hs.copy(t.ray).recast(t.near),!1===cs.containsPoint(hs.origin)){if(null===hs.intersectSphere(cs,us))return;if(hs.origin.distanceToSquared(us)>(t.far-t.near)**2)return}ls.copy(s).invert(),hs.copy(t.ray).applyMatrix4(ls),null!==i.boundingBox&&!1===hs.intersectsBox(i.boundingBox)||this._computeIntersections(t,e,hs)}}_computeIntersections(t,e,i){let n;const s=this.geometry,a=this.material,r=s.index,o=s.attributes.position,l=s.attributes.uv,h=s.attributes.uv1,c=s.attributes.normal,u=s.groups,d=s.drawRange;if(null!==r)if(Array.isArray(a))for(let s=0,o=u.length;s<o;s++){const o=u[s],p=a[o.materialIndex];for(let s=Math.max(o.start,d.start),a=Math.min(r.count,Math.min(o.start+o.count,d.start+d.count));s<a;s+=3)n=Ms(this,p,t,i,l,h,c,r.getX(s),r.getX(s+1),r.getX(s+2)),n&&(n.faceIndex=Math.floor(s/3),n.face.materialIndex=o.materialIndex,e.push(n))}else for(let s=Math.max(0,d.start),o=Math.min(r.count,d.start+d.count);s<o;s+=3)n=Ms(this,a,t,i,l,h,c,r.getX(s),r.getX(s+1),r.getX(s+2)),n&&(n.faceIndex=Math.floor(s/3),e.push(n));else if(void 0!==o)if(Array.isArray(a))for(let s=0,r=u.length;s<r;s++){const r=u[s],p=a[r.materialIndex];for(let s=Math.max(r.start,d.start),a=Math.min(o.count,Math.min(r.start+r.count,d.start+d.count));s<a;s+=3)n=Ms(this,p,t,i,l,h,c,s,s+1,s+2),n&&(n.faceIndex=Math.floor(s/3),n.face.materialIndex=r.materialIndex,e.push(n))}else for(let s=Math.max(0,d.start),r=Math.min(o.count,d.start+d.count);s<r;s+=3)n=Ms(this,a,t,i,l,h,c,s,s+1,s+2),n&&(n.faceIndex=Math.floor(s/3),e.push(n))}}function Ms(t,e,i,n,s,a,r,o,l,h){t.getVertexPosition(o,ds),t.getVertexPosition(l,ps),t.getVertexPosition(h,ms);const c=function(t,e,i,n,s,a,r,o){let l;if(l=1===e.side?n.intersectTriangle(r,a,s,!0,o):n.intersectTriangle(s,a,r,0===e.side,o),null===l)return null;vs.copy(o),vs.applyMatrix4(t.matrixWorld);const h=i.ray.origin.distanceTo(vs);return h<i.near||h>i.far?null:{distance:h,point:vs.clone(),object:t}}(t,e,i,n,ds,ps,ms,ys);if(c){const t=new qe;In.getBarycoord(ys,ds,ps,ms,t),s&&(c.uv=In.getInterpolatedAttribute(s,o,l,h,t,new je)),a&&(c.uv1=In.getInterpolatedAttribute(a,o,l,h,t,new je)),r&&(c.normal=In.getInterpolatedAttribute(r,o,l,h,t,new qe),c.normal.dot(n.direction)>0&&c.normal.multiplyScalar(-1));const e={a:o,b:l,c:h,normal:new qe,materialIndex:0};In.getNormal(ds,ps,ms,e.normal),c.face=e,c.barycoord=t}return c}class _s extends os{constructor(t=1,e=1,i=1,n=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:n,heightSegments:s,depthSegments:a};const r=this;n=Math.floor(n),s=Math.floor(s),a=Math.floor(a);const o=[],l=[],h=[],c=[];let u=0,d=0;function p(t,e,i,n,s,a,p,m,g,f,y){const v=a/g,b=p/f,M=a/2,_=p/2,x=m/2,w=g+1,S=f+1;let T=0,C=0;const E=new qe;for(let a=0;a<S;a++){const r=a*b-_;for(let o=0;o<w;o++){const u=o*v-M;E[t]=u*n,E[e]=r*s,E[i]=x,l.push(E.x,E.y,E.z),E[t]=0,E[e]=0,E[i]=m>0?1:-1,h.push(E.x,E.y,E.z),c.push(o/g),c.push(1-a/f),T+=1}}for(let t=0;t<f;t++)for(let e=0;e<g;e++){const i=u+e+w*t,n=u+e+w*(t+1),s=u+(e+1)+w*(t+1),a=u+(e+1)+w*t;o.push(i,n,a),o.push(n,s,a),C+=6}r.addGroup(d,C,y),d+=C,u+=T}p("z","y","x",-1,-1,i,e,t,a,s,0),p("z","y","x",1,-1,i,e,-t,a,s,1),p("x","z","y",1,1,t,i,e,n,a,2),p("x","z","y",1,-1,t,i,-e,n,a,3),p("x","y","z",1,-1,t,e,i,n,s,4),p("x","y","z",-1,-1,t,e,-i,n,s,5),this.setIndex(o),this.setAttribute("position",new Kn(l,3)),this.setAttribute("normal",new Kn(h,3)),this.setAttribute("uv",new Kn(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new _s(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function xs(t){const e={};for(const i in t){e[i]={};for(const n in t[i]){const s=t[i][n];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?(De("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[i][n]=null):e[i][n]=s.clone():Array.isArray(s)?e[i][n]=s.slice():e[i][n]=s}}return e}function ws(t){const e={};for(let i=0;i<t.length;i++){const n=xs(t[i]);for(const t in n)e[t]=n[t]}return e}function Ss(t){const e=t.getRenderTarget();return null===e?t.outputColorSpace:!0===e.isXRRenderTarget?e.texture.colorSpace:ei.workingColorSpace}const Ts={clone:xs,merge:ws};class Cs extends Nn{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=xs(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let i=0;i<t.length;i++)e.push(t[i].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const n=this.uniforms[i].value;n&&n.isTexture?e.uniforms[i]={type:"t",value:n.toJSON(t).uuid}:n&&n.isColor?e.uniforms[i]={type:"c",value:n.getHex()}:n&&n.isVector2?e.uniforms[i]={type:"v2",value:n.toArray()}:n&&n.isVector3?e.uniforms[i]={type:"v3",value:n.toArray()}:n&&n.isVector4?e.uniforms[i]={type:"v4",value:n.toArray()}:n&&n.isMatrix3?e.uniforms[i]={type:"m3",value:n.toArray()}:n&&n.isMatrix4?e.uniforms[i]={type:"m4",value:n.toArray()}:e.uniforms[i]={value:n}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const i={};for(const t in this.extensions)!0===this.extensions[t]&&(i[t]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}class Es extends vn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Wi,this.projectionMatrix=new Wi,this.projectionMatrixInverse=new Wi,this.coordinateSystem=Me,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}const As=new qe,Ps=new je,Ds=new je;class Rs extends Es{constructor(t=50,e=1,i=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=n,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*ze*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Oe*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*ze*Math.atan(Math.tan(.5*Oe*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,i){As.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(As.x,As.y).multiplyScalar(-t/As.z),As.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(As.x,As.y).multiplyScalar(-t/As.z)}getViewSize(t,e){return this.getViewBounds(t,Ps,Ds),e.subVectors(Ds,Ps)}setViewOffset(t,e,i,n,s,a){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Oe*this.fov)/this.zoom,i=2*e,n=this.aspect*i,s=-.5*n;const a=this.view;if(null!==this.view&&this.view.enabled){const t=a.fullWidth,r=a.fullHeight;s+=a.offsetX*n/t,e-=a.offsetY*i/r,n*=a.width/t,i*=a.height/r}const r=this.filmOffset;0!==r&&(s+=t*r/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+n,e,e-i,t,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const Is=-90;class Bs extends vn{constructor(t,e,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null,this.activeMipmapLevel=0;const n=new Rs(Is,1,t,e);n.layers=this.layers,this.add(n);const s=new Rs(Is,1,t,e);s.layers=this.layers,this.add(s);const a=new Rs(Is,1,t,e);a.layers=this.layers,this.add(a);const r=new Rs(Is,1,t,e);r.layers=this.layers,this.add(r);const o=new Rs(Is,1,t,e);o.layers=this.layers,this.add(o);const l=new Rs(Is,1,t,e);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[i,n,s,a,r,o]=e;for(const t of e)this.remove(t);if(t===Me)i.up.set(0,1,0),i.lookAt(1,0,0),n.up.set(0,1,0),n.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),r.up.set(0,1,0),r.lookAt(0,0,1),o.up.set(0,1,0),o.lookAt(0,0,-1);else{if(t!==_e)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);i.up.set(0,-1,0),i.lookAt(-1,0,0),n.up.set(0,-1,0),n.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),r.up.set(0,-1,0),r.lookAt(0,0,1),o.up.set(0,-1,0),o.lookAt(0,0,-1)}for(const t of e)this.add(t),t.updateMatrixWorld()}update(t,e){null===this.parent&&this.updateMatrixWorld();const{renderTarget:i,activeMipmapLevel:n}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[s,a,r,o,l,h]=this.children,c=t.getRenderTarget(),u=t.getActiveCubeFace(),d=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const m=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0,n),t.render(e,s),t.setRenderTarget(i,1,n),t.render(e,a),t.setRenderTarget(i,2,n),t.render(e,r),t.setRenderTarget(i,3,n),t.render(e,o),t.setRenderTarget(i,4,n),t.render(e,l),i.texture.generateMipmaps=m,t.setRenderTarget(i,5,n),t.render(e,h),t.setRenderTarget(c,u,d),t.xr.enabled=p,i.texture.needsPMREMUpdate=!0}}class Ls extends ui{constructor(t=[],e=301,i,n,s,a,r,o,l,h){super(t,e,i,n,s,a,r,o,l,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class ks extends mi{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const i={width:t,height:t,depth:1},n=[i,i,i,i,i,i];this.texture=new Ls(n),this._setTextureOptions(e),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={tEquirect:{value:null}},n="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",s="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",a=new _s(5,5,5),r=new Cs({name:"CubemapFromEquirect",uniforms:xs(i),vertexShader:n,fragmentShader:s,side:1,blending:0});r.uniforms.tEquirect.value=e;const o=new bs(a,r),l=e.minFilter;return e.minFilter===Y&&(e.minFilter=X),new Bs(1,10,this).update(t,o),e.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(t,e=!0,i=!0,n=!0){const s=t.getRenderTarget();for(let s=0;s<6;s++)t.setRenderTarget(this,s),t.clear(e,i,n);t.setRenderTarget(s)}}class Os extends vn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const zs={type:"move"};class Fs{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new Os,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new Os,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new qe,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new qe),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new Os,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new qe,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new qe),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const i of t.hand.values())this._getHandJoint(e,i)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,i){let n=null,s=null,a=null;const r=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState){if(l&&t.hand){a=!0;for(const n of t.hand.values()){const t=e.getJointPose(n,i),s=this._getHandJoint(l,n);null!==t&&(s.matrix.fromArray(t.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),s.matrixWorldNeedsUpdate=!0,s.jointRadius=t.radius),s.visible=null!==t}const n=l.joints["index-finger-tip"],s=l.joints["thumb-tip"],r=n.position.distanceTo(s.position),o=.02,h=.005;l.inputState.pinching&&r>o+h?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&r<=o-h&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(s=e.getPose(t.gripSpace,i),null!==s&&(o.matrix.fromArray(s.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,s.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(s.linearVelocity)):o.hasLinearVelocity=!1,s.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(s.angularVelocity)):o.hasAngularVelocity=!1));null!==r&&(n=e.getPose(t.targetRaySpace,i),null===n&&null!==s&&(n=s),null!==n&&(r.matrix.fromArray(n.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.matrixWorldNeedsUpdate=!0,n.linearVelocity?(r.hasLinearVelocity=!0,r.linearVelocity.copy(n.linearVelocity)):r.hasLinearVelocity=!1,n.angularVelocity?(r.hasAngularVelocity=!0,r.angularVelocity.copy(n.angularVelocity)):r.hasAngularVelocity=!1,this.dispatchEvent(zs)))}return null!==r&&(r.visible=null!==n),null!==o&&(o.visible=null!==s),null!==l&&(l.visible=null!==a),this}_getHandJoint(t,e){if(void 0===t.joints[e.jointName]){const i=new Os;i.matrixAutoUpdate=!1,i.visible=!1,t.joints[e.jointName]=i,t.add(i)}return t.joints[e.jointName]}}class Us{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new zn(t),this.density=e}clone(){return new Us(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Ns{constructor(t,e=1,i=1e3){this.isFog=!0,this.name="",this.color=new zn(t),this.near=e,this.far=i}clone(){return new Ns(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Gs extends vn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new tn,this.environmentIntensity=1,this.environmentRotation=new tn,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class Vs{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=ye,this.updateRanges=[],this.version=0,this.uuid=Fe()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let n=0,s=this.stride;n<s;n++)this.array[t+n]=e.array[i+n];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Fe()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Fe()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Hs=new qe;class Ws{constructor(t,e,i,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)Hs.fromBufferAttribute(this,e),Hs.applyMatrix4(t),this.setXYZ(e,Hs.x,Hs.y,Hs.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Hs.fromBufferAttribute(this,e),Hs.applyNormalMatrix(t),this.setXYZ(e,Hs.x,Hs.y,Hs.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Hs.fromBufferAttribute(this,e),Hs.transformDirection(t),this.setXYZ(e,Hs.x,Hs.y,Hs.z);return this}getComponent(t,e){let i=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(i=Ve(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=He(i,this.array)),this.data.array[t*this.data.stride+this.offset+e]=i,this}setX(t,e){return this.normalized&&(e=He(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=He(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=He(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=He(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Ve(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Ve(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Ve(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Ve(e,this.array)),e}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=He(e,this.array),i=He(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=He(e,this.array),i=He(i,this.array),n=He(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this}setXYZW(t,e,i,n,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=He(e,this.array),i=He(i,this.array),n=He(n,this.array),s=He(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this.data.array[t+3]=s,this}clone(t){if(void 0===t){Pe("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return new Zn(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Ws(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){Pe("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const i=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[i+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class js extends Nn{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new zn(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let Xs;const qs=new qe,Ys=new qe,$s=new qe,Zs=new je,Js=new je,Qs=new Wi,Ks=new qe,ta=new qe,ea=new qe,ia=new je,na=new je,sa=new je;class aa extends vn{constructor(t=new js){if(super(),this.isSprite=!0,this.type="Sprite",void 0===Xs){Xs=new os;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new Vs(t,5);Xs.setIndex([0,1,2,0,2,3]),Xs.setAttribute("position",new Ws(e,3,0,!1)),Xs.setAttribute("uv",new Ws(e,2,3,!1))}this.geometry=Xs,this.material=t,this.center=new je(.5,.5),this.count=1}raycast(t,e){null===t.camera&&Re('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ys.setFromMatrixScale(this.matrixWorld),Qs.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),$s.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Ys.multiplyScalar(-$s.z);const i=this.material.rotation;let n,s;0!==i&&(s=Math.cos(i),n=Math.sin(i));const a=this.center;ra(Ks.set(-.5,-.5,0),$s,a,Ys,n,s),ra(ta.set(.5,-.5,0),$s,a,Ys,n,s),ra(ea.set(.5,.5,0),$s,a,Ys,n,s),ia.set(0,0),na.set(1,0),sa.set(1,1);let r=t.ray.intersectTriangle(Ks,ta,ea,!1,qs);if(null===r&&(ra(ta.set(-.5,.5,0),$s,a,Ys,n,s),na.set(0,1),r=t.ray.intersectTriangle(Ks,ea,ta,!1,qs),null===r))return;const o=t.ray.origin.distanceTo(qs);o<t.near||o>t.far||e.push({distance:o,point:qs.clone(),uv:In.getInterpolation(qs,Ks,ta,ea,ia,na,sa,new je),face:null,object:this})}copy(t,e){return super.copy(t,e),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function ra(t,e,i,n,s,a){Zs.subVectors(t,i).addScalar(.5).multiply(n),void 0!==s?(Js.x=a*Zs.x-s*Zs.y,Js.y=s*Zs.x+a*Zs.y):Js.copy(Zs),t.copy(e),t.x+=Js.x,t.y+=Js.y,t.applyMatrix4(Qs)}const oa=new qe,la=new qe;class ha extends vn{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,i=e.length;t<i;t++){const i=e[t];this.addLevel(i.object.clone(),i.distance,i.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0,i=0){e=Math.abs(e);const n=this.levels;let s;for(s=0;s<n.length&&!(e<n[s].distance);s++);return n.splice(s,0,{distance:e,hysteresis:i,object:t}),this.add(t),this}removeLevel(t){const e=this.levels;for(let i=0;i<e.length;i++)if(e[i].distance===t){const t=e.splice(i,1);return this.remove(t[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let i,n;for(i=1,n=e.length;i<n;i++){let n=e[i].distance;if(e[i].object.visible&&(n-=n*e[i].hysteresis),t<n)break}return e[i-1].object}return null}raycast(t,e){if(this.levels.length>0){oa.setFromMatrixPosition(this.matrixWorld);const i=t.ray.origin.distanceTo(oa);this.getObjectForDistance(i).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){oa.setFromMatrixPosition(t.matrixWorld),la.setFromMatrixPosition(this.matrixWorld);const i=oa.distanceTo(la)/t.zoom;let n,s;for(e[0].object.visible=!0,n=1,s=e.length;n<s;n++){let t=e[n].distance;if(e[n].object.visible&&(t-=t*e[n].hysteresis),!(i>=t))break;e[n-1].object.visible=!1,e[n].object.visible=!0}for(this._currentLevel=n-1;n<s;n++)e[n].object.visible=!1}}toJSON(t){const e=super.toJSON(t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const i=this.levels;for(let t=0,n=i.length;t<n;t++){const n=i[t];e.object.levels.push({object:n.object.uuid,distance:n.distance,hysteresis:n.hysteresis})}return e}}const ca=new qe,ua=new di,da=new di,pa=new qe,ma=new Wi,ga=new qe,fa=new ki,ya=new Wi,va=new Hi;class ba extends bs{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=I,this.bindMatrix=new Wi,this.bindMatrixInverse=new Wi,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;null===this.boundingBox&&(this.boundingBox=new yi),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,ga),this.boundingBox.expandByPoint(ga)}computeBoundingSphere(){const t=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new ki),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,ga),this.boundingSphere.expandByPoint(ga)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const i=this.material,n=this.matrixWorld;void 0!==i&&(null===this.boundingSphere&&this.computeBoundingSphere(),fa.copy(this.boundingSphere),fa.applyMatrix4(n),!1!==t.ray.intersectsSphere(fa)&&(ya.copy(n).invert(),va.copy(t.ray).applyMatrix4(ya),null!==this.boundingBox&&!1===va.intersectsBox(this.boundingBox)||this._computeIntersections(t,e,va)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new di,e=this.geometry.attributes.skinWeight;for(let i=0,n=e.count;i<n;i++){t.fromBufferAttribute(e,i);const n=1/t.manhattanLength();n!==1/0?t.multiplyScalar(n):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===I?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===B?this.bindMatrixInverse.copy(this.bindMatrix).invert():De("SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const i=this.skeleton,n=this.geometry;ua.fromBufferAttribute(n.attributes.skinIndex,t),da.fromBufferAttribute(n.attributes.skinWeight,t),ca.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const n=da.getComponent(t);if(0!==n){const s=ua.getComponent(t);ma.multiplyMatrices(i.bones[s].matrixWorld,i.boneInverses[s]),e.addScaledVector(pa.copy(ca).applyMatrix4(ma),n)}}return e.applyMatrix4(this.bindMatrixInverse)}}class Ma extends vn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class _a extends ui{constructor(t=null,e=1,i=1,n,s,a,r,o,l=1003,h=1003,c,u){super(null,a,r,o,l,h,n,s,c,u),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const xa=new Wi,wa=new Wi;class Sa{constructor(t=[],e=[]){this.uuid=Fe(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){De("Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new Wi)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new Wi;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,i=this.boneMatrices,n=this.boneTexture;for(let n=0,s=t.length;n<s;n++){const s=t[n]?t[n].matrixWorld:wa;xa.multiplyMatrices(s,e[n]),xa.toArray(i,16*n)}null!==n&&(n.needsUpdate=!0)}clone(){return new Sa(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const i=new _a(e,t,t,ct,et);return i.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=i,this}getBoneByName(t){for(let e=0,i=this.bones.length;e<i;e++){const i=this.bones[e];if(i.name===t)return i}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let i=0,n=t.bones.length;i<n;i++){const n=t.bones[i];let s=e[n];void 0===s&&(De("Skeleton: No bone found with UUID:",n),s=new Ma),this.bones.push(s),this.boneInverses.push((new Wi).fromArray(t.boneInverses[i]))}return this.init(),this}toJSON(){const t={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,i=this.boneInverses;for(let n=0,s=e.length;n<s;n++){const s=e[n];t.bones.push(s.uuid);const a=i[n];t.boneInverses.push(a.toArray())}return t}}class Ta extends Zn{constructor(t,e,i,n=1){super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const Ca=new Wi,Ea=new Wi,Aa=[],Pa=new yi,Da=new Wi,Ra=new bs,Ia=new ki;class Ba extends bs{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Ta(new Float32Array(16*i),16),this.instanceColor=null,this.morphTexture=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let t=0;t<i;t++)this.setMatrixAt(t,Da)}computeBoundingBox(){const t=this.geometry,e=this.count;null===this.boundingBox&&(this.boundingBox=new yi),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,Ca),Pa.copy(t.boundingBox).applyMatrix4(Ca),this.boundingBox.union(Pa)}computeBoundingSphere(){const t=this.geometry,e=this.count;null===this.boundingSphere&&(this.boundingSphere=new ki),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,Ca),Ia.copy(t.boundingSphere).applyMatrix4(Ca),this.boundingSphere.union(Ia)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.morphTexture&&(this.morphTexture=t.morphTexture.clone()),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}getMorphAt(t,e){const i=e.morphTargetInfluences,n=this.morphTexture.source.data.data,s=t*(i.length+1)+1;for(let t=0;t<i.length;t++)i[t]=n[s+t]}raycast(t,e){const i=this.matrixWorld,n=this.count;if(Ra.geometry=this.geometry,Ra.material=this.material,void 0!==Ra.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),Ia.copy(this.boundingSphere),Ia.applyMatrix4(i),!1!==t.ray.intersectsSphere(Ia)))for(let s=0;s<n;s++){this.getMatrixAt(s,Ca),Ea.multiplyMatrices(i,Ca),Ra.matrixWorld=Ea,Ra.raycast(t,Aa);for(let t=0,i=Aa.length;t<i;t++){const i=Aa[t];i.instanceId=s,i.object=this,e.push(i)}Aa.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new Ta(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}setMorphAt(t,e){const i=e.morphTargetInfluences,n=i.length+1;null===this.morphTexture&&(this.morphTexture=new _a(new Float32Array(n*this.count),n,this.count,pt,et));const s=this.morphTexture.source.data.data;let a=0;for(let t=0;t<i.length;t++)a+=i[t];const r=this.geometry.morphTargetsRelative?1:1-a,o=n*t;s[o]=r,s.set(i,o+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null)}}const La=new qe,ka=new qe,Oa=new Ze;class za{constructor(t=new qe(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,n){return this.normal.set(t,e,i),this.constant=n,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const n=La.subVectors(i,e).cross(ka.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const i=t.delta(La),n=this.normal.dot(i);if(0===n)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/n;return s<0||s>1?null:e.copy(t.start).addScaledVector(i,s)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||Oa.getNormalMatrix(t),n=this.coplanarPoint(La).applyMatrix4(t),s=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const Fa=new ki,Ua=new je(.5,.5),Na=new qe;class Ga{constructor(t=new za,e=new za,i=new za,n=new za,s=new za,a=new za){this.planes=[t,e,i,n,s,a]}set(t,e,i,n,s,a){const r=this.planes;return r[0].copy(t),r[1].copy(e),r[2].copy(i),r[3].copy(n),r[4].copy(s),r[5].copy(a),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t,e=2e3,i=!1){const n=this.planes,s=t.elements,a=s[0],r=s[1],o=s[2],l=s[3],h=s[4],c=s[5],u=s[6],d=s[7],p=s[8],m=s[9],g=s[10],f=s[11],y=s[12],v=s[13],b=s[14],M=s[15];if(n[0].setComponents(l-a,d-h,f-p,M-y).normalize(),n[1].setComponents(l+a,d+h,f+p,M+y).normalize(),n[2].setComponents(l+r,d+c,f+m,M+v).normalize(),n[3].setComponents(l-r,d-c,f-m,M-v).normalize(),i)n[4].setComponents(o,u,g,b).normalize(),n[5].setComponents(l-o,d-u,f-g,M-b).normalize();else if(n[4].setComponents(l-o,d-u,f-g,M-b).normalize(),e===Me)n[5].setComponents(l+o,d+u,f+g,M+b).normalize();else{if(e!==_e)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);n[5].setComponents(o,u,g,b).normalize()}return this}intersectsObject(t){if(void 0!==t.boundingSphere)null===t.boundingSphere&&t.computeBoundingSphere(),Fa.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;null===e.boundingSphere&&e.computeBoundingSphere(),Fa.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(Fa)}intersectsSprite(t){Fa.center.set(0,0,0);const e=Ua.distanceTo(t.center);return Fa.radius=.7071067811865476+e,Fa.applyMatrix4(t.matrixWorld),this.intersectsSphere(Fa)}intersectsSphere(t){const e=this.planes,i=t.center,n=-t.radius;for(let t=0;t<6;t++)if(e[t].distanceToPoint(i)<n)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const n=e[i];if(Na.x=n.normal.x>0?t.max.x:t.min.x,Na.y=n.normal.y>0?t.max.y:t.min.y,Na.z=n.normal.z>0?t.max.z:t.min.z,n.distanceToPoint(Na)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}const Va=new Wi,Ha=new Ga;class Wa{constructor(){this.coordinateSystem=Me}intersectsObject(t,e){if(!e.isArrayCamera||0===e.cameras.length)return!1;for(let i=0;i<e.cameras.length;i++){const n=e.cameras[i];if(Va.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Ha.setFromProjectionMatrix(Va,n.coordinateSystem,n.reversedDepth),Ha.intersectsObject(t))return!0}return!1}intersectsSprite(t,e){if(!e||!e.cameras||0===e.cameras.length)return!1;for(let i=0;i<e.cameras.length;i++){const n=e.cameras[i];if(Va.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Ha.setFromProjectionMatrix(Va,n.coordinateSystem,n.reversedDepth),Ha.intersectsSprite(t))return!0}return!1}intersectsSphere(t,e){if(!e||!e.cameras||0===e.cameras.length)return!1;for(let i=0;i<e.cameras.length;i++){const n=e.cameras[i];if(Va.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Ha.setFromProjectionMatrix(Va,n.coordinateSystem,n.reversedDepth),Ha.intersectsSphere(t))return!0}return!1}intersectsBox(t,e){if(!e||!e.cameras||0===e.cameras.length)return!1;for(let i=0;i<e.cameras.length;i++){const n=e.cameras[i];if(Va.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Ha.setFromProjectionMatrix(Va,n.coordinateSystem,n.reversedDepth),Ha.intersectsBox(t))return!0}return!1}containsPoint(t,e){if(!e||!e.cameras||0===e.cameras.length)return!1;for(let i=0;i<e.cameras.length;i++){const n=e.cameras[i];if(Va.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),Ha.setFromProjectionMatrix(Va,n.coordinateSystem,n.reversedDepth),Ha.containsPoint(t))return!0}return!1}clone(){return new Wa}}function ja(t,e){return t-e}function Xa(t,e){return t.z-e.z}function qa(t,e){return e.z-t.z}class Ya{constructor(){this.index=0,this.pool=[],this.list=[]}push(t,e,i,n){const s=this.pool,a=this.list;this.index>=s.length&&s.push({start:-1,count:-1,z:-1,index:-1});const r=s[this.index];a.push(r),this.index++,r.start=t,r.count=e,r.z=i,r.index=n}reset(){this.list.length=0,this.index=0}}const $a=new Wi,Za=new zn(1,1,1),Ja=new Ga,Qa=new Wa,Ka=new yi,tr=new ki,er=new qe,ir=new qe,nr=new qe,sr=new Ya,ar=new bs,rr=[];function or(t,e,i=0){const n=e.itemSize;if(t.isInterleavedBufferAttribute||t.array.constructor!==e.array.constructor){const s=t.count;for(let a=0;a<s;a++)for(let s=0;s<n;s++)e.setComponent(a+i,s,t.getComponent(a,s))}else e.array.set(t.array,i*n);e.needsUpdate=!0}function lr(t,e){if(t.constructor!==e.constructor){const i=Math.min(t.length,e.length);for(let n=0;n<i;n++)e[n]=t[n]}else{const i=Math.min(t.length,e.length);e.set(new t.constructor(t.buffer,0,i))}}class hr extends bs{constructor(t,e,i=2*e,n){super(new os,n),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=t,this._maxVertexCount=e,this._maxIndexCount=i,this._multiDrawCounts=new Int32Array(t),this._multiDrawStarts=new Int32Array(t),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let t=Math.sqrt(4*this._maxInstanceCount);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4),i=new _a(e,t,t,ct,et);this._matricesTexture=i}_initIndirectTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Uint32Array(t*t),i=new _a(e,t,t,mt,tt);this._indirectTexture=i}_initColorsTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=new Float32Array(t*t*4).fill(1),i=new _a(e,t,t,ct,et);i.colorSpace=ei.workingColorSpace,this._colorsTexture=i}_initializeGeometry(t){const e=this.geometry,i=this._maxVertexCount,n=this._maxIndexCount;if(!1===this._geometryInitialized){for(const n in t.attributes){const s=t.getAttribute(n),{array:a,itemSize:r,normalized:o}=s,l=new a.constructor(i*r),h=new Zn(l,r,o);e.setAttribute(n,h)}if(null!==t.getIndex()){const t=i>65535?new Uint32Array(n):new Uint16Array(n);e.setIndex(new Zn(t,1))}this._geometryInitialized=!0}}_validateGeometry(t){const e=this.geometry;if(Boolean(t.getIndex())!==Boolean(e.getIndex()))throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const i in e.attributes){if(!t.hasAttribute(i))throw new Error(`THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);const n=t.getAttribute(i),s=e.getAttribute(i);if(n.itemSize!==s.itemSize||n.normalized!==s.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(t){const e=this._instanceInfo;if(t<0||t>=e.length||!1===e[t].active)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${t}. Instance is either out of range or has been deleted.`)}validateGeometryId(t){const e=this._geometryInfo;if(t<0||t>=e.length||!1===e[t].active)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${t}. Geometry is either out of range or has been deleted.`)}setCustomSort(t){return this.customSort=t,this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new yi);const t=this.boundingBox,e=this._instanceInfo;t.makeEmpty();for(let i=0,n=e.length;i<n;i++){if(!1===e[i].active)continue;const n=e[i].geometryIndex;this.getMatrixAt(i,$a),this.getBoundingBoxAt(n,Ka).applyMatrix4($a),t.union(Ka)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new ki);const t=this.boundingSphere,e=this._instanceInfo;t.makeEmpty();for(let i=0,n=e.length;i<n;i++){if(!1===e[i].active)continue;const n=e[i].geometryIndex;this.getMatrixAt(i,$a),this.getBoundingSphereAt(n,tr).applyMatrix4($a),t.union(tr)}}addInstance(t){if(this._instanceInfo.length>=this.maxInstanceCount&&0===this._availableInstanceIds.length)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const e={visible:!0,active:!0,geometryIndex:t};let i=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(ja),i=this._availableInstanceIds.shift(),this._instanceInfo[i]=e):(i=this._instanceInfo.length,this._instanceInfo.push(e));const n=this._matricesTexture;$a.identity().toArray(n.image.data,16*i),n.needsUpdate=!0;const s=this._colorsTexture;return s&&(Za.toArray(s.image.data,4*i),s.needsUpdate=!0),this._visibilityChanged=!0,i}addGeometry(t,e=-1,i=-1){this._initializeGeometry(t),this._validateGeometry(t);const n={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},s=this._geometryInfo;n.vertexStart=this._nextVertexStart,n.reservedVertexCount=-1===e?t.getAttribute("position").count:e;const a=t.getIndex();if(null!==a&&(n.indexStart=this._nextIndexStart,n.reservedIndexCount=-1===i?a.count:i),-1!==n.indexStart&&n.indexStart+n.reservedIndexCount>this._maxIndexCount||n.vertexStart+n.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let r;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(ja),r=this._availableGeometryIds.shift(),s[r]=n):(r=this._geometryCount,this._geometryCount++,s.push(n)),this.setGeometryAt(r,t),this._nextIndexStart=n.indexStart+n.reservedIndexCount,this._nextVertexStart=n.vertexStart+n.reservedVertexCount,r}setGeometryAt(t,e){if(t>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(e);const i=this.geometry,n=null!==i.getIndex(),s=i.getIndex(),a=e.getIndex(),r=this._geometryInfo[t];if(n&&a.count>r.reservedIndexCount||e.attributes.position.count>r.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const o=r.vertexStart,l=r.reservedVertexCount;r.vertexCount=e.getAttribute("position").count;for(const t in i.attributes){const n=e.getAttribute(t),s=i.getAttribute(t);or(n,s,o);const a=n.itemSize;for(let t=n.count,e=l;t<e;t++){const e=o+t;for(let t=0;t<a;t++)s.setComponent(e,t,0)}s.needsUpdate=!0,s.addUpdateRange(o*a,l*a)}if(n){const t=r.indexStart,i=r.reservedIndexCount;r.indexCount=e.getIndex().count;for(let e=0;e<a.count;e++)s.setX(t+e,o+a.getX(e));for(let e=a.count,n=i;e<n;e++)s.setX(t+e,o);s.needsUpdate=!0,s.addUpdateRange(t,r.reservedIndexCount)}return r.start=n?r.indexStart:r.vertexStart,r.count=n?r.indexCount:r.vertexCount,r.boundingBox=null,null!==e.boundingBox&&(r.boundingBox=e.boundingBox.clone()),r.boundingSphere=null,null!==e.boundingSphere&&(r.boundingSphere=e.boundingSphere.clone()),this._visibilityChanged=!0,t}deleteGeometry(t){const e=this._geometryInfo;if(t>=e.length||!1===e[t].active)return this;const i=this._instanceInfo;for(let e=0,n=i.length;e<n;e++)i[e].active&&i[e].geometryIndex===t&&this.deleteInstance(e);return e[t].active=!1,this._availableGeometryIds.push(t),this._visibilityChanged=!0,this}deleteInstance(t){return this.validateInstanceId(t),this._instanceInfo[t].active=!1,this._availableInstanceIds.push(t),this._visibilityChanged=!0,this}optimize(){let t=0,e=0;const i=this._geometryInfo,n=i.map((t,e)=>e).sort((t,e)=>i[t].vertexStart-i[e].vertexStart),s=this.geometry;for(let a=0,r=i.length;a<r;a++){const r=n[a],o=i[r];if(!1!==o.active){if(null!==s.index){if(o.indexStart!==e){const{indexStart:i,vertexStart:n,reservedIndexCount:a}=o,r=s.index,l=r.array,h=t-n;for(let t=i;t<i+a;t++)l[t]=l[t]+h;r.array.copyWithin(e,i,i+a),r.addUpdateRange(e,a),o.indexStart=e}e+=o.reservedIndexCount}if(o.vertexStart!==t){const{vertexStart:e,reservedVertexCount:i}=o,n=s.attributes;for(const s in n){const a=n[s],{array:r,itemSize:o}=a;r.copyWithin(t*o,e*o,(e+i)*o),a.addUpdateRange(t*o,i*o)}o.vertexStart=t}t+=o.reservedVertexCount,o.start=s.index?o.indexStart:o.vertexStart,this._nextIndexStart=s.index?o.indexStart+o.reservedIndexCount:0,this._nextVertexStart=o.vertexStart+o.reservedVertexCount}}return this}getBoundingBoxAt(t,e){if(t>=this._geometryCount)return null;const i=this.geometry,n=this._geometryInfo[t];if(null===n.boundingBox){const t=new yi,e=i.index,s=i.attributes.position;for(let i=n.start,a=n.start+n.count;i<a;i++){let n=i;e&&(n=e.getX(n)),t.expandByPoint(er.fromBufferAttribute(s,n))}n.boundingBox=t}return e.copy(n.boundingBox),e}getBoundingSphereAt(t,e){if(t>=this._geometryCount)return null;const i=this.geometry,n=this._geometryInfo[t];if(null===n.boundingSphere){const e=new ki;this.getBoundingBoxAt(t,Ka),Ka.getCenter(e.center);const s=i.index,a=i.attributes.position;let r=0;for(let t=n.start,i=n.start+n.count;t<i;t++){let i=t;s&&(i=s.getX(i)),er.fromBufferAttribute(a,i),r=Math.max(r,e.center.distanceToSquared(er))}e.radius=Math.sqrt(r),n.boundingSphere=e}return e.copy(n.boundingSphere),e}setMatrixAt(t,e){this.validateInstanceId(t);const i=this._matricesTexture,n=this._matricesTexture.image.data;return e.toArray(n,16*t),i.needsUpdate=!0,this}getMatrixAt(t,e){return this.validateInstanceId(t),e.fromArray(this._matricesTexture.image.data,16*t)}setColorAt(t,e){return this.validateInstanceId(t),null===this._colorsTexture&&this._initColorsTexture(),e.toArray(this._colorsTexture.image.data,4*t),this._colorsTexture.needsUpdate=!0,this}getColorAt(t,e){return this.validateInstanceId(t),e.fromArray(this._colorsTexture.image.data,4*t)}setVisibleAt(t,e){return this.validateInstanceId(t),this._instanceInfo[t].visible===e||(this._instanceInfo[t].visible=e,this._visibilityChanged=!0),this}getVisibleAt(t){return this.validateInstanceId(t),this._instanceInfo[t].visible}setGeometryIdAt(t,e){return this.validateInstanceId(t),this.validateGeometryId(e),this._instanceInfo[t].geometryIndex=e,this}getGeometryIdAt(t){return this.validateInstanceId(t),this._instanceInfo[t].geometryIndex}getGeometryRangeAt(t,e={}){this.validateGeometryId(t);const i=this._geometryInfo[t];return e.vertexStart=i.vertexStart,e.vertexCount=i.vertexCount,e.reservedVertexCount=i.reservedVertexCount,e.indexStart=i.indexStart,e.indexCount=i.indexCount,e.reservedIndexCount=i.reservedIndexCount,e.start=i.start,e.count=i.count,e}setInstanceCount(t){const e=this._availableInstanceIds,i=this._instanceInfo;for(e.sort(ja);e[e.length-1]===i.length-1;)i.pop(),e.pop();if(t<i.length)throw new Error(`BatchedMesh: Instance ids outside the range ${t} are being used. Cannot shrink instance count.`);const n=new Int32Array(t),s=new Int32Array(t);lr(this._multiDrawCounts,n),lr(this._multiDrawStarts,s),this._multiDrawCounts=n,this._multiDrawStarts=s,this._maxInstanceCount=t;const a=this._indirectTexture,r=this._matricesTexture,o=this._colorsTexture;a.dispose(),this._initIndirectTexture(),lr(a.image.data,this._indirectTexture.image.data),r.dispose(),this._initMatricesTexture(),lr(r.image.data,this._matricesTexture.image.data),o&&(o.dispose(),this._initColorsTexture(),lr(o.image.data,this._colorsTexture.image.data))}setGeometrySize(t,e){const i=[...this._geometryInfo].filter(t=>t.active);if(Math.max(...i.map(t=>t.vertexStart+t.reservedVertexCount))>t)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${e}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...i.map(t=>t.indexStart+t.reservedIndexCount))>e)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${e}. Cannot shrink further.`);const n=this.geometry;n.dispose(),this._maxVertexCount=t,this._maxIndexCount=e,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new os,this._initializeGeometry(n));const s=this.geometry;n.index&&lr(n.index.array,s.index.array);for(const t in n.attributes)lr(n.attributes[t].array,s.attributes[t].array)}raycast(t,e){const i=this._instanceInfo,n=this._geometryInfo,s=this.matrixWorld,a=this.geometry;ar.material=this.material,ar.geometry.index=a.index,ar.geometry.attributes=a.attributes,null===ar.geometry.boundingBox&&(ar.geometry.boundingBox=new yi),null===ar.geometry.boundingSphere&&(ar.geometry.boundingSphere=new ki);for(let a=0,r=i.length;a<r;a++){if(!i[a].visible||!i[a].active)continue;const r=i[a].geometryIndex,o=n[r];ar.geometry.setDrawRange(o.start,o.count),this.getMatrixAt(a,ar.matrixWorld).premultiply(s),this.getBoundingBoxAt(r,ar.geometry.boundingBox),this.getBoundingSphereAt(r,ar.geometry.boundingSphere),ar.raycast(t,rr);for(let t=0,i=rr.length;t<i;t++){const i=rr[t];i.object=this,i.batchId=a,e.push(i)}rr.length=0}ar.material=null,ar.geometry.index=null,ar.geometry.attributes={},ar.geometry.setDrawRange(0,1/0)}copy(t){return super.copy(t),this.geometry=t.geometry.clone(),this.perObjectFrustumCulled=t.perObjectFrustumCulled,this.sortObjects=t.sortObjects,this.boundingBox=null!==t.boundingBox?t.boundingBox.clone():null,this.boundingSphere=null!==t.boundingSphere?t.boundingSphere.clone():null,this._geometryInfo=t._geometryInfo.map(t=>({...t,boundingBox:null!==t.boundingBox?t.boundingBox.clone():null,boundingSphere:null!==t.boundingSphere?t.boundingSphere.clone():null})),this._instanceInfo=t._instanceInfo.map(t=>({...t})),this._availableInstanceIds=t._availableInstanceIds.slice(),this._availableGeometryIds=t._availableGeometryIds.slice(),this._nextIndexStart=t._nextIndexStart,this._nextVertexStart=t._nextVertexStart,this._geometryCount=t._geometryCount,this._maxInstanceCount=t._maxInstanceCount,this._maxVertexCount=t._maxVertexCount,this._maxIndexCount=t._maxIndexCount,this._geometryInitialized=t._geometryInitialized,this._multiDrawCounts=t._multiDrawCounts.slice(),this._multiDrawStarts=t._multiDrawStarts.slice(),this._indirectTexture=t._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=t._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),null!==this._colorsTexture&&(this._colorsTexture=t._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,null!==this._colorsTexture&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(t,e,i,n,s){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const a=n.getIndex(),r=null===a?1:a.array.BYTES_PER_ELEMENT,o=this._instanceInfo,l=this._multiDrawStarts,h=this._multiDrawCounts,c=this._geometryInfo,u=this.perObjectFrustumCulled,d=this._indirectTexture,p=d.image.data,m=i.isArrayCamera?Qa:Ja;u&&!i.isArrayCamera&&($a.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse).multiply(this.matrixWorld),Ja.setFromProjectionMatrix($a,i.coordinateSystem,i.reversedDepth));let g=0;if(this.sortObjects){$a.copy(this.matrixWorld).invert(),er.setFromMatrixPosition(i.matrixWorld).applyMatrix4($a),ir.set(0,0,-1).transformDirection(i.matrixWorld).transformDirection($a);for(let t=0,e=o.length;t<e;t++)if(o[t].visible&&o[t].active){const e=o[t].geometryIndex;this.getMatrixAt(t,$a),this.getBoundingSphereAt(e,tr).applyMatrix4($a);let n=!1;if(u&&(n=!m.intersectsSphere(tr,i)),!n){const i=c[e],n=nr.subVectors(tr.center,er).dot(ir);sr.push(i.start,i.count,n,t)}}const t=sr.list,e=this.customSort;null===e?t.sort(s.transparent?qa:Xa):e.call(this,t,i);for(let e=0,i=t.length;e<i;e++){const i=t[e];l[g]=i.start*r,h[g]=i.count,p[g]=i.index,g++}sr.reset()}else for(let t=0,e=o.length;t<e;t++)if(o[t].visible&&o[t].active){const e=o[t].geometryIndex;let n=!1;if(u&&(this.getMatrixAt(t,$a),this.getBoundingSphereAt(e,tr).applyMatrix4($a),n=!m.intersectsSphere(tr,i)),!n){const i=c[e];l[g]=i.start*r,h[g]=i.count,p[g]=t,g++}}d.needsUpdate=!0,this._multiDrawCount=g,this._visibilityChanged=!1}onBeforeShadow(t,e,i,n,s,a){this.onBeforeRender(t,null,n,s,a)}}class cr extends Nn{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new zn(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const ur=new qe,dr=new qe,pr=new Wi,mr=new Hi,gr=new ki,fr=new qe,yr=new qe;class vr extends vn{constructor(t=new os,e=new cr){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,i=[0];for(let t=1,n=e.count;t<n;t++)ur.fromBufferAttribute(e,t-1),dr.fromBufferAttribute(e,t),i[t]=i[t-1],i[t]+=ur.distanceTo(dr);t.setAttribute("lineDistance",new Kn(i,1))}else De("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,s=t.params.Line.threshold,a=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),gr.copy(i.boundingSphere),gr.applyMatrix4(n),gr.radius+=s,!1===t.ray.intersectsSphere(gr))return;pr.copy(n).invert(),mr.copy(t.ray).applyMatrix4(pr);const r=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=r*r,l=this.isLineSegments?2:1,h=i.index,c=i.attributes.position;if(null!==h){const i=Math.max(0,a.start),n=Math.min(h.count,a.start+a.count);for(let s=i,a=n-1;s<a;s+=l){const i=h.getX(s),n=h.getX(s+1),a=br(this,t,mr,o,i,n,s);a&&e.push(a)}if(this.isLineLoop){const s=h.getX(n-1),a=h.getX(i),r=br(this,t,mr,o,s,a,n-1);r&&e.push(r)}}else{const i=Math.max(0,a.start),n=Math.min(c.count,a.start+a.count);for(let s=i,a=n-1;s<a;s+=l){const i=br(this,t,mr,o,s,s+1,s);i&&e.push(i)}if(this.isLineLoop){const s=br(this,t,mr,o,n-1,i,n-1);s&&e.push(s)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=i.length;t<e;t++){const e=i[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function br(t,e,i,n,s,a,r){const o=t.geometry.attributes.position;if(ur.fromBufferAttribute(o,s),dr.fromBufferAttribute(o,a),i.distanceSqToSegment(ur,dr,fr,yr)>n)return;fr.applyMatrix4(t.matrixWorld);const l=e.ray.origin.distanceTo(fr);return l<e.near||l>e.far?void 0:{distance:l,point:yr.clone().applyMatrix4(t.matrixWorld),index:r,face:null,faceIndex:null,barycoord:null,object:t}}const Mr=new qe,_r=new qe;class xr extends vr{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,i=[];for(let t=0,n=e.count;t<n;t+=2)Mr.fromBufferAttribute(e,t),_r.fromBufferAttribute(e,t+1),i[t]=0===t?0:i[t-1],i[t+1]=i[t]+Mr.distanceTo(_r);t.setAttribute("lineDistance",new Kn(i,1))}else De("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class wr extends vr{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class Sr extends Nn{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new zn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const Tr=new Wi,Cr=new Hi,Er=new ki,Ar=new qe;class Pr extends vn{constructor(t=new os,e=new Sr){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,s=t.params.Points.threshold,a=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),Er.copy(i.boundingSphere),Er.applyMatrix4(n),Er.radius+=s,!1===t.ray.intersectsSphere(Er))return;Tr.copy(n).invert(),Cr.copy(t.ray).applyMatrix4(Tr);const r=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=r*r,l=i.index,h=i.attributes.position;if(null!==l)for(let i=Math.max(0,a.start),s=Math.min(l.count,a.start+a.count);i<s;i++){const s=l.getX(i);Ar.fromBufferAttribute(h,s),Dr(Ar,s,o,n,t,e,this)}else for(let i=Math.max(0,a.start),s=Math.min(h.count,a.start+a.count);i<s;i++)Ar.fromBufferAttribute(h,i),Dr(Ar,i,o,n,t,e,this)}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const i=t[e[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=i.length;t<e;t++){const e=i[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function Dr(t,e,i,n,s,a,r){const o=Cr.distanceSqToPoint(t);if(o<i){const i=new qe;Cr.closestPointToPoint(t,i),i.applyMatrix4(n);const l=s.ray.origin.distanceTo(i);if(l<s.near||l>s.far)return;a.push({distance:l,distanceToRay:Math.sqrt(o),point:i,index:e,face:null,faceIndex:null,barycoord:null,object:r})}}class Rr extends ui{constructor(t,e,i,n,s=1006,a=1006,r,o,l){super(t,e,i,n,s,a,r,o,l),this.isVideoTexture=!0,this.generateMipmaps=!1,this._requestVideoFrameCallbackId=0;const h=this;"requestVideoFrameCallback"in t&&(this._requestVideoFrameCallbackId=t.requestVideoFrameCallback(function e(){h.needsUpdate=!0,h._requestVideoFrameCallbackId=t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}dispose(){0!==this._requestVideoFrameCallbackId&&(this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),this._requestVideoFrameCallbackId=0),super.dispose()}}class Ir extends ui{constructor(t,e,i,n,s,a,r,o,l,h,c,u){super(null,a,r,o,l,h,n,s,c,u),this.isCompressedTexture=!0,this.image={width:e,height:i},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class Br extends ui{constructor(t,e,i,n,s,a,r,o,l){super(t,e,i,n,s,a,r,o,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Lr extends ui{constructor(t,e,i=1014,n,s,a,r=1003,o=1003,l,h=1026,c=1){if(h!==ut&&h!==dt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");super({width:t,height:e,depth:c},n,s,a,r,o,h,i,l),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.source=new oi(Object.assign({},t.image)),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}}class kr extends ui{constructor(t=null){super(),this.sourceTexture=t,this.isExternalTexture=!0}copy(t){return super.copy(t),this.sourceTexture=t.sourceTexture,this}}class Or extends os{constructor(t=1,e=1,i=4,n=8,s=1){super(),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:i,radialSegments:n,heightSegments:s},e=Math.max(0,e),i=Math.max(1,Math.floor(i)),n=Math.max(3,Math.floor(n)),s=Math.max(1,Math.floor(s));const a=[],r=[],o=[],l=[],h=e/2,c=Math.PI/2*t,u=e,d=2*c+u,p=2*i+s,m=n+1,g=new qe,f=new qe;for(let y=0;y<=p;y++){let v=0,b=0,M=0,_=0;if(y<=i){const e=y/i,n=e*Math.PI/2;b=-h-t*Math.cos(n),M=t*Math.sin(n),_=-t*Math.cos(n),v=e*c}else if(y<=i+s){const n=(y-i)/s;b=n*e-h,M=t,_=0,v=c+n*u}else{const e=(y-i-s)/i,n=e*Math.PI/2;b=h+t*Math.sin(n),M=t*Math.cos(n),_=t*Math.sin(n),v=c+u+e*c}const x=Math.max(0,Math.min(1,v/d));let w=0;0===y?w=.5/n:y===p&&(w=-.5/n);for(let t=0;t<=n;t++){const e=t/n,i=e*Math.PI*2,s=Math.sin(i),a=Math.cos(i);f.x=-M*a,f.y=b,f.z=M*s,r.push(f.x,f.y,f.z),g.set(-M*a,_,M*s),g.normalize(),o.push(g.x,g.y,g.z),l.push(e+w,x)}if(y>0){const t=(y-1)*m;for(let e=0;e<n;e++){const i=t+e,n=t+e+1,s=y*m+e,r=y*m+e+1;a.push(i,n,s),a.push(n,r,s)}}}this.setIndex(a),this.setAttribute("position",new Kn(r,3)),this.setAttribute("normal",new Kn(o,3)),this.setAttribute("uv",new Kn(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Or(t.radius,t.height,t.capSegments,t.radialSegments,t.heightSegments)}}class zr extends os{constructor(t=1,e=32,i=0,n=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:i,thetaLength:n},e=Math.max(3,e);const s=[],a=[],r=[],o=[],l=new qe,h=new je;a.push(0,0,0),r.push(0,0,1),o.push(.5,.5);for(let s=0,c=3;s<=e;s++,c+=3){const u=i+s/e*n;l.x=t*Math.cos(u),l.y=t*Math.sin(u),a.push(l.x,l.y,l.z),r.push(0,0,1),h.x=(a[c]/t+1)/2,h.y=(a[c+1]/t+1)/2,o.push(h.x,h.y)}for(let t=1;t<=e;t++)s.push(t,t+1,0);this.setIndex(s),this.setAttribute("position",new Kn(a,3)),this.setAttribute("normal",new Kn(r,3)),this.setAttribute("uv",new Kn(o,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new zr(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class Fr extends os{constructor(t=1,e=1,i=1,n=32,s=1,a=!1,r=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:i,radialSegments:n,heightSegments:s,openEnded:a,thetaStart:r,thetaLength:o};const l=this;n=Math.floor(n),s=Math.floor(s);const h=[],c=[],u=[],d=[];let p=0;const m=[],g=i/2;let f=0;function y(i){const s=p,a=new je,m=new qe;let y=0;const v=!0===i?t:e,b=!0===i?1:-1;for(let t=1;t<=n;t++)c.push(0,g*b,0),u.push(0,b,0),d.push(.5,.5),p++;const M=p;for(let t=0;t<=n;t++){const e=t/n*o+r,i=Math.cos(e),s=Math.sin(e);m.x=v*s,m.y=g*b,m.z=v*i,c.push(m.x,m.y,m.z),u.push(0,b,0),a.x=.5*i+.5,a.y=.5*s*b+.5,d.push(a.x,a.y),p++}for(let t=0;t<n;t++){const e=s+t,n=M+t;!0===i?h.push(n,n+1,e):h.push(n+1,n,e),y+=3}l.addGroup(f,y,!0===i?1:2),f+=y}!function(){const a=new qe,y=new qe;let v=0;const b=(e-t)/i;for(let l=0;l<=s;l++){const h=[],f=l/s,v=f*(e-t)+t;for(let t=0;t<=n;t++){const e=t/n,s=e*o+r,l=Math.sin(s),m=Math.cos(s);y.x=v*l,y.y=-f*i+g,y.z=v*m,c.push(y.x,y.y,y.z),a.set(l,b,m).normalize(),u.push(a.x,a.y,a.z),d.push(e,1-f),h.push(p++)}m.push(h)}for(let i=0;i<n;i++)for(let n=0;n<s;n++){const a=m[n][i],r=m[n+1][i],o=m[n+1][i+1],l=m[n][i+1];(t>0||0!==n)&&(h.push(a,r,l),v+=3),(e>0||n!==s-1)&&(h.push(r,o,l),v+=3)}l.addGroup(f,v,0),f+=v}(),!1===a&&(t>0&&y(!0),e>0&&y(!1)),this.setIndex(h),this.setAttribute("position",new Kn(c,3)),this.setAttribute("normal",new Kn(u,3)),this.setAttribute("uv",new Kn(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Fr(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Ur extends Fr{constructor(t=1,e=1,i=32,n=1,s=!1,a=0,r=2*Math.PI){super(0,t,e,i,n,s,a,r),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:i,heightSegments:n,openEnded:s,thetaStart:a,thetaLength:r}}static fromJSON(t){return new Ur(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Nr extends os{constructor(t=[],e=[],i=1,n=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:i,detail:n};const s=[],a=[];function r(t,e,i,n){const s=n+1,a=[];for(let n=0;n<=s;n++){a[n]=[];const r=t.clone().lerp(i,n/s),o=e.clone().lerp(i,n/s),l=s-n;for(let t=0;t<=l;t++)a[n][t]=0===t&&n===s?r:r.clone().lerp(o,t/l)}for(let t=0;t<s;t++)for(let e=0;e<2*(s-t)-1;e++){const i=Math.floor(e/2);e%2==0?(o(a[t][i+1]),o(a[t+1][i]),o(a[t][i])):(o(a[t][i+1]),o(a[t+1][i+1]),o(a[t+1][i]))}}function o(t){s.push(t.x,t.y,t.z)}function l(e,i){const n=3*e;i.x=t[n+0],i.y=t[n+1],i.z=t[n+2]}function h(t,e,i,n){n<0&&1===t.x&&(a[e]=t.x-1),0===i.x&&0===i.z&&(a[e]=n/2/Math.PI+.5)}function c(t){return Math.atan2(t.z,-t.x)}function u(t){return Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))}!function(t){const i=new qe,n=new qe,s=new qe;for(let a=0;a<e.length;a+=3)l(e[a+0],i),l(e[a+1],n),l(e[a+2],s),r(i,n,s,t)}(n),function(t){const e=new qe;for(let i=0;i<s.length;i+=3)e.x=s[i+0],e.y=s[i+1],e.z=s[i+2],e.normalize().multiplyScalar(t),s[i+0]=e.x,s[i+1]=e.y,s[i+2]=e.z}(i),function(){const t=new qe;for(let e=0;e<s.length;e+=3){t.x=s[e+0],t.y=s[e+1],t.z=s[e+2];const i=c(t)/2/Math.PI+.5,n=u(t)/Math.PI+.5;a.push(i,1-n)}(function(){const t=new qe,e=new qe,i=new qe,n=new qe,r=new je,o=new je,l=new je;for(let u=0,d=0;u<s.length;u+=9,d+=6){t.set(s[u+0],s[u+1],s[u+2]),e.set(s[u+3],s[u+4],s[u+5]),i.set(s[u+6],s[u+7],s[u+8]),r.set(a[d+0],a[d+1]),o.set(a[d+2],a[d+3]),l.set(a[d+4],a[d+5]),n.copy(t).add(e).add(i).divideScalar(3);const p=c(n);h(r,d+0,t,p),h(o,d+2,e,p),h(l,d+4,i,p)}})(),function(){for(let t=0;t<a.length;t+=6){const e=a[t+0],i=a[t+2],n=a[t+4],s=Math.max(e,i,n),r=Math.min(e,i,n);s>.9&&r<.1&&(e<.2&&(a[t+0]+=1),i<.2&&(a[t+2]+=1),n<.2&&(a[t+4]+=1))}}()}(),this.setAttribute("position",new Kn(s,3)),this.setAttribute("normal",new Kn(s.slice(),3)),this.setAttribute("uv",new Kn(a,2)),0===n?this.computeVertexNormals():this.normalizeNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Nr(t.vertices,t.indices,t.radius,t.details)}}class Gr extends Nr{constructor(t=1,e=0){const i=(1+Math.sqrt(5))/2,n=1/i;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-n,-i,0,-n,i,0,n,-i,0,n,i,-n,-i,0,-n,i,0,n,-i,0,n,i,0,-i,0,-n,i,0,-n,-i,0,n,i,0,n],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Gr(t.radius,t.detail)}}const Vr=new qe,Hr=new qe,Wr=new qe,jr=new In;class Xr extends os{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const i=4,n=Math.pow(10,i),s=Math.cos(Oe*e),a=t.getIndex(),r=t.getAttribute("position"),o=a?a.count:r.count,l=[0,0,0],h=["a","b","c"],c=new Array(3),u={},d=[];for(let t=0;t<o;t+=3){a?(l[0]=a.getX(t),l[1]=a.getX(t+1),l[2]=a.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:i,c:o}=jr;if(e.fromBufferAttribute(r,l[0]),i.fromBufferAttribute(r,l[1]),o.fromBufferAttribute(r,l[2]),jr.getNormal(Wr),c[0]=`${Math.round(e.x*n)},${Math.round(e.y*n)},${Math.round(e.z*n)}`,c[1]=`${Math.round(i.x*n)},${Math.round(i.y*n)},${Math.round(i.z*n)}`,c[2]=`${Math.round(o.x*n)},${Math.round(o.y*n)},${Math.round(o.z*n)}`,c[0]!==c[1]&&c[1]!==c[2]&&c[2]!==c[0])for(let t=0;t<3;t++){const e=(t+1)%3,i=c[t],n=c[e],a=jr[h[t]],r=jr[h[e]],o=`${i}_${n}`,p=`${n}_${i}`;p in u&&u[p]?(Wr.dot(u[p].normal)<=s&&(d.push(a.x,a.y,a.z),d.push(r.x,r.y,r.z)),u[p]=null):o in u||(u[o]={index0:l[t],index1:l[e],normal:Wr.clone()})}}for(const t in u)if(u[t]){const{index0:e,index1:i}=u[t];Vr.fromBufferAttribute(r,e),Hr.fromBufferAttribute(r,i),d.push(Vr.x,Vr.y,Vr.z),d.push(Hr.x,Hr.y,Hr.z)}this.setAttribute("position",new Kn(d,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class qr{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){De("Curve: .getPoint() not implemented.")}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,n=this.getPoint(0),s=0;e.push(0);for(let a=1;a<=t;a++)i=this.getPoint(a/t),s+=i.distanceTo(n),e.push(s),n=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e=null){const i=this.getLengths();let n=0;const s=i.length;let a;a=e||t*i[s-1];let r,o=0,l=s-1;for(;o<=l;)if(n=Math.floor(o+(l-o)/2),r=i[n]-a,r<0)o=n+1;else{if(!(r>0)){l=n;break}l=n-1}if(n=l,i[n]===a)return n/(s-1);const h=i[n];return(n+(a-h)/(i[n+1]-h))/(s-1)}getTangent(t,e){const i=1e-4;let n=t-i,s=t+i;n<0&&(n=0),s>1&&(s=1);const a=this.getPoint(n),r=this.getPoint(s),o=e||(a.isVector2?new je:new qe);return o.copy(r).sub(a).normalize(),o}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e=!1){const i=new qe,n=[],s=[],a=[],r=new qe,o=new Wi;for(let e=0;e<=t;e++){const i=e/t;n[e]=this.getTangentAt(i,new qe)}s[0]=new qe,a[0]=new qe;let l=Number.MAX_VALUE;const h=Math.abs(n[0].x),c=Math.abs(n[0].y),u=Math.abs(n[0].z);h<=l&&(l=h,i.set(1,0,0)),c<=l&&(l=c,i.set(0,1,0)),u<=l&&i.set(0,0,1),r.crossVectors(n[0],i).normalize(),s[0].crossVectors(n[0],r),a[0].crossVectors(n[0],s[0]);for(let e=1;e<=t;e++){if(s[e]=s[e-1].clone(),a[e]=a[e-1].clone(),r.crossVectors(n[e-1],n[e]),r.length()>Number.EPSILON){r.normalize();const t=Math.acos(Ue(n[e-1].dot(n[e]),-1,1));s[e].applyMatrix4(o.makeRotationAxis(r,t))}a[e].crossVectors(n[e],s[e])}if(!0===e){let e=Math.acos(Ue(s[0].dot(s[t]),-1,1));e/=t,n[0].dot(r.crossVectors(s[0],s[t]))>0&&(e=-e);for(let i=1;i<=t;i++)s[i].applyMatrix4(o.makeRotationAxis(n[i],e*i)),a[i].crossVectors(n[i],s[i])}return{tangents:n,normals:s,binormals:a}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Yr extends qr{constructor(t=0,e=0,i=1,n=1,s=0,a=2*Math.PI,r=!1,o=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=i,this.yRadius=n,this.aStartAngle=s,this.aEndAngle=a,this.aClockwise=r,this.aRotation=o}getPoint(t,e=new je){const i=e,n=2*Math.PI;let s=this.aEndAngle-this.aStartAngle;const a=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=n;for(;s>n;)s-=n;s<Number.EPSILON&&(s=a?0:n),!0!==this.aClockwise||a||(s===n?s=-n:s-=n);const r=this.aStartAngle+t*s;let o=this.aX+this.xRadius*Math.cos(r),l=this.aY+this.yRadius*Math.sin(r);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),i=o-this.aX,n=l-this.aY;o=i*t-n*e+this.aX,l=i*e+n*t+this.aY}return i.set(o,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class $r extends Yr{constructor(t,e,i,n,s,a){super(t,e,i,i,n,s,a),this.isArcCurve=!0,this.type="ArcCurve"}}function Zr(){let t=0,e=0,i=0,n=0;function s(s,a,r,o){t=s,e=r,i=-3*s+3*a-2*r-o,n=2*s-2*a+r+o}return{initCatmullRom:function(t,e,i,n,a){s(e,i,a*(i-t),a*(n-e))},initNonuniformCatmullRom:function(t,e,i,n,a,r,o){let l=(e-t)/a-(i-t)/(a+r)+(i-e)/r,h=(i-e)/r-(n-e)/(r+o)+(n-i)/o;l*=r,h*=r,s(e,i,l,h)},calc:function(s){const a=s*s;return t+e*s+i*a+n*(a*s)}}}const Jr=new qe,Qr=new Zr,Kr=new Zr,to=new Zr;class eo extends qr{constructor(t=[],e=!1,i="centripetal",n=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=i,this.tension=n}getPoint(t,e=new qe){const i=e,n=this.points,s=n.length,a=(s-(this.closed?0:1))*t;let r,o,l=Math.floor(a),h=a-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/s)+1)*s:0===h&&l===s-1&&(l=s-2,h=1),this.closed||l>0?r=n[(l-1)%s]:(Jr.subVectors(n[0],n[1]).add(n[0]),r=Jr);const c=n[l%s],u=n[(l+1)%s];if(this.closed||l+2<s?o=n[(l+2)%s]:(Jr.subVectors(n[s-1],n[s-2]).add(n[s-1]),o=Jr),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(r.distanceToSquared(c),t),i=Math.pow(c.distanceToSquared(u),t),n=Math.pow(u.distanceToSquared(o),t);i<1e-4&&(i=1),e<1e-4&&(e=i),n<1e-4&&(n=i),Qr.initNonuniformCatmullRom(r.x,c.x,u.x,o.x,e,i,n),Kr.initNonuniformCatmullRom(r.y,c.y,u.y,o.y,e,i,n),to.initNonuniformCatmullRom(r.z,c.z,u.z,o.z,e,i,n)}else"catmullrom"===this.curveType&&(Qr.initCatmullRom(r.x,c.x,u.x,o.x,this.tension),Kr.initCatmullRom(r.y,c.y,u.y,o.y,this.tension),to.initCatmullRom(r.z,c.z,u.z,o.z,this.tension));return i.set(Qr.calc(h),Kr.calc(h),to.calc(h)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push(i.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const i=this.points[e];t.points.push(i.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push((new qe).fromArray(i))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function io(t,e,i,n,s){const a=.5*(n-e),r=.5*(s-i),o=t*t;return(2*i-2*n+a+r)*(t*o)+(-3*i+3*n-2*a-r)*o+a*t+i}function no(t,e,i,n){return function(t,e){const i=1-t;return i*i*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,i)+function(t,e){return t*t*e}(t,n)}function so(t,e,i,n,s){return function(t,e){const i=1-t;return i*i*i*e}(t,e)+function(t,e){const i=1-t;return 3*i*i*t*e}(t,i)+function(t,e){return 3*(1-t)*t*t*e}(t,n)+function(t,e){return t*t*t*e}(t,s)}class ao extends qr{constructor(t=new je,e=new je,i=new je,n=new je){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=i,this.v3=n}getPoint(t,e=new je){const i=e,n=this.v0,s=this.v1,a=this.v2,r=this.v3;return i.set(so(t,n.x,s.x,a.x,r.x),so(t,n.y,s.y,a.y,r.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class ro extends qr{constructor(t=new qe,e=new qe,i=new qe,n=new qe){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=i,this.v3=n}getPoint(t,e=new qe){const i=e,n=this.v0,s=this.v1,a=this.v2,r=this.v3;return i.set(so(t,n.x,s.x,a.x,r.x),so(t,n.y,s.y,a.y,r.y),so(t,n.z,s.z,a.z,r.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class oo extends qr{constructor(t=new je,e=new je){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new je){const i=e;return 1===t?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new je){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class lo extends qr{constructor(t=new qe,e=new qe){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new qe){const i=e;return 1===t?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new qe){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class ho extends qr{constructor(t=new je,e=new je,i=new je){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new je){const i=e,n=this.v0,s=this.v1,a=this.v2;return i.set(no(t,n.x,s.x,a.x),no(t,n.y,s.y,a.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class co extends qr{constructor(t=new qe,e=new qe,i=new qe){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new qe){const i=e,n=this.v0,s=this.v1,a=this.v2;return i.set(no(t,n.x,s.x,a.x),no(t,n.y,s.y,a.y),no(t,n.z,s.z,a.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class uo extends qr{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new je){const i=e,n=this.points,s=(n.length-1)*t,a=Math.floor(s),r=s-a,o=n[0===a?a:a-1],l=n[a],h=n[a>n.length-2?n.length-1:a+1],c=n[a>n.length-3?n.length-1:a+2];return i.set(io(r,o.x,l.x,h.x,c.x),io(r,o.y,l.y,h.y,c.y)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const i=this.points[e];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const i=t.points[e];this.points.push((new je).fromArray(i))}return this}}var po=Object.freeze({__proto__:null,ArcCurve:$r,CatmullRomCurve3:eo,CubicBezierCurve:ao,CubicBezierCurve3:ro,EllipseCurve:Yr,LineCurve:oo,LineCurve3:lo,QuadraticBezierCurve:ho,QuadraticBezierCurve3:co,SplineCurve:uo});class mo extends qr{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){const i=!0===t.isVector2?"LineCurve":"LineCurve3";this.curves.push(new po[i](e,t))}return this}getPoint(t,e){const i=t*this.getLength(),n=this.getCurveLengths();let s=0;for(;s<n.length;){if(n[s]>=i){const t=n[s]-i,a=this.curves[s],r=a.getLength(),o=0===r?0:1-t/r;return a.getPointAt(o,e)}s++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let i=0,n=this.curves.length;i<n;i++)e+=this.curves[i].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let i;for(let n=0,s=this.curves;n<s.length;n++){const a=s[n],r=a.isEllipseCurve?2*t:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?t*a.points.length:t,o=a.getPoints(r);for(let t=0;t<o.length;t++){const n=o[t];i&&i.equals(n)||(e.push(n),i=n)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const i=t.curves[e];this.curves.push(i.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,i=this.curves.length;e<i;e++){const i=this.curves[e];t.curves.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const i=t.curves[e];this.curves.push((new po[i.type]).fromJSON(i))}return this}}class go extends mo{constructor(t){super(),this.type="Path",this.currentPoint=new je,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const i=new oo(this.currentPoint.clone(),new je(t,e));return this.curves.push(i),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,i,n){const s=new ho(this.currentPoint.clone(),new je(t,e),new je(i,n));return this.curves.push(s),this.currentPoint.set(i,n),this}bezierCurveTo(t,e,i,n,s,a){const r=new ao(this.currentPoint.clone(),new je(t,e),new je(i,n),new je(s,a));return this.curves.push(r),this.currentPoint.set(s,a),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),i=new uo(e);return this.curves.push(i),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,i,n,s,a){const r=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+r,e+o,i,n,s,a),this}absarc(t,e,i,n,s,a){return this.absellipse(t,e,i,i,n,s,a),this}ellipse(t,e,i,n,s,a,r,o){const l=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+l,e+h,i,n,s,a,r,o),this}absellipse(t,e,i,n,s,a,r,o){const l=new Yr(t,e,i,n,s,a,r,o);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const h=l.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class fo extends go{constructor(t){super(t),this.uuid=Fe(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let i=0,n=this.holes.length;i<n;i++)e[i]=this.holes[i].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const i=t.holes[e];this.holes.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,i=this.holes.length;e<i;e++){const i=this.holes[e];t.holes.push(i.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const i=t.holes[e];this.holes.push((new go).fromJSON(i))}return this}}function yo(t,e,i,n,s){let a;if(s===function(t,e,i,n){let s=0;for(let a=e,r=i-n;a<i;a+=n)s+=(t[r]-t[a])*(t[a+1]+t[r+1]),r=a;return s}(t,e,i,n)>0)for(let s=e;s<i;s+=n)a=Uo(s/n|0,t[s],t[s+1],a);else for(let s=i-n;s>=e;s-=n)a=Uo(s/n|0,t[s],t[s+1],a);return a&&Bo(a,a.next)&&(No(a),a=a.next),a}function vo(t,e){if(!t)return t;e||(e=t);let i,n=t;do{if(i=!1,n.steiner||!Bo(n,n.next)&&0!==Io(n.prev,n,n.next))n=n.next;else{if(No(n),n=e=n.prev,n===n.next)break;i=!0}}while(i||n!==e);return e}function bo(t,e,i,n,s,a,r){if(!t)return;!r&&a&&function(t,e,i,n){let s=t;do{0===s.z&&(s.z=Eo(s.x,s.y,e,i,n)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next}while(s!==t);s.prevZ.nextZ=null,s.prevZ=null,function(t){let e,i=1;do{let n,s=t;t=null;let a=null;for(e=0;s;){e++;let r=s,o=0;for(let t=0;t<i&&(o++,r=r.nextZ,r);t++);let l=i;for(;o>0||l>0&&r;)0!==o&&(0===l||!r||s.z<=r.z)?(n=s,s=s.nextZ,o--):(n=r,r=r.nextZ,l--),a?a.nextZ=n:t=n,n.prevZ=a,a=n;s=r}a.nextZ=null,i*=2}while(e>1)}(s)}(t,n,s,a);let o=t;for(;t.prev!==t.next;){const l=t.prev,h=t.next;if(a?_o(t,n,s,a):Mo(t))e.push(l.i,t.i,h.i),No(t),t=h.next,o=h.next;else if((t=h)===o){r?1===r?bo(t=xo(vo(t),e),e,i,n,s,a,2):2===r&&wo(t,e,i,n,s,a):bo(vo(t),e,i,n,s,a,1);break}}}function Mo(t){const e=t.prev,i=t,n=t.next;if(Io(e,i,n)>=0)return!1;const s=e.x,a=i.x,r=n.x,o=e.y,l=i.y,h=n.y,c=Math.min(s,a,r),u=Math.min(o,l,h),d=Math.max(s,a,r),p=Math.max(o,l,h);let m=n.next;for(;m!==e;){if(m.x>=c&&m.x<=d&&m.y>=u&&m.y<=p&&Do(s,o,a,l,r,h,m.x,m.y)&&Io(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function _o(t,e,i,n){const s=t.prev,a=t,r=t.next;if(Io(s,a,r)>=0)return!1;const o=s.x,l=a.x,h=r.x,c=s.y,u=a.y,d=r.y,p=Math.min(o,l,h),m=Math.min(c,u,d),g=Math.max(o,l,h),f=Math.max(c,u,d),y=Eo(p,m,e,i,n),v=Eo(g,f,e,i,n);let b=t.prevZ,M=t.nextZ;for(;b&&b.z>=y&&M&&M.z<=v;){if(b.x>=p&&b.x<=g&&b.y>=m&&b.y<=f&&b!==s&&b!==r&&Do(o,c,l,u,h,d,b.x,b.y)&&Io(b.prev,b,b.next)>=0)return!1;if(b=b.prevZ,M.x>=p&&M.x<=g&&M.y>=m&&M.y<=f&&M!==s&&M!==r&&Do(o,c,l,u,h,d,M.x,M.y)&&Io(M.prev,M,M.next)>=0)return!1;M=M.nextZ}for(;b&&b.z>=y;){if(b.x>=p&&b.x<=g&&b.y>=m&&b.y<=f&&b!==s&&b!==r&&Do(o,c,l,u,h,d,b.x,b.y)&&Io(b.prev,b,b.next)>=0)return!1;b=b.prevZ}for(;M&&M.z<=v;){if(M.x>=p&&M.x<=g&&M.y>=m&&M.y<=f&&M!==s&&M!==r&&Do(o,c,l,u,h,d,M.x,M.y)&&Io(M.prev,M,M.next)>=0)return!1;M=M.nextZ}return!0}function xo(t,e){let i=t;do{const n=i.prev,s=i.next.next;!Bo(n,s)&&Lo(n,i,i.next,s)&&zo(n,s)&&zo(s,n)&&(e.push(n.i,i.i,s.i),No(i),No(i.next),i=t=s),i=i.next}while(i!==t);return vo(i)}function wo(t,e,i,n,s,a){let r=t;do{let t=r.next.next;for(;t!==r.prev;){if(r.i!==t.i&&Ro(r,t)){let o=Fo(r,t);return r=vo(r,r.next),o=vo(o,o.next),bo(r,e,i,n,s,a,0),void bo(o,e,i,n,s,a,0)}t=t.next}r=r.next}while(r!==t)}function So(t,e){let i=t.x-e.x;return 0===i&&(i=t.y-e.y,0===i)&&(i=(t.next.y-t.y)/(t.next.x-t.x)-(e.next.y-e.y)/(e.next.x-e.x)),i}function To(t,e){const i=function(t,e){let i=e;const n=t.x,s=t.y;let a,r=-1/0;if(Bo(t,i))return i;do{if(Bo(t,i.next))return i.next;if(s<=i.y&&s>=i.next.y&&i.next.y!==i.y){const t=i.x+(s-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(t<=n&&t>r&&(r=t,a=i.x<i.next.x?i:i.next,t===n))return a}i=i.next}while(i!==e);if(!a)return null;const o=a,l=a.x,h=a.y;let c=1/0;i=a;do{if(n>=i.x&&i.x>=l&&n!==i.x&&Po(s<h?n:r,s,l,h,s<h?r:n,s,i.x,i.y)){const e=Math.abs(s-i.y)/(n-i.x);zo(i,t)&&(e<c||e===c&&(i.x>a.x||i.x===a.x&&Co(a,i)))&&(a=i,c=e)}i=i.next}while(i!==o);return a}(t,e);if(!i)return e;const n=Fo(i,t);return vo(n,n.next),vo(i,i.next)}function Co(t,e){return Io(t.prev,t,e.prev)<0&&Io(e.next,t,t.next)<0}function Eo(t,e,i,n,s){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-i)*s|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*s|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Ao(t){let e=t,i=t;do{(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next}while(e!==t);return i}function Po(t,e,i,n,s,a,r,o){return(s-r)*(e-o)>=(t-r)*(a-o)&&(t-r)*(n-o)>=(i-r)*(e-o)&&(i-r)*(a-o)>=(s-r)*(n-o)}function Do(t,e,i,n,s,a,r,o){return!(t===r&&e===o)&&Po(t,e,i,n,s,a,r,o)}function Ro(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let i=t;do{if(i.i!==t.i&&i.next.i!==t.i&&i.i!==e.i&&i.next.i!==e.i&&Lo(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}(t,e)&&(zo(t,e)&&zo(e,t)&&function(t,e){let i=t,n=!1;const s=(t.x+e.x)/2,a=(t.y+e.y)/2;do{i.y>a!=i.next.y>a&&i.next.y!==i.y&&s<(i.next.x-i.x)*(a-i.y)/(i.next.y-i.y)+i.x&&(n=!n),i=i.next}while(i!==t);return n}(t,e)&&(Io(t.prev,t,e.prev)||Io(t,e.prev,e))||Bo(t,e)&&Io(t.prev,t,t.next)>0&&Io(e.prev,e,e.next)>0)}function Io(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function Bo(t,e){return t.x===e.x&&t.y===e.y}function Lo(t,e,i,n){const s=Oo(Io(t,e,i)),a=Oo(Io(t,e,n)),r=Oo(Io(i,n,t)),o=Oo(Io(i,n,e));return s!==a&&r!==o||!(0!==s||!ko(t,i,e))||!(0!==a||!ko(t,n,e))||!(0!==r||!ko(i,t,n))||!(0!==o||!ko(i,e,n))}function ko(t,e,i){return e.x<=Math.max(t.x,i.x)&&e.x>=Math.min(t.x,i.x)&&e.y<=Math.max(t.y,i.y)&&e.y>=Math.min(t.y,i.y)}function Oo(t){return t>0?1:t<0?-1:0}function zo(t,e){return Io(t.prev,t,t.next)<0?Io(t,e,t.next)>=0&&Io(t,t.prev,e)>=0:Io(t,e,t.prev)<0||Io(t,t.next,e)<0}function Fo(t,e){const i=Go(t.i,t.x,t.y),n=Go(e.i,e.x,e.y),s=t.next,a=e.prev;return t.next=e,e.prev=t,i.next=s,s.prev=i,n.next=i,i.prev=n,a.next=n,n.prev=a,n}function Uo(t,e,i,n){const s=Go(t,e,i);return n?(s.next=n.next,s.prev=n,n.next.prev=s,n.next=s):(s.prev=s,s.next=s),s}function No(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Go(t,e,i){return{i:t,x:e,y:i,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}class Vo{static triangulate(t,e,i=2){return function(t,e,i=2){const n=e&&e.length,s=n?e[0]*i:t.length;let a=yo(t,0,s,i,!0);const r=[];if(!a||a.next===a.prev)return r;let o,l,h;if(n&&(a=function(t,e,i,n){const s=[];for(let i=0,a=e.length;i<a;i++){const r=yo(t,e[i]*n,i<a-1?e[i+1]*n:t.length,n,!1);r===r.next&&(r.steiner=!0),s.push(Ao(r))}s.sort(So);for(let t=0;t<s.length;t++)i=To(s[t],i);return i}(t,e,a,i)),t.length>80*i){o=t[0],l=t[1];let e=o,n=l;for(let a=i;a<s;a+=i){const i=t[a],s=t[a+1];i<o&&(o=i),s<l&&(l=s),i>e&&(e=i),s>n&&(n=s)}h=Math.max(e-o,n-l),h=0!==h?32767/h:0}return bo(a,r,i,o,l,h,0),r}(t,e,i)}}class Ho{static area(t){const e=t.length;let i=0;for(let n=e-1,s=0;s<e;n=s++)i+=t[n].x*t[s].y-t[s].x*t[n].y;return.5*i}static isClockWise(t){return Ho.area(t)<0}static triangulateShape(t,e){const i=[],n=[],s=[];Wo(t),jo(i,t);let a=t.length;e.forEach(Wo);for(let t=0;t<e.length;t++)n.push(a),a+=e[t].length,jo(i,e[t]);const r=Vo.triangulate(i,n);for(let t=0;t<r.length;t+=3)s.push(r.slice(t,t+3));return s}}function Wo(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function jo(t,e){for(let i=0;i<e.length;i++)t.push(e[i].x),t.push(e[i].y)}class Xo extends os{constructor(t=new fo([new je(.5,.5),new je(-.5,.5),new je(-.5,-.5),new je(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const i=this,n=[],s=[];for(let e=0,i=t.length;e<i;e++)a(t[e]);function a(t){const a=[],r=void 0!==e.curveSegments?e.curveSegments:12,o=void 0!==e.steps?e.steps:1,l=void 0!==e.depth?e.depth:1;let h=void 0===e.bevelEnabled||e.bevelEnabled,c=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:c-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const m=e.extrudePath,g=void 0!==e.UVGenerator?e.UVGenerator:qo;let f,y,v,b,M,_=!1;m&&(f=m.getSpacedPoints(o),_=!0,h=!1,y=m.computeFrenetFrames(o,!1),v=new qe,b=new qe,M=new qe),h||(p=0,c=0,u=0,d=0);const x=t.extractPoints(r);let w=x.shape;const S=x.holes;if(!Ho.isClockWise(w)){w=w.reverse();for(let t=0,e=S.length;t<e;t++){const e=S[t];Ho.isClockWise(e)&&(S[t]=e.reverse())}}function T(t){const e=1e-10*1e-10;let i=t[0];for(let n=1;n<=t.length;n++){const s=n%t.length,a=t[s],r=a.x-i.x,o=a.y-i.y,l=r*r+o*o,h=Math.max(Math.abs(a.x),Math.abs(a.y),Math.abs(i.x),Math.abs(i.y));l<=e*h*h?(t.splice(s,1),n--):i=a}}T(w),S.forEach(T);const C=S.length,E=w;for(let t=0;t<C;t++){const e=S[t];w=w.concat(e)}function A(t,e,i){return e||Re("ExtrudeGeometry: vec does not exist"),t.clone().addScaledVector(e,i)}const P=w.length;function D(t,e,i){let n,s,a;const r=t.x-e.x,o=t.y-e.y,l=i.x-t.x,h=i.y-t.y,c=r*r+o*o,u=r*h-o*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(c),d=Math.sqrt(l*l+h*h),p=e.x-o/u,m=e.y+r/u,g=((i.x-h/d-p)*h-(i.y+l/d-m)*l)/(r*h-o*l);n=p+r*g-t.x,s=m+o*g-t.y;const f=n*n+s*s;if(f<=2)return new je(n,s);a=Math.sqrt(f/2)}else{let t=!1;r>Number.EPSILON?l>Number.EPSILON&&(t=!0):r<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(h)&&(t=!0),t?(n=-o,s=r,a=Math.sqrt(c)):(n=r,s=o,a=Math.sqrt(c/2))}return new je(n/a,s/a)}const R=[];for(let t=0,e=E.length,i=e-1,n=t+1;t<e;t++,i++,n++)i===e&&(i=0),n===e&&(n=0),R[t]=D(E[t],E[i],E[n]);const I=[];let B,L,k=R.concat();for(let t=0,e=C;t<e;t++){const e=S[t];B=[];for(let t=0,i=e.length,n=i-1,s=t+1;t<i;t++,n++,s++)n===i&&(n=0),s===i&&(s=0),B[t]=D(e[t],e[n],e[s]);I.push(B),k=k.concat(B)}if(0===p)L=Ho.triangulateShape(E,S);else{const t=[],e=[];for(let i=0;i<p;i++){const n=i/p,s=c*Math.cos(n*Math.PI/2),a=u*Math.sin(n*Math.PI/2)+d;for(let e=0,i=E.length;e<i;e++){const i=A(E[e],R[e],a);U(i.x,i.y,-s),0===n&&t.push(i)}for(let t=0,i=C;t<i;t++){const i=S[t];B=I[t];const r=[];for(let t=0,e=i.length;t<e;t++){const e=A(i[t],B[t],a);U(e.x,e.y,-s),0===n&&r.push(e)}0===n&&e.push(r)}}L=Ho.triangulateShape(t,e)}const O=L.length,z=u+d;for(let t=0;t<P;t++){const e=h?A(w[t],k[t],z):w[t];_?(b.copy(y.normals[0]).multiplyScalar(e.x),v.copy(y.binormals[0]).multiplyScalar(e.y),M.copy(f[0]).add(b).add(v),U(M.x,M.y,M.z)):U(e.x,e.y,0)}for(let t=1;t<=o;t++)for(let e=0;e<P;e++){const i=h?A(w[e],k[e],z):w[e];_?(b.copy(y.normals[t]).multiplyScalar(i.x),v.copy(y.binormals[t]).multiplyScalar(i.y),M.copy(f[t]).add(b).add(v),U(M.x,M.y,M.z)):U(i.x,i.y,l/o*t)}for(let t=p-1;t>=0;t--){const e=t/p,i=c*Math.cos(e*Math.PI/2),n=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=E.length;t<e;t++){const e=A(E[t],R[t],n);U(e.x,e.y,l+i)}for(let t=0,e=S.length;t<e;t++){const e=S[t];B=I[t];for(let t=0,s=e.length;t<s;t++){const s=A(e[t],B[t],n);_?U(s.x,s.y+f[o-1].y,f[o-1].x+i):U(s.x,s.y,l+i)}}}function F(t,e){let i=t.length;for(;--i>=0;){const n=i;let s=i-1;s<0&&(s=t.length-1);for(let t=0,i=o+2*p;t<i;t++){const i=P*t,a=P*(t+1);G(e+n+i,e+s+i,e+s+a,e+n+a)}}}function U(t,e,i){a.push(t),a.push(e),a.push(i)}function N(t,e,s){V(t),V(e),V(s);const a=n.length/3,r=g.generateTopUV(i,n,a-3,a-2,a-1);H(r[0]),H(r[1]),H(r[2])}function G(t,e,s,a){V(t),V(e),V(a),V(e),V(s),V(a);const r=n.length/3,o=g.generateSideWallUV(i,n,r-6,r-3,r-2,r-1);H(o[0]),H(o[1]),H(o[3]),H(o[1]),H(o[2]),H(o[3])}function V(t){n.push(a[3*t+0]),n.push(a[3*t+1]),n.push(a[3*t+2])}function H(t){s.push(t.x),s.push(t.y)}!function(){const t=n.length/3;if(h){let t=0,e=P*t;for(let t=0;t<O;t++){const i=L[t];N(i[2]+e,i[1]+e,i[0]+e)}t=o+2*p,e=P*t;for(let t=0;t<O;t++){const i=L[t];N(i[0]+e,i[1]+e,i[2]+e)}}else{for(let t=0;t<O;t++){const e=L[t];N(e[2],e[1],e[0])}for(let t=0;t<O;t++){const e=L[t];N(e[0]+P*o,e[1]+P*o,e[2]+P*o)}}i.addGroup(t,n.length/3-t,0)}(),function(){const t=n.length/3;let e=0;F(E,e),e+=E.length;for(let t=0,i=S.length;t<i;t++){const i=S[t];F(i,e),e+=i.length}i.addGroup(t,n.length/3-t,1)}()}this.setAttribute("position",new Kn(n,3)),this.setAttribute("uv",new Kn(s,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e,i){if(i.shapes=[],Array.isArray(t))for(let e=0,n=t.length;e<n;e++){const n=t[e];i.shapes.push(n.uuid)}else i.shapes.push(t.uuid);return i.options=Object.assign({},e),void 0!==e.extrudePath&&(i.options.extrudePath=e.extrudePath.toJSON()),i}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const i=[];for(let n=0,s=t.shapes.length;n<s;n++){const s=e[t.shapes[n]];i.push(s)}const n=t.options.extrudePath;return void 0!==n&&(t.options.extrudePath=(new po[n.type]).fromJSON(n)),new Xo(i,t.options)}}const qo={generateTopUV:function(t,e,i,n,s){const a=e[3*i],r=e[3*i+1],o=e[3*n],l=e[3*n+1],h=e[3*s],c=e[3*s+1];return[new je(a,r),new je(o,l),new je(h,c)]},generateSideWallUV:function(t,e,i,n,s,a){const r=e[3*i],o=e[3*i+1],l=e[3*i+2],h=e[3*n],c=e[3*n+1],u=e[3*n+2],d=e[3*s],p=e[3*s+1],m=e[3*s+2],g=e[3*a],f=e[3*a+1],y=e[3*a+2];return Math.abs(o-c)<Math.abs(r-h)?[new je(r,1-l),new je(h,1-u),new je(d,1-m),new je(g,1-y)]:[new je(o,1-l),new je(c,1-u),new je(p,1-m),new je(f,1-y)]}};class Yo extends Nr{constructor(t=1,e=0){const i=(1+Math.sqrt(5))/2;super([-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Yo(t.radius,t.detail)}}class $o extends os{constructor(t=[new je(0,-.5),new je(.5,0),new je(0,.5)],e=12,i=0,n=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:i,phiLength:n},e=Math.floor(e),n=Ue(n,0,2*Math.PI);const s=[],a=[],r=[],o=[],l=[],h=1/e,c=new qe,u=new je,d=new qe,p=new qe,m=new qe;let g=0,f=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:g=t[e+1].x-t[e].x,f=t[e+1].y-t[e].y,d.x=1*f,d.y=-g,d.z=0*f,m.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case t.length-1:o.push(m.x,m.y,m.z);break;default:g=t[e+1].x-t[e].x,f=t[e+1].y-t[e].y,d.x=1*f,d.y=-g,d.z=0*f,p.copy(d),d.x+=m.x,d.y+=m.y,d.z+=m.z,d.normalize(),o.push(d.x,d.y,d.z),m.copy(p)}for(let s=0;s<=e;s++){const d=i+s*h*n,p=Math.sin(d),m=Math.cos(d);for(let i=0;i<=t.length-1;i++){c.x=t[i].x*p,c.y=t[i].y,c.z=t[i].x*m,a.push(c.x,c.y,c.z),u.x=s/e,u.y=i/(t.length-1),r.push(u.x,u.y);const n=o[3*i+0]*p,h=o[3*i+1],d=o[3*i+0]*m;l.push(n,h,d)}}for(let i=0;i<e;i++)for(let e=0;e<t.length-1;e++){const n=e+i*t.length,a=n,r=n+t.length,o=n+t.length+1,l=n+1;s.push(a,r,l),s.push(o,l,r)}this.setIndex(s),this.setAttribute("position",new Kn(a,3)),this.setAttribute("uv",new Kn(r,2)),this.setAttribute("normal",new Kn(l,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new $o(t.points,t.segments,t.phiStart,t.phiLength)}}class Zo extends Nr{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Zo(t.radius,t.detail)}}class Jo extends os{constructor(t=1,e=1,i=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:n};const s=t/2,a=e/2,r=Math.floor(i),o=Math.floor(n),l=r+1,h=o+1,c=t/r,u=e/o,d=[],p=[],m=[],g=[];for(let t=0;t<h;t++){const e=t*u-a;for(let i=0;i<l;i++){const n=i*c-s;p.push(n,-e,0),m.push(0,0,1),g.push(i/r),g.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<r;e++){const i=e+l*t,n=e+l*(t+1),s=e+1+l*(t+1),a=e+1+l*t;d.push(i,n,a),d.push(n,s,a)}this.setIndex(d),this.setAttribute("position",new Kn(p,3)),this.setAttribute("normal",new Kn(m,3)),this.setAttribute("uv",new Kn(g,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Jo(t.width,t.height,t.widthSegments,t.heightSegments)}}class Qo extends os{constructor(t=.5,e=1,i=32,n=1,s=0,a=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:i,phiSegments:n,thetaStart:s,thetaLength:a},i=Math.max(3,i);const r=[],o=[],l=[],h=[];let c=t;const u=(e-t)/(n=Math.max(1,n)),d=new qe,p=new je;for(let t=0;t<=n;t++){for(let t=0;t<=i;t++){const n=s+t/i*a;d.x=c*Math.cos(n),d.y=c*Math.sin(n),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,h.push(p.x,p.y)}c+=u}for(let t=0;t<n;t++){const e=t*(i+1);for(let t=0;t<i;t++){const n=t+e,s=n,a=n+i+1,o=n+i+2,l=n+1;r.push(s,a,l),r.push(a,o,l)}}this.setIndex(r),this.setAttribute("position",new Kn(o,3)),this.setAttribute("normal",new Kn(l,3)),this.setAttribute("uv",new Kn(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Qo(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class Ko extends os{constructor(t=new fo([new je(0,.5),new je(-.5,-.5),new je(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const i=[],n=[],s=[],a=[];let r=0,o=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(r,o,e),r+=o,o=0;function l(t){const r=n.length/3,l=t.extractPoints(e);let h=l.shape;const c=l.holes;!1===Ho.isClockWise(h)&&(h=h.reverse());for(let t=0,e=c.length;t<e;t++){const e=c[t];!0===Ho.isClockWise(e)&&(c[t]=e.reverse())}const u=Ho.triangulateShape(h,c);for(let t=0,e=c.length;t<e;t++){const e=c[t];h=h.concat(e)}for(let t=0,e=h.length;t<e;t++){const e=h[t];n.push(e.x,e.y,0),s.push(0,0,1),a.push(e.x,e.y)}for(let t=0,e=u.length;t<e;t++){const e=u[t],n=e[0]+r,s=e[1]+r,a=e[2]+r;i.push(n,s,a),o+=3}}this.setIndex(i),this.setAttribute("position",new Kn(n,3)),this.setAttribute("normal",new Kn(s,3)),this.setAttribute("uv",new Kn(a,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let i=0,n=t.length;i<n;i++){const n=t[i];e.shapes.push(n.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const i=[];for(let n=0,s=t.shapes.length;n<s;n++){const s=e[t.shapes[n]];i.push(s)}return new Ko(i,t.curveSegments)}}class tl extends os{constructor(t=1,e=32,i=16,n=0,s=2*Math.PI,a=0,r=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:n,phiLength:s,thetaStart:a,thetaLength:r},e=Math.max(3,Math.floor(e)),i=Math.max(2,Math.floor(i));const o=Math.min(a+r,Math.PI);let l=0;const h=[],c=new qe,u=new qe,d=[],p=[],m=[],g=[];for(let d=0;d<=i;d++){const f=[],y=d/i;let v=0;0===d&&0===a?v=.5/e:d===i&&o===Math.PI&&(v=-.5/e);for(let i=0;i<=e;i++){const o=i/e;c.x=-t*Math.cos(n+o*s)*Math.sin(a+y*r),c.y=t*Math.cos(a+y*r),c.z=t*Math.sin(n+o*s)*Math.sin(a+y*r),p.push(c.x,c.y,c.z),u.copy(c).normalize(),m.push(u.x,u.y,u.z),g.push(o+v,1-y),f.push(l++)}h.push(f)}for(let t=0;t<i;t++)for(let n=0;n<e;n++){const e=h[t][n+1],s=h[t][n],r=h[t+1][n],l=h[t+1][n+1];(0!==t||a>0)&&d.push(e,s,l),(t!==i-1||o<Math.PI)&&d.push(s,r,l)}this.setIndex(d),this.setAttribute("position",new Kn(p,3)),this.setAttribute("normal",new Kn(m,3)),this.setAttribute("uv",new Kn(g,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new tl(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class el extends Nr{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new el(t.radius,t.detail)}}class il extends os{constructor(t=1,e=.4,i=12,n=48,s=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:i,tubularSegments:n,arc:s},i=Math.floor(i),n=Math.floor(n);const a=[],r=[],o=[],l=[],h=new qe,c=new qe,u=new qe;for(let a=0;a<=i;a++)for(let d=0;d<=n;d++){const p=d/n*s,m=a/i*Math.PI*2;c.x=(t+e*Math.cos(m))*Math.cos(p),c.y=(t+e*Math.cos(m))*Math.sin(p),c.z=e*Math.sin(m),r.push(c.x,c.y,c.z),h.x=t*Math.cos(p),h.y=t*Math.sin(p),u.subVectors(c,h).normalize(),o.push(u.x,u.y,u.z),l.push(d/n),l.push(a/i)}for(let t=1;t<=i;t++)for(let e=1;e<=n;e++){const i=(n+1)*t+e-1,s=(n+1)*(t-1)+e-1,r=(n+1)*(t-1)+e,o=(n+1)*t+e;a.push(i,s,o),a.push(s,r,o)}this.setIndex(a),this.setAttribute("position",new Kn(r,3)),this.setAttribute("normal",new Kn(o,3)),this.setAttribute("uv",new Kn(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new il(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class nl extends os{constructor(t=1,e=.4,i=64,n=8,s=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:i,radialSegments:n,p:s,q:a},i=Math.floor(i),n=Math.floor(n);const r=[],o=[],l=[],h=[],c=new qe,u=new qe,d=new qe,p=new qe,m=new qe,g=new qe,f=new qe;for(let r=0;r<=i;++r){const v=r/i*s*Math.PI*2;y(v,s,a,t,d),y(v+.01,s,a,t,p),g.subVectors(p,d),f.addVectors(p,d),m.crossVectors(g,f),f.crossVectors(m,g),m.normalize(),f.normalize();for(let t=0;t<=n;++t){const s=t/n*Math.PI*2,a=-e*Math.cos(s),p=e*Math.sin(s);c.x=d.x+(a*f.x+p*m.x),c.y=d.y+(a*f.y+p*m.y),c.z=d.z+(a*f.z+p*m.z),o.push(c.x,c.y,c.z),u.subVectors(c,d).normalize(),l.push(u.x,u.y,u.z),h.push(r/i),h.push(t/n)}}for(let t=1;t<=i;t++)for(let e=1;e<=n;e++){const i=(n+1)*(t-1)+(e-1),s=(n+1)*t+(e-1),a=(n+1)*t+e,o=(n+1)*(t-1)+e;r.push(i,s,o),r.push(s,a,o)}function y(t,e,i,n,s){const a=Math.cos(t),r=Math.sin(t),o=i/e*t,l=Math.cos(o);s.x=n*(2+l)*.5*a,s.y=n*(2+l)*r*.5,s.z=n*Math.sin(o)*.5}this.setIndex(r),this.setAttribute("position",new Kn(o,3)),this.setAttribute("normal",new Kn(l,3)),this.setAttribute("uv",new Kn(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new nl(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class sl extends os{constructor(t=new co(new qe(-1,-1,0),new qe(-1,1,0),new qe(1,1,0)),e=64,i=1,n=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:i,radialSegments:n,closed:s};const a=t.computeFrenetFrames(e,s);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const r=new qe,o=new qe,l=new je;let h=new qe;const c=[],u=[],d=[],p=[];function m(s){h=t.getPointAt(s/e,h);const l=a.normals[s],d=a.binormals[s];for(let t=0;t<=n;t++){const e=t/n*Math.PI*2,s=Math.sin(e),a=-Math.cos(e);o.x=a*l.x+s*d.x,o.y=a*l.y+s*d.y,o.z=a*l.z+s*d.z,o.normalize(),u.push(o.x,o.y,o.z),r.x=h.x+i*o.x,r.y=h.y+i*o.y,r.z=h.z+i*o.z,c.push(r.x,r.y,r.z)}}!function(){for(let t=0;t<e;t++)m(t);m(!1===s?e:0),function(){for(let t=0;t<=e;t++)for(let i=0;i<=n;i++)l.x=t/e,l.y=i/n,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=n;e++){const i=(n+1)*(t-1)+(e-1),s=(n+1)*t+(e-1),a=(n+1)*t+e,r=(n+1)*(t-1)+e;p.push(i,s,r),p.push(s,a,r)}}()}(),this.setIndex(p),this.setAttribute("position",new Kn(c,3)),this.setAttribute("normal",new Kn(u,3)),this.setAttribute("uv",new Kn(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new sl((new po[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class al extends os{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],i=new Set,n=new qe,s=new qe;if(null!==t.index){const a=t.attributes.position,r=t.index;let o=t.groups;0===o.length&&(o=[{start:0,count:r.count,materialIndex:0}]);for(let t=0,l=o.length;t<l;++t){const l=o[t],h=l.start;for(let t=h,o=h+l.count;t<o;t+=3)for(let o=0;o<3;o++){const l=r.getX(t+o),h=r.getX(t+(o+1)%3);n.fromBufferAttribute(a,l),s.fromBufferAttribute(a,h),!0===rl(n,s,i)&&(e.push(n.x,n.y,n.z),e.push(s.x,s.y,s.z))}}}else{const a=t.attributes.position;for(let t=0,r=a.count/3;t<r;t++)for(let r=0;r<3;r++){const o=3*t+r,l=3*t+(r+1)%3;n.fromBufferAttribute(a,o),s.fromBufferAttribute(a,l),!0===rl(n,s,i)&&(e.push(n.x,n.y,n.z),e.push(s.x,s.y,s.z))}}this.setAttribute("position",new Kn(e,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function rl(t,e,i){const n=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,s=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==i.has(n)&&!0!==i.has(s)&&(i.add(n),i.add(s),!0)}var ol=Object.freeze({__proto__:null,BoxGeometry:_s,CapsuleGeometry:Or,CircleGeometry:zr,ConeGeometry:Ur,CylinderGeometry:Fr,DodecahedronGeometry:Gr,EdgesGeometry:Xr,ExtrudeGeometry:Xo,IcosahedronGeometry:Yo,LatheGeometry:$o,OctahedronGeometry:Zo,PlaneGeometry:Jo,PolyhedronGeometry:Nr,RingGeometry:Qo,ShapeGeometry:Ko,SphereGeometry:tl,TetrahedronGeometry:el,TorusGeometry:il,TorusKnotGeometry:nl,TubeGeometry:sl,WireframeGeometry:al});class ll extends Nn{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new zn(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class hl extends Cs{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class cl extends Nn{constructor(t){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new zn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new zn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new tn,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class ul extends cl{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new je(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ue(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new zn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new zn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new zn(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class dl extends Nn{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new zn(16777215),this.specular=new zn(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new zn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new tn,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class pl extends Nn{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new zn(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new zn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class ml extends Nn{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class gl extends Nn{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new zn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new zn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new tn,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class fl extends Nn{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class yl extends Nn{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}class vl extends Nn{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new zn(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this.fog=t.fog,this}}class bl extends cr{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function Ml(t,e){return t&&t.constructor!==e?"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t):t}function _l(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function xl(t){const e=t.length,i=new Array(e);for(let t=0;t!==e;++t)i[t]=t;return i.sort(function(e,i){return t[e]-t[i]}),i}function wl(t,e,i){const n=t.length,s=new t.constructor(n);for(let a=0,r=0;r!==n;++a){const n=i[a]*e;for(let i=0;i!==e;++i)s[r++]=t[n+i]}return s}function Sl(t,e,i,n){let s=1,a=t[0];for(;void 0!==a&&void 0===a[n];)a=t[s++];if(void 0===a)return;let r=a[n];if(void 0!==r)if(Array.isArray(r))do{r=a[n],void 0!==r&&(e.push(a.time),i.push(...r)),a=t[s++]}while(void 0!==a);else if(void 0!==r.toArray)do{r=a[n],void 0!==r&&(e.push(a.time),r.toArray(i,i.length)),a=t[s++]}while(void 0!==a);else do{r=a[n],void 0!==r&&(e.push(a.time),i.push(r)),a=t[s++]}while(void 0!==a)}class Tl{constructor(t,e,i,n){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==n?n:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,n=e[i],s=e[i-1];t:{e:{let a;i:{n:if(!(t<n)){for(let a=i+2;;){if(void 0===n){if(t<s)break n;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===a)break;if(s=n,n=e[++i],t<n)break e}a=e.length;break i}if(!(t>=s)){const r=e[1];t<r&&(i=2,s=r);for(let a=i-2;;){if(void 0===s)return this._cachedIndex=0,this.copySampleValue_(0);if(i===a)break;if(n=s,s=e[--i-1],t>=s)break e}a=i,i=0;break i}break t}for(;i<a;){const n=i+a>>>1;t<e[n]?a=n:i=n+1}if(n=e[i],s=e[i-1],void 0===s)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===n)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,s,n)}return this.interpolate_(i,s,t,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,n=this.valueSize,s=t*n;for(let t=0;t!==n;++t)e[t]=i[s+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Cl extends Tl{constructor(t,e,i,n){super(t,e,i,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Kt,endingEnd:Kt}}intervalChanged_(t,e,i){const n=this.parameterPositions;let s=t-2,a=t+1,r=n[s],o=n[a];if(void 0===r)switch(this.getSettings_().endingStart){case te:s=t,r=2*e-i;break;case ee:s=n.length-2,r=e+n[s]-n[s+1];break;default:s=t,r=i}if(void 0===o)switch(this.getSettings_().endingEnd){case te:a=t,o=2*i-e;break;case ee:a=1,o=i+n[1]-n[0];break;default:a=t-1,o=e}const l=.5*(i-e),h=this.valueSize;this._weightPrev=l/(e-r),this._weightNext=l/(o-i),this._offsetPrev=s*h,this._offsetNext=a*h}interpolate_(t,e,i,n){const s=this.resultBuffer,a=this.sampleValues,r=this.valueSize,o=t*r,l=o-r,h=this._offsetPrev,c=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(i-e)/(n-e),m=p*p,g=m*p,f=-u*g+2*u*m-u*p,y=(1+u)*g+(-1.5-2*u)*m+(-.5+u)*p+1,v=(-1-d)*g+(1.5+d)*m+.5*p,b=d*g-d*m;for(let t=0;t!==r;++t)s[t]=f*a[h+t]+y*a[l+t]+v*a[o+t]+b*a[c+t];return s}}class El extends Tl{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t,e,i,n){const s=this.resultBuffer,a=this.sampleValues,r=this.valueSize,o=t*r,l=o-r,h=(i-e)/(n-e),c=1-h;for(let t=0;t!==r;++t)s[t]=a[l+t]*c+a[o+t]*h;return s}}class Al extends Tl{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t){return this.copySampleValue_(t-1)}}class Pl{constructor(t,e,i,n){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Ml(e,this.TimeBufferType),this.values=Ml(i,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:Ml(t.times,Array),values:Ml(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(i.interpolation=e)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new Al(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new El(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Cl(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Zt:e=this.InterpolantFactoryMethodDiscrete;break;case Jt:e=this.InterpolantFactoryMethodLinear;break;case Qt:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return De("KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Zt;case this.InterpolantFactoryMethodLinear:return Jt;case this.InterpolantFactoryMethodSmooth:return Qt}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let i=0,n=e.length;i!==n;++i)e[i]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let i=0,n=e.length;i!==n;++i)e[i]*=t}return this}trim(t,e){const i=this.times,n=i.length;let s=0,a=n-1;for(;s!==n&&i[s]<t;)++s;for(;-1!==a&&i[a]>e;)--a;if(++a,0!==s||a!==n){s>=a&&(a=Math.max(a,1),s=a-1);const t=this.getValueSize();this.times=i.slice(s,a),this.values=this.values.slice(s*t,a*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(Re("KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,n=this.values,s=i.length;0===s&&(Re("KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let e=0;e!==s;e++){const n=i[e];if("number"==typeof n&&isNaN(n)){Re("KeyframeTrack: Time is not a valid number.",this,e,n),t=!1;break}if(null!==a&&a>n){Re("KeyframeTrack: Out of order keys.",this,e,n,a),t=!1;break}a=n}if(void 0!==n&&_l(n))for(let e=0,i=n.length;e!==i;++e){const i=n[e];if(isNaN(i)){Re("KeyframeTrack: Value is not a valid number.",this,e,i),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),i=this.getValueSize(),n=this.getInterpolation()===Qt,s=t.length-1;let a=1;for(let r=1;r<s;++r){let s=!1;const o=t[r];if(o!==t[r+1]&&(1!==r||o!==t[0]))if(n)s=!0;else{const t=r*i,n=t-i,a=t+i;for(let r=0;r!==i;++r){const i=e[t+r];if(i!==e[n+r]||i!==e[a+r]){s=!0;break}}}if(s){if(r!==a){t[a]=t[r];const n=r*i,s=a*i;for(let t=0;t!==i;++t)e[s+t]=e[n+t]}++a}}if(s>0){t[a]=t[s];for(let t=s*i,n=a*i,r=0;r!==i;++r)e[n+r]=e[t+r];++a}return a!==t.length?(this.times=t.slice(0,a),this.values=e.slice(0,a*i)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),i=new(0,this.constructor)(this.name,t,e);return i.createInterpolant=this.createInterpolant,i}}Pl.prototype.ValueTypeName="",Pl.prototype.TimeBufferType=Float32Array,Pl.prototype.ValueBufferType=Float32Array,Pl.prototype.DefaultInterpolation=Jt;class Dl extends Pl{constructor(t,e,i){super(t,e,i)}}Dl.prototype.ValueTypeName="bool",Dl.prototype.ValueBufferType=Array,Dl.prototype.DefaultInterpolation=Zt,Dl.prototype.InterpolantFactoryMethodLinear=void 0,Dl.prototype.InterpolantFactoryMethodSmooth=void 0;class Rl extends Pl{constructor(t,e,i,n){super(t,e,i,n)}}Rl.prototype.ValueTypeName="color";class Il extends Pl{constructor(t,e,i,n){super(t,e,i,n)}}Il.prototype.ValueTypeName="number";class Bl extends Tl{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t,e,i,n){const s=this.resultBuffer,a=this.sampleValues,r=this.valueSize,o=(i-e)/(n-e);let l=t*r;for(let t=l+r;l!==t;l+=4)Xe.slerpFlat(s,0,a,l-r,a,l,o);return s}}class Ll extends Pl{constructor(t,e,i,n){super(t,e,i,n)}InterpolantFactoryMethodLinear(t){return new Bl(this.times,this.values,this.getValueSize(),t)}}Ll.prototype.ValueTypeName="quaternion",Ll.prototype.InterpolantFactoryMethodSmooth=void 0;class kl extends Pl{constructor(t,e,i){super(t,e,i)}}kl.prototype.ValueTypeName="string",kl.prototype.ValueBufferType=Array,kl.prototype.DefaultInterpolation=Zt,kl.prototype.InterpolantFactoryMethodLinear=void 0,kl.prototype.InterpolantFactoryMethodSmooth=void 0;class Ol extends Pl{constructor(t,e,i,n){super(t,e,i,n)}}Ol.prototype.ValueTypeName="vector";class zl{constructor(t="",e=-1,i=[],n=2500){this.name=t,this.tracks=i,this.duration=e,this.blendMode=n,this.uuid=Fe(),this.userData={},this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,n=1/(t.fps||1);for(let t=0,s=i.length;t!==s;++t)e.push(Fl(i[t]).scale(n));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s.userData=JSON.parse(t.userData||"{}"),s}static toJSON(t){const e=[],i=t.tracks,n={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode,userData:JSON.stringify(t.userData)};for(let t=0,n=i.length;t!==n;++t)e.push(Pl.toJSON(i[t]));return n}static CreateFromMorphTargetSequence(t,e,i,n){const s=e.length,a=[];for(let t=0;t<s;t++){let r=[],o=[];r.push((t+s-1)%s,t,(t+1)%s),o.push(0,1,0);const l=xl(r);r=wl(r,1,l),o=wl(o,1,l),n||0!==r[0]||(r.push(s),o.push(o[0])),a.push(new Il(".morphTargetInfluences["+e[t].name+"]",r,o).scale(1/i))}return new this(t,-1,a)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const e=t;i=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<i.length;t++)if(i[t].name===e)return i[t];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const n={},s=/^([\w-]*?)([\d]+)$/;for(let e=0,i=t.length;e<i;e++){const i=t[e],a=i.name.match(s);if(a&&a.length>1){const t=a[1];let e=n[t];e||(n[t]=e=[]),e.push(i)}}const a=[];for(const t in n)a.push(this.CreateFromMorphTargetSequence(t,n[t],e,i));return a}static parseAnimation(t,e){if(De("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!t)return Re("AnimationClip: No animation in JSONLoader data."),null;const i=function(t,e,i,n,s){if(0!==i.length){const a=[],r=[];Sl(i,a,r,n),0!==a.length&&s.push(new t(e,a,r))}},n=[],s=t.name||"default",a=t.fps||30,r=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const s=l[t].keys;if(s&&0!==s.length)if(s[0].morphTargets){const t={};let e;for(e=0;e<s.length;e++)if(s[e].morphTargets)for(let i=0;i<s[e].morphTargets.length;i++)t[s[e].morphTargets[i]]=-1;for(const i in t){const t=[],a=[];for(let n=0;n!==s[e].morphTargets.length;++n){const n=s[e];t.push(n.time),a.push(n.morphTarget===i?1:0)}n.push(new Il(".morphTargetInfluence["+i+"]",t,a))}o=t.length*a}else{const a=".bones["+e[t].name+"]";i(Ol,a+".position",s,"pos",n),i(Ll,a+".quaternion",s,"rot",n),i(Ol,a+".scale",s,"scl",n)}}return 0===n.length?null:new this(s,o,n,r)}resetDuration(){let t=0;for(let e=0,i=this.tracks.length;e!==i;++e){const i=this.tracks[e];t=Math.max(t,i.times[i.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());const e=new this.constructor(this.name,this.duration,t,this.blendMode);return e.userData=JSON.parse(JSON.stringify(this.userData)),e}toJSON(){return this.constructor.toJSON(this)}}function Fl(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Il;case"vector":case"vector2":case"vector3":case"vector4":return Ol;case"color":return Rl;case"quaternion":return Ll;case"bool":case"boolean":return Dl;case"string":return kl}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],i=[];Sl(t.keys,e,i,"value"),t.times=e,t.values=i}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const Ul={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class Nl{constructor(t,e,i){const n=this;let s,a=!1,r=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this._abortController=null,this.itemStart=function(t){o++,!1===a&&void 0!==n.onStart&&n.onStart(t,r,o),a=!0},this.itemEnd=function(t){r++,void 0!==n.onProgress&&n.onProgress(t,r,o),r===o&&(a=!1,void 0!==n.onLoad&&n.onLoad())},this.itemError=function(t){void 0!==n.onError&&n.onError(t)},this.resolveURL=function(t){return s?s(t):t},this.setURLModifier=function(t){return s=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,i=l.length;e<i;e+=2){const i=l[e],n=l[e+1];if(i.global&&(i.lastIndex=0),i.test(t))return n}return null},this.abort=function(){return this.abortController.abort(),this._abortController=null,this}}get abortController(){return this._abortController||(this._abortController=new AbortController),this._abortController}}const Gl=new Nl;class Vl{constructor(t){this.manager=void 0!==t?t:Gl,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise(function(n,s){i.load(t,n,e,s)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}abort(){return this}}Vl.DEFAULT_MATERIAL_NAME="__DEFAULT";const Hl={};class Wl extends Error{constructor(t,e){super(t),this.response=e}}class jl extends Vl{constructor(t){super(t),this.mimeType="",this.responseType="",this._abortController=new AbortController}load(t,e,i,n){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=Ul.get(`file:${t}`);if(void 0!==s)return this.manager.itemStart(t),setTimeout(()=>{e&&e(s),this.manager.itemEnd(t)},0),s;if(void 0!==Hl[t])return void Hl[t].push({onLoad:e,onProgress:i,onError:n});Hl[t]=[],Hl[t].push({onLoad:e,onProgress:i,onError:n});const a=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:"function"==typeof AbortSignal.any?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal}),r=this.mimeType,o=this.responseType;fetch(a).then(e=>{if(200===e.status||0===e.status){if(0===e.status&&De("FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const i=Hl[t],n=e.body.getReader(),s=e.headers.get("X-File-Size")||e.headers.get("Content-Length"),a=s?parseInt(s):0,r=0!==a;let o=0;const l=new ReadableStream({start(t){!function e(){n.read().then(({done:n,value:s})=>{if(n)t.close();else{o+=s.byteLength;const n=new ProgressEvent("progress",{lengthComputable:r,loaded:o,total:a});for(let t=0,e=i.length;t<e;t++){const e=i[t];e.onProgress&&e.onProgress(n)}t.enqueue(s),e()}},e=>{t.error(e)})}()}});return new Response(l)}throw new Wl(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)}).then(t=>{switch(o){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then(t=>(new DOMParser).parseFromString(t,r));case"json":return t.json();default:if(""===r)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(r),i=e&&e[1]?e[1].toLowerCase():void 0,n=new TextDecoder(i);return t.arrayBuffer().then(t=>n.decode(t))}}}).then(e=>{Ul.add(`file:${t}`,e);const i=Hl[t];delete Hl[t];for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onLoad&&n.onLoad(e)}}).catch(e=>{const i=Hl[t];if(void 0===i)throw this.manager.itemError(t),e;delete Hl[t];for(let t=0,n=i.length;t<n;t++){const n=i[t];n.onError&&n.onError(e)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}const Xl=new WeakMap;class ql extends Vl{constructor(t){super(t)}load(t,e,i,n){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=Ul.get(`image:${t}`);if(void 0!==a){if(!0===a.complete)s.manager.itemStart(t),setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0);else{let t=Xl.get(a);void 0===t&&(t=[],Xl.set(a,t)),t.push({onLoad:e,onError:n})}return a}const r=Te("img");function o(){h(),e&&e(this);const i=Xl.get(this)||[];for(let t=0;t<i.length;t++){const e=i[t];e.onLoad&&e.onLoad(this)}Xl.delete(this),s.manager.itemEnd(t)}function l(e){h(),n&&n(e),Ul.remove(`image:${t}`);const i=Xl.get(this)||[];for(let t=0;t<i.length;t++){const n=i[t];n.onError&&n.onError(e)}Xl.delete(this),s.manager.itemError(t),s.manager.itemEnd(t)}function h(){r.removeEventListener("load",o,!1),r.removeEventListener("error",l,!1)}return r.addEventListener("load",o,!1),r.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(r.crossOrigin=this.crossOrigin),Ul.add(`image:${t}`,r),s.manager.itemStart(t),r.src=t,r}}class Yl extends Vl{constructor(t){super(t)}load(t,e,i,n){const s=this,a=new _a,r=new jl(this.manager);return r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setPath(this.path),r.setWithCredentials(s.withCredentials),r.load(t,function(t){let i;try{i=s.parse(t)}catch(t){if(void 0===n)return void t(t);n(t)}void 0!==i.image?a.image=i.image:void 0!==i.data&&(a.image.width=i.width,a.image.height=i.height,a.image.data=i.data),a.wrapS=void 0!==i.wrapS?i.wrapS:G,a.wrapT=void 0!==i.wrapT?i.wrapT:G,a.magFilter=void 0!==i.magFilter?i.magFilter:X,a.minFilter=void 0!==i.minFilter?i.minFilter:X,a.anisotropy=void 0!==i.anisotropy?i.anisotropy:1,void 0!==i.colorSpace&&(a.colorSpace=i.colorSpace),void 0!==i.flipY&&(a.flipY=i.flipY),void 0!==i.format&&(a.format=i.format),void 0!==i.type&&(a.type=i.type),void 0!==i.mipmaps&&(a.mipmaps=i.mipmaps,a.minFilter=Y),1===i.mipmapCount&&(a.minFilter=X),void 0!==i.generateMipmaps&&(a.generateMipmaps=i.generateMipmaps),a.needsUpdate=!0,e&&e(a,i)},i,n),a}}class $l extends Vl{constructor(t){super(t)}load(t,e,i,n){const s=new ui,a=new ql(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,function(t){s.image=t,s.needsUpdate=!0,void 0!==e&&e(s)},i,n),s}}class Zl extends vn{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new zn(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),void 0!==this.target&&(e.object.target=this.target.uuid),e}}class Jl extends Zl{constructor(t,e,i){super(t,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(vn.DEFAULT_UP),this.updateMatrix(),this.groundColor=new zn(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const Ql=new Wi,Kl=new qe,th=new qe;class eh{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new je(512,512),this.mapType=$,this.map=null,this.mapPass=null,this.matrix=new Wi,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ga,this._frameExtents=new je(1,1),this._viewportCount=1,this._viewports=[new di(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;Kl.setFromMatrixPosition(t.matrixWorld),e.position.copy(Kl),th.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(th),e.updateMatrixWorld(),Ql.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ql,e.coordinateSystem,e.reversedDepth),e.reversedDepth?i.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(Ql)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.autoUpdate=t.autoUpdate,this.needsUpdate=t.needsUpdate,this.normalBias=t.normalBias,this.blurSamples=t.blurSamples,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 1!==this.intensity&&(t.intensity=this.intensity),0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class ih extends eh{constructor(){super(new Rs(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(t){const e=this.camera,i=2*ze*t.angle*this.focus,n=this.mapSize.width/this.mapSize.height*this.aspect,s=t.distance||e.far;i===e.fov&&n===e.aspect&&s===e.far||(e.fov=i,e.aspect=n,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class nh extends Zl{constructor(t,e,i=0,n=Math.PI/3,s=0,a=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(vn.DEFAULT_UP),this.updateMatrix(),this.target=new vn,this.distance=i,this.angle=n,this.penumbra=s,this.decay=a,this.map=null,this.shadow=new ih}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const sh=new Wi,ah=new qe,rh=new qe;class oh extends eh{constructor(){super(new Rs(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new je(4,2),this._viewportCount=6,this._viewports=[new di(2,1,1,1),new di(0,1,1,1),new di(3,1,1,1),new di(1,1,1,1),new di(3,0,1,1),new di(1,0,1,1)],this._cubeDirections=[new qe(1,0,0),new qe(-1,0,0),new qe(0,0,1),new qe(0,0,-1),new qe(0,1,0),new qe(0,-1,0)],this._cubeUps=[new qe(0,1,0),new qe(0,1,0),new qe(0,1,0),new qe(0,1,0),new qe(0,0,1),new qe(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,n=this.matrix,s=t.distance||i.far;s!==i.far&&(i.far=s,i.updateProjectionMatrix()),ah.setFromMatrixPosition(t.matrixWorld),i.position.copy(ah),rh.copy(i.position),rh.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(rh),i.updateMatrixWorld(),n.makeTranslation(-ah.x,-ah.y,-ah.z),sh.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(sh,i.coordinateSystem,i.reversedDepth)}}class lh extends Zl{constructor(t,e,i=0,n=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=n,this.shadow=new oh}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class hh extends Es{constructor(t=-1,e=1,i=1,n=-1,s=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=n,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,i,n,s,a){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let s=i-t,a=i+t,r=n+e,o=n-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=t*this.view.offsetX,a=s+t*this.view.width,r-=e*this.view.offsetY,o=r-e*this.view.height}this.projectionMatrix.makeOrthographic(s,a,r,o,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}class ch extends eh{constructor(){super(new hh(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class uh extends Zl{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(vn.DEFAULT_UP),this.updateMatrix(),this.target=new vn,this.shadow=new ch}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class dh extends Zl{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class ph extends Zl{constructor(t,e,i=10,n=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=n}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class mh{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new qe)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const i=t.x,n=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*n),e.addScaledVector(a[2],.488603*s),e.addScaledVector(a[3],.488603*i),e.addScaledVector(a[4],i*n*1.092548),e.addScaledVector(a[5],n*s*1.092548),e.addScaledVector(a[6],.315392*(3*s*s-1)),e.addScaledVector(a[7],i*s*1.092548),e.addScaledVector(a[8],.546274*(i*i-n*n)),e}getIrradianceAt(t,e){const i=t.x,n=t.y,s=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],1.023328*n),e.addScaledVector(a[2],1.023328*s),e.addScaledVector(a[3],1.023328*i),e.addScaledVector(a[4],.858086*i*n),e.addScaledVector(a[5],.858086*n*s),e.addScaledVector(a[6],.743125*s*s-.247708),e.addScaledVector(a[7],.858086*i*s),e.addScaledVector(a[8],.429043*(i*i-n*n)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const i=this.coefficients;for(let n=0;n<9;n++)i[n].fromArray(t,e+3*n);return this}toArray(t=[],e=0){const i=this.coefficients;for(let n=0;n<9;n++)i[n].toArray(t,e+3*n);return t}static getBasisAt(t,e){const i=t.x,n=t.y,s=t.z;e[0]=.282095,e[1]=.488603*n,e[2]=.488603*s,e[3]=.488603*i,e[4]=1.092548*i*n,e[5]=1.092548*n*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*i*s,e[8]=.546274*(i*i-n*n)}}class gh extends Zl{constructor(t=new mh,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class fh extends Vl{constructor(t){super(t),this.textures={}}load(t,e,i,n){const s=this,a=new jl(s.manager);a.setPath(s.path),a.setRequestHeader(s.requestHeader),a.setWithCredentials(s.withCredentials),a.load(t,function(i){try{e(s.parse(JSON.parse(i)))}catch(e){n?n(e):Re(e),s.manager.itemError(t)}},i,n)}parse(t){const e=this.textures;function i(t){return void 0===e[t]&&De("MaterialLoader: Undefined texture",t),e[t]}const n=this.createMaterialFromType(t.type);if(void 0!==t.uuid&&(n.uuid=t.uuid),void 0!==t.name&&(n.name=t.name),void 0!==t.color&&void 0!==n.color&&n.color.setHex(t.color),void 0!==t.roughness&&(n.roughness=t.roughness),void 0!==t.metalness&&(n.metalness=t.metalness),void 0!==t.sheen&&(n.sheen=t.sheen),void 0!==t.sheenColor&&(n.sheenColor=(new zn).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(n.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==n.emissive&&n.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==n.specular&&n.specular.setHex(t.specular),void 0!==t.specularIntensity&&(n.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==n.specularColor&&n.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(n.shininess=t.shininess),void 0!==t.clearcoat&&(n.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(n.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.dispersion&&(n.dispersion=t.dispersion),void 0!==t.iridescence&&(n.iridescence=t.iridescence),void 0!==t.iridescenceIOR&&(n.iridescenceIOR=t.iridescenceIOR),void 0!==t.iridescenceThicknessRange&&(n.iridescenceThicknessRange=t.iridescenceThicknessRange),void 0!==t.transmission&&(n.transmission=t.transmission),void 0!==t.thickness&&(n.thickness=t.thickness),void 0!==t.attenuationDistance&&(n.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==n.attenuationColor&&n.attenuationColor.setHex(t.attenuationColor),void 0!==t.anisotropy&&(n.anisotropy=t.anisotropy),void 0!==t.anisotropyRotation&&(n.anisotropyRotation=t.anisotropyRotation),void 0!==t.fog&&(n.fog=t.fog),void 0!==t.flatShading&&(n.flatShading=t.flatShading),void 0!==t.blending&&(n.blending=t.blending),void 0!==t.combine&&(n.combine=t.combine),void 0!==t.side&&(n.side=t.side),void 0!==t.shadowSide&&(n.shadowSide=t.shadowSide),void 0!==t.opacity&&(n.opacity=t.opacity),void 0!==t.transparent&&(n.transparent=t.transparent),void 0!==t.alphaTest&&(n.alphaTest=t.alphaTest),void 0!==t.alphaHash&&(n.alphaHash=t.alphaHash),void 0!==t.depthFunc&&(n.depthFunc=t.depthFunc),void 0!==t.depthTest&&(n.depthTest=t.depthTest),void 0!==t.depthWrite&&(n.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(n.colorWrite=t.colorWrite),void 0!==t.blendSrc&&(n.blendSrc=t.blendSrc),void 0!==t.blendDst&&(n.blendDst=t.blendDst),void 0!==t.blendEquation&&(n.blendEquation=t.blendEquation),void 0!==t.blendSrcAlpha&&(n.blendSrcAlpha=t.blendSrcAlpha),void 0!==t.blendDstAlpha&&(n.blendDstAlpha=t.blendDstAlpha),void 0!==t.blendEquationAlpha&&(n.blendEquationAlpha=t.blendEquationAlpha),void 0!==t.blendColor&&void 0!==n.blendColor&&n.blendColor.setHex(t.blendColor),void 0!==t.blendAlpha&&(n.blendAlpha=t.blendAlpha),void 0!==t.stencilWriteMask&&(n.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(n.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(n.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(n.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(n.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(n.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(n.stencilZPass=t.stencilZPass),void 0!==t.stencilWrite&&(n.stencilWrite=t.stencilWrite),void 0!==t.wireframe&&(n.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(n.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(n.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(n.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(n.rotation=t.rotation),void 0!==t.linewidth&&(n.linewidth=t.linewidth),void 0!==t.dashSize&&(n.dashSize=t.dashSize),void 0!==t.gapSize&&(n.gapSize=t.gapSize),void 0!==t.scale&&(n.scale=t.scale),void 0!==t.polygonOffset&&(n.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(n.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(n.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(n.dithering=t.dithering),void 0!==t.alphaToCoverage&&(n.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(n.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.forceSinglePass&&(n.forceSinglePass=t.forceSinglePass),void 0!==t.visible&&(n.visible=t.visible),void 0!==t.toneMapped&&(n.toneMapped=t.toneMapped),void 0!==t.userData&&(n.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?n.vertexColors=t.vertexColors>0:n.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const s=t.uniforms[e];switch(n.uniforms[e]={},s.type){case"t":n.uniforms[e].value=i(s.value);break;case"c":n.uniforms[e].value=(new zn).setHex(s.value);break;case"v2":n.uniforms[e].value=(new je).fromArray(s.value);break;case"v3":n.uniforms[e].value=(new qe).fromArray(s.value);break;case"v4":n.uniforms[e].value=(new di).fromArray(s.value);break;case"m3":n.uniforms[e].value=(new Ze).fromArray(s.value);break;case"m4":n.uniforms[e].value=(new Wi).fromArray(s.value);break;default:n.uniforms[e].value=s.value}}if(void 0!==t.defines&&(n.defines=t.defines),void 0!==t.vertexShader&&(n.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(n.fragmentShader=t.fragmentShader),void 0!==t.glslVersion&&(n.glslVersion=t.glslVersion),void 0!==t.extensions)for(const e in t.extensions)n.extensions[e]=t.extensions[e];if(void 0!==t.lights&&(n.lights=t.lights),void 0!==t.clipping&&(n.clipping=t.clipping),void 0!==t.size&&(n.size=t.size),void 0!==t.sizeAttenuation&&(n.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(n.map=i(t.map)),void 0!==t.matcap&&(n.matcap=i(t.matcap)),void 0!==t.alphaMap&&(n.alphaMap=i(t.alphaMap)),void 0!==t.bumpMap&&(n.bumpMap=i(t.bumpMap)),void 0!==t.bumpScale&&(n.bumpScale=t.bumpScale),void 0!==t.normalMap&&(n.normalMap=i(t.normalMap)),void 0!==t.normalMapType&&(n.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),n.normalScale=(new je).fromArray(e)}return void 0!==t.displacementMap&&(n.displacementMap=i(t.displacementMap)),void 0!==t.displacementScale&&(n.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(n.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(n.roughnessMap=i(t.roughnessMap)),void 0!==t.metalnessMap&&(n.metalnessMap=i(t.metalnessMap)),void 0!==t.emissiveMap&&(n.emissiveMap=i(t.emissiveMap)),void 0!==t.emissiveIntensity&&(n.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(n.specularMap=i(t.specularMap)),void 0!==t.specularIntensityMap&&(n.specularIntensityMap=i(t.specularIntensityMap)),void 0!==t.specularColorMap&&(n.specularColorMap=i(t.specularColorMap)),void 0!==t.envMap&&(n.envMap=i(t.envMap)),void 0!==t.envMapRotation&&n.envMapRotation.fromArray(t.envMapRotation),void 0!==t.envMapIntensity&&(n.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(n.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(n.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(n.lightMap=i(t.lightMap)),void 0!==t.lightMapIntensity&&(n.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(n.aoMap=i(t.aoMap)),void 0!==t.aoMapIntensity&&(n.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(n.gradientMap=i(t.gradientMap)),void 0!==t.clearcoatMap&&(n.clearcoatMap=i(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap=i(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(n.clearcoatNormalMap=i(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(n.clearcoatNormalScale=(new je).fromArray(t.clearcoatNormalScale)),void 0!==t.iridescenceMap&&(n.iridescenceMap=i(t.iridescenceMap)),void 0!==t.iridescenceThicknessMap&&(n.iridescenceThicknessMap=i(t.iridescenceThicknessMap)),void 0!==t.transmissionMap&&(n.transmissionMap=i(t.transmissionMap)),void 0!==t.thicknessMap&&(n.thicknessMap=i(t.thicknessMap)),void 0!==t.anisotropyMap&&(n.anisotropyMap=i(t.anisotropyMap)),void 0!==t.sheenColorMap&&(n.sheenColorMap=i(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(n.sheenRoughnessMap=i(t.sheenRoughnessMap)),n}setTextures(t){return this.textures=t,this}createMaterialFromType(t){return fh.createMaterialFromType(t)}static createMaterialFromType(t){return new{ShadowMaterial:ll,SpriteMaterial:js,RawShaderMaterial:hl,ShaderMaterial:Cs,PointsMaterial:Sr,MeshPhysicalMaterial:ul,MeshStandardMaterial:cl,MeshPhongMaterial:dl,MeshToonMaterial:pl,MeshNormalMaterial:ml,MeshLambertMaterial:gl,MeshDepthMaterial:fl,MeshDistanceMaterial:yl,MeshBasicMaterial:Gn,MeshMatcapMaterial:vl,LineDashedMaterial:bl,LineBasicMaterial:cr,Material:Nn}[t]}}class yh{static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class vh extends os{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class bh extends Vl{constructor(t){super(t)}load(t,e,i,n){const s=this,a=new jl(s.manager);a.setPath(s.path),a.setRequestHeader(s.requestHeader),a.setWithCredentials(s.withCredentials),a.load(t,function(i){try{e(s.parse(JSON.parse(i)))}catch(e){n?n(e):Re(e),s.manager.itemError(t)}},i,n)}parse(t){const e={},i={};function n(t,n){if(void 0!==e[n])return e[n];const s=t.interleavedBuffers[n],a=function(t,e){if(void 0!==i[e])return i[e];const n=t.arrayBuffers[e],s=new Uint32Array(n).buffer;return i[e]=s,s}(t,s.buffer),r=Se(s.type,a),o=new Vs(r,s.stride);return o.uuid=s.uuid,e[n]=o,o}const s=t.isInstancedBufferGeometry?new vh:new os,a=t.data.index;if(void 0!==a){const t=Se(a.type,a.array);s.setIndex(new Zn(t,1))}const r=t.data.attributes;for(const e in r){const i=r[e];let a;if(i.isInterleavedBufferAttribute){const e=n(t.data,i.data);a=new Ws(e,i.itemSize,i.offset,i.normalized)}else{const t=Se(i.type,i.array);a=new(i.isInstancedBufferAttribute?Ta:Zn)(t,i.itemSize,i.normalized)}void 0!==i.name&&(a.name=i.name),void 0!==i.usage&&a.setUsage(i.usage),s.setAttribute(e,a)}const o=t.data.morphAttributes;if(o)for(const e in o){const i=o[e],a=[];for(let e=0,s=i.length;e<s;e++){const s=i[e];let r;if(s.isInterleavedBufferAttribute){const e=n(t.data,s.data);r=new Ws(e,s.itemSize,s.offset,s.normalized)}else{const t=Se(s.type,s.array);r=new Zn(t,s.itemSize,s.normalized)}void 0!==s.name&&(r.name=s.name),a.push(r)}s.morphAttributes[e]=a}t.data.morphTargetsRelative&&(s.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];s.addGroup(e.start,e.count,e.materialIndex)}const h=t.data.boundingSphere;return void 0!==h&&(s.boundingSphere=(new ki).fromJSON(h)),t.name&&(s.name=t.name),t.userData&&(s.userData=t.userData),s}}const Mh={UVMapping:L,CubeReflectionMapping:k,CubeRefractionMapping:O,EquirectangularReflectionMapping:z,EquirectangularRefractionMapping:F,CubeUVReflectionMapping:U},_h={RepeatWrapping:N,ClampToEdgeWrapping:G,MirroredRepeatWrapping:V},xh={NearestFilter:H,NearestMipmapNearestFilter:W,NearestMipmapLinearFilter:j,LinearFilter:X,LinearMipmapNearestFilter:q,LinearMipmapLinearFilter:Y},wh=new WeakMap;let Sh;class Th{static getContext(){return void 0===Sh&&(Sh=new(window.AudioContext||window.webkitAudioContext)),Sh}static setContext(t){Sh=t}}const Ch=new Wi,Eh=new Wi,Ah=new Wi;class Ph extends Rs{constructor(t=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=t}}class Dh{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=performance.now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}const Rh=new qe,Ih=new Xe,Bh=new qe,Lh=new qe,kh=new qe;class Oh extends vn{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void De("Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void De("Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;De("Audio: this Audio has no playback control.")}stop(t=0){if(!1!==this.hasPlaybackControl)return this._progress=0,null!==this.source&&(this.source.stop(this.context.currentTime+t),this.source.onended=null),this.isPlaying=!1,this;De("Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(!1!==this._connected){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){return this.detune=t,!0===this.isPlaying&&void 0!==this.source.detune&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;De("Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return!1===this.hasPlaybackControl?(De("Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;De("Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}copy(t,e){return super.copy(t,e),"buffer"!==t.sourceType?(De("Audio: Audio source type cannot be copied."),this):(this.autoplay=t.autoplay,this.buffer=t.buffer,this.detune=t.detune,this.loop=t.loop,this.loopStart=t.loopStart,this.loopEnd=t.loopEnd,this.offset=t.offset,this.duration=t.duration,this.playbackRate=t.playbackRate,this.hasPlaybackControl=t.hasPlaybackControl,this.sourceType=t.sourceType,this.filters=t.filters.slice(),this)}clone(t){return new this.constructor(this.listener).copy(this,t)}}const zh=new qe,Fh=new Xe,Uh=new qe,Nh=new qe;class Gh{constructor(t,e,i){let n,s,a;switch(this.binding=t,this.valueSize=i,e){case"quaternion":n=this._slerp,s=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":n=this._select,s=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(5*i);break;default:n=this._lerp,s=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=n,this._mixBufferRegionAdditive=s,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const i=this.buffer,n=this.valueSize,s=t*n+n;let a=this.cumulativeWeight;if(0===a){for(let t=0;t!==n;++t)i[s+t]=i[t];a=e}else{a+=e;const t=e/a;this._mixBufferRegion(i,s,0,t,n)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,i=this.valueSize,n=i*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,n,0,t,i),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,i=this.buffer,n=t*e+e,s=this.cumulativeWeight,a=this.cumulativeWeightAdditive,r=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const t=e*this._origIndex;this._mixBufferRegion(i,n,t,1-s,e)}a>0&&this._mixBufferRegionAdditive(i,n,this._addIndex*e,1,e);for(let t=e,s=e+e;t!==s;++t)if(i[t]!==i[t+e]){r.setValue(i,n);break}}saveOriginalState(){const t=this.binding,e=this.buffer,i=this.valueSize,n=i*this._origIndex;t.getValue(e,n);for(let t=i,s=n;t!==s;++t)e[t]=e[n+t%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}_select(t,e,i,n,s){if(n>=.5)for(let n=0;n!==s;++n)t[e+n]=t[i+n]}_slerp(t,e,i,n){Xe.slerpFlat(t,e,t,e,t,i,n)}_slerpAdditive(t,e,i,n,s){const a=this._workIndex*s;Xe.multiplyQuaternionsFlat(t,a,t,e,t,i),Xe.slerpFlat(t,e,t,e,t,a,n)}_lerp(t,e,i,n,s){const a=1-n;for(let r=0;r!==s;++r){const s=e+r;t[s]=t[s]*a+t[i+r]*n}}_lerpAdditive(t,e,i,n,s){for(let a=0;a!==s;++a){const s=e+a;t[s]=t[s]+t[i+a]*n}}}const Vh="\\[\\]\\.:\\/",Hh=new RegExp("["+Vh+"]","g"),Wh="[^"+Vh+"]",jh="[^"+Vh.replace("\\.","")+"]",Xh=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",Wh)+/(WCOD+)?/.source.replace("WCOD",jh)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Wh)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Wh)+"$"),qh=["material","materials","bones","map"];class Yh{constructor(t,e,i){this.path=e,this.parsedPath=i||Yh.parseTrackName(e),this.node=Yh.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new Yh.Composite(t,e,i):new Yh(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Hh,"")}static parseTrackName(t){const e=Xh.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},n=i.nodeName&&i.nodeName.lastIndexOf(".");if(void 0!==n&&-1!==n){const t=i.nodeName.substring(n+1);-1!==qh.indexOf(t)&&(i.nodeName=i.nodeName.substring(0,n),i.objectName=t)}if(null===i.propertyName||0===i.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(void 0!==i)return i}if(t.children){const i=function(t){for(let n=0;n<t.length;n++){const s=t[n];if(s.name===e||s.uuid===e)return s;const a=i(s.children);if(a)return a}return null},n=i(t.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let n=0,s=i.length;n!==s;++n)t[e++]=i[n]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let n=0,s=i.length;n!==s;++n)i[n]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let n=0,s=i.length;n!==s;++n)i[n]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let n=0,s=i.length;n!==s;++n)i[n]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,n=e.propertyName;let s=e.propertyIndex;if(t||(t=Yh.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void De("PropertyBinding: No target node found for track: "+this.path+".");if(i){let n=e.objectIndex;switch(i){case"materials":if(!t.material)return void Re("PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void Re("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void Re("PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===n){n=e;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material)return void Re("PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.map)return void Re("PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);t=t.material.map;break;default:if(void 0===t[i])return void Re("PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[i]}if(void 0!==n){if(void 0===t[n])return void Re("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[n]}}const a=t[n];if(void 0===a)return void Re("PropertyBinding: Trying to update property for track: "+e.nodeName+"."+n+" but it wasn't found.",t);let r=this.Versioning.None;this.targetObject=t,!0===t.isMaterial?r=this.Versioning.NeedsUpdate:!0===t.isObject3D&&(r=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==s){if("morphTargetInfluences"===n){if(!t.geometry)return void Re("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void Re("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[s]&&(s=t.morphTargetDictionary[s])}o=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else void 0!==a.fromArray&&void 0!==a.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(o=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=n;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][r]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Yh.Composite=class{constructor(t,e,i){const n=i||Yh.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,n)}getValue(t,e){this.bind();const i=this._targetGroup.nCachedObjects_,n=this._bindings[i];void 0!==n&&n.getValue(t,e)}setValue(t,e){const i=this._bindings;for(let n=this._targetGroup.nCachedObjects_,s=i.length;n!==s;++n)i[n].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}},Yh.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Yh.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Yh.prototype.GetterByBindingType=[Yh.prototype._getValue_direct,Yh.prototype._getValue_array,Yh.prototype._getValue_arrayElement,Yh.prototype._getValue_toArray],Yh.prototype.SetterByBindingTypeAndVersioning=[[Yh.prototype._setValue_direct,Yh.prototype._setValue_direct_setNeedsUpdate,Yh.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Yh.prototype._setValue_array,Yh.prototype._setValue_array_setNeedsUpdate,Yh.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Yh.prototype._setValue_arrayElement,Yh.prototype._setValue_arrayElement_setNeedsUpdate,Yh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Yh.prototype._setValue_fromArray,Yh.prototype._setValue_fromArray_setNeedsUpdate,Yh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class $h{constructor(t,e,i=null,n=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=n;const s=e.tracks,a=s.length,r=new Array(a),o={endingStart:Kt,endingEnd:Kt};for(let t=0;t!==a;++t){const e=s[t].createInterpolant(null);r[t]=e,e.settings=o}this._interpolantSettings=o,this._interpolants=r,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i=!1){if(t.fadeOut(e),this.fadeIn(e),!0===i){const i=this._clip.duration,n=t._clip.duration,s=n/i,a=i/n;t.warp(1,s,e),this.warp(a,1,e)}return this}crossFadeTo(t,e,i=!1){return t.crossFadeFrom(this,e,i)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){const n=this._mixer,s=n.time,a=this.timeScale;let r=this._timeScaleInterpolant;null===r&&(r=n._lendControlInterpolant(),this._timeScaleInterpolant=r);const o=r.parameterPositions,l=r.sampleValues;return o[0]=s,o[1]=s+i,l[0]=t/a,l[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,i,n){if(!this.enabled)return void this._updateWeight(t);const s=this._startTime;if(null!==s){const n=(t-s)*i;n<0||0===i?e=0:(this._startTime=null,e=i*n)}e*=this._updateTimeScale(t);const a=this._updateTime(e),r=this._updateWeight(t);if(r>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===ie)for(let i=0,n=t.length;i!==n;++i)t[i].evaluate(a),e[i].accumulateAdditive(r);else for(let i=0,s=t.length;i!==s;++i)t[i].evaluate(a),e[i].accumulate(n,r)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const i=this._weightInterpolant;if(null!==i){const n=i.evaluate(t)[0];e*=n,t>i.parameterPositions[1]&&(this.stopFading(),0===n&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const i=this._timeScaleInterpolant;null!==i&&(e*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,i=this.loop;let n=this.time+t,s=this._loopCount;const a=2202===i;if(0===t)return-1===s||!a||1&~s?n:e-n;if(2200===i){-1===s&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(n>=e)n=e;else{if(!(n<0)){this.time=n;break t}n=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===s&&(t>=0?(s=0,this._setEndings(!0,0===this.repetitions,a)):this._setEndings(0===this.repetitions,!0,a)),n>=e||n<0){const i=Math.floor(n/e);n-=e*i,s+=Math.abs(i);const r=this.repetitions-s;if(r<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,n=t>0?e:0,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===r){const e=t<0;this._setEndings(e,!e,a)}else this._setEndings(!1,!1,a);this._loopCount=s,this.time=n,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=n;if(a&&!(1&~s))return e-n}return n}_setEndings(t,e,i){const n=this._interpolantSettings;i?(n.endingStart=te,n.endingEnd=te):(n.endingStart=t?this.zeroSlopeAtStart?te:Kt:ee,n.endingEnd=e?this.zeroSlopeAtEnd?te:Kt:ee)}_scheduleFading(t,e,i){const n=this._mixer,s=n.time;let a=this._weightInterpolant;null===a&&(a=n._lendControlInterpolant(),this._weightInterpolant=a);const r=a.parameterPositions,o=a.sampleValues;return r[0]=s,o[0]=e,r[1]=s+t,o[1]=i,this}}const Zh=new Float32Array(1);class Jh{constructor(t){this.value=t}clone(){return new Jh(void 0===this.value.clone?this.value:this.value.clone())}}let Qh=0;const Kh=new Wi;function tc(t,e){return t.distance-e.distance}function ec(t,e,i,n){let s=!0;if(t.layers.test(e.layers)&&!1===t.raycast(e,i)&&(s=!1),!0===s&&!0===n){const n=t.children;for(let t=0,s=n.length;t<s;t++)ec(n[t],e,i,!0)}}function ic(){!1===this._document.hidden&&this.reset()}class nc{constructor(t=1,e=0,i=0){this.radius=t,this.phi=e,this.theta=i}set(t,e,i){return this.radius=t,this.phi=e,this.theta=i,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Ue(this.phi,t,Math.PI-t),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,i){return this.radius=Math.sqrt(t*t+e*e+i*i),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,i),this.phi=Math.acos(Ue(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class sc{constructor(t,e,i,n){sc.prototype.isMatrix2=!0,this.elements=[1,0,0,1],void 0!==t&&this.set(t,e,i,n)}identity(){return this.set(1,0,0,1),this}fromArray(t,e=0){for(let i=0;i<4;i++)this.elements[i]=t[i+e];return this}set(t,e,i,n){const s=this.elements;return s[0]=t,s[2]=e,s[1]=i,s[3]=n,this}}const ac=new je,rc=new qe,oc=new qe,lc=new qe,hc=new qe,cc=new qe,uc=new qe,dc=new qe,pc=new qe,mc=new qe,gc=new Wi,fc=new Wi;function yc(t){const e=[];!0===t.isBone&&e.push(t);for(let i=0;i<t.children.length;i++)e.push(...yc(t.children[i]));return e}const vc=new qe,bc=new zn,Mc=new zn,_c=new qe,xc=new qe,wc=new qe,Sc=new qe,Tc=new Es;function Cc(t,e,i,n,s,a,r){Sc.set(s,a,r).unproject(n);const o=e[t];if(void 0!==o){const t=i.getAttribute("position");for(let e=0,i=o.length;e<i;e++)t.setXYZ(o[e],Sc.x,Sc.y,Sc.z)}}const Ec=new yi,Ac=new qe;let Pc,Dc;class Rc extends Be{constructor(t,e=null){super(),this.object=t,this.domElement=e,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(t){void 0!==t?(null!==this.domElement&&this.disconnect(),this.domElement=t):De("Controls: connect() now requires an element.")}disconnect(){}dispose(){}update(){}}function Ic(t,e,i,n){const s=function(t){switch(t){case $:case Z:return{byteLength:1,components:1};case Q:case J:case it:return{byteLength:2,components:1};case nt:case st:return{byteLength:2,components:4};case tt:case K:case et:return{byteLength:4,components:1};case rt:case ot:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${t}.`)}(n);switch(i){case lt:return t*e;case pt:case mt:return t*e/s.components*s.byteLength;case gt:case ft:return t*e*2/s.components*s.byteLength;case ht:return t*e*3/s.components*s.byteLength;case ct:case yt:return t*e*4/s.components*s.byteLength;case vt:case bt:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case Mt:case _t:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case wt:case Tt:return Math.max(t,16)*Math.max(e,8)/4;case xt:case St:return Math.max(t,8)*Math.max(e,8)/2;case Ct:case Et:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case At:case Pt:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case Dt:return Math.floor((t+4)/5)*Math.floor((e+3)/4)*16;case Rt:return Math.floor((t+4)/5)*Math.floor((e+4)/5)*16;case It:return Math.floor((t+5)/6)*Math.floor((e+4)/5)*16;case Bt:return Math.floor((t+5)/6)*Math.floor((e+5)/6)*16;case Lt:return Math.floor((t+7)/8)*Math.floor((e+4)/5)*16;case kt:return Math.floor((t+7)/8)*Math.floor((e+5)/6)*16;case Ot:return Math.floor((t+7)/8)*Math.floor((e+7)/8)*16;case zt:return Math.floor((t+9)/10)*Math.floor((e+4)/5)*16;case Ft:return Math.floor((t+9)/10)*Math.floor((e+5)/6)*16;case Ut:return Math.floor((t+9)/10)*Math.floor((e+7)/8)*16;case Nt:return Math.floor((t+9)/10)*Math.floor((e+9)/10)*16;case Gt:return Math.floor((t+11)/12)*Math.floor((e+9)/10)*16;case Vt:return Math.floor((t+11)/12)*Math.floor((e+11)/12)*16;case Ht:case Wt:case jt:return Math.ceil(t/4)*Math.ceil(e/4)*16;case Xt:case qt:return Math.ceil(t/4)*Math.ceil(e/4)*8;case Yt:case $t:return Math.ceil(t/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${i} format.`)}function Bc(){let t=null,e=!1,i=null,n=null;function s(e,a){i(e,a),n=t.requestAnimationFrame(s)}return{start:function(){!0!==e&&null!==i&&(n=t.requestAnimationFrame(s),e=!0)},stop:function(){t.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(t){i=t},setContext:function(e){t=e}}}function Lc(t){const e=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),e.get(t)},remove:function(i){i.isInterleavedBufferAttribute&&(i=i.data);const n=e.get(i);n&&(t.deleteBuffer(n.buffer),e.delete(i))},update:function(i,n){if(i.isInterleavedBufferAttribute&&(i=i.data),i.isGLBufferAttribute){const t=e.get(i);return void((!t||t.version<i.version)&&e.set(i,{buffer:i.buffer,type:i.type,bytesPerElement:i.elementSize,version:i.version}))}const s=e.get(i);if(void 0===s)e.set(i,function(e,i){const n=e.array,s=e.usage,a=n.byteLength,r=t.createBuffer();let o;if(t.bindBuffer(i,r),t.bufferData(i,n,s),e.onUploadCallback(),n instanceof Float32Array)o=t.FLOAT;else if("undefined"!=typeof Float16Array&&n instanceof Float16Array)o=t.HALF_FLOAT;else if(n instanceof Uint16Array)o=e.isFloat16BufferAttribute?t.HALF_FLOAT:t.UNSIGNED_SHORT;else if(n instanceof Int16Array)o=t.SHORT;else if(n instanceof Uint32Array)o=t.UNSIGNED_INT;else if(n instanceof Int32Array)o=t.INT;else if(n instanceof Int8Array)o=t.BYTE;else if(n instanceof Uint8Array)o=t.UNSIGNED_BYTE;else{if(!(n instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+n);o=t.UNSIGNED_BYTE}return{buffer:r,type:o,bytesPerElement:n.BYTES_PER_ELEMENT,version:e.version,size:a}}(i,n));else if(s.version<i.version){if(s.size!==i.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(e,i,n){const s=i.array,a=i.updateRanges;if(t.bindBuffer(n,e),0===a.length)t.bufferSubData(n,0,s);else{a.sort((t,e)=>t.start-e.start);let e=0;for(let t=1;t<a.length;t++){const i=a[e],n=a[t];n.start<=i.start+i.count+1?i.count=Math.max(i.count,n.start+n.count-i.start):(++e,a[e]=n)}a.length=e+1;for(let e=0,i=a.length;e<i;e++){const i=a[e];t.bufferSubData(n,i.start*s.BYTES_PER_ELEMENT,s,i.start,i.count)}i.clearUpdateRanges()}i.onUploadCallback()}(s.buffer,i,n),s.version=i.version}}}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:t}})),"undefined"!=typeof window&&(window.__THREE__?De("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=t);const kc={alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",alphahash_pars_fragment:"#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",batching_pars_vertex:"#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",batching_vertex:"#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",begin_vertex:"vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",colorspace_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment:"vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"uniform sampler2D dfgLUT;\nstruct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 uv = vec2( roughness, dotNV );\n\treturn texture2D( dfgLUT, uv ).rg;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nvec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 dfgV = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNV * dotNV), 0.0, dotNV), material.roughness );\n\tvec2 dfgL = DFGApprox( vec3(0.0, 0.0, 1.0), vec3(sqrt(1.0 - dotNL * dotNL), 0.0, dotNL), material.roughness );\n\tvec3 FssEss_V = material.specularColor * dfgV.x + material.specularF90 * dfgV.y;\n\tvec3 FssEss_L = material.specularColor * dfgL.x + material.specularF90 * dfgL.y;\n\tfloat Ess_V = dfgV.x + dfgV.y;\n\tfloat Ess_L = dfgL.x + dfgL.y;\n\tfloat Ems_V = 1.0 - Ess_V;\n\tfloat Ems_L = 1.0 - Ess_L;\n\tvec3 Favg = material.specularColor + ( 1.0 - material.specularColor ) * 0.047619;\n\tvec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg * Favg + EPSILON );\n\tfloat compensationFactor = Ems_V * Ems_L;\n\tvec3 multiScatter = Fms * compensationFactor;\n\treturn singleScatter + multiScatter;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphinstance_vertex:"#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",opaque_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\tfloat depth = unpackRGBAToDepth( texture2D( depths, uv ) );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\treturn step( depth, compare );\n\t\t#else\n\t\t\treturn step( compare, depth );\n\t\t#endif\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow( sampler2D shadow, vec2 uv, float compare ) {\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\tfloat hard_shadow = step( distribution.x, compare );\n\t\t#else\n\t\t\tfloat hard_shadow = step( compare, distribution.x );\n\t\t#endif\n\t\tif ( hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",depth_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\tfloat fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n\t#else\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n\t#endif\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"},Oc={common:{diffuse:{value:new zn(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Ze},alphaMap:{value:null},alphaMapTransform:{value:new Ze},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Ze}},envmap:{envMap:{value:null},envMapRotation:{value:new Ze},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98},dfgLUT:{value:null}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Ze}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Ze}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Ze},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Ze},normalScale:{value:new je(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Ze},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Ze}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Ze}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Ze}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new zn(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new zn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Ze},alphaTest:{value:0},uvTransform:{value:new Ze}},sprite:{diffuse:{value:new zn(16777215)},opacity:{value:1},center:{value:new je(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Ze},alphaMap:{value:null},alphaMapTransform:{value:new Ze},alphaTest:{value:0}}},zc={basic:{uniforms:ws([Oc.common,Oc.specularmap,Oc.envmap,Oc.aomap,Oc.lightmap,Oc.fog]),vertexShader:kc.meshbasic_vert,fragmentShader:kc.meshbasic_frag},lambert:{uniforms:ws([Oc.common,Oc.specularmap,Oc.envmap,Oc.aomap,Oc.lightmap,Oc.emissivemap,Oc.bumpmap,Oc.normalmap,Oc.displacementmap,Oc.fog,Oc.lights,{emissive:{value:new zn(0)}}]),vertexShader:kc.meshlambert_vert,fragmentShader:kc.meshlambert_frag},phong:{uniforms:ws([Oc.common,Oc.specularmap,Oc.envmap,Oc.aomap,Oc.lightmap,Oc.emissivemap,Oc.bumpmap,Oc.normalmap,Oc.displacementmap,Oc.fog,Oc.lights,{emissive:{value:new zn(0)},specular:{value:new zn(1118481)},shininess:{value:30}}]),vertexShader:kc.meshphong_vert,fragmentShader:kc.meshphong_frag},standard:{uniforms:ws([Oc.common,Oc.envmap,Oc.aomap,Oc.lightmap,Oc.emissivemap,Oc.bumpmap,Oc.normalmap,Oc.displacementmap,Oc.roughnessmap,Oc.metalnessmap,Oc.fog,Oc.lights,{emissive:{value:new zn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:kc.meshphysical_vert,fragmentShader:kc.meshphysical_frag},toon:{uniforms:ws([Oc.common,Oc.aomap,Oc.lightmap,Oc.emissivemap,Oc.bumpmap,Oc.normalmap,Oc.displacementmap,Oc.gradientmap,Oc.fog,Oc.lights,{emissive:{value:new zn(0)}}]),vertexShader:kc.meshtoon_vert,fragmentShader:kc.meshtoon_frag},matcap:{uniforms:ws([Oc.common,Oc.bumpmap,Oc.normalmap,Oc.displacementmap,Oc.fog,{matcap:{value:null}}]),vertexShader:kc.meshmatcap_vert,fragmentShader:kc.meshmatcap_frag},points:{uniforms:ws([Oc.points,Oc.fog]),vertexShader:kc.points_vert,fragmentShader:kc.points_frag},dashed:{uniforms:ws([Oc.common,Oc.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:kc.linedashed_vert,fragmentShader:kc.linedashed_frag},depth:{uniforms:ws([Oc.common,Oc.displacementmap]),vertexShader:kc.depth_vert,fragmentShader:kc.depth_frag},normal:{uniforms:ws([Oc.common,Oc.bumpmap,Oc.normalmap,Oc.displacementmap,{opacity:{value:1}}]),vertexShader:kc.meshnormal_vert,fragmentShader:kc.meshnormal_frag},sprite:{uniforms:ws([Oc.sprite,Oc.fog]),vertexShader:kc.sprite_vert,fragmentShader:kc.sprite_frag},background:{uniforms:{uvTransform:{value:new Ze},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:kc.background_vert,fragmentShader:kc.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Ze}},vertexShader:kc.backgroundCube_vert,fragmentShader:kc.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:kc.cube_vert,fragmentShader:kc.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:kc.equirect_vert,fragmentShader:kc.equirect_frag},distanceRGBA:{uniforms:ws([Oc.common,Oc.displacementmap,{referencePosition:{value:new qe},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:kc.distanceRGBA_vert,fragmentShader:kc.distanceRGBA_frag},shadow:{uniforms:ws([Oc.lights,Oc.fog,{color:{value:new zn(0)},opacity:{value:1}}]),vertexShader:kc.shadow_vert,fragmentShader:kc.shadow_frag}};zc.physical={uniforms:ws([zc.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Ze},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Ze},clearcoatNormalScale:{value:new je(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Ze},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Ze},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Ze},sheen:{value:0},sheenColor:{value:new zn(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Ze},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Ze},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Ze},transmissionSamplerSize:{value:new je},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Ze},attenuationDistance:{value:0},attenuationColor:{value:new zn(0)},specularColor:{value:new zn(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Ze},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Ze},anisotropyVector:{value:new je},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Ze}}]),vertexShader:kc.meshphysical_vert,fragmentShader:kc.meshphysical_frag};const Fc={r:0,b:0,g:0},Uc=new tn,Nc=new Wi;function Gc(t,e,i,n,s,a,r){const o=new zn(0);let l,h,c=!0===a?0:1,u=null,d=0,p=null;function m(t){let n=!0===t.isScene?t.background:null;return n&&n.isTexture&&(n=(t.backgroundBlurriness>0?i:e).get(n)),n}function g(e,i){e.getRGB(Fc,Ss(t)),n.buffers.color.setClear(Fc.r,Fc.g,Fc.b,i,r)}return{getClearColor:function(){return o},setClearColor:function(t,e=1){o.set(t),c=e,g(o,c)},getClearAlpha:function(){return c},setClearAlpha:function(t){c=t,g(o,c)},render:function(e){let i=!1;const s=m(e);null===s?g(o,c):s&&s.isColor&&(g(s,1),i=!0);const a=t.xr.getEnvironmentBlendMode();"additive"===a?n.buffers.color.setClear(0,0,0,1,r):"alpha-blend"===a&&n.buffers.color.setClear(0,0,0,0,r),(t.autoClear||i)&&(n.buffers.depth.setTest(!0),n.buffers.depth.setMask(!0),n.buffers.color.setMask(!0),t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil))},addToRenderList:function(e,i){const n=m(i);n&&(n.isCubeTexture||n.mapping===U)?(void 0===h&&(h=new bs(new _s(1,1,1),new Cs({name:"BackgroundCubeMaterial",uniforms:xs(zc.backgroundCube.uniforms),vertexShader:zc.backgroundCube.vertexShader,fragmentShader:zc.backgroundCube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(t,e,i){this.matrixWorld.copyPosition(i.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(h)),Uc.copy(i.backgroundRotation),Uc.x*=-1,Uc.y*=-1,Uc.z*=-1,n.isCubeTexture&&!1===n.isRenderTargetTexture&&(Uc.y*=-1,Uc.z*=-1),h.material.uniforms.envMap.value=n,h.material.uniforms.flipEnvMap.value=n.isCubeTexture&&!1===n.isRenderTargetTexture?-1:1,h.material.uniforms.backgroundBlurriness.value=i.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=i.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(Nc.makeRotationFromEuler(Uc)),h.material.toneMapped=ei.getTransfer(n.colorSpace)!==oe,u===n&&d===n.version&&p===t.toneMapping||(h.material.needsUpdate=!0,u=n,d=n.version,p=t.toneMapping),h.layers.enableAll(),e.unshift(h,h.geometry,h.material,0,0,null)):n&&n.isTexture&&(void 0===l&&(l=new bs(new Jo(2,2),new Cs({name:"BackgroundMaterial",uniforms:xs(zc.background.uniforms),vertexShader:zc.background.vertexShader,fragmentShader:zc.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(l)),l.material.uniforms.t2D.value=n,l.material.uniforms.backgroundIntensity.value=i.backgroundIntensity,l.material.toneMapped=ei.getTransfer(n.colorSpace)!==oe,!0===n.matrixAutoUpdate&&n.updateMatrix(),l.material.uniforms.uvTransform.value.copy(n.matrix),u===n&&d===n.version&&p===t.toneMapping||(l.material.needsUpdate=!0,u=n,d=n.version,p=t.toneMapping),l.layers.enableAll(),e.unshift(l,l.geometry,l.material,0,0,null))},dispose:function(){void 0!==h&&(h.geometry.dispose(),h.material.dispose(),h=void 0),void 0!==l&&(l.geometry.dispose(),l.material.dispose(),l=void 0)}}}function Vc(t,e){const i=t.getParameter(t.MAX_VERTEX_ATTRIBS),n={},s=h(null);let a=s,r=!1;function o(e){return t.bindVertexArray(e)}function l(e){return t.deleteVertexArray(e)}function h(t){const e=[],n=[],s=[];for(let t=0;t<i;t++)e[t]=0,n[t]=0,s[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:s,object:t,attributes:{},index:null}}function c(){const t=a.newAttributes;for(let e=0,i=t.length;e<i;e++)t[e]=0}function u(t){d(t,0)}function d(e,i){const n=a.newAttributes,s=a.enabledAttributes,r=a.attributeDivisors;n[e]=1,0===s[e]&&(t.enableVertexAttribArray(e),s[e]=1),r[e]!==i&&(t.vertexAttribDivisor(e,i),r[e]=i)}function p(){const e=a.newAttributes,i=a.enabledAttributes;for(let n=0,s=i.length;n<s;n++)i[n]!==e[n]&&(t.disableVertexAttribArray(n),i[n]=0)}function m(e,i,n,s,a,r,o){!0===o?t.vertexAttribIPointer(e,i,n,a,r):t.vertexAttribPointer(e,i,n,s,a,r)}function g(){f(),r=!0,a!==s&&(a=s,o(a.object))}function f(){s.geometry=null,s.program=null,s.wireframe=!1}return{setup:function(i,s,l,g,f){let y=!1;const v=function(e,i,s){const a=!0===s.wireframe;let r=n[e.id];void 0===r&&(r={},n[e.id]=r);let o=r[i.id];void 0===o&&(o={},r[i.id]=o);let l=o[a];return void 0===l&&(l=h(t.createVertexArray()),o[a]=l),l}(g,l,s);a!==v&&(a=v,o(a.object)),y=function(t,e,i,n){const s=a.attributes,r=e.attributes;let o=0;const l=i.getAttributes();for(const e in l)if(l[e].location>=0){const i=s[e];let n=r[e];if(void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor)),void 0===i)return!0;if(i.attribute!==n)return!0;if(n&&i.data!==n.data)return!0;o++}return a.attributesNum!==o||a.index!==n}(i,g,l,f),y&&function(t,e,i,n){const s={},r=e.attributes;let o=0;const l=i.getAttributes();for(const e in l)if(l[e].location>=0){let i=r[e];void 0===i&&("instanceMatrix"===e&&t.instanceMatrix&&(i=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(i=t.instanceColor));const n={};n.attribute=i,i&&i.data&&(n.data=i.data),s[e]=n,o++}a.attributes=s,a.attributesNum=o,a.index=n}(i,g,l,f),null!==f&&e.update(f,t.ELEMENT_ARRAY_BUFFER),(y||r)&&(r=!1,function(i,n,s,a){c();const r=a.attributes,o=s.getAttributes(),l=n.defaultAttributeValues;for(const n in o){const s=o[n];if(s.location>=0){let o=r[n];if(void 0===o&&("instanceMatrix"===n&&i.instanceMatrix&&(o=i.instanceMatrix),"instanceColor"===n&&i.instanceColor&&(o=i.instanceColor)),void 0!==o){const n=o.normalized,r=o.itemSize,l=e.get(o);if(void 0===l)continue;const h=l.buffer,c=l.type,p=l.bytesPerElement,g=c===t.INT||c===t.UNSIGNED_INT||o.gpuType===K;if(o.isInterleavedBufferAttribute){const e=o.data,l=e.stride,f=o.offset;if(e.isInstancedInterleavedBuffer){for(let t=0;t<s.locationSize;t++)d(s.location+t,e.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=e.meshPerAttribute*e.count)}else for(let t=0;t<s.locationSize;t++)u(s.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<s.locationSize;t++)m(s.location+t,r/s.locationSize,c,n,l*p,(f+r/s.locationSize*t)*p,g)}else{if(o.isInstancedBufferAttribute){for(let t=0;t<s.locationSize;t++)d(s.location+t,o.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=o.meshPerAttribute*o.count)}else for(let t=0;t<s.locationSize;t++)u(s.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<s.locationSize;t++)m(s.location+t,r/s.locationSize,c,n,r*p,r/s.locationSize*t*p,g)}}else if(void 0!==l){const e=l[n];if(void 0!==e)switch(e.length){case 2:t.vertexAttrib2fv(s.location,e);break;case 3:t.vertexAttrib3fv(s.location,e);break;case 4:t.vertexAttrib4fv(s.location,e);break;default:t.vertexAttrib1fv(s.location,e)}}}}p()}(i,s,l,g),null!==f&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.get(f).buffer))},reset:g,resetDefaultState:f,dispose:function(){g();for(const t in n){const e=n[t];for(const t in e){const i=e[t];for(const t in i)l(i[t].object),delete i[t];delete e[t]}delete n[t]}},releaseStatesOfGeometry:function(t){if(void 0===n[t.id])return;const e=n[t.id];for(const t in e){const i=e[t];for(const t in i)l(i[t].object),delete i[t];delete e[t]}delete n[t.id]},releaseStatesOfProgram:function(t){for(const e in n){const i=n[e];if(void 0===i[t.id])continue;const s=i[t.id];for(const t in s)l(s[t].object),delete s[t];delete i[t.id]}},initAttributes:c,enableAttribute:u,disableUnusedAttributes:p}}function Hc(t,e,i){let n;function s(e,s,a){0!==a&&(t.drawArraysInstanced(n,e,s,a),i.update(s,n,a))}this.setMode=function(t){n=t},this.render=function(e,s){t.drawArrays(n,e,s),i.update(s,n,1)},this.renderInstances=s,this.renderMultiDraw=function(t,s,a){if(0===a)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,t,0,s,0,a);let r=0;for(let t=0;t<a;t++)r+=s[t];i.update(r,n,1)},this.renderMultiDrawInstances=function(t,a,r,o){if(0===r)return;const l=e.get("WEBGL_multi_draw");if(null===l)for(let e=0;e<t.length;e++)s(t[e],a[e],o[e]);else{l.multiDrawArraysInstancedWEBGL(n,t,0,a,0,o,0,r);let e=0;for(let t=0;t<r;t++)e+=a[t]*o[t];i.update(e,n,1)}}}function Wc(t,e,i,n){let s;function a(e){if("highp"===e){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let r=void 0!==i.precision?i.precision:"highp";const o=a(r);o!==r&&(De("WebGLRenderer:",r,"not supported, using",o,"instead."),r=o);const l=!0===i.logarithmicDepthBuffer,h=!0===i.reversedDepthBuffer&&e.has("EXT_clip_control"),c=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),u=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);return{isWebGL2:!0,getMaxAnisotropy:function(){if(void 0!==s)return s;if(!0===e.has("EXT_texture_filter_anisotropic")){const i=e.get("EXT_texture_filter_anisotropic");s=t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s},getMaxPrecision:a,textureFormatReadable:function(e){return e===ct||n.convert(e)===t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)},textureTypeReadable:function(i){const s=i===it&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(i!==$&&n.convert(i)!==t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE)&&i!==et&&!s)},precision:r,logarithmicDepthBuffer:l,reversedDepthBuffer:h,maxTextures:c,maxVertexTextures:u,maxTextureSize:t.getParameter(t.MAX_TEXTURE_SIZE),maxCubemapSize:t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes:t.getParameter(t.MAX_VERTEX_ATTRIBS),maxVertexUniforms:t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings:t.getParameter(t.MAX_VARYING_VECTORS),maxFragmentUniforms:t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures:u>0,maxSamples:t.getParameter(t.MAX_SAMPLES)}}function jc(t){const e=this;let i=null,n=0,s=!1,a=!1;const r=new za,o=new Ze,l={value:null,needsUpdate:!1};function h(t,i,n,s){const a=null!==t?t.length:0;let h=null;if(0!==a){if(h=l.value,!0!==s||null===h){const e=n+4*a,s=i.matrixWorldInverse;o.getNormalMatrix(s),(null===h||h.length<e)&&(h=new Float32Array(e));for(let e=0,i=n;e!==a;++e,i+=4)r.copy(t[e]).applyMatrix4(s,o),r.normal.toArray(h,i),h[i+3]=r.constant}l.value=h,l.needsUpdate=!0}return e.numPlanes=a,e.numIntersection=0,h}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e){const i=0!==t.length||e||0!==n||s;return s=e,n=t.length,i},this.beginShadows=function(){a=!0,h(null)},this.endShadows=function(){a=!1},this.setGlobalState=function(t,e){i=h(t,e,0)},this.setState=function(r,o,c){const u=r.clippingPlanes,d=r.clipIntersection,p=r.clipShadows,m=t.get(r);if(!s||null===u||0===u.length||a&&!p)a?h(null):(l.value!==i&&(l.value=i,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0);else{const t=a?0:n,e=4*t;let s=m.clippingState||null;l.value=s,s=h(u,o,e,c);for(let t=0;t!==e;++t)s[t]=i[t];m.clippingState=s,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function Xc(t){let e=new WeakMap;function i(t,e){return e===z?t.mapping=k:e===F&&(t.mapping=O),t}function n(t){const i=t.target;i.removeEventListener("dispose",n);const s=e.get(i);void 0!==s&&(e.delete(i),s.dispose())}return{get:function(s){if(s&&s.isTexture){const a=s.mapping;if(a===z||a===F){if(e.has(s))return i(e.get(s).texture,s.mapping);{const a=s.image;if(a&&a.height>0){const r=new ks(a.height);return r.fromEquirectangularTexture(t,s),e.set(s,r),s.addEventListener("dispose",n),i(r.texture,s.mapping)}return null}}}return s},dispose:function(){e=new WeakMap}}}const qc=[.125,.215,.35,.446,.526,.582],Yc=new hh,$c=new zn;let Zc=null,Jc=0,Qc=0,Kc=!1;const tu=new qe;class eu{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._backgroundBox=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._blurMaterial=null,this._ggxMaterial=null}fromScene(t,e=0,i=.1,n=100,s={}){const{size:a=256,position:r=tu}=s;Zc=this._renderer.getRenderTarget(),Jc=this._renderer.getActiveCubeFace(),Qc=this._renderer.getActiveMipmapLevel(),Kc=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(a);const o=this._allocateTargets();return o.depthBuffer=!0,this._sceneToCubeUV(t,i,n,o,r),e>0&&this._blur(o,0,0,e),this._applyPMREM(o),this._cleanup(o),o}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=au(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=su(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose(),null!==this._backgroundBox&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._ggxMaterial&&this._ggxMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodMeshes.length;t++)this._lodMeshes[t].geometry.dispose()}_cleanup(t){this._renderer.setRenderTarget(Zc,Jc,Qc),this._renderer.xr.enabled=Kc,t.scissorTest=!1,nu(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===k||t.mapping===O?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),Zc=this._renderer.getRenderTarget(),Jc=this._renderer.getActiveCubeFace(),Qc=this._renderer.getActiveMipmapLevel(),Kc=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const i=e||this._allocateTargets();return this._textureToCubeUV(t,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,i={magFilter:X,minFilter:X,generateMipmaps:!1,type:it,format:ct,colorSpace:ae,depthBuffer:!1},n=iu(t,e,i);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=iu(t,e,i);const{_lodMax:n}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=function(t){const e=[],i=[],n=[];let s=t;const a=t-4+1+qc.length;for(let r=0;r<a;r++){const a=Math.pow(2,s);e.push(a);let o=1/a;r>t-4?o=qc[r-t+4-1]:0===r&&(o=0),i.push(o);const l=1/(a-2),h=-l,c=1+l,u=[h,h,c,h,c,c,h,h,c,c,h,c],d=6,p=6,m=3,g=2,f=1,y=new Float32Array(m*p*d),v=new Float32Array(g*p*d),b=new Float32Array(f*p*d);for(let t=0;t<d;t++){const e=t%3*2/3-1,i=t>2?0:-1,n=[e,i,0,e+2/3,i,0,e+2/3,i+1,0,e,i,0,e+2/3,i+1,0,e,i+1,0];y.set(n,m*p*t),v.set(u,g*p*t);const s=[t,t,t,t,t,t];b.set(s,f*p*t)}const M=new os;M.setAttribute("position",new Zn(y,m)),M.setAttribute("uv",new Zn(v,g)),M.setAttribute("faceIndex",new Zn(b,f)),n.push(new bs(M,null)),s>4&&s--}return{lodMeshes:n,sizeLods:e,sigmas:i}}(n)),this._blurMaterial=function(t,e,i){const n=new Float32Array(20),s=new qe(0,1,0);return new Cs({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/i,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}(n,t,e)}return n}_compileMaterial(t){const e=new bs(new os,t);this._renderer.compile(e,Yc)}_sceneToCubeUV(t,e,i,n,s){const a=new Rs(90,1,e,i),r=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],l=this._renderer,h=l.autoClear,c=l.toneMapping;l.getClearColor($c),l.toneMapping=0,l.autoClear=!1,l.state.buffers.depth.getReversed()&&(l.setRenderTarget(n),l.clearDepth(),l.setRenderTarget(null)),null===this._backgroundBox&&(this._backgroundBox=new bs(new _s,new Gn({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1})));const u=this._backgroundBox,d=u.material;let p=!1;const m=t.background;m?m.isColor&&(d.color.copy(m),t.background=null,p=!0):(d.color.copy($c),p=!0);for(let e=0;e<6;e++){const i=e%3;0===i?(a.up.set(0,r[e],0),a.position.set(s.x,s.y,s.z),a.lookAt(s.x+o[e],s.y,s.z)):1===i?(a.up.set(0,0,r[e]),a.position.set(s.x,s.y,s.z),a.lookAt(s.x,s.y+o[e],s.z)):(a.up.set(0,r[e],0),a.position.set(s.x,s.y,s.z),a.lookAt(s.x,s.y,s.z+o[e]));const h=this._cubeSize;nu(n,i*h,e>2?h:0,h,h),l.setRenderTarget(n),p&&l.render(u,a),l.render(t,a)}l.toneMapping=c,l.autoClear=h,t.background=m}_textureToCubeUV(t,e){const i=this._renderer,n=t.mapping===k||t.mapping===O;n?(null===this._cubemapMaterial&&(this._cubemapMaterial=au()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=su());const s=n?this._cubemapMaterial:this._equirectMaterial,a=this._lodMeshes[0];a.material=s,s.uniforms.envMap.value=t;const r=this._cubeSize;nu(e,0,0,3*r,2*r),i.setRenderTarget(e),i.render(a,Yc)}_applyPMREM(t){const e=this._renderer,i=e.autoClear;e.autoClear=!1;const n=this._lodMeshes.length;for(let e=1;e<n;e++)this._applyGGXFilter(t,e-1,e);e.autoClear=i}_applyGGXFilter(t,e,i){const n=this._renderer,s=this._pingPongRenderTarget;if(null===this._ggxMaterial){const t=3*Math.max(this._cubeSize,16),e=4*this._cubeSize;this._ggxMaterial=function(t,e,i){return new Cs({name:"PMREMGGXConvolution",defines:{GGX_SAMPLES:512,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/i,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},roughness:{value:0},mipInt:{value:0}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:'\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform float roughness;\n\t\t\tuniform float mipInt;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t#define PI 3.14159265359\n\n\t\t\t// Van der Corput radical inverse\n\t\t\tfloat radicalInverse_VdC(uint bits) {\n\t\t\t\tbits = (bits << 16u) | (bits >> 16u);\n\t\t\t\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\t\t\t\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\t\t\t\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\t\t\t\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\t\t\t\treturn float(bits) * 2.3283064365386963e-10; // / 0x100000000\n\t\t\t}\n\n\t\t\t// Hammersley sequence\n\t\t\tvec2 hammersley(uint i, uint N) {\n\t\t\t\treturn vec2(float(i) / float(N), radicalInverse_VdC(i));\n\t\t\t}\n\n\t\t\t// GGX VNDF importance sampling (Eric Heitz 2018)\n\t\t\t// "Sampling the GGX Distribution of Visible Normals"\n\t\t\t// https://jcgt.org/published/0007/04/01/\n\t\t\tvec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {\n\t\t\t\tfloat alpha = roughness * roughness;\n\n\t\t\t\t// Section 3.2: Transform view direction to hemisphere configuration\n\t\t\t\tvec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));\n\n\t\t\t\t// Section 4.1: Orthonormal basis\n\t\t\t\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\t\t\t\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 T2 = cross(Vh, T1);\n\n\t\t\t\t// Section 4.2: Parameterization of projected area\n\t\t\t\tfloat r = sqrt(Xi.x);\n\t\t\t\tfloat phi = 2.0 * PI * Xi.y;\n\t\t\t\tfloat t1 = r * cos(phi);\n\t\t\t\tfloat t2 = r * sin(phi);\n\t\t\t\tfloat s = 0.5 * (1.0 + Vh.z);\n\t\t\t\tt2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n\t\t\t\t// Section 4.3: Reprojection onto hemisphere\n\t\t\t\tvec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n\t\t\t\t// Section 3.4: Transform back to ellipsoid configuration\n\t\t\t\treturn normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));\n\t\t\t}\n\n\t\t\tvoid main() {\n\t\t\t\tvec3 N = normalize(vOutputDirection);\n\t\t\t\tvec3 V = N; // Assume view direction equals normal for pre-filtering\n\n\t\t\t\tvec3 prefilteredColor = vec3(0.0);\n\t\t\t\tfloat totalWeight = 0.0;\n\n\t\t\t\t// For very low roughness, just sample the environment directly\n\t\t\t\tif (roughness < 0.001) {\n\t\t\t\t\tgl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Tangent space basis for VNDF sampling\n\t\t\t\tvec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 tangent = normalize(cross(up, N));\n\t\t\t\tvec3 bitangent = cross(N, tangent);\n\n\t\t\t\tfor(uint i = 0u; i < uint(GGX_SAMPLES); i++) {\n\t\t\t\t\tvec2 Xi = hammersley(i, uint(GGX_SAMPLES));\n\n\t\t\t\t\t// For PMREM, V = N, so in tangent space V is always (0, 0, 1)\n\t\t\t\t\tvec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);\n\n\t\t\t\t\t// Transform H back to world space\n\t\t\t\t\tvec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);\n\t\t\t\t\tvec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n\t\t\t\t\tfloat NdotL = max(dot(N, L), 0.0);\n\n\t\t\t\t\tif(NdotL > 0.0) {\n\t\t\t\t\t\t// Sample environment at fixed mip level\n\t\t\t\t\t\t// VNDF importance sampling handles the distribution filtering\n\t\t\t\t\t\tvec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);\n\n\t\t\t\t\t\t// Weight by NdotL for the split-sum approximation\n\t\t\t\t\t\t// VNDF PDF naturally accounts for the visible microfacet distribution\n\t\t\t\t\t\tprefilteredColor += sampleColor * NdotL;\n\t\t\t\t\t\ttotalWeight += NdotL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (totalWeight > 0.0) {\n\t\t\t\t\tprefilteredColor = prefilteredColor / totalWeight;\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = vec4(prefilteredColor, 1.0);\n\t\t\t}\n\t\t',blending:0,depthTest:!1,depthWrite:!1})}(this._lodMax,t,e)}const a=this._ggxMaterial,r=this._lodMeshes[i];r.material=a;const o=a.uniforms,l=i/(this._lodMeshes.length-1),h=e/(this._lodMeshes.length-1),c=Math.sqrt(l*l-h*h)*(.05+.95*l),{_lodMax:u}=this,d=this._sizeLods[i],p=3*d*(i>u-4?i-u+4:0),m=4*(this._cubeSize-d);o.envMap.value=t.texture,o.roughness.value=c,o.mipInt.value=u-e,nu(s,p,m,3*d,2*d),n.setRenderTarget(s),n.render(r,Yc),o.envMap.value=s.texture,o.roughness.value=0,o.mipInt.value=u-i,nu(t,p,m,3*d,2*d),n.setRenderTarget(t),n.render(r,Yc)}_blur(t,e,i,n,s){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,i,n,"latitudinal",s),this._halfBlur(a,t,i,i,n,"longitudinal",s)}_halfBlur(t,e,i,n,s,a,r){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&Re("blur direction must be either latitudinal or longitudinal!");const h=this._lodMeshes[n];h.material=l;const c=l.uniforms,u=this._sizeLods[i]-1,d=isFinite(s)?Math.PI/(2*u):2*Math.PI/39,p=s/d,m=isFinite(s)?1+Math.floor(3*p):20;m>20&&De(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);const g=[];let f=0;for(let t=0;t<20;++t){const e=t/p,i=Math.exp(-e*e/2);g.push(i),0===t?f+=i:t<m&&(f+=2*i)}for(let t=0;t<g.length;t++)g[t]=g[t]/f;c.envMap.value=t.texture,c.samples.value=m,c.weights.value=g,c.latitudinal.value="latitudinal"===a,r&&(c.poleAxis.value=r);const{_lodMax:y}=this;c.dTheta.value=d,c.mipInt.value=y-i;const v=this._sizeLods[n];nu(e,3*v*(n>y-4?n-y+4:0),4*(this._cubeSize-v),3*v,2*v),o.setRenderTarget(e),o.render(h,Yc)}}function iu(t,e,i){const n=new mi(t,e,i);return n.texture.mapping=U,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function nu(t,e,i,n,s){t.viewport.set(e,i,n,s),t.scissor.set(e,i,n,s)}function su(){return new Cs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function au(){return new Cs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function ru(t){let e=new WeakMap,i=null;function n(t){const i=t.target;i.removeEventListener("dispose",n);const s=e.get(i);void 0!==s&&(e.delete(i),s.dispose())}return{get:function(s){if(s&&s.isTexture){const a=s.mapping,r=a===z||a===F,o=a===k||a===O;if(r||o){let a=e.get(s);const l=void 0!==a?a.texture.pmremVersion:0;if(s.isRenderTargetTexture&&s.pmremVersion!==l)return null===i&&(i=new eu(t)),a=r?i.fromEquirectangular(s,a):i.fromCubemap(s,a),a.texture.pmremVersion=s.pmremVersion,e.set(s,a),a.texture;if(void 0!==a)return a.texture;{const l=s.image;return r&&l&&l.height>0||o&&l&&function(t){let e=0;for(let i=0;i<6;i++)void 0!==t[i]&&e++;return 6===e}(l)?(null===i&&(i=new eu(t)),a=r?i.fromEquirectangular(s):i.fromCubemap(s),a.texture.pmremVersion=s.pmremVersion,e.set(s,a),s.addEventListener("dispose",n),a.texture):null}}}return s},dispose:function(){e=new WeakMap,null!==i&&(i.dispose(),i=null)}}}function ou(t){const e={};function i(i){if(void 0!==e[i])return e[i];const n=t.getExtension(i);return e[i]=n,n}return{has:function(t){return null!==i(t)},init:function(){i("EXT_color_buffer_float"),i("WEBGL_clip_cull_distance"),i("OES_texture_float_linear"),i("EXT_color_buffer_half_float"),i("WEBGL_multisampled_render_to_texture"),i("WEBGL_render_shared_exponent")},get:function(t){const e=i(t);return null===e&&Ie("WebGLRenderer: "+t+" extension not supported."),e}}}function lu(t,e,i,n){const s={},a=new WeakMap;function r(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);o.removeEventListener("dispose",r),delete s[o.id];const l=a.get(o);l&&(e.remove(l),a.delete(o)),n.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,i.memory.geometries--}function o(t){const i=[],n=t.index,s=t.attributes.position;let r=0;if(null!==n){const t=n.array;r=n.version;for(let e=0,n=t.length;e<n;e+=3){const n=t[e+0],s=t[e+1],a=t[e+2];i.push(n,s,s,a,a,n)}}else{if(void 0===s)return;{const t=s.array;r=s.version;for(let e=0,n=t.length/3-1;e<n;e+=3){const t=e+0,n=e+1,s=e+2;i.push(t,n,n,s,s,t)}}}const o=new(xe(i)?Qn:Jn)(i,1);o.version=r;const l=a.get(t);l&&e.remove(l),a.set(t,o)}return{get:function(t,e){return!0===s[e.id]||(e.addEventListener("dispose",r),s[e.id]=!0,i.memory.geometries++),e},update:function(i){const n=i.attributes;for(const i in n)e.update(n[i],t.ARRAY_BUFFER)},getWireframeAttribute:function(t){const e=a.get(t);if(e){const i=t.index;null!==i&&e.version<i.version&&o(t)}else o(t);return a.get(t)}}}function hu(t,e,i){let n,s,a;function r(e,r,o){0!==o&&(t.drawElementsInstanced(n,r,s,e*a,o),i.update(r,n,o))}this.setMode=function(t){n=t},this.setIndex=function(t){s=t.type,a=t.bytesPerElement},this.render=function(e,r){t.drawElements(n,r,s,e*a),i.update(r,n,1)},this.renderInstances=r,this.renderMultiDraw=function(t,a,r){if(0===r)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,a,0,s,t,0,r);let o=0;for(let t=0;t<r;t++)o+=a[t];i.update(o,n,1)},this.renderMultiDrawInstances=function(t,o,l,h){if(0===l)return;const c=e.get("WEBGL_multi_draw");if(null===c)for(let e=0;e<t.length;e++)r(t[e]/a,o[e],h[e]);else{c.multiDrawElementsInstancedWEBGL(n,o,0,s,t,0,h,0,l);let e=0;for(let t=0;t<l;t++)e+=o[t]*h[t];i.update(e,n,1)}}}function cu(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(i,n,s){switch(e.calls++,n){case t.TRIANGLES:e.triangles+=s*(i/3);break;case t.LINES:e.lines+=s*(i/2);break;case t.LINE_STRIP:e.lines+=s*(i-1);break;case t.LINE_LOOP:e.lines+=s*i;break;case t.POINTS:e.points+=s*i;break;default:Re("WebGLInfo: Unknown draw mode:",n)}}}}function uu(t,e,i){const n=new WeakMap,s=new di;return{update:function(a,r,o){const l=a.morphTargetInfluences,h=r.morphAttributes.position||r.morphAttributes.normal||r.morphAttributes.color,c=void 0!==h?h.length:0;let u=n.get(r);if(void 0===u||u.count!==c){void 0!==u&&u.texture.dispose();const d=void 0!==r.morphAttributes.position,p=void 0!==r.morphAttributes.normal,m=void 0!==r.morphAttributes.color,g=r.morphAttributes.position||[],f=r.morphAttributes.normal||[],y=r.morphAttributes.color||[];let v=0;!0===d&&(v=1),!0===p&&(v=2),!0===m&&(v=3);let b=r.attributes.position.count*v,M=1;b>e.maxTextureSize&&(M=Math.ceil(b/e.maxTextureSize),b=e.maxTextureSize);const _=new Float32Array(b*M*4*c),x=new gi(_,b,M,c);x.type=et,x.needsUpdate=!0;const w=4*v;for(let T=0;T<c;T++){const C=g[T],E=f[T],A=y[T],P=b*M*4*T;for(let D=0;D<C.count;D++){const R=D*w;!0===d&&(s.fromBufferAttribute(C,D),_[P+R+0]=s.x,_[P+R+1]=s.y,_[P+R+2]=s.z,_[P+R+3]=0),!0===p&&(s.fromBufferAttribute(E,D),_[P+R+4]=s.x,_[P+R+5]=s.y,_[P+R+6]=s.z,_[P+R+7]=0),!0===m&&(s.fromBufferAttribute(A,D),_[P+R+8]=s.x,_[P+R+9]=s.y,_[P+R+10]=s.z,_[P+R+11]=4===A.itemSize?s.w:1)}}function S(){x.dispose(),n.delete(r),r.removeEventListener("dispose",S)}u={count:c,texture:x,size:new je(b,M)},n.set(r,u),r.addEventListener("dispose",S)}if(!0===a.isInstancedMesh&&null!==a.morphTexture)o.getUniforms().setValue(t,"morphTexture",a.morphTexture,i);else{let I=0;for(let L=0;L<l.length;L++)I+=l[L];const B=r.morphTargetsRelative?1:1-I;o.getUniforms().setValue(t,"morphTargetBaseInfluence",B),o.getUniforms().setValue(t,"morphTargetInfluences",l)}o.getUniforms().setValue(t,"morphTargetsTexture",u.texture,i),o.getUniforms().setValue(t,"morphTargetsTextureSize",u.size)}}}function du(t,e,i,n){let s=new WeakMap;function a(t){const e=t.target;e.removeEventListener("dispose",a),i.remove(e.instanceMatrix),null!==e.instanceColor&&i.remove(e.instanceColor)}return{update:function(r){const o=n.render.frame,l=r.geometry,h=e.get(r,l);if(s.get(h)!==o&&(e.update(h),s.set(h,o)),r.isInstancedMesh&&(!1===r.hasEventListener("dispose",a)&&r.addEventListener("dispose",a),s.get(r)!==o&&(i.update(r.instanceMatrix,t.ARRAY_BUFFER),null!==r.instanceColor&&i.update(r.instanceColor,t.ARRAY_BUFFER),s.set(r,o))),r.isSkinnedMesh){const t=r.skeleton;s.get(t)!==o&&(t.update(),s.set(t,o))}return h},dispose:function(){s=new WeakMap}}}const pu=new ui,mu=new Lr(1,1),gu=new gi,fu=new fi,yu=new Ls,vu=[],bu=[],Mu=new Float32Array(16),_u=new Float32Array(9),xu=new Float32Array(4);function wu(t,e,i){const n=t[0];if(n<=0||n>0)return t;const s=e*i;let a=vu[s];if(void 0===a&&(a=new Float32Array(s),vu[s]=a),0!==e){n.toArray(a,0);for(let n=1,s=0;n!==e;++n)s+=i,t[n].toArray(a,s)}return a}function Su(t,e){if(t.length!==e.length)return!1;for(let i=0,n=t.length;i<n;i++)if(t[i]!==e[i])return!1;return!0}function Tu(t,e){for(let i=0,n=e.length;i<n;i++)t[i]=e[i]}function Cu(t,e){let i=bu[e];void 0===i&&(i=new Int32Array(e),bu[e]=i);for(let n=0;n!==e;++n)i[n]=t.allocateTextureUnit();return i}function Eu(t,e){const i=this.cache;i[0]!==e&&(t.uniform1f(this.addr,e),i[0]=e)}function Au(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(Su(i,e))return;t.uniform2fv(this.addr,e),Tu(i,e)}}function Pu(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else if(void 0!==e.r)i[0]===e.r&&i[1]===e.g&&i[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),i[0]=e.r,i[1]=e.g,i[2]=e.b);else{if(Su(i,e))return;t.uniform3fv(this.addr,e),Tu(i,e)}}function Du(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z&&i[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(Su(i,e))return;t.uniform4fv(this.addr,e),Tu(i,e)}}function Ru(t,e){const i=this.cache,n=e.elements;if(void 0===n){if(Su(i,e))return;t.uniformMatrix2fv(this.addr,!1,e),Tu(i,e)}else{if(Su(i,n))return;xu.set(n),t.uniformMatrix2fv(this.addr,!1,xu),Tu(i,n)}}function Iu(t,e){const i=this.cache,n=e.elements;if(void 0===n){if(Su(i,e))return;t.uniformMatrix3fv(this.addr,!1,e),Tu(i,e)}else{if(Su(i,n))return;_u.set(n),t.uniformMatrix3fv(this.addr,!1,_u),Tu(i,n)}}function Bu(t,e){const i=this.cache,n=e.elements;if(void 0===n){if(Su(i,e))return;t.uniformMatrix4fv(this.addr,!1,e),Tu(i,e)}else{if(Su(i,n))return;Mu.set(n),t.uniformMatrix4fv(this.addr,!1,Mu),Tu(i,n)}}function Lu(t,e){const i=this.cache;i[0]!==e&&(t.uniform1i(this.addr,e),i[0]=e)}function ku(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y||(t.uniform2i(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(Su(i,e))return;t.uniform2iv(this.addr,e),Tu(i,e)}}function Ou(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z||(t.uniform3i(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else{if(Su(i,e))return;t.uniform3iv(this.addr,e),Tu(i,e)}}function zu(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z&&i[3]===e.w||(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(Su(i,e))return;t.uniform4iv(this.addr,e),Tu(i,e)}}function Fu(t,e){const i=this.cache;i[0]!==e&&(t.uniform1ui(this.addr,e),i[0]=e)}function Uu(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y||(t.uniform2ui(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(Su(i,e))return;t.uniform2uiv(this.addr,e),Tu(i,e)}}function Nu(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z||(t.uniform3ui(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else{if(Su(i,e))return;t.uniform3uiv(this.addr,e),Tu(i,e)}}function Gu(t,e){const i=this.cache;if(void 0!==e.x)i[0]===e.x&&i[1]===e.y&&i[2]===e.z&&i[3]===e.w||(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(Su(i,e))return;t.uniform4uiv(this.addr,e),Tu(i,e)}}function Vu(t,e,i){const n=this.cache,s=i.allocateTextureUnit();let a;n[0]!==s&&(t.uniform1i(this.addr,s),n[0]=s),this.type===t.SAMPLER_2D_SHADOW?(mu.compareFunction=515,a=mu):a=pu,i.setTexture2D(e||a,s)}function Hu(t,e,i){const n=this.cache,s=i.allocateTextureUnit();n[0]!==s&&(t.uniform1i(this.addr,s),n[0]=s),i.setTexture3D(e||fu,s)}function Wu(t,e,i){const n=this.cache,s=i.allocateTextureUnit();n[0]!==s&&(t.uniform1i(this.addr,s),n[0]=s),i.setTextureCube(e||yu,s)}function ju(t,e,i){const n=this.cache,s=i.allocateTextureUnit();n[0]!==s&&(t.uniform1i(this.addr,s),n[0]=s),i.setTexture2DArray(e||gu,s)}function Xu(t,e){t.uniform1fv(this.addr,e)}function qu(t,e){const i=wu(e,this.size,2);t.uniform2fv(this.addr,i)}function Yu(t,e){const i=wu(e,this.size,3);t.uniform3fv(this.addr,i)}function $u(t,e){const i=wu(e,this.size,4);t.uniform4fv(this.addr,i)}function Zu(t,e){const i=wu(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,i)}function Ju(t,e){const i=wu(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,i)}function Qu(t,e){const i=wu(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,i)}function Ku(t,e){t.uniform1iv(this.addr,e)}function td(t,e){t.uniform2iv(this.addr,e)}function ed(t,e){t.uniform3iv(this.addr,e)}function id(t,e){t.uniform4iv(this.addr,e)}function nd(t,e){t.uniform1uiv(this.addr,e)}function sd(t,e){t.uniform2uiv(this.addr,e)}function ad(t,e){t.uniform3uiv(this.addr,e)}function rd(t,e){t.uniform4uiv(this.addr,e)}function od(t,e,i){const n=this.cache,s=e.length,a=Cu(i,s);Su(n,a)||(t.uniform1iv(this.addr,a),Tu(n,a));for(let t=0;t!==s;++t)i.setTexture2D(e[t]||pu,a[t])}function ld(t,e,i){const n=this.cache,s=e.length,a=Cu(i,s);Su(n,a)||(t.uniform1iv(this.addr,a),Tu(n,a));for(let t=0;t!==s;++t)i.setTexture3D(e[t]||fu,a[t])}function hd(t,e,i){const n=this.cache,s=e.length,a=Cu(i,s);Su(n,a)||(t.uniform1iv(this.addr,a),Tu(n,a));for(let t=0;t!==s;++t)i.setTextureCube(e[t]||yu,a[t])}function cd(t,e,i){const n=this.cache,s=e.length,a=Cu(i,s);Su(n,a)||(t.uniform1iv(this.addr,a),Tu(n,a));for(let t=0;t!==s;++t)i.setTexture2DArray(e[t]||gu,a[t])}class ud{constructor(t,e,i){this.id=t,this.addr=i,this.cache=[],this.type=e.type,this.setValue=function(t){switch(t){case 5126:return Eu;case 35664:return Au;case 35665:return Pu;case 35666:return Du;case 35674:return Ru;case 35675:return Iu;case 35676:return Bu;case 5124:case 35670:return Lu;case 35667:case 35671:return ku;case 35668:case 35672:return Ou;case 35669:case 35673:return zu;case 5125:return Fu;case 36294:return Uu;case 36295:return Nu;case 36296:return Gu;case 35678:case 36198:case 36298:case 36306:case 35682:return Vu;case 35679:case 36299:case 36307:return Hu;case 35680:case 36300:case 36308:case 36293:return Wu;case 36289:case 36303:case 36311:case 36292:return ju}}(e.type)}}class dd{constructor(t,e,i){this.id=t,this.addr=i,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Xu;case 35664:return qu;case 35665:return Yu;case 35666:return $u;case 35674:return Zu;case 35675:return Ju;case 35676:return Qu;case 5124:case 35670:return Ku;case 35667:case 35671:return td;case 35668:case 35672:return ed;case 35669:case 35673:return id;case 5125:return nd;case 36294:return sd;case 36295:return ad;case 36296:return rd;case 35678:case 36198:case 36298:case 36306:case 35682:return od;case 35679:case 36299:case 36307:return ld;case 35680:case 36300:case 36308:case 36293:return hd;case 36289:case 36303:case 36311:case 36292:return cd}}(e.type)}}class pd{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,i){const n=this.seq;for(let s=0,a=n.length;s!==a;++s){const a=n[s];a.setValue(t,e[a.id],i)}}}const md=/(\w+)(\])?(\[|\.)?/g;function gd(t,e){t.seq.push(e),t.map[e.id]=e}function fd(t,e,i){const n=t.name,s=n.length;for(md.lastIndex=0;;){const a=md.exec(n),r=md.lastIndex;let o=a[1];const l="]"===a[2],h=a[3];if(l&&(o|=0),void 0===h||"["===h&&r+2===s){gd(i,void 0===h?new ud(o,t,e):new dd(o,t,e));break}{let t=i.map[o];void 0===t&&(t=new pd(o),gd(i,t)),i=t}}}class yd{constructor(t,e){this.seq=[],this.map={};const i=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let n=0;n<i;++n){const i=t.getActiveUniform(e,n);fd(i,t.getUniformLocation(e,i.name),this)}}setValue(t,e,i,n){const s=this.map[e];void 0!==s&&s.setValue(t,i,n)}setOptional(t,e,i){const n=e[i];void 0!==n&&this.setValue(t,i,n)}static upload(t,e,i,n){for(let s=0,a=e.length;s!==a;++s){const a=e[s],r=i[a.id];!1!==r.needsUpdate&&a.setValue(t,r.value,n)}}static seqWithValue(t,e){const i=[];for(let n=0,s=t.length;n!==s;++n){const s=t[n];s.id in e&&i.push(s)}return i}}function vd(t,e,i){const n=t.createShader(e);return t.shaderSource(n,i),t.compileShader(n),n}let bd=0;const Md=new Ze;function _d(t,e,i){const n=t.getShaderParameter(e,t.COMPILE_STATUS),s=(t.getShaderInfoLog(e)||"").trim();if(n&&""===s)return"";const a=/ERROR: 0:(\d+)/.exec(s);if(a){const n=parseInt(a[1]);return i.toUpperCase()+"\n\n"+s+"\n\n"+function(t,e){const i=t.split("\n"),n=[],s=Math.max(e-6,0),a=Math.min(e+6,i.length);for(let t=s;t<a;t++){const s=t+1;n.push(`${s===e?">":" "} ${s}: ${i[t]}`)}return n.join("\n")}(t.getShaderSource(e),n)}return s}function xd(t,e){const i=function(t){ei._getMatrix(Md,ei.workingColorSpace,t);const e=`mat3( ${Md.elements.map(t=>t.toFixed(4))} )`;switch(ei.getTransfer(t)){case re:return[e,"LinearTransferOETF"];case oe:return[e,"sRGBTransferOETF"];default:return De("WebGLProgram: Unsupported color space: ",t),[e,"LinearTransferOETF"]}}(e);return[`vec4 ${t}( vec4 value ) {`,`\treturn ${i[1]}( vec4( value.rgb * ${i[0]}, value.a ) );`,"}"].join("\n")}function wd(t,e){let i;switch(e){case 1:i="Linear";break;case 2:i="Reinhard";break;case 3:i="Cineon";break;case 4:i="ACESFilmic";break;case 6:i="AgX";break;case 7:i="Neutral";break;case 5:i="Custom";break;default:De("WebGLProgram: Unsupported toneMapping:",e),i="Linear"}return"vec3 "+t+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}const Sd=new qe;function Td(t){return""!==t}function Cd(t,e){const i=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,i).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Ed(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Ad=/^[ \t]*#include +<([\w\d./]+)>/gm;function Pd(t){return t.replace(Ad,Rd)}const Dd=new Map;function Rd(t,e){let i=kc[e];if(void 0===i){const t=Dd.get(e);if(void 0===t)throw new Error("Can not resolve #include <"+e+">");i=kc[t],De('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,t)}return Pd(i)}const Id=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Bd(t){return t.replace(Id,Ld)}function Ld(t,e,i,n){let s="";for(let t=parseInt(e);t<parseInt(i);t++)s+=n.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return s}function kd(t){let e=`precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Od(t,e,i,n){const s=t.getContext(),a=i.defines;let r=i.vertexShader,o=i.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return 1===t.shadowMapType?e="SHADOWMAP_TYPE_PCF":2===t.shadowMapType?e="SHADOWMAP_TYPE_PCF_SOFT":3===t.shadowMapType&&(e="SHADOWMAP_TYPE_VSM"),e}(i),h=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case k:case O:e="ENVMAP_TYPE_CUBE";break;case U:e="ENVMAP_TYPE_CUBE_UV"}return e}(i),c=function(t){let e="ENVMAP_MODE_REFLECTION";return t.envMap&&t.envMapMode===O&&(e="ENVMAP_MODE_REFRACTION"),e}(i),u=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case 0:e="ENVMAP_BLENDING_MULTIPLY";break;case 1:e="ENVMAP_BLENDING_MIX";break;case 2:e="ENVMAP_BLENDING_ADD"}return e}(i),d=function(t){const e=t.envMapCubeUVHeight;if(null===e)return null;const i=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,i),112)),texelHeight:n,maxMip:i}}(i),p=function(t){return[t.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",t.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Td).join("\n")}(i),m=function(t){const e=[];for(const i in t){const n=t[i];!1!==n&&e.push("#define "+i+" "+n)}return e.join("\n")}(a),g=s.createProgram();let f,y,v=i.glslVersion?"#version "+i.glslVersion+"\n":"";i.isRawShaderMaterial?(f=["#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,m].filter(Td).join("\n"),f.length>0&&(f+="\n"),y=["#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,m].filter(Td).join("\n"),y.length>0&&(y+="\n")):(f=[kd(i),"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,m,i.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",i.batching?"#define USE_BATCHING":"",i.batchingColor?"#define USE_BATCHING_COLOR":"",i.instancing?"#define USE_INSTANCING":"",i.instancingColor?"#define USE_INSTANCING_COLOR":"",i.instancingMorph?"#define USE_INSTANCING_MORPH":"",i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+c:"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",i.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",i.displacementMap?"#define USE_DISPLACEMENTMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.anisotropy?"#define USE_ANISOTROPY":"",i.anisotropyMap?"#define USE_ANISOTROPYMAP":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",i.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaHash?"#define USE_ALPHAHASH":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",i.mapUv?"#define MAP_UV "+i.mapUv:"",i.alphaMapUv?"#define ALPHAMAP_UV "+i.alphaMapUv:"",i.lightMapUv?"#define LIGHTMAP_UV "+i.lightMapUv:"",i.aoMapUv?"#define AOMAP_UV "+i.aoMapUv:"",i.emissiveMapUv?"#define EMISSIVEMAP_UV "+i.emissiveMapUv:"",i.bumpMapUv?"#define BUMPMAP_UV "+i.bumpMapUv:"",i.normalMapUv?"#define NORMALMAP_UV "+i.normalMapUv:"",i.displacementMapUv?"#define DISPLACEMENTMAP_UV "+i.displacementMapUv:"",i.metalnessMapUv?"#define METALNESSMAP_UV "+i.metalnessMapUv:"",i.roughnessMapUv?"#define ROUGHNESSMAP_UV "+i.roughnessMapUv:"",i.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+i.anisotropyMapUv:"",i.clearcoatMapUv?"#define CLEARCOATMAP_UV "+i.clearcoatMapUv:"",i.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+i.clearcoatNormalMapUv:"",i.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+i.clearcoatRoughnessMapUv:"",i.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+i.iridescenceMapUv:"",i.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+i.iridescenceThicknessMapUv:"",i.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+i.sheenColorMapUv:"",i.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+i.sheenRoughnessMapUv:"",i.specularMapUv?"#define SPECULARMAP_UV "+i.specularMapUv:"",i.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+i.specularColorMapUv:"",i.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+i.specularIntensityMapUv:"",i.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+i.transmissionMapUv:"",i.thicknessMapUv?"#define THICKNESSMAP_UV "+i.thicknessMapUv:"",i.vertexTangents&&!1===i.flatShading?"#define USE_TANGENT":"",i.vertexColors?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUv1s?"#define USE_UV1":"",i.vertexUv2s?"#define USE_UV2":"",i.vertexUv3s?"#define USE_UV3":"",i.pointsUvs?"#define USE_POINTS_UV":"",i.flatShading?"#define FLAT_SHADED":"",i.skinning?"#define USE_SKINNING":"",i.morphTargets?"#define USE_MORPHTARGETS":"",i.morphNormals&&!1===i.flatShading?"#define USE_MORPHNORMALS":"",i.morphColors?"#define USE_MORPHCOLORS":"",i.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+i.morphTextureStride:"",i.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+i.morphTargetsCount:"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+l:"",i.sizeAttenuation?"#define USE_SIZEATTENUATION":"",i.numLightProbes>0?"#define USE_LIGHT_PROBES":"",i.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",i.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Td).join("\n"),y=[kd(i),"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,m,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",i.map?"#define USE_MAP":"",i.matcap?"#define USE_MATCAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+h:"",i.envMap?"#define "+c:"",i.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",i.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.anisotropy?"#define USE_ANISOTROPY":"",i.anisotropyMap?"#define USE_ANISOTROPYMAP":"",i.clearcoat?"#define USE_CLEARCOAT":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.dispersion?"#define USE_DISPERSION":"",i.iridescence?"#define USE_IRIDESCENCE":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",i.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaTest?"#define USE_ALPHATEST":"",i.alphaHash?"#define USE_ALPHAHASH":"",i.sheen?"#define USE_SHEEN":"",i.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.vertexTangents&&!1===i.flatShading?"#define USE_TANGENT":"",i.vertexColors||i.instancingColor||i.batchingColor?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUv1s?"#define USE_UV1":"",i.vertexUv2s?"#define USE_UV2":"",i.vertexUv3s?"#define USE_UV3":"",i.pointsUvs?"#define USE_POINTS_UV":"",i.gradientMap?"#define USE_GRADIENTMAP":"",i.flatShading?"#define FLAT_SHADED":"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+l:"",i.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",i.numLightProbes>0?"#define USE_LIGHT_PROBES":"",i.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",i.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",i.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",i.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==i.toneMapping?"#define TONE_MAPPING":"",0!==i.toneMapping?kc.tonemapping_pars_fragment:"",0!==i.toneMapping?wd("toneMapping",i.toneMapping):"",i.dithering?"#define DITHERING":"",i.opaque?"#define OPAQUE":"",kc.colorspace_pars_fragment,xd("linearToOutputTexel",i.outputColorSpace),(ei.getLuminanceCoefficients(Sd),["float luminance( const in vec3 rgb ) {",`\tconst vec3 weights = vec3( ${Sd.x.toFixed(4)}, ${Sd.y.toFixed(4)}, ${Sd.z.toFixed(4)} );`,"\treturn dot( weights, rgb );","}"].join("\n")),i.useDepthPacking?"#define DEPTH_PACKING "+i.depthPacking:"","\n"].filter(Td).join("\n")),r=Pd(r),r=Cd(r,i),r=Ed(r,i),o=Pd(o),o=Cd(o,i),o=Ed(o,i),r=Bd(r),o=Bd(o),!0!==i.isRawShaderMaterial&&(v="#version 300 es\n",f=[p,"#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+f,y=["#define varying in",i.glslVersion===be?"":"layout(location = 0) out highp vec4 pc_fragColor;",i.glslVersion===be?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+y);const b=v+f+r,M=v+y+o,_=vd(s,s.VERTEX_SHADER,b),x=vd(s,s.FRAGMENT_SHADER,M);function w(e){if(t.debug.checkShaderErrors){const i=s.getProgramInfoLog(g)||"",n=s.getShaderInfoLog(_)||"",a=s.getShaderInfoLog(x)||"",r=i.trim(),o=n.trim(),l=a.trim();let h=!0,c=!0;if(!1===s.getProgramParameter(g,s.LINK_STATUS))if(h=!1,"function"==typeof t.debug.onShaderError)t.debug.onShaderError(s,g,_,x);else{const t=_d(s,_,"vertex"),i=_d(s,x,"fragment");Re("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(g,s.VALIDATE_STATUS)+"\n\nMaterial Name: "+e.name+"\nMaterial Type: "+e.type+"\n\nProgram Info Log: "+r+"\n"+t+"\n"+i)}else""!==r?De("WebGLProgram: Program Info Log:",r):""!==o&&""!==l||(c=!1);c&&(e.diagnostics={runnable:h,programLog:r,vertexShader:{log:o,prefix:f},fragmentShader:{log:l,prefix:y}})}s.deleteShader(_),s.deleteShader(x),S=new yd(s,g),T=function(t,e){const i={},n=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let s=0;s<n;s++){const n=t.getActiveAttrib(e,s),a=n.name;let r=1;n.type===t.FLOAT_MAT2&&(r=2),n.type===t.FLOAT_MAT3&&(r=3),n.type===t.FLOAT_MAT4&&(r=4),i[a]={type:n.type,location:t.getAttribLocation(e,a),locationSize:r}}return i}(s,g)}let S,T;s.attachShader(g,_),s.attachShader(g,x),void 0!==i.index0AttributeName?s.bindAttribLocation(g,0,i.index0AttributeName):!0===i.morphTargets&&s.bindAttribLocation(g,0,"position"),s.linkProgram(g),this.getUniforms=function(){return void 0===S&&w(this),S},this.getAttributes=function(){return void 0===T&&w(this),T};let C=!1===i.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===C&&(C=s.getProgramParameter(g,37297)),C},this.destroy=function(){n.releaseStatesOfProgram(this),s.deleteProgram(g),this.program=void 0},this.type=i.shaderType,this.name=i.shaderName,this.id=bd++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=_,this.fragmentShader=x,this}let zd=0;class Fd{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,i=t.fragmentShader,n=this._getShaderStage(e),s=this._getShaderStage(i),a=this._getShaderCacheForMaterial(t);return!1===a.has(n)&&(a.add(n),n.usedTimes++),!1===a.has(s)&&(a.add(s),s.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let i=e.get(t);return void 0===i&&(i=new Set,e.set(t,i)),i}_getShaderStage(t){const e=this.shaderCache;let i=e.get(t);return void 0===i&&(i=new Ud(t),e.set(t,i)),i}}class Ud{constructor(t){this.id=zd++,this.code=t,this.usedTimes=0}}function Nd(t,e,i,n,s,a,r){const o=new en,l=new Fd,h=new Set,c=[],u=s.logarithmicDepthBuffer,d=s.vertexTextures;let p=s.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function g(t){return h.add(t),0===t?"uv":`uv${t}`}return{getParameters:function(a,o,c,f,y){const v=f.fog,b=y.geometry,M=a.isMeshStandardMaterial?f.environment:null,_=(a.isMeshStandardMaterial?i:e).get(a.envMap||M),x=_&&_.mapping===U?_.image.height:null,w=m[a.type];null!==a.precision&&(p=s.getMaxPrecision(a.precision),p!==a.precision&&De("WebGLProgram.getParameters:",a.precision,"not supported, using",p,"instead."));const S=b.morphAttributes.position||b.morphAttributes.normal||b.morphAttributes.color,T=void 0!==S?S.length:0;let C,E,A,P,D=0;if(void 0!==b.morphAttributes.position&&(D=1),void 0!==b.morphAttributes.normal&&(D=2),void 0!==b.morphAttributes.color&&(D=3),w){const t=zc[w];C=t.vertexShader,E=t.fragmentShader}else C=a.vertexShader,E=a.fragmentShader,l.update(a),A=l.getVertexShaderID(a),P=l.getFragmentShaderID(a);const R=t.getRenderTarget(),I=t.state.buffers.depth.getReversed(),B=!0===y.isInstancedMesh,L=!0===y.isBatchedMesh,k=!!a.map,O=!!a.matcap,z=!!_,F=!!a.aoMap,N=!!a.lightMap,G=!!a.bumpMap,V=!!a.normalMap,H=!!a.displacementMap,W=!!a.emissiveMap,j=!!a.metalnessMap,X=!!a.roughnessMap,q=a.anisotropy>0,Y=a.clearcoat>0,$=a.dispersion>0,Z=a.iridescence>0,J=a.sheen>0,Q=a.transmission>0,K=q&&!!a.anisotropyMap,tt=Y&&!!a.clearcoatMap,et=Y&&!!a.clearcoatNormalMap,it=Y&&!!a.clearcoatRoughnessMap,nt=Z&&!!a.iridescenceMap,st=Z&&!!a.iridescenceThicknessMap,at=J&&!!a.sheenColorMap,rt=J&&!!a.sheenRoughnessMap,ot=!!a.specularMap,lt=!!a.specularColorMap,ht=!!a.specularIntensityMap,ct=Q&&!!a.transmissionMap,ut=Q&&!!a.thicknessMap,dt=!!a.gradientMap,pt=!!a.alphaMap,mt=a.alphaTest>0,gt=!!a.alphaHash,ft=!!a.extensions;let yt=0;a.toneMapped&&(null!==R&&!0!==R.isXRRenderTarget||(yt=t.toneMapping));const vt={shaderID:w,shaderType:a.type,shaderName:a.name,vertexShader:C,fragmentShader:E,defines:a.defines,customVertexShaderID:A,customFragmentShaderID:P,isRawShaderMaterial:!0===a.isRawShaderMaterial,glslVersion:a.glslVersion,precision:p,batching:L,batchingColor:L&&null!==y._colorsTexture,instancing:B,instancingColor:B&&null!==y.instanceColor,instancingMorph:B&&null!==y.morphTexture,supportsVertexTextures:d,outputColorSpace:null===R?t.outputColorSpace:!0===R.isXRRenderTarget?R.texture.colorSpace:ae,alphaToCoverage:!!a.alphaToCoverage,map:k,matcap:O,envMap:z,envMapMode:z&&_.mapping,envMapCubeUVHeight:x,aoMap:F,lightMap:N,bumpMap:G,normalMap:V,displacementMap:d&&H,emissiveMap:W,normalMapObjectSpace:V&&1===a.normalMapType,normalMapTangentSpace:V&&0===a.normalMapType,metalnessMap:j,roughnessMap:X,anisotropy:q,anisotropyMap:K,clearcoat:Y,clearcoatMap:tt,clearcoatNormalMap:et,clearcoatRoughnessMap:it,dispersion:$,iridescence:Z,iridescenceMap:nt,iridescenceThicknessMap:st,sheen:J,sheenColorMap:at,sheenRoughnessMap:rt,specularMap:ot,specularColorMap:lt,specularIntensityMap:ht,transmission:Q,transmissionMap:ct,thicknessMap:ut,gradientMap:dt,opaque:!1===a.transparent&&1===a.blending&&!1===a.alphaToCoverage,alphaMap:pt,alphaTest:mt,alphaHash:gt,combine:a.combine,mapUv:k&&g(a.map.channel),aoMapUv:F&&g(a.aoMap.channel),lightMapUv:N&&g(a.lightMap.channel),bumpMapUv:G&&g(a.bumpMap.channel),normalMapUv:V&&g(a.normalMap.channel),displacementMapUv:H&&g(a.displacementMap.channel),emissiveMapUv:W&&g(a.emissiveMap.channel),metalnessMapUv:j&&g(a.metalnessMap.channel),roughnessMapUv:X&&g(a.roughnessMap.channel),anisotropyMapUv:K&&g(a.anisotropyMap.channel),clearcoatMapUv:tt&&g(a.clearcoatMap.channel),clearcoatNormalMapUv:et&&g(a.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:it&&g(a.clearcoatRoughnessMap.channel),iridescenceMapUv:nt&&g(a.iridescenceMap.channel),iridescenceThicknessMapUv:st&&g(a.iridescenceThicknessMap.channel),sheenColorMapUv:at&&g(a.sheenColorMap.channel),sheenRoughnessMapUv:rt&&g(a.sheenRoughnessMap.channel),specularMapUv:ot&&g(a.specularMap.channel),specularColorMapUv:lt&&g(a.specularColorMap.channel),specularIntensityMapUv:ht&&g(a.specularIntensityMap.channel),transmissionMapUv:ct&&g(a.transmissionMap.channel),thicknessMapUv:ut&&g(a.thicknessMap.channel),alphaMapUv:pt&&g(a.alphaMap.channel),vertexTangents:!!b.attributes.tangent&&(V||q),vertexColors:a.vertexColors,vertexAlphas:!0===a.vertexColors&&!!b.attributes.color&&4===b.attributes.color.itemSize,pointsUvs:!0===y.isPoints&&!!b.attributes.uv&&(k||pt),fog:!!v,useFog:!0===a.fog,fogExp2:!!v&&v.isFogExp2,flatShading:!0===a.flatShading&&!1===a.wireframe,sizeAttenuation:!0===a.sizeAttenuation,logarithmicDepthBuffer:u,reversedDepthBuffer:I,skinning:!0===y.isSkinnedMesh,morphTargets:void 0!==b.morphAttributes.position,morphNormals:void 0!==b.morphAttributes.normal,morphColors:void 0!==b.morphAttributes.color,morphTargetsCount:T,morphTextureStride:D,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numSpotLightMaps:o.spotLightMap.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numSpotLightShadowsWithMaps:o.numSpotLightShadowsWithMaps,numLightProbes:o.numLightProbes,numClippingPlanes:r.numPlanes,numClipIntersection:r.numIntersection,dithering:a.dithering,shadowMapEnabled:t.shadowMap.enabled&&c.length>0,shadowMapType:t.shadowMap.type,toneMapping:yt,decodeVideoTexture:k&&!0===a.map.isVideoTexture&&ei.getTransfer(a.map.colorSpace)===oe,decodeVideoTextureEmissive:W&&!0===a.emissiveMap.isVideoTexture&&ei.getTransfer(a.emissiveMap.colorSpace)===oe,premultipliedAlpha:a.premultipliedAlpha,doubleSided:2===a.side,flipSided:1===a.side,useDepthPacking:a.depthPacking>=0,depthPacking:a.depthPacking||0,index0AttributeName:a.index0AttributeName,extensionClipCullDistance:ft&&!0===a.extensions.clipCullDistance&&n.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(ft&&!0===a.extensions.multiDraw||L)&&n.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:a.customProgramCacheKey()};return vt.vertexUv1s=h.has(1),vt.vertexUv2s=h.has(2),vt.vertexUv3s=h.has(3),h.clear(),vt},getProgramCacheKey:function(e){const i=[];if(e.shaderID?i.push(e.shaderID):(i.push(e.customVertexShaderID),i.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)i.push(t),i.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(function(t,e){t.push(e.precision),t.push(e.outputColorSpace),t.push(e.envMapMode),t.push(e.envMapCubeUVHeight),t.push(e.mapUv),t.push(e.alphaMapUv),t.push(e.lightMapUv),t.push(e.aoMapUv),t.push(e.bumpMapUv),t.push(e.normalMapUv),t.push(e.displacementMapUv),t.push(e.emissiveMapUv),t.push(e.metalnessMapUv),t.push(e.roughnessMapUv),t.push(e.anisotropyMapUv),t.push(e.clearcoatMapUv),t.push(e.clearcoatNormalMapUv),t.push(e.clearcoatRoughnessMapUv),t.push(e.iridescenceMapUv),t.push(e.iridescenceThicknessMapUv),t.push(e.sheenColorMapUv),t.push(e.sheenRoughnessMapUv),t.push(e.specularMapUv),t.push(e.specularColorMapUv),t.push(e.specularIntensityMapUv),t.push(e.transmissionMapUv),t.push(e.thicknessMapUv),t.push(e.combine),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numSpotLightMaps),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.numSpotLightShadowsWithMaps),t.push(e.numLightProbes),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking)}(i,e),function(t,e){o.disableAll(),e.supportsVertexTextures&&o.enable(0),e.instancing&&o.enable(1),e.instancingColor&&o.enable(2),e.instancingMorph&&o.enable(3),e.matcap&&o.enable(4),e.envMap&&o.enable(5),e.normalMapObjectSpace&&o.enable(6),e.normalMapTangentSpace&&o.enable(7),e.clearcoat&&o.enable(8),e.iridescence&&o.enable(9),e.alphaTest&&o.enable(10),e.vertexColors&&o.enable(11),e.vertexAlphas&&o.enable(12),e.vertexUv1s&&o.enable(13),e.vertexUv2s&&o.enable(14),e.vertexUv3s&&o.enable(15),e.vertexTangents&&o.enable(16),e.anisotropy&&o.enable(17),e.alphaHash&&o.enable(18),e.batching&&o.enable(19),e.dispersion&&o.enable(20),e.batchingColor&&o.enable(21),e.gradientMap&&o.enable(22),t.push(o.mask),o.disableAll(),e.fog&&o.enable(0),e.useFog&&o.enable(1),e.flatShading&&o.enable(2),e.logarithmicDepthBuffer&&o.enable(3),e.reversedDepthBuffer&&o.enable(4),e.skinning&&o.enable(5),e.morphTargets&&o.enable(6),e.morphNormals&&o.enable(7),e.morphColors&&o.enable(8),e.premultipliedAlpha&&o.enable(9),e.shadowMapEnabled&&o.enable(10),e.doubleSided&&o.enable(11),e.flipSided&&o.enable(12),e.useDepthPacking&&o.enable(13),e.dithering&&o.enable(14),e.transmission&&o.enable(15),e.sheen&&o.enable(16),e.opaque&&o.enable(17),e.pointsUvs&&o.enable(18),e.decodeVideoTexture&&o.enable(19),e.decodeVideoTextureEmissive&&o.enable(20),e.alphaToCoverage&&o.enable(21),t.push(o.mask)}(i,e),i.push(t.outputColorSpace)),i.push(e.customProgramCacheKey),i.join()},getUniforms:function(t){const e=m[t.type];let i;if(e){const t=zc[e];i=Ts.clone(t.uniforms)}else i=t.uniforms;return i},acquireProgram:function(e,i){let n;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(e.cacheKey===i){n=e,++n.usedTimes;break}}return void 0===n&&(n=new Od(t,i,e,a),c.push(n)),n},releaseProgram:function(t){if(0===--t.usedTimes){const e=c.indexOf(t);c[e]=c[c.length-1],c.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:c,dispose:function(){l.dispose()}}}function Gd(){let t=new WeakMap;return{has:function(e){return t.has(e)},get:function(e){let i=t.get(e);return void 0===i&&(i={},t.set(e,i)),i},remove:function(e){t.delete(e)},update:function(e,i,n){t.get(e)[i]=n},dispose:function(){t=new WeakMap}}}function Vd(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Hd(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Wd(){const t=[];let e=0;const i=[],n=[],s=[];function a(i,n,s,a,r,o){let l=t[e];return void 0===l?(l={id:i.id,object:i,geometry:n,material:s,groupOrder:a,renderOrder:i.renderOrder,z:r,group:o},t[e]=l):(l.id=i.id,l.object=i,l.geometry=n,l.material=s,l.groupOrder=a,l.renderOrder=i.renderOrder,l.z=r,l.group=o),e++,l}return{opaque:i,transmissive:n,transparent:s,init:function(){e=0,i.length=0,n.length=0,s.length=0},push:function(t,e,r,o,l,h){const c=a(t,e,r,o,l,h);r.transmission>0?n.push(c):!0===r.transparent?s.push(c):i.push(c)},unshift:function(t,e,r,o,l,h){const c=a(t,e,r,o,l,h);r.transmission>0?n.unshift(c):!0===r.transparent?s.unshift(c):i.unshift(c)},finish:function(){for(let i=e,n=t.length;i<n;i++){const e=t[i];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){i.length>1&&i.sort(t||Vd),n.length>1&&n.sort(e||Hd),s.length>1&&s.sort(e||Hd)}}}function jd(){let t=new WeakMap;return{get:function(e,i){const n=t.get(e);let s;return void 0===n?(s=new Wd,t.set(e,[s])):i>=n.length?(s=new Wd,n.push(s)):s=n[i],s},dispose:function(){t=new WeakMap}}}function Xd(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let i;switch(e.type){case"DirectionalLight":i={direction:new qe,color:new zn};break;case"SpotLight":i={position:new qe,direction:new qe,color:new zn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new qe,color:new zn,distance:0,decay:0};break;case"HemisphereLight":i={direction:new qe,skyColor:new zn,groundColor:new zn};break;case"RectAreaLight":i={color:new zn,position:new qe,halfWidth:new qe,halfHeight:new qe}}return t[e.id]=i,i}}}let qd=0;function Yd(t,e){return(e.castShadow?2:0)-(t.castShadow?2:0)+(e.map?1:0)-(t.map?1:0)}function $d(t){const e=new Xd,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let i;switch(e.type){case"DirectionalLight":case"SpotLight":i={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new je};break;case"PointLight":i={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new je,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=i,i}}}(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let t=0;t<9;t++)n.probe.push(new qe);const s=new qe,a=new Wi,r=new Wi;return{setup:function(s){let a=0,r=0,o=0;for(let t=0;t<9;t++)n.probe[t].set(0,0,0);let l=0,h=0,c=0,u=0,d=0,p=0,m=0,g=0,f=0,y=0,v=0;s.sort(Yd);for(let t=0,b=s.length;t<b;t++){const b=s[t],M=b.color,_=b.intensity,x=b.distance,w=b.shadow&&b.shadow.map?b.shadow.map.texture:null;if(b.isAmbientLight)a+=M.r*_,r+=M.g*_,o+=M.b*_;else if(b.isLightProbe){for(let t=0;t<9;t++)n.probe[t].addScaledVector(b.sh.coefficients[t],_);v++}else if(b.isDirectionalLight){const t=e.get(b);if(t.color.copy(b.color).multiplyScalar(b.intensity),b.castShadow){const t=b.shadow,e=i.get(b);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,n.directionalShadow[l]=e,n.directionalShadowMap[l]=w,n.directionalShadowMatrix[l]=b.shadow.matrix,p++}n.directional[l]=t,l++}else if(b.isSpotLight){const t=e.get(b);t.position.setFromMatrixPosition(b.matrixWorld),t.color.copy(M).multiplyScalar(_),t.distance=x,t.coneCos=Math.cos(b.angle),t.penumbraCos=Math.cos(b.angle*(1-b.penumbra)),t.decay=b.decay,n.spot[c]=t;const s=b.shadow;if(b.map&&(n.spotLightMap[f]=b.map,f++,s.updateMatrices(b),b.castShadow&&y++),n.spotLightMatrix[c]=s.matrix,b.castShadow){const t=i.get(b);t.shadowIntensity=s.intensity,t.shadowBias=s.bias,t.shadowNormalBias=s.normalBias,t.shadowRadius=s.radius,t.shadowMapSize=s.mapSize,n.spotShadow[c]=t,n.spotShadowMap[c]=w,g++}c++}else if(b.isRectAreaLight){const t=e.get(b);t.color.copy(M).multiplyScalar(_),t.halfWidth.set(.5*b.width,0,0),t.halfHeight.set(0,.5*b.height,0),n.rectArea[u]=t,u++}else if(b.isPointLight){const t=e.get(b);if(t.color.copy(b.color).multiplyScalar(b.intensity),t.distance=b.distance,t.decay=b.decay,b.castShadow){const t=b.shadow,e=i.get(b);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,e.shadowCameraNear=t.camera.near,e.shadowCameraFar=t.camera.far,n.pointShadow[h]=e,n.pointShadowMap[h]=w,n.pointShadowMatrix[h]=b.shadow.matrix,m++}n.point[h]=t,h++}else if(b.isHemisphereLight){const t=e.get(b);t.skyColor.copy(b.color).multiplyScalar(_),t.groundColor.copy(b.groundColor).multiplyScalar(_),n.hemi[d]=t,d++}}u>0&&(!0===t.has("OES_texture_float_linear")?(n.rectAreaLTC1=Oc.LTC_FLOAT_1,n.rectAreaLTC2=Oc.LTC_FLOAT_2):(n.rectAreaLTC1=Oc.LTC_HALF_1,n.rectAreaLTC2=Oc.LTC_HALF_2)),n.ambient[0]=a,n.ambient[1]=r,n.ambient[2]=o;const b=n.hash;b.directionalLength===l&&b.pointLength===h&&b.spotLength===c&&b.rectAreaLength===u&&b.hemiLength===d&&b.numDirectionalShadows===p&&b.numPointShadows===m&&b.numSpotShadows===g&&b.numSpotMaps===f&&b.numLightProbes===v||(n.directional.length=l,n.spot.length=c,n.rectArea.length=u,n.point.length=h,n.hemi.length=d,n.directionalShadow.length=p,n.directionalShadowMap.length=p,n.pointShadow.length=m,n.pointShadowMap.length=m,n.spotShadow.length=g,n.spotShadowMap.length=g,n.directionalShadowMatrix.length=p,n.pointShadowMatrix.length=m,n.spotLightMatrix.length=g+f-y,n.spotLightMap.length=f,n.numSpotLightShadowsWithMaps=y,n.numLightProbes=v,b.directionalLength=l,b.pointLength=h,b.spotLength=c,b.rectAreaLength=u,b.hemiLength=d,b.numDirectionalShadows=p,b.numPointShadows=m,b.numSpotShadows=g,b.numSpotMaps=f,b.numLightProbes=v,n.version=qd++)},setupView:function(t,e){let i=0,o=0,l=0,h=0,c=0;const u=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=n.directional[i];t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),i++}else if(d.isSpotLight){const t=n.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(s),t.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const t=n.rectArea[h];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),r.identity(),a.copy(d.matrixWorld),a.premultiply(u),r.extractRotation(a),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(r),t.halfHeight.applyMatrix4(r),h++}else if(d.isPointLight){const t=n.point[o];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),o++}else if(d.isHemisphereLight){const t=n.hemi[c];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(u),c++}}},state:n}}function Zd(t){const e=new $d(t),i=[],n=[],s={lightsArray:i,shadowsArray:n,camera:null,lights:e,transmissionRenderTarget:{}};return{init:function(t){s.camera=t,i.length=0,n.length=0},state:s,setupLights:function(){e.setup(i)},setupLightsView:function(t){e.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){n.push(t)}}}function Jd(t){let e=new WeakMap;return{get:function(i,n=0){const s=e.get(i);let a;return void 0===s?(a=new Zd(t),e.set(i,[a])):n>=s.length?(a=new Zd(t),s.push(a)):a=s[n],a},dispose:function(){e=new WeakMap}}}function Qd(t,e,i){let r=new Ga;const o=new je,l=new je,h=new di,c=new fl({depthPacking:3201}),u=new yl,d={},p=i.maxTextureSize,m={[n]:1,[s]:0,[a]:2},g=new Cs({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new je},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),f=g.clone();f.defines.HORIZONTAL_PASS=1;const y=new os;y.setAttribute("position",new Zn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const v=new bs(y,g),b=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1;let M=this.type;function _(i,n){const s=e.update(v);g.defines.VSM_SAMPLES!==i.blurSamples&&(g.defines.VSM_SAMPLES=i.blurSamples,f.defines.VSM_SAMPLES=i.blurSamples,g.needsUpdate=!0,f.needsUpdate=!0),null===i.mapPass&&(i.mapPass=new mi(o.x,o.y)),g.uniforms.shadow_pass.value=i.map.texture,g.uniforms.resolution.value=i.mapSize,g.uniforms.radius.value=i.radius,t.setRenderTarget(i.mapPass),t.clear(),t.renderBufferDirect(n,null,s,g,v,null),f.uniforms.shadow_pass.value=i.mapPass.texture,f.uniforms.resolution.value=i.mapSize,f.uniforms.radius.value=i.radius,t.setRenderTarget(i.map),t.clear(),t.renderBufferDirect(n,null,s,f,v,null)}function x(e,i,n,s){let a=null;const r=!0===n.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(void 0!==r)a=r;else if(a=!0===n.isPointLight?u:c,t.localClippingEnabled&&!0===i.clipShadows&&Array.isArray(i.clippingPlanes)&&0!==i.clippingPlanes.length||i.displacementMap&&0!==i.displacementScale||i.alphaMap&&i.alphaTest>0||i.map&&i.alphaTest>0||!0===i.alphaToCoverage){const t=a.uuid,e=i.uuid;let n=d[t];void 0===n&&(n={},d[t]=n);let s=n[e];void 0===s&&(s=a.clone(),n[e]=s,i.addEventListener("dispose",S)),a=s}return a.visible=i.visible,a.wireframe=i.wireframe,a.side=3===s?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:m[i.side],a.alphaMap=i.alphaMap,a.alphaTest=!0===i.alphaToCoverage?.5:i.alphaTest,a.map=i.map,a.clipShadows=i.clipShadows,a.clippingPlanes=i.clippingPlanes,a.clipIntersection=i.clipIntersection,a.displacementMap=i.displacementMap,a.displacementScale=i.displacementScale,a.displacementBias=i.displacementBias,a.wireframeLinewidth=i.wireframeLinewidth,a.linewidth=i.linewidth,!0===n.isPointLight&&!0===a.isMeshDistanceMaterial&&(t.properties.get(a).light=n),a}function w(i,n,s,a,o){if(!1===i.visible)return;if(i.layers.test(n.layers)&&(i.isMesh||i.isLine||i.isPoints)&&(i.castShadow||i.receiveShadow&&3===o)&&(!i.frustumCulled||r.intersectsObject(i))){i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,i.matrixWorld);const r=e.update(i),l=i.material;if(Array.isArray(l)){const e=r.groups;for(let h=0,c=e.length;h<c;h++){const c=e[h],u=l[c.materialIndex];if(u&&u.visible){const e=x(i,u,a,o);i.onBeforeShadow(t,i,n,s,r,e,c),t.renderBufferDirect(s,null,r,e,i,c),i.onAfterShadow(t,i,n,s,r,e,c)}}}else if(l.visible){const e=x(i,l,a,o);i.onBeforeShadow(t,i,n,s,r,e,null),t.renderBufferDirect(s,null,r,e,i,null),i.onAfterShadow(t,i,n,s,r,e,null)}}const l=i.children;for(let t=0,e=l.length;t<e;t++)w(l[t],n,s,a,o)}function S(t){t.target.removeEventListener("dispose",S);for(const e in d){const i=d[e],n=t.target.uuid;n in i&&(i[n].dispose(),delete i[n])}}this.render=function(e,i,n){if(!1===b.enabled)return;if(!1===b.autoUpdate&&!1===b.needsUpdate)return;if(0===e.length)return;const s=t.getRenderTarget(),a=t.getActiveCubeFace(),c=t.getActiveMipmapLevel(),u=t.state;u.setBlending(0),!0===u.buffers.depth.getReversed()?u.buffers.color.setClear(0,0,0,0):u.buffers.color.setClear(1,1,1,1),u.buffers.depth.setTest(!0),u.setScissorTest(!1);const d=3!==M&&3===this.type,m=3===M&&3!==this.type;for(let s=0,a=e.length;s<a;s++){const a=e[s],c=a.shadow;if(void 0===c){De("WebGLShadowMap:",a,"has no shadow.");continue}if(!1===c.autoUpdate&&!1===c.needsUpdate)continue;o.copy(c.mapSize);const g=c.getFrameExtents();if(o.multiply(g),l.copy(c.mapSize),(o.x>p||o.y>p)&&(o.x>p&&(l.x=Math.floor(p/g.x),o.x=l.x*g.x,c.mapSize.x=l.x),o.y>p&&(l.y=Math.floor(p/g.y),o.y=l.y*g.y,c.mapSize.y=l.y)),null===c.map||!0===d||!0===m){const t=3!==this.type?{minFilter:H,magFilter:H}:{};null!==c.map&&c.map.dispose(),c.map=new mi(o.x,o.y,t),c.map.texture.name=a.name+".shadowMap",c.camera.updateProjectionMatrix()}t.setRenderTarget(c.map),t.clear();const f=c.getViewportCount();for(let t=0;t<f;t++){const e=c.getViewport(t);h.set(l.x*e.x,l.y*e.y,l.x*e.z,l.y*e.w),u.viewport(h),c.updateMatrices(a,t),r=c.getFrustum(),w(i,n,c.camera,a,this.type)}!0!==c.isPointLightShadow&&3===this.type&&_(c,n),c.needsUpdate=!1}M=this.type,b.needsUpdate=!1,t.setRenderTarget(s,a,c)}}const Kd={[S]:1,[C]:6,[A]:7,[E]:5,[T]:0,[D]:2,[R]:4,[P]:3};function tp(t,e){const i=new function(){let e=!1;const i=new di;let n=null;const s=new di(0,0,0,0);return{setMask:function(i){n===i||e||(t.colorMask(i,i,i,i),n=i)},setLocked:function(t){e=t},setClear:function(e,n,a,r,o){!0===o&&(e*=r,n*=r,a*=r),i.set(e,n,a,r),!1===s.equals(i)&&(t.clearColor(e,n,a,r),s.copy(i))},reset:function(){e=!1,n=null,s.set(-1,0,0,0)}}},n=new function(){let i=!1,n=!1,s=null,a=null,r=null;return{setReversed:function(t){if(n!==t){const i=e.get("EXT_clip_control");t?i.clipControlEXT(i.LOWER_LEFT_EXT,i.ZERO_TO_ONE_EXT):i.clipControlEXT(i.LOWER_LEFT_EXT,i.NEGATIVE_ONE_TO_ONE_EXT),n=t;const s=r;r=null,this.setClear(s)}},getReversed:function(){return n},setTest:function(e){e?st(t.DEPTH_TEST):at(t.DEPTH_TEST)},setMask:function(e){s===e||i||(t.depthMask(e),s=e)},setFunc:function(e){if(n&&(e=Kd[e]),a!==e){switch(e){case 0:t.depthFunc(t.NEVER);break;case 1:t.depthFunc(t.ALWAYS);break;case 2:t.depthFunc(t.LESS);break;case 3:default:t.depthFunc(t.LEQUAL);break;case 4:t.depthFunc(t.EQUAL);break;case 5:t.depthFunc(t.GEQUAL);break;case 6:t.depthFunc(t.GREATER);break;case 7:t.depthFunc(t.NOTEQUAL)}a=e}},setLocked:function(t){i=t},setClear:function(e){r!==e&&(n&&(e=1-e),t.clearDepth(e),r=e)},reset:function(){i=!1,s=null,a=null,r=null,n=!1}}},s=new function(){let e=!1,i=null,n=null,s=null,a=null,r=null,o=null,l=null,h=null;return{setTest:function(i){e||(i?st(t.STENCIL_TEST):at(t.STENCIL_TEST))},setMask:function(n){i===n||e||(t.stencilMask(n),i=n)},setFunc:function(e,i,r){n===e&&s===i&&a===r||(t.stencilFunc(e,i,r),n=e,s=i,a=r)},setOp:function(e,i,n){r===e&&o===i&&l===n||(t.stencilOp(e,i,n),r=e,o=i,l=n)},setLocked:function(t){e=t},setClear:function(e){h!==e&&(t.clearStencil(e),h=e)},reset:function(){e=!1,i=null,n=null,s=null,a=null,r=null,o=null,l=null,h=null}}},a=new WeakMap,S=new WeakMap;let T={},C={},E=new WeakMap,A=[],P=null,D=!1,R=null,I=null,B=null,L=null,k=null,O=null,z=null,F=new zn(0,0,0),U=0,N=!1,G=null,V=null,H=null,W=null,j=null;const X=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let q=!1,Y=0;const $=t.getParameter(t.VERSION);-1!==$.indexOf("WebGL")?(Y=parseFloat(/^WebGL (\d)/.exec($)[1]),q=Y>=1):-1!==$.indexOf("OpenGL ES")&&(Y=parseFloat(/^OpenGL ES (\d)/.exec($)[1]),q=Y>=2);let Z=null,J={};const Q=t.getParameter(t.SCISSOR_BOX),K=t.getParameter(t.VIEWPORT),tt=(new di).fromArray(Q),et=(new di).fromArray(K);function it(e,i,n,s){const a=new Uint8Array(4),r=t.createTexture();t.bindTexture(e,r),t.texParameteri(e,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(e,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let r=0;r<n;r++)e===t.TEXTURE_3D||e===t.TEXTURE_2D_ARRAY?t.texImage3D(i,0,t.RGBA,1,1,s,0,t.RGBA,t.UNSIGNED_BYTE,a):t.texImage2D(i+r,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,a);return r}const nt={};function st(e){!0!==T[e]&&(t.enable(e),T[e]=!0)}function at(e){!1!==T[e]&&(t.disable(e),T[e]=!1)}nt[t.TEXTURE_2D]=it(t.TEXTURE_2D,t.TEXTURE_2D,1),nt[t.TEXTURE_CUBE_MAP]=it(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),nt[t.TEXTURE_2D_ARRAY]=it(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),nt[t.TEXTURE_3D]=it(t.TEXTURE_3D,t.TEXTURE_3D,1,1),i.setClear(0,0,0,1),n.setClear(1),s.setClear(0),st(t.DEPTH_TEST),n.setFunc(3),ht(!1),ct(1),st(t.CULL_FACE),lt(0);const rt={[r]:t.FUNC_ADD,[o]:t.FUNC_SUBTRACT,[l]:t.FUNC_REVERSE_SUBTRACT};rt[103]=t.MIN,rt[104]=t.MAX;const ot={[h]:t.ZERO,[c]:t.ONE,[u]:t.SRC_COLOR,[p]:t.SRC_ALPHA,[b]:t.SRC_ALPHA_SATURATE,[y]:t.DST_COLOR,[g]:t.DST_ALPHA,[d]:t.ONE_MINUS_SRC_COLOR,[m]:t.ONE_MINUS_SRC_ALPHA,[v]:t.ONE_MINUS_DST_COLOR,[f]:t.ONE_MINUS_DST_ALPHA,[M]:t.CONSTANT_COLOR,[_]:t.ONE_MINUS_CONSTANT_COLOR,[x]:t.CONSTANT_ALPHA,[w]:t.ONE_MINUS_CONSTANT_ALPHA};function lt(e,i,n,s,a,o,l,h,c,u){if(0!==e){if(!1===D&&(st(t.BLEND),D=!0),5===e)a=a||i,o=o||n,l=l||s,i===I&&a===k||(t.blendEquationSeparate(rt[i],rt[a]),I=i,k=a),n===B&&s===L&&o===O&&l===z||(t.blendFuncSeparate(ot[n],ot[s],ot[o],ot[l]),B=n,L=s,O=o,z=l),!1!==h.equals(F)&&c===U||(t.blendColor(h.r,h.g,h.b,c),F.copy(h),U=c),R=e,N=!1;else if(e!==R||u!==N){if(I===r&&k===r||(t.blendEquation(t.FUNC_ADD),I=r,k=r),u)switch(e){case 1:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.ONE,t.ONE);break;case 3:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case 4:t.blendFuncSeparate(t.DST_COLOR,t.ONE_MINUS_SRC_ALPHA,t.ZERO,t.ONE);break;default:Re("WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE,t.ONE,t.ONE);break;case 3:Re("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case 4:Re("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:Re("WebGLState: Invalid blending: ",e)}B=null,L=null,O=null,z=null,F.set(0,0,0),U=0,R=e,N=u}}else!0===D&&(at(t.BLEND),D=!1)}function ht(e){G!==e&&(e?t.frontFace(t.CW):t.frontFace(t.CCW),G=e)}function ct(e){0!==e?(st(t.CULL_FACE),e!==V&&(1===e?t.cullFace(t.BACK):2===e?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):at(t.CULL_FACE),V=e}function ut(e,i,n){e?(st(t.POLYGON_OFFSET_FILL),W===i&&j===n||(t.polygonOffset(i,n),W=i,j=n)):at(t.POLYGON_OFFSET_FILL)}return{buffers:{color:i,depth:n,stencil:s},enable:st,disable:at,bindFramebuffer:function(e,i){return C[e]!==i&&(t.bindFramebuffer(e,i),C[e]=i,e===t.DRAW_FRAMEBUFFER&&(C[t.FRAMEBUFFER]=i),e===t.FRAMEBUFFER&&(C[t.DRAW_FRAMEBUFFER]=i),!0)},drawBuffers:function(e,i){let n=A,s=!1;if(e){n=E.get(i),void 0===n&&(n=[],E.set(i,n));const a=e.textures;if(n.length!==a.length||n[0]!==t.COLOR_ATTACHMENT0){for(let e=0,i=a.length;e<i;e++)n[e]=t.COLOR_ATTACHMENT0+e;n.length=a.length,s=!0}}else n[0]!==t.BACK&&(n[0]=t.BACK,s=!0);s&&t.drawBuffers(n)},useProgram:function(e){return P!==e&&(t.useProgram(e),P=e,!0)},setBlending:lt,setMaterial:function(e,a){2===e.side?at(t.CULL_FACE):st(t.CULL_FACE);let r=1===e.side;a&&(r=!r),ht(r),1===e.blending&&!1===e.transparent?lt(0):lt(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.blendColor,e.blendAlpha,e.premultipliedAlpha),n.setFunc(e.depthFunc),n.setTest(e.depthTest),n.setMask(e.depthWrite),i.setMask(e.colorWrite);const o=e.stencilWrite;s.setTest(o),o&&(s.setMask(e.stencilWriteMask),s.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),s.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),ut(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?st(t.SAMPLE_ALPHA_TO_COVERAGE):at(t.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:ht,setCullFace:ct,setLineWidth:function(e){e!==H&&(q&&t.lineWidth(e),H=e)},setPolygonOffset:ut,setScissorTest:function(e){e?st(t.SCISSOR_TEST):at(t.SCISSOR_TEST)},activeTexture:function(e){void 0===e&&(e=t.TEXTURE0+X-1),Z!==e&&(t.activeTexture(e),Z=e)},bindTexture:function(e,i,n){void 0===n&&(n=null===Z?t.TEXTURE0+X-1:Z);let s=J[n];void 0===s&&(s={type:void 0,texture:void 0},J[n]=s),s.type===e&&s.texture===i||(Z!==n&&(t.activeTexture(n),Z=n),t.bindTexture(e,i||nt[e]),s.type=e,s.texture=i)},unbindTexture:function(){const e=J[Z];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D(...arguments)}catch(t){t("WebGLState:",t)}},compressedTexImage3D:function(){try{t.compressedTexImage3D(...arguments)}catch(t){t("WebGLState:",t)}},texImage2D:function(){try{t.texImage2D(...arguments)}catch(t){t("WebGLState:",t)}},texImage3D:function(){try{t.texImage3D(...arguments)}catch(t){t("WebGLState:",t)}},updateUBOMapping:function(e,i){let n=S.get(i);void 0===n&&(n=new WeakMap,S.set(i,n));let s=n.get(e);void 0===s&&(s=t.getUniformBlockIndex(i,e.name),n.set(e,s))},uniformBlockBinding:function(e,i){const n=S.get(i).get(e);a.get(i)!==n&&(t.uniformBlockBinding(i,n,e.__bindingPointIndex),a.set(i,n))},texStorage2D:function(){try{t.texStorage2D(...arguments)}catch(t){t("WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D(...arguments)}catch(t){t("WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D(...arguments)}catch(t){t("WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D(...arguments)}catch(t){t("WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D(...arguments)}catch(t){t("WebGLState:",t)}},compressedTexSubImage3D:function(){try{t.compressedTexSubImage3D(...arguments)}catch(t){t("WebGLState:",t)}},scissor:function(e){!1===tt.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),tt.copy(e))},viewport:function(e){!1===et.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),et.copy(e))},reset:function(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.blendColor(0,0,0,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),n.setReversed(!1),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),T={},Z=null,J={},C={},E=new WeakMap,A=[],P=null,D=!1,R=null,I=null,B=null,L=null,k=null,O=null,z=null,F=new zn(0,0,0),U=0,N=!1,G=null,V=null,H=null,W=null,j=null,tt.set(0,0,t.canvas.width,t.canvas.height),et.set(0,0,t.canvas.width,t.canvas.height),i.reset(),n.reset(),s.reset()}}}function ep(t,e,i,n,s,a,r){const o=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),h=new je,c=new WeakMap;let u;const d=new WeakMap;let p=!1;try{p="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function m(t,e){return p?new OffscreenCanvas(t,e):Te("canvas")}function g(t,e,i){let n=1;const s=it(t);if((s.width>i||s.height>i)&&(n=i/Math.max(s.width,s.height)),n<1){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap||"undefined"!=typeof VideoFrame&&t instanceof VideoFrame){const i=Math.floor(n*s.width),a=Math.floor(n*s.height);void 0===u&&(u=m(i,a));const r=e?m(i,a):u;return r.width=i,r.height=a,r.getContext("2d").drawImage(t,0,0,i,a),De("WebGLRenderer: Texture has been resized from ("+s.width+"x"+s.height+") to ("+i+"x"+a+")."),r}return"data"in t&&De("WebGLRenderer: Image in DataTexture is too big ("+s.width+"x"+s.height+")."),t}return t}function f(t){return t.generateMipmaps}function y(e){t.generateMipmap(e)}function v(e){return e.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:e.isWebGL3DRenderTarget?t.TEXTURE_3D:e.isWebGLArrayRenderTarget||e.isCompressedArrayTexture?t.TEXTURE_2D_ARRAY:t.TEXTURE_2D}function b(i,n,s,a,r=!1){if(null!==i){if(void 0!==t[i])return t[i];De("WebGLRenderer: Attempt to use non-existing WebGL internal format '"+i+"'")}let o=n;if(n===t.RED&&(s===t.FLOAT&&(o=t.R32F),s===t.HALF_FLOAT&&(o=t.R16F),s===t.UNSIGNED_BYTE&&(o=t.R8)),n===t.RED_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.R8UI),s===t.UNSIGNED_SHORT&&(o=t.R16UI),s===t.UNSIGNED_INT&&(o=t.R32UI),s===t.BYTE&&(o=t.R8I),s===t.SHORT&&(o=t.R16I),s===t.INT&&(o=t.R32I)),n===t.RG&&(s===t.FLOAT&&(o=t.RG32F),s===t.HALF_FLOAT&&(o=t.RG16F),s===t.UNSIGNED_BYTE&&(o=t.RG8)),n===t.RG_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RG8UI),s===t.UNSIGNED_SHORT&&(o=t.RG16UI),s===t.UNSIGNED_INT&&(o=t.RG32UI),s===t.BYTE&&(o=t.RG8I),s===t.SHORT&&(o=t.RG16I),s===t.INT&&(o=t.RG32I)),n===t.RGB_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RGB8UI),s===t.UNSIGNED_SHORT&&(o=t.RGB16UI),s===t.UNSIGNED_INT&&(o=t.RGB32UI),s===t.BYTE&&(o=t.RGB8I),s===t.SHORT&&(o=t.RGB16I),s===t.INT&&(o=t.RGB32I)),n===t.RGBA_INTEGER&&(s===t.UNSIGNED_BYTE&&(o=t.RGBA8UI),s===t.UNSIGNED_SHORT&&(o=t.RGBA16UI),s===t.UNSIGNED_INT&&(o=t.RGBA32UI),s===t.BYTE&&(o=t.RGBA8I),s===t.SHORT&&(o=t.RGBA16I),s===t.INT&&(o=t.RGBA32I)),n===t.RGB&&(s===t.UNSIGNED_INT_5_9_9_9_REV&&(o=t.RGB9_E5),s===t.UNSIGNED_INT_10F_11F_11F_REV&&(o=t.R11F_G11F_B10F)),n===t.RGBA){const e=r?re:ei.getTransfer(a);s===t.FLOAT&&(o=t.RGBA32F),s===t.HALF_FLOAT&&(o=t.RGBA16F),s===t.UNSIGNED_BYTE&&(o=e===oe?t.SRGB8_ALPHA8:t.RGBA8),s===t.UNSIGNED_SHORT_4_4_4_4&&(o=t.RGBA4),s===t.UNSIGNED_SHORT_5_5_5_1&&(o=t.RGB5_A1)}return o!==t.R16F&&o!==t.R32F&&o!==t.RG16F&&o!==t.RG32F&&o!==t.RGBA16F&&o!==t.RGBA32F||e.get("EXT_color_buffer_float"),o}function M(e,i){let n;return e?null===i||i===tt||i===at?n=t.DEPTH24_STENCIL8:i===et?n=t.DEPTH32F_STENCIL8:i===Q&&(n=t.DEPTH24_STENCIL8,De("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):null===i||i===tt||i===at?n=t.DEPTH_COMPONENT24:i===et?n=t.DEPTH_COMPONENT32F:i===Q&&(n=t.DEPTH_COMPONENT16),n}function _(t,e){return!0===f(t)||t.isFramebufferTexture&&t.minFilter!==H&&t.minFilter!==X?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function x(t){const e=t.target;e.removeEventListener("dispose",x),function(t){const e=n.get(t);if(void 0===e.__webglInit)return;const i=t.source,s=d.get(i);if(s){const n=s[e.__cacheKey];n.usedTimes--,0===n.usedTimes&&S(t),0===Object.keys(s).length&&d.delete(i)}n.remove(t)}(e),e.isVideoTexture&&c.delete(e)}function w(e){const i=e.target;i.removeEventListener("dispose",w),function(e){const i=n.get(e);if(e.depthTexture&&(e.depthTexture.dispose(),n.remove(e.depthTexture)),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++){if(Array.isArray(i.__webglFramebuffer[e]))for(let n=0;n<i.__webglFramebuffer[e].length;n++)t.deleteFramebuffer(i.__webglFramebuffer[e][n]);else t.deleteFramebuffer(i.__webglFramebuffer[e]);i.__webglDepthbuffer&&t.deleteRenderbuffer(i.__webglDepthbuffer[e])}else{if(Array.isArray(i.__webglFramebuffer))for(let e=0;e<i.__webglFramebuffer.length;e++)t.deleteFramebuffer(i.__webglFramebuffer[e]);else t.deleteFramebuffer(i.__webglFramebuffer);if(i.__webglDepthbuffer&&t.deleteRenderbuffer(i.__webglDepthbuffer),i.__webglMultisampledFramebuffer&&t.deleteFramebuffer(i.__webglMultisampledFramebuffer),i.__webglColorRenderbuffer)for(let e=0;e<i.__webglColorRenderbuffer.length;e++)i.__webglColorRenderbuffer[e]&&t.deleteRenderbuffer(i.__webglColorRenderbuffer[e]);i.__webglDepthRenderbuffer&&t.deleteRenderbuffer(i.__webglDepthRenderbuffer)}const s=e.textures;for(let e=0,i=s.length;e<i;e++){const i=n.get(s[e]);i.__webglTexture&&(t.deleteTexture(i.__webglTexture),r.memory.textures--),n.remove(s[e])}n.remove(e)}(i)}function S(e){const i=n.get(e);t.deleteTexture(i.__webglTexture);const s=e.source;delete d.get(s)[i.__cacheKey],r.memory.textures--}let T=0;function C(e,s){const a=n.get(e);if(e.isVideoTexture&&function(t){const e=r.render.frame;c.get(t)!==e&&(c.set(t,e),t.update())}(e),!1===e.isRenderTargetTexture&&!0!==e.isExternalTexture&&e.version>0&&a.__version!==e.version){const t=e.image;if(null===t)De("WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==t.complete)return void B(a,e,s);De("WebGLRenderer: Texture marked for update but image is incomplete")}}else e.isExternalTexture&&(a.__webglTexture=e.sourceTexture?e.sourceTexture:null);i.bindTexture(t.TEXTURE_2D,a.__webglTexture,t.TEXTURE0+s)}const E={[N]:t.REPEAT,[G]:t.CLAMP_TO_EDGE,[V]:t.MIRRORED_REPEAT},A={[H]:t.NEAREST,[W]:t.NEAREST_MIPMAP_NEAREST,[j]:t.NEAREST_MIPMAP_LINEAR,[X]:t.LINEAR,[q]:t.LINEAR_MIPMAP_NEAREST,[Y]:t.LINEAR_MIPMAP_LINEAR},P={[he]:t.NEVER,[fe]:t.ALWAYS,[ce]:t.LESS,[de]:t.LEQUAL,[ue]:t.EQUAL,[ge]:t.GEQUAL,[pe]:t.GREATER,[me]:t.NOTEQUAL};function D(i,a){if(a.type!==et||!1!==e.has("OES_texture_float_linear")||a.magFilter!==X&&a.magFilter!==q&&a.magFilter!==j&&a.magFilter!==Y&&a.minFilter!==X&&a.minFilter!==q&&a.minFilter!==j&&a.minFilter!==Y||De("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),t.texParameteri(i,t.TEXTURE_WRAP_S,E[a.wrapS]),t.texParameteri(i,t.TEXTURE_WRAP_T,E[a.wrapT]),i!==t.TEXTURE_3D&&i!==t.TEXTURE_2D_ARRAY||t.texParameteri(i,t.TEXTURE_WRAP_R,E[a.wrapR]),t.texParameteri(i,t.TEXTURE_MAG_FILTER,A[a.magFilter]),t.texParameteri(i,t.TEXTURE_MIN_FILTER,A[a.minFilter]),a.compareFunction&&(t.texParameteri(i,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(i,t.TEXTURE_COMPARE_FUNC,P[a.compareFunction])),!0===e.has("EXT_texture_filter_anisotropic")){if(a.magFilter===H)return;if(a.minFilter!==j&&a.minFilter!==Y)return;if(a.type===et&&!1===e.has("OES_texture_float_linear"))return;if(a.anisotropy>1||n.get(a).__currentAnisotropy){const r=e.get("EXT_texture_filter_anisotropic");t.texParameterf(i,r.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(a.anisotropy,s.getMaxAnisotropy())),n.get(a).__currentAnisotropy=a.anisotropy}}}function R(e,i){let n=!1;void 0===e.__webglInit&&(e.__webglInit=!0,i.addEventListener("dispose",x));const s=i.source;let a=d.get(s);void 0===a&&(a={},d.set(s,a));const o=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.wrapR||0),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.colorSpace),e.join()}(i);if(o!==e.__cacheKey){void 0===a[o]&&(a[o]={texture:t.createTexture(),usedTimes:0},r.memory.textures++,n=!0),a[o].usedTimes++;const s=a[e.__cacheKey];void 0!==s&&(a[e.__cacheKey].usedTimes--,0===s.usedTimes&&S(i)),e.__cacheKey=o,e.__webglTexture=a[o].texture}return n}function I(t,e,i){return Math.floor(Math.floor(t/i)/e)}function B(e,r,o){let l=t.TEXTURE_2D;(r.isDataArrayTexture||r.isCompressedArrayTexture)&&(l=t.TEXTURE_2D_ARRAY),r.isData3DTexture&&(l=t.TEXTURE_3D);const h=R(e,r),c=r.source;i.bindTexture(l,e.__webglTexture,t.TEXTURE0+o);const u=n.get(c);if(c.version!==u.__version||!0===h){i.activeTexture(t.TEXTURE0+o);const e=ei.getPrimaries(ei.workingColorSpace),n=r.colorSpace===ne?null:ei.getPrimaries(r.colorSpace),d=r.colorSpace===ne||e===n?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,r.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,d);let p=g(r.image,!1,s.maxTextureSize);p=K(r,p);const m=a.convert(r.format,r.colorSpace),v=a.convert(r.type);let x,w=b(r.internalFormat,m,v,r.colorSpace,r.isVideoTexture);D(l,r);const S=r.mipmaps,T=!0!==r.isVideoTexture,C=void 0===u.__version||!0===h,E=c.dataReady,A=_(r,p);if(r.isDepthTexture)w=M(r.format===dt,r.type),C&&(T?i.texStorage2D(t.TEXTURE_2D,1,w,p.width,p.height):i.texImage2D(t.TEXTURE_2D,0,w,p.width,p.height,0,m,v,null));else if(r.isDataTexture)if(S.length>0){T&&C&&i.texStorage2D(t.TEXTURE_2D,A,w,S[0].width,S[0].height);for(let e=0,n=S.length;e<n;e++)x=S[e],T?E&&i.texSubImage2D(t.TEXTURE_2D,e,0,0,x.width,x.height,m,v,x.data):i.texImage2D(t.TEXTURE_2D,e,w,x.width,x.height,0,m,v,x.data);r.generateMipmaps=!1}else T?(C&&i.texStorage2D(t.TEXTURE_2D,A,w,p.width,p.height),E&&function(e,n,s,a){const r=e.updateRanges;if(0===r.length)i.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,s,a,n.data);else{r.sort((t,e)=>t.start-e.start);let o=0;for(let t=1;t<r.length;t++){const e=r[o],i=r[t],s=e.start+e.count,a=I(i.start,n.width,4),l=I(e.start,n.width,4);i.start<=s+1&&a===l&&I(i.start+i.count-1,n.width,4)===a?e.count=Math.max(e.count,i.start+i.count-e.start):(++o,r[o]=i)}r.length=o+1;const l=t.getParameter(t.UNPACK_ROW_LENGTH),h=t.getParameter(t.UNPACK_SKIP_PIXELS),c=t.getParameter(t.UNPACK_SKIP_ROWS);t.pixelStorei(t.UNPACK_ROW_LENGTH,n.width);for(let e=0,o=r.length;e<o;e++){const o=r[e],l=Math.floor(o.start/4),h=Math.ceil(o.count/4),c=l%n.width,u=Math.floor(l/n.width),d=h,p=1;t.pixelStorei(t.UNPACK_SKIP_PIXELS,c),t.pixelStorei(t.UNPACK_SKIP_ROWS,u),i.texSubImage2D(t.TEXTURE_2D,0,c,u,d,p,s,a,n.data)}e.clearUpdateRanges(),t.pixelStorei(t.UNPACK_ROW_LENGTH,l),t.pixelStorei(t.UNPACK_SKIP_PIXELS,h),t.pixelStorei(t.UNPACK_SKIP_ROWS,c)}}(r,p,m,v)):i.texImage2D(t.TEXTURE_2D,0,w,p.width,p.height,0,m,v,p.data);else if(r.isCompressedTexture)if(r.isCompressedArrayTexture){T&&C&&i.texStorage3D(t.TEXTURE_2D_ARRAY,A,w,S[0].width,S[0].height,p.depth);for(let e=0,n=S.length;e<n;e++)if(x=S[e],r.format!==ct)if(null!==m)if(T){if(E)if(r.layerUpdates.size>0){const n=Ic(x.width,x.height,r.format,r.type);for(const s of r.layerUpdates){const a=x.data.subarray(s*n/x.data.BYTES_PER_ELEMENT,(s+1)*n/x.data.BYTES_PER_ELEMENT);i.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,s,x.width,x.height,1,m,a)}r.clearLayerUpdates()}else i.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,x.width,x.height,p.depth,m,x.data)}else i.compressedTexImage3D(t.TEXTURE_2D_ARRAY,e,w,x.width,x.height,p.depth,0,x.data,0,0);else De("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else T?E&&i.texSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,x.width,x.height,p.depth,m,v,x.data):i.texImage3D(t.TEXTURE_2D_ARRAY,e,w,x.width,x.height,p.depth,0,m,v,x.data)}else{T&&C&&i.texStorage2D(t.TEXTURE_2D,A,w,S[0].width,S[0].height);for(let e=0,n=S.length;e<n;e++)x=S[e],r.format!==ct?null!==m?T?E&&i.compressedTexSubImage2D(t.TEXTURE_2D,e,0,0,x.width,x.height,m,x.data):i.compressedTexImage2D(t.TEXTURE_2D,e,w,x.width,x.height,0,x.data):De("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):T?E&&i.texSubImage2D(t.TEXTURE_2D,e,0,0,x.width,x.height,m,v,x.data):i.texImage2D(t.TEXTURE_2D,e,w,x.width,x.height,0,m,v,x.data)}else if(r.isDataArrayTexture)if(T){if(C&&i.texStorage3D(t.TEXTURE_2D_ARRAY,A,w,p.width,p.height,p.depth),E)if(r.layerUpdates.size>0){const e=Ic(p.width,p.height,r.format,r.type);for(const n of r.layerUpdates){const s=p.data.subarray(n*e/p.data.BYTES_PER_ELEMENT,(n+1)*e/p.data.BYTES_PER_ELEMENT);i.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,n,p.width,p.height,1,m,v,s)}r.clearLayerUpdates()}else i.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,p.width,p.height,p.depth,m,v,p.data)}else i.texImage3D(t.TEXTURE_2D_ARRAY,0,w,p.width,p.height,p.depth,0,m,v,p.data);else if(r.isData3DTexture)T?(C&&i.texStorage3D(t.TEXTURE_3D,A,w,p.width,p.height,p.depth),E&&i.texSubImage3D(t.TEXTURE_3D,0,0,0,0,p.width,p.height,p.depth,m,v,p.data)):i.texImage3D(t.TEXTURE_3D,0,w,p.width,p.height,p.depth,0,m,v,p.data);else if(r.isFramebufferTexture){if(C)if(T)i.texStorage2D(t.TEXTURE_2D,A,w,p.width,p.height);else{let e=p.width,n=p.height;for(let s=0;s<A;s++)i.texImage2D(t.TEXTURE_2D,s,w,e,n,0,m,v,null),e>>=1,n>>=1}}else if(S.length>0){if(T&&C){const e=it(S[0]);i.texStorage2D(t.TEXTURE_2D,A,w,e.width,e.height)}for(let e=0,n=S.length;e<n;e++)x=S[e],T?E&&i.texSubImage2D(t.TEXTURE_2D,e,0,0,m,v,x):i.texImage2D(t.TEXTURE_2D,e,w,m,v,x);r.generateMipmaps=!1}else if(T){if(C){const e=it(p);i.texStorage2D(t.TEXTURE_2D,A,w,e.width,e.height)}E&&i.texSubImage2D(t.TEXTURE_2D,0,0,0,m,v,p)}else i.texImage2D(t.TEXTURE_2D,0,w,m,v,p);f(r)&&y(l),u.__version=c.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}function L(e,s,r,l,h,c){const u=a.convert(r.format,r.colorSpace),d=a.convert(r.type),p=b(r.internalFormat,u,d,r.colorSpace),m=n.get(s),g=n.get(r);if(g.__renderTarget=s,!m.__hasExternalTextures){const e=Math.max(1,s.width>>c),n=Math.max(1,s.height>>c);h===t.TEXTURE_3D||h===t.TEXTURE_2D_ARRAY?i.texImage3D(h,c,p,e,n,s.depth,0,u,d,null):i.texImage2D(h,c,p,e,n,0,u,d,null)}i.bindFramebuffer(t.FRAMEBUFFER,e),J(s)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,l,h,g.__webglTexture,0,Z(s)):(h===t.TEXTURE_2D||h>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&h<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,l,h,g.__webglTexture,c),i.bindFramebuffer(t.FRAMEBUFFER,null)}function k(e,i,n){if(t.bindRenderbuffer(t.RENDERBUFFER,e),i.depthBuffer){const s=i.depthTexture,a=s&&s.isDepthTexture?s.type:null,r=M(i.stencilBuffer,a),l=i.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,h=Z(i);J(i)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,h,r,i.width,i.height):n?t.renderbufferStorageMultisample(t.RENDERBUFFER,h,r,i.width,i.height):t.renderbufferStorage(t.RENDERBUFFER,r,i.width,i.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,l,t.RENDERBUFFER,e)}else{const e=i.textures;for(let s=0;s<e.length;s++){const r=e[s],l=a.convert(r.format,r.colorSpace),h=a.convert(r.type),c=b(r.internalFormat,l,h,r.colorSpace),u=Z(i);n&&!1===J(i)?t.renderbufferStorageMultisample(t.RENDERBUFFER,u,c,i.width,i.height):J(i)?o.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,u,c,i.width,i.height):t.renderbufferStorage(t.RENDERBUFFER,c,i.width,i.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function O(e,s){if(s&&s.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(i.bindFramebuffer(t.FRAMEBUFFER,e),!s.depthTexture||!s.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const a=n.get(s.depthTexture);a.__renderTarget=s,a.__webglTexture&&s.depthTexture.image.width===s.width&&s.depthTexture.image.height===s.height||(s.depthTexture.image.width=s.width,s.depthTexture.image.height=s.height,s.depthTexture.needsUpdate=!0),C(s.depthTexture,0);const r=a.__webglTexture,l=Z(s);if(s.depthTexture.format===ut)J(s)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,r,0,l):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,r,0);else{if(s.depthTexture.format!==dt)throw new Error("Unknown depthTexture format");J(s)?o.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,r,0,l):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,r,0)}}function z(e){const s=n.get(e),a=!0===e.isWebGLCubeRenderTarget;if(s.__boundDepthTexture!==e.depthTexture){const t=e.depthTexture;if(s.__depthDisposeCallback&&s.__depthDisposeCallback(),t){const e=()=>{delete s.__boundDepthTexture,delete s.__depthDisposeCallback,t.removeEventListener("dispose",e)};t.addEventListener("dispose",e),s.__depthDisposeCallback=e}s.__boundDepthTexture=t}if(e.depthTexture&&!s.__autoAllocateDepthBuffer){if(a)throw new Error("target.depthTexture not supported in Cube render targets");const t=e.texture.mipmaps;t&&t.length>0?O(s.__webglFramebuffer[0],e):O(s.__webglFramebuffer,e)}else if(a){s.__webglDepthbuffer=[];for(let n=0;n<6;n++)if(i.bindFramebuffer(t.FRAMEBUFFER,s.__webglFramebuffer[n]),void 0===s.__webglDepthbuffer[n])s.__webglDepthbuffer[n]=t.createRenderbuffer(),k(s.__webglDepthbuffer[n],e,!1);else{const i=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,a=s.__webglDepthbuffer[n];t.bindRenderbuffer(t.RENDERBUFFER,a),t.framebufferRenderbuffer(t.FRAMEBUFFER,i,t.RENDERBUFFER,a)}}else{const n=e.texture.mipmaps;if(n&&n.length>0?i.bindFramebuffer(t.FRAMEBUFFER,s.__webglFramebuffer[0]):i.bindFramebuffer(t.FRAMEBUFFER,s.__webglFramebuffer),void 0===s.__webglDepthbuffer)s.__webglDepthbuffer=t.createRenderbuffer(),k(s.__webglDepthbuffer,e,!1);else{const i=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,n=s.__webglDepthbuffer;t.bindRenderbuffer(t.RENDERBUFFER,n),t.framebufferRenderbuffer(t.FRAMEBUFFER,i,t.RENDERBUFFER,n)}}i.bindFramebuffer(t.FRAMEBUFFER,null)}const F=[],U=[];function Z(t){return Math.min(s.maxSamples,t.samples)}function J(t){const i=n.get(t);return t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==i.__useRenderToTexture}function K(t,e){const i=t.colorSpace,n=t.format,s=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||i!==ae&&i!==ne&&(ei.getTransfer(i)===oe?n===ct&&s===$||De("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):Re("WebGLTextures: Unsupported texture color space:",i)),e}function it(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement?(h.width=t.naturalWidth||t.width,h.height=t.naturalHeight||t.height):"undefined"!=typeof VideoFrame&&t instanceof VideoFrame?(h.width=t.displayWidth,h.height=t.displayHeight):(h.width=t.width,h.height=t.height),h}this.allocateTextureUnit=function(){const t=T;return t>=s.maxTextures&&De("WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+s.maxTextures),T+=1,t},this.resetTextureUnits=function(){T=0},this.setTexture2D=C,this.setTexture2DArray=function(e,s){const a=n.get(e);!1===e.isRenderTargetTexture&&e.version>0&&a.__version!==e.version?B(a,e,s):(e.isExternalTexture&&(a.__webglTexture=e.sourceTexture?e.sourceTexture:null),i.bindTexture(t.TEXTURE_2D_ARRAY,a.__webglTexture,t.TEXTURE0+s))},this.setTexture3D=function(e,s){const a=n.get(e);!1===e.isRenderTargetTexture&&e.version>0&&a.__version!==e.version?B(a,e,s):i.bindTexture(t.TEXTURE_3D,a.__webglTexture,t.TEXTURE0+s)},this.setTextureCube=function(e,r){const o=n.get(e);e.version>0&&o.__version!==e.version?function(e,r,o){if(6!==r.image.length)return;const l=R(e,r),h=r.source;i.bindTexture(t.TEXTURE_CUBE_MAP,e.__webglTexture,t.TEXTURE0+o);const c=n.get(h);if(h.version!==c.__version||!0===l){i.activeTexture(t.TEXTURE0+o);const e=ei.getPrimaries(ei.workingColorSpace),n=r.colorSpace===ne?null:ei.getPrimaries(r.colorSpace),u=r.colorSpace===ne||e===n?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,r.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,u);const d=r.isCompressedTexture||r.image[0].isCompressedTexture,p=r.image[0]&&r.image[0].isDataTexture,m=[];for(let t=0;t<6;t++)m[t]=d||p?p?r.image[t].image:r.image[t]:g(r.image[t],!0,s.maxCubemapSize),m[t]=K(r,m[t]);const v=m[0],M=a.convert(r.format,r.colorSpace),x=a.convert(r.type),w=b(r.internalFormat,M,x,r.colorSpace),S=!0!==r.isVideoTexture,T=void 0===c.__version||!0===l,C=h.dataReady;let E,A=_(r,v);if(D(t.TEXTURE_CUBE_MAP,r),d){S&&T&&i.texStorage2D(t.TEXTURE_CUBE_MAP,A,w,v.width,v.height);for(let e=0;e<6;e++){E=m[e].mipmaps;for(let n=0;n<E.length;n++){const s=E[n];r.format!==ct?null!==M?S?C&&i.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,s.width,s.height,M,s.data):i.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,w,s.width,s.height,0,s.data):De("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):S?C&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,s.width,s.height,M,x,s.data):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,w,s.width,s.height,0,M,x,s.data)}}}else{if(E=r.mipmaps,S&&T){E.length>0&&A++;const e=it(m[0]);i.texStorage2D(t.TEXTURE_CUBE_MAP,A,w,e.width,e.height)}for(let e=0;e<6;e++)if(p){S?C&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,m[e].width,m[e].height,M,x,m[e].data):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,w,m[e].width,m[e].height,0,M,x,m[e].data);for(let n=0;n<E.length;n++){const s=E[n].image[e].image;S?C&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n+1,0,0,s.width,s.height,M,x,s.data):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n+1,w,s.width,s.height,0,M,x,s.data)}}else{S?C&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,M,x,m[e]):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,w,M,x,m[e]);for(let n=0;n<E.length;n++){const s=E[n];S?C&&i.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n+1,0,0,M,x,s.image[e]):i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,n+1,w,M,x,s.image[e])}}}f(r)&&y(t.TEXTURE_CUBE_MAP),c.__version=h.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}(o,e,r):i.bindTexture(t.TEXTURE_CUBE_MAP,o.__webglTexture,t.TEXTURE0+r)},this.rebindTextures=function(e,i,s){const a=n.get(e);void 0!==i&&L(a.__webglFramebuffer,e,e.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,0),void 0!==s&&z(e)},this.setupRenderTarget=function(e){const s=e.texture,o=n.get(e),l=n.get(s);e.addEventListener("dispose",w);const h=e.textures,c=!0===e.isWebGLCubeRenderTarget,u=h.length>1;if(u||(void 0===l.__webglTexture&&(l.__webglTexture=t.createTexture()),l.__version=s.version,r.memory.textures++),c){o.__webglFramebuffer=[];for(let e=0;e<6;e++)if(s.mipmaps&&s.mipmaps.length>0){o.__webglFramebuffer[e]=[];for(let i=0;i<s.mipmaps.length;i++)o.__webglFramebuffer[e][i]=t.createFramebuffer()}else o.__webglFramebuffer[e]=t.createFramebuffer()}else{if(s.mipmaps&&s.mipmaps.length>0){o.__webglFramebuffer=[];for(let e=0;e<s.mipmaps.length;e++)o.__webglFramebuffer[e]=t.createFramebuffer()}else o.__webglFramebuffer=t.createFramebuffer();if(u)for(let e=0,i=h.length;e<i;e++){const i=n.get(h[e]);void 0===i.__webglTexture&&(i.__webglTexture=t.createTexture(),r.memory.textures++)}if(e.samples>0&&!1===J(e)){o.__webglMultisampledFramebuffer=t.createFramebuffer(),o.__webglColorRenderbuffer=[],i.bindFramebuffer(t.FRAMEBUFFER,o.__webglMultisampledFramebuffer);for(let i=0;i<h.length;i++){const n=h[i];o.__webglColorRenderbuffer[i]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,o.__webglColorRenderbuffer[i]);const s=a.convert(n.format,n.colorSpace),r=a.convert(n.type),l=b(n.internalFormat,s,r,n.colorSpace,!0===e.isXRRenderTarget),c=Z(e);t.renderbufferStorageMultisample(t.RENDERBUFFER,c,l,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+i,t.RENDERBUFFER,o.__webglColorRenderbuffer[i])}t.bindRenderbuffer(t.RENDERBUFFER,null),e.depthBuffer&&(o.__webglDepthRenderbuffer=t.createRenderbuffer(),k(o.__webglDepthRenderbuffer,e,!0)),i.bindFramebuffer(t.FRAMEBUFFER,null)}}if(c){i.bindTexture(t.TEXTURE_CUBE_MAP,l.__webglTexture),D(t.TEXTURE_CUBE_MAP,s);for(let i=0;i<6;i++)if(s.mipmaps&&s.mipmaps.length>0)for(let n=0;n<s.mipmaps.length;n++)L(o.__webglFramebuffer[i][n],e,s,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+i,n);else L(o.__webglFramebuffer[i],e,s,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+i,0);f(s)&&y(t.TEXTURE_CUBE_MAP),i.unbindTexture()}else if(u){for(let s=0,a=h.length;s<a;s++){const a=h[s],r=n.get(a);let l=t.TEXTURE_2D;(e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(l=e.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY),i.bindTexture(l,r.__webglTexture),D(l,a),L(o.__webglFramebuffer,e,a,t.COLOR_ATTACHMENT0+s,l,0),f(a)&&y(l)}i.unbindTexture()}else{let n=t.TEXTURE_2D;if((e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(n=e.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY),i.bindTexture(n,l.__webglTexture),D(n,s),s.mipmaps&&s.mipmaps.length>0)for(let i=0;i<s.mipmaps.length;i++)L(o.__webglFramebuffer[i],e,s,t.COLOR_ATTACHMENT0,n,i);else L(o.__webglFramebuffer,e,s,t.COLOR_ATTACHMENT0,n,0);f(s)&&y(n),i.unbindTexture()}e.depthBuffer&&z(e)},this.updateRenderTargetMipmap=function(t){const e=t.textures;for(let s=0,a=e.length;s<a;s++){const a=e[s];if(f(a)){const e=v(t),s=n.get(a).__webglTexture;i.bindTexture(e,s),y(e),i.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(e.samples>0)if(!1===J(e)){const s=e.textures,a=e.width,r=e.height;let o=t.COLOR_BUFFER_BIT;const h=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,c=n.get(e),u=s.length>1;if(u)for(let e=0;e<s.length;e++)i.bindFramebuffer(t.FRAMEBUFFER,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,null),i.bindFramebuffer(t.FRAMEBUFFER,c.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,null,0);i.bindFramebuffer(t.READ_FRAMEBUFFER,c.__webglMultisampledFramebuffer);const d=e.texture.mipmaps;d&&d.length>0?i.bindFramebuffer(t.DRAW_FRAMEBUFFER,c.__webglFramebuffer[0]):i.bindFramebuffer(t.DRAW_FRAMEBUFFER,c.__webglFramebuffer);for(let i=0;i<s.length;i++){if(e.resolveDepthBuffer&&(e.depthBuffer&&(o|=t.DEPTH_BUFFER_BIT),e.stencilBuffer&&e.resolveStencilBuffer&&(o|=t.STENCIL_BUFFER_BIT)),u){t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,c.__webglColorRenderbuffer[i]);const e=n.get(s[i]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)}t.blitFramebuffer(0,0,a,r,0,0,a,r,o,t.NEAREST),!0===l&&(F.length=0,U.length=0,F.push(t.COLOR_ATTACHMENT0+i),e.depthBuffer&&!1===e.resolveDepthBuffer&&(F.push(h),U.push(h),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,U)),t.invalidateFramebuffer(t.READ_FRAMEBUFFER,F))}if(i.bindFramebuffer(t.READ_FRAMEBUFFER,null),i.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),u)for(let e=0;e<s.length;e++){i.bindFramebuffer(t.FRAMEBUFFER,c.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,c.__webglColorRenderbuffer[e]);const a=n.get(s[e]).__webglTexture;i.bindFramebuffer(t.FRAMEBUFFER,c.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,a,0)}i.bindFramebuffer(t.DRAW_FRAMEBUFFER,c.__webglMultisampledFramebuffer)}else if(e.depthBuffer&&!1===e.resolveDepthBuffer&&l){const i=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT;t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[i])}},this.setupDepthRenderbuffer=z,this.setupFrameBufferTexture=L,this.useMultisampledRTT=J}function ip(t,e){return{convert:function(i,n=""){let s;const a=ei.getTransfer(n);if(i===$)return t.UNSIGNED_BYTE;if(i===nt)return t.UNSIGNED_SHORT_4_4_4_4;if(i===st)return t.UNSIGNED_SHORT_5_5_5_1;if(i===rt)return t.UNSIGNED_INT_5_9_9_9_REV;if(i===ot)return t.UNSIGNED_INT_10F_11F_11F_REV;if(i===Z)return t.BYTE;if(i===J)return t.SHORT;if(i===Q)return t.UNSIGNED_SHORT;if(i===K)return t.INT;if(i===tt)return t.UNSIGNED_INT;if(i===et)return t.FLOAT;if(i===it)return t.HALF_FLOAT;if(i===lt)return t.ALPHA;if(i===ht)return t.RGB;if(i===ct)return t.RGBA;if(i===ut)return t.DEPTH_COMPONENT;if(i===dt)return t.DEPTH_STENCIL;if(i===pt)return t.RED;if(i===mt)return t.RED_INTEGER;if(i===gt)return t.RG;if(i===ft)return t.RG_INTEGER;if(i===yt)return t.RGBA_INTEGER;if(i===vt||i===bt||i===Mt||i===_t)if(a===oe){if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(i===vt)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===bt)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===Mt)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===_t)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=e.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(i===vt)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===bt)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===Mt)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===_t)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===xt||i===wt||i===St||i===Tt){if(s=e.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(i===xt)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===wt)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===St)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===Tt)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===Ct||i===Et||i===At){if(s=e.get("WEBGL_compressed_texture_etc"),null===s)return null;if(i===Ct||i===Et)return a===oe?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(i===At)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(i===Pt||i===Dt||i===Rt||i===It||i===Bt||i===Lt||i===kt||i===Ot||i===zt||i===Ft||i===Ut||i===Nt||i===Gt||i===Vt){if(s=e.get("WEBGL_compressed_texture_astc"),null===s)return null;if(i===Pt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===Dt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===Rt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===It)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===Bt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===Lt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===kt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===Ot)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===zt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===Ft)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===Ut)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===Nt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===Gt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===Vt)return a===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(i===Ht||i===Wt||i===jt){if(s=e.get("EXT_texture_compression_bptc"),null===s)return null;if(i===Ht)return a===oe?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(i===Wt)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(i===jt)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(i===Xt||i===qt||i===Yt||i===$t){if(s=e.get("EXT_texture_compression_rgtc"),null===s)return null;if(i===Xt)return s.COMPRESSED_RED_RGTC1_EXT;if(i===qt)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===Yt)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===$t)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return i===at?t.UNSIGNED_INT_24_8:void 0!==t[i]?t[i]:null}}}class np{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(t,e){if(null===this.texture){const i=new kr(t.texture);t.depthNear===e.depthNear&&t.depthFar===e.depthFar||(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=i}}getMesh(t){if(null!==this.texture&&null===this.mesh){const e=t.cameras[0].viewport,i=new Cs({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new bs(new Jo(20,20),i)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class sp extends Be{constructor(t,e){super();const i=this;let n=null,s=1,a=null,r="local-floor",o=1,l=null,h=null,c=null,u=null,d=null,p=null;const m="undefined"!=typeof XRWebGLBinding,g=new np,f={},y=e.getContextAttributes();let v=null,b=null;const M=[],_=[],x=new je;let w=null;const S=new Rs;S.viewport=new di;const T=new Rs;T.viewport=new di;const C=[S,T],E=new Ph;let A=null,P=null;function D(t){const e=_.indexOf(t.inputSource);if(-1===e)return;const i=M[e];void 0!==i&&(i.update(t.inputSource,t.frame,l||a),i.dispatchEvent({type:t.type,data:t.inputSource}))}function R(){n.removeEventListener("select",D),n.removeEventListener("selectstart",D),n.removeEventListener("selectend",D),n.removeEventListener("squeeze",D),n.removeEventListener("squeezestart",D),n.removeEventListener("squeezeend",D),n.removeEventListener("end",R),n.removeEventListener("inputsourceschange",I);for(let t=0;t<M.length;t++){const e=_[t];null!==e&&(_[t]=null,M[t].disconnect(e))}A=null,P=null,g.reset();for(const t in f)delete f[t];t.setRenderTarget(v),d=null,u=null,c=null,n=null,b=null,z.stop(),i.isPresenting=!1,t.setPixelRatio(w),t.setSize(x.width,x.height,!1),i.dispatchEvent({type:"sessionend"})}function I(t){for(let e=0;e<t.removed.length;e++){const i=t.removed[e],n=_.indexOf(i);n>=0&&(_[n]=null,M[n].disconnect(i))}for(let e=0;e<t.added.length;e++){const i=t.added[e];let n=_.indexOf(i);if(-1===n){for(let t=0;t<M.length;t++){if(t>=_.length){_.push(i),n=t;break}if(null===_[t]){_[t]=i,n=t;break}}if(-1===n)break}const s=M[n];s&&s.connect(i)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=M[t];return void 0===e&&(e=new Fs,M[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=M[t];return void 0===e&&(e=new Fs,M[t]=e),e.getGripSpace()},this.getHand=function(t){let e=M[t];return void 0===e&&(e=new Fs,M[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){s=t,!0===i.isPresenting&&De("WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){r=t,!0===i.isPresenting&&De("WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||a},this.setReferenceSpace=function(t){l=t},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return null===c&&m&&(c=new XRWebGLBinding(n,e)),c},this.getFrame=function(){return p},this.getSession=function(){return n},this.setSession=async function(h){if(n=h,null!==n){if(v=t.getRenderTarget(),n.addEventListener("select",D),n.addEventListener("selectstart",D),n.addEventListener("selectend",D),n.addEventListener("squeeze",D),n.addEventListener("squeezestart",D),n.addEventListener("squeezeend",D),n.addEventListener("end",R),n.addEventListener("inputsourceschange",I),!0!==y.xrCompatible&&await e.makeXRCompatible(),w=t.getPixelRatio(),t.getSize(x),m&&"createProjectionLayer"in XRWebGLBinding.prototype){let i=null,a=null,r=null;y.depth&&(r=y.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,i=y.stencil?dt:ut,a=y.stencil?at:tt);const o={colorFormat:e.RGBA8,depthFormat:r,scaleFactor:s};c=this.getBinding(),u=c.createProjectionLayer(o),n.updateRenderState({layers:[u]}),t.setPixelRatio(1),t.setSize(u.textureWidth,u.textureHeight,!1),b=new mi(u.textureWidth,u.textureHeight,{format:ct,type:$,depthTexture:new Lr(u.textureWidth,u.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,i),stencilBuffer:y.stencil,colorSpace:t.outputColorSpace,samples:y.antialias?4:0,resolveDepthBuffer:!1===u.ignoreDepthValues,resolveStencilBuffer:!1===u.ignoreDepthValues})}else{const i={antialias:y.antialias,alpha:!0,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(n,e,i),n.updateRenderState({baseLayer:d}),t.setPixelRatio(1),t.setSize(d.framebufferWidth,d.framebufferHeight,!1),b=new mi(d.framebufferWidth,d.framebufferHeight,{format:ct,type:$,colorSpace:t.outputColorSpace,stencilBuffer:y.stencil,resolveDepthBuffer:!1===d.ignoreDepthValues,resolveStencilBuffer:!1===d.ignoreDepthValues})}b.isXRRenderTarget=!0,this.setFoveation(o),l=null,a=await n.requestReferenceSpace(r),z.setContext(n),z.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==n)return n.environmentBlendMode},this.getDepthTexture=function(){return g.getDepthTexture()};const B=new qe,L=new qe;function k(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===n)return;let e=t.near,i=t.far;null!==g.texture&&(g.depthNear>0&&(e=g.depthNear),g.depthFar>0&&(i=g.depthFar)),E.near=T.near=S.near=e,E.far=T.far=S.far=i,A===E.near&&P===E.far||(n.updateRenderState({depthNear:E.near,depthFar:E.far}),A=E.near,P=E.far),E.layers.mask=6|t.layers.mask,S.layers.mask=3&E.layers.mask,T.layers.mask=5&E.layers.mask;const s=t.parent,a=E.cameras;k(E,s);for(let t=0;t<a.length;t++)k(a[t],s);2===a.length?function(t,e,i){B.setFromMatrixPosition(e.matrixWorld),L.setFromMatrixPosition(i.matrixWorld);const n=B.distanceTo(L),s=e.projectionMatrix.elements,a=i.projectionMatrix.elements,r=s[14]/(s[10]-1),o=s[14]/(s[10]+1),l=(s[9]+1)/s[5],h=(s[9]-1)/s[5],c=(s[8]-1)/s[0],u=(a[8]+1)/a[0],d=r*c,p=r*u,m=n/(-c+u),g=m*-c;if(e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(g),t.translateZ(m),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert(),-1===s[10])t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse);else{const e=r+m,i=o+m,s=d-g,a=p+(n-g),c=l*o/i*e,u=h*o/i*e;t.projectionMatrix.makePerspective(s,a,c,u,e,i),t.projectionMatrixInverse.copy(t.projectionMatrix).invert()}}(E,S,T):E.projectionMatrix.copy(S.projectionMatrix),function(t,e,i){null===i?t.matrix.copy(e.matrixWorld):(t.matrix.copy(i.matrixWorld),t.matrix.invert(),t.matrix.multiply(e.matrixWorld)),t.matrix.decompose(t.position,t.quaternion,t.scale),t.updateMatrixWorld(!0),t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse),t.isPerspectiveCamera&&(t.fov=2*ze*Math.atan(1/t.projectionMatrix.elements[5]),t.zoom=1)}(t,E,s)},this.getCamera=function(){return E},this.getFoveation=function(){if(null!==u||null!==d)return o},this.setFoveation=function(t){o=t,null!==u&&(u.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)},this.hasDepthSensing=function(){return null!==g.texture},this.getDepthSensingMesh=function(){return g.getMesh(E)},this.getCameraTexture=function(t){return f[t]};let O=null;const z=new Bc;z.setAnimationLoop(function(e,s){if(h=s.getViewerPose(l||a),p=s,null!==h){const e=h.views;null!==d&&(t.setRenderTargetFramebuffer(b,d.framebuffer),t.setRenderTarget(b));let s=!1;e.length!==E.cameras.length&&(E.cameras.length=0,s=!0);for(let i=0;i<e.length;i++){const n=e[i];let a=null;if(null!==d)a=d.getViewport(n);else{const e=c.getViewSubImage(u,n);a=e.viewport,0===i&&(t.setRenderTargetTextures(b,e.colorTexture,e.depthStencilTexture),t.setRenderTarget(b))}let r=C[i];void 0===r&&(r=new Rs,r.layers.enable(i),r.viewport=new di,C[i]=r),r.matrix.fromArray(n.transform.matrix),r.matrix.decompose(r.position,r.quaternion,r.scale),r.projectionMatrix.fromArray(n.projectionMatrix),r.projectionMatrixInverse.copy(r.projectionMatrix).invert(),r.viewport.set(a.x,a.y,a.width,a.height),0===i&&(E.matrix.copy(r.matrix),E.matrix.decompose(E.position,E.quaternion,E.scale)),!0===s&&E.cameras.push(r)}const a=n.enabledFeatures;if(a&&a.includes("depth-sensing")&&"gpu-optimized"==n.depthUsage&&m){c=i.getBinding();const t=c.getDepthInformation(e[0]);t&&t.isValid&&t.texture&&g.init(t,n.renderState)}if(a&&a.includes("camera-access")&&m){t.state.unbindTexture(),c=i.getBinding();for(let t=0;t<e.length;t++){const i=e[t].camera;if(i){let t=f[i];t||(t=new kr,f[i]=t);const e=c.getCameraImage(i);t.sourceTexture=e}}}}for(let t=0;t<M.length;t++){const e=_[t],i=M[t];null!==e&&void 0!==i&&i.update(e,s,l||a)}O&&O(e,s),s.detectedPlanes&&i.dispatchEvent({type:"planesdetected",data:s}),p=null}),this.setAnimationLoop=function(t){O=t},this.dispose=function(){}}}const ap=new tn,rp=new Wi;function op(t,e){function i(t,e){!0===t.matrixAutoUpdate&&t.updateMatrix(),e.value.copy(t.matrix)}function n(t,n){t.opacity.value=n.opacity,n.color&&t.diffuse.value.copy(n.color),n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(t.map.value=n.map,i(n.map,t.mapTransform)),n.alphaMap&&(t.alphaMap.value=n.alphaMap,i(n.alphaMap,t.alphaMapTransform)),n.bumpMap&&(t.bumpMap.value=n.bumpMap,i(n.bumpMap,t.bumpMapTransform),t.bumpScale.value=n.bumpScale,1===n.side&&(t.bumpScale.value*=-1)),n.normalMap&&(t.normalMap.value=n.normalMap,i(n.normalMap,t.normalMapTransform),t.normalScale.value.copy(n.normalScale),1===n.side&&t.normalScale.value.negate()),n.displacementMap&&(t.displacementMap.value=n.displacementMap,i(n.displacementMap,t.displacementMapTransform),t.displacementScale.value=n.displacementScale,t.displacementBias.value=n.displacementBias),n.emissiveMap&&(t.emissiveMap.value=n.emissiveMap,i(n.emissiveMap,t.emissiveMapTransform)),n.specularMap&&(t.specularMap.value=n.specularMap,i(n.specularMap,t.specularMapTransform)),n.alphaTest>0&&(t.alphaTest.value=n.alphaTest);const s=e.get(n),a=s.envMap,r=s.envMapRotation;a&&(t.envMap.value=a,ap.copy(r),ap.x*=-1,ap.y*=-1,ap.z*=-1,a.isCubeTexture&&!1===a.isRenderTargetTexture&&(ap.y*=-1,ap.z*=-1),t.envMapRotation.value.setFromMatrix4(rp.makeRotationFromEuler(ap)),t.flipEnvMap.value=a.isCubeTexture&&!1===a.isRenderTargetTexture?-1:1,t.reflectivity.value=n.reflectivity,t.ior.value=n.ior,t.refractionRatio.value=n.refractionRatio),n.lightMap&&(t.lightMap.value=n.lightMap,t.lightMapIntensity.value=n.lightMapIntensity,i(n.lightMap,t.lightMapTransform)),n.aoMap&&(t.aoMap.value=n.aoMap,t.aoMapIntensity.value=n.aoMapIntensity,i(n.aoMap,t.aoMapTransform))}return{refreshFogUniforms:function(e,i){i.color.getRGB(e.fogColor.value,Ss(t)),i.isFog?(e.fogNear.value=i.near,e.fogFar.value=i.far):i.isFogExp2&&(e.fogDensity.value=i.density)},refreshMaterialUniforms:function(t,s,a,r,o){s.isMeshBasicMaterial||s.isMeshLambertMaterial?n(t,s):s.isMeshToonMaterial?(n(t,s),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap)}(t,s)):s.isMeshPhongMaterial?(n(t,s),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4)}(t,s)):s.isMeshStandardMaterial?(n(t,s),function(t,e){t.metalness.value=e.metalness,e.metalnessMap&&(t.metalnessMap.value=e.metalnessMap,i(e.metalnessMap,t.metalnessMapTransform)),t.roughness.value=e.roughness,e.roughnessMap&&(t.roughnessMap.value=e.roughnessMap,i(e.roughnessMap,t.roughnessMapTransform)),e.envMap&&(t.envMapIntensity.value=e.envMapIntensity)}(t,s),s.isMeshPhysicalMaterial&&function(t,e,n){t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap,i(e.sheenColorMap,t.sheenColorMapTransform)),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap,i(e.sheenRoughnessMap,t.sheenRoughnessMapTransform))),e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap,i(e.clearcoatMap,t.clearcoatMapTransform)),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap,i(e.clearcoatRoughnessMap,t.clearcoatRoughnessMapTransform)),e.clearcoatNormalMap&&(t.clearcoatNormalMap.value=e.clearcoatNormalMap,i(e.clearcoatNormalMap,t.clearcoatNormalMapTransform),t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),1===e.side&&t.clearcoatNormalScale.value.negate())),e.dispersion>0&&(t.dispersion.value=e.dispersion),e.iridescence>0&&(t.iridescence.value=e.iridescence,t.iridescenceIOR.value=e.iridescenceIOR,t.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],t.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(t.iridescenceMap.value=e.iridescenceMap,i(e.iridescenceMap,t.iridescenceMapTransform)),e.iridescenceThicknessMap&&(t.iridescenceThicknessMap.value=e.iridescenceThicknessMap,i(e.iridescenceThicknessMap,t.iridescenceThicknessMapTransform))),e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=n.texture,t.transmissionSamplerSize.value.set(n.width,n.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap,i(e.transmissionMap,t.transmissionMapTransform)),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap,i(e.thicknessMap,t.thicknessMapTransform)),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor)),e.anisotropy>0&&(t.anisotropyVector.value.set(e.anisotropy*Math.cos(e.anisotropyRotation),e.anisotropy*Math.sin(e.anisotropyRotation)),e.anisotropyMap&&(t.anisotropyMap.value=e.anisotropyMap,i(e.anisotropyMap,t.anisotropyMapTransform))),t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap,i(e.specularColorMap,t.specularColorMapTransform)),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap,i(e.specularIntensityMap,t.specularIntensityMapTransform))}(t,s,o)):s.isMeshMatcapMaterial?(n(t,s),function(t,e){e.matcap&&(t.matcap.value=e.matcap)}(t,s)):s.isMeshDepthMaterial?n(t,s):s.isMeshDistanceMaterial?(n(t,s),function(t,i){const n=e.get(i).light;t.referencePosition.value.setFromMatrixPosition(n.matrixWorld),t.nearDistance.value=n.shadow.camera.near,t.farDistance.value=n.shadow.camera.far}(t,s)):s.isMeshNormalMaterial?n(t,s):s.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,e.map&&(t.map.value=e.map,i(e.map,t.mapTransform))}(t,s),s.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,s)):s.isPointsMaterial?function(t,e,n,s){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*s,e.map&&(t.map.value=e.map,i(e.map,t.uvTransform)),e.alphaMap&&(t.alphaMap.value=e.alphaMap,i(e.alphaMap,t.alphaMapTransform)),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,s,a,r):s.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map,i(e.map,t.mapTransform)),e.alphaMap&&(t.alphaMap.value=e.alphaMap,i(e.alphaMap,t.alphaMapTransform)),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,s):s.isShadowMaterial?(t.color.value.copy(s.color),t.opacity.value=s.opacity):s.isShaderMaterial&&(s.uniformsNeedUpdate=!1)}}}function lp(t,e,i,n){let s={},a={},r=[];const o=t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);function l(t,e,i,n){const s=t.value,a=e+"_"+i;if(void 0===n[a])return n[a]="number"==typeof s||"boolean"==typeof s?s:s.clone(),!0;{const t=n[a];if("number"==typeof s||"boolean"==typeof s){if(t!==s)return n[a]=s,!0}else if(!1===t.equals(s))return t.copy(s),!0}return!1}function h(t){const e={boundary:0,storage:0};return"number"==typeof t||"boolean"==typeof t?(e.boundary=4,e.storage=4):t.isVector2?(e.boundary=8,e.storage=8):t.isVector3||t.isColor?(e.boundary=16,e.storage=12):t.isVector4?(e.boundary=16,e.storage=16):t.isMatrix3?(e.boundary=48,e.storage=48):t.isMatrix4?(e.boundary=64,e.storage=64):t.isTexture?De("WebGLRenderer: Texture samplers can not be part of an uniforms group."):De("WebGLRenderer: Unsupported uniform value type.",t),e}function c(e){const i=e.target;i.removeEventListener("dispose",c);const n=r.indexOf(i.__bindingPointIndex);r.splice(n,1),t.deleteBuffer(s[i.id]),delete s[i.id],delete a[i.id]}return{bind:function(t,e){const i=e.program;n.uniformBlockBinding(t,i)},update:function(i,u){let d=s[i.id];void 0===d&&(function(t){const e=t.uniforms;let i=0;for(let t=0,n=e.length;t<n;t++){const n=Array.isArray(e[t])?e[t]:[e[t]];for(let t=0,e=n.length;t<e;t++){const e=n[t],s=Array.isArray(e.value)?e.value:[e.value];for(let t=0,n=s.length;t<n;t++){const n=h(s[t]),a=i%16,r=a%n.boundary,o=a+r;i+=r,0!==o&&16-o<n.storage&&(i+=16-o),e.__data=new Float32Array(n.storage/Float32Array.BYTES_PER_ELEMENT),e.__offset=i,i+=n.storage}}}const n=i%16;n>0&&(i+=16-n),t.__size=i,t.__cache={}}(i),d=function(e){const i=function(){for(let t=0;t<o;t++)if(-1===r.indexOf(t))return r.push(t),t;return Re("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=i;const n=t.createBuffer(),s=e.__size,a=e.usage;return t.bindBuffer(t.UNIFORM_BUFFER,n),t.bufferData(t.UNIFORM_BUFFER,s,a),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,i,n),n}(i),s[i.id]=d,i.addEventListener("dispose",c));const p=u.program;n.updateUBOMapping(i,p);const m=e.render.frame;a[i.id]!==m&&(function(e){const i=s[e.id],n=e.uniforms,a=e.__cache;t.bindBuffer(t.UNIFORM_BUFFER,i);for(let e=0,i=n.length;e<i;e++){const i=Array.isArray(n[e])?n[e]:[n[e]];for(let n=0,s=i.length;n<s;n++){const s=i[n];if(!0===l(s,e,n,a)){const e=s.__offset,i=Array.isArray(s.value)?s.value:[s.value];let n=0;for(let a=0;a<i.length;a++){const r=i[a],o=h(r);"number"==typeof r||"boolean"==typeof r?(s.__data[0]=r,t.bufferSubData(t.UNIFORM_BUFFER,e+n,s.__data)):r.isMatrix3?(s.__data[0]=r.elements[0],s.__data[1]=r.elements[1],s.__data[2]=r.elements[2],s.__data[3]=0,s.__data[4]=r.elements[3],s.__data[5]=r.elements[4],s.__data[6]=r.elements[5],s.__data[7]=0,s.__data[8]=r.elements[6],s.__data[9]=r.elements[7],s.__data[10]=r.elements[8],s.__data[11]=0):(r.toArray(s.__data,n),n+=o.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,e,s.__data)}}}t.bindBuffer(t.UNIFORM_BUFFER,null)}(i),a[i.id]=m)},dispose:function(){for(const e in s)t.deleteBuffer(s[e]);r=[],s={},a={}}}}const hp=new Uint16Array([11481,15204,11534,15171,11808,15015,12385,14843,12894,14716,13396,14600,13693,14483,13976,14366,14237,14171,14405,13961,14511,13770,14605,13598,14687,13444,14760,13305,14822,13066,14876,12857,14923,12675,14963,12517,14997,12379,15025,12230,15049,12023,15070,11843,15086,11687,15100,11551,15111,11433,15120,11330,15127,11217,15132,11060,15135,10922,15138,10801,15139,10695,15139,10600,13012,14923,13020,14917,13064,14886,13176,14800,13349,14666,13513,14526,13724,14398,13960,14230,14200,14020,14383,13827,14488,13651,14583,13491,14667,13348,14740,13132,14803,12908,14856,12713,14901,12542,14938,12394,14968,12241,14992,12017,15010,11822,15024,11654,15034,11507,15041,11380,15044,11269,15044,11081,15042,10913,15037,10764,15031,10635,15023,10520,15014,10419,15003,10330,13657,14676,13658,14673,13670,14660,13698,14622,13750,14547,13834,14442,13956,14317,14112,14093,14291,13889,14407,13704,14499,13538,14586,13389,14664,13201,14733,12966,14792,12758,14842,12577,14882,12418,14915,12272,14940,12033,14959,11826,14972,11646,14980,11490,14983,11355,14983,11212,14979,11008,14971,10830,14961,10675,14950,10540,14936,10420,14923,10315,14909,10204,14894,10041,14089,14460,14090,14459,14096,14452,14112,14431,14141,14388,14186,14305,14252,14130,14341,13941,14399,13756,14467,13585,14539,13430,14610,13272,14677,13026,14737,12808,14790,12617,14833,12449,14869,12303,14896,12065,14916,11845,14929,11655,14937,11490,14939,11347,14936,11184,14930,10970,14921,10783,14912,10621,14900,10480,14885,10356,14867,10247,14848,10062,14827,9894,14805,9745,14400,14208,14400,14206,14402,14198,14406,14174,14415,14122,14427,14035,14444,13913,14469,13767,14504,13613,14548,13463,14598,13324,14651,13082,14704,12858,14752,12658,14795,12483,14831,12330,14860,12106,14881,11875,14895,11675,14903,11501,14905,11351,14903,11178,14900,10953,14892,10757,14880,10589,14865,10442,14847,10313,14827,10162,14805,9965,14782,9792,14757,9642,14731,9507,14562,13883,14562,13883,14563,13877,14566,13862,14570,13830,14576,13773,14584,13689,14595,13582,14613,13461,14637,13336,14668,13120,14704,12897,14741,12695,14776,12516,14808,12358,14835,12150,14856,11910,14870,11701,14878,11519,14882,11361,14884,11187,14880,10951,14871,10748,14858,10572,14842,10418,14823,10286,14801,10099,14777,9897,14751,9722,14725,9567,14696,9430,14666,9309,14702,13604,14702,13604,14702,13600,14703,13591,14705,13570,14707,13533,14709,13477,14712,13400,14718,13305,14727,13106,14743,12907,14762,12716,14784,12539,14807,12380,14827,12190,14844,11943,14855,11727,14863,11539,14870,11376,14871,11204,14868,10960,14858,10748,14845,10565,14829,10406,14809,10269,14786,10058,14761,9852,14734,9671,14705,9512,14674,9374,14641,9253,14608,9076,14821,13366,14821,13365,14821,13364,14821,13358,14821,13344,14821,13320,14819,13252,14817,13145,14815,13011,14814,12858,14817,12698,14823,12539,14832,12389,14841,12214,14850,11968,14856,11750,14861,11558,14866,11390,14867,11226,14862,10972,14853,10754,14840,10565,14823,10401,14803,10259,14780,10032,14754,9820,14725,9635,14694,9473,14661,9333,14627,9203,14593,8988,14557,8798,14923,13014,14922,13014,14922,13012,14922,13004,14920,12987,14919,12957,14915,12907,14909,12834,14902,12738,14894,12623,14888,12498,14883,12370,14880,12203,14878,11970,14875,11759,14873,11569,14874,11401,14872,11243,14865,10986,14855,10762,14842,10568,14825,10401,14804,10255,14781,10017,14754,9799,14725,9611,14692,9445,14658,9301,14623,9139,14587,8920,14548,8729,14509,8562,15008,12672,15008,12672,15008,12671,15007,12667,15005,12656,15001,12637,14997,12605,14989,12556,14978,12490,14966,12407,14953,12313,14940,12136,14927,11934,14914,11742,14903,11563,14896,11401,14889,11247,14879,10992,14866,10767,14851,10570,14833,10400,14812,10252,14789,10007,14761,9784,14731,9592,14698,9424,14663,9279,14627,9088,14588,8868,14548,8676,14508,8508,14467,8360,15080,12386,15080,12386,15079,12385,15078,12383,15076,12378,15072,12367,15066,12347,15057,12315,15045,12253,15030,12138,15012,11998,14993,11845,14972,11685,14951,11530,14935,11383,14920,11228,14904,10981,14887,10762,14870,10567,14850,10397,14827,10248,14803,9997,14774,9771,14743,9578,14710,9407,14674,9259,14637,9048,14596,8826,14555,8632,14514,8464,14471,8317,14427,8182,15139,12008,15139,12008,15138,12008,15137,12007,15135,12003,15130,11990,15124,11969,15115,11929,15102,11872,15086,11794,15064,11693,15041,11581,15013,11459,14987,11336,14966,11170,14944,10944,14921,10738,14898,10552,14875,10387,14850,10239,14824,9983,14794,9758,14762,9563,14728,9392,14692,9244,14653,9014,14611,8791,14569,8597,14526,8427,14481,8281,14436,8110,14391,7885,15188,11617,15188,11617,15187,11617,15186,11618,15183,11617,15179,11612,15173,11601,15163,11581,15150,11546,15133,11495,15110,11427,15083,11346,15051,11246,15024,11057,14996,10868,14967,10687,14938,10517,14911,10362,14882,10206,14853,9956,14821,9737,14787,9543,14752,9375,14715,9228,14675,8980,14632,8760,14589,8565,14544,8395,14498,8248,14451,8049,14404,7824,14357,7630,15228,11298,15228,11298,15227,11299,15226,11301,15223,11303,15219,11302,15213,11299,15204,11290,15191,11271,15174,11217,15150,11129,15119,11015,15087,10886,15057,10744,15024,10599,14990,10455,14957,10318,14924,10143,14891,9911,14856,9701,14820,9516,14782,9352,14744,9200,14703,8946,14659,8725,14615,8533,14568,8366,14521,8220,14472,7992,14423,7770,14374,7578,14315,7408,15260,10819,15260,10819,15259,10822,15258,10826,15256,10832,15251,10836,15246,10841,15237,10838,15225,10821,15207,10788,15183,10734,15151,10660,15120,10571,15087,10469,15049,10359,15012,10249,14974,10041,14937,9837,14900,9647,14860,9475,14820,9320,14779,9147,14736,8902,14691,8688,14646,8499,14598,8335,14549,8189,14499,7940,14448,7720,14397,7529,14347,7363,14256,7218,15285,10410,15285,10411,15285,10413,15284,10418,15282,10425,15278,10434,15272,10442,15264,10449,15252,10445,15235,10433,15210,10403,15179,10358,15149,10301,15113,10218,15073,10059,15033,9894,14991,9726,14951,9565,14909,9413,14865,9273,14822,9073,14777,8845,14730,8641,14682,8459,14633,8300,14583,8129,14531,7883,14479,7670,14426,7482,14373,7321,14305,7176,14201,6939,15305,9939,15305,9940,15305,9945,15304,9955,15302,9967,15298,9989,15293,10010,15286,10033,15274,10044,15258,10045,15233,10022,15205,9975,15174,9903,15136,9808,15095,9697,15053,9578,15009,9451,14965,9327,14918,9198,14871,8973,14825,8766,14775,8579,14725,8408,14675,8259,14622,8058,14569,7821,14515,7615,14460,7435,14405,7276,14350,7108,14256,6866,14149,6653,15321,9444,15321,9445,15321,9448,15320,9458,15317,9470,15314,9490,15310,9515,15302,9540,15292,9562,15276,9579,15251,9577,15226,9559,15195,9519,15156,9463,15116,9389,15071,9304,15025,9208,14978,9023,14927,8838,14878,8661,14827,8496,14774,8344,14722,8206,14667,7973,14612,7749,14556,7555,14499,7382,14443,7229,14385,7025,14322,6791,14210,6588,14100,6409,15333,8920,15333,8921,15332,8927,15332,8943,15329,8965,15326,9002,15322,9048,15316,9106,15307,9162,15291,9204,15267,9221,15244,9221,15212,9196,15175,9134,15133,9043,15088,8930,15040,8801,14990,8665,14938,8526,14886,8391,14830,8261,14775,8087,14719,7866,14661,7664,14603,7482,14544,7322,14485,7178,14426,6936,14367,6713,14281,6517,14166,6348,14054,6198,15341,8360,15341,8361,15341,8366,15341,8379,15339,8399,15336,8431,15332,8473,15326,8527,15318,8585,15302,8632,15281,8670,15258,8690,15227,8690,15191,8664,15149,8612,15104,8543,15055,8456,15001,8360,14948,8259,14892,8122,14834,7923,14776,7734,14716,7558,14656,7397,14595,7250,14534,7070,14472,6835,14410,6628,14350,6443,14243,6283,14125,6135,14010,5889,15348,7715,15348,7717,15348,7725,15347,7745,15345,7780,15343,7836,15339,7905,15334,8e3,15326,8103,15310,8193,15293,8239,15270,8270,15240,8287,15204,8283,15163,8260,15118,8223,15067,8143,15014,8014,14958,7873,14899,7723,14839,7573,14778,7430,14715,7293,14652,7164,14588,6931,14524,6720,14460,6531,14396,6362,14330,6210,14207,6015,14086,5781,13969,5576,15352,7114,15352,7116,15352,7128,15352,7159,15350,7195,15348,7237,15345,7299,15340,7374,15332,7457,15317,7544,15301,7633,15280,7703,15251,7754,15216,7775,15176,7767,15131,7733,15079,7670,15026,7588,14967,7492,14906,7387,14844,7278,14779,7171,14714,6965,14648,6770,14581,6587,14515,6420,14448,6269,14382,6123,14299,5881,14172,5665,14049,5477,13929,5310,15355,6329,15355,6330,15355,6339,15355,6362,15353,6410,15351,6472,15349,6572,15344,6688,15337,6835,15323,6985,15309,7142,15287,7220,15260,7277,15226,7310,15188,7326,15142,7318,15090,7285,15036,7239,14976,7177,14914,7045,14849,6892,14782,6736,14714,6581,14645,6433,14576,6293,14506,6164,14438,5946,14369,5733,14270,5540,14140,5369,14014,5216,13892,5043,15357,5483,15357,5484,15357,5496,15357,5528,15356,5597,15354,5692,15351,5835,15347,6011,15339,6195,15328,6317,15314,6446,15293,6566,15268,6668,15235,6746,15197,6796,15152,6811,15101,6790,15046,6748,14985,6673,14921,6583,14854,6479,14785,6371,14714,6259,14643,6149,14571,5946,14499,5750,14428,5567,14358,5401,14242,5250,14109,5111,13980,4870,13856,4657,15359,4555,15359,4557,15358,4573,15358,4633,15357,4715,15355,4841,15353,5061,15349,5216,15342,5391,15331,5577,15318,5770,15299,5967,15274,6150,15243,6223,15206,6280,15161,6310,15111,6317,15055,6300,14994,6262,14928,6208,14860,6141,14788,5994,14715,5838,14641,5684,14566,5529,14492,5384,14418,5247,14346,5121,14216,4892,14079,4682,13948,4496,13822,4330,15359,3498,15359,3501,15359,3520,15359,3598,15358,3719,15356,3860,15355,4137,15351,4305,15344,4563,15334,4809,15321,5116,15303,5273,15280,5418,15250,5547,15214,5653,15170,5722,15120,5761,15064,5763,15002,5733,14935,5673,14865,5597,14792,5504,14716,5400,14640,5294,14563,5185,14486,5041,14410,4841,14335,4655,14191,4482,14051,4325,13918,4183,13790,4012,15360,2282,15360,2285,15360,2306,15360,2401,15359,2547,15357,2748,15355,3103,15352,3349,15345,3675,15336,4020,15324,4272,15307,4496,15285,4716,15255,4908,15220,5086,15178,5170,15128,5214,15072,5234,15010,5231,14943,5206,14871,5166,14796,5102,14718,4971,14639,4833,14559,4687,14480,4541,14402,4401,14315,4268,14167,4142,14025,3958,13888,3747,13759,3556,15360,923,15360,925,15360,946,15360,1052,15359,1214,15357,1494,15356,1892,15352,2274,15346,2663,15338,3099,15326,3393,15309,3679,15288,3980,15260,4183,15226,4325,15185,4437,15136,4517,15080,4570,15018,4591,14950,4581,14877,4545,14800,4485,14720,4411,14638,4325,14556,4231,14475,4136,14395,3988,14297,3803,14145,3628,13999,3465,13861,3314,13729,3177,15360,263,15360,264,15360,272,15360,325,15359,407,15358,548,15356,780,15352,1144,15347,1580,15339,2099,15328,2425,15312,2795,15292,3133,15264,3329,15232,3517,15191,3689,15143,3819,15088,3923,15025,3978,14956,3999,14882,3979,14804,3931,14722,3855,14639,3756,14554,3645,14470,3529,14388,3409,14279,3289,14124,3173,13975,3055,13834,2848,13701,2658,15360,49,15360,49,15360,52,15360,75,15359,111,15358,201,15356,283,15353,519,15348,726,15340,1045,15329,1415,15314,1795,15295,2173,15269,2410,15237,2649,15197,2866,15150,3054,15095,3140,15032,3196,14963,3228,14888,3236,14808,3224,14725,3191,14639,3146,14553,3088,14466,2976,14382,2836,14262,2692,14103,2549,13952,2409,13808,2278,13674,2154,15360,4,15360,4,15360,4,15360,13,15359,33,15358,59,15357,112,15353,199,15348,302,15341,456,15331,628,15316,827,15297,1082,15272,1332,15241,1601,15202,1851,15156,2069,15101,2172,15039,2256,14970,2314,14894,2348,14813,2358,14728,2344,14640,2311,14551,2263,14463,2203,14376,2133,14247,2059,14084,1915,13930,1761,13784,1609,13648,1464,15360,0,15360,0,15360,0,15360,3,15359,18,15358,26,15357,53,15354,80,15348,97,15341,165,15332,238,15318,326,15299,427,15275,529,15245,654,15207,771,15161,885,15108,994,15046,1089,14976,1170,14900,1229,14817,1266,14731,1284,14641,1282,14550,1260,14460,1223,14370,1174,14232,1116,14066,1050,13909,981,13761,910,13623,839]);let cp=null;class up{constructor(e={}){const{canvas:i=Ce(),context:n=null,depth:s=!0,stencil:a=!1,alpha:r=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:h=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:u=!1,reversedDepthBuffer:d=!1}=e;let p;if(this.isWebGLRenderer=!0,null!==n){if("undefined"!=typeof WebGLRenderingContext&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");p=n.getContextAttributes().alpha}else p=r;const m=new Set([yt,ft,mt]),g=new Set([$,tt,Q,at,nt,st]),f=new Uint32Array(4),y=new Int32Array(4);let v=null,b=null;const M=[],_=[];this.domElement=i,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=0,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const x=this;let w=!1;this._outputColorSpace=se;let S=0,T=0,C=null,E=-1,A=null;const P=new di,D=new di;let R=null;const I=new zn(0);let B=0,L=i.width,k=i.height,O=1,z=null,F=null;const U=new di(0,0,L,k),N=new di(0,0,L,k);let V=!1;const H=new Ga;let W=!1,j=!1;const q=new Wi,Z=new qe,J=new di,K={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let et=!1;function rt(){return null===C?O:1}let ot,lt,ht,ct,ut,dt,pt,vt,bt,Mt,_t,xt,wt,St,Tt,Ct,Et,At,Pt,Dt,Rt,It,Bt,Lt,kt=n;function Ot(t,e){return i.getContext(t,e)}try{const e={alpha:!0,depth:s,stencil:a,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:h,powerPreference:c,failIfMajorPerformanceCaveat:u};if("setAttribute"in i&&i.setAttribute("data-engine",`three.js r${t}`),i.addEventListener("webglcontextlost",Ut,!1),i.addEventListener("webglcontextrestored",Nt,!1),i.addEventListener("webglcontextcreationerror",Gt,!1),null===kt){const t="webgl2";if(kt=Ot(t,e),null===kt)throw Ot(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(t){throw t("WebGLRenderer: "+t.message),t}function zt(){ot=new ou(kt),ot.init(),It=new ip(kt,ot),lt=new Wc(kt,ot,e,It),ht=new tp(kt,ot),lt.reversedDepthBuffer&&d&&ht.buffers.depth.setReversed(!0),ct=new cu(kt),ut=new Gd,dt=new ep(kt,ot,ht,ut,lt,It,ct),pt=new Xc(x),vt=new ru(x),bt=new Lc(kt),Bt=new Vc(kt,bt),Mt=new lu(kt,bt,ct,Bt),_t=new du(kt,Mt,bt,ct),Pt=new uu(kt,lt,dt),Ct=new jc(ut),xt=new Nd(x,pt,vt,ot,lt,Bt,Ct),wt=new op(x,ut),St=new jd,Tt=new Jd(ot),At=new Gc(x,pt,vt,ht,_t,p,l),Et=new Qd(x,_t,lt),Lt=new lp(kt,ct,lt,ht),Dt=new Hc(kt,ot,ct),Rt=new hu(kt,ot,ct),ct.programs=xt.programs,x.capabilities=lt,x.extensions=ot,x.properties=ut,x.renderLists=St,x.shadowMap=Et,x.state=ht,x.info=ct}zt();const Ft=new sp(x,kt);function Ut(t){t.preventDefault(),Pe("WebGLRenderer: Context Lost."),w=!0}function Nt(){Pe("WebGLRenderer: Context Restored."),w=!1;const t=ct.autoReset,e=Et.enabled,i=Et.autoUpdate,n=Et.needsUpdate,s=Et.type;zt(),ct.autoReset=t,Et.enabled=e,Et.autoUpdate=i,Et.needsUpdate=n,Et.type=s}function Gt(t){Re("WebGLRenderer: A WebGL context could not be created. Reason: ",t.statusMessage)}function Vt(t){const e=t.target;e.removeEventListener("dispose",Vt),function(t){(function(t){const e=ut.get(t).programs;void 0!==e&&(e.forEach(function(t){xt.releaseProgram(t)}),t.isShaderMaterial&&xt.releaseShaderCache(t))})(t),ut.remove(t)}(e)}function Ht(t,e,i){!0===t.transparent&&2===t.side&&!1===t.forceSinglePass?(t.side=1,t.needsUpdate=!0,Kt(t,e,i),t.side=0,t.needsUpdate=!0,Kt(t,e,i),t.side=2):Kt(t,e,i)}this.xr=Ft,this.getContext=function(){return kt},this.getContextAttributes=function(){return kt.getContextAttributes()},this.forceContextLoss=function(){const t=ot.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=ot.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(t){void 0!==t&&(O=t,this.setSize(L,k,!1))},this.getSize=function(t){return t.set(L,k)},this.setSize=function(t,e,n=!0){Ft.isPresenting?De("WebGLRenderer: Can't change size while VR device is presenting."):(L=t,k=e,i.width=Math.floor(t*O),i.height=Math.floor(e*O),!0===n&&(i.style.width=t+"px",i.style.height=e+"px"),this.setViewport(0,0,t,e))},this.getDrawingBufferSize=function(t){return t.set(L*O,k*O).floor()},this.setDrawingBufferSize=function(t,e,n){L=t,k=e,O=n,i.width=Math.floor(t*n),i.height=Math.floor(e*n),this.setViewport(0,0,t,e)},this.getCurrentViewport=function(t){return t.copy(P)},this.getViewport=function(t){return t.copy(U)},this.setViewport=function(t,e,i,n){t.isVector4?U.set(t.x,t.y,t.z,t.w):U.set(t,e,i,n),ht.viewport(P.copy(U).multiplyScalar(O).round())},this.getScissor=function(t){return t.copy(N)},this.setScissor=function(t,e,i,n){t.isVector4?N.set(t.x,t.y,t.z,t.w):N.set(t,e,i,n),ht.scissor(D.copy(N).multiplyScalar(O).round())},this.getScissorTest=function(){return V},this.setScissorTest=function(t){ht.setScissorTest(V=t)},this.setOpaqueSort=function(t){z=t},this.setTransparentSort=function(t){F=t},this.getClearColor=function(t){return t.copy(At.getClearColor())},this.setClearColor=function(){At.setClearColor(...arguments)},this.getClearAlpha=function(){return At.getClearAlpha()},this.setClearAlpha=function(){At.setClearAlpha(...arguments)},this.clear=function(t=!0,e=!0,i=!0){let n=0;if(t){let t=!1;if(null!==C){const e=C.texture.format;t=m.has(e)}if(t){const t=C.texture.type,e=g.has(t),i=At.getClearColor(),n=At.getClearAlpha(),s=i.r,a=i.g,r=i.b;e?(f[0]=s,f[1]=a,f[2]=r,f[3]=n,kt.clearBufferuiv(kt.COLOR,0,f)):(y[0]=s,y[1]=a,y[2]=r,y[3]=n,kt.clearBufferiv(kt.COLOR,0,y))}else n|=kt.COLOR_BUFFER_BIT}e&&(n|=kt.DEPTH_BUFFER_BIT),i&&(n|=kt.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),kt.clear(n)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){i.removeEventListener("webglcontextlost",Ut,!1),i.removeEventListener("webglcontextrestored",Nt,!1),i.removeEventListener("webglcontextcreationerror",Gt,!1),At.dispose(),St.dispose(),Tt.dispose(),ut.dispose(),pt.dispose(),vt.dispose(),_t.dispose(),Bt.dispose(),Lt.dispose(),xt.dispose(),Ft.dispose(),Ft.removeEventListener("sessionstart",jt),Ft.removeEventListener("sessionend",Xt),qt.stop()},this.renderBufferDirect=function(t,e,i,n,s,a){null===e&&(e=K);const r=s.isMesh&&s.matrixWorld.determinant()<0,o=function(t,e,i,n,s){!0!==e.isScene&&(e=K),dt.resetTextureUnits();const a=e.fog,r=n.isMeshStandardMaterial?e.environment:null,o=null===C?x.outputColorSpace:!0===C.isXRRenderTarget?C.texture.colorSpace:ae,l=(n.isMeshStandardMaterial?vt:pt).get(n.envMap||r),h=!0===n.vertexColors&&!!i.attributes.color&&4===i.attributes.color.itemSize,c=!!i.attributes.tangent&&(!!n.normalMap||n.anisotropy>0),u=!!i.morphAttributes.position,d=!!i.morphAttributes.normal,p=!!i.morphAttributes.color;let m=0;n.toneMapped&&(null!==C&&!0!==C.isXRRenderTarget||(m=x.toneMapping));const g=i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color,f=void 0!==g?g.length:0,y=ut.get(n),v=b.state.lights;if(!0===W&&(!0===j||t!==A)){const e=t===A&&n.id===E;Ct.setState(n,t,e)}let M=!1;n.version===y.__version?y.needsLights&&y.lightsStateVersion!==v.state.version||y.outputColorSpace!==o||s.isBatchedMesh&&!1===y.batching?M=!0:s.isBatchedMesh||!0!==y.batching?s.isBatchedMesh&&!0===y.batchingColor&&null===s.colorTexture||s.isBatchedMesh&&!1===y.batchingColor&&null!==s.colorTexture||s.isInstancedMesh&&!1===y.instancing?M=!0:s.isInstancedMesh||!0!==y.instancing?s.isSkinnedMesh&&!1===y.skinning?M=!0:s.isSkinnedMesh||!0!==y.skinning?s.isInstancedMesh&&!0===y.instancingColor&&null===s.instanceColor||s.isInstancedMesh&&!1===y.instancingColor&&null!==s.instanceColor||s.isInstancedMesh&&!0===y.instancingMorph&&null===s.morphTexture||s.isInstancedMesh&&!1===y.instancingMorph&&null!==s.morphTexture||y.envMap!==l||!0===n.fog&&y.fog!==a?M=!0:void 0===y.numClippingPlanes||y.numClippingPlanes===Ct.numPlanes&&y.numIntersection===Ct.numIntersection?(y.vertexAlphas!==h||y.vertexTangents!==c||y.morphTargets!==u||y.morphNormals!==d||y.morphColors!==p||y.toneMapping!==m||y.morphTargetsCount!==f)&&(M=!0):M=!0:M=!0:M=!0:M=!0:(M=!0,y.__version=n.version);let _=y.currentProgram;!0===M&&(_=Kt(n,e,s));let w=!1,S=!1,T=!1;const P=_.getUniforms(),D=y.uniforms;if(ht.useProgram(_.program)&&(w=!0,S=!0,T=!0),n.id!==E&&(E=n.id,S=!0),w||A!==t){ht.buffers.depth.getReversed()&&!0!==t.reversedDepth&&(t._reversedDepth=!0,t.updateProjectionMatrix()),P.setValue(kt,"projectionMatrix",t.projectionMatrix),P.setValue(kt,"viewMatrix",t.matrixWorldInverse);const e=P.map.cameraPosition;void 0!==e&&e.setValue(kt,Z.setFromMatrixPosition(t.matrixWorld)),lt.logarithmicDepthBuffer&&P.setValue(kt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&P.setValue(kt,"isOrthographic",!0===t.isOrthographicCamera),A!==t&&(A=t,S=!0,T=!0)}if(s.isSkinnedMesh){P.setOptional(kt,s,"bindMatrix"),P.setOptional(kt,s,"bindMatrixInverse");const t=s.skeleton;t&&(null===t.boneTexture&&t.computeBoneTexture(),P.setValue(kt,"boneTexture",t.boneTexture,dt))}s.isBatchedMesh&&(P.setOptional(kt,s,"batchingTexture"),P.setValue(kt,"batchingTexture",s._matricesTexture,dt),P.setOptional(kt,s,"batchingIdTexture"),P.setValue(kt,"batchingIdTexture",s._indirectTexture,dt),P.setOptional(kt,s,"batchingColorTexture"),null!==s._colorsTexture&&P.setValue(kt,"batchingColorTexture",s._colorsTexture,dt));const R=i.morphAttributes;var I,B;if(void 0===R.position&&void 0===R.normal&&void 0===R.color||Pt.update(s,i,_),(S||y.receiveShadow!==s.receiveShadow)&&(y.receiveShadow=s.receiveShadow,P.setValue(kt,"receiveShadow",s.receiveShadow)),n.isMeshGouraudMaterial&&null!==n.envMap&&(D.envMap.value=l,D.flipEnvMap.value=l.isCubeTexture&&!1===l.isRenderTargetTexture?-1:1),n.isMeshStandardMaterial&&null===n.envMap&&null!==e.environment&&(D.envMapIntensity.value=e.environmentIntensity),void 0!==D.dfgLUT&&(D.dfgLUT.value=(null===cp&&(cp=new _a(hp,32,32,gt,it),cp.minFilter=X,cp.magFilter=X,cp.wrapS=G,cp.wrapT=G,cp.generateMipmaps=!1,cp.needsUpdate=!0),cp)),S&&(P.setValue(kt,"toneMappingExposure",x.toneMappingExposure),y.needsLights&&(B=T,(I=D).ambientLightColor.needsUpdate=B,I.lightProbe.needsUpdate=B,I.directionalLights.needsUpdate=B,I.directionalLightShadows.needsUpdate=B,I.pointLights.needsUpdate=B,I.pointLightShadows.needsUpdate=B,I.spotLights.needsUpdate=B,I.spotLightShadows.needsUpdate=B,I.rectAreaLights.needsUpdate=B,I.hemisphereLights.needsUpdate=B),a&&!0===n.fog&&wt.refreshFogUniforms(D,a),wt.refreshMaterialUniforms(D,n,O,k,b.state.transmissionRenderTarget[t.id]),yd.upload(kt,te(y),D,dt)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(yd.upload(kt,te(y),D,dt),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&P.setValue(kt,"center",s.center),P.setValue(kt,"modelViewMatrix",s.modelViewMatrix),P.setValue(kt,"normalMatrix",s.normalMatrix),P.setValue(kt,"modelMatrix",s.matrixWorld),n.isShaderMaterial||n.isRawShaderMaterial){const t=n.uniformsGroups;for(let e=0,i=t.length;e<i;e++){const i=t[e];Lt.update(i,_),Lt.bind(i,_)}}return _}(t,e,i,n,s);ht.setMaterial(n,r);let l=i.index,h=1;if(!0===n.wireframe){if(l=Mt.getWireframeAttribute(i),void 0===l)return;h=2}const c=i.drawRange,u=i.attributes.position;let d=c.start*h,p=(c.start+c.count)*h;null!==a&&(d=Math.max(d,a.start*h),p=Math.min(p,(a.start+a.count)*h)),null!==l?(d=Math.max(d,0),p=Math.min(p,l.count)):null!=u&&(d=Math.max(d,0),p=Math.min(p,u.count));const m=p-d;if(m<0||m===1/0)return;let g;Bt.setup(s,n,o,i,l);let f=Dt;if(null!==l&&(g=bt.get(l),f=Rt,f.setIndex(g)),s.isMesh)!0===n.wireframe?(ht.setLineWidth(n.wireframeLinewidth*rt()),f.setMode(kt.LINES)):f.setMode(kt.TRIANGLES);else if(s.isLine){let t=n.linewidth;void 0===t&&(t=1),ht.setLineWidth(t*rt()),s.isLineSegments?f.setMode(kt.LINES):s.isLineLoop?f.setMode(kt.LINE_LOOP):f.setMode(kt.LINE_STRIP)}else s.isPoints?f.setMode(kt.POINTS):s.isSprite&&f.setMode(kt.TRIANGLES);if(s.isBatchedMesh)if(null!==s._multiDrawInstances)Ie("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),f.renderMultiDrawInstances(s._multiDrawStarts,s._multiDrawCounts,s._multiDrawCount,s._multiDrawInstances);else if(ot.get("WEBGL_multi_draw"))f.renderMultiDraw(s._multiDrawStarts,s._multiDrawCounts,s._multiDrawCount);else{const t=s._multiDrawStarts,e=s._multiDrawCounts,i=s._multiDrawCount,a=l?bt.get(l).bytesPerElement:1,r=ut.get(n).currentProgram.getUniforms();for(let n=0;n<i;n++)r.setValue(kt,"_gl_DrawID",n),f.render(t[n]/a,e[n])}else if(s.isInstancedMesh)f.renderInstances(d,m,s.count);else if(i.isInstancedBufferGeometry){const t=void 0!==i._maxInstanceCount?i._maxInstanceCount:1/0,e=Math.min(i.instanceCount,t);f.renderInstances(d,m,e)}else f.render(d,m)},this.compile=function(t,e,i=null){null===i&&(i=t),b=Tt.get(i),b.init(e),_.push(b),i.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(b.pushLight(t),t.castShadow&&b.pushShadow(t))}),t!==i&&t.traverseVisible(function(t){t.isLight&&t.layers.test(e.layers)&&(b.pushLight(t),t.castShadow&&b.pushShadow(t))}),b.setupLights();const n=new Set;return t.traverse(function(t){if(!(t.isMesh||t.isPoints||t.isLine||t.isSprite))return;const e=t.material;if(e)if(Array.isArray(e))for(let s=0;s<e.length;s++){const a=e[s];Ht(a,i,t),n.add(a)}else Ht(e,i,t),n.add(e)}),b=_.pop(),n},this.compileAsync=function(t,e,i=null){const n=this.compile(t,e,i);return new Promise(e=>{function i(){n.forEach(function(t){ut.get(t).currentProgram.isReady()&&n.delete(t)}),0!==n.size?setTimeout(i,10):e(t)}null!==ot.get("KHR_parallel_shader_compile")?i():setTimeout(i,10)})};let Wt=null;function jt(){qt.stop()}function Xt(){qt.start()}const qt=new Bc;function Yt(t,e,i,n){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)i=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)b.pushLight(t),t.castShadow&&b.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||H.intersectsSprite(t)){n&&J.setFromMatrixPosition(t.matrixWorld).applyMatrix4(q);const e=_t.update(t),s=t.material;s.visible&&v.push(t,e,s,i,J.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||H.intersectsObject(t))){const e=_t.update(t),s=t.material;if(n&&(void 0!==t.boundingSphere?(null===t.boundingSphere&&t.computeBoundingSphere(),J.copy(t.boundingSphere.center)):(null===e.boundingSphere&&e.computeBoundingSphere(),J.copy(e.boundingSphere.center)),J.applyMatrix4(t.matrixWorld).applyMatrix4(q)),Array.isArray(s)){const n=e.groups;for(let a=0,r=n.length;a<r;a++){const r=n[a],o=s[r.materialIndex];o&&o.visible&&v.push(t,e,o,i,J.z,r)}}else s.visible&&v.push(t,e,s,i,J.z,null)}const s=t.children;for(let t=0,a=s.length;t<a;t++)Yt(s[t],e,i,n)}function $t(t,e,i,n){const{opaque:s,transmissive:a,transparent:r}=t;b.setupLightsView(i),!0===W&&Ct.setGlobalState(x.clippingPlanes,i),n&&ht.viewport(P.copy(n)),s.length>0&&Jt(s,e,i),a.length>0&&Jt(a,e,i),r.length>0&&Jt(r,e,i),ht.buffers.depth.setTest(!0),ht.buffers.depth.setMask(!0),ht.buffers.color.setMask(!0),ht.setPolygonOffset(!1)}function Zt(t,e,i,n){if(null!==(!0===i.isScene?i.overrideMaterial:null))return;void 0===b.state.transmissionRenderTarget[n.id]&&(b.state.transmissionRenderTarget[n.id]=new mi(1,1,{generateMipmaps:!0,type:ot.has("EXT_color_buffer_half_float")||ot.has("EXT_color_buffer_float")?it:$,minFilter:Y,samples:4,stencilBuffer:a,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:ei.workingColorSpace}));const s=b.state.transmissionRenderTarget[n.id],r=n.viewport||P;s.setSize(r.z*x.transmissionResolutionScale,r.w*x.transmissionResolutionScale);const o=x.getRenderTarget(),l=x.getActiveCubeFace(),h=x.getActiveMipmapLevel();x.setRenderTarget(s),x.getClearColor(I),B=x.getClearAlpha(),B<1&&x.setClearColor(16777215,.5),x.clear(),et&&At.render(i);const c=x.toneMapping;x.toneMapping=0;const u=n.viewport;if(void 0!==n.viewport&&(n.viewport=void 0),b.setupLightsView(n),!0===W&&Ct.setGlobalState(x.clippingPlanes,n),Jt(t,i,n),dt.updateMultisampleRenderTarget(s),dt.updateRenderTargetMipmap(s),!1===ot.has("WEBGL_multisampled_render_to_texture")){let t=!1;for(let s=0,a=e.length;s<a;s++){const a=e[s],{object:r,geometry:o,material:l,group:h}=a;if(2===l.side&&r.layers.test(n.layers)){const e=l.side;l.side=1,l.needsUpdate=!0,Qt(r,i,n,o,l,h),l.side=e,l.needsUpdate=!0,t=!0}}!0===t&&(dt.updateMultisampleRenderTarget(s),dt.updateRenderTargetMipmap(s))}x.setRenderTarget(o,l,h),x.setClearColor(I,B),void 0!==u&&(n.viewport=u),x.toneMapping=c}function Jt(t,e,i){const n=!0===e.isScene?e.overrideMaterial:null;for(let s=0,a=t.length;s<a;s++){const a=t[s],{object:r,geometry:o,group:l}=a;let h=a.material;!0===h.allowOverride&&null!==n&&(h=n),r.layers.test(i.layers)&&Qt(r,e,i,o,h,l)}}function Qt(t,e,i,n,s,a){t.onBeforeRender(x,e,i,n,s,a),t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),s.onBeforeRender(x,e,i,n,t,a),!0===s.transparent&&2===s.side&&!1===s.forceSinglePass?(s.side=1,s.needsUpdate=!0,x.renderBufferDirect(i,e,n,s,t,a),s.side=0,s.needsUpdate=!0,x.renderBufferDirect(i,e,n,s,t,a),s.side=2):x.renderBufferDirect(i,e,n,s,t,a),t.onAfterRender(x,e,i,n,s,a)}function Kt(t,e,i){!0!==e.isScene&&(e=K);const n=ut.get(t),s=b.state.lights,a=b.state.shadowsArray,r=s.state.version,o=xt.getParameters(t,s.state,a,e,i),l=xt.getProgramCacheKey(o);let h=n.programs;n.environment=t.isMeshStandardMaterial?e.environment:null,n.fog=e.fog,n.envMap=(t.isMeshStandardMaterial?vt:pt).get(t.envMap||n.environment),n.envMapRotation=null!==n.environment&&null===t.envMap?e.environmentRotation:t.envMapRotation,void 0===h&&(t.addEventListener("dispose",Vt),h=new Map,n.programs=h);let c=h.get(l);if(void 0!==c){if(n.currentProgram===c&&n.lightsStateVersion===r)return ee(t,o),c}else o.uniforms=xt.getUniforms(t),t.onBeforeCompile(o,x),c=xt.acquireProgram(o,l),h.set(l,c),n.uniforms=o.uniforms;const u=n.uniforms;return(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=Ct.uniform),ee(t,o),n.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),n.lightsStateVersion=r,n.needsLights&&(u.ambientLightColor.value=s.state.ambient,u.lightProbe.value=s.state.probe,u.directionalLights.value=s.state.directional,u.directionalLightShadows.value=s.state.directionalShadow,u.spotLights.value=s.state.spot,u.spotLightShadows.value=s.state.spotShadow,u.rectAreaLights.value=s.state.rectArea,u.ltc_1.value=s.state.rectAreaLTC1,u.ltc_2.value=s.state.rectAreaLTC2,u.pointLights.value=s.state.point,u.pointLightShadows.value=s.state.pointShadow,u.hemisphereLights.value=s.state.hemi,u.directionalShadowMap.value=s.state.directionalShadowMap,u.directionalShadowMatrix.value=s.state.directionalShadowMatrix,u.spotShadowMap.value=s.state.spotShadowMap,u.spotLightMatrix.value=s.state.spotLightMatrix,u.spotLightMap.value=s.state.spotLightMap,u.pointShadowMap.value=s.state.pointShadowMap,u.pointShadowMatrix.value=s.state.pointShadowMatrix),n.currentProgram=c,n.uniformsList=null,c}function te(t){if(null===t.uniformsList){const e=t.currentProgram.getUniforms();t.uniformsList=yd.seqWithValue(e.seq,t.uniforms)}return t.uniformsList}function ee(t,e){const i=ut.get(t);i.outputColorSpace=e.outputColorSpace,i.batching=e.batching,i.batchingColor=e.batchingColor,i.instancing=e.instancing,i.instancingColor=e.instancingColor,i.instancingMorph=e.instancingMorph,i.skinning=e.skinning,i.morphTargets=e.morphTargets,i.morphNormals=e.morphNormals,i.morphColors=e.morphColors,i.morphTargetsCount=e.morphTargetsCount,i.numClippingPlanes=e.numClippingPlanes,i.numIntersection=e.numClipIntersection,i.vertexAlphas=e.vertexAlphas,i.vertexTangents=e.vertexTangents,i.toneMapping=e.toneMapping}qt.setAnimationLoop(function(t){Wt&&Wt(t)}),"undefined"!=typeof self&&qt.setContext(self),this.setAnimationLoop=function(t){Wt=t,Ft.setAnimationLoop(t),null===t?qt.stop():qt.start()},Ft.addEventListener("sessionstart",jt),Ft.addEventListener("sessionend",Xt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void Re("WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===w)return;if(!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===Ft.enabled&&!0===Ft.isPresenting&&(!0===Ft.cameraAutoUpdate&&Ft.updateCamera(e),e=Ft.getCamera()),!0===t.isScene&&t.onBeforeRender(x,t,e,C),b=Tt.get(t,_.length),b.init(e),_.push(b),q.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),H.setFromProjectionMatrix(q,Me,e.reversedDepth),j=this.localClippingEnabled,W=Ct.init(this.clippingPlanes,j),v=St.get(t,M.length),v.init(),M.push(v),!0===Ft.enabled&&!0===Ft.isPresenting){const t=x.xr.getDepthSensingMesh();null!==t&&Yt(t,e,-1/0,x.sortObjects)}Yt(t,e,0,x.sortObjects),v.finish(),!0===x.sortObjects&&v.sort(z,F),et=!1===Ft.enabled||!1===Ft.isPresenting||!1===Ft.hasDepthSensing(),et&&At.addToRenderList(v,t),this.info.render.frame++,!0===W&&Ct.beginShadows();const i=b.state.shadowsArray;Et.render(i,t,e),!0===W&&Ct.endShadows(),!0===this.info.autoReset&&this.info.reset();const n=v.opaque,s=v.transmissive;if(b.setupLights(),e.isArrayCamera){const i=e.cameras;if(s.length>0)for(let e=0,a=i.length;e<a;e++)Zt(n,s,t,i[e]);et&&At.render(t);for(let e=0,n=i.length;e<n;e++){const n=i[e];$t(v,t,n,n.viewport)}}else s.length>0&&Zt(n,s,t,e),et&&At.render(t),$t(v,t,e);null!==C&&0===T&&(dt.updateMultisampleRenderTarget(C),dt.updateRenderTargetMipmap(C)),!0===t.isScene&&t.onAfterRender(x,t,e),Bt.resetDefaultState(),E=-1,A=null,_.pop(),_.length>0?(b=_[_.length-1],!0===W&&Ct.setGlobalState(x.clippingPlanes,b.state.camera)):b=null,M.pop(),v=M.length>0?M[M.length-1]:null},this.getActiveCubeFace=function(){return S},this.getActiveMipmapLevel=function(){return T},this.getRenderTarget=function(){return C},this.setRenderTargetTextures=function(t,e,i){const n=ut.get(t);n.__autoAllocateDepthBuffer=!1===t.resolveDepthBuffer,!1===n.__autoAllocateDepthBuffer&&(n.__useRenderToTexture=!1),ut.get(t.texture).__webglTexture=e,ut.get(t.depthTexture).__webglTexture=n.__autoAllocateDepthBuffer?void 0:i,n.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(t,e){const i=ut.get(t);i.__webglFramebuffer=e,i.__useDefaultFramebuffer=void 0===e};const ie=kt.createFramebuffer();this.setRenderTarget=function(t,e=0,i=0){C=t,S=e,T=i;let n=!0,s=null,a=!1,r=!1;if(t){const o=ut.get(t);if(void 0!==o.__useDefaultFramebuffer)ht.bindFramebuffer(kt.FRAMEBUFFER,null),n=!1;else if(void 0===o.__webglFramebuffer)dt.setupRenderTarget(t);else if(o.__hasExternalTextures)dt.rebindTextures(t,ut.get(t.texture).__webglTexture,ut.get(t.depthTexture).__webglTexture);else if(t.depthBuffer){const e=t.depthTexture;if(o.__boundDepthTexture!==e){if(null!==e&&ut.has(e)&&(t.width!==e.image.width||t.height!==e.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");dt.setupDepthRenderbuffer(t)}}const l=t.texture;(l.isData3DTexture||l.isDataArrayTexture||l.isCompressedArrayTexture)&&(r=!0);const h=ut.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(s=Array.isArray(h[e])?h[e][i]:h[e],a=!0):s=t.samples>0&&!1===dt.useMultisampledRTT(t)?ut.get(t).__webglMultisampledFramebuffer:Array.isArray(h)?h[i]:h,P.copy(t.viewport),D.copy(t.scissor),R=t.scissorTest}else P.copy(U).multiplyScalar(O).floor(),D.copy(N).multiplyScalar(O).floor(),R=V;if(0!==i&&(s=ie),ht.bindFramebuffer(kt.FRAMEBUFFER,s)&&n&&ht.drawBuffers(t,s),ht.viewport(P),ht.scissor(D),ht.setScissorTest(R),a){const n=ut.get(t.texture);kt.framebufferTexture2D(kt.FRAMEBUFFER,kt.COLOR_ATTACHMENT0,kt.TEXTURE_CUBE_MAP_POSITIVE_X+e,n.__webglTexture,i)}else if(r){const n=e;for(let e=0;e<t.textures.length;e++){const s=ut.get(t.textures[e]);kt.framebufferTextureLayer(kt.FRAMEBUFFER,kt.COLOR_ATTACHMENT0+e,s.__webglTexture,i,n)}}else if(null!==t&&0!==i){const e=ut.get(t.texture);kt.framebufferTexture2D(kt.FRAMEBUFFER,kt.COLOR_ATTACHMENT0,kt.TEXTURE_2D,e.__webglTexture,i)}E=-1},this.readRenderTargetPixels=function(t,e,i,n,s,a,r,o=0){if(!t||!t.isWebGLRenderTarget)return void Re("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=ut.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==r&&(l=l[r]),l){ht.bindFramebuffer(kt.FRAMEBUFFER,l);try{const r=t.textures[o],l=r.format,h=r.type;if(!lt.textureFormatReadable(l))return void Re("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!lt.textureTypeReadable(h))return void Re("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=t.width-n&&i>=0&&i<=t.height-s&&(t.textures.length>1&&kt.readBuffer(kt.COLOR_ATTACHMENT0+o),kt.readPixels(e,i,n,s,It.convert(l),It.convert(h),a))}finally{const t=null!==C?ut.get(C).__webglFramebuffer:null;ht.bindFramebuffer(kt.FRAMEBUFFER,t)}}},this.readRenderTargetPixelsAsync=async function(t,e,i,n,s,a,r,o=0){if(!t||!t.isWebGLRenderTarget)throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=ut.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==r&&(l=l[r]),l){if(e>=0&&e<=t.width-n&&i>=0&&i<=t.height-s){ht.bindFramebuffer(kt.FRAMEBUFFER,l);const r=t.textures[o],h=r.format,c=r.type;if(!lt.textureFormatReadable(h))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!lt.textureTypeReadable(c))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const u=kt.createBuffer();kt.bindBuffer(kt.PIXEL_PACK_BUFFER,u),kt.bufferData(kt.PIXEL_PACK_BUFFER,a.byteLength,kt.STREAM_READ),t.textures.length>1&&kt.readBuffer(kt.COLOR_ATTACHMENT0+o),kt.readPixels(e,i,n,s,It.convert(h),It.convert(c),0);const d=null!==C?ut.get(C).__webglFramebuffer:null;ht.bindFramebuffer(kt.FRAMEBUFFER,d);const p=kt.fenceSync(kt.SYNC_GPU_COMMANDS_COMPLETE,0);return kt.flush(),await function(t,e){return new Promise(function(i,n){setTimeout(function s(){switch(t.clientWaitSync(e,t.SYNC_FLUSH_COMMANDS_BIT,0)){case t.WAIT_FAILED:n();break;case t.TIMEOUT_EXPIRED:setTimeout(s,4);break;default:i()}},4)})}(kt,p),kt.bindBuffer(kt.PIXEL_PACK_BUFFER,u),kt.getBufferSubData(kt.PIXEL_PACK_BUFFER,0,a),kt.deleteBuffer(u),kt.deleteSync(p),a}throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(t,e=null,i=0){const n=Math.pow(2,-i),s=Math.floor(t.image.width*n),a=Math.floor(t.image.height*n),r=null!==e?e.x:0,o=null!==e?e.y:0;dt.setTexture2D(t,0),kt.copyTexSubImage2D(kt.TEXTURE_2D,i,0,0,r,o,s,a),ht.unbindTexture()};const ne=kt.createFramebuffer(),re=kt.createFramebuffer();this.copyTextureToTexture=function(t,e,i=null,n=null,s=0,a=null){let r,o,l,h,c,u,d,p,m;null===a&&(0!==s?(Ie("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),a=s,s=0):a=0);const g=t.isCompressedTexture?t.mipmaps[a]:t.image;if(null!==i)r=i.max.x-i.min.x,o=i.max.y-i.min.y,l=i.isBox3?i.max.z-i.min.z:1,h=i.min.x,c=i.min.y,u=i.isBox3?i.min.z:0;else{const e=Math.pow(2,-s);r=Math.floor(g.width*e),o=Math.floor(g.height*e),l=t.isDataArrayTexture?g.depth:t.isData3DTexture?Math.floor(g.depth*e):1,h=0,c=0,u=0}null!==n?(d=n.x,p=n.y,m=n.z):(d=0,p=0,m=0);const f=It.convert(e.format),y=It.convert(e.type);let v;e.isData3DTexture?(dt.setTexture3D(e,0),v=kt.TEXTURE_3D):e.isDataArrayTexture||e.isCompressedArrayTexture?(dt.setTexture2DArray(e,0),v=kt.TEXTURE_2D_ARRAY):(dt.setTexture2D(e,0),v=kt.TEXTURE_2D),kt.pixelStorei(kt.UNPACK_FLIP_Y_WEBGL,e.flipY),kt.pixelStorei(kt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),kt.pixelStorei(kt.UNPACK_ALIGNMENT,e.unpackAlignment);const b=kt.getParameter(kt.UNPACK_ROW_LENGTH),M=kt.getParameter(kt.UNPACK_IMAGE_HEIGHT),_=kt.getParameter(kt.UNPACK_SKIP_PIXELS),x=kt.getParameter(kt.UNPACK_SKIP_ROWS),w=kt.getParameter(kt.UNPACK_SKIP_IMAGES);kt.pixelStorei(kt.UNPACK_ROW_LENGTH,g.width),kt.pixelStorei(kt.UNPACK_IMAGE_HEIGHT,g.height),kt.pixelStorei(kt.UNPACK_SKIP_PIXELS,h),kt.pixelStorei(kt.UNPACK_SKIP_ROWS,c),kt.pixelStorei(kt.UNPACK_SKIP_IMAGES,u);const S=t.isDataArrayTexture||t.isData3DTexture,T=e.isDataArrayTexture||e.isData3DTexture;if(t.isDepthTexture){const i=ut.get(t),n=ut.get(e),g=ut.get(i.__renderTarget),f=ut.get(n.__renderTarget);ht.bindFramebuffer(kt.READ_FRAMEBUFFER,g.__webglFramebuffer),ht.bindFramebuffer(kt.DRAW_FRAMEBUFFER,f.__webglFramebuffer);for(let i=0;i<l;i++)S&&(kt.framebufferTextureLayer(kt.READ_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,ut.get(t).__webglTexture,s,u+i),kt.framebufferTextureLayer(kt.DRAW_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,ut.get(e).__webglTexture,a,m+i)),kt.blitFramebuffer(h,c,r,o,d,p,r,o,kt.DEPTH_BUFFER_BIT,kt.NEAREST);ht.bindFramebuffer(kt.READ_FRAMEBUFFER,null),ht.bindFramebuffer(kt.DRAW_FRAMEBUFFER,null)}else if(0!==s||t.isRenderTargetTexture||ut.has(t)){const i=ut.get(t),n=ut.get(e);ht.bindFramebuffer(kt.READ_FRAMEBUFFER,ne),ht.bindFramebuffer(kt.DRAW_FRAMEBUFFER,re);for(let t=0;t<l;t++)S?kt.framebufferTextureLayer(kt.READ_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,i.__webglTexture,s,u+t):kt.framebufferTexture2D(kt.READ_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,kt.TEXTURE_2D,i.__webglTexture,s),T?kt.framebufferTextureLayer(kt.DRAW_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,n.__webglTexture,a,m+t):kt.framebufferTexture2D(kt.DRAW_FRAMEBUFFER,kt.COLOR_ATTACHMENT0,kt.TEXTURE_2D,n.__webglTexture,a),0!==s?kt.blitFramebuffer(h,c,r,o,d,p,r,o,kt.COLOR_BUFFER_BIT,kt.NEAREST):T?kt.copyTexSubImage3D(v,a,d,p,m+t,h,c,r,o):kt.copyTexSubImage2D(v,a,d,p,h,c,r,o);ht.bindFramebuffer(kt.READ_FRAMEBUFFER,null),ht.bindFramebuffer(kt.DRAW_FRAMEBUFFER,null)}else T?t.isDataTexture||t.isData3DTexture?kt.texSubImage3D(v,a,d,p,m,r,o,l,f,y,g.data):e.isCompressedArrayTexture?kt.compressedTexSubImage3D(v,a,d,p,m,r,o,l,f,g.data):kt.texSubImage3D(v,a,d,p,m,r,o,l,f,y,g):t.isDataTexture?kt.texSubImage2D(kt.TEXTURE_2D,a,d,p,r,o,f,y,g.data):t.isCompressedTexture?kt.compressedTexSubImage2D(kt.TEXTURE_2D,a,d,p,g.width,g.height,f,g.data):kt.texSubImage2D(kt.TEXTURE_2D,a,d,p,r,o,f,y,g);kt.pixelStorei(kt.UNPACK_ROW_LENGTH,b),kt.pixelStorei(kt.UNPACK_IMAGE_HEIGHT,M),kt.pixelStorei(kt.UNPACK_SKIP_PIXELS,_),kt.pixelStorei(kt.UNPACK_SKIP_ROWS,x),kt.pixelStorei(kt.UNPACK_SKIP_IMAGES,w),0===a&&e.generateMipmaps&&kt.generateMipmap(v),ht.unbindTexture()},this.initRenderTarget=function(t){void 0===ut.get(t).__webglFramebuffer&&dt.setupRenderTarget(t)},this.initTexture=function(t){t.isCubeTexture?dt.setTextureCube(t,0):t.isData3DTexture?dt.setTexture3D(t,0):t.isDataArrayTexture||t.isCompressedArrayTexture?dt.setTexture2DArray(t,0):dt.setTexture2D(t,0),ht.unbindTexture()},this.resetState=function(){S=0,T=0,C=null,ht.reset(),Bt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Me}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorSpace=ei._getDrawingBufferColorSpace(t),e.unpackColorSpace=ei._getUnpackColorSpace()}}var dp=Object.freeze({__proto__:null,ACESFilmicToneMapping:4,AddEquation:r,AddOperation:2,AdditiveAnimationBlendMode:ie,AdditiveBlending:2,AgXToneMapping:6,AlphaFormat:lt,AlwaysCompare:519,AlwaysDepth:1,AlwaysStencilFunc:519,AmbientLight:dh,AnimationAction:$h,AnimationClip:zl,AnimationLoader:class extends Vl{constructor(t){super(t)}load(t,e,i,n){const s=this,a=new jl(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(i){try{e(s.parse(JSON.parse(i)))}catch(e){n?n(e):Re(e),s.manager.itemError(t)}},i,n)}parse(t){const e=[];for(let i=0;i<t.length;i++){const n=zl.parse(t[i]);e.push(n)}return e}},AnimationMixer:class extends Be{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const i=t._localRoot||this._root,n=t._clip.tracks,s=n.length,a=t._propertyBindings,r=t._interpolants,o=i.uuid,l=this._bindingsByRootAndName;let h=l[o];void 0===h&&(h={},l[o]=h);for(let t=0;t!==s;++t){const s=n[t],l=s.name;let c=h[l];if(void 0!==c)++c.referenceCount,a[t]=c;else{if(c=a[t],void 0!==c){null===c._cacheIndex&&(++c.referenceCount,this._addInactiveBinding(c,o,l));continue}const n=e&&e._propertyBindings[t].binding.parsedPath;c=new Gh(Yh.create(i,l,n),s.ValueTypeName,s.getValueSize()),++c.referenceCount,this._addInactiveBinding(c,o,l),a[t]=c}r[t].resultBuffer=c.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,i=t._clip.uuid,n=this._actionsByClip[i];this._bindAction(t,n&&n.knownActions[0]),this._addInactiveAction(t,i,e)}const e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const i=e[t];0===i.useCount++&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const i=e[t];0===--i.useCount&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,i){const n=this._actions,s=this._actionsByClip;let a=s[e];if(void 0===a)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=a;else{const e=a.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=n.length,n.push(t),a.actionByRoot[i]=t}_removeInactiveAction(t){const e=this._actions,i=e[e.length-1],n=t._cacheIndex;i._cacheIndex=n,e[n]=i,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,a=this._actionsByClip,r=a[s],o=r.knownActions,l=o[o.length-1],h=t._byClipCacheIndex;l._byClipCacheIndex=h,o[h]=l,o.pop(),t._byClipCacheIndex=null,delete r.actionByRoot[(t._localRoot||this._root).uuid],0===o.length&&delete a[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,i=e.length;t!==i;++t){const i=e[t];0===--i.referenceCount&&this._removeInactiveBinding(i)}}_lendAction(t){const e=this._actions,i=t._cacheIndex,n=this._nActiveActions++,s=e[n];t._cacheIndex=n,e[n]=t,s._cacheIndex=i,e[i]=s}_takeBackAction(t){const e=this._actions,i=t._cacheIndex,n=--this._nActiveActions,s=e[n];t._cacheIndex=n,e[n]=t,s._cacheIndex=i,e[i]=s}_addInactiveBinding(t,e,i){const n=this._bindingsByRootAndName,s=this._bindings;let a=n[e];void 0===a&&(a={},n[e]=a),a[i]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,i=t.binding,n=i.rootNode.uuid,s=i.path,a=this._bindingsByRootAndName,r=a[n],o=e[e.length-1],l=t._cacheIndex;o._cacheIndex=l,e[l]=o,e.pop(),delete r[s],0===Object.keys(r).length&&delete a[n]}_lendBinding(t){const e=this._bindings,i=t._cacheIndex,n=this._nActiveBindings++,s=e[n];t._cacheIndex=n,e[n]=t,s._cacheIndex=i,e[i]=s}_takeBackBinding(t){const e=this._bindings,i=t._cacheIndex,n=--this._nActiveBindings,s=e[n];t._cacheIndex=n,e[n]=t,s._cacheIndex=i,e[i]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let i=t[e];return void 0===i&&(i=new El(new Float32Array(2),new Float32Array(2),1,Zh),i.__cacheIndex=e,t[e]=i),i}_takeBackControlInterpolant(t){const e=this._controlInterpolants,i=t.__cacheIndex,n=--this._nActiveControlInterpolants,s=e[n];t.__cacheIndex=n,e[n]=t,s.__cacheIndex=i,e[i]=s}clipAction(t,e,i){const n=e||this._root,s=n.uuid;let a="string"==typeof t?zl.findByName(n,t):t;const r=null!==a?a.uuid:t,o=this._actionsByClip[r];let l=null;if(void 0===i&&(i=null!==a?a.blendMode:2500),void 0!==o){const t=o.actionByRoot[s];if(void 0!==t&&t.blendMode===i)return t;l=o.knownActions[0],null===a&&(a=l._clip)}if(null===a)return null;const h=new $h(this,a,e,i);return this._bindAction(h,l),this._addInactiveAction(h,r,s),h}existingAction(t,e){const i=e||this._root,n=i.uuid,s="string"==typeof t?zl.findByName(i,t):t,a=s?s.uuid:t,r=this._actionsByClip[a];return void 0!==r&&r.actionByRoot[n]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,i=this._nActiveActions,n=this.time+=t,s=Math.sign(t),a=this._accuIndex^=1;for(let r=0;r!==i;++r)e[r]._update(n,t,s,a);const r=this._bindings,o=this._nActiveBindings;for(let t=0;t!==o;++t)r[t].apply(a);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,i=t.uuid,n=this._actionsByClip,s=n[i];if(void 0!==s){const t=s.knownActions;for(let i=0,n=t.length;i!==n;++i){const n=t[i];this._deactivateAction(n);const s=n._cacheIndex,a=e[e.length-1];n._cacheIndex=null,n._byClipCacheIndex=null,a._cacheIndex=s,e[s]=a,e.pop(),this._removeInactiveBindingsForAction(n)}delete n[i]}}uncacheRoot(t){const e=t.uuid,i=this._actionsByClip;for(const t in i){const n=i[t].actionByRoot[e];void 0!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}const n=this._bindingsByRootAndName[e];if(void 0!==n)for(const t in n){const e=n[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const i=this.existingAction(t,e);null!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}},AnimationObjectGroup:class{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Fe(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,i=arguments.length;e!==i;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,i=this._paths,n=this._parsedPaths,s=this._bindings,a=s.length;let r,o=t.length,l=this.nCachedObjects_;for(let h=0,c=arguments.length;h!==c;++h){const c=arguments[h],u=c.uuid;let d=e[u];if(void 0===d){d=o++,e[u]=d,t.push(c);for(let t=0,e=a;t!==e;++t)s[t].push(new Yh(c,i[t],n[t]))}else if(d<l){r=t[d];const o=--l,h=t[o];e[h.uuid]=d,t[d]=h,e[u]=o,t[o]=c;for(let t=0,e=a;t!==e;++t){const e=s[t],a=e[o];let r=e[d];e[d]=a,void 0===r&&(r=new Yh(c,i[t],n[t])),e[o]=r}}else t[d]!==r&&Re("AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this._objects,e=this._indicesByUUID,i=this._bindings,n=i.length;let s=this.nCachedObjects_;for(let a=0,r=arguments.length;a!==r;++a){const r=arguments[a],o=r.uuid,l=e[o];if(void 0!==l&&l>=s){const a=s++,h=t[a];e[h.uuid]=l,t[l]=h,e[o]=a,t[a]=r;for(let t=0,e=n;t!==e;++t){const e=i[t],n=e[a],s=e[l];e[l]=n,e[a]=s}}}this.nCachedObjects_=s}uncache(){const t=this._objects,e=this._indicesByUUID,i=this._bindings,n=i.length;let s=this.nCachedObjects_,a=t.length;for(let r=0,o=arguments.length;r!==o;++r){const o=arguments[r].uuid,l=e[o];if(void 0!==l)if(delete e[o],l<s){const r=--s,o=t[r],h=--a,c=t[h];e[o.uuid]=l,t[l]=o,e[c.uuid]=r,t[r]=c,t.pop();for(let t=0,e=n;t!==e;++t){const e=i[t],n=e[r],s=e[h];e[l]=n,e[r]=s,e.pop()}}else{const s=--a,r=t[s];s>0&&(e[r.uuid]=l),t[l]=r,t.pop();for(let t=0,e=n;t!==e;++t){const e=i[t];e[l]=e[s],e.pop()}}}this.nCachedObjects_=s}subscribe_(t,e){const i=this._bindingsIndicesByPath;let n=i[t];const s=this._bindings;if(void 0!==n)return s[n];const a=this._paths,r=this._parsedPaths,o=this._objects,l=o.length,h=this.nCachedObjects_,c=new Array(l);n=s.length,i[t]=n,a.push(t),r.push(e),s.push(c);for(let i=h,n=o.length;i!==n;++i){const n=o[i];c[i]=new Yh(n,t,e)}return c}unsubscribe_(t){const e=this._bindingsIndicesByPath,i=e[t];if(void 0!==i){const n=this._paths,s=this._parsedPaths,a=this._bindings,r=a.length-1,o=a[r];e[t[r]]=i,a[i]=o,a.pop(),s[i]=s[r],s.pop(),n[i]=n[r],n.pop()}}},AnimationUtils:class{static convertArray(t,e){return Ml(t,e)}static isTypedArray(t){return _l(t)}static getKeyframeOrder(t){return xl(t)}static sortedArray(t,e,i){return wl(t,e,i)}static flattenJSON(t,e,i,n){Sl(t,e,i,n)}static subclip(t,e,i,n,s=30){return function(t,e,i,n,s=30){const a=t.clone();a.name=e;const r=[];for(let t=0;t<a.tracks.length;++t){const e=a.tracks[t],o=e.getValueSize(),l=[],h=[];for(let t=0;t<e.times.length;++t){const a=e.times[t]*s;if(!(a<i||a>=n)){l.push(e.times[t]);for(let i=0;i<o;++i)h.push(e.values[t*o+i])}}0!==l.length&&(e.times=Ml(l,e.times.constructor),e.values=Ml(h,e.values.constructor),r.push(e))}a.tracks=r;let o=1/0;for(let t=0;t<a.tracks.length;++t)o>a.tracks[t].times[0]&&(o=a.tracks[t].times[0]);for(let t=0;t<a.tracks.length;++t)a.tracks[t].shift(-1*o);return a.resetDuration(),a}(t,e,i,n,s)}static makeClipAdditive(t,e=0,i=t,n=30){return function(t,e=0,i=t,n=30){n<=0&&(n=30);const s=i.tracks.length,a=e/n;for(let e=0;e<s;++e){const n=i.tracks[e],s=n.ValueTypeName;if("bool"===s||"string"===s)continue;const r=t.tracks.find(function(t){return t.name===n.name&&t.ValueTypeName===s});if(void 0===r)continue;let o=0;const l=n.getValueSize();n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let h=0;const c=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=c/3);const u=n.times.length-1;let d;if(a<=n.times[0]){const t=o,e=l-o;d=n.values.slice(t,e)}else if(a>=n.times[u]){const t=u*l+o,e=t+l-o;d=n.values.slice(t,e)}else{const t=n.createInterpolant(),e=o,i=l-o;t.evaluate(a),d=t.resultBuffer.slice(e,i)}"quaternion"===s&&(new Xe).fromArray(d).normalize().conjugate().toArray(d);const p=r.times.length;for(let t=0;t<p;++t){const e=t*c+h;if("quaternion"===s)Xe.multiplyQuaternionsFlat(r.values,e,d,0,r.values,e);else{const t=c-2*h;for(let i=0;i<t;++i)r.values[e+i]-=d[i]}}}return t.blendMode=ie,t}(t,e,i,n)}},ArcCurve:$r,ArrayCamera:Ph,ArrowHelper:class extends vn{constructor(t=new qe(0,0,1),e=new qe(0,0,0),i=1,n=16776960,s=.2*i,a=.2*s){super(),this.type="ArrowHelper",void 0===Pc&&(Pc=new os,Pc.setAttribute("position",new Kn([0,0,0,0,1,0],3)),Dc=new Ur(.5,1,5,1),Dc.translate(0,-.5,0)),this.position.copy(e),this.line=new vr(Pc,new cr({color:n,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new bs(Dc,new Gn({color:n,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(i,s,a)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Ac.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Ac,e)}}setLength(t,e=.2*t,i=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(i,e,i),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}},AttachedBindMode:I,Audio:Oh,AudioAnalyser:class{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let i=0;i<e.length;i++)t+=e[i];return t/e.length}},AudioContext:Th,AudioListener:class extends vn{constructor(){super(),this.type="AudioListener",this.context=Th.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Dh}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Rh,Ih,Bh),Lh.set(0,0,-1).applyQuaternion(Ih),kh.set(0,1,0).applyQuaternion(Ih),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(Rh.x,t),e.positionY.linearRampToValueAtTime(Rh.y,t),e.positionZ.linearRampToValueAtTime(Rh.z,t),e.forwardX.linearRampToValueAtTime(Lh.x,t),e.forwardY.linearRampToValueAtTime(Lh.y,t),e.forwardZ.linearRampToValueAtTime(Lh.z,t),e.upX.linearRampToValueAtTime(kh.x,t),e.upY.linearRampToValueAtTime(kh.y,t),e.upZ.linearRampToValueAtTime(kh.z,t)}else e.setPosition(Rh.x,Rh.y,Rh.z),e.setOrientation(Lh.x,Lh.y,Lh.z,kh.x,kh.y,kh.z)}},AudioLoader:class extends Vl{constructor(t){super(t)}load(t,e,i,n){const s=this,a=new jl(this.manager);function r(e){n?n(e):Re(e),s.manager.itemError(t)}a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(t){try{const i=t.slice(0);Th.getContext().decodeAudioData(i,function(t){e(t)}).catch(r)}catch(t){r(t)}},i,n)}},AxesHelper:class extends xr{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],i=new os;i.setAttribute("position",new Kn(e,3)),i.setAttribute("color",new Kn([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(i,new cr({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,i){const n=new zn,s=this.geometry.attributes.color.array;return n.set(t),n.toArray(s,0),n.toArray(s,3),n.set(e),n.toArray(s,6),n.toArray(s,9),n.set(i),n.toArray(s,12),n.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}},BackSide:1,BasicDepthPacking:3200,BasicShadowMap:0,BatchedMesh:hr,Bone:Ma,BooleanKeyframeTrack:Dl,Box2:class{constructor(t=new je(1/0,1/0),e=new je(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=ac.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,ac).distanceTo(t)}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}},Box3:yi,Box3Helper:class extends xr{constructor(t,e=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new os;n.setIndex(new Zn(i,1)),n.setAttribute("position",new Kn([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(n,new cr({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}dispose(){this.geometry.dispose(),this.material.dispose()}},BoxGeometry:_s,BoxHelper:class extends xr{constructor(t,e=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array(24),s=new os;s.setIndex(new Zn(i,1)),s.setAttribute("position",new Zn(n,3)),super(s,new cr({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(void 0!==this.object&&Ec.setFromObject(this.object),Ec.isEmpty())return;const t=Ec.min,e=Ec.max,i=this.geometry.attributes.position,n=i.array;n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=t.x,n[4]=e.y,n[5]=e.z,n[6]=t.x,n[7]=t.y,n[8]=e.z,n[9]=e.x,n[10]=t.y,n[11]=e.z,n[12]=e.x,n[13]=e.y,n[14]=t.z,n[15]=t.x,n[16]=e.y,n[17]=t.z,n[18]=t.x,n[19]=t.y,n[20]=t.z,n[21]=e.x,n[22]=t.y,n[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}},BufferAttribute:Zn,BufferGeometry:os,BufferGeometryLoader:bh,ByteType:Z,Cache:Ul,Camera:Es,CameraHelper:class extends xr{constructor(t){const e=new os,i=new cr({color:16777215,vertexColors:!0,toneMapped:!1}),n=[],s=[],a={};function r(t,e){o(t),o(e)}function o(t){n.push(0,0,0),s.push(0,0,0),void 0===a[t]&&(a[t]=[]),a[t].push(n.length/3-1)}r("n1","n2"),r("n2","n4"),r("n4","n3"),r("n3","n1"),r("f1","f2"),r("f2","f4"),r("f4","f3"),r("f3","f1"),r("n1","f1"),r("n2","f2"),r("n3","f3"),r("n4","f4"),r("p","n1"),r("p","n2"),r("p","n3"),r("p","n4"),r("u1","u2"),r("u2","u3"),r("u3","u1"),r("c","t"),r("p","c"),r("cn1","cn2"),r("cn3","cn4"),r("cf1","cf2"),r("cf3","cf4"),e.setAttribute("position",new Kn(n,3)),e.setAttribute("color",new Kn(s,3)),super(e,i),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update();const l=new zn(16755200),h=new zn(16711680),c=new zn(43775),u=new zn(16777215),d=new zn(3355443);this.setColors(l,h,c,u,d)}setColors(t,e,i,n,s){const a=this.geometry.getAttribute("color");return a.setXYZ(0,t.r,t.g,t.b),a.setXYZ(1,t.r,t.g,t.b),a.setXYZ(2,t.r,t.g,t.b),a.setXYZ(3,t.r,t.g,t.b),a.setXYZ(4,t.r,t.g,t.b),a.setXYZ(5,t.r,t.g,t.b),a.setXYZ(6,t.r,t.g,t.b),a.setXYZ(7,t.r,t.g,t.b),a.setXYZ(8,t.r,t.g,t.b),a.setXYZ(9,t.r,t.g,t.b),a.setXYZ(10,t.r,t.g,t.b),a.setXYZ(11,t.r,t.g,t.b),a.setXYZ(12,t.r,t.g,t.b),a.setXYZ(13,t.r,t.g,t.b),a.setXYZ(14,t.r,t.g,t.b),a.setXYZ(15,t.r,t.g,t.b),a.setXYZ(16,t.r,t.g,t.b),a.setXYZ(17,t.r,t.g,t.b),a.setXYZ(18,t.r,t.g,t.b),a.setXYZ(19,t.r,t.g,t.b),a.setXYZ(20,t.r,t.g,t.b),a.setXYZ(21,t.r,t.g,t.b),a.setXYZ(22,t.r,t.g,t.b),a.setXYZ(23,t.r,t.g,t.b),a.setXYZ(24,e.r,e.g,e.b),a.setXYZ(25,e.r,e.g,e.b),a.setXYZ(26,e.r,e.g,e.b),a.setXYZ(27,e.r,e.g,e.b),a.setXYZ(28,e.r,e.g,e.b),a.setXYZ(29,e.r,e.g,e.b),a.setXYZ(30,e.r,e.g,e.b),a.setXYZ(31,e.r,e.g,e.b),a.setXYZ(32,i.r,i.g,i.b),a.setXYZ(33,i.r,i.g,i.b),a.setXYZ(34,i.r,i.g,i.b),a.setXYZ(35,i.r,i.g,i.b),a.setXYZ(36,i.r,i.g,i.b),a.setXYZ(37,i.r,i.g,i.b),a.setXYZ(38,n.r,n.g,n.b),a.setXYZ(39,n.r,n.g,n.b),a.setXYZ(40,s.r,s.g,s.b),a.setXYZ(41,s.r,s.g,s.b),a.setXYZ(42,s.r,s.g,s.b),a.setXYZ(43,s.r,s.g,s.b),a.setXYZ(44,s.r,s.g,s.b),a.setXYZ(45,s.r,s.g,s.b),a.setXYZ(46,s.r,s.g,s.b),a.setXYZ(47,s.r,s.g,s.b),a.setXYZ(48,s.r,s.g,s.b),a.setXYZ(49,s.r,s.g,s.b),a.needsUpdate=!0,this}update(){const t=this.geometry,e=this.pointMap;let i,n;if(Tc.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),!0===this.camera.reversedDepth)i=1,n=0;else if(this.camera.coordinateSystem===Me)i=-1,n=1;else{if(this.camera.coordinateSystem!==_e)throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: "+this.camera.coordinateSystem);i=0,n=1}Cc("c",e,t,Tc,0,0,i),Cc("t",e,t,Tc,0,0,n),Cc("n1",e,t,Tc,-1,-1,i),Cc("n2",e,t,Tc,1,-1,i),Cc("n3",e,t,Tc,-1,1,i),Cc("n4",e,t,Tc,1,1,i),Cc("f1",e,t,Tc,-1,-1,n),Cc("f2",e,t,Tc,1,-1,n),Cc("f3",e,t,Tc,-1,1,n),Cc("f4",e,t,Tc,1,1,n),Cc("u1",e,t,Tc,.7,1.1,i),Cc("u2",e,t,Tc,-.7,1.1,i),Cc("u3",e,t,Tc,0,2,i),Cc("cf1",e,t,Tc,-1,0,n),Cc("cf2",e,t,Tc,1,0,n),Cc("cf3",e,t,Tc,0,-1,n),Cc("cf4",e,t,Tc,0,1,n),Cc("cn1",e,t,Tc,-1,0,i),Cc("cn2",e,t,Tc,1,0,i),Cc("cn3",e,t,Tc,0,-1,i),Cc("cn4",e,t,Tc,0,1,i),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},CanvasTexture:Br,CapsuleGeometry:Or,CatmullRomCurve3:eo,CineonToneMapping:3,CircleGeometry:zr,ClampToEdgeWrapping:G,Clock:Dh,Color:zn,ColorKeyframeTrack:Rl,ColorManagement:ei,CompressedArrayTexture:class extends Ir{constructor(t,e,i,n,s,a){super(t,e,i,s,a),this.isCompressedArrayTexture=!0,this.image.depth=n,this.wrapR=G,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}},CompressedCubeTexture:class extends Ir{constructor(t,e,i){super(void 0,t[0].width,t[0].height,e,i,k),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=t}},CompressedTexture:Ir,CompressedTextureLoader:class extends Vl{constructor(t){super(t)}load(t,e,i,n){const s=this,a=[],r=new Ir,o=new jl(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(s.withCredentials);let l=0;function h(h){o.load(t[h],function(t){const i=s.parse(t,!0);a[h]={width:i.width,height:i.height,format:i.format,mipmaps:i.mipmaps},l+=1,6===l&&(1===i.mipmapCount&&(r.minFilter=X),r.image=a,r.format=i.format,r.needsUpdate=!0,e&&e(r))},i,n)}if(Array.isArray(t))for(let e=0,i=t.length;e<i;++e)h(e);else o.load(t,function(t){const i=s.parse(t,!0);if(i.isCubemap){const t=i.mipmaps.length/i.mipmapCount;for(let e=0;e<t;e++){a[e]={mipmaps:[]};for(let t=0;t<i.mipmapCount;t++)a[e].mipmaps.push(i.mipmaps[e*i.mipmapCount+t]),a[e].format=i.format,a[e].width=i.width,a[e].height=i.height}r.image=a}else r.image.width=i.width,r.image.height=i.height,r.mipmaps=i.mipmaps;1===i.mipmapCount&&(r.minFilter=X),r.format=i.format,r.needsUpdate=!0,e&&e(r)},i,n);return r}},ConeGeometry:Ur,ConstantAlphaFactor:213,ConstantColorFactor:211,Controls:Rc,CubeCamera:Bs,CubeReflectionMapping:k,CubeRefractionMapping:O,CubeTexture:Ls,CubeTextureLoader:class extends Vl{constructor(t){super(t)}load(t,e,i,n){const s=new Ls;s.colorSpace=se;const a=new ql(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let r=0;function o(i){a.load(t[i],function(t){s.images[i]=t,r++,6===r&&(s.needsUpdate=!0,e&&e(s))},void 0,n)}for(let e=0;e<t.length;++e)o(e);return s}},CubeUVReflectionMapping:U,CubicBezierCurve:ao,CubicBezierCurve3:ro,CubicInterpolant:Cl,CullFaceBack:1,CullFaceFront:2,CullFaceFrontBack:3,CullFaceNone:0,Curve:qr,CurvePath:mo,CustomBlending:5,CustomToneMapping:5,CylinderGeometry:Fr,Cylindrical:class{constructor(t=1,e=0,i=0){this.radius=t,this.theta=e,this.y=i}set(t,e,i){return this.radius=t,this.theta=e,this.y=i,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,i){return this.radius=Math.sqrt(t*t+i*i),this.theta=Math.atan2(t,i),this.y=e,this}clone(){return(new this.constructor).copy(this)}},Data3DTexture:fi,DataArrayTexture:gi,DataTexture:_a,DataTextureLoader:Yl,DataUtils:Xn,DecrementStencilOp:7683,DecrementWrapStencilOp:34056,DefaultLoadingManager:Gl,DepthFormat:ut,DepthStencilFormat:dt,DepthTexture:Lr,DetachedBindMode:B,DirectionalLight:uh,DirectionalLightHelper:class extends vn{constructor(t,e,i){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="DirectionalLightHelper",void 0===e&&(e=1);let n=new os;n.setAttribute("position",new Kn([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const s=new cr({fog:!1,toneMapped:!1});this.lightPlane=new vr(n,s),this.add(this.lightPlane),n=new os,n.setAttribute("position",new Kn([0,0,0,0,0,1],3)),this.targetLine=new vr(n,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),_c.setFromMatrixPosition(this.light.matrixWorld),xc.setFromMatrixPosition(this.light.target.matrixWorld),wc.subVectors(xc,_c),this.lightPlane.lookAt(xc),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(xc),this.targetLine.scale.z=wc.length()}},DiscreteInterpolant:Al,DodecahedronGeometry:Gr,DoubleSide:2,DstAlphaFactor:206,DstColorFactor:208,DynamicCopyUsage:35050,DynamicDrawUsage:ve,DynamicReadUsage:35049,EdgesGeometry:Xr,EllipseCurve:Yr,EqualCompare:514,EqualDepth:4,EqualStencilFunc:514,EquirectangularReflectionMapping:z,EquirectangularRefractionMapping:F,Euler:tn,EventDispatcher:Be,ExternalTexture:kr,ExtrudeGeometry:Xo,FileLoader:jl,Float16BufferAttribute:class extends Zn{constructor(t,e,i){super(new Uint16Array(t),e,i),this.isFloat16BufferAttribute=!0}getX(t){let e=jn(this.array[t*this.itemSize]);return this.normalized&&(e=Ve(e,this.array)),e}setX(t,e){return this.normalized&&(e=He(e,this.array)),this.array[t*this.itemSize]=Wn(e),this}getY(t){let e=jn(this.array[t*this.itemSize+1]);return this.normalized&&(e=Ve(e,this.array)),e}setY(t,e){return this.normalized&&(e=He(e,this.array)),this.array[t*this.itemSize+1]=Wn(e),this}getZ(t){let e=jn(this.array[t*this.itemSize+2]);return this.normalized&&(e=Ve(e,this.array)),e}setZ(t,e){return this.normalized&&(e=He(e,this.array)),this.array[t*this.itemSize+2]=Wn(e),this}getW(t){let e=jn(this.array[t*this.itemSize+3]);return this.normalized&&(e=Ve(e,this.array)),e}setW(t,e){return this.normalized&&(e=He(e,this.array)),this.array[t*this.itemSize+3]=Wn(e),this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=He(e,this.array),i=He(i,this.array)),this.array[t+0]=Wn(e),this.array[t+1]=Wn(i),this}setXYZ(t,e,i,n){return t*=this.itemSize,this.normalized&&(e=He(e,this.array),i=He(i,this.array),n=He(n,this.array)),this.array[t+0]=Wn(e),this.array[t+1]=Wn(i),this.array[t+2]=Wn(n),this}setXYZW(t,e,i,n,s){return t*=this.itemSize,this.normalized&&(e=He(e,this.array),i=He(i,this.array),n=He(n,this.array),s=He(s,this.array)),this.array[t+0]=Wn(e),this.array[t+1]=Wn(i),this.array[t+2]=Wn(n),this.array[t+3]=Wn(s),this}},Float32BufferAttribute:Kn,FloatType:et,Fog:Ns,FogExp2:Us,FramebufferTexture:class extends ui{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=H,this.minFilter=H,this.generateMipmaps=!1,this.needsUpdate=!0}},FrontSide:0,Frustum:Ga,FrustumArray:Wa,GLBufferAttribute:class{constructor(t,e,i,n,s,a=!1){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=e,this.itemSize=i,this.elementSize=n,this.count=s,this.normalized=a,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}},GLSL1:"100",GLSL3:be,GreaterCompare:516,GreaterDepth:6,GreaterEqualCompare:518,GreaterEqualDepth:5,GreaterEqualStencilFunc:518,GreaterStencilFunc:516,GridHelper:class extends xr{constructor(t=10,e=10,i=4473924,n=8947848){i=new zn(i),n=new zn(n);const s=e/2,a=t/e,r=t/2,o=[],l=[];for(let t=0,h=0,c=-r;t<=e;t++,c+=a){o.push(-r,0,c,r,0,c),o.push(c,0,-r,c,0,r);const e=t===s?i:n;e.toArray(l,h),h+=3,e.toArray(l,h),h+=3,e.toArray(l,h),h+=3,e.toArray(l,h),h+=3}const h=new os;h.setAttribute("position",new Kn(o,3)),h.setAttribute("color",new Kn(l,3)),super(h,new cr({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}},Group:Os,HalfFloatType:it,HemisphereLight:Jl,HemisphereLightHelper:class extends vn{constructor(t,e,i){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="HemisphereLightHelper";const n=new Zo(e);n.rotateY(.5*Math.PI),this.material=new Gn({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const s=n.getAttribute("position"),a=new Float32Array(3*s.count);n.setAttribute("color",new Zn(a,3)),this.add(new bs(n,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");bc.copy(this.light.color),Mc.copy(this.light.groundColor);for(let t=0,i=e.count;t<i;t++){const n=t<i/2?bc:Mc;e.setXYZ(t,n.r,n.g,n.b)}e.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),t.lookAt(vc.setFromMatrixPosition(this.light.matrixWorld).negate())}},IcosahedronGeometry:Yo,ImageBitmapLoader:class extends Vl{constructor(t){super(t),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&De("ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&De("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"},this._abortController=new AbortController}setOptions(t){return this.options=t,this}load(t,e,i,n){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,a=Ul.get(`image-bitmap:${t}`);if(void 0!==a)return s.manager.itemStart(t),a.then?void a.then(i=>{if(!0!==wh.has(a))return e&&e(i),s.manager.itemEnd(t),i;n&&n(wh.get(a)),s.manager.itemError(t),s.manager.itemEnd(t)}):(setTimeout(function(){e&&e(a),s.manager.itemEnd(t)},0),a);const r={};r.credentials="anonymous"===this.crossOrigin?"same-origin":"include",r.headers=this.requestHeader,r.signal="function"==typeof AbortSignal.any?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal;const o=fetch(t,r).then(function(t){return t.blob()}).then(function(t){return createImageBitmap(t,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(i){return Ul.add(`image-bitmap:${t}`,i),e&&e(i),s.manager.itemEnd(t),i}).catch(function(e){n&&n(e),wh.set(o,e),Ul.remove(`image-bitmap:${t}`),s.manager.itemError(t),s.manager.itemEnd(t)});Ul.add(`image-bitmap:${t}`,o),s.manager.itemStart(t)}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}},ImageLoader:ql,ImageUtils:ai,IncrementStencilOp:7682,IncrementWrapStencilOp:34055,InstancedBufferAttribute:Ta,InstancedBufferGeometry:vh,InstancedInterleavedBuffer:class extends Vs{constructor(t,e,i=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}},InstancedMesh:Ba,Int16BufferAttribute:class extends Zn{constructor(t,e,i){super(new Int16Array(t),e,i)}},Int32BufferAttribute:class extends Zn{constructor(t,e,i){super(new Int32Array(t),e,i)}},Int8BufferAttribute:class extends Zn{constructor(t,e,i){super(new Int8Array(t),e,i)}},IntType:K,InterleavedBuffer:Vs,InterleavedBufferAttribute:Ws,Interpolant:Tl,InterpolateDiscrete:Zt,InterpolateLinear:Jt,InterpolateSmooth:Qt,InterpolationSamplingMode:{NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FIRST:"first",EITHER:"either"},InterpolationSamplingType:{PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},InvertStencilOp:5386,KeepStencilOp:le,KeyframeTrack:Pl,LOD:ha,LatheGeometry:$o,Layers:en,LessCompare:513,LessDepth:2,LessEqualCompare:515,LessEqualDepth:3,LessEqualStencilFunc:515,LessStencilFunc:513,Light:Zl,LightProbe:gh,Line:vr,Line3:class{constructor(t=new qe,e=new qe){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){rc.subVectors(t,this.start),oc.subVectors(this.end,this.start);const i=oc.dot(oc);let n=oc.dot(rc)/i;return e&&(n=Ue(n,0,1)),n}closestPointToPoint(t,e,i){const n=this.closestPointToPointParameter(t,e);return this.delta(i).multiplyScalar(n).add(this.start)}distanceSqToLine3(t,e=uc,i=dc){const n=1e-8*1e-8;let s,a;const r=this.start,o=t.start,l=this.end,h=t.end;lc.subVectors(l,r),hc.subVectors(h,o),cc.subVectors(r,o);const c=lc.dot(lc),u=hc.dot(hc),d=hc.dot(cc);if(c<=n&&u<=n)return e.copy(r),i.copy(o),e.sub(i),e.dot(e);if(c<=n)s=0,a=d/u,a=Ue(a,0,1);else{const t=lc.dot(cc);if(u<=n)a=0,s=Ue(-t/c,0,1);else{const e=lc.dot(hc),i=c*u-e*e;s=0!==i?Ue((e*d-t*u)/i,0,1):0,a=(e*s+d)/u,a<0?(a=0,s=Ue(-t/c,0,1)):a>1&&(a=1,s=Ue((e-t)/c,0,1))}}return e.copy(r).add(lc.multiplyScalar(s)),i.copy(o).add(hc.multiplyScalar(a)),e.sub(i),e.dot(e)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}},LineBasicMaterial:cr,LineCurve:oo,LineCurve3:lo,LineDashedMaterial:bl,LineLoop:wr,LineSegments:xr,LinearFilter:X,LinearInterpolant:El,LinearMipMapLinearFilter:1008,LinearMipMapNearestFilter:1007,LinearMipmapLinearFilter:Y,LinearMipmapNearestFilter:q,LinearSRGBColorSpace:ae,LinearToneMapping:1,LinearTransfer:re,Loader:Vl,LoaderUtils:yh,LoadingManager:Nl,LoopOnce:2200,LoopPingPong:2202,LoopRepeat:2201,MOUSE:e,Material:Nn,MaterialLoader:fh,MathUtils:We,Matrix2:sc,Matrix3:Ze,Matrix4:Wi,MaxEquation:104,Mesh:bs,MeshBasicMaterial:Gn,MeshDepthMaterial:fl,MeshDistanceMaterial:yl,MeshLambertMaterial:gl,MeshMatcapMaterial:vl,MeshNormalMaterial:ml,MeshPhongMaterial:dl,MeshPhysicalMaterial:ul,MeshStandardMaterial:cl,MeshToonMaterial:pl,MinEquation:103,MirroredRepeatWrapping:V,MixOperation:1,MultiplyBlending:4,MultiplyOperation:0,NearestFilter:H,NearestMipMapLinearFilter:1005,NearestMipMapNearestFilter:1004,NearestMipmapLinearFilter:j,NearestMipmapNearestFilter:W,NeutralToneMapping:7,NeverCompare:512,NeverDepth:0,NeverStencilFunc:512,NoBlending:0,NoColorSpace:ne,NoToneMapping:0,NormalAnimationBlendMode:2500,NormalBlending:1,NotEqualCompare:517,NotEqualDepth:7,NotEqualStencilFunc:517,NumberKeyframeTrack:Il,Object3D:vn,ObjectLoader:class extends Vl{constructor(t){super(t)}load(t,e,i,n){const s=this,a=""===this.path?yh.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||a;const r=new jl(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(t,function(i){let a=null;try{a=JSON.parse(i)}catch(e){return void 0!==n&&n(e),void e("ObjectLoader: Can't parse "+t+".",e.message)}const r=a.metadata;if(void 0===r||void 0===r.type||"geometry"===r.type.toLowerCase())return void 0!==n&&n(new Error("THREE.ObjectLoader: Can't load "+t)),void Re("ObjectLoader: Can't load "+t);s.parse(a,e)},i,n)}async loadAsync(t,e){const i=""===this.path?yh.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||i;const n=new jl(this.manager);n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials);const s=await n.loadAsync(t,e),a=JSON.parse(s),r=a.metadata;if(void 0===r||void 0===r.type||"geometry"===r.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(a)}parse(t,e){const i=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),s=this.parseGeometries(t.geometries,n),a=this.parseImages(t.images,function(){void 0!==e&&e(l)}),r=this.parseTextures(t.textures,a),o=this.parseMaterials(t.materials,r),l=this.parseObject(t.object,s,o,r,i),h=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,h),this.bindLightTargets(l),void 0!==e){let t=!1;for(const e in a)if(a[e].data instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}async parseAsync(t){const e=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),n=this.parseGeometries(t.geometries,i),s=await this.parseImagesAsync(t.images),a=this.parseTextures(t.textures,s),r=this.parseMaterials(t.materials,a),o=this.parseObject(t.object,n,r,a,e),l=this.parseSkeletons(t.skeletons,o);return this.bindSkeletons(o,l),this.bindLightTargets(o),o}parseShapes(t){const e={};if(void 0!==t)for(let i=0,n=t.length;i<n;i++){const n=(new fo).fromJSON(t[i]);e[n.uuid]=n}return e}parseSkeletons(t,e){const i={},n={};if(e.traverse(function(t){t.isBone&&(n[t.uuid]=t)}),void 0!==t)for(let e=0,s=t.length;e<s;e++){const s=(new Sa).fromJSON(t[e],n);i[s.uuid]=s}return i}parseGeometries(t,e){const i={};if(void 0!==t){const n=new bh;for(let s=0,a=t.length;s<a;s++){let a;const r=t[s];switch(r.type){case"BufferGeometry":case"InstancedBufferGeometry":a=n.parse(r);break;default:r.type in ol?a=ol[r.type].fromJSON(r,e):De(`ObjectLoader: Unsupported geometry type "${r.type}"`)}a.uuid=r.uuid,void 0!==r.name&&(a.name=r.name),void 0!==r.userData&&(a.userData=r.userData),i[r.uuid]=a}}return i}parseMaterials(t,e){const i={},n={};if(void 0!==t){const s=new fh;s.setTextures(e);for(let e=0,a=t.length;e<a;e++){const a=t[e];void 0===i[a.uuid]&&(i[a.uuid]=s.parse(a)),n[a.uuid]=i[a.uuid]}}return n}parseAnimations(t){const e={};if(void 0!==t)for(let i=0;i<t.length;i++){const n=t[i],s=zl.parse(n);e[s.uuid]=s}return e}parseImages(t,e){const i=this,n={};let s;function a(t){if("string"==typeof t){const e=t;return function(t){return i.manager.itemStart(t),s.load(t,function(){i.manager.itemEnd(t)},void 0,function(){i.manager.itemError(t),i.manager.itemEnd(t)})}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:i.resourcePath+e)}return t.data?{data:Se(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const i=new Nl(e);s=new ql(i),s.setCrossOrigin(this.crossOrigin);for(let e=0,i=t.length;e<i;e++){const i=t[e],s=i.url;if(Array.isArray(s)){const t=[];for(let e=0,i=s.length;e<i;e++){const i=a(s[e]);null!==i&&(i instanceof HTMLImageElement?t.push(i):t.push(new _a(i.data,i.width,i.height)))}n[i.uuid]=new oi(t)}else{const t=a(i.url);n[i.uuid]=new oi(t)}}}return n}async parseImagesAsync(t){const e=this,i={};let n;async function s(t){if("string"==typeof t){const i=t,s=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(i)?i:e.resourcePath+i;return await n.loadAsync(s)}return t.data?{data:Se(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){n=new ql(this.manager),n.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],a=n.url;if(Array.isArray(a)){const t=[];for(let e=0,i=a.length;e<i;e++){const i=a[e],n=await s(i);null!==n&&(n instanceof HTMLImageElement?t.push(n):t.push(new _a(n.data,n.width,n.height)))}i[n.uuid]=new oi(t)}else{const t=await s(n.url);i[n.uuid]=new oi(t)}}}return i}parseTextures(t,e){function i(t,e){return"number"==typeof t?t:(De("ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const n={};if(void 0!==t)for(let s=0,a=t.length;s<a;s++){const a=t[s];void 0===a.image&&De('ObjectLoader: No "image" specified for',a.uuid),void 0===e[a.image]&&De("ObjectLoader: Undefined image",a.image);const r=e[a.image],o=r.data;let l;Array.isArray(o)?(l=new Ls,6===o.length&&(l.needsUpdate=!0)):(l=o&&o.data?new _a:new ui,o&&(l.needsUpdate=!0)),l.source=r,l.uuid=a.uuid,void 0!==a.name&&(l.name=a.name),void 0!==a.mapping&&(l.mapping=i(a.mapping,Mh)),void 0!==a.channel&&(l.channel=a.channel),void 0!==a.offset&&l.offset.fromArray(a.offset),void 0!==a.repeat&&l.repeat.fromArray(a.repeat),void 0!==a.center&&l.center.fromArray(a.center),void 0!==a.rotation&&(l.rotation=a.rotation),void 0!==a.wrap&&(l.wrapS=i(a.wrap[0],_h),l.wrapT=i(a.wrap[1],_h)),void 0!==a.format&&(l.format=a.format),void 0!==a.internalFormat&&(l.internalFormat=a.internalFormat),void 0!==a.type&&(l.type=a.type),void 0!==a.colorSpace&&(l.colorSpace=a.colorSpace),void 0!==a.minFilter&&(l.minFilter=i(a.minFilter,xh)),void 0!==a.magFilter&&(l.magFilter=i(a.magFilter,xh)),void 0!==a.anisotropy&&(l.anisotropy=a.anisotropy),void 0!==a.flipY&&(l.flipY=a.flipY),void 0!==a.generateMipmaps&&(l.generateMipmaps=a.generateMipmaps),void 0!==a.premultiplyAlpha&&(l.premultiplyAlpha=a.premultiplyAlpha),void 0!==a.unpackAlignment&&(l.unpackAlignment=a.unpackAlignment),void 0!==a.compareFunction&&(l.compareFunction=a.compareFunction),void 0!==a.userData&&(l.userData=a.userData),n[a.uuid]=l}return n}parseObject(t,e,i,n,s){let a,r,o;function l(t){return void 0===e[t]&&De("ObjectLoader: Undefined geometry",t),e[t]}function h(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let n=0,s=t.length;n<s;n++){const s=t[n];void 0===i[s]&&De("ObjectLoader: Undefined material",s),e.push(i[s])}return e}return void 0===i[t]&&De("ObjectLoader: Undefined material",t),i[t]}}function c(t){return void 0===n[t]&&De("ObjectLoader: Undefined texture",t),n[t]}switch(t.type){case"Scene":a=new Gs,void 0!==t.background&&(Number.isInteger(t.background)?a.background=new zn(t.background):a.background=c(t.background)),void 0!==t.environment&&(a.environment=c(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?a.fog=new Ns(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(a.fog=new Us(t.fog.color,t.fog.density)),""!==t.fog.name&&(a.fog.name=t.fog.name)),void 0!==t.backgroundBlurriness&&(a.backgroundBlurriness=t.backgroundBlurriness),void 0!==t.backgroundIntensity&&(a.backgroundIntensity=t.backgroundIntensity),void 0!==t.backgroundRotation&&a.backgroundRotation.fromArray(t.backgroundRotation),void 0!==t.environmentIntensity&&(a.environmentIntensity=t.environmentIntensity),void 0!==t.environmentRotation&&a.environmentRotation.fromArray(t.environmentRotation);break;case"PerspectiveCamera":a=new Rs(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(a.focus=t.focus),void 0!==t.zoom&&(a.zoom=t.zoom),void 0!==t.filmGauge&&(a.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(a.filmOffset=t.filmOffset),void 0!==t.view&&(a.view=Object.assign({},t.view));break;case"OrthographicCamera":a=new hh(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(a.zoom=t.zoom),void 0!==t.view&&(a.view=Object.assign({},t.view));break;case"AmbientLight":a=new dh(t.color,t.intensity);break;case"DirectionalLight":a=new uh(t.color,t.intensity),a.target=t.target||"";break;case"PointLight":a=new lh(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":a=new ph(t.color,t.intensity,t.width,t.height);break;case"SpotLight":a=new nh(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay),a.target=t.target||"";break;case"HemisphereLight":a=new Jl(t.color,t.groundColor,t.intensity);break;case"LightProbe":a=(new gh).fromJSON(t);break;case"SkinnedMesh":r=l(t.geometry),o=h(t.material),a=new ba(r,o),void 0!==t.bindMode&&(a.bindMode=t.bindMode),void 0!==t.bindMatrix&&a.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(a.skeleton=t.skeleton);break;case"Mesh":r=l(t.geometry),o=h(t.material),a=new bs(r,o);break;case"InstancedMesh":r=l(t.geometry),o=h(t.material);const e=t.count,i=t.instanceMatrix,n=t.instanceColor;a=new Ba(r,o,e),a.instanceMatrix=new Ta(new Float32Array(i.array),16),void 0!==n&&(a.instanceColor=new Ta(new Float32Array(n.array),n.itemSize));break;case"BatchedMesh":r=l(t.geometry),o=h(t.material),a=new hr(t.maxInstanceCount,t.maxVertexCount,t.maxIndexCount,o),a.geometry=r,a.perObjectFrustumCulled=t.perObjectFrustumCulled,a.sortObjects=t.sortObjects,a._drawRanges=t.drawRanges,a._reservedRanges=t.reservedRanges,a._geometryInfo=t.geometryInfo.map(t=>{let e=null,i=null;return void 0!==t.boundingBox&&(e=(new yi).fromJSON(t.boundingBox)),void 0!==t.boundingSphere&&(i=(new ki).fromJSON(t.boundingSphere)),{...t,boundingBox:e,boundingSphere:i}}),a._instanceInfo=t.instanceInfo,a._availableInstanceIds=t._availableInstanceIds,a._availableGeometryIds=t._availableGeometryIds,a._nextIndexStart=t.nextIndexStart,a._nextVertexStart=t.nextVertexStart,a._geometryCount=t.geometryCount,a._maxInstanceCount=t.maxInstanceCount,a._maxVertexCount=t.maxVertexCount,a._maxIndexCount=t.maxIndexCount,a._geometryInitialized=t.geometryInitialized,a._matricesTexture=c(t.matricesTexture.uuid),a._indirectTexture=c(t.indirectTexture.uuid),void 0!==t.colorsTexture&&(a._colorsTexture=c(t.colorsTexture.uuid)),void 0!==t.boundingSphere&&(a.boundingSphere=(new ki).fromJSON(t.boundingSphere)),void 0!==t.boundingBox&&(a.boundingBox=(new yi).fromJSON(t.boundingBox));break;case"LOD":a=new ha;break;case"Line":a=new vr(l(t.geometry),h(t.material));break;case"LineLoop":a=new wr(l(t.geometry),h(t.material));break;case"LineSegments":a=new xr(l(t.geometry),h(t.material));break;case"PointCloud":case"Points":a=new Pr(l(t.geometry),h(t.material));break;case"Sprite":a=new aa(h(t.material));break;case"Group":a=new Os;break;case"Bone":a=new Ma;break;default:a=new vn}if(a.uuid=t.uuid,void 0!==t.name&&(a.name=t.name),void 0!==t.matrix?(a.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(a.matrixAutoUpdate=t.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(void 0!==t.position&&a.position.fromArray(t.position),void 0!==t.rotation&&a.rotation.fromArray(t.rotation),void 0!==t.quaternion&&a.quaternion.fromArray(t.quaternion),void 0!==t.scale&&a.scale.fromArray(t.scale)),void 0!==t.up&&a.up.fromArray(t.up),void 0!==t.castShadow&&(a.castShadow=t.castShadow),void 0!==t.receiveShadow&&(a.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.intensity&&(a.shadow.intensity=t.shadow.intensity),void 0!==t.shadow.bias&&(a.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(a.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(a.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&a.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(a.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(a.visible=t.visible),void 0!==t.frustumCulled&&(a.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(a.renderOrder=t.renderOrder),void 0!==t.userData&&(a.userData=t.userData),void 0!==t.layers&&(a.layers.mask=t.layers),void 0!==t.children){const r=t.children;for(let t=0;t<r.length;t++)a.add(this.parseObject(r[t],e,i,n,s))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const i=e[t];a.animations.push(s[i])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(a.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const i=e[t],n=a.getObjectByProperty("uuid",i.object);void 0!==n&&a.addLevel(n,i.distance,i.hysteresis)}}return a}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse(function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const i=e[t.skeleton];void 0===i?De("ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(i,t.bindMatrix)}})}bindLightTargets(t){t.traverse(function(e){if(e.isDirectionalLight||e.isSpotLight){const i=e.target,n=t.getObjectByProperty("uuid",i);e.target=void 0!==n?n:new vn}})}},ObjectSpaceNormalMap:1,OctahedronGeometry:Zo,OneFactor:c,OneMinusConstantAlphaFactor:214,OneMinusConstantColorFactor:212,OneMinusDstAlphaFactor:207,OneMinusDstColorFactor:209,OneMinusSrcAlphaFactor:m,OneMinusSrcColorFactor:203,OrthographicCamera:hh,PCFShadowMap:1,PCFSoftShadowMap:2,PMREMGenerator:eu,Path:go,PerspectiveCamera:Rs,Plane:za,PlaneGeometry:Jo,PlaneHelper:class extends vr{constructor(t,e=1,i=16776960){const n=i,s=new os;s.setAttribute("position",new Kn([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),s.computeBoundingSphere(),super(s,new cr({color:n,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const a=new os;a.setAttribute("position",new Kn([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),a.computeBoundingSphere(),this.add(new bs(a,new Gn({color:n,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}},PointLight:lh,PointLightHelper:class extends bs{constructor(t,e,i){super(new tl(e,4,2),new Gn({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},Points:Pr,PointsMaterial:Sr,PolarGridHelper:class extends xr{constructor(t=10,e=16,i=8,n=64,s=4473924,a=8947848){s=new zn(s),a=new zn(a);const r=[],o=[];if(e>1)for(let i=0;i<e;i++){const n=i/e*(2*Math.PI),l=Math.sin(n)*t,h=Math.cos(n)*t;r.push(0,0,0),r.push(l,0,h);const c=1&i?s:a;o.push(c.r,c.g,c.b),o.push(c.r,c.g,c.b)}for(let e=0;e<i;e++){const l=1&e?s:a,h=t-t/i*e;for(let t=0;t<n;t++){let e=t/n*(2*Math.PI),i=Math.sin(e)*h,s=Math.cos(e)*h;r.push(i,0,s),o.push(l.r,l.g,l.b),e=(t+1)/n*(2*Math.PI),i=Math.sin(e)*h,s=Math.cos(e)*h,r.push(i,0,s),o.push(l.r,l.g,l.b)}}const l=new os;l.setAttribute("position",new Kn(r,3)),l.setAttribute("color",new Kn(o,3)),super(l,new cr({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}},PolyhedronGeometry:Nr,PositionalAudio:class extends Oh{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,i){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=i,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(zh,Fh,Uh),Nh.set(0,0,1).applyQuaternion(Fh);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(zh.x,t),e.positionY.linearRampToValueAtTime(zh.y,t),e.positionZ.linearRampToValueAtTime(zh.z,t),e.orientationX.linearRampToValueAtTime(Nh.x,t),e.orientationY.linearRampToValueAtTime(Nh.y,t),e.orientationZ.linearRampToValueAtTime(Nh.z,t)}else e.setPosition(zh.x,zh.y,zh.z),e.setOrientation(Nh.x,Nh.y,Nh.z)}},PropertyBinding:Yh,PropertyMixer:Gh,QuadraticBezierCurve:ho,QuadraticBezierCurve3:co,Quaternion:Xe,QuaternionKeyframeTrack:Ll,QuaternionLinearInterpolant:Bl,RED_GREEN_RGTC2_Format:Yt,RED_RGTC1_Format:Xt,REVISION:t,RGBADepthPacking:3201,RGBAFormat:ct,RGBAIntegerFormat:yt,RGBA_ASTC_10x10_Format:Nt,RGBA_ASTC_10x5_Format:zt,RGBA_ASTC_10x6_Format:Ft,RGBA_ASTC_10x8_Format:Ut,RGBA_ASTC_12x10_Format:Gt,RGBA_ASTC_12x12_Format:Vt,RGBA_ASTC_4x4_Format:Pt,RGBA_ASTC_5x4_Format:Dt,RGBA_ASTC_5x5_Format:Rt,RGBA_ASTC_6x5_Format:It,RGBA_ASTC_6x6_Format:Bt,RGBA_ASTC_8x5_Format:Lt,RGBA_ASTC_8x6_Format:kt,RGBA_ASTC_8x8_Format:Ot,RGBA_BPTC_Format:Ht,RGBA_ETC2_EAC_Format:At,RGBA_PVRTC_2BPPV1_Format:Tt,RGBA_PVRTC_4BPPV1_Format:St,RGBA_S3TC_DXT1_Format:bt,RGBA_S3TC_DXT3_Format:Mt,RGBA_S3TC_DXT5_Format:_t,RGBDepthPacking:3202,RGBFormat:ht,RGBIntegerFormat:1032,RGB_BPTC_SIGNED_Format:Wt,RGB_BPTC_UNSIGNED_Format:jt,RGB_ETC1_Format:Ct,RGB_ETC2_Format:Et,RGB_PVRTC_2BPPV1_Format:wt,RGB_PVRTC_4BPPV1_Format:xt,RGB_S3TC_DXT1_Format:vt,RGDepthPacking:3203,RGFormat:gt,RGIntegerFormat:ft,RawShaderMaterial:hl,Ray:Hi,Raycaster:class{constructor(t,e,i=0,n=1/0){this.ray=new Hi(t,e),this.near=i,this.far=n,this.camera=null,this.layers=new en,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):Re("Raycaster: Unsupported camera type: "+e.type)}setFromXRController(t){return Kh.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(Kh),this}intersectObject(t,e=!0,i=[]){return ec(t,this,i,e),i.sort(tc),i}intersectObjects(t,e=!0,i=[]){for(let n=0,s=t.length;n<s;n++)ec(t[n],this,i,e);return i.sort(tc),i}},RectAreaLight:ph,RedFormat:pt,RedIntegerFormat:mt,ReinhardToneMapping:2,RenderTarget:pi,RenderTarget3D:class extends pi{constructor(t=1,e=1,i=1,n={}){super(t,e,n),this.isRenderTarget3D=!0,this.depth=i,this.texture=new fi(null,t,e,i),this._setTextureOptions(n),this.texture.isRenderTargetTexture=!0}},RepeatWrapping:N,ReplaceStencilOp:7681,ReverseSubtractEquation:102,RingGeometry:Qo,SIGNED_RED_GREEN_RGTC2_Format:$t,SIGNED_RED_RGTC1_Format:qt,SRGBColorSpace:se,SRGBTransfer:oe,Scene:Gs,ShaderChunk:kc,ShaderLib:zc,ShaderMaterial:Cs,ShadowMaterial:ll,Shape:fo,ShapeGeometry:Ko,ShapePath:class{constructor(){this.type="ShapePath",this.color=new zn,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new go,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,i,n){return this.currentPath.quadraticCurveTo(t,e,i,n),this}bezierCurveTo(t,e,i,n,s,a){return this.currentPath.bezierCurveTo(t,e,i,n,s,a),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function e(t,e){const i=e.length;let n=!1;for(let s=i-1,a=0;a<i;s=a++){let i=e[s],r=e[a],o=r.x-i.x,l=r.y-i.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(i=e[a],o=-o,r=e[s],l=-l),t.y<i.y||t.y>r.y)continue;if(t.y===i.y){if(t.x===i.x)return!0}else{const e=l*(t.x-i.x)-o*(t.y-i.y);if(0===e)return!0;if(e<0)continue;n=!n}}else{if(t.y!==i.y)continue;if(r.x<=t.x&&t.x<=i.x||i.x<=t.x&&t.x<=r.x)return!0}}return n}const i=Ho.isClockWise,n=this.subPaths;if(0===n.length)return[];let s,a,r;const o=[];if(1===n.length)return a=n[0],r=new fo,r.curves=a.curves,o.push(r),o;let l=!i(n[0].getPoints());l=t?!l:l;const h=[],c=[];let u,d,p=[],m=0;c[m]=void 0,p[m]=[];for(let e=0,r=n.length;e<r;e++)a=n[e],u=a.getPoints(),s=i(u),s=t?!s:s,s?(!l&&c[m]&&m++,c[m]={s:new fo,p:u},c[m].s.curves=a.curves,l&&m++,p[m]=[]):p[m].push({h:a,p:u[0]});if(!c[0])return function(t){const e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i],s=new fo;s.curves=n.curves,e.push(s)}return e}(n);if(c.length>1){let t=!1,i=0;for(let t=0,e=c.length;t<e;t++)h[t]=[];for(let n=0,s=c.length;n<s;n++){const s=p[n];for(let a=0;a<s.length;a++){const r=s[a];let o=!0;for(let s=0;s<c.length;s++)e(r.p,c[s].p)&&(n!==s&&i++,o?(o=!1,h[s].push(r)):t=!0);o&&h[n].push(r)}}i>0&&!1===t&&(p=h)}for(let t=0,e=c.length;t<e;t++){r=c[t].s,o.push(r),d=p[t];for(let t=0,e=d.length;t<e;t++)r.holes.push(d[t].h)}return o}},ShapeUtils:Ho,ShortType:J,Skeleton:Sa,SkeletonHelper:class extends xr{constructor(t){const e=yc(t),i=new os,n=[],s=[];for(let t=0;t<e.length;t++){const i=e[t];i.parent&&i.parent.isBone&&(n.push(0,0,0),n.push(0,0,0),s.push(0,0,0),s.push(0,0,0))}i.setAttribute("position",new Kn(n,3)),i.setAttribute("color",new Kn(s,3)),super(i,new cr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1;const a=new zn(255),r=new zn(65280);this.setColors(a,r)}updateMatrixWorld(t){const e=this.bones,i=this.geometry,n=i.getAttribute("position");fc.copy(this.root.matrixWorld).invert();for(let t=0,i=0;t<e.length;t++){const s=e[t];s.parent&&s.parent.isBone&&(gc.multiplyMatrices(fc,s.matrixWorld),mc.setFromMatrixPosition(gc),n.setXYZ(i,mc.x,mc.y,mc.z),gc.multiplyMatrices(fc,s.parent.matrixWorld),mc.setFromMatrixPosition(gc),n.setXYZ(i+1,mc.x,mc.y,mc.z),i+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}setColors(t,e){const i=this.geometry.getAttribute("color");for(let n=0;n<i.count;n+=2)i.setXYZ(n,t.r,t.g,t.b),i.setXYZ(n+1,e.r,e.g,e.b);return i.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}},SkinnedMesh:ba,Source:oi,Sphere:ki,SphereGeometry:tl,Spherical:nc,SphericalHarmonics3:mh,SplineCurve:uo,SpotLight:nh,SpotLightHelper:class extends vn{constructor(t,e){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=e,this.type="SpotLightHelper";const i=new os,n=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,i=32;t<i;t++,e++){const s=t/i*Math.PI*2,a=e/i*Math.PI*2;n.push(Math.cos(s),Math.sin(s),1,Math.cos(a),Math.sin(a),1)}i.setAttribute("position",new Kn(n,3));const s=new cr({fog:!1,toneMapped:!1});this.cone=new xr(i,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),pc.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(pc),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},Sprite:aa,SpriteMaterial:js,SrcAlphaFactor:p,SrcAlphaSaturateFactor:210,SrcColorFactor:202,StaticCopyUsage:35046,StaticDrawUsage:ye,StaticReadUsage:35045,StereoCamera:class{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Rs,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Rs,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,Ah.copy(t.projectionMatrix);const i=e.eyeSep/2,n=i*e.near/e.focus,s=e.near*Math.tan(Oe*e.fov*.5)/e.zoom;let a,r;Eh.elements[12]=-i,Ch.elements[12]=i,a=-s*e.aspect+n,r=s*e.aspect+n,Ah.elements[0]=2*e.near/(r-a),Ah.elements[8]=(r+a)/(r-a),this.cameraL.projectionMatrix.copy(Ah),a=-s*e.aspect-n,r=s*e.aspect-n,Ah.elements[0]=2*e.near/(r-a),Ah.elements[8]=(r+a)/(r-a),this.cameraR.projectionMatrix.copy(Ah)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Eh),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ch)}},StreamCopyUsage:35042,StreamDrawUsage:35040,StreamReadUsage:35041,StringKeyframeTrack:kl,SubtractEquation:101,SubtractiveBlending:3,TOUCH:i,TangentSpaceNormalMap:0,TetrahedronGeometry:el,Texture:ui,TextureLoader:$l,TextureUtils:class{static contain(t,e){return function(t,e){const i=t.image&&t.image.width?t.image.width/t.image.height:1;return i>e?(t.repeat.x=1,t.repeat.y=i/e,t.offset.x=0,t.offset.y=(1-t.repeat.y)/2):(t.repeat.x=e/i,t.repeat.y=1,t.offset.x=(1-t.repeat.x)/2,t.offset.y=0),t}(t,e)}static cover(t,e){return function(t,e){const i=t.image&&t.image.width?t.image.width/t.image.height:1;return i>e?(t.repeat.x=e/i,t.repeat.y=1,t.offset.x=(1-t.repeat.x)/2,t.offset.y=0):(t.repeat.x=1,t.repeat.y=i/e,t.offset.x=0,t.offset.y=(1-t.repeat.y)/2),t}(t,e)}static fill(t){return function(t){return t.repeat.x=1,t.repeat.y=1,t.offset.x=0,t.offset.y=0,t}(t)}static getByteLength(t,e,i,n){return Ic(t,e,i,n)}},Timer:class{constructor(){this._previousTime=0,this._currentTime=0,this._startTime=performance.now(),this._delta=0,this._elapsed=0,this._timescale=1,this._document=null,this._pageVisibilityHandler=null}connect(t){this._document=t,void 0!==t.hidden&&(this._pageVisibilityHandler=ic.bind(this),t.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disconnect(){null!==this._pageVisibilityHandler&&(this._document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this._pageVisibilityHandler=null),this._document=null}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getTimescale(){return this._timescale}setTimescale(t){return this._timescale=t,this}reset(){return this._currentTime=performance.now()-this._startTime,this}dispose(){this.disconnect()}update(t){return null!==this._pageVisibilityHandler&&!0===this._document.hidden?this._delta=0:(this._previousTime=this._currentTime,this._currentTime=(void 0!==t?t:performance.now())-this._startTime,this._delta=(this._currentTime-this._previousTime)*this._timescale,this._elapsed+=this._delta),this}},TimestampQuery:{COMPUTE:"compute",RENDER:"render"},TorusGeometry:il,TorusKnotGeometry:nl,Triangle:In,TriangleFanDrawMode:2,TriangleStripDrawMode:1,TrianglesDrawMode:0,TubeGeometry:sl,UVMapping:L,Uint16BufferAttribute:Jn,Uint32BufferAttribute:Qn,Uint8BufferAttribute:class extends Zn{constructor(t,e,i){super(new Uint8Array(t),e,i)}},Uint8ClampedBufferAttribute:class extends Zn{constructor(t,e,i){super(new Uint8ClampedArray(t),e,i)}},Uniform:Jh,UniformsGroup:class extends Be{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:Qh++}),this.name="",this.usage=ye,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const e=this.uniforms.indexOf(t);return-1!==e&&this.uniforms.splice(e,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(t){this.name=t.name,this.usage=t.usage;const e=t.uniforms;this.uniforms.length=0;for(let t=0,i=e.length;t<i;t++){const i=Array.isArray(e[t])?e[t]:[e[t]];for(let t=0;t<i.length;t++)this.uniforms.push(i[t].clone())}return this}clone(){return(new this.constructor).copy(this)}},UniformsLib:Oc,UniformsUtils:Ts,UnsignedByteType:$,UnsignedInt101111Type:ot,UnsignedInt248Type:at,UnsignedInt5999Type:rt,UnsignedIntType:tt,UnsignedShort4444Type:nt,UnsignedShort5551Type:st,UnsignedShortType:Q,VSMShadowMap:3,Vector2:je,Vector3:qe,Vector4:di,VectorKeyframeTrack:Ol,VideoFrameTexture:class extends Rr{constructor(t,e,i,n,s,a,r,o){super({},t,e,i,n,s,a,r,o),this.isVideoFrameTexture=!0}update(){}clone(){return(new this.constructor).copy(this)}setFrame(t){this.image=t,this.needsUpdate=!0}},VideoTexture:Rr,WebGL3DRenderTarget:class extends mi{constructor(t=1,e=1,i=1,n={}){super(t,e,n),this.isWebGL3DRenderTarget=!0,this.depth=i,this.texture=new fi(null,t,e,i),this._setTextureOptions(n),this.texture.isRenderTargetTexture=!0}},WebGLArrayRenderTarget:class extends mi{constructor(t=1,e=1,i=1,n={}){super(t,e,n),this.isWebGLArrayRenderTarget=!0,this.depth=i,this.texture=new gi(null,t,e,i),this._setTextureOptions(n),this.texture.isRenderTargetTexture=!0}},WebGLCoordinateSystem:Me,WebGLCubeRenderTarget:ks,WebGLRenderTarget:mi,WebGLRenderer:up,WebGLUtils:ip,WebGPUCoordinateSystem:_e,WebXRController:Fs,WireframeGeometry:al,WrapAroundEnding:ee,ZeroCurvatureEnding:Kt,ZeroFactor:200,ZeroSlopeEnding:te,ZeroStencilOp:0,createCanvasElement:Ce,error:Re,getConsoleFunction:function(){return Ae},log:Pe,setConsoleFunction:function(t){Ae=t},warn:De,warnOnce:Ie});const pp={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class mp{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const gp=new hh(-1,1,1,-1,0,1),fp=new class extends os{constructor(){super(),this.setAttribute("position",new Kn([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Kn([0,2,0,0,2,0],2))}};class yp{constructor(t){this._mesh=new bs(fp,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,gp)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}class vp extends mp{constructor(t,e="tDiffuse"){super(),this.textureID=e,this.uniforms=null,this.material=null,t instanceof Cs?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=Ts.clone(t.uniforms),this.material=new Cs({name:void 0!==t.name?t.name:"unspecified",defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this._fsQuad=new yp(this.material)}render(t,e,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this._fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this._fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this._fsQuad.render(t))}dispose(){this.material.dispose(),this._fsQuad.dispose()}}class bp extends mp{constructor(t,e){super(),this.scene=t,this.camera=e,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,e,i){const n=t.getContext(),s=t.state;let a,r;s.buffers.color.setMask(!1),s.buffers.depth.setMask(!1),s.buffers.color.setLocked(!0),s.buffers.depth.setLocked(!0),this.inverse?(a=0,r=1):(a=1,r=0),s.buffers.stencil.setTest(!0),s.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),s.buffers.stencil.setFunc(n.ALWAYS,a,4294967295),s.buffers.stencil.setClear(r),s.buffers.stencil.setLocked(!0),t.setRenderTarget(i),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),s.buffers.color.setLocked(!1),s.buffers.depth.setLocked(!1),s.buffers.color.setMask(!0),s.buffers.depth.setMask(!0),s.buffers.stencil.setLocked(!1),s.buffers.stencil.setFunc(n.EQUAL,1,4294967295),s.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),s.buffers.stencil.setLocked(!0)}}class Mp extends mp{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}class _p{constructor(t,e){if(this.renderer=t,this._pixelRatio=t.getPixelRatio(),void 0===e){const i=t.getSize(new je);this._width=i.width,this._height=i.height,(e=new mi(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:it})).texture.name="EffectComposer.rt1"}else this._width=e.width,this._height=e.height;this.renderTarget1=e,this.renderTarget2=e.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new vp(pp),this.copyPass.material.blending=0,this.clock=new Dh}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(t,e){this.passes.splice(e,0,t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(t){const e=this.passes.indexOf(t);-1!==e&&this.passes.splice(e,1)}isLastEnabledPass(t){for(let e=t+1;e<this.passes.length;e++)if(this.passes[e].enabled)return!1;return!0}render(t){void 0===t&&(t=this.clock.getDelta());const e=this.renderer.getRenderTarget();let i=!1;for(let e=0,n=this.passes.length;e<n;e++){const n=this.passes[e];if(!1!==n.enabled){if(n.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(e),n.render(this.renderer,this.writeBuffer,this.readBuffer,t,i),n.needsSwap){if(i){const e=this.renderer.getContext(),i=this.renderer.state.buffers.stencil;i.setFunc(e.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),i.setFunc(e.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==bp&&(n instanceof bp?i=!0:n instanceof Mp&&(i=!1))}}this.renderer.setRenderTarget(e)}reset(t){if(void 0===t){const e=this.renderer.getSize(new je);this._pixelRatio=this.renderer.getPixelRatio(),this._width=e.width,this._height=e.height,(t=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,e){this._width=t,this._height=e;const i=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(i,n),this.renderTarget2.setSize(i,n);for(let t=0;t<this.passes.length;t++)this.passes[t].setSize(i,n)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class xp extends mp{constructor(t,e,i=null,n=null,s=null){super(),this.scene=t,this.camera=e,this.overrideMaterial=i,this.clearColor=n,this.clearAlpha=s,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new zn}render(t,e,i){const n=t.autoClear;let s,a;t.autoClear=!1,null!==this.overrideMaterial&&(a=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(t.getClearColor(this._oldClearColor),t.setClearColor(this.clearColor,t.getClearAlpha())),null!==this.clearAlpha&&(s=t.getClearAlpha(),t.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:i),!0===this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),null!==this.clearColor&&t.setClearColor(this._oldClearColor),null!==this.clearAlpha&&t.setClearAlpha(s),null!==this.overrideMaterial&&(this.scene.overrideMaterial=a),t.autoClear=n}}class wp extends mp{constructor(t,e,i,n){super(),this.strength=void 0!==e?e:1,this.radius=i,this.threshold=n,this.resolution=void 0!==t?new je(t.x,t.y):new je(256,256);const s={minFilter:X,magFilter:X,format:ct,type:it};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let a=Math.round(.75*this.resolution.x),r=Math.round(.75*this.resolution.y);this.renderTargetBright=new mi(a,r,s),this.renderTargetBright.texture.name="UnrealBloomPassAlpha.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let t=0;t<this.nMips;t++){const e=new mi(a,r,s);e.texture.name=`UnrealBloomPassAlpha.h${t}`,e.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(e);const i=new mi(a,r,s);i.texture.name=`UnrealBloomPassAlpha.v${t}`,i.texture.generateMipmaps=!1,this.renderTargetsVertical.push(i),a=Math.round(a/2),r=Math.round(r/2)}this.highPassUniforms={tDiffuse:{value:null},luminosityThreshold:{value:n},smoothWidth:{value:.01}},this.materialHighPassFilter=new Cs({uniforms:this.highPassUniforms,vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                uniform float luminosityThreshold;\n                uniform float smoothWidth;\n                varying vec2 vUv;\n\n                void main() {\n                    vec4 texel = texture2D(tDiffuse, vUv);\n                    vec3 luma = vec3(0.299, 0.587, 0.114);\n                    float v = dot(texel.xyz, luma);\n                    float alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);\n\n                    // CRITICAL: Preserve original alpha, only filter by luminosity\n                    gl_FragColor = vec4(texel.rgb * alpha, texel.a);\n                }"}),this.separableBlurMaterials=[];const o=[3,5,7,9,11];a=Math.round(.75*this.resolution.x),r=Math.round(.75*this.resolution.y);for(let t=0;t<this.nMips;t++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(o[t])),this.separableBlurMaterials[t].uniforms.texSize.value=new je(a,r),a=Math.round(a/2),r=Math.round(r/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=e,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new qe(1,1,1),new qe(1,1,1),new qe(1,1,1),new qe(1,1,1),new qe(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,this.materialCopy=new Cs({uniforms:{tDiffuse:{value:null}},vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                varying vec2 vUv;\n                void main() {\n                    gl_FragColor = texture2D(tDiffuse, vUv);\n                }",blending:2,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new zn,this.oldClearAlpha=1,this.clearColor=new zn(0,0,0),this.basic=new Gn({transparent:!0,depthTest:!1,depthWrite:!1}),this.fsQuad=new yp(null)}dispose(){if(this.renderTargetsHorizontal)for(let t=0;t<this.renderTargetsHorizontal.length;t++)this.renderTargetsHorizontal[t]?.dispose();if(this.renderTargetsVertical)for(let t=0;t<this.renderTargetsVertical.length;t++)this.renderTargetsVertical[t]?.dispose();if(this.renderTargetBright?.dispose(),this.separableBlurMaterials)for(let t=0;t<this.separableBlurMaterials.length;t++)this.separableBlurMaterials[t]?.dispose();this.compositeMaterial?.dispose(),this.blendMaterial?.dispose(),this.basic?.dispose(),this.fsQuad?.dispose()}clearBloomBuffers(t){const e=t.getRenderTarget(),i=t.getClearColor(this._oldClearColor),n=t.getClearAlpha();t.setClearColor(0,0),t.setRenderTarget(this.renderTargetBright),t.clear();for(let e=0;e<this.renderTargetsHorizontal.length;e++)t.setRenderTarget(this.renderTargetsHorizontal[e]),t.clear();for(let e=0;e<this.renderTargetsVertical.length;e++)t.setRenderTarget(this.renderTargetsVertical[e]),t.clear();t.setRenderTarget(e),t.setClearColor(i,n)}setSize(t,e){let i=Math.round(.75*t),n=Math.round(.75*e);this.renderTargetBright.setSize(i,n);for(let t=0;t<this.nMips;t++)this.renderTargetsHorizontal[t].setSize(i,n),this.renderTargetsVertical[t].setSize(i,n),this.separableBlurMaterials[t].uniforms.texSize.value=new je(i,n),i=Math.round(i/2),n=Math.round(n/2)}render(t,e,i,n,s){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const a=t.autoClear;t.autoClear=!1,t.setClearColor(this.clearColor,0),s&&t.state.buffers.stencil.setTest(!1),this.renderToScreen&&!this.skipBaseCopy&&(this.fsQuad.material=this.basic,this.basic.map=i.texture,t.setRenderTarget(null),this.fsQuad.render(t)),this.highPassUniforms.tDiffuse.value=i.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,t.setRenderTarget(this.renderTargetBright),t.clear(),this.fsQuad.render(t);let r=this.renderTargetBright;for(let e=0;e<this.nMips;e++)this.fsQuad.material=this.separableBlurMaterials[e],this.separableBlurMaterials[e].uniforms.colorTexture.value=r.texture,this.separableBlurMaterials[e].uniforms.direction.value=wp.BlurDirectionX,t.setRenderTarget(this.renderTargetsHorizontal[e]),t.clear(),this.fsQuad.render(t),this.separableBlurMaterials[e].uniforms.colorTexture.value=this.renderTargetsHorizontal[e].texture,this.separableBlurMaterials[e].uniforms.direction.value=wp.BlurDirectionY,t.setRenderTarget(this.renderTargetsVertical[e]),t.clear(),this.fsQuad.render(t),r=this.renderTargetsVertical[e];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,t.setRenderTarget(this.renderTargetsHorizontal[0]),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.materialCopy,this.materialCopy.uniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,s&&t.state.buffers.stencil.setTest(!0),this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(i),this.fsQuad.render(t)),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=a}getSeperableBlurMaterial(t){return new Cs({defines:{MAX_RADIUS:t},uniforms:{colorTexture:{value:null},texSize:{value:new je(.5,.5)},direction:{value:new je(.5,.5)},kernelRadius:{value:1}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",fragmentShader:"\n                #include <common>\n                varying vec2 vUv;\n                uniform sampler2D colorTexture;\n                uniform vec2 texSize;\n                uniform vec2 direction;\n                uniform float kernelRadius;\n\n                float gaussianPdf(in float x, in float sigma) {\n                    return 0.39894 * exp( -0.5 * x * x / ( sigma * sigma ) ) / sigma;\n                }\n\n                void main() {\n                    vec2 invSize = 1.0 / texSize;\n                    float sigma = kernelRadius / 2.0;\n                    float weightSum = gaussianPdf(0.0, sigma);\n\n                    // CRITICAL: Accumulate RGB and alpha SEPARATELY\n                    // Include center pixel for BOTH RGB and alpha\n                    vec4 centerPixel = texture2D(colorTexture, vUv);\n                    vec3 diffuseSum = centerPixel.rgb * weightSum;\n                    float alphaSum = centerPixel.a * weightSum;\n\n                    vec2 delta = direction * invSize * kernelRadius / float(MAX_RADIUS);\n\n                    for( int i = 1; i < MAX_RADIUS; i ++ ) {\n                        float x = kernelRadius * float(i) / float(MAX_RADIUS);\n                        float w = gaussianPdf(x, sigma);\n\n                        vec2 uvOffset = delta * float(i);\n                        vec4 sample1 = texture2D(colorTexture, vUv + uvOffset);\n                        vec4 sample2 = texture2D(colorTexture, vUv - uvOffset);\n\n                        // Accumulate RGB and alpha separately\n                        diffuseSum += (sample1.rgb + sample2.rgb) * w;\n                        alphaSum += (sample1.a + sample2.a) * w;\n                        weightSum += 2.0 * w;\n                    }\n\n                    // Output with separately normalized alpha\n                    gl_FragColor = vec4(diffuseSum / weightSum, alphaSum / weightSum);\n                }"})}getCompositeMaterial(t){return new Cs({uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",fragmentShader:"\n                varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[5];\n                uniform vec3 bloomTintColors[5];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    // ALPHA PRESERVATION: Sample all textures and preserve their alpha\n                    vec4 sample1 = texture2D(blurTexture1, vUv);\n                    vec4 sample2 = texture2D(blurTexture2, vUv);\n                    vec4 sample3 = texture2D(blurTexture3, vUv);\n                    vec4 sample4 = texture2D(blurTexture4, vUv);\n                    vec4 sample5 = texture2D(blurTexture5, vUv);\n\n                    // Apply tint to RGB only, preserve alpha from samples\n                    vec4 color = bloomStrength * (\n                        lerpBloomFactor(bloomFactors[0]) * vec4(sample1.rgb * bloomTintColors[0], sample1.a) +\n                        lerpBloomFactor(bloomFactors[1]) * vec4(sample2.rgb * bloomTintColors[1], sample2.a) +\n                        lerpBloomFactor(bloomFactors[2]) * vec4(sample3.rgb * bloomTintColors[2], sample3.a) +\n                        lerpBloomFactor(bloomFactors[3]) * vec4(sample4.rgb * bloomTintColors[3], sample4.a) +\n                        lerpBloomFactor(bloomFactors[4]) * vec4(sample5.rgb * bloomTintColors[4], sample5.a)\n                    );\n\n                    gl_FragColor = color;\n                }"})}}wp.BlurDirectionX=new je(1,0),wp.BlurDirectionY=new je(0,1);const Sp={type:"change"},Tp={type:"start"},Cp={type:"end"},Ep=new Hi,Ap=new za,Pp=Math.cos(70*We.DEG2RAD),Dp=new qe,Rp=2*Math.PI,Ip=-1,Bp=1e-6;class Lp extends Rc{constructor(t,n=null){super(t,n),this.state=Ip,this.target=new qe,this.cursor=new qe,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.keyRotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:e.ROTATE,MIDDLE:e.DOLLY,RIGHT:e.PAN},this.touches={ONE:i.ROTATE,TWO:i.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new qe,this._lastQuaternion=new Xe,this._lastTargetPosition=new qe,this._quat=(new Xe).setFromUnitVectors(t.up,new qe(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new nc,this._sphericalDelta=new nc,this._scale=1,this._panOffset=new qe,this._rotateStart=new je,this._rotateEnd=new je,this._rotateDelta=new je,this._panStart=new je,this._panEnd=new je,this._panDelta=new je,this._dollyStart=new je,this._dollyEnd=new je,this._dollyDelta=new je,this._dollyDirection=new qe,this._mouse=new je,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=Op.bind(this),this._onPointerDown=kp.bind(this),this._onPointerUp=zp.bind(this),this._onContextMenu=Wp.bind(this),this._onMouseWheel=Np.bind(this),this._onKeyDown=Gp.bind(this),this._onTouchStart=Vp.bind(this),this._onTouchMove=Hp.bind(this),this._onMouseDown=Fp.bind(this),this._onMouseMove=Up.bind(this),this._interceptControlDown=jp.bind(this),this._interceptControlUp=Xp.bind(this),null!==this.domElement&&this.connect(this.domElement),this.update()}connect(t){super.connect(t),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(t){t.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=t}stopListenToKeyEvents(){null!==this._domElementKeyEvents&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(Sp),this.update(),this.state=Ip}update(t=null){const e=this.object.position;Dp.copy(e).sub(this.target),Dp.applyQuaternion(this._quat),this._spherical.setFromVector3(Dp),this.autoRotate&&this.state===Ip&&this._rotateLeft(this._getAutoRotationAngle(t)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let i=this.minAzimuthAngle,n=this.maxAzimuthAngle;isFinite(i)&&isFinite(n)&&(i<-Math.PI?i+=Rp:i>Math.PI&&(i-=Rp),n<-Math.PI?n+=Rp:n>Math.PI&&(n-=Rp),this._spherical.theta=i<=n?Math.max(i,Math.min(n,this._spherical.theta)):this._spherical.theta>(i+n)/2?Math.max(i,this._spherical.theta):Math.min(n,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),!0===this.enableDamping?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let s=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const t=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),s=t!=this._spherical.radius}if(Dp.setFromSpherical(this._spherical),Dp.applyQuaternion(this._quatInverse),e.copy(this.target).add(Dp),this.object.lookAt(this.target),!0===this.enableDamping?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let t=null;if(this.object.isPerspectiveCamera){const e=Dp.length();t=this._clampDistance(e*this._scale);const i=e-t;this.object.position.addScaledVector(this._dollyDirection,i),this.object.updateMatrixWorld(),s=!!i}else if(this.object.isOrthographicCamera){const e=new qe(this._mouse.x,this._mouse.y,0);e.unproject(this.object);const i=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),s=i!==this.object.zoom;const n=new qe(this._mouse.x,this._mouse.y,0);n.unproject(this.object),this.object.position.sub(n).add(e),this.object.updateMatrixWorld(),t=Dp.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;null!==t&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(t).add(this.object.position):(Ep.origin.copy(this.object.position),Ep.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(Ep.direction))<Pp?this.object.lookAt(this.target):(Ap.setFromNormalAndCoplanarPoint(this.object.up,this.target),Ep.intersectPlane(Ap,this.target))))}else if(this.object.isOrthographicCamera){const t=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),t!==this.object.zoom&&(this.object.updateProjectionMatrix(),s=!0)}return this._scale=1,this._performCursorZoom=!1,!!(s||this._lastPosition.distanceToSquared(this.object.position)>Bp||8*(1-this._lastQuaternion.dot(this.object.quaternion))>Bp||this._lastTargetPosition.distanceToSquared(this.target)>Bp)&&(this.dispatchEvent(Sp),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0)}_getAutoRotationAngle(t){return null!==t?Rp/60*this.autoRotateSpeed*t:Rp/60/60*this.autoRotateSpeed}_getZoomScale(t){const e=Math.abs(.01*t);return Math.pow(.95,this.zoomSpeed*e)}_rotateLeft(t){this._sphericalDelta.theta-=t}_rotateUp(t){this._sphericalDelta.phi-=t}_panLeft(t,e){Dp.setFromMatrixColumn(e,0),Dp.multiplyScalar(-t),this._panOffset.add(Dp)}_panUp(t,e){!0===this.screenSpacePanning?Dp.setFromMatrixColumn(e,1):(Dp.setFromMatrixColumn(e,0),Dp.crossVectors(this.object.up,Dp)),Dp.multiplyScalar(t),this._panOffset.add(Dp)}_pan(t,e){const i=this.domElement;if(this.object.isPerspectiveCamera){const n=this.object.position;Dp.copy(n).sub(this.target);let s=Dp.length();s*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*t*s/i.clientHeight,this.object.matrix),this._panUp(2*e*s/i.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(t*(this.object.right-this.object.left)/this.object.zoom/i.clientWidth,this.object.matrix),this._panUp(e*(this.object.top-this.object.bottom)/this.object.zoom/i.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(t){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(t){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(t,e){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const i=this.domElement.getBoundingClientRect(),n=t-i.left,s=e-i.top,a=i.width,r=i.height;this._mouse.x=n/a*2-1,this._mouse.y=-s/r*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(t){return Math.max(this.minDistance,Math.min(this.maxDistance,t))}_handleMouseDownRotate(t){this._rotateStart.set(t.clientX,t.clientY)}_handleMouseDownDolly(t){this._updateZoomParameters(t.clientX,t.clientX),this._dollyStart.set(t.clientX,t.clientY)}_handleMouseDownPan(t){this._panStart.set(t.clientX,t.clientY)}_handleMouseMoveRotate(t){this._rotateEnd.set(t.clientX,t.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const e=this.domElement;this._rotateLeft(Rp*this._rotateDelta.x/e.clientHeight),this._rotateUp(Rp*this._rotateDelta.y/e.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(t){this._dollyEnd.set(t.clientX,t.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(t){this._panEnd.set(t.clientX,t.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(t){this._updateZoomParameters(t.clientX,t.clientY),t.deltaY<0?this._dollyIn(this._getZoomScale(t.deltaY)):t.deltaY>0&&this._dollyOut(this._getZoomScale(t.deltaY)),this.update()}_handleKeyDown(t){let e=!1;switch(t.code){case this.keys.UP:t.ctrlKey||t.metaKey||t.shiftKey?this.enableRotate&&this._rotateUp(Rp*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,this.keyPanSpeed),e=!0;break;case this.keys.BOTTOM:t.ctrlKey||t.metaKey||t.shiftKey?this.enableRotate&&this._rotateUp(-Rp*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,-this.keyPanSpeed),e=!0;break;case this.keys.LEFT:t.ctrlKey||t.metaKey||t.shiftKey?this.enableRotate&&this._rotateLeft(Rp*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(this.keyPanSpeed,0),e=!0;break;case this.keys.RIGHT:t.ctrlKey||t.metaKey||t.shiftKey?this.enableRotate&&this._rotateLeft(-Rp*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(-this.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),this.update())}_handleTouchStartRotate(t){if(1===this._pointers.length)this._rotateStart.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),i=.5*(t.pageX+e.x),n=.5*(t.pageY+e.y);this._rotateStart.set(i,n)}}_handleTouchStartPan(t){if(1===this._pointers.length)this._panStart.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),i=.5*(t.pageX+e.x),n=.5*(t.pageY+e.y);this._panStart.set(i,n)}}_handleTouchStartDolly(t){const e=this._getSecondPointerPosition(t),i=t.pageX-e.x,n=t.pageY-e.y,s=Math.sqrt(i*i+n*n);this._dollyStart.set(0,s)}_handleTouchStartDollyPan(t){this.enableZoom&&this._handleTouchStartDolly(t),this.enablePan&&this._handleTouchStartPan(t)}_handleTouchStartDollyRotate(t){this.enableZoom&&this._handleTouchStartDolly(t),this.enableRotate&&this._handleTouchStartRotate(t)}_handleTouchMoveRotate(t){if(1==this._pointers.length)this._rotateEnd.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),i=.5*(t.pageX+e.x),n=.5*(t.pageY+e.y);this._rotateEnd.set(i,n)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const e=this.domElement;this._rotateLeft(Rp*this._rotateDelta.x/e.clientHeight),this._rotateUp(Rp*this._rotateDelta.y/e.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(t){if(1===this._pointers.length)this._panEnd.set(t.pageX,t.pageY);else{const e=this._getSecondPointerPosition(t),i=.5*(t.pageX+e.x),n=.5*(t.pageY+e.y);this._panEnd.set(i,n)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(t){const e=this._getSecondPointerPosition(t),i=t.pageX-e.x,n=t.pageY-e.y,s=Math.sqrt(i*i+n*n);this._dollyEnd.set(0,s),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const a=.5*(t.pageX+e.x),r=.5*(t.pageY+e.y);this._updateZoomParameters(a,r)}_handleTouchMoveDollyPan(t){this.enableZoom&&this._handleTouchMoveDolly(t),this.enablePan&&this._handleTouchMovePan(t)}_handleTouchMoveDollyRotate(t){this.enableZoom&&this._handleTouchMoveDolly(t),this.enableRotate&&this._handleTouchMoveRotate(t)}_addPointer(t){this._pointers.push(t.pointerId)}_removePointer(t){delete this._pointerPositions[t.pointerId];for(let e=0;e<this._pointers.length;e++)if(this._pointers[e]==t.pointerId)return void this._pointers.splice(e,1)}_isTrackingPointer(t){for(let e=0;e<this._pointers.length;e++)if(this._pointers[e]==t.pointerId)return!0;return!1}_trackPointer(t){let e=this._pointerPositions[t.pointerId];void 0===e&&(e=new je,this._pointerPositions[t.pointerId]=e),e.set(t.pageX,t.pageY)}_getSecondPointerPosition(t){const e=t.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[e]}_customWheelEvent(t){const e=t.deltaMode,i={clientX:t.clientX,clientY:t.clientY,deltaY:t.deltaY};switch(e){case 1:i.deltaY*=16;break;case 2:i.deltaY*=100}return t.ctrlKey&&!this._controlActive&&(i.deltaY*=10),i}}function kp(t){!1!==this.enabled&&(0===this._pointers.length&&(this.domElement.setPointerCapture(t.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._isTrackingPointer(t)||(this._addPointer(t),"touch"===t.pointerType?this._onTouchStart(t):this._onMouseDown(t)))}function Op(t){!1!==this.enabled&&("touch"===t.pointerType?this._onTouchMove(t):this._onMouseMove(t))}function zp(t){switch(this._removePointer(t),this._pointers.length){case 0:this.domElement.releasePointerCapture(t.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(Cp),this.state=Ip;break;case 1:const e=this._pointers[0],i=this._pointerPositions[e];this._onTouchStart({pointerId:e,pageX:i.x,pageY:i.y})}}function Fp(t){let i;switch(t.button){case 0:i=this.mouseButtons.LEFT;break;case 1:i=this.mouseButtons.MIDDLE;break;case 2:i=this.mouseButtons.RIGHT;break;default:i=-1}switch(i){case e.DOLLY:if(!1===this.enableZoom)return;this._handleMouseDownDolly(t),this.state=1;break;case e.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===this.enablePan)return;this._handleMouseDownPan(t),this.state=2}else{if(!1===this.enableRotate)return;this._handleMouseDownRotate(t),this.state=0}break;case e.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===this.enableRotate)return;this._handleMouseDownRotate(t),this.state=0}else{if(!1===this.enablePan)return;this._handleMouseDownPan(t),this.state=2}break;default:this.state=Ip}this.state!==Ip&&this.dispatchEvent(Tp)}function Up(t){switch(this.state){case 0:if(!1===this.enableRotate)return;this._handleMouseMoveRotate(t);break;case 1:if(!1===this.enableZoom)return;this._handleMouseMoveDolly(t);break;case 2:if(!1===this.enablePan)return;this._handleMouseMovePan(t)}}function Np(t){!1!==this.enabled&&!1!==this.enableZoom&&this.state===Ip&&(t.preventDefault(),this.dispatchEvent(Tp),this._handleMouseWheel(this._customWheelEvent(t)),this.dispatchEvent(Cp))}function Gp(t){!1!==this.enabled&&this._handleKeyDown(t)}function Vp(t){switch(this._trackPointer(t),this._pointers.length){case 1:switch(this.touches.ONE){case i.ROTATE:if(!1===this.enableRotate)return;this._handleTouchStartRotate(t),this.state=3;break;case i.PAN:if(!1===this.enablePan)return;this._handleTouchStartPan(t),this.state=4;break;default:this.state=Ip}break;case 2:switch(this.touches.TWO){case i.DOLLY_PAN:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchStartDollyPan(t),this.state=5;break;case i.DOLLY_ROTATE:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchStartDollyRotate(t),this.state=6;break;default:this.state=Ip}break;default:this.state=Ip}this.state!==Ip&&this.dispatchEvent(Tp)}function Hp(t){switch(this._trackPointer(t),this.state){case 3:if(!1===this.enableRotate)return;this._handleTouchMoveRotate(t),this.update();break;case 4:if(!1===this.enablePan)return;this._handleTouchMovePan(t),this.update();break;case 5:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchMoveDollyPan(t),this.update();break;case 6:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchMoveDollyRotate(t),this.update();break;default:this.state=Ip}}function Wp(t){!1!==this.enabled&&t.preventDefault()}function jp(t){"Control"===t.key&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function Xp(t){"Control"===t.key&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}class qp{constructor(t){this.renderer=t,this.glowAmount=0,this.targetGlowAmount=0,this.glowColor=new zn(1,1,1),this.targetGlowColor=new zn(1,1,1),this.worldPosition=new qe(0,0,0),this.time=0,this.ringPhase=0,this.scene=new Gs,this.camera=new hh(-1,1,1,-1,.1,10),this.camera.position.z=1,this.createGlowMesh(),this._tempVector=new qe,this._tempColor=new zn}createGlowMesh(){const t=new Jo(2,2),e=new Cs({uniforms:{glowAmount:{value:0},glowColor:{value:new zn(1,1,1)},centerUV:{value:new je(.5,.5)},time:{value:0},ringPhase:{value:0},aspectRatio:{value:1}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);\n                }\n            ",fragmentShader:"\n                uniform float glowAmount;\n                uniform vec3 glowColor;\n                uniform vec2 centerUV;\n                uniform float time;\n                uniform float ringPhase;\n                uniform float aspectRatio;\n\n                varying vec2 vUv;\n\n                void main() {\n                    // Aspect-correct UV coordinates - apply aspect to Y instead\n                    // This prevents horizontal clipping on wide screens\n                    vec2 centeredUV = vUv - centerUV;\n                    // Don't multiply by aspect - let glow be circular in screen space\n\n                    float dist = length(centeredUV);\n\n                    // Ring parameters that evolve with ringPhase\n                    // MUCH LARGER radii to prevent clipping - glow can extend to screen edges\n                    // At ringPhase=0: tight ring close to center\n                    // At ringPhase=1: expanded ring that can fill most of screen\n                    float innerRadius = mix(0.02, 0.08, ringPhase);\n                    float outerRadius = mix(0.15, 1.2, ringPhase);  // Can extend beyond screen!\n                    float peakRadius = mix(0.06, 0.25, ringPhase);\n\n                    // Create soft ring falloff\n                    // Inner falloff: 0 at center, 1 at peak\n                    float innerFalloff = smoothstep(innerRadius * 0.3, peakRadius, dist);\n\n                    // Outer falloff: 1 at peak, 0 at outer edge (very gradual fade)\n                    float outerFalloff = 1.0 - smoothstep(peakRadius, outerRadius, dist);\n\n                    // Combine for ring shape\n                    float ringIntensity = innerFalloff * outerFalloff;\n\n                    // Add subtle shimmer/undulation\n                    float shimmer = 0.9 + 0.1 * sin(time * 3.0 + dist * 20.0);\n\n                    // Final intensity with glow amount control\n                    float intensity = ringIntensity * glowAmount * shimmer;\n\n                    // Soft glow color with intensity\n                    // Use HDR values (>1.0) for bloom pickup\n                    vec3 color = glowColor * intensity * 2.0;\n\n                    // Alpha for blending\n                    float alpha = intensity * 0.6;\n\n                    gl_FragColor = vec4(color, alpha);\n                }\n            ",transparent:!0,blending:2,depthTest:!1,depthWrite:!1});this.glowMesh=new bs(t,e),this.scene.add(this.glowMesh)}setGlow(t,e,i){this.targetGlowAmount=Math.max(0,t),e&&(Array.isArray(e)?this.targetGlowColor.setRGB(e[0],e[1],e[2]):this.targetGlowColor.copy(e)),i&&this.worldPosition.copy(i)}update(t,e){const i=t/1e3;this.time+=i,this.glowAmount+=(this.targetGlowAmount-this.glowAmount)*Math.min(1,8*i),this.glowColor.lerp(this.targetGlowColor,Math.min(1,8*i));const n=Math.min(1,this.glowAmount);if(this.ringPhase+=(n-this.ringPhase)*Math.min(1,4*i),e){this._tempVector.copy(this.worldPosition),this._tempVector.project(e);const t=(this._tempVector.x+1)/2,i=(this._tempVector.y+1)/2;this.glowMesh.material.uniforms.centerUV.value.set(t,i)}this.glowMesh.material.uniforms.glowAmount.value=this.glowAmount,this.glowMesh.material.uniforms.glowColor.value.copy(this.glowColor),this.glowMesh.material.uniforms.time.value=this.time,this.glowMesh.material.uniforms.ringPhase.value=this.ringPhase;const s=this.renderer.domElement;this.glowMesh.material.uniforms.aspectRatio.value=s.width/s.height}render(t){if(this.glowAmount<.001)return;const{autoClear:e}=t;t.autoClear=!1,t.render(this.scene,this.camera),t.autoClear=e}isActive(){return this.glowAmount>.001||this.targetGlowAmount>0}dispose(){this.glowMesh&&(this.glowMesh.geometry.dispose(),this.glowMesh.material.dispose(),this.scene.remove(this.glowMesh),this.glowMesh=null),this.scene=null,this.camera=null,this._tempVector=null,this._tempColor=null}}const Yp=t=>({front:{x:0,y:0,z:t},side:{x:t,y:0,z:0},top:{x:0,y:t,z:0},angle:{x:.67*t,y:.5*t,z:.67*t},back:{x:0,y:0,z:-t},bottom:{x:0,y:-t,z:0}});class $p{constructor(t,e,i=3){this.camera=t,this.controls=e,this.cameraDistance=i,this.animationId=null}getAvailablePresets(){return Object.keys(Yp(this.cameraDistance))}setPreset(t,e=1e3,i=!1){if(!this.controls)return;const n=Yp(this.cameraDistance)[t];if(!n)return void console.warn(`Unknown camera preset: ${t}`);this.cancelAnimation();const s=i?this.controls.target.clone():null;0!==e?this._animateTo(n,e,s,i):this._setInstant(n,s)}_setInstant(t,e){this.controls.reset(),this.camera.position.set(t.x,t.y,t.z),e?(this.controls.target.copy(e),this.camera.lookAt(e)):(this.controls.target.set(0,0,0),this.camera.lookAt(0,0,0)),this.controls.update()}_animateTo(t,e,i,n){n||this.controls.target.set(0,0,0);const s=this.camera.position.clone(),a=new qe(t.x,t.y,t.z),r=performance.now(),o=t=>{const i=t-r,n=Math.min(i/e,1),l=1-Math.pow(1-n,3);this.camera.position.lerpVectors(s,a,l),this.camera.lookAt(0,0,0),this.controls.update(),this.animationId=n<1?requestAnimationFrame(o):null};this.animationId=requestAnimationFrame(o)}isAnimating(){return null!==this.animationId}cancelAnimation(){null!==this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null)}reset(t=1e3){this.setPreset("front",t)}setCameraDistance(t){this.cameraDistance=t}dispose(){this.cancelAnimation(),this.camera=null,this.controls=null}}class Zp{constructor(t,e={}){this.canvas=t,this.options=e,this._destroyed=!1,this.assetBasePath=e.assetBasePath||"",this.scene=new Gs,this.scene.background=null,this.renderer=new up({canvas:t,alpha:!0,premultipliedAlpha:!1,antialias:!0,powerPreference:"high-performance",preserveDrawingBuffer:!1,precision:"highp",logarithmicDepthBuffer:!1,stencil:!1}),this.renderer.outputColorSpace=se,this.renderer.toneMapping=0,this.renderer.toneMappingExposure=1,this.renderer.setClearColor(0,0),this.renderer.clear(),this.renderer.autoClear=!1,this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5)),this.renderer.setSize(t.width,t.height,!1),e.enableShadows&&(this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=2),this._contextLost=!1,this._boundHandleContextLost=this.handleContextLost.bind(this),this._boundHandleContextRestored=this.handleContextRestored.bind(this),this.renderer.domElement.addEventListener("webglcontextlost",this._boundHandleContextLost,!1),this.renderer.domElement.addEventListener("webglcontextrestored",this._boundHandleContextRestored,!1),this._boundHandleVisibilityChange=this._handleVisibilityChange.bind(this),document.addEventListener("visibilitychange",this._boundHandleVisibilityChange);const i=void 0!==e.fov?e.fov:45;this.camera=new Rs(i,t.width/t.height,.1,100),this.cameraDistance=void 0!==e.cameraDistance?e.cameraDistance:3,this.camera.position.set(0,0,this.cameraDistance),this.camera.lookAt(0,0,0),!1!==e.enableControls&&this.setupCameraControls(),this.setupLights(),!1!==e.enablePostProcessing&&this.setupPostProcessing(),this.coreMesh=null,this.materialMode="glow",this.glowMaterial=null,this.glassMaterial=null,this.mixer=null,this.clock=new Dh,this._tempColor=new zn,this._tempColor2=new zn,this._white=new zn(1,1,1),this._tempQuat=new Xe,this._tempEuler=new tn,this._quatX=new Xe,this._quatY=new Xe,this._quatZ=new Xe,this._rollQuat=new Xe,this._meshQuat=new Xe,this._xAxis=new qe(1,0,0),this._yAxis=new qe(0,1,0),this._zAxis=new qe(0,0,1),this._cameraToMesh=new qe,this._cameraDir=new qe,this._soulPosTemp=new qe,this._cachedSoulMesh=null,this._drawingBufferSize=new je}setupCameraControls(){this.controls=new Lp(this.camera,this.renderer.domElement),this.controls.enableDamping=!0,this.controls.dampingFactor=.1;const t=void 0!==this.options.minZoom?this.options.minZoom:.5*this.cameraDistance,e=void 0!==this.options.maxZoom?this.options.maxZoom:2*this.cameraDistance;this.controls.minDistance=t,this.controls.maxDistance=e,this.controls.enablePan=!1,this.controls.autoRotate=!0===this.options.autoRotate,this.controls.autoRotateSpeed=void 0!==this.options.autoRotateSpeed?this.options.autoRotateSpeed:.5,this.controls.minPolarAngle=.2*Math.PI,this.controls.maxPolarAngle=.8*Math.PI,this.controls.rotateSpeed=.8,this.controls.zoomSpeed=1.5,("ontouchstart"in window||navigator.maxTouchPoints>0)&&(this.controls.rotateSpeed=1,this.controls.zoomSpeed=1.2),this.renderer.domElement.style.touchAction="none";const i=()=>{this.controls&&this.controls.update()};this.renderer.domElement.addEventListener("pointermove",i,{passive:!0}),this.renderer.domElement.addEventListener("pointerdown",i,{passive:!0}),this.cameraPresetManager=new $p(this.camera,this.controls,this.cameraDistance)}setupLights(){this.ambientLight=new dh(16777215,.3),this.ambientLight.name="ambientLight",this.scene.add(this.ambientLight),this.keyLight=new uh(16777215,.8),this.keyLight.position.set(2,2,2),this.keyLight.name="keyLight",this.options.enableShadows&&(this.keyLight.castShadow=!0,this.keyLight.shadow.mapSize.width=1024,this.keyLight.shadow.mapSize.height=1024,this.keyLight.shadow.camera.near=.5,this.keyLight.shadow.camera.far=10),this.scene.add(this.keyLight),this.fillLight=new uh(16777215,.5),this.fillLight.position.set(-2,1,1),this.fillLight.name="fillLight",this.scene.add(this.fillLight),this.rimLight=new uh(16777215,.7),this.rimLight.position.set(0,1,-2),this.rimLight.name="rimLight",this.scene.add(this.rimLight),this.accentLight1=new lh(54527,.3,10),this.accentLight1.position.set(-3,0,1),this.accentLight1.name="accentLight1",this.scene.add(this.accentLight1),this.accentLight2=new lh(16716947,.2,10),this.accentLight2.position.set(3,0,1),this.accentLight2.name="accentLight2",this.scene.add(this.accentLight2),this.accentLight3=new lh(16739125,.2,10),this.accentLight3.position.set(0,3,-1),this.accentLight3.name="accentLight3",this.scene.add(this.accentLight3),this.createEnvironmentMap()}async createEnvironmentMap(){if(this._destroyed)return;this._envMapLoading=!0;try{const{HDRLoader:t}=await Promise.resolve().then(function(){return Y_});if(this._destroyed)return;const e=new eu(this.renderer);e.compileEquirectangularShader();try{const i=new t,n="studio_1k.hdr";let s;if(this.assetBasePath){let t=this.assetBasePath.replace(/\/$/,"");t.endsWith("/assets")&&(t=t.slice(0,-7)),s=t?`${t}/hdri/${n}`:`/hdri/${n}`}else{const t=window.location.pathname.split("/");let e="";t.length>2&&t[1]&&(e=`/${t[1]}`),s=e?`${e}/hdri/${n}`:`/hdri/${n}`}let a=null;try{a=await i.loadAsync(s)}catch{}if(!a||!a.image)throw new Error(`HDR texture not found at ${s}`);return this._destroyed?(a.dispose(),void e.dispose()):(a.mapping=z,this.envMap=e.fromEquirectangular(a).texture,a.dispose(),e.dispose(),void(this._envMapLoading=!1))}catch{e.dispose()}}catch{}if(this._destroyed)return;const t=new ks(512),e=new Gs,i=new zn(5609983),n=new zn(16739229),s=new zn(1710638),a=new Jl(i,s,1.5);e.add(a);const r=new lh(54527,2,20);r.position.set(-5,2,-5),e.add(r);const o=new lh(16716947,2,20);o.position.set(5,2,-5),e.add(o);const l=new lh(16755200,1.5,20);l.position.set(0,5,0),e.add(l),e.background=n;const h=new Bs(.1,100,t);h.update(this.renderer,e),this.envMap=t.texture,this._envCubeRenderTarget=t,this._envScene=e,this._envCubeCamera=h,this._envMapLoading=!1}setupPostProcessing(){const t=new je;this.renderer.getDrawingBufferSize(t);const e=new mi(t.x,t.y,{format:ct,type:it,minFilter:X,magFilter:X,stencilBuffer:!1,depthBuffer:!0});this.composer=new _p(this.renderer,e),this.renderer.setRenderTarget(e),this.renderer.clear(),this.renderer.setRenderTarget(this.composer.readBuffer),this.renderer.clear(),this.renderer.setRenderTarget(this.composer.writeBuffer),this.renderer.clear(),this.renderer.setRenderTarget(null);const i=new xp(this.scene,this.camera);i.clearColor=new zn(0),i.clearAlpha=0,this.composer.addPass(i);const n="ontouchstart"in window||navigator.maxTouchPoints>0?.5:1,s=new je(Math.floor(t.x*n),Math.floor(t.y*n));this.bloomPass=new wp(s,1.2,.8,.3),this.bloomPass.name="bloomPass",this.bloomPass.enabled=!0,this.bloomPass.renderToScreen=!0,this.composer.addPass(this.bloomPass),this.bloomPass.clearBloomBuffers(this.renderer),this.particleRenderTarget=new mi(t.x,t.y,{format:ct,type:it,minFilter:X,magFilter:X,stencilBuffer:!1,depthBuffer:!0}),this.renderer.setRenderTarget(this.particleRenderTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this.particleBloomPass=new wp(s,.5,.4,.3),this.particleBloomPass.name="particleBloomPass",this.particleBloomPass.enabled=!0,this.particleBloomPass.clearColor=new zn(1,1,1),this.particleBloomPass.skipBaseCopy=!0,this.particleBloomPass.clearBloomBuffers(this.renderer),this.soulRenderTarget=new mi(t.x,t.y,{format:ct,type:it,minFilter:X,magFilter:X,stencilBuffer:!1,depthBuffer:!0}),this.renderer.setRenderTarget(this.soulRenderTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this.particleCompositeShader={uniforms:{tDiffuse:{value:null},tParticles:{value:null}},vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            ",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                uniform sampler2D tParticles;\n                varying vec2 vUv;\n\n                void main() {\n                    vec4 base = texture2D(tDiffuse, vUv);\n                    vec4 particles = texture2D(tParticles, vUv);\n\n                    // Alpha-preserving composite: particles over base\n                    // Use particle alpha to blend\n                    vec3 blended = mix(base.rgb, particles.rgb, particles.a);\n                    float alpha = base.a + particles.a * (1.0 - base.a);\n\n                    gl_FragColor = vec4(blended, alpha);\n                }\n            "},this.glowLayer=new qp(this.renderer)}handleContextLost(t){t.preventDefault(),this._contextLost=!0,console.warn(" WebGL context lost - rendering paused"),this.cameraAnimationId&&(cancelAnimationFrame(this.cameraAnimationId),this.cameraAnimationId=null)}handleContextRestored(){this._contextLost=!1,this.recreateResources(),this.onContextRestored&&this.onContextRestored()}recreateResources(){this.createEnvironmentMap(),"glow"===this.materialMode?(this.glowMaterial=this.createGlowMaterial(),this.coreMesh&&(this.coreMesh.material=this.glowMaterial)):"glass"===this.materialMode&&(this.glassMaterial=this.createGlassMaterial(),this.coreMesh&&(this.coreMesh.material=this.glassMaterial),this.coreMesh&&this.createInnerCore())}_handleVisibilityChange(){if(!this._destroyed&&!document.hidden){const t=this.renderer?.getContext();if(t&&t.isContextLost())console.warn(" WebGL context lost detected on visibility change"),this._contextLost=!0;else if(this.coreMesh?.material){const{material:t}=this.coreMesh;t.map&&!t.map.image&&(console.warn(" Texture invalidated on visibility change - triggering reload"),this.onContextRestored&&this.onContextRestored())}}}createCoreMesh(t,e=null){if(this.coreMesh&&(this.scene.remove(this.coreMesh),this.coreMesh.isGroup?this.coreMesh.traverse(t=>{t.geometry&&t.geometry.dispose(),t.material&&this.disposeMaterial(t.material)}):(this.coreMesh.geometry&&this.coreMesh.geometry.dispose(),this.coreMesh.material&&this.disposeMaterial(this.coreMesh.material)),this.coreMesh=null),t.isGroup)return this.coreMesh=t,this.coreMesh.name="coreMascot",this.options.enableShadows&&this.coreMesh.traverse(t=>{t.isMesh&&(t.castShadow=!0,t.receiveShadow=!0)}),this.scene.add(this.coreMesh),this.coreMesh;let i;return e?i=e:(this.glowMaterial||(this.glowMaterial=this.createGlowMaterial()),i="glass"===this.materialMode?this.glassMaterial||this.createGlassMaterial():this.glowMaterial),this.coreMesh=new bs(t,i),this.coreMesh.name="coreMascot",this.options.enableShadows&&(this.coreMesh.castShadow=!0,this.coreMesh.receiveShadow=!0),this.scene.add(this.coreMesh),"glass"===this.materialMode&&this.createInnerCore(),this.coreMesh}swapGeometry(t,e=null){if(!this.coreMesh)return;this.bloomPass&&this.bloomPass.clearBloomBuffers(this.renderer),this.particleBloomPass&&this.particleBloomPass.clearBloomBuffers(this.renderer);const i=this.coreMesh.geometry;if(i&&i.dispose(),this.coreMesh.geometry=t,e){if(this.coreMesh.material&&this.coreMesh.material!==this.glowMaterial&&this.coreMesh.material!==this.glassMaterial&&this.disposeMaterial(this.coreMesh.material),this.coreMesh.material=e,e.uniforms?.resolution){const t=this.renderer.getDrawingBufferSize(new je);e.uniforms.resolution.value.set(t.x,t.y)}}else{const t="glass"===this.materialMode?this.glassMaterial||this.createGlassMaterial():this.glowMaterial;this.coreMesh.material!==t&&(this.coreMesh.material&&this.coreMesh.material!==this.glowMaterial&&this.coreMesh.material!==this.glassMaterial&&this.disposeMaterial(this.coreMesh.material),this.coreMesh.material=t)}"glass"!==this.materialMode||e||this.createInnerCore()}createGlowMaterial(){return new Cs({uniforms:{glowColor:{value:new zn(1,1,1)},glowIntensity:{value:1},coreColor:{value:new zn(1,1,1)},fresnelPower:{value:3}},vertexShader:"\n                varying vec3 vNormal;\n                varying vec3 vViewPosition;\n\n                void main() {\n                    // Transform normal to view space\n                    vNormal = normalize(normalMatrix * normal);\n\n                    // Calculate view space position\n                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                    vViewPosition = -mvPosition.xyz;\n\n                    // Output clip space position\n                    gl_Position = projectionMatrix * mvPosition;\n                }\n            ",fragmentShader:"\n                uniform vec3 glowColor;\n                uniform vec3 coreColor;\n                uniform float glowIntensity;\n                uniform float fresnelPower;\n\n                varying vec3 vNormal;\n                varying vec3 vViewPosition;\n\n                void main() {\n                    // Fresnel effect: edges glow more than center\n                    vec3 viewDir = normalize(vViewPosition);\n                    float fresnel = pow(1.0 - abs(dot(vNormal, viewDir)), fresnelPower);\n\n                    // Combine white core with colored glow\n                    // Both core and glow respect glowIntensity for proper on/off toggle\n                    vec3 finalColor = (coreColor * glowIntensity) + (glowColor * glowIntensity * fresnel);\n\n                    gl_FragColor = vec4(finalColor, 1.0);\n                }\n            ",transparent:!1,side:0})}createGlassMaterial(){this.glassEmissiveMultiplier=.6;const t=new ul({transmission:1,thickness:2.7,roughness:.37,metalness:0,ior:1.5,reflectivity:.5,envMapIntensity:1.2,side:2,transparent:!0,opacity:1,color:16777215,emissive:16777215,emissiveIntensity:.6,clearcoat:.8,clearcoatRoughness:.05,iridescence:.4,iridescenceIOR:1.3,iridescenceThicknessRange:[100,400]});return this.envMap&&(t.envMap=this.envMap),t}createInnerCore(){if(this.innerCore&&(this.coreMesh&&this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null),!this.coreMesh||!this.coreMesh.geometry)return;const t=this.coreMesh.geometry;let e;if("TorusGeometry"===t.type||void 0!==t.parameters?.tube){const i=t.parameters,n=i.radius||1,s=.25*(i.tube||.4),a=i.radialSegments||16,r=i.tubularSegments||100;e=new il(n,s,a,r)}else if("SphereGeometry"===t.type){const i=.2*(t.parameters.radius||1);e=new tl(i,32,32)}else if("BoxGeometry"===t.type){const i=t.parameters,n=.2*(i.width||1),s=.2*(i.height||1),a=.2*(i.depth||1);e=new _s(n,s,a)}else if("IcosahedronGeometry"===t.type||"OctahedronGeometry"===t.type){const i=t.parameters,n=.2*(i.radius||1),s=i.detail||2;e="IcosahedronGeometry"===t.type?new Yo(n,s):new Zo(n,s)}else e=new Yo(.2,2);const i=t.userData?.geometryType,n="IcosahedronGeometry"===t.type||"OctahedronGeometry"===t.type||"crystal"===i||"diamond"===i,s=new cl({emissive:16777215,emissiveIntensity:n?3.5:2,color:16777215,transparent:!1,opacity:1});this.innerCoreMaterial=s,this.innerCore=new bs(e,s),this.innerCore.name="innerCore",this.coreMesh.add(this.innerCore)}setMaterialMode(t){if(!this.coreMesh)return console.warn("Cannot set material mode: core mesh not created yet"),void(this.materialMode=t);if(t===this.materialMode)return;this.materialMode=t,"glass"!==t||this.glassMaterial?"glow"!==t||this.glowMaterial||(this.glowMaterial=this.createGlowMaterial()):this.glassMaterial=this.createGlassMaterial();const e="glass"===t?this.glassMaterial:this.glowMaterial;this.coreMesh.material=e,"glass"===t?this.createInnerCore():this.innerCore&&(this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null)}updateGlassProperties(t){this.glassMaterial&&(void 0!==t.transmission&&(this.glassMaterial.transmission=t.transmission,this.glassMaterial.needsUpdate=!0),void 0!==t.thickness&&(this.glassMaterial.thickness=t.thickness,this.glassMaterial.needsUpdate=!0),void 0!==t.roughness&&(this.glassMaterial.roughness=t.roughness,this.glassMaterial.needsUpdate=!0),void 0!==t.emissiveMultiplier&&(this.glassEmissiveMultiplier=t.emissiveMultiplier))}updateLighting(t,e,i=.15){if(!e||!e.visual)return;const n=e.visual.glowColor||"#FFFFFF";this._tempColor.set(n);const s=e.visual.glowIntensity||1;if(this.keyLight&&(this.keyLight.color.lerp(this._tempColor,i),this.keyLight.intensity+=(.8*s-this.keyLight.intensity)*i),this.fillLight&&(this._tempColor2.copy(this._tempColor).lerp(this._white,.7),this.fillLight.color.lerp(this._tempColor2,.5*i),this.fillLight.intensity+=(.3*s-this.fillLight.intensity)*i),this.ambientLight){const t=.4*s;this.ambientLight.intensity+=(t-this.ambientLight.intensity)*i}}normalizeIntensity(t){return.8+Math.log(t+1)/Math.log(11)*.4}calculateColorLuminance(t,e,i){const n=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);return.2126*n(t)+.7152*n(e)+.0722*n(i)}updateBloom(t,e=.1,i=null){if(this.bloomPass){const n=this.normalizeIntensity(t);let s,a,r;"sun"===i?(a=1.5,r=.4,s=.3):"crystal"===i||"rough"===i||"heart"===i?(a=1.8,r=.7,s=.35):"glass"===this.materialMode?(a=.3,r=.2,s=.85):(a=1+.8*n,r=.4,s=.85),this.bloomPass.strength+=(a-this.bloomPass.strength)*e,this.bloomPass.threshold+=(s-this.bloomPass.threshold)*e,this.bloomPass.radius=r}}setCameraPreset(t,e=1e3,i=!1){if(!this.controls)return;const n=this.cameraDistance,s={front:{x:0,y:0,z:n},side:{x:n,y:0,z:0},top:{x:0,y:n,z:0},angle:{x:.67*n,y:.5*n,z:.67*n},back:{x:0,y:0,z:-n},bottom:{x:0,y:-n,z:0}}[t];if(!s)return void console.warn(`Unknown camera preset: ${t}`);const a=i?this.controls.target.clone():null;if(0===e)return this.controls.reset(),this.camera.position.set(s.x,s.y,s.z),a?(this.controls.target.copy(a),this.camera.lookAt(a)):(this.controls.target.set(0,0,0),this.camera.lookAt(0,0,0)),void this.controls.update();i||this.controls.target.set(0,0,0);const r=this.camera.position.clone(),o=new qe(s.x,s.y,s.z),l=performance.now(),h=t=>{const i=t-l,n=Math.min(i/e,1),s=1-Math.pow(1-n,3);this.camera.position.lerpVectors(r,o,s),this.camera.lookAt(0,0,0),this.controls.update(),this.cameraAnimationId=n<1?requestAnimationFrame(h):null};this.cameraAnimationId=requestAnimationFrame(h)}resetCamera(){this.setCameraPreset("front",1e3)}toggleAutoRotate(t){this.controls&&(this.controls.autoRotate=void 0!==t?t:!this.controls.autoRotate)}isAutoRotateEnabled(){return!!this.controls&&this.controls.autoRotate}render(t={}){if(this._destroyed)return;if(this._contextLost)return;if(!this.scene||!this.camera||!this.renderer)return;if(!this.coreMesh)return;if(this._envMapLoading)return;if(!this._firstFrameRendered)return this._firstFrameRendered=!0,this.renderer.setRenderTarget(null),this.renderer.setClearColor(0,0),void this.renderer.clear();const e=(t,i)=>{if(!t||!t.children)return!0;for(let n=0;n<t.children.length;n++){const s=t.children[n];null!=s?null!==s.visible&&void 0!==s.visible?e(s,`${i}.children[${n}]`):(console.error(`[ThreeRenderer] child.visible is NULL at ${i}.children[${n}] name=${s.name} - REMOVING!`),t.children.splice(n,1),n--):(console.error(`[ThreeRenderer] NULL CHILD at ${i}.children[${n}] - REMOVING!`),t.children.splice(n,1),n--)}return!0};e(this.scene,"scene");const{position:i=[0,0,0],rotation:n=[0,0,0],scale:s=1,nonUniformScale:a=null,glowColor:r=[1,1,1],glowIntensity:o=1,hasActiveGesture:l=!1,calibrationRotation:h=[0,0,0],cameraRoll:c=0,solarEclipse:u=null,deltaTime:d=0,morphProgress:p=null,hasSoul:m=!1,hasParticles:g=!0}=t;if(this.controls&&this.controls.update(),this.coreMesh){if(this.coreMesh.position.set(...i),this._tempEuler.set(n[0],n[1],n[2],"XYZ"),this._tempQuat.setFromEuler(this._tempEuler),this._quatX.setFromAxisAngle(this._xAxis,h[0]),this._quatY.setFromAxisAngle(this._yAxis,h[1]),this._cameraToMesh.subVectors(this.coreMesh.position,this.camera.position).normalize(),this._quatZ.setFromAxisAngle(this._cameraToMesh,h[2]),this._tempQuat.multiply(this._quatX),this._tempQuat.multiply(this._quatY),this._tempQuat.multiply(this._quatZ),this.coreMesh.rotation.setFromQuaternion(this._tempQuat),0!==c&&(this._cameraDir.subVectors(this.coreMesh.position,this.camera.position).normalize(),this._rollQuat.setFromAxisAngle(this._cameraDir,c),this._meshQuat.setFromEuler(this.coreMesh.rotation),this._meshQuat.premultiply(this._rollQuat),this.coreMesh.rotation.setFromQuaternion(this._meshQuat)),a?this.coreMesh.scale.set(a[0],a[1],a[2]):this.coreMesh.scale.setScalar(s),u&&u.update(this.camera,this.coreMesh,d,p),this.coreMesh.material&&this.coreMesh.material.uniforms){if(this.coreMesh.material.uniforms.glowColor&&(this._tempColor.setRGB(...r),this.coreMesh.material.uniforms.glowColor.value.lerp(this._tempColor,.15)),this.coreMesh.material.uniforms.glowIntensity){let t;t=0===o?0:l?o:this.normalizeIntensity(o);const e=this.coreMesh.material.uniforms.glowIntensity.value,i=l?.5:.15;this.coreMesh.material.uniforms.glowIntensity.value+=(t-e)*i}if(void 0!==this.coreMesh.material.uniforms.deformationStrength){const e=t.deformation;if(e&&e.enabled&&e.strength>.001){if(!this._lastDeformLog||Date.now()-this._lastDeformLog>1e3){const t=e.impactPoint;console.log(` DEFORMATION: strength=${e.strength.toFixed(3)} impactPoint=[${t[0].toFixed(3)}, ${t[1].toFixed(3)}, ${t[2].toFixed(3)}] falloff=${e.falloffRadius}`),this._lastDeformLog=Date.now()}this.coreMesh.material.uniforms.deformationStrength.value=e.strength,e.impactPoint&&this.coreMesh.material.uniforms.impactPoint&&this.coreMesh.material.uniforms.impactPoint.value.set(e.impactPoint[0],e.impactPoint[1],e.impactPoint[2]),void 0!==e.falloffRadius&&this.coreMesh.material.uniforms.deformationFalloff&&(this.coreMesh.material.uniforms.deformationFalloff.value=e.falloffRadius)}else this.coreMesh.material.uniforms.deformationStrength.value=0}}else if(this.coreMesh.material&&this.coreMesh.material.emissive){this._tempColor.setRGB(...r),this.coreMesh.material.emissive.lerp(this._tempColor,.15);const t=.15*o,e=this.coreMesh.material.emissiveIntensity,i=l?.5:.15;this.coreMesh.material.emissiveIntensity+=(t-e)*i,this.coreMesh.material.color.lerp(this._white,.15)}this.innerCore&&(this.innerCore.visible=o>0,this.innerCoreMaterial&&(this._tempColor.setRGB(...r),this.innerCoreMaterial.emissive.lerp(this._tempColor,.15)))}if(this.mixer){const t=this.clock.getDelta();this.mixer.update(t)}if(this.renderer.clear(),this.composer){if(this.soulRenderTarget&&m){this._cachedSoulMesh||this.scene.traverse(t=>{"crystalSoul"===t.name&&(this._cachedSoulMesh=t)});const t=this._cachedSoulMesh;if(this.renderer.setRenderTarget(this.soulRenderTarget),this.renderer.clear(),this.camera.layers.set(2),this.renderer.render(this.scene,this.camera),this.coreMesh?.material?.uniforms?.soulTexture&&(this.coreMesh.material.uniforms.soulTexture.value=this.soulRenderTarget.texture,this.coreMesh.material.uniforms.soulTextureSize&&this.coreMesh.material.uniforms.soulTextureSize.value.set(this.soulRenderTarget.width,this.soulRenderTarget.height),this.coreMesh.material.uniforms.soulScreenCenter&&t)){this._soulPosTemp.copy(t.position),this._soulPosTemp.project(this.camera);const e=.5*(this._soulPosTemp.x+1),i=.5*(this._soulPosTemp.y+1);this.coreMesh.material.uniforms.soulScreenCenter.value.set(e,i)}this.renderer.setRenderTarget(null)}if(this.camera.layers.set(0),this.composer.render(),g&&this.particleRenderTarget&&this.particleBloomPass){this.renderer.setRenderTarget(this.particleRenderTarget),this.renderer.setClearColor(16777215,0),this.renderer.clear(),this.camera.layers.set(0);const t=this._depthOnlyMaterial||(this._depthOnlyMaterial=new Gn({colorWrite:!1,depthWrite:!0}));this.scene.overrideMaterial=t,this.renderer.render(this.scene,this.camera),this.scene.overrideMaterial=null,this.camera.layers.set(1),this.renderer.render(this.scene,this.camera);const e=this.particleRenderTarget;this.particleBloomPass.renderToScreen=!0,this.particleBloomPass.render(this.renderer,null,e,0,!1),this.renderer.setClearColor(0,0),this.renderer.setRenderTarget(null)}else g&&(this.camera.layers.set(1),this.renderer.render(this.scene,this.camera));this.camera.layers.enableAll(),this.glowLayer&&this.glowLayer.isActive()&&this.glowLayer.render(this.renderer)}else this.renderer.render(this.scene,this.camera),this.glowLayer&&this.glowLayer.isActive()&&this.glowLayer.render(this.renderer)}updateGlowLayer(t,e,i,n){this.glowLayer&&(this.glowLayer.setGlow(t,e,i),this.glowLayer.update(n,this.camera))}resize(t,e){if(this.camera.aspect=t/e,this.camera.updateProjectionMatrix(),this.renderer.setSize(t,e,!1),this.composer){const t=new je;this.renderer.getDrawingBufferSize(t),this.composer.setSize(t.x,t.y),this.bloomPass&&this.bloomPass.resolution&&this.bloomPass.resolution.set(t.x,t.y),this.particleRenderTarget&&this.particleRenderTarget.setSize(t.x,t.y),this.particleBloomPass&&this.particleBloomPass.setSize(t.x,t.y),this.soulRenderTarget&&this.soulRenderTarget.setSize(t.x,t.y),this.coreMesh?.material?.uniforms?.resolution&&this.coreMesh.material.uniforms.resolution.value.set(t.x,t.y)}}disposeMaterial(t){t&&(["map","lightMap","bumpMap","normalMap","specularMap","envMap","alphaMap","aoMap","displacementMap","emissiveMap","gradientMap","metalnessMap","roughnessMap"].forEach(e=>{t[e]&&t[e].dispose()}),t.uniforms&&Object.values(t.uniforms).forEach(t=>{t.value&&(t.value.isTexture?(t.value.dispose(),t.value=null):(t.value.isColor||t.value.isVector2||t.value.isVector3||t.value.isVector4)&&(t.value=null))}),t.dispose())}destroy(){this._destroyed=!0,this.renderer?.domElement&&(this.renderer.domElement.removeEventListener("webglcontextlost",this._boundHandleContextLost,!1),this.renderer.domElement.removeEventListener("webglcontextrestored",this._boundHandleContextRestored,!1)),document.removeEventListener("visibilitychange",this._boundHandleVisibilityChange),this.cameraAnimationId&&(cancelAnimationFrame(this.cameraAnimationId),this.cameraAnimationId=null),this.innerCore&&(this.coreMesh&&this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null),this.coreMesh&&(this.scene.remove(this.coreMesh),this.coreMesh.geometry.dispose(),this.disposeMaterial(this.coreMesh.material),this.coreMesh=null),this.glowMaterial&&(this.disposeMaterial(this.glowMaterial),this.glowMaterial=null),this.glassMaterial&&(this.disposeMaterial(this.glassMaterial),this.glassMaterial=null),this.composer&&(this.composer.dispose(),this.composer=null),this.particleRenderTarget&&(this.particleRenderTarget.dispose(),this.particleRenderTarget=null),this.particleBloomPass&&(this.particleBloomPass.dispose(),this.particleBloomPass=null),this.soulRenderTarget&&(this.soulRenderTarget.dispose(),this.soulRenderTarget=null),this.glowLayer&&(this.glowLayer.dispose(),this.glowLayer=null),this.cameraPresetManager&&(this.cameraPresetManager.dispose(),this.cameraPresetManager=null),this.controls&&(this.controls.dispose(),this.controls=null),this.keyLight?.shadow?.map&&this.keyLight.shadow.map.dispose(),this.fillLight?.shadow?.map&&this.fillLight.shadow.map.dispose(),this.rimLight?.shadow?.map&&this.rimLight.shadow.map.dispose(),this.keyLight=null,this.fillLight=null,this.rimLight=null,this.ambientLight=null,this.accentLight1=null,this.accentLight2=null,this.accentLight3=null,this.envMap&&(this.envMap.dispose(),this.envMap=null),this._envCubeRenderTarget&&(this._envCubeRenderTarget.dispose(),this._envCubeRenderTarget=null),this._envScene&&(this._envScene.traverse(t=>{t.geometry&&t.geometry.dispose(),t.material&&this.disposeMaterial(t.material)}),this._envScene.clear(),this._envScene=null),this._envCubeCamera&&(this._envCubeCamera=null),this.renderer&&(this.renderer.dispose(),this.renderer=null),this.scene.clear(),this.mixer&&(this.mixer.stopAllAction(),this.mixer=null),this.clock=null,this.camera=null,this._tempColor=null,this._tempColor2=null,this._white=null,this._tempQuat=null,this._tempEuler=null,this._quatX=null,this._quatY=null,this._quatZ=null,this._rollQuat=null,this._meshQuat=null,this._xAxis=null,this._yAxis=null,this._zAxis=null,this._cameraToMesh=null,this._cameraDir=null}}const Jp=/^[og]\s*(.+)?/,Qp=/^mtllib /,Kp=/^usemtl /,tm=/^usemap /,em=/\s+/,im=new qe,nm=new qe,sm=new qe,am=new qe,rm=new qe,om=new zn;function lm(){const t={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=!1!==e);const i=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:!1!==e,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(t,e){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const n={index:this.materials.length,name:t||"",mtllib:Array.isArray(e)&&e.length>0?e[e.length-1]:"",smooth:void 0!==i?i.smooth:this.smooth,groupStart:void 0!==i?i.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(t){const e={index:"number"==typeof t?t:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return e.clone=this.clone.bind(e),e}};return this.materials.push(n),n},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){const e=this.currentMaterial();if(e&&-1===e.groupEnd&&(e.groupEnd=this.geometry.vertices.length/3,e.groupCount=e.groupEnd-e.groupStart,e.inherited=!1),t&&this.materials.length>1)for(let t=this.materials.length-1;t>=0;t--)this.materials[t].groupCount<=0&&this.materials.splice(t,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),e}},i&&i.name&&"function"==typeof i.clone){const t=i.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const i=parseInt(t,10);return 3*(i>=0?i-1:i+e/3)},parseNormalIndex:function(t,e){const i=parseInt(t,10);return 3*(i>=0?i-1:i+e/3)},parseUVIndex:function(t,e){const i=parseInt(t,10);return 2*(i>=0?i-1:i+e/2)},addVertex:function(t,e,i){const n=this.vertices,s=this.object.geometry.vertices;s.push(n[t+0],n[t+1],n[t+2]),s.push(n[e+0],n[e+1],n[e+2]),s.push(n[i+0],n[i+1],n[i+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,i){const n=this.normals,s=this.object.geometry.normals;s.push(n[t+0],n[t+1],n[t+2]),s.push(n[e+0],n[e+1],n[e+2]),s.push(n[i+0],n[i+1],n[i+2])},addFaceNormal:function(t,e,i){const n=this.vertices,s=this.object.geometry.normals;im.fromArray(n,t),nm.fromArray(n,e),sm.fromArray(n,i),rm.subVectors(sm,nm),am.subVectors(im,nm),rm.cross(am),rm.normalize(),s.push(rm.x,rm.y,rm.z),s.push(rm.x,rm.y,rm.z),s.push(rm.x,rm.y,rm.z)},addColor:function(t,e,i){const n=this.colors,s=this.object.geometry.colors;void 0!==n[t]&&s.push(n[t+0],n[t+1],n[t+2]),void 0!==n[e]&&s.push(n[e+0],n[e+1],n[e+2]),void 0!==n[i]&&s.push(n[i+0],n[i+1],n[i+2])},addUV:function(t,e,i){const n=this.uvs,s=this.object.geometry.uvs;s.push(n[t+0],n[t+1]),s.push(n[e+0],n[e+1]),s.push(n[i+0],n[i+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,i,n,s,a,r,o,l){const h=this.vertices.length;let c=this.parseVertexIndex(t,h),u=this.parseVertexIndex(e,h),d=this.parseVertexIndex(i,h);if(this.addVertex(c,u,d),this.addColor(c,u,d),void 0!==r&&""!==r){const t=this.normals.length;c=this.parseNormalIndex(r,t),u=this.parseNormalIndex(o,t),d=this.parseNormalIndex(l,t),this.addNormal(c,u,d)}else this.addFaceNormal(c,u,d);if(void 0!==n&&""!==n){const t=this.uvs.length;c=this.parseUVIndex(n,t),u=this.parseUVIndex(s,t),d=this.parseUVIndex(a,t),this.addUV(c,u,d),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let i=0,n=t.length;i<n;i++){const n=this.parseVertexIndex(t[i],e);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const i=this.vertices.length,n=this.uvs.length;for(let e=0,n=t.length;e<n;e++)this.addVertexLine(this.parseVertexIndex(t[e],i));for(let t=0,i=e.length;t<i;t++)this.addUVLine(this.parseUVIndex(e[t],n))}};return t.startObject("",!1),t}class hm extends Vl{constructor(t){super(t),this.materials=null}load(t,e,i,n){const s=this,a=new jl(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,function(i){try{e(s.parse(i))}catch(e){n?n(e):console.error(e),s.manager.itemError(t)}},i,n)}setMaterials(t){return this.materials=t,this}parse(t){const e=new lm;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n")),-1!==t.indexOf("\\\n")&&(t=t.replace(/\\\n/g,""));const i=t.split("\n");let n=[];for(let t=0,s=i.length;t<s;t++){const s=i[t].trimStart();if(0===s.length)continue;const a=s.charAt(0);if("#"!==a)if("v"===a){const t=s.split(em);switch(t[0]){case"v":e.vertices.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])),t.length>=7?(om.setRGB(parseFloat(t[4]),parseFloat(t[5]),parseFloat(t[6]),se),e.colors.push(om.r,om.g,om.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":e.uvs.push(parseFloat(t[1]),parseFloat(t[2]))}}else if("f"===a){const t=s.slice(1).trim().split(em),i=[];for(let e=0,n=t.length;e<n;e++){const n=t[e];if(n.length>0){const t=n.split("/");i.push(t)}}const n=i[0];for(let t=1,s=i.length-1;t<s;t++){const s=i[t],a=i[t+1];e.addFace(n[0],s[0],a[0],n[1],s[1],a[1],n[2],s[2],a[2])}}else if("l"===a){const t=s.substring(1).trim().split(" ");let i=[];const n=[];if(-1===s.indexOf("/"))i=t;else for(let e=0,s=t.length;e<s;e++){const s=t[e].split("/");""!==s[0]&&i.push(s[0]),""!==s[1]&&n.push(s[1])}e.addLineGeometry(i,n)}else if("p"===a){const t=s.slice(1).trim().split(" ");e.addPointGeometry(t)}else if(null!==(n=Jp.exec(s))){const t=(" "+n[0].slice(1).trim()).slice(1);e.startObject(t)}else if(Kp.test(s))e.object.startMaterial(s.substring(7).trim(),e.materialLibraries);else if(Qp.test(s))e.materialLibraries.push(s.substring(7).trim());else if(tm.test(s))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===a){if(n=s.split(" "),n.length>1){const t=n[1].trim().toLowerCase();e.object.smooth="0"!==t&&"off"!==t}else e.object.smooth=!0;const t=e.object.currentMaterial();t&&(t.smooth=e.object.smooth)}else{if("\0"===s)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+s+'"')}}e.finalize();const s=new Os;if(s.materialLibraries=[].concat(e.materialLibraries),!0==!(1===e.objects.length&&0===e.objects[0].geometry.vertices.length))for(let t=0,i=e.objects.length;t<i;t++){const i=e.objects[t],n=i.geometry,a=i.materials,r="Line"===n.type,o="Points"===n.type;let l=!1;if(0===n.vertices.length)continue;const h=new os;h.setAttribute("position",new Kn(n.vertices,3)),n.normals.length>0&&h.setAttribute("normal",new Kn(n.normals,3)),n.colors.length>0&&(l=!0,h.setAttribute("color",new Kn(n.colors,3))),!0===n.hasUVIndices&&h.setAttribute("uv",new Kn(n.uvs,2));const c=[];for(let t=0,i=a.length;t<i;t++){const i=a[t],n=i.name+"_"+i.smooth+"_"+l;let s=e.materials[n];if(null!==this.materials)if(s=this.materials.create(i.name),!r||!s||s instanceof cr){if(o&&s&&!(s instanceof Sr)){const t=new Sr({size:10,sizeAttenuation:!1});Nn.prototype.copy.call(t,s),t.color.copy(s.color),t.map=s.map,s=t}}else{const t=new cr;Nn.prototype.copy.call(t,s),t.color.copy(s.color),s=t}void 0===s&&(s=r?new cr:o?new Sr({size:1,sizeAttenuation:!1}):new dl,s.name=i.name,s.flatShading=!i.smooth,s.vertexColors=l,e.materials[n]=s),c.push(s)}let u;if(c.length>1){for(let t=0,e=a.length;t<e;t++){const e=a[t];h.addGroup(e.groupStart,e.groupCount,t)}u=r?new xr(h,c):o?new Pr(h,c):new bs(h,c)}else u=r?new xr(h,c[0]):o?new Pr(h,c[0]):new bs(h,c[0]);u.name=i.name,s.add(u)}else if(e.vertices.length>0){const t=new Sr({size:1,sizeAttenuation:!1}),i=new os;i.setAttribute("position",new Kn(e.vertices,3)),e.colors.length>0&&void 0!==e.colors[0]&&(i.setAttribute("color",new Kn(e.colors,3)),t.vertexColors=!0);const n=new Pr(i,t);s.add(n)}return s}}const cm="\n/**\n * Apply a single blend mode to two colors\n * @param base - Base color (RGB, 0.0-1.0 range)\n * @param blend - Blend color (RGB, 0.0-1.0 range)\n * @param mode - Blend mode index (0-17)\n * @return Blended color (RGB, 0.0-1.0 range)\n *\n * Blend Mode Reference:\n *  0 = Multiply        (darkening)\n *  1 = Linear Burn     (darkening, linear)\n *  2 = Color Burn      (darkening, intense)\n *  3 = Color Dodge     (brightening, intense)\n *  4 = Screen          (brightening)\n *  5 = Overlay         (contrast, screen/multiply hybrid)\n *  6 = Add             (brightening, additive glow)\n *  7 = Soft Light      (contrast, gentle)\n *  8 = Hard Light      (contrast, strong)\n *  9 = Vivid Light     (contrast, saturation boost)\n * 10 = Linear Light    (contrast, linear)\n * 11 = Difference      (inversion)\n * 12 = Exclusion       (soft inversion)\n * 13 = Darken          (comparison, darker)\n * 14 = Lighten         (comparison, lighter)\n * 15 = Subtract        (darkening, deep shadows)\n * 16 = Divide          (brightening, ethereal glow)\n * 17 = Pin Light       (posterization)\n */\nvec3 applyBlendMode(vec3 base, vec3 blend, int mode) {\n    if (mode == 0) {\n        // MULTIPLY: base * blend\n        return base * blend;\n    } else if (mode == 1) {\n        // LINEAR BURN: base + blend - 1\n        return max(base + blend - vec3(1.0), vec3(0.0));\n    } else if (mode == 2) {\n        // COLOR BURN: (blend==0.0) ? 0.0 : max((1.0-((1.0-base)/blend)), 0.0)\n        return vec3(\n            blend.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.r) / blend.r), 0.0),\n            blend.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.g) / blend.g), 0.0),\n            blend.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.b) / blend.b), 0.0)\n        );\n    } else if (mode == 3) {\n        // COLOR DODGE: (blend==1.0) ? 1.0 : min(base/(1.0-blend), 1.0)\n        return vec3(\n            blend.r == 1.0 ? 1.0 : min(base.r / (1.0 - blend.r), 1.0),\n            blend.g == 1.0 ? 1.0 : min(base.g / (1.0 - blend.g), 1.0),\n            blend.b == 1.0 ? 1.0 : min(base.b / (1.0 - blend.b), 1.0)\n        );\n    } else if (mode == 4) {\n        // SCREEN: 1 - (1 - base) * (1 - blend)\n        return vec3(1.0) - (vec3(1.0) - base) * (vec3(1.0) - blend);\n    } else if (mode == 5) {\n        // OVERLAY: base < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n        return vec3(\n            base.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),\n            base.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),\n            base.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))\n        );\n    } else if (mode == 6) {\n        // ADD (LINEAR DODGE): base + blend\n        return min(base + blend, vec3(1.0));\n    } else if (mode == 7) {\n        // SOFT LIGHT: blend < 0.5 ? (2*base*blend + base^2*(1-2*blend)) : (sqrt(base)*(2*blend-1) + 2*base*(1-blend))\n        return vec3(\n            blend.r < 0.5 ? (2.0 * base.r * blend.r + base.r * base.r * (1.0 - 2.0 * blend.r)) : (sqrt(base.r) * (2.0 * blend.r - 1.0) + 2.0 * base.r * (1.0 - blend.r)),\n            blend.g < 0.5 ? (2.0 * base.g * blend.g + base.g * base.g * (1.0 - 2.0 * blend.g)) : (sqrt(base.g) * (2.0 * blend.g - 1.0) + 2.0 * base.g * (1.0 - blend.g)),\n            blend.b < 0.5 ? (2.0 * base.b * blend.b + base.b * base.b * (1.0 - 2.0 * blend.b)) : (sqrt(base.b) * (2.0 * blend.b - 1.0) + 2.0 * base.b * (1.0 - blend.b))\n        );\n    } else if (mode == 8) {\n        // HARD LIGHT: blend < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n        return vec3(\n            blend.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),\n            blend.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),\n            blend.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))\n        );\n    } else if (mode == 9) {\n        // VIVID LIGHT: blend < 0.5 ? ColorBurn(base, 2*blend) : ColorDodge(base, 2*(blend-0.5))\n        return vec3(\n            blend.r < 0.5 ? (blend.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.r) / (2.0 * blend.r)), 0.0)) : (blend.r == 1.0 ? 1.0 : min(base.r / (2.0 * (1.0 - blend.r)), 1.0)),\n            blend.g < 0.5 ? (blend.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.g) / (2.0 * blend.g)), 0.0)) : (blend.g == 1.0 ? 1.0 : min(base.g / (2.0 * (1.0 - blend.g)), 1.0)),\n            blend.b < 0.5 ? (blend.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.b) / (2.0 * blend.b)), 0.0)) : (blend.b == 1.0 ? 1.0 : min(base.b / (2.0 * (1.0 - blend.b)), 1.0))\n        );\n    } else if (mode == 10) {\n        // LINEAR LIGHT: blend < 0.5 ? LinearBurn(base, 2*blend) : LinearDodge(base, 2*(blend-0.5))\n        return vec3(\n            blend.r < 0.5 ? max(base.r + 2.0 * blend.r - 1.0, 0.0) : min(base.r + 2.0 * (blend.r - 0.5), 1.0),\n            blend.g < 0.5 ? max(base.g + 2.0 * blend.g - 1.0, 0.0) : min(base.g + 2.0 * (blend.g - 0.5), 1.0),\n            blend.b < 0.5 ? max(base.b + 2.0 * blend.b - 1.0, 0.0) : min(base.b + 2.0 * (blend.b - 0.5), 1.0)\n        );\n    } else if (mode == 11) {\n        // DIFFERENCE: abs(base - blend)\n        return abs(base - blend);\n    } else if (mode == 12) {\n        // EXCLUSION: base + blend - 2 * base * blend\n        return base + blend - 2.0 * base * blend;\n    } else if (mode == 13) {\n        // DARKEN: min(base, blend)\n        return min(base, blend);\n    } else if (mode == 14) {\n        // LIGHTEN: max(base, blend)\n        return max(base, blend);\n    } else if (mode == 15) {\n        // SUBTRACT: max(base - blend, 0)\n        return max(base - blend, vec3(0.0));\n    } else if (mode == 16) {\n        // DIVIDE: base / (blend + epsilon)\n        return min(base / (blend + vec3(0.001)), vec3(1.0));\n    } else {\n        // PIN LIGHT (mode 17): Replaces colors based on blend brightness\n        float blendLum = (blend.r + blend.g + blend.b) / 3.0;\n        if (blendLum > 0.5) {\n            // Lighten: replace pixels darker than blend\n            return max(base, 2.0 * blend - vec3(1.0));\n        } else {\n            // Darken: replace pixels lighter than blend\n            return min(base, 2.0 * blend);\n        }\n    }\n}\n",um=["Multiply","Linear Burn","Color Burn","Color Dodge","Screen","Overlay","Add","Soft Light","Hard Light","Vivid Light","Linear Light","Difference","Exclusion","Darken","Lighten","Subtract","Divide","Pin Light"];function dm(t){return um[t]||"Unknown"}function pm(t){const e=um.indexOf(t);return-1!==e?e:0}const mm=`\n/**\n * Moon Fragment Shader with Blend Layers\n *\n * Supports up to 4 sequential blend mode layers for complex color grading\n * using universal Photoshop-style blend modes\n */\n\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec2 shadowOffset;\nuniform float shadowCoverage;\nuniform float shadowSoftness;\nuniform vec3 glowColor;\nuniform float glowIntensity;\nuniform float opacity;\n\n// Lunar Eclipse (Blood Moon) uniforms\nuniform float eclipseProgress;\nuniform float eclipseIntensity;\nuniform vec3 bloodMoonColor;\nuniform float emissiveStrength;\nuniform vec2 eclipseShadowPos;      // Shadow center position (-2 to 1)\nuniform float eclipseShadowRadius;  // Shadow radius\n\n// Eclipse Color Grading (from color pickers)\nuniform vec3 eclipseShadowColor;\nuniform vec3 eclipseMidtoneColor;\nuniform vec3 eclipseHighlightColor;\nuniform vec3 eclipseGlowColor;\n\n// Brightness model toggle (0 = centeredness-based, 1 = edge-based)\nuniform float eclipseBrightnessModel;\n\n// Shadow darkness control (0.0 = no darkening, 1.0 = maximum darkening)\nuniform float shadowDarkness;\n\n// Blend Layer Uniforms (up to 4 layers)\nuniform float layer1Mode;\nuniform float layer1Strength;\nuniform float layer1Enabled;\n\nuniform float layer2Mode;\nuniform float layer2Strength;\nuniform float layer2Enabled;\n\nuniform float layer3Mode;\nuniform float layer3Strength;\nuniform float layer3Enabled;\n\nuniform float layer4Mode;\nuniform float layer4Strength;\nuniform float layer4Enabled;\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n// \n// UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n// \n${cm}\n\nvoid main() {\n    // DIRECTIONAL SHADOW in VIEW SPACE - camera-relative moon phase\n    // Shadow stays fixed relative to screen; rotating moon doesn't change which side is lit\n    vec3 viewNormal = normalize(vViewNormal);\n\n    float lightX = shadowOffset.x;\n    float lightY = shadowOffset.y;\n    float offsetMagnitude = length(vec2(lightX, lightY));\n    float lightZ = 1.0 - pow(offsetMagnitude, 1.5);\n    vec3 lightDir = normalize(vec3(lightX, lightY, lightZ));\n\n    // Light direction is in view space (camera-relative)\n    float facing = dot(viewNormal, lightDir);\n    float edgeWidth = max(fwidth(facing) * 4.0, shadowSoftness * 3.0);\n    float shadowFactor = smoothstep(-edgeWidth, edgeWidth, facing);\n\n    // Sample moon surface texture\n    vec4 texColor = texture2D(colorMap, vUv);\n    float brightness = texColor.r + texColor.g + texColor.b;\n    if (brightness < 0.03) {\n        texColor = vec4(0.5, 0.5, 0.5, 1.0);\n    }\n\n    // VIEW DIRECTION (for eclipse rim effects only, NOT for general lighting)\n    vec3 viewDir = normalize(-vViewPosition);\n    float rimFactor = dot(viewNormal, viewDir);\n\n    // EARTHSHINE - faint blue glow on shadowed side\n    vec3 earthshine = texColor.rgb * 0.01 * vec3(0.35, 0.4, 0.6);\n\n    // Apply shadow transition (moon phase only - NOT camera-based)\n    // The moon texture is uniformly visible; only the phase shadow creates darkness\n    float litFactor = pow(shadowFactor, 2.0);\n    vec3 detailEnhanced = texColor.rgb * 1.08;\n    float textureLuminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    detailEnhanced = mix(texColor.rgb * 0.95, texColor.rgb * 1.12, smoothstep(0.3, 0.7, textureLuminance));\n\n    // Lit areas show texture; shadowed areas show earthshine\n    // NO camera-based limb darkening - moon rotates, texture stays uniformly lit\n    vec3 shadowedColor = mix(earthshine, detailEnhanced, litFactor);\n\n    vec3 emissive = vec3(0.02, 0.02, 0.02) * shadowFactor;\n    vec3 emotionGlow = glowColor * glowIntensity * 0.02 * shadowFactor;\n    vec3 finalColor = shadowedColor + emissive + emotionGlow;\n\n    // \n    // LUNAR ECLIPSE EFFECT (Earth's Shadow Sweep)\n    // Shadow position drives everything - automatically transitions from dark sharp shadow to red glow\n    // \n    // Only apply eclipse if shadow is actually near the moon (shadowX > -1.5)\n    if (eclipseProgress > 0.001 && eclipseShadowPos.x > -1.5) {\n        // Eclipse progress is now pre-modulated by UI based on shadow position\n        // No need for shader-side modulation\n        float effectiveProgress = eclipseProgress;\n\n        // Calculate distance from shadow center using VIEW-SPACE position (3D spherical)\n        // This creates a proper circular shadow on the sphere, not a flat UV-based cutoff\n        // viewNormal.xy ranges -1 to 1, scale to match UV range (0 to 0.5 from center)\n        vec2 shadowCenter = vec2(eclipseShadowPos.x, eclipseShadowPos.y);\n        vec2 spherePos = viewNormal.xy * 0.5; // Scale to UV-equivalent range\n        float distFromShadow = length(spherePos - shadowCenter);\n\n        // TOTALITY FACTOR: Based on how centered the shadow is on the moon\n        // When shadowX near 0.0 (centered), we're at totality - brightens and reddens\n        // When shadowX far from 0.0 (off to side), we're partial - stays dark and diffuse\n        float shadowCenteredness = 1.0 - smoothstep(0.0, 0.6, abs(eclipseShadowPos.x));\n        float totalityFactor = shadowCenteredness;\n\n        // Earth's umbra (full shadow) - DIFFUSE at partials, sharper at totality\n        float umbraRadius = eclipseShadowRadius * 0.7;\n        // Edge softness: very diffuse at partials (0.25), sharp at totality (0.05)\n        float umbraEdge = mix(0.25, 0.05, totalityFactor);\n        float umbra = 1.0 - smoothstep(umbraRadius - umbraEdge, umbraRadius + umbraEdge, distFromShadow);\n\n        // Earth's penumbra (partial shadow) - wider and softer\n        // Penumbra extends further at partials, tighter at totality\n        float penumbraRadius = eclipseShadowRadius * mix(1.4, 1.1, totalityFactor);\n        float penumbraEdge = mix(0.3, 0.15, totalityFactor);\n        float penumbra = 1.0 - smoothstep(penumbraRadius - penumbraEdge, penumbraRadius + penumbraEdge, distFromShadow);\n\n        // UMBRA DARKENING: Much darker at partials, lighter at totality\n        // Partials: 85% darkening (very dark shadow)\n        // Totality: 30% darkening (blood moon glow visible)\n        float baseDarkening = mix(0.85, 0.30, totalityFactor);\n        float umbraDarkeningAmount = baseDarkening * shadowDarkness;\n        float umbraDarkening = umbra * effectiveProgress;\n\n        // Apply base darkening first\n        finalColor *= (1.0 - umbraDarkening * umbraDarkeningAmount);\n\n        // PENUMBRA: Darker gradient at partials, lighter at totality\n        float penumbraDarkening = (penumbra - umbra) * effectiveProgress;\n        float penumbraDarkenAmount = mix(0.50, 0.20, totalityFactor); // 50% at partials, 20% at totality\n        finalColor *= (1.0 - penumbraDarkening * penumbraDarkenAmount);\n\n        // BLOOD MOON COLOR: Applied throughout entire eclipse, not just totality\n        // Matches real lunar eclipse behavior - color present at all phases\n        // Use totality factor to control BRIGHTNESS, not color presence\n        float colorStrength = umbra; // Color appears wherever umbra shadow is present\n        vec3 bloodMoonTint = mix(vec3(1.0), eclipseMidtoneColor, colorStrength);\n        finalColor *= bloodMoonTint;\n\n        // REALISTIC ECLIPSE PROGRESSION (corrected):\n        // Shadow sweeps LEFT  RIGHT but NEVER fully covers moon during partials\n        // A bright crescent ALWAYS remains visible (shadow stops before covering moon)\n        // Just before totality: shadow nearly covers moon, blood moon glow appears\n        // The glow spreads FROM the visible bright crescent INTO the shadowed area\n        // During totality: shadow finally covers entire moon, full blood moon\n\n        // Use view-space normal for spherical position (not UV)\n        // Scale to match UV range\n        float pixelX = viewNormal.x * 0.5;\n\n        // THE LIT CRESCENT: Always visible during partial phases\n        // During partials, the moon is partially lit (outside umbra)\n        // Only during totality does the shadow fully cover the moon\n\n        // Where is the bright crescent? Opposite side from shadow\n        // Approaching (shadowX < 0): crescent on RIGHT (positive X)\n        // Leaving (shadowX > 0): crescent on LEFT (negative X)\n        float crescentSide = -sign(eclipseShadowPos.x);\n\n        // CRESCENT EDGE: Where shadow meets lit surface\n        // This is always VISIBLE during partials - never goes to zero\n        float umbraEdgeX = eclipseShadowPos.x + (umbraRadius * crescentSide);\n\n        // Distance from this pixel to the lit crescent edge\n        // Positive = inside shadow, negative = in lit crescent\n        float distFromLitEdge = (pixelX - umbraEdgeX) * crescentSide;\n\n        // GRADIENT: Blood moon glow spreads from the LIT CRESCENT\n        // Only pixels INSIDE the shadow get the gradient\n        // Gradient is strongest at the umbra edge (where crescent is)\n        float crescentGradient = smoothstep(0.5, 0.0, distFromLitEdge);\n\n        // BRIGHTNESS CONTROL: Glow only appears near totality\n        // When shadow is far from center: stays dark\n        // When shadow approaches center: glow spreads from crescent\n        float brightnessControl = umbra * crescentGradient * totalityFactor;\n\n        // During full totality (shadowX  0), switch to uniform brightness\n        brightnessControl = mix(brightnessControl, umbra * totalityFactor, totalityFactor);\n\n        // EMISSIVE GLOW: Blood moon color spreading from crescent\n        float glowStrength = mix(0.0, 1.0, brightnessControl);\n        vec3 atmosphereGlow = eclipseMidtoneColor * emissiveStrength * glowStrength * umbra;\n        finalColor += atmosphereGlow;\n\n        // RIM GLOW: Atmospheric limb brightening\n        float limbGlowStrength = mix(0.0, 1.5, brightnessControl);\n        float limbGlow = pow(1.0 - rimFactor, 3.0) * umbra;\n        vec3 rimColor = mix(eclipseGlowColor, eclipseHighlightColor, 0.5);\n        finalColor += rimColor * limbGlow * emissiveStrength * limbGlowStrength;\n\n        // \n        // ECLIPSE BLEND LAYERS (Applied AFTER blood moon color)\n        // Applied throughout eclipse wherever umbra is present\n        // Strength modulated by totality factor for smooth brightness transitions\n        // \n\n        // Layer 1: Linear Burn @ 0.634\n        if (layer1Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n            int mode1 = int(layer1Mode + 0.5);\n            vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n            // Apply at FULL strength wherever umbra exists\n            finalColor = clamp(mix(finalColor, blended1, umbra), 0.0, 1.0);\n        }\n\n        // Layer 2: Multiply @ 3.086 - Brightness enhancement\n        if (layer2Enabled > 0.5 && effectiveProgress > 0.1) {\n            // Apply full brightness boost wherever umbra exists\n            vec3 brightened = clamp(finalColor * min(layer2Strength, 5.0), 0.0, 1.0);\n            finalColor = mix(finalColor, brightened, umbra);\n        }\n\n        // Layer 3: Hard Light @ 0.351\n        if (layer3Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n            int mode3 = int(layer3Mode + 0.5);\n            vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n            // Apply at FULL strength wherever umbra exists\n            finalColor = clamp(mix(finalColor, blended3, umbra), 0.0, 1.0);\n        }\n\n        // Layer 4: Manual UI layer\n        if (layer4Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n            int mode4 = int(layer4Mode + 0.5);\n            vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n            finalColor = clamp(mix(finalColor, blended4, umbra), 0.0, 1.0);\n        }\n    }\n\n    // \n    // UNIVERSAL BLEND MODE LAYERS (Only applied when eclipse is OFF)\n    // These are manual UI-driven color grading tools\n    // NOTE: These are DISABLED by default - they're NEVER used since the multiplexer\n    // demo doesn't enable them. This section exists for potential future manual control.\n    // \n    // INTENTIONALLY COMMENTED OUT - these would interfere with eclipse blend layers\n    // if (eclipseProgress < 0.001) {\n    //     // Layer 1 - manual UI control only\n    //     if (layer1Enabled > 0.5) {\n    //         vec3 blendColor1 = vec3(layer1Strength);\n    //         int mode1 = int(layer1Mode + 0.5);\n    //         finalColor = applyBlendMode(finalColor, blendColor1, mode1);\n    //     }\n    // }\n\n    gl_FragColor = vec4(finalColor, opacity);\n}\n`,gm=55.5,fm=-85,ym=-60.5,vm={enabled:!0,strength:1,lockedFace:[0,0,1],lerpSpeed:10},bm={new:{x:200,y:0,coverage:0},"waxing-crescent":{x:1.5,y:0,coverage:.25},"first-quarter":{x:1,y:0,coverage:.5},"waxing-gibbous":{x:.7,y:0,coverage:.75},full:{x:0,y:0,coverage:1},"waning-gibbous":{x:-.7,y:0,coverage:.75},"last-quarter":{x:-1,y:0,coverage:.5},"waning-crescent":{x:-1.5,y:0,coverage:.25}};function Mm(){return Object.keys(bm)}function _m(t){const e=(t%1+1)%1;let i;if(e<=.5){const t=2*e;i=10*Math.pow(1-t,2.5)}else{const t=2*(e-.5);if(t<=.25)i=t/.25*-.3;else if(t<=.5)i=-.3-(t-.25)/.25*.7;else if(t<=.75)i=-1-(t-.5)/.25*2;else{const e=(t-.75)/.25;i=13*Math.pow(e,.4)-3}}return{x:i,y:0,coverage:1-2*Math.abs(e-.5)}}function xm(t=64,e=64){const i=new tl(.5,t,e);return i.userData.tracked=!0,i}function wm(t){if(t&&(t.geometry&&t.geometry.dispose(),t.material)){const{material:e}=t;e.userData&&e.userData.pendingTextures&&(e.userData.pendingTextures.forEach(({texture:t})=>{t&&t.dispose()}),e.userData.pendingTextures.clear()),e.map&&e.map.dispose(),e.normalMap&&e.normalMap.dispose(),e.uniforms&&(e.uniforms.colorMap&&e.uniforms.colorMap.value&&e.uniforms.colorMap.value.dispose(),e.uniforms.normalMap&&e.uniforms.normalMap.value&&e.uniforms.normalMap.value.dispose()),e.dispose()}}function Sm(t,e={}){const i=e.resolution||"4k",n=e.assetBasePath||"/assets",s=`${n}/textures/Moon/moon-color-${i}.jpg`,a=`${n}/textures/Moon/moon-normal-${i}.jpg`,r=new Map;r.set(s,{texture:null});const o=t.load(s,t=>{const e=r.get(s);e&&(e.texture=t),r.delete(s)},void 0,t=>{console.error(` Failed to load moon color texture (${i}):`,t),r.delete(s)});r.set(a,{texture:null});const l=t.load(a,t=>{const e=r.get(a);e&&(e.texture=t),r.delete(a)},void 0,t=>{console.error(` Failed to load moon normal map (${i}):`,t),r.delete(a)});o.wrapS=o.wrapT=N,l.wrapS=l.wrapT=N,o.anisotropy=16,l.anisotropy=16;const h=new cl({map:o,normalMap:l,normalScale:new je(1.5,1.5),roughness:.7,metalness:0,emissive:new zn(.3,.3,.3),emissiveIntensity:.5,transparent:!1,side:0});return h.userData.pendingTextures=r,h}function Tm(t=new zn(16777215),e=0){return new cl({color:15263976,roughness:.9,metalness:0,emissive:t,emissiveIntensity:e})}function Cm(t,e={}){const i=e.resolution||"4k",n=e.glowColor||new zn(1,1,1),s=e.glowIntensity||1,a=e.shadowType||"crescent",r=e.assetBasePath||"/assets";let o,l;if(void 0!==e.shadowOffsetX)({shadowOffsetX:o}=e),l=void 0!==e.shadowOffsetY?e.shadowOffsetY:0;else if(void 0!==e.moonPhase){let t;"string"==typeof e.moonPhase?([t]=[bm[e.moonPhase]],t||(console.warn(`Unknown moon phase: ${e.moonPhase}, using waxing-crescent`),t=bm["waxing-crescent"])):t="number"==typeof e.moonPhase?_m(e.moonPhase):bm["waxing-crescent"],o=t.x,l=t.y}else{const t=bm["waxing-crescent"];o=t.x,l=t.y}const h=void 0!==e.shadowCoverage?e.shadowCoverage:.85,c=`${r}/textures/Moon/moon-color-${i}.jpg`,u=`${r}/textures/Moon/moon-normal-${i}.jpg`,{vertexShader:d,fragmentShader:p}=function(t){return"crescent"===t||console.warn(`Unknown shadow type: ${t}, defaulting to crescent`),{vertexShader:"\n/**\n * Moon Crescent Vertex Shader\n * Passes world-space normal to fragment shader for realistic lighting\n */\n\nvarying vec3 vPosition; // LOCAL position\nvarying vec3 vWorldPosition;\nvarying vec3 vWorldNormal; // WORLD SPACE normal (rotates with moon)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n\n    // Transform normal to WORLD space (not view space)\n    // This makes the shadow rotate with the moon geometry\n    vWorldNormal = normalize(mat3(modelMatrix) * normal);\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPosition.xyz;\n    vec4 viewPosition = viewMatrix * worldPosition;\n    vViewPosition = viewPosition.xyz;\n    gl_Position = projectionMatrix * viewPosition;\n}\n",fragmentShader:"\n/**\n * Moon Crescent Fragment Shader\n *\n * Uses directional half-space test in WORLD SPACE to create realistic terminator:\n * - Light direction fixed in world space (like the sun)\n * - Normals rotate with moon geometry (in world space)\n * - dot(normal, lightDir) < 0 = shadow side\n * - dot(normal, lightDir) > 0 = lit side\n * - Smooth terminator with earthshine on dark side\n */\n\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec2 shadowOffset; // Controls light direction (x=horizontal, y=vertical)\nuniform float shadowCoverage; // Unused for directional shadow\nuniform float shadowSoftness; // Terminator edge softness (default: 0.05)\nuniform vec3 glowColor;\nuniform float glowIntensity;\nuniform float opacity; // Fade in opacity (0-1) to prevent gray flash during texture load\n\n// Lunar Eclipse (Blood Moon) uniforms\nuniform float eclipseProgress; // 0.0 = no eclipse, 1.0 = totality\nuniform float eclipseIntensity; // Darkening strength (0.0-1.0)\nuniform vec3 bloodMoonColor; // Deep reddish-orange for total eclipse\nuniform float blendMode; // 0=Multiply, 1=LinearBurn, 2=ColorBurn, 3=ColorDodge, 4=Screen, 5=Overlay\nuniform float blendStrength; // Blend strength multiplier (0.0-5.0)\nuniform float emissiveStrength; // Emissive glow strength (0.0-1.0)\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vWorldNormal; // WORLD SPACE normal (rotates with moon)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    // DIRECTIONAL SHADOW in WORLD SPACE - realistic moon phase lighting\n    // Light direction is fixed in world space, shadow rotates with moon\n\n    // Use world-space normal (rotates with moon geometry)\n    vec3 worldNormal = normalize(vWorldNormal);\n\n    // Light direction in WORLD SPACE\n    // shadowOffset.x controls horizontal angle (left/right)\n    // shadowOffset.y controls vertical angle (up/down)\n    // For thin crescents, we need extreme angles (light from the side or behind)\n\n    float lightX = shadowOffset.x;\n    float lightY = shadowOffset.y;\n\n    // Adaptive Z component with LOGARITHMIC scaling for wider angular range\n    // Goal: Spread phases across full 0 to 180 instead of plateauing at 135\n    //\n    // Target angles after normalization:\n    // - Full moon (x=0): 0 (light from front)\n    // - Quarter moon (x=1): 90 (light from side)\n    // - Crescent (x=3): 120 (thin crescent)\n    // - New moon (x=10): 170 (nearly behind)\n\n    float offsetMagnitude = length(vec2(lightX, lightY));\n\n    // Use exponential decay for Z to spread angular range\n    // Formula: Z = 1.0 - offsetMagnitude^1.5 for better distribution\n    float lightZ = 1.0 - pow(offsetMagnitude, 1.5);\n\n    // Normalize the light direction vector\n    vec3 lightDir = normalize(vec3(lightX, lightY, lightZ));\n\n    // Calculate how much this fragment faces the light source\n    float facing = dot(worldNormal, lightDir);\n\n    // Smooth transition at terminator (shadow boundary)\n    // Softer edge for realistic lunar terminator (like real moon photography)\n    // Use fwidth() for automatic screen-space anti-aliasing\n    float edgeWidth = max(fwidth(facing) * 4.0, shadowSoftness * 3.0);\n    float shadowFactor = smoothstep(-edgeWidth, edgeWidth, facing);\n\n    // Sample moon surface texture\n    vec4 texColor = texture2D(colorMap, vUv);\n\n    // Fallback to gray if texture not loaded yet\n    float brightness = texColor.r + texColor.g + texColor.b;\n    if (brightness < 0.03) {\n        texColor = vec4(0.5, 0.5, 0.5, 1.0);\n    }\n\n    // LIMB DARKENING: Moon gets darker at edges (spherical falloff)\n    vec3 viewDir = normalize(-vViewPosition);\n    float rimFactor = dot(worldNormal, viewDir);\n    float limbDarkening = smoothstep(0.0, 0.6, rimFactor); // Subtle edge darkening\n\n    // DIFFUSE LIGHTING: Vary brightness across lit surface (not uniform)\n    // More realistic Lambertian diffuse reflection\n    float diffuse = max(facing, 0.0);\n    float diffuseLighting = mix(0.7, 1.0, diffuse); // Subtle variation\n\n    // EARTHSHINE: Almost invisible (~1% for ultimate realism)\n    vec3 earthshine = texColor.rgb * 0.01 * vec3(0.35, 0.4, 0.6);\n\n    // Apply dramatic shadow transition with maximum contrast\n    float litFactor = pow(shadowFactor, 2.0); // Maximum contrast\n\n    // TEXTURE ENHANCEMENT: Boost surface detail contrast\n    // Slightly darken dark areas, brighten bright areas of texture\n    vec3 detailEnhanced = texColor.rgb * 1.08; // Subtle boost\n    float textureLuminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    detailEnhanced = mix(texColor.rgb * 0.95, texColor.rgb * 1.12, smoothstep(0.3, 0.7, textureLuminance));\n\n    // Combine enhanced texture with diffuse lighting\n    vec3 litColor = detailEnhanced * diffuseLighting;\n    vec3 shadowedColor = mix(earthshine, litColor, litFactor);\n\n    // Apply limb darkening (slightly stronger for more depth)\n    shadowedColor *= mix(0.6, 1.0, limbDarkening);\n\n    // Nearly zero emissive for pure realism\n    vec3 emissive = vec3(0.02, 0.02, 0.02) * shadowFactor;\n\n    // Emotion glow (almost invisible)\n    vec3 emotionGlow = glowColor * glowIntensity * 0.02 * shadowFactor;\n\n    // Combine all lighting components\n    vec3 finalColor = shadowedColor + emissive + emotionGlow;\n\n    // \n    // LUNAR ECLIPSE (BLOOD MOON) EFFECT\n    // \n    // Simulates Earth's umbral shadow with Rayleigh scattering (reddish glow)\n    if (eclipseProgress > 0.001) {\n        // Calculate gradient from lit edge to dark center\n        // Use rim factor (view angle) to create radial gradient\n        float gradientFactor = rimFactor; // 1.0 at edges, 0.0 at center\n\n        // Darken the moon (Earth's shadow)\n        float darkeningFactor = 1.0 - eclipseIntensity;\n        finalColor *= darkeningFactor;\n\n        // \n        // PHOTOSHOP-STYLE BLEND MODES: Multiple modes for deep saturation control\n        // \n\n        // Define blood moon gradient colors\n        vec3 deepRed = vec3(0.6, 0.2, 0.12);       // Dark burnt red-orange (center)\n        vec3 brightOrange = vec3(0.95, 0.45, 0.22); // Bright burnt orange (edges)\n\n        // Create radial gradient from center (dark) to edge (bright)\n        vec3 bloodGradient = mix(deepRed, brightOrange, pow(gradientFactor, 1.8));\n\n        // Apply blend strength multiplier\n        vec3 blendColor = bloodGradient * blendStrength;\n\n        // Calculate all blend modes\n        vec3 finalBlend;\n        int mode = int(blendMode + 0.5); // Round to nearest int\n\n        if (mode == 0) {\n            // MULTIPLY: base * blend\n            finalBlend = finalColor * blendColor;\n        } else if (mode == 1) {\n            // LINEAR BURN: base + blend - 1\n            finalBlend = max(finalColor + blendColor - vec3(1.0), vec3(0.0));\n        } else if (mode == 2) {\n            // COLOR BURN: (blend==0.0) ? 0.0 : max((1.0-((1.0-base)/blend)), 0.0)\n            finalBlend = vec3(\n                blendColor.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.r) / blendColor.r), 0.0),\n                blendColor.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.g) / blendColor.g), 0.0),\n                blendColor.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.b) / blendColor.b), 0.0)\n            );\n        } else if (mode == 3) {\n            // COLOR DODGE: (blend==1.0) ? 1.0 : min(base/(1.0-blend), 1.0)\n            finalBlend = vec3(\n                blendColor.r == 1.0 ? 1.0 : min(finalColor.r / (1.0 - blendColor.r), 1.0),\n                blendColor.g == 1.0 ? 1.0 : min(finalColor.g / (1.0 - blendColor.g), 1.0),\n                blendColor.b == 1.0 ? 1.0 : min(finalColor.b / (1.0 - blendColor.b), 1.0)\n            );\n        } else if (mode == 4) {\n            // SCREEN: 1 - (1 - base) * (1 - blend)\n            finalBlend = vec3(1.0) - (vec3(1.0) - finalColor) * (vec3(1.0) - blendColor);\n        } else {\n            // OVERLAY: base < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n            finalBlend = vec3(\n                finalColor.r < 0.5 ? (2.0 * finalColor.r * blendColor.r) : (1.0 - 2.0 * (1.0 - finalColor.r) * (1.0 - blendColor.r)),\n                finalColor.g < 0.5 ? (2.0 * finalColor.g * blendColor.g) : (1.0 - 2.0 * (1.0 - finalColor.g) * (1.0 - blendColor.g)),\n                finalColor.b < 0.5 ? (2.0 * finalColor.b * blendColor.b) : (1.0 - 2.0 * (1.0 - finalColor.b) * (1.0 - blendColor.b))\n            );\n        }\n\n        // Apply blood moon effect\n        finalColor = mix(finalColor, finalBlend, eclipseProgress);\n\n        // Add emissive glow for visibility\n        finalColor += bloodGradient * emissiveStrength * eclipseProgress;\n\n        // Add bright rim glow during totality (refracted atmosphere light)\n        if (eclipseProgress > 0.7) {\n            float rimIntensity = pow(gradientFactor, 2.5); // Sharp falloff from edge\n            vec3 rimGlow = brightOrange * rimIntensity * (eclipseProgress - 0.7) * 2.5;\n            finalColor += rimGlow;\n        }\n    }\n\n    // Apply fade-in opacity to prevent gray flash during texture load\n    gl_FragColor = vec4(finalColor, opacity);\n}\n"}}(a),m=new Cs({uniforms:{colorMap:{value:null},normalMap:{value:null},shadowOffset:{value:new je(o,l)},shadowCoverage:{value:h},shadowSoftness:{value:.05},glowColor:{value:n},glowIntensity:{value:s},opacity:{value:0},eclipseProgress:{value:0},eclipseIntensity:{value:0},bloodMoonColor:{value:[.85,.18,.08]},blendMode:{value:0},blendStrength:{value:2},emissiveStrength:{value:.39},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:1.2},eclipseShadowColor:{value:[.85,.08,.02]},eclipseMidtoneColor:{value:[1,.12,.03]},eclipseHighlightColor:{value:[1,.35,.08]},eclipseGlowColor:{value:[1,.4,.1]}},vertexShader:d,fragmentShader:p,transparent:!0,side:0}),g=new Map;g.set(c,{texture:null});const f=t.load(c,t=>{m.uniforms.colorMap.value=t;const e=performance.now(),i=()=>{const t=performance.now()-e,n=Math.min(t/300,1);m.uniforms.opacity.value=n,m.needsUpdate=!0,n<1&&requestAnimationFrame(i)};i();const n=g.get(c);n&&(n.texture=t),g.delete(c)},void 0,t=>{console.error(" Failed to load moon crescent color texture:",t),g.delete(c)});g.set(u,{texture:null});const y=t.load(u,t=>{m.uniforms.normalMap.value=t,m.needsUpdate=!0;const e=g.get(u);e&&(e.texture=t),g.delete(u)},void 0,t=>{console.error(" Failed to load moon crescent normal map:",t),g.delete(u)});return f.wrapS=f.wrapT=N,y.wrapS=y.wrapT=N,f.anisotropy=16,y.anisotropy=16,m.userData.pendingTextures=g,m}function Em(t,e={}){return Cm(t,{...e,shadowType:"crescent"})}function Am(t,e){if(!t.uniforms||!t.uniforms.shadowOffset)return console.warn("Material does not have shadowOffset uniform"),!1;let i;if("string"==typeof e){if(i=bm[e],!i)return console.warn(`Unknown moon phase: ${e}`),!1}else{if("number"!=typeof e)return console.warn("Phase must be a string or number"),!1;i=_m(e)}return t.uniforms.shadowOffset.value.set(i.x,i.y),!0}function Pm(t,e,i=2e3){let n=null,s=!1;const a=new Promise((a,r)=>{if(!t.uniforms||!t.uniforms.shadowOffset)return void r(new Error("Material does not have shadowOffset uniform"));let o;if("string"==typeof e){if(o=bm[e],!o)return void r(new Error(`Unknown moon phase: ${e}`))}else{if("number"!=typeof e)return void r(new Error("Phase must be a string or number"));o=_m(e)}const l=t.uniforms.shadowOffset.value.x,h=t.uniforms.shadowOffset.value.y,c=o.x,u=o.y,d=Date.now(),p=()=>{if(s)return void a({cancelled:!0});const e=Date.now()-d,r=Math.min(e/i,1),o=r<.5?4*r*r*r:1-Math.pow(-2*r+2,3)/2,m=l+(c-l)*o,g=h+(u-h)*o;t.uniforms.shadowOffset.value.set(m,g),r<1?n=requestAnimationFrame(p):a({cancelled:!1})};p()});return{promise:a,cancel:()=>{s=!0,null!==n&&(cancelAnimationFrame(n),n=null)}}}function Dm(t,e,i){t.emissive&&(t.emissive.copy(e),t.emissiveIntensity=i),t.uniforms&&t.uniforms.glowColor&&(t.uniforms.glowColor.value.copy(e),t.uniforms.glowIntensity.value=i)}function Rm(t,e,i,n){t.uniforms&&t.uniforms.shadowOffset&&(t.uniforms.shadowOffset.value.set(e,i),t.uniforms.shadowCoverage.value=n)}function Im(t,e={}){const{resolution:i="4k",glowColor:n=new zn(16777215),glowIntensity:s=1,assetBasePath:a="/assets"}=e,{vertexShader:r,fragmentShader:o}={vertexShader:"\n/**\n * Moon Vertex Shader\n * Passes view-space normal for camera-relative moon phase shadows\n */\n\nvarying vec3 vPosition; // LOCAL position (object space)\nvarying vec3 vWorldPosition;\nvarying vec3 vViewNormal; // VIEW SPACE normal (fixed relative to camera)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n\n    // Transform normal to VIEW space (camera-relative)\n    // This keeps the moon phase shadow fixed relative to camera view\n    // When you rotate the moon, the texture rotates but the phase shadow stays put\n    vViewNormal = normalize(normalMatrix * normal);\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPosition.xyz;\n    vec4 viewPosition = viewMatrix * worldPosition;\n    vViewPosition = viewPosition.xyz;\n    gl_Position = projectionMatrix * viewPosition;\n}\n",fragmentShader:mm},l=new Cs({uniforms:{colorMap:{value:null},normalMap:{value:null},shadowOffset:{value:new je(0,0)},shadowCoverage:{value:.5},shadowSoftness:{value:.05},glowColor:{value:n},glowIntensity:{value:s},opacity:{value:0},eclipseProgress:{value:0},eclipseIntensity:{value:0},bloodMoonColor:{value:[.85,.18,.08]},emissiveStrength:{value:.39},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:1.2},eclipseShadowColor:{value:[1,.58,0]},eclipseMidtoneColor:{value:[.71,.43,.03]},eclipseHighlightColor:{value:[1,.28,.1]},eclipseGlowColor:{value:[.09,.09,.09]},eclipseBrightnessModel:{value:0},shadowDarkness:{value:.53},layer1Mode:{value:9},layer1Strength:{value:.322},layer1Enabled:{value:1},layer2Mode:{value:0},layer2Strength:{value:2.785},layer2Enabled:{value:1},layer3Mode:{value:7},layer3Strength:{value:.199},layer3Enabled:{value:1},layer4Mode:{value:0},layer4Strength:{value:0},layer4Enabled:{value:0}},vertexShader:r,fragmentShader:o,transparent:!0,depthWrite:!0,side:0}),h=`${a}/textures/Moon/moon-color-${i}.jpg`,c=`${a}/textures/Moon/moon-normal-${i}.jpg`;return t.load(h,t=>{l.uniforms.colorMap.value=t;const e=performance.now(),i=()=>{const t=performance.now()-e,n=Math.min(t/300,1);l.uniforms.opacity.value=n,l.needsUpdate=!0,n<1&&requestAnimationFrame(i)};i()}),t.load(c,t=>{l.uniforms.normalMap.value=t}),l}const Bm=`\n/**\n * Sun Fragment Shader with Blend Layers and Solar Eclipse\n *\n * Supports solar eclipse effects with moon's shadow darkening the sun\n * and up to 4 sequential blend mode layers for eclipse appearance adjustment\n */\n\nuniform float time;\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec3 baseColor;\nuniform float emissiveIntensity;\nuniform vec2 shadowOffset;\nuniform float shadowCoverage;\nuniform float shadowSoftness;\nuniform float opacity;\n\n// Solar Eclipse uniforms (moon's shadow covering sun)\nuniform float eclipseProgress;        // Eclipse progress (0 = no eclipse, 1 = totality)\nuniform vec2 eclipseShadowPos;        // Shadow center position in UV space\nuniform float eclipseShadowRadius;    // Moon's shadow radius\nuniform float shadowDarkness;         // How much to darken the sun (0-1)\n\n// Blend Layer Uniforms (up to 4 layers)\nuniform float layer1Mode;\nuniform float layer1Strength;\nuniform float layer1Enabled;\n\nuniform float layer2Mode;\nuniform float layer2Strength;\nuniform float layer2Enabled;\n\nuniform float layer3Mode;\nuniform float layer3Strength;\nuniform float layer3Enabled;\n\nuniform float layer4Mode;\nuniform float layer4Strength;\nuniform float layer4Enabled;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;  // View-space position (camera-relative)\n\n// \n// UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n// \n${cm}\n\n// \n// SIMPLEX NOISE (for fire animation - from original sun shader)\n// \nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nvoid main() {\n    // \n    // BASE SUN RENDERING (photosphere texture + fire animation)\n    // \n\n    // Sample base photosphere texture\n    vec4 texColor = texture2D(colorMap, vUv);\n\n    // Optimized single-octave noise for subtle fire\n    vec3 noiseCoord = vPosition * 30.0 + vec3(0.0, time * 0.025, 0.0);\n    float fireNoise = snoise(noiseCoord);\n\n    // Simple threshold - fire appears only in specific noise ranges\n    float fireMask = fireNoise * 0.5 + 0.5; // Remap -1..1 to 0..1\n    fireMask = step(0.45, fireMask) * (1.0 - step(0.55, fireMask)); // Only 0.45-0.55 range\n\n    // Almost imperceptible warmth shift\n    vec3 fireColor = vec3(1.01, 1.0, 0.99);\n\n    // Microscopic blending\n    vec3 finalColor = mix(texColor.rgb, fireColor, fireMask * 0.008);\n\n    // Apply base color tinting\n    finalColor *= baseColor;\n\n    // Apply emissive intensity for HDR bloom\n    finalColor *= emissiveIntensity;\n\n    // \n    // LIMB DARKENING (realistic solar effect - edges appear darker than center)\n    // \n\n    // Calculate distance from center (0 at center, 1 at edge)\n    float distFromCenterLimb = length(vWorldPosition.xy) / 0.5; // normalize by sun radius (0.5)\n    distFromCenterLimb = clamp(distFromCenterLimb, 0.0, 1.0);\n\n    // Limb darkening formula: I() = 1 - u*(1-) where  = cos(viewing angle)\n    // Simplified using distance: darker at edges, brighter at center\n    float mu = sqrt(1.0 - distFromCenterLimb * distFromCenterLimb); // cos approximation\n    // EXTREME limb darkening for visibility\n    float limbDarkeningCoeff = 0.98; // 98% darkening at edges\n    float limbBrightness = 1.0 - limbDarkeningCoeff * (1.0 - mu);\n    limbBrightness = pow(limbBrightness, 0.4); // Very aggressive power curve\n\n    // Clamp to prevent over-darkening\n    limbBrightness = max(limbBrightness, 0.02); // Edges at least 2% brightness\n\n    // Apply limb darkening (BEFORE bloom processing)\n    finalColor *= limbBrightness;\n\n    // \n    // SOLAR ECLIPSE EFFECT (Moon Occulting Sun)\n    // \n    // Solar eclipse: Moon passes BETWEEN viewer and sun, blocking our view\n    // The moon appears as a dark circular disk that covers parts of the sun\n    // From Earth, moon and sun appear same angular size (0.5)\n\n    // Only apply eclipse if there's a moon to occlude (radius > 0)\n    if (eclipseShadowRadius > 0.01) {\n        // Only occlude FRONT-FACING parts of the sun (vViewPosition.z < 0 faces camera in view space)\n        // Back of sun should not be affected by moon\n        if (vViewPosition.z < 0.1) {\n            // Project to screen space - camera-relative, independent of sun rotation\n            // vViewPosition.xy is already in camera space, just normalize to sun radius\n            // Sun radius in view space is approximately 0.5 at typical camera distance\n            vec2 screenPos = vViewPosition.xy;\n\n            // Moon center position in screen space (same coordinate system)\n            vec2 moonCenter = eclipseShadowPos;\n\n            // Distance from this sun point to moon center (2D screen space)\n            float distToMoon = length(screenPos - moonCenter);\n\n            // Moon's angular size (appears same size as sun from Earth)\n            // In normalized screen space, sun radius = 1.0, moon radius = 1.0 for total eclipse\n            float moonRadius = eclipseShadowRadius;\n            float moonEdge = 0.01; // Sharp edge for moon silhouette\n\n            // Check if moon blocks this point (moon is in front of sun)\n            float moonOcclusion = 1.0 - smoothstep(moonRadius - moonEdge, moonRadius + moonEdge, distToMoon);\n\n            // Only apply if moon is actually occluding something\n            if (moonOcclusion > 0.001) {\n                // Moon completely blocks sun where it overlaps (no light gets through)\n                finalColor *= (1.0 - moonOcclusion);\n\n                // Subtle penumbra around moon edge (diffraction)\n                float penumbraRadius = moonRadius * 1.02;\n                float penumbraEdge = 0.03;\n                float penumbra = 1.0 - smoothstep(penumbraRadius - penumbraEdge, penumbraRadius + penumbraEdge, distToMoon);\n                float penumbraBlocking = (penumbra - moonOcclusion) * 0.2;\n                finalColor *= (1.0 - penumbraBlocking);\n            }\n        }\n    }\n\n    // \n    // BLEND LAYERS (Applied globally to entire sun)\n    // These allow adjusting the appearance of the sun\n    // \n\n    // Layer 1\n    if (layer1Enabled > 0.5) {\n        vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n        int mode1 = int(layer1Mode + 0.5);\n        vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n        finalColor = clamp(blended1, 0.0, 1.0);\n    }\n\n    // Layer 2\n    if (layer2Enabled > 0.5) {\n        vec3 blendColor2 = vec3(min(layer2Strength, 1.0));\n        int mode2 = int(layer2Mode + 0.5);\n        vec3 blended2 = clamp(applyBlendMode(finalColor, blendColor2, mode2), 0.0, 1.0);\n        finalColor = clamp(blended2, 0.0, 1.0);\n    }\n\n    // Layer 3\n    if (layer3Enabled > 0.5) {\n        vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n        int mode3 = int(layer3Mode + 0.5);\n        vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n        finalColor = clamp(blended3, 0.0, 1.0);\n    }\n\n    // Layer 4\n    if (layer4Enabled > 0.5) {\n        vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n        int mode4 = int(layer4Mode + 0.5);\n        vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n        finalColor = clamp(blended4, 0.0, 1.0);\n    }\n\n    // Apply fade-in opacity to prevent texture flash during load\n    gl_FragColor = vec4(finalColor, opacity);\n}\n`,Lm={baseSpeed:.01,axes:[0,1,0]};function km(t,e={}){const i=e.resolution||"4k",n=e.glowColor||[1,1,1],s=e.glowIntensity||1,a=e.materialVariant||null,r=e.assetBasePath||"/assets",o=`${r}/textures/Sun/sun-photosphere-${i}.jpg`,l=`${r}/textures/Sun/sun-photosphere-normal-${i}.jpg`,h=1+2*s,c=new zn(h*n[0],h*n[1],h*n[2]*.95),u=new Map;u.set(o,{texture:null});const d=t.load(o,t=>{y.uniforms?.opacity&&(y.uniforms.opacity.value=1);const e=u.get(o);e&&(e.texture=t),u.delete(o)},void 0,t=>{console.warn(` Failed to load sun texture (${i}), using color fallback:`,t),u.delete(o)});u.set(l,{texture:null});const p=t.load(l,t=>{const e=u.get(l);e&&(e.texture=t),u.delete(l)},void 0,t=>{console.warn(` Sun normal map not found (${i}), continuing without surface detail:`,t),u.delete(l)});let m,g;d.wrapS=d.wrapT=N,p.wrapS=p.wrapT=N,d.anisotropy=16,p.anisotropy=16;let f={};if("multiplexer"===a){const{vertexShader:t,fragmentShader:e}={vertexShader:"\n/**\n * Sun Vertex Shader\n * Passes view-space position for camera-relative eclipse shadow calculations\n */\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;  // View-space position (camera-relative)\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalize(normalMatrix * normal);\n    vPosition = position;\n    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\n    // Calculate view-space position (camera-relative, always faces camera)\n    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n    vViewPosition = viewPos.xyz;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:Bm};m=t,g=e,f={eclipseProgress:{value:0},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:.882},shadowDarkness:{value:1},layer1Mode:{value:0},layer1Strength:{value:.23},layer1Enabled:{value:1},layer2Mode:{value:0},layer2Strength:{value:0},layer2Enabled:{value:0},layer3Mode:{value:0},layer3Strength:{value:0},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:0},layer4Enabled:{value:0}}}else m="\n            varying vec2 vUv;\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n\n            void main() {\n                vUv = uv;\n                vNormal = normalize(normalMatrix * normal);\n                vPosition = position;\n                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",g="\n            uniform float time;\n            uniform sampler2D colorMap;\n            uniform sampler2D normalMap;\n            uniform vec3 baseColor;\n            uniform float emissiveIntensity;\n            uniform vec2 shadowOffset;\n            uniform float shadowCoverage;\n            uniform float shadowSoftness;\n            uniform float opacity;  // Fade in opacity (0-1) to prevent texture flash\n\n            varying vec2 vUv;\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n\n            // Simplex noise for fire animation (Ashima Arts)\n            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n            float snoise(vec3 v) {\n                const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n                vec3 i  = floor(v + dot(v, C.yyy));\n                vec3 x0 = v - i + dot(i, C.xxx);\n\n                vec3 g = step(x0.yzx, x0.xyz);\n                vec3 l = 1.0 - g;\n                vec3 i1 = min(g.xyz, l.zxy);\n                vec3 i2 = max(g.xyz, l.zxy);\n\n                vec3 x1 = x0 - i1 + C.xxx;\n                vec3 x2 = x0 - i2 + C.yyy;\n                vec3 x3 = x0 - D.yyy;\n\n                i = mod289(i);\n                vec4 p = permute(permute(permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n                float n_ = 0.142857142857;\n                vec3 ns = n_ * D.wyz - D.xzx;\n\n                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n                vec4 x_ = floor(j * ns.z);\n                vec4 y_ = floor(j - 7.0 * x_);\n\n                vec4 x = x_ *ns.x + ns.yyyy;\n                vec4 y = y_ *ns.x + ns.yyyy;\n                vec4 h = 1.0 - abs(x) - abs(y);\n\n                vec4 b0 = vec4(x.xy, y.xy);\n                vec4 b1 = vec4(x.zw, y.zw);\n\n                vec4 s0 = floor(b0)*2.0 + 1.0;\n                vec4 s1 = floor(b1)*2.0 + 1.0;\n                vec4 sh = -step(h, vec4(0.0));\n\n                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n                vec3 p0 = vec3(a0.xy, h.x);\n                vec3 p1 = vec3(a0.zw, h.y);\n                vec3 p2 = vec3(a1.xy, h.z);\n                vec3 p3 = vec3(a1.zw, h.w);\n\n                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n                p0 *= norm.x;\n                p1 *= norm.y;\n                p2 *= norm.z;\n                p3 *= norm.w;\n\n                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                m = m * m;\n                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n            }\n\n            void main() {\n                // Sample base photosphere texture\n                vec4 texColor = texture2D(colorMap, vUv);\n\n                // Optimized single-octave noise for subtle fire (was 2 FBM calls with 3 octaves each)\n                // Using position-based noise with time offset for animation\n                vec3 noiseCoord = vPosition * 30.0 + vec3(0.0, time * 0.025, 0.0);\n                float fireNoise = snoise(noiseCoord);\n\n                // Simple threshold - fire appears only in specific noise ranges\n                // Using step functions instead of smoothstep for performance\n                float fireMask = fireNoise * 0.5 + 0.5; // Remap -1..1 to 0..1\n                fireMask = step(0.45, fireMask) * (1.0 - step(0.55, fireMask)); // Only 0.45-0.55 range\n\n                // Almost imperceptible warmth shift (same visual as before)\n                vec3 fireColor = vec3(1.01, 1.0, 0.99);\n\n                // Microscopic blending - nearly invisible (same blend factor)\n                vec3 finalColor = mix(texColor.rgb, fireColor, fireMask * 0.008);\n\n                // Apply base color tinting\n                finalColor *= baseColor;\n\n                // Apply emissive intensity for HDR bloom\n                finalColor *= emissiveIntensity;\n\n                // \n                // LIMB DARKENING (realistic solar effect - edges appear darker than center)\n                // \n\n                // Calculate distance from center (0 at center, 1 at edge)\n                float distFromCenterLimb = length(vWorldPosition.xy) / 0.5; // normalize by sun radius (0.5)\n                distFromCenterLimb = clamp(distFromCenterLimb, 0.0, 1.0);\n\n                // Limb darkening formula: I() = 1 - u*(1-) where  = cos(viewing angle)\n                // Simplified using distance: darker at edges, brighter at center\n                float mu = sqrt(1.0 - distFromCenterLimb * distFromCenterLimb); // cos approximation\n                float limbDarkeningCoeff = 0.6; // NASA solar data: ~60% darkening at limb\n                float limbBrightness = 1.0 - limbDarkeningCoeff * (1.0 - mu);\n\n                // Apply limb darkening (preserves bright core for bloom)\n                finalColor *= limbBrightness;\n\n                // \n                // SHADOW DARKENING (applied AFTER bloom intensity so it doesn't affect bloom)\n                // \n\n                // Sun sphere center (world space origin)\n                float sunRadius = 0.5; // Matches geometry radius\n\n                // Shadow sphere center (offset from sun center)\n                vec3 shadowCenter = vec3(shadowOffset.x, shadowOffset.y, 0.0);\n\n                // Calculate distance from fragment to shadow sphere center\n                float distToShadow = distance(vWorldPosition, shadowCenter);\n\n                // Shadow threshold (shadow sphere radius adjusted by coverage)\n                float shadowRadius = sunRadius * shadowCoverage;\n\n                // Calculate shadow factor (0 = full shadow, 1 = no shadow)\n                float shadowFactor = smoothstep(shadowRadius - shadowSoftness, shadowRadius + shadowSoftness, distToShadow);\n\n                // Darken ONLY the final color output (not the bloom calculation)\n                float shadowDarkness = 0.05; // How dark the shadow gets (5% brightness)\n                finalColor *= mix(shadowDarkness, 1.0, shadowFactor);\n\n                // \n                // RADIAL CORONA WAVES (applied AFTER shadow, visible around eclipse edge)\n                // \n\n                // Calculate angle from sun center in world space XY plane\n                float angle = atan(vWorldPosition.y, vWorldPosition.x);\n\n                // Create radial wave pattern (16 petals for finer detail, rotating slowly)\n                float wave = sin(angle * 16.0 + time * 0.3) * 0.5 + 0.5;\n\n                // Apply waves to visible (non-shadowed) edges\n                float distFromCenter = length(vWorldPosition.xy);\n\n                // Edge factor: strong at sun's edge where bloom will amplify it\n                float edgeFactor = smoothstep(0.35, 0.5, distFromCenter);\n\n                // Only apply waves to non-shadowed areas (visible during eclipse)\n                // Combine with shadow factor so waves appear around shadow edge\n                float waveStrength = edgeFactor * shadowFactor;\n\n                // Very strong modulation (2x variation) for dramatic eclipse corona\n                float coronaModulation = 1.0 + (wave * 2.0 - 1.0) * waveStrength;\n                finalColor *= coronaModulation;\n\n                // Apply fade-in opacity to prevent texture flash during load\n                gl_FragColor = vec4(finalColor, opacity);\n            }\n        ";const y=new Cs({uniforms:{time:{value:0},colorMap:{value:d},normalMap:{value:p},baseColor:{value:c},emissiveIntensity:{value:1.2},glowColor:{value:new zn(1,1,1)},glowIntensity:{value:1},shadowOffset:{value:new je(200,0)},shadowCoverage:{value:.5},shadowSoftness:{value:.1},opacity:{value:0},...f},vertexShader:m,fragmentShader:g,transparent:!0,toneMapped:!1});return y.userData.uniforms=y.uniforms,y.userData.pendingTextures=u,y}function Om(t=null,e={}){const i=e.glowColor||[1,1,1],n=e.glowIntensity||1,s=e.resolution||"4k",a=e.materialVariant||null,r=new tl(.5,128,128);let o;if(r.userData.tracked=!0,t)o=km(t,{glowColor:i,glowIntensity:n,resolution:s,materialVariant:a});else{const t=1+2*n,e=new zn(t*i[0],t*i[1],t*i[2]*.95);o=new Gn({color:e,toneMapped:!1})}const l=new bs(r,o);return l.castShadow=!1,l.receiveShadow=!1,l}function zm(t,e,i=1,n=0){if(!t||!t.material)return;const{material:s}=t;if(s.uniforms&&s.uniforms.baseColor){const{uniforms:t}=s;n>0&&(t.time.value=(t.time.value+n)%(2*Math.PI));const e=1+2*i;t.baseColor.value.setRGB(e,e,.95*e),t.emissiveIntensity.value=1.2}else if(s.color){const t=1+2*i;s.color.setRGB(t,t,.95*t)}}function Fm(t){if(t&&(t.geometry&&t.geometry.dispose(),t.material)){const{material:e}=t;e.userData&&e.userData.pendingTextures&&(e.userData.pendingTextures.forEach(({texture:t})=>{t&&t.dispose()}),e.userData.pendingTextures.clear()),e.uniforms&&(e.uniforms.colorMap&&e.uniforms.colorMap.value&&e.uniforms.colorMap.value.dispose(),e.uniforms.normalMap&&e.uniforms.normalMap.value&&e.uniforms.normalMap.value.dispose()),e.map&&e.map.dispose(),e.normalMap&&e.normalMap.dispose(),e.dispose()}}function Um(){const t=new tl(.5,32,32),e=t.attributes.position;for(let t=0;t<e.count;t++){let i=e.getX(t);const n=e.getY(t);let s=e.getZ(t);const a=1+.3*Math.max(0,n);if(i*=a,s*=.8*a,n<-.3){const t=(-n-.3)/.2;i*=1-.8*t,s*=1-.8*t}e.setXYZ(t,i,n,s)}return t.computeVertexNormals(),t}function Nm(){const t=new Gr(.5,0);return t.computeVertexNormals(),t}function Gm(){const t=new os,e=[],i=[];e.push(0,2.3,0);for(let t=0;t<6;t++){const i=t/6*Math.PI*2;e.push(1*Math.cos(i),1.5,1*Math.sin(i))}for(let t=0;t<6;t++){const i=t/6*Math.PI*2;e.push(1*Math.cos(i),-1.5,1*Math.sin(i))}e.push(0,-2.3,0);for(let t=0;t<6;t++){const e=(t+1)%6;i.push(0,1+t,1+e)}for(let t=0;t<6;t++){const e=(t+1)%6;i.push(1+t,7+t,1+e),i.push(1+e,7+t,7+e)}for(let t=0;t<6;t++){const e=(t+1)%6;i.push(13,7+e,7+t)}t.setAttribute("position",new Kn(e,3)),t.setIndex(i);const n=1.6/4.6;return t.scale(n,n,n),t.computeVertexNormals(),t}const Vm={moon:{geometry:xm(64,64),material:"custom",blink:{type:"gentle-pulse",duration:180,scaleAxis:[.95,.95,.95],glowBoost:.2,curve:"sine"},particleRadiusMultiplier:1.4},sun:{geometry:new tl(.5,64,64),material:"emissive",blink:{type:"radial-pulse",duration:200,scaleAxis:[1.05,1.05,1.05],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.5},crystal:{geometry:null,geometryLoader:function(t="/assets"){return new Promise((e,i)=>{(new hm).load(`${t}/models/Crystal/crystal.obj`,t=>{let i=null;if(t.traverse(t=>{t.isMesh&&t.geometry&&({geometry:i}=t)}),i){i.computeBoundingBox();const t=new qe;i.boundingBox.getCenter(t),i.translate(-t.x,-t.y,-t.z);const n=new qe;i.boundingBox.getSize(n);const s=1.6/Math.max(n.x,n.y,n.z);i.scale(s,s,s),i.attributes.normal||i.computeVertexNormals(),i.computeBoundingBox();const a=new qe;i.boundingBox.getSize(a);let r=i;r.computeVertexNormals(),e(r)}else{console.warn(" [CRYSTAL] No mesh in OBJ, using fallback");const t=Gm();e(t)}},t=>{},t=>{console.warn(" [CRYSTAL] OBJ load FAILED:",t);const i=Gm();e(i)})})},material:"custom",blink:{type:"facet-flash",duration:160,scaleAxis:[.95,.95,.95],glowBoost:.4,curve:"sine"},particleRadiusMultiplier:1.4},rough:{geometry:null,geometryLoader:function(t="/assets"){return new Promise(e=>{(new hm).load(`${t}/models/Crystal/rough.obj`,t=>{let i=null;if(t.traverse(t=>{t.isMesh&&t.geometry&&({geometry:i}=t)}),i){i.computeBoundingBox();const t=new qe;i.boundingBox.getCenter(t),i.translate(-t.x,-t.y,-t.z);const n=new qe;i.boundingBox.getSize(n);const s=1.6/Math.max(n.x,n.y,n.z);i.scale(s,s,s),i.computeVertexNormals(),i.computeBoundingBox(),e(i)}else console.warn(" [ROUGH] No mesh in OBJ, using fallback sphere"),e(new tl(.5,32,32))},void 0,t=>{console.warn(" [ROUGH] OBJ load failed:",t),e(new tl(.5,32,32))})})},material:"custom",blink:{type:"facet-flash",duration:150,scaleAxis:[.95,.95,.95],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.3},heart:{geometry:null,geometryLoader:function(t="/assets"){return new Promise(e=>{(new hm).load(`${t}/models/Crystal/heart.obj`,t=>{let i=null;if(t.traverse(t=>{t.isMesh&&t.geometry&&({geometry:i}=t)}),i){i.computeBoundingBox();const t=new qe;i.boundingBox.getCenter(t),i.translate(-t.x,-t.y,-t.z);const n=new qe;i.boundingBox.getSize(n);const s=1.2/Math.max(n.x,n.y,n.z);i.scale(s,s,s),i.computeVertexNormals(),i.computeBoundingBox(),i.attributes.uv||function(t){t.computeBoundingBox();const e=t.boundingBox,i=t.attributes.position,n=new Float32Array(2*i.count),s=e.max.x-e.min.x,a=e.max.y-e.min.y;for(let t=0;t<i.count;t++){const r=i.getX(t),o=i.getY(t);n[2*t]=(r-e.min.x)/s,n[2*t+1]=(o-e.min.y)/a}t.setAttribute("uv",new Zn(n,2))}(i),e(i)}else console.warn(" [HEART] No mesh in OBJ, using fallback"),e(Um())},void 0,t=>{console.warn(" [HEART] OBJ load failed:",t),e(Um())})})},material:"custom",blink:{type:"gentle-pulse",duration:180,scaleAxis:[.92,.92,.92],glowBoost:.6,curve:"sine"},particleRadiusMultiplier:1.3},star:{geometry:null,geometryLoader:function(t="/assets"){return new Promise(e=>{(new hm).load(`${t}/models/Crystal/star.obj`,t=>{let i=null;if(t.traverse(t=>{t.isMesh&&t.geometry&&({geometry:i}=t)}),i){i.computeBoundingBox();const t=new qe;i.boundingBox.getCenter(t),i.translate(-t.x,-t.y,-t.z);const n=new qe;i.boundingBox.getSize(n);const s=1.4/Math.max(n.x,n.y,n.z);i.scale(s,s,s),i.computeVertexNormals(),i.computeBoundingBox(),i.attributes.uv||function(t){t.computeBoundingBox();const e=t.boundingBox,i=t.attributes.position,n=new Float32Array(2*i.count),s=e.max.x-e.min.x,a=e.max.y-e.min.y;for(let t=0;t<i.count;t++){const r=i.getX(t),o=i.getY(t);n[2*t]=(r-e.min.x)/s,n[2*t+1]=(o-e.min.y)/a}t.setAttribute("uv",new Zn(n,2))}(i),e(i)}else console.warn(" [STAR] No mesh in OBJ, using fallback"),e(Nm())},void 0,t=>{console.warn(" [STAR] OBJ load failed:",t),e(Nm())})})},material:"custom",blink:{type:"facet-flash",duration:150,scaleAxis:[.93,.93,.93],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.4}};class Hm{constructor(){this.currentAnimation=null,this.animations=[],this.time=0}playEmotion(t,e={}){const i=this.createEmotionAnimation(t);this.startAnimation(i,e)}playGesture(t,e={}){const i=this.createGestureAnimation(t);this.startAnimation(i,e)}playMorph(t,e,i={}){const n=this.createMorphAnimation(t,e);this.startAnimation(n,i)}update(t){this.time+=t;for(let t=this.animations.length-1;t>=0;t--){const e=this.animations[t],i=e.duration;Math.min((this.time-e.startTime)/i,1)>=1&&(e.callbacks&&e.callbacks.onComplete&&e.callbacks.onComplete(),this.animations.splice(t,1))}}createEmotionAnimation(t){const e={joy:{duration:.6,evaluate:t=>({scale:1+.15*Math.sin(t*Math.PI),glowIntensity:1+.15*Math.sin(t*Math.PI)})},love:{duration:1.2,evaluate:t=>({scale:1+.08*Math.sin(t*Math.PI*2),glowIntensity:1+.1*Math.sin(t*Math.PI*2)})},curiosity:{duration:.8,evaluate:t=>({rotation:[0,.1*Math.sin(t*Math.PI*4),0],scale:1+.05*Math.sin(t*Math.PI),glowIntensity:1})},sadness:{duration:1.5,evaluate:t=>({scale:1-.1*t,glowIntensity:1-.15*Math.sin(t*Math.PI)})},anger:{duration:.4,evaluate:t=>{const e=.15*Math.sin(t*Math.PI*8);return{rotation:[e,e,0],scale:1.1+.1*Math.sin(t*Math.PI),glowIntensity:1+.15*Math.sin(t*Math.PI*8)}}},fear:{duration:.5,evaluate:t=>{const e=.08*Math.sin(t*Math.PI*10);return{scale:.9+e,rotation:[e,0,e],glowIntensity:1+.1*Math.sin(t*Math.PI*10)}}},surprise:{duration:.4,evaluate:t=>({scale:1+.25*(1-Math.cos(t*Math.PI)),glowIntensity:1+.2*(1-Math.cos(t*Math.PI))})},neutral:{duration:.5,evaluate:t=>({scale:1,glowIntensity:1})}};return e[t]||e.neutral}createGestureAnimation(t){const e={pop:{duration:.2,isAccent:!0,evaluate:t=>({scaleBoost:1+.025*Math.sin(t*Math.PI)})},bob:{duration:.25,isAccent:!0,evaluate:t=>({rotationBoost:[.025*Math.sin(t*Math.PI),0,0]})},swell:{duration:.6,isAccent:!0,evaluate:t=>{const e=Math.sin(t*Math.PI),i=1-Math.pow(1-e,2);return{scaleBoost:1+.04*i,glowBoost:.3*i}}},swagger:{duration:.4,isAccent:!0,evaluate:t=>{const e=Math.sin(t*Math.PI);return{rotationBoost:[0,0,.04*e],positionBoost:[.01*e,0,0]}}},dip:{duration:.25,isAccent:!0,evaluate:t=>{const e=Math.sin(t*Math.PI);return{positionBoost:[0,.015*-e,0],scaleBoost:1-.015*e}}},flare:{duration:.3,isAccent:!0,evaluate:t=>{const e=Math.sin(t*Math.PI);return{scaleBoost:1+.03*e,glowBoost:.25*e}}},bounce:{duration:1,evaluate:t=>{const e=t*Math.PI*2,i=1-.6*t,n=Math.sin(e)*i,s=Math.sin(2*e)*i*.3,a=Math.max(0,n+s);return{position:[0,.35*a,0],scale:a>.5?1+.05*a:1-.08*a}}},pulse:{duration:.6,evaluate:t=>{const e=Math.sin(t*Math.PI);return{scale:1+.2*e,glowIntensity:1+.5*e}}},spin:{duration:1,evaluate:t=>({rotation:[0,t*Math.PI*2,0]})},wobble:{duration:1,evaluate:t=>{const e=Math.sin(t*Math.PI*3);return{rotation:[.3*e,0,.2*e]}}},float:{duration:2,evaluate:t=>({position:[0,.3*Math.sin(t*Math.PI),0]})},shake:{duration:.5,evaluate:t=>{const e=Math.sin(t*Math.PI*6)*(1-t);return{position:[.2*e,0,0],rotation:[0,0,.1*e]}}},nod:{duration:.5,evaluate:t=>{let e=0;if(t<.4){const i=t/.4;e=.12*Math.sin(i*Math.PI)}else if(t<.8){const i=(t-.4)/.4;e=.07*Math.sin(i*Math.PI)}return{cameraRelativePosition:[0,0,e],scale:1-.3*Math.abs(e),glowIntensity:1+.5*Math.abs(e)}}},wiggle:{duration:.4,evaluate:t=>{const e=Math.pow(1-t,.6),i=Math.sin(t*Math.PI*12)*e;return{cameraRelativePosition:[.04*i,0,0],scale:1+.03*Math.abs(i),glowIntensity:1+.1*Math.abs(i)}}},headBob:{duration:.3,evaluate:t=>{const e=t<.15?t/.15:Math.pow(1-(t-.15)/.85,2);return{cameraRelativePosition:[0,0,.08*e],position:[0,.015*-e,0],scale:1-.05*e,glowIntensity:1+.15*e}}},sway:{duration:1.2,evaluate:t=>{const e=t<.15?t/.15*t/.15:t>.85?Math.pow((1-t)/.15,2):1,i=Math.sin(t*Math.PI*2)*e;return{rotation:[0,0,.12*i],position:[.06*i,0,0]}}},jump:{duration:.6,evaluate:t=>({position:[0,.4*Math.sin(t*Math.PI),0],scale:t<.1?1-3*t:t>.9?1-3*(1-t):1})},twist:{duration:.5,evaluate:t=>({rotation:[0,Math.sin(t*Math.PI*2)*(1-.5*t)*.3,0]})},hula:{duration:1,evaluate:t=>{const e=t*Math.PI*2;return{position:[.05*Math.sin(e),0,.03*Math.cos(e)],rotation:[0,0,.05*Math.sin(e)]}}},lean:{duration:.6,evaluate:t=>{const e=Math.sin(t*Math.PI);return{rotation:[0,0,.15*e],position:[.04*e,.01*-Math.abs(e),0]}}},tilt:{duration:.5,evaluate:t=>{const e=Math.sin(t*Math.PI);return{position:[0,0,.05*e],rotation:[.08*e,0,0]}}},twitch:{duration:.2,evaluate:t=>{const e=(1-t)*Math.sin(t*Math.PI*6);return{rotation:[.03*e,.03*e,0]}}},flash:{duration:.3,evaluate:t=>{const e=t<.2?t/.2:1-(t-.2)/.8;return{glowIntensity:1+.4*e,scale:1+.03*e}}},glow:{duration:.8,evaluate:t=>{const e=Math.sin(t*Math.PI);return{glowIntensity:1+.25*e,scale:1+.02*e}}},burst:{duration:.6,evaluate:t=>{let e=0,i=1,n=1;if(t<.15){const s=t/.15,a=1-Math.pow(1-s,3);e=.15*a,i=1+.2*a,n=1+.5*a}else if(t<.35){const s=(t-.15)/.2;e=.15*(1-1.5*s),i=1+.2*(1-s)-.1*Math.sin(s*Math.PI),n=1+.4*(1-s)}else{const s=(t-.35)/.65,a=Math.pow(1-s,2),r=Math.sin(s*Math.PI*2)*a;e=.03*r,i=1+.05*r,n=1+.15*Math.abs(r)}return{cameraRelativePosition:[0,0,e],scale:i,glowIntensity:n}}},flicker:{duration:.6,evaluate:t=>{const e=Math.sin(t*Math.PI),i=Math.sin(t*Math.PI*4)*e;return{glowIntensity:1+.15*i,scale:1+.01*i}}}};return e[t]||e.pulse}createMorphAnimation(t,e){return{duration:1,fromShape:t,toShape:e,evaluate:t=>({morphProgress:t,scale:1+.1*Math.sin(t*Math.PI),rotation:[0,t*Math.PI*.5,0]})}}startAnimation(t,e){this.animations.push({...t,startTime:this.time,callbacks:e||{}}),this.currentAnimation=t}stopAll(){this.animations=[],this.currentAnimation=null}destroy(){this.stopAll(),this.animations=null,this.currentAnimation=null,this.time=0}easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}getIdleAnimation(){return{duration:3,loop:!0,evaluate:t=>{const e=Math.sin(t*Math.PI*2),i=Math.sin(t*Math.PI);return{scale:1+.02*e,position:[.05*i,.03*e,0],rotation:[0,.05*i,0],glowIntensity:1+.1*e}}}}isPlaying(){return this.animations.length>0}}class Wm{constructor(){this.breathingSpeed=1,this.breathingDepth=.03,this.breathingPhase=0,this.breathRate=1,this.breathDepth=.03,this.breathRateMult=1,this.breathDepthMult=1,this.rhythmAdapter=null,this.grooveBlendFactor=.4,this.emotionBreathPatterns={happy:{rate:1.1,depth:1.2},sad:{rate:.8,depth:.7},angry:{rate:1.4,depth:1.3},calm:{rate:.7,depth:.9},excited:{rate:1.5,depth:1.4},focused:{rate:.9,depth:.6},neutral:{rate:1,depth:1},love:{rate:1.2,depth:1.3},surprised:{rate:1.3,depth:1.1},confused:{rate:1.1,depth:.9},amused:{rate:1.2,depth:1.1},bored:{rate:.6,depth:.8},tired:{rate:.5,depth:1.2},anxious:{rate:1.6,depth:.9},determined:{rate:1.1,depth:1},proud:{rate:.9,depth:1.3},content:{rate:.8,depth:1},hopeful:{rate:1,depth:1.1},zen:{rate:.4,depth:1.5},intrigued:{rate:1.1,depth:.8},embarrassed:{rate:1.3,depth:.7},grateful:{rate:.9,depth:1.1},inspired:{rate:1,depth:1.3},silly:{rate:1.4,depth:1.2},sleepy:{rate:.3,depth:1.4}}}update(t,e,i=null){const n=this.emotionBreathPatterns[e]||{rate:1,depth:1};i&&i["3d"]&&i["3d"].scale?(this.breathRateMult=i["3d"].scale.breathRateMultiplier||1,this.breathDepthMult=i["3d"].scale.breathDepthMultiplier||1):(this.breathRateMult=1,this.breathDepthMult=1),this.breathRate=n.rate*this.breathRateMult,this.breathDepth=this.breathingDepth*n.depth*this.breathDepthMult;const s=this.breathingSpeed*this.breathRate*(t/1e3);this.breathingPhase+=s,this.breathingPhase>2*Math.PI&&(this.breathingPhase-=2*Math.PI)}setRhythmAdapter(t){this.rhythmAdapter=t}getBreathingScale(){const t=this.rhythmAdapter?.isPlaying?.()?this.grooveBlendFactor:1;return 1+Math.sin(this.breathingPhase)*this.breathDepth*t}setEmotion(t,e=null){const i=this.emotionBreathPatterns[t]||{rate:1,depth:1};e&&e["3d"]&&e["3d"].scale?(this.breathRateMult=e["3d"].scale.breathRateMultiplier||1,this.breathDepthMult=e["3d"].scale.breathDepthMultiplier||1):(this.breathRateMult=1,this.breathDepthMult=1),this.breathRate=i.rate*this.breathRateMult,this.breathDepth=this.breathingDepth*i.depth*this.breathDepthMult}reset(){this.breathingPhase=0,this.breathRate=1,this.breathDepth=this.breathingDepth,this.breathRateMult=1,this.breathDepthMult=1}getBreathingInfo(){return{phase:this.breathingPhase,rate:this.breathRate,depth:this.breathDepth,scale:this.getBreathingScale(),rateMult:this.breathRateMult,depthMult:this.breathDepthMult}}destroy(){this.emotionBreathPatterns=null,this.rhythmAdapter=null}}class jm{constructor(){this.tempEuler=new tn,this.tempQuat=new Xe,this.accumulatedRotationQuat=new Xe,this.finalQuaternion=new Xe,this.prevRotation=[0,0,0],this.hasValidPrevRotation=!1}blend(t,e,i,n,s){this.accumulatedRotationQuat.identity();const a={position:[0,0,0],rotationQuat:this.accumulatedRotationQuat,scale:1,nonUniformScale:[1,1,1],glowIntensity:1,glowBoost:0,cameraRelativePosition:[0,0,0],cameraRelativeRotation:[0,0,0],positionBoost:[0,0,0],rotationBoost:[0,0,0],scaleBoost:1,hasAccentGestures:!1,hasAbsoluteGestures:!1,hasCameraRelativeGestures:!1,freezeRotation:0,freezeWobble:0,freezeGroove:0,freezeParticles:0,deformation:null,shatter:null};for(const i of t)if(i.evaluate){const t=e-i.startTime,n=i.duration,s=Math.min(t/n,1),r=i.evaluate(s);if(r){const t=.15,e=.85;let n=1;if(s<t){const e=s/t;n=e*e*(3-2*e)}else if(s>e){const t=(s-e)/(1-e);n=1-t*t*(3-2*t)}if(!0===i.isAccent?a.hasAccentGestures=!0:(r.position||r.rotation||void 0!==r.scale)&&(a.hasAbsoluteGestures=!0),r.position&&(a.position[0]+=r.position[0]*n,a.position[1]+=r.position[1]*n,a.position[2]+=r.position[2]*n),r.rotation&&(this.tempEuler.set(r.rotation[0]*n,r.rotation[1]*n,r.rotation[2]*n,"XYZ"),this.tempQuat.setFromEuler(this.tempEuler),a.rotationQuat.multiply(this.tempQuat)),void 0!==r.scale)if(Array.isArray(r.scale)){const t=1+(r.scale[0]-1)*n,e=1+(r.scale[1]-1)*n,i=1+(r.scale[2]-1)*n;a.nonUniformScale[0]*=t,a.nonUniformScale[1]*=e,a.nonUniformScale[2]*=i}else{const t=1+(r.scale-1)*n;a.scale*=t}if(void 0!==r.glowIntensity&&(a.glowIntensity*=r.glowIntensity),void 0!==r.glowBoost&&(a.glowBoost+=r.glowBoost),r.positionBoost&&(a.positionBoost[0]+=r.positionBoost[0],a.positionBoost[1]+=r.positionBoost[1],a.positionBoost[2]+=r.positionBoost[2]),r.rotationBoost&&(a.rotationBoost[0]+=r.rotationBoost[0],a.rotationBoost[1]+=r.rotationBoost[1],a.rotationBoost[2]+=r.rotationBoost[2]),void 0!==r.scaleBoost&&(a.scaleBoost*=r.scaleBoost),r.cameraRelativePosition&&(a.cameraRelativePosition[0]+=r.cameraRelativePosition[0]*n,a.cameraRelativePosition[1]+=r.cameraRelativePosition[1]*n,a.cameraRelativePosition[2]+=r.cameraRelativePosition[2]*n,a.hasCameraRelativeGestures=!0),r.cameraRelativeRotation&&(a.cameraRelativeRotation[0]+=r.cameraRelativeRotation[0]*n,a.cameraRelativeRotation[1]+=r.cameraRelativeRotation[1]*n,a.cameraRelativeRotation[2]+=r.cameraRelativeRotation[2]*n,a.hasCameraRelativeGestures=!0),void 0!==r.freezeRotation&&(a.freezeRotation=Math.max(a.freezeRotation,r.freezeRotation*n)),void 0!==r.freezeWobble&&(a.freezeWobble=Math.max(a.freezeWobble,r.freezeWobble*n)),void 0!==r.freezeGroove&&(a.freezeGroove=Math.max(a.freezeGroove,r.freezeGroove*n)),void 0!==r.freezeParticles&&(a.freezeParticles=Math.max(a.freezeParticles,r.freezeParticles*n)),r.deformation&&r.deformation.enabled){const t=r.deformation;(!a.deformation||t.strength>a.deformation.strength)&&(a.deformation={...t})}r.shatter&&(r.shatter.enabled&&!a.shatter&&(a.shatter={...r.shatter}),r.shatter.reassemble&&(a.shatter||(a.shatter={enabled:!1}),a.shatter.reassemble=!0,a.shatter.reassembleDuration=r.shatter.reassembleDuration||1e3))}}a.scaleBoost=Math.max(.85,Math.min(1.15,a.scaleBoost)),a.glowBoost=Math.min(.5,a.glowBoost);for(let t=0;t<3;t++)a.positionBoost[t]=Math.max(-.05,Math.min(.05,a.positionBoost[t]));for(let t=0;t<3;t++)a.rotationBoost[t]=Math.max(-.1,Math.min(.1,a.rotationBoost[t]));this.tempEuler.setFromQuaternion(a.rotationQuat,"XYZ");const r=this.tempEuler.x,o=this.tempEuler.y,l=this.tempEuler.z,h=[i[0]+r,i[1]+o,i[2]+l],c=n*a.scale,u=s*a.glowIntensity,d=1!==a.nonUniformScale[0]||1!==a.nonUniformScale[1]||1!==a.nonUniformScale[2]?[c*a.nonUniformScale[0],c*a.nonUniformScale[1],c*a.nonUniformScale[2]]:null;return{position:a.position,rotation:h,scale:c,nonUniformScale:d,glowIntensity:u,glowBoost:a.glowBoost,cameraRelativePosition:a.cameraRelativePosition,cameraRelativeRotation:a.cameraRelativeRotation,positionBoost:a.positionBoost,rotationBoost:a.rotationBoost,scaleBoost:a.scaleBoost,hasAccentGestures:a.hasAccentGestures,hasAbsoluteGestures:a.hasAbsoluteGestures,hasCameraRelativeGestures:a.hasCameraRelativeGestures,freezeRotation:a.freezeRotation,freezeWobble:a.freezeWobble,freezeGroove:a.freezeGroove,freezeParticles:a.freezeParticles,deformation:a.deformation,shatter:a.shatter,gestureQuaternion:a.rotationQuat}}resetSmoothing(){this.hasValidPrevRotation=!1,this.prevRotation&&(this.prevRotation[0]=0,this.prevRotation[1]=0,this.prevRotation[2]=0)}destroy(){this.tempEuler=null,this.tempQuat=null,this.accumulatedRotationQuat=null,this.finalQuaternion=null,this.prevRotation=null}}const Xm=new Map;var qm=function(t){return Xm.get(t)||null},Ym=function(){return Array.from(Xm.keys())},$m={name:"suspicion",emoji:"",description:"Paranoid watchfulness with surveillance scanning",visual:{glowColor:"#6B46C1",particleRate:4,minParticles:6,maxParticles:12,particleBehavior:"surveillance",particleSpeed:.2,breathRate:.6,breathDepth:.04,coreJitter:.02,blinkRate:1.1,blinkSpeed:1,particleColors:[{color:"#6B46C1",weight:30},{color:"#4A5568",weight:25},{color:"#8B4789",weight:20},{color:"#9F7AEA",weight:15},{color:"#2D3748",weight:10}],threatLevel:0,getGlowIntensity(){return.3+.7*this.threatLevel},getParticleSpeed(){return.2+.8*this.threatLevel},getGlowColor(){const t=this.threatLevel||0,e=Math.round(107+113*t),i=Math.round(70+-32*t),n=Math.round(193+-66*t),s=t=>t.toString(16).padStart(2,"0");return`#${s(e)}${s(i)}${s(n)}`}},modifiers:{speed:.4,amplitude:.6,intensity:1.2,smoothness:.3,regularity:.2,focus:1.5,addWobble:!0},typicalGestures:["scan","twitch","peek","tilt","hold"],transitions:{duration:500,easing:"linear",priority:4},special:{coreSquint:.6,scanInterval:2e3,scanDuration:1200,scanAngle:60,twitchChance:.02,peekInterval:4e3,maxThreatDistance:300,alertThreshold:.7},"3d":{rotation:{type:"suspicious",speed:1,axes:[0,0,0],musicSync:!1},glow:{color:"#6B46C1",intensity:.85,pulse:{speed:.6,range:[.7,1]}},scale:{base:1,breathe:{enabled:!0,depth:.04,rate:.6}}},soulAnimation:{driftSpeed:.9,shimmerSpeed:1.8,turbulence:.4}},Zm={name:"calm",emoji:"",description:"Serene, peaceful state with gentle movements",visual:{glowColor:"#66D9CC",particleRate:6,minParticles:10,maxParticles:50,particleBehavior:"zen",breathRate:.4,breathDepth:.12,coreJitter:!1,blinkRate:.8,blinkSpeed:1,particleColors:[{color:"#66D9CC",weight:35},{color:"#99E6D9",weight:25},{color:"#40BFB3",weight:20},{color:"#B3F2E6",weight:15},{color:"#339980",weight:5}]},modifiers:{speed:.5,amplitude:.3,intensity:.4,smoothness:2,regularity:1.5,addWeight:!1,floatHeight:.2,swayAmount:.15,duration:1.5},typicalGestures:["breathe","float","drift","idle"],transitions:{duration:800,easing:"easeInOutSine",priority:1},movement:{floatPattern:"sine_slow",floatPeriod:6e3,floatAmplitude:8,swayPattern:"gentle",swayPeriod:8e3,swayAmplitude:5,microMovements:!1},getCoreParams(t){const e=t.time||Date.now(),i=.5*Math.sin(6e-4*e)+.5;return{scaleX:1-.02*i,scaleY:1-.02*i,eyeOpenness:.85,eyeExpression:"serene",pupilOffset:{x:2*Math.sin(3e-4*e),y:1*Math.cos(4e-4*e)},glowPulse:.95+.05*i}},updateParticle(t,e){t.x+=.1*Math.sin(.001*t.life),t.y-=.02*e,t.opacity=.3*Math.sin(.002*t.life)+.2,t.size=t.baseSize*(1+.2*Math.sin(.001*t.life))},renderCore:(t,e,i,n)=>!1,"3d":{rotation:{type:"gentle",speed:.5,axes:[0,.3,0],musicSync:!0},glow:{color:"#66D9CC",intensity:.6,pulse:{speed:.4,range:[.5,.7]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.4}}},soulAnimation:{driftSpeed:.3,shimmerSpeed:.4,turbulence:.1}};const Jm=new Map,Qm={happy:"joy",peaceful:"calm",curious:"surprise",frustrated:"anger",sad:"sadness",excitement:"excited"};function Km(t){const e=Qm[t]||t,i=Jm.get(e);if(i)return i;return qm(e)||null}function tg(t){const e=Km(t);if(!e)return Km("neutral").visual;if(!e.visual)return{};const{visual:i}=e,n={};for(const t in i)"function"!=typeof i[t]&&(n[t]=i[t]);return"function"==typeof i.getGlowIntensity&&(n.glowIntensity=i.getGlowIntensity()),"function"==typeof i.getParticleSpeed&&(n.particleSpeed=i.getParticleSpeed()),"function"==typeof i.getParticleRate&&(n.particleRate=i.getParticleRate()),"function"==typeof i.getGlowColor&&(n.glowColor=i.getGlowColor()),n}function eg(t){const e=Km(t);return e?e.modifiers:Km("neutral").modifiers}function ig(){return[...Array.from(Jm.keys()),...Ym()]}function ng(t,e){const i=Km(t),n=Km(e);return i&&n?n.transitions&&n.transitions[t]?n.transitions[t]:{duration:1e3,easing:"ease-in-out",gesture:n.transitions?.defaultGesture||null}:{duration:1e3,easing:"ease-in-out"}}[{name:"neutral",emoji:"",description:"Calm, balanced emotional state",visual:{glowColor:"#00BCD4",particleRate:2,minParticles:8,maxParticles:10,particleBehavior:"ambient",breathRate:1,breathDepth:.08,coreJitter:!1,blinkRate:1,blinkSpeed:1,particleColors:[{color:"#00BCD4",weight:25},{color:"#00ACC1",weight:20},{color:"#26C6DA",weight:15},{color:"#B2EBF2",weight:15},{color:"#0097A7",weight:10},{color:"#80DEEA",weight:10},{color:"#E0F7FA",weight:5}]},modifiers:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1},typicalGestures:["breathe","float","idle","blink"],transitions:{duration:500,easing:"easeInOut",priority:0},getCoreParams:t=>({scaleX:1,scaleY:1,eyeOpenness:1,eyeExpression:"neutral",pupilOffset:{x:0,y:0}}),renderCore:(t,e,i,n)=>!1,"3d":{rotation:{type:"gentle",speed:1,axes:[0,.3,0],musicSync:!1},glow:{color:"#00BCD4",intensity:.9,pulse:{speed:1,range:[.8,1]}},scale:{base:1,breathe:{enabled:!0,depth:.08,rate:1}}},soulAnimation:{driftSpeed:.5,shimmerSpeed:.5,turbulence:.2}},{name:"joy",emoji:"",description:"Playful happiness and celebration",visual:{glowColor:"#FFEB3B",particleRate:8,minParticles:0,maxParticles:50,particleBehavior:"popcorn",breathRate:1.5,breathDepth:.1,coreJitter:!1,blinkRate:1.3,blinkSpeed:1.1,particleColors:[{color:"#FFEB3B",weight:25},{color:"#FFC107",weight:20},{color:"#FFFF00",weight:15},{color:"#FFD700",weight:15},{color:"#FFF59D",weight:10},{color:"#FF9800",weight:10},{color:"#FFFDE7",weight:5}]},modifiers:{speed:1.8,amplitude:1.9,intensity:1.1,smoothness:1,regularity:.9,addBounce:!0},typicalGestures:["bounce","spin","wave","expand","shake","float"],transitions:{duration:400,easing:"easeOutBack",priority:5,burstOnEntry:!0},getCoreParams:t=>({scaleX:1,scaleY:1,eyeOpenness:1,eyeExpression:"happy",pupilOffset:{x:0,y:-.1},sparkle:!0}),"3d":{rotation:{type:"rhythmic",speed:1.8,axes:[0,.3,0],musicSync:!0},glow:{color:"#FFEB3B",intensity:1.6,pulse:{speed:1.5,range:[1.2,1.8]}},scale:{base:1,breathe:{enabled:!0,depth:.1,rate:1.5}}},soulAnimation:{driftSpeed:1.2,shimmerSpeed:1.5,turbulence:.3}},{name:"sadness",emoji:"",description:"Deep melancholic sorrow",visual:{glowColor:"#4169E1",particleRate:6,minParticles:0,maxParticles:50,particleBehavior:"falling",breathRate:.6,breathDepth:.12,coreJitter:!1,blinkRate:.6,blinkSpeed:.8,particleColors:[{color:"#4169E1",weight:25},{color:"#1E90FF",weight:20},{color:"#6495ED",weight:15},{color:"#B0C4DE",weight:15},{color:"#191970",weight:10},{color:"#87CEEB",weight:10},{color:"#2F4F4F",weight:5}]},modifiers:{speed:.7,amplitude:.6,intensity:.8,smoothness:1.3,regularity:1.1,addGravity:!0},typicalGestures:["droop","sway","contract","drift","sink"],transitions:{duration:800,easing:"easeInOut",priority:3},"3d":{rotation:{type:"gentle",speed:.7,axes:[0,.2,0],musicSync:!1},glow:{color:"#4169E1",intensity:.65,pulse:{speed:.6,range:[.5,.8]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.6}}},soulAnimation:{driftSpeed:.2,shimmerSpeed:.3,turbulence:.1}},{name:"anger",emoji:"",description:"Intense rage and aggression",visual:{glowColor:"#DC143C",particleRate:8,minParticles:8,maxParticles:50,particleBehavior:"aggressive",breathRate:2.2,breathDepth:.15,coreJitter:!0,blinkRate:1.6,blinkSpeed:1.3,particleColors:[{color:"#DC143C",weight:25},{color:"#FF0000",weight:20},{color:"#B22222",weight:15},{color:"#FF4500",weight:15},{color:"#8B0000",weight:10},{color:"#FF6347",weight:10},{color:"#660000",weight:5}]},modifiers:{speed:1.5,amplitude:1.4,intensity:1.3,smoothness:.3,regularity:.7,addShake:!0},typicalGestures:["shake","vibrate","expand","pulse","flicker","strike"],transitions:{duration:300,easing:"easeOutExpo",priority:8,shakeOnEntry:!0},special:{screenShake:!0,particleTrails:"fire",glowPulse:!0,temperatureEffect:"hot"},"3d":{rotation:{type:"unstable",speed:1.5,axes:[0,.3,0],shake:{amplitude:.02,frequency:7},eruption:{enabled:!0,interval:3e3,speedMultiplier:3.5,duration:400},musicSync:!1},glow:{color:"#DC143C",intensity:1.8,pulse:{speed:2.2,range:[.8,2]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:2.2}}},soulAnimation:{driftSpeed:2,shimmerSpeed:.8,turbulence:.8}},{name:"fear",emoji:"",description:"Anxious state with fleeing particles",visual:{glowColor:"#8A2BE2",particleRate:8,minParticles:8,maxParticles:50,particleBehavior:"scattering",breathRate:2.5,breathDepth:.06,coreJitter:!0,blinkRate:1.7,blinkSpeed:1.4,particleColors:[{color:"#8A2BE2",weight:25},{color:"#4B0082",weight:20},{color:"#9400D3",weight:15},{color:"#6B46C1",weight:15},{color:"#9932CC",weight:10},{color:"#E6E6FA",weight:8},{color:"#301934",weight:7}]},modifiers:{speed:1.4,amplitude:.8,intensity:1.2,smoothness:.5,regularity:.5,addJitter:!0},typicalGestures:["shake","vibrate","contract","flicker","retreat"],transitions:{duration:400,easing:"easeOut",priority:7},"3d":{rotation:{type:"unstable",speed:1.4,axes:[0,.3,0],shake:{amplitude:.015,frequency:3.5},musicSync:!1},glow:{color:"#8A2BE2",intensity:.9,pulse:{speed:2.5,range:[.6,1.2]}},scale:{base:1,breathe:{enabled:!0,depth:.06,rate:2.5}}},soulAnimation:{driftSpeed:1.8,shimmerSpeed:2.5,turbulence:.6}},{name:"surprise",emoji:"",description:"Sudden shock with explosive particles",visual:{glowColor:"#FFD700",particleRate:5,minParticles:0,maxParticles:15,particleBehavior:"burst",breathRate:.3,breathDepth:.18,coreJitter:!1,blinkRate:1.4,blinkSpeed:1.2,particleColors:[{color:"#FFD700",weight:25},{color:"#FFA500",weight:20},{color:"#FFFF00",weight:15},{color:"#FF6347",weight:15},{color:"#FFE4B5",weight:10},{color:"#FF4500",weight:10},{color:"#FFFACD",weight:5}]},modifiers:{speed:1.6,amplitude:1.5,intensity:1.4,smoothness:.7,regularity:.8,addPop:!0},typicalGestures:["expand","bounce","flash","pulse","pop"],transitions:{duration:200,easing:"easeOutBack",priority:6},"3d":{rotation:{type:"unstable",speed:1.6,axes:[0,.45,0],shake:{amplitude:.01,frequency:3},musicSync:!1},glow:{color:"#FFD700",intensity:1.8,pulse:{speed:.3,range:[1,2.2]}},scale:{base:1,breathe:{enabled:!0,depth:.18,rate:.3}}},soulAnimation:{driftSpeed:1.5,shimmerSpeed:2,turbulence:.5}},{name:"disgust",emoji:"",description:"Revulsion with repelling particles",visual:{glowColor:"#9ACD32",particleRate:4,minParticles:5,maxParticles:12,particleBehavior:"repelling",breathRate:.7,breathDepth:.04,coreJitter:!1,blinkRate:.9,blinkSpeed:.9,particleColors:[{color:"#9ACD32",weight:25},{color:"#ADFF2F",weight:20},{color:"#7FFF00",weight:15},{color:"#BDB76B",weight:15},{color:"#6B8E23",weight:10},{color:"#CCFF00",weight:8},{color:"#556B2F",weight:7}]},modifiers:{speed:.9,amplitude:.7,intensity:.9,smoothness:.8,regularity:1,addRecoil:!0},typicalGestures:["contract","shake","recoil","wobble"],transitions:{duration:600,easing:"easeIn",priority:4},"3d":{rotation:{type:"gentle",speed:.9,axes:[0,.25,0],musicSync:!1},glow:{color:"#9ACD32",intensity:1,pulse:{speed:.7,range:[.7,1.2]}},scale:{base:1,breathe:{enabled:!0,depth:.04,rate:.7}}},soulAnimation:{driftSpeed:.4,shimmerSpeed:.6,turbulence:.35}},{name:"love",emoji:"",description:"Warm affection with orbiting particles",visual:{glowColor:"#FF1493",particleRate:6,minParticles:15,maxParticles:50,particleBehavior:"orbiting",breathRate:.75,breathDepth:.15,coreJitter:!1,blinkRate:1.2,blinkSpeed:1,particleColors:[{color:"#FF1493",weight:30},{color:"#FF69B4",weight:25},{color:"#FF007F",weight:15},{color:"#FFB6C1",weight:10},{color:"#FF45A0",weight:10},{color:"#E91E63",weight:5},{color:"#FFC0CB",weight:5}]},modifiers:{speed:.9,amplitude:1.1,intensity:1.2,smoothness:1.4,regularity:1.2,addWarmth:!0},typicalGestures:["pulse","sway","orbit","glow","breathe","float"],transitions:{duration:700,easing:"easeInOut",priority:5},"3d":{rotation:{type:"gentle",speed:.9,axes:[0,.28,0],musicSync:!0},glow:{color:"#FF1493",intensity:1.8,pulse:{speed:.75,range:[1.3,2]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:.75}}},soulAnimation:{driftSpeed:.8,shimmerSpeed:1.2,turbulence:.2}},$m,{name:"excited",emoji:"",description:"High energy with rapid particles",visual:{glowColor:"#FF6B35",particleRate:8,minParticles:10,maxParticles:50,particleBehavior:"burst",breathRate:2,breathDepth:.14,coreJitter:!0,blinkRate:1.5,blinkSpeed:1.2,particleColors:[{color:"#FF6B35",weight:25},{color:"#FF1744",weight:20},{color:"#FFC107",weight:15},{color:"#FF9100",weight:15},{color:"#FFEB3B",weight:10},{color:"#FF5722",weight:10},{color:"#FFF59D",weight:5}]},modifiers:{speed:1.4,amplitude:1.3,intensity:1.3,smoothness:.8,regularity:.7,addVibration:!0},typicalGestures:["bounce","spin","vibrate","expand","shake","pulse"],transitions:{duration:300,easing:"easeOutElastic",priority:6},"3d":{rotation:{type:"unstable",speed:1.4,axes:[0,.4,0],shake:{amplitude:.01,frequency:4},musicSync:!1},glow:{color:"#FF6B35",intensity:1.5,pulse:{speed:2,range:[1,1.8]}},scale:{base:1,breathe:{enabled:!0,depth:.14,rate:2}}},soulAnimation:{driftSpeed:1.5,shimmerSpeed:2,turbulence:.5}},{name:"resting",emoji:"",description:"Deep relaxation with slow drift",visual:{glowColor:"#9370DB",particleRate:1,minParticles:3,maxParticles:5,particleBehavior:"resting",breathRate:.8,breathDepth:.12,coreJitter:!1,blinkRate:.4,blinkSpeed:.7,particleColors:[{color:"#9370DB",weight:30},{color:"#A591C4",weight:20},{color:"#B366FF",weight:20},{color:"#B8A1E6",weight:15},{color:"#674D9B",weight:15}]},modifiers:{speed:.5,amplitude:.4,intensity:.5,smoothness:1.4,regularity:.9,addWeight:!0},typicalGestures:["breathe","drift","sway","float"],transitions:{duration:1e3,easing:"easeInOut",priority:2},"3d":{rotation:{type:"gentle",speed:.5,axes:[0,.15,0],musicSync:!1},glow:{color:"#9370DB",intensity:.8,pulse:{speed:.8,range:[.6,1]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.8}}},soulAnimation:{driftSpeed:.15,shimmerSpeed:.1,turbulence:.05}},{name:"euphoria",emoji:"",description:"Radiant hope and new beginnings",visual:{glowColor:"#FFB6C1",particleRate:6,minParticles:15,maxParticles:30,particleBehavior:"radiant",breathRate:1.3,breathDepth:.25,coreJitter:!1,blinkRate:1.4,blinkSpeed:1.1,particleColors:[{color:"#FFB6C1",weight:20},{color:"#FFD700",weight:18},{color:"#87CEEB",weight:15},{color:"#DDA0DD",weight:15},{color:"#98FB98",weight:12},{color:"#FFA07A",weight:10},{color:"#E6E6FA",weight:8},{color:"#FFFFFF",weight:2}]},modifiers:{speed:1.4,amplitude:1.5,intensity:1.6,smoothness:1.3,regularity:.8,addWarmth:!0,addLift:!0},typicalGestures:["expand","radiate","pulse","glow","float","bloom"],transitions:{duration:600,easing:"easeOutExpo",priority:8},"3d":{rotation:{type:"rhythmic",speed:1.4,axes:[0,.35,0],musicSync:!0},glow:{color:"#FFB6C1",intensity:1.2,pulse:{speed:1.3,range:[.9,1.5]}},scale:{base:1,breathe:{enabled:!0,depth:.25,rate:1.3}}},soulAnimation:{driftSpeed:1.8,shimmerSpeed:2.5,turbulence:.7}},{name:"focused",emoji:"",description:"Intense concentration with directed flow",visual:{glowColor:"#00CED1",particleRate:4,minParticles:5,maxParticles:12,particleBehavior:"directed",breathRate:1.2,breathDepth:.08,coreJitter:!0,blinkRate:.7,blinkSpeed:1,particleColors:[{color:"#00CED1",weight:30},{color:"#4A9FA0",weight:20},{color:"#00FFFF",weight:20},{color:"#5FE5E7",weight:15},{color:"#006B6D",weight:15}],eyeOpenness:.7,microAdjustments:!0},modifiers:{speed:1,amplitude:.9,intensity:1.1,smoothness:1.1,regularity:1.2,addPrecision:!0},typicalGestures:["track","lock","scan","pulse","vibrate"],transitions:{duration:400,easing:"easeIn",priority:5},getCoreParams:t=>({scaleX:1.1,scaleY:.7,eyeOpenness:.7,eyeExpression:"focused",pupilOffset:{x:0,y:0},microAdjustments:!0}),"3d":{rotation:{type:"still",speed:.5,axes:[0,.1,0],musicSync:!1},glow:{color:"#00CED1",intensity:1.2,pulse:{speed:1.2,range:[1,1.3]}},scale:{base:1,breathe:{enabled:!0,depth:.08,rate:1.2}}},soulAnimation:{driftSpeed:.6,shimmerSpeed:.2,turbulence:.1}},{name:"glitch",emoji:"",description:"Surprised sadness with rainbow colors and glitch wiggle",visual:{primaryColor:"#FF6B9D",glowColor:"#4169E1",glowIntensity:1.2,particleRate:5,minParticles:5,maxParticles:15,particleBehavior:"burst",particleSpeed:1,breathRate:.4,breathDepth:.15,coreJitter:!1,coreSize:1,eyeOpenness:.8,blinkRate:1.3,blinkSpeed:1.2,particleColors:[{color:"#FF0080",weight:18},{color:"#00FF80",weight:18},{color:"#8000FF",weight:18},{color:"#FF8000",weight:15},{color:"#0080FF",weight:15},{color:"#FFFF00",weight:10},{color:"#FF6B9D",weight:6}],particleGlitchWiggle:!0,glitchWiggleIntensity:.3,glitchWiggleFrequency:.1},modifiers:{speed:1.1,amplitude:1,intensity:1.1,smoothness:.8,regularity:.7,focus:.6},typicalGestures:["bounce","sway","pulse","drift","flash"],transitions:{duration:300,easing:"easeInOut",priority:5},"3d":{rotation:{type:"unstable",speed:1.1,axes:[0,.35,0],shake:{amplitude:.02,frequency:5},musicSync:!1},glow:{color:"#FF6B9D",intensity:1.2,pulse:{speed:.4,range:[.8,1.6]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:.4}}}},Zm].forEach(t=>{t&&t.name&&Jm.set(t.name,t)});class sg{constructor(t,e={}){this.blinkConfig=t.blink||this.getDefaultBlinkConfig(),this.currentGeometryType=null,this.baseDuration=this.blinkConfig.duration||150,this.baseMinInterval=3e3,this.baseMaxInterval=7e3,this.emotionBlinkRate=1,this.emotionBlinkSpeed=1,this.isBlinking=!1,this.blinkTimer=0,this.nextBlinkTime=this.getRandomBlinkTime(),this.enabled=!0,this.blinkProgress=0}setEmotion(t){const e=Km(t);this.emotionBlinkRate=e?.visual?.blinkRate||1,this.emotionBlinkSpeed=e?.visual?.blinkSpeed||1}setGeometry(t){this.blinkConfig=t.blink||this.getDefaultBlinkConfig(),this.baseDuration=this.blinkConfig.duration||150}update(t){if(!this.enabled)return this.getIdleState();if(this.isBlinking){this.blinkTimer+=t;const e=this.baseDuration/this.emotionBlinkSpeed;if(this.blinkTimer>=e)return this.completeBlink(),this.getIdleState();const i=this.blinkTimer/e;return this.blinkProgress=i,this.getBlinkState()}return Date.now()>=this.nextBlinkTime?(this.startBlink(),this.getBlinkState()):this.getIdleState()}startBlink(){this.enabled&&(this.isBlinking=!0,this.blinkTimer=0,this.blinkProgress=0)}completeBlink(){this.isBlinking=!1,this.blinkTimer=0,this.blinkProgress=0,this.nextBlinkTime=Date.now()+this.getRandomBlinkTime()}getRandomBlinkTime(){const t=this.baseMinInterval/this.emotionBlinkRate,e=this.baseMaxInterval/this.emotionBlinkRate;return t+Math.random()*(e-t)}getBlinkState(){const t=this.blinkConfig,e=Math.sin(this.blinkProgress*Math.PI);let i=1;if(t.playful)if(this.blinkProgress<.1){const e=this.blinkProgress/.1;i-=Math.sin(e*Math.PI)*t.playful.anticipation}else if(this.blinkProgress>.8){const e=(this.blinkProgress-.8)/.2;i+=Math.sin(e*Math.PI)*t.playful.overshoot}const n=e*i,s=[1-(1-t.scaleAxis[0])*n,1-(1-t.scaleAxis[1])*n,1-(1-t.scaleAxis[2])*n];let a=null;t.rotation&&(a=[t.rotation[0]*n,t.rotation[1]*n,t.rotation[2]*n]);let r=0;return t.glowBoost&&(r=t.glowBoost*n),{isBlinking:!0,progress:this.blinkProgress,scale:s,rotation:a,glowBoost:r}}getIdleState(){return{isBlinking:!1,progress:0,scale:[1,1,1],rotation:null,glowBoost:0}}getDefaultBlinkConfig(){return{type:"vertical-squish",duration:150,scaleAxis:[1,.3,1],curve:"sine"}}pause(){this.enabled=!1,this.isBlinking&&this.completeBlink()}resume(){this.enabled=!0,this.nextBlinkTime=Date.now()+this.getRandomBlinkTime()}getState(){return{isBlinking:this.isBlinking,enabled:this.enabled,blinkProgress:this.blinkProgress,emotionBlinkRate:this.emotionBlinkRate,emotionBlinkSpeed:this.emotionBlinkSpeed,nextBlinkTime:this.nextBlinkTime}}destroy(){this.blinkConfig=null,this.enabled=!1,this.isBlinking=!1}}let ag;"undefined"!=typeof window&&window.__emotiveRhythmEngine?ag=window.__emotiveRhythmEngine:(ag=new class{constructor(){this.bpm=120,this.timeSignature=[4,4],this.isPlaying=!1,this.startTime=0,this.currentBeat=0,this.currentBar=0,this.beatProgress=0,this.barProgress=0,this.beatDuration=6e4/this.bpm,this.barDuration=this.beatDuration*this.timeSignature[0],this.lastBeatTime=0,this.nextBeatTime=0,this.listeners=new Map,this.beatCallbacks=new Set,this.barCallbacks=new Set,this.subdivisions={sixteenth:0,eighth:0,triplet:0,swing:0},this.audioSync=null,this.syncOffset=0,this.autoSync=!1,this.intensity=1,this.groove=0,this.humanize=.05,this.patterns=new Map,this.currentPattern=null,this.initializePatterns()}initializePatterns(){this.patterns.set("4/4",{name:"4/4",description:"Common time - 4 beats per bar",timeSignature:[4,4],groove:0,accents:[1,.5,.7,.5]}),this.patterns.set("straight",{name:"straight",description:"Straight, even timing",groove:0,accents:[1,.5,.7,.5]}),this.patterns.set("swing",{name:"swing",description:"Swing/shuffle timing",groove:.67,accents:[1,.3,.8,.3]}),this.patterns.set("3/4",{name:"3/4",description:"Waltz time - 3 beats per bar",timeSignature:[3,4],accents:[1,.5,.5]}),this.patterns.set("waltz",{name:"waltz",description:"3/4 waltz timing",timeSignature:[3,4],accents:[1,.5,.5]}),this.patterns.set("6/8",{name:"6/8",description:"Compound duple time",timeSignature:[6,8],accents:[1,.3,.3,.7,.3,.3]}),this.patterns.set("5/4",{name:"5/4",description:"Complex meter - 5 beats per bar",timeSignature:[5,4],accents:[1,.5,.6,.5,.7]}),this.patterns.set("7/8",{name:"7/8",description:"Irregular meter",timeSignature:[7,8],accents:[1,.5,.5,.7,.5,.5,.6]}),this.patterns.set("dubstep",{name:"dubstep",description:"Dubstep half-time feel",accents:[.2,.2,1,.2],subdivisions:{wobble:!0}}),this.patterns.set("breakbeat",{name:"breakbeat",description:"Broken beat pattern",accents:[1,.2,.7,.9,.2,.8,.4,.2]})}start(){this.isPlaying||(this.isPlaying=!0,this.isRunning=!0,this.startTime=performance.now(),this.lastBeatTime=this.startTime,this.nextBeatTime=this.startTime+this.beatDuration,this.currentBeat=0,this.currentBar=0,this.emit("start",{bpm:this.bpm,timeSignature:this.timeSignature,pattern:this.currentPattern}),this.update())}stop(){this.isPlaying&&(this.isPlaying=!1,this.emit("stop",{totalBeats:this.currentBeat,totalBars:this.currentBar}))}update(){if(!this.isPlaying)return;const t=(performance.now()-this.startTime)/this.beatDuration,e=Math.floor(t);this.beatProgress=t%1,e>this.currentBeat&&this.onBeat(e);const i=Math.floor(e/this.timeSignature[0]);i>this.currentBar&&this.onBar(i),this.currentBeat=e,this.currentBar=i,this.barProgress=e%this.timeSignature[0]/this.timeSignature[0],this.updateSubdivisions(),this.emit("update",this.getTimeInfo()),this.isPlaying&&requestAnimationFrame(()=>this.update())}onBeat(t){const e=t%this.timeSignature[0],i=this.getAccent(e),n=this.humanize*(Math.random()-.5)*this.beatDuration,s={beat:t,beatInBar:e,bar:this.currentBar,accent:i,intensity:this.intensity*i,humanTiming:n,timestamp:performance.now()};this.emit("beat",s),this.beatCallbacks.forEach(t=>t(s)),this.lastBeatTime=performance.now(),this.nextBeatTime=this.lastBeatTime+this.beatDuration}onBar(t){const e={bar:t,timeSignature:this.timeSignature,pattern:this.currentPattern,timestamp:performance.now()};this.emit("bar",e),this.barCallbacks.forEach(t=>t(e))}updateSubdivisions(){if(this.subdivisions.sixteenth=4*this.beatProgress%1,this.subdivisions.eighth=2*this.beatProgress%1,this.subdivisions.triplet=3*this.beatProgress%1,this.groove>0){const t=.5+.17*this.groove;this.subdivisions.eighth<.5?this.subdivisions.swing=this.subdivisions.eighth/t:this.subdivisions.swing=.5+(this.subdivisions.eighth-.5)/(1-t)}else this.subdivisions.swing=this.subdivisions.eighth}getAccent(t){if(this.currentPattern&&this.patterns.has(this.currentPattern)){const e=this.patterns.get(this.currentPattern);if(e.accents&&void 0!==e.accents[t])return e.accents[t]}return 0===t?1:2===t&&4===this.timeSignature[0]?.7:.5}getTimeInfo(){return{elapsed:performance.now()-this.startTime,beat:this.currentBeat,bar:this.currentBar,beatInBar:this.currentBeat%this.timeSignature[0],beatProgress:this.beatProgress,barProgress:this.barProgress,subdivisions:{...this.subdivisions},bpm:this.bpm,beatDuration:this.beatDuration,timeSignature:[...this.timeSignature],intensity:this.intensity,groove:this.groove,pattern:this.currentPattern,nextBeatIn:this.nextBeatTime-performance.now(),accent:this.getAccent(this.currentBeat%this.timeSignature[0])}}setBPM(t){this.bpm=Math.max(20,Math.min(360,t)),this.beatDuration=6e4/this.bpm,this.barDuration=this.beatDuration*this.timeSignature[0],this.emit("tempoChange",{bpm:this.bpm})}setTimeSignature(t,e){this.timeSignature=[t,e],this.barDuration=this.beatDuration*t,this.emit("timeSignatureChange",{timeSignature:this.timeSignature})}setPattern(t){if(!this.patterns.has(t))return;const e=this.patterns.get(t);this.currentPattern=t,e.timeSignature&&this.setTimeSignature(...e.timeSignature),void 0!==e.groove&&(this.groove=e.groove),this.emit("patternChange",{pattern:t})}onBeatCallback(t){return this.beatCallbacks.add(t),()=>this.beatCallbacks.delete(t)}onBarCallback(t){return this.barCallbacks.add(t),()=>this.barCallbacks.delete(t)}emit(t,e){this.listeners.has(t)&&this.listeners.get(t).forEach(t=>t(e))}on(t,e){return this.listeners.has(t)||this.listeners.set(t,new Set),this.listeners.get(t).add(e),()=>{this.listeners.has(t)&&this.listeners.get(t).delete(e)}}syncToAudio(t,e){this.audioSync={context:t,source:e}}getAdapter(){return{getTimeInfo:()=>this.getTimeInfo(),isOnBeat:(t=.1)=>this.beatProgress<t||this.beatProgress>1-t,isOnSubdivision:(t,e=.1)=>{const i=this.subdivisions[t]||0;return i<e||i>1-e},getBeatSync:(t=0,e=1,i="linear")=>{let n=this.beatProgress;switch(i){case"ease":n=.5-Math.cos(n*Math.PI)/2;break;case"bounce":n=Math.abs(Math.sin(n*Math.PI));break;case"pulse":n=Math.pow(Math.sin(n*Math.PI),2)}return t+(e-t)*n},getAccentedValue:(t,e=2)=>t*(1+(this.getAccent(this.currentBeat%this.timeSignature[0])-.5)*e),onBeat:t=>this.onBeatCallback(t),onBar:t=>this.onBarCallback(t),beatsToMs:t=>t*this.beatDuration,msToBeats:t=>t/this.beatDuration,isPlaying:()=>this.isPlaying,getBPM:()=>this.bpm,getPattern:()=>this.currentPattern}}},"undefined"!=typeof window&&(window.__emotiveRhythmEngine=ag));const rg={groove1:{name:"groove1",description:"Subtle, elegant - gentle bounce and sway",bounceAmount:.015,swayAmount:.012,pulseAmount:.02,rotationAmount:.015,bounceFreq:1,swayFreq:.5,phaseOffset:0,easing:"sine"},groove2:{name:"groove2",description:"Energetic, bouncy - pronounced vertical motion",bounceAmount:.035,swayAmount:.02,pulseAmount:.045,rotationAmount:.025,bounceFreq:1,swayFreq:1,phaseOffset:0,easing:"bounce"},groove3:{name:"groove3",description:"Smooth, flowing - emphasis on rotation and sway",bounceAmount:.01,swayAmount:.03,pulseAmount:.015,rotationAmount:.04,bounceFreq:.5,swayFreq:.25,phaseOffset:Math.PI/4,easing:"sine"}},og="groove1";class lg{constructor(){this.enabled=!1,this.adapter=null,this.beatProgress=0,this.barProgress=0,this.accent=.5,this.intensity=1,this.bpm=120,this.isOnBeat=!1,this.pattern=null,this.grooveEnabled=!0,this.currentGroove=og,this.targetGroove=og,this.grooveTransition=0,this.grooveTransitionSpeed=2,this.grooveConfidence=1,this.bpmMultiplier=1,this.modulation={scaleMultiplier:1,glowMultiplier:1,positionMultiplier:1,rotationMultiplier:1,accentBoost:0,grooveOffset:[0,0,0],grooveScale:1,grooveRotation:[0,0,0],grooveGlow:1},this._target={scaleMultiplier:1,glowMultiplier:1,positionMultiplier:1,rotationMultiplier:1,accentBoost:0,grooveOffset:[0,0,0],grooveScale:1,grooveRotation:[0,0,0],grooveGlow:1},this.config={beatSyncStrength:.3,accentMultiplier:1.5,smoothingSpeed:8,grooveSmoothingSpeed:12},this._maxDeltaTime=.05,this._pendingGroove=null,this._pendingGrooveOptions=null}_lerp(t,e,i,n){return t+(e-t)*(1-Math.exp(-i*n))}_lerpArray(t,e,i,n){const s=1-Math.exp(-i*n);return t.map((t,i)=>t+(e[i]-t)*s)}_applyEasing(t,e){switch(e){case"bounce":return Math.sign(t)*Math.pow(Math.abs(t),.6);case"elastic":return t*(1+.15*Math.sin(Math.abs(t)*Math.PI*2));default:return t}}_getGroovePreset(t){return rg[t]||rg[og]}_interpolatePresets(t,e,i){return{bounceAmount:t.bounceAmount+(e.bounceAmount-t.bounceAmount)*i,swayAmount:t.swayAmount+(e.swayAmount-t.swayAmount)*i,pulseAmount:t.pulseAmount+(e.pulseAmount-t.pulseAmount)*i,rotationAmount:t.rotationAmount+(e.rotationAmount-t.rotationAmount)*i,bounceFreq:t.bounceFreq+(e.bounceFreq-t.bounceFreq)*i,swayFreq:t.swayFreq+(e.swayFreq-t.swayFreq)*i,phaseOffset:t.phaseOffset+(e.phaseOffset-t.phaseOffset)*i}}initialize(){this.adapter=ag.getAdapter(),this.enabled=!0,this.adapter.onBeat(t=>{this.accent=t.accent,this.isOnBeat=!0,setTimeout(()=>{this.isOnBeat=!1},100)})}start(t=120,e="straight"){this.enabled||this.initialize(),t&&ag.setBPM(t),e&&ag.setPattern(e),ag.start()}stop(){ag.stop()}setBPM(t){ag.setBPM(t),this.bpm=t}setPattern(t){ag.setPattern(t),this.pattern=t}setGroove(t,e={}){if(rg[t]){if(!(this.currentGroove===t&&this.grooveTransition>=1)){if(e.quantize)return this._pendingGroove=t,void(this._pendingGrooveOptions={...e,quantize:!1});if(this.targetGroove=t,e.bars||e.duration)if(this.grooveTransition=0,e.bars){const t=60/this.bpm*4,i=e.bars*t;this.grooveTransitionSpeed=1/i}else e.duration&&(this.grooveTransitionSpeed=1/e.duration);else this.currentGroove=t,this.grooveTransition=1}}else console.warn(`[Rhythm3DAdapter] Unknown groove preset: ${t}`)}getGroovePresets(){return Object.keys(rg)}getCurrentGroove(){return this.grooveTransition>=1?this.targetGroove:this.currentGroove}update(t){const e=Math.min(t/1e3,this._maxDeltaTime);if(this.adapter||(this.adapter=ag.getAdapter()),!this.adapter)return void this.resetModulation(e);if(!this.adapter.isPlaying())return void this.resetModulation(e);this.enabled=!0;const i=this.adapter.getTimeInfo();this.beatProgress=i.beatProgress,this.barProgress=i.barProgress,this.intensity=i.intensity,this.bpm=i.bpm||this.bpm,this.pattern=i.pattern,this._pendingGroove&&this.barProgress<.05&&(this.setGroove(this._pendingGroove,this._pendingGrooveOptions||{}),this._pendingGroove=null,this._pendingGrooveOptions=null),this.grooveTransition<1&&(this.grooveTransition=Math.min(1,this.grooveTransition+this.grooveTransitionSpeed*e),this.grooveTransition>=1&&(this.currentGroove=this.targetGroove)),this.computeModulation(),this.applySmoothing(e)}computeModulation(){const{beatSyncStrength:t,accentMultiplier:e}=this.config,i=this.beatProgress*Math.PI*2,n=.5*(Math.cos(i)+1);this._target.scaleMultiplier=1+n*t*.4,this._target.glowMultiplier=1+n*t*.8,this._target.positionMultiplier=1+n*t*.2,this._target.rotationMultiplier=1+n*t*.15,this._target.accentBoost=this.isOnBeat?(this.accent-.5)*e:0,this.grooveEnabled?this.computeGroove():(this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0])}computeGroove(){const t=this._getGroovePreset(this.currentGroove),e=this._getGroovePreset(this.targetGroove),i=this.grooveTransition>=1?e:this._interpolatePresets(t,e,this.grooveTransition),n=this.grooveConfidence,s=i.bounceAmount*n,a=i.swayAmount*n,r=i.pulseAmount*n,o=i.rotationAmount*n,{bounceFreq:l,swayFreq:h,phaseOffset:c,easing:u}=i,d=this.beatProgress*l*this.bpmMultiplier*Math.PI*2+c,p=Math.sin(d),m=this._applyEasing(p,u),g=this.barProgress*h*this.bpmMultiplier*Math.PI*2+c,f=Math.sin(g),y=this._applyEasing(f,u),v=.5*(Math.cos(this.beatProgress*Math.PI*2)+1),b=Math.max(0,this.accent-.4)/.6,M=v*b*.25,_=m*s*(1+M),x=y*a,w=Math.sin(d),S=1+this._applyEasing(w,u)*r*(1+.5*M),T=y*o,C=Math.sin(g+Math.PI/3)*a*.3,E=Math.sin(.5*g)*o*.4,A=Math.cos(.7*d)*o*.25,P=1+.5*(Math.cos(d)+1)*.12*n+v*b*.12;this._target.grooveOffset=[x,_,C],this._target.grooveScale=S,this._target.grooveRotation=[E,A,T],this._target.grooveGlow=P}applySmoothing(t){const{smoothingSpeed:e,grooveSmoothingSpeed:i}=this.config;this.modulation.scaleMultiplier=this._lerp(this.modulation.scaleMultiplier,this._target.scaleMultiplier,e,t),this.modulation.glowMultiplier=this._lerp(this.modulation.glowMultiplier,this._target.glowMultiplier,e,t),this.modulation.positionMultiplier=this._lerp(this.modulation.positionMultiplier,this._target.positionMultiplier,e,t),this.modulation.rotationMultiplier=this._lerp(this.modulation.rotationMultiplier,this._target.rotationMultiplier,e,t),this.modulation.accentBoost=this._lerp(this.modulation.accentBoost,this._target.accentBoost,.5*e,t),this.modulation.grooveOffset=this._lerpArray(this.modulation.grooveOffset,this._target.grooveOffset,i,t),this.modulation.grooveScale=this._lerp(this.modulation.grooveScale,this._target.grooveScale,i,t),this.modulation.grooveRotation=this._lerpArray(this.modulation.grooveRotation,this._target.grooveRotation,i,t),this.modulation.grooveGlow=this._lerp(this.modulation.grooveGlow,this._target.grooveGlow,i,t)}resetModulation(t=.016){this._target.scaleMultiplier=1,this._target.glowMultiplier=1,this._target.positionMultiplier=1,this._target.rotationMultiplier=1,this._target.accentBoost=0,this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0],this._target.grooveGlow=1,this.modulation.scaleMultiplier=this._lerp(this.modulation.scaleMultiplier,1,4,t),this.modulation.glowMultiplier=this._lerp(this.modulation.glowMultiplier,1,4,t),this.modulation.positionMultiplier=this._lerp(this.modulation.positionMultiplier,1,4,t),this.modulation.rotationMultiplier=this._lerp(this.modulation.rotationMultiplier,1,4,t),this.modulation.accentBoost=this._lerp(this.modulation.accentBoost,0,4,t),this.modulation.grooveOffset=this._lerpArray(this.modulation.grooveOffset,[0,0,0],4,t),this.modulation.grooveScale=this._lerp(this.modulation.grooveScale,1,4,t),this.modulation.grooveRotation=this._lerpArray(this.modulation.grooveRotation,[0,0,0],4,t),this.modulation.grooveGlow=this._lerp(this.modulation.grooveGlow,1,4,t)}getModulation(){return this.modulation}getMusicalDuration(t,e=null){if(!this.enabled||!this.adapter||!this.adapter.isPlaying())return t;if(e?.durationSync){const t=e.durationSync;if("beats"===t.mode&&t.beats)return this.adapter.beatsToMs(t.beats);if("bars"===t.mode&&t.bars)return this.adapter.beatsToMs(4*t.bars)}return t}isOnBeatNow(t=.1){return!(!this.enabled||!this.adapter)&&this.adapter.isOnBeat(t)}isOnAccent(t=.7){return this.isOnBeat&&this.accent>=t}getBeatSync(t,e,i="pulse"){return this.enabled&&this.adapter?this.adapter.getBeatSync(t,e,i):t}getAccentedValue(t,e=2){return this.enabled&&this.adapter?this.adapter.getAccentedValue(t,e):t}setGrooveEnabled(t){this.grooveEnabled=t,t||(this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0])}setGrooveConfidence(t){this.grooveConfidence=Math.max(0,Math.min(1,t))}setBPMMultiplier(t){this.bpmMultiplier=Math.max(.25,Math.min(4,t))}getBPMMultiplier(){return this.bpmMultiplier}setGrooveConfig(t){Object.assign(this.config,t)}setBeatSyncStrength(t){this.config.beatSyncStrength=Math.max(0,Math.min(1,t))}isPlaying(){return this.enabled&&this.adapter&&this.adapter.isPlaying()}getBPM(){return this.bpm}getPattern(){return this.pattern}destroy(){this.enabled=!1,this.adapter=null,this.resetModulation()}}const hg=new lg;class cg{constructor(){this.isTransitioning=!1,this.currentGeometryType=null,this.targetGeometryType=null,this.morphStartTime=0,this.morphDuration=1e3,this.morphProgress=0,this.visualProgress=0,this.hasSwappedGeometry=!1,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.easing="easeInOutCubic"}startMorph(t,e,i=1e3){if(t===e&&!this.isTransitioning)return!1;if(this.isTransitioning&&this.targetGeometryType===e)return!1;if(this.isTransitioning){const t=this.calculateScaleMultiplier(this.visualProgress);if(this.hasSwappedGeometry){this.morphStartTime=Date.now(),this.morphDuration=i;const n=t>0?Math.sqrt(1-Math.min(t,1))/2:.5;this.morphProgress=n,this.visualProgress=n,this.hasSwappedGeometry=!1,this.targetGeometryType=e,this._interruptedTarget=e,this.isPausedAtSwap=!1,this.isGrowIn=!1;const s=n*i;return this.morphStartTime=Date.now()-s,!0}return this.targetGeometryType=e,this._interruptedTarget=e,!0}return this.currentGeometryType=t,this.targetGeometryType=e,this.morphStartTime=Date.now(),this.morphDuration=i,this.morphProgress=0,this.visualProgress=0,this.isTransitioning=!0,this.hasSwappedGeometry=!1,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.isGrowIn=!1,this._interruptedTarget=null,!0}getInterruptedTarget(){const t=this._interruptedTarget;return this._interruptedTarget=null,t}growIn(t,e=500){return!this.isTransitioning&&(this.currentGeometryType=t,this.targetGeometryType=t,this.morphStartTime=Date.now(),this.morphDuration=e,this.morphProgress=0,this.visualProgress=0,this.isTransitioning=!0,this.hasSwappedGeometry=!0,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.isGrowIn=!0,!0)}pauseAtSwap(){this.isTransitioning&&!this.isPausedAtSwap&&(this.isPausedAtSwap=!0,this.pausedAtTime=Date.now())}resumeFromSwap(){if(this.isPausedAtSwap){const t=Date.now()-this.pausedAtTime;this.morphStartTime+=t,this.isPausedAtSwap=!1,this.pausedAtTime=0}}update(t){if(!this.isTransitioning)return{isTransitioning:!1,progress:0,visualProgress:0,scaleMultiplier:1};if(this.isPausedAtSwap)return{isTransitioning:!0,progress:.5,visualProgress:.5,scaleMultiplier:0,waitingForGeometry:!0};const e=Date.now()-this.morphStartTime,i=Math.min(e/this.morphDuration,1);this.morphProgress=this.applyEasing(i),this.visualProgress=.6*this.visualProgress+.4*this.morphProgress,Math.abs(this.visualProgress-this.morphProgress)<.01&&(this.visualProgress=this.morphProgress);const n=this.calculateScaleMultiplier(this.visualProgress);let s=!1;return!this.hasSwappedGeometry&&this.morphProgress>=.5&&(this.hasSwappedGeometry=!0,s=!0),this.morphProgress>=1?(this.completeMorph(),{isTransitioning:!1,progress:1,visualProgress:1,scaleMultiplier:1,completed:!0}):{isTransitioning:!0,progress:this.morphProgress,visualProgress:this.visualProgress,scaleMultiplier:n,shouldSwapGeometry:s}}calculateScaleMultiplier(t){if(this.isGrowIn){const e=1.70158,i=1+(e+1)*Math.pow(t-1,3)+e*Math.pow(t-1,2);return Math.max(0,i)}if(t<=.5){const e=2*t;return 1-e*e}{const e=2*(t-.5);return e*(2-e)}}completeMorph(){this.currentGeometryType=this.targetGeometryType,this.targetGeometryType=null,this.isTransitioning=!1,this.morphProgress=0,this.visualProgress=0}applyEasing(t){switch(this.easing){case"linear":return t;case"easeInQuad":return t*t;case"easeOutQuad":return t*(2-t);case"easeInOutQuad":return t<.5?2*t*t:(4-2*t)*t-1;case"easeInOutSine":return-(Math.cos(Math.PI*t)-1)/2;default:return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}}getState(){return{isTransitioning:this.isTransitioning,currentGeometryType:this.currentGeometryType,targetGeometryType:this.targetGeometryType,progress:this.morphProgress,visualProgress:this.visualProgress}}cancel(){this.isTransitioning=!1,this.targetGeometryType=null,this.morphProgress=0,this.visualProgress=0}}const ug={none:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1,"3d":{rotation:{speedMultiplier:1,shakeMultiplier:1},glow:{intensityMultiplier:1,pulseSpeedMultiplier:1},scale:{breathDepthMultiplier:1,breathRateMultiplier:1},righting:{strengthMultiplier:1}}},clear:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1,"3d":{rotation:{speedMultiplier:1,shakeMultiplier:1},glow:{intensityMultiplier:1,pulseSpeedMultiplier:1},scale:{breathDepthMultiplier:1,breathRateMultiplier:1},righting:{strengthMultiplier:1}}},nervous:{speed:1.2,amplitude:.9,intensity:1.1,smoothness:.7,regularity:.6,addFlutter:!0,addMicroShake:!0,"3d":{rotation:{speedMultiplier:1.5,shakeMultiplier:3.5,enableEpisodicWobble:!0},glow:{intensityMultiplier:1.25,pulseSpeedMultiplier:2},scale:{breathDepthMultiplier:.5,breathRateMultiplier:1.8},righting:{strengthMultiplier:.7}}},confident:{speed:.9,amplitude:1.3,intensity:1.2,smoothness:1.1,regularity:1.2,addPower:!0,addHold:!0,"3d":{rotation:{speedMultiplier:.7,shakeMultiplier:.2},glow:{intensityMultiplier:1.4,pulseSpeedMultiplier:.7},scale:{breathDepthMultiplier:1.5,breathRateMultiplier:.7},righting:{strengthMultiplier:1.6}}},tired:{speed:.7,amplitude:.7,intensity:.8,smoothness:1.3,regularity:.8,addDroop:!0,addPause:!0,"3d":{rotation:{speedMultiplier:.4,shakeMultiplier:.15},glow:{intensityMultiplier:.5,pulseSpeedMultiplier:.5},scale:{breathDepthMultiplier:1.3,breathRateMultiplier:.5},righting:{strengthMultiplier:.6}}},intense:{speed:1.3,amplitude:1.2,intensity:1.4,smoothness:.6,regularity:.9,addPulse:!0,addFocus:!0,"3d":{rotation:{speedMultiplier:1.6,shakeMultiplier:2.5},glow:{intensityMultiplier:1.8,pulseSpeedMultiplier:2.2},scale:{breathDepthMultiplier:1.6,breathRateMultiplier:1.8},righting:{strengthMultiplier:1.3}}},subdued:{speed:.8,amplitude:.8,intensity:.7,smoothness:1.2,regularity:1.1,addSoftness:!0,addFade:!0,"3d":{rotation:{speedMultiplier:.5,shakeMultiplier:.1},glow:{intensityMultiplier:.55,pulseSpeedMultiplier:.6},scale:{breathDepthMultiplier:.7,breathRateMultiplier:.6},righting:{strengthMultiplier:1.4}}}};function dg(t){return t&&""!==t&&"clear"!==t&&ug[t]||ug.clear}function pg(t,e=0,i="glow"){const n=function(t){const e=parseInt(t.slice(1,3),16)/255,i=parseInt(t.slice(3,5),16)/255,n=parseInt(t.slice(5,7),16)/255,s=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);return.2126*s(e)+.7152*s(i)+.0722*s(n)}(t),s=(.5+e)/Math.max(n,.05);return Math.max(.3,Math.min(10,s))}function mg(t){return 3===(t=t.replace("#","")).length&&(t=t.split("").map(t=>t+t).join("")),{r:parseInt(t.substr(0,2),16),g:parseInt(t.substr(2,2),16),b:parseInt(t.substr(4,2),16)}}const gg={intense:1.6,confident:1.3,nervous:1.15,clear:1,tired:.8,subdued:.5};function fg(t,e){if(!e||"clear"===e)return t;const i=gg[e.toLowerCase()];return i&&1!==i?function(t,e){const i=mg(t),n=function(t,e,i){t/=255,e/=255,i/=255;const n=Math.max(t,e,i),s=Math.min(t,e,i),a=(n+s)/2;let r,o;if(n===s)r=o=0;else{const l=n-s;switch(o=a>.5?l/(2-n-s):l/(n+s),n){case t:r=(e-i)/l+(e<i?6:0);break;case e:r=(i-t)/l+2;break;case i:r=(t-e)/l+4}r/=6}return{h:360*r,s:100*o,l:100*a}}(i.r,i.g,i.b);n.s=Math.max(0,Math.min(100,n.s*e));const s=function(t,e,i){t/=360,i/=100;const n=(t,e,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+(e-t)*(2/3-i)*6:t);let s,a,r;if(0==(e/=100))s=a=r=i;else{const o=i<.5?i*(1+e):i+e-i*e,l=2*i-o;s=n(l,o,t+1/3),a=n(l,o,t),r=n(l,o,t-1/3)}return{r:Math.round(255*s),g:Math.round(255*a),b:Math.round(255*r)}}(n.h,n.s,n.l);return function(t,e,i){const n=t=>{const e=Math.round(Math.max(0,Math.min(255,t))).toString(16);return 1===e.length?`0${e}`:e};return`#${n(t)}${n(e)}${n(i)}`}(s.r,s.g,s.b)}(t,i):t}Object.fromEntries(Object.entries({neutral:"#B0B0B0",joy:"#FFD700",sadness:"#4169E1",anger:"#DC143C",fear:"#8B008B",surprise:"#FF8C00",disgust:"#9ACD32",love:"#FF69B4"}).map(([t,e])=>{const i=mg(e);return[t,`${i.r}, ${i.g}, ${i.b}`]}));const yg=new class{constructor(){this.enabled=!1,this.adapter=null,this.subsystemConfigs=new Map,this.activeModulations=new Map}initialize(){this.adapter=ag.getAdapter(),this.enabled=!0,this.adapter.onBeat(this.handleBeat.bind(this)),this.adapter.onBar(this.handleBar.bind(this))}updateBPM(t){if(t>=60&&t<=220){if(window.rhythmManuallyStoppedForCurrentAudio)return;if(!ag.isRunning)return this.start(t,"straight"),void(window.rhythmSyncVisualizer&&!window.rhythmSyncVisualizer.state.active&&window.rhythmSyncVisualizer.start());ag.setBPM(t)}}registerConfig(t,e,i){if(!i.rhythm||!i.rhythm.enabled)return;const n=`${t}:${e}`;this.subsystemConfigs.set(n,{type:t,name:e,rhythmConfig:i.rhythm,originalConfig:i})}applyGestureRhythm(t,e,i,n){if(!this.enabled||!t.rhythm?.enabled)return{};const s=t.rhythm,a={};if(s.amplitudeSync){const t=s.amplitudeSync,e=this.adapter.getBeatSync(t.offBeat||.8,t.onBeat||1.5,t.curve||"linear");a.amplitudeMultiplier=e}if(s.wobbleSync){const t=s.wobbleSync;this.adapter.isOnSubdivision(t.subdivision,.1)?a.wobbleMultiplier=1+t.intensity:a.wobbleMultiplier=1}if(s.accentResponse?.enabled){const t=this.adapter.getAccentedValue(1,s.accentResponse.multiplier||1.5);a.accentMultiplier=t}const r=this.adapter.getPattern();return r&&s.patternOverrides?.[r]&&Object.assign(a,s.patternOverrides[r]),a}applyParticleRhythm(t,e){if(!this.enabled||!t.rhythm?.enabled)return{};const i=this.adapter.getTimeInfo(),n=t.rhythm,s={};if(n.particleEmission){const t=n.particleEmission;"beat"===t.syncMode&&this.adapter.isOnBeat(.1)?s.emitBurst=t.burstSize||3:void 0!==t.offBeatRate&&(s.emissionRate=t.offBeatRate)}if(n.glowSync){const t=n.glowSync,e=this.adapter.getBeatSync(t.intensityRange[0]||1,t.intensityRange[1]||2,"pulse");s.glowIntensity=e}if("bars"===n.breathSync?.mode){const t=n.breathSync,e=i.bar%t.barsPerBreath/t.barsPerBreath;s.breathPhase=e*Math.PI*2}return s}applyBehaviorRhythm(t,e,i){if(!this.enabled||!t.rhythm?.enabled)return{};const n=this.adapter.getTimeInfo(),s=t.rhythm,a={};if(s.glitchTiming){const t=s.glitchTiming;if(this.adapter.isOnSubdivision(t.subdivision,.05)&&Math.random()<t.probability){const e=this.adapter.isOnBeat()?t.intensityOnBeat:t.intensityOffBeat;a.triggerGlitch=!0,a.glitchIntensity=e}}if(s.orbitRhythm){const t=s.orbitRhythm;"tempo"===t.baseSpeed&&(a.speedMultiplier=this.adapter.getBPM()/120),t.beatAcceleration&&this.adapter.isOnBeat(.1)&&(a.speedBoost=t.beatAcceleration),t.barReset&&0===n.beatInBar&&(a.resetOrbit=!0)}if(s.stutterSync){const t=s.stutterSync,e=this.adapter.getPattern();if(e&&t.patterns?.[e]){const i=t.patterns[e];i.freezeOnDrop&&2===n.beatInBar?(a.freeze=!0,a.freezeDuration=i.dropDuration):i.randomFreeze&&Math.random()<i.randomFreeze&&(a.freeze=!0,a.freezeDuration=i.duration)}}return a}handleBeat(t){this.lastBeatInfo=t}handleBar(t){this.lastBarInfo=t}getMusicalDuration(t,e){if(!this.enabled||!t?.durationSync)return e;const i=t.durationSync;return"bars"===i.mode?this.adapter.beatsToMs(4*i.bars):"beats"===i.mode?this.adapter.beatsToMs(i.beats):e}isEnabled(){return this.enabled&&this.adapter.isPlaying()}start(t=120,e="straight"){t&&ag.setBPM(t),e&&ag.setPattern(e),ag.start(),this.enabled=!0}stop(){ag.stop(),this.enabled=!1,this.bpmLocked=!1,this.lockedBPM=null}setPattern(t){ag.setPattern(t)}setBPM(t){ag.setBPM(t),this.bpmLocked&&(this.lockedBPM=t)}resampleBPM(){this.bpmLocked=!1,this.lockedBPM=null}setTimeSignature(t){this.timeSignature=t;const e=document.getElementById("time-sig-display");e&&(e.textContent=t),"3/4"===t&&ag.getPattern()}syncToAudio(t,e){ag.syncToAudio(t,e)}},vg=new class{constructor(){this.emotionCache=new Map,this.visualParamsCache=new Map,this.modifiersCache=new Map,this.transitionCache=new Map,this.stats={hits:0,misses:0,loadTime:0,cacheSize:0},this.isInitialized=!1,this.loadStartTime=0,this.initialize()}initialize(){this.loadStartTime=performance.now();try{const t=ig();t.forEach(t=>{this.cacheEmotion(t)}),this.cacheCommonTransitions(t),this.isInitialized=!0,this.stats.loadTime=performance.now()-this.loadStartTime,this.stats.cacheSize=this.emotionCache.size}catch(t){console.error("[EmotionCache] Initialization failed:",t),this.isInitialized=!1}}cacheEmotion(t){try{const e=Km(t);e&&this.emotionCache.set(t,e);const i=tg(t);this.visualParamsCache.set(t,i);const n=eg(t);this.modifiersCache.set(t,n)}catch(e){console.warn(`[EmotionCache] Failed to cache emotion '${t}':`,e)}}cacheCommonTransitions(t){[["neutral","joy"],["neutral","sadness"],["neutral","anger"],["joy","sadness"],["sadness","joy"],["anger","calm"],["calm","anger"]].forEach(([e,i])=>{if(t.includes(e)&&t.includes(i))try{const t=ng(e,i),n=`${e}->${i}`;this.transitionCache.set(n,t)}catch(t){console.warn(`[EmotionCache] Failed to cache transition '${e}->${i}':`,t)}})}getEmotion(t){if(!this.isInitialized)return console.warn("[EmotionCache] Cache not initialized, falling back to direct access"),Km(t);const e=this.emotionCache.get(t);return e?(this.stats.hits++,e):(this.stats.misses++,console.warn(`[EmotionCache] Cache miss for emotion '${t}', consider adding to pre-cache`),Km(t))}getVisualParams(t){if(!this.isInitialized)return tg(t);const e=this.visualParamsCache.get(t);return e?(this.stats.hits++,e):(this.stats.misses++,tg(t))}getModifiers(t){if(!this.isInitialized)return eg(t);const e=this.modifiersCache.get(t);return e?(this.stats.hits++,e):(this.stats.misses++,eg(t))}getTransitionParams(t,e){if(!this.isInitialized)return ng(t,e);const i=`${t}->${e}`,n=this.transitionCache.get(i);return n?(this.stats.hits++,n):(this.stats.misses++,ng(t,e))}hasEmotion(t){return this.emotionCache.has(t)}getStats(){const t=this.stats.hits+this.stats.misses,e=t>0?(this.stats.hits/t*100).toFixed(2):0;return{isInitialized:this.isInitialized,loadTime:this.stats.loadTime,cacheSize:this.stats.cacheSize,hits:this.stats.hits,misses:this.stats.misses,hitRate:`${e}%`,emotions:this.emotionCache.size,visualParams:this.visualParamsCache.size,modifiers:this.modifiersCache.size,transitions:this.transitionCache.size}}clear(){this.emotionCache.clear(),this.visualParamsCache.clear(),this.modifiersCache.clear(),this.transitionCache.clear(),this.isInitialized=!1,this.stats={hits:0,misses:0,loadTime:0,cacheSize:0}}reinitialize(){this.clear(),this.initialize()}};function bg(t){if(!t||0===t.length)return"#FFFFFF";let e=0,i=0;const n=[];for(const s of t)"string"==typeof s?(n.push({color:s,weight:null}),i++):s&&"object"==typeof s&&s.color&&(n.push({color:s.color,weight:s.weight||null}),s.weight?e+=s.weight:i++);const s=Math.max(0,100-e),a=i>0?s/i:0,r=[];let o=0;for(const t of n)o+=null!==t.weight?t.weight:a,r.push({color:t.color,threshold:o});const l=Math.random()*o;for(const t of r)if(l<=t.threshold)return t.color;return n[n.length-1].color}var Mg={name:"ambient",emoji:"",description:"Gentle upward drift like smoke",initialize:function(t){t.vx=0,t.vy=-.04-.02*Math.random(),t.lifeDecay=.002,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={upwardSpeed:5e-4,waviness:0,friction:.998}},update:function(t,e,i,n){const s=t.behaviorData;t.vy*=Math.pow(s.friction,e),t.vy-=s.upwardSpeed*e,t.vx=0}};const _g=2*Math.PI;var xg={name:"orbiting",emoji:"",description:"Romantic firefly dance around the orb",initialize:function(t){t.lifeDecay=.001+.002*Math.random(),t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.isSparkle="#FFE4E1"===t.color||"#FFCCCB"===t.color||"#FFC0CB"===t.color;const e=40*(t.scaleFactor||1)*(1.3+.9*Math.random());t.blinkPhase=Math.random()*_g,t.blinkSpeed=.3+1.2*Math.random(),t.blinkIntensity=.6+.4*Math.random(),t.fadePhase=Math.random()*_g,t.fadeSpeed=.1+.3*Math.random(),t.minOpacity=.2+.2*Math.random(),t.maxOpacity=.8+.2*Math.random(),t.isSparkle&&(t.blinkSpeed*=2,t.blinkIntensity=1,t.minOpacity=0,t.maxOpacity=1),t.behaviorData={angle:Math.random()*_g,radius:e,baseRadius:e,angularVelocity:8e-4+.0017*Math.random(),swayAmount:3+7*Math.random(),swaySpeed:.2+.5*Math.random(),floatOffset:Math.random()*_g,floatSpeed:.3+.7*Math.random(),floatAmount:2+6*Math.random(),twinklePhase:Math.random()*_g,twinkleSpeed:2+3*Math.random()}},update:function(t,e,i,n){const s=t.behaviorData;s.angle+=s.angularVelocity*e;const a=Math.sin(s.angle*s.swaySpeed)*s.swayAmount,r=6*Math.sin(1.5*s.angle),o=(s.radius||s.baseRadius)+r+.2*a,l=i+Math.cos(s.angle)*o,h=n+Math.sin(s.angle)*o;s.floatOffset+=s.floatSpeed*e*.001;const c=Math.sin(s.floatOffset)*s.floatAmount;t.vx=.1*(l-t.x),t.vy=.1*(h+c-t.y),t.fadePhase+=t.fadeSpeed*e*.001;const u=.5*Math.sin(t.fadePhase)+.5,d=t.minOpacity+(t.maxOpacity-t.minOpacity)*u;let p;t.blinkPhase+=t.blinkSpeed*e*.002,t.isSparkle?(s.twinklePhase+=s.twinkleSpeed*e*.001,p=.7*Math.pow(Math.sin(s.twinklePhase),16)+.2*Math.sin(5*t.blinkPhase)+.1):p=.4*Math.sin(t.blinkPhase)+.3*Math.sin(3*t.blinkPhase)+.2*Math.sin(7*t.blinkPhase)+.1*Math.sin(11*t.blinkPhase);const m=.5*(p+1),g=.2+m*t.blinkIntensity*.8;t.opacity=t.baseOpacity*d*g,t.isSparkle?t.size=t.baseSize*(.5+1*m):t.size=t.baseSize*(.8+.3*m),t.isSparkle&&(t.tempColor=m>.85?"#FFFFFF":t.color)}},wg={name:"rising",emoji:"",description:"Buoyant upward movement like balloons",initialize:function(t){t.vx=.02*(Math.random()-.5),t.vy=-.05-.03*Math.random(),t.lifeDecay=.002,t.baseOpacity=.7+.3*Math.random(),t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={buoyancy:.001,driftAmount:.005}},update:function(t,e,i,n){const s=t.behaviorData;t.vy-=s.buoyancy*e,t.vx+=(Math.random()-.5)*s.driftAmount*e,t.vx*=Math.pow(.995,e),t.vy*=Math.pow(.998,e)}};function Sg(t){t.fallingData||(t.fallingData={originalX:t.x,originalY:t.y,originalOpacity:t.opacity??t.life??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),fallProgress:0}),t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors));const e=Math.random(),i=Math.random(),n=e*Math.PI*2,s=2*i-1,a=Math.sqrt(1-s*s);t.behaviorData={fallSpeed:8,fallDistance:400,wobbleAmount:1.5,fallingDir:{x:a*Math.cos(n),y:s,z:a*Math.sin(n)},orbitDistanceRatio:.7+.4*Math.random()}}var Tg={name:"falling",emoji:"",description:"Heavy downward drift like tears",initialize:Sg,update:function(t,e,i,n){const s=t.behaviorData;let a=t.fallingData;a||(Sg(t),a=t.fallingData),a.fallProgress+=.02*e;const r=Math.min(a.fallProgress,1),o=s.fallDistance*r;a.wobblePhase+=a.wobbleSpeed*e*.1;const l=Math.sin(a.wobblePhase)*s.wobbleAmount;if(t.x=a.originalX+l,t.y=a.originalY+o,t.vx=.3*l,t.vy=10*s.fallSpeed,r>.6){const e=(r-.6)/.4;t.opacity=a.originalOpacity*(1-e),void 0!==t.life&&(t.life=a.originalOpacity*(1-e))}}};const Cg=2e3,Eg=3,Ag=8,Pg=.7;var Dg={name:"popcorn",emoji:"",description:"Spontaneous popping with gravity and bounces",initialize:function(t){if(t.vx=.1*(Math.random()-.5),t.vy=.1*(Math.random()-.5),t.lifeDecay=.008+.012*Math.random(),t.emotionColors&&t.emotionColors.length>0)t.color=bg(t.emotionColors);else{const e=["#FFFFFF","#FFFACD","#FFF8DC","#FFFFE0","#FAFAD2"];t.color=bg(e)}t.size=Math.random()<.3?(8+4*Math.random())*t.scaleFactor*t.particleSizeMultiplier:(2+4*Math.random())*t.scaleFactor*t.particleSizeMultiplier,t.baseSize=t.size,t.hasGlow=Math.random()<.2,t.glowSizeMultiplier=t.hasGlow?1.2:0,t.behaviorData={popDelay:Math.random()*Cg,hasPopped:!1,popStrength:Eg+Math.random()*(Ag-Eg),gravity:.098,bounceDamping:Pg,bounceCount:0,maxBounces:2+Math.floor(2*Math.random()),spinRate:10*(Math.random()-.5),lifetime:0}},update:function(t,e,i,n){const s=t.behaviorData;if(s.lifetime+=16.67*e,!s.hasPopped&&s.lifetime>s.popDelay){s.hasPopped=!0;const e=Math.random()*Math.PI*2;t.vx=Math.cos(e)*s.popStrength*1.5,t.vy=Math.sin(e)*s.popStrength-.3,t.size=1.25*t.baseSize}if(s.hasPopped){t.vy+=s.gravity*e;const i=n+100*t.scaleFactor;t.y>i&&s.bounceCount<s.maxBounces&&(t.y=i,t.vy=-Math.abs(t.vy)*s.bounceDamping,t.vx*=.9,s.bounceCount++,t.size=t.baseSize*(1.5-.1*s.bounceCount)),s.bounceCount>=s.maxBounces&&(t.lifeDecay=.03+.02*Math.random(),t.size*=.95),Math.sqrt(t.vx*t.vx+t.vy*t.vy)<.5&&(t.lifeDecay*=1.5)}}},Rg={name:"burst",emoji:"",description:"Explosive expansion from center",initialize:function(t){const e="suspicion"===t.emotion,i="surprise"===t.emotion,n="glitch"===t.emotion,s=Math.random()*_g,a=e?1+.8*Math.random():i?7+5*Math.random():n?2+1.5*Math.random():3.5+2.5*Math.random();t.vx=Math.cos(s)*a,t.vy=Math.sin(s)*a,t.lifeDecay=e?.01:i?.006+.008*Math.random():n?.012:.015,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),e&&(t.size=(6+4*Math.random())*(t.scaleFactor||1)*(t.particleSizeMultiplier||1),t.baseSize=t.size,t.opacity=1,t.baseOpacity=t.opacity),t.behaviorData={isSuspicion:e,isSurprise:i,isGlitch:n,age:0,fadeStart:e?.3:.2,glitchPhase:Math.random()*Math.PI*2,glitchIntensity:n?.3:0,glitchFrequency:n?.1:0}},update:function(t,e,i,n){const s=t.behaviorData;if(s.isSurprise)if(s.age+=.016*e,s.age<.15){const i=.98;t.vx*=Math.pow(i,e),t.vy*=Math.pow(i,e)}else if(s.age<.25){const i=.85;t.vx*=Math.pow(i,e),t.vy*=Math.pow(i,e)}else{const i=.99;t.vx*=Math.pow(i,e),t.vy*=Math.pow(i,e),t.vx+=.01*(Math.random()-.5)*e,t.vy+=.01*(Math.random()-.5)*e}else{const i=s.isSuspicion?.99:s.isGlitch?.97:.95;t.vx*=Math.pow(i,e),t.vy*=Math.pow(i,e)}if(s.isSuspicion){const i=.001*Date.now();t.vx+=.01*Math.sin(2*i+t.id)*e}if(s.isGlitch){s.age+=.016*e,s.glitchPhase+=s.glitchFrequency*e;const i=Math.sin(s.glitchPhase)*s.glitchIntensity*e,n=Math.cos(1.3*s.glitchPhase)*s.glitchIntensity*e;if(t.vx+=i,t.vy+=n,Math.random()<.02){const e=Math.random()*Math.PI*2,i=.5+.5*Math.random();t.vx+=Math.cos(e)*i,t.vy+=Math.sin(e)*i}}}},Ig={name:"aggressive",emoji:"",description:"Sharp, chaotic movement with violent bursts",initialize:function(t){const e=Math.random()*_g,i=1.5+2*Math.random();t.vx=Math.cos(e)*i,t.vy=Math.sin(e)*i,t.lifeDecay=.015,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={acceleration:.05,jitter:.3,speedDecay:.95}},update:function(t,e,i,n){const s=t.behaviorData;if(t.vx+=(Math.random()-.5)*s.jitter*e,t.vy+=(Math.random()-.5)*s.jitter*e,t.vx*=Math.pow(s.speedDecay,e),t.vy*=Math.pow(s.speedDecay,e),Math.random()<Math.min(.05*e,.5)){const e=Math.random()*_g;t.vx+=Math.cos(e)*s.acceleration,t.vy+=Math.sin(e)*s.acceleration}}},Bg={name:"scattering",emoji:"",description:"Particles flee from center in panic",initialize:function(t){t.vx=0,t.vy=0,t.lifeDecay=.008,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={fleeSpeed:2,panicFactor:1.2,initialized:!1}},update:function(t,e,i,n){const s=t.behaviorData;if(!s.initialized){const e=t.x-i,a=t.y-n,r=Math.sqrt(e*e+a*a);if(r>0)t.vx=e/r*s.fleeSpeed,t.vy=a/r*s.fleeSpeed;else{const e=Math.random()*_g;t.vx=Math.cos(e)*s.fleeSpeed,t.vy=Math.sin(e)*s.fleeSpeed}s.initialized=!0}const a=t.x-i,r=t.y-n,o=Math.sqrt(a*a+r*r);o>0&&(t.vx+=a/o*s.panicFactor*.01*e,t.vy+=r/o*s.panicFactor*.01*e),t.vx+=.1*(Math.random()-.5)*e,t.vy+=.1*(Math.random()-.5)*e,t.vx*=Math.pow(.98,e),t.vy*=Math.pow(.98,e)}},Lg={name:"repelling",emoji:"",description:"Particles pushed away from center, maintaining distance",initialize:function(t){t.vx=0,t.vy=0,t.lifeDecay=.01,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={repelStrength:.8,minDistance:50,initialized:!1}},update:function(t,e,i,n){const s=t.behaviorData,a=t.x-i,r=t.y-n,o=Math.sqrt(a*a+r*r);if(!s.initialized||o<s.minDistance){if(o>0){const i=s.repelStrength/Math.max(o,5);t.vx+=a/o*i*e,t.vy+=r/o*i*e}s.initialized=!0}t.vx*=Math.pow(.99,e),t.vy*=Math.pow(.99,e)}},kg={name:"connecting",emoji:"",description:"Chaotic movement with center attraction for social states",initialize:function(t){const e=Math.random()*_g,i=2+5*Math.random();t.vx=Math.cos(e)*i,t.vy=Math.sin(e)*i,t.lifeDecay=.012,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={attractionForce:.008,chaosFactor:1,friction:.95}},update:function(t,e,i,n){const s=t.behaviorData;t.vx*=Math.pow(s.friction,e),t.vy*=Math.pow(s.friction,e);const a=(i-t.x)*s.attractionForce,r=(n-t.y)*s.attractionForce,o=(Math.random()-.5)*s.chaosFactor,l=(Math.random()-.5)*s.chaosFactor;t.vx+=a+o,t.vy+=r+l}},Og={name:"resting",emoji:"",description:"Ultra-slow vertical drift for deep rest states",initialize:function(t){t.vx=0,t.vy=-.01,t.lifeDecay=.001,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={upwardSpeed:2e-5,friction:.999}},update:function(t,e,i,n){const s=t.behaviorData;t.vy*=Math.pow(s.friction,e),t.vy-=s.upwardSpeed*e,t.vx=0}},zg={name:"radiant",emoji:"",description:"Particles radiate outward like sunbeams",initialize:function(t){const e=Math.random()*_g,i=.8+.4*Math.random();if(t.vx=Math.cos(e)*i,t.vy=Math.sin(e)*i,t.lifeDecay=.006,t.emotionColors&&t.emotionColors.length>0)t.color=bg(t.emotionColors);else{const e=["#FFD700","#FFB347","#FFA500","#FF69B4"];t.color=bg(e)}t.hasGlow=Math.random()<.7,t.glowSizeMultiplier=t.hasGlow?1.5+.5*Math.random():0,t.behaviorData={radialSpeed:.02,shimmer:Math.random()*_g,shimmerSpeed:.1,friction:.99}},update:function(t,e,i,n){const s=t.behaviorData,a=t.x-i,r=t.y-n,o=Math.sqrt(a*a+r*r);if(o>0){const i=a/o,n=r/o;t.vx+=i*s.radialSpeed*e,t.vy+=n*s.radialSpeed*e}s.shimmer+=s.shimmerSpeed*e;const l=Math.sin(s.shimmer);t.size=t.baseSize*(1+.2*l),t.opacity=t.baseOpacity*(1+.3*l),t.vx*=Math.pow(s.friction,e),t.vy*=Math.pow(s.friction,e)}};function Fg(t){t.vx=.02*(Math.random()-.5),t.vy=-.03-.02*Math.random(),t.lifeDecay=8e-4,t.size=(6+6*Math.random())*(t.scaleFactor||1)*(t.particleSizeMultiplier||1)*1.33,t.baseSize=t.size,t.baseOpacity=.2+.2*Math.random(),t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={ascensionSpeed:3e-4,waveFactor:.5,waveFrequency:.001,friction:.998,fadeStartDistance:100}}var Ug={name:"ascending",emoji:"",description:"Slow steady upward float like incense smoke",initialize:Fg,update:function(t,e,i,n){const s=t.behaviorData;if(!s)return void Fg(t);t.vx*=Math.pow(s.friction,e),t.vy*=Math.pow(s.friction,e),t.vy-=s.ascensionSpeed*e;const a=Math.sin(t.age*s.waveFrequency*1e3)*s.waveFactor;t.vx+=.001*a*e,void 0===t.initialY&&(t.initialY=t.y);const r=t.initialY-t.y;if(r>s.fadeStartDistance){const e=(r-s.fadeStartDistance)/100,i=Math.max(0,1-e);t.baseOpacity*=.995,i<.5&&(t.lifeDecay*=1.02)}Math.abs(t.vx)>.05&&(t.vx*=Math.pow(.95,e)),t.vy<-.1&&(t.vy=-.1)}},Ng={name:"erratic",emoji:"",description:"Nervous jittery movement for anxious states",initialize:function(t){const e=Math.random()*_g,i=.1+.15*Math.random();t.vx=Math.cos(e)*i,t.vy=Math.sin(e)*i,t.lifeDecay=.004,t.size=(2+4*Math.random())*(t.scaleFactor||1)*(t.particleSizeMultiplier||1),t.baseSize=t.size,t.baseOpacity=.4+.3*Math.random(),t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={jitterStrength:.02,directionChangeRate:.1,speedVariation:.3,spinRate:.05+.1*Math.random()}},update:function(t,e){const i=t.behaviorData;if(t.vx+=(Math.random()-.5)*i.jitterStrength*e,t.vy+=(Math.random()-.5)*i.jitterStrength*e,Math.random()<Math.min(i.directionChangeRate*e,.5)){const e=Math.random()*_g,i=Math.sqrt(t.vx*t.vx+t.vy*t.vy);t.vx=Math.cos(e)*i,t.vy=Math.sin(e)*i}const n=1+(Math.random()-.5)*i.speedVariation*e;t.vx*=n,t.vy*=n;const s=t.age*i.spinRate*1e3;t.size=t.baseSize*(1+.2*Math.sin(s)),t.opacity=t.baseOpacity*(.8+.4*Math.random()),t.vx*=Math.pow(.98,e),t.vy*=Math.pow(.98,e);const a=Math.sqrt(t.vx*t.vx+t.vy*t.vy);a>.5&&(t.vx=t.vx/a*.5,t.vy=t.vy/a*.5)}},Gg={name:"cautious",emoji:"",description:"Slow careful movement with watchful pauses",initialize:function(t){const e=Math.random()*_g,i=.02+.03*Math.random();t.vx=Math.cos(e)*i,t.vy=Math.sin(e)*i,t.lifeDecay=.001,t.life=1,t.size=(4+4*Math.random())*(t.scaleFactor||1)*(t.particleSizeMultiplier||1),t.baseSize=t.size,t.baseOpacity=.8+.2*Math.random(),t.opacity=t.baseOpacity,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={pauseTimer:2*Math.random(),pauseDuration:.5+.5*Math.random(),moveDuration:1+.5*Math.random(),isMoving:Math.random()>.5,moveTimer:0,originalVx:t.vx,originalVy:t.vy,watchRadius:50+30*Math.random()}},update:function(t,e,i,n){const s=t.behaviorData;if(s.moveTimer+=e,s.isMoving)s.moveTimer>s.moveDuration?(s.isMoving=!1,s.moveTimer=0,t.vx=0,t.vy=0):(t.vx=s.originalVx,t.vy=s.originalVy);else if(s.moveTimer>s.pauseDuration){s.isMoving=!0,s.moveTimer=0;const e=Math.random()*_g,i=.02+.03*Math.random();t.vx=Math.cos(e)*i,t.vy=Math.sin(e)*i,s.originalVx=t.vx,s.originalVy=t.vy}const a=t.x-i,r=t.y-n,o=Math.sqrt(a*a+r*r);if(o>s.watchRadius){const i=.02;t.vx-=a/o*i*e,t.vy-=r/o*i*e}t.vx*=Math.pow(.995,e),t.vy*=Math.pow(.995,e),s.isMoving?t.opacity=t.baseOpacity:t.opacity=t.baseOpacity*(.9+.1*Math.sin(5*t.age))}},Vg={name:"surveillance",emoji:"",description:"Searchlight scanning with paranoid watchfulness",initialize(t,e){t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorState={scanAngle:Math.random()*Math.PI-Math.PI/2,scanDirection:Math.random()<.5?1:-1,scanSpeed:.3+.2*Math.random(),scanRange:Math.PI/3+Math.random()*Math.PI/4,scanCenter:Math.random()*Math.PI*2,pauseTimer:0,pauseDuration:500+500*Math.random(),mode:"scanning",modeTimer:0,nextModeChange:2e3+3e3*Math.random(),dartTarget:{x:0,y:0},dartSpeed:0,patrolRadius:150+100*Math.random(),patrolAngle:Math.random()*Math.PI*2,alertLevel:0,lastPosition:{x:t.x,y:t.y}};const i=Math.random();i<.7?t.behaviorState.primaryRole="scanner":i<.9?(t.behaviorState.primaryRole="patroller",t.behaviorState.mode="patrolling"):(t.behaviorState.primaryRole="watcher",t.behaviorState.mode="frozen")},update(t,e,i){const n=t.behaviorState;if(n){switch(n.modeTimer+=16*e,n.modeTimer>n.nextModeChange&&(this.changeMode(t,n,i),n.modeTimer=0,n.nextModeChange=2e3+4e3*Math.random()),n.mode){case"scanning":this.updateScanning(t,e,n,i);break;case"darting":this.updateDarting(t,e,n,i);break;case"frozen":this.updateFrozen(t,e,n,i);break;case"patrolling":this.updatePatrolling(t,e,n,i)}t.vy+=.05*e,t.x+=t.vx*e,t.y+=t.vy*e,n.lastPosition.x=t.x,n.lastPosition.y=t.y}},updateScanning(t,e,i,n){i.pauseTimer>0?(i.pauseTimer-=16*e,t.vx*=.9,t.vy*=.9):(i.scanAngle+=i.scanDirection*i.scanSpeed*e*.02,Math.abs(i.scanAngle)>i.scanRange/2&&(i.scanDirection*=-1,i.pauseTimer=i.pauseDuration,i.scanAngle=Math.sign(i.scanAngle)*i.scanRange/2));const s=i.scanCenter+i.scanAngle,a=.8+.5*i.alertLevel;t.vx=Math.cos(s)*a,t.vy=Math.sin(s)*a*.3},updateDarting(t,e,i,n){const s=i.dartTarget.x-t.x,a=i.dartTarget.y-t.y,r=Math.sqrt(s*s+a*a);r>5?(t.vx=s/r*i.dartSpeed,t.vy=a/r*i.dartSpeed):(i.mode="scanning",i.modeTimer=0)},updateFrozen(t,e,i,n){t.vx*=.95,t.vy*=.95,Math.random()<.01&&(t.vx+=.5*(Math.random()-.5),t.vy+=.5*(Math.random()-.5))},updatePatrolling(t,e,i,n){i.patrolAngle+=.01*e;const s=n.corePosition?.x??n.canvasWidth/2,a=n.corePosition?.y??n.canvasHeight/2,r=s+Math.cos(i.patrolAngle)*i.patrolRadius,o=a+Math.sin(i.patrolAngle)*i.patrolRadius,l=r-t.x,h=o-t.y;t.vx=.02*l,t.vy=.02*h},changeMode(t,e,i){const n=Math.random(),s=i?.corePosition?.x??(i?.canvasWidth/2||t.x),a=i?.corePosition?.y??(i?.canvasHeight/2||t.y);"scanner"===e.primaryRole?n<.1?(e.mode="darting",e.dartTarget={x:s+200*(Math.random()-.5),y:a+200*(Math.random()-.5)},e.dartSpeed=3+2*Math.random()):e.mode=n<.2?"frozen":"scanning":"patroller"===e.primaryRole?e.mode=n<.1?"frozen":"patrolling":e.mode=n<.3?"scanning":"frozen"}},Hg={name:"glitchy",emoji:"",description:"Digital glitch with stuttering orbits and corruption",rhythm:{enabled:!0,glitchTiming:{mode:"subdivision",subdivision:"sixteenth",probability:.3,intensityOnBeat:2,intensityOffBeat:.5},stutterSync:{mode:"pattern",patterns:{dubstep:{freezeOnDrop:!0,dropDuration:100},breakbeat:{randomFreeze:.1,duration:50}}},orbitRhythm:{baseSpeed:"tempo",wobbleSync:"eighth",beatAcceleration:1.5,barReset:!0},rgbSync:{enabled:!0,amount:"intensity",direction:"beat",maxSplit:10},noiseRhythm:{trigger:"accent",duration:50,intensity:"drop"}},initialize(t,e,i,n){t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorState={orbitAngle:Math.random()*Math.PI*2,orbitRadius:300+400*Math.random(),orbitSpeed:.01+.02*Math.random(),glitchTimer:0,nextGlitch:500*Math.random()+100,isGlitching:!1,glitchDuration:0,glitchOffset:{x:0,y:0},stutterTimer:0,nextStutter:200*Math.random()+50,isFrozen:!1,frozenPosition:{x:0,y:0},frozenVelocity:{x:0,y:0},hasGhost:Math.random()<.3,ghostOffset:20*Math.random()+10,ghostAngle:Math.random()*Math.PI*2,rgbSplit:Math.random()<.4,rgbPhase:Math.random()*Math.PI*2,noiseLevel:0,noiseBurst:!1,beatPhase:Math.random()*Math.PI*2,beatFrequency:.05+.03*Math.random(),dropIntensity:0},t.lifeDecay=.0015,t.hasGlow=!0,t.glowSizeMultiplier=3+2*Math.random()},update(t,e,i,n){const s=t.behaviorState;if(!s)return;s.glitchTimer+=16*e,s.stutterTimer+=16*e,s.stutterTimer>s.nextStutter&&(s.isFrozen?(s.isFrozen=!1,s.stutterTimer=0,s.nextStutter=100+300*Math.random(),Math.random()<.3&&(t.x+=60*(Math.random()-.5),t.y+=60*(Math.random()-.5))):(s.isFrozen=!0,s.frozenPosition={x:t.x,y:t.y},s.frozenVelocity={x:t.vx,y:t.vy},s.stutterTimer=0,s.nextStutter=20+40*Math.random())),s.glitchTimer>s.nextGlitch&&!s.isGlitching&&(s.isGlitching=!0,s.glitchDuration=50+100*Math.random(),s.glitchOffset={x:80*(Math.random()-.5),y:80*(Math.random()-.5)},s.glitchTimer=0,Math.random()<.5&&t.emotionColors&&(t.color=bg(t.emotionColors))),s.isGlitching&&s.glitchTimer>s.glitchDuration&&(s.isGlitching=!1,s.glitchTimer=0,s.nextGlitch=200+800*Math.random(),s.glitchOffset={x:0,y:0}),s.beatPhase+=s.beatFrequency*e;const a=.5*Math.sin(s.beatPhase)+.5;if(s.beatPhase%(4*Math.PI)<.5*Math.PI?s.dropIntensity=Math.min(1,s.dropIntensity+.1*e):s.dropIntensity=Math.max(0,s.dropIntensity-.05*e),s.isFrozen)t.vx=.5*(Math.random()-.5),t.vy=.5*(Math.random()-.5);else{s.orbitAngle+=s.orbitSpeed*e*(1+.5*a);const r=s.orbitRadius*(1+.3*s.dropIntensity*Math.sin(4*s.beatPhase));let o=i+Math.cos(s.orbitAngle)*r,l=n+Math.sin(s.orbitAngle)*r*.6;if(s.isGlitching&&(o+=s.glitchOffset.x*Math.random()*.8,l+=s.glitchOffset.y*Math.random()*.8),s.rgbSplit){const t=3*(1+s.dropIntensity);o+=Math.sin(s.rgbPhase)*t,l+=Math.cos(s.rgbPhase)*t,s.rgbPhase+=.1*e}s.dropIntensity>.8&&Math.random()<.1&&(o+=30*(Math.random()-.5),l+=30*(Math.random()-.5));const h=s.isGlitching?.02:.03;t.vx=(o-t.x)*h,t.vy=(l-t.y)*h,t.vx+=(Math.random()-.5)*a*2,t.vy+=(Math.random()-.5)*a*2}t.x+=t.vx*e,t.y+=t.vy*e,Math.random()<.02&&(t.opacity=.1+.9*Math.random()),t.size=t.baseSize*(1+.3*a+.5*s.dropIntensity)}},Wg={name:"spaz",description:"Ultra-aggressive particles with explosive spread and chaotic motion",initialize(t,e,i,n){t.x=i,t.y=n,t.life=1,t.size=3+4*Math.random();const s=Math.random()*Math.PI*2,a=200+300*Math.random();t.vx=Math.cos(s)*a,t.vy=Math.sin(s)*a,t.behaviorState={explosionPhase:0,explosionTimer:0,explosionDuration:1e3+2e3*Math.random(),chaosTimer:0,nextChaosChange:100+200*Math.random(),chaosAngle:s,chaosSpeed:50+100*Math.random(),spazIntensity:.8+.4*Math.random(),zigzagPattern:Math.random()<.5,spiralPattern:Math.random()<.3,teleportChance:.02,sizePulse:!0,sizePulseSpeed:.1+.05*Math.random(),sizePulsePhase:Math.random()*Math.PI*2,colorShift:Math.random()<.3,colorShiftSpeed:.05+.03*Math.random()},t.lifeDecay=8e-4,t.hasGlow=!0,t.glowSizeMultiplier=4+3*Math.random(),t.glowIntensity=1.5+.5*Math.random()},update(t,e,i,n){const s=t.behaviorState;if(s.explosionTimer+=e,s.chaosTimer+=e,0===s.explosionPhase&&s.explosionTimer<500)t.vx*=.98,t.vy*=.98,Math.random()<.1&&(t.vx+=100*(Math.random()-.5),t.vy+=100*(Math.random()-.5));else if(0===s.explosionPhase&&s.explosionTimer>=500)s.explosionPhase=1,s.chaosAngle=Math.random()*Math.PI*2,s.chaosSpeed=30+70*Math.random();else if(1===s.explosionPhase){s.chaosTimer>=s.nextChaosChange&&(s.chaosAngle=Math.random()*Math.PI*2,s.chaosSpeed=20+80*Math.random(),s.nextChaosChange=50+150*Math.random(),s.chaosTimer=0);const e=Math.cos(s.chaosAngle)*s.chaosSpeed,i=Math.sin(s.chaosAngle)*s.chaosSpeed;if(t.vx=.7*t.vx+.3*e,t.vy=.7*t.vy+.3*i,s.zigzagPattern){const e=.01*s.chaosTimer;t.vx+=20*Math.sin(e),t.vy+=20*Math.cos(e)}if(s.spiralPattern){const e=.005*s.chaosTimer,i=50+30*Math.sin(.003*s.chaosTimer);t.vx+=Math.cos(e)*i*.1,t.vy+=Math.sin(e)*i*.1}}if(Math.random()<s.teleportChance){const e=Math.random()*Math.PI*2,s=200+400*Math.random();t.x=i+Math.cos(e)*s,t.y=n+Math.sin(e)*s,t.vx=200*(Math.random()-.5),t.vy=200*(Math.random()-.5)}if(t.x+=t.vx*(e/1e3),t.y+=t.vy*(e/1e3),s.sizePulse){s.sizePulsePhase+=s.sizePulseSpeed*e;const i=1+.5*Math.sin(s.sizePulsePhase);t.size=(3+4*Math.random())*i}s.colorShift&&(s.colorShiftPhase=(s.colorShiftPhase||0)+s.colorShiftSpeed*e),t.vx*=.995,t.vy*=.995,t.life-=t.lifeDecay*e,(t.life<=0||Math.abs(t.x-i)>2e3||Math.abs(t.y-n)>2e3)&&(t.life=0)},getSpawnPosition(t,e){const i=Math.random()*Math.PI*2,n=100+200*Math.random();return{x:t+Math.cos(i)*n,y:e+Math.sin(i)*n}},getVisualProperties:()=>({glowColor:"#FF00AA",glowIntensity:2,particleColors:[{color:"#FF00AA",weight:30},{color:"#00FFAA",weight:25},{color:"#FFAA00",weight:20},{color:"#AA00FF",weight:15},{color:"#00AAFF",weight:10}]})},jg={name:"directed",emoji:"",description:"Focused, straight-line movement toward target",config:{speed:3,acceleration:.15,focusStrength:.8,randomness:.1,edgeBuffer:50},initialize(t,e,i,n,s){const a=e-t.x,r=i-t.y,o=Math.sqrt(a*a+r*r);if(o>0)t.vx=a/o*this.config.speed,t.vy=r/o*this.config.speed;else{const e=Math.random()*Math.PI*2;t.vx=Math.cos(e)*this.config.speed,t.vy=Math.sin(e)*this.config.speed}t.targetX=e,t.targetY=i,t.directedPhase=0},update(t,e,i,n,s,a){t.directedPhase+=.05*e;const r=t.targetX-t.x,o=t.targetY-t.y,l=Math.sqrt(r*r+o*o);if(l>10){const i=r/l*this.config.speed,n=o/l*this.config.speed;t.vx+=(i-t.vx)*this.config.acceleration*e,t.vy+=(n-t.vy)*this.config.acceleration*e,t.vx+=(Math.random()-.5)*this.config.randomness,t.vy+=(Math.random()-.5)*this.config.randomness}else{const e=Math.random()*Math.PI*2,r=100+200*Math.random();t.targetX=i+Math.cos(e)*r,t.targetY=n+Math.sin(e)*r,t.targetX=Math.max(this.config.edgeBuffer,Math.min(s-this.config.edgeBuffer,t.targetX)),t.targetY=Math.max(this.config.edgeBuffer,Math.min(a-this.config.edgeBuffer,t.targetY))}t.x+=t.vx*e,t.y+=t.vy*e,(t.x<=0||t.x>=s)&&(t.vx*=-.8,t.x=Math.max(0,Math.min(s,t.x)),t.targetX=i+300*(Math.random()-.5)),(t.y<=0||t.y>=a)&&(t.vy*=-.8,t.y=Math.max(0,Math.min(a,t.y)),t.targetY=n+300*(Math.random()-.5))},visuals:{trailLength:"medium",opacity:.9,sizeMultiplier:1,blurAmount:.2}},Xg={name:"fizzy",emoji:"",description:"Bubbly, effervescent movement like carbonation",config:{baseRiseSpeed:2.5,wobbleAmplitude:30,wobbleFrequency:.15,popChance:.002,popForce:8,fizziness:.3,gravity:-.05},initialize(t,e,i,n,s){t.vx=2*(Math.random()-.5),t.vy=-this.config.baseRiseSpeed-2*Math.random(),t.wobblePhase=Math.random()*Math.PI*2,t.wobbleSpeed=this.config.wobbleFrequency*(.8+.4*Math.random()),t.bubbleSize=.5+.5*Math.random(),t.popTimer=0,t.isFizzing=!0},update(t,e,i,n,s,a){t.wobblePhase+=t.wobbleSpeed*e;const r=Math.sin(t.wobblePhase)*this.config.wobbleAmplitude;if(t.vx=.05*r+(Math.random()-.5)*this.config.fizziness,t.vy+=this.config.gravity*e,t.vy+=(Math.random()-.5)*this.config.fizziness,Math.random()<this.config.popChance){const e=Math.random()*Math.PI*2;t.vx=Math.cos(e)*this.config.popForce,t.vy=Math.sin(e)*this.config.popForce*.7,t.popTimer=1,t.bubbleSize=.3+.7*Math.random()}t.popTimer>0&&(t.popTimer-=.05*e,t.vx*=.95,t.vy*=.95),t.x+=t.vx*e,t.y+=t.vy*e,t.y<-50&&(t.y=a+50,t.x=i+300*(Math.random()-.5),t.vy=-this.config.baseRiseSpeed-2*Math.random(),t.bubbleSize=.5+.5*Math.random()),(t.x<=0||t.x>=s)&&(t.vx*=-.5,t.x=Math.max(0,Math.min(s,t.x))),t.y>a+50&&(t.y=a,t.vy=1.5*-this.config.baseRiseSpeed),t.size=t.baseSize*t.bubbleSize*(1+.1*Math.sin(2*t.wobblePhase))},visuals:{trailLength:"short",opacity:.6,sizeMultiplier:1.2,blurAmount:.5,sparkle:!0}};var qg={name:"zen",emoji:"",description:"Peaceful orbital movement like a hovering aura",initialize:function(t){t.vx=.5*(Math.random()-.5),t.vy=.5*(Math.random()-.5),t.lifeDecay=.003,t.emotionColors&&t.emotionColors.length>0&&(t.color=bg(t.emotionColors)),t.behaviorData={orbitAngle:Math.random()*Math.PI*2,orbitRadius:40+60*Math.random(),orbitSpeed:8e-4+6e-4*Math.random(),floatOffset:Math.random()*Math.PI*2,breathingOffset:Math.random()*Math.PI*2,lifetime:0}},update:function(t,e,i,n){const s=t.behaviorData;if(!s)return;s.lifetime+=e;const a=(s.lifetime+8e3*s.breathingOffset)/8e3,r=.5*Math.sin(a*Math.PI*2)+.5;t.size=t.baseSize*(.95+.05*r),s.orbitAngle+=s.orbitSpeed*e;const o=10*Math.sin(1e-4*s.lifetime+s.floatOffset),l=s.orbitRadius+o,h=i+Math.cos(s.orbitAngle)*l,c=n+Math.sin(s.orbitAngle)*l,u=15*Math.sin(3e-4*s.lifetime+s.breathingOffset),d=h-t.x,p=c+u-t.y;t.vx=.03*d,t.vy=.03*p,t.vx+=.02*(Math.random()-.5),t.vy+=.02*(Math.random()-.5),t.vx*=.98,t.vy*=.98}};const Yg=new Map;var $g=function(t){return Yg.get(t)||null},Zg=function(){return Array.from(Yg.keys())};const Jg={};function Qg(t){if(Jg[t])return Jg[t];return $g(t)||null}function Kg(t,e){const i=Qg(e);return i&&i.initialize?(i.initialize(t),!0):"ambient"!==e&&(console.warn(` Behavior '${e}' not found, falling back to ambient`),Kg(t,"ambient"))}function tf(t,e,i,n,s){const a=Qg(e);return!(!a||!a.update||(a.update(t,i,n,s),0))}[Mg,jg,Xg,xg,wg,Tg,Dg,Rg,Ig,Bg,Lg,kg,Og,zg,Ug,Ng,Gg,Vg,Hg,Wg,qg].forEach(t=>{Jg[t.name]=t}),"undefined"!=typeof window&&window.DEBUG_PARTICLES&&(window.ParticleBehaviors={registry:Jg,list:function(){return[...Object.values(Jg).map(t=>({name:t.name,emoji:t.emoji||"",description:t.description||"No description",type:"core"})),...Zg().map(t=>{const e=$g(t);return{name:e.name,emoji:e.emoji||"",description:e.description||"Plugin behavior",type:"plugin"}})]},get:Qg});const ef=new Map;var nf=function(t){return ef.get(t)||null},sf=function(){return Array.from(ef.keys())},af={name:"breathe",emoji:"",type:"blending",description:"Breathing rhythm with inhale and exhale",config:{musicalDuration:{musical:!0,bars:1,minBeats:2,maxBeats:16},phases:[{name:"inhale",beats:1.5},{name:"hold_in",beats:.5},{name:"exhale",beats:1.5},{name:"hold_out",beats:.5}],inhaleRadius:1.5,exhaleRadius:.3,breathRate:.3,spiralStrength:.002,scaleAmount:.25,glowAmount:.4,frequency:1,easing:"sine",strength:.8,particleMotion:{type:"breathe",strength:.8,inhaleRadius:1.5,exhaleRadius:.3}},rhythm:{enabled:!0,syncMode:"phrase",breathRateSync:{mode:"tempo",bpm:"auto",subdivision:"whole",curve:"sine"},radiusSync:{inhale:{onUpbeat:1.8,onDownbeat:1.4,curve:"ease-in"},exhale:{onUpbeat:.2,onDownbeat:.4,curve:"ease-out"}},durationSync:{mode:"phrases",phrases:2,hold:"fermata"},accentResponse:{enabled:!0,multiplier:1.5,type:"expansion"},patternOverrides:{ballad:{breathRateSync:{subdivision:"double-whole"},radiusSync:{inhale:{onUpbeat:2.2,onDownbeat:1.8},exhale:{onUpbeat:.1,onDownbeat:.2}}},uptempo:{breathRateSync:{subdivision:"half"},radiusSync:{inhale:{onUpbeat:1.4,onDownbeat:1.2},exhale:{onUpbeat:.3,onDownbeat:.4}}},ambient:{breathRateSync:{subdivision:"whole",curve:"ease"},radiusSync:{inhale:{onUpbeat:1.6,onDownbeat:1.6},exhale:{onUpbeat:.2,onDownbeat:.2}}}},dynamics:{forte:{radiusSync:{inhale:{multiplier:1.8},exhale:{multiplier:.5}},spiralStrength:.004,scaleAmount:.4},piano:{radiusSync:{inhale:{multiplier:1.2},exhale:{multiplier:.8}},spiralStrength:.001,scaleAmount:.1}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n;t.gestureData.breathe={startX:t.x,startY:t.y,angle:Math.atan2(a,s),baseRadius:Math.sqrt(s*s+a*a),phaseOffset:.2*Math.random()-.1}},apply(t,e,i,n,s,a){t.gestureData?.breathe||this.initialize(t,i,s,a);const r={...this.config,...i},o=(Math.sin(e*Math.PI*2*r.breathRate)+1)/2,l=100*(t.scaleFactor||1),h=r.inhaleRadius*l,c=r.exhaleRadius*l,u=c+(h-c)*o,d=t.x-s,p=t.y-a,m=Math.sqrt(d*d+p*p),g=u-m,f=.05*(i.strength||.8)*n;if(m>0){const e=d/m*g*f,s=p/m*g*f;t.vx+=e,t.vy+=s;const a=r.spiralStrength*n*(i.strength||1),l=-p/m,h=d/m;t.vx+=l*a*o,t.vy+=h*a*o}t.vx*=.98,t.vy*=.98},cleanup(t){t.gestureData?.breathe&&delete t.gestureData.breathe},"3d":{evaluate(t,e){const i=(e.config||{}).breathRate||.3,n=Math.sin(t*Math.PI*2*i);let s=1;if(t>.8){const e=(t-.8)/(1-.8);s=1-e*e*e}const a=.2*n*s;return{position:[0,.05*n*s,0],rotation:[0,0,0],scale:1+.35*n*s,glowIntensity:1+a,glowBoost:Math.max(0,2*a)}}}},rf={name:"expand",emoji:"",type:"blending",description:"Radial expansion from center",config:{duration:600,scaleAmount:3,scaleTarget:3,glowAmount:.5,easing:"back",strength:3,particleMotion:{type:"pulse",strength:3,direction:"outward",persist:!0}},rhythm:{enabled:!0,syncMode:"crescendo",strengthSync:{pianissimo:1.5,fortissimo:5,crescendo:"build",sforzando:"burst"},scaleTargetSync:{verse:2,chorus:4.5,climax:6,curve:"exponential"},durationSync:{mode:"phrases",build:1.2,release:.8,sustain:"hold"},accentResponse:{enabled:!0,multiplier:2.8,type:"strength"},patternOverrides:{orchestral:{strengthSync:{pianissimo:2,fortissimo:6.5,crescendo:"dramatic"},scaleTargetSync:{climax:8}},rock:{strengthSync:{pianissimo:1.8,fortissimo:5.5,curve:"power"},accentResponse:{multiplier:3.2}},ambient:{strengthSync:{pianissimo:1.2,fortissimo:3.5,crescendo:"organic"},durationSync:{build:1.8,release:1.2}},electronic:{strengthSync:{pianissimo:1.6,fortissimo:4.8,curve:"digital"},scaleTargetSync:{curve:"linear"}}},dynamics:{forte:{strengthSync:{pianissimo:{multiplier:1.4},fortissimo:{multiplier:1.8}},scaleTargetSync:{multiplier:1.6},accentResponse:{multiplier:3.5}},piano:{strengthSync:{pianissimo:{multiplier:.8},fortissimo:{multiplier:1.2}},scaleTargetSync:{multiplier:.7},accentResponse:{multiplier:2}}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n;t.gestureData.expand={startX:t.x,startY:t.y,angle:Math.atan2(a,s),baseRadius:Math.sqrt(s*s+a*a),initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.expand?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.expand,o={...this.config,...i},l=o.strength||1,h=1+(o.scaleTarget-1)*e*l,c=r.baseRadius*h,u=s+Math.cos(r.angle)*c,d=a+Math.sin(r.angle)*c,p=u-t.x,m=d-t.y;t.vx+=.8*p*n,t.vy+=.8*m*n,t.vx*=.95,t.vy*=.95},cleanup(t){t.gestureData?.expand&&delete t.gestureData.expand},"3d":{evaluate(t,e){const i={...this.config,...e},n=i.strength||3;return{position:[0,0,0],rotation:[0,0,0],scale:1+t*(i.scaleAmount||3)*(n/3),glowIntensity:1+.25*t,glowBoost:.8*t}}}},of={name:"contract",emoji:"",type:"blending",description:"Radial contraction toward center",config:{duration:600,scaleAmount:.2,scaleTarget:.2,glowAmount:-.2,easing:"cubic",strength:2.5,particleMotion:{type:"pulse",strength:2.5,direction:"inward",persist:!0}},rhythm:{enabled:!0,syncMode:"tension",strengthSync:{onTension:4,onRelease:1.5,curve:"magnetic"},scaleTargetSync:{forte:.1,piano:.4,crescendo:"gradual",diminuendo:"ease"},durationSync:{mode:"phrases",shortPhrase:.8,longPhrase:1.5,hold:"sustain"},accentResponse:{enabled:!0,multiplier:2.2,type:"strength"},patternOverrides:{classical:{strengthSync:{onTension:3.5,onRelease:1.8},scaleTargetSync:{forte:.15,piano:.35}},metal:{strengthSync:{onTension:5,onRelease:2,curve:"sharp"},scaleTargetSync:{forte:.05,piano:.25}},ambient:{strengthSync:{onTension:2.8,onRelease:1.2,curve:"ease"},durationSync:{shortPhrase:1.2,longPhrase:2}},trap:{strengthSync:{onTension:4.5,onRelease:1,dropBeat:6},scaleTargetSync:{forte:.08,piano:.3}}},dynamics:{forte:{strengthSync:{onTension:{multiplier:1.8},onRelease:{multiplier:1.4}},scaleTargetSync:{multiplier:.6},accentResponse:{multiplier:2.8}},piano:{strengthSync:{onTension:{multiplier:.7},onRelease:{multiplier:.8}},scaleTargetSync:{multiplier:1.4},accentResponse:{multiplier:1.6}}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n;t.gestureData.contract={startX:t.x,startY:t.y,angle:Math.atan2(a,s),baseRadius:Math.sqrt(s*s+a*a),initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.contract?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.contract,o={...this.config,...i},l=o.strength||1,h=1-(1-o.scaleTarget)*e*l,c=r.baseRadius*h,u=s+Math.cos(r.angle)*c,d=a+Math.sin(r.angle)*c,p=u-t.x,m=d-t.y;t.vx+=.5*p*n,t.vy+=.5*m*n,t.vx*=.95,t.vy*=.95},cleanup(t){t.gestureData?.contract&&delete t.gestureData.contract},"3d":{evaluate(t,e){const i={...this.config,...e},n=i.strength||2.5,s=i.scaleTarget||.2,a=1-t*(1-s)*(n/2.5),r=1-.15*t;return{position:[0,0,0],rotation:[0,0,0],scale:Math.max(s,a),glowIntensity:r}}}},lf={name:"pulse",emoji:"",type:"blending",description:"Radial expansion and contraction from center",config:{duration:600,amplitude:30,frequency:1,holdPeak:.1,easing:"sine",scaleAmount:.2,glowAmount:.3,strength:.15,direction:"outward",particleMotion:{type:"pulse",strength:.15,direction:"outward",frequency:1}},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.6,offBeat:.8,curve:"pulse"},frequencySync:{mode:"locked",subdivision:"quarter"},durationSync:{mode:"beats",beats:1},accentResponse:{enabled:!0,multiplier:2},patternOverrides:{waltz:{amplitudeSync:{onBeat:2,offBeat:.5},durationSync:{beats:3}},swing:{amplitudeSync:{onBeat:1.8,offBeat:.6,curve:"ease"},frequencySync:{subdivision:"swing"}},dubstep:{amplitudeSync:{onBeat:1.2,dropBeat:4,curve:"pulse"}},breakbeat:{frequencySync:{mode:"random",range:[.5,2]},amplitudeSync:{onBeat:2.5,offBeat:.3}}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n,r=Math.sqrt(s*s+a*a),o=Math.atan2(a,s);t.gestureData.pulse={baseDistance:r,angle:o,startX:t.x,startY:t.y,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.pulse?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.pulse,o={...this.config,...i},l=i.strength||1,h=this.easeInOutSine(e);let c,{frequency:u}=o,{amplitude:d}=o;i.rhythmModulation&&(d*=i.rhythmModulation.amplitudeMultiplier||1,d*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(u*=i.rhythmModulation.frequencyMultiplier));const p=h*u*2%2;c=o.holdPeak>0&&p>1-o.holdPeak&&p<1+o.holdPeak?1:Math.sin(h*Math.PI*2*u);const m=c*d*l*t.scaleFactor,g=r.baseDistance+m,f=s+Math.cos(r.angle)*g,y=a+Math.sin(r.angle)*g,v=.15*n;if(t.vx+=(f-t.x)*v*.1,t.vy+=(y-t.y)*v*.1,e>.9){const i=1-10*(e-.9);t.vx*=.9+.1*i,t.vy*=.9+.1*i}},cleanup(t){t.gestureData?.pulse&&delete t.gestureData.pulse},easeInOutSine:t=>-(Math.cos(Math.PI*t)-1)/2,"3d":{evaluate(t,e){const i=e||{},n=i.frequency||1,s=i.strength||.15,a=i.scaleAmount||.2,r=i.glowAmount||.3,o=-(Math.cos(Math.PI*t)-1)/2,l=Math.sin(o*Math.PI*2*n);return{position:[0,0,0],rotation:[0,0,0],scale:1+l*a*s,glowIntensity:1+Math.max(-.3,Math.min(.3,l*r*s*2)),glowBoost:Math.max(0,.8*l)}}}},hf={name:"sway",type:"blending",emoji:"",description:"Gentle side-to-side swaying motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},amplitude:20,frequency:1,strength:.5},rhythm:{enabled:!0,syncMode:"bar",amplitudeSync:{onBeat:1.2,offBeat:.9,curve:"ease"},durationSync:{mode:"bars",bars:1},patternOverrides:{waltz:{durationSync:{bars:1},amplitudeSync:{onBeat:1.5,curve:"ease"}},swing:{amplitudeSync:{onBeat:1.3,offBeat:.7,curve:"bounce"}}}},apply(t,e,i,n,s,a){const r={...this.config,...i},o=r.amplitude||this.config.amplitude,l=r.frequency||this.config.frequency,h=r.strength||this.config.strength,c=Math.sin(e*Math.PI*2*l)*o;t.vx+=.01*c*n*h,t.vy+=.5*Math.cos(e*Math.PI*4)*n*h},cleanup(t){},"3d":{evaluate(t,e){const i={...this.config,...e};let n=i.amplitude||this.config.amplitude;const s=i.frequency||this.config.frequency,a=i.strength||this.config.strength;e.rhythmModulation&&(n*=e.rhythmModulation.amplitudeMultiplier||1,n*=e.rhythmModulation.accentMultiplier||1);const r=Math.sin(t*Math.PI*2*s),o=n*a*.3*.01,l=.15*r*a,h=.08*r*a;return{position:[r*o,.3*Math.cos(t*Math.PI*4)*o,Math.sin(t*Math.PI*s)*o*.5],rotation:[0,h,l],scale:1}}}},cf={name:"float",type:"blending",emoji:"",description:"Gentle floating upward motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:2},amplitude:80,wobbleAmount:20,strength:1},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},wobbleSync:{subdivision:"eighth",intensity:.7},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:1.3},patternOverrides:{waltz:{wobbleSync:{subdivision:"quarter",intensity:.9}},dubstep:{amplitudeSync:{onBeat:2,curve:"pulse"}}}},apply(t,e,i,n,s,a){t.gestureData||(t.gestureData={}),t.gestureData.float||(t.gestureData.float={originalSize:t.size,originalOpacity:t.opacity||1});const r={...this.config,...i};let o=r.amplitude||this.config.amplitude,l=r.wobbleAmount||this.config.wobbleAmount;const h=r.strength||this.config.strength;i.rhythmModulation&&(o*=i.rhythmModulation.amplitudeMultiplier||1,o*=i.rhythmModulation.accentMultiplier||1,l*=i.rhythmModulation.wobbleMultiplier||1);const c=Math.sin(e*Math.PI*4)*l;t.vy-=.01*o*n*h*(1-.5*e),t.vx+=.01*c*n*h,t.size=t.baseSize*(1+.1*e),t.opacity=1-.3*e},cleanup(t){t.gestureData?.float?(t.opacity=t.gestureData.float.originalOpacity,t.size=t.gestureData.float.originalSize,delete t.gestureData.float):(t.opacity=1,t.size=t.baseSize),t.vx*=.5,t.vy*=.5},"3d":{evaluate(t,e){const i={...this.config,...e};let n=i.amplitude||this.config.amplitude,s=i.wobbleAmount||this.config.wobbleAmount;const a=i.strength||this.config.strength;e.rhythmModulation&&(n*=e.rhythmModulation.amplitudeMultiplier||1,n*=e.rhythmModulation.accentMultiplier||1,s*=e.rhythmModulation.wobbleMultiplier||1);const r=Math.sin(t*Math.PI),o=n*r*a*.005,l=Math.sin(t*Math.PI*4)*s*.3*.005,h=Math.sin(t*Math.PI)*Math.PI*.5*a,c=Math.sin(t*Math.PI);return{position:[l,o,0],rotation:[c*Math.sin(t*Math.PI*2)*.1,h,c*Math.cos(t*Math.PI*3)*.08],scale:1+.1*r}}}};const uf={left:{x:-1,y:0},right:{x:1,y:0},up:{x:0,y:1},down:{x:0,y:-1}};function df(t){return t.charAt(0).toUpperCase()+t.slice(1)}function pf(t){const e=uf[t];if(!e)throw new Error(`Invalid float direction: ${t}`);const i="up"===t||"down"===t;return{name:`float${df(t)}`,emoji:"up"===t?"":"down"===t?"":"left"===t?"":"",type:"blending",description:`Gentle floating ${t}`,config:{duration:2e3,amplitude:80,wobbleAmount:20,strength:1,direction:t},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},wobbleSync:{subdivision:"eighth",intensity:.7},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:1.3}},apply(t,n,s,a,r,o){t.gestureData||(t.gestureData={}),t.gestureData.float||(t.gestureData.float={originalSize:t.size,originalOpacity:t.opacity||1});const l={...this.config,...s};let h=l.amplitude||80,c=l.wobbleAmount||20;const u=l.strength||1;s.rhythmModulation&&(h*=s.rhythmModulation.amplitudeMultiplier||1,h*=s.rhythmModulation.accentMultiplier||1,c*=s.rhythmModulation.wobbleMultiplier||1);const d=Math.sin(n*Math.PI*4)*c,p=.01*h*a*u*(1-.5*n);i?(t.vy+=e.y*p,t.vx+=.01*d*a*u):(t.vx+=e.x*p,t.vy+=.01*d*a*u),t.size=t.baseSize*(1+.1*n),t.opacity=1-.3*n},cleanup(t){t.gestureData?.float?(t.opacity=t.gestureData.float.originalOpacity,t.size=t.gestureData.float.originalSize,delete t.gestureData.float):(t.opacity=1,t.size=t.baseSize),t.vx*=.5,t.vy*=.5},"3d":{evaluate(t,n){const s=n||{};let a=s.amplitude||80,r=s.wobbleAmount||20;const o=s.strength||1;n.rhythmModulation&&(a*=n.rhythmModulation.amplitudeMultiplier||1,a*=n.rhythmModulation.accentMultiplier||1,r*=n.rhythmModulation.wobbleMultiplier||1);const l=Math.sin(t*Math.PI),h=a*l*o*.005,c=Math.sin(t*Math.PI*4)*r*.3*.005,u=Math.sin(t*Math.PI)*Math.PI*.5*o,d=Math.sin(t*Math.PI),p=d*Math.sin(t*Math.PI*2)*.1,m=d*Math.cos(t*Math.PI*3)*.08,g=1+.1*l;let f=0,y=0;return i?(y=e.y*h,f=c):(f=e.x*h,y=c),{cameraRelativePosition:[f,y,0],rotation:[p,u,m],scale:g}}}}}var mf=pf("up"),gf=pf("down"),ff=pf("left"),yf=pf("right"),vf={name:"lean",emoji:"",type:"blending",description:"Diagonal tilting motion with smooth return",config:{duration:1200,musicalDuration:{musical:!0,beats:2},amplitude:10,frequency:1,direction:"right",strength:.7,particleMotion:{type:"lean",direction:"right",strength:.7,frequency:1}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.3,offBeat:.8,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.4},patternOverrides:{waltz:{durationSync:{beats:3},amplitudeSync:{onBeat:1.5,offBeat:.6}},swing:{amplitudeSync:{onBeat:1.6,offBeat:.5,curve:"bounce"}}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.lean={startX:t.x,startY:t.y,startVx:t.vx,startVy:t.vy,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.lean?.initialized||this.initialize(t,i);const r={...this.config,...i},o=r.strength||this.config.strength||1,l=this.easeInOutCubic(e),h=r.frequency||this.config.frequency;let c=r.amplitude*o*t.scaleFactor;i.rhythmModulation&&(c*=i.rhythmModulation.amplitudeMultiplier||1,c*=i.rhythmModulation.accentMultiplier||1);const u=Math.sin(l*Math.PI*h),d="left"===r.direction?-1:1;if(t.vx+=u*c*.015*n*d,t.vy+=u*c*.01*n*d*.5,e>.9){const i=1-10*(e-.9);t.vx=t.vx*(.95+.05*i),t.vy=t.vy*(.95+.05*i)}},cleanup(t){t.gestureData?.lean&&delete t.gestureData.lean},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,e){const i=e||{},n=i.amplitude||10,s=i.frequency||1,a=i.strength||.7,r=i.direction||"right",o=.003*n*a,l=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,h=Math.sin(l*Math.PI*s),c="left"===r?-1:1;return{position:[h*o*c,0,0],rotation:[0,0,.35*h*c],scale:1}}}};function bf(t){if("left"!==t&&"right"!==t)throw new Error(`Invalid lean direction: ${t}. Only 'left' and 'right' are supported.`);const e=uf[t];return{name:`lean${df(t)}`,emoji:"left"===t?"":"",type:"blending",description:`Lean ${t} with smooth return`,config:{duration:800,amplitude:10,frequency:1,strength:.7,direction:t},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:1.3,offBeat:.8,curve:"ease"},accentResponse:{enabled:!0,multiplier:1.4}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.lean={startX:t.x,startY:t.y,initialized:!0}},apply(t,i,n,s,a,r){t.gestureData?.lean?.initialized||this.initialize(t,n);const o={...this.config,...n},l=o.strength||.7,h=this.easeInOutCubic(i);let c=o.amplitude*l*t.scaleFactor;n.rhythmModulation&&(c*=n.rhythmModulation.amplitudeMultiplier||1,c*=n.rhythmModulation.accentMultiplier||1);const u=Math.sin(h*Math.PI*o.frequency);if(t.vx+=u*c*.015*s*e.x,t.vy+=u*c*.01*s*e.x*.5,i>.9){const e=1-10*(i-.9);t.vx*=.95+.05*e,t.vy*=.95+.05*e}},cleanup(t){t.gestureData?.lean&&delete t.gestureData.lean},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,i){const n=i||{},s=n.amplitude||10,a=n.frequency||1,r=.003*s*(n.strength||.7),o=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,l=Math.sin(o*Math.PI*a),h=.35*l*e.x;return{cameraRelativePosition:[l*r*e.x,0,0],cameraRelativeRotation:[0,0,h],scale:1}}}}}var Mf=bf("left"),_f=bf("right"),xf={name:"jitter",type:"blending",emoji:"",description:"Nervous jittery movement",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},intensity:15,frequency:30,strength:1},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:2,offBeat:.5,curve:"pulse"},patternOverrides:{breakbeat:{amplitudeSync:{onBeat:3,offBeat:.3}},dubstep:{amplitudeSync:{onBeat:5,offBeat:.1,curve:"pulse"}}}},apply(t,e,i,n,s,a){t.gestureData||(t.gestureData={}),t.gestureData.jitter||(t.gestureData.jitter={originalSize:t.size});const r={...this.config,...i};let o=r.intensity||this.config.intensity;const l=r.strength||this.config.strength;i.rhythmModulation&&(o*=i.rhythmModulation.amplitudeMultiplier||1,o*=i.rhythmModulation.accentMultiplier||1);const h=(Math.random()-.5)*o*l,c=(Math.random()-.5)*o*l,u=1-.5*e;t.vx+=.1*h*n*u,t.vy+=.1*c*n*u,t.size=t.baseSize*(1+.1*(Math.random()-.5))},cleanup(t){t.gestureData?.jitter?(t.size=t.gestureData.jitter.originalSize,delete t.gestureData.jitter):t.size=t.baseSize,t.vx*=.7,t.vy*=.7},"3d":{evaluate(t,e){const i={...this.config,...e};let n=i.intensity||this.config.intensity;const s=i.strength||this.config.strength;e.rhythmModulation&&(n*=e.rhythmModulation.amplitudeMultiplier||1,n*=e.rhythmModulation.accentMultiplier||1);const a=Math.sin(t*Math.PI),r=n*s*.002*a;return{position:[(Math.random()-.5)*r,(Math.random()-.5)*r,(Math.random()-.5)*r],rotation:[.005*(Math.random()-.5)*a,.005*(Math.random()-.5)*a,.005*(Math.random()-.5)*a],scale:1+.02*(Math.random()-.5)*a}}}},wf={name:"twitch",emoji:"",type:"blending",description:"Nervous, paranoid twitching",config:{intensity:8,frequency:.08,duration:100,musicalDuration:{musical:!0,beats:.5},recovery:200,maxOffset:15,sharpness:.9},rhythm:{enabled:!0,syncMode:"subdivision",durationSync:{mode:"beats",beats:.5},probabilitySync:{subdivision:"sixteenth",onBeat:.3,offBeat:.05,accentBoost:2},intensitySync:{onBeat:2,offBeat:.8,curve:"pulse"},patternOverrides:{breakbeat:{probabilitySync:{onBeat:.5,offBeat:.1},intensitySync:{onBeat:3,offBeat:.5}},dubstep:{intensitySync:{onBeat:1.5,dropBeat:5,curve:"pulse"}}}},apply(t,e,i,n,s,a){t.gestureData||(t.gestureData={}),t.gestureData.twitch||(t.gestureData.twitch={twitchOffset:{x:0,y:0},targetOffset:{x:0,y:0},isTwitching:!1,twitchTimer:0,cooldownTimer:0,lastTwitch:0});const r=t.gestureData.twitch,{config:o}=this;let l=i.intensity||o.intensity;i.rhythmModulation&&(l*=i.rhythmModulation.amplitudeMultiplier||1,l*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.probabilityMultiplier);const h=Date.now();if(!r.isTwitching&&r.cooldownTimer<=0&&Math.random()<(i.frequency||o.frequency)){r.isTwitching=!0,r.twitchTimer=o.duration,r.cooldownTimer=o.recovery;const t=Math.random()*Math.PI*2,e=.5*o.maxOffset+Math.random()*(.5*o.maxOffset);r.targetOffset={x:Math.cos(t)*e*l/8,y:Math.sin(t)*e*l/8},r.lastTwitch=h}if(r.cooldownTimer>0&&(r.cooldownTimer-=16*n),r.isTwitching)if(r.twitchTimer-=16*n,r.twitchTimer>0){const{sharpness:t}=o;r.twitchOffset.x+=(r.targetOffset.x-r.twitchOffset.x)*t,r.twitchOffset.y+=(r.targetOffset.y-r.twitchOffset.y)*t}else r.isTwitching=!1;else r.twitchOffset.x*=.85,r.twitchOffset.y*=.85;t.vx+=r.twitchOffset.x*n*.5,t.vy+=r.twitchOffset.y*n*.5,Math.random()<.1&&(t.vx+=(Math.random()-.5)*l*.3,t.vy+=(Math.random()-.5)*l*.3)},cleanup(t){t.gestureData?.twitch&&delete t.gestureData.twitch},"3d":{evaluate(t,e){const i=e.config||{};let n=.6*(i.intensity||8);const s=i.maxOffset||15,a=i.frequency||.08;e.rhythmModulation&&(n*=e.rhythmModulation.amplitudeMultiplier||1,n*=e.rhythmModulation.accentMultiplier||1);const r=9999*Math.floor(10*t),o=t=>{const e=1e4*Math.sin(r+t);return e-Math.floor(e)};if(o(0)<3*a){const t=o(1)*Math.PI*2,e=s*n/8*.003;return{position:[Math.cos(t)*e*o(2),Math.sin(t)*e*o(3),(o(4)-.5)*e],rotation:[.12*(o(5)-.5),.12*(o(6)-.5),.12*(o(7)-.5)],scale:1+.06*(o(8)-.5)}}{const t=.3;return{position:[(o(10)-.5)*t,(o(11)-.5)*t,(o(12)-.5)*t],rotation:[.006*(o(13)-.5),.006*(o(14)-.5),.006*(o(15)-.5)],scale:1}}}}},Sf={name:"vibrate",emoji:"",type:"blending",description:"High frequency vibration",config:{duration:500,frequency:20,amplitude:8,easing:"linear",strength:2,particleMotion:{type:"shake",strength:2,frequency:20,amplitude:8}},rhythm:{enabled:!0,syncMode:"subdivision",frequencySync:{subdivision:"thirty-second",baseFrequency:20,tempoScaling:!0},amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"pulse"},durationSync:{mode:"beats",beats:1},patternOverrides:{dubstep:{frequencySync:{subdivision:"sixteenth"},amplitudeSync:{onBeat:2,dropBeat:3}},breakbeat:{frequencySync:{mode:"random",range:[15,30]}}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.vibrate={timer:0,seed:1e3*Math.random(),initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.vibrate?.initialized||this.initialize(t,i);const r=t.gestureData.vibrate,o={...this.config,...i},l=o.strength||this.config.strength||1;let{amplitude:h}=o,{frequency:c}=o;i.rhythmModulation&&(h*=i.rhythmModulation.amplitudeMultiplier||1,h*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(c*=i.rhythmModulation.frequencyMultiplier)),r.timer+=n*c;const u=(Math.random()-.5)*h*l,d=(Math.random()-.5)*h*l;if(t.vx+=.5*u*n,t.vy+=.5*d*n,t.vx*=.9,t.vy*=.9,e>.8){const i=1-5*(e-.8);t.vx*=i,t.vy*=i}},cleanup(t){t.gestureData?.vibrate&&delete t.gestureData.vibrate},"3d":{evaluate(t,e){const i={...this.config,...e};let{amplitude:n}=i;const s=i.strength||this.config.strength||1;e.rhythmModulation&&(n*=e.rhythmModulation.amplitudeMultiplier||1,n*=e.rhythmModulation.accentMultiplier||1);const a=Math.sin(t*Math.PI),r=n*s*.003*a;return{position:[(Math.random()-.5)*r,(Math.random()-.5)*r,(Math.random()-.5)*r],rotation:[.01*(Math.random()-.5)*a,.01*(Math.random()-.5)*a,.01*(Math.random()-.5)*a],scale:1+.01*(Math.random()-.5)*a}}}},Tf={name:"shake",emoji:"",type:"blending",description:"Random jitter movement for vibration effects",config:{duration:400,amplitude:15,frequency:15,decay:.9,smoothing:.1,axes:"both",easing:"linear",strength:3,particleMotion:{type:"shake",strength:3,frequency:15,decay:!1}},rhythm:{enabled:!0,syncMode:"subdivision",amplitudeSync:{subdivision:"sixteenth",onBeat:2.5,offBeat:.7,curve:"pulse"},frequencySync:{mode:"tempo",baseFrequency:15,scaling:"linear"},durationSync:{mode:"beats",beats:2},patternOverrides:{breakbeat:{amplitudeSync:{onBeat:3,offBeat:.2},frequencySync:{mode:"random",range:[8,20]}},dubstep:{amplitudeSync:{subdivision:"eighth",onBeat:4,dropBeat:6,curve:"pulse"}},swing:{amplitudeSync:{onBeat:1.8,offBeat:1,curve:"ease"}}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.shake={originalX:t.x,originalY:t.y,randomAngle:Math.random()*Math.PI*2,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.shake?.initialized||this.initialize(t,i);const r=t.gestureData.shake,o={...this.config,...i},l=o.strength||this.config.strength||1;let{amplitude:h}=o,{frequency:c}=o;i.rhythmModulation&&(h*=i.rhythmModulation.amplitudeMultiplier||1,h*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(c*=i.rhythmModulation.frequencyMultiplier));const u=o.decay?1-e:1,d=Math.sin(e*Math.PI*c)*h*u*l*t.scaleFactor,p=d*Math.cos(r.randomAngle),m=d*Math.sin(r.randomAngle);t.x=r.originalX+p,t.y=r.originalY+m},pseudoRandom(t){const e=1e4*Math.sin(t);return e-Math.floor(e)},cleanup(t){t.gestureData?.shake&&(t.x=t.gestureData.shake.originalX,t.y=t.gestureData.shake.originalY,delete t.gestureData.shake)},"3d":{evaluate(t,e){const i=e||{},n=.003*(i.amplitude||15),s=i.frequency||15,a=.5*(i.strength||1),r=i.decay?1-t:1,o=Math.sin(t*Math.PI*s)*n*r*a,l=Math.floor(t*s);return{position:[o*(1e4*Math.sin(l)%1-.5)*2,0,o*(1e4*Math.sin(1.3*l)%1-.5)*2],rotation:[0,0,o*(1e4*Math.sin(1.7*l)%1-.5)*.2],scale:1}}}},Cf={name:"wiggle",emoji:"",type:"additive",description:"Rapid side-to-side oscillation",config:{duration:600,musicalDuration:{musical:!0,beats:1},amplitude:15,frequency:6,strength:1,damping:.3,easing:"linear",particleMotion:{type:"wiggle",strength:1,amplitude:15,frequency:6}},rhythm:{enabled:!0,syncMode:"beat",frequencySync:{subdivision:"sixteenth",wigglePerBeat:4},amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},durationSync:{mode:"beats",beats:1}},apply(t,e,i,n,s,a,r){const o=(i.amplitude||this.config.amplitude)*s,l=i.frequency||this.config.frequency,h=1-n*(i.damping||this.config.damping),c=Math.sin(n*Math.PI*l)*o*h;t.vx+=.5*c;const u=Math.cos(n*Math.PI*l*2)*o*.1*h;t.vy+=.3*u},"3d":{evaluate(t,e){const i=e.config||{},n=e.strength||1,s=i.amplitude||15,a=Math.pow(1-t,.5),r=Math.sin(t*Math.PI*14)*a,o=Math.cos(t*Math.PI*14*.7)*a*.4,l=s/15*n,h=.15*r*n;return{cameraRelativePosition:[.08*r*l,.02*Math.abs(o)*l,0],cameraRelativeRotation:[0,0,h],scale:1+.05*Math.abs(r),glowIntensity:1+.2*Math.abs(r)}}}};function Ef(t){const e=uf[t];if(!e)throw new Error(`Invalid step direction: ${t}`);return{name:`step${df(t)}`,emoji:"left"===t?"":"right"===t?"":"up"===t?"":"",type:"blending",description:`Quick step ${t} and return`,config:{duration:400,amplitude:25,strength:.7,direction:t},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:5,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"snap"}},apply(t,i,n,s,a,r){const o={...this.config,...n};let l,h=o.amplitude*o.strength*t.scaleFactor;n.rhythmModulation&&(h*=n.rhythmModulation.amplitudeMultiplier||1,h*=n.rhythmModulation.accentMultiplier||1),l=i<.3?this.easeOutQuad(i/.3):1-this.easeInOutCubic((i-.3)/.7);const c=e.x*h*l*.01*s,u=e.y*h*l*.01*s;t.vx+=c,t.vy+=u},cleanup(t){},easeOutQuad:t=>1-(1-t)*(1-t),easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,i){const n=i||{},s=n.amplitude||25,a=n.strength||.7;let r,o=.008*s*a;if(i.rhythmModulation&&(o*=i.rhythmModulation.amplitudeMultiplier||1),t<.3)r=1-(1-t/.3)*(1-t/.3);else{const e=(t-.3)/.7;r=1-(e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2)}const l=e.x*o*r,h=e.y*o*r,c=.12*r*a,u=-e.x*c;return{cameraRelativePosition:[l,h,0],rotation:[e.y*c*.5,0,u],scale:1}}}}}function Af(t){const e=uf[t];if(!e)throw new Error(`Invalid slide direction: ${t}`);return{name:`slide${df(t)}`,emoji:"left"===t?"":"",type:"blending",description:`Smooth slide ${t} and return`,config:{duration:800,amplitude:35,strength:.6,direction:t},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:1.2,offBeat:.9,curve:"ease"}},apply(t,i,n,s,a,r){const o={...this.config,...n};let l=o.amplitude*o.strength*t.scaleFactor;n.rhythmModulation&&(l*=n.rhythmModulation.amplitudeMultiplier||1,l*=n.rhythmModulation.accentMultiplier||1);const h=Math.sin(i*Math.PI),c=e.x*l*h*.008*s,u=e.y*l*h*.008*s;t.vx+=c,t.vy+=u},cleanup(t){},"3d":{evaluate(t,i){const n=i||{},s=n.amplitude||35,a=n.strength||.6;let r=.008*s*a;i.rhythmModulation&&(r*=i.rhythmModulation.amplitudeMultiplier||1);const o=Math.sin(t*Math.PI),l=e.x*r*o,h=e.y*r*o,c=.08*o*a,u=-e.x*c,d=e.x*c*.5;return{cameraRelativePosition:[l,h,.02*Math.sin(t*Math.PI*2)*a],rotation:[0,d,u],scale:1+.03*o}}}}}var Pf=Ef("left"),Df=Ef("right"),Rf=Ef("up"),If=Ef("down"),Bf=Af("left"),Lf=Af("right"),kf={name:"runningman",emoji:"",type:"effect",description:"Hip-hop running man shuffle",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},slideDistance:30,stepHeight:15,speed:1.2,strength:.8,particleMotion:{type:"runningman",strength:.7}},rhythm:{enabled:!0,syncToBeat:!0,durationSync:{mode:"bars",bars:1},beatMultiplier:1,accentBeats:[1,3]},apply:(t,e,i,n,s,a)=>!1,blend:(t,e,i)=>!1,"3d":{evaluate(t,e){const i={...this.config,...e}.strength||.8;return{position:[.1*Math.sin(t*Math.PI*4)*i,.05*Math.abs(Math.sin(t*Math.PI*8))*i,0],rotation:[0,0,.035*Math.sin(t*Math.PI*4)*i],scale:1-.035*Math.abs(Math.sin(t*Math.PI*8))*i,glowIntensity:1+.25*Math.abs(Math.sin(t*Math.PI*8)),glowBoost:.35*Math.max(0,Math.abs(Math.sin(t*Math.PI*8)))}}}},Of={name:"charleston",emoji:"",type:"effect",description:"Hip-hop Charleston shuffle with crisscross",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},kickDistance:35,swivelRange:40,bounceHeight:12,strength:.9,particleMotion:{type:"charleston",strength:.8}},rhythm:{enabled:!0,syncToBeat:!0,durationSync:{mode:"bars",bars:1.5},beatMultiplier:2,accentBeats:[1,2.5,3,4.5]},apply:(t,e,i,n,s,a)=>!1,blend:(t,e,i)=>!1,"3d":{evaluate(t,e){const i={...this.config,...e}.strength||.9;return{position:[.12*Math.sin(t*Math.PI*8)*i,.05*Math.abs(Math.sin(t*Math.PI*8))*i,0],rotation:[0,0,.05*Math.sin(t*Math.PI*8)*i],scale:1-.04*Math.abs(Math.sin(t*Math.PI*8))*i,glowIntensity:1+.3*Math.abs(Math.sin(t*Math.PI*8)),glowBoost:.4*Math.max(0,Math.abs(Math.sin(t*Math.PI*8)))}}}},zf={name:"hula",emoji:"",type:"override",description:"Hula-hoop motion with vertical waves",config:{speed:.015,maintainRadius:!1,elliptical:!0,use3D:!0,zPhaseOffset:Math.PI/4,verticalOscillation:.3,wobbleAmount:.15,duration:2500,musicalDuration:{musical:!0,bars:1.5},particleMotion:{type:"hula",strength:1,verticalOscillation:.3}},rhythm:{enabled:!0,syncMode:"bar",durationSync:{mode:"bars",bars:1.5},speedSync:{mode:"tempo",baseSpeed:.015,scaling:"proportional"},wobbleSync:{onBeat:.25,offBeat:.1,curve:"sine"},verticalSync:{subdivision:"quarter",amplitude:.4,phase:"sequential"},dynamics:{forte:{wobbleAmount:.3,speed:1.2},piano:{wobbleAmount:.05,speed:.8}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n,r=Math.sqrt(s*s+a*a),o=Math.random()<.5?1:-1,l=Math.max(r,100+180*Math.random()),h=r<5?Math.random()*Math.PI*2:Math.atan2(a,s);t.gestureData.hula={radius:l,angle:h,initialAngle:h,originalVx:t.vx,originalVy:t.vy,originalZ:t.z||0,zPhase:Math.random()*Math.PI*2,wobblePhase:Math.random()*Math.PI*2,direction:o}},apply(t,e,i,n,s,a){t.gestureData?.hula||this.initialize(t,i,s,a);const r=t.gestureData.hula,o=(i.speed||this.config.speed)*(i.strength||1);let l=1;e<.1?(l=e/.1,l=Math.sin(l*Math.PI*.5)):e>.9&&(l=(1-e)/.1,l=Math.sin(l*Math.PI*.5)),r.angle+=o*n*r.direction*l;const h=Math.sin(2*r.angle+r.wobblePhase)*(i.wobbleAmount||this.config.wobbleAmount)*l,c=r.radius*(1+h)*l,u=r.radius*(.7+h)*l,d=s+Math.cos(r.angle)*c,p=a+Math.sin(r.angle)*u;if(e<.1){const e=t.x-s,i=t.y-a;Math.sqrt(e*e+i*i)<50?(t.x=s+Math.cos(r.angle)*c,t.y=a+Math.sin(r.angle)*u):(t.x=t.x+(d-t.x)*l*.5,t.y=t.y+(p-t.y)*l*.5)}else t.x=d,t.y=p;const m=r.angle+r.zPhase+(i.zPhaseOffset||this.config.zPhaseOffset);t.z=.9*Math.sin(m)*l;const g=i.verticalOscillation||this.config.verticalOscillation,f=Math.cos(2*m)*g*r.radius*.2*l;t.y+=f;const y=t.z*r.radius*.1;t.y-=y;const v=-Math.sin(r.angle)*c*o,b=Math.cos(r.angle)*u*o;e<.1?(t.vx=r.originalVx+(v-r.originalVx)*l,t.vy=r.originalVy+(b-r.originalVy)*l):e>.9?(t.vx=v*l+r.originalVx*(1-l),t.vy=b*l+r.originalVy*(1-l),t.z=t.z*l+r.originalZ*(1-l)):(t.vx=v,t.vy=b)},cleanup(t){if(t.gestureData?.hula){const e=t.gestureData.hula;t.vx=e.originalVx,t.vy=e.originalVy,t.z=e.originalZ,delete t.gestureData.hula}},"3d":{evaluate(t,e){const{particle:i}=e;if(!i||!i.gestureData?.hula)return{position:[0,0,0],rotation:[0,0,0],scale:1};const n=i.gestureData.hula,s=e.config||{};let a=1;t<.15?(a=t/.15,a=Math.sin(a*Math.PI*.5)):t>.85&&(a=(1-t)/.15,a=Math.sin(a*Math.PI*.5));const r=n.initialAngle+t*Math.PI*2*n.direction,o=.25*Math.cos(r)*a,l=.25*Math.sin(r)*a,h=s.verticalOscillation||.3;return{position:[o,Math.sin(2*r+n.wobblePhase)*h*a,l],rotation:[0,(r-n.initialAngle)*a,0],scale:1+.15*Math.abs(Math.sin(r))*a}}}},Ff={name:"twist",emoji:"",type:"override",description:"Twisting dance motion with alternating rotation",config:{duration:1200,musicalDuration:{musical:!0,beats:3},rotationAngle:45,contractionFactor:.8,twistFrequency:2,easing:"smooth",strength:.8,particleMotion:{type:"twist",rotationAngle:45,contractionFactor:.8,twistFrequency:2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!1,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"elastic"},patternOverrides:{funk:{rotationAngle:60,contractionFactor:.7},disco:{twistFrequency:3,rotationAngle:50},latin:{rotationAngle:35,contractionFactor:.85,twistFrequency:2.5}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.twist={startX:t.x,startY:t.y,startAngle:Math.atan2(t.y-e.centerY,t.x-e.centerX),startDistance:Math.sqrt(Math.pow(t.x-e.centerX,2)+Math.pow(t.y-e.centerY,2)),initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.twist?.initialized||this.initialize(t,{...i,centerX:s,centerY:a});const r={...this.config,...i},o=t.gestureData.twist,l=r.strength||this.config.strength||1,h=e*r.twistFrequency*Math.PI*2,c=Math.sin(h)*l;let{rotationAngle:u}=r,{contractionFactor:d}=r;i.rhythmModulation&&(u*=i.rhythmModulation.amplitudeMultiplier||1,d=1-(1-d)*(i.rhythmModulation.amplitudeMultiplier||1));const p=u*Math.PI/180*c,m=1-(1-d)*Math.abs(c),g=o.startAngle+p,f=o.startDistance*m,y=s+Math.cos(g)*f,v=a+Math.sin(g)*f,b=.15*l;t.x+=(y-t.x)*b,t.y+=(v-t.y)*b,t.vx=.05*(y-t.x),t.vy=.05*(v-t.y);const M=5*Math.sin(e*Math.PI*4)*l;if(t.y+=.1*M,e>.9){const i=1-10*(e-.9);t.vx*=i,t.vy*=i}},cleanup(t){t.gestureData?.twist&&delete t.gestureData.twist},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||.8,s=t>.85?(1-t)/.15:1,a=t*(i.twistFrequency||2)*Math.PI*2,r=Math.sin(a)*n*s,o=r*((i.rotationAngle||45)*Math.PI/180);return{position:[.05*Math.sin(a)*n*s,.02*Math.abs(Math.sin(2*a))*n*s,0],rotation:[.08*Math.cos(a)*n*s,o,.12*Math.sin(.5*a)*n*s],scale:1-(1-(i.contractionFactor||.8))*Math.abs(r),glowIntensity:1+.3*Math.abs(r)}}}},Uf={name:"pop",emoji:"",type:"blending",description:"Quick scale pulse - the classic beat hit",config:{duration:200,musicalDuration:{musical:!0,beats:.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:.5},interruptible:!0,priority:5,blendable:!0},apply:(t,e,i)=>!1,blend:(t,e,i)=>!1,"3d":{isAccent:!0,evaluate(t,e){const i=e?.strength||1;let n;return t<.15?(n=t/.15,n=1-Math.pow(1-n,3)):(n=1-(t-.15)/.85,n=Math.pow(n,2)),{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+.08*n*i,glowBoost:.3*n*i,positionBoost:[0,.02*n*i,0]}}}},Nf={name:"flare",emoji:"",type:"blending",description:"Dramatic scale burst with intense glow - for big moments",config:{duration:400,musicalDuration:{musical:!0,beats:1},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1},interruptible:!0,priority:6,blendable:!0},apply:(t,e,i)=>!1,blend:(t,e,i)=>!1,"3d":{isAccent:!0,evaluate(t,e){const i=e?.strength||1;let n;if(t<.1){const e=t/.1;n=1-Math.pow(1-e,4)}else if(t<.3){const e=(t-.1)/.2;n=1-.1*Math.sin(e*Math.PI)}else n=1-(t-.3)/.7,n=Math.pow(n,.6);return{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+(.15*n+.15*Math.sin(t*Math.PI*4)*(1-t)*.02)*i,glowBoost:.8*n*i,positionBoost:[0,.04*n*i,0]}}}},Gf={name:"swell",emoji:"",type:"blending",description:"Glow build with scale - for transitions and builds",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1.5},interruptible:!0,priority:4,blendable:!0},apply:(t,e,i)=>!1,blend:(t,e,i)=>!1,"3d":{isAccent:!0,evaluate(t,e){const i=e?.strength||1;let n;if(t<.6){const e=t/.6;n=e*e}else{const e=(t-.6)/.4;n=1-e*e}return{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+.1*n*i,glowBoost:.4*n*i,positionBoost:[0,.03*Math.sin(t*Math.PI)*i,0]}}}},Vf={name:"swagger",emoji:"",type:"blending",description:"Side lean with drift - confident swagger",config:{duration:400,musicalDuration:{musical:!0,beats:1},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1},interruptible:!0,priority:4,blendable:!0},apply:(t,e,i)=>!1,blend:(t,e,i)=>!1,"3d":{isAccent:!0,evaluate(t,e){const i=e?.strength||1;let n;if(t<.3){const e=t/.3;n=1-Math.pow(1-e,2)}else if(t<.7)n=1;else{const e=(t-.7)/.3;n=1-e*e}return{position:[0,0,0],rotation:[0,0,0],scale:1,rotationBoost:[0,0,.12*n*i*1],positionBoost:[.04*n*i*1,.01*n*i,0],scaleBoost:1+.03*n*i}}}},Hf={name:"dip",emoji:"",type:"blending",description:"Downward bob - groove dip feel",config:{duration:250,musicalDuration:{musical:!0,beats:.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:.5},interruptible:!0,priority:5,blendable:!0},apply:(t,e,i)=>!1,blend:(t,e,i)=>!1,"3d":{isAccent:!0,evaluate(t,e){const i=e?.strength||1,n=Math.sin(t*Math.PI);return{position:[0,0,0],rotation:[0,0,0],scale:1,positionBoost:[0,.015*-n*i,0],scaleBoost:1-.015*n*i}}}},Wf={name:"bounce",emoji:"",type:"blending",description:"Vertical oscillation with smooth easing",config:{duration:800,musicalDuration:{musical:!0,beats:2},amplitude:30,frequency:2,axis:"vertical",damping:!0,easing:"sine",strength:.6,particleMotion:{type:"bounce",axis:"vertical",strength:.6,frequency:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.8,offBeat:.6,curve:"bounce"},frequencySync:{mode:"tempo",multiplier:1},durationSync:{mode:"beats",beats:4},accentResponse:{enabled:!0,multiplier:1.5},patternOverrides:{waltz:{frequencySync:{multiplier:.75},durationSync:{beats:3}},swing:{amplitudeSync:{onBeat:2,offBeat:.4,curve:"ease"}},dubstep:{amplitudeSync:{onBeat:1.5,dropBeat:3,curve:"pulse"}},breakbeat:{frequencySync:{multiplier:1.5},amplitudeSync:{onBeat:2.2,offBeat:.3}}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.bounce={startY:t.y,startX:t.x,startVx:t.vx,startVy:t.vy,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.bounce?.initialized||this.initialize(t,i);const r={...this.config,...i},o=r.strength||this.config.strength||1,l=this.easeInOutCubic(e);let{frequency:h}=r;const c=i.phase||0;let u=r.amplitude*o*t.scaleFactor;i.rhythmModulation&&(u*=i.rhythmModulation.amplitudeMultiplier||1,u*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(h*=i.rhythmModulation.frequencyMultiplier));const d=Math.sin((l+c)*Math.PI*2*h);if(r.damping&&e>.7&&(u*=1-(e-.7)/.3*.8),"vertical"===r.axis?(t.vy+=d*u*.01*n,e>.9&&(t.vx*=.98)):"horizontal"===r.axis&&(t.vx+=d*u*.01*n,e>.9&&(t.vy*=.98)),e>.9){const i=1-10*(e-.9);t.vx=t.vx*(.95+.05*i),t.vy=t.vy*(.95+.05*i)}},cleanup(t){t.gestureData?.bounce&&delete t.gestureData.bounce},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,e){const i=e||{},n=i.amplitude||30,s=i.frequency||2,a=.003*n*(i.strength||.6),r=(t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2)*Math.PI*s,o=Math.abs(Math.sin(r));let l=a;return t>.7&&(l*=1-(t-.7)/.3*.8),{position:[0,o*l,0],rotation:[0,0,0],scale:1+.08*o}}}},jf={name:"orbit",emoji:"",type:"override",description:"Orbital motion around center",config:{speed:.02,maintainRadius:!0,elliptical:!1,use3D:!0,zPhaseOffset:0,verticalOscillation:0,duration:3e3,musicalDuration:{musical:!0,bars:2},particleMotion:{type:"orbit",strength:1}},rhythm:{enabled:!0,syncMode:"harmonic",durationSync:{mode:"bars",bars:2},speedSync:{tonic:.02,fifth:.03,octave:.04,third:.025,curve:"smooth"},radiusSync:{bass:150,mid:100,treble:50,scaling:"logarithmic"},depthSync:{major:{z:1,phase:0},minor:{z:-1,phase:Math.PI},diminished:{z:.5,phase:Math.PI/2},augmented:{z:.8,phase:-Math.PI/2}},phaseSync:{mode:"harmonic",intervals:[1,1.5,2],drift:.05},dynamics:{forte:{speed:.04,maintainRadius:!1},piano:{speed:.01,maintainRadius:!0}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n,r=Math.sqrt(s*s+a*a),o=Math.random()<.5?1:-1,l=Math.max(r,100+180*Math.random()),h=r<5?Math.random()*Math.PI*2:Math.atan2(a,s);t.gestureData.orbit={radius:l,targetRadius:l,angle:h,initialAngle:h,originalVx:t.vx,originalVy:t.vy,originalZ:t.z||0,zPhase:Math.random()*Math.PI*2,direction:o}},apply(t,e,i,n,s,a){t.gestureData?.orbit||this.initialize(t,i,s,a);const r=t.gestureData.orbit,o=(i.speed||this.config.speed)*(i.strength||1);r.angle+=o*n*r.direction;let{radius:l}=r;if(i.maintainRadius||(l=r.radius*(1+.1*Math.sin(e*Math.PI*2))),t.x=s+Math.cos(r.angle)*l,t.y=a+Math.sin(r.angle)*l,!1!==i.use3D){const e=r.angle+r.zPhase+(i.zPhaseOffset||0);if(t.z=.8*Math.sin(e),i.verticalOscillation){const n=Math.cos(e)*i.verticalOscillation*l*.1;t.y+=n}}if(t.vx=-Math.sin(r.angle)*l*o,t.vy=Math.cos(r.angle)*l*o,e>.9){const i=10*(1-e);t.vx=t.vx*i+r.originalVx*(1-i),t.vy=t.vy*i+r.originalVy*(1-i)}},cleanup(t){if(t.gestureData?.orbit){const e=t.gestureData.orbit;t.vx=e.originalVx,t.vy=e.originalVy,t.z=e.originalZ,delete t.gestureData.orbit}},"3d":{evaluate(t,e){const i=e?.particle;if(!i||!i.gestureData?.orbit)return{position:[0,0,0],rotation:[0,0,0],scale:1};const n=i.gestureData.orbit;let s=1;t<.15?s=Math.sin(t/.15*Math.PI*.5):t>.85&&(s=Math.sin((1-t)/.15*Math.PI*.5));const a=n.initialAngle+t*Math.PI*2*n.direction,r=.3*Math.cos(a)*s,o=.3*Math.sin(a)*s,l=(a+Math.PI/2-(n.initialAngle+Math.PI/2))*s,h=i.z||0;return{position:[r,0,o+.1*h*s],rotation:[0,l,0],scale:1+.15*h*s}}}};function Xf(t){const e=uf[t];if(!e)throw new Error(`Invalid orbit direction: ${t}`);const i="up"===t||"down"===t,n="left"===t||"up"===t?1:-1;return{name:`orbit${df(t)}`,emoji:"left"===t?"":"right"===t?"":"up"===t?"":"",type:"override",description:`Orbit ${"left"===t?"counter-clockwise":"right"===t?"clockwise":t}`,config:{duration:1500,musicalDuration:{musical:!0,beats:4},speed:.02,maintainRadius:!0,use3D:!0,rotations:1,strength:1,direction:t,verticalOscillation:i?.3:0,particleMotion:{type:"orbit",strength:1,rotations:1}},rhythm:{enabled:!0,syncMode:"harmonic",durationSync:{mode:"bars",bars:1},speedSync:{tonic:.02,fifth:.03,octave:.04,curve:"smooth"},radiusSync:{bass:150,mid:100,treble:50,scaling:"logarithmic"},dynamics:{forte:{speed:.04,maintainRadius:!1},piano:{speed:.01,maintainRadius:!0}}},initialize(t,e,i,s){t.gestureData||(t.gestureData={});const a=t.x-i,r=t.y-s,o=Math.sqrt(a*a+r*r),l=Math.max(o,80+100*Math.random()),h=o<5?Math.random()*Math.PI*2:Math.atan2(r,a);t.gestureData.orbit={radius:l,targetRadius:l,angle:h,initialAngle:h,originalVx:t.vx,originalVy:t.vy,originalZ:t.z||0,zPhase:Math.random()*Math.PI*2,direction:n,initialized:!0}},apply(t,n,s,a,r,o){t.gestureData?.orbit?.initialized||this.initialize(t,s,r,o);const l=t.gestureData.orbit,h={...this.config,...s},c=s.strength||1,u=(h.speed||.02)*c;let d=1;n<.15?(d=n/.15,d=Math.sin(d*Math.PI*.5)):n>.85&&(d=(1-n)/.15,d=Math.sin(d*Math.PI*.5)),l.angle+=u*a*l.direction*d;let{radius:p}=l;h.maintainRadius||(p=l.radius*(1+.1*Math.sin(n*Math.PI*2)));const m=p*d+(1-d)*l.radius*.5;if(t.x=r+Math.cos(l.angle)*m,t.y=o+Math.sin(l.angle)*m,!1!==h.use3D){const s=l.angle+l.zPhase;if(t.z=.8*Math.sin(s)*d,i&&h.verticalOscillation){const i=e.y*n*h.verticalOscillation*p*.5;t.y+=i}}if(t.vx=-Math.sin(l.angle)*m*u*d,t.vy=Math.cos(l.angle)*m*u*d,n>.9){const e=10*(1-n);t.vx=t.vx*e+l.originalVx*(1-e),t.vy=t.vy*e+l.originalVy*(1-e)}},cleanup(t){if(t.gestureData?.orbit){const e=t.gestureData.orbit;t.vx=e.originalVx,t.vy=e.originalVy,t.z=e.originalZ,delete t.gestureData.orbit}},"3d":{evaluate(t,s){const a=s.config||s||{},r=s.strength||1,o=a.rotations||1;let l=1;t<.15?l=Math.sin(t/.15*Math.PI*.5):t>.85&&(l=Math.sin((1-t)/.15*Math.PI*.5));const h=.25*r,c=t*Math.PI*2*o*n,u=Math.cos(c)*h*l,d=Math.sin(c)*h*l;let p=0;return i&&(p=e.y*t*.2*r*l),{cameraRelativePosition:[u,p,d],rotation:[0,c*l*.5,0],scale:1+.2*d}}}}}var qf=Xf("left"),Yf=Xf("right"),$f=Xf("up"),Zf=Xf("down"),Jf={name:"jump",emoji:"",type:"override",description:"Squash, leap, and land with classic animation principles",config:{duration:800,musicalDuration:{musical:!0,beats:2},jumpHeight:60,squashAmount:.8,stretchAmount:1.2,anticipation:.2,hangTime:.1,landingImpact:!0,driftOutward:!0,easing:"quad",particleMotion:{type:"jump",strength:.9,jumpHeight:60,squash:.8,stretch:1.2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},phaseSync:{anticipation:"eighth",jump:"beat",landing:"sixteenth"},heightSync:{onBeat:1.5,offBeat:.8,accent:2,curve:"exponential"},deformationSync:{squashOnBeat:.6,stretchOnBeat:1.4,timing:"anticipatory"},hangTimeSync:{mode:"tempo",baseDuration:.1,scaling:"inverse"},dynamics:{forte:{jumpHeight:80,stretch:1.3},piano:{jumpHeight:30,stretch:1.1}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={}),t.gestureData.jump={startX:t.x,startY:t.y,startSize:t.size,originalVx:t.vx,originalVy:t.vy,driftDirection:.1*(t.x-i),initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.jump?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.jump,o={...this.config,...i},l=i.strength||1,h=o.jumpHeight*l*t.scaleFactor,c=o.squashAmount,u=o.stretchAmount,d=o.anticipation,p=1-.5*o.anticipation;if(e<d){const i=e/d,n=this.easeOutQuad(i);t.size=r.startSize*(1-(1-c)*n),t.y=r.startY+5*n*t.scaleFactor,t.vx=0,t.vy=0}else if(e<p){const i=(e-d)/(p-d);let n=Math.sin(i*Math.PI);if(o.hangTime>0&&i>.4&&i<.6){const t=(i-.4)/.2;n=.95+.05*this.easeInOutCubic(t)}if(t.y=r.startY-n*h,o.driftOutward&&(t.x=r.startX+n*r.driftDirection),i<.5){const e=2*i;t.size=r.startSize*(c+(u-c)*e)}else{const e=2*(i-.5);t.size=r.startSize*(u-(u-1)*e*.8)}t.vx=.5*r.driftDirection,t.vy=-Math.cos(i*Math.PI)*h*.1}else{const i=(e-p)/(1-p),n=this.easeOutBounce(i);if(t.y=r.startY,o.landingImpact)if(i<.3){const e=i/.3;t.size=r.startSize*(1-(1-.8*c)*(1-e))}else{const e=(i-.3)/.7;t.size=r.startSize*(.8*c+(1-.8*c)*e)}else t.size=r.startSize*(c+(1-c)*n);t.vx=r.originalVx*n,t.vy=r.originalVy*n}},cleanup(t){if(t.gestureData?.jump){const e=t.gestureData.jump;t.size=e.startSize,t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.jump}},easeOutQuad:t=>t*(2-t),easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,easeOutBounce(t){const e=7.5625,i=2.75;return t<1/i?e*t*t:t<2/i?e*(t-=1.5/i)*t+.75:t<2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375},"3d":{evaluate(t,e){const i=e.config||e||{},n=e.strength||1,s=.004*(i.jumpHeight||60)*n,a=i.squashAmount||.8,r=i.stretchAmount||1.2,o=i.anticipation||.2,l=1-.5*o;let h=0,c=1,u=0;if(t<o){const e=t/o,i=e*(2-e);c=1-(1-a)*i,h=.02*-i}else if(t<l){const e=(t-o)/(l-o);h=Math.sin(e*Math.PI)*s,c=e<.5?a+2*e*(r-a):r-2*(e-.5)*(r-1)*.8,u=.05*Math.sin(e*Math.PI)}else{const e=(t-l)/(1-l);if(e<.5){const t=2*e;h=-Math.sin(t*Math.PI)*s*.15}else h=0;c=!1!==i.landingImpact?e<.3?1-(1-.8*a)*(1-e/.3):.8*a+(e-.3)/.7*(1-.8*a):a+(1-a)*e}return{position:[0,h,0],rotation:[u,0,0],scale:c}}}};function Qf(t){const e=uf[t];if(!e)throw new Error(`Invalid jump direction: ${t}`);const i="up"===t||"down"===t;return{name:`jump${df(t)}`,emoji:"up"===t?"":"down"===t?"":"left"===t?"":"",type:"override",description:`Jump ${t} with squash & stretch`,config:{duration:800,musicalDuration:{musical:!0,beats:2},jumpDistance:60,squashAmount:.8,stretchAmount:1.2,anticipation:.2,hangTime:.1,landingImpact:!0,easing:"quad",strength:1,direction:t,particleMotion:{type:"jump",strength:.9,jumpDistance:60,squash:.8,stretch:1.2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},phaseSync:{anticipation:"eighth",jump:"beat",landing:"sixteenth"},distanceSync:{onBeat:1.5,offBeat:.8,accent:2,curve:"exponential"},deformationSync:{squashOnBeat:.6,stretchOnBeat:1.4,timing:"anticipatory"},dynamics:{forte:{jumpDistance:80,stretch:1.3},piano:{jumpDistance:30,stretch:1.1}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={}),t.gestureData.jump={startX:t.x,startY:t.y,startSize:t.size,originalVx:t.vx,originalVy:t.vy,initialized:!0}},apply(t,n,s,a,r,o){t.gestureData?.jump?.initialized||this.initialize(t,s,r,o);const l=t.gestureData.jump,h={...this.config,...s},c=s.strength||1,u=h.jumpDistance*c*t.scaleFactor,d=h.squashAmount,p=h.stretchAmount,m=h.anticipation,g=1-.5*h.anticipation;if(n<m){const s=n/m,a=this.easeOutQuad(s);t.size=l.startSize*(1-(1-d)*a),i?t.y=l.startY-e.y*a*5*t.scaleFactor:t.x=l.startX-e.x*a*5*t.scaleFactor,t.vx=0,t.vy=0}else if(n<g){const s=(n-m)/(g-m);let a=Math.sin(s*Math.PI);if(h.hangTime>0&&s>.4&&s<.6){const t=(s-.4)/.2;a=.95+.05*this.easeInOutCubic(t)}if(i?(t.y=l.startY+e.y*a*u,t.x=l.startX+3*Math.sin(s*Math.PI*2)):(t.x=l.startX+e.x*a*u,t.y=l.startY-Math.sin(s*Math.PI)*u*.3),s<.5){const e=2*s;t.size=l.startSize*(d+(p-d)*e)}else{const e=2*(s-.5);t.size=l.startSize*(p-(p-1)*e*.8)}i?(t.vy=e.y*Math.cos(s*Math.PI)*u*.1,t.vx=0):(t.vx=e.x*Math.cos(s*Math.PI)*u*.1,t.vy=-Math.cos(s*Math.PI)*u*.05)}else{const e=(n-g)/(1-g),i=this.easeOutBounce(e);if(t.x=l.startX,t.y=l.startY,h.landingImpact)if(e<.3){const i=e/.3;t.size=l.startSize*(1-(1-.8*d)*(1-i))}else{const i=(e-.3)/.7;t.size=l.startSize*(.8*d+(1-.8*d)*i)}else t.size=l.startSize*(d+(1-d)*i);t.vx=l.originalVx*i,t.vy=l.originalVy*i}},cleanup(t){if(t.gestureData?.jump){const e=t.gestureData.jump;t.size=e.startSize,t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.jump}},easeOutQuad:t=>t*(2-t),easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,easeOutBounce(t){const e=7.5625,i=2.75;return t<1/i?e*t*t:t<2/i?e*(t-=1.5/i)*t+.75:t<2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375},"3d":{evaluate(t,n){const s=n.config||n||{},a=n.strength||1,r=.004*(s.jumpDistance||60)*a,o=s.squashAmount||.8,l=s.stretchAmount||1.2,h=s.anticipation||.2,c=1-.5*h;let u=0,d=0,p=1,m=0,g=0,f=0;if(t<h){const n=t/h,s=n*(2-n);p=1-(1-o)*s,i?d=-e.y*s*.02:u=-e.x*s*.02}else if(t<c){const n=(t-h)/(c-h),s=Math.sin(n*Math.PI);i?d=e.y*s*r:(u=e.x*s*r,d=Math.sin(n*Math.PI)*r*.3),p=n<.5?o+2*n*(l-o):l-2*(n-.5)*(l-1)*.8,i?m=e.y*Math.sin(n*Math.PI)*.1:(g=e.x*Math.sin(n*Math.PI)*.15,f=-e.x*Math.sin(n*Math.PI)*.05)}else{const n=(t-c)/(1-c);if(n<.5){const t=2*n;i?d=-e.y*Math.sin(t*Math.PI)*r*.15:u=-e.x*Math.sin(t*Math.PI)*r*.1}p=!1!==s.landingImpact?n<.3?1-(1-.8*o)*(1-n/.3):.8*o+(n-.3)/.7*(1-.8*o):o+(1-o)*n}return{cameraRelativePosition:[u,d,0],rotation:[m,g,f],scale:p}}}}}var Kf=Qf("down"),ty=Qf("left"),ey=Qf("right");function iy(t){if(!["forward","back","left","right","up","down"].includes(t))throw new Error(`Invalid rush direction: ${t}`);return{name:`rush${df(t)}`,emoji:{forward:"",back:"",left:"",right:"",up:"",down:""}[t],type:"override",description:{forward:"Quick rush toward camera",back:"Quick retreat away",left:"Quick strafe left",right:"Quick strafe right",up:"Quick leap upward",down:"Quick dive downward"}[t],config:{duration:600,musicalDuration:{musical:!0,beats:1.5},strength:1,direction:t,particleMotion:{type:"rush",strength:1,direction:t}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.direction||"forward";let a=0,r=0,o=0,l=0,h=0,c=1,u=1,d=0;const p={forward:{x:0,y:0,z:1,lean:{x:.2,z:0}},back:{x:0,y:0,z:-1,lean:{x:-.2,z:0}},left:{x:-1,y:0,z:0,lean:{x:0,z:.2}},right:{x:1,y:0,z:0,lean:{x:0,z:-.2}},up:{x:0,y:1,z:0,lean:{x:-.15,z:0}},down:{x:0,y:-1,z:0,lean:{x:.2,z:0}}}[s],m=.2;if(t<.2){const e=t/.2,i=1-Math.pow(1-e,2);l=i*p.lean.x*n,h=i*p.lean.z*n,r="up"===s?.03*-i*n:.02*-i*n,u=1+.3*i}else if(t<.6){const e=(t-.2)/.4,i=1-Math.pow(1-e,3);a=p.x*i*m*n,r=p.y*i*m*n,o=p.z*i*m*n,"up"===s?r+=.05*i*n:"down"!==s&&(r+=(.04*i-.02)*n),l=p.lean.x*n,h=p.lean.z*n,c=1+.08*i,u=1.3+.5*i,d=.35*i,h+=Math.sin(e*Math.PI*12)*(1-e)*.015*n}else{const e=(t-.6)/.4,i=e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2;if(a=p.x*m*(1-i)*n,r=p.y*m*(1-i)*n,o=p.z*m*(1-i)*n,l=p.lean.x*(1-i)*n,h=p.lean.z*(1-i)*n,c=1.08-.08*i,e>.7){const t=(e-.7)/.3;r-=.02*Math.sin(t*Math.PI)*n}u=1.8-.8*i,d=.35*(1-i)}return{cameraRelativePosition:[a,r,o],cameraRelativeRotation:[l,0,h],scale:c,glowIntensity:u,glowBoost:d}}}}}var ny={name:"lunge",emoji:"",type:"override",description:"Forward thrust lunge with emphasis",config:{duration:500,musicalDuration:{musical:!0,beats:1},distance:.25,direction:"forward",recover:!0,strength:1,particleMotion:{type:"lunge",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.distance||.25,a=!1!==i.recover;let r;t<.3?(r=t/.3,r=1-Math.pow(1-r,3)):t<.6?r=1:a?(r=1-(t-.6)/.4,r=Math.pow(r,2)):r=1;const o=r*s*n;return{position:[0,.05*-Math.sin(r*Math.PI)*n,o],rotation:[.2*r*n,0,0],scale:1+.1*r*n,glowIntensity:1+.3*r,glowBoost:t<.4?.4*r:0}}}};function sy(t){if(!{...uf,forward:{x:0,y:0,z:-1},back:{x:0,y:0,z:1}}[t])throw new Error(`Invalid lunge direction: ${t}`);return{name:`lunge${df(t)}`,emoji:{forward:"",back:"",left:"",right:"",up:"",down:""}[t]||"",type:"override",description:`Lunge thrust ${t}`,config:{duration:500,musicalDuration:{musical:!0,beats:1},distance:.25,recover:!0,strength:1,direction:t,particleMotion:{type:"lunge",strength:1,direction:t}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.distance||.25,a=!1!==i.recover,r=i.direction||"forward";let o;t<.3?(o=t/.3,o=1-Math.pow(1-o,3)):t<.6?o=1:a?(o=1-(t-.6)/.4,o=Math.pow(o,2)):o=1;let l=0,h=0,c=0,u=0,d=0;switch(r){case"forward":c=o*s*n,u=.2*o*n,h=.05*-Math.sin(o*Math.PI)*n;break;case"back":c=-o*s*n,u=.2*-o*n,h=.05*-Math.sin(o*Math.PI)*n;break;case"left":l=-o*s*n,d=.2*-o*n,h=.03*-Math.sin(o*Math.PI)*n;break;case"right":l=o*s*n,d=.2*o*n,h=.03*-Math.sin(o*Math.PI)*n;break;case"up":h=o*s*n,u=.15*-o*n;break;case"down":h=-o*s*n,u=.25*o*n}return{cameraRelativePosition:[l,h,c],cameraRelativeRotation:[u,0,d],scale:1+.1*o*n,glowIntensity:1+.3*o,glowBoost:t<.4?.4*o:0}}}}}var ay={name:"spin",emoji:"",type:"override",description:"Orbital rotation around center point",config:{duration:600,musicalDuration:{musical:!0,beats:1},rotations:1,direction:"random",radiusMultiplier:1,spiralOut:!1,accelerate:!0,maintainDistance:!0,scaleAmount:.1,easing:"linear",strength:.7,particleMotion:{type:"spin",strength:.7,rotations:1,radius:1}},rhythm:{enabled:!0,syncMode:"bar",rotationSync:{mode:"bars",rotationsPerBar:1,accelerateOnBeat:!0},radiusSync:{subdivision:"quarter",expandOnBeat:1.2,contractOffBeat:.9,curve:"bounce"},durationSync:{mode:"beats",beats:4},patternOverrides:{waltz:{rotationSync:{rotationsPerBar:.75},radiusSync:{curve:"ease"}},swing:{rotationSync:{accelerateOnBeat:!1},direction:"alternating"},dubstep:{radiusSync:{subdivision:"eighth",expandOnBeat:1.5,dropMultiplier:2},spiralOut:!0},breakbeat:{rotationSync:{mode:"random",range:[.5,2]},direction:"random"}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n;let r=e.direction||this.config.direction;"random"===r&&(r=Math.random()<.5?"clockwise":"counter-clockwise"),t.gestureData.spin={startAngle:Math.atan2(a,s),startRadius:Math.sqrt(s*s+a*a)||30,originalX:t.x,originalY:t.y,originalVx:t.vx,originalVy:t.vy,direction:r,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.spin?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.spin,o={...this.config,...i},l=i.strength||1;let{rotations:h}=o,{radiusMultiplier:c}=o;i.rhythmModulation&&(i.rhythmModulation.rotationMultiplier&&(h*=i.rhythmModulation.rotationMultiplier),i.rhythmModulation.radiusMultiplier&&(c*=i.rhythmModulation.radiusMultiplier));let u=e;o.accelerate&&(u=e<.5?.5*this.easeInQuad(2*e):.5+.5*this.easeOutQuad(2*(e-.5)));const d=h*Math.PI*2*l,p="counter-clockwise"===r.direction?-1:1,m=r.startAngle+d*u*p;let g=r.startRadius;o.spiralOut&&(g*=1+.5*e),1!==c&&(g*=1+(c-1)*Math.sin(e*Math.PI));const f=s+Math.cos(m)*g,y=a+Math.sin(m)*g;if(t.x+=.25*(f-t.x),t.y+=.25*(y-t.y),t.vx=.5*(f-t.x),t.vy=.5*(y-t.y),e>.9){const i=10*(1-e);t.vx=t.vx*i+r.originalVx*(1-i),t.vy=t.vy*i+r.originalVy*(1-i)}},cleanup(t){if(t.gestureData?.spin){const e=t.gestureData.spin;t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.spin}},easeInQuad:t=>t*t,easeOutQuad:t=>t*(2-t),"3d":{evaluate(t,e){const i=e?.config||e||{},n=e?.strength||1,s=e?.particle;let a=1;s?.gestureData?.spin?a="counter-clockwise"===s.gestureData.spin.direction?-1:1:"counter-clockwise"!==i.direction&&"left"!==i.direction||(a=-1);let r=t;return!1!==i.accelerate&&(r=t<.5?t*t*4*.5:.5+(t-.5)*(2-(t-.5))*.5),{position:[0,0,0],rotation:[0,(i.rotations||1)*Math.PI*2*n*r*a,0],scale:1+(i.scaleAmount||.1)*Math.sin(t*Math.PI)*n}}}};const ry={left:"counter-clockwise",right:"clockwise"};function oy(t){const e=ry[t];if(!e)throw new Error(`Invalid spin direction: ${t}`);const i="left"===t?-1:1;return{name:`spin${df(t)}`,emoji:"left"===t?"":"",type:"override",description:`Spin ${e}`,config:{duration:600,rotations:1,direction:e,radiusMultiplier:1,spiralOut:!1,accelerate:!0,maintainDistance:!0,scaleAmount:.1,strength:.7},rhythm:{enabled:!0,syncMode:"bar",timingSync:"nextBeat",interruptible:!1,priority:7,blendable:!1,durationSync:{mode:"beats",beats:4},rotationSync:{mode:"bars",rotationsPerBar:1,accelerateOnBeat:!0}},initialize(t,i,n,s){t.gestureData||(t.gestureData={});const a=t.x-n,r=t.y-s;t.gestureData.spin={startAngle:Math.atan2(r,a),startRadius:Math.sqrt(a*a+r*r)||30,originalX:t.x,originalY:t.y,originalVx:t.vx,originalVy:t.vy,direction:e,initialized:!0}},apply(t,e,n,s,a,r){t.gestureData?.spin?.initialized||this.initialize(t,n,a,r);const o=t.gestureData.spin,l={...this.config,...n},h=n.strength||1;let{rotations:c,radiusMultiplier:u}=l;n.rhythmModulation&&(n.rhythmModulation.rotationMultiplier&&(c*=n.rhythmModulation.rotationMultiplier),n.rhythmModulation.radiusMultiplier&&(u*=n.rhythmModulation.radiusMultiplier));let d=e;l.accelerate&&(d=e<.5?.5*this.easeInQuad(2*e):.5+.5*this.easeOutQuad(2*(e-.5)));const p=c*Math.PI*2*h,m=o.startAngle+p*d*i;let g=o.startRadius;l.spiralOut&&(g*=1+.5*e),1!==u&&(g*=1+(u-1)*Math.sin(e*Math.PI));const f=a+Math.cos(m)*g,y=r+Math.sin(m)*g;if(t.x+=.25*(f-t.x),t.y+=.25*(y-t.y),t.vx=.5*(f-t.x),t.vy=.5*(y-t.y),e>.9){const i=10*(1-e);t.vx=t.vx*i+o.originalVx*(1-i),t.vy=t.vy*i+o.originalVy*(1-i)}},cleanup(t){if(t.gestureData?.spin){const e=t.gestureData.spin;t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.spin}},easeInQuad:t=>t*t,easeOutQuad:t=>t*(2-t),"3d":{evaluate(t,e){const n=e?.config||e||{},s=e?.strength||1;let a=t;return!1!==n.accelerate&&(a=t<.5?t*t*4*.5:.5+(t-.5)*(2-(t-.5))*.5),{position:[0,0,0],rotation:[0,(n.rotations||1)*Math.PI*2*s*a*i,0],scale:1+(n.scaleAmount||.1)*Math.sin(t*Math.PI)*s}}}}}var ly=oy("left"),hy=oy("right"),cy={name:"flip",emoji:"",type:"override",description:"Front flip rotation with arc trajectory",config:{duration:800,musicalDuration:{musical:!0,beats:2},rotations:1,height:.3,direction:"forward",strength:1,particleMotion:{type:"flip",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.rotations||1,a=i.height||.3,r=(t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2)*(2*-Math.PI*s),o=Math.sin(t*Math.PI)*a*n;let l=1;if(t<.1)l=1-t/.1*.15;else if(t<.2)l=.85+(t-.1)/.1*.2;else if(t>.9){const e=(t-.9)/.1;l=1.05-.1*Math.sin(e*Math.PI)}else l=1.05;return t>=.99&&(l=1),{position:[0,o,0],rotation:[r,0,0],scale:l,glowIntensity:1+.4*Math.sin(t*Math.PI),glowBoost:t>.2&&t<.8?.3:0}}}},uy={name:"backflip",emoji:"",type:"override",description:"Backwards flip with dramatic arc trajectory",config:{duration:900,musicalDuration:{musical:!0,beats:2},rotations:1,height:.35,strength:1,particleMotion:{type:"backflip",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.rotations||1,a=i.height||.35,r=(t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2)*(2*Math.PI*s),o=Math.sin(t*Math.PI)*a*n,l=.1*Math.sin(t*Math.PI)*n;let h=1;if(t<.1)h=1-t/.1*.15;else if(t<.2)h=.85+(t-.1)/.1*.25;else if(t>.9){const e=(t-.9)/.1;h=1.1-.15*Math.sin(e*Math.PI)}else h=1.1;return t>=.99&&(h=1),{position:[0,o,l],rotation:[r,0,0],scale:h,glowIntensity:1+.5*Math.sin(t*Math.PI),glowBoost:.4*Math.sin(t*Math.PI)}}}},dy={name:"point",emoji:"",type:"blending",description:"Directional pointing motion with forward momentum",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},amplitude:15,direction:"right",strength:.8,particleMotion:{type:"point",direction:"right",strength:.8}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.6},patternOverrides:{march:{amplitudeSync:{onBeat:2,offBeat:.5,curve:"pulse"}},swing:{amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"bounce"}}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.point={startX:t.x,startY:t.y,startVx:t.vx,startVy:t.vy,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.point?.initialized||this.initialize(t,i);const r={...this.config,...i},o=r.strength||this.config.strength||1,l=this.easeInOutCubic(e);let h=r.amplitude*o*t.scaleFactor;i.rhythmModulation&&(h*=i.rhythmModulation.amplitudeMultiplier||1,h*=i.rhythmModulation.accentMultiplier||1);const c=Math.sin(l*Math.PI);let u=0,d=0;switch(r.direction||"right"){case"right":u=1;break;case"left":u=-1;break;case"up":d=-1;break;case"down":d=1}if(t.vx+=c*h*.02*n*u,t.vy+=c*h*.02*n*d,e>.9){const i=1-10*(e-.9);t.vx=t.vx*(.95+.05*i),t.vy=t.vy*(.95+.05*i)}},cleanup(t){t.gestureData?.point&&delete t.gestureData.point},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,e){const i=e||{},n=i.amplitude||15,s=i.strength||.8,a=i.direction||"right",r=.005*n*s,o=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,l=Math.sin(o*Math.PI);let h=0,c=0;switch(a){case"right":h=l*r,c=.25*l;break;case"left":h=-l*r,c=.25*-l;break;case"up":case"down":c=0}return{position:[h,0,0],rotation:[0,c,0],scale:1}}}};function py(t){const e=uf[t];if(!e)throw new Error(`Invalid point direction: ${t}`);const i="up"===t||"down"===t;return{name:`point${df(t)}`,emoji:"up"===t?"":"down"===t?"":"left"===t?"":"",type:"blending",description:`Point ${t} with extension and return`,config:{duration:500,amplitude:15,strength:.8,direction:t},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"ease"},accentResponse:{enabled:!0,multiplier:1.6}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.point={startX:t.x,startY:t.y,initialized:!0}},apply(t,i,n,s,a,r){t.gestureData?.point?.initialized||this.initialize(t,n);const o={...this.config,...n},l=o.strength||.8,h=this.easeInOutCubic(i);let c=o.amplitude*l*t.scaleFactor;n.rhythmModulation&&(c*=n.rhythmModulation.amplitudeMultiplier||1,c*=n.rhythmModulation.accentMultiplier||1);const u=Math.sin(h*Math.PI);if(t.vx+=u*c*.02*s*e.x,t.vy+=u*c*.02*s*-e.y,i>.9){const e=1-10*(i-.9);t.vx*=.95+.05*e,t.vy*=.95+.05*e}},cleanup(t){t.gestureData?.point&&delete t.gestureData.point},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,n){const s=n||{},a=.005*(s.amplitude||15)*(s.strength||.8),r=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,o=Math.sin(r*Math.PI),l=e.x*o*a,h=e.y*o*a;let c=0,u=0,d=0;return i?c=e.y*o*.2:(u=e.x*o*.25,d=-e.x*o*.1),{cameraRelativePosition:[l,h,0],rotation:[c,u,d],scale:1}}}}}var my=py("up"),gy=py("down"),fy=py("left"),yy=py("right");function vy(t){if("left"!==t&&"right"!==t)throw new Error(`Invalid kick direction: ${t}. Only 'left' and 'right' are supported.`);const e=uf[t];return{name:`kick${df(t)}`,emoji:"left"===t?"":"",type:"blending",description:`Quick kick ${t} with snap return`,config:{duration:400,amplitude:30,strength:.8,direction:t},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:5,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"snap"},accentResponse:{enabled:!0,multiplier:1.5}},apply(t,i,n,s,a,r){const o={...this.config,...n};let l,h=o.amplitude*o.strength*t.scaleFactor;n.rhythmModulation&&(h*=n.rhythmModulation.amplitudeMultiplier||1,h*=n.rhythmModulation.accentMultiplier||1),l=i<.25?this.easeOutQuad(i/.25):i<.5?1:1-this.easeInQuad((i-.5)/.5);const c=e.x*h*l*.012*s,u=e.y*h*l*.012*s;t.vx+=c,t.vy+=u},cleanup(t){},easeOutQuad:t=>1-(1-t)*(1-t),easeInQuad:t=>t*t,"3d":{evaluate(t,i){const n=i||{},s=n.amplitude||30,a=n.strength||.8;let r,o=.008*s*a;if(i.rhythmModulation&&(o*=i.rhythmModulation.amplitudeMultiplier||1),t<.25)r=1-(1-t/.25)*(1-t/.25);else if(t<.5)r=1;else{const e=(t-.5)/.5;r=1-e*e}const l=.15*r*a;return{cameraRelativePosition:[e.x*o*r,e.y*o*r*.3,0],rotation:[.08*r*a,0,e.x*l],scale:1+.05*r}}}}}var by=vy("left"),My=vy("right"),_y={name:"bow",emoji:"",type:"override",description:"Graceful forward bow of respect",config:{duration:1200,musicalDuration:{musical:!0,beats:3},depth:.4,holdTime:.4,graceful:!0,strength:1,particleMotion:{type:"bow",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat"},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.depth||.4,a=i.holdTime||.4;let r;const o=.4*(1-a),l=1-.6*(1-a);return t<o?(r=t/o,r=Math.sin(r*Math.PI/2)):t<l?r=1:(r=1-(t-l)/(1-l),r=Math.sin(r*Math.PI/2)),{cameraRelativePosition:[0,.1*-r*n,.05*-r*n],cameraRelativeRotation:[r*s*Math.PI*n,0,0],scale:1,glowIntensity:1-.2*r,glowBoost:0}}}},xy={name:"nod",emoji:"",type:"blending",description:"Vertical nodding motion",config:{duration:500,amplitude:15,frequency:2,easing:"sine",strength:.4,particleMotion:{type:"bounce",axis:"vertical",strength:.4,frequency:2,phase:0}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!1,priority:5,blendable:!1,minDuration:"halfBar",frequencySync:{mode:"subdivision",subdivision:"half",multiplier:1},amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"ease"},durationSync:{mode:"beats",beats:2},patternOverrides:{waltz:{frequencySync:{subdivision:"quarter"},amplitudeSync:{onBeat:1.6,curve:"ease"}},swing:{amplitudeSync:{onBeat:1.5,offBeat:.9}},dubstep:{amplitudeSync:{onBeat:1.2,dropBeat:3,curve:"pulse"}}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.nod={startY:t.y,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.nod?.initialized||this.initialize(t,i);const r={...this.config,...i},o=r.strength||this.config.strength||1;let{frequency:l}=r,{amplitude:h}=r;i.rhythmModulation&&(h*=i.rhythmModulation.amplitudeMultiplier||1,h*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(l*=i.rhythmModulation.frequencyMultiplier));const c=Math.sin(e*Math.PI*2*l);h=h*o*t.scaleFactor,t.vy+=c*h*.01*n,e>.9&&(t.vy*=.95)},cleanup(t){t.gestureData?.nod&&delete t.gestureData.nod},"3d":{evaluate(t,e){const i={...this.config,...e};let{amplitude:n}=i;e.rhythmModulation&&(n*=e.rhythmModulation.amplitudeMultiplier||1,n*=e.rhythmModulation.accentMultiplier||1);let s=0;if(t<.4){const e=t/.4;s=.12*Math.sin(e*Math.PI)}else if(t<.8){const e=(t-.4)/.4;s=.07*Math.sin(e*Math.PI)}return s*=n/15,{cameraRelativePosition:[0,0,s],scale:1-.3*Math.abs(s),glowIntensity:1+.5*Math.abs(s)}}}},wy={name:"reach",emoji:"",type:"blending",description:"Upward reaching motion with scale increase",config:{duration:1400,musicalDuration:{musical:!0,beats:2},amplitude:25,strength:.9,scaleMax:1.05,particleMotion:{type:"reach",strength:.9,scaleMax:1.05}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.4,offBeat:.9,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.5},patternOverrides:{uplifting:{amplitudeSync:{onBeat:1.8,offBeat:.7,curve:"ease"},durationSync:{beats:3}},ambient:{amplitudeSync:{onBeat:1.2,offBeat:1,curve:"linear"}}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.reach={startY:t.y,startVy:t.vy,originalSize:t.size,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.reach?.initialized||this.initialize(t,i);const r={...this.config,...i},o=r.strength||this.config.strength||1,l=r.scaleMax||this.config.scaleMax||1.05,h=this.easeInOutCubic(e);let c=r.amplitude*o*t.scaleFactor;i.rhythmModulation&&(c*=i.rhythmModulation.amplitudeMultiplier||1,c*=i.rhythmModulation.accentMultiplier||1);const u=Math.sin(h*Math.PI);t.vy-=u*c*.015*n;const d=1+u*(l-1);if(t.size=t.baseSize*d,e>.9){const i=1-10*(e-.9);t.vy=t.vy*(.95+.05*i)}},cleanup(t){t.gestureData?.reach&&(t.gestureData.reach.originalSize?t.size=t.gestureData.reach.originalSize:t.size=t.baseSize,delete t.gestureData.reach)},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,e){const i=e||{},n=i.amplitude||25,s=i.strength||.9,a=i.scaleMax||1.05,r=.004*n*s,o=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,l=Math.sin(o*Math.PI);return{position:[0,l*r,0],rotation:[.1*l,0,0],scale:1+l*(a-1)}}}},Sy={name:"headBob",emoji:"",type:"additive",description:"Rhythmic vertical bobbing to music",config:{duration:600,musicalDuration:{musical:!0,beats:1},amplitude:12,frequency:2,strength:1,damping:.1,easing:"linear",particleMotion:{type:"headBob",strength:1,amplitude:12,frequency:2}},rhythm:{enabled:!0,syncMode:"beat",frequencySync:{subdivision:"eighth",bobsPerBeat:2},amplitudeSync:{onBeat:1.3,offBeat:1,curve:"pulse"},durationSync:{mode:"beats",beats:1}},apply(t,e,i,n,s,a,r){const o=(i.amplitude||this.config.amplitude)*s,l=i.frequency||this.config.frequency,h=1-n*(i.damping||this.config.damping),c=Math.sin(n*Math.PI*2*l)*o*h;t.vy+=.5*c;const u=Math.cos(n*Math.PI*2*l*1.5)*o*.05*h;t.vx+=.2*u},"3d":{evaluate(t,e){const i=e.config||{},n=e.strength||1,s=i.amplitude||12,a=t<.15?t/.15:Math.pow(1-(t-.15)/.85,2),r=s/12*n;return{cameraRelativePosition:[0,0,.08*a*r],position:[0,.015*-a*r,0],scale:1-.05*a,glowIntensity:1+.15*a}}}},Ty={name:"crouch",emoji:"",type:"override",description:"Compress down into a low crouch position",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},depth:.3,widen:.2,holdTime:.5,strength:1,particleMotion:{type:"crouch",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat"},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.depth||.3,a=i.widen||.2;let r;const o=(1-(i.holdTime||.5))/2,l=1-o;return r=t<o?t/o:t<l?1:1-(t-l)/o,r=Math.sin(r*Math.PI/2),{position:[0,-r*s*n,0],rotation:[.15*r*n,0,0],scale:(1+r*a*n+(1-.25*r*n))/2,glowIntensity:1-.3*r,glowBoost:0}}}},Cy={name:"tilt",emoji:"",type:"override",description:"Gather particles then tilt as unified group",config:{duration:500,musicalDuration:{musical:!0,beats:1},gatherPhase:.2,tiltAngle:45,swayAmount:80,liftAmount:60,frequency:3,homeRadius:20,easing:"sine",strength:2.5,particleMotion:{type:"tilt",strength:2.5,frequency:3,swayAmount:80,liftAmount:60},smoothness:.25},rhythm:{enabled:!0,syncMode:"swing",durationSync:{mode:"beats",beats:1},angleSync:{onBeat:45,offBeat:-30,swing:15,subdivision:"triplet",curve:"ease-in-out"},gatherSync:{beatsBefore:.5,releaseAfter:.25,intensity:"dynamic"},swaySync:{verse:60,chorus:100,bridge:80,syncopated:!0},liftSync:{upOnTilt:!0,heightOnAccent:80,normalHeight:40,curve:"bounce"},dynamics:{forte:{tiltAngle:60,swayAmount:120,frequency:4},piano:{tiltAngle:20,swayAmount:40,frequency:2}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n,r=Math.atan2(a,s),o=Math.sqrt(s*s+a*a),l=Math.random(),h=({...this.config,...e}.homeRadius+20*Math.random())*t.scaleFactor;t.gestureData.tilt={startX:t.x,startY:t.y,originalVx:t.vx,originalVy:t.vy,angle:r,distance:o,homeRadius:h,homeX:i+Math.cos(r)*h,homeY:n+Math.sin(r)*h,role:l,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.tilt?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.tilt,o={...this.config,...i},l=i.strength||1;let h,c;if(e<o.gatherPhase){const i=e/o.gatherPhase,n=this.easeInOutCubic(i);h=r.startX+(r.homeX-r.startX)*n,c=r.startY+(r.homeY-r.startY)*n;const s=.6;t.x+=(h-t.x)*s,t.y+=(c-t.y)*s}else{const i=(e-o.gatherPhase)/(1-o.gatherPhase)*Math.PI*o.frequency,n=Math.sin(i),u=o.tiltAngle*Math.PI/180*l,d=r.angle+n*u,p=Math.abs(n)*o.liftAmount*t.scaleFactor,m=r.homeRadius+p;h=s+Math.cos(d)*m,c=a+Math.sin(d)*m-.3*p;const g=o.smoothness+.1*r.role;t.x+=(h-t.x)*g,t.y+=(c-t.y)*g;const f=-Math.sin(d),y=Math.cos(d);t.vx=f*n*2,t.vy=y*n*2}if(e<o.gatherPhase&&(t.vx=.25*(h-t.x),t.vy=.25*(c-t.y)),e>.9){const i=10*(1-e),n=r.startX+(t.x-r.startX)*i,s=r.startY+(t.y-r.startY)*i;t.x=n,t.y=s,t.vx=t.vx*i+r.originalVx*(1-i),t.vy=t.vy*i+r.originalVy*(1-i)}},cleanup(t){if(t.gestureData?.tilt){const e=t.gestureData.tilt;t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.tilt}},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,e){const i=e.config||{},n=e.strength||1,s=i.gatherPhase||.2,a=i.frequency||3,r=i.tiltAngle||45;let o=0;if(t>=s){const e=(t-s)/(1-s)*Math.PI*a;o=Math.sin(e)*(r*Math.PI/180*n*.4)}return{position:[0,0,0],rotation:[0,0,o],scale:1}}}};function Ey(t){const e=uf[t];if(!e)throw new Error(`Invalid tilt direction: ${t}`);const i="up"===t||"down"===t;return{name:`tilt${df(t)}`,emoji:"up"===t?"":"down"===t?"":"left"===t?"":"",type:"override",description:`Tilt ${t} with curious expression`,config:{duration:500,musicalDuration:{musical:!0,beats:1},gatherPhase:.2,tiltAngle:45,tiltAmount:40,holdPhase:.4,homeRadius:20,easing:"sine",strength:1,direction:t,smoothness:.25,particleMotion:{type:"tilt",strength:1,tiltAmount:40}},rhythm:{enabled:!0,syncMode:"swing",durationSync:{mode:"beats",beats:1},angleSync:{onBeat:45,offBeat:30,subdivision:"triplet",curve:"ease-in-out"},gatherSync:{beatsBefore:.5,releaseAfter:.25,intensity:"dynamic"},dynamics:{forte:{tiltAngle:60,tiltAmount:60},piano:{tiltAngle:25,tiltAmount:25}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n,r=Math.atan2(a,s),o=Math.sqrt(s*s+a*a),l=({...this.config,...e}.homeRadius+20*Math.random())*t.scaleFactor;t.gestureData.tilt={startX:t.x,startY:t.y,originalVx:t.vx,originalVy:t.vy,angle:r,distance:o,homeRadius:l,homeX:i+Math.cos(r)*l,homeY:n+Math.sin(r)*l,role:Math.random(),initialized:!0}},apply(t,n,s,a,r,o){t.gestureData?.tilt?.initialized||this.initialize(t,s,r,o);const l=t.gestureData.tilt,h={...this.config,...s},c=s.strength||1;let u,d;if(n<h.gatherPhase){const e=n/h.gatherPhase,i=this.easeInOutCubic(e);u=l.startX+(l.homeX-l.startX)*i,d=l.startY+(l.homeY-l.startY)*i;const s=.6;t.x+=(u-t.x)*s,t.y+=(d-t.y)*s}else if(n<h.gatherPhase+h.holdPhase){const s=(n-h.gatherPhase)/h.holdPhase,a=this.easeOutCubic(Math.min(2*s,1)),r=h.tiltAmount*c*t.scaleFactor*a;i?(u=l.homeX,d=l.homeY+e.y*r):(u=l.homeX+e.x*r,d=l.homeY-Math.abs(e.x)*r*.2);const o=h.smoothness+.1*l.role;t.x+=(u-t.x)*o,t.y+=(d-t.y)*o,t.vx=.5*(u-t.x),t.vy=.5*(d-t.y)}else{const e=(n-h.gatherPhase-h.holdPhase)/(1-h.gatherPhase-h.holdPhase),i=this.easeInOutCubic(e);u=t.x+(l.startX-t.x)*i,d=t.y+(l.startY-t.y)*i,t.x=u,t.y=d,t.vx=l.originalVx*i,t.vy=l.originalVy*i}n<h.gatherPhase&&(t.vx=.25*(u-t.x),t.vy=.25*(d-t.y))},cleanup(t){if(t.gestureData?.tilt){const e=t.gestureData.tilt;t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.tilt}},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,easeOutCubic:t=>1-Math.pow(1-t,3),"3d":{evaluate(t,n){const s=n.config||n||{},a=n.strength||1,r=s.gatherPhase||.2,o=s.holdPhase||.4,l=s.tiltAngle||45,h=s.tiltAmount||40;let c=0,u=0,d=0,p=0,m=0;if(t<r);else if(t<r+o){const n=(t-r)/o,s=1-Math.pow(1-Math.min(2*n,1),3),g=l*Math.PI/180*a*.4*s,f=.004*h*a*s;i?(d=e.y*g,u=e.y*f):(m=-e.x*g,c=e.x*f*.5,p=e.x*g*.3)}else{const n=(t-r-o)/(1-r-o),s=n<.5?4*n*n*n:1-Math.pow(-2*n+2,3)/2,g=l*Math.PI/180*a*.4*(1-s),f=.004*h*a*(1-s);i?(d=e.y*g,u=e.y*f):(m=-e.x*g,c=e.x*f*.5,p=e.x*g*.3)}return{cameraRelativePosition:[c,u,0],rotation:[d,p,m],scale:1}}}}}var Ay=Ey("up"),Py=Ey("down"),Dy=Ey("left"),Ry=Ey("right");function Iy(t){if(!["left","right","front","back","up","down"].includes(t))throw new Error(`Invalid oof direction: ${t}`);return{name:`oof${df(t)}`,emoji:{left:"",right:"",front:"",back:"",up:"",down:""}[t],type:"override",description:{left:"Punched from left",right:"Punched from right",front:"Gut punch",back:"Kidney shot",up:"Uppercut",down:"Hammer fist"}[t],config:{duration:500,musicalDuration:{musical:!0,beats:1},intensity:1,strength:1,direction:t,particleMotion:{type:"oof",strength:1,direction:t}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1;let s,a;if(t<.25){const e=t/.25;s=e*(2-e)}else{const e=(t-.25)/.75;s=1-e*e}a=t<.1?t/.1:t<.4?1:1-(t-.4)/.6;const r=.2*n,o=.35*n;let l=0,h=0,c=0,u=0,d=0;let p=[0,0,.4];switch(i.direction||"front"){case"left":l=-s*r,d=s*o,p=[.4,0,0];break;case"right":l=s*r,d=-s*o,p=[-.4,0,0];break;case"front":c=-s*r,h=.03*-s,u=s*o*.7,p=[0,0,.4];break;case"back":c=s*r,u=-s*o*.6,p=[0,0,-.4];break;case"up":h=s*r,u=-s*o*.4,p=[0,.8,0];break;case"down":h=-s*r,u=s*o*.3,p=[0,-.8,0]}let m=1,g=0;if(t<.15){const e=t/.15;m=1+.6*(1-e),g=.4*(1-e)}return{cameraRelativePosition:[l,h,c],cameraRelativeRotation:[u,0,d],scale:1,glowIntensity:m,glowBoost:g,deformation:{enabled:!0,strength:a*n*2,impactPoint:p,falloffRadius:.5}}}}}}var By={name:"recoil",emoji:"",type:"override",description:"Snap backwards in shock or surprise",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},distance:.2,intensity:1,recover:!0,strength:1,particleMotion:{type:"recoil",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.distance||.2,a=i.intensity||1,r=!1!==i.recover;let o;return t<.15?(o=t/.15,o=1-Math.pow(1-o,4)):t<.4?o=1:r?(o=1-(t-.4)/.6,o=Math.pow(o,.5)):o=1,{position:[0,.05*o*n,-o*s*n*a],rotation:[.25*-o*n*a,0,0],scale:1-.1*o*a,glowIntensity:1+(t<.2?3*(.2-t):0),glowBoost:t<.15?.5:0}}}};function Ly(t){if(!{...uf,forward:{x:0,y:0,z:-1},back:{x:0,y:0,z:1}}[t])throw new Error(`Invalid recoil direction: ${t}`);return{name:`recoil${df(t)}`,emoji:{back:"",forward:"",left:"",right:"",up:"",down:""}[t]||"",type:"override",description:`Recoil ${t} in shock`,config:{duration:600,musicalDuration:{musical:!0,beats:1.5},distance:.2,intensity:1,recover:!0,strength:1,direction:t,particleMotion:{type:"recoil",strength:1,direction:t}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.distance||.2,a=i.intensity||1,r=!1!==i.recover,o=i.direction||"back";let l;t<.15?(l=t/.15,l=1-Math.pow(1-l,4)):t<.4?l=1:r?(l=1-(t-.4)/.6,l=Math.pow(l,.5)):l=1;let h=0,c=0,u=0,d=0,p=0;switch(o){case"back":u=-l*s*n*a,d=.25*-l*n*a,c=.05*l*n;break;case"forward":u=l*s*n*a,d=.25*l*n*a,c=.05*-l*n;break;case"left":h=-l*s*n*a,p=.2*l*n*a;break;case"right":h=l*s*n*a,p=.2*-l*n*a;break;case"up":c=l*s*n*a,d=.1*-l*n*a;break;case"down":c=-l*s*n*a,d=.3*l*n*a}return{cameraRelativePosition:[h,c,u],cameraRelativeRotation:[d,0,p],scale:1-.1*l*a,glowIntensity:1+(t<.2?3*(.2-t):0),glowBoost:t<.15?.5:0}}}}}var ky={name:"knockdown",emoji:"",type:"override",description:"Quick knockdown with fast recovery",config:{duration:1500,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"knockdown",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1;let n=0,s=0,a=0,r=0,o=1,l=1,h=0;if(t<.15){const e=t/.15,n=1-Math.pow(1-e,2);s=.1*n*i,a=.2*-n*i,l=1+.6*n,h=.5*n}else if(t<.4){const e=(t-.15)/.25,s=e*e;n=.2*-s*i,a=(.6*s-.2)*i,r=.3*s*i,e>.7&&(o=1-(e-.7)/.3*.1),l=1.6-.5*e,h=.5-.4*e}else if(t<.6){const e=(t-.4)/.2;n=-.2*i,a=.4*i,r=.3*i,r+=.02*Math.sin(e*Math.PI*2),o=.9,l=.8}else{const e=(t-.6)/.4,s=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2;if(n=(.2*s-.2)*i,a=(.4-.4*s)*i,r=(.3-.3*s)*i,o=.9+.1*s,e>.7){const t=(e-.7)/.3;r+=.03*Math.sin(t*Math.PI*4)*(1-t)}l=.8+.2*s,e>.9&&(h=(e-.9)/.1*.2)}return{position:[0,n,s],rotation:[a,0,r],scale:o,glowIntensity:l,glowBoost:h}}}},Oy={name:"knockout",emoji:"",type:"override",description:"Theatrical knockout with failed rise attempt, then recovery",config:{duration:4e3,musicalDuration:{musical:!0,bars:2},strength:1,particleMotion:{type:"knockout",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1;let n=0,s=0,a=0,r=0,o=0,l=1,h=1,c=0;if(t<.1){const e=t/.1,n=1-Math.pow(1-e,3);s=.15*n*i,a=.3*-n*i,h=1+.8*n,c=.6*n,o=.1*Math.sin(e*Math.PI*4)*n}else if(t<.25){const e=(t-.1)/.15,s=e*e;n=.25*-s*i,a=(.8*s-.3)*i,o=.4*s*i,e>.8&&(l=1-(e-.8)/.2*.15),h=1.8-.6*e,c=.6-.4*e}else if(t<.35){const e=(t-.25)/.1;n=-.25*i,a=.5*i,o=.4*i,o+=.03*Math.sin(e*Math.PI*6)*(1-e),l=.85,h=1-.3*e}else if(t<.45){const e=(t-.35)/.1,s=1-Math.pow(1-e,2);n=(.15*s-.25)*i,a=(.5-.3*s)*i,o=(.4-.2*s)*i,l=.85+.1*s,h=.7+.4*s}else if(t<.55){const e=(t-.45)/.1,s=e*e;n=(-.1-.15*s)*i,a=(.2+.35*s)*i,o=(.2+.25*s)*i,l=.95-.12*s,e>.7&&(c=(e-.7)/.3*.3),h=1.1-.4*e}else if(t<.75){const e=(t-.55)/.2;n=-.25*i,a=.55*i,o=.45*i,l=.83;const s=.02*Math.sin(e*Math.PI*4)*Math.sin(e*Math.PI);o+=s,h=.6+2*s}else if(t<.9){const e=(t-.75)/.15,s=e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2;n=(.25*s-.25)*i,a=(.55-.55*s)*i,o=(.45-.45*s)*i,l=.83+.17*s,h=.6+.5*s}else{const e=(t-.9)/.1;n=0,a=0,o=Math.sin(e*Math.PI*6)*(1-e)*.08*i,r=Math.sin(e*Math.PI*8)*(1-e)*.1*i,l=1,h=1+.2*Math.sin(e*Math.PI*3)*(1-e),c=.2*Math.sin(e*Math.PI)}return{position:[0,n,s],rotation:[a,r,o],scale:l,glowIntensity:h,glowBoost:c}}}},zy={name:"inflate",emoji:"",type:"override",description:"Puff up dramatically like a balloon",config:{duration:800,musicalDuration:{musical:!0,beats:2},maxScale:1.4,holdTime:.3,deflate:!0,strength:1,particleMotion:{type:"inflate",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",strengthSync:{onBeat:1.3,offBeat:.8}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.maxScale||1.4,a=i.holdTime||.3,r=!1!==i.deflate;let o;const l=.5*(1-a),h=1-l;t<l?(o=t/l,o=1-Math.pow(1-o,2)):t<h||!r?o=1:(o=1-(t-h)/l,o=Math.pow(o,2));const c=1+(s-1)*o*n,u=.08*o*n,d=1+.4*o*n,p=.3*o,m=o>.8?.02*Math.sin(t*Math.PI*8):0;return{position:[m,u,0],rotation:[0,0,2*m],scale:c,glowIntensity:d,glowBoost:p}}}},Fy={name:"deflate",emoji:"",type:"override",description:"Shrink down sadly like a deflating balloon",config:{duration:1e3,musicalDuration:{musical:!0,beats:2.5},minScale:.6,droop:.15,reinflate:!0,strength:1,particleMotion:{type:"deflate",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2.5},timingSync:"onBeat"},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.minScale||.6,a=i.droop||.15,r=!1!==i.reinflate;let o;return t<.5?(o=t/.5,o=Math.pow(o,.7)):t<.7||!r?o=1:(o=1-(t-.7)/.3,o=Math.pow(o,1.5)),{position:[0,-o*a*n,0],rotation:[.15*o*n,0,.1*o*n],scale:1-(1-s)*o*n,glowIntensity:1-.4*o,glowBoost:0}}}},Uy={name:"squash",emoji:"",type:"override",description:"Flatten horizontally like a cartoon impact",config:{duration:500,musicalDuration:{musical:!0,beats:1},squashAmount:.5,stretchAmount:1.5,bounce:!0,strength:1,particleMotion:{type:"squash",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.squashAmount||.5,a=i.stretchAmount||1.5,r=!1!==i.bounce;let o;if(t<.15)o=t/.15,o=1-Math.pow(1-o,3);else if(r){const e=(t-.15)/.85,i=Math.exp(4*-e);o=Math.cos(e*Math.PI*3)*i,o=Math.max(0,o)}else o=0;const l=1+o*(a-1)*n;return{position:[0,.15*-o*n,0],rotation:[0,0,0],scale:[l,1-o*(1-s)*n,l],glowIntensity:1+(t<.2?3*(.2-t):0),glowBoost:t<.15?.6:0}}}},Ny={name:"stretch",emoji:"",type:"override",description:"Scale particles along X and Y axes",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},scaleX:1.3,scaleY:.9,alternate:!1,elastic:!0,overshoot:.1,frequency:1,easing:"sine",strength:1,particleMotion:{type:"stretch",scaleX:1.8,scaleY:.6,strength:1},centerBased:!0,preserveArea:!1},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},scaleSync:{onBeat:{x:1.5,y:.7},offBeat:{x:.8,y:1.3},subdivision:"eighth",curve:"elastic"},alternateSync:{pattern:"XYXY",beatsPerChange:1,overlap:.1},overshootSync:{normal:.1,accent:.3,downbeat:.2,curve:"spring"},preservationSync:{verse:!0,chorus:!1,bridge:!0},dynamics:{forte:{scaleX:2,scaleY:.5,overshoot:.4},piano:{scaleX:1.1,scaleY:.95,overshoot:.05}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n;t.gestureData.stretch={offsetX:s,offsetY:a,startX:t.x,startY:t.y,originalVx:t.vx,originalVy:t.vy,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.stretch?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.stretch,o={...this.config,...i},l=i.strength||1;let h,c,{scaleX:u}=o,{scaleY:d}=o;if(o.preserveArea&&1!==u&&1!==d){const t=u*d,e=Math.sqrt(1/t);u*=e,d*=e}if(o.alternate)if(e<.5){const t=2*e;u=1+(u-1)*this.getElasticProgress(t,o),d=1+(1/u-1)*(o.preserveArea?1:0)}else{const t=2*(e-.5);u+=(1-u)*this.getElasticProgress(t,o),d=1+(d-1)*this.getElasticProgress(t,o)}else{const t=this.getElasticProgress(e,o);u=1+(u-1)*t*l,d=1+(d-1)*t*l}if(o.centerBased?(h=s+r.offsetX*u,c=a+r.offsetY*d):(h=r.startX*u,c=r.startY*d),t.x=h,t.y=c,t.vx=r.offsetX*(u-1)*l*.1,t.vy=r.offsetY*(d-1)*l*.1,e>.9){const i=10*(1-e);t.vx=t.vx*i+r.originalVx*(1-i),t.vy=t.vy*i+r.originalVy*(1-i)}},getElasticProgress(t,e){if(!e.elastic)return this.easeInOutCubic(t);if(0===t)return 0;if(1===t)return 1;const i=e.overshoot||.1;if(t<.5){const e=2*t;return.5*this.easeInElastic(e,i)}{const e=2*(t-.5);return.5+.5*this.easeOutElastic(e,i)}},cleanup(t){if(t.gestureData?.stretch){const e=t.gestureData.stretch;t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.stretch}},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,easeInElastic:(t,e)=>0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin((t-1-.075)*(2*Math.PI)/.3)*(1+e),easeOutElastic:(t,e)=>0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin((t-.075)*(2*Math.PI)/.3)*(1+e)+1,"3d":{evaluate(t,e){const{particle:i}=e;if(!i||!i.gestureData?.stretch)return{position:[0,0,0],rotation:[0,0,0],scale:1};const n=e.config||{},s=e.strength||1;let a,r=n.scaleX||1.3,o=n.scaleY||.9;if(n.preserveArea&&1!==r&&1!==o){const t=r*o,e=Math.sqrt(1/t);r*=e,o*=e}if(n.elastic){const e=n.overshoot||.1;if(t<.5){const i=2*t,n=.3,s=n/4;a=-Math.pow(2,10*(i-1))*Math.sin((i-1-s)*(2*Math.PI)/n)*(1+e)*.5}else{const i=2*(t-.5),n=.3,s=n/4;a=.5+.5*(Math.pow(2,-10*i)*Math.sin((i-s)*(2*Math.PI)/n)*(1+e)+1)}}else a=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;let l,h=1;if(t>.8){const e=(t-.8)/(1-.8);h=1-e*e*e}l=n.alternate?t<.5?2*t*.8:.8-2*(t-.5)*1.4:1*a*s;const c=1+l*h;return{position:[0,0,0],rotation:[0,0,.1*Math.sin(t*Math.PI*4)*a*h],scale:c}}}},Gy={name:"pancake",emoji:"",type:"override",description:"Extreme flatten and hold - cartoon pancake effect",config:{duration:1600,musicalDuration:{musical:!0,bars:1},squashAmount:.2,stretchAmount:2,holdRatio:.5,strength:1,particleMotion:{type:"pancake",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.squashAmount||.2,a=i.stretchAmount||2,r=.1+.6*(i.holdRatio||.5);let o=0,l=0;if(t<.1){const e=t/.1;o=1-Math.pow(1-e,2)}else if(t<r){o=1;const e=(t-.1)/(r-.1);l=Math.sin(e*Math.PI*4)*(1-e)*.02}else{const e=(t-r)/(1-r);if(o=1-(e<.3?e/.3*.3:.3+(e-.3)/.7*.7),e>.8){const t=(e-.8)/.2,i=.15*Math.sin(t*Math.PI);o=Math.max(0,o-i)}}const h=1+o*(a-1)*n;let c=1,u=0;return t<.15?(c=1+.8*(1-t/.15),u=.6*(1-t/.15)):t<r?(c=1.3,u=.2):c=1.3-(t-r)/(1-r)*.3,{position:[l*n,.2*-o*n,0],rotation:[0,0,2*l*n],scale:[h,1-o*(1-s)*n,h],glowIntensity:c,glowBoost:u}}}},Vy={name:"rage",emoji:"",type:"override",description:"Barbarian rage - intense buildup and release",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"rage",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1;let n=0,s=0,a=0,r=0,o=1,l=1,h=0;if(t<.2){const e=t/.2,o=e*e;s=.05*-o*i,a=.15*o*i;const h=Math.sin(80*t)*o*.02;r=h*i,n=.02*h*i,l=1+.3*o}else if(t<.6){const e=(t-.2)/.4,c=e*e;s=(-.05-.03*c)*i,a=(.15+.1*c)*i;const u=.02+.04*c,d=100+50*e,p=Math.sin(t*d)*u;r=p*i,n=.03*p*i,o=1+.1*c,l=1.3+.7*c,h=.5*c}else if(t<.8){const e=(t-.6)/.2;s=(.15*e-.08)*i,a=(.25-.4*e)*i,r=Math.sin(150*t)*(1-.5*e)*.05*i,o=1.1+.08*Math.sin(e*Math.PI),l=2-.3*e,h=.5+.3*Math.sin(e*Math.PI)}else{const e=(t-.8)/.2,n=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2;s=(.07-.07*n)*i,a=(.15*n-.15)*i,r=Math.sin(50*t)*(1-n)*.02*i,o=1.1-.1*n,l=1.7-.7*n,h=.5*(1-n)}return{position:[n,s,0],rotation:[a,0,r],scale:o,glowIntensity:l,glowBoost:h}}}},Hy={name:"fury",emoji:"",type:"override",description:"Quick fury burst - intense flash of anger",config:{duration:800,musicalDuration:{musical:!0,beats:2},strength:1,particleMotion:{type:"fury",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1;let n=0,s=0,a=0,r=1,o=1,l=0;if(t<.2){const e=t/.2,s=1-Math.pow(1-e,3);r=1+.15*s*i;const h=Math.sin(120*t)*s*.04;a=h*i,n=.02*h*i,o=1+1.2*s,l=.7*s}else if(t<.5){const e=(t-.2)/.3;r=1.15+.03*Math.sin(e*Math.PI*3);const h=.05*Math.sin(150*t)*(1-.3*e);a=h*i,n=.025*h*i,s=.1*Math.sin(e*Math.PI)*i,o=2.2-.3*e,l=.7-.2*e}else{const e=(t-.5)/.5,n=e*e;r=1.15-.15*n,a=Math.sin(80*t)*(1-n)*.03*i,s=.1*(1-n)*i,o=1.9-.9*n,l=.5*(1-n)}return{position:[n,0,0],rotation:[s,0,a],scale:r,glowIntensity:o,glowBoost:l}}}},Wy={name:"battlecry",emoji:"",type:"override",description:"Warrior battlecry - inhale, expand, roar",config:{duration:1500,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"battlecry",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1;let n=0,s=0,a=0,r=0,o=1,l=1,h=0;if(t<.25){const e=t/.25,r=e*e;s=.08*r*i,a=.15*-r*i,n=.03*-r*i,o=1+.05*r,l=1+.4*r}else if(t<.4){const e=(t-.25)/.15;s=(.08+.02*e)*i,a=(-.15-.1*e)*i,n=(.05*e-.03)*i,o=1.05+.08*e,l=1.4+.5*e,h=.4*e}else if(t<.6){const e=(t-.4)/.2,c=1-Math.pow(1-e,3);s=(.1-.2*c)*i,a=(.4*c-.25)*i,n=(.02+.08*c)*i,o=1.13+.12*c,l=1.9+.6*c,h=.4+.4*c,r=Math.sin(e*Math.PI*20)*(1-e)*.02*i}else{const e=(t-.6)/.4,c=e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2;s=-.1*(1-c)*i,a=.15*(1-c)*i,n=.1*(1-c)*i,o=1.25-.25*c,r=Math.sin(e*Math.PI*8)*(1-c)*.015*i,l=2.5-1.5*c,h=.8-.8*c}return{position:[0,n,s],rotation:[a,0,r],scale:o,glowIntensity:l,glowBoost:h}}}},jy={name:"charge",emoji:"",type:"override",description:"Bull charge - wind up and rush forward",config:{duration:1200,musicalDuration:{musical:!0,beats:3},strength:1,particleMotion:{type:"charge",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1;let n=0,s=0,a=0,r=0,o=0,l=1,h=1,c=0;if(t<.2){const e=t/.2,n=e*e;s=.08*-n*i,a=.1*n*i,r=.25*n*i,l=1-.05*n,h=1+.4*n}else if(t<.6){const e=(t-.2)/.4,n=1-Math.pow(1-e,2);a=(.1-.35*n)*i,r=(.25+.1*n)*i,s=(.06*n-.08)*i,l=.95+.15*n,h=1.4+.6*n,c=.4*n,o=Math.sin(e*Math.PI*10)*n*.02*i}else if(t<.85){const e=(t-.6)/.25;a=-.25*i,r=(.35-.1*e)*i;const s=Math.sin(e*Math.PI*15)*(1-e)*.04;o=s*i,n=.02*s*i,l=1.1+.05*Math.sin(e*Math.PI),h=2-.3*e,c=.4*(1-.5*e)}else{const e=(t-.85)/.15,n=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2;a=-.25*(1-n)*i,r=.25*(1-n)*i,s=-.02*(1-n)*i,l=1.1-.1*n,h=1.7-.7*n,c=.2*(1-n)}return{cameraRelativePosition:[n,s,a],rotation:[r,0,o],scale:l,glowIntensity:h,glowBoost:c}}}},Xy={name:"wobble",emoji:"",type:"override",description:"Unsteady circular wobbling motion",config:{duration:1500,musicalDuration:{musical:!0,beats:4},wobbleRadius:.08,wobbleAngle:.2,rotations:2,decay:.5,strength:1,particleMotion:{type:"wobble",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:4},timingSync:"onBeat"},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.wobbleRadius||.08,a=i.wobbleAngle||.2,r=i.rotations||2,o=i.decay||.5,l=t*r*Math.PI*2,h=1-o*t,c=Math.sin(l)*s*h*n,u=Math.cos(l)*s*h*n,d=Math.cos(l)*a*h*n,p=Math.sin(l)*a*h*n;return{position:[c,.02*Math.sin(2*l)*h*n,u],rotation:[d,0,p],scale:1+.05*Math.sin(2*l)*h,glowIntensity:1+.2*Math.sin(l)*h,glowBoost:0}}}},qy={name:"teeter",emoji:"",type:"override",description:"Rock back and forth unstably like losing balance",config:{duration:1200,musicalDuration:{musical:!0,beats:3},tiltAngle:.25,frequency:3,irregularity:.3,strength:1,particleMotion:{type:"teeter",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat"},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.tiltAngle||.25,a=i.frequency||3,r=i.irregularity||.3,o=(Math.sin(t*a*Math.PI*2)+Math.sin(t*(a+1.7)*Math.PI*2)*r+Math.sin(t*(.5*a)*Math.PI*2)*r*.5)/(1+1.5*r),l=o*s*n*.7,h=Math.sin(t*a*Math.PI*2+.5)*s*n*.5;return{position:[.15*h,0,.1*l],rotation:[l,0,h],scale:1+.05*Math.abs(o),glowIntensity:1+.2*Math.abs(o),glowBoost:0}}}},Yy={name:"rock",emoji:"",type:"override",description:"Gentle front-back rocking motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},rockAngle:.15,rockCycles:2,smooth:!0,strength:1,particleMotion:{type:"rock",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat"},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.rockAngle||.15,a=t*(i.rockCycles||2)*Math.PI*2,r=Math.sin(a),o=r*s*n,l=.05*r*n;return{position:[0,.02*Math.abs(r)*n,l],rotation:[o,0,0],scale:1+.02*Math.sin(.5*a),glowIntensity:1+.1*r,glowBoost:0}}}},$y={name:"pendulum",emoji:"",type:"override",description:"Swing side to side like a pendulum clock",config:{duration:1500,musicalDuration:{musical:!0,beats:4},swingAngle:.4,swings:2,damping:.3,strength:1,particleMotion:{type:"pendulum",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:4},timingSync:"onBeat"},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.swingAngle||.4,a=i.swings||2,r=i.damping||.3,o=t*a*Math.PI*2,l=1-r*t,h=Math.sin(o)*l,c=h*s*n;return{position:[.1*h*n,.03*-Math.abs(h)*n,0],rotation:[0,0,c],scale:1,glowIntensity:1+.15*Math.abs(h),glowBoost:0}}}},Zy={name:"shatter",emoji:"",type:"override",description:"Particles explode outward then freeze like shattered glass",config:{duration:1500,musicalDuration:{musical:!0,bars:1},explosionPhase:.3,freezePhase:.7,distance:100,tumble:1,strength:1,particleMotion:{type:"shatter",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=Math.random()*Math.PI*2,a=.5+.5*Math.random();t.gestureData.shatter={originalX:t.x,originalY:t.y,originalOpacity:t.opacity??1,velocityX:Math.cos(s)*a,velocityY:Math.sin(s)*a,tumbleAngle:0,tumbleSpeed:4*(Math.random()-.5),frozenX:null,frozenY:null,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.shatter?.initialized||this.initialize(t,i,s,a);const r={...this.config,...i},o=r.strength||1,l=r.distance||100,h=t.gestureData.shatter,c=r.explosionPhase||.3,u=r.freezePhase||.7;if(e<c){const i=e/c,n=1-Math.pow(1-i,3),s=h.velocityX*l*n*o,a=h.velocityY*l*n*o;t.x=h.originalX+s,t.y=h.originalY+a,h.tumbleAngle+=h.tumbleSpeed*(1-i)}else if(e<u){const i=(e-c)/(u-c),n=h.originalX+h.velocityX*l*o,s=h.originalY+h.velocityY*l*o,a=h.velocityX*l*.2*i*o,r=h.velocityY*l*.2*i*o;t.x=n+a,t.y=s+r,h.tumbleAngle+=.3*h.tumbleSpeed*(1-i),i>.95&&null===h.frozenX&&(h.frozenX=t.x,h.frozenY=t.y)}else if(null!==h.frozenX&&(t.x=h.frozenX,t.y=h.frozenY),e>.9){const i=(e-.9)/.1;t.opacity=h.originalOpacity*(1-.5*i)}},cleanup(t){if(t.gestureData?.shatter){const e=t.gestureData.shatter;t.x=e.originalX,t.y=e.originalY,t.opacity=e.originalOpacity,delete t.gestureData.shatter}},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1;let n=1,s=1,a=1,r=0,o=0,l=0,h=0,c=0,u=0,d=1,p=0;if(t<.1){const e=t/.1,r=1-Math.pow(1-e,2);s=1-.4*r*i,n=1+.2*r*i,a=1+.2*r*i,c=.1*-r*i,d=1+1*r,p=.8*r}else if(t<.4){const e=(t-.1)/.3,m=1-.6*e,g=40,f=Math.sin(t*g*Math.PI)*m,y=Math.cos(t*g*1.3*Math.PI)*m,v=Math.sin(t*g*.7*Math.PI)*m,b=1+.3*(1-Math.pow(1-e,2))*i;n=b+.15*f*i,s=b+.15*y*i,a=b+.15*v*i,r=.4*f*i,o=.5*y*i,l=.3*v*i,h=.15*f*i,c=.12*y*i+.1*e,u=.1*v*i,d=1.5+.5*Math.abs(f),p=.5*m}else if(t<.7){const e=(t-.4)/.3,r=e*e,o=1-r,h=20*o,u=Math.sin(t*h*Math.PI)*o,m=1.3-.4*r;n=m+.05*u*i,s=m+.05*u*i,a=m+.05*u*i,l=.15*u*i,c=.1*o,d=1.5-.3*r,p=.3*o}else{const e=(t-.7)/.3,i=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,r=Math.sin(e*Math.PI*2)*(1-e)*.05;if(n=.9+.1*i+r,s=.9+.1*i+r,a=.9+.1*i+r,d=1.2-.2*i,t>.95){const e=(t-.95)/.05;p=.3*Math.sin(e*Math.PI)}}return{position:[h,c,u],rotation:[r,o,l],scale:[n,s,a],glowIntensity:d,glowBoost:p}}}};const Jy={default:{name:"shatter",emoji:"",description:"Dramatic shattering effect",duration:2500,beats:4,intensity:1,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!1,revealSoul:!1},explosive:{name:"shatterExplosive",emoji:"",description:"Explosive outward shatter",duration:2e3,beats:3,intensity:1.5,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0},crumble:{name:"shatterCrumble",emoji:"",description:"Slow crumbling collapse",duration:8e3,beats:16,intensity:.15,impactPoint:[0,-.4,0],impactDirection:[0,-1,0],reassemble:!1,revealSoul:!0,gravity:-.8,explosionForce:.1,rotationForce:.5,shatterTriggerAt:0},reform:{name:"shatterReform",emoji:"",description:"Shatter then magically reassemble",duration:4e3,beats:8,intensity:1,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!0,reassembleAt:.5,reassembleDuration:1500,revealSoul:!0},punchLeft:{name:"shatterPunchLeft",emoji:"",description:"Shatter from left impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[-.4,0,0],impactDirection:[1,0,0],reassemble:!1,useDeformation:!0,direction:"left",revealSoul:!1},punchRight:{name:"shatterPunchRight",emoji:"",description:"Shatter from right impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[.4,0,0],impactDirection:[-1,0,0],reassemble:!1,useDeformation:!0,direction:"right",revealSoul:!1},punchFront:{name:"shatterPunchFront",emoji:"",description:"Shatter from front impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!1,useDeformation:!0,direction:"front",revealSoul:!1},suspend:{name:"shatterSuspend",emoji:"",description:"Shatter, freeze mid-air, then reassemble",duration:4e3,beats:8,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!0,reassembleAt:.7,reassembleDuration:1200,revealSoul:!0,isSuspendMode:!0,suspendAt:.12,suspendDuration:.2,gravity:-2,explosionForce:1.2},freeze:{name:"shatterFreeze",emoji:"",description:"Shatter and freeze mid-air (call triggerReassembly to reform)",duration:2e3,beats:4,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0,isFreezeMode:!0,isSuspendMode:!0,suspendAt:.12,suspendDuration:.2,gravity:-2,explosionForce:1.2},implode:{name:"shatterImplode",emoji:"",description:"Shards implode inward to center (or implode existing frozen shards)",duration:2500,beats:4,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0,isDualMode:!0,dualModeType:"implode",dualModeDuration:1800,gravity:-3,explosionForce:1.2},gravity:{name:"shatterGravity",emoji:"",description:"Shards fall with gravity and bounce on floor (or drop frozen shards)",duration:4e3,beats:8,intensity:.6,impactPoint:[0,0,0],impactDirection:[0,-1,0],reassemble:!1,revealSoul:!0,isDualMode:!0,dualModeType:"gravity",dualModeDuration:3e3,floorY:-.35,gravity:-2,explosionForce:.4},orbit:{name:"shatterOrbit",emoji:"",description:"Shards orbit around the soul then reassemble",duration:5e3,beats:10,intensity:.6,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!0,reassembleAt:.75,reassembleDuration:1200,revealSoul:!0,isDualMode:!0,dualModeType:"orbit",dualModeDuration:3500,orbitSpeed:1.5,radiusMultiplier:1.2,gravity:-3,explosionForce:1}};function Qy(t="default"){const e=Jy[t]||Jy.default;return{name:e.name,emoji:e.emoji,type:"override",description:e.description,config:{duration:e.duration,musicalDuration:{musical:!0,beats:e.beats},intensity:e.intensity,variant:t},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:e.beats},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.intensity||1,s=i.variant||"default",a=Jy[s]||Jy.default,r=a.useDeformation||!1,o=a.direction||"front";let l=!1,h=!1,c=1,u=0,d=1,p=null,m=null,g=null;const f=a.reassemble,y=a.reassembleAt||.5;if(r){let e;if(t<.3){const i=t/.3;e=i*(2-i)}else e=0;let i=0;t<.25?i=t/.25:t<.3&&(i=1);const s=.15*n,r=.25*n;let h=0,d=0;const f=0;let y=0,v=0;switch(o){case"left":h=e*s,v=-e*r;break;case"right":h=-e*s,v=e*r;break;case"front":d=-e*s,y=e*r*.7}if(e>0&&(m=[h,f,d],g=[y,0,v]),i>0&&(p={enabled:!0,strength:i*n*2.5,impactPoint:a.impactPoint,falloffRadius:.5}),t>=.28&&t<.32&&(l=!0),t<.35){const e=t/.35;c=1+.8*(1-e),u=.5*(1-e)}}else{const e=void 0!==a.shatterTriggerAt?a.shatterTriggerAt:.1,i=e+.02;if(t<e){if(e>0){const i=t/e,n=i*i;c=1+.6*n,u=.3*n,d=1+.05*n,"explosive"===s&&(d+=.01*Math.sin(200*t)*i)}}else if(t<i)l=t>=e&&t<e+.005,c=1.6,u=.4,d=1.05;else{if(f&&t>=y&&t<y+.02&&(h=!0),f&&t>=y){const e=(t-y)/(1-y),i=e*e;c=1+.8*i,u=.5*i,t>.95&&(c=2,u=.8)}else{const e=(t-i)/(f?y-i:1-i),n=Math.min(1,e),s=1-(1-n)*(1-n);c=1.6-.6*s,u=.4-.4*s}d=1}}const v={scale:d,glowIntensity:c,glowBoost:u,shatter:{enabled:l,impactPoint:a.impactPoint,impactDirection:a.impactDirection||[0,0,-1],intensity:n*a.intensity,variant:s,reassemble:h,reassembleDuration:a.reassembleDuration||1e3,revealSoul:!1!==a.revealSoul,isCrackMode:a.isCrackMode||!1,crackSeparation:a.crackSeparation||.02,isSuspendMode:a.isSuspendMode||!1,suspendAt:a.suspendAt||.25,suspendDuration:a.suspendDuration||.35,isFreezeMode:a.isFreezeMode||!1,gravity:a.gravity,explosionForce:a.explosionForce,rotationForce:a.rotationForce,gestureDuration:a.duration,isDualMode:a.isDualMode||!1,dualModeType:a.dualModeType,dualModeConfig:{duration:a.dualModeDuration||2e3,impactPoint:a.impactPoint,windDirection:a.windDirection,windForce:a.windForce,turbulence:a.turbulence,waveSpeed:a.waveSpeed,floorY:a.floorY,orbitSpeed:a.orbitSpeed,radiusMultiplier:a.radiusMultiplier,reassemble:a.reassemble,reassembleDuration:a.reassembleDuration}}};return p&&(v.deformation=p),m&&(v.cameraRelativePosition=m),g&&(v.cameraRelativeRotation=g),v}}}}const Ky={up:{name:"dissolveUp",emoji:"",description:"Shards blow upward like rising dust",windDirection:[0,1,.1],windForce:2.5,turbulence:.6},down:{name:"dissolveDown",emoji:"",description:"Shards blow downward like falling ash",windDirection:[0,-1,.1],windForce:1.8,turbulence:.4},left:{name:"dissolveLeft",emoji:"",description:"Shards blow left in the wind",windDirection:[-1,.15,0],impactDir:[1,.15,0],windForce:2.2,turbulence:.5},right:{name:"dissolveRight",emoji:"",description:"Shards blow right in the wind",windDirection:[1,.15,0],impactDir:[-1,.15,0],windForce:2.2,turbulence:.5},away:{name:"dissolveAway",emoji:"",description:"Shards blow away from camera into distance",windDirection:[0,.1,-1],windForce:2,turbulence:.4},toward:{name:"dissolveToward",emoji:"",description:"Shards blow toward camera",windDirection:[0,.1,1],windForce:2.5,turbulence:.6}};function tv(t="away"){const e=Ky[t]||Ky.away;return{name:e.name,emoji:e.emoji,type:"override",description:e.description,config:{duration:3500,musicalDuration:{musical:!0,beats:6},intensity:.7,direction:t},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:6},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.2}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.intensity||.7,s=i.direction||"away",a=Ky[s]||Ky.away;let r=!1,o=1,l=0,h=1;const c=.06;if(t<c){const e=t/c;o=1+.4*e,l=.2*e,h=1+.03*e}else if(t<.08)r=t>=c&&t<.065,o=1.4,l=.3;else{const e=(t-c)/.94;o=1.4-.6*e,l=Math.max(0,.3-.3*e)}return{scale:h,glowIntensity:o,glowBoost:l,shatter:{enabled:r,impactPoint:[0,0,0],impactDirection:a.impactDir||a.windDirection,intensity:.5*n,variant:`dissolve_${s}`,revealSoul:!0,isSuspendMode:!1,isFreezeMode:!1,gravity:-.5,explosionForce:.3,gestureDuration:3500,isDualMode:!0,dualModeType:"dissolve",dualModeConfig:{duration:3e3,windDirection:a.windDirection,windForce:a.windForce*n,turbulence:a.turbulence}}}}}}}var ev={name:"morph",emoji:"",type:"override",description:"Form geometric patterns and shapes",config:{musicalDuration:{musical:!0,beats:2,minBeats:1,maxBeats:8},phases:[{name:"gather",beats:.25},{name:"form",beats:.75},{name:"hold",beats:.5},{name:"dissolve",beats:.5}],morphType:"fluid",pattern:"star",points:5,innerRadius:.4,size:80,amplitude:20,rotation:0,smooth:!0,randomizeOrder:!1,easing:"sine",strength:1.2,particleMotion:{type:"morph",pattern:"star",strength:1.2,smooth:!0,points:5}},rhythm:{enabled:!0,syncMode:"phrase",patternSync:{verse:"circle",chorus:"star",bridge:"heart",drop:"explosion"},timingSync:{formationBeat:1,holdBeats:2,dissolveBeat:4,curve:"anticipatory"},sizeSync:{onBeat:1.2,offBeat:.95,subdivision:"quarter",curve:"elastic"},rotationSync:{mode:"continuous",degreesPerBar:90,direction:"clockwise"},dynamics:{forte:{points:8,size:100},piano:{points:3,size:60}}},initialize(t,e,i,n,s){t.gestureData||(t.gestureData={});const a={...this.config,...e},r=t.x,o=t.y,l=Math.atan2(t.y-n,t.x-i),h=Math.random()<.5?1:-1;let c,u;const d=a.size*t.scaleFactor,p=(a.rotation||0)*Math.PI/180*h;switch(a.pattern){case"star":c=i,u=n,this.calculateStarPosition(t,l,d,a.points,a.innerRadius,p,i,n);break;case"heart":this.calculateHeartPosition(t,l,d,p,i,n);break;case"square":this.calculateSquarePosition(t,l,d,p,i,n);break;case"triangle":this.calculateTrianglePosition(t,l,d,p,i,n);break;default:{const t=d;c=i+Math.cos(l+p)*t,u=n+Math.sin(l+p)*t;break}}t.gestureData.morph={startX:r,startY:o,targetX:t.gestureData.morphTargetX||c,targetY:t.gestureData.morphTargetY||u,originalVx:t.vx,originalVy:t.vy,rotationDirection:h,initialized:!0}},calculateStarPosition(t,e,i,n,s,a,r,o){const l=((e+Math.PI)%(2*Math.PI)+2*Math.PI)%(2*Math.PI),h=Math.floor(l/(2*Math.PI)*10),c=h%2==0,u=Math.floor(h/2);let d;d=c?72*u*Math.PI/180:(72*u+36)*Math.PI/180,d+=a;const p=c?i:i*s;t.gestureData.morphTargetX=r+Math.cos(d)*p,t.gestureData.morphTargetY=o+Math.sin(d)*p},calculateHeartPosition(t,e,i,n,s,a){const r=(e+Math.PI)/(2*Math.PI),o=.05*i,l=16*Math.pow(Math.sin(r*Math.PI*2),3),h=-(13*Math.cos(r*Math.PI*2)-5*Math.cos(2*r*Math.PI*2)-2*Math.cos(3*r*Math.PI*2)-Math.cos(4*r*Math.PI*2)),c=Math.cos(n),u=Math.sin(n),d=l*c-h*u,p=l*u+h*c;t.gestureData.morphTargetX=s+d*o,t.gestureData.morphTargetY=a+p*o},calculateSquarePosition(t,e,i,n,s,a){const r=((e+n)%(2*Math.PI)+2*Math.PI)%(2*Math.PI);let o,l;const h=i;r<Math.PI/4||r>=7*Math.PI/4?(o=h,l=h*Math.tan(r)):r<3*Math.PI/4?(o=h/Math.tan(r),l=h):r<5*Math.PI/4?(o=-h,l=-h*Math.tan(r)):(o=-h/Math.tan(r),l=-h);const c=Math.cos(n),u=Math.sin(n),d=o*c-l*u,p=o*u+l*c;t.gestureData.morphTargetX=s+d,t.gestureData.morphTargetY=a+p},calculateTrianglePosition(t,e,i,n,s,a){const r=[{x:0,y:-i},{x:.866*-i,y:.5*i},{x:.866*i,y:.5*i}],o=Math.floor((e+Math.PI)/(2*Math.PI)*3)%3,l=(o+1)%3,h=Math.random(),c=r[o].x+(r[l].x-r[o].x)*h,u=r[o].y+(r[l].y-r[o].y)*h,d=Math.cos(n),p=Math.sin(n),m=c*d-u*p,g=c*p+u*d;t.gestureData.morphTargetX=s+m,t.gestureData.morphTargetY=a+g},apply(t,e,i,n,s,a){t.gestureData?.morph?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.morph,o={...this.config,...i};let l,h,c=e;if(o.holdTime>0){const t=.5-o.holdTime/2,i=.5+o.holdTime/2;c=e<t?e/t*.5:e<i?.5:.5+(e-i)/(1-i)*.5}if(c<=.5){const t=2*c;l=r.startX+(r.targetX-r.startX)*this.easeOutQuad(t),h=r.startY+(r.targetY-r.startY)*this.easeOutQuad(t)}else{const t=2*(c-.5);l=r.targetX+(r.startX-r.targetX)*this.easeInQuad(t),h=r.targetY+(r.startY-r.targetY)*this.easeInQuad(t)}if(o.smooth){const e=.2;t.x+=(l-t.x)*e,t.y+=(h-t.y)*e}else t.x=l,t.y=h;if(t.vx=.5*(l-t.x),t.vy=.5*(h-t.y),e>.9){const i=10*(1-e);t.vx=t.vx*i+r.originalVx*(1-i),t.vy=t.vy*i+r.originalVy*(1-i)}},cleanup(t){if(t.gestureData?.morph){const e=t.gestureData.morph;t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.morph,delete t.gestureData.morphTargetX,delete t.gestureData.morphTargetY}},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,easeOutQuad:t=>t*(2-t),easeInQuad:t=>t*t,"3d":{evaluate(t,e){const i=e?.strength||1,n=Math.sin(t*Math.PI);let s;if(t<=.5){const e=2*t;s=1+e*(2-e)*.25*i}else{const e=2*(t-.5);s=1.25*i+e*e*(1-1.25*i),s=Math.max(1,s)}return{position:[0,0,0],rotation:[0,n*Math.PI*.3*i,.1*Math.sin(t*Math.PI*2)*i],scale:s,glowIntensity:1+.4*n*i,glowBoost:1.5*n*i}}}},iv={name:"rain",emoji:"",type:"override",description:"Particles fall down from their current positions",config:{duration:3e3,musicalDuration:{musical:!0,bars:2},fallSpeed:8,fallDistance:400,wobbleAmount:1.5,strength:1,particleMotion:{type:"rain",strength:1,fallSpeed:8}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:2},intensitySync:{quiet:.5,loud:1.5,crescendo:"increase",diminuendo:"decrease"}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.rain={originalX:t.x,originalY:t.y,originalVx:t.vx,originalVy:t.vy,originalOpacity:t.opacity??t.life??1,currentX:t.x,currentY:t.y,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),initialized:!0},console.log("[RAIN] initialize() - Captured particle position:",{originalX:t.x,originalY:t.y,particleId:t.id||"no-id"})},apply(t,e,i,n){const s="number"==typeof n?n:1;console.log("[RAIN] apply() CALLED - progress:",e?.toFixed?.(3)||e,"dt:",s),t.gestureData?.rain?.initialized||(console.log("[RAIN] apply() - First frame, initializing..."),this.initialize(t,i));const a=t.gestureData.rain,r={...this.config,...i},o=i?.strength||1,l=(r.fallSpeed||8)*o,h=(r.fallDistance||400)*e*o;a.wobblePhase+=a.wobbleSpeed*s*.1;const c=Math.sin(a.wobblePhase)*(r.wobbleAmount||1.5),u=t.y;if(t.x=a.originalX+c,t.y=a.originalY+h,console.log("[RAIN] apply() - Setting position:",{originalY:a.originalY,totalFall:h?.toFixed?.(1)||h,newY:t.y?.toFixed?.(1)||t.y,oldY:u?.toFixed?.(1)||u,progress:e?.toFixed?.(3)||e}),t.vx=.3*c,t.vy=10*l,e>.6){const i=(e-.6)/.4;t.opacity=a.originalOpacity*(1-i),void 0!==t.life&&(t.life=a.originalOpacity*(1-i))}else t.opacity=a.originalOpacity,void 0!==t.life&&(t.life=a.originalOpacity)},cleanup(t){if(t.gestureData?.rain){const e=t.gestureData.rain;t.x=e.originalX,t.y=e.originalY,t.vx=e.originalVx,t.vy=e.originalVy,t.opacity=e.originalOpacity,void 0!==t.life&&(t.life=e.originalOpacity),delete t.gestureData.rain}},"3d":{evaluate:(t,e)=>({position:[0,0,0],rotation:[0,0,0],scale:1})}},nv={name:"drift",emoji:"",type:"override",description:"Controlled floating with fade effects",config:{duration:800,musicalDuration:{musical:!0,beats:2},distance:50,angle:45,returnToOrigin:!0,fadeOut:!1,holdTime:.2,turbulence:.1,angleSpread:45,smoothness:.08,easing:"ease",strength:1,particleMotion:{type:"drift",strength:1,distance:60}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"beats",beats:2},distanceSync:{quiet:30,loud:80,crescendo:"expand",diminuendo:"contract"},angleSync:{major:45,minor:225,modulation:"smooth",cadence:"return"},holdSync:{shortPhrase:.1,longPhrase:.4,fermata:"sustain"},accentResponse:{enabled:!0,multiplier:1.3,type:"distance"},patternOverrides:{ambient:{distanceSync:{quiet:40,loud:100},holdSync:{shortPhrase:.3,longPhrase:.6}},classical:{angleSync:{major:30,minor:210},distanceSync:{quiet:25,loud:60}},jazz:{angleSync:{major:60,minor:240,swing:!0,syncopated:!0}},new_age:{distanceSync:{quiet:35,loud:70},holdSync:{shortPhrase:.4,longPhrase:.8},angleSync:{modulation:"gradual"}}},dynamics:{forte:{distanceSync:{quiet:{multiplier:1.5},loud:{multiplier:1.8}},holdSync:{multiplier:1.2},accentResponse:{multiplier:1.6}},piano:{distanceSync:{quiet:{multiplier:.6},loud:{multiplier:.8}},holdSync:{multiplier:.8},accentResponse:{multiplier:1.1}}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n;let r=Math.atan2(a,s);const o={...this.config,...e}.angleSpread*Math.PI/180,l=(Math.random()-.5)*o;r+=l;const h=30+30*Math.random();t.gestureData.drift={startX:t.x,startY:t.y,originalVx:t.vx,originalVy:t.vy,baseOpacity:t.opacity||t.life||1,driftAngle:r,angleOffset:l,homeRadius:h*t.scaleFactor,homeX:i+Math.cos(r)*h,homeY:n+Math.sin(r)*h,role:Math.random(),turbulencePhase:Math.random()*Math.PI*2,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.drift?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.drift,o={...this.config,...i},l=i.strength||1,h=this.easeInOutCubic(e),c=Math.max(0,h-.1*r.role);let u,d,p;if(o.returnToOrigin)if(c<.4){const t=c/.4,e=this.easeOutQuad(t);u=r.startX+(r.homeX-r.startX)*e,d=r.startY+(r.homeY-r.startY)*e}else if(c<.6+o.holdTime){const e=(c-.4)/(.2+o.holdTime);p=r.homeRadius+Math.sin(e*Math.PI*.5)*o.distance*l*t.scaleFactor}else{const e=(c-.6-o.holdTime)/(.4-o.holdTime);p=r.homeRadius+Math.cos(e*Math.PI*.5)*o.distance*l*t.scaleFactor}else{const e=c;p=r.homeRadius+e*o.distance*l*t.scaleFactor}if(void 0!==p){r.turbulencePhase+=o.turbulence*n;const t=Math.sin(r.turbulencePhase)*o.turbulence*10,e=Math.cos(1.3*r.turbulencePhase)*o.turbulence*10,i=r.driftAngle+r.angleOffset;u=s+Math.cos(i)*p+t,d=a+Math.sin(i)*p+e}const m=o.smoothness+.08*r.role;if(t.x+=(u-t.x)*m,t.y+=(d-t.y)*m,t.vx=.25*(u-t.x),t.vy=.25*(d-t.y),o.fadeOut){let i;i=e<.25?.3+e/.25*.7:e<.75?.7+.3*Math.sin((e-.25)*Math.PI/.5):4*(1-e),t.opacity=r.baseOpacity*i,void 0!==t.life&&(t.life=t.opacity)}e>=.99&&(t.vx=.1*r.originalVx,t.vy=.1*r.originalVy,o.fadeOut&&(t.opacity=r.baseOpacity,void 0!==t.life&&(t.life=r.baseOpacity)))},cleanup(t){if(t.gestureData?.drift){const e=t.gestureData.drift;t.vx=e.originalVx,t.vy=e.originalVy,t.opacity=e.baseOpacity,void 0!==t.life&&(t.life=e.baseOpacity),delete t.gestureData.drift}},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,easeOutQuad:t=>t*(2-t),"3d":{evaluate(t,e){const i={...this.config,...e},n=e.strength||1,s=(i.angle||45)*Math.PI/180,a=i.returnToOrigin?t<.5?2*t:2*(1-t):t;return{position:[Math.cos(s)*a*.3*n,Math.sin(s)*a*.3*n,.15*Math.sin(t*Math.PI)*n],rotation:[0,10*a*n,0],scale:1+.03*Math.sin(t*Math.PI),glowIntensity:1-.1*a}}}};function sv(t){const e=uf[t];if(!e)throw new Error(`Invalid drift direction: ${t}`);const i="up"===t||"down"===t;return{name:`drift${df(t)}`,emoji:"up"===t?"":"down"===t?"":"left"===t?"":"",type:"override",description:`Gentle drifting ${t}`,config:{duration:800,musicalDuration:{musical:!0,beats:2},distance:50,returnToOrigin:!0,fadeOut:!1,holdTime:.2,turbulence:.1,smoothness:.08,strength:1,direction:t,particleMotion:{type:"drift",strength:1,distance:60}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"beats",beats:2},distanceSync:{quiet:30,loud:80,crescendo:"expand",diminuendo:"contract"},holdSync:{shortPhrase:.1,longPhrase:.4,fermata:"sustain"},accentResponse:{enabled:!0,multiplier:1.3,type:"distance"}},initialize(t,e,i,n){t.gestureData||(t.gestureData={}),this.config;const s=(30+30*Math.random())*t.scaleFactor;t.gestureData.drift={startX:t.x,startY:t.y,originalVx:t.vx,originalVy:t.vy,baseOpacity:t.opacity||t.life||1,homeRadius:s,role:Math.random(),turbulencePhase:Math.random()*Math.PI*2,initialized:!0}},apply(t,n,s,a,r,o){t.gestureData?.drift?.initialized||this.initialize(t,s,r,o);const l=t.gestureData.drift,h={...this.config,...s},c=s.strength||1,u=this.easeInOutCubic(n),d=Math.max(0,u-.1*l.role);let p,m=l.startX,g=l.startY;p=h.returnToOrigin?d<.5?2*d:2*(1-d):d;const f=h.distance*c*t.scaleFactor*p;l.turbulencePhase+=h.turbulence*a;const y=Math.sin(l.turbulencePhase)*h.turbulence*10,v=Math.cos(1.3*l.turbulencePhase)*h.turbulence*10;i?(g=l.startY+e.y*f+y,m=l.startX+.5*v):(m=l.startX+e.x*f+v,g=l.startY+.5*y);const b=h.smoothness+.08*l.role;if(t.x+=(m-t.x)*b,t.y+=(g-t.y)*b,t.vx=.25*(m-t.x),t.vy=.25*(g-t.y),h.fadeOut){let e=1;e=n<.25?.3+n/.25*.7:n<.75?.7+.3*Math.sin((n-.25)*Math.PI/.5):4*(1-n),t.opacity=l.baseOpacity*e}n>=.99&&(t.vx=.1*l.originalVx,t.vy=.1*l.originalVy,h.fadeOut&&(t.opacity=l.baseOpacity))},cleanup(t){if(t.gestureData?.drift){const e=t.gestureData.drift;t.vx=e.originalVx,t.vy=e.originalVy,t.opacity=e.baseOpacity,delete t.gestureData.drift}},easeInOutCubic:t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,"3d":{evaluate(t,n){const s=n||{},a=s.strength||1,r=s.distance||50,o=!1!==s.returnToOrigin?Math.sin(t*Math.PI):t,l=.004*r*a*o,h=e.x*l,c=e.y*l;let u=0,d=0;return i?u=e.y*o*.1:d=e.x*o*.15,{cameraRelativePosition:[h,c,0],rotation:[u,d,0],scale:1+.03*o,glowIntensity:1-.1*o}}}}}var av=sv("up"),rv=sv("down"),ov=sv("left"),lv=sv("right"),hv={name:"vortex",emoji:"",type:"override",description:"Spiral tornado pattern inward or outward",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},direction:"inward",rotationSpeed:2,pullStrength:1,liftAmount:.5,strength:1,particleMotion:{type:"vortex",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",rotationSync:{onBeat:1.5,offBeat:.8}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-(i||0),a=t.y-(n||0);t.gestureData.vortex={originalX:t.x,originalY:t.y,startAngle:Math.atan2(a,s),startDistance:Math.sqrt(s*s+a*a),initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.vortex?.initialized||this.initialize(t,i,s,a);const r={...this.config,...i},o=t.gestureData.vortex,l="outward"!==r.direction,h=r.rotationSpeed||2,c=r.pullStrength||1,u=e*h*Math.PI*2,d=o.startAngle+u;let p;p=l?1-e*c*.8:1+e*c*.5;const m=o.startDistance*p;t.x=s+Math.cos(d)*m,t.y=a+Math.sin(d)*m,l&&e>.7&&(t.opacity=1-(e-.7)/.3)},cleanup(t){if(t.gestureData?.vortex){const e=t.gestureData.vortex;t.x=e.originalX,t.y=e.originalY,t.opacity=1,delete t.gestureData.vortex}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s="outward"!==i.direction,a=i.rotationSpeed||2,r=i.liftAmount||.5,o=t*a*Math.PI*2*n;let l;l=s?1-.3*t*n:1+.2*t*n;const h=t>.85?(1-t)/.15:1;return{position:[0,Math.sin(t*Math.PI)*r*.1*n*h,0],rotation:[.1*Math.sin(o)*n*h,o,.1*Math.cos(o)*n*h],scale:l,glowIntensity:1+.4*t,glowBoost:.3*t}}}};function cv(t){if(!uf[t])throw new Error(`Invalid cascade direction: ${t}`);const e="up"===t||"down"===t,i="down"===t||"right"===t;return{name:`cascade${df(t)}`,emoji:"down"===t?"":"up"===t?"":"left"===t?"":"",type:"override",description:`Sequential cascade ${t}`,config:{duration:2e3,musicalDuration:{musical:!0,bars:1},distance:200,waveCount:4,staggerDelay:.15,wobble:1,strength:1,direction:t,particleMotion:{type:"cascade",strength:1,direction:t}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",distanceSync:{quiet:100,loud:300,crescendo:"expand",diminuendo:"contract"}},initialize(t,e){t.gestureData||(t.gestureData={});const i=e?.waveCount||4;let n;n=Math.floor(Math.random()*i),t.gestureData.cascade={originalX:t.x,originalY:t.y,originalOpacity:t.opacity??t.life??1,waveGroup:n,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),initialized:!0}},apply(t,n,s,a,r,o){t.gestureData?.cascade?.initialized||this.initialize(t,s);const l={...this.config,...s},h=l.strength||1,c=t.gestureData.cascade,u="number"==typeof a?a:1,d=l.waveCount||4,p=l.staggerDelay||.15,m=c.waveGroup*p,g=Math.max(0,(n-m)/(1-m*(d-1)/d));if(g<=0)return;const f=(1-Math.pow(1-g,2))*((l.distance||200)*h)*(i?1:-1);c.wobblePhase+=c.wobbleSpeed*u*.1;const y=Math.sin(c.wobblePhase)*(l.wobble||1)*10;if(e?(t.y=c.originalY+f,t.x=c.originalX+y):(t.x=c.originalX+f,t.y=c.originalY+y),g>.6){const e=(g-.6)/.4;t.opacity=c.originalOpacity*(1-e)}},cleanup(t){if(t.gestureData?.cascade){const e=t.gestureData.cascade;t.x=e.originalX,t.y=e.originalY,t.opacity=e.originalOpacity,delete t.gestureData.cascade}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.direction||"down",a=1-Math.pow(1-t,2);let r=0,o=0;const l=.3*a*n;switch(s){case"down":o=-l;break;case"up":o=l;break;case"left":r=-l;break;case"right":r=l}const h=.03*Math.sin(t*Math.PI*4)*n;"down"===s||"up"===s?r+=h:o+=h;const c=t>.85?(1-t)/.15:1;return{cameraRelativePosition:[r*c,o*c,0],rotation:[("down"===s?.05:"up"===s?-.05:0)*n*c,0,("left"===s?.1:"right"===s?-.1:0)*n*c],scale:1-.1*a,glowIntensity:1+.2*(1-a)}}}}}var uv=cv("up"),dv=cv("down"),pv=cv("left"),mv=cv("right"),gv={name:"confetti",emoji:"",type:"effect",description:"Celebratory confetti flutter with chaotic rotation",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},burstHeight:.3,fallSpeed:1,tumbleSpeed:2,spread:1,strength:1,particleMotion:{type:"confetti",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1.5},timingSync:"onBeat"},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.confetti={originalX:t.x,originalY:t.y,driftX:2*(Math.random()-.5),tumblePhase:Math.random()*Math.PI*2,tumbleSpeed:.5+1.5*Math.random(),flutterAmp:.3+.7*Math.random(),initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.confetti?.initialized||this.initialize(t,i);const r={...this.config,...i},o=r.strength||1,l=t.gestureData.confetti,h=Math.min(e/.2,1),c=Math.max(0,(e-.2)/.8),u=-50*Math.sin(h*Math.PI)*(r.burstHeight||.3),d=c*c*200*(r.fallSpeed||1),p=20*Math.sin(e*Math.PI*8*l.tumbleSpeed)*l.flutterAmp,m=l.driftX*e*100*(r.spread||1);t.x=l.originalX+m+p*o,t.y=l.originalY+u+d*o,e>.7&&(t.opacity=1-(e-.7)/.3)},cleanup(t){t.gestureData?.confetti&&delete t.gestureData.confetti},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1,n=Math.min(t/.2,1),s=Math.max(0,(t-.2)/.8),a=.15*Math.sin(n*Math.PI)-s*s*.3,r=t*Math.PI*4,o=.3*Math.sin(1.3*r)*i,l=.4*Math.sin(.7*r)*i,h=.5*Math.sin(1.1*r)*i,c=t>.85?(1-t)/.15:1;return{position:[.08*Math.sin(t*Math.PI*6)*i*c,a*i*c,0],rotation:[o*c,l*c,h*c],scale:1+.1*Math.sin(2*r)*i,glowIntensity:1+.3*(1-s)}}}},fv={name:"fizz",emoji:"",type:"override",description:"Bubbles rising upward with wobble",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},riseSpeed:6,riseDistance:300,wobbleAmount:2,strength:1,particleMotion:{type:"fizz",strength:1}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:1.5},intensitySync:{quiet:.5,loud:1.5}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.fizz={originalX:t.x,originalY:t.y,originalOpacity:t.opacity??t.life??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.4+.6*Math.random(),riseMultiplier:.7+.6*Math.random(),initialized:!0}},apply(t,e,i,n){t.gestureData?.fizz?.initialized||this.initialize(t,i);const s={...this.config,...i},a=s.strength||1,r=t.gestureData.fizz,o="number"==typeof n?n:1,l=(s.riseDistance||300)*e*a*r.riseMultiplier;r.wobblePhase+=r.wobbleSpeed*o*.1;const h=Math.sin(r.wobblePhase)*(s.wobbleAmount||2)*(1+e);if(t.x=r.originalX+h,t.y=r.originalY-l,t.vx=.3*h,t.vy=10*-(s.riseSpeed||6),e>.6){const i=(e-.6)/.4;t.opacity=r.originalOpacity*(1-i),void 0!==t.life&&(t.life=r.originalOpacity*(1-i))}},cleanup(t){if(t.gestureData?.fizz){const e=t.gestureData.fizz;t.x=e.originalX,t.y=e.originalY,t.opacity=e.originalOpacity,void 0!==t.life&&(t.life=e.originalOpacity),delete t.gestureData.fizz}},"3d":{evaluate(t,e){const i=(e.config||this.config||{}).strength||1;let n=0,s=1,a=1;if(t<.15){const e=t/.15;n=.15*e,s=1+.02*e,a=1+.15*e}else if(t<.7){const e=(t-.15)/.55;n=.5-.15*e,s=1.02+.03*Math.sin(e*Math.PI*6),a=1.2+.15*Math.sin(e*Math.PI*8)}else{const e=(t-.7)/.3;n=.35*(1-e),s=1.02-.02*e,a=1.2-.2*e}const r=35*t;return{position:[.008*Math.sin(1.7*r)*n*i,.006*Math.sin(2.3*r)*n*i,.004*Math.sin(1.9*r)*n*i],rotation:[.03*Math.sin(1.3*r)*n*i,.02*Math.sin(1.1*r)*n*i,.04*Math.sin(1.5*r)*n*i],scale:[s+.015*Math.sin(2.1*r)*n,s+.02*Math.sin(1.8*r)*n,s+.015*Math.sin(2.4*r)*n],glowIntensity:a,glowBoost:.2*n}}}};function yv(t){const e=uf[t];if(!e)throw new Error(`Invalid swarm direction: ${t}`);return{name:`swarm${df(t)}`,emoji:"up"===t?"":"down"===t?"":"",type:"override",description:`Flock movement ${t}`,config:{duration:1800,musicalDuration:{musical:!0,bars:1},clusterPhase:.3,moveDistance:120,clusterTightness:.5,wobble:1,strength:1,direction:t,particleMotion:{type:"swarm",strength:1,direction:t}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat"},initialize(t,e,i,n){t.gestureData||(t.gestureData={}),t.gestureData.swarm={originalX:t.x,originalY:t.y,originalOpacity:t.opacity??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),timeOffset:.1*Math.random(),initialized:!0}},apply(t,i,n,s,a,r){t.gestureData?.swarm?.initialized||this.initialize(t,n,a,r);const o={...this.config,...n},l=o.strength||1,h=t.gestureData.swarm,c=o.clusterPhase||.3,u=o.moveDistance||120,d=o.clusterTightness||.5,p=Math.max(0,Math.min(1,i-h.timeOffset));let m,g;if(p<c){const t=p/c,e=1-Math.pow(1-t,2);m=h.originalX+(a-h.originalX)*d*e,g=h.originalY+(r-h.originalY)*d*e}else{const t=(p-c)/(1-c),i=1-Math.pow(1-t,2),n=h.originalX+(a-h.originalX)*d,s=h.originalY+(r-h.originalY)*d;m=n+e.x*u*i*l,g=s+e.y*u*i*l}const f="number"==typeof s?s:1;h.wobblePhase+=h.wobbleSpeed*f*.1;const y=Math.sin(3*h.wobblePhase)*o.wobble*5,v=Math.cos(2.5*h.wobblePhase)*o.wobble*5;t.x=m+y,t.y=g+v,p>.8&&(t.opacity=h.originalOpacity*(1-5*(p-.8)))},cleanup(t){if(t.gestureData?.swarm){const e=t.gestureData.swarm;t.x=e.originalX,t.y=e.originalY,t.opacity=e.originalOpacity,delete t.gestureData.swarm}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.direction||"up",a=i.clusterPhase||.3,[r,o]={up:[0,1],down:[0,-1],left:[-1,0],right:[1,0]}[s]||[0,1];let l=0,h=0,c=1;if(t<a)c=1-t/a*.1*n;else{const e=(t-a)/(1-a),i=1-Math.pow(1-e,2);l=r*i*.25*n,h=o*i*.25*n,c=.9+.1*e}const u=t>a?.1:0,d=t>.85?(1-t)/.15:1;return{cameraRelativePosition:[(l+.02*Math.sin(t*Math.PI*6)*n)*d,h*d,0],rotation:[o*u*n,0,-r*u*n],scale:c,glowIntensity:1+(t>a?.2:0)}}}}}var vv=yv("up"),bv=yv("down"),Mv=yv("left"),_v=yv("right"),xv={name:"burst",emoji:"",type:"blending",description:"Explosive outward burst from center",config:{decay:.5,strength:2},rhythm:{enabled:!0,syncMode:"beat",strengthSync:{onBeat:3.5,offBeat:1,curve:"explosion"},decaySync:{mode:"tempo",fast:.8,slow:.3,curve:"exponential"},durationSync:{mode:"beats",beats:.5,sustain:!1},accentResponse:{enabled:!0,multiplier:2.5,type:"strength"},patternOverrides:{rock:{strengthSync:{onBeat:4,offBeat:1.5},decaySync:{fast:.6,slow:.4}},electronic:{strengthSync:{onBeat:3.8,offBeat:.8,curve:"sharp"},decaySync:{fast:.9,slow:.7}},jazz:{strengthSync:{onBeat:2.8,offBeat:1.8,swing:!0},decaySync:{fast:.5,slow:.2}},orchestral:{strengthSync:{onBeat:3.2,offBeat:.5},accentResponse:{multiplier:3}}},dynamics:{forte:{strengthSync:{onBeat:{multiplier:2},offBeat:{multiplier:1.5}},decaySync:{multiplier:.7},accentResponse:{multiplier:3.5}},piano:{strengthSync:{onBeat:{multiplier:.6},offBeat:{multiplier:.3}},decaySync:{multiplier:1.3},accentResponse:{multiplier:1.8}}}},apply(t,e,i,n,s,a){const r=i.decay||this.config.decay,o=(i.strength||this.config.strength)*(1-e*r),l=t.x-s,h=t.y-a,c=Math.sqrt(l*l+h*h);c>1&&(t.vx+=l/c*o*2*n,t.vy+=h/c*o*2*n)},"3d":{evaluate(t,e){const i=e.strength||2;let n=0,s=1,a=1,r=0;if(t<.15){const e=t/.15,o=1-Math.pow(1-e,3);n=.15*o*i,s=1+.2*o*i,a=1+.5*o,r=.4*o}else if(t<.35){const e=(t-.15)/.2;n=.15*(1-1.5*e)*i,s=1+.2*(1-e)*i-.1*Math.sin(e*Math.PI),a=1+.4*(1-e),r=.2*(1-e)}else{const e=(t-.35)/.65,r=Math.pow(1-e,2),o=Math.sin(e*Math.PI*2)*r;n=.03*o*i,s=1+.05*o,a=1+.15*Math.abs(o)}return{cameraRelativePosition:[0,0,n],position:[0,0,0],rotation:[0,0,0],scale:s,glowIntensity:a,glowBoost:r}}}};function wv(t){const e=uf[t];if(!e)throw new Error(`Invalid burst direction: ${t}`);const i="up"===t||"down"===t;return{name:`burst${df(t)}`,emoji:"up"===t?"":"down"===t?"":"",type:"blending",description:`Explosive burst ${t}`,config:{duration:600,musicalDuration:{musical:!0,beats:1},decay:.5,strength:2,spread:.3,direction:t,particleMotion:{type:"burst",strength:2,direction:t}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",strengthSync:{onBeat:3.5,offBeat:1,curve:"explosion"},accentResponse:{enabled:!0,multiplier:2.5,type:"strength"}},apply(t,n,s,a,r,o){const l={...this.config,...s},h=l.decay||.5,c=(l.strength||2)*(1-n*h),u=l.spread||.3;let d=e.x*c*2,p=e.y*c*2;const m=(Math.random()-.5)*u*c;i?d+=m:p+=m,t.vx+=d*a,t.vy+=p*a},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||2,s=i.direction||"up";let a=0,r=0,o=0,l=1,h=1,c=0;const[u,d]={up:[0,1],down:[0,-1],left:[-1,0],right:[1,0]}[s]||[0,1];if(t<.15){const e=t/.15,i=1-Math.pow(1-e,3);a=u*i*.2*n,r=d*i*.2*n,o=.1*i*n,l=1+.15*i*n,h=1+.5*i,c=.4*i}else if(t<.35){const e=(t-.15)/.2,i=1-1.5*e;a=.2*u*i*n,r=.2*d*i*n,o=.1*i*n,l=1+.15*(1-e)*n,h=1+.4*(1-e),c=.2*(1-e)}else{const e=(t-.35)/.65,i=Math.pow(1-e,2),s=Math.sin(e*Math.PI*2)*i;a=u*s*.05*n,r=d*s*.05*n,l=1+.05*s,h=1+.15*Math.abs(s)}return{cameraRelativePosition:[a,r,o],position:[0,0,0],rotation:[0,0,0],scale:l,glowIntensity:h,glowBoost:c}}}}}var Sv=wv("up"),Tv=wv("down"),Cv=wv("left"),Ev=wv("right"),Av={name:"ripple",emoji:"",type:"effect",description:"Concentric waves emanating from center",config:{duration:1500,musicalDuration:{musical:!0,bars:1},waveCount:3,waveSpeed:1,amplitude:15,damping:.7,strength:1,particleMotion:{type:"ripple",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",amplitudeSync:{onBeat:1.5,offBeat:.8}},apply(t,e,i,n,s,a){const r={...this.config,...i},o=r.strength||1,l=r.waveCount||3,h=r.amplitude||15,c=r.damping||.7,u=t.x-s,d=t.y-a,p=Math.sqrt(u*u+d*d),m=(p/50-e*l*2)*Math.PI,g=Math.pow(1-e,c),f=Math.sin(m)*h*o*g;if(p>1){const e=.5*Math.cos(m)*o*g;t.x+=u/p*e,t.y+=d/p*e}t.opacity=Math.max(.3,1-.3*Math.abs(f/h))},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.waveCount||3,a=i.damping||.7,r=Math.pow(1-t,a),o=t*Math.PI*s*2,l=Math.sin(o),h=t*Math.PI*4,c=Math.sin(h)*n*r,u=.5*Math.sin(h+Math.PI/2)*n*r,d=.12,p=1-c*d+u*d*.3,m=1+c*d,g=1-c*d-u*d*.3,f=.08*(m-1);return{position:[.01*Math.sin(1.5*h)*r,f,0],rotation:[.04*l*n*r,0,.03*u*n*r],scale:[p,m,g],glowIntensity:1+.3*Math.abs(c),glowBoost:.25*Math.max(0,c)*r}}}},Pv={name:"wave",emoji:"",type:"override",description:"Infinity pattern flow with phasing",config:{musicalDuration:{musical:!0,bars:1,minBeats:4,maxBeats:16},phases:[{name:"gather",beats:.5},{name:"rise",beats:.5},{name:"waveLeft",beats:1},{name:"waveRight",beats:1},{name:"settle",beats:1}],amplitude:40,frequency:1,phaseShift:.3,liftHeight:20,fadeInOut:!0,smoothness:.1,easing:"sine",strength:1,particleMotion:{type:"wave",strength:1,amplitude:50}},rhythm:{enabled:!0,syncMode:"wave",amplitudeSync:{onWave:65,onStatic:25,curve:"flowing"},frequencySync:{mode:"phrase",slow:.7,fast:1.8,curve:"melodic"},durationSync:{mode:"bars",adaptToPhrase:!0,sustain:!0},phaseSync:{enabled:!0,multiplier:.5,type:"ensemble"},melodicResponse:{enabled:!0,multiplier:1.4,type:"amplitude"},patternOverrides:{ambient:{amplitudeSync:{onWave:80,onStatic:40,curve:"hypnotic"},frequencySync:{slow:.5,fast:1.2},durationSync:{minBeats:16,maxBeats:64}},ocean:{amplitudeSync:{onWave:90,onStatic:20,curve:"natural"},phaseSync:{multiplier:.8},melodicResponse:{multiplier:1.8}},electronic:{amplitudeSync:{onWave:70,onStatic:30,curve:"digital"},frequencySync:{slow:.8,fast:2.5,curve:"precise"}},orchestral:{amplitudeSync:{onWave:75,onStatic:35},phaseSync:{multiplier:.7},melodicResponse:{multiplier:2}}},dynamics:{forte:{amplitudeSync:{onWave:{multiplier:1.8},onStatic:{multiplier:1.4}},frequencySync:{multiplier:1.3},melodicResponse:{multiplier:2.2}},piano:{amplitudeSync:{onWave:{multiplier:.6},onStatic:{multiplier:.4}},frequencySync:{multiplier:.7},melodicResponse:{multiplier:1.1}}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-i,a=t.y-n,r=Math.atan2(a,s),o=Math.sqrt(s*s+a*a),l=Math.random()<.5?1:-1;t.gestureData.wave={startX:t.x,startY:t.y,originalVx:t.vx,originalVy:t.vy,baseOpacity:t.opacity||t.life||1,angle:r,radius:o,offset:Math.random()*Math.PI*2,role:Math.random(),direction:l,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.wave?.initialized||this.initialize(t,i,s,a);const r=t.gestureData.wave,o={...this.config,...i},l=i.strength||1,h=this.easeInOutSine(e),c=r.role*o.phaseShift,u=Math.max(0,h-c),d=u*Math.PI*2*o.frequency*r.direction+r.offset,p=.5+r.radius/100*.5,m=o.amplitude*p*l*t.scaleFactor,g=s+Math.sin(d)*m,f=a+Math.sin(2*d)*m*.3+-Math.abs(Math.sin(h*Math.PI))*o.liftHeight*t.scaleFactor,y=o.smoothness+.12*r.role;if(t.x+=(g-t.x)*y,t.y+=(f-t.y)*y,t.vx=.3*(g-t.x),t.vy=.3*(f-t.y),o.fadeInOut){let e;e=u<.1?u/.1:u>.9?(1-u)/.1:.5+.5*Math.sin(u*Math.PI),t.opacity=r.baseOpacity*(.3+.7*e),void 0!==t.life&&(t.life=t.opacity)}if(e>=.95){const i=20*(1-e);t.vx=t.vx*i+r.originalVx*(1-i),t.vy=t.vy*i+r.originalVy*(1-i),o.fadeInOut&&(t.opacity=r.baseOpacity*i,void 0!==t.life&&(t.life=t.opacity))}},cleanup(t){if(t.gestureData?.wave){const e=t.gestureData.wave;t.vx=e.originalVx,t.vy=e.originalVy,t.opacity=e.baseOpacity,void 0!==t.life&&(t.life=e.baseOpacity),delete t.gestureData.wave}},easeInOutSine:t=>-(Math.cos(Math.PI*t)-1)/2,"3d":{evaluate(t,e){const i=e?.strength||1,n=e?.frequency||1,s=-(Math.cos(Math.PI*t)-1)/2,a=s*Math.PI*2*n,r=.12*Math.sin(a)*i,o=.06*Math.sin(2*a)*i,l=.03*Math.sin(a)*i,h=.08*Math.sin(2*a)*i,c=.05*Math.sin(a)*i,u=1+.08*Math.abs(Math.sin(s*Math.PI))*i,d=Math.abs(Math.sin(a));return{position:[r,o,l],rotation:[h,0,c],scale:u,glowIntensity:1+.3*d*i,glowBoost:.6*d*i}}}},Dv={name:"flash",emoji:"",type:"blending",description:"Bright flash burst effect",config:{duration:400,glowAmount:2.5,glowPeak:3,scalePeak:1.1,easing:"cubic",strength:1,particleMotion:{type:"burst",strength:1,decay:.3}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"immediate",interruptible:!0,priority:8,blendable:!0,intensitySync:{onBeat:3.5,offBeat:1,accent:5,subdivision:"quarter",curve:"exponential"},durationSync:{mode:"tempo",baseDuration:400,scaling:"inverse"},scaleSync:{onBeat:1.2,offBeat:1,accent:1.4,curve:"elastic"},strobeSync:{enabled:!1,pattern:"XXOX",subdivision:"sixteenth"},dynamics:{forte:{glowPeak:4,scalePeak:1.3,duration:300},piano:{glowPeak:2,scalePeak:1.05,duration:500}}},initialize(t,e){t.gestureData||(t.gestureData={}),t.gestureData.flash={originalOpacity:t.opacity,originalSize:t.size,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.flash?.initialized||this.initialize(t,i);const r=t.gestureData.flash,o={...this.config,...i},l=o.strength||1;let h;if(h=e<.3?e/.3*o.glowPeak:o.glowPeak*(1-(e-.3)/.7),t.opacity=Math.min(1,r.originalOpacity*(1+h*l)),t.size=r.originalSize*(1+(o.scalePeak-1)*h*l*.1),e<.2){const i=(1-e/.2)*l,r=Math.atan2(t.y-a,t.x-s);t.vx+=Math.cos(r)*i*2*n,t.vy+=Math.sin(r)*i*2*n}t.vx*=1-.1*o.particleMotion.decay,t.vy*=1-.1*o.particleMotion.decay},cleanup(t){t.gestureData?.flash&&(t.opacity=t.gestureData.flash.originalOpacity,t.size=t.gestureData.flash.originalSize,delete t.gestureData.flash)},"3d":{evaluate(t,e){const i={...this.config,...e};let n;e.strength,n=t<.3?t/.3:1-(t-.3)/.7;const s=1+.4*n;return{position:[0,0,0],rotation:[0,0,0],scale:1+n*((i.scalePeak||1.1)-1),glowIntensity:s,glowBoost:2*n}}}},Rv={name:"glow",emoji:"",type:"blending",description:"Pure luminous glow without movement",config:{duration:1500,amplitude:0,frequency:1,holdPeak:.3,easing:"sine",scaleAmount:.1,glowAmount:.8,strength:0,direction:"none",particleMotion:{type:"glow",strength:0,direction:"none",frequency:1}},rhythm:{enabled:!0,syncMode:"phrase",amplitudeSync:{onBeat:2,offBeat:1.2,curve:"smooth"},frequencySync:{mode:"phrase",subdivision:"bar"},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:2.5},patternOverrides:{ambient:{amplitudeSync:{onBeat:2.5,offBeat:1.8},durationSync:{bars:4}},electronic:{amplitudeSync:{onBeat:3,offBeat:.5,curve:"sharp"},frequencySync:{subdivision:"quarter"}}}},initialize(t,e,i,n){t.gestureData||(t.gestureData={}),t.gestureData.glow={startOpacity:t.opacity,startGlow:t.glowSizeMultiplier||0,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.glow?.initialized||this.initialize(t,i,s,a);const r={...this.config,...i},o=this.easeInOutSine(e);let l,{frequency:h}=r,{glowAmount:c}=r;i.rhythmModulation&&(c*=i.rhythmModulation.amplitudeMultiplier||1,c*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(h*=i.rhythmModulation.frequencyMultiplier));const u=o*h*2%2;l=r.holdPeak>0&&u>1-r.holdPeak&&u<1+r.holdPeak?1:Math.sin(o*Math.PI*2*h);let d=1;e>.9&&(d=.5+.5*(1-10*(e-.9))),t.glowIntensity=1+l*c*d},cleanup(t){t.gestureData?.glow&&(t.glowIntensity=1,delete t.gestureData.glow)},easeInOutSine:t=>-(Math.cos(Math.PI*t)-1)/2,"3d":{evaluate(t,e){const i={...this.config,...e},n=-(Math.cos(Math.PI*t)-1)/2,s=Math.sin(n*Math.PI);let a=i.glowAmount||.8;e.rhythmModulation&&(a*=e.rhythmModulation.amplitudeMultiplier||1,a*=e.rhythmModulation.accentMultiplier||1);const r=1+s*a;return{position:[0,0,0],rotation:[0,0,0],scale:1+s*(i.scaleAmount||.1)*.5,glowIntensity:r,glowBoost:1.5*s}}}},Iv={name:"bloom",emoji:"",type:"effect",description:"Particles unfold outward like flower petals opening",config:{duration:1500,musicalDuration:{musical:!0,bars:1},petalCount:6,openingSpeed:1,rotationAmount:.3,strength:1,particleMotion:{type:"bloom",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",amplitudeSync:{onBeat:1.3,offBeat:.8}},initialize(t,e,i,n){t.gestureData||(t.gestureData={});const s=t.x-(i||0),a=t.y-(n||0);t.gestureData.bloom={originalX:t.x,originalY:t.y,originalOpacity:t.opacity??1,startAngle:Math.atan2(a,s),startDistance:Math.sqrt(s*s+a*a),initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.bloom?.initialized||this.initialize(t,i,s,a);const r={...this.config,...i},o=r.strength||1,l=t.gestureData.bloom,h=Math.pow(e,.7),c=(r.rotationAmount||.3)*Math.PI,u=Math.sin(h*Math.PI)*c,d=1+.5*h*o,p=l.startDistance*d,m=l.startAngle+u;t.x=s+Math.cos(m)*p,t.y=a+Math.sin(m)*p,t.opacity=Math.min(1,l.originalOpacity*(.7+.3*h))},cleanup(t){if(t.gestureData?.bloom){const e=t.gestureData.bloom;t.x=e.originalX,t.y=e.originalY,t.opacity=e.originalOpacity,delete t.gestureData.bloom}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.rotationAmount||.3,a=Math.pow(t,.7),r=1+.2*a*n,o=Math.sin(a*Math.PI)*s*n,l=.1*Math.sin(a*Math.PI*.5)*n,h=t>.85?1-(t-.85)/.15*.3:1;return{position:[0,.05*Math.sin(a*Math.PI)*n*h,0],rotation:[0,o*h,l*h],scale:r*(.7+.3*h),glowIntensity:1+.4*a,glowBoost:.3*a}}}},Bv={name:"flicker",emoji:"",type:"blending",description:"Rapid opacity changes with motion jitter",config:{duration:800,musicalDuration:{musical:!0,beats:2},flickerRate:15,frequency:6,minOpacity:.3,maxOpacity:1,jitterAmount:2,colorShift:!1,strobe:!1,pulseMode:!1,groupFlicker:.3,easing:"linear",strength:.7,particleMotion:{type:"flicker",strength:.7,frequency:6}},rhythm:{enabled:!0,syncMode:"subdivision",durationSync:{mode:"beats",beats:2},rateSync:{subdivision:"sixteenth",onBeat:30,offBeat:10,triplet:20,curve:"step"},opacitySync:{pattern:"HLMH",subdivision:"eighth",onAccent:.1,regular:.5},jitterSync:{onBeat:5,offBeat:1,accent:10,curve:"random"},strobeSync:{verse:!1,chorus:!0,drop:"intense",pattern:"XOXO"},dynamics:{forte:{flickerRate:25,jitterAmount:5,minOpacity:.1},piano:{flickerRate:8,jitterAmount:1,minOpacity:.5}}},initialize(t,e){t.gestureData||(t.gestureData={});const i={...this.config,...e},n=Math.random()<i.groupFlicker;t.gestureData.flicker={baseOpacity:t.opacity||t.life||1,baseColor:t.color,baseX:t.x,baseY:t.y,flickerTimer:0,lastFlicker:0,flickerState:!0,isGrouped:n,groupId:n?Math.floor(3*Math.random()):-1,phase:Math.random()*Math.PI*2,colorHue:0,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.flicker?.initialized||this.initialize(t,i);const r=t.gestureData.flicker,o={...this.config,...i},l=i.strength||1;let h;if(r.flickerTimer+=n*o.flickerRate,o.strobe)h=(r.flickerTimer+r.phase)%1<.5?1:o.minOpacity;else if(o.pulseMode){const t=r.flickerTimer+r.phase;h=o.minOpacity+(o.maxOpacity-o.minOpacity)*(.5*Math.sin(t)+.5)}else{if(r.flickerTimer-r.lastFlicker>1)if(r.lastFlicker=r.flickerTimer,r.isGrouped){const t=Math.floor(r.flickerTimer)%3;r.flickerState=t===r.groupId}else r.flickerState=Math.random()>.3;const e=r.flickerState?o.maxOpacity:o.minOpacity+.3*Math.random(),i=t.opacity/r.baseOpacity;h=i+.3*(e-i)}const c=r.baseOpacity*(1+(h-1)*l);if(t.opacity=Math.max(0,Math.min(1,c)),void 0!==t.life&&(t.life=t.opacity),o.jitterAmount>0&&h>o.minOpacity){const e=o.jitterAmount*l*t.scaleFactor,i=(Math.random()-.5)*e*h,s=(Math.random()-.5)*e*h;t.vx+=.1*i*n,t.vy+=.1*s*n}if(o.colorShift&&t.color){r.colorHue+=.01*n;const e=30*Math.sin(r.colorHue);t.color=this.shiftHue(r.baseColor,e*l)}let u=1;e<.1?u=e/.1:e>.9&&(u=(1-e)/.1),t.opacity*=u,void 0!==t.life&&(t.life=t.opacity),e>.8&&(t.vx*=.95,t.vy*=.95)},shiftHue(t,e){if(!t||!t.startsWith("#"))return t;const i=t.slice(1),n=parseInt(i.substr(0,2),16)/255,s=parseInt(i.substr(2,2),16)/255,a=parseInt(i.substr(4,2),16)/255,r=e*Math.PI/180,o=Math.cos(r),l=Math.sin(r),h=n*l+s*o,c=a,u=t=>Math.max(0,Math.min(255,Math.round(255*t))).toString(16).padStart(2,"0");return`#${u(n*o-s*l)}${u(h)}${u(c)}`},cleanup(t){if(t.gestureData?.flicker){const e=t.gestureData.flicker;t.opacity=e.baseOpacity,t.color=e.baseColor,void 0!==t.life&&(t.life=e.baseOpacity),delete t.gestureData.flicker}},"3d":{evaluate(t,e){const i=e.config||{},n=e.strength||.7,s=i.flickerRate||15;i.minOpacity;const a=t*s,r=Math.sin(a*Math.PI*2),o=Math.floor(10*a),l=.3*r+.5*(Math.sin(123.456*o)+1)*.7,h=.6+.8*l,c=i.jitterAmount||2,u=.003*n*h,d=(Math.random()-.5)*c*u,p=(Math.random()-.5)*c*u,m=.03*(Math.random()-.5)*n*h;return{position:[d,p,0],rotation:[.5*m,0,m],scale:1+.08*(h-1),glowIntensity:h,glowBoost:1.2*l}}}},Lv={name:"shiver",emoji:"",type:"effect",description:"High-frequency micro-vibrations for nervousness or cold",config:{duration:1500,musicalDuration:{musical:!0,bars:1},frequency:30,amplitude:.02,decay:.3,strength:1,particleMotion:{type:"shiver",strength:.8}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:1},intensitySync:{quiet:.5,loud:1.5,crescendo:"increase",diminuendo:"decrease"}},apply(t,e,i,n,s,a){const r={...this.config,...i},o=r.strength||1,l=r.frequency||30,h=100*(r.amplitude||.02),c=e*l*Math.PI*2,u=(.6*Math.sin(c)+.3*Math.sin(1.7*c+1.3)+.1*Math.sin(2.3*c+2.7))*h*o,d=Math.sin(e*Math.PI);t.x+=u*d*(Math.random()-.5)*2,t.y+=u*d*(Math.random()-.5)*2},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.frequency||30,a=i.amplitude||.02,r=Math.sin(t*Math.PI),o=t*s*Math.PI*2,l=.6*Math.sin(o)+.3*Math.sin(1.7*o)+.1*Math.sin(2.3*o),h=.5*Math.cos(1.1*o)+.3*Math.cos(1.9*o)+.2*Math.cos(2.7*o);return{position:[l*a*n*r,h*a*n*r,(.4*Math.sin(.9*o+1)+.4*Math.sin(1.5*o+2))*a*.5*n*r],rotation:[.02*h*n*r,0,.02*l*n*r],scale:1+.01*Math.abs(l)*n*r,glowIntensity:1+.1*Math.abs(l)*r}}}},kv={name:"heartbeat",emoji:"",type:"effect",description:"Rhythmic double-pump heartbeat (lub-dub)",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},lubStrength:.8,dubStrength:1,lubDubGap:.15,strength:1,particleMotion:{type:"heartbeat",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",amplitudeSync:{onBeat:1.2,offBeat:.8}},apply(t,e,i,n,s,a){const r={...this.config,...i},o=r.strength||1,l=this._calculatePulse(e,r),h=t.x-s,c=t.y-a,u=Math.sqrt(h*h+c*c)||1,d=10*l*o;t.x+=h/u*d,t.y+=c/u*d},_calculatePulse(t,e){const i=e.lubDubGap||.15,n=e.lubStrength||.8,s=e.dubStrength||1;let a=0;const r=Math.abs(t-.1);r<.08&&(a=Math.cos(r/.08*Math.PI*.5)*n);const o=.1+i+.05,l=Math.abs(t-o);if(l<.1){const t=Math.cos(l/.1*Math.PI*.5)*s;a=Math.max(a,t)}return a},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.lubDubGap||.15,a=i.lubStrength||.8,r=i.dubStrength||1;let o=0;const l=Math.abs(t-.1);l<.08&&(o=Math.cos(l/.08*Math.PI*.5)*a);const h=.1+s+.05,c=Math.abs(t-h);if(c<.1){const t=Math.cos(c/.1*Math.PI*.5)*r;o=Math.max(o,t)}return{position:[0,0,.03*o*n],rotation:[0,0,0],scale:1+.15*o*n,glowIntensity:1+.5*o*n,glowBoost:.8*o*n}}}},Ov={name:"snap",emoji:"",type:"effect",description:"Quick elastic snap with overshoot and settle",config:{duration:500,musicalDuration:{musical:!0,beats:1},snapDistance:.1,overshoot:1.3,bounces:2,strength:1,particleMotion:{type:"snap",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},apply(t,e,i,n,s,a){const r={...this.config,...i},o=r.strength||1,l=100*(r.snapDistance||.1),h=r.overshoot||1.3,c=this._calculateSnap(e,h,r.bounces||2),u=s-t.x,d=a-t.y,p=Math.sqrt(u*u+d*d)||1;t.x+=u/p*c*l*o*.1,t.y+=d/p*c*l*o*.1},_calculateSnap(t,e,i){if(t<.2){const i=t/.2;return(1-Math.pow(1-i,3))*e}{const n=(t-.2)/.8,s=Math.exp(4*-n);return 1+(e-1)*Math.cos(n*Math.PI*i*2)*s}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.snapDistance||.1,a=i.overshoot||1.3,r=i.bounces||2;let o;if(t<.2){const e=t/.2;o=(1-Math.pow(1-e,3))*a}else{const e=(t-.2)/.8,i=Math.exp(4*-e);o=1+(a-1)*Math.cos(e*Math.PI*r*2)*i}return{position:[0,0,(o-1)*s*n],rotation:[0,0,.1*(o-1)*n],scale:1+.15*(o-1),glowIntensity:1+.5*Math.abs(o-1),glowBoost:t<.3?(.3-t)/.3*.4:0}}}},zv={name:"elasticBounce",emoji:"",type:"effect",description:"Drop and bounce with elastic oscillation",config:{duration:1200,musicalDuration:{musical:!0,beats:3},dropHeight:.15,bounceCount:3,elasticity:.6,strength:1,particleMotion:{type:"elasticBounce",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",amplitudeSync:{onBeat:1.3,offBeat:.8}},apply(t,e,i,n,s,a){const r={...this.config,...i},o=r.strength||1,l=200*(r.dropHeight||.15),h=r.bounceCount||3,c=r.elasticity||.6,u=this._calculateBounce(e,l,h,c);t.y+=u*o;const d=.3*Math.max(0,-u/l);t.scaleY=1-d*o,t.scaleX=1+.5*d*o},_calculateBounce(t,e,i,n){let s=e,a=0,r=0,o=.3;for(;r<i&&a<1;){const e=o*Math.pow(n,.5*r);if(t<a+e){const i=(t-a)/e;return 4*i*(1-i)*-s}a+=e,s*=n,r++,o*=n}return 0},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.dropHeight||.15,a=i.bounceCount||3,r=i.elasticity||.6;let o=s,l=0,h=0,c=.3,u=0,d=!1;for(;h<a&&l<1;){const e=c*Math.pow(r,.5*h);if(t<l+e){const i=(t-l)/e;u=o*(4*i*(1-i))*n,d=i>.45&&i<.55;break}l+=e,o*=r,h++,c*=r}let p=1,m=1;if(d){const t=.15*n*Math.pow(r,h);p=1+t,m=1-t}return{position:[0,u,0],rotation:[0,0,0],scale:(p+m)/2,glowIntensity:1+(d?.3:0)}}}},Fv={name:"hold",emoji:"",type:"override",description:"Hold particles in current position",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},holdStrength:.95,allowDrift:!1,strength:1},rhythm:{enabled:!0,syncMode:"rest",holdSync:{onRest:.98,onSound:.8,curve:"immediate"},durationSync:{mode:"rests",minBeats:.5,maxBeats:8,sustain:!0},pauseResponse:{enabled:!0,multiplier:1.5,type:"strength"},patternOverrides:{classical:{holdSync:{onRest:.99,onSound:.75,curve:"dramatic"},pauseResponse:{multiplier:2}},minimal:{holdSync:{onRest:.95,onSound:.85},durationSync:{minBeats:2,maxBeats:16}},jazz:{holdSync:{onRest:.9,onSound:.7},allowDrift:!0},electronic:{holdSync:{onRest:.99,onSound:.6,curve:"digital"},pauseResponse:{multiplier:1.2}}},dynamics:{forte:{holdSync:{onRest:{multiplier:1.02},onSound:{multiplier:.9}},pauseResponse:{multiplier:2.2}},piano:{holdSync:{onRest:{multiplier:.97},onSound:{multiplier:.85}},pauseResponse:{multiplier:1.3}}}},initialize(t){t.gestureData||(t.gestureData={}),t.gestureData.hold={holdX:t.x,holdY:t.y,originalVx:t.vx,originalVy:t.vy}},apply(t,e,i,n,s,a){t.gestureData?.hold||this.initialize(t);const r=t.gestureData.hold,o=i.holdStrength||this.config.holdStrength;if(i.allowDrift?(t.vx*=o,t.vy*=o):(t.x+=(r.holdX-t.x)*(1-o),t.y+=(r.holdY-t.y)*(1-o),t.vx=0,t.vy=0),e>.9){const i=10*(e-.9);t.vx=t.vx*(1-i)+r.originalVx*i,t.vy=t.vy*(1-i)+r.originalVy*i}},cleanup(t){if(t.gestureData?.hold){const e=t.gestureData.hold;t.vx=e.originalVx,t.vy=e.originalVy,delete t.gestureData.hold}},"3d":{evaluate(t,e){let i=0,n=1;if(t<.15){const e=t/.15;i=e*e*(3-2*e),n=1-.2*i}else if(t<.85)i=1,n=.8;else{const e=(t-.85)/.15;i=1-e*e*(3-2*e),n=.8+.2*e}return i*=(e.config||this.config||{}).strength||1,{position:[0,0,0],rotation:[0,0,0],scale:1,glowIntensity:n,freezeRotation:i,freezeWobble:i,freezeGroove:i,freezeParticles:i}}}},Uv={name:"fade",emoji:"",type:"blending",description:"Fade particle opacity",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},fadeIn:!0,fadeOut:!0,minOpacity:0,maxOpacity:1},rhythm:{enabled:!0,syncMode:"dynamic",durationSync:{mode:"bars",bars:1},opacitySync:{onBeat:.9,offBeat:.3,subdivision:"eighth",curve:"exponential"},fadePhaseSync:{verse:{fadeIn:!0,fadeOut:!1},chorus:{fadeIn:!1,fadeOut:!1},bridge:{fadeIn:!0,fadeOut:!0},outro:{fadeIn:!1,fadeOut:!0}},pulseSync:{enabled:!0,frequency:"quarter",intensity:.2,onAccent:.4},dynamics:{forte:{minOpacity:.5,maxOpacity:1},piano:{minOpacity:0,maxOpacity:.4}}},initialize(t){t.gestureData||(t.gestureData={}),t.gestureData.fade={baseOpacity:t.opacity||t.life||1}},apply(t,e,i,n,s,a){t.gestureData?.fade||this.initialize(t);const r=t.gestureData.fade,o={...this.config,...i};let l;l=o.fadeIn&&!o.fadeOut?o.minOpacity+(o.maxOpacity-o.minOpacity)*e:o.fadeOut&&!o.fadeIn?o.maxOpacity-(o.maxOpacity-o.minOpacity)*e:e<.5?o.minOpacity+(o.maxOpacity-o.minOpacity)*(2*e):o.maxOpacity-(o.maxOpacity-o.minOpacity)*(2*(e-.5)),t.opacity=r.baseOpacity*l,void 0!==t.life&&(t.life=t.opacity)},cleanup(t){t.gestureData?.fade&&(t.opacity=t.gestureData.fade.baseOpacity,void 0!==t.life&&(t.life=t.opacity),delete t.gestureData.fade)},"3d":{evaluate(t,e){const i={...this?.config||{},...e},n=i.fadeIn??!0,s=i.fadeOut??!0;let a;a=n&&!s?t:s&&!n?1-t:t<.5?1-t/.5:(t-.5)/.5;const r=a*a*(3-2*a);return{position:[0,0,0],rotation:[0,0,0],scale:.01+.99*r,glowIntensity:r,glowBoost:0}}}},Nv={name:"settle",emoji:"",type:"blending",description:"Gradually settle particles to rest",config:{damping:.02,threshold:.01},rhythm:{enabled:!0,syncMode:"resolution",dampingSync:{onResolution:.035,onTension:.015,curve:"gradual"},thresholdSync:{mode:"dynamics",forte:.02,piano:.005,curve:"exponential"},durationSync:{mode:"phrase",minBeats:2,maxBeats:12,sustain:!0},cadenceResponse:{enabled:!0,multiplier:1.6,type:"damping"},patternOverrides:{ambient:{dampingSync:{onResolution:.025,onTension:.008,curve:"atmospheric"},durationSync:{minBeats:8,maxBeats:32}},jazz:{dampingSync:{onResolution:.04,onTension:.02},cadenceResponse:{multiplier:1.8}},classical:{dampingSync:{onResolution:.045,onTension:.012,curve:"expressive"},cadenceResponse:{multiplier:2}},minimalist:{dampingSync:{onResolution:.02,onTension:.005},durationSync:{minBeats:16,maxBeats:64}}},dynamics:{forte:{dampingSync:{onResolution:{multiplier:1.4},onTension:{multiplier:.8}},thresholdSync:{multiplier:2},cadenceResponse:{multiplier:2.2}},piano:{dampingSync:{onResolution:{multiplier:.7},onTension:{multiplier:1.2}},thresholdSync:{multiplier:.5},cadenceResponse:{multiplier:1.3}}}},apply(t,e,i,n,s,a){const r=i.damping||this.config.damping,o=i.threshold||this.config.threshold;t.vx*=Math.max(0,1-r*n*60),t.vy*=Math.max(0,1-r*n*60),Math.abs(t.vx)<o&&(t.vx=0),Math.abs(t.vy)<o&&(t.vy=0)},"3d":{evaluate(t,e){const i=1-Math.pow(1-t,2),n=.01*(1-i);return{position:[Math.sin(t*Math.PI*2)*n,Math.cos(t*Math.PI*3)*n*.5,0],rotation:[0,0,0],scale:1-.03*i,glowIntensity:1-.15*i}}}},Gv={name:"peek",emoji:"",type:"effect",description:"Quick peek and hide motion",config:{peekDistance:40,peekSpeed:.15,holdDuration:200,hideSpeed:.25,stagger:!0,duration:1500},rhythm:{enabled:!0,syncMode:"accent",distanceSync:{onAccent:60,offAccent:25,curve:"quick"},speedSync:{mode:"tempo",fast:.25,slow:.1,hideMultiplier:1.8},durationSync:{mode:"subdivision",beats:.25,staggerBeats:.125,sustain:!1},syncopationResponse:{enabled:!0,multiplier:1.8,type:"distance"},patternOverrides:{funk:{distanceSync:{onAccent:70,offAccent:35,curve:"funky"},syncopationResponse:{multiplier:2.2}},latin:{speedSync:{fast:.3,slow:.12},durationSync:{beats:.5,staggerBeats:.25}},breakbeat:{distanceSync:{onAccent:55,offAccent:40},syncopationResponse:{multiplier:2.5}},classical:{distanceSync:{onAccent:45,offAccent:20,curve:"elegant"},speedSync:{fast:.18,slow:.08}}},dynamics:{forte:{distanceSync:{onAccent:{multiplier:1.6},offAccent:{multiplier:1.3}},speedSync:{multiplier:1.4},syncopationResponse:{multiplier:2.8}},piano:{distanceSync:{onAccent:{multiplier:.6},offAccent:{multiplier:.4}},speedSync:{multiplier:.7},syncopationResponse:{multiplier:1.2}}}},apply(t,e,i,n,s,a){if(t.gestureData||(t.gestureData={}),!t.gestureData.peek){const e=t.x-s,i=t.y-a,n=Math.atan2(i,e),r=Math.sqrt(e*e+i*i);t.gestureData.peek={originalX:t.x,originalY:t.y,peekAngle:n,originalDistance:r,staggerDelay:this.config.stagger?.3*Math.random():0,phase:"waiting",phaseTimer:0,peekOffset:{x:0,y:0}}}const r=t.gestureData.peek,{config:o}=this,l=Math.max(0,Math.min(1,(e-r.staggerDelay)/(1-r.staggerDelay)));0===l?r.phase="waiting":l<.3?r.phase="peeking":l<.6?r.phase="holding":l<1&&(r.phase="hiding");let h=0;switch(r.phase){case"peeking":{const t=l/.3;h=this.easeOutCubic(t)*o.peekDistance;break}case"holding":h=o.peekDistance,Math.random()<.1&&(r.peekOffset.x+=2*(Math.random()-.5),r.peekOffset.y+=2*(Math.random()-.5));break;case"hiding":{const t=(l-.6)/.4;h=(1-this.easeInCubic(t))*o.peekDistance;break}}if("waiting"!==r.phase){const e=Math.cos(r.peekAngle)*h,i=Math.sin(r.peekAngle)*h;r.peekOffset.x+=(e-r.peekOffset.x)*o.peekSpeed,r.peekOffset.y+=(i-r.peekOffset.y)*o.peekSpeed,t.x=r.originalX+r.peekOffset.x,t.y=r.originalY+r.peekOffset.y}void 0!==t.alpha&&("peeking"===r.phase||"holding"===r.phase?t.alpha=.7+.3*Math.random():t.alpha=1)},easeOutCubic:t=>1-Math.pow(1-t,3),easeInCubic:t=>t*t*t,cleanup(t){t.gestureData?.peek&&(t.x=t.gestureData.peek.originalX,t.y=t.gestureData.peek.originalY,void 0!==t.alpha&&(t.alpha=1),delete t.gestureData.peek)},"3d":{evaluate(t,e){const i=.01*({...this.config,...e}.peekDistance||40);let n=0,s=1;if(t<.3){const e=t/.3;n=(1-Math.pow(1-e,3))*i}else if(t<.6)n=i,s=.7+.3*Math.random();else{const e=(t-.6)/.4;n=(1-Math.pow(e,3))*i}return{position:[n,0,0],rotation:[0,0,0],scale:1,glowIntensity:s}}}},Vv={name:"directional",emoji:"",type:"blending",description:"Move particles in a specific direction",config:{angle:0,returnToOrigin:!1,strength:1},rhythm:{enabled:!0,syncMode:"flow",angleSync:{verse:0,chorus:90,bridge:180,outro:270,transition:"smooth"},strengthSync:{onBeat:1.8,offBeat:.6,curve:"wave"},returnSync:{enabled:!0,onSectionChange:!0,duration:"transition",strength:1.2},accentResponse:{enabled:!0,multiplier:2,type:"strength"},patternOverrides:{march:{angleSync:{verse:0,chorus:0},strengthSync:{onBeat:2.5,offBeat:1}},waltz:{angleSync:{verse:45,chorus:135,bridge:225,outro:315,transition:"circular"}},swing:{strengthSync:{onBeat:1.6,offBeat:1.4,swing:!0}},electronic:{angleSync:{transition:"instant"},strengthSync:{onBeat:2.2,offBeat:.4,curve:"sharp"}}},dynamics:{forte:{strengthSync:{onBeat:{multiplier:1.6},offBeat:{multiplier:1.2}},angleSync:{transition:"sharp"},accentResponse:{multiplier:2.5}},piano:{strengthSync:{onBeat:{multiplier:.7},offBeat:{multiplier:.8}},angleSync:{transition:"gradual"},accentResponse:{multiplier:1.4}}}},initialize(t){t.gestureData||(t.gestureData={}),t.gestureData.directional={initialX:t.x,initialY:t.y}},apply(t,e,i,n,s,a){t.gestureData?.directional||this.initialize(t);const r=(i.angle||this.config.angle)*Math.PI/180,o=i.strength||this.config.strength;if(t.vx+=Math.cos(r)*o*.3*n,t.vy+=Math.sin(r)*o*.3*n,i.returnToOrigin&&e>.5){const i=2*(e-.5),s=t.gestureData.directional,a=s.initialX-t.x,r=s.initialY-t.y;t.vx+=a*i*.02*n,t.vy+=r*i*.02*n}},"3d":{evaluate(t,e){const i={...this.config,...e},n=(i.angle||0)*Math.PI/180,s=e.strength||1,a=i.returnToOrigin?t<.5?2*t:2*(1-t):t;return{position:[Math.cos(n)*a*.4*s,Math.sin(n)*a*.4*s,0],rotation:[0,0,0],scale:1,glowIntensity:1}}}};function Hv(t){if(!["forward","back","left","right","up","down","attract","repel"].includes(t))throw new Error(`Invalid magnetic direction: ${t}`);return{name:`magnetic${df(t)}`,emoji:{forward:"",back:"",left:"",right:"",up:"",down:"",attract:"",repel:""}[t],type:"effect",description:{forward:"Magnetic pull toward camera",back:"Magnetic push away from camera",left:"Magnetic pull leftward",right:"Magnetic pull rightward",up:"Magnetic pull upward",down:"Magnetic pull downward",attract:"Magnetic attraction to center",repel:"Magnetic repulsion from center"}[t],config:{duration:1200,musicalDuration:{musical:!0,beats:3},direction:t,pullStrength:1,returnToOrigin:!0,strength:1,particleMotion:{type:"magnetic",strength:1,direction:t}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",strengthSync:{onBeat:1.5,offBeat:.7}},initialize(t,e,i,n){t.gestureData||(t.gestureData={}),t.gestureData.magnetic={originalX:t.x,originalY:t.y,originalOpacity:t.opacity??1,initialized:!0}},apply(t,e,i,n,s,a){t.gestureData?.magnetic?.initialized||this.initialize(t,i,s,a);const r={...this.config,...i},o=r.strength||1,l=r.pullStrength||1,h=!1!==r.returnToOrigin,c=t.gestureData.magnetic,u=r.direction||"attract";let d,p,m;switch(d=h?Math.sin(e*Math.PI):Math.min(1,2*e),u){case"left":p=c.originalX-100,m=c.originalY;break;case"right":p=c.originalX+100,m=c.originalY;break;case"up":p=c.originalX,m=c.originalY-100;break;case"down":p=c.originalX,m=c.originalY+100;break;case"repel":{const t=c.originalX-s,e=c.originalY-a,i=Math.sqrt(t*t+e*e)||1;p=c.originalX+t/i*100,m=c.originalY+e/i*100;break}default:p=s,m=a}const g=(p-c.originalX)*d*l*o*.5,f=(m-c.originalY)*d*l*o*.5;t.x=c.originalX+g,t.y=c.originalY+f},cleanup(t){if(t.gestureData?.magnetic){const e=t.gestureData.magnetic;t.x=e.originalX,t.y=e.originalY,t.opacity=e.originalOpacity,delete t.gestureData.magnetic}},"3d":{evaluate(t,e){const i=e.config||this.config||{},n=i.strength||1,s=i.direction||"attract";let a;a=!1!==i.returnToOrigin?Math.sin(t*Math.PI):Math.min(1,2*t);let r=0,o=0,l=0,h=1;const c=.15*a*n;switch(s){case"forward":l=c,h=1+.1*a*n;break;case"back":l=-c,h=1-.08*a*n;break;case"left":r=-c;break;case"right":r=c;break;case"up":o=c;break;case"down":o=-c;break;case"attract":l=c,h=1-.1*a*n;break;case"repel":l=-c,h=1+.1*a*n}const u=1+.4*a,d=.3*a;return{cameraRelativePosition:[r+(a>.5?.01*Math.sin(t*Math.PI*20)*(a-.5)*2:0),o,l],rotation:[0,0,0],scale:h,glowIntensity:u,glowBoost:d}}}}}const Wv=sy("forward"),jv=sy("back"),Xv=sy("left"),qv=sy("right"),Yv=sy("up"),$v=sy("down"),Zv=Ly("back"),Jv=Ly("forward"),Qv=Ly("left"),Kv=Ly("right"),tb=Ly("up"),eb=Ly("down"),ib=Iy("left"),nb=Iy("right"),sb=Iy("front"),ab=Iy("back"),rb=Iy("up"),ob=Iy("down"),lb=Qy("default"),hb=Qy("explosive"),cb=Qy("crumble"),ub=Qy("reform"),db=Qy("punchLeft"),pb=Qy("punchRight"),mb=Qy("punchFront"),gb=Qy("suspend"),fb=Qy("freeze"),yb=Qy("implode"),vb=Qy("gravity"),bb=Qy("orbit"),Mb=tv("up"),_b=tv("down"),xb=tv("left"),wb=tv("right"),Sb=tv("away"),Tb=tv("toward"),Cb=iy("forward"),Eb=iy("back"),Ab=iy("left"),Pb=iy("right"),Db=iy("up"),Rb=iy("down"),Ib=Hv("forward"),Bb=Hv("back"),Lb=Hv("left"),kb=Hv("right"),Ob=Hv("up"),zb=Hv("down"),Fb=Hv("attract"),Ub=Hv("repel"),Nb=[Wf,lf,Tf,xy,Sf,wf,hf,cf,xf,{name:"sparkle",emoji:"",type:"blending",description:"Bright twinkling sparkle bursts",config:{duration:800,musicalDuration:{musical:!0,beats:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:2},interruptible:!0,priority:5,blendable:!0},apply:(t,e,i)=>!1,blend:(t,e,i)=>!1,"3d":{evaluate(t,e){const i=e?.strength||1,n=Math.pow(Math.max(0,Math.sin(t*Math.PI*6)),3),s=Math.pow(Math.max(0,Math.sin(t*Math.PI*8+1)),3),a=Math.pow(Math.max(0,Math.sin(t*Math.PI*10+2)),3),r=Math.max(n,s,a)*Math.sin(t*Math.PI);return{position:[0,0,0],rotation:[0,0,0],scale:1+.08*r*i,glowIntensity:1+.5*r*i,glowBoost:2*r*i}}}},{name:"shimmer",emoji:"",type:"particle",description:"Shimmer effect with sparkling particles",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},particleMotion:"radiant"},rhythm:{enabled:!0,syncType:"beat",durationSync:{mode:"bars",bars:1},intensity:.8},override:(t,e,i)=>(t.shimmerEffect=!0,t.shimmerProgress=e,!0),blend:(t,e,i)=>!1,"3d":{evaluate(t,e){const i=e?.strength||1,n=(.4*Math.sin(t*Math.PI*4)+.35*Math.sin(t*Math.PI*6+.5)+.25*Math.sin(t*Math.PI*10+1)+1)/2;return{position:[0,0,0],rotation:[0,0,0],scale:1+.05*n*i,glowIntensity:1+.3*n*i,glowBoost:1*n*i}}}},Cf,((t,e="")=>({name:t,emoji:e,type:"blending",description:`${t} animation`,config:{duration:1e3,musicalDuration:{musical:!0,beats:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:2},interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",maxQueue:3},apply:(t,e,i)=>!1,blend:(t,e,i)=>!1}))("groove",""),dy,vf,wy,Sy,Uf,Gf,Vf,Hf,Nf,Pf,Df,Rf,If,Bf,Lf,Mf,_f,by,My,mf,gf,ff,yf,my,gy,fy,yy,af,rf,of,Yy,$y,Xy,qy,zf,jf,qf,Yf,$f,Zf,Ff,kf,Of],Gb=[ay,ly,hy,Jf,Kf,ty,ey,ev,Ny,Cy,Ay,Py,Dy,Ry,Zy,cy,uy,Ty,ny,By,_y,Wv,jv,Xv,qv,Yv,$v,Zv,Jv,Qv,Kv,tb,eb,zy,Fy,Uy,Oy,ky,ib,nb,sb,ab,rb,ob,Vy,Hy,Wy,jy,Cb,Eb,Ab,Pb,Db,Rb,Gy,lb,hb,cb,ub,db,pb,mb,gb,fb,yb,vb,bb,Mb,_b,xb,wb,Sb,Tb],Vb=[Pv,nv,av,rv,ov,lv,Bv,xv,Vv,Nv,Uv,Fv,Dv,Rv,Gv,iv,Lv,kv,gv,fv,uv,dv,pv,mv,Sv,Tv,Cv,Ev,Av,zv,vv,bv,Mv,_v,Iv,Ov,Ib,Bb,Lb,kb,Ob,zb,Fb,Ub,hv],Hb={};[...Nb,...Gb,...Vb].forEach(t=>{Hb[t.name]=t}),Nb.map(t=>t.name),Gb.map(t=>t.name),Vb.map(t=>t.name);const Wb={idle:["breathe","expand","contract","pulse","sway","float","floatUp","floatDown","floatLeft","floatRight","bob","lean","leanLeft","leanRight","jitter","twitch","vibrate","shake","wiggle"],dance:["stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","runningman","charleston","hula","twist","pop","flare","swell","swagger","dip","bounce","orbit","orbitLeft","orbitRight","orbitUp","orbitDown","sparkle","shimmer","groove"],actions:["jump","jumpDown","jumpLeft","jumpRight","rushForward","rushBack","rushLeft","rushRight","rushUp","rushDown","lunge","lungeForward","lungeBack","lungeLeft","lungeRight","lungeUp","lungeDown","spin","spinLeft","spinRight","flip","backflip","point","pointUp","pointDown","pointLeft","pointRight","kickLeft","kickRight","bow","nod","reach","headBob","crouch","tilt","tiltUp","tiltDown","tiltLeft","tiltRight"],reactions:["oofLeft","oofRight","oofFront","oofBack","oofUp","oofDown","recoil","recoilBack","recoilForward","recoilLeft","recoilRight","recoilUp","recoilDown","knockdown","knockout","inflate","deflate","squash","stretch","pancake","rage","fury","battlecry","charge","wobble","teeter","rock","pendulum"],destruction:["shatter","shatterMesh","shatterExplosive","shatterCrumble","shatterReform","shatterPunchLeft","shatterPunchRight","shatterPunchFront","shatterSuspend","shatterFreeze","shatterImplode","shatterGravity","shatterOrbit","dissolveUp","dissolveDown","dissolveLeft","dissolveRight","dissolveAway","dissolveToward","morph"],atmosphere:["rain","drift","driftUp","driftDown","driftLeft","driftRight","vortex","cascadeUp","cascadeDown","cascadeLeft","cascadeRight","confetti","fizz","swarmUp","swarmDown","swarmLeft","swarmRight","burst","burstUp","burstDown","burstLeft","burstRight","ripple","wave","flash","glow","bloom","flicker","shiver","heartbeat","snap","elasticBounce","hold","fade","settle","peek","directional","magneticForward","magneticBack","magneticLeft","magneticRight","magneticUp","magneticDown","magneticAttract","magneticRepel"]},jb={};function Xb(t){if(Hb[t])return Hb[t];return nf(t)||null}function qb(){const t=[];return Object.values(Hb).forEach(e=>{t.push({name:e.name,emoji:e.emoji||"",type:e.type,category:jb[e.name]||"atmosphere",description:e.description||"No description",source:"core"})}),sf().forEach(e=>{const i=nf(e);t.push({name:i.name,emoji:i.emoji||"",type:i.type,category:i.category||"effect",description:i.description||"Plugin gesture",source:"plugin"})}),t}function Yb(t){return function(t){const e=Xb(t);return!!e&&"override"===e.type}(t)}Object.entries(Wb).forEach(([t,e])=>{e.forEach(e=>{jb[e]=t})});class $b{constructor(t,e,i="ambient",n=1,s=1,a=null){const r=Math.random();this.z=r<1/13?.5+.5*Math.random():.9*Math.random()-1;const o=this.z>0?(20+20*Math.random())*n:3*n,l=Math.random()*Math.PI*2;this.x=t+Math.cos(l)*o,this.y=e+Math.sin(l)*o,this.vx=0,this.vy=0,this.vz=0,this.life=0,this.maxLife=1,this.lifeDecay=.01,this.fadeInTime=.15,this.fadeOutTime=.3,this.isFadingOut=!1,this.age=0,this.scaleFactor=n,this.particleSizeMultiplier=s,this.size=(4+6*Math.random())*n*s,this.baseSize=this.size,this.emotionColors=a,this.color="#ffffff",this.opacity=1,this.hasGlow=Math.random()<.333,this.glowSizeMultiplier=this.hasGlow?1.33+.33*Math.random():0,this.isCellShaded=Math.random()<.333,this.baseOpacity=.3+.4*Math.random(),this.cachedColors=new Map,this.maxCachedColors=20,this.colorAccessOrder=[],this.lastColor=null,this.lastOpacity=-1,this.behavior=i,this.behaviorData={},this.gestureData={initialX:t,initialY:e},Kg(this,i)}update(t,e,i,n=null,s=null,a=0,r=null){const o=Math.min(t,50)/16.67,l="rain"===s?.type;l&&console.log("[PARTICLE] update() - RAIN gesture detected:",{gestureMotionType:s?.type,gestureProgress:a?.toFixed(3),particleY:this.y?.toFixed(1)});const h=s&&s.type&&a>0&&Yb(s.type);l&&console.log("[PARTICLE] update() - gestureIsOverriding:",h,"isGestureOverriding(rain):",Yb("rain"));const c=this.y;h?(l&&console.log("[PARTICLE] update() - Calling applyGestureMotion for RAIN"),this.applyGestureMotion(s,a,o,e,i)):"falling"===this.gestureBehavior?tf(this,"falling",o,e,i):"radiant"===this.gestureBehavior?tf(this,"radiant",o,e,i):(tf(this,this.behavior,o,e,i),s&&a>0&&this.applyGestureMotion(s,a,o,e,i)),l&&console.log("[PARTICLE] update() - After applyGestureMotion, Y:",c?.toFixed(1),"->",this.y?.toFixed(1));const u=this.rainData||"falling"===this.gestureBehavior||this.fallingData||this.gestureData?.rain,d=h||u;if(l&&console.log("[PARTICLE] update() - Physics check:",{isRaining:u,gestureIsOverriding:h,skipPhysics:d,hasRainData:!!this.rainData,hasGestureDataRain:!!this.gestureData?.rain,gestureBehavior:this.gestureBehavior}),d?l&&console.log("[PARTICLE] update() - SKIPPED velocity (skipPhysics was true)"):(this.x+=this.vx*o,this.y+=this.vy*o,l&&console.log("[PARTICLE] update() - APPLIED velocity (skipPhysics was false)")),!d){let t,n;if(r)t=r.width,n=r.height;else{const s=document.getElementById("card-mascot")||document.getElementById("cherokee-guide-mascot")||document.querySelector("canvas");t=s?s.width:2*e,n=s?s.height:2*i}const s=20,a=e-t/2+s,o=e+t/2+s,l=i-n/2+s,h=i+n/2-s;this.x-this.size<a?(this.x=a+this.size,this.vx=.5*Math.abs(this.vx)):this.x+this.size>o&&(this.x=o-this.size,this.vx=.5*-Math.abs(this.vx)),this.y-this.size<l?(this.y=l+this.size,this.vy=.5*Math.abs(this.vy)):this.y+this.size>h&&(this.y=h-this.size,this.vy=.5*-Math.abs(this.vy))}this.age+=this.lifeDecay*o,this.age<this.fadeInTime?this.life=this.age/this.fadeInTime:this.age<1-this.fadeOutTime?this.life=1:(this.life=(1-this.age)/this.fadeOutTime,this.isFadingOut=!0,"popcorn"===this.behavior&&(this.size=this.baseSize*(.5+.5*this.life))),this.life=Math.max(0,Math.min(1,this.life)),"falling"===this.behavior?this.opacity=this.life:this.opacity=this.easeInOutCubic(this.life),"burst"===this.behavior&&this.behaviorData&&this.life<this.behaviorData.fadeStart&&(this.size=this.baseSize*(this.life/this.behaviorData.fadeStart))}applyUndertoneModifier(t,e){}applyGestureMotion(t,e,i,n,s){!function(t,e,i,n,s,a){if(!i||!i.type||n>=1)return void("rain"===i?.type&&console.log("[GESTURE_MOTION] applyGestureMotion() SKIPPED - validation failed:",{hasMotion:!!i,motionType:i?.type,progress:n,progressCheck:n>=1}));"rain"===i.type&&console.log("[GESTURE_MOTION] applyGestureMotion() CALLED for RAIN:",{motionType:i.type,progress:n.toFixed(3),dt:e?.toFixed(2),particleY:t.y?.toFixed(1)}),t.gestureData||(t.gestureData={originalVx:t.vx,originalVy:t.vy,initialX:t.x,initialY:t.y,startAngle:Math.atan2(t.y-a,t.x-s),startRadius:Math.sqrt(Math.pow(t.x-s,2)+Math.pow(t.y-a,2))});const r=Xb(i.type);if(!r)return void("rain"===i.type&&console.log("[GESTURE_MOTION] ERROR - gesture not found for type:",i.type));"rain"===i.type&&console.log("[GESTURE_MOTION] Found gesture:",r.name,"hasApply:",!!r.apply);let o=i;if(yg.isEnabled()&&r.rhythm?.enabled){const s=yg.applyGestureRhythm(r,t,n,e);o={...i,amplitude:(i.amplitude||1)*(s.amplitudeMultiplier||1)*(s.accentMultiplier||1),wobbleAmount:(i.wobbleAmount||0)*(s.wobbleMultiplier||1),rhythmModulation:s}}if(r.apply){const l=t.y;r.apply(t,n,o,e,s,a),"rain"===i.type&&console.log("[GESTURE_MOTION] After gesture.apply() - Y changed:",l?.toFixed(1),"->",t.y?.toFixed(1))}n>=.99&&r.cleanup&&(r.cleanup(t),t.gestureData=null)}(this,i,t,e,n,s)}isOutOfBounds(t,e){return this.x<-50||this.x>t+50||this.y<-50||this.y>e+50}isAlive(){return this.life>0}setOutwardVelocity(t){if(this.behaviorData&&void 0!==this.behaviorData.outwardSpeed){const e=this.behaviorData.outwardSpeed;this.vx=Math.cos(t)*e,this.vy=Math.sin(t)*e+(this.behaviorData.upwardBias||0)}}getDepthAdjustedSize(){const t=1+.2*this.z;return this.size*t}getState(){return{position:{x:this.x,y:this.y,z:this.z},velocity:{x:this.vx,y:this.vy,z:this.vz},life:this.life,behavior:this.behavior,size:this.size,opacity:this.opacity}}reset(t,e,i="ambient",n=1,s=1,a=null){const r=Math.random();this.z=r<1/13?.5+.5*Math.random():.9*Math.random()-1;const o=this.z>0?(20+20*Math.random())*n:3*n,l=Math.random()*Math.PI*2;if(this.x=t+Math.cos(l)*o,this.y=e+Math.sin(l)*o,this.vx=0,this.vy=0,this.vz=0,this.life=0,this.age=0,this.scaleFactor=n,this.particleSizeMultiplier=s,this.size=(4+6*Math.random())*n*s,this.baseSize=this.size,this.emotionColors=a,this.cachedColors.clear(),this.colorAccessOrder=[],this.opacity=0,this.isFadingOut=!1,this.baseOpacity=.3+.4*Math.random(),this.color="#ffffff",this.behavior=i,this.gestureData=null,this.behaviorData)for(const t in this.behaviorData)delete this.behaviorData[t];else this.behaviorData={};Kg(this,i)}getCachedColor(t,e){const i=Math.round(100*e)/100,n=`${t}_${i}`;if(this.cachedColors.has(n)){const t=this.colorAccessOrder.indexOf(n);-1!==t&&this.colorAccessOrder.splice(t,1),this.colorAccessOrder.push(n)}else{if(this.cachedColors.size>=this.maxCachedColors){const t=this.colorAccessOrder.shift();this.cachedColors.delete(t)}this.cachedColors.set(n,this.hexToRgba(t,i)),this.colorAccessOrder.push(n)}return this.cachedColors.get(n)}hexToRgba(t,e){const i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return i?`rgba(${parseInt(i[1],16)}, ${parseInt(i[2],16)}, ${parseInt(i[3],16)}, ${e})`:`rgba(255, 255, 255, ${e})`}easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}render(t,e="#ffffff"){if(this.life<=0)return;if(!isFinite(this.x)||!isFinite(this.y))return;const i=this.x,n=this.y,s=Math.max(.1,this.size),a=this.tempColor||this.color||e;if(t.save(),this.isCellShaded){t.strokeStyle=this.getCachedColor(a,.9*this.opacity),t.lineWidth=2,t.beginPath(),t.arc(i,n,s,0,2*Math.PI),t.stroke();const e=Math.floor(3*this.opacity)/3;t.fillStyle=this.getCachedColor(a,e*(this.baseOpacity||.5)*.5),t.beginPath(),t.arc(i,n,Math.max(.1,s-1),0,2*Math.PI),t.fill(),e>.5&&(t.fillStyle=this.getCachedColor("#FFFFFF",.3),t.beginPath(),t.arc(i-.3*s,n-.3*s,.3*s,0,2*Math.PI),t.fill())}else{const e=t.createRadialGradient(i,n,0,i,n,s);if(e.addColorStop(0,this.getCachedColor(a,this.opacity*(this.baseOpacity||.5))),e.addColorStop(.5,this.getCachedColor(a,this.opacity*(this.baseOpacity||.5)*.5)),e.addColorStop(1,this.getCachedColor(a,0)),t.fillStyle=e,t.beginPath(),t.arc(i,n,s,0,2*Math.PI),t.fill(),this.hasGlow&&this.glowSizeMultiplier>0){const e=s*this.glowSizeMultiplier,r=t.createRadialGradient(i,n,.5*s,i,n,e),o=.3,l=Math.max(o,this.opacity),h=Math.min(1,this.glowSizeMultiplier/3);r.addColorStop(0,this.getCachedColor(a,Math.max(.5,.8*l)*h)),r.addColorStop(.25,this.getCachedColor(a,Math.max(.3,.6*l)*h)),r.addColorStop(.5,this.getCachedColor(a,Math.max(.2,.4*l)*h)),r.addColorStop(.75,this.getCachedColor(a,Math.max(.1,.2*l)*h)),r.addColorStop(1,this.getCachedColor(a,0)),t.save(),t.globalCompositeOperation="screen",t.fillStyle=r,t.beginPath(),t.arc(i,n,e,0,2*Math.PI),t.fill(),t.restore()}}t.restore()}}class Zb{constructor(t=50){this.poolSize=Math.min(t,50),this.pool=[],this.totalParticlesCreated=0,this.totalParticlesDestroyed=0,this.poolHits=0,this.poolMisses=0}getParticle(t,e,i,n,s,a,r,o=null){let l;return this.pool.length>0?(l=this.pool.pop(),l.reset(t,e,i,n,s,a),this.poolHits++):(l=new $b(t,e,i,n,s,a),this.poolMisses++,this.totalParticlesCreated++),l.emotion=r,o&&(l.gestureBehavior=o),l}returnParticle(t){if(this.pool.length<this.poolSize){if(t.cachedGradient=null,t.cachedGradientKey=null,t.behaviorData)for(const e in t.behaviorData)delete t.behaviorData[e];this.pool.push(t)}else this.totalParticlesDestroyed++}refreshPool(){const t=this.pool.length-this.poolSize;t>0&&(this.pool.splice(this.poolSize),this.totalParticlesDestroyed+=t)}getStats(){return{poolSize:this.pool.length,poolHits:this.poolHits,poolMisses:this.poolMisses,totalCreated:this.totalParticlesCreated,totalDestroyed:this.totalParticlesDestroyed}}clear(){this.pool=[],this.poolHits=0,this.poolMisses=0,this.totalParticlesCreated=0,this.totalParticlesDestroyed=0}}class Jb{constructor(){this.spawnAccumulator=0}getSpawnPosition(t,e,i,n,s,a=null){const r=Math.min(n,s)/12,o=2.5*r,l=1.1*o,h=Math.min(e-30,n-e-30),c=Math.min(i-30,s-i-30),u=Math.min(1.5*o,h,c);switch(t){case"ambient":case"resting":{const t=Math.random()*Math.PI*2,n=.9*o;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n,angle:t}}case"rising":{const t=Math.random()*Math.PI*2,n=l+Math.random()*(u-l);return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n}}case"falling":{const t=Math.random()*Math.PI*2,n=.9*o;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n,angle:t}}case"aggressive":{const t=Math.random()*Math.PI*2,n=o+Math.random()*r;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n}}case"scattering":default:return{x:e,y:i};case"burst":{const t=Math.random()*Math.PI*2;if("suspicion"===a){const n=1.5*r;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n}}if("surprise"===a){const n=1.2*r;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n}}return{x:e,y:i}}case"repelling":{const t=Math.random()*Math.PI*2,n=.9*o;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n}}case"orbiting":{const t=Math.random()*Math.PI*2,n=1.2*o+Math.random()*o*.5;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n}}case"glitchy":{const t=Math.random()*Math.PI*2,n=3*o+Math.random()*o*4;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n}}case"spaz":{const t=Math.random()*Math.PI*2,n=2*o+Math.random()*o*3;return{x:e+Math.cos(t)*n,y:i+Math.sin(t)*n}}}}clampToCanvas(t,e,i,n,s=30){return{x:Math.max(s,Math.min(i-s,t)),y:Math.max(s,Math.min(n-s,e))}}calculateSpawnRate(t,e){if(t<=0)return 0;const i=Math.min(e,50),n=t/1e3;this.spawnAccumulator+=n*i,this.spawnAccumulator=Math.min(this.spawnAccumulator,3);let s=0;for(;this.spawnAccumulator>=1;)s++,this.spawnAccumulator-=1;return s}resetAccumulator(){this.spawnAccumulator=0}}class Qb{render(t,e,i="#ffffff",n=null){const s=[];for(const t of e)t.life<=0||s.push(t);this._renderParticles(t,s,i,n)}renderLayer(t,e,i="#ffffff",n=!1,s=null){const a=[],r=t.canvas.width,o=t.canvas.height;for(const t of e)t.z>=0===n&&(t.x<-50||t.x>r+50||t.y<-50||t.y>o+50||t.life<=0||a.push(t));return a.sort((t,e)=>t.isCellShaded!==e.isCellShaded?t.isCellShaded?-1:1:t.hasGlow!==e.hasGlow?t.hasGlow?-1:1:0),this._renderParticles(t,a,i,s),a}_renderParticles(t,e,i,n=null){t.save();let s=null;for(const a of e)if(a.isCellShaded)a.render(t,i),s=null;else{const e=a.color||i;if(e!==s&&(t.fillStyle=e,s=e),!isFinite(a.x)||!isFinite(a.y))continue;const r=a.getDepthAdjustedSize?a.getDepthAdjustedSize():a.size;let o=Math.max(.1,r),l=1;if(n&&n.fireflyEffect){const t=(.01*a.x+.01*a.y+.1*a.size)%(2*Math.PI),e=n.fireflyTime||.001*Date.now(),i=n.particleGlow||2;l=.3+Math.max(0,Math.sin(3*e+t))*i}if(n&&n.flickerEffect){const t=(.02*a.x+.02*a.y)%(2*Math.PI),e=n.flickerTime||.001*Date.now(),i=n.particleGlow||2;l=.5+Math.sin(12*e+t)*i*.5}if(n&&n.shimmerEffect){const e=a.x-t.canvas.width/2,i=a.y-t.canvas.height/2,s=Math.sqrt(e*e+i*i)/200,r=n.shimmerTime||.001*Date.now(),o=n.shimmerWave||0,h=n.particleGlow||1.2;l=1+.15*Math.sin(3*r-s+o)*h}if(n&&n.glowEffect){const e=n.glowProgress||0,i=n.particleGlow||2,s=a.x-t.canvas.width/2,r=a.y-t.canvas.height/2,l=Math.sqrt(s*s+r*r)/300,h=Math.min(.3*l,.5),c=Math.max(0,(e-h)/(1-h)),u=Math.sin(c*Math.PI);a._originalGlow||(a._originalGlow={hasGlow:a.hasGlow,glowSizeMultiplier:a.glowSizeMultiplier||0}),a.hasGlow=!0,a.glowSizeMultiplier=Math.max(3,a._originalGlow.glowSizeMultiplier)+u*i*3,o*=1+.3*u,e>=.99&&a._originalGlow&&(a.hasGlow=a._originalGlow.hasGlow,a.glowSizeMultiplier=a._originalGlow.glowSizeMultiplier,delete a._originalGlow)}if(a.hasGlow||l>1){const e=Math.max(.1,o*(a.glowSizeMultiplier||1.5)*l),i=t.globalCompositeOperation;t.globalCompositeOperation="screen",t.globalAlpha=.15*a.opacity*l,t.beginPath(),t.arc(a.x,a.y,e,0,2*Math.PI),t.fill(),t.globalAlpha=.25*a.opacity*l,t.beginPath(),t.arc(a.x,a.y,.6*e,0,2*Math.PI),t.fill(),t.globalCompositeOperation=i}t.globalAlpha=a.opacity*(a.baseOpacity||.5)*.6*Math.min(2,l),t.beginPath(),t.arc(a.x,a.y,o,0,2*Math.PI),t.fill()}t.restore()}}class Kb{constructor(t=50,e=null){this.errorBoundary=e,this.maxParticles=t,this.absoluteMaxParticles=2*t,this.particles=[],this.particlePool=new Zb(t),this.particleSpawner=new Jb,this.particleRenderer=new Qb,this.containmentBounds=null,this.stateChangeCount=0,this.lastMemoryCheck=Date.now(),this.lastLeakedCount=0,this.particleCount=0,this.cleanupTimer=0,this.cleanupInterval=5e3}get pool(){return this.particlePool.pool}get poolSize(){return this.particlePool.poolSize}get poolHits(){return this.particlePool.poolHits}get poolMisses(){return this.particlePool.poolMisses}get totalParticlesCreated(){return this.particlePool.totalParticlesCreated}get totalParticlesDestroyed(){return this.particlePool.totalParticlesDestroyed}get spawnAccumulator(){return this.particleSpawner.spawnAccumulator}set spawnAccumulator(t){this.particleSpawner.spawnAccumulator=t}getParticleFromPool(t,e,i){return this.particlePool.getParticle(t,e,i,this.scaleFactor||1,this.particleSizeMultiplier||1,this.currentEmotionColors,this.currentEmotion,this.gestureBehavior)}returnParticleToPool(t){this.particlePool.returnParticle(t)}spawn(t,e,i,n,s,a,r=null,o=0,l=10,h=1,c=1,u=null,d=null){if(this.scaleFactor=h,this.particleSizeMultiplier=c,this.errorBoundary)return this.errorBoundary.wrap(()=>{this._spawn(t,e,i,n,s,a,r,o,l,u,d)},"particle-spawn")();this._spawn(t,e,i,n,s,a,r,o,l,u,d)}resetAccumulator(){this.particleSpawner.resetAccumulator()}_spawn(t,e,i,n,s,a,r,o=0,l=10,h=null,c=null){this.currentEmotion=e,this.baseEmotionColors=h,this.currentUndertone=c,this.currentEmotionColors=h&&c?function(t,e){return t&&Array.isArray(t)&&e&&"clear"!==e?t.map(t=>"string"==typeof t?fg(t,e):t&&"object"==typeof t&&t.color?{...t,color:fg(t.color,e)}:t):t}(h,c):h;let u=i;if(yg.isEnabled()){const i=vg&&vg.isInitialized?vg.getEmotion(e):Km(e);if(i){const e=yg.applyParticleRhythm(i,this);if(e.emitBurst)for(let i=0;i<e.emitBurst&&this.particles.length<l;i++)this.spawnSingleParticle(t,n,s);void 0!==e.emissionRate&&(u*=e.emissionRate)}}if(null!==r){for(let e=0;e<r&&this.particles.length<this.maxParticles;e++)this.spawnSingleParticle(t,n,s);return}if(this.skipSpawnThisFrame)return;for(;this.particles.length<o&&this.particles.length<this.maxParticles;)this.spawnSingleParticle(t,n,s);if(this.particles.length>=l)return;if(u<=0)return;const d=this.particleSpawner.calculateSpawnRate(u,a);for(let e=0;e<d&&this.particles.length<l;e++)this.spawnSingleParticle(t,n,s)}getSpawnPosition(t,e,i,n,s){return this.particleSpawner.getSpawnPosition(t,e,i,n,s,this.currentEmotion)}clampToCanvas(t,e,i,n,s=30){return this.particleSpawner.clampToCanvas(t,e,i,n,s)}spawnSingleParticle(t,e,i){if(this.particles.length>=this.absoluteMaxParticles)return;const n=this.canvasWidth||2*e,s=this.canvasHeight||2*i,a=this.particleSpawner.getSpawnPosition(t,e,i,n,s,this.currentEmotion),r=this.particleSpawner.clampToCanvas(a.x,a.y,n,s);a.x=r.x,a.y=r.y;const o=this.getParticleFromPool(a.x,a.y,t);"meditation_swirl"===t&&a.palmCenter&&(o.palmCenter=a.palmCenter,o.swirlAngle=a.swirlAngle),this.particles.push(o),this.particleCount++}update(t,e,i,n=null,s=0,a=null){if(this.errorBoundary)return this.errorBoundary.wrap((t,e,i,n,s,a)=>this._update(t,e,i,n,s,a),"particle-update")(t,e,i,n,s,a);this._update(t,e,i,n,s,a)}_update(t,e,i,n=null,s=0,a=null){"rain"===n?.type&&console.log("[PARTICLE_SYSTEM] _update() with RAIN:",{gestureMotionType:n.type,gestureProgress:s?.toFixed(3),particleCount:this.particles.length});let r=!1;for(this.particles=this.particles.filter(o=>("rain"!==n?.type||r||(console.log("[PARTICLE_SYSTEM] Calling particle.update() for first particle with RAIN"),r=!0),o.update(t,e,i,a,n,s,this.containmentBounds),o.isAlive()));this.particles.length>this.maxParticles;)this.removeParticle(0)}setGestureBehavior(t,e){this.gestureBehavior=e?t:null,e?this.particles.forEach(e=>{e.gestureBehavior=t}):this.particles.forEach(t=>{t.gestureBehavior=null})}removeParticle(t){if(t>=0&&t<this.particles.length){const e=this.particles.splice(t,1)[0];e.cachedGradient=null,e.cachedGradientKey=null,this.returnParticleToPool(e),this.particleCount=Math.max(0,this.particleCount-1)}}render(t,e="#ffffff",i=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._render(t,e,i)},"particle-render")();this._render(t,e,i)}renderBackground(t,e="#ffffff",i=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._renderLayer(t,e,!1,i)},"particle-render-bg")();this._renderLayer(t,e,!1,i)}renderForeground(t,e="#ffffff",i=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._renderLayer(t,e,!0,i)},"particle-render-fg")();this._renderLayer(t,e,!0,i)}_renderLayer(t,e,i,n=null){this.particleRenderer.renderLayer(t,this.particles,e,i,n)}_render(t,e,i=null){this.particleRenderer.render(t,this.particles,e,i)}onVisibilityResume(t,e=null){if(this.resetAccumulator(),t>3e4)this.clear();else if(t>1e4){const t=this.particles.length,i=e??t,n=Math.max(10,Math.floor(.5*i));for(;this.particles.length>n;)this.removeParticle(0)}}clear(){for(this.stateChangeCount++;this.particles.length>0;){const t=this.particles.pop();if(t.cachedColors&&t.cachedColors.clear(),t.behaviorData)for(const e in t.behaviorData)delete t.behaviorData[e];this.pool.length<this.poolSize&&!this.pool.includes(t)&&this.pool.push(t)}if(this.particles.length=0,this.particleCount=0,this.spawnAccumulator=0,this.pool.length>this.poolSize){const t=this.pool.length-this.poolSize;this.pool.splice(this.poolSize,t)}}burst(t,e,i,n){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._burst(t,e,i,n)},"particle-burst")();this._burst(t,e,i,n)}_burst(t,e,i,n){const s=Math.min(t,this.maxParticles-this.particles.length);for(let t=0;t<s;t++)this.spawnSingleParticle(e,i,n)}performCleanup(){if(this.pool.length>this.poolSize){const t=this.pool.length-this.poolSize;for(let e=0;e<t;e++){const t=this.pool.pop();t&&(t.cachedGradient=null,t.cachedGradientKey=null,t.behaviorData=null)}}for(const t of this.particles)t.cachedGradient&&t.life<.5&&(t.cachedGradient=null,t.cachedGradientKey=null)}getStats(){return{activeParticles:this.particles.length,maxParticles:this.maxParticles,poolSize:this.pool.length,poolHits:this.poolHits,poolMisses:this.poolMisses,poolEfficiency:this.poolHits/Math.max(1,this.poolHits+this.poolMisses),spawnAccumulator:this.spawnAccumulator}}setMaxParticles(t){for(this.originalMaxParticles=this.originalMaxParticles||this.maxParticles,this.maxParticles=Math.max(1,t);this.particles.length>this.maxParticles;)this.removeParticle(0)}cleanupDeadParticles(){const t=this.particles.length;this.particles=this.particles.filter(t=>t.isAlive());const e=t-this.particles.length;return this.pool.length>20&&(this.pool.length=20),e}getParticlesByBehavior(t){return this.particles.filter(e=>e.behavior===t)}validateParticles(){for(const t of this.particles)if(!t.isAlive()||t.life<0||t.life>1)return!1;return!0}cleanup(){for(let t=this.particles.length-1;t>=0;t--)this.particles[t].isAlive()||this.removeParticle(t)}refreshPool(){this.particlePool.clear();for(const t of this.particles)t.life=0}setContainmentBounds(t){this.containmentBounds=t}destroy(){this.clear(),this.particlePool.clear()}}class tM{constructor(t={}){this.worldScale=t.worldScale||.2,this.baseRadius=t.baseRadius||.15,this.depthScale=t.depthScale||.75,this.verticalScale=t.verticalScale||1,this.coreRadius3D=t.coreRadius3D||1,this.tempVec3=new qe,this.tempVec3_2=new qe,this.behaviorTranslators=this._initBehaviorTranslators(),this.currentGestureData=null}setCoreRadius3D(t){this.coreRadius3D=t}updateRotationState(t,e,i=null){this.rotationState=t,this.deltaTime=e,this.currentGestureData=i}_initBehaviorTranslators(){return{ambient:this._translateAmbient.bind(this),orbiting:this._translateOrbiting.bind(this),rising:this._translateRising.bind(this),falling:this._translateFalling.bind(this),popcorn:this._translatePopcorn.bind(this),burst:this._translateBurst.bind(this),aggressive:this._translateAggressive.bind(this),scattering:this._translateScattering.bind(this),repelling:this._translateRepelling.bind(this),connecting:this._translateConnecting.bind(this),resting:this._translateResting.bind(this),radiant:this._translateRadiant.bind(this),ascending:this._translateAscending.bind(this),erratic:this._translateErratic.bind(this),cautious:this._translateCautious.bind(this),surveillance:this._translateSurveillance.bind(this),glitchy:this._translateGlitchy.bind(this),spaz:this._translateSpaz.bind(this),directed:this._translateDirected.bind(this),fizzy:this._translateFizzy.bind(this),zen:this._translateZen.bind(this),gravitationalAccretion:this._translateGravitationalAccretion.bind(this)}}translate2DTo3D(t,e,i){if(t.gestureData?.rain?.initialized)return this._translateRainGesture(t,e,i);const n=(this.behaviorTranslators[t.behavior]||this._translateDefault.bind(this))(t,e,i);return this.currentGestureData&&"spin"===this.currentGestureData.gestureName?this._applySpinRotation(n,e,this.currentGestureData.progress):n}_translateRainGesture(t,e,i){const n=i.width/2,s=i.height/2,a=t.gestureData.rain,r=.004*(t.y-a.originalY),o=this._getUniformDirection3D(t),l=a.originalX-n,h=a.originalY-s,c=Math.sqrt(l*l+h*h)/n,u=.6*this.coreRadius3D,d=u+c*(1.2*this.coreRadius3D-u);return this.tempVec3.set(e.x+o.x*d,e.y+o.y*d*this.verticalScale-r,e.z+o.z*d)}_applySpinRotation(t,e,i){const n=t.x-e.x,s=t.y-e.y,a=t.z-e.z,r=Math.sin(i*Math.PI)*Math.PI*2,o=Math.cos(r),l=Math.sin(r),h=n*o-a*l,c=n*l+a*o;return this.tempVec3.set(e.x+h,e.y+s,e.z+c)}_canvasToWorld(t,e,i,n,s,a){const r=(t-n)/n,o=-(e-s)/s,l=1+i*this.depthScale,h=r*this.worldScale*l+a.x,c=o*this.worldScale*this.verticalScale*l+a.y,u=i*this.worldScale*.5+a.z;return this.tempVec3.set(h,c,u)}_hash(t){const e=43758.5453123*Math.sin(t);return e-Math.floor(e)}_getUniformDirection3D(t){const e=t.behaviorData||{};if(e.direction3D)return e.direction3D;const i=127.1*t.x+311.7*t.y+74.7*(t.vx||0)+159.3*(t.vy||0),n=this._hash(i),s=this._hash(i+1),a=n*Math.PI*2,r=2*s-1,o=Math.sqrt(1-r*r),l=o*Math.cos(a),h=r,c=o*Math.sin(a);return e.direction3D={x:l,y:h,z:c},e.direction3D}_toSpherical(t,e,i,n){const s=t-n.x,a=e-n.y,r=i-n.z,o=Math.sqrt(s*s+a*a+r*r);return{radius:o,theta:Math.atan2(r,s),phi:Math.acos(a/(o||1))}}_toCartesian(t,e,i,n){const s=t*Math.sin(i)*Math.cos(e)+n.x,a=t*Math.cos(i)+n.y,r=t*Math.sin(i)*Math.sin(e)+n.z;return this.tempVec3_2.set(s,a,r)}_translateDefault(t,e,i){return this._canvasToWorld(t.x,t.y,t.z,i.width/2,i.height/2,e)}_translateAmbient(t,e,i){const n=this._getUniformDirection3D(t),s=i.width/2,a=i.height/2,r=t.x-s,o=t.y-a,l=Math.sqrt(r*r+o*o)/s,h=.6*this.coreRadius3D,c=h+l*(1.2*this.coreRadius3D-h),u=.5*t.age,d=.03*this.coreRadius3D,p=Math.cos(u)*d,m=Math.sin(u)*d;return this.tempVec3.set(e.x+n.x*c+p,e.y+n.y*c*this.verticalScale,e.z+n.z*c+m)}_translateOrbiting(t,e,i){const n=t.behaviorData||{};if(!n.orbitPlane){const e=t.x+.5*t.y,i=.7*t.x+t.y;n.orbitPlane={inclination:.5*(Math.sin(.1*e)+1)*Math.PI,rotation:.5*(Math.sin(.1*i)+1)*Math.PI*2}}const{inclination:s,rotation:a}=n.orbitPlane,r=n.angle||0,o=.01*(n.radius||100)*this.baseRadius*.25*(1+t.z*this.depthScale),l=Math.cos(r)*o,h=Math.sin(r)*o,c=Math.cos(s),u=Math.sin(s),d=Math.cos(a),p=Math.sin(a),m=l*d-h*c*p,g=h*u,f=l*p+h*c*d;return this.tempVec3.set(e.x+m,e.y+g*this.verticalScale,e.z+f)}_translateRising(t,e,i){const n=this._canvasToWorld(t.x,t.y,t.z,i.width/2,i.height/2,e),s=-.01*t.vy;return n.y+=s,n}_translateFalling(t,e,i){const n=i.width/2,s=i.height/2,a=t.gestureData?.rain?.initialized;if(a){const i=t.gestureData.rain,a=.004*(t.y-i.originalY),r=this._getUniformDirection3D(t),o=i.originalX-n,l=i.originalY-s,h=Math.sqrt(o*o+l*l)/n,c=.6*this.coreRadius3D,u=c+h*(1.2*this.coreRadius3D-c);return this.tempVec3.set(e.x+r.x*u,e.y+r.y*u*this.verticalScale-a,e.z+r.z*u)}const r=this._getUniformDirection3D(t),o=t.x-n,l=t.y-s,h=Math.sqrt(o*o+l*l)/n,c=.6*this.coreRadius3D,u=c+h*(1.2*this.coreRadius3D-c),d=.6*t.age*this.coreRadius3D;return this.tempVec3.set(e.x+r.x*u,e.y+r.y*u*this.verticalScale-d,e.z+r.z*u)}_translatePopcorn(t,e,i){const n=i.width/2,s=i.height/2,a=t.behaviorData||{},r=this._getUniformDirection3D(t);if(!a.hasPopped){const t=.7*this.coreRadius3D;return this.tempVec3.set(e.x+r.x*t,e.y+r.y*t*this.verticalScale,e.z+r.z*t)}const o=t.x-n,l=t.y-s,h=Math.sqrt(o*o+l*l),c=Math.min(h/n,1.5),u=1.2*this.coreRadius3D,d=u+c*(4*this.coreRadius3D-u);return this.tempVec3.set(e.x+r.x*d,e.y+r.y*d*this.verticalScale,e.z+r.z*d)}_translateBurst(t,e,i){const n=this._getUniformDirection3D(t),s=1-t.life,a=this.coreRadius3D*(1+1*s);return this.tempVec3.set(e.x+n.x*a,e.y+n.y*a*this.verticalScale,e.z+n.z*a)}_translateAggressive(t,e,i){const n=this._getUniformDirection3D(t),s=i.width/2,a=i.height/2,r=t.x-s,o=t.y-a,l=Math.sqrt(r*r+o*o)/s,h=.3*this.coreRadius3D,c=h+l*(.55*this.coreRadius3D-h),u=.04*this.coreRadius3D,d=Math.sin(10*t.age+.1*t.x)*u,p=Math.cos(12*t.age+.1*t.y)*u,m=Math.sin(8*t.age+.1*t.vx)*u;return this.tempVec3.set(e.x+n.x*c+d,e.y+n.y*c*this.verticalScale+p,e.z+n.z*c+m)}_translateScattering(t,e,i){const n=this._getUniformDirection3D(t),s=Math.min(.8*t.age,1),a=this.coreRadius3D*(.3+.3*s);return this.tempVec3.set(e.x+n.x*a,e.y+n.y*a*this.verticalScale,e.z+n.z*a)}_translateRepelling(t,e,i){const n=this._getUniformDirection3D(t),s=Math.min(.6*t.age,1),a=this.coreRadius3D*(.3+.3*s);return this.tempVec3.set(e.x+n.x*a,e.y+n.y*a*this.verticalScale,e.z+n.z*a)}_translateConnecting(t,e,i){const n=this._canvasToWorld(t.x,t.y,t.z,i.width/2,i.height/2,e),s=.3*(1-t.life),a=this.tempVec3_2.set(e.x-n.x,e.y-n.y,e.z-n.z).normalize();return n.add(a.multiplyScalar(s)),n}_translateResting(t,e,i){const n=this._getUniformDirection3D(t),s=i.width/2,a=i.height/2,r=t.x-s,o=t.y-a,l=Math.sqrt(r*r+o*o)/s,h=.25*this.coreRadius3D,c=h+l*(.45*this.coreRadius3D-h),u=.3*t.age,d=Math.sin(u)*this.coreRadius3D*.01;return this.tempVec3.set(e.x+n.x*c,e.y+n.y*c*this.verticalScale+d,e.z+n.z*c)}_translateRadiant(t,e,i){const n=this._getUniformDirection3D(t),s=1-t.life,a=this.coreRadius3D*(1+.8*s);return this.tempVec3.set(e.x+n.x*a,e.y+n.y*a*this.verticalScale,e.z+n.z*a)}_translateAscending(t,e,i){const n=t.behaviorData||{},s=n.spiralAngle||0,a=.01*(n.spiralRadius||50)*this.coreRadius3D,r=t.age*this.coreRadius3D*.5,o=Math.cos(s)*a+e.x,l=r+e.y,h=Math.sin(s)*a+e.z;return this.tempVec3.set(o,l,h)}_translateErratic(t,e,i){const n=this._canvasToWorld(t.x,t.y,t.z,i.width/2,i.height/2,e),s=10*t.age;return n.x+=.1*Math.sin(1.1*s),n.y+=.1*Math.cos(1.3*s),n.z+=.1*Math.sin(1.7*s),n}_translateCautious(t,e,i){return this._translateAmbient(t,e,i)}_translateSurveillance(t,e,i){const n=this._getUniformDirection3D(t),s=.5*t.age,a=1.2*this.coreRadius3D,r={x:0*n.y-1*n.z,y:0*n.z-0*n.x,z:1*n.x-0*n.y},o=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z);o>0&&(r.x/=o,r.y/=o,r.z/=o);const l=Math.cos(s)*n.x+Math.sin(s)*r.x,h=Math.cos(s)*n.y+Math.sin(s)*r.y,c=Math.cos(s)*n.z+Math.sin(s)*r.z;return this.tempVec3.set(e.x+l*a,e.y+h*a*this.verticalScale,e.z+c*a)}_translateGlitchy(t,e,i){const n=this._canvasToWorld(t.x,t.y,t.z,i.width/2,i.height/2,e);return Math.floor(10*t.age)%3==0&&(n.x+=.3*(Math.random()-.5),n.y+=.3*(Math.random()-.5),n.z+=.3*(Math.random()-.5)),n}_translateSpaz(t,e,i){const n=this._canvasToWorld(t.x,t.y,t.z,i.width/2,i.height/2,e),s=.15,a=20*t.age;return n.x+=Math.sin(2.1*a)*s,n.y+=Math.cos(2.3*a)*s,n.z+=Math.sin(2.7*a)*s,n}_translateDirected(t,e,i){const n=t.behaviorData||{};if(void 0!==n.targetX&&void 0!==n.targetY){const s=this._canvasToWorld(n.targetX,n.targetY,t.z,i.width/2,i.height/2,e),a=this._canvasToWorld(t.x,t.y,t.z,i.width/2,i.height/2,e),r=1-t.life;return this.tempVec3.lerpVectors(a,s,r)}const s=this._getUniformDirection3D(t),a=i.width/2,r=i.height/2,o=t.x-a,l=t.y-r,h=Math.sqrt(o*o+l*l)/a,c=1*this.coreRadius3D,u=c+h*(1.6*this.coreRadius3D-c);return this.tempVec3.set(e.x+s.x*u,e.y+s.y*u*this.verticalScale,e.z+s.z*u)}_translateFizzy(t,e,i){const n=this._canvasToWorld(t.x,t.y,t.z,i.width/2,i.height/2,e),s=.05*Math.sin(8*t.age);return n.x+=s,n.z+=.05*Math.cos(8*t.age),n.y+=.5*t.age,n}_translateZen(t,e,i){const n=this._getUniformDirection3D(t),s=.2*t.age,a=1.4*this.coreRadius3D,r={x:0*n.y-1*n.z,y:0*n.z-0*n.x,z:1*n.x-0*n.y},o=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z);o>0&&(r.x/=o,r.y/=o,r.z/=o);const l=Math.cos(s)*n.x+Math.sin(s)*r.x,h=Math.cos(s)*n.y+Math.sin(s)*r.y,c=Math.cos(s)*n.z+Math.sin(s)*r.z;return this.tempVec3.set(e.x+l*a,e.y+h*a*this.verticalScale,e.z+c*a)}_translateGravitationalAccretion(t,e,i){const n=t.behaviorData||{},s=.25;if(n.orbitRadius||(t.x,t.y,n.orbitRadius=s*(2.5+5.5*Math.random()),n.orbitAngle=Math.PI+Math.random()*Math.PI,n.diskInclination=.1*(Math.random()-.5),n.angularVelocity=.5/Math.sqrt(n.orbitRadius/s),n.tidalStretch={x:1,y:1,z:1}),n.orbitRadius-=1e-4*this.baseRadius,n.angularVelocity=.5/Math.sqrt(n.orbitRadius/s),n.orbitAngle+=n.angularVelocity*(this.deltaTime||16)*.001,n.orbitAngle=n.orbitAngle%(2*Math.PI),n.orbitAngle<0&&(n.orbitAngle+=2*Math.PI),n.orbitAngle<Math.PI)return t.isAlive=!1,t.life=0,this.tempVec3.set(e.x,e.y,e.z);const a=n.orbitRadius/s;if(a<=1)t.isAlive=!1,t.life=0;else if(a<=1.5)n.tidalStretch.x=.3,n.tidalStretch.y=3,n.tidalStretch.z=.3;else if(a<=2.5){const t=(2.5-a)/1;n.tidalStretch.x=1-.7*t,n.tidalStretch.y=1+2*t,n.tidalStretch.z=1-.7*t}else n.tidalStretch.x=1,n.tidalStretch.y=1,n.tidalStretch.z=1;const r=Math.cos(n.orbitAngle)*n.orbitRadius,o=Math.sin(n.orbitAngle)*n.orbitRadius,l=.025*Math.sin(3*n.orbitAngle+t.x)*Math.sin(n.diskInclination),h=r*n.tidalStretch.x,c=l*n.tidalStretch.y,u=o*n.tidalStretch.z,d=.25;return this.tempVec3.set(e.x+h*d,e.y+c*d,e.z+u*d)}setWorldScale(t){this.worldScale=t}setBaseRadius(t){this.baseRadius=t}cleanupParticleCaches(t){for(const e of t)!e.isAlive&&e.behaviorData&&(e.behaviorData.direction3D&&(e.behaviorData.direction3D=null),e.behaviorData.orbitPlane&&(e.behaviorData.orbitPlane=null),e.behaviorData.orbitPath&&(e.behaviorData.orbitPath=null),e.behaviorData.orbitRadius&&(e.behaviorData.orbitRadius=null,e.behaviorData.orbitAngle=null,e.behaviorData.diskInclination=null,e.behaviorData.angularVelocity=null,e.behaviorData.tidalStretch=null))}dispose(){this.tempVec3=null,this.tempVec3_2=null,this.rotationState=null,this.currentGestureData=null}}let eM=null,iM=null;const nM=`\n    uniform float time;\n    uniform vec3 emotionColor;\n    uniform float energyIntensity;\n    uniform float driftEnabled;\n    uniform float driftSpeed;\n    uniform float crossWaveEnabled;\n    uniform float crossWaveSpeed;\n    uniform float ghostMode;      // 0.0 = solid, 1.0 = ghost (only visible through bloom)\n    uniform float baseOpacity;    // Base opacity when not in ghost mode (default 1.0)\n    uniform float phaseOffset1;   // Phase offset for primary drift (radians)\n    uniform float phaseOffset2;   // Phase offset for secondary drift (radians)\n    uniform float phaseOffset3;   // Phase offset for crosswave (radians)\n\n    // Blend layer uniforms\n    uniform float blendLayer1Mode;\n    uniform float blendLayer1Strength;\n    uniform float blendLayer1Enabled;\n    uniform float blendLayer2Mode;\n    uniform float blendLayer2Strength;\n    uniform float blendLayer2Enabled;\n\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n\n    // Blend modes (injected from blendModesGLSL)\n    ${cm}\n\n    // Smooth noise function\n    float noise3D(vec3 p) {\n        vec3 i = floor(p);\n        vec3 f = fract(p);\n        f = f * f * (3.0 - 2.0 * f);\n        float n = i.x + i.y * 157.0 + i.z * 113.0;\n        vec4 v = fract(sin(vec4(n, n+1.0, n+157.0, n+158.0)) * 43758.5453);\n        return mix(mix(v.x, v.y, f.x), mix(v.z, v.w, f.x), f.y);\n    }\n\n    void main() {\n        // Drifting energy clouds - slow, ethereal movement\n        // Start with zero energy - only effects add to it\n        float driftEnergy = 0.0;\n        float crossWaveEnergy = 0.0;\n\n        // Spatially triangulated fire bands - each owns a 120 wedge of the geometry\n        // Bands can never overlap because they're physically separated\n        float angle = atan(vPosition.x, vPosition.z); // - to \n        float normalizedAngle = (angle + 3.14159) / 6.28318; // 0 to 1\n\n        // Determine which zone this fragment belongs to (0, 1, or 2)\n        float zone = floor(normalizedAngle * 3.0);\n        float zonePos = fract(normalizedAngle * 3.0); // Position within zone (0-1)\n\n        // Time-based phase for each zone (120 offset in time)\n        float phaseSpeed = 0.15;\n        float t = time * phaseSpeed;\n        float phase1Time = sin(t + phaseOffset1) * 0.5 + 0.5;\n        float phase2Time = sin(t + phaseOffset2) * 0.5 + 0.5;\n        float phase3Time = sin(t + phaseOffset3) * 0.5 + 0.5;\n\n        // Only ONE phase affects this fragment - the one that owns this spatial zone\n        float activePhase = zone < 1.0 ? phase1Time : (zone < 2.0 ? phase2Time : phase3Time);\n\n        float primaryDrift = 0.0;\n        float secondaryDrift = 0.0;\n\n        if (driftEnabled > 0.5) {\n            float t = time * driftSpeed;\n            // OPTIMIZED: Reduced from 4 noise calls to 2 for better performance\n            // Primary drift - single noise call with combined coordinates\n            float drift1 = noise3D(vPosition * 2.0 + vec3(t, t * 0.7, t * 0.3));\n            primaryDrift = max(0.0, drift1 - 0.3) * 1.5; // Adjusted threshold for single noise\n\n            // Secondary drift - offset phase to fill gaps\n            float drift2 = noise3D(vPosition * 2.5 - vec3(t * 0.6, t * 0.4, t));\n            secondaryDrift = max(0.0, drift2 - 0.3) * 1.5;\n\n            driftEnergy = primaryDrift + secondaryDrift;\n        }\n\n        // Horizontal cross wave - thin bands sweeping across\n        float rawCrossWave = 0.0;\n        if (crossWaveEnabled > 0.5) {\n            float t = time * crossWaveSpeed;\n            float wave = sin(vPosition.x * 4.0 + vPosition.z * 2.0 - t) * 0.5 + 0.5;\n            // pow(4) for thin bright bands\n            rawCrossWave = pow(wave, 4.0);\n            crossWaveEnergy = rawCrossWave;\n        }\n\n        // Mix the effects - normalize to prevent blowout\n        // driftEnergy can be 0-2 (two drifts), rawCrossWave is 0-1\n        float normalizedDrift = min(1.0, driftEnergy * 0.5);\n        float normalizedWave = rawCrossWave;\n\n        // activePhase is 0-1, remap to visibility range\n        // 0.53 floor (just above 0.52 threshold), 0.58 ceiling (subtle glow)\n        float remappedPhase = 0.53 + activePhase * 0.05;\n\n        // Effects add subtle variation (max 0.05)\n        float effectContrib = (normalizedDrift * 0.03) + (normalizedWave * 0.02);\n        float phasedActivity = remappedPhase + effectContrib;\n\n        // Keep unclamped for visibility threshold check (ghost mode needs full range)\n        float rawEffectActivity = phasedActivity;\n        // Clamp for color intensity (floor: guaranteed visible, ceiling: no blowout)\n        float effectActivity = clamp(phasedActivity, 0.53, 0.60);\n\n        // Total energy for color calculation (reduced for subtler bloom)\n        float totalEnergy = 0.25 + effectActivity * 0.55; // Base glow + effect contribution\n\n        // Edge glow - adds rim lighting\n        vec3 viewDir = normalize(-vPosition);\n        float edgeGlow = 1.0 - abs(dot(vNormal, viewDir));\n        edgeGlow = pow(edgeGlow, 2.0) * 0.4;\n\n        // Final color before blend layers\n        vec3 coreColor = emotionColor * totalEnergy * energyIntensity;\n        coreColor += emotionColor * edgeGlow * 0.3;\n\n        // Apply blend layers to the entire soul color\n        if (blendLayer1Enabled > 0.5) {\n            int mode = int(blendLayer1Mode + 0.5);\n            vec3 blendResult = applyBlendMode(coreColor, emotionColor * blendLayer1Strength, mode);\n            coreColor = mix(coreColor, blendResult, blendLayer1Strength);\n        }\n        if (blendLayer2Enabled > 0.5) {\n            int mode = int(blendLayer2Mode + 0.5);\n            vec3 blendResult = applyBlendMode(coreColor, emotionColor * blendLayer2Strength, mode);\n            coreColor = mix(coreColor, blendResult, blendLayer2Strength);\n        }\n\n        // Ghost mode: ONLY the traveling fire bands are visible\n        // Everything below the threshold is completely invisible\n        float alpha = baseOpacity;\n        if (ghostMode > 0.01) {\n            // High threshold - only the peaks of the thin bands pass through\n            float threshold = 0.4 + ghostMode * 0.4; // 0.4-0.8 range\n            float visibility = smoothstep(threshold, threshold + 0.05, rawEffectActivity);\n\n            // Hard cutoff - only bright fire bands visible\n            alpha = visibility * baseOpacity;\n\n            // Discard everything that isn't a bright fire band\n            if (alpha < 0.05) {\n                discard;\n            }\n\n            // Boost color intensity for visible fire\n            coreColor *= 1.2 + visibility * 0.6;\n        }\n\n        // Output the computed core color\n        gl_FragColor = vec4(coreColor, alpha);\n    }\n`;class sM{constructor(t={}){this.radius=t.radius||.15,this.detail=t.detail||1,this.geometryType=t.geometryType||"crystal",this.renderer=t.renderer||null,this.assetBasePath=t.assetBasePath||"/assets",this.mesh=null,this.material=null,this.parentMesh=null,this.baseScale=1,this._pendingParent=null,this._disposed=!1,this._createMesh()}static _loadInclusionGeometry(t="/assets"){return eM?Promise.resolve(eM.clone()):iM?iM.then(t=>t.clone()):(iM=new Promise(e=>{(new hm).load(`${t}/models/Crystal/inclusion.obj`,t=>{let i=null;if(t.traverse(t=>{t.isMesh&&t.geometry&&({geometry:i}=t)}),i){i.computeBoundingBox();const t=new qe;i.boundingBox.getCenter(t),i.translate(-t.x,-t.y,-t.z),i.rotateX(Math.PI/2),i.computeBoundingBox();const n=new qe;i.boundingBox.getSize(n);const s=.3/Math.max(n.x,n.y,n.z);i.scale(s,s,s),i.computeVertexNormals(),eM=i,e(i.clone())}else console.warn("[ SOUL] No mesh in inclusion.obj, using fallback"),e(null)},void 0,t=>{console.warn("[ SOUL] Failed to load inclusion.obj:",t),e(null)})}),iM)}_createMesh(){let t;this.material=new Cs({uniforms:{time:{value:0},emotionColor:{value:new zn(1,1,1)},energyIntensity:{value:.8},driftEnabled:{value:1},driftSpeed:{value:.5},crossWaveEnabled:{value:1},crossWaveSpeed:{value:.4},ghostMode:{value:.36},baseOpacity:{value:1},phaseOffset1:{value:0},phaseOffset2:{value:2.094},phaseOffset3:{value:4.189},blendLayer1Mode:{value:2},blendLayer1Strength:{value:2.3},blendLayer1Enabled:{value:1},blendLayer2Mode:{value:0},blendLayer2Strength:{value:1},blendLayer2Enabled:{value:1}},vertexShader:"\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n\n    void main() {\n        vPosition = position;\n        vNormal = normalize(normalMatrix * normal);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n",fragmentShader:nM,transparent:!0,depthWrite:!0,depthTest:!0,side:0}),t=eM?eM.clone():new Zo(this.radius,this.detail),this.mesh=new bs(t,this.material),this.mesh.name="crystalSoul",this.mesh.renderOrder=0,this.mesh.layers.set(2)}attachTo(t,e){this._disposed||(t?this.mesh?(this.mesh.parent&&this.mesh.parent.remove(this.mesh),this.parentMesh=t,this._scene=e,e&&!this.mesh.parent&&e.add(this.mesh),this._syncPosition(),this.mesh.visible=!0):console.warn("[CrystalSoul] Cannot attach - mesh is null"):console.warn("[CrystalSoul] Cannot attach to null parent"))}_syncPosition(){this.parentMesh&&this.mesh&&(this.parentMesh.getWorldPosition(this.mesh.position),this.parentMesh.getWorldQuaternion(this.mesh.quaternion))}detach(){this.mesh&&(this.mesh.visible=!1,this.parentMesh=null)}update(t,e,i=1){if(!this.material||!this.material.uniforms)return;this._syncPosition();const{uniforms:n}=this.material;if(n.time&&(n.time.value+=t/1e3),n.emotionColor&&e){const t=n.emotionColor.value;t.r===e[0]&&t.g===e[1]&&t.b===e[2]||t.setRGB(e[0],e[1],e[2])}this.mesh&&this.mesh.scale.setScalar(this.baseScale*i)}setSize(t){if(!this.mesh)return;const e=.05+.95*t;this.baseScale=e,this.mesh.scale.setScalar(e)}setEffects(t={}){if(!this.material||!this.material.uniforms)return;const{uniforms:e}=this.material;void 0!==t.driftEnabled&&e.driftEnabled&&(e.driftEnabled.value=t.driftEnabled?1:0),void 0!==t.driftSpeed&&e.driftSpeed&&(e.driftSpeed.value=Math.max(.1,Math.min(3,t.driftSpeed))),void 0!==t.crossWaveEnabled&&e.crossWaveEnabled&&(e.crossWaveEnabled.value=t.crossWaveEnabled?1:0),void 0!==t.crossWaveSpeed&&e.crossWaveSpeed&&(e.crossWaveSpeed.value=Math.max(.1,Math.min(3,t.crossWaveSpeed))),void 0!==t.phaseOffset1&&e.phaseOffset1&&(e.phaseOffset1.value=t.phaseOffset1),void 0!==t.phaseOffset2&&e.phaseOffset2&&(e.phaseOffset2.value=t.phaseOffset2),void 0!==t.phaseOffset3&&e.phaseOffset3&&(e.phaseOffset3.value=t.phaseOffset3)}setColor(t){this.material&&this.material.uniforms&&this.material.uniforms.emotionColor&&this.material.uniforms.emotionColor.value.setRGB(t[0],t[1],t[2])}setBlendLayers(t){if(!this.material||!this.material.uniforms)return;const e=this.material.uniforms;t[0]?(e.blendLayer1Mode&&(e.blendLayer1Mode.value=t[0].mode??0),e.blendLayer1Strength&&(e.blendLayer1Strength.value=t[0].strength??0),e.blendLayer1Enabled&&(e.blendLayer1Enabled.value=t[0].enabled?1:0)):e.blendLayer1Enabled&&(e.blendLayer1Enabled.value=0),t[1]?(e.blendLayer2Mode&&(e.blendLayer2Mode.value=t[1].mode??0),e.blendLayer2Strength&&(e.blendLayer2Strength.value=t[1].strength??0),e.blendLayer2Enabled&&(e.blendLayer2Enabled.value=t[1].enabled?1:0)):e.blendLayer2Enabled&&(e.blendLayer2Enabled.value=0)}isAttached(){return null!==this.parentMesh&&null!==this.mesh&&null!==this.mesh.parent}setVisible(t){this.mesh&&(this.mesh.visible=t)}setGhostMode(t){this.material&&this.material.uniforms&&this.material.uniforms.ghostMode&&(this.material.uniforms.ghostMode.value=t?1:0)}setBaseOpacity(t){this.material&&this.material.uniforms&&this.material.uniforms.baseOpacity&&(this.material.uniforms.baseOpacity.value=Math.max(0,Math.min(1,t)))}dispose(){if(this._disposed)return;this._disposed=!0;const t=this.mesh,e=this.material;t?.parent&&t.parent.remove(t),t&&(t.visible=!1),this.mesh=null,this.material=null,this.parentMesh=null,requestAnimationFrame(()=>{t?.geometry&&t.geometry.dispose(),e&&e.dispose()})}}class aM{constructor(t=50,e={}){this.maxParticles=t,this.options=e,this.geometry=null,this.material=null,this.points=null,this.positions=null,this.sizes=null,this.colors=null,this.alphas=null,this.glowIntensities=null,this.depths=null,this.styles=null,this.particleCount=0,this.gestureEffects={firefly:!1,flicker:!1,shimmer:!1,glow:!1,time:0},this._initGeometry(),this._initMaterial(),this._initPoints()}_initGeometry(){this.geometry=new os;const{maxParticles:t}=this;this.positions=new Float32Array(3*t),this.sizes=new Float32Array(t),this.colors=new Float32Array(3*t),this.alphas=new Float32Array(t),this.glowIntensities=new Float32Array(t),this.depths=new Float32Array(t),this.styles=new Float32Array(t),this.geometry.setAttribute("position",new Zn(this.positions,3)),this.geometry.setAttribute("size",new Zn(this.sizes,1)),this.geometry.setAttribute("customColor",new Zn(this.colors,3)),this.geometry.setAttribute("alpha",new Zn(this.alphas,1)),this.geometry.setAttribute("glowIntensity",new Zn(this.glowIntensities,1)),this.geometry.setAttribute("depth",new Zn(this.depths,1)),this.geometry.setAttribute("style",new Zn(this.styles,1)),this.geometry.attributes.position.setUsage(ve),this.geometry.attributes.size.setUsage(ve),this.geometry.attributes.customColor.setUsage(ve),this.geometry.attributes.alpha.setUsage(ve),this.geometry.attributes.glowIntensity.setUsage(ve),this.geometry.attributes.depth.setUsage(ve),this.geometry.attributes.style.setUsage(ve),this.geometry.setDrawRange(0,0)}_initMaterial(){this.material=new Cs({uniforms:{coreScale:{value:1},viewportHeight:{value:600},pixelRatio:{value:1}},vertexShader:"\n/**\n * Particle Vertex Shader - Simple 2D-style particles in 3D space\n * Matches the 2D canvas particle appearance\n */\n\n// Per-particle attributes\nattribute float size;\nattribute vec3 customColor;\nattribute float alpha;\nattribute float glowIntensity;\nattribute float style;  // 0.0 = solid/gradient, 1.0 = cell-shaded (ring with transparent center)\n\n// Uniforms\nuniform float coreScale;\nuniform float viewportHeight;\nuniform float pixelRatio;\n\n// Varying to fragment shader\nvarying vec3 vColor;\nvarying float vAlpha;\nvarying float vGlowIntensity;\nvarying float vStyle;\n\nvoid main() {\n    // Pass attributes to fragment shader\n    vColor = customColor;\n    vAlpha = alpha;\n    vGlowIntensity = glowIntensity;\n    vStyle = style;\n\n    // Calculate position in clip space\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n    // Calculate point size with perspective scaling\n    float perspectiveScale = coreScale * (75.0 / length(mvPosition.xyz)) * (viewportHeight / 600.0) / pixelRatio;\n    gl_PointSize = size * perspectiveScale;\n\n    // Final position\n    gl_Position = projectionMatrix * mvPosition;\n}\n",fragmentShader:"\n/**\n * Particle Fragment Shader - Solid colored circles matching 2D appearance\n * Uses premultiplied alpha for proper blending\n */\n\nvarying vec3 vColor;\nvarying float vAlpha;\nvarying float vGlowIntensity;\nvarying float vStyle;\n\nvoid main() {\n    // Distance from center (0 at center, 0.5 at edge)\n    vec2 center = gl_PointCoord - vec2(0.5);\n    float dist = length(center);\n\n    // Hard circle cutoff - discard everything outside\n    if (dist > 0.45) {\n        discard;\n    }\n\n    vec3 finalColor = vColor;\n\n    // Base opacity from particle (already includes baseOpacity variation)\n    float alpha = vAlpha;\n\n    // Gesture glow boost\n    if (vGlowIntensity >= 2.0) {\n        float gestureBoost = (vGlowIntensity - 2.0) / 13.0;\n        finalColor *= (1.0 + gestureBoost * 0.5);\n        alpha = min(alpha * (1.0 + gestureBoost * 0.3), 1.0);\n    }\n\n    // Cell-shaded particles are slightly more opaque\n    float opacityBoost = vStyle > 0.5 ? 1.0 : 0.85;\n    alpha *= opacityBoost;\n\n    // Output with proper alpha for blending\n    // Premultiply alpha for correct compositing\n    gl_FragColor = vec4(finalColor * alpha, alpha);\n}\n",transparent:!0,blending:5,blendSrc:c,blendDst:m,blendSrcAlpha:c,blendDstAlpha:m,depthWrite:!1,depthTest:!0})}_initPoints(){this.points=new Pr(this.geometry,this.material),this.points.frustumCulled=!0}updateParticles(t,e,i,n,s,a,r,o,l){this.particleCount=Math.min(t.length,this.maxParticles),void 0!==o&&(this.material.uniforms.coreScale.value=o),n&&n.height&&(this.material.uniforms.viewportHeight.value=n.height),this.options.renderer&&(this.material.uniforms.pixelRatio.value=this.options.renderer.getPixelRatio()),this.gestureEffects.time+=.016,this.gestureEffects.time>2*Math.PI&&(this.gestureEffects.time=this.gestureEffects.time%(2*Math.PI)),s&&a&&e.updateRotationState(s,a,r);for(let s=0;s<this.particleCount;s++){const a=t[s];if(!a.isAlive()){this.alphas[s]=0;continue}const r=e.translate2DTo3D(a,i,n);if(("crystal"===l||"heart"===l||"rough"===l)&&r.z>.15){this.alphas[s]=0;continue}const o=3*s;this.positions[o+0]=r.x,this.positions[o+1]=r.y,this.positions[o+2]=r.z;const h=a.getDepthAdjustedSize?a.getDepthAdjustedSize():a.size,c="popcorn"===a.behavior?1.2:.85;this.sizes[s]=h*c;const u=this._parseColor(a.color||"#ffffff"),d=3*s;this.colors[d+0]=u.r,this.colors[d+1]=u.g,this.colors[d+2]=u.b,this.alphas[s]=a.opacity*(a.baseOpacity||1);let p=a.hasGlow?1*(a.glowSizeMultiplier||1.5):0;p=this._applyGestureEffects(a,p,s),this.glowIntensities[s]=p;const m=.5*(1-a.z);this.depths[s]=Math.max(0,Math.min(1,m)),this.styles[s]=a.isCellShaded?1:0}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.size.needsUpdate=!0,this.geometry.attributes.customColor.needsUpdate=!0,this.geometry.attributes.alpha.needsUpdate=!0,this.geometry.attributes.glowIntensity.needsUpdate=!0,this.geometry.attributes.depth.needsUpdate=!0,this.geometry.attributes.style.needsUpdate=!0,this.geometry.setDrawRange(0,this.particleCount)}_applyGestureEffects(t,e,i){let n=e;if(this.gestureEffects.firefly){const e=(.01*t.x+.01*t.y+.1*t.size)%(2*Math.PI),i=2+.5*(Math.sin(3*this.gestureEffects.time+e)+1)*10;n=Math.max(n,i)}if(this.gestureEffects.flicker){const e=(.02*t.x+.02*t.y)%(2*Math.PI),s=15*this.gestureEffects.time,a=.5*(Math.sin(s+e)+1),r=Math.floor(10*s+i),o=2+10*(.3*a+.5*(Math.sin(123.456*r)+1)*.7);n=Math.max(n,o)}if(this.gestureEffects.shimmer){const e=t.x-(this.gestureEffects.centerX||0),i=t.y-(this.gestureEffects.centerY||0),s=Math.sqrt(e*e+i*i)/200,a=2+.5*(Math.sin(3*this.gestureEffects.time-s)+1)*8;n=Math.max(n,a)}if(this.gestureEffects.glow){const t=this.gestureEffects.glowProgress||0,e=3+12*Math.sin(t*Math.PI);n=Math.max(n,e)}return n}_parseColor(t){const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return e?{r:parseInt(e[1],16)/255,g:parseInt(e[2],16)/255,b:parseInt(e[3],16)/255}:{r:1,g:1,b:1}}setGestureEffects(t){if(!t)return this.gestureEffects.firefly=!1,this.gestureEffects.flicker=!1,this.gestureEffects.shimmer=!1,void(this.gestureEffects.glow=!1);this.gestureEffects.firefly=t.fireflyEffect||!1,this.gestureEffects.flicker=t.flickerEffect||!1,this.gestureEffects.shimmer=t.shimmerEffect||!1,this.gestureEffects.glow=t.glowEffect||!1,this.gestureEffects.glowProgress=t.glowProgress,this.gestureEffects.centerX=t.centerX,this.gestureEffects.centerY=t.centerY}getPoints(){return this.points}setVisible(t){this.points.visible=t}resize(t){t!==this.maxParticles&&(this.geometry&&this.geometry.dispose(),this.maxParticles=t,this._initGeometry(),this.points&&(this.points.geometry=this.geometry))}cleanupParticleStates(t){for(const e of t)!e.isAlive()&&e.behaviorData&&(e.behaviorData.direction3D&&(e.behaviorData.direction3D=null),e.behaviorData.orbitPlane&&(e.behaviorData.orbitPlane=null),e.behaviorData.orbitPath&&(e.behaviorData.orbitPath=null),e.behaviorData=null)}dispose(){this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose(),this.positions=null,this.sizes=null,this.colors=null,this.alphas=null,this.glowIntensities=null,this.depths=null,this.styles=null}}class rM{constructor(){this.cachedConfigs=new Map,this.maxCacheSize=100}calculate(t,e=null){const i=`${t}:${e||"none"}`;if(this.cachedConfigs.has(i))return this.cachedConfigs.get(i);const n=Km(t);if(!n)return console.warn(`[ParticleEmotionCalculator] Unknown emotion: ${t}`),this._getDefaultConfig();const s=this._extractBaseConfig(n,t),a=this._applyUndertoneModifiers(s,e),r=this._applySpecialBehaviors(a,t);if(this.cachedConfigs.size>=this.maxCacheSize){const t=this.cachedConfigs.keys().next().value;this.cachedConfigs.delete(t)}return this.cachedConfigs.set(i,r),r}_extractBaseConfig(t,e){const i=t.visual||{};return{behavior:i.particleBehavior||"ambient",rate:i.particleRate||1,min:void 0!==i.minParticles?i.minParticles:0,max:void 0!==i.maxParticles?i.maxParticles:10,colors:i.particleColors||null,emotion:e}}_applyUndertoneModifiers(t,e){if(!e)return t;const i=dg(e);if(!i||!i.particles)return t;const n=i.particles,s={...t};return n.behaviorOverride&&(s.behavior=n.behaviorOverride),n.rateMultiplier&&(s.rate=t.rate*n.rateMultiplier,s.max=Math.floor(t.max*n.rateMultiplier)),void 0!==n.minParticles&&(s.min=n.minParticles),void 0!==n.maxParticles&&(s.max=n.maxParticles),s}_applySpecialBehaviors(t,e){return"zen"===e?{...t,specialBehavior:"zen-mixing"}:t}selectZenBehavior(){return Math.random()<.6?"falling":"orbiting"}_getDefaultConfig(){return{behavior:"ambient",rate:1,min:0,max:10,colors:null,emotion:"neutral"}}clearCache(){this.cachedConfigs.clear()}getCacheSize(){return this.cachedConfigs.size}}class oM{constructor(){this.previousGesture=null}extract(t,e){if(!t||0===t.length)return this.previousGesture=null,null;const i=t[0],n=this._calculateProgress(i,e);if(n>=1)return this.previousGesture=null,null;const s=this._extractGestureName(i);if(!s)return null;const a=this._buildGestureMotion(i,s);return this.previousGesture=s,{motion:a,progress:n,config:i.config||{},gestureName:s,animation:i}}_calculateProgress(t,e){const i=(e-t.startTime)/t.duration;return Math.max(0,Math.min(1,i))}_extractGestureName(t){return t.gestureName||t.name||t.config?.gestureName||null}_buildGestureMotion(t,e){const i=t.config||{};return{type:e,amplitude:i.amplitude||1,strength:i.strength||1,wobbleAmount:i.wobbleAmount||0,duration:t.duration}}hasGestureChanged(t){return!(!t&&!this.previousGesture||(t||!this.previousGesture)&&(!t||this.previousGesture)&&t.gestureName===this.previousGesture)}extractAll(t,e){if(!t||0===t.length)return[];const i=[];for(const n of t){const t=this._calculateProgress(n,e);if(t>=1)continue;const s=this._extractGestureName(n);if(!s)continue;const a=this._buildGestureMotion(n,s);i.push({motion:a,progress:t,config:n.config||{},gestureName:s,animation:n})}return i}reset(){this.previousGesture=null}}class lM{constructor(){this.effectMap={sparkle:this.buildFireflyEffect.bind(this),twinkle:this.buildFireflyEffect.bind(this),flicker:this.buildFlickerEffect.bind(this),shimmer:this.buildShimmerEffect.bind(this),glow:this.buildGlowEffect.bind(this),burst:this.buildGlowEffect.bind(this),flash:this.buildFlickerEffect.bind(this)}}build(t,e,i){if(!t||!t.motion)return null;const{gestureName:n}=t,s=this.effectMap[n];return s?s(t,e,i):null}buildFireflyEffect(t,e,i){const n=t.config||{};return{fireflyEffect:!0,fireflyTime:.001*Date.now(),particleGlow:n.particleGlow||2,centerX:e,centerY:i}}buildFlickerEffect(t,e,i){const n=t.config||{};return{flickerEffect:!0,flickerTime:.001*Date.now(),particleGlow:n.particleGlow||2,centerX:e,centerY:i}}buildShimmerEffect(t,e,i){const n=t.config||{},s=t.progress||0;return{shimmerEffect:!0,shimmerTime:.001*Date.now(),shimmerWave:s*Math.PI*2,particleGlow:n.particleGlow||1.2,centerX:e,centerY:i}}buildGlowEffect(t,e,i){const n=t.config||{};return{glowEffect:!0,glowProgress:t.progress||0,particleGlow:n.particleGlow||2,centerX:e,centerY:i}}registerEffect(t,e){this.effectMap[t]=e.bind(this)}hasEffect(t){return!!this.effectMap[t]}getEffectGestures(){return Object.keys(this.effectMap)}buildAll(t,e,i){if(!t||0===t.length)return[];const n=[];for(const s of t){const t=this.build(s,e,i);t&&n.push(t)}return n}mergeEffects(t){if(!t||0===t.length)return null;if(1===t.length)return t[0];const e={};for(const i of t)Object.assign(e,i);return e}destroy(){this.effectMap=null}}class hM{constructor(t,e,i){this.particleSystem=t,this.translator=e,this.renderer=i,this.emotionCalculator=new rM,this.gestureExtractor=new oM,this.effectsBuilder=new lM,this.currentEmotion=null,this.currentUndertone=null,this.currentConfig=null}update(t,e,i,n,s,a,r,o,l,h){void 0!==h&&this.translator.setCoreRadius3D(h);const c=this._updateEmotionConfig(e,i),u=this.gestureExtractor.extract(n,s);this._spawnParticles(c,t,r),this._updatePhysics(c,u,t,r,i),this._updateRendering(u,a,r,o,t,l)}_updateEmotionConfig(t,e){return this.currentEmotion===t&&this.currentUndertone===e||(this.currentEmotion=t,this.currentUndertone=e,this.currentConfig=this.emotionCalculator.calculate(t,e),this.particleSystem.clear()),this.currentConfig}_spawnParticles(t,e,i){const n=i.width/2,s=i.height/2;let a=t.behavior;"zen-mixing"===t.specialBehavior&&(a=this.emotionCalculator.selectZenBehavior()),this.particleSystem.spawn(a,t.emotion,t.rate,n,s,e,null,t.min,t.max,1,1,t.colors,this.currentUndertone)}_updatePhysics(t,e,i,n,s){const a=n.width/2,r=n.height/2,o=s?{undertone:s}:null;this.particleSystem.update(i,a,r,e?e.motion:null,e?e.progress:0,o)}_updateRendering(t,e,i,n,s,a){const r=i.width/2,o=i.height/2,l=t?this.effectsBuilder.build(t,r,o):null;this.renderer.updateParticles(this.particleSystem.particles,this.translator,e,i,n,s,t,a,this.geometryType),this.renderer.setGestureEffects(l)}setEmotion(t,e=null){this.currentEmotion=null,this.currentUndertone=null}setGeometryType(t){this.geometryType=t}clear(){this.particleSystem.clear()}setEnabled(t){this.renderer.setVisible(t),t||this.clear()}getParticleCount(){return this.particleSystem.particles.length}getCurrentConfig(){return this.currentConfig}registerEffect(t,e){this.effectsBuilder.registerEffect(t,e)}destroy(){this.particleSystem.destroy(),this.renderer.dispose(),this.translator&&(this.translator.dispose?.(),this.translator=null),this.emotionCalculator.clearCache(),this.emotionCalculator=null,this.gestureExtractor.reset(),this.gestureExtractor=null,this.effectsBuilder&&(this.effectsBuilder.destroy?.(),this.effectsBuilder=null)}}const cM={quartz:{sssStrength:.8,sssAbsorption:[2.8,2.9,3],sssScatterDistance:[.2,.2,.25],sssThicknessBias:.6,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.12,frostiness:.15,innerGlowStrength:.2,fresnelIntensity:1.5,causticIntensity:1.2},emerald:{sssStrength:2,sssAbsorption:[.05,4,.1],sssScatterDistance:[.1,.5,.1],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.2,innerGlowStrength:.15,fresnelIntensity:1.2,emotionColorBleed:.35},ruby:{sssStrength:1.8,sssAbsorption:[4,.03,.08],sssScatterDistance:[.4,.04,.08],sssThicknessBias:.65,sssThicknessScale:1.9,sssCurvatureScale:2.5,sssAmbient:.08,frostiness:.12,innerGlowStrength:.12,fresnelIntensity:1.2,causticIntensity:1.15,emotionColorBleed:.35},sapphire:{sssStrength:2.2,sssAbsorption:[.15,.4,4],sssScatterDistance:[.1,.15,.5],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.18,innerGlowStrength:.15,fresnelIntensity:1.3,emotionColorBleed:.35},amethyst:{sssStrength:2.5,sssAbsorption:[3,.05,4.5],sssScatterDistance:[.4,.05,.5],sssThicknessBias:.7,sssThicknessScale:2,sssCurvatureScale:3,sssAmbient:.08,frostiness:.18,innerGlowStrength:.12,fresnelIntensity:1.4,emotionColorBleed:.35}},uM="\n// \n// DEFORMATION UNIFORMS - Localized vertex displacement for impacts\n// \nuniform float deformationStrength;  // 0-2+ (intensity of dent)\nuniform vec3 impactPoint;           // Impact position in MESH-LOCAL space\n                                    // Transformed by JS to account for camera direction\nuniform float deformationFalloff;   // Radius of influence (0.1-0.5 typical)\n",dM={deformationStrength:0,impactPoint:[0,0,0],deformationFalloff:.5},pM=`\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n${uM}\n\n\n// \n// DEFORMATION - Localized dent toward mesh center\n// \n\nvec3 calculateDeformation(vec3 pos) {\n    if (deformationStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Distance from this vertex to the impact point (both in mesh-local space)\n    float dist = length(pos - impactPoint);\n\n    // Falloff: 1.0 at impact point, 0.0 at falloff radius\n    // Use squared falloff for sharper edges\n    float t = dist / max(deformationFalloff, 0.001);\n    float falloff = max(0.0, 1.0 - t * t);\n\n    // Direction: push vertex INWARD toward mesh center\n    vec3 inward = -normalize(pos + vec3(0.0001));\n\n    // Depth of dent\n    float depth = deformationStrength * 0.15 * falloff;\n\n    return inward * depth;\n}\n\n\nvoid main() {\n    vUv = uv;\n\n    // Apply deformation to position (impactPoint pre-transformed by JS for tidal locking)\n    vec3 deformedPosition = position + calculateDeformation(position);\n\n    vPosition = deformedPosition;\n    vNormal = normalize(normalMatrix * normal);\n\n    vec4 mvPosition = modelViewMatrix * vec4(deformedPosition, 1.0);\n    vViewPosition = -mvPosition.xyz;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n`,mM=`\nuniform float time;\nuniform vec3 emotionColor;\nuniform float glowIntensity;\nuniform float opacity;\n\n// Crystal appearance controls\nuniform float frostiness;        // 0 = clear glass, 1 = fully frosted (default: 0.7)\nuniform float fresnelPower;      // Edge brightness falloff (default: 3.0)\nuniform float fresnelIntensity;  // Edge brightness strength (default: 1.2)\nuniform float innerGlowStrength; // How much inner soul shows through (default: 0.8)\nuniform float surfaceRoughness;  // Surface texture variation (default: 0.3)\n\n// Enhanced lighting controls\nuniform float shadowDarkness;     // How dark shadows can get (0-1, default: 0.4)\nuniform float specularIntensity;  // Edge highlight brightness (default: 0.8)\nuniform float specularPower;      // Specular falloff sharpness (default: 32.0)\nuniform float transmissionContrast; // Thin/thick brightness ratio (default: 1.5)\nuniform float minBrightness;      // Minimum brightness floor (default: 0.05)\n\n// Noise scale controls\nuniform float surfaceNoiseScale;  // Scale of surface frost pattern (default: 1.5)\nuniform float noiseFrequency;     // Frequency of hash noise pattern (default: 1.0)\n\n// Internal caustics - light pooling inside the gem\nuniform float causticIntensity;   // Brightness of internal caustics (default: 0.4)\nuniform float causticScale;       // Scale of caustic pattern (default: 3.0)\nuniform float causticSpeed;       // Animation speed of caustics (default: 0.15)\n\n// Texture\nuniform sampler2D crystalTexture;\nuniform float textureStrength;    // How much texture affects appearance (default: 0.5)\n\n// Soul refraction - samples soul rendered to texture with optical distortion\nuniform sampler2D soulTexture;    // Soul mesh rendered to texture\nuniform vec2 resolution;          // Screen resolution for UV calculation\nuniform vec2 soulTextureSize;     // Soul render target size (may differ from screen)\nuniform vec2 soulScreenCenter;    // Soul center projected to screen UV (0-1 range)\nuniform float refractionIndex;    // Index of refraction (1.5 glass, 2.4 diamond)\nuniform float refractionStrength; // Distortion magnitude (0.1-0.5)\n\n// Physically-based subsurface scattering\nuniform float sssStrength;            // Overall SSS intensity (0-1)\nuniform vec3 sssAbsorption;           // Absorption coefficients per RGB channel\nuniform vec3 sssScatterDistance;      // Mean free path / scatter radius per RGB\nuniform float sssThicknessBias;       // Thickness offset (0-1)\nuniform float sssThicknessScale;      // Thickness multiplier\nuniform float sssCurvatureScale;      // How much curvature affects SSS\nuniform float sssAmbient;             // Ambient SSS contribution\nuniform vec3 sssLightDir;             // Primary light direction for SSS\nuniform vec3 sssLightColor;           // Light color for SSS\n\n// Emotion color bleed - how much soul color tints the gem material\nuniform float emotionColorBleed;      // 0 = gem color only, 1 = full emotion tint (default: 0.0)\n\n// Component-specific blend layers\n// Shell layers - affect the frosted crystal shell\nuniform float shellLayer1Mode;\nuniform float shellLayer1Strength;\nuniform float shellLayer1Enabled;\nuniform float shellLayer2Mode;\nuniform float shellLayer2Strength;\nuniform float shellLayer2Enabled;\n\n// Soul layers - affect the inner glowing soul color\nuniform float soulLayer1Mode;\nuniform float soulLayer1Strength;\nuniform float soulLayer1Enabled;\nuniform float soulLayer2Mode;\nuniform float soulLayer2Strength;\nuniform float soulLayer2Enabled;\n\n// Rim layers - affect the fresnel rim glow\nuniform float rimLayer1Mode;\nuniform float rimLayer1Strength;\nuniform float rimLayer1Enabled;\nuniform float rimLayer2Mode;\nuniform float rimLayer2Strength;\nuniform float rimLayer2Enabled;\n\n// SSS layers - affect subsurface scattering contribution\nuniform float sssLayer1Mode;\nuniform float sssLayer1Strength;\nuniform float sssLayer1Enabled;\nuniform float sssLayer2Mode;\nuniform float sssLayer2Strength;\nuniform float sssLayer2Enabled;\n\n${uM}\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n// \n// NOISE FUNCTIONS for surface variation and frosted effect\n// \n\n// Simple 3D noise for frosted surface\nfloat hash(vec3 p) {\n    p = p * noiseFrequency;  // Apply frequency control\n    p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat noise3D(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // Smoothstep\n\n    float n = mix(\n        mix(\n            mix(hash(i), hash(i + vec3(1, 0, 0)), f.x),\n            mix(hash(i + vec3(0, 1, 0)), hash(i + vec3(1, 1, 0)), f.x),\n            f.y\n        ),\n        mix(\n            mix(hash(i + vec3(0, 0, 1)), hash(i + vec3(1, 0, 1)), f.x),\n            mix(hash(i + vec3(0, 1, 1)), hash(i + vec3(1, 1, 1)), f.x),\n            f.y\n        ),\n        f.z\n    );\n    return n;\n}\n\n// Fractal Brownian Motion for natural-looking frosted texture\nfloat fbm(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 3; i++) {\n        value += amplitude * noise3D(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// \n// BLEND MODES (from universal library)\n// \n${cm}\n\n// \n// ENHANCED LIGHTING FUNCTIONS\n// \n\n// Calculate ambient occlusion from geometry\nfloat calculateAO(vec3 normal, vec3 viewDir, vec3 position) {\n    // Faces pointing away from view are in shadow\n    float viewAO = max(0.0, dot(normal, viewDir));\n\n    // Use light direction for directional shadow instead of gravity\n    // This creates shadows on the side away from light\n    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8)); // Match sssLightDir default\n    float lightAO = dot(normal, lightDir) * 0.5 + 0.5;\n\n    // Combine AO factors - no gravity term\n    return viewAO * 0.5 + lightAO * 0.5;\n}\n\n// Calculate specular highlights on facet edges\nfloat calculateFacetSpecular(vec3 normal, vec3 viewDir, vec3 lightDir, float power) {\n    // Detect facet edges from normal discontinuities\n    float edgeDetect = length(fwidth(normal)) * 15.0;\n    edgeDetect = smoothstep(0.1, 0.5, edgeDetect);\n\n    // Standard Blinn-Phong specular\n    vec3 halfVec = normalize(lightDir + viewDir);\n    float specular = pow(max(0.0, dot(normal, halfVec)), power);\n\n    // Boost specular on edges\n    specular += edgeDetect * 0.5;\n\n    return specular;\n}\n\n// Calculate "fire" - intense sparkle points that real gems exhibit\n// These are concentrated, view-dependent highlights from light dispersion\nfloat calculateFire(vec3 normal, vec3 viewDir, vec3 lightDir) {\n    // Primary fire highlight - VERY sharp falloff for pinpoint sparkles\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float fire1 = pow(max(0.0, dot(reflectDir, viewDir)), 512.0);\n\n    // Secondary fire from different light angle (simulates environment)\n    vec3 lightDir2 = normalize(vec3(-0.3, 0.8, 0.5));\n    vec3 reflectDir2 = reflect(-lightDir2, normal);\n    float fire2 = pow(max(0.0, dot(reflectDir2, viewDir)), 384.0);\n\n    // Third fire point for more sparkle\n    vec3 lightDir3 = normalize(vec3(0.7, 0.4, -0.6));\n    vec3 reflectDir3 = reflect(-lightDir3, normal);\n    float fire3 = pow(max(0.0, dot(reflectDir3, viewDir)), 256.0);\n\n    // Combine fire points - only keep the brightest peaks\n    float fire = fire1 + fire2 * 0.7 + fire3 * 0.5;\n\n    // Facet edges catch more fire\n    float edgeFactor = length(fwidth(normal)) * 20.0;\n    fire *= (1.0 + edgeFactor * 2.0);\n\n    return fire;\n}\n\n// Calculate bright lines along facet edges where bevels catch light\nfloat calculateFacetEdgeLines(vec3 normal, vec3 viewDir, vec3 lightDir) {\n    // Detect edges from normal discontinuities\n    float edgeMag = length(fwidth(normal));\n\n    // Sharp threshold to create distinct lines\n    float edgeLine = smoothstep(0.02, 0.08, edgeMag);\n\n    // Modulate by light angle - edges facing light are brighter\n    float lightFacing = max(0.0, dot(normal, lightDir));\n    edgeLine *= (0.3 + lightFacing * 0.7);\n\n    // View-dependent - edges perpendicular to view are more visible\n    float viewPerp = 1.0 - abs(dot(normal, viewDir));\n    edgeLine *= (0.5 + viewPerp * 0.5);\n\n    return edgeLine;\n}\n\n// Calculate light transmission based on thickness\nfloat calculateTransmission(vec3 position, vec3 normal, vec3 viewDir, float contrast) {\n    // Thickness estimation - edges are thin, center is thick\n    float distFromCenter = length(position);\n    float thickness = smoothstep(0.0, 0.6, distFromCenter);\n\n    // View angle affects perceived thickness\n    float viewThickness = 1.0 - abs(dot(normal, viewDir));\n    thickness = mix(thickness, viewThickness, 0.5);\n\n    // Thin areas transmit more light (brighter), thick areas are darker\n    float transmission = 1.0 - thickness * contrast * 0.5;\n\n    return clamp(transmission, 0.3, 1.5);\n}\n\n// \n// PHYSICALLY-BASED SUBSURFACE SCATTERING\n// \n\n// \n// PHYSICALLY-BASED SUBSURFACE SCATTERING\n// Based on Disney's Burley Normalized Diffusion (2015)\n// \n\n// SSS Uniforms - declare these in your shader\n// uniform float sssStrength;           // Overall SSS intensity (0-1)\n// uniform vec3 sssAbsorption;          // Absorption coefficients per RGB channel\n// uniform vec3 sssScatterDistance;     // Mean free path / scatter radius per RGB\n// uniform float sssThicknessBias;      // Thickness offset (0-1)\n// uniform float sssThicknessScale;     // Thickness multiplier\n// uniform float sssCurvatureScale;     // How much curvature affects SSS\n// uniform float sssAmbient;            // Ambient SSS contribution\n// uniform vec3 sssLightDir;            // Primary light direction for SSS\n// uniform vec3 sssLightColor;          // Light color for SSS\n\n/**\n * Estimate local thickness from geometry\n * Uses the relationship between view angle and surface normal\n * Combined with a simple depth approximation\n *\n * @param normal - Surface normal in view space\n * @param viewDir - View direction\n * @param position - Vertex position (for depth-based estimation)\n * @param thicknessBias - Base thickness value\n * @param thicknessScale - Thickness multiplier\n * @return Estimated thickness (0-1)\n */\nfloat estimateThickness(vec3 normal, vec3 viewDir, vec3 position, float thicknessBias, float thicknessScale) {\n    // Method 1: View-dependent thickness\n    // Surfaces facing away from viewer are "thicker" (light travels further)\n    float viewThickness = 1.0 - abs(dot(normal, viewDir));\n\n    // Method 2: Position-based depth (simple spherical assumption)\n    // Objects are thinner at edges, thicker in center\n    float posDepth = 1.0 - length(position) * 0.5;\n    posDepth = clamp(posDepth, 0.0, 1.0);\n\n    // Method 3: Curvature hint from normal variation\n    // High-frequency normal changes indicate thin areas (edges, details)\n    // This is approximated by the gradient of the normal\n    float curvatureHint = length(fwidth(normal)) * 10.0;\n    curvatureHint = 1.0 - clamp(curvatureHint, 0.0, 1.0);\n\n    // Combine methods with weighting\n    float thickness = viewThickness * 0.4 + posDepth * 0.4 + curvatureHint * 0.2;\n\n    // Apply bias and scale\n    thickness = thicknessBias + thickness * thicknessScale;\n\n    return clamp(thickness, 0.01, 1.0);\n}\n\n/**\n * Beer's Law absorption - light attenuates exponentially through material\n * Different wavelengths absorb at different rates, creating color shifts\n *\n * @param thickness - Distance light travels through material\n * @param absorption - Absorption coefficients per RGB (higher = more absorbed)\n * @return Transmittance per RGB channel (0-1)\n */\nvec3 beersLawAbsorption(float thickness, vec3 absorption) {\n    // Beer-Lambert Law: T = e^(- * d)\n    // Where  is absorption coefficient, d is distance\n    return exp(-absorption * thickness * 4.0);\n}\n\n/**\n * Burley Normalized Diffusion Profile\n * Disney's approximation of the full BSSRDF, energy-conserving\n *\n * R(r) = A * s * (e^(-s*r) + e^(-s*r/3)) / (8r)\n *\n * @param radius - Distance from entry point (normalized)\n * @param scatterDist - Mean free path / diffusion length\n * @return Diffusion weight at this radius\n */\nfloat burleyDiffusionProfile(float radius, float scatterDist) {\n    // Prevent division by zero\n    float r = max(radius, 0.001);\n    float s = 1.0 / max(scatterDist, 0.001);\n\n    // Burley's two-term approximation\n    float term1 = exp(-s * r);\n    float term2 = exp(-s * r / 3.0);\n\n    // Normalized profile (simplified, without 8r for real-time)\n    float profile = (term1 + term2) * s * 0.25;\n\n    return profile;\n}\n\n/**\n * Christensen-Burley Normalized Diffusion\n * Improved version with better energy conservation\n *\n * @param radius - Distance from entry point\n * @param A - Surface albedo\n * @param d - Diffusion length (mean free path)\n * @return RGB diffusion weights\n */\nvec3 christensenBurleyDiffusion(float radius, vec3 A, vec3 d) {\n    vec3 result = vec3(0.0);\n\n    // Per-channel diffusion (different scatter distances for RGB)\n    for (int i = 0; i < 3; i++) {\n        float s = 1.9 - A[i] + 3.5 * (A[i] - 0.8) * (A[i] - 0.8);\n        s = 1.0 / (s * max(d[i], 0.001));\n\n        float r = max(radius, 0.001);\n\n        // Two-exponential fit\n        float profile = s * (exp(-s * r) + exp(-s * r / 3.0)) / (8.0 * 3.14159 * r);\n\n        result[i] = profile;\n    }\n\n    return result;\n}\n\n/**\n * Calculate curvature factor for SSS intensity\n * SSS is more visible on curved surfaces (fingers, ears, edges)\n *\n * @param normal - Surface normal\n * @return Curvature factor (higher = more curved)\n */\nfloat calculateCurvature(vec3 normal) {\n    // Use screen-space derivatives to estimate curvature\n    vec3 dx = dFdx(normal);\n    vec3 dy = dFdy(normal);\n\n    // Curvature magnitude\n    float curvature = length(dx) + length(dy);\n\n    // Normalize to useful range\n    return clamp(curvature * 5.0, 0.0, 1.0);\n}\n\n/**\n * Full physically-based SSS calculation\n * Combines all components for realistic translucent materials\n *\n * @param normal - Surface normal (view space)\n * @param viewDir - View direction\n * @param position - Vertex position\n * @param lightDir - Light direction\n * @param lightColor - Light color\n * @param baseColor - Material base/albedo color\n * @param sssStrength - Overall SSS strength\n * @param absorption - Absorption coefficients RGB (inverted: higher = MORE of that color)\n * @param scatterDist - Scatter distance RGB (higher = more scatter)\n * @param thicknessBias - Base thickness\n * @param thicknessScale - Thickness multiplier\n * @param curvatureScale - Curvature influence\n * @param ambient - Ambient SSS contribution\n * @return Final SSS color contribution\n */\nvec3 calculatePhysicalSSS(\n    vec3 normal,\n    vec3 viewDir,\n    vec3 position,\n    vec3 lightDir,\n    vec3 lightColor,\n    vec3 baseColor,\n    float sssStrength,\n    vec3 absorption,\n    vec3 scatterDist,\n    float thicknessBias,\n    float thicknessScale,\n    float curvatureScale,\n    float ambient\n) {\n    if (sssStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // \n    // THICKNESS ESTIMATION\n    // \n    float thickness = estimateThickness(normal, viewDir, position, thicknessBias, thicknessScale);\n\n    // \n    // ABSORPTION COLOR (Beer's Law with artist-friendly values)\n    // Creates the characteristic color of translucent materials\n    // absorption values: high value = MORE of that color passes through (transmitted)\n    // This is inverted from physics but intuitive: jade has high green absorption\n    // \n    // Use absorption directly as transmittance - higher = more of that color shows\n    // Normalize to prevent any channel from dominating\n    float maxAbsorption = max(absorption.r, max(absorption.g, absorption.b));\n    vec3 normalizedTransmit = absorption / max(maxAbsorption, 0.001);\n\n    // Apply thickness-based falloff - thin areas show more color\n    float thicknessFactor = 1.0 - thickness * 0.3;\n    vec3 colorShift = normalizedTransmit * thicknessFactor;\n\n    // Ensure minimum color presence\n    colorShift = max(colorShift, vec3(0.15));\n\n    // \n    // SCATTER INTENSITY\n    // How much light scatters based on material properties\n    // \n    // Higher scatter distance = more light gets through, but keep it subtle\n    vec3 scatterIntensity = scatterDist * 0.8;\n    scatterIntensity = clamp(scatterIntensity, vec3(0.1), vec3(1.0));\n\n    // \n    // LIGHTING TERMS - Boosted for visibility\n    // \n\n    // Back-lighting: light passing through from behind (strongest SSS cue)\n    float NdotL = dot(normal, lightDir);\n    float backLight = max(0.0, -NdotL);\n    backLight = pow(backLight, 1.2) * 1.5;  // Boosted\n\n    // Wrap lighting: soft diffuse that wraps around\n    float wrapLight = (NdotL + 1.0) * 0.5;  // Full wrap, 0-1 range\n    wrapLight = wrapLight * wrapLight;\n\n    // View-dependent translucency (looking through thin parts)\n    float VdotL = dot(viewDir, -lightDir);\n    float translucency = pow(max(0.0, VdotL), 1.5) * 1.2;  // Boosted\n\n    // Edge glow (fresnel-like SSS at silhouettes)\n    float edgeGlow = pow(1.0 - abs(dot(normal, viewDir)), 2.0);\n\n    // \n    // THICKNESS-BASED TRANSMISSION\n    // Thin areas let more light through\n    // \n    float thinTransmission = 1.0 - thickness * 0.5;\n    thinTransmission = max(thinTransmission, 0.3);\n\n    // \n    // CURVATURE ENHANCEMENT\n    // \n    float curvature = calculateCurvature(normal);\n    float curvatureFactor = 1.0 + curvature * curvatureScale;\n\n    // \n    // COMBINE ALL TERMS\n    // \n\n    // Total light contribution (more additive for visibility)\n    float totalLight = backLight + translucency * 0.8 + wrapLight * 0.4 + edgeGlow * 0.5;\n    totalLight *= curvatureFactor * thinTransmission;\n\n    // Base SSS color - colorShift IS the tint (e.g., green for jade)\n    // Don't multiply by baseColor to avoid washing out with emotionColor\n    vec3 sssColor = colorShift * scatterIntensity;\n\n    // Ambient SSS (always visible, gives material its translucent look)\n    vec3 ambientSSS = sssColor * ambient;\n\n    // Direct SSS from lighting - subtle contribution\n    vec3 directSSS = sssColor * lightColor * totalLight * 0.5;\n\n    // Final combination\n    vec3 finalSSS = directSSS + ambientSSS;\n\n    // Apply overall strength (linear, no boost to prevent blowout)\n    return finalSSS * sssStrength;\n}\n\n/**\n * Simplified SSS for performance-critical scenarios\n * Uses pre-computed approximations\n *\n * @param normal - Surface normal\n * @param viewDir - View direction\n * @param lightDir - Light direction\n * @param thickness - Pre-computed or approximated thickness\n * @param baseColor - Material color\n * @param scatterColor - Scatter tint color\n * @param strength - SSS strength\n * @return SSS color contribution\n */\nvec3 calculateSimpleSSS(\n    vec3 normal,\n    vec3 viewDir,\n    vec3 lightDir,\n    float thickness,\n    vec3 baseColor,\n    vec3 scatterColor,\n    float strength\n) {\n    if (strength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Back-lighting\n    float backLight = pow(max(0.0, dot(viewDir, -lightDir)), 2.0);\n\n    // Transmittance (simplified Beer's law)\n    float transmit = exp(-thickness * 2.0);\n\n    // Edge enhancement\n    float edge = pow(1.0 - abs(dot(normal, viewDir)), 2.0);\n\n    // Combine\n    float sssIntensity = (backLight * transmit + edge * 0.3) * strength;\n\n    return mix(baseColor, scatterColor, 0.5) * sssIntensity;\n}\n\n\n// \n// DEFORMATION IMPACT GLOW\n// \n\n// \n// IMPACT GLOW - Localized bright spot at punch impact site\n// \n\nvec3 calculateImpactGlow(vec3 fragPos, vec3 emotionColor) {\n    if (deformationStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Distance from this fragment to the impact point (both in mesh-local space)\n    float impactDist = length(fragPos - impactPoint);\n    float impactT = impactDist / max(deformationFalloff, 0.001);\n    float impactFalloff = max(0.0, 1.0 - impactT * impactT);\n\n    // Bright glow at impact site\n    vec3 impactColor = mix(emotionColor, vec3(1.0), impactFalloff * 0.7);\n\n    return impactColor * impactFalloff * 1.5;\n}\n\n\nvoid main() {\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewPosition);\n\n    // \n    // FRESNEL EFFECT - Colored rim at edges (cyan-tinted)\n    // \n    float fresnel = pow(1.0 - abs(dot(normal, viewDir)), fresnelPower);\n    fresnel *= fresnelIntensity;\n\n    // \n    // AMBIENT OCCLUSION - Dark shadows for depth\n    // \n    float ao = calculateAO(normal, viewDir, vPosition);\n    float shadowFactor = mix(1.0, ao, shadowDarkness);\n\n    // \n    // SPECULAR HIGHLIGHTS - Bright catches on facet edges\n    // \n    vec3 lightDir = normalize(sssLightDir);\n    float specular = calculateFacetSpecular(normal, viewDir, lightDir, specularPower);\n    specular *= specularIntensity;\n\n    // \n    // LIGHT TRANSMISSION - Thin areas glow, thick areas darken\n    // \n    float transmission = calculateTransmission(vPosition, normal, viewDir, transmissionContrast);\n\n    // \n    // TEXTURE SAMPLING - Crystal surface detail from UV-mapped texture\n    // \n    vec4 texColor = texture2D(crystalTexture, vUv);\n    float texValue = (texColor.r + texColor.g + texColor.b) / 3.0;  // Grayscale\n\n    // \n    // FROSTED SURFACE - Subtle cloudy variation (not opaque white!)\n    // \n    float surfaceNoise = fbm(vPosition * surfaceNoiseScale + time * 0.02);\n    surfaceNoise = surfaceNoise * surfaceRoughness;\n\n    // \n    // INNER SOUL GLOW - The glowing core visible through the crystal\n    // \n\n    // Animated internal glow - subtle pulsing\n    float glowPulse = sin(time * 0.5) * 0.15 + 0.85;\n\n    // Core glow - strongest in center, fades toward edges with sharper falloff\n    float distFromCenter = length(vPosition);\n    float coreGlow = exp(-distFromCenter * 2.5) * glowPulse;\n\n    // \n    // INTERNAL CAUSTICS - Light refraction pools inside the gem\n    // Creates bright concentrated spots that shift with viewing angle\n    // Real caustics form where refracted light rays converge inside the gem\n    // Now with CHROMATIC ABERRATION - different wavelengths refract differently\n    // \n\n    // Refract view direction through gem surface with different IOR per wavelength\n    // Red refracts less (higher IOR ratio), blue refracts more (lower IOR ratio)\n    // Chromatic separation is REDUCED for colored gems to avoid color contamination\n    // Quartz (low sssStrength) gets full rainbow, colored gems get subtle dispersion\n    float chromaticStrength = 1.0 - clamp((sssStrength - 0.5) * 0.8, 0.0, 0.8);\n    float iorR = mix(0.57, 0.70, chromaticStrength); // Red - approaches green for colored gems\n    float iorB = mix(0.57, 0.44, chromaticStrength); // Blue - approaches green for colored gems\n    vec3 refractDirR = refract(-viewDir, normal, iorR);\n    vec3 refractDirG = refract(-viewDir, normal, 0.57); // Green - always medium\n    vec3 refractDirB = refract(-viewDir, normal, iorB);\n\n    // Animated drift\n    float causticTime = time * causticSpeed;\n    vec3 drift = vec3(causticTime * 0.3, causticTime * 0.2, causticTime * 0.1);\n\n    // Sample positions for each color channel\n    // Offset is also reduced for colored gems to minimize chromatic contamination\n    float spatialOffset = mix(1.0, 3.0, chromaticStrength);\n    vec3 causticPosR = vPosition * causticScale + refractDirR * spatialOffset + drift;\n    vec3 causticPosG = vPosition * causticScale + refractDirG * spatialOffset + drift;\n    vec3 causticPosB = vPosition * causticScale + refractDirB * spatialOffset + drift;\n\n    // Create caustic pattern for each channel\n    // Red channel\n    float waveR1 = sin(causticPosR.x * 2.0 + causticPosR.y * 1.5 + causticPosR.z);\n    float waveR2 = sin(causticPosR.y * 2.3 - causticPosR.x * 1.2 + causticPosR.z * 1.8);\n    float waveR3 = sin(causticPosR.z * 1.9 + causticPosR.x * 0.8 - causticPosR.y * 1.4);\n    float interferenceR = (waveR1 + waveR2 + waveR3) / 3.0;\n    float causticR = smoothstep(0.3, 0.8, interferenceR);\n\n    // Green channel\n    float waveG1 = sin(causticPosG.x * 2.0 + causticPosG.y * 1.5 + causticPosG.z);\n    float waveG2 = sin(causticPosG.y * 2.3 - causticPosG.x * 1.2 + causticPosG.z * 1.8);\n    float waveG3 = sin(causticPosG.z * 1.9 + causticPosG.x * 0.8 - causticPosG.y * 1.4);\n    float interferenceG = (waveG1 + waveG2 + waveG3) / 3.0;\n    float causticG = smoothstep(0.3, 0.8, interferenceG);\n\n    // Blue channel\n    float waveB1 = sin(causticPosB.x * 2.0 + causticPosB.y * 1.5 + causticPosB.z);\n    float waveB2 = sin(causticPosB.y * 2.3 - causticPosB.x * 1.2 + causticPosB.z * 1.8);\n    float waveB3 = sin(causticPosB.z * 1.9 + causticPosB.x * 0.8 - causticPosB.y * 1.4);\n    float interferenceB = (waveB1 + waveB2 + waveB3) / 3.0;\n    float causticB = smoothstep(0.3, 0.8, interferenceB);\n\n    // Combine into RGB caustic with chromatic separation\n    vec3 causticRGB = vec3(causticR, causticG, causticB);\n\n    // Add noise variation to break up uniformity\n    float noiseVar = noise3D(causticPosG * 0.5);\n    causticRGB *= (0.7 + noiseVar * 0.6);\n\n    // Clamp caustic peaks to prevent hot spot blobs\n    // This keeps caustics subtle and distributed rather than concentrated\n    causticRGB = min(causticRGB, vec3(0.6));\n\n    // Caustics are MORE visible in thick areas (center) where light has more\n    // material to refract through and pool\n    float thickness = abs(dot(normal, viewDir)); // 1 at center, 0 at edges\n    causticRGB *= (0.3 + thickness * 0.7);\n\n    // Apply intensity control\n    causticRGB *= causticIntensity;\n\n    // Boost caustic visibility for colored gems to compensate for reduced chromatic spread\n    // Colored gems (high sssStrength) have suppressed chromatic aberration, so boost their\n    // monochromatic caustics to maintain internal "life" and sparkle\n    float causticBoost = 1.0 + clamp((sssStrength - 0.5) * 0.8, 0.0, 0.6);\n    causticRGB *= causticBoost;\n\n    // Also keep a scalar caustic for compatibility\n    float caustic = (causticRGB.r + causticRGB.g + causticRGB.b) / 3.0;\n\n    // Animation pattern (0-1 range) - core glow + caustic hot spots\n    float animationPattern = coreGlow * 0.7 + caustic * 0.3;\n\n    // Soul intensity controls overall brightness with more dramatic falloff\n    // Brighter near core, darker at edges\n    float baseLevel = 0.1;  // Lower base for more contrast\n    float patternContrast = 0.9;  // Higher contrast for more variation\n    float soulIntensity = (baseLevel + animationPattern * patternContrast) * innerGlowStrength;\n\n    // Apply transmission to soul - thin areas glow brighter\n    soulIntensity *= transmission;\n\n    // Soul color from emotion\n    // NOTE: emotionColor is pre-normalized by normalizeColorLuminance() in Core3DManager\n    // This ensures consistent perceived brightness across all emotions (yellow won't wash out, blue stays visible)\n    // Reduced intensity to prevent blowout - soul should be visible but not white\n    float glowCurve = sqrt(innerGlowStrength * glowIntensity) * 0.5;\n    vec3 soulColor = emotionColor * soulIntensity * glowCurve;\n    // Clamp soul color to prevent blowout\n    soulColor = min(soulColor, vec3(0.8));\n\n    // \n    // REFRACTED SOUL SAMPLING - True optical lensing through crystal\n    // The soul is rendered to a texture, then sampled with refraction distortion\n    // This creates the effect of looking at the soul through a crystal lens\n    // \n\n    // \n    // REFRACTED SOUL SAMPLING\n    // Sample the soul texture with physical refraction distortion\n    // Creates the "looking through glass" lensing effect\n    // \n    vec3 refractedSoulColor = vec3(0.0);\n    float refractedSoulAlpha = 0.0;\n\n    if (soulTextureSize.x > 0.0 && soulScreenCenter.x >= 0.0) {\n        // Fragment's screen UV position\n        vec2 fragUV = gl_FragCoord.xy / soulTextureSize;\n\n        // Calculate refraction offset using Snell's law\n        float ior = refractionIndex;\n        vec3 refractedDir = refract(-viewDir, normal, 1.0 / ior);\n\n        // Apply refraction distortion toward the soul center\n        // This creates the magnifying glass effect - bending light toward center\n        vec2 refractionOffset = refractedDir.xy * refractionStrength * 0.1;\n\n        // Sample at fragment position with refraction offset\n        // The soul texture contains the soul rendered at its actual screen position\n        vec2 soulUV = fragUV + refractionOffset;\n\n        // Clamp to valid UV range\n        soulUV = clamp(soulUV, 0.0, 1.0);\n\n        // Sample the soul texture\n        vec4 soulSample = texture2D(soulTexture, soulUV);\n\n        // Store for later use in final composition\n        refractedSoulColor = soulSample.rgb;\n        refractedSoulAlpha = soulSample.a;\n\n        // Also blend into soulColor for existing pipeline\n        soulColor = mix(soulColor, soulSample.rgb, soulSample.a * 0.5);\n    }\n\n    // \n    // SOUL BLEND LAYERS - Apply before combining with shell\n    // \n    if (soulLayer1Enabled > 0.5) {\n        int mode = int(soulLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(soulColor, emotionColor * soulLayer1Strength, mode);\n        soulColor = mix(soulColor, blendResult, soulLayer1Strength);\n    }\n    if (soulLayer2Enabled > 0.5) {\n        int mode = int(soulLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(soulColor, emotionColor * soulLayer2Strength, mode);\n        soulColor = mix(soulColor, blendResult, soulLayer2Strength);\n    }\n\n    // \n    // FROSTED SHELL - Milky white layer with INTERNAL lighting model\n    // Lit from inside: thin edges bright, thick center dark\n    // \n\n    // Frosted glass base - will be modulated by thickness\n    // Lower base values allow for darker thick areas while maintaining bright edges\n    vec3 frostBase = vec3(0.45, 0.48, 0.55) * frostiness;\n\n    // THICKNESS-BASED DARKNESS (internal lighting model)\n    // Face-on facets are THICK (light travels far through) = DARK\n    // Edge-on facets are THIN (light escapes easily) = BRIGHT\n    float edgeThinness = 1.0 - abs(dot(normal, viewDir));  // 1 at edges, 0 facing camera\n\n    // Apply curve to make face-on areas darker more aggressively\n    float thinness = pow(edgeThinness, 0.7);  // Push more area toward dark\n\n    // Thickness multiplier: thin edges=bright (1.0), thick face-on=dark (0.01 for near-black)\n    float thicknessMultiplier = 0.01 + thinness * 0.99;\n    frostBase *= thicknessMultiplier;\n\n    // Surface variation adds subtle texture\n    frostBase += vec3(surfaceNoise * 0.03);\n\n    // Specular highlights on facet edges (external light catch)\n    float facetHighlight = pow(max(0.0, dot(normal, normalize(vec3(0.5, 1.0, 0.8)))), 16.0);\n    frostBase += vec3(facetHighlight * 0.2);\n\n    // SOUL BLEED - Inner glow illuminates the shell from inside\n    // Use gentler falloff so color reaches the shell surface\n    float soulBleed = exp(-distFromCenter * 1.2) * innerGlowStrength;\n    // Stronger color contribution - tint the frost with emotion color\n    frostBase = mix(frostBase, frostBase + emotionColor * 0.4, soulBleed);\n\n    // \n    // SHELL BLEND LAYERS - Apply to frosted shell\n    // \n    if (shellLayer1Enabled > 0.5) {\n        int mode = int(shellLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(frostBase, emotionColor * shellLayer1Strength, mode);\n        frostBase = mix(frostBase, blendResult, shellLayer1Strength);\n    }\n    if (shellLayer2Enabled > 0.5) {\n        int mode = int(shellLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(frostBase, emotionColor * shellLayer2Strength, mode);\n        frostBase = mix(frostBase, blendResult, shellLayer2Strength);\n    }\n\n    // \n    // FRESNEL RIM - Bright emotion-colored edge glow\n    // \n    vec3 rimColor = mix(vec3(0.5, 0.9, 1.0), emotionColor, 0.6);\n    vec3 rimGlow = rimColor * fresnel * 1.2;\n\n    // \n    // RIM BLEND LAYERS - Apply to fresnel rim glow\n    // \n    if (rimLayer1Enabled > 0.5) {\n        int mode = int(rimLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(rimGlow, emotionColor * rimLayer1Strength, mode);\n        rimGlow = mix(rimGlow, blendResult, rimLayer1Strength);\n    }\n    if (rimLayer2Enabled > 0.5) {\n        int mode = int(rimLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(rimGlow, emotionColor * rimLayer2Strength, mode);\n        rimGlow = mix(rimGlow, blendResult, rimLayer2Strength);\n    }\n\n    // \n    // PHYSICALLY-BASED SUBSURFACE SCATTERING\n    // Uses BSSRDF with Beer's Law absorption and Burley diffusion profile\n    // \n    vec3 sss = calculatePhysicalSSS(\n        normal,\n        viewDir,\n        vPosition,\n        normalize(sssLightDir),\n        sssLightColor,\n        emotionColor,\n        sssStrength,\n        sssAbsorption,\n        sssScatterDistance,\n        sssThicknessBias,\n        sssThicknessScale,\n        sssCurvatureScale,\n        sssAmbient\n    );\n\n    // \n    // SSS BLEND LAYERS - Apply to subsurface scattering contribution\n    // \n    if (sssLayer1Enabled > 0.5) {\n        int mode = int(sssLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(sss, emotionColor * sssLayer1Strength, mode);\n        sss = mix(sss, blendResult, sssLayer1Strength);\n    }\n    if (sssLayer2Enabled > 0.5) {\n        int mode = int(sssLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(sss, emotionColor * sssLayer2Strength, mode);\n        sss = mix(sss, blendResult, sssLayer2Strength);\n    }\n\n    // \n    // COMBINE - Frosted shell base + soul glow (soul adds to shell, doesn't replace)\n    // \n\n    // Start with shell as base - preserves dark shadows\n    vec3 finalColor = frostBase;\n\n    // Add soul glow on top (additive, not replacement) - concentrated in center\n    // Soul should illuminate dark areas but not wash out entirely\n    float soulBlendFactor = soulIntensity * 0.6;\n    finalColor += soulColor * soulBlendFactor;\n\n    // Apply texture - blend based on texture brightness and strength\n    vec3 texContribution = texColor.rgb * textureStrength;\n    finalColor = mix(finalColor, finalColor + texContribution, textureStrength);\n\n    // Apply SSS material color - PRESERVE BRIGHTNESS, only change HUE\n    // The sssAbsorption values define the material color hue\n    // But thickness-based darkness must be preserved for gemstone look\n    if (sssStrength > 0.01) {\n        // Get current brightness (this includes thickness darkening)\n        float currentLum = dot(finalColor, vec3(0.299, 0.587, 0.114));\n\n        // Normalize absorption to get hue direction (0-1 range)\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 hue = absorption / max(maxAbs, 0.001);\n\n        // Create material color that PRESERVES current brightness\n        // This keeps dark areas dark while tinting them with the gem color\n        float hueLum = dot(hue, vec3(0.299, 0.587, 0.114));\n        vec3 materialColor = hue * currentLum / max(hueLum, 0.001);\n\n        // Clamp to prevent blowout on bright areas\n        materialColor = min(materialColor, vec3(1.0));\n\n        // Add subtle variation from SSS lighting calculation\n        float sssLum = dot(sss, vec3(0.299, 0.587, 0.114));\n        materialColor *= (0.9 + sssLum * 0.2);\n\n        // Replace crystal color with material color\n        float replaceAmount = sssStrength * 0.7;\n        finalColor = mix(finalColor, materialColor, replaceAmount);\n    }\n\n    // Add rim glow, tinted toward material color\n    if (sssStrength > 0.01) {\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 hue = absorption / max(maxAbs, 0.001);\n        // Stronger tint for colored gems - use gem hue directly\n        float rimTintStrength = clamp(sssStrength * 0.6, 0.0, 0.95);\n        vec3 tintedRim = rimGlow * mix(vec3(1.0), hue * 1.2, rimTintStrength);\n        // Cap rim to prevent bloom\n        tintedRim = min(tintedRim, vec3(0.5));\n        finalColor += tintedRim;\n    } else {\n        finalColor += rimGlow;\n    }\n\n    // \n    // SPECULAR HIGHLIGHTS - Add bright hot spots\n    // Tinted by gem color for colored gems to prevent white bloom\n    // \n    vec3 specularColor = vec3(1.0, 0.98, 0.95); // Warm white highlights for clear gems\n    float specularIntensityMod = 1.0;\n\n    if (sssStrength > 0.5) {\n        // Tint specular by gem color to prevent white bloom\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 gemHue = absorption / max(maxAbs, 0.001);\n        float colorStrength = clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0);\n        // Use gem hue for specular color\n        specularColor = mix(specularColor, gemHue * 1.3, colorStrength);\n        // Also reduce specular intensity for colored gems\n        specularIntensityMod = mix(1.0, 0.4, colorStrength);\n    }\n\n    vec3 specularContrib = specularColor * specular * transmission * specularIntensityMod;\n    specularContrib = min(specularContrib, vec3(0.5)); // Cap specular to prevent bloom\n    finalColor += specularContrib;\n\n    // \n    // FACET EDGE LINES - Bright catches along beveled edges\n    // \n    float edgeLines = calculateFacetEdgeLines(normal, viewDir, lightDir);\n    finalColor += vec3(edgeLines * 0.15) * transmission;\n\n    // \n    // SATURATION BOOST AT THIN EDGES\n    // Real gems have MORE saturated color at thin edges where light escapes\n    // \n    if (sssStrength > 0.01) {\n        // thinness: 1 at edges, 0 facing camera\n        float satBoost = thinness * 0.4; // Up to 40% saturation boost at edges\n\n        // Get current color's saturation\n        float maxC = max(max(finalColor.r, finalColor.g), finalColor.b);\n        float minC = min(min(finalColor.r, finalColor.g), finalColor.b);\n        float currentSat = maxC > 0.001 ? (maxC - minC) / maxC : 0.0;\n\n        // Boost saturation at thin areas\n        if (maxC > 0.001 && currentSat > 0.01) {\n            // Calculate luminance\n            float lum = dot(finalColor, vec3(0.299, 0.587, 0.114));\n            // Increase saturation by moving away from gray toward the color\n            vec3 gray = vec3(lum);\n            float newSat = min(currentSat + satBoost, 1.0);\n            float satRatio = currentSat > 0.001 ? newSat / currentSat : 1.0;\n            finalColor = gray + (finalColor - gray) * satRatio;\n        }\n    }\n\n    // \n    // FINAL THICKNESS APPLICATION - Apply AFTER all additive terms\n    // This ensures thick areas stay dark even with glow added\n    // \n    // thicknessMultiplier: 0.15 in thick center, 1.0 at thin edges\n    finalColor *= thicknessMultiplier;\n\n    // \n    // INTERNAL CAUSTICS - Bright spots from light concentration inside gem\n    // Now with chromatic aberration for rainbow dispersion effect\n    // Applied AFTER thickness darkening so they punch through dark areas\n    // \n    if (causticIntensity > 0.01) {\n        // Get material hue for tinting caustics\n        vec3 causticTint = vec3(1.0); // Default white\n        float causticTintStrength = 0.4; // Default for clear gems\n        if (sssStrength > 0.5) {\n            vec3 absorption = sssAbsorption;\n            float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n            vec3 hue = absorption / max(maxAbs, 0.001);\n            // Stronger tint for colored gems to prevent white bloom\n            causticTintStrength = clamp((sssStrength - 0.5) * 0.8 + 0.4, 0.4, 0.9);\n            causticTint = mix(vec3(1.0), hue * 1.2, causticTintStrength);\n        }\n        // Add RGB caustic with chromatic aberration\n        // Reduce raw RGB blend for colored gems\n        float rawBlend = mix(0.3, 0.1, clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0));\n        vec3 causticFinal = causticRGB * causticTint + causticRGB * rawBlend;\n        causticFinal = min(causticFinal, vec3(0.4)); // Cap to prevent bloom\n        finalColor += causticFinal;\n    }\n\n    // \n    // FIRE - Intense sparkle points from light dispersion in facets\n    // The "fire" effect that makes gems sparkle brilliantly\n    // \n    float fire = calculateFire(normal, viewDir, lightDir);\n\n    // Tint fire by gem color - colored gems should have tinted highlights\n    // Pure white fire only for quartz/clear gems (low sssStrength)\n    vec3 fireColor = vec3(1.0, 0.99, 0.97); // Base warm white\n    float fireIntensity = 0.3; // Base intensity for clear gems\n    float fireClamp = 1.5; // Max fire value for clear gems\n\n    if (sssStrength > 0.5) {\n        // Get gem hue from absorption - this IS the gem's color\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 gemHue = absorption / max(maxAbs, 0.001);\n\n        // For colored gems, fire should BE the gem color, not white\n        // The more colored the gem (higher sssStrength), the more the fire matches the gem\n        float colorStrength = clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0);\n\n        // Use gem hue directly as fire color - NOT mixed with white\n        // This ensures fire can never bloom to white\n        fireColor = gemHue * 1.2; // Slight brightness boost but stay saturated\n\n        // Reduce fire intensity AND clamp for colored gems to prevent bloom washout\n        // Colored gems should have subtle, saturated fire, not bright white spots\n        fireIntensity = mix(0.3, 0.08, colorStrength); // Much lower for colored gems\n        fireClamp = mix(1.5, 0.5, colorStrength); // Much lower clamp for colored gems\n    }\n\n    // Apply fire clamp BEFORE multiplying by color\n    fire = min(fire, fireClamp);\n\n    // Calculate fire contribution and clamp to prevent any channel from blooming\n    vec3 fireContribution = fireColor * fire * fireIntensity;\n    fireContribution = min(fireContribution, vec3(0.4)); // Hard cap on fire brightness\n    finalColor += fireContribution;\n\n    // Ensure minimum brightness - allow near-black for gemstones\n    // minBrightness of 0.01 allows true darks while preventing total black\n    finalColor = max(finalColor, vec3(minBrightness));\n\n    // \n    // ALPHA - More opaque for visibility\n    // \n\n    // Higher base opacity\n    float baseAlpha = 0.6 + frostiness * 0.25;\n\n    // Fresnel makes edges solid\n    float rimAlpha = fresnel * 0.3;\n\n    // Soul glow adds opacity\n    float glowAlpha = soulIntensity * 0.15;\n\n    float finalAlpha = min(baseAlpha + rimAlpha + glowAlpha, 0.95) * opacity;\n\n    // \n    // REFRACTED SOUL - Add the soul visible through the crystal\n    // This is the actual soul mesh rendered to texture and sampled with refraction\n    // \n    if (refractedSoulAlpha > 0.01) {\n        // The soul should glow through the crystal, tinted by the crystal's color\n        // Use additive blending so the soul illuminates the crystal from within\n        vec3 soulGlow = refractedSoulColor * refractedSoulAlpha;\n\n        // Tint the soul by the crystal's SSS color for colored gems\n        // emotionColorBleed controls how much pure emotion color comes through\n        // 0 = fully tinted by gem color, 1 = pure emotion color\n        if (sssStrength > 0.01) {\n            vec3 absorption = sssAbsorption;\n            float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n            vec3 gemHue = absorption / max(maxAbs, 0.001);\n            float tintAmount = sssStrength * 0.5 * (1.0 - emotionColorBleed);\n            soulGlow *= mix(vec3(1.0), gemHue, tintAmount);\n        }\n\n        // Add soul glow to final color\n        finalColor += soulGlow * 0.8;\n    }\n\n    // \n    // EMOTION COLOR BLEED - Additional inner glow from soul emotion\n    // Adds pure emotion color as light shining through the gem from the soul\n    // \n    if (emotionColorBleed > 0.001 && sssStrength > 0.01) {\n        // Inner glow based on thickness - thinner areas show more soul light\n        float innerGlow = 1.0 - abs(dot(normal, viewDir)); // Edges are thin\n        innerGlow = pow(innerGlow, 1.5) * emotionColorBleed;\n\n        // Also add glow near the core\n        float coreProximity = exp(-distFromCenter * 2.0);\n        innerGlow += coreProximity * emotionColorBleed * 0.5;\n\n        // Add pure emotion color as inner light\n        finalColor += emotionColor * innerGlow * 0.4;\n    }\n\n    // \n    // IMPACT GLOW - Localized bright spot at punch impact site\n    // Uses calculateImpactGlow() from deformation.js utility\n    // vPosition is in mesh-local space (impactPoint pre-transformed by JS)\n    // \n    finalColor += calculateImpactGlow(vPosition, emotionColor);\n\n    gl_FragColor = vec4(finalColor, finalAlpha);\n}\n`,gM={time:0,glowIntensity:1,opacity:1,frostiness:.55,fresnelPower:2.8,fresnelIntensity:.35,innerGlowStrength:.55,surfaceRoughness:.12,shadowDarkness:.6,specularIntensity:.9,specularPower:28,transmissionContrast:1,minBrightness:.005,surfaceNoiseScale:1.5,noiseFrequency:1.33,causticIntensity:.8,causticScale:2,causticSpeed:.12,textureStrength:.55,refractionIndex:1.5,refractionStrength:.5,resolution:[1920,1080],soulTextureSize:[1920,1080],soulScreenCenter:[.5,.5],sssStrength:.65,sssAbsorption:[2.4,2.5,2.8],sssScatterDistance:[.35,.4,.45],sssThicknessBias:.18,sssThicknessScale:.6,sssCurvatureScale:1.8,sssAmbient:.3,sssLightDir:[.5,1,.8],sssLightColor:[1,.98,.95],shellLayer1Mode:0,shellLayer1Strength:0,shellLayer1Enabled:0,shellLayer2Mode:0,shellLayer2Strength:0,shellLayer2Enabled:0,soulLayer1Mode:0,soulLayer1Strength:0,soulLayer1Enabled:0,soulLayer2Mode:0,soulLayer2Strength:0,soulLayer2Enabled:0,rimLayer1Mode:0,rimLayer1Strength:0,rimLayer1Enabled:0,rimLayer2Mode:0,rimLayer2Strength:0,rimLayer2Enabled:0,sssLayer1Mode:0,sssLayer1Strength:0,sssLayer1Enabled:0,sssLayer2Mode:0,sssLayer2Strength:0,sssLayer2Enabled:0};function fM(t,e,i={}){const{glowColor:n=[1,1,.95],glowIntensity:s=1,materialVariant:a=null,emotionData:r=null,assetBasePath:o="/assets"}=i;return"custom"===e.material?function(t,e,i,n,s,a){const r=new $l;switch(t){case"moon":return function(t,e,i,n=null,s="/assets"){const a=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)?"2k":"4k";if("multiplexer"===n)return{material:Im(t,{resolution:a,glowColor:new zn(e[0],e[1],e[2]),glowIntensity:i,assetBasePath:s}),type:"moon-multiplexer"};return{material:Cm(t,{resolution:a,glowColor:new zn(e[0],e[1],e[2]),glowIntensity:i,moonPhase:"full",assetBasePath:s}),type:"moon"}}(r,e,i,n,a);case"crystal":return yM(e,i,"crystal",{sssPreset:"quartz"},a);case"rough":return yM(e,i,"rough",{frostiness:.05,innerGlowStrength:0,fresnelIntensity:1.6},a);case"heart":return yM(e,i,"heart",{frostiness:.475,innerGlowStrength:.117,fresnelIntensity:1.206},a);case"star":return yM(e,i,"star",{sssPreset:"citrine"},a);default:return console.warn("Unknown custom material type:",t),null}}(t,n,s,a,0,o):"emissive"===e.material?function(t,e,i,n,s,a){const r=new $l;return"sun"===t?function(t,e,i,n=null,s=null,a="/assets"){return{material:km(t,{glowColor:e,glowIntensity:i,resolution:"4k",materialVariant:n,assetBasePath:a}),type:"sun"}}(r,e,i,n,s,a):(console.warn("Unknown emissive material type:",t),null)}(t,n,s,a,r,o):null}function yM(t,e,i="crystal",n={},s="/assets"){const{vertexShader:a,fragmentShader:r}={vertexShader:pM,fragmentShader:mM};let o=null;if(i){const t=new $l,e={crystal:`${s}/textures/Crystal/crystal.png`,rough:`${s}/textures/Crystal/rough.png`,heart:`${s}/textures/Crystal/heart.png`,star:`${s}/textures/Crystal/star.png`},n=e[i]||e.crystal;o=t.load(n,void 0,t=>console.warn(` ${i} texture failed to load:`,t))}const l=n.sssPreset?cM[n.sssPreset]:null;return{material:new Cs({uniforms:{time:{value:0},emotionColor:{value:new zn(t[0],t[1],t[2])},glowIntensity:{value:e},opacity:{value:1},frostiness:{value:n.frostiness??gM.frostiness},fresnelPower:{value:n.fresnelPower??gM.fresnelPower},fresnelIntensity:{value:n.fresnelIntensity??gM.fresnelIntensity},innerGlowStrength:{value:n.innerGlowStrength??gM.innerGlowStrength},surfaceRoughness:{value:gM.surfaceRoughness},shadowDarkness:{value:n.shadowDarkness??gM.shadowDarkness},specularIntensity:{value:n.specularIntensity??gM.specularIntensity},specularPower:{value:n.specularPower??gM.specularPower},transmissionContrast:{value:n.transmissionContrast??gM.transmissionContrast},minBrightness:{value:n.minBrightness??gM.minBrightness},surfaceNoiseScale:{value:gM.surfaceNoiseScale},noiseFrequency:{value:gM.noiseFrequency},causticIntensity:{value:n.causticIntensity??gM.causticIntensity},causticScale:{value:n.causticScale??gM.causticScale},causticSpeed:{value:n.causticSpeed??gM.causticSpeed},crystalTexture:{value:o},textureStrength:{value:"heart"===i?.35:i?gM.textureStrength:0},soulTexture:{value:null},resolution:{value:new je(gM.resolution[0],gM.resolution[1])},soulTextureSize:{value:new je(gM.soulTextureSize[0],gM.soulTextureSize[1])},soulScreenCenter:{value:new je(gM.soulScreenCenter[0],gM.soulScreenCenter[1])},refractionIndex:{value:n.refractionIndex??gM.refractionIndex},refractionStrength:{value:n.refractionStrength??gM.refractionStrength},sssStrength:{value:n.sssStrength??l?.sssStrength??gM.sssStrength},sssAbsorption:{value:new qe(...n.sssAbsorption??l?.sssAbsorption??gM.sssAbsorption)},sssScatterDistance:{value:new qe(...n.sssScatterDistance??l?.sssScatterDistance??gM.sssScatterDistance)},sssThicknessBias:{value:n.sssThicknessBias??l?.sssThicknessBias??gM.sssThicknessBias},sssThicknessScale:{value:n.sssThicknessScale??l?.sssThicknessScale??gM.sssThicknessScale},sssCurvatureScale:{value:n.sssCurvatureScale??l?.sssCurvatureScale??gM.sssCurvatureScale},sssAmbient:{value:n.sssAmbient??l?.sssAmbient??gM.sssAmbient},sssLightDir:{value:new qe(...n.sssLightDir??gM.sssLightDir)},sssLightColor:{value:new qe(...n.sssLightColor??gM.sssLightColor)},emotionColorBleed:{value:n.emotionColorBleed??l?.emotionColorBleed??0},shellLayer1Mode:{value:gM.shellLayer1Mode},shellLayer1Strength:{value:gM.shellLayer1Strength},shellLayer1Enabled:{value:gM.shellLayer1Enabled},shellLayer2Mode:{value:gM.shellLayer2Mode},shellLayer2Strength:{value:gM.shellLayer2Strength},shellLayer2Enabled:{value:gM.shellLayer2Enabled},soulLayer1Mode:{value:gM.soulLayer1Mode},soulLayer1Strength:{value:gM.soulLayer1Strength},soulLayer1Enabled:{value:gM.soulLayer1Enabled},soulLayer2Mode:{value:gM.soulLayer2Mode},soulLayer2Strength:{value:gM.soulLayer2Strength},soulLayer2Enabled:{value:gM.soulLayer2Enabled},rimLayer1Mode:{value:gM.rimLayer1Mode},rimLayer1Strength:{value:gM.rimLayer1Strength},rimLayer1Enabled:{value:gM.rimLayer1Enabled},rimLayer2Mode:{value:gM.rimLayer2Mode},rimLayer2Strength:{value:gM.rimLayer2Strength},rimLayer2Enabled:{value:gM.rimLayer2Enabled},sssLayer1Mode:{value:gM.sssLayer1Mode},sssLayer1Strength:{value:gM.sssLayer1Strength},sssLayer1Enabled:{value:gM.sssLayer1Enabled},sssLayer2Mode:{value:gM.sssLayer2Mode},sssLayer2Strength:{value:gM.sssLayer2Strength},sssLayer2Enabled:{value:gM.sssLayer2Enabled},deformationStrength:{value:dM.deformationStrength},impactPoint:{value:new qe(...dM.impactPoint)},deformationFalloff:{value:dM.deformationFalloff}},vertexShader:a,fragmentShader:r,transparent:!0,side:2,depthWrite:!1,blending:1}),type:"crystal"}}function vM(t){t&&(t.map&&t.map.dispose(),t.normalMap&&t.normalMap.dispose(),t.emissiveMap&&t.emissiveMap.dispose(),t.roughnessMap&&t.roughnessMap.dispose(),t.metalnessMap&&t.metalnessMap.dispose())}const bM=new Map;async function MM(t,e={}){if(bM.has(t)){const e=bM.get(t);if(e.loaded)return e}const i=Vm[t];if(!i)return console.warn(`[GeometryCache] Unknown geometry type: ${t}`),null;const n={geometry:null,material:null,materialType:null,config:i,loaded:!1};if(i.geometryLoader?n.geometry=await i.geometryLoader(e.assetBasePath):n.geometry=i.geometry,"custom"===i.material||"emissive"===i.material){const s=fM(t,i,{glowColor:e.glowColor||[1,1,.95],glowIntensity:e.glowIntensity||1,materialVariant:e.materialVariant,emotionData:e.emotionData,assetBasePath:e.assetBasePath});s&&(n.material=s.material,n.materialType=s.type)}return n.loaded=!0,bM.set(t,n),n}async function _M(t={}){await Promise.all(["crystal","rough","heart","moon","sun"].map(e=>MM(e,t)))}function xM(){for(const[t,e]of bM.entries())e.material&&(vM(e.material),e.material.dispose());bM.clear()}var wM={preload:MM,preloadAll:_M,get:function(t){const e=bM.get(t);return e&&e.loaded?e:null},has:function(t){const e=bM.get(t);return e&&e.loaded},updateMaterialOptions:function(t,e){const i=bM.get(t);if(!i||!i.material)return;const{uniforms:n}=i.material;n&&(e.glowColor&&n.glowColor&&n.glowColor.value.set(...e.glowColor),void 0!==e.glowIntensity&&n.glowIntensity&&(n.glowIntensity.value=e.glowIntensity))},dispose:xM,getStatus:function(){const t={};for(const[e,i]of bM.entries())t[e]={loaded:i.loaded,hasGeometry:!!i.geometry,hasMaterial:!!i.material,materialType:i.materialType};return t}};class SM{constructor(t,e){this.animator=t,this.gestureBlender=e,this.virtualParticlePool=this._createVirtualParticlePool(5),this.nextPoolIndex=0}_createVirtualParticlePool(t){const e=[];for(let i=0;i<t;i++)e.push({x:0,y:0,vx:0,vy:0,size:1,baseSize:1,opacity:1,scaleFactor:1,gestureData:null});return e}getVirtualParticleFromPool(){const t=this.virtualParticlePool[this.nextPoolIndex];return this.nextPoolIndex=(this.nextPoolIndex+1)%this.virtualParticlePool.length,t.x=0,t.y=0,t.vx=0,t.vy=0,t.size=1,t.baseSize=1,t.opacity=1,t.scaleFactor=1,t.gestureData=null,t}playGesture(t,e={}){const i=Xb(t);if(!i){const i=this.animator.createGestureAnimation(t);return i&&i.evaluate?this._playProceduralGesture(t,i,e):(console.warn(`Unknown gesture: ${t}`),!1)}const n=this.getVirtualParticleFromPool(),s=i.config||{};let a;a=s.musicalDuration?.musical?s.musicalDuration.bars?2e3*s.musicalDuration.bars:500*(s.musicalDuration.beats||2):s.duration||800;const r=this.animator.time;if(this.animator.animations.length>=10){const t=this.animator.animations.shift();console.warn(`Animation limit reached (10), removed oldest: ${t.gestureName||"unknown"}`)}const o={initialized:!1};return this.animator.animations.push({gestureName:t,duration:a,startTime:r,config:s,evaluate:t=>{n.x=0,n.y=0,n.vx=0,n.vy=0,n.size=1,n.opacity=1,i.apply&&(!o.initialized&&i.initialize&&(i.initialize(n,s,0,0),o.initialized=!0),i.apply(n,t,s,1/60,0,0));const e={...s,particle:n,config:s,strength:s.strength||1};return i["3d"]&&i["3d"].evaluate?i["3d"].evaluate.call(i,t,e):{position:[0,0,0],rotation:[0,0,0],scale:1}},callbacks:{onUpdate:e.onUpdate||null,onComplete:()=>{i.cleanup&&i.cleanup(n),e.onComplete&&e.onComplete()}}}),!0}_playProceduralGesture(t,e,i={}){const n=1e3*(e.duration||.5),s=this.animator.time;if(this.animator.animations.length>=10){const t=this.animator.animations.shift();console.warn(`Animation limit reached (10), removed oldest: ${t.gestureName||"unknown"}`)}return this.animator.animations.push({gestureName:t,duration:n,startTime:s,isAccent:e.isAccent||!1,evaluate:e.evaluate,callbacks:{onUpdate:i.onUpdate||null,onComplete:i.onComplete||null}}),!0}update(t){this.animator.update(t)}blend(t,e,i){return this.gestureBlender.blend(this.animator.animations,this.animator.time,t,e,i)}hasActiveAnimations(){return this.animator.animations.length>0}getActiveAnimationCount(){return this.animator.animations.length}getTime(){return this.animator.time}getActiveAnimations(){return this.animator.animations}stopAll(){this.animator.stopAll()}playEmotion(t){this.animator.playEmotion(t)}dispose(){this.stopAll(),this.virtualParticlePool&&(this.virtualParticlePool.length=0,this.virtualParticlePool=null),this.animator=null,this.gestureBlender=null,this.tempEuler=null,this.gestureQuaternion=null}}const TM="off",CM="annular",EM="total",AM={[TM]:{shadowCoverage:0,coronaIntensity:1,coronaRaysEnabled:!1,baileyBeadsEnabled:!1,baileyBeadsCount:0,baileyBeadsSize:0},[CM]:{shadowCoverage:.95,coronaIntensity:.8,coronaRaysEnabled:!1,baileyBeadsEnabled:!0,baileyBeadsCount:12,baileyBeadsSize:.015},[EM]:{shadowCoverage:1.019,coronaIntensity:4,coronaRaysEnabled:!0,baileyBeadsEnabled:!0,baileyBeadsCount:6,baileyBeadsSize:.025}};function PM(t){return AM[t]||AM[TM]}class DM{constructor(t,e){this.scene=t,this.sunRadius=e,this.heroBeadCount=3,this.supportBeadCount=15,this.beadCount=this.heroBeadCount+this.supportBeadCount,this.beads=[],this.visible=!1,this._directionToCamera=new qe,this._up=new qe(0,1,0),this._right=new qe,this._upVector=new qe,this._beadOffset=new qe,this._tempColor=new zn,this.sharedTexture=null,this.createBeads()}createBeads(){const t=document.createElement("canvas");t.width=64,t.height=64;const e=t.getContext("2d"),i=e.createRadialGradient(32,32,0,32,32,32);i.addColorStop(0,"rgba(255, 255, 255, 1.0)"),i.addColorStop(.1,"rgba(255, 255, 255, 0.9)"),i.addColorStop(.3,"rgba(255, 240, 200, 0.6)"),i.addColorStop(.6,"rgba(255, 220, 150, 0.2)"),i.addColorStop(1,"rgba(255, 200, 100, 0.0)"),e.fillStyle=i,e.fillRect(0,0,64,64);const n=new Br(t);n.needsUpdate=!0,this.sharedTexture=n;const s=this.generateLunarValleys();for(let t=0;t<this.beadCount;t++){const e=new Os,i=new js({map:n.clone(),blending:2,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(1,.3,.3)}),a=new aa(i);a.scale.set(.08,.08,1),e.add(a);const r=new js({map:n.clone(),blending:2,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(.8,1,.8)}),o=new aa(r);o.scale.set(.08,.08,1),e.add(o);const l=new js({map:n,blending:2,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(.3,.5,1)}),h=new aa(l);h.scale.set(.08,.08,1),e.add(h),e.userData={angle:s[t].angle,depth:s[t].depth,baseIntensity:s[t].baseIntensity,isHero:s[t].isHero,sizeMultiplier:s[t].isHero?1.5:1,targetOpacity:0,currentOpacity:0,redSprite:a,greenSprite:o,blueSprite:h},this.beads.push(e),this.scene.add(e)}}generateLunarValleys(){const t=[];let e=12345;const i=()=>(e=(9301*e+49297)%233280,e/233280),n=i()*Math.PI*2;for(let e=0;e<this.heroBeadCount;e++){const s=n+e*Math.PI*2/3;t.push({angle:s,depth:.8+.2*i(),baseIntensity:.8+.2*i(),isHero:!0})}for(let e=0;e<this.supportBeadCount;e++){const s=n+Math.floor(e/(this.supportBeadCount/3))*Math.PI*2/3,a=1.2*(i()-.5);t.push({angle:s+a,depth:.3+.5*i(),baseIntensity:.4+.4*i(),isHero:!1})}return t}update(t,e,i,n,s=1){const a=this.sunRadius*s*1,r=t.position;this._directionToCamera.subVectors(r,e).normalize(),this._right.crossVectors(this._directionToCamera,this._up).normalize(),this._upVector.crossVectors(this._right,this._directionToCamera).normalize();for(const t of this.beads){const{angle:i,redSprite:n,greenSprite:r,blueSprite:o,sizeMultiplier:l}=t.userData,h=Math.cos(i)*a,c=Math.sin(i)*a;this._beadOffset.set(0,0,0),this._beadOffset.addScaledVector(this._right,h),this._beadOffset.addScaledVector(this._upVector,c),this._beadOffset.addScaledVector(this._directionToCamera,.01*a);const u=e.x+this._beadOffset.x,d=e.y+this._beadOffset.y,p=e.z+this._beadOffset.z,m=.008*s,g=Math.cos(i)*m,f=Math.sin(i)*m;n.position.set(g,f,.001),r.position.set(0,0,0),o.position.set(-g,-f,-.001),t.position.set(u,d,p),t.updateMatrixWorld(!0);const y=.15*s*l;n.scale.set(y,y,1),r.scale.set(y,y,1),o.scale.set(y,y,1)}if(this.visible){const t=.9,e=.97,n=1;for(const s of this.beads){let a=0;if(i>=t&&i<n){const r=(i-t)/(n-t)*Math.PI*2,o=Math.abs((s.userData.angle-r+Math.PI)%(2*Math.PI)-Math.PI);let l=1;i<e&&(l=(i-t)/(e-t)),a=Math.max(0,1-o/1)*s.userData.baseIntensity*l*s.userData.depth,a*=200}s.userData.targetOpacity=a}}else for(const t of this.beads)t.userData.targetOpacity=0;for(const t of this.beads){const{redSprite:e,greenSprite:i,blueSprite:s}=t.userData,a=t.userData.targetOpacity-t.userData.currentOpacity;t.userData.currentOpacity+=3*a*(n/1e3),t.userData.currentOpacity<.001&&(t.userData.currentOpacity=0),e.material.opacity=.7*t.userData.currentOpacity,i.material.opacity=1*t.userData.currentOpacity,s.material.opacity=.7*t.userData.currentOpacity}}setVisible(t){this.visible=t}dispose(){for(const t of this.beads){const{redSprite:e,greenSprite:i,blueSprite:n}=t.userData;e.material.map&&e.material.map.dispose(),e.material.dispose(),i.material.map&&i.material.map.dispose(),i.material.dispose(),n.material.map&&n.material.map.dispose(),n.material.dispose(),this.scene.remove(t)}this.beads=[],this.sharedTexture&&(this.sharedTexture.dispose(),this.sharedTexture=null),this._directionToCamera=null,this._up=null,this._right=null,this._upVector=null,this._beadOffset=null,this._tempColor=null,this.scene=null}}class RM{constructor(t,e,i=null){this.scene=t,this.sunRadius=e,this.sunMesh=i,this.eclipseType=TM,this.previousEclipseType=TM,this.enabled=!1,this.time=0,this.randomSeed=12345,this.isTransitioning=!1,this.transitionProgress=0,this.transitionDuration=400,this.transitionDirection="in",this.manualControl=!1,this.customShadowCoverage=void 0,this._directionToCamera=new qe,this._up=new qe(0,1,0),this._right=new qe,this._upVector=new qe,this._tempOffset=new qe,this._tempColor=new zn,this.createShadowDisk(),this.createCoronaDisk(),this.createCounterCoronaDisk(),this.sunMesh&&(this.scene.remove(this.coronaDisk),this.scene.remove(this.counterCoronaDisk),this.sunMesh.add(this.coronaDisk),this.sunMesh.add(this.counterCoronaDisk)),this.baileysBeads=new DM(t,e)}createShadowDisk(){const t=this.sunRadius,e=new zr(t,256),i=new Gn({color:0,transparent:!0,opacity:1,blending:4,premultipliedAlpha:!0,side:2,depthWrite:!1,depthTest:!1,fog:!1});this.shadowDisk=new bs(e,i),this.shadowDisk.renderOrder=1e4,this.shadowDisk.position.set(200,0,0),this.scene.add(this.shadowDisk)}createCoronaDisk(){const t=2.05*this.sunRadius,e=.6*this.sunRadius,i=new Qo(e,t,256),n=new Cs({uniforms:{time:{value:0},glowColor:{value:new zn(.9,.95,1)},intensity:{value:2.4},randomSeed:{value:this.randomSeed},uvRotation:{value:0},rayElongation:{value:1},uberHeroElongation:{value:1},isTotalEclipse:{value:0},layer1Mode:{value:11},layer1Strength:{value:2.155},layer1Enabled:{value:1},layer2Mode:{value:5},layer2Strength:{value:.695},layer2Enabled:{value:1},layer3Mode:{value:0},layer3Strength:{value:1},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:1},layer4Enabled:{value:0}},vertexShader:"\n                uniform float uvRotation;\n                varying vec2 vUv;\n\n                void main() {\n                    // Rotate UVs around center (0.5, 0.5)\n                    vec2 centeredUV = uv - 0.5;\n                    float cosRot = cos(uvRotation);\n                    float sinRot = sin(uvRotation);\n                    mat2 rotMatrix = mat2(cosRot, -sinRot, sinRot, cosRot);\n                    vec2 rotatedUV = rotMatrix * centeredUV;\n                    vUv = rotatedUV + 0.5;\n\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            ",fragmentShader:`\n                uniform float time;\n                uniform vec3 glowColor;\n                uniform float intensity;\n                uniform float randomSeed;\n                uniform float rayElongation;\n                uniform float uberHeroElongation;\n                uniform float isTotalEclipse;\n\n                // Blend Layer Uniforms (up to 4 layers)\n                uniform float layer1Mode;\n                uniform float layer1Strength;\n                uniform float layer1Enabled;\n\n                uniform float layer2Mode;\n                uniform float layer2Strength;\n                uniform float layer2Enabled;\n\n                uniform float layer3Mode;\n                uniform float layer3Strength;\n                uniform float layer3Enabled;\n\n                uniform float layer4Mode;\n                uniform float layer4Strength;\n                uniform float layer4Enabled;\n\n                varying vec2 vUv;\n\n                // \n                // UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n                // \n                ${cm}\n\n                // Hash function for pseudo-random variation\n                float hash(float n) {\n                    return fract(sin(n) * 43758.5453123);\n                }\n\n                // 2D hash for more variation\n                float hash2(vec2 p) {\n                    return fract(sin(dot(p, vec2(12.9898 + randomSeed, 78.233 + randomSeed))) * 43758.5453);\n                }\n\n                void main() {\n                    // Calculate distance and angle from center\n                    vec2 center = vec2(0.5, 0.5);\n                    vec2 toCenter = vUv - center;\n                    float dist = length(toCenter) * 2.0; // Normalize to 0-1 range\n                    float angle = atan(toCenter.y, toCenter.x);  // UVs are already rotated in vertex shader\n\n                    // Shadow edge - where corona rays start\n                    // Ring inner edge is at (sunRadius*0.85)/coronaRadius = 0.765/1.845 = 0.415\n                    // Start rays at sun's geometric edge (0.488) so they don't show inside sun\n                    float shadowEdge = 0.488;\n\n                    // Varied radial streamer pattern with artistic composition\n                    float rayIntensity = 0.0;\n\n                    // RULE OF THIRDS: Place 3 hero rays at compositionally strong points\n                    // Golden angles based on rule of thirds: 1/3, 2/3, and offset positions\n                    float heroAngles[3];\n                    heroAngles[0] = hash(randomSeed * 1.234) * 6.28318; // First hero ray (random rotation)\n                    heroAngles[1] = heroAngles[0] + 2.0944; // 120 apart (1/3 circle)\n                    heroAngles[2] = heroAngles[0] + 4.1888; // 240 apart (2/3 circle)\n\n                    // Process hero rays first (3 extra-long dramatic rays)\n                    for (int h = 0; h < 3; h++) {\n                        float rayAngle = heroAngles[h];\n                        float angleDiff = abs(mod(angle - rayAngle + 3.14159, 6.28318) - 3.14159);\n\n                        // Hero rays: extra long and prominent (fit within 0.535 normalized space)\n                        float baseHeroLength = 0.45 + hash(float(h) * 31.415 + randomSeed) * 0.08; // 0.45 to 0.53 (max available, longer!)\n\n                        // Apply UBER elongation: hero rays ALWAYS get extreme elongation (regardless of angle)\n                        // This creates 3 dramatic streamers that extend far in their respective directions\n                        float heroLength = baseHeroLength * uberHeroElongation;\n\n                        // Uber hero rays: keep them narrow but visible for dramatic pointy effect\n                        // Width scales with elongation to stay sharp but visible\n                        float baseHeroWidth = 0.15 + hash(float(h) * 27.183 + randomSeed) * 0.15; // 0.15 to 0.3 base width\n                        float narrowingFactor = mix(1.0, 0.3, (uberHeroElongation - 1.0) / max(uberHeroElongation, 1.0)); // 1.0  0.3 (70% narrower at max elongation)\n                        float heroWidth = baseHeroWidth * narrowingFactor; // Narrow when elongated = pointy!\n\n                        float distFromEdge = dist - shadowEdge;\n\n                        // Ghostly ethereal taper - very gradual falloff\n                        float taper = pow(1.0 - clamp(distFromEdge / max(heroLength, 0.001), 0.0, 1.0), 3.0);\n                        float rayWidth = heroWidth * taper;\n\n                        // Soft feathered edges instead of hard cutoff\n                        float edgeSoftness = 0.15; // Wider feather for smooth edges\n                        float angularMask = smoothstep(rayWidth + edgeSoftness, rayWidth - edgeSoftness, angleDiff);\n\n                        // Very gentle radial falloff for ethereal look\n                        float radialFalloff = pow(taper, 0.8);\n\n                        // Soft radial range with feathered ends\n                        float radialMask = smoothstep(-0.1, 0.05, distFromEdge) *\n                                          smoothstep(heroLength + 0.15, heroLength - 0.05, distFromEdge);\n\n                        float heroIntensity = angularMask * radialFalloff * radialMask * 0.7; // Reduced intensity for ghostly effect\n                        rayIntensity = max(rayIntensity, heroIntensity);\n                    }\n\n                    // 20 supporting rays with rule-of-thirds-aware distribution\n                    for (float i = 0.0; i < 20.0; i++) {\n                        // Cluster more rays around hero ray positions (rule of thirds)\n                        float clusterTarget = mod(i, 3.0); // Which hero ray to cluster near\n                        float clusterAngle = heroAngles[int(clusterTarget)];\n\n                        // Base distribution with clustering tendency\n                        float spreadAngle = (i / 20.0) * 6.28318;\n                        float clusterPull = (hash(i * 13.579 + randomSeed) - 0.5) * 1.5; // Stronger variation\n                        float rayAngle = spreadAngle + clusterPull;\n\n                        float angleDiff = abs(mod(angle - rayAngle + 3.14159, 6.28318) - 3.14159);\n\n                        // Unique random values per ray\n                        float random1 = hash(i * 12.9898 + randomSeed);\n                        float random2 = hash(i * 78.233 + randomSeed);\n                        float random3 = hash(i * 37.719 + randomSeed);\n                        float random4 = hash(i * 93.989 + randomSeed);\n\n                        // Varied lengths following power law distribution (more short, fewer long)\n                        float lengthVariation = random1 * random1; // Squared for naturalistic distribution\n                        float baseRayLength = 0.1 + lengthVariation * 0.7; // 0.1 to 0.8\n\n                        // 20% chance of long streamers (supporting the hero rays)\n                        float isLong = step(0.80, random2);\n                        baseRayLength = mix(baseRayLength, 0.7 + random3 * 0.6, isLong); // 0.7 to 1.3\n\n                        // Apply directional elongation: rays pointing up/down (vertical) get elongated\n                        float verticalWeight = abs(sin(rayAngle));\n                        float elongationFactor = mix(1.0, rayElongation, verticalWeight);\n                        float rayLength = baseRayLength * elongationFactor;\n\n                        // EQUATORIAL ASYMMETRY (total eclipse only): rays along equator are more prominent\n                        // Solar minimum: streamers cluster along equatorial plane\n                        float equatorialWeight = abs(cos(rayAngle)); // 1.0 at horizontal, 0.0 at vertical\n                        float asymmetryBoost = mix(1.0, 1.0 + equatorialWeight * 0.5, isTotalEclipse);\n                        rayLength *= asymmetryBoost;\n\n                        // Varied widths with power law (more thin, fewer thick)\n                        float baseWidth = 0.03 + (random4 * random4) * 0.2; // 0.03 to 0.23 (naturally varied)\n\n                        // Taper: wide at base, narrow at tip\n                        float distFromEdge = dist - shadowEdge;\n\n                        // Ghostly ethereal taper - very gradual falloff\n                        float taper = pow(1.0 - clamp(distFromEdge / max(rayLength, 0.001), 0.0, 1.0), 3.5);\n                        float rayWidth = baseWidth * taper;\n\n                        // Soft feathered edges for ethereal wisps\n                        float edgeSoftness = 0.10; // Wider feather for smooth edges\n                        float angularMask = smoothstep(rayWidth + edgeSoftness, rayWidth - edgeSoftness, angleDiff);\n\n                        // Very gentle radial falloff for ghostly appearance\n                        float radialFalloff = pow(taper, 1.0);\n\n                        // Soft radial range with feathered ends\n                        float radialMask = smoothstep(-0.08, 0.03, distFromEdge) *\n                                          smoothstep(rayLength + 0.12, rayLength - 0.03, distFromEdge);\n\n                        float streamerIntensity = angularMask * radialFalloff * radialMask * 0.5; // Reduced for ethereal wisps\n                        rayIntensity = max(rayIntensity, streamerIntensity);\n                    }\n\n                    // Base corona glow - thinner during total eclipse for realism\n                    float baseGlowWidth = mix(0.04, 0.015, isTotalEclipse); // Thinner during totality\n                    float baseGlow = smoothstep(shadowEdge - 0.01, shadowEdge, dist) *\n                                    (1.0 - smoothstep(shadowEdge + baseGlowWidth * 0.5, shadowEdge + baseGlowWidth, dist));\n\n                    // Enhanced gradient: white  cool blue-white  deep blue with distance\n                    // Distance normalized to corona extent (0 = shadow edge, 1 = far corona)\n                    float coronaDist = clamp((dist - shadowEdge) / 0.6, 0.0, 1.0);\n\n                    // \n                    // TOTAL ECLIPSE ENHANCEMENTS (scaled continuously by isTotalEclipse 0.0-1.0)\n                    // \n\n                    // 1. CHROMOSPHERE RED RIM - thin pink/red ring at sun's edge (hydrogen emission)\n                    float rimStart = shadowEdge;\n                    float rimEnd = shadowEdge + 0.025;\n                    float chromosphereRim = smoothstep(rimStart - 0.005, rimStart, dist) *\n                                     (1.0 - smoothstep(rimEnd - 0.01, rimEnd, dist));\n                    chromosphereRim *= 0.6 * isTotalEclipse; // Scale by eclipse progress\n                    vec3 chromosphereColor = vec3(1.0, 0.3, 0.4); // Pink-red (H-alpha emission)\n\n                    // 2. STRONGER BRIGHTNESS FALLOFF - inner corona much brighter\n                    // Mix between 1.0 (normal) and enhanced falloff based on isTotalEclipse\n                    float enhancedFalloff = mix(3.0, 0.3, pow(coronaDist, 0.7));\n                    float brightnessMultiplier = mix(1.0, enhancedFalloff, isTotalEclipse);\n\n                    // 3. F-CORONA OUTER GLOW - faint diffuse glow from interplanetary dust\n                    float fCoronaDist = clamp((dist - shadowEdge) / 1.2, 0.0, 1.0);\n                    float fCorona = (1.0 - fCoronaDist) * 0.08;\n                    fCorona *= smoothstep(0.3, 0.5, coronaDist);\n                    fCorona *= isTotalEclipse; // Scale by eclipse progress\n\n                    // 4. WISPY TENDRILS - add fine detail noise to ray intensity\n                    float noiseAngle = angle * 8.0 + time * 0.1;\n                    float noiseRadius = dist * 15.0;\n                    float wispyDetail = hash(noiseAngle + noiseRadius + randomSeed * 3.0) * 0.15;\n                    wispyDetail *= rayIntensity * isTotalEclipse; // Scale by eclipse progress\n\n                    // Combine: base glow + streamers + wispy detail\n                    float finalIntensity = (baseGlow * 0.6 + rayIntensity + wispyDetail) * intensity;\n                    finalIntensity *= brightnessMultiplier;\n\n                    // Multi-stage color gradient for realistic corona\n                    vec3 innerGlow = vec3(1.0, 1.0, 1.0);           // Pure white at base\n                    vec3 middleGlow = vec3(0.9, 0.95, 1.0);         // Cool white\n                    vec3 outerGlow = vec3(0.6, 0.75, 0.95);         // Pale blue\n                    vec3 farGlow = vec3(0.3, 0.5, 0.8);             // Deep blue\n\n                    // Three-stage color mix\n                    vec3 coronaColor;\n                    if (coronaDist < 0.3) {\n                        // Inner: white  cool white\n                        coronaColor = mix(innerGlow, middleGlow, coronaDist / 0.3);\n                    } else if (coronaDist < 0.7) {\n                        // Middle: cool white  pale blue\n                        coronaColor = mix(middleGlow, outerGlow, (coronaDist - 0.3) / 0.4);\n                    } else {\n                        // Outer: pale blue  deep blue\n                        coronaColor = mix(outerGlow, farGlow, (coronaDist - 0.7) / 0.3);\n                    }\n\n                    vec3 finalColor = coronaColor * finalIntensity;\n\n                    // Add chromosphere red rim (total eclipse only)\n                    finalColor += chromosphereColor * chromosphereRim * intensity;\n\n                    // Add F-corona outer glow (total eclipse only)\n                    finalColor += vec3(0.9, 0.85, 0.8) * fCorona * intensity; // Slightly warm white\n\n                    // \n                    // BLEND LAYERS (Applied globally to entire corona)\n                    // These allow adjusting the appearance of the corona to prevent black edges\n                    // \n\n                    // Layer 1\n                    if (layer1Enabled > 0.5) {\n                        vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n                        int mode1 = int(layer1Mode + 0.5);\n                        vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n                        finalColor = clamp(blended1, 0.0, 1.0);\n                    }\n\n                    // Layer 2\n                    if (layer2Enabled > 0.5) {\n                        vec3 blendColor2 = vec3(min(layer2Strength, 1.0));\n                        int mode2 = int(layer2Mode + 0.5);\n                        vec3 blended2 = clamp(applyBlendMode(finalColor, blendColor2, mode2), 0.0, 1.0);\n                        finalColor = clamp(blended2, 0.0, 1.0);\n                    }\n\n                    // Layer 3\n                    if (layer3Enabled > 0.5) {\n                        vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n                        int mode3 = int(layer3Mode + 0.5);\n                        vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n                        finalColor = clamp(blended3, 0.0, 1.0);\n                    }\n\n                    // Layer 4\n                    if (layer4Enabled > 0.5) {\n                        vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n                        int mode4 = int(layer4Mode + 0.5);\n                        vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n                        finalColor = clamp(blended4, 0.0, 1.0);\n                    }\n\n                    // Sharp alpha falloff to prevent black bleeding in bloom\n                    // Higher power = sharper cutoff at edges (less semi-transparent area)\n                    float alphaFalloff = pow(1.0 - coronaDist, 3.0);\n                    float alpha = finalIntensity * alphaFalloff * 0.95;\n\n                    gl_FragColor = vec4(finalColor, alpha);\n                }\n            `,transparent:!0,blending:2,depthWrite:!1,side:2});this.coronaDisk=new bs(i,n),this.coronaDisk.position.set(0,0,0),this.coronaDisk.renderOrder=9998,this.scene.add(this.coronaDisk)}createCounterCoronaDisk(){const t=this.coronaDisk.geometry,e=this.randomSeed+5e3,i=new Cs({uniforms:{time:{value:0},glowColor:{value:new zn(.9,.95,1)},intensity:{value:2.4},randomSeed:{value:e},uvRotation:{value:0},rayElongation:{value:1},uberHeroElongation:{value:1},isTotalEclipse:{value:0},layer1Mode:{value:11},layer1Strength:{value:2.155},layer1Enabled:{value:1},layer2Mode:{value:5},layer2Strength:{value:.695},layer2Enabled:{value:1},layer3Mode:{value:0},layer3Strength:{value:1},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:1},layer4Enabled:{value:0}},vertexShader:this.coronaDisk.material.vertexShader,fragmentShader:this.coronaDisk.material.fragmentShader,transparent:!0,blending:2,depthWrite:!1,side:2});this.counterCoronaDisk=new bs(t,i),this.counterCoronaDisk.position.set(0,0,0),this.counterCoronaDisk.renderOrder=9997,this.scene.add(this.counterCoronaDisk)}setShadowCoverage(t){this.customShadowCoverage=t}setCoronaBlendLayer(t,e){if(t<1||t>4)return void console.error(` Invalid corona layer number: ${t} (must be 1-4)`);const{mode:i=0,strength:n=1,enabled:s=!1}=e;this.coronaDisk?.material?.uniforms&&(this.coronaDisk.material.uniforms[`layer${t}Mode`].value=i,this.coronaDisk.material.uniforms[`layer${t}Strength`].value=n,this.coronaDisk.material.uniforms[`layer${t}Enabled`].value=s?1:0),this.counterCoronaDisk?.material?.uniforms&&(this.counterCoronaDisk.material.uniforms[`layer${t}Mode`].value=i,this.counterCoronaDisk.material.uniforms[`layer${t}Strength`].value=n,this.counterCoronaDisk.material.uniforms[`layer${t}Enabled`].value=s?1:0)}setEclipseType(t){if(t===this.eclipseType)return;const e=this.enabled;this.previousEclipseType=this.eclipseType,this.eclipseType=t,this.enabled=t!==TM,this.manualControl=!1;const i=PM(this.previousEclipseType),n=PM(t);this.startShadowCoverage=i.shadowCoverage,this.targetShadowCoverage=n.shadowCoverage,!e&&this.enabled?(this.transitionDirection="in",this.isTransitioning=!0,this.transitionProgress=0):e&&!this.enabled?(this.transitionDirection="out",this.isTransitioning=!0,this.transitionProgress=0):e&&this.enabled&&(this.isTransitioning=!0,this.transitionProgress=0,this.transitionDirection="switch")}easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}setManualProgress(t){this.manualControl=!0,this.transitionProgress=Math.max(0,Math.min(1,t)),this.isTransitioning=!0,this.transitionDirection="in"}setManualShadowPosition(t){this.manualControl=!0,this.manualShadowPosition=Math.max(-2,Math.min(2,t)),this.isTransitioning=!0,this.transitionDirection="manual"}update(t,e,i,n=null){const s=t.position,a=e.position,r=e.scale.x;let o=1;if(null!==n&&n>.5){const t=2*(n-.5);o=t*t*t}else if(null!==n&&n<=.5){const t=2*n;o=(1-t)*(1-t)*(1-t)}const l=this.eclipseType===TM?3:1;if(this.time+=i*l,this.isTransitioning&&!this.manualControl){const t=i/this.transitionDuration;this.transitionProgress+=t,this.transitionProgress>=1&&(this.transitionProgress=1,this.isTransitioning=!1)}if(this.enabled||"out"===this.transitionDirection&&this.isTransitioning){const t="out"===this.transitionDirection&&this.isTransitioning?this.previousEclipseType:this.eclipseType,e=PM(t),n=this.sunRadius*r,l=this.easeInOutCubic(this.transitionProgress);let h;void 0!==this.customShadowCoverage?h=this.customShadowCoverage:"switch"===this.transitionDirection&&this.isTransitioning&&void 0!==this.startShadowCoverage&&void 0!==this.targetShadowCoverage?h=this.startShadowCoverage+(this.targetShadowCoverage-this.startShadowCoverage)*l:({shadowCoverage:h}=e);const c=n*h/this.sunRadius;this.shadowDisk.scale.setScalar(c),this.currentShadowPosX=-2,"manual"===this.transitionDirection&&void 0!==this.manualShadowPosition?this.currentShadowPosX=this.manualShadowPosition:this.isTransitioning?"in"===this.transitionDirection?this.currentShadowPosX=2*l-2:"out"===this.transitionDirection?this.currentShadowPosX=0+1*l:"switch"===this.transitionDirection&&(this.currentShadowPosX=0):this.currentShadowPosX=0;const u=this.currentShadowPosX,d=2.5*n,p=u*d*.5,m=-u*u*d*.25;this._directionToCamera.subVectors(s,a).normalize(),this._right.crossVectors(this._directionToCamera,this._up).normalize(),this._upVector.crossVectors(this._right,this._directionToCamera).normalize();const g=0;this._tempOffset.copy(this._directionToCamera).multiplyScalar(g),this.shadowDisk.position.copy(a).add(this._tempOffset),this._tempOffset.copy(this._right).multiplyScalar(p),this.shadowDisk.position.add(this._tempOffset),this._tempOffset.copy(this._upVector).multiplyScalar(m),this.shadowDisk.position.add(this._tempOffset),this.shadowDisk.lookAt(s),this.coronaDisk.parent&&this.coronaDisk.parent!==this.scene||(this.coronaDisk.position.copy(a),this.counterCoronaDisk.position.copy(a),this.coronaDisk.scale.setScalar(r),this.counterCoronaDisk.scale.setScalar(r));const f=Math.abs(this.currentShadowPosX||0),y=2,v=Math.max(0,1-f/y);let b=0;if("switch"===this.transitionDirection&&this.isTransitioning){const t=this.previousEclipseType===EM,e=this.eclipseType===EM;e&&!t?b=l:!e&&t&&(b=1-l)}else t===EM&&(b=1);const M=1+(1+24*Math.pow(v,4)-1)*b,_=1+(1+199*Math.pow(v,5)-1)*b;this.coronaDisk.material.uniforms.rayElongation.value=M,this.counterCoronaDisk.material.uniforms.rayElongation.value=M,this.coronaDisk.material.uniforms.uberHeroElongation.value=_,this.counterCoronaDisk.material.uniforms.uberHeroElongation.value=_;const x=.5,w=.99,S=Math.max(0,Math.min(1,(v-x)/(w-x))),T=S*S*(3-2*S),C=T*b;this.coronaDisk.material.uniforms.isTotalEclipse.value=C,this.counterCoronaDisk.material.uniforms.isTotalEclipse.value=C;const E=b>0&&v>=x,A=1-.947*T*b;this.setCoronaBlendLayer(3,{mode:1,strength:A,enabled:E}),this.coronaDisk.lookAt(s),this.counterCoronaDisk.lookAt(s);let P=0;if(t===TM)P=i/1e3*.075;else if(t===CM){const t=.075;P=i/1e3*(t-(t-.25*t)*v)}else if(t===EM){const t=.075;P=i/1e3*(t-(t-.05*t)*v)}this.coronaDisk.material.uniforms.uvRotation.value+=P,this.counterCoronaDisk.material.uniforms.uvRotation.value-=P;let D=1.2;if(t===TM)D=3.6;else if(t===CM){const t=3.6,e=.08*t;this.transitionDirection,D=t-(t-e)*v}else if(t===EM){const t=3.6,e=.65*t;this.transitionDirection,D=t-(t-e)*v}this.coronaDisk.material.uniforms.intensity.value=D*o,this.counterCoronaDisk.material.uniforms.intensity.value=D*o,this.coronaDisk.material.uniforms.time.value=this.time,this.counterCoronaDisk.material.uniforms.time.value=this.time}else{this.shadowDisk.position.set(200,0,0),this.coronaDisk.parent&&this.coronaDisk.parent!==this.scene||(this.coronaDisk.position.copy(a),this.counterCoronaDisk.position.copy(a),this.coronaDisk.scale.setScalar(r),this.counterCoronaDisk.scale.setScalar(r)),this.coronaDisk.material.uniforms.rayElongation.value=1,this.counterCoronaDisk.material.uniforms.rayElongation.value=1,this.coronaDisk.material.uniforms.uberHeroElongation.value=1,this.counterCoronaDisk.material.uniforms.uberHeroElongation.value=1,this.coronaDisk.material.uniforms.isTotalEclipse.value=0,this.counterCoronaDisk.material.uniforms.isTotalEclipse.value=0,this.coronaDisk.material.uniforms.intensity.value=3.06*o,this.counterCoronaDisk.material.uniforms.intensity.value=3.06*o,this.setCoronaBlendLayer(3,{mode:1,strength:0,enabled:!1}),this.coronaDisk.lookAt(s),this.counterCoronaDisk.lookAt(s);const t=i/1e3*.075;this.coronaDisk.material.uniforms.uvRotation.value+=t,this.counterCoronaDisk.material.uniforms.uvRotation.value-=t,this.coronaDisk.material.uniforms.intensity.value=3.6*o,this.counterCoronaDisk.material.uniforms.intensity.value=3.6*o,this.coronaDisk.material.uniforms.time.value=this.time,this.counterCoronaDisk.material.uniforms.time.value=this.time}if(this.eclipseType===EM){let e=0,n=!1;if("manual"===this.transitionDirection){const t=Math.abs(this.currentShadowPosX),i=2;e=Math.max(0,Math.min(1,1-t/i)),e>=.9&&e<=1&&(n=!0)}else if("in"===this.transitionDirection&&this.isTransitioning){const t=.8;this.transitionProgress>=t&&(n=!0,e=.9+(this.transitionProgress-t)/(1-t)*.1)}else if("out"===this.transitionDirection&&this.isTransitioning){const t=.2;this.transitionProgress<=t&&(n=!0,e=1-this.transitionProgress/t*.1)}else this.isTransitioning||(e=1,n=!0);this.baileysBeads.setVisible(n),this.baileysBeads.update(t,a,e,i,r)}else this.baileysBeads.setVisible(!1),this.baileysBeads.update(t,a,0,i,r)}dispose(){this.shadowDisk&&(this.scene.remove(this.shadowDisk),this.shadowDisk.geometry.dispose(),this.shadowDisk.material.dispose(),this.shadowDisk=null),this.coronaDisk&&(this.coronaDisk.parent&&this.coronaDisk.parent.remove(this.coronaDisk),this.coronaDisk.geometry.dispose(),this.coronaDisk.material.dispose(),this.coronaDisk=null),this.counterCoronaDisk&&(this.counterCoronaDisk.parent&&this.counterCoronaDisk.parent.remove(this.counterCoronaDisk),this.counterCoronaDisk.material.dispose(),this.counterCoronaDisk=null),this.baileysBeads&&(this.baileysBeads.dispose(),this.baileysBeads=null),this._directionToCamera=null,this._up=null,this._right=null,this._upVector=null,this._tempOffset=null,this._tempColor=null,this.scene=null,this.sunMesh=null}}class IM{constructor(t){this.material=t,this.eclipseType="off",this.progress=0,this.targetProgress=0,this.animating=!1,this.bloodMoonColor={r:.85,g:.18,b:.08},this.animationDuration=3e3,this.startTime=0,this.shadowX=-2,this.shadowY=0,this.shadowRadius=.7,this.targetShadowX=-2,this.shadowSpeed=1,this.emissiveStrength=0,this.targetEmissive=0,this.shadowDarkness=1,this.targetDarkness=1,this.material.uniforms.eclipseProgress||(this.material.uniforms.eclipseProgress={value:0},this.material.uniforms.eclipseIntensity={value:0},this.material.uniforms.bloodMoonColor={value:[this.bloodMoonColor.r,this.bloodMoonColor.g,this.bloodMoonColor.b]},this.material.uniforms.eclipseShadowPos={value:[this.shadowX,this.shadowY]},this.material.uniforms.eclipseShadowRadius={value:this.shadowRadius})}setEclipseType(t){if(this.eclipseType===t)return;const e="off"===this.eclipseType;switch(this.eclipseType=t,e&&"off"!==t&&(this.shadowX=-2,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY]),t){case"off":this.targetProgress=0,this.targetShadowX=2,this.targetEmissive=0,this.targetDarkness=1;break;case"penumbral":this.targetProgress=.3,this.targetShadowX=-1,this.targetEmissive=.05,this.targetDarkness=.85;break;case"partial":this.targetProgress=.65,this.targetShadowX=-.4,this.targetEmissive=.2,this.targetDarkness=.7;break;case"total":this.targetProgress=1,this.targetShadowX=0,this.targetEmissive=.39,this.targetDarkness=.53;break;default:return void console.warn(`Unknown lunar eclipse type: ${t}`)}this.animating=!0,this.startTime=performance.now()}update(t){if(!this.animating)return;const e=performance.now()-this.startTime,i=Math.min(e/this.animationDuration,1),n=this.easeInOutCubic(i);this.progress=this.progress+(this.targetProgress-this.progress)*n,this.shadowX=this.shadowX+(this.targetShadowX-this.shadowX)*n*this.shadowSpeed,this.emissiveStrength=this.emissiveStrength+(this.targetEmissive-this.emissiveStrength)*n,this.shadowDarkness=this.shadowDarkness+(this.targetDarkness-this.shadowDarkness)*n,this.material.uniforms.eclipseProgress.value=this.progress,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY],this.material.uniforms.emissiveStrength&&(this.material.uniforms.emissiveStrength.value=this.emissiveStrength),this.material.uniforms.shadowDarkness&&(this.material.uniforms.shadowDarkness.value=this.shadowDarkness);let s=0;"total"===this.eclipseType?s=this.progress:"partial"===this.eclipseType?s=.6*this.progress:"penumbral"===this.eclipseType&&(s=.25*this.progress),this.material.uniforms.eclipseIntensity.value=s,i>=1&&(this.animating=!1)}easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}reset(){this.progress=0,this.targetProgress=0,this.shadowX=-2,this.targetShadowX=-2,this.emissiveStrength=0,this.targetEmissive=0,this.shadowDarkness=1,this.targetDarkness=1,this.animating=!1,this.eclipseType="off",this.material.uniforms.eclipseProgress&&(this.material.uniforms.eclipseProgress.value=0,this.material.uniforms.eclipseIntensity.value=0,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY]),this.material.uniforms.emissiveStrength&&(this.material.uniforms.emissiveStrength.value=0),this.material.uniforms.shadowDarkness&&(this.material.uniforms.shadowDarkness.value=1)}dispose(){}}const BM=["crystal","rough","heart","star"];class LM{constructor(t,e="/assets"){this.renderer=t,this.assetBasePath=e,this.solarEclipse=null,this.lunarEclipse=null,this.crystalSoul=null,this.currentGeometryType=null,this.coreGlowEnabled=!0}initializeForGeometry(t,e={}){const{coreMesh:i,customMaterial:n,sunRadius:s=1}=e;this.currentGeometryType=t,this._cleanupUnneededEffects(t),"sun"===t?this._initSolarEclipse(s,i):"moon"===t&&this._initLunarEclipse(n)}_initSolarEclipse(t,e){!this.solarEclipse&&this.renderer?.scene&&(this.solarEclipse=new RM(this.renderer.scene,t,e))}_initLunarEclipse(t){!this.lunarEclipse&&t&&(this.lunarEclipse=new IM(t))}_cleanupUnneededEffects(t){"sun"!==t&&this.solarEclipse&&(this.solarEclipse.dispose(),this.solarEclipse=null),"moon"!==t&&this.lunarEclipse&&(this.lunarEclipse.dispose(),this.lunarEclipse=null),!BM.includes(t)&&this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null)}async createCrystalSoul(t={}){const{coreMesh:e,geometryType:i}=t;if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!e)return null;await sM._loadInclusionGeometry(this.assetBasePath),this.crystalSoul=new sM({radius:.35,detail:1,geometryType:i,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(e,this.renderer?.scene);const{shellBaseScale:n,soulScale:s}=this._getCrystalScaleConfig(i);return this.crystalSoul.baseScale=s,this.crystalSoul.mesh.scale.setScalar(s),this.crystalSoul.setVisible(this.coreGlowEnabled),{mesh:this.crystalSoul.mesh,material:this.crystalSoul.material,baseScale:this.crystalSoul.baseScale,shellBaseScale:n}}createCrystalSoulSync(t={}){const{coreMesh:e,geometryType:i}=t;if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!e)return null;this.crystalSoul=new sM({radius:.35,detail:1,geometryType:i,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(e,this.renderer?.scene);const{shellBaseScale:n,soulScale:s}=this._getCrystalScaleConfig(i);return this.crystalSoul.baseScale=s,this.crystalSoul.mesh.scale.setScalar(s),this.crystalSoul.setVisible(this.coreGlowEnabled),{mesh:this.crystalSoul.mesh,material:this.crystalSoul.material,baseScale:this.crystalSoul.baseScale,shellBaseScale:n}}_getCrystalScaleConfig(t){let e=2,i=1;return"heart"===t?(e=2.4,i=1):"rough"===t?(e=1.6,i=1):"star"===t?(e=2,i=1.4):"crystal"===t&&(e=2,i=1),{shellBaseScale:e,soulScale:i}}setSolarEclipse(t){return!!this.solarEclipse&&(this.solarEclipse.setEclipseType(t),!0)}setLunarEclipse(t){return!!this.lunarEclipse&&(this.lunarEclipse.setEclipseType(t),!0)}stopAllEclipses(){this.solarEclipse&&this.solarEclipse.setEclipseType("off"),this.lunarEclipse&&this.lunarEclipse.setEclipseType("off")}updateCrystalSoul(t,e,i=1){this.crystalSoul&&this.crystalSoul.update(t,e,i)}updateLunarEclipse(t){this.lunarEclipse&&this.lunarEclipse.update(t)}setCrystalSoulEffects(t){this.crystalSoul&&this.crystalSoul.setEffects(t)}setCrystalSoulSize(t){return this.crystalSoul?(this.crystalSoul.setSize(t),this.crystalSoul.baseScale):1}setCrystalSoulVisible(t){this.coreGlowEnabled=t,this.crystalSoul&&this.crystalSoul.setVisible(t)}hasCrystalSoul(){return!!this.crystalSoul}getCrystalSoulBaseScale(){return this.crystalSoul?.baseScale??1}hasSolarEclipse(){return!!this.solarEclipse}hasLunarEclipse(){return!!this.lunarEclipse}getSolarEclipse(){return this.solarEclipse}dispose(){this.solarEclipse&&(this.solarEclipse.dispose(),this.solarEclipse=null),this.lunarEclipse&&(this.lunarEclipse.dispose(),this.lunarEclipse=null),this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),this.renderer=null}}class kM{constructor(t={},e=null,i=null){if(this.config=t,this.rhythmEngine=e,this.geometryRotation=i,this.type=t.type||"gentle",this.speed=t.speed||1,i&&void 0!==i.baseSpeed){const t=i.baseSpeed,e=i.axes||[0,1,0];this.axes=[e[0]*t*this.speed,e[1]*t*this.speed,e[2]*t*this.speed]}else this.axes=t.axes||[0,.01,0];this.shake=t.shake||{amplitude:0,frequency:0},this.wobbleEnabled=!0,this.eruption=t.eruption||{enabled:!1},this.eruption.enabled&&(this.eruption.interval=this.eruption.interval||3e3,this.eruption.speedMultiplier=this.eruption.speedMultiplier||3,this.eruption.duration=this.eruption.duration||400,this.eruption.nextEruptionTime=this.eruption.interval,this.eruption.eruptionStartTime=-1),this.musicSync=void 0!==t.musicSync&&t.musicSync,this.time=0,this.episodicWobble={enabled:!1,minInterval:2e3,maxInterval:5e3,amplitude:.05,duration:200,nextWobbleTime:0,wobbleStartTime:-1,wobbleTarget:[0,0,0]}}update(t,e){switch(this.time+=t,this.episodicWobble.enabled&&this.wobbleEnabled&&this._applyEpisodicWobble(t,e),this.type){case"gentle":default:return this._evaluateGentle(t,e);case"unstable":return this._evaluateUnstable(t,e);case"rhythmic":return this._evaluateRhythmic(t,e);case"orbital":return this._evaluateOrbital(t,e);case"still":return this._evaluateStill(t,e);case"suspicious":return this._evaluateSuspicious(t,e)}}_evaluateGentle(t,e){const i=.001*t;return e[0]+=this.axes[0]*this.speed*i,e[1]+=this.axes[1]*this.speed*i,e[2]+=this.axes[2]*this.speed*i,e}_evaluateUnstable(t,e){const i=.001*t;let n=1;if(this.eruption.enabled&&(this.eruption.eruptionStartTime<0&&this.time>=this.eruption.nextEruptionTime&&(this.eruption.eruptionStartTime=this.time),this.eruption.eruptionStartTime>=0)){const t=this.time-this.eruption.eruptionStartTime;if(t<this.eruption.duration){const e=t/this.eruption.duration,i=Math.sin(e*Math.PI);n=1+(this.eruption.speedMultiplier-1)*i}else this.eruption.eruptionStartTime=-1,this.eruption.nextEruptionTime=this.time+this.eruption.interval}const s=this.speed*n;if(e[0]+=this.axes[0]*s*i,e[1]+=this.axes[1]*s*i,e[2]+=this.axes[2]*s*i,this.wobbleEnabled){const t=.001*this.time,i=this.shake.frequency||8,n=this.shake.amplitude||.02,s=.02,a=Math.min(n,s),r=Math.sin(t*i*Math.PI*2)*a*.7,o=Math.sin(t*i*Math.PI*2*1.3)*a*.5,l=Math.sin(t*i*Math.PI*2*.9)*a*.8;e[0]+=r,e[1]+=o,e[2]+=l}return e}_evaluateRhythmic(t,e){const i=.001*t;if(!this.musicSync||!this.rhythmEngine)return this._evaluateGentle(t,e);{const t=60/(this.rhythmEngine.bpm||120),n=.001*this.time%t,s=1+.3*Math.sin(n/t*Math.PI*2);e[0]+=this.axes[0]*this.speed*s*i,e[1]+=this.axes[1]*this.speed*s*i,e[2]+=this.axes[2]*this.speed*s*i}return e}_evaluateOrbital(t,e){const i=.001*t,n=.001*this.time,s=.5*this.speed,a=.1*Math.sin(n*s*Math.PI*2),r=.05*Math.sin(n*s*Math.PI*2*.5);return e[0]+=a*i,e[1]+=this.axes[1]*this.speed*i,e[2]+=r*i,e}_evaluateStill(t,e){const i=.001*t;return e[0]+=.1*this.axes[0]*i,e[1]+=.1*this.axes[1]*i,e[2]+=.1*this.axes[2]*i,e}_evaluateSuspicious(t,e){const i=.001*t,n=.001*this.time,s=4/this.speed,a=n%s/s;let r;if(a<.85)r=a/.85*Math.PI;else{const t=(a-.85)/.15;r=Math.PI*(1-t)}const o=r-e[1];return e[1]+=3*o*i,e}reset(){this.time=0}_applyEpisodicWobble(t,e){const i=this.episodicWobble;if(-1===i.wobbleStartTime&&this.time>=i.nextWobbleTime){i.wobbleStartTime=this.time,i.wobbleTarget=[(Math.random()-.5)*i.amplitude,(Math.random()-.5)*i.amplitude,(Math.random()-.5)*i.amplitude];const t=i.minInterval+Math.random()*(i.maxInterval-i.minInterval);i.nextWobbleTime=this.time+t}if(-1!==i.wobbleStartTime){const t=this.time-i.wobbleStartTime,n=Math.min(t/i.duration,1);if(n<1){const t=Math.sin(n*Math.PI);e[0]+=i.wobbleTarget[0]*t,e[1]+=i.wobbleTarget[1]*t,e[2]+=i.wobbleTarget[2]*t}else i.wobbleStartTime=-1}}updateConfig(t){if(this.config=t,this.type=t.type||"gentle",this.speed=t.speed||1,this.geometryRotation&&void 0!==this.geometryRotation.baseSpeed){const t=this.geometryRotation.baseSpeed,e=this.geometryRotation.axes||[0,1,0];this.axes=[e[0]*t*this.speed,e[1]*t*this.speed,e[2]*t*this.speed]}else this.axes=t.axes||[0,.01,0];this.shake=t.shake||{amplitude:0,frequency:0},this.musicSync=void 0!==t.musicSync&&t.musicSync}applyUndertoneMultipliers(t){if(void 0!==t.speedMultiplier&&(this.speed*=t.speedMultiplier),void 0!==t.shakeMultiplier&&this.shake.amplitude&&(this.shake.amplitude*=t.shakeMultiplier),void 0!==t.enableEpisodicWobble&&(this.episodicWobble.enabled=t.enableEpisodicWobble,this.episodicWobble.enabled&&0===this.episodicWobble.nextWobbleTime)){const t=this.episodicWobble.minInterval+Math.random()*(this.episodicWobble.maxInterval-this.episodicWobble.minInterval);this.episodicWobble.nextWobbleTime=this.time+t}}setWobbleEnabled(t){this.wobbleEnabled=t}}class OM{constructor(t={}){this.config=t,this.strength=void 0!==t.strength?t.strength:.5,this.damping=void 0!==t.damping?t.damping:.8,this.centerOfMass=t.centerOfMass||[0,-.3,0],this.axes=t.axes||{pitch:!0,roll:!0,yaw:!1},this.angularVelocity={x:0,y:0,z:0}}update(t,e){if(0===this.strength)return e;const i=.001*t,n=e[0],s=e[1],a=e[2];if(this.axes.pitch){const t=-n*this.strength;this.angularVelocity.x+=t*i,this.angularVelocity.x*=1-this.damping,e[0]+=this.angularVelocity.x*i}if(this.axes.roll){const t=-a*this.strength;this.angularVelocity.z+=t*i,this.angularVelocity.z*=1-this.damping,e[2]+=this.angularVelocity.z*i}if(this.axes.yaw){const t=-s*this.strength;this.angularVelocity.y+=t*i,this.angularVelocity.y*=1-this.damping,e[1]+=this.angularVelocity.y*i}return e}reset(){this.angularVelocity={x:0,y:0,z:0}}updateConfig(t){this.config=t,this.strength=void 0!==t.strength?t.strength:this.strength,this.damping=void 0!==t.damping?t.damping:this.damping,this.centerOfMass=t.centerOfMass||this.centerOfMass,this.axes=t.axes||this.axes}applyUndertoneMultipliers(t){void 0!==t.strengthMultiplier&&(this.strength*=t.strengthMultiplier)}}class zM{constructor(t={},e=null){this.config=t,this.camera=e,this.strength=void 0!==t.strength?t.strength:1,this.lockedFace=t.lockedFace||[0,0,1],this.calibrationRotation=t.calibrationRotation||[0,0,0],this.lerpSpeed=void 0!==t.lerpSpeed?t.lerpSpeed:1,this.tempVector=new qe,this.tempQuaternion=new Xe,this.targetQuaternion=new Xe,this.calibrationQuaternion=new Xe,this.currentQuaternion=new Xe,this._lockedFaceVec=new qe,this._targetMatrix=new Wi,this._lookAtOrigin=new qe(0,0,0),this._upVector=new qe(0,1,0),this._tempEuler=new tn(0,0,0,"XYZ"),this._defaultPosition=new qe(0,0,0)}update(t,e,i){if(0===this.strength||!this.camera)return e;const n=i||this._defaultPosition,s=.001*t;this.tempVector.copy(this.camera.position).sub(n),this.tempVector.lengthSq()<1e-4&&this.tempVector.set(0,0,1),this.tempVector.normalize(),this._lockedFaceVec.set(this.lockedFace[0],this.lockedFace[1],this.lockedFace[2]).normalize(),this._targetMatrix.lookAt(this.tempVector,this._lookAtOrigin,this._upVector),this.targetQuaternion.setFromRotationMatrix(this._targetMatrix),0===this.calibrationRotation[0]&&0===this.calibrationRotation[1]&&0===this.calibrationRotation[2]||(this._tempEuler.set(this.calibrationRotation[0],this.calibrationRotation[1],this.calibrationRotation[2],"XYZ"),this.calibrationQuaternion.setFromEuler(this._tempEuler),this.targetQuaternion.multiply(this.calibrationQuaternion)),this._tempEuler.set(e[0],e[1],e[2],"XYZ"),this.currentQuaternion.setFromEuler(this._tempEuler);const a=Math.min(1,this.strength*this.lerpSpeed*s*60);return this.currentQuaternion.slerp(this.targetQuaternion,a),this._tempEuler.setFromQuaternion(this.currentQuaternion,"XYZ"),e[0]=this._tempEuler.x,e[1]=this._tempEuler.y,e[2]=this._tempEuler.z,e}setCamera(t){this.camera=t}setCalibrationRotation(t){this.calibrationRotation=t}updateConfig(t){this.config=t,this.strength=void 0!==t.strength?t.strength:this.strength,this.lockedFace=t.lockedFace||this.lockedFace,this.calibrationRotation=t.calibrationRotation||this.calibrationRotation,this.lerpSpeed=void 0!==t.lerpSpeed?t.lerpSpeed:this.lerpSpeed}dispose(){this.camera=null,this.tempVector=null,this.tempQuaternion=null,this.targetQuaternion=null,this.calibrationQuaternion=null,this.currentQuaternion=null}}const FM={strength:5,damping:.85,centerOfMass:[0,-.3,0],axes:{pitch:!0,roll:!0,yaw:!1}};class UM{constructor(t={}){this.rotationBehavior=null,this.rightingBehavior=null,this.facingBehavior=null,this.rotationDisabled=t.rotationDisabled||!1,this.wobbleEnabled=!1!==t.wobbleEnabled,this.rhythmEngine=t.rhythmEngine||null,this.camera=t.camera||null,this.geometryType=null,this.rightingBehavior=new OM(FM)}configureForEmotion(t={}){const{geometryType:e,emotionData:i,facingConfig:n,geometryRotation:s}=t;if(this.geometryType=e,"moon"===e)return this._disableRotation(),void this._initFacingBehavior(n);this._disposeFacingBehavior(),this.rotationDisabled?this._disableRotation():(i?.["3d"]?.rotation?this._configureRotationFromEmotion(i["3d"].rotation,s):this._ensureDefaultRotation(s),this.rightingBehavior&&this.rightingBehavior.reset())}applyUndertone(t){t&&(t.rotation&&this.rotationBehavior&&this.rotationBehavior.applyUndertoneMultipliers(t.rotation),t.righting&&this.rightingBehavior&&this.rightingBehavior.applyUndertoneMultipliers(t.righting))}update(t,e){this.rotationBehavior?this.rotationBehavior.update(t,e):"moon"===this.geometryType||this.rotationDisabled||(e[1]+=3e-4*t),this.rightingBehavior&&this.rightingBehavior.update(t,e),this.facingBehavior&&(e[0]=0,e[1]=0,e[2]=0)}setWobbleEnabled(t){this.wobbleEnabled=t,this.rotationBehavior&&this.rotationBehavior.setWobbleEnabled(t),!t&&this.rightingBehavior&&this.rightingBehavior.reset()}resetRighting(){this.rightingBehavior&&this.rightingBehavior.reset()}getAngularVelocity(){return this.rotationBehavior?this.rotationBehavior.axes:[0,0,0]}hasRotationBehavior(){return!!this.rotationBehavior}hasFacingBehavior(){return!!this.facingBehavior}configureForMorph(t={}){const{targetGeometryType:e,emotionData:i,facingConfig:n,geometryRotation:s}=t;this.resetRighting(),this.configureForEmotion({geometryType:e,emotionData:i,facingConfig:n,geometryRotation:s})}_configureRotationFromEmotion(t,e){this.rotationBehavior?this.rotationBehavior.updateConfig(t):this.rotationBehavior=new kM(t,this.rhythmEngine,e),this.rotationBehavior.setWobbleEnabled(this.wobbleEnabled)}_ensureDefaultRotation(t){this.rotationBehavior||(this.rotationBehavior=new kM({type:"gentle",speed:1,axes:[0,.01,0]},this.rhythmEngine,t),this.rotationBehavior.setWobbleEnabled(this.wobbleEnabled))}_disableRotation(){this.rotationBehavior=null}_initFacingBehavior(t){!this.facingBehavior&&t?.enabled&&(this.facingBehavior=new zM({strength:t.strength,lockedFace:t.lockedFace,lerpSpeed:t.lerpSpeed,calibrationRotation:t.calibrationRotation},this.camera))}_disposeFacingBehavior(){this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null)}dispose(){this.rotationBehavior&&(this.rotationBehavior.destroy?.(),this.rotationBehavior=null),this.rightingBehavior&&(this.rightingBehavior.destroy?.(),this.rightingBehavior=null),this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null)}}class NM{constructor(){this._phase=null,this._startTime=0,this._duration=0,this._startScale=1,this._targetScale=1,this._currentScale=1}startPhase(t,e){const i=Math.max(.5,Math.min(30,e));switch(this._startScale=this._currentScale,this._startTime=performance.now(),this._duration=1e3*i,this._phase=t,t){case"inhale":this._targetScale=1.3;break;case"exhale":this._targetScale=.85;break;default:this._targetScale=this._startScale}}stop(){this._phase=null,this._currentScale=1,this._startScale=1,this._targetScale=1}isActive(){return null!==this._phase}getPhase(){return this._phase}update(t){if(!this._phase)return this._currentScale;const e=performance.now()-this._startTime,i=Math.min(1,e/this._duration),n=Math.sin(i*Math.PI/2);return this._currentScale=this._startScale+(this._targetScale-this._startScale)*n,i>=1&&(this._currentScale=this._targetScale,this._phase=null),this._currentScale}getScaleMultiplier(){return this._currentScale}getState(){return{phase:this._phase,startScale:this._startScale,targetScale:this._targetScale,currentScale:this._currentScale,duration:this._duration,isActive:null!==this._phase}}dispose(){this._phase=null}}class GM{static generate(t,e={}){const{shardCount:i=30,minShardSize:n=.05,seed:s=Date.now(),preserveUVs:a=!0}=e,r=t.index?t:this._toIndexed(t),o=r.getAttribute("position"),l=r.getIndex(),h=r.getAttribute("uv"),c=r.getAttribute("normal");if(!l||0===l.count)return console.warn("ShardGenerator: No valid indices found"),[];const u=l.count/3;if(0===u)return console.warn("ShardGenerator: No faces found"),[];const d=this._buildAdjacencyGraph(l,u),p=Math.min(i,u);return this._clusterFaces(d,p,u,s).filter(t=>t.length>0).map(t=>this._createShardGeometry(t,o,l,a?h:null,c))}static _toIndexed(t){const e=t.getAttribute("position"),i=[];for(let t=0;t<e.count;t++)i.push(t);const n=t.clone();return n.setIndex(i),n}static _buildAdjacencyGraph(t,e){const i=new Map,n=new Map;for(let s=0;s<e;s++){const e=t.getX(3*s),a=t.getX(3*s+1),r=t.getX(3*s+2);[[Math.min(e,a),Math.max(e,a)],[Math.min(a,r),Math.max(a,r)],[Math.min(r,e),Math.max(r,e)]].forEach(([t,e])=>{const i=`${t},${e}`;n.has(i)||n.set(i,[]),n.get(i).push(s)}),i.set(s,new Set)}for(const t of n.values())2===t.length&&(i.get(t[0]).add(t[1]),i.get(t[1]).add(t[0]));return i}static _clusterFaces(t,e,i,n){const s=this._seededRandom(n),a=new Array(i).fill(-1),r=[],o=[],l=[...Array(i).keys()];for(let t=0;t<e&&0!==l.length;t++){const t=Math.floor(s()*l.length);o.push(l.splice(t,1)[0])}o.forEach((t,e)=>{r.push([t]),a[t]=e});let h=!0,c=0;const u=2*i;for(;h&&c<u;){h=!1,c++;for(let e=0;e<r.length;e++){const i=r[e],n=[];for(const s of i){const i=t.get(s);if(i)for(const t of i)-1===a[t]&&(a[t]=e,n.push(t),h=!0)}r[e]=[...i,...n]}}for(let t=0;t<i;t++)if(-1===a[t]){let e=1/0,i=0;for(let t=0;t<r.length;t++)r[t].length<e&&(e=r[t].length,i=t);r[i].push(t),a[t]=i}return r}static _createShardGeometry(t,e,i,n,s){const a=[],r=[],o=[],l=[],h=new Map;let c=1/0,u=1/0,d=1/0,p=-1/0,m=-1/0,g=-1/0;for(const f of t){const t=[i.getX(3*f),i.getX(3*f+1),i.getX(3*f+2)].map(t=>{if(!h.has(t)){const i=a.length/3;h.set(t,i);const l=e.getX(t),f=e.getY(t),y=e.getZ(t);a.push(l,f,y),c=Math.min(c,l),u=Math.min(u,f),d=Math.min(d,y),p=Math.max(p,l),m=Math.max(m,f),g=Math.max(g,y),n&&r.push(n.getX(t),n.getY(t)),s&&o.push(s.getX(t),s.getY(t),s.getZ(t))}return h.get(t)});l.push(...t)}const f=new os;f.setAttribute("position",new Kn(a,3)),r.length>0&&f.setAttribute("uv",new Kn(r,2)),o.length>0?f.setAttribute("normal",new Kn(o,3)):f.computeVertexNormals(),f.setIndex(l);const y=new qe((c+p)/2,(u+m)/2,(d+g)/2);f.userData.centroid=y;const v=(p-c)*(m-u)*(g-d);return f.userData.volume=Math.max(v,.001),f.computeBoundingBox(),f.computeBoundingSphere(),f}static _seededRandom(t){let e=t%2147483647;return e<=0&&(e+=2147483646),()=>(e=1103515245*e+12345&2147483647,e/2147483647)}static hashGeometry(t){const e=t.getAttribute("position");if(!e)return`empty_${Date.now()}`;let i=0;const n=Math.min(e.count,50),s=Math.max(1,Math.floor(e.count/n));for(let t=0;t<e.count;t+=s)i^=1e3*e.getX(t)|0,i^=1e3*e.getY(t)<<8,i^=1e3*e.getZ(t)<<16,i=31*i|0;return`geo_${e.count}_${Math.abs(i).toString(16)}`}}class VM{constructor(t={}){const{maxShards:e=50,scene:i=null}=t;this.maxShards=e,this.scene=i,this.pool=[],this.active=[],this.shardMaterial=null,this._placeholderGeometry=null,this._initPool()}_initPool(){this._placeholderGeometry=new os,this._placeholderGeometry.setAttribute("position",new Kn([0,0,0,0,0,0,0,0,0],3)),this.shardMaterial=this._createShardMaterial();for(let t=0;t<this.maxShards;t++){const e=this.shardMaterial.clone(),i=new bs(this._placeholderGeometry,e);i.visible=!1,i.frustumCulled=!0,i.userData.poolIndex=t,i.userData.state=this._createShardState(),this.pool.push(i),this.scene&&this.scene.add(i)}}_createShardMaterial(){return new ul({transparent:!0,opacity:.9,side:2,metalness:.1,roughness:.15,transmission:.3,thickness:.2,ior:1.5,emissive:new zn(0),emissiveIntensity:0,iridescence:.2,iridescenceIOR:1.3,clearcoat:.3,clearcoatRoughness:.2})}_createShardState(){return{velocity:new qe,angularVelocity:new qe,lifetime:0,maxLifetime:2e3,opacity:1,gravity:-9.8,originalPosition:new qe,originalRotation:new tn,originalQuaternion:new Xe,originalScale:new qe(1,1,1),localCentroid:new qe,impactGlow:1,baseEmissiveIntensity:.5,reassemblyStartPos:new qe,reassemblyStartRot:new tn,reassemblyStartQuat:new Xe,reassemblyStartScale:new qe(1,1,1),depthFactor:0,vortexPhase:0,isCrackMode:!1,crackTargetOffset:new qe,isSuspendMode:!1,suspendProgress:0,floatPhase:Math.random()*Math.PI*2,dualMode:null,implodeStartPos:new qe,dissolveVelocity:new qe,dissolveOpacity:1,rippleDelay:0,ripplePhase:0,gravityVelocity:new qe,bounceCount:0,onFloor:!1,orbitRadius:0,orbitAngle:0,orbitSpeed:0,orbitHeight:0,orbitTilt:0}}activate(t,e,i,n={}){const{explosionForce:s=2,rotationForce:a=5,lifetime:r=2e3,gravity:o=-9.8,inheritVelocity:l=new qe,meshPosition:h=new qe,meshQuaternion:c=new Xe,meshScale:u=new qe(1,1,1),isCrackMode:d=!1,crackSeparation:p=.02,isSuspendMode:m=!1}=n,g=Math.min(t.length,this.pool.length),f=[];for(let n=0;n<g&&0!==this.pool.length;n++){const d=this.pool.pop(),p=t[n];d.geometry!==this._placeholderGeometry&&d.geometry.dispose(),d.geometry=p.clone();const g=p.userData.centroid?p.userData.centroid.clone():new qe,y=g.clone();y.multiply(u),y.applyQuaternion(c),y.add(h),d.position.copy(y),d.quaternion.copy(c),d.scale.copy(u),d.userData.state.originalPosition.copy(y),d.userData.state.originalRotation.copy(d.rotation),d.userData.state.originalQuaternion.copy(d.quaternion),d.userData.state.originalScale.copy(u),d.userData.state.localCentroid.copy(g),d.userData.state.depthFactor=g.z,d.userData.state.vortexPhase=Math.random()*Math.PI*2;const v=y.clone().sub(e),b=v.length();v.normalize();const M=s*Math.max(.3,1/(1+2*b)),_=Math.max(.2,1-3*b);v.lerp(i,.6*_),v.normalize(),v.x+=.3*(Math.random()-.5),v.y+=.3*(Math.random()-.5)+.15,v.z+=.3*(Math.random()-.5),v.normalize(),d.userData.state.velocity.copy(v).multiplyScalar(M).add(l);const x=(new qe).crossVectors(i,new qe(0,1,0)).normalize(),w=.5*_;d.userData.state.angularVelocity.set((Math.random()-.5)*a+x.x*w*a,(Math.random()-.5)*a+x.y*w*a,(Math.random()-.5)*a+x.z*w*a),d.userData.state.lifetime=0,d.userData.state.maxLifetime=r+(Math.random()-.5)*r*.3,d.userData.state.opacity=1,d.userData.state.gravity=o,d.userData.state.impactGlow=1,d.userData.state.baseEmissiveIntensity=.5,d.userData.state.isSuspendMode=m,d.userData.state.suspendProgress=0,d.userData.state.floatPhase=Math.random()*Math.PI*2,d.visible=!0,d.material.opacity=.9,d.material.emissiveIntensity=1.5,this.active.push(d),f.push(d)}if(f.length>1){let t=1/0,e=-1/0;for(const i of f){const n=i.userData.state.depthFactor;t=Math.min(t,n),e=Math.max(e,n)}const i=e-t;if(i>.001)for(const e of f)e.userData.state.depthFactor=1-(e.userData.state.depthFactor-t)/i}return f.length}update(t){const e=t/1e3,i=performance.now()/1e3;for(let n=this.active.length-1;n>=0;n--){const s=this.active[n],{state:a}=s.userData;a.lifetime+=t;const r=a.lifetime/a.maxLifetime;if(r>=1)this._deactivateShard(s,n);else{if(a.isSuspendMode){const t=a.suspendProgress,n=a.gravity*(1-t);a.velocity.y+=n*e;const r=.995-.145*t;if(a.velocity.multiplyScalar(r),a.angularVelocity.multiplyScalar(r),s.position.addScaledVector(a.velocity,e),t>.5){const e=2*(t-.5),n=.8,r=.003*e,o=.001*e;s.position.y+=Math.sin(i*n+a.floatPhase)*r,s.position.x+=Math.sin(i*n*.7+1.3*a.floatPhase)*o,s.position.z+=Math.cos(i*n*.5+.7*a.floatPhase)*o}s.rotation.x+=a.angularVelocity.x*e,s.rotation.y+=a.angularVelocity.y*e,s.rotation.z+=a.angularVelocity.z*e}else a.velocity.y+=a.gravity*e,s.position.addScaledVector(a.velocity,e),s.rotation.x+=a.angularVelocity.x*e,s.rotation.y+=a.angularVelocity.y*e,s.rotation.z+=a.angularVelocity.z*e,a.velocity.multiplyScalar(.995),a.angularVelocity.multiplyScalar(.99);if(r<.2){const t=r/.2;a.impactGlow=1-t*t;const e=a.baseEmissiveIntensity+1*a.impactGlow;s.material.emissiveIntensity=e}else if(r<.5)s.material.emissiveIntensity=.8*a.baseEmissiveIntensity;else{const t=(r-.5)/.5;s.material.emissiveIntensity=a.baseEmissiveIntensity*(1-t)}if(r>.7&&!a.isSuspendMode&&(a.opacity=1-(r-.7)/.3,s.material.opacity=.9*a.opacity),r>.8&&!a.isSuspendMode){const t=1-(r-.8)/.2*.5;s.scale.copy(a.originalScale).multiplyScalar(t)}}}}_deactivateShard(t,e){t.visible=!1,t.scale.set(1,1,1),this.active.splice(e,1),this.pool.push(t)}captureCurrentPositions(){for(const t of this.active){const{state:e}=t.userData;e.reassemblyStartPos.copy(t.position),e.reassemblyStartRot.copy(t.rotation),e.reassemblyStartQuat.copy(t.quaternion),e.reassemblyStartScale.copy(t.scale)}}updateReassembly(t,e=null){const i=performance.now()/1e3;for(const n of this.active){const{state:s}=n.userData;let a,r,o;e&&s.localCentroid?(a=s.localCentroid.clone(),a.multiply(e.scale),a.applyQuaternion(e.quaternion),a.add(e.position),r=e.quaternion,o=s.originalScale):(a=s.originalPosition,r=s.originalQuaternion,o=s.originalScale);const l=.3*s.depthFactor,h=Math.max(0,(t-l)/(1-l)),c=Math.min(1,h),u=(new qe).lerpVectors(s.reassemblyStartPos,a,c),d=.15*Math.sin(c*Math.PI),p=s.vortexPhase+c*Math.PI*2,m=d*(1-c),g=(new qe).subVectors(a,s.reassemblyStartPos).normalize(),f=new qe(0,1,0),y=(new qe).crossVectors(g,f).normalize(),v=(new qe).crossVectors(y,g).normalize();u.addScaledVector(y,Math.cos(p)*m),u.addScaledVector(v,Math.sin(p)*m),n.position.copy(u);const b=new Xe;let M;if(b.slerpQuaternions(s.reassemblyStartQuat,r,c),n.quaternion.copy(b),n.scale.lerpVectors(s.reassemblyStartScale,o,c),c<.3){const t=8*i+s.vortexPhase;M=.3+(.5+.15*Math.sin(t))*c}else if(c<.7){const t=(c-.3)/.4;M=.5+.8*t+.1*Math.sin(12*i+s.vortexPhase)*(1-t)}else if(c<.95){const t=(c-.7)/.25;M=1.3+t*t*1.2}else M=2.5-(c-.95)/.05*1.5;n.material.emissiveIntensity=M;const _=.7+.2*c;n.material.opacity=Math.min(.9,_)}}updateSuspendProgress(t){for(const e of this.active)e.userData.state.suspendProgress=t}initImplodeMode(t={}){for(const t of this.active){const{state:e}=t.userData;e.dualMode="implode",e.implodeStartPos.copy(t.position),e.vortexPhase=Math.random()*Math.PI*2}}initDissolveMode(t={}){const e=t.windDirection||[1,.2,0],i=t.windForce||2,n=t.turbulence||.5;for(const t of this.active){const{state:s}=t.userData;s.dualMode="dissolve",s.dissolveOpacity=1,s.dissolveVelocity.set(e[0]*i+(Math.random()-.5)*n,e[1]*i+(Math.random()-.5)*n,e[2]*i+(Math.random()-.5)*n),s.floatPhase=Math.random()*Math.PI*2}}initGravityMode(t={}){const e=t.gravity||-15;for(const t of this.active){const{state:i}=t.userData;i.dualMode="gravity",i.gravity=e,i.gravityVelocity.set(.5*(Math.random()-.5),0,.5*(Math.random()-.5)),i.bounceCount=0,i.onFloor=!1}}initOrbitMode(t={}){const e=t.orbitSpeed||1,i=t.radiusMultiplier||1,n=new qe;for(const t of this.active){const{state:s}=t.userData;s.dualMode="orbit";const a=t.position.clone().sub(n);s.orbitRadius=a.length()*i,s.orbitAngle=Math.atan2(a.x,a.z),s.orbitHeight=a.y,s.orbitSpeed=e*(.8+.4*Math.random()),s.orbitTilt=.3*(Math.random()-.5)}}applyImpulse(t,e=3,i=.4){for(const n of this.active){const{state:s}=n.userData,a=new qe(t[0]*e+(Math.random()-.5)*i*e,t[1]*e+(Math.random()-.5)*i*e+.3,t[2]*e+(Math.random()-.5)*i*e);s.velocity.add(a),s.angularVelocity.x+=6*(Math.random()-.5),s.angularVelocity.y+=6*(Math.random()-.5),s.angularVelocity.z+=6*(Math.random()-.5)}}updateImplode(t,e,i){const n=t/1e3,s=e*e*e;for(const t of this.active){const{state:a}=t.userData;if("implode"!==a.dualMode)continue;const r=(new qe).lerpVectors(a.implodeStartPos,i,s),o=.15*(1-s),l=a.vortexPhase+e*Math.PI*4;r.x+=Math.cos(l)*o,r.z+=Math.sin(l)*o,t.position.copy(r);const h=1+5*s;t.rotation.x+=n*h*2,t.rotation.y+=n*h*3;const c=Math.max(.1,1-.8*s);t.scale.copy(a.originalScale).multiplyScalar(c),t.material.emissiveIntensity=.5+2*s,t.material.opacity=Math.max(.3,1-.5*s)}}updateDissolve(t,e,i={}){const n=t/1e3,s=performance.now()/1e3,a=i.turbulence||.5;for(const t of this.active){const{state:i}=t.userData;if("dissolve"!==i.dualMode)continue;t.position.add(i.dissolveVelocity.clone().multiplyScalar(n));const r=Math.sin(3*s+i.floatPhase)*a*.02,o=Math.sin(2*s+1.5*i.floatPhase)*a*.01,l=Math.cos(2.5*s+.8*i.floatPhase)*a*.02;t.position.x+=r,t.position.y+=o,t.position.z+=l,t.rotation.x+=.5*n,t.rotation.y+=.8*n;const h=Math.max(.05,1-e*e);t.scale.copy(i.originalScale).multiplyScalar(h),i.dissolveOpacity=Math.max(0,1-e),t.material.opacity=.9*i.dissolveOpacity,t.material.emissiveIntensity=.3*(1-e)}}updateGravityBounce(t,e,i=-1){const n=t/1e3;for(const t of this.active){const{state:s}=t.userData;if("gravity"===s.dualMode&&(s.gravityVelocity.y+=s.gravity*n,t.position.add(s.gravityVelocity.clone().multiplyScalar(n)),t.position.y<=i&&s.bounceCount<3?(t.position.y=i,s.gravityVelocity.y*=-.5,s.gravityVelocity.x*=.8,s.gravityVelocity.z*=.8,s.bounceCount++,t.material.emissiveIntensity=.8):t.position.y<=i&&(t.position.y=i,s.gravityVelocity.set(0,0,0),s.onFloor=!0),s.onFloor||(t.rotation.x+=3*n,t.rotation.z+=2*n),t.material.emissiveIntensity=Math.max(.1,t.material.emissiveIntensity-.5*n),e>.7)){const i=(e-.7)/.3;t.material.opacity=Math.max(.1,.9-.8*i)}}}updateOrbit(t,e,i,n={}){const s=t/1e3,a=performance.now()/1e3;for(const t of this.active){const{state:e}=t.userData;if("orbit"!==e.dualMode)continue;e.orbitAngle+=e.orbitSpeed*s;const n=i.x+Math.sin(e.orbitAngle)*e.orbitRadius,r=i.z+Math.cos(e.orbitAngle)*e.orbitRadius,o=.05*Math.sin(2*a+e.floatPhase),l=i.y+e.orbitHeight+o,h=Math.sin(e.orbitAngle+e.orbitTilt)*e.orbitRadius*.1;t.position.set(n,l+h,r),t.lookAt(i),t.rotation.z+=.5*s;const c=.3+.2*Math.sin(3*a+e.floatPhase);t.material.emissiveIntensity=c;const u=1+.05*Math.sin(2*a+e.floatPhase);t.scale.copy(e.originalScale).multiplyScalar(u)}}clear(){for(let t=this.active.length-1;t>=0;t--){const e=this.active[t];e.visible=!1,e.scale.set(1,1,1),this.pool.push(e)}this.active=[]}updateMaterial(t){const e=[...this.pool,...this.active];for(const i of e)t.color&&i.material.color.copy(t.color),t.emissive&&(i.material.emissive.copy(t.emissive),i.material.emissiveIntensity=t.emissiveIntensity||.3)}setScene(t){if(this.scene!==t){if(this.scene)for(const t of[...this.pool,...this.active])this.scene.remove(t);if(this.scene=t,this.scene)for(const t of[...this.pool,...this.active])this.scene.add(t)}}get activeCount(){return this.active.length}get availableCount(){return this.pool.length}dispose(){this.clear();for(const t of this.pool)this.scene&&this.scene.remove(t),t.geometry!==this._placeholderGeometry&&t.geometry.dispose(),t.material.dispose();this.pool=[],this._placeholderGeometry&&(this._placeholderGeometry.dispose(),this._placeholderGeometry=null),this.shardMaterial&&(this.shardMaterial.dispose(),this.shardMaterial=null)}}const HM={IDLE:"idle",GENERATING:"generating",SHATTERING:"shattering",FROZEN:"frozen",REASSEMBLING:"reassembling",IMPLODING:"imploding",DISSOLVING:"dissolving",FALLING:"falling",ORBITING:"orbiting"};class WM{constructor(t={}){const e="undefined"!=typeof navigator&&/Android|iPhone|iPad|iPod/i.test(navigator.userAgent),{scene:i=null,maxShards:n=(e?25:50),shardLifetime:s=(e?1500:2e3),enableReassembly:a=!0,autoRestore:r=!0}=t;this.scene=i,this.maxShards=n,this.shardLifetime=s,this.enableReassembly=a,this.autoRestore=r,this.state=HM.IDLE,this.shardPool=new VM({maxShards:n,scene:i}),this.geometryCache=new Map,this.targetMesh=null,this.innerMesh=null,this.onShatterStart=null,this.onShatterComplete=null,this.onReassemblyComplete=null,this._shatterStartTime=0,this._soulRevealProgress=0,this._soulOriginalScale=1,this._soulOriginalEmissive=0,this._soulOriginalGhostMode=.36,this._soulOriginalLayer=2,this._reassemblyDuration=1e3,this._reassemblyStartTime=0,this._reassemblyProgress=0,this._soulWasRevealed=!1,this._shatterQueue=[],this._chainedDelay=150,this._lastChainTrigger=0,this._isSuspendMode=!1,this._suspendAt=.25,this._suspendDuration=.35,this._isFreezeMode=!1,this._dualModeType=null,this._dualModeConfig={},this._dualModeStartTime=0,this._dualModeDuration=2e3}prepareGeometry(t,e=null){const i=e||GM.hashGeometry(t);if(this.geometryCache.has(i))return this.geometryCache.get(i);const n=GM.generate(t,{shardCount:this.maxShards,seed:this._hashString(i)});return this.geometryCache.set(i,n),n}shatter(t,e={}){if(this.state!==HM.IDLE)return console.warn("ShatterSystem: Cannot shatter - already in state:",this.state),!1;const{impactPoint:i=new qe(0,0,.4),impactDirection:n=new qe(0,0,-1),intensity:s=1,geometryId:a=null,revealInner:r=!0,inheritMeshVelocity:o=null,isCrackMode:l=!1,crackSeparation:h=.02,isSuspendMode:c=!1,suspendAt:u=.25,suspendDuration:d=.35,isFreezeMode:p=!1,isDualMode:m=!1,dualModeType:g=null,dualModeConfig:f={},gravity:y,explosionForce:v,rotationForce:b}=e;this.state=HM.GENERATING,this.targetMesh=t,this._shatterStartTime=performance.now(),this._isSuspendMode=c,this._suspendAt=u,this._suspendDuration=d,this._gestureDuration=e.gestureDuration||6e3,this._isFreezeMode=p,this._pendingDualMode=m?g:null,this._pendingDualModeConfig=m?f:{};const M=a||GM.hashGeometry(t.geometry);let _=this.geometryCache.get(M);if(_||(_=this.prepareGeometry(t.geometry,M)),!_||0===_.length)return console.warn("ShatterSystem: No shards generated"),this.state=HM.IDLE,!1;const x=new qe,w=new Xe,S=new qe;t.matrixWorld.decompose(x,w,S);const T=i.clone();T.applyQuaternion(w),T.add(x);const C=n.clone();if(C.applyQuaternion(w),C.normalize(),t.visible=!1,this._soulWasRevealed=r&&this.innerMesh,this._soulWasRevealed){this.innerMesh.visible=!0,this._soulRevealProgress=0,this._soulOriginalScale=this.innerMesh.scale.x,this._soulOriginalLayer=this.innerMesh.layers.mask,this.innerMesh.layers.set(0),this._soulOriginalDepthTest=this.innerMesh.material?.depthTest??!0,this._soulOriginalRenderOrder=this.innerMesh.renderOrder??0,this.innerMesh.material&&(this.innerMesh.material.depthTest=!1),this.innerMesh.renderOrder=100;const t=this.innerMesh.material?.uniforms;t?(this._soulOriginalEmissive=t.energyIntensity?.value??.8,this._soulOriginalGhostMode=t.ghostMode?.value??.36,t.energyIntensity&&(t.energyIntensity.value=2),t.ghostMode&&(t.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this._soulOriginalEmissive=this.innerMesh.material.emissiveIntensity,this.innerMesh.material.emissiveIntensity=2),this.innerMesh.scale.setScalar(.5*this._soulOriginalScale)}this.state=HM.SHATTERING;let E=this.shardLifetime;c||p?E=1e4:m&&f?.duration&&(E=400+f.duration+1e3);const A=E,P=l?0:(void 0!==v?v:2)*s,D=l?.5*s:(void 0!==b?b:5)*s,R=l?0:void 0!==y?y:c?-3:-9.8,I=this.shardPool.activate(_,T,C,{explosionForce:P,rotationForce:D,lifetime:A,gravity:R,inheritVelocity:o||new qe,meshPosition:x,meshQuaternion:w,meshScale:S,isCrackMode:l,crackSeparation:h,isSuspendMode:c});return this._syncShardMaterial(t),this.onShatterStart&&this.onShatterStart(t,{shardCount:I}),!0}_syncShardMaterial(t){let e=new zn(8965375),i=new zn(0);t.material?.uniforms?.emotionColor?(e=t.material.uniforms.emotionColor.value.clone(),i=e.clone().multiplyScalar(.3)):t.material?.color&&(e=t.material.color.clone(),i=t.material.emissive?.clone()||new zn(0)),this.shardPool.updateMaterial({color:e,emissive:i,emissiveIntensity:.4})}shatterChain(t,e={}){if(!t||0===t.length)return!1;const{delay:i=150,propagationDir:n=null}=e;this._chainedDelay=i;const s=[...t];if(n){const t=n.clone().normalize();s.sort((e,i)=>{const n=new qe,s=new qe;return e.mesh.getWorldPosition(n),i.mesh.getWorldPosition(s),n.dot(t)-s.dot(t)})}return this._shatterQueue=s.map((t,e)=>({mesh:t.mesh,config:t.config||{},triggerTime:performance.now()+e*i})),this.state===HM.IDLE&&this._shatterQueue.length>0&&this._processNextInChain(),!0}_processNextInChain(){if(0===this._shatterQueue.length)return;const t=this._shatterQueue[0],e=performance.now();e>=t.triggerTime&&(this._shatterQueue.shift(),this._lastChainTrigger=e,this.shatter(t.mesh,t.config))}reassemble(t={}){if(this.state!==HM.SHATTERING||!this.enableReassembly)return!1;const{duration:e=1e3}=t;return this.state=HM.REASSEMBLING,this._reassemblyDuration=e,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions(),!0}triggerReassembly(t=1500){return this.state!==HM.FROZEN?(console.warn("ShatterSystem.triggerReassembly: Can only trigger from FROZEN state, current state:",this.state),!1):(this.state=HM.REASSEMBLING,this._reassemblyDuration=t,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions(),!0)}isFrozen(){return this.state===HM.FROZEN}moveFrozenShards(t,e=3){if(this.state!==HM.FROZEN)return!1;this.shardPool.applyImpulse(t,e,.4),this.state=HM.SHATTERING,this._isFreezeMode=!1,this._isSuspendMode=!1;for(const t of this.shardPool.active)t.userData.state.lifetime=0,t.userData.state.maxLifetime=1500;return!0}triggerDualMode(t,e={}){return["implode","dissolve","gravity","orbit"].includes(t)?[HM.IMPLODING,HM.DISSOLVING,HM.FALLING,HM.ORBITING].includes(this.state)?(console.warn("ShatterSystem.triggerDualMode: Already in dual-mode state:",this.state),!1):(this._dualModeType=t,this._dualModeConfig=e,this._dualModeStartTime=performance.now(),this._dualModeDuration=e.duration||2e3,this.state===HM.FROZEN&&(this._startDualModeFromFrozen(t,e),!0)):(console.warn("ShatterSystem.triggerDualMode: Invalid mode:",t),!1)}_startDualModeFromFrozen(t,e){switch(this.shardPool.captureCurrentPositions(),t){case"implode":this.state=HM.IMPLODING,this.shardPool.initImplodeMode(e);break;case"dissolve":this.state=HM.DISSOLVING,this.shardPool.initDissolveMode(e);break;case"gravity":this.state=HM.FALLING,this.shardPool.initGravityMode(e);break;case"orbit":this.state=HM.ORBITING,this.shardPool.initOrbitMode(e)}}update(t){if(this.state===HM.IDLE&&this._shatterQueue.length>0&&this._processNextInChain(),this.state===HM.SHATTERING){if(this._isSuspendMode){const t=performance.now()-this._shatterStartTime,e=Math.min(1,t/this._gestureDuration);let i=0;if(e>=this._suspendAt){const t=e-this._suspendAt;i=Math.min(1,t/this._suspendDuration),i=1-Math.pow(1-i,2)}this.shardPool.updateSuspendProgress(i)}if(this.shardPool.update(t),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;if(this._soulRevealProgress<1){this._soulRevealProgress+=t/500,this._soulRevealProgress=Math.min(1,this._soulRevealProgress);const i=this._soulRevealProgress,n=1-Math.pow(1-i,3),s=this._soulOriginalScale*(.5+.5*n);if(this.innerMesh.scale.setScalar(s),e)e.energyIntensity&&(e.energyIntensity.value=2-n*(2-this._soulOriginalEmissive)),e.ghostMode&&(e.ghostMode.value=0);else if(void 0!==this.innerMesh.material?.emissiveIntensity){const t=2-n*(2-this._soulOriginalEmissive);this.innerMesh.material.emissiveIntensity=t}}else this.innerMesh.scale.setScalar(this._soulOriginalScale),e?(e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive),e.ghostMode&&(e.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive)}if(this._isFreezeMode&&this._isSuspendMode){const t=performance.now()-this._shatterStartTime;Math.min(1,t/this._gestureDuration)>=this._suspendAt+this._suspendDuration&&(this._pendingDualMode?(this._dualModeType=this._pendingDualMode,this._dualModeConfig=this._pendingDualModeConfig,this._dualModeStartTime=performance.now(),this._dualModeDuration=this._pendingDualModeConfig.duration||2e3,this._startDualModeFromFrozen(this._pendingDualMode,this._pendingDualModeConfig),this._pendingDualMode=null,this._pendingDualModeConfig={}):this.state=HM.FROZEN)}this._pendingDualMode&&!this._isFreezeMode&&performance.now()-this._shatterStartTime>=400&&(this._dualModeType=this._pendingDualMode,this._dualModeConfig=this._pendingDualModeConfig,this._dualModeStartTime=performance.now(),this._dualModeDuration=this._pendingDualModeConfig.duration||2e3,this.shardPool.captureCurrentPositions(),this._startDualModeFromFrozen(this._pendingDualMode,this._pendingDualModeConfig),this._pendingDualMode=null,this._pendingDualModeConfig={}),0!==this.shardPool.activeCount||this._isFreezeMode||this._pendingDualMode||this._onShatterComplete()}if(this.state===HM.IMPLODING&&this._updateImplodeMode(t),this.state===HM.DISSOLVING&&this._updateDissolveMode(t),this.state===HM.FALLING&&this._updateGravityMode(t),this.state===HM.ORBITING&&this._updateOrbitMode(t),this.state===HM.REASSEMBLING){const t=performance.now()-this._reassemblyStartTime;this._reassemblyProgress=Math.min(1,t/this._reassemblyDuration);const e=this._reassemblyProgress,i=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,n=this.targetMesh?{position:this.targetMesh.position.clone(),quaternion:this.targetMesh.quaternion.clone(),scale:this.targetMesh.scale.clone()}:null;if(this.shardPool.updateReassembly(i,n),this._soulWasRevealed&&this.innerMesh){const t=this.innerMesh.material?.uniforms;if(this._reassemblyProgress<=.6)this.innerMesh.scale.setScalar(this._soulOriginalScale),t?(t.energyIntensity&&(t.energyIntensity.value=this._soulOriginalEmissive),t.ghostMode&&(t.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive);else{const e=(this._reassemblyProgress-.6)/.4,i=e*e,n=this._soulOriginalScale*(1-.3*i);this.innerMesh.scale.setScalar(n),t?(t.energyIntensity&&(t.energyIntensity.value=this._soulOriginalEmissive*(1-i)),t.ghostMode&&void 0!==this._soulOriginalGhostMode&&(t.ghostMode.value=i*this._soulOriginalGhostMode)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive*(1-i))}}this._reassemblyProgress>=1&&this._onReassemblyComplete()}}_updateImplodeMode(t){const e=performance.now()-this._dualModeStartTime,i=Math.min(1,e/this._dualModeDuration),n=this.innerMesh?this.innerMesh.position.clone():new qe;if(this.shardPool.updateImplode(t,i,n),this._soulWasRevealed&&this.innerMesh){const t=this.innerMesh.material?.uniforms;if(t){const e=1+1.5*i;t.energyIntensity&&(t.energyIntensity.value=e)}}i>=1&&this._onDualModeComplete()}_updateDissolveMode(t){const e=performance.now()-this._dualModeStartTime,i=Math.min(1,e/this._dualModeDuration);if(this.shardPool.updateDissolve(t,i,this._dualModeConfig),this._soulWasRevealed&&this.innerMesh){const t=this.innerMesh.material?.uniforms;t&&t.energyIntensity&&(t.energyIntensity.value=this._soulOriginalEmissive*(1-.5*i))}i>=1&&this._onDualModeComplete()}_updateGravityMode(t){const e=performance.now()-this._dualModeStartTime,i=Math.min(1,e/this._dualModeDuration),n=this._dualModeConfig.floorY??-1;this.shardPool.updateGravityBounce(t,i,n),i>=1&&this._onDualModeComplete()}_updateOrbitMode(t){const e=performance.now()-this._dualModeStartTime,i=Math.min(1,e/this._dualModeDuration),n=this.innerMesh?this.innerMesh.position.clone():new qe;if(this.shardPool.updateOrbit(t,i,n,this._dualModeConfig),this._soulWasRevealed&&this.innerMesh){const t=this.innerMesh.material?.uniforms;if(t){const i=.2*Math.sin(e/200);t.energyIntensity&&(t.energyIntensity.value=this._soulOriginalEmissive+i)}}i>=1&&!1!==this._dualModeConfig.autoComplete&&(this._dualModeConfig.reassemble?(this.state=HM.REASSEMBLING,this._reassemblyDuration=this._dualModeConfig.reassembleDuration||1200,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions()):this._onDualModeComplete())}_onDualModeComplete(){this.shardPool.clear(),this.targetMesh&&(this.targetMesh.visible=!0),this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms()),this._dualModeType=null,this._dualModeConfig={},this.state=HM.IDLE,this.onShatterComplete&&this.onShatterComplete(this.targetMesh)}_onShatterComplete(){this.state=HM.IDLE,this.autoRestore&&this.targetMesh&&(this.targetMesh.visible=!0,this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms())),this.onShatterComplete&&this.onShatterComplete(this.targetMesh)}_onReassemblyComplete(){this.shardPool.clear(),this.targetMesh&&(this.targetMesh.visible=!0),this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms()),this.state=HM.IDLE,this.onReassemblyComplete&&this.onReassemblyComplete(this.targetMesh)}_resetSoulUniforms(){if(!this.innerMesh)return;void 0!==this._soulOriginalLayer&&(this.innerMesh.layers.mask=this._soulOriginalLayer),this.innerMesh.material&&void 0!==this._soulOriginalDepthTest&&(this.innerMesh.material.depthTest=this._soulOriginalDepthTest),void 0!==this._soulOriginalRenderOrder&&(this.innerMesh.renderOrder=this._soulOriginalRenderOrder);const t=this.innerMesh.material?.uniforms;t?(t.energyIntensity&&(t.energyIntensity.value=this._soulOriginalEmissive),t.ghostMode&&void 0!==this._soulOriginalGhostMode&&(t.ghostMode.value=this._soulOriginalGhostMode)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive)}setTargets(t,e=null){this.targetMesh=t,this.innerMesh=e}setScene(t){this.scene=t,this.shardPool.setScene(t)}forceStop(){this.shardPool.clear(),this.state=HM.IDLE,this._shatterQueue=[],this.targetMesh&&(this.targetMesh.visible=!0),this.innerMesh&&(this.innerMesh.visible=!1)}clearChainQueue(){this._shatterQueue=[]}getChainQueueLength(){return this._shatterQueue.length}getState(){return this.state}isShattering(){return this.state===HM.SHATTERING}isIdle(){return this.state===HM.IDLE}isReassembling(){return this.state===HM.REASSEMBLING}getStats(){return{state:this.state,activeShards:this.shardPool.activeCount,availableShards:this.shardPool.availableCount,cachedGeometries:this.geometryCache.size,chainQueueLength:this._shatterQueue.length,reassemblyProgress:this.state===HM.REASSEMBLING?this._reassemblyProgress:null}}clearCache(){for(const t of this.geometryCache.values())for(const e of t)e.dispose();this.geometryCache.clear()}dispose(){this.forceStop(),this.shardPool.dispose(),this.clearCache(),this.targetMesh=null,this.innerMesh=null,this.onShatterStart=null,this.onShatterComplete=null,this.onReassemblyComplete=null}_hashString(t){let e=0;for(let i=0;i<t.length;i++)e=(e<<5)-e+t.charCodeAt(i),e&=e;return Math.abs(e)}}class jM{constructor(t,e={}){if(!t)throw new Error("Core3DManager: canvas element is required");if(!(t instanceof HTMLCanvasElement))throw new Error("Core3DManager: canvas must be an HTMLCanvasElement");if(void 0===dp)throw new Error("Core3DManager: Three.js library is not loaded. Import three.js before using Core3DManager");this._instanceId=Math.random().toString(36).substr(2,6),this.canvas=t,this.options=e,this._destroyed=!1,this._ready=!1,this._readyPromise=null,this.debugMotionLogging=!1,this.assetBasePath=void 0!==e.assetBasePath?e.assetBasePath:"",this.geometryType=e.geometry||"sphere";const i="moon"===this.geometryType;this.renderer=new Zp(t,{enablePostProcessing:!1!==e.enablePostProcessing,enableShadows:e.enableShadows||!1,enableControls:!1!==e.enableControls,autoRotate:!i&&!1!==e.autoRotate,autoRotateSpeed:e.autoRotateSpeed,cameraDistance:e.cameraDistance,fov:e.fov,minZoom:e.minZoom,maxZoom:e.maxZoom,assetBasePath:this.assetBasePath}),this.renderer.onContextRestored=()=>this._handleContextRestored();const n=Vm[this.geometryType];n?this.geometryConfig=n:(console.warn(`Unknown geometry: ${this.geometryType}, falling back to sphere`),this.geometryConfig=Vm.sphere),this.geometry=this.geometryConfig.geometry,this.geometry&&!this.geometry.isGroup&&(this.geometry.userData.geometryType=this.geometryType),this.materialVariant=e.materialVariant||null,this.onMaterialSwap=null;let s=null;const a=Km(this.emotion),r=fM(this.geometryType,this.geometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:a,assetBasePath:this.assetBasePath});if(r&&(s=r.material,this.customMaterial=s,this.customMaterialType=r.type),this.geometryConfig.geometryLoader?this._readyPromise=this._loadAsyncGeometry():(this._ready=!0,this._readyPromise=Promise.resolve()),null===this.geometry&&this.geometryConfig.geometryLoader?this._deferredMeshCreation=!0:(this.coreMesh=this.renderer.createCoreMesh(this.geometry,s),"crystal"===this.customMaterialType&&this.createCrystalInnerCore()),this.calibrationRotation=[0,0,0],this.cameraRoll=0,"moon"===this.geometryType){const t=Math.PI/180;this.calibrationRotation=[gm*t,fm*t,ym*t],this.cameraRoll=0}if("crystal"===this.geometryType||"rough"===this.geometryType||"heart"===this.geometryType||"star"===this.geometryType){const t=Math.PI/180;this.calibrationRotation=[0*t,30*t,0*t]}if(this.animator=new Hm,this.gestureBlender=new jm,this.animationManager=new SM(this.animator,this.gestureBlender),this.effectManager=new LM(this.renderer,this.assetBasePath),this.behaviorController=new UM({rotationDisabled:!1===e.autoRotate,wobbleEnabled:!0,rhythmEngine:e.rhythmEngine||null,camera:this.renderer.camera}),this.breathingPhaseManager=new NM,this.breathingAnimator=new Wm,this.breathingEnabled=!1!==e.enableBreathing,this.geometryMorpher=new cg,this._skipRenderFrames=0,this.blinkAnimator=new sg(this.geometryConfig),this.blinkAnimator.setEmotion(this.emotion),this.blinkingManuallyDisabled=!1,!1===e.enableBlinking&&(this.blinkAnimator.pause(),this.blinkingManuallyDisabled=!0),this.rotationDisabled=!1===e.autoRotate,this.wobbleEnabled=!0,i&&vm.enabled){const t=Math.PI/180;this.behaviorController.configureForEmotion({geometryType:"moon",emotionData:null,facingConfig:{enabled:!0,strength:vm.strength,lockedFace:vm.lockedFace,lerpSpeed:vm.lerpSpeed,calibrationRotation:[gm*t,fm*t,ym*t]}})}this.emotion=e.emotion||"neutral",this.undertone=e.undertone||null,this.glowColor=[1,1,1],this.glowColorHex="#FFFFFF",this.glowIntensity=1,this._normalizedGlowColor=null,this.coreGlowEnabled=!0,this.glowIntensityOverride=null,this.intensityCalibrationOffset=0,this.baseEuler=[0,0,0],this.baseQuaternion=new Xe,this.gestureQuaternion=new Xe,this.tempEuler=new tn,this.rotation=[0,0,0],this.baseScale=.16,this.scale=.16,this.position=[0,0,0],this.rhythmEngine=e.rhythmEngine||null,this.rhythm3DAdapter=hg,this.rhythmEnabled=!1!==e.enableRhythm,this.rhythmEnabled&&(this.rhythm3DAdapter.initialize(),this.breathingAnimator.setRhythmAdapter(this.rhythm3DAdapter)),this.particlesEnabled=!1!==e.enableParticles,this.particleVisibility=this.particlesEnabled;const o=new Kb(50);o.canvasWidth=t.width,o.canvasHeight=t.height;const l=new tM({worldScale:2,baseRadius:1.5,depthScale:.75,verticalScale:1,coreRadius3D:2}),h=new aM(150,{renderer:this.renderer.renderer}),c=h.getPoints();c.layers.set(1),this.renderer.scene.add(c),this.particleOrchestrator=new hM(o,l,h),this.particleOrchestrator.setGeometryType(this.geometryType),this.particlesEnabled||h.geometry.setDrawRange(0,0);const u=this.geometry?.parameters?.radius||.5;this.effectManager.initializeForGeometry(this.geometryType,{coreMesh:this.coreMesh,customMaterial:this.customMaterial,sunRadius:u}),this.shatterSystem=new WM({scene:this.renderer.scene,maxShards:50,shardLifetime:2e3,enableReassembly:!0,autoRestore:!0}),this.shatterSystem.onShatterStart=()=>{},this.shatterSystem.onShatterComplete=()=>{this.crystalSoul&&this.crystalSoul.setVisible(this.coreGlowEnabled)},this.shatterSystem.onReassemblyComplete=()=>{this.crystalSoul&&this.crystalSoul.setVisible(this.coreGlowEnabled)},this._pendingShatter=null,this.geometryConfig.defaultGlassMode&&!this.customMaterial&&this.setGlassMaterialEnabled(!0),this.setEmotion(this.emotion)}setEmotion(t,e=null){this.emotion=t,this.undertone=e;const i=Km(t);if(i&&i.visual){if(i.visual.glowColor){let t=(n=(n=i.visual.glowColor).replace("#",""),[parseInt(n.substring(0,2),16)/255,parseInt(n.substring(2,4),16)/255,parseInt(n.substring(4,6),16)/255]);t=function(t,e){if(!e||"clear"===e||"none"===e)return t;const i={intense:{saturation:2.5,lightness:1.3},confident:{saturation:1.8,lightness:1.15},nervous:{saturation:1.6,lightness:1.1},tired:{saturation:.4,lightness:.65},subdued:{saturation:.25,lightness:.55}}[e];if(!i)return t;const n=function(t,e,i){const n=Math.max(t,e,i),s=Math.min(t,e,i),a=n-s,r=n+s;let o=0,l=0;const h=r/2;if(0!==a)switch(l=h>.5?a/(2-r):a/r,n){case t:o=((e-i)/a+(e<i?6:0))/6;break;case e:o=((i-t)/a+2)/6;break;case i:o=((t-e)/a+4)/6}return[360*o,100*l,100*h]}(t[0],t[1],t[2]);return n[1]=Math.min(100,n[1]*i.saturation),n[2]=Math.min(100,Math.max(0,n[2]*i.lightness)),function(t,e,i){let n,s,a;if(t/=360,i/=100,0==(e/=100))n=s=a=i;else{const r=(t,e,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+(e-t)*(2/3-i)*6:t),o=i<.5?i*(1+e):i+e-i*e,l=2*i-o;n=r(l,o,t+1/3),s=r(l,o,t),a=r(l,o,t-1/3)}return[n,s,a]}(n[0],n[1],n[2])}(t,e),this.glowColor=t,this.glowColorHex=i.visual.glowColor;const s=function(t,e=.5){const[i,n,s]=t,a=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4),r=a(i),o=a(n),l=a(s),h=.2126*r+.7152*o+.0722*l,c=e/Math.max(h,.001);let u=r*c,d=o*c,p=l*c;const m=Math.max(u,d,p);m>1&&(u/=m,d/=m,p/=m);const g=t=>t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055;return{r:Math.min(1,Math.max(0,g(u))),g:Math.min(1,Math.max(0,g(d))),b:Math.min(1,Math.max(0,g(p)))}}(t,.3);this._targetGlowColor=[s.r,s.g,s.b],this._normalizedGlowColor||(this._normalizedGlowColor=[...this._targetGlowColor]),this._colorTransitionProgress=0,this._colorTransitionStart=[...this._normalizedGlowColor];const a=this.renderer.materialMode||"glass";this.glowIntensity=pg(i.visual.glowColor,this.intensityCalibrationOffset,a)}if(this.renderer.updateLighting(t,i),this.customMaterial&&"moon"===this.customMaterialType){const t=new zn(this.glowColor[0],this.glowColor[1],this.glowColor[2]);Dm(this.customMaterial,t,this.glowIntensity)}else this.customMaterial&&"sun"===this.customMaterialType&&zm(this.coreMesh,this.glowColor,this.glowIntensity,0)}var n;const s="sun"===this.geometryType?Lm:null;let a=null;if("moon"===this.geometryType&&vm.enabled){const t=Math.PI/180;a={enabled:!0,strength:vm.strength,lockedFace:vm.lockedFace,lerpSpeed:vm.lerpSpeed,calibrationRotation:[gm*t,fm*t,ym*t]}}this.behaviorController.configureForEmotion({geometryType:this.geometryType,emotionData:i,facingConfig:a,geometryRotation:s}),this.baseEuler[0]=0,this.baseEuler[2]=0;const r=dg(e);r&&r["3d"]&&this.behaviorController.applyUndertone(r["3d"]),this.animator.stopAll();const o=i?.visual?.glowColor||"#00BCD4",l=this.renderer.materialMode||"glass";if(this.baseGlowIntensity=pg(o,this.intensityCalibrationOffset,l),r&&r["3d"]&&r["3d"].glow&&(this.baseGlowIntensity*=r["3d"].glow.intensityMultiplier),this.breathingAnimator.setEmotion(t,r),this.blinkAnimator.setEmotion(t),this.rhythmEnabled&&this.rhythm3DAdapter?.isPlaying?.()){const e=this._getEmotionGroove(t);this.rhythm3DAdapter.setGroove(e,{quantize:!0,bars:2})}if(this.renderer.updateBloom(this.baseGlowIntensity,1,this.geometryType),this.animator.playEmotion(t),this.particlesEnabled&&this.particleOrchestrator&&this.particleOrchestrator.setEmotion(t,e),i&&i.soulAnimation){const t=i.soulAnimation;this.setCrystalSoulEffects({driftEnabled:!0,driftSpeed:t.driftSpeed||.5,shimmerEnabled:!0,shimmerSpeed:t.shimmerSpeed||.5})}}setCoreGlowEnabled(t){this.coreGlowEnabled=t,this.crystalSoul&&this.crystalSoul.setVisible(t)}setGlassMaterialEnabled(t){const e=t?"glass":"glow";this.renderer.setMaterialMode(e)}setGlowIntensity(t){this.glowIntensityOverride=t,null!==t&&(this.glowIntensity=t,this.baseGlowIntensity=t)}sliderToIntensity(t){const e=t/100;return.3*Math.pow(10/.3,e)}setIntensityCalibration(t){this.intensityCalibrationOffset=t,this.setEmotion(this.emotion,this.undertone)}getGlowIntensity(){return this.glowIntensity}playGesture(t){this.animationManager.playGesture(t,{onUpdate:(t,e)=>{t.position&&(this.position=t.position),t.rotation&&(this.tempEuler.set(t.rotation[0],t.rotation[1],t.rotation[2],"XYZ"),this.gestureQuaternion.setFromEuler(this.tempEuler)),void 0!==t.scale&&(this.scale=this.baseScale*t.scale),void 0!==t.glowIntensity&&(this.glowIntensity=this.baseGlowIntensity*t.glowIntensity)},onComplete:()=>{this.position=[0,0,0],this.scale=this.baseScale}})}triggerReassembly(t=1500){return this.shatterSystem?this.shatterSystem.triggerReassembly(t):(console.warn("triggerReassembly: ShatterSystem not initialized"),!1)}isShatterFrozen(){return this.shatterSystem?.isFrozen()||!1}setSunShadow(t="off"){"sun"===this.geometryType&&this.effectManager.hasSolarEclipse()?this.effectManager.setSolarEclipse(t):console.warn(" Eclipse only available for sun geometry")}startSolarEclipse(t={}){const e=t.type||"total";"sun"===this.geometryType&&this.effectManager.hasSolarEclipse()?this.effectManager.setSolarEclipse(e):(this.morphToShape("sun"),setTimeout(()=>{this.effectManager.hasSolarEclipse()&&this.effectManager.setSolarEclipse(e)},600))}startLunarEclipse(t={}){const e=t.type||"total";"moon"===this.geometryType&&this.effectManager.hasLunarEclipse()?this.effectManager.setLunarEclipse(e):(this.morphToShape("moon"),setTimeout(()=>{this.effectManager.hasLunarEclipse()&&this.effectManager.setLunarEclipse(e)},600))}stopEclipse(){this.effectManager.stopAllEclipses()}setMoonEclipse(t="off"){"moon"===this.geometryType&&this.effectManager.hasLunarEclipse()?this.effectManager.setLunarEclipse(t):console.warn(" Lunar eclipse only available for moon geometry")}setBloodMoonBlend(t={}){"moon"===this.geometryType&&this.customMaterial?(void 0!==t.blendMode&&(this.customMaterial.uniforms.blendMode.value=t.blendMode),void 0!==t.blendStrength&&(this.customMaterial.uniforms.blendStrength.value=t.blendStrength),void 0!==t.emissiveStrength&&(this.customMaterial.uniforms.emissiveStrength.value=t.emissiveStrength),void 0!==t.eclipseIntensity&&(this.customMaterial.uniforms.eclipseIntensity.value=t.eclipseIntensity)):console.warn(" Blood moon blend only available for moon geometry")}setBlendLayer(t,e={}){if("moon"!==this.geometryType&&"sun"!==this.geometryType||!this.customMaterial)return void console.warn(" Blend layers only available for moon and sun geometry");const i=`layer${t}`;void 0!==e.mode&&this.customMaterial.uniforms[`${i}Mode`]&&(this.customMaterial.uniforms[`${i}Mode`].value=e.mode),void 0!==e.strength&&this.customMaterial.uniforms[`${i}Strength`]&&(this.customMaterial.uniforms[`${i}Strength`].value=e.strength),void 0!==e.enabled&&this.customMaterial.uniforms[`${i}Enabled`]&&(this.customMaterial.uniforms[`${i}Enabled`].value=e.enabled?1:0)}setAllBlendLayers(t){"moon"!==this.geometryType&&"sun"!==this.geometryType||!this.customMaterial?console.warn(" Blend layers only available for moon and sun geometry"):t.forEach((t,e)=>{this.setBlendLayer(e+1,t)})}setCrystalBlendLayer(t,e,i={}){if("crystal"!==this.geometryType&&"rough"!==this.geometryType||!this.customMaterial||"crystal"!==this.customMaterialType)return;const n=`${t}Blend${e}`;void 0!==i.mode&&this.customMaterial.uniforms[`${n}Mode`]&&(this.customMaterial.uniforms[`${n}Mode`].value=i.mode),void 0!==i.strength&&this.customMaterial.uniforms[`${n}Strength`]&&(this.customMaterial.uniforms[`${n}Strength`].value=i.strength),void 0!==i.enabled&&this.customMaterial.uniforms[`${n}Enabled`]&&(this.customMaterial.uniforms[`${n}Enabled`].value=i.enabled?1:0)}setCrystalUniforms(t={}){if("crystal"!==this.geometryType&&"rough"!==this.geometryType||!this.customMaterial||"crystal"!==this.customMaterialType)return void console.warn(" Crystal uniforms only available with crystal blend-layers material");const{uniforms:e}=this.customMaterial,i=(t,e,i=0,n=10)=>{t&&"number"==typeof e&&!isNaN(e)&&isFinite(e)&&(t.value=Math.max(i,Math.min(n,e)))};i(e.coreGlowStrength,t.coreGlowStrength,0,2),void 0===t.coreGlowFalloff||isNaN(t.coreGlowFalloff)||(i(e.coreGlowFalloff,t.coreGlowFalloff,.1,3),this.setCrystalCoreSize(t.coreGlowFalloff)),i(e.fresnelStrength,t.fresnelStrength,0,2),i(e.fresnelPower,t.fresnelPower,.5,10),i(e.transmissionStrength,t.transmissionStrength,0,1),i(e.facetStrength,t.facetStrength,0,2),i(e.iridescenceStrength,t.iridescenceStrength,0,1),i(e.chromaticAberration,t.chromaticAberration,0,1),i(e.causticStrength,t.causticStrength,0,1),i(e.emissiveIntensity,t.emissiveIntensity,0,5),i(e.sparkleEnabled,t.sparkleEnabled,0,1),i(e.sparkleSpeed,t.sparkleSpeed,.1,5),i(e.causticEnabled,t.causticEnabled,0,1),i(e.causticSpeed,t.causticSpeed,.1,10),i(e.causticScale,t.causticScale,.5,10),i(e.causticCoverage,t.causticCoverage,0,1),i(e.energyPulseEnabled,t.energyPulseEnabled,0,1),i(e.energyPulseSpeed,t.energyPulseSpeed,.1,5)}createCrystalInnerCore(){if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!this.coreMesh)return;const t=this._targetGeometryType||this.geometryType;this.crystalSoul=new sM({radius:.35,detail:1,geometryType:t,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(this.coreMesh,this.renderer?.scene);let e=1;"heart"===t?(this.crystalShellBaseScale=2.4,e=1):"rough"===t?(this.crystalShellBaseScale=1.6,e=1):"star"===t?(this.crystalShellBaseScale=2,e=1.4):"crystal"===t&&(this.crystalShellBaseScale=2,e=1),this.crystalSoul.baseScale=e,this.crystalSoul.mesh.scale.setScalar(e),this.crystalSoul.setVisible(this.coreGlowEnabled),this.crystalInnerCore=this.crystalSoul.mesh,this.crystalInnerCoreMaterial=this.crystalSoul.material,this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}updateCrystalInnerCore(t,e=0){if(!this.crystalSoul)return;const i=this.breathingAnimator&&this.breathingEnabled?this.breathingAnimator.getBreathingScale():1;this.crystalSoul.update(e,t,i),this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}setCrystalSoulEffects(t={}){this.crystalSoul&&this.crystalSoul.setEffects(t)}setCrystalCoreSize(t){this.crystalSoul&&(this.crystalSoul.setSize(t),this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale)}setCrystalShellSize(t){!this.coreMesh||"crystal"!==this.geometryType&&"rough"!==this.geometryType&&"heart"!==this.geometryType||(this.crystalShellBaseScale=t)}setWobbleEnabled(t){this.wobbleEnabled=t,this.behaviorController.setWobbleEnabled(t),t||(this.baseEuler[0]=0,this.baseEuler[2]=0)}setMaterialVariant(t){this.materialVariant=t}setRhythmEnabled(t){this.rhythmEnabled=t,t&&this.rhythm3DAdapter&&!this.rhythm3DAdapter.enabled&&this.rhythm3DAdapter.initialize()}setGrooveEnabled(t){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGrooveEnabled(t)}setBeatSyncStrength(t){this.rhythm3DAdapter&&this.rhythm3DAdapter.setBeatSyncStrength(t)}setGrooveConfig(t){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGrooveConfig(t)}isRhythmPlaying(){return this.rhythm3DAdapter?.isPlaying()||!1}getRhythmBPM(){return this.rhythm3DAdapter?.getBPM()||120}startRhythm(t=120,e="straight"){this.rhythm3DAdapter&&this.rhythm3DAdapter.start(t,e)}stopRhythm(){this.rhythm3DAdapter&&this.rhythm3DAdapter.stop()}setRhythmBPM(t){this.rhythm3DAdapter&&this.rhythm3DAdapter.setBPM(t)}setRhythmPattern(t){this.rhythm3DAdapter&&this.rhythm3DAdapter.setPattern(t)}setGroove(t,e={}){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGroove(t,e)}getGroovePresets(){return this.rhythm3DAdapter?this.rhythm3DAdapter.getGroovePresets():["groove1","groove2","groove3"]}getCurrentGroove(){return this.rhythm3DAdapter?this.rhythm3DAdapter.getCurrentGroove():"groove1"}breathePhase(t,e){this.breathingPhaseManager.startPhase(t,e)}stopBreathingPhase(){this.breathingPhaseManager.stop()}_updateBreathingPhase(t){return this.breathingPhaseManager.update(t)}morphToShape(t,e=800){const i=Vm[t];i?this.geometryMorpher.startMorph(this.geometryType,t,e)&&(this.geometryMorpher.getInterruptedTarget(),this.blinkAnimator.pause(),this._targetGeometryConfig=i,this._targetGeometryType=t,i.geometryLoader&&!i.geometry?(this._targetGeometry=null,this._pendingGeometryLoad=i.geometryLoader(this.assetBasePath).then(t=>{this._targetGeometry=t,i.geometry=t,this._pendingGeometryLoad=null})):(this._targetGeometry=i.geometry,this._pendingGeometryLoad=null)):console.warn(`Unknown shape: ${t}`)}isMorphing(){return this.geometryMorpher.isTransitioning}getMorphState(){return this.geometryMorpher.getState()}growIn(t=500){this.geometryMorpher.growIn(this.geometryType,t)}easeInOutCubic(t){return t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2}render(t){if(this._destroyed)return;if(!this._ready)return;this.animator.update(t);const e=this.geometryMorpher.update(t);if(e.shouldSwapGeometry&&this._pendingGeometryLoad&&this.geometryMorpher.pauseAtSwap(),e.waitingForGeometry&&this._targetGeometry&&!this._pendingGeometryLoad&&(this.geometryMorpher.resumeFromSwap(),this.geometryMorpher.hasSwappedGeometry=!1),e.shouldSwapGeometry&&this._targetGeometry){this._skipRenderFrames=3;const t=this.geometryType;this.customMaterial&&function(t,e){switch(t){case"moon":!function(t){if(!t||!t.uniforms)return;const e=t.uniforms;e.shadowOffset&&e.shadowOffset.value.set(bm.full.x,bm.full.y),e.shadowCoverage&&(e.shadowCoverage.value=.5),e.shadowSoftness&&(e.shadowSoftness.value=.05),e.eclipseProgress&&(e.eclipseProgress.value=0),e.eclipseIntensity&&(e.eclipseIntensity.value=0),e.bloodMoonColor&&(e.bloodMoonColor.value=[.85,.18,.08]),e.emissiveStrength&&(e.emissiveStrength.value=.39),e.eclipseShadowPos&&(e.eclipseShadowPos.value=[-2,0]),e.eclipseShadowRadius&&(e.eclipseShadowRadius.value=1.2),e.shadowDarkness&&(e.shadowDarkness.value=.53),e.eclipseShadowColor&&(e.eclipseShadowColor.value=[1,.58,0]),e.eclipseMidtoneColor&&(e.eclipseMidtoneColor.value=[.71,.43,.03]),e.eclipseHighlightColor&&(e.eclipseHighlightColor.value=[1,.28,.1]),e.eclipseGlowColor&&(e.eclipseGlowColor.value=[.09,.09,.09]),e.eclipseBrightnessModel&&(e.eclipseBrightnessModel.value=0),e.layer1Mode&&(e.layer1Mode.value=9),e.layer1Strength&&(e.layer1Strength.value=.322),e.layer1Enabled&&(e.layer1Enabled.value=1),e.layer2Mode&&(e.layer2Mode.value=0),e.layer2Strength&&(e.layer2Strength.value=2.785),e.layer2Enabled&&(e.layer2Enabled.value=1),e.layer3Mode&&(e.layer3Mode.value=7),e.layer3Strength&&(e.layer3Strength.value=.199),e.layer3Enabled&&(e.layer3Enabled.value=1),e.layer4Mode&&(e.layer4Mode.value=0),e.layer4Strength&&(e.layer4Strength.value=0),e.layer4Enabled&&(e.layer4Enabled.value=0),e.opacity&&(e.opacity.value=1)}(e);break;case"sun":!function(t){if(!t||!t.uniforms)return;const e=t.uniforms;e.eclipseProgress&&(e.eclipseProgress.value=0),e.eclipseShadowPos&&(e.eclipseShadowPos.value=[-2,0]),e.eclipseShadowRadius&&(e.eclipseShadowRadius.value=.882),e.shadowDarkness&&(e.shadowDarkness.value=1),e.shadowOffset&&e.shadowOffset.value.set(200,0),e.shadowCoverage&&(e.shadowCoverage.value=.5),e.shadowSoftness&&(e.shadowSoftness.value=.1),e.layer1Mode&&(e.layer1Mode.value=0),e.layer1Strength&&(e.layer1Strength.value=.23),e.layer1Enabled&&(e.layer1Enabled.value=1),e.layer2Mode&&(e.layer2Mode.value=0),e.layer2Strength&&(e.layer2Strength.value=0),e.layer2Enabled&&(e.layer2Enabled.value=0),e.layer3Mode&&(e.layer3Mode.value=0),e.layer3Strength&&(e.layer3Strength.value=0),e.layer3Enabled&&(e.layer3Enabled.value=0),e.layer4Mode&&(e.layer4Mode.value=0),e.layer4Strength&&(e.layer4Strength.value=0),e.layer4Enabled&&(e.layer4Enabled.value=0),e.emissiveIntensity&&(e.emissiveIntensity.value=4),e.opacity&&(e.opacity.value=1),e.time&&(e.time.value=0)}(e);break;case"crystal":case"diamond":!function(t){if(!t||!t.uniforms)return;const e=t.uniforms,i=gM;e.frostiness&&(e.frostiness.value=i.frostiness),e.fresnelPower&&(e.fresnelPower.value=i.fresnelPower),e.fresnelIntensity&&(e.fresnelIntensity.value=i.fresnelIntensity),e.innerGlowStrength&&(e.innerGlowStrength.value=i.innerGlowStrength),e.surfaceRoughness&&(e.surfaceRoughness.value=i.surfaceRoughness),e.surfaceNoiseScale&&(e.surfaceNoiseScale.value=i.surfaceNoiseScale),e.noiseFrequency&&(e.noiseFrequency.value=i.noiseFrequency),e.causticIntensity&&(e.causticIntensity.value=i.causticIntensity),e.causticScale&&(e.causticScale.value=i.causticScale),e.causticSpeed&&(e.causticSpeed.value=i.causticSpeed),e.textureStrength&&(e.textureStrength.value=i.textureStrength),e.layer1Mode&&(e.layer1Mode.value=i.layer1Mode),e.layer1Strength&&(e.layer1Strength.value=i.layer1Strength),e.layer1Enabled&&(e.layer1Enabled.value=i.layer1Enabled),e.layer2Mode&&(e.layer2Mode.value=i.layer2Mode),e.layer2Strength&&(e.layer2Strength.value=i.layer2Strength),e.layer2Enabled&&(e.layer2Enabled.value=i.layer2Enabled),e.layer3Mode&&(e.layer3Mode.value=i.layer3Mode),e.layer3Strength&&(e.layer3Strength.value=i.layer3Strength),e.layer3Enabled&&(e.layer3Enabled.value=i.layer3Enabled),e.layer4Mode&&(e.layer4Mode.value=i.layer4Mode),e.layer4Strength&&(e.layer4Strength.value=i.layer4Strength),e.layer4Enabled&&(e.layer4Enabled.value=i.layer4Enabled),e.glowIntensity&&(e.glowIntensity.value=i.glowIntensity),e.opacity&&(e.opacity.value=i.opacity),e.time&&(e.time.value=i.time)}(e)}}(t,this.customMaterial),this.geometry=this._targetGeometry,this.geometryType=this._targetGeometryType,this.geometryConfig=this._targetGeometryConfig,this.customMaterial&&(vM(this.customMaterial),this.renderer.disposeMaterial(this.customMaterial),this.customMaterial=null,this.customMaterialType=null);let e=null;const i=Km(this.emotion),n=fM(this._targetGeometryType,this._targetGeometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:i,assetBasePath:this.assetBasePath});if(n&&(e=n.material,this.customMaterial=e,this.customMaterialType=n.type),e)this.renderer.swapGeometry(this.geometry,e);else{this.renderer.swapGeometry(this.geometry);const t=!0===this._targetGeometryConfig.defaultGlassMode;this.setGlassMaterialEnabled(t)}this.onMaterialSwap&&this.onMaterialSwap({geometryType:this._targetGeometryType,material:this.customMaterial,materialType:this.customMaterialType}),this.blinkAnimator.setGeometry(this._targetGeometryConfig),this.rotation=[0,0,0];const s=this.geometry.parameters?.radius||.5;this.effectManager.initializeForGeometry(this._targetGeometryType,{coreMesh:this.renderer.coreMesh,customMaterial:this.customMaterial,sunRadius:s}),"crystal"===this._targetGeometryType||"rough"===this._targetGeometryType||"heart"===this._targetGeometryType||"star"===this._targetGeometryType?"crystal"===this.customMaterialType&&this.createCrystalInnerCore():this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null,this.crystalInnerCore=null,this.crystalInnerCoreMaterial=null);let a=null;if("moon"===this._targetGeometryType&&vm.enabled){const t=Math.PI/180;a={enabled:!0,strength:vm.strength,lockedFace:vm.lockedFace,lerpSpeed:vm.lerpSpeed,calibrationRotation:[gm*t,fm*t,ym*t]}}if(this.behaviorController.configureForMorph({targetGeometryType:this._targetGeometryType,emotionData:i,facingConfig:a,geometryRotation:null}),"moon"===this._targetGeometryType){this.renderer?.controls&&(this.renderer.controls.autoRotate=!1),this.renderer?.setCameraPreset&&this.renderer.setCameraPreset("front",0,!0);const t=Math.PI/180;this.calibrationRotation[0]=gm*t,this.calibrationRotation[1]=fm*t,this.calibrationRotation[2]=ym*t}else if(this.renderer?.controls&&!1!==this.options.autoRotate&&(this.renderer.controls.autoRotate=!0),"crystal"===this._targetGeometryType||"rough"===this._targetGeometryType||"heart"===this._targetGeometryType){const t=Math.PI/180;this.calibrationRotation[0]=0*t,this.calibrationRotation[1]=30*t,this.calibrationRotation[2]=0*t}else this.calibrationRotation[0]=0,this.calibrationRotation[1]=0,this.calibrationRotation[2]=0}e.completed&&(this._targetGeometry=null,this._targetGeometryType=null,this._targetGeometryConfig=null,this.blinkingManuallyDisabled||this.blinkAnimator.resume()),this.breathingAnimator.update(t,this.emotion,dg(this.undertone));const i=this._updateBreathingPhase(t),n=1!==i?i:this.breathingEnabled?this.breathingAnimator.getBreathingScale():1,s=e.scaleMultiplier,a=this.blinkAnimator.update(t),r=this._pendingFreezeRotation||0,o=this._pendingFreezeWobble||0;if(r>0){const e=t*(1-r);this.behaviorController.update(e,this.baseEuler)}else this.behaviorController.update(t,this.baseEuler);o>.5&&this.wobbleEnabled?(this.behaviorController.setWobbleEnabled(!1),this._wobbleWasFrozen=!0):this._wobbleWasFrozen&&o<.5&&(this.behaviorController.setWobbleEnabled(this.wobbleEnabled),this._wobbleWasFrozen=!1);this.baseEuler[0]=Math.max(-.35,Math.min(.35,this.baseEuler[0])),this.baseEuler[2]=Math.max(-.35,Math.min(.35,this.baseEuler[2])),this.tempEuler.set(this.baseEuler[0],this.baseEuler[1],this.baseEuler[2],"XYZ"),this.baseQuaternion.setFromEuler(this.tempEuler),this.rhythm3DAdapter&&this.rhythm3DAdapter.update(t);const l=this.animationManager.blend(this.baseEuler,this.baseScale,this.baseGlowIntensity),h=this.rhythm3DAdapter?.isPlaying()?this.rhythm3DAdapter.getModulation():null,c=l.hasAbsoluteGestures;void 0===this._grooveBlendCurrent&&(this._grooveBlendCurrent=1),void 0===this._smoothedBoost&&(this._smoothedBoost={position:[0,0,0],rotation:[0,0,0],scale:1});const u=(c?.3:1)*(1-(l.freezeGroove||0)),d=t/1e3,p=1-Math.exp(-12*d);this._grooveBlendCurrent+=(u-this._grooveBlendCurrent)*p;const m=this._grooveBlendCurrent,g=l.positionBoost||[0,0,0],f=l.rotationBoost||[0,0,0],y=l.scaleBoost||1;for(let t=0;t<3;t++)this._smoothedBoost.position[t]+=(g[t]-this._smoothedBoost.position[t])*p,this._smoothedBoost.rotation[t]+=(f[t]-this._smoothedBoost.rotation[t])*p;this._smoothedBoost.scale+=(y-this._smoothedBoost.scale)*p;const v=this._smoothedBoost.position,b=this._smoothedBoost.rotation,M=this._smoothedBoost.scale;let _=0,x=0,w=0;if(this._cameraRoll=0,l.hasCameraRelativeGestures&&this.renderer.camera){const t=this.renderer.camera,e=l.cameraRelativePosition;this._camTempVec3||(this._camTempVec3=new qe,this._camRight=new qe,this._camUp=new qe,this._camForward=new qe),t.updateMatrixWorld(),t.getWorldDirection(this._camForward),this._camRight.setFromMatrixColumn(t.matrixWorld,0),this._camUp.setFromMatrixColumn(t.matrixWorld,1),_=this._camRight.x*e[0]+this._camUp.x*e[1]-this._camForward.x*e[2],x=this._camRight.y*e[0]+this._camUp.y*e[1]-this._camForward.y*e[2],w=this._camRight.z*e[0]+this._camUp.z*e[1]-this._camForward.z*e[2];const i=l.cameraRelativeRotation;i&&0!==i[2]?this._cameraRoll=i[2]:this._cameraRoll=0}if(h){const t=h.grooveOffset[0]*m,e=h.grooveOffset[1]*m,i=h.grooveOffset[2]*m,n=c?h.positionMultiplier:1;this.position=[l.position[0]*n+_+t+v[0],l.position[1]*n+x+e+v[1],l.position[2]*n+w+i+v[2]],this.rotation=[l.rotation[0]+h.grooveRotation[0]*m+b[0],l.rotation[1]+h.grooveRotation[1]*m+b[1],l.rotation[2]+h.grooveRotation[2]*m+b[2]];const s=1+(h.grooveScale-1)*m,a=c?h.scaleMultiplier:1;if(this.scale=l.scale*s*a*M,l.nonUniformScale){const t=s*a*M;this.nonUniformScale=[l.nonUniformScale[0]*t,l.nonUniformScale[1]*t,l.nonUniformScale[2]*t]}else this.nonUniformScale=null}else this.position=[l.position[0]+_+v[0],l.position[1]+x+v[1],l.position[2]+w+v[2]],this.rotation=[l.rotation[0]+b[0],l.rotation[1]+b[1],l.rotation[2]+b[2]],this.scale=l.scale*M,l.nonUniformScale?this.nonUniformScale=[l.nonUniformScale[0]*M,l.nonUniformScale[1]*M,l.nonUniformScale[2]*M]:this.nonUniformScale=null;if(null===this.glowIntensityOverride)if(h){const t=1+(h.grooveGlow-1)*m,e=c?h.glowMultiplier:1;this.glowIntensity=l.glowIntensity*t*e}else this.glowIntensity=l.glowIntensity;if(this.gestureQuaternion=l.gestureQuaternion,this.glowBoost=l.glowBoost||0,this._pendingFreezeRotation=l.freezeRotation||0,this._pendingFreezeWobble=l.freezeWobble||0,l.deformation&&l.deformation.enabled&&this.renderer?.camera&&this.renderer?.coreMesh){const t=l.deformation,e=t.impactPoint,i=this.renderer.camera,n=this.renderer.coreMesh;i.updateMatrixWorld(),n.updateMatrixWorld(),this._deformCamRight||(this._deformCamRight=new qe,this._deformCamUp=new qe,this._deformCamForward=new qe,this._deformWorldDir=new qe,this._deformLocalDir=new qe,this._deformInverseQuat=new Xe),i.getWorldDirection(this._deformCamForward),this._deformCamRight.setFromMatrixColumn(i.matrixWorld,0),this._deformCamUp.setFromMatrixColumn(i.matrixWorld,1),this._deformWorldDir.set(this._deformCamRight.x*e[0]+this._deformCamUp.x*e[1]-this._deformCamForward.x*e[2],this._deformCamRight.y*e[0]+this._deformCamUp.y*e[1]-this._deformCamForward.y*e[2],this._deformCamRight.z*e[0]+this._deformCamUp.z*e[1]-this._deformCamForward.z*e[2]),n.getWorldQuaternion(this._deformInverseQuat),this._deformInverseQuat.invert(),this._deformLocalDir.copy(this._deformWorldDir),this._deformLocalDir.applyQuaternion(this._deformInverseQuat),this._deformation={...t,impactPoint:[this._deformLocalDir.x,this._deformLocalDir.y,this._deformLocalDir.z]}}else l.deformation&&l.deformation.enabled?this._deformation={...l.deformation}:this._deformation=l.deformation||null;if(this.shatterSystem?.isFrozen()||(this._frozenShardsMovedThisGesture=!1),l.shatter&&l.shatter.enabled){const t=l.shatter;if(t.isDualMode&&this.shatterSystem.isFrozen())this.shatterSystem.triggerDualMode(t.dualModeType,t.dualModeConfig||{});else if("reform"===t.variant&&this.shatterSystem.isFrozen())this.shatterSystem.triggerReassembly(t.reassembleDuration||1500);else if(t.isDualMode||!this.shatterSystem.isFrozen()||this._frozenShardsMovedThisGesture){if(this.shatterSystem.isIdle()){const e=t.impactPoint||[0,0,.4];let i=new qe(e[0],e[1],e[2]);if(this.renderer?.camera&&this.renderer?.coreMesh){const t=this.renderer.camera,n=this.renderer.coreMesh,s=new qe,a=new qe,r=new qe;t.getWorldDirection(r),s.crossVectors(t.up,r).normalize(),a.crossVectors(r,s).normalize(),i=(new qe).addScaledVector(s,e[0]).addScaledVector(a,e[1]).addScaledVector(r,-e[2]),i.add(n.position);const o=this.crystalSoul?.mesh||null;this.shatterSystem.setTargets(n,o)}const n=t.impactDirection||[0,0,-1];let s=new qe(n[0],n[1],n[2]);if(this.renderer?.camera){const t=this.renderer.camera,e=new qe,i=new qe,a=new qe;t.getWorldDirection(a),e.crossVectors(t.up,a).normalize(),i.crossVectors(a,e).normalize(),s=(new qe).addScaledVector(e,n[0]).addScaledVector(i,n[1]).addScaledVector(a,-n[2]).normalize()}this.shatterSystem.shatter(this.renderer.coreMesh,{impactPoint:i,impactDirection:s,intensity:t.intensity||1,revealInner:!1!==t.revealSoul,isCrackMode:t.isCrackMode||!1,crackSeparation:t.crackSeparation||.02,isSuspendMode:t.isSuspendMode||!1,suspendAt:t.suspendAt||.25,suspendDuration:t.suspendDuration||.35,isFreezeMode:t.isFreezeMode||!1,isDualMode:t.isDualMode||!1,dualModeType:t.dualModeType,dualModeConfig:t.dualModeConfig||{},gravity:t.gravity,explosionForce:t.explosionForce,rotationForce:t.rotationForce,gestureDuration:t.gestureDuration})}}else{const e=t.impactDirection||[0,0,-1],i=t.variant?.startsWith("punch")?3.5:"explosive"===t.variant?4:"crumble"===t.variant?1.5:2.5;this.shatterSystem.moveFrozenShards(e,i),this._frozenShardsMovedThisGesture=!0}}if(l.shatter&&l.shatter.reassemble&&this.shatterSystem.isShattering()&&this.shatterSystem.reassemble({duration:l.shatter.reassembleDuration||1e3}),this.shatterSystem&&this.shatterSystem.update(t),this.debugMotionLogging&&(this._motionLogInterval||(this._motionLogInterval=0),this._motionLogInterval+=t,this._motionLogInterval>=200)){this._motionLogInterval=0;const t=l.hasAbsoluteGestures||l.hasAccentGestures,e=l.position,i=l.rotation,n=l.scale;(Math.abs(e[0])>.001||Math.abs(e[1])>.001||Math.abs(e[2])>.001||Math.abs(i[0])>.001||Math.abs(i[1])>.001||Math.abs(i[2])>.001||Math.abs(n-1)>.001||h&&(Math.abs(h.grooveOffset[1])>.001||Math.abs(h.grooveScale-1)>.001)||t)&&(console.log("[Motion] "),console.log(`[Motion] GESTURE: pos=[${e.map(t=>t.toFixed(3)).join(", ")}] rot=[${i.map(t=>(180*t/Math.PI).toFixed(1)).join(", ")}] scale=${n.toFixed(3)} hasAbs=${c}`),h&&console.log(`[Motion] GROOVE: offset=[${h.grooveOffset.map(t=>t.toFixed(3)).join(", ")}] rot=[${h.grooveRotation.map(t=>(180*t/Math.PI).toFixed(1)).join(", ")}] scale=${h.grooveScale.toFixed(3)} blend=${m.toFixed(2)}`),console.log(`[Motion] BOOST: pos=[${v.map(t=>t.toFixed(3)).join(", ")}] rot=[${b.map(t=>(180*t/Math.PI).toFixed(1)).join(", ")}] scale=${M.toFixed(3)}`),console.log(`[Motion] FINAL: pos=[${this.position.map(t=>t.toFixed(3)).join(", ")}] rot=[${this.rotation.map(t=>(180*t/Math.PI).toFixed(1)).join(", ")}] scale=${this.scale.toFixed(3)}`))}a.isBlinking&&a.rotation&&(this.rotation[0]+=a.rotation[0],this.rotation[1]+=a.rotation[1],this.rotation[2]+=a.rotation[2]);const S="crystal"!==this.geometryType&&"rough"!==this.geometryType,T=s*n*(a.isBlinking&&S?a.scale[1]:1)*(this.crystalShellBaseScale||2),C=this.scale*T,E=this.nonUniformScale?[this.nonUniformScale[0]*T,this.nonUniformScale[1]*T,this.nonUniformScale[2]*T]:null;if(this.particleVisibility&&this.particleOrchestrator){const e=this.geometryConfig?.particleRadiusMultiplier||1,i=(this.crystalShellBaseScale||2)*this.scale*n*e;this.particleOrchestrator.update(t,this.emotion,this.undertone,this.animationManager.getActiveAnimations(),this.animationManager.getTime(),{x:this.position[0],y:this.position[1],z:this.position[2]},{width:this.canvas.width,height:this.canvas.height},{euler:this.baseEuler,quaternion:this.baseQuaternion,angularVelocity:this.behaviorController.getAngularVelocity()},this.baseScale,i)}const A=a.isBlinking&&a.glowBoost?1+a.glowBoost:1,P=this.coreGlowEnabled?this.glowIntensity*A:0,D=this.emotiveEngine?.getVirtualParticle(),R=P*(D?.opacity??1),I=e.isTransitioning?.3:.1;if(this.renderer.updateBloom(R,I,this.geometryType),this.glowBoost>0||this.renderer.glowLayer&&this.renderer.glowLayer.isActive()){const e=this.coreMesh?.position;this.renderer.updateGlowLayer(this.glowBoost,this.glowColor,e,t)}if("sun"===this.customMaterialType&&zm(this.coreMesh,this.glowColor,R,t),"moon"!==this.customMaterialType&&"moon-multiplexer"!==this.customMaterialType||!this.customMaterial||this.customMaterial.uniforms&&this.customMaterial.uniforms.glowIntensity&&(this.customMaterial.uniforms.glowIntensity.value=R),"crystal"===this.customMaterialType&&this.customMaterial){if(this.customMaterial.uniforms){if(this.customMaterial.uniforms.time.value+=t/1e3,this.customMaterial.uniforms.glowIntensity&&(this.customMaterial.uniforms.glowIntensity.value=R),this._targetGlowColor&&this._colorTransitionProgress<1){const e=this.colorTransitionDuration||500;this._colorTransitionProgress+=t/e,this._colorTransitionProgress=Math.min(this._colorTransitionProgress,1);const i=1-Math.pow(1-this._colorTransitionProgress,2),n=this._colorTransitionStart||this._normalizedGlowColor||[1,1,1],s=this._targetGlowColor;this._normalizedGlowColor=[n[0]+(s[0]-n[0])*i,n[1]+(s[1]-n[1])*i,n[2]+(s[2]-n[2])*i]}if(this._targetSSSValues&&this._sssTransitionProgress<1){const e=this.sssTransitionDuration||500;this._sssTransitionProgress+=t/e,this._sssTransitionProgress=Math.min(this._sssTransitionProgress,1);const i=1-Math.pow(1-this._sssTransitionProgress,2),n=this.customMaterial.uniforms,s=this._sssTransitionStart,a=this._targetSSSValues;n.sssStrength&&void 0!==s.sssStrength&&(n.sssStrength.value=s.sssStrength+(a.sssStrength-s.sssStrength)*i),n.sssThicknessBias&&void 0!==s.sssThicknessBias&&(n.sssThicknessBias.value=s.sssThicknessBias+(a.sssThicknessBias-s.sssThicknessBias)*i),n.sssThicknessScale&&void 0!==s.sssThicknessScale&&(n.sssThicknessScale.value=s.sssThicknessScale+(a.sssThicknessScale-s.sssThicknessScale)*i),n.sssCurvatureScale&&void 0!==s.sssCurvatureScale&&(n.sssCurvatureScale.value=s.sssCurvatureScale+(a.sssCurvatureScale-s.sssCurvatureScale)*i),n.sssAmbient&&void 0!==s.sssAmbient&&(n.sssAmbient.value=s.sssAmbient+(a.sssAmbient-s.sssAmbient)*i),n.frostiness&&void 0!==s.frostiness&&(n.frostiness.value=s.frostiness+(a.frostiness-s.frostiness)*i),n.innerGlowStrength&&void 0!==s.innerGlowStrength&&(n.innerGlowStrength.value=s.innerGlowStrength+(a.innerGlowStrength-s.innerGlowStrength)*i),n.fresnelIntensity&&void 0!==s.fresnelIntensity&&(n.fresnelIntensity.value=s.fresnelIntensity+(a.fresnelIntensity-s.fresnelIntensity)*i),n.causticIntensity&&void 0!==s.causticIntensity&&(n.causticIntensity.value=s.causticIntensity+(a.causticIntensity-s.causticIntensity)*i),n.emotionColorBleed&&void 0!==s.emotionColorBleed&&(n.emotionColorBleed.value=s.emotionColorBleed+(a.emotionColorBleed-s.emotionColorBleed)*i),n.sssAbsorption&&s.sssAbsorption&&n.sssAbsorption.value.set(s.sssAbsorption[0]+(a.sssAbsorption[0]-s.sssAbsorption[0])*i,s.sssAbsorption[1]+(a.sssAbsorption[1]-s.sssAbsorption[1])*i,s.sssAbsorption[2]+(a.sssAbsorption[2]-s.sssAbsorption[2])*i),n.sssScatterDistance&&s.sssScatterDistance&&n.sssScatterDistance.value.set(s.sssScatterDistance[0]+(a.sssScatterDistance[0]-s.sssScatterDistance[0])*i,s.sssScatterDistance[1]+(a.sssScatterDistance[1]-s.sssScatterDistance[1])*i,s.sssScatterDistance[2]+(a.sssScatterDistance[2]-s.sssScatterDistance[2])*i)}const e=this._normalizedGlowColor||[1,1,1];if(this.customMaterial.uniforms.emotionColor.value.setRGB(e[0],e[1],e[2]),this.customMaterial.uniforms.blinkIntensity){const t=a.isBlinking?Math.sin(a.progress*Math.PI):0;this.customMaterial.uniforms.blinkIntensity.value=t}}const e=this.shatterSystem&&!this.shatterSystem.isIdle();if(this.coreGlowEnabled&&!e){const e=this._normalizedGlowColor||[1,1,1];this.updateCrystalInnerCore(e,t)}}this._skipRenderFrames>0?this._skipRenderFrames--:(this.renderer.render({position:this.position,rotation:this.rotation,scale:C,nonUniformScale:E,glowColor:this.glowColor,glowColorHex:this.glowColorHex,glowIntensity:R,hasActiveGesture:this.animationManager.hasActiveAnimations(),calibrationRotation:this.calibrationRotation,cameraRoll:this._cameraRoll||0,solarEclipse:this.effectManager.getSolarEclipse(),deltaTime:t,morphProgress:e.isTransitioning?e.visualProgress:null,hasSoul:"crystal"===this.customMaterialType&&null!==this.crystalSoul,hasParticles:this.particleVisibility&&null!==this.particleOrchestrator,deformation:this._deformation}),this.effectManager.updateLunarEclipse(t))}async _loadAsyncGeometry(){try{const t=await MM(this.geometryType,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:Km(this.emotion),assetBasePath:this.assetBasePath});if(this._destroyed)return;if(!t||!t.geometry)return console.warn(`[Core3D:${this._instanceId}] Async geometry load returned null!`),void(this._ready=!0);const e=t.geometry.clone();if(e.userData.geometryType=this.geometryType,this.geometry=e,this._deferredMeshCreation){if(this.coreMesh=this.renderer.createCoreMesh(e,this.customMaterial),this._destroyed)return;if("crystal"===this.customMaterialType&&(await this._createCrystalInnerCoreAsync(),this._destroyed))return;this._deferredMeshCreation=!1}else if(this.coreMesh){const t=this.coreMesh.geometry;if(this.coreMesh.geometry=e,t&&t!==e&&t.dispose(),this._destroyed)return;if("crystal"===this.customMaterialType&&(await this._createCrystalInnerCoreAsync(),this._destroyed))return}if(this._destroyed)return;this._logSceneHierarchy(),this._ready=!0}catch(t){console.warn(`[Core3D:${this._instanceId}] Async geometry load FAILED:`,t),this._destroyed||(this._ready=!0)}}_logSceneHierarchy(){const t=this.renderer?.scene;t&&t.children.forEach((t,e)=>{const i=null===t?"NULL!":void 0===t?"UNDEFINED!":null===t.visible?"visible=NULL!":void 0===t.visible?"visible=UNDEF!":"OK";console.warn(`  [${e}] ${t?.name||t?.type||"UNKNOWN"} status=${i} uuid=${t?.uuid?.slice(0,8)||"N/A"}`)})}async _createCrystalInnerCoreAsync(){if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!this.coreMesh)return;if(await sM._loadInclusionGeometry(this.assetBasePath),this._destroyed||!this.coreMesh)return;this.crystalSoul=new sM({radius:.35,detail:1,geometryType:this.geometryType,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(this.coreMesh,this.renderer?.scene);let t=1;"heart"===this.geometryType?(this.crystalShellBaseScale=2.4,t=1):"rough"===this.geometryType?(this.crystalShellBaseScale=1.6,t=1):"crystal"===this.geometryType&&(t=1),this.crystalSoul.baseScale=t,this.crystalSoul.mesh.scale.setScalar(t),this.crystalSoul.setVisible(this.coreGlowEnabled),this.crystalInnerCore=this.crystalSoul.mesh,this.crystalInnerCoreMaterial=this.crystalSoul.material,this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}async _handleContextRestored(){if(!this._destroyed&&this.coreMesh&&this.customMaterialType){const t=Km(this.emotion),e=fM(this.geometryType,this.geometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:t,assetBasePath:this.assetBasePath});e&&(this.customMaterial&&vM(this.customMaterial),this.customMaterial=e.material,this.coreMesh.material=this.customMaterial,"crystal"===this.customMaterialType&&this.crystalSoul&&await this._createCrystalInnerCoreAsync(),this.onMaterialSwap&&this.onMaterialSwap())}}isReady(){return this._ready}async waitUntilReady(){this._ready||this._readyPromise&&await this._readyPromise}destroy(){if(this._destroyed=!0,this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null,this.crystalInnerCore=null,this.crystalInnerCoreMaterial=null),this.particleOrchestrator){const t=this.particleOrchestrator.renderer;if(t){const e=t.getPoints();e&&this.renderer?.scene&&this.renderer.scene.remove(e)}this.particleOrchestrator.destroy(),this.particleOrchestrator=null}this.shatterSystem&&(this.shatterSystem.dispose(),this.shatterSystem=null),this.effectManager&&(this.effectManager.dispose(),this.effectManager=null),this.behaviorController&&(this.behaviorController.dispose(),this.behaviorController=null),this.breathingPhaseManager&&(this.breathingPhaseManager.dispose(),this.breathingPhaseManager=null),this.customMaterial&&(this.renderer.disposeMaterial(this.customMaterial),this.customMaterial=null,this.customMaterialType=null),this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null),this.animationManager.stopAll(),this.renderer.destroy(),this.animationManager.dispose(),this.animationManager=null,this.animator.destroy?.(),this.breathingAnimator.destroy?.(),this.gestureBlender.destroy?.(),this.geometryMorpher.destroy?.(),this.blinkAnimator.destroy?.(),this.behaviorController.dispose(),this.behaviorController=null,this.tempEuler=null,this.baseQuaternion=null,this.gestureQuaternion=null,this.geometry=null,this.geometryConfig=null,this._targetGeometry=null,this._targetGeometryConfig=null,this._targetGeometryType=null,this.canvas=null,this.options=null,this.coreMesh=null,this.rhythmEngine=null,this.rhythm3DAdapter=null,this.emotiveEngine=null,xM()}_getEmotionGroove(t){return{happy:"groove2",excited:"groove2",amused:"groove2",silly:"groove2",surprised:"groove2",calm:"groove1",neutral:"groove1",sad:"groove1",content:"groove1",focused:"groove1",bored:"groove1",tired:"groove1",sleepy:"groove1",zen:"groove3",love:"groove3",grateful:"groove3",inspired:"groove3",hopeful:"groove3",proud:"groove3",angry:"groove2",anxious:"groove2",determined:"groove2"}[t]||"groove1"}async preloadGeometries(){const t={glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:Km(this.emotion)};await _M(t)}}class XM{constructor(t={}){this.config=t,this.container=null,this.webglCanvas=null,this.canvas2D=null,this._canvasAppended=!1}setup(t){if("CANVAS"===t.tagName){const e=t.parentElement;this.container=document.createElement("div"),this.container.style.position="relative",this.container.style.width="100%",this.container.style.height="100%",e.replaceChild(this.container,t)}else this.container=t,this.container.style.position&&"static"!==this.container.style.position||(this.container.style.position="relative");return this.canvas2D=document.createElement("canvas"),this.canvas2D.id=`${this.config.canvasId}-particles`,this.canvas2D.width=this.container.offsetWidth||400,this.canvas2D.height=this.container.offsetHeight||400,this.canvas2D.style.position="absolute",this.canvas2D.style.top="0",this.canvas2D.style.left="0",this.canvas2D.style.width="100%",this.canvas2D.style.height="100%",this.canvas2D.style.background="transparent",this.canvas2D.style.zIndex="1",this.canvas2D.style.pointerEvents="none",this.container.appendChild(this.canvas2D),this.webglCanvas=document.createElement("canvas"),this.webglCanvas.id=`${this.config.canvasId}-3d`,this.webglCanvas.width=this.canvas2D.width,this.webglCanvas.height=this.canvas2D.height,this.webglCanvas.style.cssText="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: transparent;\n            z-index: 2;\n        ",this.config.enableControls?(this.webglCanvas.style.pointerEvents="auto",this.webglCanvas.style.touchAction="none"):(this.webglCanvas.style.pointerEvents="none",this.webglCanvas.style.touchAction="auto"),this._canvasAppended=!1,{container:this.container,webglCanvas:this.webglCanvas,canvas2D:this.canvas2D}}appendWebGLCanvas(){!this._canvasAppended&&this.webglCanvas&&this.container&&(this.container.appendChild(this.webglCanvas),this._canvasAppended=!0)}isCanvasAppended(){return this._canvasAppended}getDimensions(){return{width:this.canvas2D?.width||0,height:this.canvas2D?.height||0}}resize(t,e){this.canvas2D&&(this.canvas2D.width=t,this.canvas2D.height=e),this.webglCanvas&&(this.webglCanvas.width=t,this.webglCanvas.height=e)}destroy(){this.webglCanvas&&this.webglCanvas.parentNode&&this.webglCanvas.parentNode.removeChild(this.webglCanvas),this.canvas2D&&this.canvas2D.parentNode&&this.canvas2D.parentNode.removeChild(this.canvas2D),this.container=null,this.webglCanvas=null,this.canvas2D=null,this._canvasAppended=!1}}class qM{constructor(){this.listeners=new Map,this.groups=new Map,this.stats={registered:0,removed:0,active:0}}addEventListener(t,e,i,n={},s="default"){const a=this.generateId(),r={id:a,target:t,eventType:e,handler:i,options:n,group:s,active:!0};return this.listeners.set(a,r),this.groups.has(s)||this.groups.set(s,new Set),this.groups.get(s).add(a),t.addEventListener(e,i,n),this.stats.registered++,this.stats.active++,a}removeEventListener(t){const e=this.listeners.get(t);if(!e||!e.active)return!1;e.target.removeEventListener(e.eventType,e.handler,e.options),e.active=!1;const i=this.groups.get(e.group);return i&&(i.delete(t),0===i.size&&this.groups.delete(e.group)),this.listeners.delete(t),this.stats.removed++,this.stats.active--,!0}removeGroup(t){const e=this.groups.get(t);if(!e)return 0;let i=0;for(const t of e)this.removeEventListener(t)&&i++;return i}removeAllForTarget(t){let e=0;for(const[i,n]of this.listeners.entries())n.target===t&&n.active&&this.removeEventListener(i)&&e++;return e}removeAllOfType(t){let e=0;for(const[i,n]of this.listeners.entries())n.eventType===t&&n.active&&this.removeEventListener(i)&&e++;return e}removeAll(){let t=0;for(const[e,i]of this.listeners.entries())i.active&&this.removeEventListener(e)&&t++;return t}createAutoRemove(t,e,i,n={}){const s=this.addEventListener(t,e,i,n);return{id:s,remove:()=>this.removeEventListener(s)}}once(t,e,i,n={}){const s=this.addEventListener(t,e,t=>{i(t),this.removeEventListener(s)},n);return s}debounced(t,e,i,n=250,s={}){let a;return this.addEventListener(t,e,t=>{clearTimeout(a),a=setTimeout(()=>i(t),n)},s)}throttled(t,e,i,n=100,s={}){let a=!1;return this.addEventListener(t,e,t=>{a||(i(t),a=!0,setTimeout(()=>{a=!1},n))},s)}generateId(){return`listener_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}getStats(){return{...this.stats,groups:this.groups.size,listeners:this.listeners.size}}getActiveListeners(){const t=[];for(const[e,i]of this.listeners.entries())i.active&&t.push({id:e,eventType:i.eventType,group:i.group,target:i.target.constructor.name});return t}analyzeLeaks(){const t={totalListeners:this.listeners.size,activeListeners:this.stats.active,inactiveButNotRemoved:0,byTarget:new Map,byType:new Map,potentialLeaks:[]};for(const[e,i]of this.listeners.entries()){const n=i.target.constructor.name;t.byTarget.set(n,(t.byTarget.get(n)||0)+1),t.byType.set(i.eventType,(t.byType.get(i.eventType)||0)+1),i.active||(t.inactiveButNotRemoved++,t.potentialLeaks.push({id:e,eventType:i.eventType,target:n}))}return t.byTarget=Object.fromEntries(t.byTarget),t.byType=Object.fromEntries(t.byType),t}cleanup(){let t=0;for(const[e,i]of this.listeners.entries())i.active||(this.listeners.delete(e),t++);return t}destroy(){const t=this.removeAll();return this.listeners.clear(),this.groups.clear(),this.stats={registered:0,removed:0,active:0},t}}class YM{constructor(){this.errors=[],this.maxErrors=10,this.errorCounts=new Map,this.defaults={emotion:"neutral",gesture:null,audioLevel:0,particleCount:0,glowIntensity:.7,coreSize:1,breathRate:1,color:"#B0B0B0"}}wrap(t,e,i=null){return(...n)=>{try{return t(...n)}catch(t){return this.logError(t,e),null!==i?i:this.getDefault(e)}}}logError(t,e){const i={timestamp:(new Date).toISOString(),context:e,message:t.message,stack:t.stack};this.errors.push(i);const n=this.errorCounts.get(e)||0;this.errorCounts.set(e,n+1),this.errors.length>this.maxErrors&&this.errors.shift()}getDefault(t){const e={"emotion-transition":this.defaults.emotion,"gesture-execution":this.defaults.gesture,"audio-processing":this.defaults.audioLevel,"particle-system":this.defaults.particleCount,rendering:{glowIntensity:this.defaults.glowIntensity,coreSize:this.defaults.coreSize,color:this.defaults.color},"canvas-operations":null,"state-management":this.defaults.emotion};return Object.prototype.hasOwnProperty.call(e,t)?e[t]:null}validateInput(t,e,i){try{switch(e){case"emotion":return["neutral","joy","sadness","anger","fear","surprise","disgust","love","euphoria"].includes(t)?t:i;case"undertone":return null===t||["nervous","confident","tired","intense","subdued"].includes(t)?t:null;case"gesture":return["bounce","pulse","shake","spin","nod","tilt","expand","contract","flash","drift"].includes(t)?t:i;case"number":return"number"!=typeof t||isNaN(t)?i:t;case"string":return"string"==typeof t?t:i;case"boolean":return"boolean"==typeof t?t:i;default:return null!=t?t:i}}catch(t){return this.logError(t,"input-validation"),i}}hasExceededThreshold(t,e=5){return(this.errorCounts.get(t)||0)>=e}getErrorStats(){return{totalErrors:this.errors.length,errorsByContext:Object.fromEntries(this.errorCounts),recentErrors:this.errors.slice(-5)}}clearErrors(){this.errors=[],this.errorCounts.clear()}async attemptRecovery(t,e,i=3){let n=0;for(;n<i;)try{return await e()}catch(e){if(n++,this.logError(e,`recovery-${t}-attempt-${n}`),n>=i)throw new Error(`Recovery failed for ${t} after ${i} attempts`);await new Promise(t=>setTimeout(t,100*Math.pow(2,n)))}}}const $M={quartz:{sssStrength:.8,sssAbsorption:[2.8,2.9,3],sssScatterDistance:[.2,.2,.25],sssThicknessBias:.6,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.12,frostiness:.15,innerGlowStrength:.2,fresnelIntensity:1.5,causticIntensity:1.2,emotionColorBleed:0},emerald:{sssStrength:2,sssAbsorption:[.05,4,.1],sssScatterDistance:[.1,.5,.1],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.2,innerGlowStrength:.15,fresnelIntensity:1.2,causticIntensity:1,emotionColorBleed:.35},ruby:{sssStrength:1.8,sssAbsorption:[4,.03,.08],sssScatterDistance:[.4,.04,.08],sssThicknessBias:.65,sssThicknessScale:1.9,sssCurvatureScale:2.5,sssAmbient:.08,frostiness:.12,innerGlowStrength:.12,fresnelIntensity:1.2,causticIntensity:1.15,emotionColorBleed:.35},sapphire:{sssStrength:2.2,sssAbsorption:[.15,.4,4],sssScatterDistance:[.1,.15,.5],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.18,innerGlowStrength:.15,fresnelIntensity:1.3,causticIntensity:1,emotionColorBleed:.35},amethyst:{sssStrength:2.5,sssAbsorption:[3,.05,4.5],sssScatterDistance:[.4,.05,.5],sssThicknessBias:.7,sssThicknessScale:2,sssCurvatureScale:3,sssAmbient:.08,frostiness:.18,innerGlowStrength:.12,fresnelIntensity:1.4,causticIntensity:1,emotionColorBleed:.35},topaz:{sssStrength:1.5,sssAbsorption:[3.5,2,.1],sssScatterDistance:[.3,.2,.05],sssThicknessBias:.6,sssThicknessScale:1.7,sssCurvatureScale:2.8,sssAmbient:.12,frostiness:.14,innerGlowStrength:.18,fresnelIntensity:1.4,causticIntensity:1.1,emotionColorBleed:.25},citrine:{sssStrength:1.6,sssAbsorption:[3.8,2.5,.05],sssScatterDistance:[.35,.25,.05],sssThicknessBias:.58,sssThicknessScale:1.6,sssCurvatureScale:2.6,sssAmbient:.14,frostiness:.12,innerGlowStrength:.22,fresnelIntensity:1.3,causticIntensity:1.2,emotionColorBleed:.2},diamond:{sssStrength:.5,sssAbsorption:[2.5,2.5,2.5],sssScatterDistance:[.15,.15,.15],sssThicknessBias:.55,sssThicknessScale:1.5,sssCurvatureScale:4,sssAmbient:.15,frostiness:.08,innerGlowStrength:.25,fresnelIntensity:2,causticIntensity:1.5,emotionColorBleed:0}};function ZM(t,e){if(!e||!t?.core3D?.customMaterial?.uniforms)return!1;const i=$M[e];if(!i)return!1;const n=t.core3D.customMaterial.uniforms;return n.sssStrength&&(n.sssStrength.value=i.sssStrength),n.sssAbsorption&&n.sssAbsorption.value.set(...i.sssAbsorption),n.sssScatterDistance&&n.sssScatterDistance.value.set(...i.sssScatterDistance),n.sssThicknessBias&&(n.sssThicknessBias.value=i.sssThicknessBias),n.sssThicknessScale&&(n.sssThicknessScale.value=i.sssThicknessScale),n.sssCurvatureScale&&(n.sssCurvatureScale.value=i.sssCurvatureScale),n.sssAmbient&&(n.sssAmbient.value=i.sssAmbient),n.frostiness&&(n.frostiness.value=i.frostiness),n.innerGlowStrength&&(n.innerGlowStrength.value=i.innerGlowStrength),n.fresnelIntensity&&(n.fresnelIntensity.value=i.fresnelIntensity),void 0!==i.causticIntensity&&n.causticIntensity&&(n.causticIntensity.value=i.causticIntensity),n.emotionColorBleed&&(n.emotionColorBleed.value=i.emotionColorBleed??0),!0}function JM(){return Object.keys($M)}function QM(t){return $M[t]||null}const KM=["bouncing up and down","hopping around","rocking back and forth","side to side","light on feet","spring in step","leaning forward","leaning in","leaning closer","leaning toward","reaching out","reaching toward","pointing at","pointing to","waving hello","waving goodbye","nodding head","shaking head","head shake","head nod","head bob","head tilt","deep breath","taking a breath","breathing deeply","settling down","calming down","winding down","getting bigger","getting smaller","puffing up","spinning around","twirling around","at peace","in love","on cloud nine","over the moon","on top of the world","in awe","grossed out","freaked out","low key","low-key","high key","on edge","keyed up","wound up","low energy","no energy","running low","just a bit","just a little","a little bit","kind of","sort of","a bit","a little","a lot","over the top","off the charts","through the roof","split second","one time","few times","many times","again and again","over and over","on repeat","blood moon","full moon","new moon","half moon","solar eclipse","lunar eclipse","total eclipse","ring of fire","diamond ring","killing it","crushing it","nailed it","sussy baka","side eye"],t_=/[,;|/]+/,e_=new Set(["a","an","the","is","are","am","be","being","been","i","me","my","it","its","to","of","for","with","as","this","that","these","those","just","only","also","too","please","pls","plz"]),i_=new Set(["but","and","or","yet","while","although","not","no","never","very","really","so","quite","rather","slightly","barely","extremely","completely","feeling","feel","feels","become","becoming","morph","morphing"]);function n_(t){return t.toLowerCase().trim().replace(/['']/g,"'").replace(/[""]/g,'"').replace(/\s+/g," ")}function s_(t){return["but","and","or","yet","while","although","with"].includes(t)}function a_(t){return["not","no","never","don't","dont","doesn't","doesnt","isn't","isnt"].includes(t)}const r_={nervous:{candidates:[{category:"emotion",target:"fear",priority:1},{category:"undertone",target:"nervous",priority:2}],rule:"standalone_is_emotion",examples:[{input:"nervous",resolved:{emotion:"fear"}},{input:"happy but nervous",resolved:{emotion:"joy",undertone:"nervous"}}]},anxious:{candidates:[{category:"emotion",target:"fear",priority:1},{category:"undertone",target:"nervous",priority:2}],rule:"standalone_is_emotion"},confident:{candidates:[{category:"emotion",target:"trust",priority:2},{category:"undertone",target:"confident",priority:1}],rule:"prefer_undertone",examples:[{input:"confident",resolved:{undertone:"confident"}},{input:"feeling confident",resolved:{emotion:"trust"}}]},tired:{candidates:[{category:"emotion",target:"sadness",priority:2},{category:"undertone",target:"tired",priority:1}],rule:"prefer_undertone",examples:[{input:"tired",resolved:{undertone:"tired"}},{input:"feeling tired",resolved:{emotion:"sadness",undertone:"tired"}}]},intense:{candidates:[{category:"undertone",target:"intense",priority:1},{category:"modifier",target:"intensity.very",priority:2}],rule:"prefer_undertone"},curious:{candidates:[{category:"emotion",target:"focused",priority:1},{category:"gesture",target:"lean",priority:2}],rule:"standalone_is_emotion",examples:[{input:"curious",resolved:{emotion:"focused"}},{input:"curious, leaning in",resolved:{emotion:"focused",gesture:"lean"}}]},interested:{candidates:[{category:"emotion",target:"focused",priority:1},{category:"gesture",target:"lean",priority:2}],rule:"standalone_is_emotion"},excited:{candidates:[{category:"emotion",target:"joy",priority:1},{category:"gesture",target:"bounce",priority:3}],rule:"standalone_is_emotion"},shaking:{candidates:[{category:"gesture",target:"shake",priority:1},{category:"emotion",target:"fear",priority:2}],rule:"standalone_is_gesture"},nodding:{candidates:[{category:"gesture",target:"nod",priority:1}],rule:"always_gesture"},glowing:{candidates:[{category:"gesture",target:"glow",priority:1},{category:"shape",target:"sun",priority:3}],rule:"standalone_is_gesture"},spinning:{candidates:[{category:"gesture",target:"spin",priority:1}],rule:"always_gesture"},love:{candidates:[{category:"emotion",target:"love",priority:1},{category:"shape",target:"heart",priority:2}],rule:"standalone_is_emotion",examples:[{input:"love",resolved:{emotion:"love"}},{input:"love heart",resolved:{emotion:"love",shape:"heart"}},{input:"become love",resolved:{shape:"heart"}}]},suspicious:{candidates:[{category:"emotion",target:"suspicion",priority:1},{category:"shape",target:"suspicion",priority:2}],rule:"standalone_is_emotion"},bright:{candidates:[{category:"emotion",target:"joy",priority:2},{category:"shape",target:"sun",priority:3},{category:"modifier",target:"intensity.very",priority:4}],rule:"context_dependent"},yes:{candidates:[{category:"gesture",target:"nod",priority:1}],rule:"always_gesture"},no:{candidates:[{category:"gesture",target:"shake",priority:1}],rule:"always_gesture"},agree:{candidates:[{category:"gesture",target:"nod",priority:1},{category:"emotion",target:"trust",priority:2}],rule:"standalone_is_gesture"},disagree:{candidates:[{category:"gesture",target:"shake",priority:1}],rule:"always_gesture"}},o_={emotionContext:["feeling","feel","feels","felt","emotion","emotional","emotionally","mood","moody","state","am","is","are","being","becoming","become","grew","growing"],gestureContext:["do","doing","does","did","perform","performing","action","move","moving","movement","start","starting","begin","beginning","physically","motion"],shapeContext:["morph","morphing","morphed","transform","transforming","transformed","become","becoming","turn into","shape","form","look like","change to","change into"],undertoneContext:["but","yet","while","although","with","and also","mixed with","underneath","underlying","beneath","a bit","slightly","somewhat"],modifierContext:["very","really","so","extremely","slightly","barely","completely","quickly","slowly","briefly"]};function l_(t,e,i){const n=o_[`${i}Context`];if(!n)return!1;const s=Math.max(0,e-3),a=Math.min(t.length,e+4);for(let i=s;i<a;i++)if(i!==e&&n.includes(t[i]))return!0;return!1}function h_(t,e){switch(e){case"emotion":return null!==t.emotion;case"gesture":return t.gestures&&t.gestures.length>0;case"shape":return null!==t.shape;case"undertone":return null!==t.undertone;default:return!1}}function c_(t,e,i,n){const s=r_[t];if(!s)return null;const{candidates:a,rule:r}=s;if(1===a.length)return a[0];switch(r){case"standalone_is_emotion":if(h_(n,"emotion")){const t=a.find(t=>"emotion"!==t.category);if(t)return t}return l_(e,i,"emotion"),a.find(t=>"emotion"===t.category)||a[0];case"standalone_is_gesture":if(h_(n,"gesture")){const t=a.find(t=>"gesture"!==t.category);if(t)return t}return l_(e,i,"gesture"),a.find(t=>"gesture"===t.category)||a[0];case"prefer_undertone":return l_(e,i,"emotion")?a.find(t=>"emotion"===t.category)||a[0]:a.find(t=>"undertone"===t.category)||a[0];case"always_gesture":return a.find(t=>"gesture"===t.category)||a[0];case"always_emotion":return a.find(t=>"emotion"===t.category)||a[0];case"context_dependent":for(const t of["emotion","gesture","shape","undertone"])if(l_(e,i,t)){const e=a.find(e=>e.category===t);if(e)return e}return a.sort((t,e)=>t.priority-e.priority)[0];default:return a.sort((t,e)=>t.priority-e.priority)[0]}}function u_(t){return t in r_}const d_={neutral:["neutral","default","normal","baseline","standard","nothing special","nothing particular","no strong feeling","not much","meh","whatever","indifferent","balanced","even","steady","stable","centered","level","middle ground","in between","ready","waiting","standing by","at attention","present","here","available","attentive","reset","clear","blank","empty","clean slate"],joy:["happy","joy","joyful","joyous","pleased","glad","content","satisfied","gratified","comfortable","good","cheerful","cheery","merry","jovial","jolly","upbeat","sunny","bright","lighthearted","buoyant","delighted","thrilled","overjoyed","elated","jubilant","exultant","gleeful","glowing","beaming","radiant","pumped","stoked","psyched","amped","hyped","vibing","living","slaying","winning","lit","fire","sick","dope","chuffed","pleased as punch","over the moon","made up","tickled","tickled pink","felicitous","beatific","blissful","smiling","grinning","laughing","giggling"],calm:["calm","peaceful","serene","tranquil","relaxed","at ease","comfortable","loose","unwound","decompressed","chilled","still","quiet","hushed","silent","soft","gentle","mild","placid","smooth","composed","collected","centered","grounded","untroubled","unworried","unbothered","unfazed","meditative","zen","mindful","contemplative","reflective","introspective","soothed","eased","mellowed","softened","chill","coasting","floating","drifting","laid back","easy going","low key","sorted","easy peasy"],excited:["excited","exciting","excitable","enthusiastic","eager","keen","avid","passionate","fervent","ardent","zealous","energetic","energized","animated","lively","spirited","vivacious","vibrant","dynamic","bouncy","peppy","perky","sprightly","anticipating","expectant","looking forward","itching","raring","chomping at the bit","fired up","charged","electric","electrified","buzzing","tingling","crackling","sparking","jazzed","juiced","geeked","hype","turnt","going off","well excited","buzzing","restless","fidgety","antsy","jumpy","twitchy","keyed up","wound up"],sadness:["sad","sadness","saddened","unhappy","down","low","blue","glum","bummed","disappointed","let down","discouraged","disheartened","dispirited","deflated","melancholy","melancholic","somber","gloomy","mournful","sorrowful","doleful","woeful","heavy-hearted","downcast","crestfallen","heartbroken","devastated","crushed","shattered","despairing","despondent","desolate","inconsolable","grief","grieving","mourning","bereft","empty","hollow","numb","void","wistful","longing","yearning","pining","nostalgic","bummed out","down in the dumps","in a funk","in the dumps","feeling low","gutted","choked","crying","tearful","weeping","sobbing","sighing","drooping","wilting","slumping"],anger:["angry","anger","angered","mad","annoyed","irritated","bothered","irked","peeved","miffed","vexed","displeased","put out","ticked off","ticked","frustrated","aggravated","exasperated","fed up","sick of","had enough","cross","upset","worked up","furious","enraged","livid","irate","incensed","infuriated","outraged","seething","fuming","boiling","burning","smoldering","raging","ballistic","apoplectic","berserk","seeing red","losing it","pissed","pissed off","salty","pressed","triggered","tilted","heated","steaming","narked","cheesed off","brassed off","shirty","stroppy","mardy","ropeable","filthy","spewing","clenching","tensing","grinding"],fear:["afraid","scared","fear","fearful","uneasy","unsettled","apprehensive","wary","concerned","worried","jittery","shaky","trembling","quivering","tense","tight","clenched","knotted","frightened","alarmed","startled","spooked","freaked","freaked out","creeped out","on edge","rattled","unnerved","terrified","petrified","horrified","panicked","panic","panicking","terror","dread","paranoid","distrustful","looking over shoulder","sketched","sketched out","wigged out","shook","bricking it","having kittens","in a flap","frozen","paralyzed","deer in headlights","heart racing","heart pounding","sweating"],surprise:["surprised","surprise","surprising","oh","huh","hmm","interesting","unexpected","caught off guard","astonished","amazed","astounded","startled","taken aback","struck","shocked","stunned","staggered","floored","dumbfounded","flabbergasted","gobsmacked","blown away","mind blown","speechless","wow","whoa","omg","no way","incredible","unbelievable","amazing","alarmed","dismayed","appalled","bewildered","baffled","perplexed","puzzled","confused","disoriented","thrown","shooketh","gagged","dead","wait what","blimey","crikey","bloody hell","jaw dropped","eyes wide","double take","gasp","gasping"],disgust:["disgusted","disgust","disgusting","distaste","dislike","aversion","put off","turned off","off-putting","repulsed","revolted","repelled","grossed out","creeped out","icked out","sickened","nauseated","nauseous","appalled","horrified","scandalized","offended","outraged","indignant","contempt","contemptuous","disdain","scorn","gagging","retching","cringing","wincing","recoiling","shrinking back","gross","ew","eww","yuck","yucky","ick","nasty","foul","vile","rank","minging","manky","grotty"],love:["love","loving","loved","affection","affectionate","fond","fondness","tender","tenderness","gentle","caring","care","nurturing","supportive","protective","devoted","dedicated","warm","warmth","warm-hearted","kind","kind-hearted","compassionate","sympathetic","adoring","adore","cherish","cherishing","treasure","treasuring","doting","romantic","amorous","passionate","smitten","infatuated","enamored","besotted","head over heels","falling for","connected","bonded","attached","close","intimate","deep","profound","heart eyes","crushing","swooning","melting","hugging","embracing","holding","cuddling","snuggling","nuzzling"],euphoria:["euphoric","euphoria","bliss","blissful","transcendent","otherworldly","sublime","heavenly","divine","ethereal","celestial","ecstatic","ecstasy","rapture","rapturous","exultant","exalted","elevated","peak","pinnacle","height","climax","breakthrough","revelation","epiphany","overwhelming joy","pure joy","absolute joy","complete happiness","total bliss","floating","soaring","flying","weightless","radiating","shining","on cloud nine","in heaven","on top of the world","walking on air","living my best life","ascended"],focused:["focused","focus","focusing","concentrating","concentration","concentrated","attentive","attention","attending","thinking","thought","thoughtful","pondering","considering","contemplating","reflecting","musing","mulling","engaged","absorbed","immersed","engrossed","rapt","riveted","captivated","enthralled","intent","determined","resolute","single-minded","laser focused","zeroed in","working","processing","analyzing","examining","studying","learning","figuring out","locked in","dialed in","in the zone","flow state","deep work","grinding","staring","gazing","peering","squinting","furrowed brow"],suspicion:["suspicious","suspicion","suspect","doubtful","doubt","doubting","skeptical","skepticism","questioning","uncertain","unsure","unconvinced","wary","cautious","guarded","careful","leery","circumspect","vigilant","distrustful","mistrust","mistrustful","disbelieving","incredulous","unbelieving","scrutinizing","examining","assessing","evaluating","judging","sizing up","sus","sussy","suss","side eye","giving side eye","side-eyeing","eyeing","not buying it","narrowed eyes","squinting","raised eyebrow","cocked head","tilted head","looking askance"],resting:["resting","rest","restful","tired","weary","fatigued","exhausted","drained","spent","depleted","worn out","sleepy","drowsy","dozy","groggy","yawning","nodding off","drifting off","sluggish","lethargic","listless","languid","lazy","idle","inactive","recovering","recuperating","recharging","winding down","powering down","shutting down","sleeping","asleep","slumbering","dozing","napping","snoozing","zonked","wiped","beat","dead tired","running on empty","out of gas","crashed","knackered","shattered","cream crackered"],glitch:["glitch","glitchy","glitching","malfunction","malfunctioning","broken","bugged","buggy","error","erroring","corrupted","corruption","scrambled","garbled","distorted","warped","static","noise","interference","pixelated","artifacting","tearing","haywire","fritzing","shorting out","going crazy","spazzing","unstable","erratic","unpredictable","flickering","stuttering","lagging","does not compute","syntax error","crash"]},p_={nervous:["nervous","nervously","anxious","anxiously","worried","worriedly","uneasy","uneasily","apprehensive","jittery","shaky","trembling","quivering","fidgety","restless","twitchy","tense","tensely","on edge","edgy","keyed up","wound up","uptight","self-conscious","awkward","awkwardly","hesitant","hesitantly","uncertain","uncertainly","sketchy","stressed","stressing","low-key panicking","kinda freaking out"],confident:["confident","confidently","confidence","assured","assuredly","certain","certainly","sure","surely","positive","positively","bold","boldly","brave","bravely","daring","daringly","fearless","fearlessly","strong","strongly","powerful","powerfully","firm","firmly","solid","solidly","authoritative","commanding","assertive","decisive","decisively","resolute","resolutely","poised","self-assured","unflappable","unfazed","owning it","killing it","crushing it","boss","like a boss"],tired:["tired","tiredly","tiredness","exhausted","weary","wearily","fatigued","drained","spent","depleted","sluggish","sluggishly","slow","slowly","lethargic","listless","languid","low energy","no energy","out of energy","running low","running on fumes","droopy","drooping","sagging","slumping","heavy","weighted","dragging","wiped","beat","dead","zonked","burned out","fried","cooked","toast"],intense:["intense","intensely","intensity","heightened","elevated","amplified","magnified","increased","enhanced","forceful","forcefully","powerful","powerfully","fierce","fiercely","strong","strongly","passionate","passionately","fervent","fervently","ardent","ardently","vehement","vehemently","sharp","sharply","acute","acutely","keen","keenly","piercing","piercingly","extreme","extremely","deeply","profoundly","tremendously","immensely","incredibly","super","mega","ultra","hella","mad","crazy"],subdued:["subdued","subduedly","soft","softly","gentle","gently","mild","mildly","light","lightly","restrained","held back","contained","tempered","moderated","toned down","quiet","quietly","hushed","muted","understated","subtle","subtly","modest","modestly","humble","humbly","reserved","demure","unassuming","faint","faintly","dim","dimly","pale","faded","washed out","low key","lowkey","easy","easy going"],clear:["clear","clearly","pure","purely","clean","cleanly","simple","simply","plain","plainly","direct","directly","straightforward","honest","honestly","frank","frankly","transparent","transparently","open","openly","obvious","obviously","evident","evidently","unmodified","unaltered","unchanged","normal","normally","regular","regularly","standard","basic","baseline"]},m_={breathe:["breathe","breathing","breath","inhale","inhaling","exhale","exhaling","sigh","sighing","respire","respiring","deep breath","deep breathing","slow breath","slow breathing","long breath","full breath","breathing deeply","breathing slowly","taking a breath","take a breath","catching breath","breath work","breathwork","inhale exhale","in and out","meditative breathing","calming breath","cleansing breath","relaxing breath","centering breath","mindful breathing"],expand:["expand","expanding","grow","growing","enlarge","enlarging","swell","swelling","bloat","bloating","getting bigger","growing larger","puffing up","expanding outward"],contract:["contract","contracting","shrink","shrinking","compress","compressing","reduce","reducing","getting smaller","shrinking down","pulling in","contracting inward"],pulse:["pulse","pulsing","pulsate","pulsating","throb","throbbing","beat","beating","pulsing gently","steady pulse","heartbeat","heart beat"],sway:["sway","swaying","swing","swinging","oscillate","oscillating","swaying gently","gentle sway","side to side","swaying motion"],float:["float","floating","hover","hovering","glide","gliding","levitate","levitating","weightless","weightlessness","buoyant","airy","floating gently","hovering in place","light as air","floating freely"],floatUp:["float up","floating up","floating upward","rise","rising","ascend","ascending","lift","lifting","lifted up","soar","soaring","going up"],floatDown:["float down","floating down","floating downward","descend","descending","sink","sinking","lower","lowering","going down"],floatLeft:["float left","floating left","drift left","drifting left"],floatRight:["float right","floating right","drift right","drifting right"],bob:["bob","bobbing","bobbing up and down","gentle bob"],lean:["lean","leaning","incline","inclining","leaning in","lean in","leaning forward","lean forward","leaning toward","lean toward","leaning closer","lean closer","moving closer","coming closer","drawing near","approaching","interested","intrigued","engaged","attentive","listening closely","paying attention"],leanLeft:["lean left","leaning left","tilt left","tilting left"],leanRight:["lean right","leaning right","tilt right","tilting right"],jitter:["jitter","jittering","jittery","stutter","stuttering","jittering around","slight jitter","nervous jitter"],twitch:["twitch","twitching","twitchy","spasm","spasming","flinch","flinching","quick twitch","nervous twitch","sudden movement"],vibrate:["vibrate","vibrating","vibration","buzz","buzzing","hum","humming","quiver","quivering","vibrating slightly","gentle buzz","low hum","subtle vibration"],shake:["shake","shaking","shaky","shudder","shuddering","tremble","trembling","quake","quaking","no","nope","nah","disagree","disagreeing","refuse","refusing","deny","denying","shaking head","shake head","head shake","saying no","shaking no"],wiggle:["wiggle","wiggling","wiggly","jiggle","jiggling","jiggly","squirm","squirming","wriggle","wriggling","wiggling around","little wiggle","happy wiggle","excited wiggle"],stepLeft:["step left","stepping left","sidestep left","move left","moving left","shift left"],stepRight:["step right","stepping right","sidestep right","move right","moving right","shift right"],stepUp:["step up","stepping up","step forward"],stepDown:["step down","stepping down","step back"],slideLeft:["slide left","sliding left","glide left"],slideRight:["slide right","sliding right","glide right"],runningman:["running man","runningman","running man dance","run in place","running in place"],charleston:["charleston","charleston dance","swing dance","kick step","kick and step"],hula:["hula","hula-ing","hip sway","swaying hips","circular sway","round motion","hula motion","hula dance"],twist:["twist","twisting","twisty","contort","contorting","do the twist","twisting dance","twisting around","getting twisted"],pop:["pop","popping","pop and lock","popping motion","hit","hitting"],flare:["flare","flaring","dramatic flare","flourish"],swell:["swell","swelling","surge","surging","crescendo"],swagger:["swagger","swaggering","strut","strutting","confident walk","cocky"],dip:["dip","dipping","drop","dropping down","low dip","dance dip"],bounce:["bounce","bouncing","bouncy","hop","hopping","hoppy","spring","springing","springy","boing","boinging","bouncing up and down","hopping around","spring in step","light on feet"],orbit:["orbit","orbiting","circle","circling","revolve","revolving","circling around","going around","rotating slowly","orbital motion"],orbitLeft:["orbit left","orbiting left","circle left","counter-clockwise","counterclockwise"],orbitRight:["orbit right","orbiting right","circle right","clockwise"],orbitUp:["orbit up","orbiting up","rising orbit","spiral up","spiraling up"],orbitDown:["orbit down","orbiting down","descending orbit","spiral down","spiraling down"],sparkle:["sparkle","sparkling","sparkly","twinkle","twinkling","twinkly","glitter","glittering","glittery","shine","shining","shiny","celebrate","celebrating","celebration","celebratory","festive","party","partying","victory","triumphant","triumph","winning","success","successful","achievement","accomplished","nailed it","slay","slaying","killing it","yasss","yay","woo","woohoo"],shimmer:["shimmer","shimmering","shimmery","glisten","glistening","gleam","gleaming","lustrous","luminous","soft shimmer","gentle gleam","shimmering light","pearlescent"],groove:["groove","grooving","groovy","dance","dancing","boogie","boogying","funk","funky","rhythmic","moving to music","feeling the music","in the groove","getting down","busting a move","doing a little dance"],jump:["jump","jumping","jumpy","leap","leaping","bound","bounding","jumping up","leap up","spring up","jumping for joy"],jumpDown:["jump down","jumping down","drop down"],jumpLeft:["jump left","jumping left","leap left"],jumpRight:["jump right","jumping right","leap right"],lunge:["lunge","lunging","thrust","thrusting","charge forward","aggressive step"],lungeForward:["lunge forward","lunging forward","thrust forward"],lungeBack:["lunge back","lunging back","retreat lunge"],rushForward:["rush forward","rushing forward","dash forward","sprint","sprinting","charge","charging"],rushBack:["rush back","rushing back","dash back","retreat quickly"],spin:["spin","spinning","twirl","twirling","whirl","whirling","rotate","rotating","turn","turning","spinning around","quick spin","full rotation","twirling around"],spinLeft:["spin left","spinning left","turn left","rotate left","counter-clockwise spin"],spinRight:["spin right","spinning right","turn right","rotate right","clockwise spin"],flip:["flip","flipping","somersault","somersaulting","front flip","frontflip"],backflip:["backflip","back flip","backflipping","back somersault","flip backward"],point:["point","pointing","indicate","indicating","gesture","gesturing","direct","directing","pointing at","pointing to","pointing toward","gesturing toward","showing","directing attention"],pointUp:["point up","pointing up","pointing upward","look up","look to the sky"],pointDown:["point down","pointing down","pointing downward","look down","look at this"],pointLeft:["point left","pointing left","gesture left"],pointRight:["point right","pointing right","gesture right"],kickLeft:["kick left","kicking left","left kick"],kickRight:["kick right","kicking right","right kick"],bow:["bow","bowing","curtsy","curtseying","reverence","showing respect","take a bow","bow down"],nod:["nod","nodding","yes","yeah","yep","yup","agree","agreeing","acknowledge","acknowledging","confirm","confirming","accept","accepting","approve","approving","understand","understanding","got it","gotcha","i see","makes sense","understood","nodding head","nod head","head nod","nodding along","nodding yes"],reach:["reach","reaching","extend","extending","reaching out","reach out","reaching toward","reach toward","extending toward","offer","offering","present","presenting","give","giving","help","helping"],headBob:["headbob","head bob","headbobbing","head bobbing","nodding to beat","nodding to music","bobbing along","bobbing to rhythm","vibing","jamming","bobbing head","bob head","feeling the beat","moving to music"],wave:["wave","waving","greet","greeting","hello","hi","hey","goodbye","bye","farewell","welcome","welcoming","waving hello","waving goodbye","friendly wave","waving hand"],crouch:["crouch","crouching","squat","squatting","hunker","hunkering","duck","ducking","get low","getting low"],tilt:["tilt","tilting","tilted","angle","angling","angled","cock","cocking","cocked","tilting head","tilt head","cocking head","curious tilt","angling sideways","head tilt"],tiltUp:["tilt up","tilting up","look up","looking up"],tiltDown:["tilt down","tilting down","look down","looking down"],tiltLeft:["tilt left","tilting left","head tilt left"],tiltRight:["tilt right","tilting right","head tilt right"],recoil:["recoil","recoiling","flinch","flinching","wince","wincing","pull back","pulling back","jerk back","snap back"],knockdown:["knockdown","knock down","knocked down","fall","falling","fell","topple","toppling","take a hit","got hit"],knockout:["knockout","knock out","knocked out","KO","ko'd","lights out","out cold"],squash:["squash","squashing","squashed","flatten","flattening","flattened","compress","compressed","smoosh","smooshed"],stretch:["stretch","stretching","stretchy","elongate","elongating","lengthen","lengthening","stretching out","big stretch","reaching up","stretching tall"],inflate:["inflate","inflating","inflated","puff up","puffing up","puffed up","balloon","ballooning"],deflate:["deflate","deflating","deflated","let air out","losing air","shrivel","shriveling"],pancake:["pancake","pancaked","pancaking","flatten completely","totally flat","squished flat","smooshed flat"],rage:["rage","raging","furious","fury","angry","anger","mad","livid","enraged","seeing red","lose temper","losing it"],fury:["fury","furious","quick anger","flash of anger","snap","snapping"],battlecry:["battlecry","battle cry","war cry","roar","yell","yelling","scream","screaming","rallying cry"],charge:["charge","charging","rush","rushing","attack","attacking","assault","advance"],wobble:["wobble","wobbling","wobbly","unstable","unsteady","drunk","dizzy","off balance","losing balance"],teeter:["teeter","teetering","totter","tottering","about to fall","precarious","on edge","unbalanced"],rock:["rock","rocking","soothing rock","gentle rocking","back and forth","rocking motion"],pendulum:["pendulum","pendulum motion","swing back and forth","swinging","hypnotic swing","metronome"],shatter:["shatter","shattering","shattered","break","breaking","broken","smash","smashing","smashed","fragment","fragmenting","explode into pieces","break apart"],shatterExplosive:["explosive shatter","explode","exploding","blow up","blowing up","detonate","detonating","big explosion","kaboom"],shatterCrumble:["crumble","crumbling","fall apart","falling apart","disintegrate","disintegrating","collapse","collapsing"],dissolveUp:["dissolve up","dissolving up","evaporate","evaporating","fade up","rising dust"],dissolveDown:["dissolve down","dissolving down","melt","melting","drip away","dripping"],dissolveAway:["dissolve away","dissolving away","blow away","scatter in wind","dust in wind","fade to dust"],morph:["morph","morphing","transform","transforming","shape shift","shapeshifting","change form","metamorphose"],rain:["rain","raining","shower","showering","drip","dripping","pour","pouring","raining down","particles falling","gentle rain","shower of particles"],drift:["drift","drifting","waft","wafting","float gently","gentle drift"],driftUp:["drift up","drifting up","rising mist","float upward","waft up"],driftDown:["drift down","drifting down","settling dust","float downward","waft down"],vortex:["vortex","whirlpool","tornado","cyclone","maelstrom","spinning vortex","swirling"],cascadeDown:["cascade","cascading","cascade down","waterfall","falling water","pour down","flow down"],confetti:["confetti","throw confetti","celebration particles","party confetti","ticker tape","streamers"],fizz:["fizz","fizzing","fizzy","bubble","bubbling","bubbly","effervescent","carbonated","sparkling bubbles"],burst:["burst","bursting","erupt","erupting","eruption","boom","booming","bursting out","burst of energy","explosive burst","big burst"],burstUp:["burst up","bursting up","fountain","geyser","erupting up"],ripple:["ripple","rippling","wave effect","ripple effect","water ripple","spreading rings"],flash:["flash","flashing","flashy","blink","blinking","strobe","strobing","quick flash","bright flash","flashing light","strobing light"],glow:["glow","glowing","glowy","radiate","radiating","emanate","emanating","luminescent","bright","brighten","brightening","soft glow","warm glow","inner glow","glowing warmly","lighting up","lit up"],bloom:["bloom","blooming","blossom","blossoming","flower","flowering","unfold","unfolding","light bloom","lens bloom"],flicker:["flicker","flickering","flickery","flutter","fluttering","waver","wavering","guttering","flickering light","unsteady light","wavering glow","candle-like"],shiver:["shiver","shivering","chill","chilly","cold","freezing","brr","brrr"],heartbeat:["heartbeat","heart beat","pulse of life","living pulse","thump thump","ba-dum"],snap:["snap","snapping","click","clicking","quick snap","finger snap"],elasticBounce:["elastic bounce","rubbery bounce","springy","bouncy elastic","rubber band","spring back"],hold:["hold","holding","pause","pausing","paused","freeze","freezing","frozen","still","stillness","stop","stopping","stopped","holding still","staying still","frozen in place","completely still","motionless","stationary"],fade:["fade","fading","dim","dimming","disappear","disappearing","vanish","vanishing","fading out","fading away","growing dim","becoming transparent"],settle:["settle","settling","settled","calm","calming","ground","grounding","grounded","center","centering","centered","anchor","anchoring","anchored","root","rooting","rooted","relax","relaxing","unwind","unwinding","decompress","decompressing","settling down","calming down","winding down","cooling down","coming to rest","finding peace"],peek:["peek","peeking","peer","peering","peep","peeping","glance","glancing","peeking out","peek out","looking shyly","shy glance","quick peek","sneaking a look"]},g_={circle:["circle","circular","round","rounded","orb","ball","sphere","spherical","ring","disc","disk","whole","complete","unity","unified","endless","infinite","continuous","full circle","perfect round","come full circle"],sphere:["sphere","spherical","globe","globular","ball","3d circle","three dimensional","round ball","floating sphere"],square:["square","squared","boxy","box","rectangle","rectangular","quadrilateral","cube","cubic","block","blocky","stable","solid","grounded","sturdy","rigid","firm","structured","four sided","four corners","box shape"],triangle:["triangle","triangular","tri","pyramid","pyramidal","delta","wedge","arrow","arrowhead","pointed","sharp","dynamic","directional","ascending","three sided","three pointed","pointing up"],heart:["heart","hearted","hearts","love","loving","lovely","valentine","romantic","affection","affectionate","caring","care","tender","warmth","warm-hearted","heartfelt","compassion","compassionate","devotion","devoted","luv","wuv","<3","","","","full of love","with love","heart shape","heart shaped","from the heart"],suspicion:["suspicion","suspicious","suspect","sly","slyly","sneaky","sneakily","mischievous","mischief","smirk","smirking","smirky","grin","grinning","sly grin","side eye","sideeye","side-eye","skeptical","skepticism","doubtful","doubt","doubting","wary","distrustful","distrust","sus","sussy","sussy baka","hmm","hmmm","hmmmm","shady","fishy","sketchy","not buying it","something fishy","seems off","up to something"],star:["star","starred","starry","stars","stellar","astral","twinkle","twinkling","achievement","achieved","excellence","excellent","gold star","five star","superstar","rockstar","rock star","wonder","wonderful","wondrous","magical","magic","miraculous","amazing","spectacular","reach for stars","seeing stars","star shape","shining star"],sun:["sun","sunny","sunshine","sunlight","solar","sol","daylight","daytime","day","radiant","radiance","radiating","bright","brightness","brilliant","glowing","glow","blazing","blaze","warm","warmth","cheerful","cheery","optimistic","optimism","hopeful","hope","positive","positivity","full of light","ray of sunshine","like the sun","sunny disposition"],moon:["moon","moony","moonlight","moonlit","lunar","crescent","nighttime","night","nocturnal","waxing","waning","gibbous","new moon","full moon","half moon","quarter moon","crescent moon","dreamy","dreamlike","dream","mysterious","mystery","mystical","ethereal","otherworldly","serene","serenity","tranquil","contemplative","reflective","moonlit night","by moonlight","moon shape","under the moon"],lunar:["lunar eclipse","blood moon","blood-moon","red moon","copper moon","rust moon","eclipsing","eclipsed","shadow crossing","earth shadow","ominous","foreboding","portentous","dramatic","intense","transforming","transformation","moon in shadow","moon turning red","eclipse phase","lunar event"],solar:["solar eclipse","total eclipse","corona","diamond ring","totality","umbra","penumbra","ring of fire","dark sun","blocked sun","occluded","awe","awesome","awe-inspiring","rare","momentous","historic","breathtaking","magnificent","sun blocked","sun covered","total darkness","corona visible"],eclipse:["eclipse","eclipsing","eclipsed","celestial event","astronomical event","overshadow","overshadowed","blocked","blocking","obscured","hidden","hiding","concealed","passing","crossing","alignment","in eclipse","going dark","being eclipsed","eclipsed by"]},f_={intensity:{barely:["barely","hardly","scarcely","faintly","slightly","marginally","just a bit","just a little","just barely","hint of","touch of","trace of"],slightly:["slightly","somewhat","a little","a bit","mildly","lightly","kind of","kinda","sort of","sorta","a tad","a touch","a smidge"],moderately:["moderately","reasonably","fairly","pretty","rather","quite"],normal:["normal","normally","regular","regularly","standard","typical","typically","average","ordinary"],notably:["notably","noticeably","clearly","definitely","certainly","decidedly","genuinely","truly","really"],very:["very","really","so","such","quite","highly","deeply","seriously","majorly","hella","super","extra","mad"],extremely:["extremely","incredibly","immensely","tremendously","enormously","hugely","intensely","fiercely","wildly","insanely","crazy","ridiculously","mega","ultra","hyper"],absolutely:["absolutely","completely","totally","utterly","entirely","wholly","fully","maximum","max","over the top","off the charts","through the roof","to the max"]},duration:{flash:["flash","instant","instantaneous","split second","split-second","momentary","fleeting","brief flash"],quick:["quick","quickly","fast","rapid","swift","swiftly","brief","briefly","short","shortly","snap"],normal:["normal","regular","standard","typical","usual"],slow:["slow","slowly","gradual","gradually","gentle","gently","easy","easily","leisurely","unhurried"],long:["long","prolonged","extended","sustained","lasting","lingering","drawn out","drawn-out"],persistent:["persistent","constant","continuous","ongoing","steady","maintained","held","holding","stay","staying","keep","keeping","remain","remaining"]},transition:{instant:["instant","instantly","immediate","immediately","sudden","suddenly","abrupt","abruptly","snap","cut","jump"],snappy:["snappy","crisp","sharp","sharply","brisk","briskly","punchy"],smooth:["smooth","smoothly","natural","naturally","fluid","fluidly","flowing"],gentle:["gentle","gently","soft","softly","gradual","gradually","easing","gliding","drifting"],dreamy:["dreamy","dreamlike","floaty","ethereal","languid","lazy","flowing","melting"]},repetition:{once:["once","one time","single","just once","only once","one shot"],few:["few","few times","couple","couple times","twice","two times","thrice","three times"],several:["several","several times","multiple","multiple times","repeatedly","again and again"],many:["many","many times","lots","lots of times","over and over","nonstop"],loop:["loop","looping","looped","continuous","continuously","forever","infinitely","endlessly","always","keep going","on repeat"]}},y_={barely:{min:.1,max:.2,default:.15},slightly:{min:.2,max:.4,default:.3},moderately:{min:.4,max:.5,default:.45},normal:{min:.5,max:.6,default:.55},notably:{min:.6,max:.7,default:.65},very:{min:.7,max:.85,default:.8},extremely:{min:.85,max:.95,default:.9},absolutely:{min:.95,max:1,default:1}},v_={flash:{min:100,max:500,default:250},quick:{min:500,max:1e3,default:750},normal:{min:1e3,max:2e3,default:1500},slow:{min:2e3,max:4e3,default:3e3},long:{min:4e3,max:8e3,default:6e3},persistent:{min:8e3,max:1/0,default:1e4}};function b_(t){const e=new Map;for(const[i,n]of Object.entries(t)){for(const t of n){const n=t.toLowerCase().trim();e.set(n,i)}e.set(i.toLowerCase(),i)}return e}class M_{constructor(){this.emotionLookup=b_(d_),this.undertoneLookup=b_(p_),this.gestureLookup=b_(m_),this.shapeLookup=b_(g_),this.modifierLookup=function(t){const e=new Map;for(const[i,n]of Object.entries(t))for(const[t,s]of Object.entries(n))for(const n of s){const s=n.toLowerCase().trim();e.set(s,{type:i,level:t})}return e}(f_)}parse(t){const e={emotion:null,undertone:"clear",gestures:[],shape:null,intensity:y_.normal.default,duration:v_.normal.default,transition:"smooth",repetition:"once",unrecognized:[],raw:t};if(!t||"string"!=typeof t)return e;const{tokens:i}=function(t){if(!t||"string"!=typeof t)return{tokens:[],segments:[],phrases:new Map};const e=n_(t),{processed:i,phrases:n}=function(t){const e=new Map;let i=t,n=0;for(const t of KM){const s=n_(t);if(i.includes(s)){const t=`__PHRASE_${n}__`;i=i.replace(new RegExp(s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"g"),t),e.set(t,s),n++}}return{processed:i,phrases:e}}(e),s=i.split(t_).map(t=>t.trim()).filter(t=>t.length>0),a=[],r=[];for(const t of s){let e=t;for(const[t,i]of n)e=e.replace(t,i);r.push(e.trim());const i=t.split(/\s+/);for(const t of i){if(n.has(t)){a.push(n.get(t));continue}if(!t)continue;if(e_.has(t)&&!i_.has(t))continue;const e=t.replace(/^[^\w]+|[^\w]+$/g,"");e&&a.push(e)}}return{tokens:a,segments:r,phrases:n}}(t);if(0===i.length)return e;let n=!1;for(let t=0;t<i.length;t++){const s=i[t];if(!s_(s))if(a_(s))n=!0;else if(n)n=!1;else{if(u_(s)){const n=c_(s,i,t,e);if(n){this._applyResolution(e,n);continue}}this._tryEmotion(s,e)||this._tryGesture(s,e)||this._tryShape(s,e)||this._tryUndertone(s,e)||this._tryModifier(s,e)||e.unrecognized.push(s)}}return e}_applyResolution(t,e){const{category:i,target:n}=e;switch(i){case"emotion":t.emotion||(t.emotion=n);break;case"undertone":"clear"===t.undertone&&(t.undertone=n);break;case"gesture":t.gestures.includes(n)||t.gestures.push(n);break;case"shape":t.shape||(t.shape=n)}}_tryEmotion(t,e){const i=this.emotionLookup.get(t);return!(!i||e.emotion||(e.emotion=i,0))}_tryGesture(t,e){const i=this.gestureLookup.get(t);return!(!i||e.gestures.includes(i)||(e.gestures.push(i),0))}_tryShape(t,e){const i=this.shapeLookup.get(t);return!(!i||e.shape||(e.shape=i,0))}_tryUndertone(t,e){const i=this.undertoneLookup.get(t);return!(!i||"clear"!==e.undertone||(e.undertone=i,0))}_tryModifier(t,e){const i=this.modifierLookup.get(t);if(i){const{type:t,level:n}=i;switch(t){case"intensity":e.intensity=y_[n]?.default||e.intensity;break;case"duration":e.duration=v_[n]?.default||e.duration;break;case"transition":e.transition=n;break;case"repetition":e.repetition=n}return!0}return!1}validate(t){const e=[];return t.emotion||0!==t.gestures.length||t.shape||e.push("No actionable intent found (need emotion, gesture, or shape)"),(t.intensity<0||t.intensity>1)&&e.push(`Intensity ${t.intensity} out of range [0, 1]`),t.duration<=0&&e.push(`Duration ${t.duration} must be positive`),{valid:0===e.length,errors:e}}static getAvailableEmotions(){return Object.keys(d_)}static getAvailableUndertones(){return Object.keys(p_)}static getAvailableGestures(){return Object.keys(m_)}static getAvailableShapes(){return Object.keys(g_)}}class __{constructor(){this.minBPM=60,this.maxBPM=180,this.lastPeakTime=0,this.peakCount=0,this.intervals=[],this.maxIntervals=40,this.bpmVotes=new Map,this.currentBPM=0,this.lockedBPM=0,this.confidence=0,this.isActive=!1,this.lockStage=0,this.stage1LockTime=0,this.stage2CorrectionApplied=!1,this.correctionType="none",this._recentSubdivisionChecks=[],this._stage3StartTime=0,this._stage3StableTime=0,this._memoryCleanedUp=!1,this._microTuneBPM=0,this.grooveConfidence=.15,this._grooveConfidenceTarget=.15,this._lastLogTime=0,this._logIntervalMs=2e3,this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0,this._logBuffer=[],this._maxLogEntries=20}processPeak(t,e=performance.now()){if(this.isActive=!0,this.peakCount++,t<.1)this._skippedPeaks++;else{if(this.lastPeakTime>0){const t=e-this.lastPeakTime;t>=250&&t<=2e3?(this.intervals.push(t),this._recentIntervals.push(Math.round(t)),this.intervals.length>this.maxIntervals&&this.intervals.shift(),this.voteForInterval(t)):this._skippedIntervals++}this.lastPeakTime=e,this.updateBPM(),this._debugLog(e)}}voteForInterval(t){const e=6e4/t;this._recentRawBPMs.push(Math.round(e));let i=e;const n=.95*this.minBPM,s=1.05*this.maxBPM;if(i<n)for(;i<this.minBPM;)i*=2;else if(i>s)for(;i>this.maxBPM;)i/=2;i=Math.max(this.minBPM,Math.min(this.maxBPM,i)),this._recentNormalizedBPMs.push(Math.round(i));const a=Math.round(i);for(let t=-2;t<=2;t++){const e=a+t;if(e>=this.minBPM&&e<=this.maxBPM){const i=Math.exp(-t*t/2),n=this.bpmVotes.get(e)||0;this.bpmVotes.set(e,n+i)}}for(const[t,e]of this.bpmVotes){const i=.95*e;i<.3?this.bpmVotes.delete(t):this.bpmVotes.set(t,i)}}updateBPM(){if(0===this.bpmVotes.size||this.intervals.length<3)return;const t=performance.now();let e=0,i=0,n=0;for(const[t,s]of this.bpmVotes)n+=s,s>i&&(i=s,e=t);if(0===e)return;let s=0;for(let t=-2;t<=2;t++){const i=e+t;s+=this.bpmVotes.get(i)||0}const a=s,r=Math.round(e/2);let o=0;if(r>=this.minBPM)for(let t=-2;t<=2;t++)o+=this.bpmVotes.get(r+t)||0;const l=2*e;let h=0;if(l<=this.maxBPM)for(let t=-2;t<=2;t++)h+=this.bpmVotes.get(l+t)||0;let c=0,u=0;const d=a>0?o/a:0;if(this.intervals.length>=6){const t=this.intervals.slice(-8),e=t.reduce((t,e)=>t+e,0)/t.length;let i=0;for(let n=0;n<t.length-1;n++)t[n]>e!=t[n+1]>e&&i++;c=i/(t.length-1);const n=[];for(let e=0;e<t.length-1;e+=2)n.push(t[e]+t[e+1]);if(n.length>=2){const t=n.reduce((t,e)=>t+e,0)/n.length;u=n.reduce((e,i)=>e+Math.abs(i-t),0)/n.length/t}}this.confidence=n>0?a/n:0;let p=0;if(this.intervals.length>=4){const t=6e4/e,i=t/2,n=this.intervals.slice(-8);let s=0;for(const e of n){const n=Math.abs(e-t)/t<.15,a=Math.abs(e-i)/i<.15,r=Math.abs(e-2*t)/(2*t)<.15;(n||a||r)&&s++}p=s/n.length}if(0===this.currentBPM)this.currentBPM=e;else{const t=this.intervals.length<6?.5:.3;this.currentBPM=this.currentBPM*(1-t)+e*t}if(0===this.lockStage){this._lastLockCheck={intervalCount:this.intervals.length,bestVotes:i.toFixed(1),clusterVotes:a.toFixed(1),confidence:`${(100*this.confidence).toFixed(0)}%`,consistency:`${(100*p).toFixed(0)}%`,bestBPM:e,adjustedBPM:e,isSubdivision:!1,stage:0,failReasons:[]};const n=e>120?12:8,s=.2,r=.45;this.intervals.length<n&&this._lastLockCheck.failReasons.push(`intervals<${n}`),a<=5&&this._lastLockCheck.failReasons.push("votes<=5"),this.confidence<=s&&this._lastLockCheck.failReasons.push(`conf<=${(100*s).toFixed(0)}%`),p<=r&&this._lastLockCheck.failReasons.push(`consistency<=${(100*r).toFixed(0)}%`),this.intervals.length>=n&&a>5&&this.confidence>s&&p>r&&(this.lockedBPM=Math.round(this.currentBPM),this.lockStage=1,this.stage1LockTime=t)}if(1===this.lockStage||2===this.lockStage){this._recentSubdivisionChecks.push({alternatingScore:c,pairVariance:u,halfVoteRatio:d,time:t}),this._recentSubdivisionChecks.length>15&&this._recentSubdivisionChecks.shift();const i=this._recentSubdivisionChecks.filter(t=>t.alternatingScore>.7&&t.pairVariance<.1).length,n=this._recentSubdivisionChecks.reduce((t,e)=>t+e.alternatingScore,0)/this._recentSubdivisionChecks.length,s=this._recentSubdivisionChecks.reduce((t,e)=>t+e.pairVariance,0)/this._recentSubdivisionChecks.length,o=this._recentSubdivisionChecks.reduce((t,e)=>t+e.halfVoteRatio,0)/this._recentSubdivisionChecks.length,p=this.intervals.length>0?this.intervals.reduce((t,e)=>t+e,0)/this.intervals.length:0,m=a>0?h/a:0;let g=0,f=0;if(this.intervals.length>=8){const t=this.intervals.slice(-12),e=[...t].sort((t,e)=>t-e),i=e[Math.floor(e.length/2)],n=t.filter(t=>Math.abs(t-i)/i<.5);if(f=n.length,n.length>=6){const t=n.reduce((t,e)=>t+e,0)/n.length;g=n.reduce((e,i)=>e+Math.abs(i-t),0)/n.length/t}}if(this._lastLockCheck={intervalCount:this.intervals.length,bestBPM:e,adjustedBPM:this.lockedBPM,halfBPM:r,stage:this.lockStage,subdivisionChecks:this._recentSubdivisionChecks.length,positiveChecks:i,avgAltScore:`${(100*n).toFixed(0)}%`,avgPairVar:`${(100*s).toFixed(1)}%`,avgHalfRatio:`${(100*o).toFixed(0)}%`,intervalVariance:`${(100*g).toFixed(1)}%`,filteredCount:f,correctionApplied:this.stage2CorrectionApplied,failReasons:[]},!this.stage2CorrectionApplied&&this._recentSubdivisionChecks.length>=10&&r>=this.minBPM){const t=i>=7&&n>.7&&s<.1&&this.lockedBPM>100,e=o>.4&&this.lockedBPM>150&&r>=65&&r<=85;let a=0,l=0;if(this.intervals.length>=8){const t=this.intervals.slice(-12),e=[...t].sort((t,e)=>t-e),i=e[Math.floor(e.length/2)],n=t.filter(t=>Math.abs(t-i)/i<.5);if(l=n.length,n.length>=6){const t=n.reduce((t,e)=>t+e,0)/n.length;a=n.reduce((e,i)=>e+Math.abs(i-t),0)/n.length/t}}const h=this.lockedBPM>140&&r>=65&&r<=85&&l>=8&&a<.05;(t||e||h)&&(this.lockedBPM=Math.round(this.lockedBPM/2),this.lockStage=2,this.stage2CorrectionApplied=!0,this.correctionType="halved")}!this.stage2CorrectionApplied&&this._recentSubdivisionChecks.length>=10&&l<=this.maxBPM&&p>900&&m>.5&&this.lockedBPM<75&&(this.lockedBPM=Math.round(2*this.lockedBPM),this.lockStage=2,this.stage2CorrectionApplied=!0,this.correctionType="doubled");const y=t-this.stage1LockTime;1===this.lockStage&&this._recentSubdivisionChecks.length>=6&&(this.lockStage=2);const v=this._recentSubdivisionChecks.length>=12&&i<3,b=y>1e4;2===this.lockStage&&(this.stage2CorrectionApplied||v||b)&&(this.lockStage=3,this._stage3StartTime=t)}if(3===this.lockStage){const e=t-this._stage3StartTime,i=this.intervals.slice(-8);if(i.length>=4){const t=6e4/(i.reduce((t,e)=>t+e,0)/i.length);if(Math.abs(t-this.lockedBPM)/this.lockedBPM<.05){0===this._microTuneBPM&&(this._microTuneBPM=this.lockedBPM),this._microTuneBPM=.9*this._microTuneBPM+.1*t;const e=Math.round(this._microTuneBPM);e!==this.lockedBPM&&(this.lockedBPM=e),this._stage3StableTime+=100}else this._stage3StableTime=0}const n=(e>5e3||this._stage3StableTime>3e3)&&!this._memoryCleanedUp;n&&3===this.lockStage&&(this._performMemoryCleanup(),this._memoryCleanedUp=!0),this._lastLockCheck={stage:3,lockedBPM:this.lockedBPM,correctionType:this.correctionType,timeSinceStage3:`${(e/1e3).toFixed(1)}s`,stableTime:`${(this._stage3StableTime/1e3).toFixed(1)}s`,finalized:n,failReasons:[]}}this._updateGrooveConfidence()}_updateGrooveConfidence(){this._memoryCleanedUp?this._grooveConfidenceTarget=1:this._grooveConfidenceTarget=[.15,.4,.65,.85][this.lockStage]||.15;const t=this.grooveConfidence+.08*(this._grooveConfidenceTarget-this.grooveConfidence);t>this.grooveConfidence&&(this.grooveConfidence=t)}_performMemoryCleanup(){this.intervals.length>8&&(this.intervals=this.intervals.slice(-8)),this.bpmVotes.clear(),this._subdivisionHistory=[],this._recentSubdivisionChecks=[],this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[]}processFrame(t,e=performance.now()){}reset(){this.intervals=[],this.bpmVotes.clear(),this.lastPeakTime=0,this.peakCount=0,this.currentBPM=0,this.lockedBPM=0,this.confidence=0,this.isActive=!1,this.lockStage=0,this.stage1LockTime=0,this.stage2CorrectionApplied=!1,this.correctionType="none",this._recentSubdivisionChecks=[],this._stage3StartTime=0,this._stage3StableTime=0,this._memoryCleanedUp=!1,this._microTuneBPM=0,this.grooveConfidence=.15,this._grooveConfidenceTarget=.15,this._lastLogTime=0,this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0,this._logBuffer=[],this._lastLockCheck=null,this._subdivisionHistory=[]}getBPM(){return this.lockedBPM>0?this.lockedBPM:Math.round(this.currentBPM)||0}getSubdivision(){return 1}getStatus(){return{bpm:this.getBPM(),subdivision:1,confidence:this.confidence,locked:this.lockedBPM>0,lockStage:this.lockStage,correctionType:this.correctionType,finalized:this._memoryCleanedUp,grooveConfidence:this.grooveConfidence,agentCount:this.bpmVotes.size,peakCount:this.peakCount,histogramSize:this.bpmVotes.size,topAgents:this.getTopCandidates(5),intervalCount:this.intervals.length}}getTopCandidates(t=5){return[...this.bpmVotes.entries()].sort((t,e)=>e[1]-t[1]).slice(0,t).map(([t,e])=>({bpm:t,score:e.toFixed(1),interval:Math.round(6e4/t)}))}getTopIntervals(t=5){return this.getTopCandidates(t).map(t=>({interval:t.interval,bpm:t.bpm,weight:t.score}))}_debugLog(t){if(t-this._lastLogTime<this._logIntervalMs)return;if(this._lastLogTime=t,0===this._recentIntervals.length&&0===this._skippedPeaks)return;const e=[],i=["Detecting","Initial Lock","Refinement","Final Lock"][this.lockStage]||"Unknown";e.push(""),e.push(`Status: Stage ${this.lockStage} (${i}) | Current: ${Math.round(this.currentBPM)} BPM | Locked: ${this.lockedBPM||"-"}`),e.push(`Peaks: ${this.peakCount} total | ${this._skippedPeaks} skipped (weak) | ${this._skippedIntervals} intervals out-of-range`),this._recentIntervals.length>0&&e.push(`Recent intervals (ms): [${this._recentIntervals.join(", ")}]`),this._recentRawBPMs.length>0&&e.push(`Raw BPMs (before normalize): [${this._recentRawBPMs.join(", ")}]`),this._recentNormalizedBPMs.length>0&&e.push(`Normalized BPMs (60-180): [${this._recentNormalizedBPMs.join(", ")}]`);const n=this.getTopCandidates(5);if(n.length>0){const t=n.map(t=>`${t.bpm}(${t.score})`).join(", ");e.push(`Top candidates: ${t}`)}if(this._lastLockCheck){const t=this._lastLockCheck;0===t.stage?t.failReasons&&t.failReasons.length>0?e.push(`Stage 0: NOT locking - ${t.failReasons.join(", ")}`):e.push(`Stage 0: Ready to lock at ${t.bestBPM} BPM`):1===t.stage||2===t.stage?(e.push(`Stage ${t.stage}: Locked=${t.adjustedBPM} BPM | checks=${t.subdivisionChecks} positive=${t.positiveChecks}`),e.push(`  altScore=${t.avgAltScore} pairVar=${t.avgPairVar} halfRatio=${t.avgHalfRatio}`),t.correctionApplied&&e.push(`  Correction applied: ${this.correctionType}`)):3===t.stage&&(e.push(`Stage 3: Final=${t.lockedBPM} BPM | correction=${t.correctionType} | time=${t.timeSinceStage3} stable=${t.stableTime}`),t.finalized&&e.push("  FINALIZED - memory cleaned"))}if(this.intervals.length>=6){const t=this.intervals.slice(-8),i=t.reduce((t,e)=>t+e,0)/t.length,n=(t.reduce((t,e)=>t+Math.abs(e-i),0)/t.length/i*100).toFixed(1);let s=0;for(let e=0;e<t.length-1;e++)t[e]>i!=t[e+1]>i&&s++;const a=(s/(t.length-1)*100).toFixed(0);e.push(`Interval pattern: variance=${n}% alternating=${a}% (>70% triggers subdivision)`)}const s=[...this.intervals].map(t=>Math.round(t));if(s.length>0){const t=Math.min(...s),i=Math.max(...s),n=Math.round(s.reduce((t,e)=>t+e,0)/s.length);e.push(`Interval buffer (${s.length}/${this.maxIntervals}): min=${t}ms max=${i}ms avg=${n}ms (=${Math.round(6e4/n)} BPM)`)}e.push("");const a=(new Date).toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"});for(this._logBuffer.push({time:a,lines:e});this._logBuffer.length>this._maxLogEntries;)this._logBuffer.shift();this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0}getDebugLog(){if(0===this._logBuffer.length)return"No BPM debug logs yet. Play audio to generate logs.";let t="=== BPM Debug Log ===\n\n";for(const e of this._logBuffer){t+=`[${e.time}]\n`;for(const i of e.lines)t+=`${i}\n`;t+="\n"}return t}clearDebugLog(){this._logBuffer=[]}}class x_{constructor(t={}){this.options=t,this._audioContext=null,this._analyzerNode=null,this._analyzerConnected=!1,this._audioElement=null,this._audioSourceNode=null,this._connectedAudioElement=null,this._audioHandlers=null,this._decodedAudioBuffer=null,this._audioBufferDuration=null,this._analysisSourceNode=null,this._bufferAnalyzerNode=null,this._analysisGainNode=null,this._analysisStartTime=null,this._bpmDetector=null,this._bpmDetectionInterval=null,this._detectedBPM=0,this._bpmConfidence=0,this._bpmLocked=!1}async connectAudio(t){if(!t)return;this._audioElement=t,this._audioContext||(this._audioContext=new(window.AudioContext||window.webkitAudioContext)),"suspended"===this._audioContext.state&&await this._audioContext.resume(),this._analyzerNode||(this._analyzerNode=this._audioContext.createAnalyser(),this._analyzerNode.fftSize=256,this._analyzerNode.smoothingTimeConstant=.8);const e=t.src;if(e)try{const t=await fetch(e),i=await t.arrayBuffer(),n=await this._audioContext.decodeAudioData(i);this._decodedAudioBuffer=n,this._audioBufferDuration=n.duration}catch(t){console.warn("[Audio] Buffer decode failed, falling back to MediaElementSource:",t.message)}if(this._connectedAudioElement===t&&this._audioSourceNode)try{this._audioSourceNode.connect(this._analyzerNode)}catch{}else{if(this._audioSourceNode)try{this._audioSourceNode.disconnect()}catch{}try{this._audioSourceNode=this._audioContext.createMediaElementSource(t),this._audioSourceNode.connect(this._analyzerNode),this._connectedAudioElement=t}catch(t){console.error("[Audio] ERROR creating MediaElementSource:",t.message)}}this._analyzerConnected||(this._analyzerNode.connect(this._audioContext.destination),this._analyzerConnected=!0);const i=()=>{const e=this._detectedBPM||120;this.options.onRhythmStart?.(e,"straight"),this._decodedAudioBuffer&&!this._analysisSourceNode&&this._startBufferAnalysis(t.currentTime)},n=()=>{this.options.onRhythmStop?.(),this._stopBufferAnalysis()},s=()=>{this.options.onRhythmStop?.(),this._stopBufferAnalysis()},a=()=>{this._decodedAudioBuffer&&this._analysisSourceNode&&!t.paused&&(this._stopBufferAnalysis(),this._startBufferAnalysis(t.currentTime))};this._audioHandlers={onPlay:i,onPause:n,onEnded:s,onSeeked:a},t.addEventListener("play",i),t.addEventListener("pause",n),t.addEventListener("ended",s),t.addEventListener("seeked",a),t.paused||i(),this._decodedAudioBuffer&&!this._analysisSourceNode&&this._startBufferAnalysis(t.currentTime),this._startBPMDetectionWithValidation()}disconnectAudio(){if(this.options.onRhythmStop?.(),this._stopBufferAnalysis(),this._audioElement&&this._audioHandlers&&(this._audioElement.removeEventListener("play",this._audioHandlers.onPlay),this._audioElement.removeEventListener("pause",this._audioHandlers.onPause),this._audioElement.removeEventListener("ended",this._audioHandlers.onEnded),this._audioHandlers.onSeeked&&this._audioElement.removeEventListener("seeked",this._audioHandlers.onSeeked)),this._stopBPMDetection(),this._audioSourceNode)try{this._audioSourceNode.disconnect()}catch{}this._audioElement=null,this._audioHandlers=null,this._connectedAudioElement=null,this._audioSourceNode=null,this._decodedAudioBuffer=null,this._bufferAnalyzerNode=null}getAnalyzerNode(){return this._bufferAnalyzerNode||this._analyzerNode}getAudioContext(){return this._audioContext}isPlaying(){return this._audioElement&&!this._audioElement.paused}getBPMStatus(){return this._bpmDetector?this._bpmDetector.getStatus():{bpm:this._detectedBPM||120,subdivision:1,confidence:0,locked:!1,lockStage:0,correctionType:"none",finalized:!1,grooveConfidence:1,agentCount:0,peakCount:0,histogramSize:0,topAgents:[],intervalCount:0}}getBPMDebugLog(){return this._bpmDetector&&this._bpmDetector.getDebugLog?this._bpmDetector.getDebugLog():"No BPM detector active or debug log unavailable."}resetBPMDetection(t=null){this._bpmDetector&&this._bpmDetector.reset(t),this._bpmLocked=!1,this._bpmConfidence=0,this._detectedBPM=t||120}getDetectedBPM(){return this._detectedBPM}isBPMLocked(){return this._bpmLocked}_startBPMDetectionWithValidation(){let t=0;const e=()=>{t++,this._startBPMDetection(),setTimeout(()=>{this._validateAnalyzerWorking()||(t<3?(console.warn(`[BPM] Analyzer validation FAILED - rebuilding audio pipeline (attempt ${t+1})`),this._stopBPMDetection(),this._rebuildBufferAnalysis(),setTimeout(e,100)):console.error("[BPM] Analyzer validation FAILED after max retries - detection may not work"))},300)};e()}_validateAnalyzerWorking(){if(!this._bufferAnalyzerNode)return!1;const t=new Uint8Array(this._bufferAnalyzerNode.frequencyBinCount);let e=0,i=0;for(let n=0;n<10;n++){this._bufferAnalyzerNode.getByteFrequencyData(t),e=Math.max(e,Math.max(...t)),this._bufferAnalyzerNode.getByteTimeDomainData(t);const n=Math.min(...t),s=Math.max(...t);(n<115||s>141)&&i++}return!!(this._bpmDetector&&this._bpmDetector.peakCount>0)||i>0||e>5}_startBPMDetection(){this._bpmDetector||(this._bpmDetector=new __),this._bpmDetector.reset(),this._detectedBPM=0,this.options.onGrooveConfidenceChange?.(.15),this._bpmDetectionInterval&&(clearInterval(this._bpmDetectionInterval),this._bpmDetectionInterval=null);let t=null,e=0,i=0,n=0;const s=[];this._bpmDetectionInterval=setInterval(()=>{if(!this._audioElement||this._audioElement.paused)return;if(!this._bufferAnalyzerNode)return;const a=this._bufferAnalyzerNode.frequencyBinCount;t&&t.length===a||(t=new Uint8Array(a)),this._bufferAnalyzerNode.getByteFrequencyData(t);let r=0;for(let e=0;e<16;e++)r+=t[e];r/=16;let o=0;for(let e=0;e<a;e++)o+=t[e];o/=a;const l=new Uint8Array(a);this._bufferAnalyzerNode.getByteTimeDomainData(l);let h=0,c=255;for(let t=0;t<a;t++)h=Math.max(h,l[t]),c=Math.min(c,l[t]);const u=h-c,d=u-n;n=u;const p=Math.max(0,r-i);i=r,s.push(p),s.length>20&&s.shift();const m=s.reduce((t,e)=>t+e,0)/s.length*1.1+2,g=performance.now(),f=(u>40&&n<10||d>30)&&o>1;if((p>m||f)&&g-e>350){const t=f?Math.min(1,u/100):Math.min(1,p/50);this._bpmDetector.processPeak(t,g);const i=this._bpmDetector.getStatus();i.bpm>0&&(this._detectedBPM=i.bpm,this._bpmConfidence=i.confidence,this._bpmLocked=i.locked,i.locked&&this.options.onBPMChange?.(i.bpm),void 0!==i.grooveConfidence&&this.options.onGrooveConfidenceChange?.(i.grooveConfidence)),e=g}},10)}_stopBPMDetection(){this._bpmDetectionInterval&&(clearInterval(this._bpmDetectionInterval),this._bpmDetectionInterval=null),this._bpmLocked=!1,this._bpmConfidence=0}_rebuildBufferAnalysis(){if(this._stopBufferAnalysis(),this._analysisGainNode){try{this._analysisGainNode.disconnect()}catch{}this._analysisGainNode=null}this._bufferAnalyzerNode=null,this._decodedAudioBuffer&&this._audioElement&&this._startBufferAnalysis(this._audioElement.currentTime)}_startBufferAnalysis(t=0){if(!this._decodedAudioBuffer||!this._audioContext)return;const e=!this._bufferAnalyzerNode;this._bufferAnalyzerNode||(this._bufferAnalyzerNode=this._audioContext.createAnalyser(),this._bufferAnalyzerNode.fftSize=2048,this._bufferAnalyzerNode.smoothingTimeConstant=.1),this._analysisSourceNode=this._audioContext.createBufferSource(),this._analysisSourceNode.buffer=this._decodedAudioBuffer,this._analysisGainNode||(this._analysisGainNode=this._audioContext.createGain(),this._analysisGainNode.gain.value=.001,this._analysisGainNode.connect(this._audioContext.destination)),this._analysisSourceNode.connect(this._bufferAnalyzerNode),this._bufferAnalyzerNode.connect(this._analysisGainNode),this._analysisSourceNode.start(0,t),this._analysisStartTime=this._audioContext.currentTime-t,e&&this._bpmDetectionInterval&&(this._stopBPMDetection(),this._startBPMDetection())}_stopBufferAnalysis(){if(this._analysisSourceNode){try{this._analysisSourceNode.stop(),this._analysisSourceNode.disconnect()}catch{}this._analysisSourceNode=null}if(this._bufferAnalyzerNode){try{this._bufferAnalyzerNode.disconnect()}catch{}this._bufferAnalyzerNode=null}if(this._analysisGainNode)try{this._analysisGainNode.disconnect(),this._analysisGainNode.connect(this._audioContext.destination)}catch{}}destroy(){if(this.disconnectAudio(),this._audioContext){try{this._audioContext.close()}catch{}this._audioContext=null}this._analyzerNode=null,this._analyzerConnected=!1}}const w_=["flash","glow","burst","flicker"],S_={subtle:{single:["pop","bob","swell","nod","sway","tilt","floatUp"],combo:[]},moderate:{single:["pop","bob","dip","swagger","bounce","wiggle","headBob","lean","stepLeft","stepRight","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight"],combo:[["pop","bob"],["dip","swell"],["stepLeft","stepRight"],["leanLeft","leanRight"],["kickLeft","kickRight"]]},energetic:{single:["flare","swagger","dip","spin","spinLeft","spinRight","jump","twist","hula","stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight"],combo:[["flare","bob"],["pop","dip"],["swagger","flare"],["stepLeft","stepRight"],["slideLeft","slideRight"],["spinLeft","spinRight"],["kickLeft","kickRight"]]}},T_=[{geometry:"crystal",variant:null},{geometry:"rough",variant:null},{geometry:"heart",variant:null},{geometry:"star",variant:null},{geometry:"moon",variant:{type:"phase",value:"full"}},{geometry:"moon",variant:{type:"phase",value:"waxing-gibbous"}},{geometry:"moon",variant:{type:"phase",value:"first-quarter"}},{geometry:"moon",variant:{type:"phase",value:"waxing-crescent"}},{geometry:"moon",variant:{type:"phase",value:"new"}},{geometry:"moon",variant:{type:"eclipse",value:"partial"}},{geometry:"moon",variant:{type:"eclipse",value:"total"}},{geometry:"sun",variant:null},{geometry:"sun",variant:{type:"eclipse",value:"annular"}},{geometry:"sun",variant:{type:"eclipse",value:"total"}}],C_=["joy","excited","euphoria","surprise"],E_=["focused","love","calm","neutral"],A_=["resting","calm","sadness"],P_=["anger","fear","suspicion","glitch","disgust"],D_=["joy","excited","euphoria","surprise","focused","love","calm","neutral","resting","sadness","anger","fear","suspicion","glitch"],R_=.55,I_=.25,B_=.5;class L_{constructor(){this.rhythmAdapter=null,this.mascot=null,this.audioDeformer=null,this.enabled=!1,this.intensity=.5,this.currentGroove="groove1",this.lastGestureTime=0,this.lastGlowTime=0,this.lastFlashBar=-4,this.barCount=0,this.lastBarProgress=0,this._bassHistory=[],this._vocalHistory=[],this._historyLength=60,this._pendingGestures=[],this._gesturesThisBar=0,this._lastGestureBar=-1,this._lastMorphBar=-16,this._currentTarget={geometry:"crystal",variant:null},this._baseTarget={geometry:"crystal",variant:null},this._morphReturnTimeout=null,this._lastEmotionBar=-12,this._currentEmotion="neutral",this._baseEmotion="neutral",this._emotionReturnTimeout=null,this.config={gestureFrequencyBars:4,minGestureIntervalMs:800,comboProbability:{subtle:0,moderate:.1,energetic:.15},morphEnabled:!0,morphCooldownBars:16,morphEnergyThreshold:.5,morphReturnBars:8,emotionEnabled:!0,emotionCooldownBars:12,emotionReturnBars:16,emotionMatchEnergy:!0,dramaticEmotionProbability:.1,grooveSwitchBars:2,energySmoothing:.05,intensityAffectsFrequency:!0,intensityAffectsAmplitude:!0,glowEnabled:!0,maxGlowBoost:1.3,glowCooldownMs:800,autoEnableOnLock:!0}}setRhythmAdapter(t){this.rhythmAdapter=t}setMascot(t){if(this.mascot=t,t?.core3D?.geometryType){const e=t.core3D.geometryType;this._currentTarget={geometry:e,variant:null},this._baseTarget={geometry:e,variant:null}}t?.core3D?.emotion&&(this._currentEmotion=t.core3D.emotion,this._baseEmotion=t.core3D.emotion)}setAudioDeformer(t){this.audioDeformer=t}enable(){this.enabled=!0}disable(){this.enabled=!1}setIntensity(t){this.intensity=Math.max(0,Math.min(1,t))}getIntensity(){return this.intensity}update(t,e=null){if(!this.rhythmAdapter)return void console.warn("[DanceChoreographer] No rhythmAdapter!");if(this.config.autoEnableOnLock&&!this.enabled&&this.mascot){const t=this.mascot._bpmDetector;if(t){const e=t.getStatus();e?.finalized&&(this.enable(),this.setIntensity(1))}}if(!this.enabled)return;const i=e||this._getAudioData();this._updateEnergyHistory(i),this._detectBarTransition(),this._updateGroovePreset(),this._triggerGestures(i),this._considerMorph(i),this._considerEmotion(i)}_getAudioData(){return this.audioDeformer?{bass:this.audioDeformer.bassEnergy||0,vocal:this.audioDeformer.vocalPresence||0,flux:this.audioDeformer.transientStrength||0}:{bass:0,vocal:0,flux:0}}_updateEnergyHistory(t){for(this._bassHistory.push(t.bass),this._vocalHistory.push(t.vocal);this._bassHistory.length>this._historyLength;)this._bassHistory.shift();for(;this._vocalHistory.length>this._historyLength;)this._vocalHistory.shift()}_getSmoothedEnergy(t){return 0===t.length?0:t.reduce((t,e)=>t+e,0)/t.length}_detectBarTransition(){if(!this.rhythmAdapter)return;if(!this.rhythmAdapter?.isPlaying?.())return void(this.lastBarProgress=0);const t=this.rhythmAdapter.barProgress||0;t<this.lastBarProgress-.5&&(this.barCount++,this._gesturesThisBar=0),this.lastBarProgress=t}_updateGroovePreset(){if(!this.rhythmAdapter)return;const t=this._getSmoothedEnergy(this._bassHistory),e=this._getSmoothedEnergy(this._vocalHistory),i=this._detectGroovePreset(t,e);i!==this.currentGroove&&this._switchGroove(i)}_detectGroovePreset(t,e){const i=.5+.5*this.intensity;return t>R_*i?"groove2":e>B_*i&&t<1.5*I_?"groove3":"groove1"}_switchGroove(t){this.rhythmAdapter&&rg[t]&&(this.rhythmAdapter.setGroove(t,{quantize:!0,bars:this.config.grooveSwitchBars}),this.currentGroove=t)}_triggerGestures(t){if(!this.mascot)return void console.warn("[DanceChoreographer] _triggerGestures: No mascot reference!");if(!this.rhythmAdapter?.isPlaying?.())return void(this._lastGestureBar=-1);const e=performance.now();if(e-this.lastGestureTime<this.config.minGestureIntervalMs)return;const i=this.config.intensityAffectsFrequency?Math.max(1,Math.round(this.config.gestureFrequencyBars/(.5+this.intensity))):this.config.gestureFrequencyBars;if(this.barCount%i!==0)return;if(this._lastGestureBar===this.barCount)return;const n=this._selectGestureType(t),s=this._selectGesture(n,t);s&&(this._executeGesture(s),this._lastGestureBar=this.barCount,this.lastGestureTime=e)}_selectGestureType(t){return"groove2"===this.currentGroove&&this.intensity>.85&&t.bass>.7&&Math.random()<.3?"climactic":t.flux>.6?"dynamics":"groove2"===this.currentGroove&&this.intensity>.6?"movement":"punctuation"}_selectGesture(t,e){let i="subtle";this.intensity>.7||"groove2"===this.currentGroove?i="energetic":this.intensity>.4&&(i="moderate");const n=S_[i],s=this.config.comboProbability[i]||0;return n.combo.length>0&&Math.random()<s?n.combo[Math.floor(Math.random()*n.combo.length)]:n.single[Math.floor(Math.random()*n.single.length)]}_executeGesture(t){this.mascot&&t&&(Array.isArray(t)?t.forEach((t,e)=>{setTimeout(()=>{this._executeSingleGesture(t)},50*e)}):this._executeSingleGesture(t))}_executeSingleGesture(t){if(!this.mascot||!t)return;if(w_.includes(t)){if(!this._canTriggerGlow())return;this.lastGlowTime=performance.now(),"flash"===t&&(this.lastFlashBar=this.barCount)}const e=this.config.intensityAffectsAmplitude?.5+.5*this.intensity:1;"function"==typeof this.mascot.gesture&&this.mascot.gesture(t,{scale:e})}_canTriggerGlow(){return!!this.config.glowEnabled&&!(performance.now()-this.lastGlowTime<this.config.glowCooldownMs||this.barCount-this.lastFlashBar<4)}_considerMorph(t){if(!this.config.morphEnabled||!this.mascot)return;if(!this.rhythmAdapter?.isPlaying?.())return;const e=this.barCount-this._lastMorphBar;if(e<this.config.morphCooldownBars)return;const i=this._getSmoothedEnergy(this._bassHistory);this._getSmoothedEnergy(this._vocalHistory);let n=!1,s="";void 0===this._previousGroove&&(this._previousGroove=this.currentGroove),this.currentGroove!==this._previousGroove&&(Math.random()<.4&&(n=!0,s="section_change"),this._previousGroove=this.currentGroove),!n&&"groove2"===this.currentGroove&&i>.7&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.05&&(n=!0,s="energy_peak"),this._lastMorphCheckBar=this.barCount),!n&&e>=16&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.25&&(n=!0,s="time_variety"),this._lastMorphCheckBar=this.barCount),!n&&this._lastMorphBar<0&&this.barCount>=8&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.15&&(n=!0,s="intro_variety"),this._lastMorphCheckBar=this.barCount),n&&this._triggerMorph(s)}_triggerMorph(t){if(!this.mascot)return;this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null);const e=(t,e)=>t.geometry===e.geometry&&(!t.variant&&!e.variant||!(!t.variant||!e.variant)&&t.variant.type===e.variant.type&&t.variant.value===e.variant.value),i=T_.filter(t=>!e(t,this._currentTarget)&&!e(t,this._baseTarget)),n=i.length>0?i:T_.filter(t=>!e(t,this._currentTarget));if(0===n.length)return;const s=n[Math.floor(Math.random()*n.length)];this._applyMorphTarget(s),this._currentTarget=s,this._lastMorphBar=this.barCount;const a=60/(this.rhythmAdapter?.getBPM?.()||120)*4*1e3,r=this.config.morphReturnBars*a;this._morphReturnTimeout=setTimeout(()=>{this._returnToBaseGeometry()},r)}_returnToBaseGeometry(){var t,e;this.mascot&&(this._morphReturnTimeout=null,t=this._currentTarget,e=this._baseTarget,t.geometry===e.geometry&&(!t.variant&&!e.variant||t.variant&&e.variant&&t.variant.type===e.variant.type&&t.variant.value===e.variant.value)||(this._applyMorphTarget(this._baseTarget),this._currentTarget={...this._baseTarget}))}_applyMorphTarget(t){const e=this.mascot?.core3D;e&&(e.geometryType!==t.geometry?("function"==typeof this.mascot.morphTo?this.mascot.morphTo(t.geometry):"function"==typeof this.mascot.setGeometry&&this.mascot.setGeometry(t.geometry),t.variant&&setTimeout(()=>{e.geometryType===t.geometry&&this._applyVariant(t.geometry,t.variant)},1200)):t.variant?this._applyVariant(t.geometry,t.variant):this._clearVariant(t.geometry))}_applyVariant(t,e){const i=this.mascot?.core3D;if(i)if(i.geometryType===t)if("moon"===t){if(!i.customMaterial?.uniforms?.shadowOffset)return void console.warn("[DanceChoreographer] Moon material not ready for phase/eclipse");"eclipse"===e.type?(Am(i.customMaterial,"full"),"function"==typeof i.setMoonEclipse&&i.setMoonEclipse(e.value)):"phase"===e.type&&("function"==typeof i.setMoonEclipse&&i.setMoonEclipse("off"),Am(i.customMaterial,e.value))}else"sun"===t&&"eclipse"===e.type&&"function"==typeof i.setSunShadow&&i.setSunShadow(e.value);else console.warn(`[DanceChoreographer] Skipping variant - expected ${t}, got ${i.geometryType}`)}_clearVariant(t){const e=this.mascot?.core3D;e&&e.geometryType===t&&("moon"===t?("function"==typeof e.setMoonEclipse&&e.setMoonEclipse("off"),e.customMaterial?.uniforms?.shadowOffset&&Am(e.customMaterial,"full")):"sun"===t&&"function"==typeof e.setSunShadow&&e.setSunShadow("off"))}_getTargetLabel(t){return t.variant?`${t.geometry}:${t.variant.value}`:t.geometry}_considerEmotion(t){if(!this.config.emotionEnabled||!this.mascot)return;if(!this.rhythmAdapter?.isPlaying?.())return;const e=this.barCount-this._lastEmotionBar;if(e<this.config.emotionCooldownBars)return;const i=(this._getSmoothedEnergy(this._bassHistory)+this._getSmoothedEnergy(this._vocalHistory))/2;let n=!1,s="";void 0===this._prevGrooveForEmotion&&(this._prevGrooveForEmotion=this.currentGroove),this.currentGroove!==this._prevGrooveForEmotion&&(Math.random()<.6&&(n=!0,s="section_change"),this._prevGrooveForEmotion=this.currentGroove),!n&&"groove2"===this.currentGroove&&i>.6&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.15&&(n=!0,s="energy_peak"),this._lastEmotionCheckBar=this.barCount),!n&&"groove1"===this.currentGroove&&i<.25&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.1&&(n=!0,s="energy_low"),this._lastEmotionCheckBar=this.barCount),!n&&e>=12&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.2&&(n=!0,s="time_variety"),this._lastEmotionCheckBar=this.barCount),n&&this._triggerEmotion(s,i)}_triggerEmotion(t,e){if(!this.mascot)return;let i;this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null),i=this.config.emotionMatchEnergy?e>.65&&Math.random()<this.config.dramaticEmotionProbability?P_:e>.55?C_:e>.3?E_:A_:D_;const n=i.filter(t=>t!==this._currentEmotion);if(0===n.length)return;const s=n[Math.floor(Math.random()*n.length)];"function"==typeof this.mascot.setEmotion?this.mascot.setEmotion(s):this.mascot.core3D&&"function"==typeof this.mascot.core3D.setEmotion&&this.mascot.core3D.setEmotion(s),this._currentEmotion=s,this._lastEmotionBar=this.barCount;const a=60/(this.rhythmAdapter?.getBPM?.()||120)*4*1e3,r=this.config.emotionReturnBars*a;this._emotionReturnTimeout=setTimeout(()=>{this._returnToBaseEmotion()},r)}_returnToBaseEmotion(){this.mascot&&(this._emotionReturnTimeout=null,this._currentEmotion!==this._baseEmotion&&("function"==typeof this.mascot.setEmotion?this.mascot.setEmotion(this._baseEmotion):this.mascot.core3D&&"function"==typeof this.mascot.core3D.setEmotion&&this.mascot.core3D.setEmotion(this._baseEmotion),this._currentEmotion=this._baseEmotion))}setBaseEmotion(t){this._baseEmotion=t,this._currentEmotion=t}syncEmotionFromMascot(){this.mascot?.core3D?.emotion&&(this._currentEmotion=this.mascot.core3D.emotion)}getStatus(){return{enabled:this.enabled,intensity:this.intensity,currentGroove:this.currentGroove,currentTarget:this._getTargetLabel(this._currentTarget),baseTarget:this._getTargetLabel(this._baseTarget),currentEmotion:this._currentEmotion,baseEmotion:this._baseEmotion,barCount:this.barCount,avgBass:this._getSmoothedEnergy(this._bassHistory).toFixed(3),avgVocal:this._getSmoothedEnergy(this._vocalHistory).toFixed(3),lastGestureAgo:`${Math.round((performance.now()-this.lastGestureTime)/1e3)}s`,lastGlowAgo:`${Math.round((performance.now()-this.lastGlowTime)/1e3)}s`,lastMorphBar:this._lastMorphBar,barsSinceLastMorph:this.barCount-this._lastMorphBar,lastEmotionBar:this._lastEmotionBar,barsSinceLastEmotion:this.barCount-this._lastEmotionBar,canGlow:this._canTriggerGlow()}}setBaseGeometry(t,e=null){this._baseTarget={geometry:t,variant:e},this._currentTarget={geometry:t,variant:e}}syncGeometryFromMascot(){if(this.mascot?.core3D?.geometryType){const t=this.mascot.core3D.geometryType;this._currentTarget={geometry:t,variant:null}}}reset(){this.enabled=!1,this.currentGroove="groove1",this.barCount=0,this.lastBarProgress=0,this.lastGestureTime=0,this.lastGlowTime=0,this.lastFlashBar=-4,this._bassHistory=[],this._vocalHistory=[],this._gesturesThisBar=0,this._lastGestureBar=-1,this._lastMorphBar=-16;const t=this.mascot?.core3D?.geometryType||"crystal";this._currentTarget={geometry:t,variant:null},this._baseTarget={geometry:t,variant:null},this._previousGroove=void 0,this._lastMorphCheckBar=-1,this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null),this._lastEmotionBar=-12;const e=this.mascot?.core3D?.emotion||"neutral";this._currentEmotion=e,this._baseEmotion=e,this._prevGrooveForEmotion=void 0,this._lastEmotionCheckBar=-1,this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null)}destroy(){this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null),this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null),this.reset(),this.rhythmAdapter=null,this.mascot=null,this.audioDeformer=null}}function k_(t=32,e=32){const i=[],n=[],s=[];for(let s=0;s<=e;s++){const a=s/e*Math.PI;for(let e=0;e<=t;e++){const s=e/t*Math.PI*2,r=Math.cos(s)*Math.sin(a),o=Math.cos(a),l=Math.sin(s)*Math.sin(a);i.push(r,o,l),n.push(r,o,l)}}for(let i=0;i<e;i++)for(let e=0;e<t;e++){const n=i*(t+1)+e,a=n+t+1,r=n+1,o=a+1;s.push(n,a,r),s.push(r,a,o)}return{vertices:new Float32Array(i),normals:new Float32Array(n),indices:new Uint16Array(s)}}function O_(t=6){const e=[],i=[],n=[],s=new Map;let a=0;function r(t,n,r,o,l,h){const c=`${t},${n},${r}`;return s.has(c)||(e.push(t,n,r),i.push(o,l,h),s.set(c,a++)),s.get(c)}const o=r(0,1.5,0,0,1,0),l=[];for(let e=0;e<t;e++){const i=e/t*Math.PI*2,n=r(.7*Math.cos(i),0,.7*Math.sin(i),Math.cos(i),0,Math.sin(i));l.push(n)}const h=r(0,-1.5,0,0,-1,0);for(let e=0;e<t;e++){const i=(e+1)%t;n.push(o,l[e],l[i])}for(let e=0;e<t;e++){const i=(e+1)%t;n.push(l[e],h,l[i])}return{vertices:new Float32Array(e),normals:new Float32Array(i),indices:new Uint16Array(n)}}function z_(){const t=[],e=[],i=[],n=[0,1.2,0],s=[0,-.8,0],a=[];for(let t=0;t<8;t++){const e=t/8*Math.PI*2;a.push([.8*Math.cos(e),0,.8*Math.sin(e)])}function r(n,s,a){const r=[s[0]-n[0],s[1]-n[1],s[2]-n[2]],o=[a[0]-n[0],a[1]-n[1],a[2]-n[2]],l=r[1]*o[2]-r[2]*o[1],h=r[2]*o[0]-r[0]*o[2],c=r[0]*o[1]-r[1]*o[0],u=Math.sqrt(l*l+h*h+c*c),d=[l/u,h/u,c/u],p=t.length/3;t.push(...n),e.push(...d),t.push(...s),e.push(...d),t.push(...a),e.push(...d),i.push(p,p+1,p+2)}for(let t=0;t<8;t++){const e=(t+1)%8;r(n,a[t],a[e])}for(let t=0;t<8;t++){const e=(t+1)%8;r(a[t],s,a[e])}return{vertices:new Float32Array(t),normals:new Float32Array(e),indices:new Uint16Array(i)}}const F_={sphere:k_(32,32),crystal:O_(6),diamond:z_()};function U_(){Object.values(F_).forEach(t=>{t&&t.vertices&&(t.vertices=null,t.normals=null,t.indices=null)})}const N_={geometries:["crystal","rough","heart","star","moon","sun"],sssPresets:["quartz","emerald","ruby","sapphire","amethyst"],emotions:["neutral","joy","sadness","anger","fear","surprise","disgust","love","suspicion","excited","resting","euphoria","focused","glitch","calm"],motionGestures:["bounce","pulse","shake","nod","vibrate","orbit","twitch","sway","float","jitter","wiggle","sparkle","shimmer","pop","bob","swell","swagger","dip","flare","headBob","lean","point","reach","stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight","floatUp","floatDown","floatLeft","floatRight","pointUp","pointDown","pointLeft","pointRight"],transformGestures:["spin","spinLeft","spinRight","jump","morph","stretch","tilt","orbital","hula","twist"],effectGestures:["wave","drift","flicker","burst","fade","breathe","expand","contract","flash","glow","settle","hold"]},G_='You are a dance choreographer for an animated 3D mascot. Interpret lyrics/mood and output movement commands.\n\n## PHILOSOPHY\n- Gestures are constant - always return at least one to keep the mascot alive\n- Emotions shift with lyrical sentiment - change when the overall mood shifts\n- Geometry transforms are DRAMATIC EVENTS - only for song structure changes (introverse, versechorus, chorusbridge)\n- SSS (material color) requires EXPLICIT visual imagery - don\'t infer colors from abstract concepts\n- Focus on the FEELING of the phrase, not literal word-by-word interpretation\n\n## VOCABULARY\n\n**Geometries** (STRICT: max 2 per song, only at structural moments):\n- crystal (default, neutral) - use for verses, calm sections\n- heart (love, romance) - ONLY when love/heart explicitly mentioned\n- star (dreams, hope) - ONLY for aspirational climax moments\n- moon (night, introspection) - ONLY when night/darkness is the theme\n- sun (energy, warmth) - ONLY for bright, warm imagery\n- rough (raw, edgy) - ONLY for intense/aggressive sections\n\n**SSS Presets** (ONLY with explicit visual imagery):\n- quartz (pure, light, glowing) - "glow", "shine", "light", "bright"\n- emerald (nature) - "green", "forest", "grow", "nature"\n- ruby (fire, passion) - "fire", "burn", "red", "flame"\n- sapphire (water, sky) - "ocean", "rain", "blue", "sky", "tears"\n- amethyst (mystical, dreams) - "stars", "dream", "magic", "purple"\n\nDO NOT use SSS for: abstract emotions, actions, or phrases without color/nature imagery.\n\n**Emotions**:\n- neutral, calm, resting (baseline)\n- joy, excited, euphoria (positive high energy)\n- love (romantic, tender)\n- sadness, fear (vulnerable, soft)\n- anger, disgust (intense, but use sparingly)\n- surprise (sudden shifts only)\n- focused, suspicion (tension, anticipation)\n\n**Gestures by Category**:\n- Base (ongoing): sway, float, bounce, swagger, pulse\n- Accent (momentary hit): pop, bob, swell, dip, flare, burst\n- Texture (layer on top): shimmer, sparkle, glow, breathe\n- Transform (dramatic): spin, spinLeft, spinRight, jump, shake, twist\n- Directional (beat-synced moves): stepLeft, stepRight, stepUp, stepDown, slideLeft, slideRight\n- Directional (lean/kick): leanLeft, leanRight, kickLeft, kickRight\n- Directional (storytelling): floatUp, floatDown, floatLeft, floatRight, pointUp, pointDown, pointLeft, pointRight\n\n## GESTURE CHAINING\n\n- Single: "gesture": "sway"\n- Layered (simultaneous): "gesture": ["sway", "shimmer"]\n- Sequential (accent then settle): "gesture": "pop", "then": "sway"\n\nPatterns:\n- Verse/narrative: base + texture  ["sway", "breathe"]\n- Beat accent: accent then base  "pop", then: "sway"\n- Chorus/hook: base + texture + energy  ["swagger", "sparkle"]\n- Climax/drop: transform then base  "burst", then: "swagger"\n\n## DECISION GUIDE\n\n| Content | Response |\n|---------|----------|\n| Emotional phrase | emotion + gesture |\n| Explicit visual imagery (colors, nature, light) | sss + gesture |\n| Action words (dance, move, jump) | gesture only |\n| Narrative/story | subtle base gesture |\n| High energy hook/chorus | layered gestures + emotion |\n| FIRST line of new song section | geometry + maybe sss |\n\n## EXAMPLES\n\n"Tell me who\'s got rhythm in their feet"  {"gesture":["bounce","pulse"],"emotion":"excited"}\n"Who\'s got a heartbeat loud"  {"gesture":"pulse","emotion":"excited"}\n"Moving in the light"  {"gesture":["sway","shimmer"]}\n"Hands up high"  {"gesture":"swell","emotion":"joy"}\n"Feet on fire"  {"gesture":"flare","then":"swagger","emotion":"euphoria","sss":"ruby"}\n"We glow"  {"gesture":["sway","glow"],"sss":"quartz"}\n"Electric flow"  {"gesture":["swagger","sparkle"],"emotion":"excited"}\n"You know"  {"gesture":"sway"}\n"The night\'s our own"  {"gesture":["float","shimmer"],"emotion":"calm"}\n"Turn it up loud"  {"gesture":"burst","then":"swagger","emotion":"euphoria"}\n"To the left"  {"gesture":"stepLeft"}\n"Slide to the right"  {"gesture":"slideRight"}\n"To the left, to the left"  {"gesture":["stepLeft","stepLeft"]}\n"Hands up high"  {"gesture":"stepUp","emotion":"joy"}\n"Drop it low"  {"gesture":"stepDown","emotion":"excited"}\n"Lean back"  {"gesture":"leanRight"}\n"Kick it out"  {"gesture":"kickLeft","emotion":"excited"}\n"Spin around"  {"gesture":"spinRight"}\n"Turn the other way"  {"gesture":"spinLeft"}\n"Look to the stars"  {"gesture":"pointUp","emotion":"anticipation"}\n"He sank into despair"  {"gesture":"floatDown","emotion":"sadness"}\n"She drifted away"  {"gesture":"floatRight","emotion":"calm"}\n"Point to the future"  {"gesture":"pointUp","emotion":"joy"}\n"[Intro]"  {"gesture":["floatUp","breathe"],"emotion":"calm"}\n"[Bridge/Outro]"  {"gesture":["floatUp","breathe"],"emotion":"calm","geometry":"crystal"}\n\nRULES:\n1. Always include gesture\n2. Use only listed vocabulary\n3. Geometry changes are RARE (max 2 per song) - only at section boundaries\n4. SSS requires EXPLICIT color/visual imagery - no inference\n5. Match emotion to overall phrase sentiment, not individual words\n6. JSON only';class V_{constructor(t={}){this.apiKey=t.apiKey||null,this.endpoint=t.endpoint||null,this.model=t.model||null,this.onAction=t.onAction||null,this.onError=t.onError||null,this.enabled=!1,this.lastAction=null,this.lastInterpretTime=0,this.minIntervalMs=3e3,this.pendingRequest=null,this.currentState={geometry:null,sss:null,emotion:null},this.textBuffer=[],this.bufferTimeout=null}configure(t){t.apiKey&&(this.apiKey=t.apiKey.replace(/[^\x00-\x7F]/g,"").trim()),t.endpoint&&(this.endpoint=t.endpoint),t.model&&(this.model=t.model)}_isAnthropic(){return this.endpoint&&this.endpoint.includes("anthropic.com")}enable(){return this.apiKey&&this.endpoint?(this.enabled=!0,console.log("[AudioInterpreter] Enabled:",this.endpoint),!0):(console.warn("[AudioInterpreter] Need API key and endpoint"),!1)}disable(){this.enabled=!1,this.bufferTimeout&&(clearTimeout(this.bufferTimeout),this.bufferTimeout=null),console.log("[AudioInterpreter] Disabled")}updateCurrentState(t){t.geometry&&(this.currentState.geometry=t.geometry),t.sss&&(this.currentState.sss=t.sss),t.emotion&&(this.currentState.emotion=t.emotion)}feedText(t){this.enabled&&this.apiKey&&t&&0!==t.trim().length&&(this.textBuffer.push(t.trim()),this.bufferTimeout&&clearTimeout(this.bufferTimeout),this.bufferTimeout=setTimeout(()=>{this._processBuffer()},500))}async interpret(t){if(!this.enabled||!this.apiKey)return null;const e=Date.now();if(e-this.lastInterpretTime<this.minIntervalMs)return null;this.pendingRequest&&(this.pendingRequest=null),this.lastInterpretTime=e;try{const e=await this._callLLM(t);return e&&(this.lastAction=e,this._emitAction(e)),e}catch(t){return console.error("[AudioInterpreter] Error:",t),this.onError&&this.onError(t),null}}async _processBuffer(){if(0===this.textBuffer.length)return;const t=this.textBuffer.join(" ");this.textBuffer=[],await this.interpret(t)}async _callLLM(t){const e=Date.now();let i;if(this.pendingRequest=e,i=this._isAnthropic()?await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json","x-api-key":this.apiKey,"anthropic-version":"2023-06-01","anthropic-dangerous-direct-browser-access":"true"},body:JSON.stringify({model:this.model||"claude-3-haiku-20240307",max_tokens:100,system:G_,messages:[{role:"user",content:`Audio context: "${t}"`}]})}):await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.apiKey}`},body:JSON.stringify({model:this.model||"gpt-4o-mini",messages:[{role:"system",content:G_},{role:"user",content:`Audio context: "${t}"`}],max_tokens:100,temperature:.3})}),this.pendingRequest!==e)return null;if(!i.ok){const t=await i.json().catch(()=>({}));throw new Error(t.error?.message||`API error: ${i.status}`)}const n=await i.json();let s;if(this._isAnthropic()){const t=n.content?.find(t=>"text"===t.type);s=t?.text}else s=n.choices?.[0]?.message?.content;if(!s)return null;try{const t=JSON.parse(s.trim());return this._validateAction(t)}catch{const t=s.match(/\{[\s\S]*\}/);if(t)try{const e=JSON.parse(t[0]);return this._validateAction(e)}catch{return console.warn("[AudioInterpreter] Failed to parse:",s),null}return console.warn("[AudioInterpreter] Failed to parse:",s),null}}_validateAction(t){if(!t||"object"!=typeof t)return null;const e={};if(t.geometry&&N_.geometries.includes(t.geometry)&&t.geometry!==this.currentState.geometry&&(e.geometry=t.geometry),t.sss&&N_.sssPresets.includes(t.sss)){const i=e.geometry||this.currentState.geometry;["crystal","rough","heart","star"].includes(i)&&t.sss!==this.currentState.sss&&(e.sss=t.sss)}if(t.emotion&&N_.emotions.includes(t.emotion)&&t.emotion!==this.currentState.emotion&&(e.emotion=t.emotion),t.gesture){const i=[...N_.motionGestures,...N_.transformGestures,...N_.effectGestures];if(Array.isArray(t.gesture)){const n=t.gesture.filter(t=>i.includes(t));n.length>0&&(e.gesture=1===n.length?n[0]:n)}else i.includes(t.gesture)&&(e.gesture=t.gesture)}if(t.then){const i=[...N_.motionGestures,...N_.transformGestures,...N_.effectGestures];if(Array.isArray(t.then)){const n=t.then.filter(t=>i.includes(t));n.length>0&&(e.then=1===n.length?n[0]:n)}else i.includes(t.then)&&(e.then=t.then)}return 0===Object.keys(e).length?null:e}_emitAction(t){t.geometry&&(this.currentState.geometry=t.geometry),t.sss&&(this.currentState.sss=t.sss),t.emotion&&(this.currentState.emotion=t.emotion),this.onAction&&this.onAction(t)}static getVocabulary(){return{...N_}}}const H_={anthropic:"https://api.anthropic.com/v1/messages",openai:"https://api.openai.com/v1/chat/completions",grok:"https://api.x.ai/v1/chat/completions"},W_=new V_,j_=["sphere","crystal","diamond","rough","heart","star","moon","sun"];class X_{constructor(t={}){this.config={canvasId:t.canvasId||"emotive-canvas",coreGeometry:t.coreGeometry||"sphere",targetFPS:t.targetFPS||60,enableParticles:!1!==t.enableParticles,defaultEmotion:t.defaultEmotion||"neutral",...t},this._canvasLayerManager=null,this.container=null,this.webglCanvas=null,this.canvas2D=null,this.core3D=null,this.particleSystem=null,this.danceChoreographer=null,this.isRunning=!1,this._destroyed=!1,this.animationFrameId=null,this.lastFrameTime=0,this.gestureTimeouts=[],this.eventManager=new qM,this.eventManager.emit||(this.eventManager._listeners={},this.eventManager.emit=(t,e)=>{const i=this.eventManager._listeners[t];i&&i.forEach(t=>t(e))},this.eventManager.on=(t,e)=>{this.eventManager._listeners[t]||(this.eventManager._listeners[t]=[]),this.eventManager._listeners[t].push(e)},this.eventManager.off=(t,e)=>{const i=this.eventManager._listeners[t];if(i){const t=i.indexOf(e);t>-1&&i.splice(t,1)}}),this.errorBoundary=new YM,this.emotion="neutral",this.undertone=null,this._intentParser=new M_,this._feelRateLimiter={calls:[],windowMs:1e3,maxCallsPerSecond:10},this._audioBridge=null,this._prefersReducedMotion="undefined"!=typeof window&&(window.matchMedia?.("(prefers-reduced-motion: reduce)").matches??!1),this._reducedMotionMediaQuery=null}prefersReducedMotion(){return this._prefersReducedMotion}setReducedMotion(t){return this._prefersReducedMotion=t,t&&this.disableAutoRotate(),this.eventManager.emit("accessibility:reducedMotion",{enabled:t}),this}_setupReducedMotionListener(){"undefined"!=typeof window&&window.matchMedia&&(this._reducedMotionMediaQuery=window.matchMedia("(prefers-reduced-motion: reduce)"),this._reducedMotionHandler=t=>{this._prefersReducedMotion=t.matches,this.setReducedMotion(t.matches)},this._reducedMotionMediaQuery.addEventListener?this._reducedMotionMediaQuery.addEventListener("change",this._reducedMotionHandler):this._reducedMotionMediaQuery.addListener&&this._reducedMotionMediaQuery.addListener(this._reducedMotionHandler))}_isDestroyed(){return this._destroyed||!this.eventManager||!this.eventManager._listeners}_getAudioBridge(){return this._audioBridge||(this._audioBridge=new x_({onRhythmStart:(t,e)=>this.startRhythm(t,e),onRhythmStop:()=>this.stopRhythm(),onBPMChange:t=>{this.isRhythmPlaying()&&this.setRhythmBPM(t)},onGrooveConfidenceChange:t=>{this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setGrooveConfidence(t)}})),this._audioBridge}init(t){if("undefined"==typeof window)throw new Error("EmotiveMascot3D.init() requires a browser environment. For SSR frameworks, use dynamic import with ssr:false (Next.js) or <ClientOnly> (Nuxt).");try{this._canvasLayerManager=new XM({canvasId:this.config.canvasId,enableControls:this.config.enableControls});const e=this._canvasLayerManager.setup(t);if(this.container=e.container,this.webglCanvas=e.webglCanvas,this.canvas2D=e.canvas2D,this.core3D=new jM(this.webglCanvas,{geometry:this.config.coreGeometry,emotion:this.config.defaultEmotion,enableParticles:this.config.enableParticles,enablePostProcessing:this.config.enablePostProcessing,enableShadows:this.config.enableShadows,enableControls:this.config.enableControls,autoRotate:this.config.autoRotate,enableBlinking:this.config.enableBlinking,enableBreathing:this.config.enableBreathing,cameraDistance:this.config.cameraDistance,fov:this.config.fov,minZoom:this.config.minZoom,maxZoom:this.config.maxZoom,materialVariant:this.config.materialVariant,assetBasePath:this.config.assetBasePath}),this.ctx2D=this.canvas2D.getContext("2d"),this.config.enableParticles&&!this.core3D?.particleOrchestrator){const t=this.config.maxParticles||300;this.particleSystem=new Kb(t,this.errorBoundary),this.particleSystem.canvasWidth=this.canvas2D.width,this.particleSystem.canvasHeight=this.canvas2D.height}return this.danceChoreographer=new L_,this.danceChoreographer.setRhythmAdapter(this.core3D?.rhythm3DAdapter),this.danceChoreographer.setMascot(this),this._setupReducedMotionListener(),this._prefersReducedMotion&&this.setReducedMotion(!0),this}catch(t){throw console.error("Failed to initialize 3D engine:",t),t}}async start(){this.isRunning||(this.core3D&&await this.core3D.waitUntilReady(),this.isRunning=!0,this.lastFrameTime=null,this.animationFrameId=requestAnimationFrame(this.animate.bind(this)))}stop(){this.isRunning=!1,this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null)}animate(t){if(!this.isRunning||this._destroyed)return;if(null===this.lastFrameTime)return this.lastFrameTime=t,void(this.animationFrameId=requestAnimationFrame(this.animate.bind(this)));const e=t-this.lastFrameTime,i=Math.min(e,100);if(this.lastFrameTime=t,this.core3D&&!this._destroyed&&(this.core3D.render(i),this._canvasLayerManager&&!this._canvasLayerManager.isCanvasAppended()&&this._canvasLayerManager.appendWebGLCanvas()),this.danceChoreographer&&!this._destroyed&&this.danceChoreographer.update(i/1e3),this.canvas2D&&this.ctx2D&&(this.ctx2D.clearRect(0,0,this.canvas2D.width,this.canvas2D.height),this.ctx2D.fillStyle="rgba(0,0,0,0)",this.ctx2D.fillRect(0,0,this.canvas2D.width,this.canvas2D.height),this.particleSystem)){const e=this.canvas2D.width/2,n=this.canvas2D.height/2,s=this.core3D?this.core3D.emotion:"neutral",a=Km(s),r=this.core3D?this.rgbToHex(this.core3D.glowColor):"#FFFFFF",o=a?.visual?.particleBehavior||"ambient",l=a?.visual?.particleRate||15,h=a?.visual?.minParticles||5,c=a?.visual?.maxParticles||30,u=a?.visual?.particleColors||null;this.particleSystem.spawn(o,s,l,e,n,i,null,h,c,1,1,u,this.undertone);let d=null,p=0;if(this.currentGesture){const e=t-this.currentGesture.startTime;p=Math.min(e/this.currentGesture.duration,1),d={...this.currentGesture.config,type:this.currentGesture.name}}this.particleSystem.update(i,e,n,d,p,this.undertone),this.particleSystem.render(this.ctx2D,r,null)}this.animationFrameId=requestAnimationFrame(t=>this.animate(t))}setEmotion(t,e,i){return this._isDestroyed()?this:t&&"string"==typeof t?(function(t){const e=Qm[t]||t;return Jm.has(e)||null!==qm(e)}(t)||console.warn(`[EmotiveMascot3D] Unknown emotion "${t}". Valid emotions: ${ig().join(", ")}`),this.emotion=t,void 0!==e&&("string"==typeof e?this.undertone=e:"number"==typeof e||(e&&"object"==typeof e?this.undertone=e.undertone||null:null===e&&(this.undertone=null))),this.core3D&&this.core3D.setEmotion(t,this.undertone),this.particleSystem&&(this.particleSystem.particles=[]),this.eventManager.emit("emotion:change",{emotion:t,undertone:this.undertone}),this):(console.warn(`[EmotiveMascot3D] setEmotion: Invalid emotion "${t}". Use getAvailableEmotions() for valid options.`),this)}updateUndertone(t){return this._isDestroyed()||(this.undertone=t,this.core3D&&this.emotion&&this.core3D.setEmotion(this.emotion,t),this.eventManager.emit("undertone:change",{undertone:t})),this}setUndertone(t){return this.updateUndertone(t)}express(t){if(this._isDestroyed())return this;if(!t||"string"!=typeof t)return console.warn(`[EmotiveMascot3D] express: Invalid gesture "${t}". Use getAvailableGestures() for valid options.`),this;this.core3D&&this.core3D.playGesture(t);const e=Xb(t);if(e){const i=e.config||{},n=i.musicalDuration?.musical?500*(i.musicalDuration.beats||2):i.duration||800;this.currentGesture={name:t,gesture:e,config:i,startTime:performance.now(),duration:n};const s=setTimeout(()=>{this.currentGesture&&this.currentGesture.name===t&&(this.currentGesture=null)},n);this.gestureTimeouts.push(s)}else{const e=qb().map(t=>t.name);console.warn(`[EmotiveMascot3D] Unknown gesture "${t}". Valid gestures: ${e.slice(0,10).join(", ")}...`)}return this.eventManager.emit("gesture:trigger",{gesture:t}),this}gesture(t,e={}){return this.express(t)}chain(t){const e=("string"==typeof t?{rise:"breathe > sway+lean+tilt",flow:"sway > lean+tilt > spin > bounce",burst:"jump > nod > shake > flash",drift:"sway+breathe+float+drift",chaos:"shake+shake > spin+flash > bounce+pulse > twist+sparkle",morph:"expand > contract > morph+glow > expand+flash",rhythm:"pulse > pulse+sparkle > pulse+flicker",spiral:"spin > orbital > twist > orbital+sparkle",routine:"nod > bounce > spin+sparkle > sway+pulse > nod+flash",radiance:"sparkle > pulse+flicker > shimmer",twinkle:"sparkle > flash > pulse+sparkle > shimmer+flicker",stream:"wave > nod+pulse > sparkle > flash"}[t]||t:t.join(">")).split(">").map(t=>t.trim().split("+").map(t=>t.trim()).filter(t=>t.length>0));this.executeChainSequence(e)}executeChainSequence(t){if(!t||0===t.length)return;let e=0;const i=()=>{if(!(e>=t.length)&&(t[e].forEach(t=>{this.express(t)}),e++,e<t.length)){const t=setTimeout(i,800);this.gestureTimeouts.push(t)}};i()}morphTo(t,e={}){if(this._isDestroyed())return this;if(!t||"string"!=typeof t)return console.warn(`[EmotiveMascot3D] morphTo: Invalid shape "${t}". Use getAvailableGeometries() for valid options.`),this;if(j_.includes(t)||console.warn(`[EmotiveMascot3D] Unknown geometry "${t}". Valid geometries: ${j_.join(", ")}`),this.core3D){if(void 0!==e.materialVariant&&this.core3D.setMaterialVariant(e.materialVariant),e.onMaterialSwap){const t=this.core3D.onMaterialSwap;this.core3D.onMaterialSwap=i=>{t&&t(i),e.onMaterialSwap(i),this.core3D.onMaterialSwap=t}}const i=e.duration||800;this.core3D.morphToShape(t,i)}return this.eventManager.emit("shape:morph",{shape:t}),this}triggerReassembly(t=1500){return!!this.core3D&&this.core3D.triggerReassembly(t)}isShatterFrozen(){return this.core3D?.isShatterFrozen()||!1}feel(t){if(this._isDestroyed())return{success:!1,error:"Engine destroyed",parsed:null};const e=Date.now(),i=this._feelRateLimiter;if(i.calls=i.calls.filter(t=>e-t<i.windowMs),i.calls.length>=i.maxCallsPerSecond)return console.warn(`[EmotiveMascot3D] feel: Rate limit exceeded. Max ${i.maxCallsPerSecond} calls per second.`),{success:!1,error:"Rate limit exceeded",parsed:null};i.calls.push(e);const n=this._intentParser.parse(t),s=this._intentParser.validate(n);if(!s.valid)return console.warn("[feel] Invalid intent:",s.errors),{success:!1,error:s.errors.join("; "),parsed:n};try{if(n.emotion){const t={};n.undertone&&"clear"!==n.undertone&&(t.undertone=n.undertone),this.setEmotion(n.emotion,t)}for(const t of n.gestures)this.express(t);return n.shape&&this.morphTo(n.shape),{success:!0,error:null,parsed:n}}catch(t){return console.error("[feel] Execution error:",t),{success:!1,error:t.message,parsed:n}}}isMorphing(){return!!this.core3D&&this.core3D.isMorphing()}getMorphState(){return this.core3D?this.core3D.getMorphState():null}growIn(t=500){this.core3D&&this.core3D.growIn(t),this.eventManager.emit("animation:growIn",{duration:t})}setCoreGlowEnabled(t){this.core3D&&this.core3D.setCoreGlowEnabled(t),this.eventManager.emit("coreGlow:toggle",{enabled:t})}isCoreGlowEnabled(){return!this.core3D||this.core3D.coreGlowEnabled}enableAutoRotate(){this.core3D&&"moon"!==this.core3D.geometryType&&(this.core3D.renderer?.controls&&(this.core3D.renderer.controls.autoRotate=!0,this.core3D.renderer.controls.autoRotateSpeed=this.core3D.options?.autoRotateSpeed??.5),this.core3D.rotationDisabled=!1,this.setEmotion(this.core3D.emotion,this.undertone))}disableAutoRotate(){this.core3D?.renderer?.controls&&(this.core3D.renderer.controls.autoRotate=!1,this.core3D.renderer.controls.autoRotateSpeed=0),this.core3D&&(this.core3D.rotationDisabled=!0,this.core3D.rotationBehavior=null,this.core3D.baseEuler&&(this.core3D.baseEuler[0]=0,this.core3D.baseEuler[1]=0,this.core3D.baseEuler[2]=0))}setCameraPreset(t,e=1e3){this.core3D?.renderer?.setCameraPreset&&this.core3D.renderer.setCameraPreset(t,e)}get autoRotateEnabled(){return!1===this.core3D?.rotationDisabled}enableParticles(){if(this.core3D?.particleOrchestrator?.renderer&&(this.core3D.particleVisibility=!0,this.core3D.particleOrchestrator.renderer.setVisible(!0),this.core3D.particleOrchestrator.setEmotion(this.core3D.emotion,this.core3D.undertone)),!this.core3D?.particleOrchestrator&&!this.particleSystem&&this.canvas2D){const t=this.config.maxParticles||300;this.particleSystem=new Kb(t,this.errorBoundary),this.particleSystem.canvasWidth=this.canvas2D.width,this.particleSystem.canvasHeight=this.canvas2D.height}}disableParticles(){this.core3D?.particleOrchestrator?.renderer&&(this.core3D.particleVisibility=!1,this.core3D.particleOrchestrator.renderer.setVisible(!1),this.core3D.particleOrchestrator.clear()),this.core3D?.particleOrchestrator||this.particleSystem&&(this.particleSystem.destroy(),this.particleSystem=null)}get particlesEnabled(){return this.core3D?.particleOrchestrator?!0===this.core3D.particleVisibility:null!==this.particleSystem}enableBlinking(){this.core3D&&(this.core3D.blinkingManuallyDisabled=!1,this.core3D.blinkAnimator&&this.core3D.blinkAnimator.resume())}disableBlinking(){this.core3D&&(this.core3D.blinkingManuallyDisabled=!0,this.core3D.blinkAnimator&&this.core3D.blinkAnimator.pause())}get blinkingEnabled(){return!(!this.core3D||!this.core3D.blinkAnimator)&&this.core3D.blinkAnimator.enabled}enableBreathing(){this.core3D&&(this.core3D.breathingEnabled=!0)}disableBreathing(){this.core3D&&(this.core3D.breathingEnabled=!1)}get breathingEnabled(){return!this.core3D||!1!==this.core3D.breathingEnabled}breathePhase(t,e){this.core3D&&this.core3D.breathePhase(t,e)}stopBreathingPhase(){this.core3D&&this.core3D.stopBreathingPhase()}enableWobble(){this.core3D&&this.core3D.setWobbleEnabled(!0)}disableWobble(){this.core3D&&this.core3D.setWobbleEnabled(!1)}get wobbleEnabled(){return!this.core3D||!1!==this.core3D.wobbleEnabled}enableRhythmSync(){this.core3D&&this.core3D.setRhythmEnabled(!0)}disableRhythmSync(){this.core3D&&this.core3D.setRhythmEnabled(!1)}get rhythmSyncEnabled(){return!!this.core3D&&this.core3D.rhythmEnabled}enableGroove(){this.core3D&&this.core3D.setGrooveEnabled(!0)}disableGroove(){this.core3D&&this.core3D.setGrooveEnabled(!1)}setBeatSyncStrength(t){this.core3D&&this.core3D.setBeatSyncStrength(t)}setGrooveConfidence(t){this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setGrooveConfidence(t)}getGrooveConfidence(){return this.core3D?.rhythm3DAdapter?.grooveConfidence??1}setBPMMultiplier(t){this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setBPMMultiplier(t)}getBPMMultiplier(){return this.core3D?.rhythm3DAdapter?.getBPMMultiplier()??1}setGrooveConfig(t){this.core3D&&this.core3D.setGrooveConfig(t)}setGroove(t,e={}){this.core3D&&this.core3D.setGroove(t,e)}getGroovePresets(){return this.core3D?this.core3D.getGroovePresets():["groove1","groove2","groove3"]}getCurrentGroove(){return this.core3D?this.core3D.getCurrentGroove():"groove1"}enableDance(){this.danceChoreographer&&this.danceChoreographer.enable()}disableDance(){this.danceChoreographer&&this.danceChoreographer.disable()}isDanceEnabled(){return this.danceChoreographer?.enabled??!1}setDanceIntensity(t){this.danceChoreographer&&this.danceChoreographer.setIntensity(t)}getDanceIntensity(){return this.danceChoreographer?.getIntensity()??.5}getDanceStatus(){return this.danceChoreographer?.getStatus()??{enabled:!1}}isRhythmPlaying(){return this.core3D?.isRhythmPlaying()||!1}getRhythmBPM(){return this.core3D?.getRhythmBPM()||120}startRhythm(t=120,e="straight"){this.core3D&&this.core3D.startRhythm(t,e)}stopRhythm(){this.core3D&&this.core3D.stopRhythm()}setRhythmBPM(t){this.core3D&&this.core3D.setRhythmBPM(t)}setRhythmPattern(t){this.core3D&&this.core3D.setRhythmPattern(t)}connectAudio(t){return this._getAudioBridge().connectAudio(t)}disconnectAudio(){this._audioBridge&&this._audioBridge.disconnectAudio()}getBPMStatus(){return this._audioBridge?this._audioBridge.getBPMStatus():{bpm:120,subdivision:1,confidence:0,locked:!1,lockStage:0,correctionType:"none",finalized:!1,grooveConfidence:1,agentCount:0,peakCount:0,histogramSize:0,topAgents:[],intervalCount:0}}getBPMDebugLog(){return this._audioBridge?this._audioBridge.getBPMDebugLog():"No audio bridge active."}resetBPMDetection(t=null){this._audioBridge&&this._audioBridge.resetBPMDetection(t)}rgbToHex(t){return`#${[Math.round(255*t[0]),Math.round(255*t[1]),Math.round(255*t[2])].map(t=>{const e=t.toString(16);return 1===e.length?`0${e}`:e}).join("")}`}setPosition(t,e,i=0){if(!this.container)return this;const n=this.position||{x:0,y:0,z:0};this.position={x:t,y:e,z:i};const s=window.innerWidth<768;return this.container.style.transform=s?`translate(calc(-50% + ${t}px), calc(-50% + ${e}px))`:`translate(${t}px, calc(-50% + ${e}px))`,this.eventManager&&this.eventManager.emit("position:change",{x:t,y:e,z:i,previous:n}),this}getPosition(){return this.position||{x:0,y:0,z:0}}getAvailableEmotions(){return ig()}getAvailableGestures(){return qb()}getGestureCategories(){return Wb}getAvailableGeometries(){return[...j_]}animateToPosition(t,e,i=0,n=1e3,s="easeOutCubic"){if(!this.container)return;const a=this.getPosition(),r=performance.now(),o=s=>{const l=s-r,h=Math.min(l/n,1),c=(u=h,1-Math.pow(1-u,3));var u;const d=a.x+(t-a.x)*c,p=a.y+(e-a.y)*c,m=a.z+(i-a.z)*c;this.setPosition(d,p,m),h<1&&requestAnimationFrame(o)};requestAnimationFrame(o)}setContainment(t,e=1){const i=this._containmentScale||1;if(this._containmentBounds=t,this._containmentScale=e,this.particleSystem&&1!==e){const t=this.config.particleSpawnRadius||150;this.particleSystem.setSpawnRadius(t*e)}return this.eventManager&&e!==i&&this.eventManager.emit("scale:change",{scale:e,previous:i}),this}attachToElement(t,e={}){const i="string"==typeof t?document.querySelector(t):t;if(!i)return console.error(`[EmotiveMascot3D] Element not found: ${t}`),this;this._attachedElement=i,this._attachOptions={offsetX:e.offsetX||0,offsetY:e.offsetY||0,animate:!1!==e.animate,duration:e.duration||1e3,scale:e.scale||1,containParticles:!1!==e.containParticles},this._hasAttachedBefore=this._hasAttachedBefore||!1;const n=i.getBoundingClientRect();return this._attachOptions.containParticles?this.setContainment({width:n.width,height:n.height},this._attachOptions.scale):1!==this._attachOptions.scale&&this.setContainment(null,this._attachOptions.scale),this._updateAttachedPosition(),this._setupElementTracking(),this}_updateAttachedPosition(){if(!this._attachedElement||!this.container)return;const t=this._attachedElement.getBoundingClientRect(),e=this.container.getBoundingClientRect(),i=t.left+t.width/2,n=t.top+t.height/2,s=e.left+e.width/2,a=e.top+e.height/2,r=i-s+this._attachOptions.offsetX,o=n-a+this._attachOptions.offsetY,l=!this._hasAttachedBefore;this._hasAttachedBefore=!0,l&&this._attachOptions.animate?this.animateToPosition(r,o,0,this._attachOptions.duration):this.setPosition(r,o,0)}_setupElementTracking(){this._elementTrackingHandlers||(this._elementTrackingHandlers={scroll:()=>this._updateAttachedPosition(),resize:()=>this._updateAttachedPosition()},window.addEventListener("scroll",this._elementTrackingHandlers.scroll,{passive:!0}),window.addEventListener("resize",this._elementTrackingHandlers.resize))}isAttachedToElement(){return!!this._attachedElement}detachFromElement(){return this._attachedElement=null,this._hasAttachedBefore=!1,this._elementTrackingHandlers&&(window.removeEventListener("scroll",this._elementTrackingHandlers.scroll),window.removeEventListener("resize",this._elementTrackingHandlers.resize),this._elementTrackingHandlers=null),this.setContainment(null,1),this.setEmotion("neutral"),this}setSSSPreset(t,e={}){this._currentSSSPreset=t,this.core3D&&!this._materialSwapCallbackSet&&(this._materialSwapCallbackSet=!0,this.core3D.onMaterialSwap=()=>{this._currentSSSPreset&&setTimeout(()=>{ZM(this,this._currentSSSPreset)},50)});const i=$M[t];if(!i||!this.core3D?.customMaterial?.uniforms)return!1;const n=this.core3D.customMaterial.uniforms;if(e.immediate||!this.core3D._targetSSSValues){const e=ZM(this,t);return e&&(this.core3D._targetSSSValues={...i},this.core3D._sssTransitionProgress=1,this.eventManager.emit("sss:presetChanged",{preset:t})),e}return this.core3D._sssTransitionStart={sssStrength:n.sssStrength?.value??i.sssStrength,sssAbsorption:n.sssAbsorption?.value?[n.sssAbsorption.value.x,n.sssAbsorption.value.y,n.sssAbsorption.value.z]:[...i.sssAbsorption],sssScatterDistance:n.sssScatterDistance?.value?[n.sssScatterDistance.value.x,n.sssScatterDistance.value.y,n.sssScatterDistance.value.z]:[...i.sssScatterDistance],sssThicknessBias:n.sssThicknessBias?.value??i.sssThicknessBias,sssThicknessScale:n.sssThicknessScale?.value??i.sssThicknessScale,sssCurvatureScale:n.sssCurvatureScale?.value??i.sssCurvatureScale,sssAmbient:n.sssAmbient?.value??i.sssAmbient,frostiness:n.frostiness?.value??i.frostiness,innerGlowStrength:n.innerGlowStrength?.value??i.innerGlowStrength,fresnelIntensity:n.fresnelIntensity?.value??i.fresnelIntensity,causticIntensity:n.causticIntensity?.value??i.causticIntensity,emotionColorBleed:n.emotionColorBleed?.value??i.emotionColorBleed},this.core3D._targetSSSValues={sssStrength:i.sssStrength,sssAbsorption:[...i.sssAbsorption],sssScatterDistance:[...i.sssScatterDistance],sssThicknessBias:i.sssThicknessBias,sssThicknessScale:i.sssThicknessScale,sssCurvatureScale:i.sssCurvatureScale,sssAmbient:i.sssAmbient,frostiness:i.frostiness,innerGlowStrength:i.innerGlowStrength,fresnelIntensity:i.fresnelIntensity,causticIntensity:i.causticIntensity,emotionColorBleed:i.emotionColorBleed},this.core3D._sssTransitionProgress=0,this.eventManager.emit("sss:presetChanged",{preset:t,transitioning:!0}),!0}setGeometry(t,e={}){return console.warn("[EmotiveMascot3D] setGeometry() is deprecated. Use morphTo() instead."),this.morphTo(t,e)}startSolarEclipse(t={}){this.core3D&&"function"==typeof this.core3D.startSolarEclipse?this.core3D.startSolarEclipse(t):(this.morphTo("sun"),this.eventManager.emit("eclipse:solar:start",{type:t.type||"total"}))}startLunarEclipse(t={}){this.core3D&&"function"==typeof this.core3D.startLunarEclipse?this.core3D.startLunarEclipse(t):(this.morphTo("moon"),this.eventManager.emit("eclipse:lunar:start",{type:t.type||"total"}))}setColorTransitionDuration(t){return this.core3D&&(this.core3D.colorTransitionDuration=t),this}setSSSTransitionDuration(t){return this.core3D&&(this.core3D.sssTransitionDuration=t),this}stopEclipse(){this.core3D&&"function"==typeof this.core3D.stopEclipse&&this.core3D.stopEclipse(),this.eventManager&&this.eventManager.emit("eclipse:stop")}destroy(){this._destroyed=!0,this.stop(),this._audioBridge&&(this._audioBridge.destroy(),this._audioBridge=null),this._elementTrackingHandlers&&(window.removeEventListener("scroll",this._elementTrackingHandlers.scroll),window.removeEventListener("resize",this._elementTrackingHandlers.resize),this._elementTrackingHandlers=null),this._attachedElement=null,this._reducedMotionMediaQuery&&this._reducedMotionHandler&&(this._reducedMotionMediaQuery.removeEventListener?this._reducedMotionMediaQuery.removeEventListener("change",this._reducedMotionHandler):this._reducedMotionMediaQuery.removeListener&&this._reducedMotionMediaQuery.removeListener(this._reducedMotionHandler),this._reducedMotionMediaQuery=null,this._reducedMotionHandler=null),this.gestureTimeouts.forEach(t=>clearTimeout(t)),this.gestureTimeouts=[],this.eventManager&&this.eventManager._listeners&&(Object.keys(this.eventManager._listeners).forEach(t=>{this.eventManager._listeners[t]=[]}),this.eventManager._listeners=null),this.core3D&&this.core3D.destroy(),this.particleSystem&&this.particleSystem.destroy(),this.danceChoreographer&&(this.danceChoreographer.destroy(),this.danceChoreographer=null),this._canvasLayerManager&&(this._canvasLayerManager.destroy(),this._canvasLayerManager=null),this.container=null,this.webglCanvas=null,this.canvas2D=null,this.ctx2D=null,this.config=null,this.errorBoundary=null,this.currentGesture=null}}const q_=()=>"undefined"==typeof window;var Y_=Object.freeze({__proto__:null,HDRLoader:class extends Yl{constructor(t){super(t),this.type=it}parse(t){const e=function(t,e){switch(t){case 1:throw new Error("THREE.HDRLoader: Read Error: "+(e||""));case 2:throw new Error("THREE.HDRLoader: Write Error: "+(e||""));case 3:throw new Error("THREE.HDRLoader: Bad File Format: "+(e||""));default:throw new Error("THREE.HDRLoader: Memory Error: "+(e||""))}},i=function(t,e,i){e=e||1024;let n=t.pos,s=-1,a=0,r="",o=String.fromCharCode.apply(null,new Uint16Array(t.subarray(n,n+128)));for(;0>(s=o.indexOf("\n"))&&a<e&&n<t.byteLength;)r+=o,a+=o.length,n+=128,o+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(n,n+128)));return-1<s&&(t.pos+=a+s+1,r+o.slice(0,s))},n=function(t,e,i,n){const s=t[e+3],a=Math.pow(2,s-128)/255;i[n+0]=t[e+0]*a,i[n+1]=t[e+1]*a,i[n+2]=t[e+2]*a,i[n+3]=1},s=function(t,e,i,n){const s=t[e+3],a=Math.pow(2,s-128)/255;i[n+0]=Xn.toHalfFloat(Math.min(t[e+0]*a,65504)),i[n+1]=Xn.toHalfFloat(Math.min(t[e+1]*a,65504)),i[n+2]=Xn.toHalfFloat(Math.min(t[e+2]*a,65504)),i[n+3]=Xn.toHalfFloat(1)},a=new Uint8Array(t);a.pos=0;const r=function(t){const n=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,r=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,o={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,h;for((t.pos>=t.byteLength||!(l=i(t)))&&e(1,"no header found"),(h=l.match(/^#\?(\S+)/))||e(3,"bad initial token"),o.valid|=1,o.programtype=h[1],o.string+=l+"\n";l=i(t),!1!==l;)if(o.string+=l+"\n","#"!==l.charAt(0)){if((h=l.match(n))&&(o.gamma=parseFloat(h[1])),(h=l.match(s))&&(o.exposure=parseFloat(h[1])),(h=l.match(a))&&(o.valid|=2,o.format=h[1]),(h=l.match(r))&&(o.valid|=4,o.height=parseInt(h[1],10),o.width=parseInt(h[2],10)),2&o.valid&&4&o.valid)break}else o.comments+=l+"\n";return 2&o.valid||e(3,"missing format specifier"),4&o.valid||e(3,"missing image size specifier"),o}(a),o=r.width,l=r.height,h=function(t,i,n){const s=i;if(s<8||s>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);s!==(t[2]<<8|t[3])&&e(3,"wrong scanline width");const a=new Uint8Array(4*i*n);a.length||e(4,"unable to allocate buffer space");let r=0,o=0;const l=4*s,h=new Uint8Array(4),c=new Uint8Array(l);let u=n;for(;u>0&&o<t.byteLength;){o+4>t.byteLength&&e(1),h[0]=t[o++],h[1]=t[o++],h[2]=t[o++],h[3]=t[o++],2==h[0]&&2==h[1]&&(h[2]<<8|h[3])==s||e(3,"bad rgbe scanline format");let i,n=0;for(;n<l&&o<t.byteLength;){i=t[o++];const s=i>128;if(s&&(i-=128),(0===i||n+i>l)&&e(3,"bad scanline data"),s){const e=t[o++];for(let t=0;t<i;t++)c[n++]=e}else c.set(t.subarray(o,o+i),n),n+=i,o+=i}const d=s;for(let t=0;t<d;t++){let e=0;a[r]=c[t+e],e+=s,a[r+1]=c[t+e],e+=s,a[r+2]=c[t+e],e+=s,a[r+3]=c[t+e],r+=4}u--}return a}(a.subarray(a.pos),o,l);let c,u,d;switch(this.type){case et:d=h.length/4;const t=new Float32Array(4*d);for(let e=0;e<d;e++)n(h,4*e,t,4*e);c=t,u=et;break;case it:d=h.length/4;const e=new Uint16Array(4*d);for(let t=0;t<d;t++)s(h,4*t,e,4*t);c=e,u=it;break;default:throw new Error("THREE.HDRLoader: Unsupported type: "+this.type)}return{width:o,height:l,data:c,header:r.string,gamma:r.gamma,exposure:r.exposure,type:u}}setDataType(t){return this.type=t,this}load(t,e,i,n){return super.load(t,function(t,i){switch(t.type){case et:case it:t.colorSpace=ae,t.minFilter=X,t.magFilter=X,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,i)},i,n)}}});export{V_ as AudioInterpreter,F_ as CORE_GEOMETRIES,jM as Core3DManager,sM as CrystalSoul,N_ as ENGINE_VOCABULARY,X_ as EmotiveMascot3D,rg as GROOVE_PRESETS,wM as GeometryCache,H_ as LLM_ENDPOINTS,bm as MOON_PHASES,lg as Rhythm3DAdapter,$M as SSSPresets,Pm as animateMoonPhase,ZM as applySSSPreset,W_ as audioInterpreter,um as blendModeNames,O_ as createCrystal,z_ as createDiamond,xm as createMoon,Em as createMoonCrescentMaterial,Tm as createMoonFallbackMaterial,Sm as createMoonMaterial,k_ as createSphere,Om as createSunGeometry,km as createSunMaterial,X_ as default,U_ as disposeCoreGeometries,wm as disposeMoon,Fm as disposeSun,pm as getBlendModeIndex,dm as getBlendModeName,Mm as getMoonPhaseNames,_m as getPhaseFromProgress,QM as getSSSPreset,JM as getSSSPresetNames,q_ as isSSR,hg as rhythm3DAdapter,Am as setMoonPhase,Rm as updateCrescentShadow,Dm as updateMoonGlow,zm as updateSunMaterial};
//# sourceMappingURL=emotive-mascot-3d.bundled.js.map
