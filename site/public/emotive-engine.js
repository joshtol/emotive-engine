/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  CANVAS MANAGER  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Canvas Manager - High-DPI Rendering & Canvas Lifecycle
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module CanvasManager
 * @changelog 2.1.0 - Added resize callback system for visual resampling
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The FOUNDATION of visual rendering. Handles canvas setup, high-DPI scaling,       
 * ║ resize events, and provides optimized 2D context for smooth animations.           
 * ║ Ensures crisp rendering on Retina displays and manages canvas lifecycle.          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 CANVAS FEATURES                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Device Pixel Ratio (DPR) scaling for Retina displays                            
 * │ • Automatic resize handling with debouncing                                       
 * │ • Resize callback system for component notification                               
 * │ • Optimized 2D context settings for animations                                    
 * │ • Center point calculation for orb positioning                                    
 * │ • Clean canvas clearing with proper scaling                                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ CONTEXT OPTIMIZATIONS                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • alpha: true               - Enables transparency                                
 * │ • desynchronized: true      - Better animation performance                        
 * │ • willReadFrequently: false - We don't read pixels                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */
class CanvasManager {
    constructor(canvas) {
        this.canvas = canvas;
        // Get context with optimal settings for particle rendering
        this.ctx = canvas.getContext('2d', {
            alpha: true,
            desynchronized: true,  // Better performance for animations
            willReadFrequently: false  // We're not reading pixels
        });
        this.dpr = window.devicePixelRatio || 1;
        this.width = 0;
        this.height = 0;
        this.centerX = 0;
        this.centerY = 0;
        
        // Render size configuration
        this.renderSize = null;  // { width: number, height: number } - if set, use exact dimensions
        
        // Resize callbacks
        this.resizeCallbacks = [];
        
        // Bind resize handler
        this.handleResize = this.handleResize.bind(this);
        window.addEventListener('resize', this.handleResize);
        
        // Initial resize
        this.resize();
    }

    /**
     * Handles canvas resizing with proper high-DPI support
     */
    resize() {
        // Check if render size is explicitly set
        if (this.renderSize && this.renderSize.width && this.renderSize.height) {
            // Use exact render dimensions
            this.width = this.renderSize.width;
            this.height = this.renderSize.height;
            
            // Set actual canvas buffer size (no DPR scaling for fixed render size)
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            
            // No DPR scaling needed for fixed render size
            // The browser will handle the scaling automatically
        } else if (this.canvas.hasAttribute('width') && this.canvas.hasAttribute('height')) {
            // Use the explicit canvas dimensions from attributes
            const attrWidth = parseInt(this.canvas.getAttribute('width'), 10);
            const attrHeight = parseInt(this.canvas.getAttribute('height'), 10);

            // Check if attributes contain DPR-scaled values by comparing to CSS dimensions
            const rect = this.canvas.getBoundingClientRect();
            const cssWidth = rect.width;
            const cssHeight = rect.height;

            // If attribute dimensions are significantly larger than CSS dimensions,
            // assume they're DPR-scaled and we need context scaling
            const isDprScaled = (attrWidth > cssWidth * 1.5) || (attrHeight > cssHeight * 1.5);

            if (isDprScaled) {
                // Attributes contain DPR-scaled buffer dimensions
                // Use CSS dimensions as logical size
                this.width = cssWidth;
                this.height = cssHeight;

                // Use attribute values as buffer size
                this.canvas.width = attrWidth;
                this.canvas.height = attrHeight;

                // Scale context to match DPR
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(this.dpr, this.dpr);
            } else {
                // Attributes contain logical dimensions (e.g., Cherokee cards)
                // Use attribute dimensions as base size
                this.width = attrWidth;
                this.height = attrHeight;

                // Set actual canvas buffer size (no DPR scaling)
                this.canvas.width = attrWidth;
                this.canvas.height = attrHeight;

                // No context scaling needed
            }
        } else {
            // For responsive canvases, use the bounding rect
            const rect = this.canvas.getBoundingClientRect();

            // Set display size (CSS pixels)
            this.width = rect.width;
            this.height = rect.height;

            // Set actual size in memory (scaled for high-DPI)
            this.canvas.width = this.width * this.dpr;
            this.canvas.height = this.height * this.dpr;

            // CRITICAL: Reset context transform before applying DPI scale
            // This prevents cumulative scaling on resize
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);

            // Scale the drawing context for high-DPI rendering
            this.ctx.scale(this.dpr, this.dpr);
        }
        
        // Update center coordinates
        this.centerX = this.width / 2;
        this.centerY = this.height / 2;
        
        //     dpr: this.dpr,
        //     center: { x: this.centerX, y: this.centerY }
        // });
        
        // Trigger resize callbacks
        this.resizeCallbacks.forEach(callback => {
            try {
                callback(this.width, this.height, this.dpr);
            } catch (_error) {
                // Ignore callback errors
            }
        });
    }
    
    /**
     * Register a callback to be called on canvas resize
     * @param {Function} callback - Function to call with (width, height, dpr) parameters
     */
    onResize(callback) {
        if (typeof callback === 'function') {
            this.resizeCallbacks.push(callback);
        }
    }

    /**
     * Debounced resize handler to prevent excessive resize calls
     */
    handleResize() {
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = setTimeout(() => {
            // Only resize if render size is not explicitly set
            if (!this.renderSize || !this.renderSize.width || !this.renderSize.height) {
                this.resize();
            }
        }, 100);
    }

    /**
     * Sets the render size for the canvas
     */
    setRenderSize(width, height) {
        this.renderSize = { width, height };
        this.resize(); // Apply the new size immediately
    }

    /**
     * Clears the entire canvas
     */
    clear() {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }

    /**
     * Gets the center coordinates of the canvas
     * @returns {Object} Object with x and y center coordinates
     */
    getCenter() {
        return {
            x: this.centerX,
            y: this.centerY
        };
    }

    /**
     * Sets transform for drawing operations
     * @param {number} x - X translation
     * @param {number} y - Y translation  
     * @param {number} scale - Scale factor
     * @param {number} rotation - Rotation in radians
     */
    setTransform(x = 0, y = 0, scale = 1, rotation = 0) {
        this.ctx.save();
        this.ctx.translate(x, y);
        this.ctx.rotate(rotation);
        this.ctx.scale(scale, scale);
    }

    /**
     * Restores the previous transform state
     */
    restoreTransform() {
        this.ctx.restore();
    }

    /**
     * Gets the 2D rendering context
     * @returns {CanvasRenderingContext2D} The canvas 2D context
     */
    getContext() {
        return this.ctx;
    }

    /**
     * Gets canvas dimensions
     * @returns {Object} Object with width and height
     */
    getDimensions() {
        return {
            width: this.width,
            height: this.height
        };
    }

    /**
     * Cleanup method to remove event listeners
     */
    destroy() {
        window.removeEventListener('resize', this.handleResize);
        clearTimeout(this.resizeTimeout);
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  ERROR BOUNDARY  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Error Boundary - Error Handling & Recovery System
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module ErrorBoundary
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The SAFETY NET of the Emotive Engine. Catches errors, provides fallbacks,         
 * ║ logs issues for debugging, and attempts recovery to keep the animation            
 * ║ running even when things go wrong. Never let the orb die!                         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🛡️ ERROR HANDLING FEATURES                                                        
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Try-catch wrapping for all critical functions                                   
 * │ • Safe default values for all emotional states                                    
 * │ • Error logging with context and timestamps                                       
 * │ • Automatic error suppression after threshold                                     
 * │ • Recovery attempts with exponential backoff                                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 FALLBACK VALUES                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • emotion       : 'neutral' (safe default state)                                  
 * │ • gesture       : null (no animation)                                             
 * │ • audioLevel    : 0 (silent)                                                      
 * │ • particleCount : 0 (no particles)                                                
 * │ • glowIntensity : 0.7 (moderate glow)                                             
 * │ • color         : '#B0B0B0' (neutral gray)                                        
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 VALIDATION LISTS                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ VALID EMOTIONS:                                                                   
 * │   neutral, joy, sadness, anger, fear, surprise, disgust, love,                    
 * │   suspicion, resting, connecting, thinking, speaking, zen, focused                
 * │                                                                                    
 * │ VALID UNDERTONES:                                                                 
 * │   nervous, confident, tired, intense, subdued                                     
 * │                                                                                    
 * │ VALID GESTURES:                                                                    
 * │   bounce, pulse, shake, spin, nod, tilt, expand, contract, flash,                 
 * │   drift, breathe, wave, slowBlink, jump, breathHold                               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚠️  ERROR THRESHOLDS                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Max errors in log      : 10 (then rotates)                                      
 * │ • Errors before suppress : 3 per context                                          
 * │ • Recovery max attempts  : 3                                                      
 * │ • Recovery backoff       : 100ms * 2^attempt                                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                           USING ERROR BOUNDARY                                    
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ // Wrap any risky function:                                                       
 * ║ const safeFunction = errorBoundary.wrap(riskyFunction, 'context', fallback);      
 * ║                                                                                    
 * ║ // Validate input:                                                                
 * ║ const validEmotion = errorBoundary.validateInput(input, 'emotion', 'neutral');    
 * ║                                                                                    
 * ║ // Attempt recovery:                                                              
 * ║ await errorBoundary.attemptRecovery('render', retryFn, 3);                        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */
class ErrorBoundary {
    constructor() {
        this.errors = [];
        this.maxErrors = 10;
        this.errorCounts = new Map();
        
        // Safe default values for various contexts
        this.defaults = {
            emotion: 'neutral',
            gesture: null,
            audioLevel: 0,
            particleCount: 0,
            glowIntensity: 0.7,
            coreSize: 1.0,
            breathRate: 1.0,
            color: '#B0B0B0'
        };
    }

    /**
     * Wraps a function with error handling
     * @param {Function} fn - Function to wrap
     * @param {string} context - Context description for error logging
     * @param {*} fallbackValue - Value to return on error
     * @returns {Function} Wrapped function
     */
    wrap(fn, context, fallbackValue = null) {
        return (...args) => {
            try {
                return fn(...args);
            } catch (error) {
                this.logError(error, context);
                return fallbackValue !== null ? fallbackValue : this.getDefault(context);
            }
        };
    }

    /**
     * Logs an error with context and timestamp
     * @param {Error} error - The error object
     * @param {string} context - Context where the error occurred
     */
    logError(error, context) {
        const timestamp = new Date().toISOString();
        const errorEntry = {
            timestamp,
            context,
            message: error.message,
            stack: error.stack
        };

        // Add to error log
        this.errors.push(errorEntry);
        
        // Maintain error count per context
        const count = this.errorCounts.get(context) || 0;
        this.errorCounts.set(context, count + 1);

        // Rotate error log if it gets too large
        if (this.errors.length > this.maxErrors) {
            this.errors.shift();
        }
    }

    /**
     * Gets a safe default value for a given context
     * @param {string} context - The context to get default for
     * @returns {*} Safe default value
     */
    getDefault(context) {
        // Context-specific defaults
        const contextDefaults = {
            'emotion-transition': this.defaults.emotion,
            'gesture-execution': this.defaults.gesture,
            'audio-processing': this.defaults.audioLevel,
            'particle-system': this.defaults.particleCount,
            'rendering': {
                glowIntensity: this.defaults.glowIntensity,
                coreSize: this.defaults.coreSize,
                color: this.defaults.color
            },
            'canvas-operations': null,
            'state-management': this.defaults.emotion
        };

        return Object.prototype.hasOwnProperty.call(contextDefaults, context) ? contextDefaults[context] : null;
    }

    /**
     * Validates input parameters and returns safe values
     * @param {*} value - Value to validate
     * @param {string} type - Expected type
     * @param {*} defaultValue - Default value if validation fails
     * @returns {*} Validated value or default
     */
    validateInput(value, type, defaultValue) {
        try {
            switch (type) {
            case 'emotion': {
                const validEmotions = ['neutral', 'joy', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'love', 'euphoria'];
                return validEmotions.includes(value) ? value : defaultValue;
            }
                
            case 'undertone': {
                const validUndertones = ['nervous', 'confident', 'tired', 'intense', 'subdued'];
                return value === null || validUndertones.includes(value) ? value : null;
            }
                
            case 'gesture': {
                const validGestures = ['bounce', 'pulse', 'shake', 'spin', 'nod', 'tilt', 'expand', 'contract', 'flash', 'drift'];
                return validGestures.includes(value) ? value : defaultValue;
            }
                
            case 'number':
                return typeof value === 'number' && !isNaN(value) ? value : defaultValue;
                
            case 'string':
                return typeof value === 'string' ? value : defaultValue;
                
            case 'boolean':
                return typeof value === 'boolean' ? value : defaultValue;
                
            default:
                return value !== undefined && value !== null ? value : defaultValue;
            }
        } catch (error) {
            this.logError(error, 'input-validation');
            return defaultValue;
        }
    }

    /**
     * Checks if a context has exceeded error threshold
     * @param {string} context - Context to check
     * @param {number} threshold - Error threshold (default: 5)
     * @returns {boolean} True if threshold exceeded
     */
    hasExceededThreshold(context, threshold = 5) {
        return (this.errorCounts.get(context) || 0) >= threshold;
    }

    /**
     * Gets error statistics
     * @returns {Object} Error statistics
     */
    getErrorStats() {
        return {
            totalErrors: this.errors.length,
            errorsByContext: Object.fromEntries(this.errorCounts),
            recentErrors: this.errors.slice(-5)
        };
    }

    /**
     * Clears error history
     */
    clearErrors() {
        this.errors = [];
        this.errorCounts.clear();
    }

    /**
     * Attempts to recover from a failed operation
     * @param {string} operation - The operation that failed
     * @param {Function} retryFn - Function to retry
     * @param {number} maxRetries - Maximum retry attempts
     * @returns {Promise} Recovery attempt result
     */
    async attemptRecovery(operation, retryFn, maxRetries = 3) {
        let attempts = 0;
        
        while (attempts < maxRetries) {
            try {
                return await retryFn();
            } catch (error) {
                attempts++;
                this.logError(error, `recovery-${operation}-attempt-${attempts}`);
                
                if (attempts >= maxRetries) {
                    throw new Error(`Recovery failed for ${operation} after ${maxRetries} attempts`);
                }
                
                // Exponential backoff
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempts) * 100));
            }
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  COLOR UTILS  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Color Utils - Color Interpolation & Manipulation
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module ColorUtils
 * @changelog 2.1.0 - Added undertone saturation modifiers for dynamic depth
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The COLOR SCIENCE module of the engine. Provides smooth color transitions         
 * ║ between emotional states using HSL interpolation for perceptually uniform         
 * ║ transitions that feel natural and emotionally resonant.                           
 * ║                                                                                    
 * ║ NEW: Undertone saturation system creates dynamic depth by adjusting saturation    
 * ║ based on emotional undertones (intense → oversaturated, subdued → desaturated)    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 COLOR OPERATIONS                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Hex to RGB/HSL conversion                                                       
 * │ • RGB to Hex/HSL conversion                                                       
 * │ • HSL interpolation for smooth transitions                                        
 * │ • Color mixing and blending                                                       
 * │ • Luminance calculations                                                          
 * │ • Perceptually uniform color shifts                                               
 * │ • Undertone-based saturation adjustments                                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🌈 UNDERTONE SATURATION SYSTEM                                                    
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ Undertones dynamically adjust color saturation to create emotional depth:         
 * │                                                                                    
 * │ • INTENSE   : +60% saturation - Electric, vibrant, overwhelming                   
 * │ • CONFIDENT : +30% saturation - Bold, present, assertive                          
 * │ • NERVOUS   : +15% saturation - Slightly heightened, anxious energy               
 * │ • CLEAR     :   0% saturation - Normal midtone, balanced state                    
 * │ • TIRED     : -20% saturation - Washed out, fading, depleted                      
 * │ • SUBDUED   : -50% saturation - Ghostly, barely there, withdrawn                  
 * │                                                                                    
 * │ This creates a visual hierarchy where emotional intensity directly affects        
 * │ the vibrancy and presence of colors, making the mascot's state immediately        
 * │ readable through color alone.                                                     
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Converts hex color to RGB values
 * @param {string} hex - Hex color string (e.g., '#FF0000')
 * @returns {Object} RGB object with r, g, b properties
 */
function hexToRgb(hex) {
    // Remove # if present
    hex = hex.replace('#', '');
    
    // Handle 3-digit hex
    if (hex.length === 3) {
        hex = hex.split('').map(char => char + char).join('');
    }
    
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    return { r, g, b };
}

/**
 * Converts RGB values to hex color
 * @param {number} r - Red component (0-255)
 * @param {number} g - Green component (0-255)
 * @param {number} b - Blue component (0-255)
 * @returns {string} Hex color string
 */
function rgbToHex(r, g, b) {
    const toHex = component => {
        const hex = Math.round(Math.max(0, Math.min(255, component))).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
    };
    
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

/**
 * Converts RGB to HSL color space
 * @param {number} r - Red component (0-255)
 * @param {number} g - Green component (0-255)
 * @param {number} b - Blue component (0-255)
 * @returns {Object} HSL object with h, s, l properties
 */
function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    
    if (max === min) {
        h = s = 0; // achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    
    return { h: h * 360, s: s * 100, l: l * 100 };
}

/**
 * Converts HSL to RGB color space
 * @param {number} h - Hue (0-360)
 * @param {number} s - Saturation (0-100)
 * @param {number} l - Lightness (0-100)
 * @returns {Object} RGB object with r, g, b properties
 */
function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;
    
    const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    };
    
    let r, g, b;
    
    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/**
 * Interpolates between two colors in RGB space
 * @param {string} color1 - Start color (hex)
 * @param {string} color2 - End color (hex)
 * @param {number} progress - Interpolation progress (0-1)
 * @returns {string} Interpolated color (hex)
 */
function interpolateRgb(color1, color2, progress) {
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    
    const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * progress);
    const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * progress);
    const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * progress);
    
    return rgbToHex(r, g, b);
}

/**
 * Interpolates between two colors in HSL space (better for emotional transitions)
 * @param {string} color1 - Start color (hex)
 * @param {string} color2 - End color (hex)
 * @param {number} progress - Interpolation progress (0-1)
 * @returns {string} Interpolated color (hex)
 */
function interpolateHsl(color1, color2, progress) {
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    const hsl1 = rgbToHsl(rgb1.r, rgb1.g, rgb1.b);
    const hsl2 = rgbToHsl(rgb2.r, rgb2.g, rgb2.b);
    
    // Handle hue interpolation (shortest path around color wheel)
    const h1 = hsl1.h;
    let h2 = hsl2.h;
    const hDiff = h2 - h1;
    
    if (hDiff > 180) {
        h2 -= 360;
    } else if (hDiff < -180) {
        h2 += 360;
    }
    
    const h = h1 + (h2 - h1) * progress;
    const s = hsl1.s + (hsl2.s - hsl1.s) * progress;
    const l = hsl1.l + (hsl2.l - hsl1.l) * progress;
    
    // Normalize hue
    const normalizedH = ((h % 360) + 360) % 360;
    
    const rgb = hslToRgb(normalizedH, s, l);
    return rgbToHex(rgb.r, rgb.g, rgb.b);
}

/**
 * Creates an RGBA color string
 * @param {string} hex - Hex color
 * @param {number} alpha - Alpha value (0-1)
 * @returns {string} RGBA color string
 */
function hexToRgba(hex, alpha = 1) {
    const rgb = hexToRgb(hex);
    return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
}

/**
 * Adjusts the brightness of a color
 * @param {string} hex - Hex color
 * @param {number} factor - Brightness factor (0.5 = darker, 1.5 = brighter)
 * @returns {string} Adjusted color (hex)
 */
function adjustBrightness(hex, factor) {
    const rgb = hexToRgb(hex);
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    
    hsl.l = Math.max(0, Math.min(100, hsl.l * factor));
    
    const adjustedRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return rgbToHex(adjustedRgb.r, adjustedRgb.g, adjustedRgb.b);
}

/**
 * Adjusts the saturation of a color
 * @param {string} hex - Hex color
 * @param {number} factor - Saturation factor (0.5 = less saturated, 1.5 = more saturated)
 * @returns {string} Adjusted color (hex)
 */
function adjustSaturation(hex, factor) {
    const rgb = hexToRgb(hex);
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    
    hsl.s = Math.max(0, Math.min(100, hsl.s * factor));
    
    const adjustedRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    return rgbToHex(adjustedRgb.r, adjustedRgb.g, adjustedRgb.b);
}

/**
 * Gets the luminance of a color (for contrast calculations)
 * @param {string} hex - Hex color
 * @returns {number} Luminance value (0-1)
 */
function getLuminance(hex) {
    const rgb = hexToRgb(hex);
    
    // Convert to linear RGB
    const toLinear = component => {
        const c = component / 255;
        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    };
    
    const r = toLinear(rgb.r);
    const g = toLinear(rgb.g);
    const b = toLinear(rgb.b);
    
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

/**
 * Calculates contrast ratio between two colors
 * @param {string} color1 - First color (hex)
 * @param {string} color2 - Second color (hex)
 * @returns {number} Contrast ratio (1-21)
 */
function getContrastRatio(color1, color2) {
    const lum1 = getLuminance(color1);
    const lum2 = getLuminance(color2);
    
    const brightest = Math.max(lum1, lum2);
    const darkest = Math.min(lum1, lum2);
    
    return (brightest + 0.05) / (darkest + 0.05);
}

/**
 * Undertone saturation modifiers for dynamic emotional depth
 * Maps undertone names to saturation adjustment factors
 */
const UNDERTONE_SATURATION = {
    intense: 1.6,    // +60% saturation - Electric, overwhelming
    confident: 1.3,  // +30% saturation - Bold, present
    nervous: 1.15,   // +15% saturation - Slightly heightened
    clear: 1.0,      // No change - Normal midtone
    tired: 0.8,      // -20% saturation - Washed out, fading
    subdued: 0.5     // -50% saturation - Ghostly, barely there
};

/**
 * Applies undertone saturation adjustment to a color
 * @param {string} hex - Base color
 * @param {string} undertone - Undertone name (intense, confident, nervous, clear, tired, subdued)
 * @returns {string} Adjusted color with undertone saturation applied
 */
function applyUndertoneSaturation(hex, undertone) {
    if (!undertone || undertone === 'clear') {
        return hex; // No adjustment for clear or missing undertone
    }
    
    const factor = UNDERTONE_SATURATION[undertone.toLowerCase()];
    if (!factor || factor === 1.0) {
        return hex;
    }
    
    return adjustSaturation(hex, factor);
}

/**
 * Applies undertone saturation to an array of colors (for particle systems)
 * @param {Array} colors - Array of colors (can be strings or objects with color property)
 * @param {string} undertone - Undertone name
 * @returns {Array} Adjusted color array with undertone saturation applied
 */
function applyUndertoneSaturationToArray(colors, undertone) {
    if (!colors || !Array.isArray(colors)) return colors;
    if (!undertone || undertone === 'clear') return colors;
    
    return colors.map(colorItem => {
        if (typeof colorItem === 'string') {
            // Simple color string
            return applyUndertoneSaturation(colorItem, undertone);
        } else if (colorItem && typeof colorItem === 'object' && colorItem.color) {
            // Weighted color object
            return {
                ...colorItem,
                color: applyUndertoneSaturation(colorItem.color, undertone)
            };
        }
        return colorItem;
    });
}

/**
 * Gets the saturation factor for an undertone
 * @param {string} undertone - Undertone name
 * @returns {number} Saturation multiplication factor
 */
function getUndertoneSaturationFactor(undertone) {
    if (!undertone) return 1.0;
    return UNDERTONE_SATURATION[undertone.toLowerCase()] || 1.0;
}

/**
 * Emotional color palette for the mascot system
 */
const EMOTIONAL_COLORS = {
    neutral: '#B0B0B0',
    joy: '#FFD700',
    sadness: '#4169E1',
    anger: '#DC143C',
    fear: '#8B008B',
    surprise: '#FF8C00',
    disgust: '#9ACD32',
    love: '#FF69B4'
};

/**
 * Gets RGB values for emotional colors (for performance)
 */
const EMOTIONAL_COLORS_RGB = Object.fromEntries(
    Object.entries(EMOTIONAL_COLORS).map(([emotion, hex]) => {
        const rgb = hexToRgb(hex);
        return [emotion, `${rgb.r}, ${rgb.g}, ${rgb.b}`];
    })
);

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  EASING  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Easing Functions - Smooth Animation Transitions
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module Easing
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The MOTION MATHEMATICS of the engine. Provides easing functions that create       
 * ║ natural, organic movement patterns for emotional transitions and gestures,         
 * ║ making the mascot feel alive and responsive rather than mechanical.               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎢 EASING CURVES                                                                  
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Linear: Constant speed, no acceleration                                         
 * │ • Quadratic: Gentle acceleration/deceleration                                     
 * │ • Cubic: Moderate acceleration/deceleration                                       
 * │ • Elastic: Spring-like overshoot and bounce                                       
 * │ • Bounce: Realistic bouncing effect                                               
 * │ • Custom: Apply any easing by name                                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Linear easing - no acceleration
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function linear(t) {
    return t;
}

/**
 * Ease out quadratic - decelerating to zero velocity
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutQuad(t) {
    return t * (2 - t);
}

/**
 * Ease in quadratic - accelerating from zero velocity
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInQuad(t) {
    return t * t;
}

/**
 * Ease in-out quadratic - acceleration until halfway, then deceleration
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInOutQuad(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

/**
 * Ease out cubic - decelerating to zero velocity (smoother than quad)
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
}

/**
 * Ease in cubic - accelerating from zero velocity
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInCubic(t) {
    return t * t * t;
}

/**
 * Ease in-out cubic - acceleration until halfway, then deceleration
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

/**
 * Ease out elastic - elastic snap effect
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutElastic(t) {
    const c4 = (2 * Math.PI) / 3;
    return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
}

/**
 * Ease out bounce - bouncing effect
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutBounce(t) {
    const n1 = 7.5625;
    const d1 = 2.75;

    if (t < 1 / d1) {
        return n1 * t * t;
    } else if (t < 2 / d1) {
        return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
        return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
        return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
}

/**
 * Ease in-out back - slight overshoot effect
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInOutBack(t) {
    const c1 = 1.70158;
    const c2 = c1 * 1.525;

    return t < 0.5
        ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
        : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
}

/**
 * Ease out sine - sinusoidal easing
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeOutSine(t) {
    return Math.sin((t * Math.PI) / 2);
}

/**
 * Ease in-out sine - sinusoidal easing with smooth start and end
 * @param {number} t - Progress (0 to 1)
 * @returns {number} Eased value
 */
function easeInOutSine(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
}

/**
 * Gets an easing function by name
 * @param {string} name - Name of the easing function
 * @returns {Function} Easing function
 */
function getEasingFunction(name) {
    const easingFunctions = {
        linear,
        easeOutQuad,
        easeInQuad,
        easeInOutQuad,
        easeOutCubic,
        easeInCubic,
        easeInOutCubic,
        easeOutElastic,
        easeOutBounce,
        easeInOutBack,
        easeOutSine,
        easeInOutSine
    };

    return easingFunctions[name] || linear;
}

/**
 * Applies easing to a value between start and end
 * @param {number} progress - Progress (0 to 1)
 * @param {number} start - Start value
 * @param {number} end - End value
 * @param {string|Function} easing - Easing function name or function
 * @returns {number} Eased value between start and end
 */
function applyEasing(progress, start, end, easing = 'linear') {
    const easingFn = typeof easing === 'string' ? getEasingFunction(easing) : easing;
    const easedProgress = easingFn(Math.max(0, Math.min(1, progress)));
    return start + (end - start) * easedProgress;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Emotion Plugin Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bridge between plugin system and emotion registry
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module emotions/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Adapter for dynamic emotion registration from plugins.                            
 * ║ • Maintains separate registry for plugin emotions                                 
 * ║ • Validates emotion definitions for required properties                           
 * ║ • Provides legacy format conversion for older plugins                             
 * ║ • Enables runtime registration and unregistration                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Plugin emotion registry
 */
const pluginEmotions = new Map();

/**
 * Register a plugin emotion
 * @param {string} name - Emotion name
 * @param {Object} emotionDef - Emotion definition object
 */
function registerPluginEmotion(name, emotionDef) {
    // Ensure emotion has required properties
    if (!emotionDef.color) {
        return false;
    }
    
    // Add name if not present
    if (!emotionDef.name) {
        emotionDef.name = name;
    }
    
    // Ensure visual and modifiers exist
    if (!emotionDef.visual) {
        emotionDef.visual = {
            primaryColor: emotionDef.color,
            particleCount: emotionDef.particleCount || 15,
            particleSize: emotionDef.particleSize || { min: 2, max: 6 }
        };
    }
    
    if (!emotionDef.modifiers) {
        emotionDef.modifiers = {
            speed: 1.0,
            amplitude: 1.0,
            intensity: 1.0
        };
    }
    
    pluginEmotions.set(name, emotionDef);
    
    return true;
}

/**
 * Unregister a plugin emotion
 * @param {string} name - Emotion name to remove
 */
function unregisterPluginEmotion(name) {
    if (pluginEmotions.has(name)) {
        pluginEmotions.delete(name);
        
        return true;
    }
    return false;
}

/**
 * Get a plugin emotion by name
 * @param {string} name - Emotion name
 * @returns {Object|null} Emotion object or null if not found
 */
function getPluginEmotion(name) {
    return pluginEmotions.get(name) || null;
}

/**
 * Get all plugin emotion names
 * @returns {Array<string>} Array of emotion names
 */
function getAllPluginEmotions() {
    return Array.from(pluginEmotions.keys());
}

/**
 * Clear all plugin emotions
 */
function clearPluginEmotions() {
    pluginEmotions.clear();
}

/**
 * Convert legacy plugin emotion format to new format
 * @param {Object} legacyEmotion - Old format emotion
 * @returns {Object} New format emotion
 */
function createLegacyAdapter$2(legacyEmotion) {
    return {
        name: legacyEmotion.name || 'unknown',
        emoji: legacyEmotion.emoji || '🔌',
        color: legacyEmotion.primaryColor || legacyEmotion.color || '#7B68EE',
        energy: legacyEmotion.energy || 'medium',
        
        visual: {
            primaryColor: legacyEmotion.primaryColor || legacyEmotion.color || '#7B68EE',
            secondaryColor: legacyEmotion.secondaryColor,
            particleCount: legacyEmotion.particleCount || legacyEmotion.particleRate || 15,
            particleSize: legacyEmotion.particleSize || { min: 2, max: 6 },
            glowIntensity: legacyEmotion.glowIntensity || 0.5,
            trailLength: legacyEmotion.trailLength || 5,
            pulseRate: legacyEmotion.pulseRate || legacyEmotion.breathRate || 1.0
        },
        
        particles: {
            behavior: legacyEmotion.particleBehavior || 'ambient',
            density: legacyEmotion.particleDensity || 'medium',
            speed: legacyEmotion.particleSpeed || 'normal'
        },
        
        modifiers: {
            speed: legacyEmotion.speedMultiplier || 1.0,
            amplitude: legacyEmotion.amplitudeMultiplier || 1.0,
            intensity: legacyEmotion.intensityMultiplier || 1.0,
            smoothness: legacyEmotion.smoothnessMultiplier || 1.0
        },
        
        gestures: legacyEmotion.gestures || [],
        transitions: legacyEmotion.transitions || {}
    };
}

// Export adapter interface
var pluginAdapter$2 = {
    registerPluginEmotion,
    unregisterPluginEmotion,
    getPluginEmotion,
    getAllPluginEmotions,
    clearPluginEmotions,
    createLegacyAdapter: createLegacyAdapter$2
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Neutral Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Neutral emotional state - calm baseline
 * @author Emotive Engine Team
 * @module emotions/states/neutral
 */

/**
 * Neutral emotion configuration
 * The default calm state, baseline for all other emotions
 */
var neutral = {
    name: 'neutral',
    emoji: '😐',
    description: 'Calm, balanced emotional state',
    
    // Visual properties
    visual: {
        glowColor: '#00BCD4',        // Cyan baseline (more modern)
        glowIntensity: 0.9,          // Slightly softer glow
        particleRate: 2,              // Minimal particle generation
        minParticles: 8,             // Baseline particle presence
        maxParticles: 10,            // Limited particle count
        particleBehavior: 'ambient', // Gentle floating behavior
        breathRate: 1.0,             // Normal, relaxed breathing
        breathDepth: 0.08,           // Subtle breath variation
        coreJitter: false,           // Stable, still core
        particleColors: [
            { color: '#00BCD4', weight: 25 },  // Primary cyan
            { color: '#00ACC1', weight: 20 },  // Darker cyan
            { color: '#26C6DA', weight: 15 },  // Light cyan
            { color: '#B2EBF2', weight: 15 },  // Pale cyan highlight
            { color: '#0097A7', weight: 10 },  // Deep cyan shadow
            { color: '#80DEEA', weight: 10 },  // Cyan light
            { color: '#E0F7FA', weight: 5 }    // Very pale cyan
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.0,        // Baseline movement speed
        amplitude: 1.0,    // Standard motion range
        intensity: 1.0,    // Default force level
        smoothness: 1.0,   // Natural motion flow
        regularity: 1.0    // Consistent patterns
    },
    
    // Typical gestures for this emotion
    typicalGestures: [
        'breathe',   // Calm breathing
        'float',     // Gentle floating
        'idle',      // Idle animation
        'blink'      // Occasional blinks
    ],
    
    // Transition hints
    transitions: {
        duration: 500,      // Standard transition duration
        easing: 'easeInOut', // Balanced transition curve
        priority: 0         // Baseline priority level
    },
    
    // Audio/sound associations (optional)
    audio: {
        ambientSound: null,     // No specific ambient sound
        transitionSound: null,  // No transition sound
        gestureSound: null      // No gesture sound
    },
    
    // Particle spawn patterns
    particleSpawn: {
        pattern: 'random',      // Random spawn positions
        frequency: 'steady',    // Steady spawn rate
        burstOnEntry: false,    // No burst when entering state
        fadeOnExit: true        // Fade particles when leaving
    },
    
    // Eye/core appearance
    coreAppearance: {
        pupilSize: 1.0,        // Standard pupil dilation
        irisPattern: 'default', // Basic iris pattern
        blinkRate: 'normal',    // Regular blink frequency
        lookDirection: 'center' // Centered, neutral gaze
    },
    
    /**
     * Get core rendering parameters
     * @param {Object} state - Current renderer state
     * @returns {Object} Core rendering configuration
     */
    getCoreParams(state) {
        return {
            scaleX: 1.0,
            scaleY: 1.0,
            eyeOpenness: 1.0,
            eyeExpression: 'neutral', // neutral, happy, sad, focused
            pupilOffset: { x: 0, y: 0 }
        };
    },
    
    /**
     * Optional: Custom core rendering
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @returns {boolean} True if custom rendering was done
     */
    renderCore(ctx, x, y, radius) {
        // Return false to use default rendering
        return false;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Joy Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Joy emotional state - playful happiness
 * @author Emotive Engine Team
 * @module emotions/states/joy
 */

/**
 * Joy emotion configuration
 * Playful happiness with popcorn popping particles
 */
var joy = {
    name: 'joy',
    emoji: '😊',
    description: 'Playful happiness and celebration',
    
    // Visual properties
    visual: {
        glowColor: '#FFEB3B',       // Bright yellow sunshine
        glowIntensity: 1.6,         // Stronger cheerful glow
        particleRate: 40,           // Abundant celebration particles
        minParticles: 0,            // Can start from stillness
        maxParticles: 40,           // Maximum joyful expression
        particleBehavior: 'popcorn', // Spontaneous popping effect
        breathRate: 1.5,            // Excited, happy breathing
        breathDepth: 0.10,          // Moderate breath variation
        coreJitter: false,          // Stable, confident happiness
        particleColors: [
            { color: '#FFEB3B', weight: 25 },  // Bright sunshine yellow
            { color: '#FFC107', weight: 20 },  // Amber joy
            { color: '#FFFF00', weight: 15 },  // Pure yellow burst
            { color: '#FFD700', weight: 15 },  // Gold celebration
            { color: '#FFF59D', weight: 10 },  // Pale yellow sparkle
            { color: '#FF9800', weight: 10 },  // Orange warmth
            { color: '#FFFDE7', weight: 5 }    // Light cream highlight
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.8,        // Energetic, lively pace
        amplitude: 1.9,    // Expansive, celebratory movements
        intensity: 1.1,    // Enhanced joyful energy
        smoothness: 1.0,   // Natural, flowing motion
        regularity: 0.9,   // Playful, varied rhythm
        addBounce: true    // Extra springiness effect
    },
    
    // Typical gestures for joy
    typicalGestures: [
        'bounce',    // Happy bouncing
        'spin',      // Joyful spinning
        'wave',      // Excited waving
        'expand',    // Expanding with joy
        'shake',     // Excited shaking (gentle)
        'float'      // Floating with happiness
    ],
    
    // Transition hints
    transitions: {
        duration: 400,         // Swift mood elevation
        easing: 'easeOutBack', // Bouncy, playful entrance
        priority: 5,           // Elevated positive priority
        burstOnEntry: true     // Celebratory particle burst
    },
    
    // Audio/sound associations
    audio: {
        ambientSound: 'cheerful_hum',    // Cheerful background
        transitionSound: 'pop',           // Pop sound on entry
        gestureSound: 'giggle'            // Giggle on gestures
    },
    
    // Particle spawn patterns
    particleSpawn: {
        pattern: 'fountain',     // Fountain-like spawn
        frequency: 'burst',      // Burst spawning
        burstOnEntry: true,      // Big burst on entry
        fadeOnExit: false,       // Particles pop away
        specialEffect: 'sparkle' // Sparkle effect
    },
    
    // Eye/core appearance
    coreAppearance: {
        pupilSize: 1.2,          // Dilated with excitement
        irisPattern: 'radiant',   // Radiant, sparkling iris
        blinkRate: 'frequent',    // Happy, frequent blinking
        lookDirection: 'up',      // Optimistic upward gaze
        specialEffect: 'twinkle'  // Sparkling eye effect
    },
    
    // Rhythm configuration - joy bounces to the beat
    rhythm: {
        enabled: true,
        
        // Particle emission celebrates on beat
        particleEmission: {
            syncMode: 'beat',
            burstSize: 8,           // Big celebration bursts
            offBeatRate: 0.6,       // Still happy between beats
            popcornSync: true       // Popcorn pops on beat
        },
        
        // Breathing syncs to happy tempo
        breathSync: {
            mode: 'beats',
            beatsPerBreath: 4,     // One breath per bar
            intensity: 1.2          // Deeper happy breaths
        },
        
        // Glow pulses with joy
        glowSync: {
            intensityRange: [1.2, 1.8],
            syncTo: 'beat',
            attack: 0.05,           // Quick brightening
            decay: 0.4              // Bouncy fade
        },
        
        // Pattern-specific joy expressions
        patternBehaviors: {
            'waltz': {
                // Elegant happy waltz
                particleEmission: { burstSize: 5 },
                breathSync: { beatsPerBreath: 3 }
            },
            'swing': {
                // Jazzy playful joy
                particleEmission: { 
                    syncMode: 'swing',
                    burstSize: 6
                },
                glowSync: { curve: 'bounce' }
            },
            'dubstep': {
                // Explosive joy on drops
                particleEmission: {
                    burstSize: 15,
                    dropMultiplier: 3.0
                }
            },
            'breakbeat': {
                // Chaotic happy energy
                particleEmission: {
                    syncMode: 'random',
                    burstRange: [3, 12]
                }
            }
        }
    },
    
    /**
     * Get core rendering parameters for joy
     */
    getCoreParams(state) {
        return {
            scaleX: 1.0,
            scaleY: 1.0,
            eyeOpenness: 1.0,
            eyeExpression: 'happy',  // ∪ shaped eyes
            pupilOffset: { x: 0, y: -0.1 },  // Looking slightly up
            sparkle: true  // Add sparkle effect
        };
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sadness Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sadness emotional state - melancholic sorrow
 * @author Emotive Engine Team
 * @module emotions/states/sadness
 */

var sadness = {
    name: 'sadness',
    emoji: '😢',
    description: 'Deep melancholic sorrow',
    
    // Visual properties
    visual: {
        glowColor: '#4169E1',       // Royal blue melancholy
        glowIntensity: 0.65,        // Dimmer, more subdued glow
        particleRate: 25,           // Steady tear-like emission
        minParticles: 0,            // Can fade to emptiness
        maxParticles: 25,           // Abundant sorrow display
        particleBehavior: 'falling', // Tears falling downward
        breathRate: 0.6,            // Slow, heavy breathing
        breathDepth: 0.12,          // Deep, sighing breaths
        coreJitter: false,          // Still, heavy core
        particleColors: [
            { color: '#4169E1', weight: 25 },  // Royal blue sorrow
            { color: '#1E90FF', weight: 20 },  // Dodger blue tears
            { color: '#6495ED', weight: 15 },  // Cornflower blue melancholy
            { color: '#B0C4DE', weight: 15 },  // Light steel blue mist
            { color: '#191970', weight: 10 },  // Midnight blue depth
            { color: '#87CEEB', weight: 10 },  // Sky blue glimmer
            { color: '#2F4F4F', weight: 5 }    // Dark slate gray shadow
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.7,         // Slowed, weary pace
        amplitude: 0.6,     // Diminished movement range
        intensity: 0.8,     // Weakened emotional force
        smoothness: 1.3,    // Smooth, flowing sorrow
        regularity: 1.1,    // Slightly monotonous patterns
        addGravity: true    // Downward, heavy feeling
    },
    
    // Typical gestures for sadness
    typicalGestures: [
        'droop',
        'sway',
        'contract',
        'drift',
        'sink'
    ],
    
    // Transition configuration
    transitions: {
        duration: 800,         // Gradual mood shift
        easing: 'easeInOut',  // Smooth emotional transition
        priority: 3           // Lower emotional priority
    },
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Anger Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Anger emotional state - intense rage
 * @author Emotive Engine Team
 * @module emotions/states/anger
 */

/**
 * Anger emotion configuration
 * Intense aggressive state with rapid, chaotic particles
 */
var anger = {
    name: 'anger',
    emoji: '😠',
    description: 'Intense rage and aggression',
    
    // Visual properties
    visual: {
        glowColor: '#DC143C',       // Crimson rage - more intense
        glowIntensity: 1.8,         // Stronger, burning aura
        particleRate: 20,           // More frequent particle generation for chaos
        minParticles: 3,            // Maintain constant agitation
        maxParticles: 10,           // More particles for intensity
        particleBehavior: 'aggressive', // Erratic, forceful particle movement
        breathRate: 2.2,            // Rapid, agitated breathing rhythm
        breathDepth: 0.15,          // Deep, forceful breath cycles
        coreJitter: true,           // Visual tremor from internal rage
        particleColors: [
            { color: '#DC143C', weight: 25 },  // Crimson rage
            { color: '#FF0000', weight: 20 },  // Pure red fury
            { color: '#B22222', weight: 15 },  // FireBrick intensity
            { color: '#FF4500', weight: 15 },  // OrangeRed flames
            { color: '#8B0000', weight: 10 },  // Dark red depth
            { color: '#FF6347', weight: 10 },  // Tomato heat
            { color: '#660000', weight: 5 }    // Nearly black ember
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.5,        // Accelerated motion for urgency
        amplitude: 1.4,    // Exaggerated movement range
        intensity: 1.3,    // Heightened force and impact
        smoothness: 0.3,   // Sharp, abrupt transitions
        regularity: 0.7,   // Erratic, unpredictable patterns
        addShake: true     // Tremor effect from rage
    },
    
    // Typical gestures for anger
    typicalGestures: [
        'shake',     // Violent shaking
        'vibrate',   // Angry vibration
        'expand',    // Explosive expansion
        'pulse',     // Angry pulsing
        'flicker',   // Rage flickering
        'strike'     // Strike motion
    ],
    
    // Transition hints
    transitions: {
        duration: 300,          // Swift state change
        easing: 'easeOutExpo',  // Explosive, sudden entrance
        priority: 8,            // High priority emotional state
        shakeOnEntry: true      // Trigger screen disturbance
    },
    
    // Audio/sound associations
    audio: {
        ambientSound: 'rumble',      // Low rumbling
        transitionSound: 'explosion', // Explosive sound
        gestureSound: 'growl'         // Growling sounds
    },
    
    // Particle spawn patterns
    particleSpawn: {
        pattern: 'explosive',    // Explosive spawn
        frequency: 'chaotic',    // Chaotic frequency
        burstOnEntry: true,      // Explosion on entry
        fadeOnExit: false,       // Particles dissipate violently
        specialEffect: 'flames'  // Flame-like effect
    },
    
    // Eye/core appearance
    coreAppearance: {
        pupilSize: 0.7,           // Constricted for focused intensity
        irisPattern: 'sharp',      // Angular, aggressive iris pattern
        blinkRate: 'rare',        // Unwavering, intense gaze
        lookDirection: 'forward',  // Direct, confrontational focus
        specialEffect: 'flames',   // Fire-like eye effects
        pulseRate: 'rapid'        // Quick, agitated pulsing
    },
    
    // Special anger properties
    special: {
        screenShake: true,         // Environmental disturbance effect
        particleTrails: 'fire',    // Incendiary particle trail style
        glowPulse: true,          // Rhythmic aura fluctuation
        temperatureEffect: 'hot'   // Warm spectrum color shifting
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fear Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var fear = {
    name: 'fear',
    emoji: '😨',
    description: 'Anxious state with fleeing particles',
    
    // Visual properties
    visual: {
        glowColor: '#8A2BE2',       // Dark violet (BlueViolet) - more ominous
        glowIntensity: 0.9,         // Slightly stronger, pulsing glow
        particleRate: 18,           // More rapid nervous emission
        minParticles: 4,            // Constant anxious presence
        maxParticles: 16,           // Scattered fearful display
        particleBehavior: 'scattering', // Particles flee outward
        breathRate: 2.5,            // Rapid, shallow breathing
        breathDepth: 0.06,          // Short, panicked breaths
        coreJitter: true,           // Trembling with anxiety
        particleColors: [
            { color: '#8A2BE2', weight: 25 },  // Dark violet base
            { color: '#4B0082', weight: 20 },  // Indigo dread
            { color: '#9400D3', weight: 15 },  // Dark violet panic
            { color: '#6B46C1', weight: 15 },  // Deep purple anxiety
            { color: '#9932CC', weight: 10 },  // Dark orchid fear
            { color: '#E6E6FA', weight: 8 },   // Pale lavender flash
            { color: '#301934', weight: 7 }    // Almost black shadow
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.4,        // Quick, reactive movements
        amplitude: 0.8,    // Restricted, defensive range
        intensity: 1.2,    // Heightened fight-or-flight response
        smoothness: 0.5,   // Jerky, startled transitions
        regularity: 0.5,   // Unpredictable panic patterns
        addJitter: true    // Nervous trembling overlay
    },
    
    // Typical gestures for fear
    typicalGestures: ['shake', 'vibrate', 'contract', 'flicker', 'retreat'],
    
    // Transition configuration
    transitions: { 
        duration: 400,       // Quick fear response
        easing: 'easeOut',  // Sudden onset
        priority: 7         // High alert priority
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Surprise Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var surprise = {
    name: 'surprise',
    emoji: '😲',
    description: 'Sudden shock with explosive particles',
    
    // Visual properties
    visual: {
        glowColor: '#FFD700',       // Bright gold (shining surprise)
        glowIntensity: 1.8,         // Very intense, sudden flash
        particleRate: 30,           // Rapid burst emission
        minParticles: 0,            // Can start from nothing
        maxParticles: 15,           // Burst of shocked particles
        particleBehavior: 'burst',  // Explosive outward motion
        breathRate: 0.3,            // Gasping, held breath
        breathDepth: 0.18,          // Large shocked inhale
        coreJitter: false,          // Frozen in surprise
        particleColors: [
            { color: '#FFD700', weight: 25 },  // Gold burst
            { color: '#FFA500', weight: 20 },  // Orange shock
            { color: '#FFFF00', weight: 15 },  // Yellow flash
            { color: '#FF6347', weight: 15 },  // Tomato red excitement
            { color: '#FFE4B5', weight: 10 },  // Moccasin highlight
            { color: '#FF4500', weight: 10 },  // OrangeRed pop
            { color: '#FFFACD', weight: 5 }    // LemonChiffon sparkle
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.6,         // Rapid, startled reactions
        amplitude: 1.5,     // Large, exaggerated movements
        intensity: 1.4,     // Strong shock force
        smoothness: 0.7,    // Abrupt, jerky motions
        regularity: 0.8,    // Erratic surprise patterns
        addPop: true        // Popping, explosive effect
    },
    
    // Typical gestures for surprise
    typicalGestures: ['expand', 'bounce', 'flash', 'pulse', 'pop'],
    
    // Transition configuration
    transitions: { 
        duration: 200,           // Instant shock response
        easing: 'easeOutBack',  // Snappy, elastic reaction
        priority: 6             // High interrupt priority
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Disgust Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var disgust = {
    name: 'disgust',
    emoji: '🤢',
    description: 'Revulsion with repelling particles',
    
    // Visual properties
    visual: {
        glowColor: '#9ACD32',       // Sickly yellow-green (YellowGreen)
        glowIntensity: 1.0,         // Stronger, toxic glow
        particleRate: 15,           // More particles for nauseating effect
        minParticles: 5,            // Maintain visible repulsion
        maxParticles: 12,           // Controlled rejection display
        particleBehavior: 'repelling', // Particles flee from center
        breathRate: 0.7,            // Slow, queasy breathing
        breathDepth: 0.04,          // Shallow, uncomfortable breaths
        coreJitter: false,          // Stable but uneasy core
        particleColors: [
            { color: '#9ACD32', weight: 25 },  // Yellow-green toxic
            { color: '#ADFF2F', weight: 20 },  // Bright acid green
            { color: '#7FFF00', weight: 15 },  // Chartreuse nausea
            { color: '#BDB76B', weight: 15 },  // Dark khaki sick
            { color: '#6B8E23', weight: 10 },  // Olive drab decay
            { color: '#CCFF00', weight: 8 },   // Fluorescent bile
            { color: '#556B2F', weight: 7 }    // Dark olive shadow
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.9,        // Slightly slowed movements
        amplitude: 0.7,    // Restricted, withdrawn motion
        intensity: 0.9,    // Controlled repulsion force
        smoothness: 0.8,   // Mostly smooth with discomfort
        regularity: 1.0,   // Consistent rejection pattern
        addRecoil: true    // Recoiling motion effect
    },
    
    // Typical gestures for disgust
    typicalGestures: ['contract', 'shake', 'recoil', 'wobble'],
    
    // Transition configuration
    transitions: { 
        duration: 600,       // Moderate transition speed
        easing: 'easeIn',   // Gradual onset of revulsion
        priority: 4         // Mid-level priority state
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Love Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var love = {
    name: 'love',
    emoji: '💕',
    description: 'Warm affection with orbiting particles',
    
    // Visual properties
    visual: {
        glowColor: '#FF1493',       // Deep passionate pink (DeepPink)
        glowIntensity: 1.8,         // Strong, radiant warmth
        particleRate: 25,           // Generous particle flow
        minParticles: 10,           // Constant loving presence
        maxParticles: 18,           // Abundant affection display
        particleBehavior: 'orbiting', // Particles orbit romantically
        breathRate: 0.75,           // Slow, content breathing
        breathDepth: 0.15,          // Deep, satisfied breaths
        coreJitter: false,          // Stable, secure feeling
        particleColors: [
            { color: '#FF1493', weight: 30 },  // Deep passionate pink
            { color: '#FF69B4', weight: 25 },  // Hot pink
            { color: '#FF007F', weight: 15 },  // Rose red
            { color: '#FFB6C1', weight: 10 },  // Light pink highlights
            { color: '#FF45A0', weight: 10 },  // Vibrant magenta
            { color: '#E91E63', weight: 5 },   // Material pink accent
            { color: '#FFC0CB', weight: 5 }    // Soft pink glow
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.9,         // Gentle, romantic pace
        amplitude: 1.1,     // Slightly expanded movements
        intensity: 1.2,     // Enhanced emotional depth
        smoothness: 1.4,    // Extra smooth, flowing motion
        regularity: 1.2,    // Consistent, rhythmic patterns
        addWarmth: true     // Warm, inviting quality
    },
    
    // Typical gestures for love
    typicalGestures: ['pulse', 'sway', 'orbit', 'glow', 'breathe', 'float'],
    
    // Transition configuration
    transitions: { 
        duration: 700,         // Gradual emotional shift
        easing: 'easeInOut',  // Smooth, gentle transition
        priority: 5           // Moderate emotional priority
    },
    
    // Rhythm configuration - how love emotion responds to musical timing
    rhythm: {
        enabled: true,
        
        // Particle emission syncs to rhythm
        particleEmission: {
            syncMode: 'beat',        // Emit bursts on beat
            burstSize: 3,            // Extra particles per beat
            offBeatRate: 0.7         // Reduced emission between beats
        },
        
        // Orbital motion rhythm
        orbitalSync: {
            speedMultiplier: {
                onBeat: 1.2,         // Speed up on beat
                offBeat: 0.9,        // Slow between beats
                curve: 'ease'        // Smooth speed changes
            },
            radiusSync: {
                enabled: true,
                subdivision: 'quarter',  // Pulse radius on quarters
                amount: 0.15            // 15% radius variation
            }
        },
        
        // Glow pulsing with rhythm
        glowSync: {
            intensityRange: [1.4, 2.0],  // Min/max glow intensity
            syncTo: 'beat',              // Pulse on beats
            attack: 0.1,                 // Quick brightening
            decay: 0.6                   // Gentle fade
        },
        
        // Breathing synced to bars
        breathSync: {
            mode: 'bars',
            barsPerBreath: 2,    // One breath every 2 bars
            intensity: 1.0        // Full sync strength
        },
        
        // Pattern-specific overrides
        patternBehaviors: {
            'waltz': {
                // 3/4 time creates romantic swaying
                orbitalSync: { 
                    radiusSync: { subdivision: 'bar', amount: 0.25 }
                },
                particleEmission: { syncMode: 'bar', burstSize: 5 }
            },
            'swing': {
                // Jazzy, playful love
                orbitalSync: {
                    speedMultiplier: { onBeat: 1.5, curve: 'bounce' }
                }
            }
        },
        
        // Intensity modulation
        intensityMapping: {
            low: { particleRate: 0.6, glowIntensity: 0.8 },
            medium: { particleRate: 1.0, glowIntensity: 1.0 },
            high: { particleRate: 1.4, glowIntensity: 1.3 }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Suspicion Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var suspicion = {
    name: 'suspicion',
    emoji: '🤨',
    description: 'Paranoid watchfulness with surveillance scanning',
    
    // Visual properties
    visual: {
        glowColor: '#6B46C1',       // Deep purple paranoia
        glowIntensity: 0.85,        // Watchful glow that intensifies with threat
        particleRate: 18,           // Increased surveillance particles
        minParticles: 6,            // More eyes watching
        maxParticles: 12,           // Heightened alert capacity
        particleBehavior: 'surveillance',  // NEW: Searchlight scanning behavior
        particleSpeed: 0.2,         // Base particle speed
        breathRate: 0.6,            // Slower, more deliberate breathing
        breathDepth: 0.04,          // Very shallow, tense breaths
        coreJitter: 0.02,           // Slight nervous tremor
        particleColors: [
            { color: '#6B46C1', weight: 30 },  // Deep purple paranoia
            { color: '#4A5568', weight: 25 },  // Shadowy slate gray
            { color: '#8B4789', weight: 20 },  // Dark magenta mystery
            { color: '#9F7AEA', weight: 15 },  // Alert purple highlights
            { color: '#2D3748', weight: 10 }   // Deep shadow lurking
        ],
        // Dynamic threat level properties
        threatLevel: 0,             // 0-1 scale, updated by gaze distance
        getGlowIntensity() {
            return 0.3 + (this.threatLevel * 0.7);
        },
        getParticleSpeed() {
            return 0.2 + (this.threatLevel * 0.8);
        },
        getGlowColor() {
            // Color shifts from purple to red as threat increases
            const baseColor = { r: 107, g: 70, b: 193 };  // #6B46C1
            const alertColor = { r: 220, g: 38, b: 127 }; // #DC267F (magenta-red)
            
            const t = this.threatLevel || 0;
            
            const r = Math.round(baseColor.r + (alertColor.r - baseColor.r) * t);
            const g = Math.round(baseColor.g + (alertColor.g - baseColor.g) * t);
            const b = Math.round(baseColor.b + (alertColor.b - baseColor.b) * t);
            
            // Convert to hex
            const toHex = val => val.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.4,         // Slower, more deliberate movements
        amplitude: 0.6,     // Smaller, controlled movements
        intensity: 1.2,     // Higher alertness
        smoothness: 0.3,    // Jerky, paranoid movements
        regularity: 0.2,    // Highly unpredictable patterns
        focus: 1.5,         // Hyper-focused attention
        addWobble: true     // Uncertain, questioning motion
    },
    
    // Typical gestures for suspicion
    typicalGestures: ['scan', 'twitch', 'peek', 'tilt', 'hold'],
    
    // Transition configuration
    transitions: { 
        duration: 500,       // Moderate alertness shift
        easing: 'linear',   // Steady, controlled transition
        priority: 4         // Mid-level alert priority
    },
    
    // Special suspicion properties
    special: {
        coreSquint: 0.6,        // More pronounced eye narrowing
        scanInterval: 2000,     // More frequent scans
        scanDuration: 1200,     // Longer, more thorough scanning
        scanAngle: 60,          // Wider scanning range
        twitchChance: 0.02,     // 2% chance per frame to twitch
        peekInterval: 4000,     // Time between peek gestures
        maxThreatDistance: 300, // Distance for threat calculation
        alertThreshold: 0.7     // Threat level for maximum alert
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Excited Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var excited = {
    name: 'excited',
    emoji: '🤩',
    description: 'High energy with rapid particles',
    
    // Visual properties
    visual: {
        glowColor: '#FF6B35',       // Vibrant orange-red energy
        glowIntensity: 1.5,         // Stronger energetic aura
        particleRate: 25,           // Increased emission frequency (was 15)
        minParticles: 8,            // More constant particles (was 5)
        maxParticles: 30,           // More maximum particles (was 20)
        particleBehavior: 'burst',  // Explosive particle behavior
        breathRate: 2.0,            // Quick, excited breathing
        breathDepth: 0.14,          // Deep, energized breaths
        coreJitter: true,           // Vibrating with enthusiasm
        particleColors: [
            { color: '#FF6B35', weight: 25 },  // Vibrant orange energy
            { color: '#FF1744', weight: 20 },  // Red accent excitement
            { color: '#FFC107', weight: 15 },  // Amber sparkle
            { color: '#FF9100', weight: 15 },  // Deep orange burst
            { color: '#FFEB3B', weight: 10 },  // Yellow flash
            { color: '#FF5722', weight: 10 },  // Deep orange-red
            { color: '#FFF59D', weight: 5 }    // Pale yellow highlight
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.4,         // Quickened, energetic pace
        amplitude: 1.3,     // Expansive, enthusiastic movements
        intensity: 1.3,     // Strong energetic force
        smoothness: 0.8,    // Smooth with energetic bursts
        regularity: 0.7,    // Spontaneous, varied patterns
        addVibration: true  // Buzzing with excitement
    },
    
    // Typical gestures for excitement
    typicalGestures: ['bounce', 'spin', 'vibrate', 'expand', 'shake', 'pulse'],
    
    // Transition configuration
    transitions: { 
        duration: 300,              // Quick state entry
        easing: 'easeOutElastic',  // Bouncy, elastic entrance
        priority: 6                // High-energy priority level
    },
    
    // Rhythm configuration - excited syncs energetically to beat
    rhythm: {
        enabled: true,
        
        // Particle emission doubles on beat
        particleEmission: {
            syncMode: 'beat',
            burstSize: 5,           // Big bursts on beat
            offBeatRate: 0.5        // Calmer between beats
        },
        
        // Core jitter syncs to subdivisions
        jitterSync: {
            subdivision: 'sixteenth',  // Rapid jitter on 16th notes
            intensity: 0.8,           // Strong rhythm influence
            onBeat: 1.5              // Extra jitter on beat
        },
        
        // Glow pulses rapidly with beat
        glowSync: {
            intensityRange: [1.0, 1.8],
            syncTo: 'eighth',         // Pulse on 8th notes
            attack: 0.05,            // Very quick attack
            decay: 0.2               // Quick decay
        },
        
        // Different patterns create different excitement
        patternBehaviors: {
            'dubstep': {
                // Heavy drops create explosion effects
                particleEmission: { 
                    syncMode: 'beat',
                    burstSize: 10,      // Huge bursts on drop
                    dropMultiplier: 2   // Double on beat 3
                }
            },
            'breakbeat': {
                // Broken beats create chaotic energy
                jitterSync: {
                    subdivision: 'random',
                    intensity: 1.0
                }
            }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Resting Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var resting$1 = {
    name: 'resting',
    emoji: '😴',
    description: 'Deep relaxation with slow drift',
    
    // Visual properties
    visual: {
        glowColor: '#9370DB',       // Sleepy purple twilight
        glowIntensity: 0.8,         // Dimmed, drowsy glow
        particleRate: 10,           // Lazy particle generation
        minParticles: 3,            // Minimal sleepy presence
        maxParticles: 5,            // Few drifting particles
        particleBehavior: 'resting', // Slow, floating behavior
        breathRate: 0.8,            // Deep, slow breathing
        breathDepth: 0.12,          // Pronounced rest breaths
        coreJitter: false,          // Perfectly still core
        particleColors: [
            { color: '#9370DB', weight: 30 },  // Primary sleepy purple
            { color: '#A591C4', weight: 20 },  // Soft lavender drift
            { color: '#B366FF', weight: 20 },  // Dreamy violet accent
            { color: '#B8A1E6', weight: 15 },  // Light drowsy highlights
            { color: '#674D9B', weight: 15 }   // Deep sleep shadows
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 0.5,         // Slowed, drowsy pace
        amplitude: 0.4,     // Minimal movement range
        intensity: 0.5,     // Reduced energy level
        smoothness: 1.4,    // Extra smooth drifting
        regularity: 0.9,    // Slightly irregular, natural rest
        addWeight: true     // Heavy, weighted feeling
    },
    
    // Typical gestures for resting
    typicalGestures: ['breathe', 'drift', 'sway', 'float'],
    
    // Transition configuration
    transitions: { 
        duration: 1000,         // Slow fade to rest
        easing: 'easeInOut',   // Gentle transition
        priority: 2            // Low priority state
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Euphoria Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var euphoria = {
    name: 'euphoria',
    emoji: '🌟',
    description: 'Radiant hope and new beginnings',
    
    // Visual properties
    visual: {
        glowColor: '#FFB6C1',       // Light pink euphoric glow
        glowIntensity: 1.2,         // Bright radiance without accumulation
        particleRate: 35,           // Abundant particle emission
        minParticles: 15,           // Abundant positive energy
        maxParticles: 30,           // Maximum radiant display
        particleBehavior: 'radiant', // Outward radiating particles
        breathRate: 1.3,            // Elevated, joyful breathing
        breathDepth: 0.25,          // Full, satisfied breaths
        coreJitter: false,          // Stable, confident core
        particleColors: [
            { color: '#FFB6C1', weight: 20 },  // Light pink bliss
            { color: '#FFD700', weight: 18 },  // Golden joy
            { color: '#87CEEB', weight: 15 },  // Sky blue serenity
            { color: '#DDA0DD', weight: 15 },  // Plum transcendence
            { color: '#98FB98', weight: 12 },  // Pale green harmony
            { color: '#FFA07A', weight: 10 },  // Light salmon warmth
            { color: '#E6E6FA', weight: 8 },   // Lavender dream
            { color: '#FFFFFF', weight: 2 }    // Pure white sparkle
        ]
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.4,         // Energized, flowing pace
        amplitude: 1.5,     // Expansive, reaching movements
        intensity: 1.6,     // Powerful positive force
        smoothness: 1.3,    // Extra fluid, graceful motion
        regularity: 0.8,    // Natural variation in rhythm
        addWarmth: true,    // Warm, inviting quality
        addLift: true       // Upward, elevating tendency
    },
    
    // Typical gestures for euphoria
    typicalGestures: ['expand', 'radiate', 'pulse', 'glow', 'float', 'bloom'],
    
    // Transition configuration
    transitions: { 
        duration: 600,           // Smooth emergence
        easing: 'easeOutExpo',  // Explosive, radiant entrance
        priority: 8             // High priority transcendent state
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Focused Emotion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var focused = {
    name: 'focused',
    emoji: '🎯',
    description: 'Intense concentration with directed flow',
    
    // Visual properties
    visual: {
        glowColor: '#00CED1',       // Sharp cyan concentration
        glowIntensity: 1.2,         // Clear, defined aura
        particleRate: 10,           // Steady, controlled emission
        minParticles: 5,            // Consistent focus presence
        maxParticles: 12,           // Controlled attention display
        particleBehavior: 'directed', // Particles follow target
        breathRate: 1.2,            // Steady, measured breathing
        breathDepth: 0.08,          // Controlled, regular breaths
        coreJitter: true,           // Minimal tracking adjustments
        particleColors: [
            { color: '#00CED1', weight: 30 },  // Primary focused cyan
            { color: '#4A9FA0', weight: 20 },  // Muted concentration tone
            { color: '#00FFFF', weight: 20 },  // Bright attention burst
            { color: '#5FE5E7', weight: 15 },  // Light focus highlights
            { color: '#006B6D', weight: 15 }   // Deep concentration base
        ],
        eyeOpenness: 0.7,           // Narrowed for concentration
        microAdjustments: true      // Subtle tracking movements
    },
    
    // Gesture modifiers
    modifiers: {
        speed: 1.0,         // Baseline, deliberate pace
        amplitude: 0.9,     // Controlled movement range
        intensity: 1.1,     // Enhanced focus strength
        smoothness: 1.1,    // Precise, smooth tracking
        regularity: 1.2,    // Consistent, predictable patterns
        addPrecision: true  // Enhanced accuracy mode
    },
    
    // Typical gestures for focus
    typicalGestures: ['track', 'lock', 'scan', 'pulse', 'vibrate'],
    
    // Transition configuration
    transitions: { 
        duration: 400,       // Moderate focus shift
        easing: 'easeIn',   // Gradual concentration
        priority: 5         // Mid-level attention priority
    },
    
    // Core appearance parameters
    getCoreParams(state) {
        return {
            scaleX: 1.1,              // Slightly widened awareness
            scaleY: 0.7,              // Narrowed for concentration
            eyeOpenness: 0.7,         // Focused gaze intensity
            eyeExpression: 'focused', // Concentrated expression
            pupilOffset: { x: 0, y: 0 }, // Centered attention
            microAdjustments: true    // Small tracking movements
        };
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glitch Emotion (Simplified)
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var glitch = {
    name: 'glitch',
    emoji: '🌈',
    description: 'Surprised sadness with rainbow colors and glitch wiggle',
    
    // Visual properties - simplified combination of surprise + sadness
    visual: {
        primaryColor: '#FF6B9D',    // Pink surprise
        glowColor: '#4169E1',       // Blue sadness
        glowIntensity: 1.2,         // Moderate intensity (surprise + sadness)
        particleRate: 20,           // Moderate rate
        minParticles: 5,            // Some constant presence
        maxParticles: 15,           // Moderate burst
        particleBehavior: 'burst',  // Simplified from spaz to burst
        particleSpeed: 1.0,         // Moderate speed
        breathRate: 0.4,            // Between surprise (0.3) and sadness (0.6)
        breathDepth: 0.15,          // Between surprise (0.18) and sadness (0.12)
        coreJitter: false,          // No core shake
        coreSize: 1.0,              // Normal size
        eyeOpenness: 0.8,           // Wide but not fully open
        particleColors: [
            // Enhanced rainbow colors - more vibrant and balanced
            { color: '#FF0080', weight: 18 },  // Bright magenta
            { color: '#00FF80', weight: 18 },  // Bright green
            { color: '#8000FF', weight: 18 },  // Bright purple
            { color: '#FF8000', weight: 15 },  // Bright orange
            { color: '#0080FF', weight: 15 },  // Bright blue
            { color: '#FFFF00', weight: 10 },  // Bright yellow
            { color: '#FF6B9D', weight: 6 }    // Pink surprise
        ],
        // Glitch wiggle effect for particles
        particleGlitchWiggle: true,
        glitchWiggleIntensity: 0.3,
        glitchWiggleFrequency: 0.1
    },
    
    // Gesture modifiers - simplified
    modifiers: {
        speed: 1.1,         // Moderate speed
        amplitude: 1.0,      // Normal range
        intensity: 1.1,      // Slightly elevated
        smoothness: 0.8,     // Somewhat jerky
        regularity: 0.7,     // Somewhat erratic
        focus: 0.6           // Somewhat scattered
    },
    
    // Typical gestures - simplified
    typicalGestures: ['bounce', 'sway', 'pulse', 'drift', 'flash'],
    
    // Transition configuration - simplified
    transitions: { 
        duration: 300,          // Moderate transition
        easing: 'easeInOut',    // Smooth transition
        priority: 5             // Medium priority
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Calm Emotion
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Calm emotional state - serene and peaceful
 * @author Emotive Engine Team
 * @module emotions/states/calm
 */

/**
 * Calm emotion configuration
 * A state of deep tranquility and inner peace
 */
var calm = {
    name: 'calm',
    emoji: '😌',
    description: 'Serene, peaceful state with gentle movements',

    // Visual properties
    visual: {
        glowColor: '#66D9CC',        // Bright mint/turquoise (more distinct from neutral blue)
        glowIntensity: 0.6,          // Softer glow than neutral
        particleRate: 25,            // Steady, peaceful emission like sadness
        minParticles: 8,             // Keep some particles always
        maxParticles: 25,            // Allow more particles like sadness
        particleBehavior: 'zen',     // Zen orbital behavior
        breathRate: 0.4,             // Much slower breathing than neutral (1.0)
        breathDepth: 0.12,           // Deeper breaths than neutral (0.08)
        coreJitter: false,           // Perfectly still core
        particleColors: [
            { color: '#66D9CC', weight: 35 },  // Bright turquoise
            { color: '#99E6D9', weight: 25 },  // Light mint
            { color: '#40BFB3', weight: 20 },  // Medium teal
            { color: '#B3F2E6', weight: 15 },  // Pale mint
            { color: '#339980', weight: 5 }    // Deep teal shadow
        ]
    },

    // Gesture modifiers
    modifiers: {
        speed: 0.5,         // Much slower than neutral (1.0)
        amplitude: 0.3,     // Significantly reduced motion range
        intensity: 0.4,     // Very gentle force level
        smoothness: 2.0,    // Much smoother than neutral
        regularity: 1.5,    // More consistent patterns
        addWeight: false,   // Light, floating feeling
        floatHeight: 0.2,   // Minimal floating height
        swayAmount: 0.15,   // Very minimal side-to-side sway
        duration: 1.5       // Extend gesture duration
    },

    // Typical gestures for this emotion
    typicalGestures: [
        'breathe',   // Deep, slow breathing
        'float',     // Gentle floating
        'drift',     // Slow drifting
        'idle'       // Peaceful idle state
    ],

    // Transition hints
    transitions: {
        duration: 800,           // Slower transition into calm
        easing: 'easeInOutSine', // Very smooth sine curve
        priority: 1              // Low-medium priority
    },

    // Audio/sound associations
    audio: {
        ambientSound: 'soft_waves',  // Gentle ambient sounds
        transitionSound: null,        // No harsh transition
        gestureSound: null,           // Silent gestures
        volumeModifier: 0.5           // Quieter overall
    },

    // Particle spawn patterns
    particleSpawn: {
        pattern: 'center_drift',  // Spawn from center, drift outward
        frequency: 'slow',        // Very slow spawn rate
        burstOnEntry: false,      // No burst when entering
        fadeOnExit: true,         // Gentle fade when leaving
        spawnRadius: 0.3,         // Spawn close to center
        driftSpeed: 0.2           // Very slow particle drift
    },

    // Eye/core appearance
    coreAppearance: {
        pupilSize: 0.9,           // Slightly relaxed pupils
        irisPattern: 'soft',       // Softer iris edges
        blinkRate: 'slow',        // Slower, relaxed blinking
        lookDirection: 'soft_center', // Soft focus, not sharp
        eyeOpenness: 0.85         // Slightly droopy, relaxed eyes
    },

    // Movement patterns
    movement: {
        floatPattern: 'sine_slow',     // Slow sine wave floating
        floatPeriod: 6000,              // 6 second float cycle
        floatAmplitude: 8,              // 8 pixel vertical range
        swayPattern: 'gentle',          // Gentle side sway
        swayPeriod: 8000,               // 8 second sway cycle
        swayAmplitude: 5,               // 5 pixel horizontal range
        microMovements: false           // No jittery movements
    },

    /**
     * Get core rendering parameters
     * @param {Object} state - Current renderer state
     * @returns {Object} Core rendering configuration
     */
    getCoreParams(state) {
        const time = state.time || Date.now();
        const breathPhase = Math.sin(time * 0.0006) * 0.5 + 0.5; // Very slow breathing

        return {
            scaleX: 1.0 - (breathPhase * 0.02),  // Very subtle breathing scale
            scaleY: 1.0 - (breathPhase * 0.02),
            eyeOpenness: 0.85,                   // Relaxed eyes
            eyeExpression: 'serene',             // New serene expression
            pupilOffset: {
                x: Math.sin(time * 0.0003) * 2,  // Slow, minimal eye movement
                y: Math.cos(time * 0.0004) * 1
            },
            glowPulse: 0.95 + (breathPhase * 0.05)  // Very subtle glow pulse
        };
    },

    /**
     * Optional: Custom particle behavior for calm state
     * @param {Object} particle - Particle to update
     * @param {number} deltaTime - Time since last update
     */
    updateParticle(particle, deltaTime) {
        // Super slow drift
        particle.x += Math.sin(particle.life * 0.001) * 0.1;
        particle.y -= deltaTime * 0.02; // Very slow rise

        // Gentle fade based on life
        particle.opacity = Math.sin(particle.life * 0.002) * 0.3 + 0.2;

        // Slow size pulse
        particle.size = particle.baseSize * (1 + Math.sin(particle.life * 0.001) * 0.2);
    },

    /**
     * Optional: Custom core rendering
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @returns {boolean} True if custom rendering was done
     */
    renderCore(ctx, x, y, radius) {
        // Return false to use default rendering with parameters
        return false;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Emotion Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central emotion registry with full plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module emotions
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Central registry for modular emotion system with plugin adapter integration.
 * ║ • Core emotions are loaded synchronously at startup
 * ║ • Plugin emotions can be registered dynamically via adapter
 * ║ • Each emotion is self-contained with visual, gesture, and transition data
 * ║ • Value-agnostic design allows easy tuning without code changes
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// Registry to store all registered emotions
const emotionRegistry = new Map();

// Emotion aliases for compatibility
const emotionAliases = {
    'happy': 'joy',
    'peaceful': 'calm',
    'curious': 'surprise',
    'frustrated': 'anger',
    'sad': 'sadness'
};

// Register all emotions SYNCHRONOUSLY
[neutral, joy, sadness, anger, fear, surprise, disgust,
    love, suspicion, excited, resting$1, euphoria, focused, glitch, calm].forEach(emotion => {
    if (emotion && emotion.name) {
        emotionRegistry.set(emotion.name, emotion);
    }
});

/**
 * Get emotion configuration by name (checks both core and plugin emotions)
 * @param {string} emotionName - Name of the emotion (or alias)
 * @returns {Object|null} The emotion configuration or null if not found
 */
function getEmotion(emotionName) {
    // Check aliases first
    const resolvedName = emotionAliases[emotionName] || emotionName;

    // Check core emotions
    const coreEmotion = emotionRegistry.get(resolvedName);
    if (coreEmotion) {
        return coreEmotion;
    }

    // Check plugin emotions
    const pluginEmotion = pluginAdapter$2.getPluginEmotion(resolvedName);
    if (pluginEmotion) {
        return pluginEmotion;
    }

    return null;
}

/**
 * Get emotion parameters (visual properties) with dynamic evaluation
 * @param {string} emotionName - Name of the emotion
 * @returns {Object} Visual parameters for the emotion
 */
function getEmotionVisualParams(emotionName) {
    const emotion = getEmotion(emotionName);
    if (!emotion) {
        return getEmotion('neutral').visual;
    }

    // Make sure visual exists
    if (!emotion.visual) {
        return {};
    }
    
    // Create a copy of visual properties, excluding functions
    const {visual} = emotion;
    const params = {};
    
    // Copy non-function properties
    for (const key in visual) {
        if (typeof visual[key] !== 'function') {
            params[key] = visual[key];
        }
    }
    
    // Evaluate dynamic functions if they exist and override static values
    if (typeof visual.getGlowIntensity === 'function') {
        params.glowIntensity = visual.getGlowIntensity();
    }
    
    if (typeof visual.getParticleSpeed === 'function') {
        params.particleSpeed = visual.getParticleSpeed();
    }
    
    if (typeof visual.getParticleRate === 'function') {
        params.particleRate = visual.getParticleRate();
    }
    
    if (typeof visual.getGlowColor === 'function') {
        params.glowColor = visual.getGlowColor();
    }
    
    return params;
}

/**
 * Get emotion modifiers (gesture adjustments)
 * @param {string} emotionName - Name of the emotion
 * @returns {Object} Gesture modifiers for the emotion
 */
function getEmotionModifiers(emotionName) {
    const emotion = getEmotion(emotionName);
    if (!emotion) {
        return getEmotion('neutral').modifiers;
    }
    return emotion.modifiers;
}

/**
 * Get list of available emotions (core and plugin)
 * @returns {Array<string>} List of emotion names
 */
function listEmotions() {
    const coreEmotions = Array.from(emotionRegistry.keys());
    const pluginEmotions = pluginAdapter$2.getAllPluginEmotions();
    return [...coreEmotions, ...pluginEmotions];
}

/**
 * Check if an emotion exists (checks both core and plugin)
 * @param {string} emotionName - Name of the emotion to check
 * @returns {boolean} True if emotion exists
 */
function hasEmotion(emotionName) {
    const resolvedName = emotionAliases[emotionName] || emotionName;
    return emotionRegistry.has(resolvedName) || pluginAdapter$2.getPluginEmotion(resolvedName) !== null;
}

/**
 * Get emotion transition parameters
 * @param {string} fromEmotion - Starting emotion
 * @param {string} toEmotion - Target emotion
 * @returns {Object} Transition parameters
 */
function getTransitionParams(fromEmotion, toEmotion) {
    const from = getEmotion(fromEmotion);
    const to = getEmotion(toEmotion);
    
    if (!from || !to) {
        return {
            duration: 1000,
            easing: 'ease-in-out'
        };
    }
    
    // Check if 'to' emotion has specific transition hints
    if (to.transitions && to.transitions[fromEmotion]) {
        return to.transitions[fromEmotion];
    }
    
    // Use default transition
    return {
        duration: 1000,
        easing: 'ease-in-out',
        gesture: to.transitions?.defaultGesture || null
    };
}

/**
 * Get typical gestures for an emotion
 * @param {string} emotionName - Name of the emotion
 * @returns {Array<string>} List of typical gesture names
 */
function getEmotionGestures(emotionName) {
    const emotion = getEmotion(emotionName);
    return emotion?.gestures || [];
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Emotion Cache System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Pre-cached emotion system for instant emotion transitions
 * @author Emotive Engine Team
 * @module cache/EmotionCache
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Pre-caches all emotion states and their configurations for instant access.
 * ║ Eliminates the need to load emotion data on-demand, improving transition
 * ║ performance from ~20-50ms to <5ms.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * EmotionCache - Pre-caches all emotion configurations for instant access
 */
class EmotionCache {
    constructor() {
        // Cache storage
        this.emotionCache = new Map();
        this.visualParamsCache = new Map();
        this.modifiersCache = new Map();
        this.transitionCache = new Map();
        
        // Performance tracking
        this.stats = {
            hits: 0,
            misses: 0,
            loadTime: 0,
            cacheSize: 0
        };
        
        // Cache configuration
        this.isInitialized = false;
        this.loadStartTime = 0;
        
        // Initialize cache
        this.initialize();
    }
    
    /**
     * Initialize the emotion cache by pre-loading all emotions
     */
    initialize() {
        this.loadStartTime = performance.now();
        
        try {
            // Get all available emotions
            const emotions = listEmotions();
            
            // Pre-cache each emotion
            emotions.forEach(emotionName => {
                this.cacheEmotion(emotionName);
            });
            
            // Pre-cache common transitions
            this.cacheCommonTransitions(emotions);
            
            this.isInitialized = true;
            this.stats.loadTime = performance.now() - this.loadStartTime;
            this.stats.cacheSize = this.emotionCache.size;
            
            console.warn(`[EmotionCache] Initialized with ${this.emotionCache.size} emotions in ${this.stats.loadTime.toFixed(2)}ms`);
            
        } catch (error) {
            console.error('[EmotionCache] Initialization failed:', error);
            this.isInitialized = false;
        }
    }
    
    /**
     * Cache a single emotion and its related data
     * @param {string} emotionName - Name of the emotion to cache
     */
    cacheEmotion(emotionName) {
        try {
            // Cache main emotion configuration
            const emotion = getEmotion(emotionName);
            if (emotion) {
                this.emotionCache.set(emotionName, emotion);
            }
            
            // Cache visual parameters (pre-evaluated)
            const visualParams = getEmotionVisualParams(emotionName);
            this.visualParamsCache.set(emotionName, visualParams);
            
            // Cache modifiers
            const modifiers = getEmotionModifiers(emotionName);
            this.modifiersCache.set(emotionName, modifiers);
            
        } catch (error) {
            console.warn(`[EmotionCache] Failed to cache emotion '${emotionName}':`, error);
        }
    }
    
    /**
     * Cache common emotion transitions
     * @param {Array<string>} emotions - List of emotion names
     */
    cacheCommonTransitions(emotions) {
        // Cache transitions between common emotion pairs
        const commonPairs = [
            ['neutral', 'joy'],
            ['neutral', 'sadness'],
            ['neutral', 'anger'],
            ['joy', 'sadness'],
            ['sadness', 'joy'],
            ['anger', 'calm'],
            ['calm', 'anger']
        ];
        
        commonPairs.forEach(([from, to]) => {
            if (emotions.includes(from) && emotions.includes(to)) {
                try {
                    const transition = getTransitionParams(from, to);
                    const key = `${from}->${to}`;
                    this.transitionCache.set(key, transition);
                } catch (error) {
                    console.warn(`[EmotionCache] Failed to cache transition '${from}->${to}':`, error);
                }
            }
        });
    }
    
    /**
     * Get cached emotion configuration
     * @param {string} emotionName - Name of the emotion
     * @returns {Object|null} Cached emotion configuration
     */
    getEmotion(emotionName) {
        if (!this.isInitialized) {
            console.warn('[EmotionCache] Cache not initialized, falling back to direct access');
            return getEmotion(emotionName);
        }
        
        const cached = this.emotionCache.get(emotionName);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        console.warn(`[EmotionCache] Cache miss for emotion '${emotionName}', consider adding to pre-cache`);
        return getEmotion(emotionName);
    }
    
    /**
     * Get cached visual parameters
     * @param {string} emotionName - Name of the emotion
     * @returns {Object} Cached visual parameters
     */
    getVisualParams(emotionName) {
        if (!this.isInitialized) {
            return getEmotionVisualParams(emotionName);
        }
        
        const cached = this.visualParamsCache.get(emotionName);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        return getEmotionVisualParams(emotionName);
    }
    
    /**
     * Get cached modifiers
     * @param {string} emotionName - Name of the emotion
     * @returns {Object} Cached modifiers
     */
    getModifiers(emotionName) {
        if (!this.isInitialized) {
            return getEmotionModifiers(emotionName);
        }
        
        const cached = this.modifiersCache.get(emotionName);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        return getEmotionModifiers(emotionName);
    }
    
    /**
     * Get cached transition parameters
     * @param {string} fromEmotion - Starting emotion
     * @param {string} toEmotion - Target emotion
     * @returns {Object} Cached transition parameters
     */
    getTransitionParams(fromEmotion, toEmotion) {
        if (!this.isInitialized) {
            return getTransitionParams(fromEmotion, toEmotion);
        }
        
        const key = `${fromEmotion}->${toEmotion}`;
        const cached = this.transitionCache.get(key);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        return getTransitionParams(fromEmotion, toEmotion);
    }
    
    /**
     * Check if emotion is cached
     * @param {string} emotionName - Name of the emotion
     * @returns {boolean} True if emotion is cached
     */
    hasEmotion(emotionName) {
        return this.emotionCache.has(emotionName);
    }
    
    /**
     * Get cache statistics
     * @returns {Object} Cache performance statistics
     */
    getStats() {
        const totalRequests = this.stats.hits + this.stats.misses;
        const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests * 100).toFixed(2) : 0;
        
        return {
            isInitialized: this.isInitialized,
            loadTime: this.stats.loadTime,
            cacheSize: this.stats.cacheSize,
            hits: this.stats.hits,
            misses: this.stats.misses,
            hitRate: `${hitRate}%`,
            emotions: this.emotionCache.size,
            visualParams: this.visualParamsCache.size,
            modifiers: this.modifiersCache.size,
            transitions: this.transitionCache.size
        };
    }
    
    /**
     * Clear all caches
     */
    clear() {
        this.emotionCache.clear();
        this.visualParamsCache.clear();
        this.modifiersCache.clear();
        this.transitionCache.clear();
        this.isInitialized = false;
        this.stats = { hits: 0, misses: 0, loadTime: 0, cacheSize: 0 };
    }
    
    /**
     * Reinitialize cache (useful for dynamic emotion loading)
     */
    reinitialize() {
        this.clear();
        this.initialize();
    }
}

// Create singleton instance
const emotionCache = new EmotionCache();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  STATE MACHINE CORE  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Emotive State Machine - Emotional State & Transition Management
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module EmotiveStateMachine
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The BRAIN of the Emotive Engine. Manages emotional states, transitions,           
 * ║ undertones, and gesture queues. This is where emotions become behavior.           
 * ║ Works with emotionMap.js for visuals but defines the LOGIC and TIMING.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🧠 CORE RESPONSIBILITIES                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Emotional state management (current, target, transitions)                       
 * │ • Undertone layering (nervous + happy, tired + angry, etc.)                      
 * │ • Gesture queue processing (sequential animation management)                      
 * │ • Smooth property interpolation during transitions                                
 * │ • Event emission for state changes                                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚠️  CRITICAL STATE PROPERTIES                                                     
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • emotion      : Current emotional state (must be valid emotion)                  
 * │ • undertone    : Optional modifier (null or valid undertone)                      
 * │ • gesture      : Currently playing gesture animation
 * │ • transitions  : Active transition data (progress, timing, easing)
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 TRANSITION SYSTEM                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Smooth blending between emotional states                                        
 * │ • Configurable transition duration (default 500ms)                                
 * │ • Easing functions for natural motion                                             
 * │ • Property interpolation (colors, sizes, speeds)                                  
 * │ • Prevents jarring visual changes                                                 
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ DO NOT MODIFY WITHOUT UNDERSTANDING                                            
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ State validation logic    → Breaks error handling                              
 * │ ✗ Transition timing        → Causes visual glitches                              
 * │ ✗ Event emission order     → Breaks dependent systems                            
 * │ ✗ Property interpolation   → Creates animation artifacts                         
 * │ ✗ Queue processing         → Causes gesture conflicts                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                          ADDING NEW EMOTIONAL STATES                              
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ 1. Define visual properties in emotionMap.js                                      
 * ║ 2. Add state definition in initializeEmotionalStates()                            
 * ║ 3. Add validation to ErrorBoundary.js                                             
 * ║ 4. Test transitions FROM and TO the new state                                     
 * ║ 5. Verify particle behavior and performance                                       
 * ║ 6. Document any special transition rules                                          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class EmotiveStateMachine {
    constructor(errorBoundary) {
        this.errorBoundary = errorBoundary;
        
        // Current state
        this.state = {
            emotion: 'neutral',
            undertone: null,
            gesture: null,
            speaking: false,
            audioLevel: 0
        };
        
        // Transition management
        this.transitions = {
            emotional: {
                current: 'neutral',
                target: null,
                progress: 0,
                duration: 500,
                startTime: 0,
                isActive: false
            },
            undertone: {
                current: null,
                target: null,
                progress: 0,
                duration: 300,  // Faster than emotion transitions
                startTime: 0,
                isActive: false,
                currentWeight: 0,  // 0-1 weight of current undertone
                targetWeight: 0    // 0-1 weight of target undertone
            }
        };
        
        // Cache for interpolation results
        this.interpolationCache = {
            lastUpdate: 0,
            cacheInterval: 100, // Cache for 100ms
            cachedProperties: null,
            cachedRenderState: null
        };
        
        // Initialize emotional state definitions
        this.initializeEmotionalStates();
        this.initializeUndertoneModifiers();
    }

    /**
     * Initialize all 8 emotional states with their visual properties
     */
    initializeEmotionalStates() {
        // Always use emotion files - no hardcoded fallback
        this.emotionalStates = this.loadEmotionalStatesFromCache();
    }

    /**
     * Load emotional states from cache
     */
    loadEmotionalStatesFromCache() {
        const states = {};
        const emotions = ['neutral', 'joy', 'sadness', 'anger', 'fear', 'surprise', 'disgust', 'love', 'suspicion', 'excited', 'resting', 'euphoria', 'focused', 'glitch', 'calm'];
        
        emotions.forEach(emotionName => {
            const visualParams = emotionCache.getVisualParams(emotionName);
            if (visualParams) {
                states[emotionName] = {
                    primaryColor: visualParams.primaryColor || '#B0B0B0',
                    glowIntensity: visualParams.glowIntensity || 0.7,
                    particleRate: visualParams.particleRate || 1,
                    minParticles: visualParams.minParticles || 3,
                    maxParticles: visualParams.maxParticles || 4,
                    particleBehavior: visualParams.particleBehavior || 'ambient',
                    coreSize: visualParams.coreSize || 1.0,
                    breathRate: visualParams.breathRate || 1.0,
                    breathDepth: visualParams.breathDepth || 0.1
                };
            }
        });
        
        return states;
    }


    /**
     * Initialize undertone modifiers that affect base emotional properties
     */
    initializeUndertoneModifiers() {
        this.undertoneModifiers = {
            nervous: {
                jitterAmount: 0.3,
                breathRateMultiplier: 1.2,
                glowIntensityMultiplier: 0.9,
                particleRateMultiplier: 1.1
            },
            confident: {
                coreSizeMultiplier: 1.1,
                glowIntensityMultiplier: 1.2,
                breathRateMultiplier: 0.9,
                particleRateMultiplier: 1.0
            },
            tired: {
                breathRateMultiplier: 0.7,
                particleRateMultiplier: 0.5,
                glowIntensityMultiplier: 0.8,
                coreSizeMultiplier: 0.95
            },
            intense: {
                amplificationFactor: 1.3
            },
            subdued: {
                dampeningFactor: 0.7
            }
        };
    }

    /**
     * Sets the emotional state with optional undertone
     * @param {string} emotion - The emotion to set
     * @param {string|null} undertone - Optional undertone modifier
     * @param {number} duration - Transition duration in milliseconds
     * @returns {boolean} Success status
     */
    setEmotion(emotion, undertone = null, duration = 500) {
        return this.errorBoundary.wrap(() => {
            // Clear interpolation cache when emotion changes
            this.interpolationCache.cachedProperties = null;
            this.interpolationCache.cachedRenderState = null;
            
            // Validate emotion using modular system
            if (!hasEmotion(emotion) && !Object.prototype.hasOwnProperty.call(this.emotionalStates, emotion)) {
                const validEmotions = [...Object.keys(this.emotionalStates), ...listEmotions()];
                const uniqueEmotions = [...new Set(validEmotions)];
                throw new Error(`Invalid emotion: ${emotion}. Valid emotions: ${uniqueEmotions.join(', ')}`);
            }

            // Validate undertone
            if (undertone !== null && !Object.prototype.hasOwnProperty.call(this.undertoneModifiers, undertone)) {
                throw new Error(`Invalid undertone: ${undertone}. Valid undertones: ${Object.keys(this.undertoneModifiers).join(', ')}`);
            }

            // If already in this state, just update undertone
            if (this.state.emotion === emotion && this.state.undertone === undertone) {
                return true;
            }

            // Set up emotion transition if emotion is changing
            if (this.state.emotion !== emotion) {
                if (duration > 0) {
                    this.transitions.emotional = {
                        current: this.state.emotion,
                        target: emotion,
                        progress: 0,
                        duration: Math.max(100, duration),
                        startTime: performance.now(),
                        isActive: true
                    };
                    
                    // Reset simulated time for testing
                    if (this._simulatedTime !== undefined) {
                        this._simulatedTime = 0;
                    }
                } else {
                    // Immediate transition
                    this.transitions.emotional = {
                        current: emotion,
                        target: null,
                        progress: 1,
                        duration: 0,
                        startTime: performance.now(),
                        isActive: false
                    };
                }
                this.state.emotion = emotion;
            }
            
            // Set up undertone transition if undertone is changing
            if (this.state.undertone !== undertone) {
                this.transitions.undertone = {
                    current: this.state.undertone,
                    target: undertone,
                    progress: 0,
                    duration: 300,  // Always smooth undertone transitions
                    startTime: performance.now(),
                    isActive: true,
                    currentWeight: this.state.undertone ? 1 : 0,
                    targetWeight: undertone ? 1 : 0
                };
                this.state.undertone = undertone;
            }

            return true;
        }, 'emotion-setting', false)();
    }

    /**
     * Applies undertone modifiers to base emotional properties
     * @param {Object} baseProperties - Base emotional properties
     * @param {string|null} undertone - Undertone to apply
     * @returns {Object} Modified properties
     */
    applyUndertone(baseProperties, undertone) {
        if (!undertone || !Object.prototype.hasOwnProperty.call(this.undertoneModifiers, undertone)) {
            return { ...baseProperties };
        }

        const modifier = this.undertoneModifiers[undertone];
        const modified = { ...baseProperties };

        // Apply specific modifiers
        if (modifier.glowIntensityMultiplier !== undefined) {
            modified.glowIntensity *= modifier.glowIntensityMultiplier;
        }
        if (modifier.breathRateMultiplier !== undefined) {
            modified.breathRate *= modifier.breathRateMultiplier;
        }
        if (modifier.particleRateMultiplier !== undefined) {
            modified.particleRate = Math.round(modified.particleRate * modifier.particleRateMultiplier);
        }
        if (modifier.coreSizeMultiplier !== undefined) {
            modified.coreSize *= modifier.coreSizeMultiplier;
        }

        // Apply amplification/dampening factors
        if (modifier.amplificationFactor !== undefined) {
            const factor = modifier.amplificationFactor;
            modified.glowIntensity *= factor;
            modified.breathRate *= factor;
            modified.particleRate = Math.round(modified.particleRate * factor);
            modified.coreSize *= factor;
        }
        if (modifier.dampeningFactor !== undefined) {
            const factor = modifier.dampeningFactor;
            modified.glowIntensity *= factor;
            modified.breathRate *= factor;
            modified.particleRate = Math.round(modified.particleRate * factor);
            modified.coreSize *= factor;
        }

        // Add special properties
        if (modifier.jitterAmount !== undefined) {
            modified.jitterAmount = modifier.jitterAmount;
        }

        return modified;
    }

    /**
     * Updates the state machine with delta time
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    update(deltaTime) {
        this.errorBoundary.wrap(() => {
            // Update emotional transition
            if (this.transitions.emotional.isActive) {
                this.updateEmotionalTransition(deltaTime);
            }
            
            // Update undertone transition
            if (this.transitions.undertone.isActive) {
                this.updateUndertoneTransition(deltaTime);
            }
        }, 'state-machine-update')();
    }

    /**
     * Updates undertone transition progress
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateUndertoneTransition(deltaTime) {
        const transition = this.transitions.undertone;
        
        // Calculate elapsed time
        const elapsed = performance.now() - transition.startTime;
        const progress = Math.min(elapsed / transition.duration, 1);
        
        // Apply easing
        const easedProgress = easeInOutCubic(progress);
        
        // Update weights for smooth transition
        if (transition.current && transition.target) {
            // Transitioning between two undertones
            transition.currentWeight = 1 - easedProgress;
            transition.targetWeight = easedProgress;
        } else if (transition.current && !transition.target) {
            // Fading out current undertone
            transition.currentWeight = 1 - easedProgress;
            transition.targetWeight = 0;
        } else if (!transition.current && transition.target) {
            // Fading in new undertone
            transition.currentWeight = 0;
            transition.targetWeight = easedProgress;
        }
        
        transition.progress = progress;
        
        // Complete transition
        if (progress >= 1) {
            transition.isActive = false;
            transition.current = transition.target;
            transition.currentWeight = transition.target ? 1 : 0;
            transition.targetWeight = 0;
        }
    }
    
    /**
     * Updates emotional state transition progress
     * @param {number} deltaTime - Time since last update in milliseconds
     */
    updateEmotionalTransition(deltaTime) {
        const transition = this.transitions.emotional;
        
        // Use either real elapsed time or simulated deltaTime for testing
        let elapsed;
        if (this._simulatedTime !== undefined) {
            // For testing - use accumulated simulated time
            this._simulatedTime += deltaTime;
            elapsed = this._simulatedTime;
        } else {
            // For real usage - use actual elapsed time
            elapsed = performance.now() - transition.startTime;
        }
        
        // Calculate progress (0 to 1)
        transition.progress = Math.min(1, elapsed / transition.duration);
        
        // Check if transition is complete
        if (transition.progress >= 1) {
            transition.isActive = false;
            transition.current = transition.target;
            transition.target = null;
            transition.progress = 1;
        }
    }

    /**
     * Gets the current interpolated emotional properties
     * @returns {Object} Current emotional properties with smooth transitions
     */
    getCurrentEmotionalProperties() {
        return this.errorBoundary.wrap(() => {
            const now = performance.now();
            
            // Use cached result if still valid
            if (this.interpolationCache.cachedProperties && 
                (now - this.interpolationCache.lastUpdate) < this.interpolationCache.cacheInterval) {
                return this.interpolationCache.cachedProperties;
            }
            
            const transition = this.transitions.emotional;
            let properties;

            if (transition.isActive && transition.target) {
                // Interpolate between current and target states
                properties = this.interpolateEmotionalProperties(
                    transition.current,
                    transition.target,
                    transition.progress
                );
            } else {
                // Use current state properties - fallback to neutral if emotion not found
                const emotionState = this.emotionalStates[this.state.emotion] || this.emotionalStates.neutral;
                properties = { ...emotionState };
            }

            // Apply undertone modifiers
            properties = this.applyUndertone(properties, this.state.undertone);
            
            // Cache the result
            this.interpolationCache.cachedProperties = properties;
            this.interpolationCache.lastUpdate = now;

            return properties;
        }, 'emotional-properties', () => this.emotionalStates.neutral)();
    }

    /**
     * Interpolates between two emotional states
     * @param {string} fromEmotion - Source emotion
     * @param {string} toEmotion - Target emotion
     * @param {number} progress - Interpolation progress (0-1)
     * @returns {Object} Interpolated properties
     */
    interpolateEmotionalProperties(fromEmotion, toEmotion, progress) {
        const fromProps = this.emotionalStates[fromEmotion] || this.emotionalStates.neutral;
        const toProps = this.emotionalStates[toEmotion] || this.emotionalStates.neutral;
        
        // Apply easing to progress
        const easedProgress = applyEasing(progress, 0, 1, 'easeOutCubic');

        return {
            // Interpolate color in HSL space for better transitions
            primaryColor: interpolateHsl(fromProps.primaryColor, toProps.primaryColor, easedProgress),
            
            // Interpolate numeric properties
            glowIntensity: fromProps.glowIntensity + (toProps.glowIntensity - fromProps.glowIntensity) * easedProgress,
            particleRate: Math.round(fromProps.particleRate + (toProps.particleRate - fromProps.particleRate) * easedProgress),
            coreSize: fromProps.coreSize + (toProps.coreSize - fromProps.coreSize) * easedProgress,
            breathRate: fromProps.breathRate + (toProps.breathRate - fromProps.breathRate) * easedProgress,
            breathDepth: fromProps.breathDepth + (toProps.breathDepth - fromProps.breathDepth) * easedProgress,
            
            // Use target behavior when transition is more than 50% complete
            particleBehavior: easedProgress > 0.5 ? toProps.particleBehavior : fromProps.particleBehavior
        };
    }

    /**
     * Gets the current state for external inspection
     * @returns {Object} Current state information
     */
    getCurrentState() {
        return {
            emotion: this.state.emotion,
            undertone: this.state.undertone,
            isTransitioning: this.transitions.emotional.isActive,
            transitionProgress: this.transitions.emotional.progress,
            properties: this.getCurrentEmotionalProperties()
        };
    }

    /**
     * Applies an undertone to the current emotional state
     * @param {string|null} undertone - Undertone to apply
     * @returns {boolean} Success status
     */
    applyUndertoneModifier(undertone) {
        return this.errorBoundary.wrap(() => {
            // Validate undertone
            if (undertone !== null && !Object.prototype.hasOwnProperty.call(this.undertoneModifiers, undertone)) {
                throw new Error(`Invalid undertone: ${undertone}. Valid undertones: ${Object.keys(this.undertoneModifiers).join(', ')}`);
            }

            // Apply the undertone
            this.state.undertone = undertone;
            
            return true;
        }, 'undertone-application', false)();
    }

    /**
     * Clears the current undertone and resets to base emotional state
     */
    clearUndertone() {
        this.state.undertone = null;
    }

    /**
     * Gets the raw undertone modifier data for a specific undertone
     * @param {string} undertone - Undertone name
     * @returns {Object|null} Undertone modifier data or null if invalid
     */
    getUndertoneModifier(undertone) {
        return this.errorBoundary.wrap(() => {
            // Try to get from renderer first (comprehensive modifiers)
            if (this.renderer && this.renderer.undertoneModifiers && 
                this.renderer.undertoneModifiers[undertone]) {
                // Return the full modifier from renderer
                return { ...this.renderer.undertoneModifiers[undertone] };
            }
            
            // Fallback to local modifiers
            if (!undertone || !Object.prototype.hasOwnProperty.call(this.undertoneModifiers, undertone)) {
                return null;
            }
            // Ensure essential properties exist in fallback
            const localMod = { ...this.undertoneModifiers[undertone] };
            if (!localMod.glowRadiusMult) {
                localMod.glowRadiusMult = 1.0; // Default value
            }
            return localMod;
        }, 'undertone-retrieval', null)();
    }
    
    /**
     * Gets weighted undertone modifiers based on current transition state
     * @returns {Object|null} Combined undertone modifiers with transition weights applied
     */
    getWeightedUndertoneModifiers() {
        const transition = this.transitions.undertone;
        
        // If no transition is active, return current undertone modifiers directly
        if (!transition.isActive) {
            if (this.state.undertone) {
                const mod = this.getUndertoneModifier(this.state.undertone);
                if (mod) {
                    // Return full modifier with weight of 1.0 (fully applied) and type
                    return { ...mod, weight: 1.0, type: this.state.undertone };
                }
            }
            return null;
        }
        
        // During transition, return the target modifier with interpolated weight
        if (transition.target) {
            const targetMod = this.getUndertoneModifier(transition.target);
            if (targetMod) {
                // Return target modifier with transition weight and type
                return { ...targetMod, weight: transition.targetWeight, type: transition.target };
            }
        }
        
        // Fading out - return current modifier with decreasing weight  
        if (transition.current && transition.currentWeight > 0) {
            const currentMod = this.getUndertoneModifier(transition.current);
            if (currentMod) {
                return { ...currentMod, weight: transition.currentWeight, type: transition.current };
            }
        }
        
        return null;
    }

    /**
     * Resets the state machine to neutral emotion
     * @param {number} duration - Transition duration in milliseconds
     */
    reset(duration = 500) {
        this.setEmotion('neutral', null, duration);
    }

    /**
     * Validates if an emotion is valid
     * @param {string} emotion - Emotion to validate
     * @returns {boolean} True if valid
     */
    isValidEmotion(emotion) {
        return Object.prototype.hasOwnProperty.call(this.emotionalStates, emotion);
    }

    /**
     * Validates if an undertone is valid
     * @param {string} undertone - Undertone to validate
     * @returns {boolean} True if valid
     */
    isValidUndertone(undertone) {
        return undertone === null || Object.prototype.hasOwnProperty.call(this.undertoneModifiers, undertone);
    }

    /**
     * Gets all available emotions
     * @returns {Array} Array of emotion names
     */
    getAvailableEmotions() {
        return Object.keys(this.emotionalStates);
    }

    /**
     * Gets all available undertones
     * @returns {Array} Array of undertone names
     */
    getAvailableUndertones() {
        return Object.keys(this.undertoneModifiers);
    }

    /**
     * Checks if a transition is currently active
     * @returns {boolean} True if transitioning
     */
    isTransitioning() {
        return this.transitions.emotional.isActive;
    }

    /**
     * Gets the current transition progress
     * @returns {number} Progress from 0 to 1, or 1 if not transitioning
     */
    getTransitionProgress() {
        return this.transitions.emotional.isActive ? this.transitions.emotional.progress : 1;
    }

    /**
     * Forces completion of current transition
     */
    completeTransition() {
        if (this.transitions.emotional.isActive) {
            this.transitions.emotional.progress = 1;
            this.transitions.emotional.isActive = false;
            this.transitions.emotional.current = this.transitions.emotional.target;
            this.transitions.emotional.target = null;
        }
    }

    /**
     * Gets interpolated property value with easing
     * @param {number} from - Start value
     * @param {number} to - End value  
     * @param {number} progress - Progress (0-1)
     * @param {string} easingType - Easing function name
     * @returns {number} Interpolated value
     */
    interpolateProperty(from, to, progress, easingType = 'easeOutCubic') {
        return from + (to - from) * applyEasing(progress, 0, 1, easingType);
    }

    /**
     * Enables simulated time for testing purposes
     * @param {boolean} enabled - Whether to use simulated time
     */
    enableSimulatedTime(enabled = true) {
        if (enabled) {
            this._simulatedTime = 0;
        } else {
            delete this._simulatedTime;
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Color Utilities
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Color selection and manipulation utilities for particles
 * @author Emotive Engine Team
 * @module particles/utils/colorUtils
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Handles weighted color selection for particles. Each emotion has a palette of     
 * ║ colors with different weights (probabilities). This creates visual variety        
 * ║ while maintaining the emotional theme.                                            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Select a color from an array with optional weights
 * 
 * EXAMPLE INPUT:
 * [
 *   { color: '#FF69B4', weight: 30 },  // 30% chance
 *   { color: '#FFB6C1', weight: 25 },  // 25% chance
 *   { color: '#FF1493', weight: 20 },  // 20% chance
 *   '#FFC0CB',                          // Remaining weight split evenly
 *   '#C71585'                           // between unweighted colors
 * ]
 * 
 * @param {Array} colors - Array of color strings or {color, weight} objects
 * @returns {string} Selected hex color
 */
function selectWeightedColor(colors) {
    if (!colors || colors.length === 0) return '#FFFFFF';
    
    // Parse colors and weights
    let totalExplicitWeight = 0;
    let unweightedCount = 0;
    const parsedColors = [];
    
    for (const item of colors) {
        if (typeof item === 'string') {
            // Simple string color - will get default weight
            parsedColors.push({ color: item, weight: null });
            unweightedCount++;
        } else if (item && typeof item === 'object' && item.color) {
            // Object with color and optional weight
            parsedColors.push({ color: item.color, weight: item.weight || null });
            if (item.weight) {
                totalExplicitWeight += item.weight;
            } else {
                unweightedCount++;
            }
        }
    }
    
    // Calculate weight for unweighted colors
    // If weights total 75, and there are 2 unweighted colors, each gets 12.5
    const remainingWeight = Math.max(0, 100 - totalExplicitWeight);
    const defaultWeight = unweightedCount > 0 ? remainingWeight / unweightedCount : 0;
    
    // Build cumulative probability table for efficient selection
    const probTable = [];
    let cumulative = 0;
    
    for (const item of parsedColors) {
        const weight = item.weight !== null ? item.weight : defaultWeight;
        cumulative += weight;
        probTable.push({ color: item.color, threshold: cumulative });
    }
    
    // Select based on random value
    const random = Math.random() * cumulative;
    for (const entry of probTable) {
        if (random <= entry.threshold) {
            return entry.color;
        }
    }
    
    // Fallback to last color (shouldn't happen but safety first)
    return parsedColors[parsedColors.length - 1].color;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Ambient Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Gentle upward drift behavior for neutral emotional state
 * @author Emotive Engine Team
 * @module particles/behaviors/ambient
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a calm, peaceful atmosphere with particles gently drifting upward         
 * ║ like smoke or steam. This is the default behavior for neutral emotional states.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑  ↑  ↑
 *       ·  ·  ·    ← particles drift straight up
 *      ·  ·  ·  
 *     ·  ⭐  ·     ← orb center
 *      ·  ·  ·
 *       ·  ·  ·
 * 
 * USED BY EMOTIONS:
 * - neutral (default calm state)
 * 
 * RECIPE TO MODIFY:
 * - Increase upwardSpeed for faster rising (more energy)
 * - Decrease friction for longer-lasting momentum
 * - Add waviness for side-to-side motion (currently disabled)
 */


/**
 * Initialize ambient behavior for a particle
 * Sets up initial velocities and behavior-specific data
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAmbient(particle) {
    // Start with gentle upward movement
    particle.vx = 0;  // NO horizontal drift
    particle.vy = -0.04 - Math.random() * 0.02;  // Slower upward movement
    particle.lifeDecay = 0.002;  // Even slower fade - particles last ~8 seconds
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Languid upward drift
        upwardSpeed: 0.0005,      // Very slow continuous upward drift
        waviness: 0,              // NO side-to-side (set to 0.5-2 for wave motion)
        friction: 0.998           // Even more gradual slowdown
    };
}

/**
 * Update ambient behavior each frame
 * Applies gentle upward drift with air resistance
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused but kept for consistency)
 * @param {number} centerY - Orb center Y (unused but kept for consistency)
 */
function updateAmbient(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Apply friction to y velocity only (frame-rate independent)
    // Use exponential decay: friction^dt where dt is normalized to 60fps
    particle.vy *= Math.pow(data.friction, dt);
    
    // Add continuous upward drift
    particle.vy -= data.upwardSpeed * dt;
    
    // NO horizontal movement or waviness (zen-like straight up)
    particle.vx = 0;
}

// Export behavior definition for registry
var ambient = {
    name: 'ambient',
    emoji: '☁️',
    description: 'Gentle upward drift like smoke',
    initialize: initializeAmbient,
    update: updateAmbient
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Particle Physics Configuration
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Physics constants for particle behavior
 * @author Emotive Engine Team
 * @module particles/config/physics
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Core physics values that control how particles move and interact with the world.  
 * ║ Modify these with caution as they affect all particle behaviors globally.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ PHYSICS CONSTANTS - Core physics values (modify with caution)
// └─────────────────────────────────────────────────────────────────────────────────────
const PHYSICS = {
    // Math constants
    TWO_PI: Math.PI * 2};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbiting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Romantic orbiting behavior for love emotional state
 * @author Emotive Engine Team
 * @module particles/behaviors/orbiting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a romantic atmosphere with particles orbiting the orb like fireflies      
 * ║ dancing at a valentine's day party. Features individual blinking and sparkles.    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ✨     ✨
 *      💕  ╭───╮  💕    ← particles orbit & sparkle
 *    ✨   │  ⭐  │   ✨   ← orb center
 *      💕  ╰───╯  💕
 *        ✨     ✨
 * 
 * USED BY EMOTIONS:
 * - love (romantic valentine vibes)
 * 
 * RECIPE TO MODIFY:
 * - Increase angularVelocity for faster spinning
 * - Increase floatAmount for more vertical movement
 * - Adjust blinkSpeed for different firefly effects
 * - Increase baseRadius for wider orbits
 */


/**
 * Initialize orbiting behavior for a particle
 * Creates valentine fireflies with individual timing
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeOrbiting(particle) {
    // Individual fade timing - each particle has its own lifespan
    particle.lifeDecay = 0.001 + Math.random() * 0.002;  // Variable decay (0.001-0.003)
    
    // Use emotion colors if provided - glittery valentine palette
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    // Check if this is a lighter/sparkle color (light pinks)
    particle.isSparkle = particle.color === '#FFE4E1' || 
                        particle.color === '#FFCCCB' || 
                        particle.color === '#FFC0CB';
    
    // Particles orbit at various distances for depth
    const orbRadius = (particle.scaleFactor || 1) * 40; // Approximate orb size
    const depthLayer = Math.random();
    const baseRadius = orbRadius * (1.3 + depthLayer * 0.9); // 1.3x to 2.2x orb radius
    
    // Glitter firefly properties - each with unique timing
    particle.blinkPhase = Math.random() * PHYSICS.TWO_PI; // Random starting phase
    particle.blinkSpeed = 0.3 + Math.random() * 1.2; // Varied blink speeds (0.3-1.5)
    particle.blinkIntensity = 0.6 + Math.random() * 0.4; // How bright the blink gets
    
    // Individual fade properties
    particle.fadePhase = Math.random() * PHYSICS.TWO_PI; // Random fade starting phase
    particle.fadeSpeed = 0.1 + Math.random() * 0.3; // Different fade speeds
    particle.minOpacity = 0.2 + Math.random() * 0.2; // Min brightness varies (0.2-0.4)
    particle.maxOpacity = 0.8 + Math.random() * 0.2; // Max brightness varies (0.8-1.0)
    
    // Sparkles have different properties
    if (particle.isSparkle) {
        particle.blinkSpeed *= 2; // Sparkles blink faster
        particle.blinkIntensity = 1.0; // Full intensity sparkles
        particle.minOpacity = 0; // Can fade to nothing
        particle.maxOpacity = 1.0; // Can be fully bright
    }
    
    particle.behaviorData = {
        angle: Math.random() * PHYSICS.TWO_PI,
        radius: baseRadius,
        baseRadius,
        angularVelocity: 0.0008 + Math.random() * 0.0017,  // Varied rotation speeds
        swayAmount: 3 + Math.random() * 7,  // Gentle floating sway
        swaySpeed: 0.2 + Math.random() * 0.5,  // Varied sway rhythm
        floatOffset: Math.random() * PHYSICS.TWO_PI,  // Random vertical float phase
        floatSpeed: 0.3 + Math.random() * 0.7,  // Varied vertical floating speed
        floatAmount: 2 + Math.random() * 6,  // How much they float up/down
        twinklePhase: Math.random() * PHYSICS.TWO_PI,  // Individual twinkle timing
        twinkleSpeed: 2 + Math.random() * 3  // Fast twinkle for glitter effect
    };
}

/**
 * Update orbiting behavior each frame
 * Creates romantic firefly dance with sparkles
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updateOrbiting(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;

    // Slow romantic rotation around the orb
    data.angle += data.angularVelocity * dt;

    // Gentle swaying motion
    const swayOffset = Math.sin(data.angle * data.swaySpeed) * data.swayAmount;

    // Radius changes for breathing effect
    const radiusPulse = Math.sin(data.angle * 1.5) * 6;

    // Use data.radius if it exists (can be modified by gestures), otherwise use baseRadius
    const currentRadius = (data.radius || data.baseRadius) + radiusPulse + swayOffset * 0.2;

    // Calculate desired orbital position
    const targetX = centerX + Math.cos(data.angle) * currentRadius;
    const targetY = centerY + Math.sin(data.angle) * currentRadius;

    // Add gentle vertical floating (like fireflies)
    data.floatOffset += data.floatSpeed * dt * 0.001;
    const verticalFloat = Math.sin(data.floatOffset) * data.floatAmount;

    // Smoothly move towards target position instead of directly setting it
    // This allows gestures to temporarily offset particles
    const smoothingFactor = 0.1; // How quickly particles return to orbit
    particle.vx = (targetX - particle.x) * smoothingFactor;
    particle.vy = (targetY + verticalFloat - particle.y) * smoothingFactor;
    
    // Update individual fade phase
    particle.fadePhase += particle.fadeSpeed * dt * 0.001;
    
    // Calculate individual particle fade (independent timing)
    const fadeValue = Math.sin(particle.fadePhase) * 0.5 + 0.5; // 0 to 1
    const fadeOpacity = particle.minOpacity + (particle.maxOpacity - particle.minOpacity) * fadeValue;
    
    // Firefly blinking effect
    particle.blinkPhase += particle.blinkSpeed * dt * 0.002;
    
    // Create a complex glitter blink with multiple harmonics
    let blinkValue;
    if (particle.isSparkle) {
        // Sparkles have sharp, dramatic twinkles
        data.twinklePhase += data.twinkleSpeed * dt * 0.001;
        const twinkle = Math.pow(Math.sin(data.twinklePhase), 16); // Sharp peaks
        const shimmer = Math.sin(particle.blinkPhase * 5) * 0.2;
        blinkValue = twinkle * 0.7 + shimmer + 0.1;
    } else {
        // Regular particles have smoother, firefly-like pulses
        blinkValue = Math.sin(particle.blinkPhase) * 0.4 + 
                    Math.sin(particle.blinkPhase * 3) * 0.3 +
                    Math.sin(particle.blinkPhase * 7) * 0.2 +
                    Math.sin(particle.blinkPhase * 11) * 0.1; // Added harmonic
    }
    
    // Map to 0-1 range with intensity control
    const normalizedBlink = (blinkValue + 1) * 0.5; // Convert from -1,1 to 0,1
    const blink = 0.2 + normalizedBlink * particle.blinkIntensity * 0.8;
    
    // Combine individual fade with blink effect
    particle.opacity = particle.baseOpacity * fadeOpacity * blink;
    
    // Sparkles pulse size more dramatically
    if (particle.isSparkle) {
        particle.size = particle.baseSize * (0.5 + normalizedBlink * 1.0); // 50-150% size
    } else {
        particle.size = particle.baseSize * (0.8 + normalizedBlink * 0.3); // 80-110% size
    }
    
    // Add subtle color shift for sparkles (shimmer effect)
    if (particle.isSparkle) {
        // Light pink sparkles can shift to white at peak brightness
        if (normalizedBlink > 0.85) {
            particle.tempColor = '#FFFFFF'; // Flash white at peak for extra sparkle
        } else {
            particle.tempColor = particle.color;
        }
    }
}

// Export behavior definition for registry
var orbiting = {
    name: 'orbiting',
    emoji: '💕',
    description: 'Romantic firefly dance around the orb',
    initialize: initializeOrbiting,
    update: updateOrbiting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rising Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Buoyant upward movement for joyful states
 * @author Emotive Engine Team
 * @module particles/behaviors/rising
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a buoyant, uplifting atmosphere with particles rising like bubbles        
 * ║ or balloons. Slight horizontal drift adds organic movement.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      ↗  ↑  ↖
 *     ·  ·  ·    ← particles rise with drift
 *    ·  ·  ·  
 *   ·  ⭐  ·     ← orb center
 *    ·  ·  ·
 *     ·  ·  ·
 * 
 * USED BY EMOTIONS:
 * - joy (subtle happiness)
 * - optimism
 * 
 * RECIPE TO MODIFY:
 * - Increase buoyancy for faster rising (like helium balloons)
 * - Increase driftAmount for more side-to-side movement
 * - Decrease air resistance for longer-lasting momentum
 */


/**
 * Initialize rising behavior for a particle
 * Sets up buoyant upward movement with gentle drift
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRising(particle) {
    particle.vx = (Math.random() - 0.5) * 0.02;  // Even slower horizontal drift
    particle.vy = -0.05 - Math.random() * 0.03;   // Much slower upward movement
    particle.lifeDecay = 0.002;                   // Very slow decay
    particle.baseOpacity = 0.7 + Math.random() * 0.3;  // More opaque (70-100%)
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        buoyancy: 0.001,      // Even gentler upward force
        driftAmount: 0.005    // Minimal drift
    };
}

/**
 * Update rising behavior each frame
 * Applies buoyancy and gentle drift
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateRising(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Add buoyancy (upward force)
    particle.vy -= data.buoyancy * dt;
    
    // Add horizontal drift
    particle.vx += (Math.random() - 0.5) * data.driftAmount * dt;
    
    // Apply air resistance (frame-independent)
    particle.vx *= Math.pow(0.995, dt);
    particle.vy *= Math.pow(0.998, dt);
}

// Export behavior definition for registry
var rising = {
    name: 'rising',
    emoji: '🎈',
    description: 'Buoyant upward movement like balloons',
    initialize: initializeRising,
    update: updateRising
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Falling Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Heavy downward drift for sad emotional states
 * @author Emotive Engine Team
 * @module particles/behaviors/falling
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a melancholic atmosphere with particles slowly falling like tears         
 * ║ or autumn leaves. Heavy, weighted movement conveys sadness.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     ·  ·  ·
 *    ·  ·  ·  
 *   ·  ⭐  ·     ← orb center
 *    ·  ·  ·
 *     ·  ·  ·    ← particles fall slowly
 *      ↓  ↓  ↓
 * 
 * USED BY EMOTIONS:
 * - sadness (melancholy, grief)
 * - disappointment
 * - tired
 * 
 * RECIPE TO MODIFY:
 * - Increase gravity for heavier falling (more weight)
 * - Decrease drag for faster falling (less air resistance)
 * - Add horizontal drift for leaf-like falling
 */


/**
 * Initialize falling behavior for a particle
 * Sets up slow, heavy downward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeFalling(particle) {
    particle.vx = (Math.random() - 0.5) * 0.03;   // MUCH slower horizontal drift
    particle.vy = 0.05 + Math.random() * 0.05;    // MUCH slower falling
    particle.lifeDecay = 0.002;                   // Very slow decay
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        gravity: 0.002,       // Very gentle gravity
        drag: 0.995           // High drag for slow fall
    };
}

/**
 * Update falling behavior each frame
 * Applies gravity with air resistance
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateFalling(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Apply gravity
    particle.vy += data.gravity * dt;
    
    // Apply drag (frame-independent)
    particle.vx *= Math.pow(data.drag, dt);
    particle.vy *= Math.pow(data.drag, dt);
    
    // Limit terminal velocity
    if (particle.vy > 2) {
        particle.vy = 2;
    }
}

// Export behavior definition for registry
var falling = {
    name: 'falling',
    emoji: '💧',
    description: 'Heavy downward drift like tears',
    initialize: initializeFalling,
    update: updateFalling
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Playground Configuration 🎮
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Safe values for experimentation and tweaking
 * @author Emotive Engine Team
 * @module particles/config/playground
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                            🎮 PLAYGROUND VALUES                                   
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ SAFE TO MODIFY! These values are designed for experimentation.                    
 * ║ Change them to create new visual effects and behaviors.                           
 * ║                                                                                    
 * ║ TIP: After changing values, refresh your browser to see the effects!              
 * ║ TIP: Set window.DEBUG_PARTICLES = true in console to visualize changes            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

const PLAYGROUND = {
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ POPCORN BEHAVIOR - Joy particles that pop!
    // └─────────────────────────────────────────────────────────────────────────────────
    popcorn: {
        POP_DELAY_MAX: 2000,   // 🎯 Slowest pop (ms) - Try: 1000-5000
        POP_FORCE_MIN: 3,      // 🎯 Weakest pop - Try: 1-5
        POP_FORCE_MAX: 8,      // 🎯 Strongest pop - Try: 5-15
        BOUNCE_HEIGHT: 0.7     // 🎯 Bounce energy retained - Try: 0.3-0.9
    }};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Popcorn Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Spontaneous popping with bounces for joyful celebration
 * @author Emotive Engine Team
 * @module particles/behaviors/popcorn
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a celebratory atmosphere with particles that wait, then POP! and bounce   
 * ║ around with gravity. Perfect for pure joy and celebration moments.                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Stage 1: Wait      Stage 2: POP!       Stage 3: Bounce
 *         ·                  💥 ↗             ↘ 
 *        ···                ↖ 💥 ↗              ↓
 *       ·⭐·                  💥                 🎊 ← bounce!
 *        ···                ↙ 💥 ↘              ↑
 *         ·                  💥 ↓               ↗
 * 
 * USED BY EMOTIONS:
 * - joy (celebration, happiness, excitement)
 * 
 * RECIPE TO MODIFY:
 * - Decrease popDelay for faster popping (more energetic)
 * - Increase popStrength for bigger pops
 * - Adjust gravity for different bounce physics
 * - Increase maxBounces for longer bouncing
 */


/**
 * Initialize popcorn behavior for a particle
 * Sets up kernel waiting to pop
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializePopcorn(particle) {
    // Start with little to no movement (kernel waiting to pop)
    particle.vx = (Math.random() - 0.5) * 0.1;
    particle.vy = (Math.random() - 0.5) * 0.1;
    // Faster, more varied decay for dynamic disappearing
    particle.lifeDecay = 0.008 + Math.random() * 0.012; // Random between 0.008-0.020
    
    // Use emotion colors if provided, otherwise default popcorn colors
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    } else {
        // Default popcorn colors (buttery whites and yellows)
        const colors = ['#FFFFFF', '#FFFACD', '#FFF8DC', '#FFFFE0', '#FAFAD2'];
        particle.color = selectWeightedColor(colors);
    }
    
    // Vary sizes more dramatically - some big fluffy pieces, some small
    particle.size = (Math.random() < 0.3) ? 
        (8 + Math.random() * 4) * particle.scaleFactor * particle.particleSizeMultiplier : // 30% big
        (2 + Math.random() * 4) * particle.scaleFactor * particle.particleSizeMultiplier;  // 70% small
    particle.baseSize = particle.size;
    
    // Less glow, more solid popcorn look
    particle.hasGlow = Math.random() < 0.2; // Only 20% have glow
    particle.glowSizeMultiplier = particle.hasGlow ? 1.2 : 0;
    
    particle.behaviorData = {
        // Popcorn popping mechanics
        popDelay: Math.random() * PLAYGROUND.popcorn.POP_DELAY_MAX,
        hasPopped: false,
        popStrength: PLAYGROUND.popcorn.POP_FORCE_MIN + 
                    Math.random() * (PLAYGROUND.popcorn.POP_FORCE_MAX - PLAYGROUND.popcorn.POP_FORCE_MIN),
        
        // Physics after popping
        gravity: 0.098,                    // Gravity strength
        bounceDamping: PLAYGROUND.popcorn.BOUNCE_HEIGHT,
        bounceCount: 0,
        maxBounces: 2 + Math.floor(Math.random() * 2), // 2-3 bounces
        
        // Visual flair
        spinRate: (Math.random() - 0.5) * 10, // Rotation speed (for future use)
        lifetime: 0                           // Track time since spawn
    };
}

/**
 * Update popcorn behavior each frame
 * Handles waiting, popping, and bouncing phases
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updatePopcorn(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    data.lifetime += dt * 16.67; // Convert to milliseconds
    
    // Check if it's time to pop
    if (!data.hasPopped && data.lifetime > data.popDelay) {
        // POP! Sudden burst of velocity in all directions for celebration
        data.hasPopped = true;
        const popAngle = Math.random() * Math.PI * 2; // Full 360 degree spread
        particle.vx = Math.cos(popAngle) * data.popStrength * 1.5; // Extra horizontal spread
        particle.vy = Math.sin(popAngle) * data.popStrength - 0.3; // Slight upward bias for joy
        
        // Expand size when popping for dramatic effect
        particle.size = particle.baseSize * 1.25;
    }
    
    if (data.hasPopped) {
        // Apply gravity
        particle.vy += data.gravity * dt;
        
        // Check for ground bounce
        const groundLevel = centerY + 100 * particle.scaleFactor; // Below the orb
        if (particle.y > groundLevel && data.bounceCount < data.maxBounces) {
            particle.y = groundLevel;
            particle.vy = -Math.abs(particle.vy) * data.bounceDamping; // Bounce up with damping
            particle.vx *= 0.9; // Reduce horizontal speed on bounce
            data.bounceCount++;
            
            // Shrink slightly with each bounce
            particle.size = particle.baseSize * (1.5 - data.bounceCount * 0.1);
        }
        
        // Fade dramatically after final bounce
        if (data.bounceCount >= data.maxBounces) {
            particle.lifeDecay = 0.03 + Math.random() * 0.02; // Very fast fade
            particle.size *= 0.95; // Also shrink rapidly
        }
        
        // Dynamic fading based on velocity - slower particles fade faster
        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (speed < 0.5) {
            particle.lifeDecay *= 1.5; // 50% faster fade when moving slowly
        }
    }
}

// Export behavior definition for registry
var popcorn = {
    name: 'popcorn',
    emoji: '🍿',
    description: 'Spontaneous popping with gravity and bounces',
    initialize: initializePopcorn,
    update: updatePopcorn
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Burst Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Explosive expansion for surprise and suspicion states
 * @author Emotive Engine Team
 * @module particles/behaviors/burst
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates dramatic expansion effects. For surprise: fast burst then sudden stop.    
 * ║ For suspicion: controlled, watchful expansion. Particles shoot out from center.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *   Surprise:                  Suspicion:
 *       💥→                        •→
 *     ↗ 💥 ↘                    ↗ • ↘
 *   ← ⭐ →    STOP!          ← ⭐ →    (controlled)
 *     ↙ 💥 ↖                    ↙ • ↖
 *       💥←                        •←
 * 
 * USED BY EMOTIONS:
 * - surprise (dramatic burst then stop)
 * - suspicion (controlled, watchful expansion)
 * 
 * RECIPE TO MODIFY:
 * - Increase speed for more dramatic burst
 * - Adjust friction for different deceleration
 * - Change stopTime for surprise effect timing
 */


/**
 * Initialize burst behavior for a particle
 * Sets up explosive outward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeBurst(particle) {
    // Check emotion type for behavior variation
    const isSuspicion = particle.emotion === 'suspicion';
    const isSurprise = particle.emotion === 'surprise';
    const isGlitch = particle.emotion === 'glitch';
    
    // Random direction for burst
    const angle = Math.random() * PHYSICS.TWO_PI;
    
    // Speed based on emotion
    const speed = isSuspicion ? 
        (1.0 + Math.random() * 0.8) :      // Controlled burst for suspicion (1-1.8)
        (isSurprise ? 
            (7.0 + Math.random() * 5.0) :  // Much faster burst for surprise (7-12)
            (isGlitch ?
                (2.0 + Math.random() * 1.5) : // Moderate burst for glitch (2-3.5)
                (3.5 + Math.random() * 2.5)));  // Normal burst for others (3.5-6)
    
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    
    // Lifespan based on emotion
    particle.lifeDecay = isSuspicion ? 
        0.010 : 
        (isSurprise ? 0.006 + Math.random() * 0.008 : 
            (isGlitch ? 0.012 : 0.015));
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    // Make suspicion particles more visible
    if (isSuspicion) {
        particle.size = (6 + Math.random() * 4) * 
                       (particle.scaleFactor || 1) * 
                       (particle.particleSizeMultiplier || 1);
        particle.baseSize = particle.size;
        particle.opacity = 1.0;  // Full opacity for visibility
        particle.baseOpacity = particle.opacity;
    }
    
    particle.behaviorData = {
        isSuspicion,
        isSurprise,
        isGlitch,
        age: 0,
        fadeStart: isSuspicion ? 0.3 : 0.2,  // When to start fading
        // Glitch wiggle properties
        glitchPhase: Math.random() * Math.PI * 2,
        glitchIntensity: isGlitch ? 0.3 : 0,
        glitchFrequency: isGlitch ? 0.1 : 0
    };
}

/**
 * Update burst behavior each frame
 * Handles explosive expansion with emotion-specific variations
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateBurst(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Surprise particles: burst out then STOP suddenly
    if (data.isSurprise) {
        // Track age for timing the stop
        data.age += dt * 0.016; // Convert to seconds
        
        if (data.age < 0.15) {
            // First 0.15 seconds: maintain high speed
            const friction = 0.98;
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
        } else if (data.age < 0.25) {
            // 0.15-0.25 seconds: SUDDEN STOP!
            const friction = 0.85; // Heavy braking
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
        } else {
            // After stop: float gently
            const friction = 0.99;
            particle.vx *= Math.pow(friction, dt);
            particle.vy *= Math.pow(friction, dt);
            // Tiny random drift
            particle.vx += (Math.random() - 0.5) * 0.01 * dt;
            particle.vy += (Math.random() - 0.5) * 0.01 * dt;
        }
    } else {
        // Normal burst behavior for other emotions
        const friction = data.isSuspicion ? 0.99 : (data.isGlitch ? 0.97 : 0.95);
        particle.vx *= Math.pow(friction, dt);
        particle.vy *= Math.pow(friction, dt);
    }
    
    // For suspicion, add a subtle scanning motion
    if (data.isSuspicion) {
        // Add a very subtle side-to-side drift
        const time = Date.now() * 0.001;
        particle.vx += Math.sin(time * 2 + particle.id) * 0.01 * dt;
    }
    
    // For glitch, add wiggle effect
    if (data.isGlitch) {
        data.age += dt * 0.016; // Track age for glitch timing
        
        // Update glitch phase
        data.glitchPhase += data.glitchFrequency * dt;
        
        // Add wiggle to velocity
        const wiggleX = Math.sin(data.glitchPhase) * data.glitchIntensity * dt;
        const wiggleY = Math.cos(data.glitchPhase * 1.3) * data.glitchIntensity * dt;
        
        particle.vx += wiggleX;
        particle.vy += wiggleY;
        
        // Occasionally add random glitch bursts
        if (Math.random() < 0.02) { // 2% chance per frame
            const burstAngle = Math.random() * Math.PI * 2;
            const burstSpeed = 0.5 + Math.random() * 0.5;
            particle.vx += Math.cos(burstAngle) * burstSpeed;
            particle.vy += Math.sin(burstAngle) * burstSpeed;
        }
    }
}

// Export behavior definition for registry
var burst$1 = {
    name: 'burst',
    emoji: '💥',
    description: 'Explosive expansion from center',
    initialize: initializeBurst,
    update: updateBurst
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Aggressive Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sharp, chaotic movement for angry emotional states
 * @author Emotive Engine Team
 * @module particles/behaviors/aggressive
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an intense, volatile atmosphere with particles moving erratically.        
 * ║ Sharp jitters and sudden bursts of movement convey anger and frustration.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      ⚡→    ←⚡
 *        ↘  ↙       ← erratic, sharp movements
 *    ⚡← ⭐ →⚡      ← orb center (shaking)
 *        ↗  ↖
 *      ⚡←    →⚡
 * 
 * USED BY EMOTIONS:
 * - anger (rage, fury)
 * - frustration
 * - irritation
 * 
 * RECIPE TO MODIFY:
 * - Increase jitter for more chaotic movement
 * - Increase acceleration for more violent bursts
 * - Decrease speedDecay for longer-lasting energy
 */


/**
 * Initialize aggressive behavior for a particle
 * Sets up chaotic, sharp movement patterns
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAggressive(particle) {
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 1.5 + Math.random() * 2;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.015;
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        acceleration: 0.05,
        jitter: 0.3,
        speedDecay: 0.95
    };
}

/**
 * Update aggressive behavior each frame
 * Applies jitter and random acceleration bursts
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X (unused)
 * @param {number} centerY - Orb center Y (unused)
 */
function updateAggressive(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Add jitter to movement
    particle.vx += (Math.random() - 0.5) * data.jitter * dt;
    particle.vy += (Math.random() - 0.5) * data.jitter * dt;
    
    // Apply speed decay (frame-independent)
    particle.vx *= Math.pow(data.speedDecay, dt);
    particle.vy *= Math.pow(data.speedDecay, dt);
    
    // Occasionally add burst of acceleration
    // Scale probability with frame time
    if (Math.random() < Math.min(0.05 * dt, 0.5)) {
        const angle = Math.random() * PHYSICS.TWO_PI;
        particle.vx += Math.cos(angle) * data.acceleration;
        particle.vy += Math.sin(angle) * data.acceleration;
    }
}

// Export behavior definition for registry
var aggressive = {
    name: 'aggressive',
    emoji: '⚡',
    description: 'Sharp, chaotic movement with violent bursts',
    initialize: initializeAggressive,
    update: updateAggressive
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Scattering Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles fleeing from center for fear states
 * @author Emotive Engine Team
 * @module particles/behaviors/scattering
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an anxious atmosphere with particles frantically fleeing from the center. 
 * ║ Conveys fear, panic, and the desire to escape.                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ← · · · →
 *    ↖       ↗       ← particles flee outward
 *  · · ⭐ · ·       ← orb center (source of fear)
 *    ↙       ↘
 *    ← · · · →
 * 
 * USED BY EMOTIONS:
 * - fear (panic, anxiety)
 * - startled
 * - nervous
 * 
 * RECIPE TO MODIFY:
 * - Increase fleeSpeed for more frantic escape
 * - Increase panicFactor for more erratic fleeing
 * - Add jitter for nervous shaking while fleeing
 */


/**
 * Initialize scattering behavior for a particle
 * Sets up fleeing movement away from center
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeScattering(particle) {
    // Will be set relative to center in update
    particle.vx = 0;
    particle.vy = 0;
    particle.lifeDecay = 0.008;  // Live longer to spread further
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        fleeSpeed: 2.0,     // Much faster fleeing
        panicFactor: 1.2,   // More panicked movement
        initialized: false
    };
}

/**
 * Update scattering behavior each frame
 * Particles flee away from center with panic
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (frame time)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function updateScattering(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Initialize flee direction if not done
    if (!data.initialized) {
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            particle.vx = (dx / distance) * data.fleeSpeed;
            particle.vy = (dy / distance) * data.fleeSpeed;
        } else {
            // If at center, pick random direction
            const angle = Math.random() * PHYSICS.TWO_PI;
            particle.vx = Math.cos(angle) * data.fleeSpeed;
            particle.vy = Math.sin(angle) * data.fleeSpeed;
        }
        data.initialized = true;
    }
    
    // Continue fleeing with panic factor
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > 0) {
        // Add acceleration away from center
        particle.vx += (dx / distance) * data.panicFactor * 0.01 * dt;
        particle.vy += (dy / distance) * data.panicFactor * 0.01 * dt;
    }
    
    // Add nervous jitter
    particle.vx += (Math.random() - 0.5) * 0.1 * dt;
    particle.vy += (Math.random() - 0.5) * 0.1 * dt;
    
    // Apply friction
    particle.vx *= Math.pow(0.98, dt);
    particle.vy *= Math.pow(0.98, dt);
}

// Export behavior definition for registry
var scattering = {
    name: 'scattering',
    emoji: '😨',
    description: 'Particles flee from center in panic',
    initialize: initializeScattering,
    update: updateScattering
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Repelling Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles pushed away from center for aversion states
 * @author Emotive Engine Team
 * @module particles/behaviors/repelling
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a space of rejection with particles being pushed away from the center,    
 * ║ maintaining a minimum distance. Conveys disgust, rejection, and boundaries.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ← - - - →
 *    ↖       ↗       ← particles pushed away
 *  - - (  ) - -      ← empty zone around center
 *    ↙       ↘       ← minimum distance maintained
 *    ← - - - →
 * 
 * USED BY EMOTIONS:
 * - disgust (keeping things at bay)
 * - contempt
 * - aversion
 * 
 * RECIPE TO MODIFY:
 * - Increase repelStrength for stronger push
 * - Increase minDistance for larger empty zone
 * - Adjust damping for smoother/rougher motion
 */


/**
 * Initialize repelling behavior for a particle
 * Sets up repulsion from center
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRepelling(particle) {
    particle.vx = 0;
    particle.vy = 0;
    particle.lifeDecay = 0.01; // Moderate life
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        repelStrength: 0.8,      // How strongly to push away
        minDistance: 50,         // Minimum distance from center
        initialized: false       // Track if initial repel has been applied
    };
}

/**
 * Update repelling behavior - particles maintain distance from center
 * 
 * Used for: DISGUST emotion (keeping unpleasant things away)
 * Visual effect: Particles are pushed away from center and maintain a 
 *                minimum distance, creating an empty zone
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateRepelling(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Calculate distance from center
    // dx/dy = distance from center to particle (can be negative)
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    // dist = straight-line distance using Pythagorean theorem
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // STEP 2: Apply repelling force if too close to center
    // This ensures particles maintain minimum distance
    if (!data.initialized || distance < data.minDistance) {
        if (distance > 0) {
            // Calculate repel force (stronger when closer)
            // Math.max(distance, 5) prevents division by very small numbers
            const repelForce = data.repelStrength / Math.max(distance, 5);
            
            // Apply force in direction away from center
            // dx/distance = unit vector component pointing away
            // Multiply by dt for frame-rate independence
            particle.vx += (dx / distance) * repelForce * dt;
            particle.vy += (dy / distance) * repelForce * dt;
        }
        data.initialized = true;
    }
    
    // STEP 3: Apply gentle damping to smooth motion
    // This prevents infinite acceleration and creates natural deceleration
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(0.99, dt);
    particle.vy *= Math.pow(0.99, dt);
}

// Export behavior definition for registry
var repelling = {
    name: 'repelling',
    emoji: '🚫',
    description: 'Particles pushed away from center, maintaining distance',
    initialize: initializeRepelling,
    update: updateRepelling
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Connecting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Chaotic particles drawn to center for social connection states
 * @author Emotive Engine Team
 * @module particles/behaviors/connecting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an energetic social atmosphere with particles moving chaotically but       
 * ║ staying connected to the center. Like a lively party or bustling community.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ↗↘ ↖↙ ↗↘
 *   ↙ ↗ ↘ ↖ ↙       ← chaotic but connected
 *  ↘ ↖ ⭐ ↗ ↙       ← drawn to center
 *   ↗ ↙ ↖ ↘ ↗       ← higher energy than ambient
 *    ↙↖ ↗↘ ↙↖
 * 
 * USED BY EMOTIONS:
 * - curiosity (social exploration)
 * - playfulness
 * - engagement
 * 
 * RECIPE TO MODIFY:
 * - Increase attractionForce for stronger pull to center
 * - Increase chaosFactor for more erratic movement
 * - Decrease friction for more energetic motion
 */


/**
 * Initialize connecting behavior for a particle
 * Sets up chaotic but connected movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeConnecting(particle) {
    // Original Emotive connecting: speed 2-7, higher chaos
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 2 + Math.random() * 5; // Faster than ambient
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.012; // Shorter life for more dynamic feel
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Higher attraction and chaos for connecting state
        attractionForce: 0.008,  // Stronger pull (original)
        chaosFactor: 1.0,        // Higher chaos (original)
        friction: 0.95          // Less friction than ambient
    };
}

/**
 * Update connecting behavior - chaotic movement with center attraction
 * 
 * Used for: CURIOSITY/SOCIAL emotions (engaged, exploring, connecting)
 * Visual effect: Particles move chaotically but are drawn back to center,
 *                creating a bustling, connected atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateConnecting(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Apply friction to slow particles gradually
    // This prevents infinite acceleration
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Apply attraction force towards center
    // (centerX - this.x) gives direction vector to center
    // Multiplied by attractionForce to control strength
    const attractX = (centerX - particle.x) * data.attractionForce;
    const attractY = (centerY - particle.y) * data.attractionForce;
    
    // STEP 3: Add chaos for erratic movement
    // (Math.random() - 0.5) gives random value between -0.5 and 0.5
    // Multiplied by chaosFactor for intensity
    const chaosX = (Math.random() - 0.5) * data.chaosFactor;
    const chaosY = (Math.random() - 0.5) * data.chaosFactor;
    
    // STEP 4: Combine forces
    // Attraction keeps particles connected to center
    // Chaos makes movement unpredictable and lively
    particle.vx += attractX + chaosX;
    particle.vy += attractY + chaosY;
}

// Export behavior definition for registry
var connecting = {
    name: 'connecting',
    emoji: '🔗',
    description: 'Chaotic movement with center attraction for social states',
    initialize: initializeConnecting,
    update: updateConnecting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Resting Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Ultra-slow movement for deeply relaxed states
 * @author Emotive Engine Team
 * @module particles/behaviors/resting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates an atmosphere of deep calm and rest. Particles barely move, creating      
 * ║ a meditative, peaceful environment. Like watching dust motes in sunlight.         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ·
 *       · ·         ← barely moving
 *      · · ·        ← vertical drift only
 *     · ⭐ ·        ← no horizontal motion
 *      · · ·        
 *       · ·         
 *        ·
 * 
 * USED BY EMOTIONS:
 * - sleepy (deep rest)
 * - meditative
 * - tranquil
 * 
 * RECIPE TO MODIFY:
 * - Decrease upwardSpeed for even slower movement
 * - Increase lifeDecay for shorter-lived particles
 * - Add tiny horizontal drift for slight variation
 */


/**
 * Initialize resting behavior for a particle
 * Sets up minimal movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeResting(particle) {
    particle.vx = 0;  // NO horizontal movement
    particle.vy = -0.01;  // Tiniest upward drift
    particle.lifeDecay = 0.001;  // Very slow fade - particles last 10+ seconds
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        upwardSpeed: 0.00002,  // Barely perceptible upward drift
        friction: 0.999       // Almost no friction (preserve any motion)
    };
}

/**
 * Update resting behavior - ultra-slow vertical drift
 * 
 * Used for: SLEEPY/MEDITATIVE emotions (deep rest, tranquility)
 * Visual effect: Particles drift upward so slowly they appear almost still,
 *                creating a deeply peaceful atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateResting(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Apply friction to vertical velocity only
    // This creates a very gentle deceleration
    // Math.pow ensures frame-rate independence
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Add tiny continuous upward drift
    // Negative value because canvas Y increases downward
    // Multiplied by dt for frame-rate independence
    particle.vy -= data.upwardSpeed * dt;
    
    // STEP 3: Enforce NO horizontal movement
    // This creates the characteristic vertical-only drift
    // Essential for the peaceful, non-chaotic feel
    particle.vx = 0;
}

// Export behavior definition for registry
var resting = {
    name: 'resting',
    emoji: '😴',
    description: 'Ultra-slow vertical drift for deep rest states',
    initialize: initializeResting,
    update: updateResting
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Radiant Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particles radiating outward like sun rays for euphoric states
 * @author Emotive Engine Team
 * @module particles/behaviors/radiant
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a euphoric atmosphere with particles bursting outward like sunbeams,      
 * ║ with shimmering and twinkling effects. Perfect for moments of pure joy and hope.  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ☀️
 *    ✨  ↗  ✨       ← particles radiate outward
 *  ✨ ↖ ⭐ ↗ ✨     ← orb center (like the sun)
 *    ✨  ↘  ✨       ← with shimmer effect
 *        ☀️
 * 
 * USED BY EMOTIONS:
 * - euphoria (first day of spring, sunrise vibes)
 * - elation
 * - triumph
 * 
 * RECIPE TO MODIFY:
 * - Increase radialSpeed for faster radiation
 * - Increase shimmerSpeed for faster twinkling
 * - Adjust friction for longer/shorter rays
 */


/**
 * Initialize radiant behavior for a particle
 * Sets up sunburst radiation pattern
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeRadiant(particle) {
    // Particles burst outward from center like sunbeams
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.8 + Math.random() * 0.4; // Moderate to fast speed
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.006; // Moderate life - last ~8-10 seconds
    
    // Use emotion colors if provided, otherwise default sunrise colors
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    } else {
        // Default golden sunrise colors
        const colors = ['#FFD700', '#FFB347', '#FFA500', '#FF69B4'];
        particle.color = selectWeightedColor(colors);
    }
    
    // More particles have glow for radiant effect
    particle.hasGlow = Math.random() < 0.7; // 70% chance of glow
    particle.glowSizeMultiplier = particle.hasGlow ? (1.5 + Math.random() * 0.5) : 0;
    
    particle.behaviorData = {
        // Continuous outward radiation
        radialSpeed: 0.02,        // Constant outward acceleration
        shimmer: Math.random() * PHYSICS.TWO_PI, // Initial shimmer phase
        shimmerSpeed: 0.1,        // Shimmer oscillation speed
        friction: 0.99            // Very light friction for long rays
    };
}

/**
 * Update radiant behavior - particles radiate outward like sun rays
 * 
 * Used for: EUPHORIA emotion (first day of spring, sunrise vibes)
 * Visual effect: Particles burst outward from center like sunbeams, with a 
 *                shimmering/twinkling effect as they travel
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (canvas center)
 * @param {number} centerY - Y coordinate of the orb's center (canvas center)
 */
function updateRadiant(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Calculate this particle's direction from the orb center
    // dx/dy = distance from center to particle (can be negative)
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    // dist = straight-line distance using Pythagorean theorem
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // STEP 2: Push particle outward from center (like sun rays)
    if (dist > 0) {
        // Convert dx/dy into a unit vector (length = 1) pointing away from center
        // This gives us pure direction without magnitude
        const dirX = dx / dist;
        const dirY = dy / dist;
        
        // Add velocity in the outward direction
        // radialSpeed controls how fast particles shoot outward
        // Multiply by dt to make movement frame-rate independent
        particle.vx += dirX * data.radialSpeed * dt;
        particle.vy += dirY * data.radialSpeed * dt;
    }
    
    // STEP 3: Create shimmering effect (particles twinkle as they radiate)
    // Increment shimmer phase over time (shimmerSpeed controls twinkle rate)
    data.shimmer += data.shimmerSpeed * dt;
    // Create sine wave oscillation (-1 to 1)
    const shimmerEffect = Math.sin(data.shimmer);
    // Make particle size pulse: baseSize ± 20%
    particle.size = particle.baseSize * (1 + shimmerEffect * 0.2);
    // Make particle opacity pulse: baseOpacity ± 30%
    particle.opacity = particle.baseOpacity * (1 + shimmerEffect * 0.3);
    
    // STEP 4: Apply friction to slow particles over time
    // This prevents infinite acceleration and creates natural deceleration
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
}

// Export behavior definition for registry
var radiant = {
    name: 'radiant',
    emoji: '☀️',
    description: 'Particles radiate outward like sunbeams',
    initialize: initializeRadiant,
    update: updateRadiant
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Ascending Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Slow, steady upward float for zen and meditative states
 * @author Emotive Engine Team
 * @module particles/behaviors/ascending
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a zen atmosphere with particles rising like incense smoke. Slow, steady,  
 * ║ and ethereal movement that gradually fades as particles ascend.                   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑
 *       ~~~        ← gentle wave motion
 *        ↑
 *       ~~~        ← like incense smoke
 *        ↑
 *      ⭐⭐⭐      ← orb center
 *        
 * 
 * USED BY EMOTIONS:
 * - zen (deep meditation)
 * - contemplative
 * - spiritual
 * 
 * RECIPE TO MODIFY:
 * - Decrease ascensionSpeed for slower rise
 * - Increase waveFactor for more horizontal drift
 * - Adjust fadeStartDistance to control when fade begins
 */


/**
 * Initialize ascending behavior for a particle
 * Sets up slow, steady upward movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeAscending(particle) {
    // Very slow, steady upward movement
    particle.vx = (Math.random() - 0.5) * 0.02;  // Minimal horizontal drift
    particle.vy = -0.03 - Math.random() * 0.02;  // Slow upward movement (0.03-0.05)
    particle.lifeDecay = 0.0008;  // Very long-lived particles (30+ seconds)
    
    // Larger, more ethereal particles for zen
    particle.size = (6 + Math.random() * 6) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1) * 
        1.33;  // 1.33x larger for zen (reduced from 2x)
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.2 + Math.random() * 0.2;  // Very translucent (20-40%)
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        // Continuous gentle upward drift
        ascensionSpeed: 0.0003,      // Very gentle continuous upward
        waveFactor: 0.5,             // Subtle horizontal wave motion
        waveFrequency: 0.001,        // Very slow wave oscillation
        friction: 0.998,             // Almost no slowdown
        fadeStartDistance: 100       // Start fading after rising 100px
    };
}

/**
 * Update ascending behavior - slow upward float like incense
 * 
 * Used for: ZEN/CONTEMPLATIVE emotions (meditation, spirituality)
 * Visual effect: Particles rise slowly and steadily with subtle wave motion,
 *                gradually fading as they ascend like incense smoke
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateAscending(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // Validate data exists
    if (!data) {
        initializeAscending(particle);
        return;
    }
    
    // STEP 1: Apply friction to velocities
    // Very light friction to maintain smooth motion
    // Math.pow ensures frame-rate independence
    particle.vx *= Math.pow(data.friction, dt);
    particle.vy *= Math.pow(data.friction, dt);
    
    // STEP 2: Add continuous upward ascension
    // Negative because canvas Y increases downward
    // Multiplied by dt for frame-rate independence
    particle.vy -= data.ascensionSpeed * dt;
    
    // STEP 3: Add subtle wave motion for organic feel
    // Creates the characteristic incense smoke waviness
    // Age gives us time-based oscillation
    const waveOffset = Math.sin(particle.age * data.waveFrequency * 1000) * data.waveFactor;
    particle.vx += waveOffset * 0.001 * dt;
    
    // STEP 4: Track initial Y position for fade calculation
    if (particle.initialY === undefined) {
        particle.initialY = particle.y;
    }
    
    // STEP 5: Calculate distance traveled upward
    const distanceTraveled = particle.initialY - particle.y;
    
    // STEP 6: Start fading after traveling fadeStartDistance pixels
    // This creates the incense smoke dissipation effect
    if (distanceTraveled > data.fadeStartDistance) {
        const fadeProgress = (distanceTraveled - data.fadeStartDistance) / 100;
        const fadeFactor = Math.max(0, 1 - fadeProgress);
        particle.baseOpacity *= 0.995;  // Gradual fade
        
        // Accelerate life decay as particle fades
        if (fadeFactor < 0.5) {
            particle.lifeDecay *= 1.02;
        }
    }
    
    // STEP 7: Dampen excessive horizontal movement
    // Keeps the ascension primarily vertical
    if (Math.abs(particle.vx) > 0.05) {
        particle.vx *= Math.pow(0.95, dt);
    }
    
    // STEP 8: Cap upward velocity for consistency
    // Prevents particles from accelerating too much
    if (particle.vy < -0.1) {
        particle.vy = -0.1;
    }
}

// Export behavior definition for registry
var ascending = {
    name: 'ascending',
    emoji: '🧘',
    description: 'Slow steady upward float like incense smoke',
    initialize: initializeAscending,
    update: updateAscending
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Erratic Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Nervous, jittery movement for anxious states
 * @author Emotive Engine Team
 * @module particles/behaviors/erratic
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a nervous, unstable atmosphere with particles jittering and changing       
 * ║ direction unpredictably. Conveys anxiety, nervousness, and instability.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    ↗↙↖  ↘↗
 *   ↙ ↗↘  ↖↙       ← unpredictable changes
 *  ↘↖ ⭐ ↗↙        ← jittery movement
 *   ↗ ↙↖  ↘↗       ← nervous energy
 *    ↙↗↘  ↖↙
 * 
 * USED BY EMOTIONS:
 * - nervous (anxiety, jitters)
 * - unstable
 * - agitated
 * 
 * RECIPE TO MODIFY:
 * - Increase jitterStrength for more shaking
 * - Increase directionChangeRate for more frequent changes
 * - Increase speedVariation for more erratic speed changes
 */


/**
 * Initialize erratic behavior for a particle
 * Sets up nervous, jittery movement
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeErratic(particle) {
    // Random, chaotic initial direction
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.1 + Math.random() * 0.15;
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.004;  // Shorter lived due to nervous energy
    
    particle.size = (2 + Math.random() * 4) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1);  // Varied sizes scaled
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.4 + Math.random() * 0.3;  // More visible
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        jitterStrength: 0.02,        // Random direction changes
        directionChangeRate: 0.1,    // How often to change direction
        speedVariation: 0.3,         // Speed changes randomly
        spinRate: 0.05 + Math.random() * 0.1  // Particles spin
    };
}

/**
 * Update erratic behavior - nervous, jittery movement
 * 
 * Used for: NERVOUS/ANXIOUS emotions (anxiety, instability, agitation)
 * Visual effect: Particles jitter nervously, changing direction and speed
 *                unpredictably, creating an unstable atmosphere
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center (unused)
 * @param {number} centerY - Y coordinate of the orb's center (unused)
 */
function updateErratic(particle, dt) {
    const data = particle.behaviorData;
    
    // STEP 1: Add constant jitter to movement
    // Creates the nervous shaking effect
    // (Math.random() - 0.5) gives values between -0.5 and 0.5
    // Multiplied by jitterStrength and dt for controlled chaos
    particle.vx += (Math.random() - 0.5) * data.jitterStrength * dt;
    particle.vy += (Math.random() - 0.5) * data.jitterStrength * dt;
    
    // STEP 2: Randomly change direction occasionally
    // Creates unpredictable movement patterns
    // Math.min ensures probability doesn't exceed reasonable bounds
    if (Math.random() < Math.min(data.directionChangeRate * dt, 0.5)) {
        // Pick new random direction
        const newAngle = Math.random() * PHYSICS.TWO_PI;
        const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        
        // Apply new direction while maintaining similar speed
        particle.vx = Math.cos(newAngle) * currentSpeed;
        particle.vy = Math.sin(newAngle) * currentSpeed;
    }
    
    // STEP 3: Vary the speed randomly
    // Creates erratic acceleration/deceleration
    const speedMultiplier = 1 + (Math.random() - 0.5) * data.speedVariation * dt;
    particle.vx *= speedMultiplier;
    particle.vy *= speedMultiplier;
    
    // STEP 4: Apply spin to particle size
    // Makes particles appear to rotate/vibrate
    const spinPhase = particle.age * data.spinRate * 1000;
    particle.size = particle.baseSize * (1 + Math.sin(spinPhase) * 0.2);
    
    // STEP 5: Fluctuate opacity nervously
    // Creates a flickering effect
    particle.opacity = particle.baseOpacity * (0.8 + Math.random() * 0.4);
    
    // STEP 6: Apply damping to prevent infinite acceleration
    // Keeps movement bounded
    particle.vx *= Math.pow(0.98, dt);
    particle.vy *= Math.pow(0.98, dt);
    
    // STEP 7: Cap maximum velocity
    // Prevents particles from moving too fast
    const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
    if (speed > 0.5) {
        particle.vx = (particle.vx / speed) * 0.5;
        particle.vy = (particle.vy / speed) * 0.5;
    }
}

// Export behavior definition for registry
var erratic = {
    name: 'erratic',
    emoji: '😰',
    description: 'Nervous jittery movement for anxious states',
    initialize: initializeErratic,
    update: updateErratic
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Cautious Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Slow, careful movement with pauses for suspicious states
 * @author Emotive Engine Team
 * @module particles/behaviors/cautious
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a watchful, suspicious atmosphere with particles moving slowly and         
 * ║ pausing frequently, as if carefully observing. Like being on guard.               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    · → · STOP
 *   STOP ← ·        ← move, then pause
 *    · ⭐ ·         ← watching center
 *   · STOP →        ← pause, then move
 *    STOP · ← ·
 * 
 * USED BY EMOTIONS:
 * - suspicion (watchful, guarded)
 * - uncertainty
 * - wariness
 * 
 * RECIPE TO MODIFY:
 * - Increase pauseDuration for longer stops
 * - Decrease moveDuration for shorter movements
 * - Adjust watchRadius to control patrol area
 */


/**
 * Initialize cautious behavior for a particle
 * Sets up slow, deliberate movement patterns
 * 
 * @param {Particle} particle - The particle to initialize
 */
function initializeCautious(particle) {
    // Particles move very slowly and deliberately
    const angle = Math.random() * PHYSICS.TWO_PI;
    const speed = 0.02 + Math.random() * 0.03; // Very slow: 0.02-0.05 units/frame
    particle.vx = Math.cos(angle) * speed;
    particle.vy = Math.sin(angle) * speed;
    particle.lifeDecay = 0.001;  // Very long-lived for visibility
    particle.life = 1.0;  // Ensure full life
    
    particle.size = (4 + Math.random() * 4) * 
        (particle.scaleFactor || 1) * 
        (particle.particleSizeMultiplier || 1);
    particle.baseSize = particle.size;
    particle.baseOpacity = 0.8 + Math.random() * 0.2;  // Very visible (80-100%)
    particle.opacity = particle.baseOpacity;
    
    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }
    
    particle.behaviorData = {
        pauseTimer: Math.random() * 2,      // Start with random pause offset
        pauseDuration: 0.5 + Math.random() * 0.5,  // Pause for 0.5-1s
        moveDuration: 1 + Math.random() * 0.5,     // Move for 1-1.5s
        isMoving: Math.random() > 0.5,             // Randomly start moving or paused
        moveTimer: 0,
        originalVx: particle.vx,
        originalVy: particle.vy,
        watchRadius: 50 + Math.random() * 30       // Stay within 50-80 units of core
    };
}

/**
 * Update cautious behavior - slow movement with frequent pauses
 * 
 * Used for: SUSPICION/UNCERTAINTY emotions (watchful, guarded, wary)
 * Visual effect: Particles move slowly and deliberately, pausing frequently
 *                as if carefully observing their surroundings
 * 
 * @param {Particle} particle - The particle to update
 * @param {number} dt - Delta time (milliseconds since last frame, typically ~16.67 for 60fps)
 * @param {number} centerX - X coordinate of the orb's center
 * @param {number} centerY - Y coordinate of the orb's center
 */
function updateCautious(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    
    // STEP 1: Update movement timer
    // Tracks how long we've been in current state (moving or paused)
    data.moveTimer += dt;
    
    // STEP 2: Switch between moving and pausing states
    if (data.isMoving) {
        // Currently moving - check if time to pause
        if (data.moveTimer > data.moveDuration) {
            data.isMoving = false;
            data.moveTimer = 0;
            // Stop movement during pause (watchful stillness)
            particle.vx = 0;
            particle.vy = 0;
        } else {
            // Continue moving at cautious speed
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
        }
    } else {
        // Currently paused - check if time to move
        if (data.moveTimer > data.pauseDuration) {
            data.isMoving = true;
            data.moveTimer = 0;
            // Pick a new careful direction
            const angle = Math.random() * PHYSICS.TWO_PI;
            const speed = 0.02 + Math.random() * 0.03;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;
            // Store for next movement phase
            data.originalVx = particle.vx;
            data.originalVy = particle.vy;
        }
    }
    
    // STEP 3: Keep particles within watch radius of core
    // They're suspicious, so they don't stray too far
    const dx = particle.x - centerX;
    const dy = particle.y - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist > data.watchRadius) {
        // Pull back towards core slowly (maintaining caution)
        const pullStrength = 0.02;
        particle.vx -= (dx / dist) * pullStrength * dt;
        particle.vy -= (dy / dist) * pullStrength * dt;
    }
    
    // STEP 4: Apply very light damping
    // Keeps movement controlled and deliberate
    particle.vx *= Math.pow(0.995, dt);
    particle.vy *= Math.pow(0.995, dt);
    
    // STEP 5: Subtle opacity flicker during pauses
    // Creates a watchful "blinking" effect
    if (!data.isMoving) {
        particle.opacity = particle.baseOpacity * (0.9 + Math.sin(particle.age * 5) * 0.1);
    } else {
        particle.opacity = particle.baseOpacity;
    }
}

// Export behavior definition for registry
var cautious = {
    name: 'cautious',
    emoji: '🤨',
    description: 'Slow careful movement with watchful pauses',
    initialize: initializeCautious,
    update: updateCautious
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Surveillance Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Searchlight scanning behavior for suspicious/paranoid states
 * @author Emotive Engine Team
 * @module particles/behaviors/surveillance
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Particles act like searchlights or surveillance cameras, slowly scanning back     
 * ║ and forth in arcs, pausing at edges, occasionally darting to new positions.       
 * ║ Creates a paranoid, watchful atmosphere with deliberate, searching movements.     
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * BEHAVIOR PATTERN:
 * • Slow horizontal scanning arcs (like searchlights)
 * • Pause at scan extremes (checking corners)
 * • Occasional quick darts to new positions (alert response)
 * • Some particles patrol perimeter (edge surveillance)
 * • Random freezing in place (listening/watching)
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  VISUAL: Searchlight Scanning                                                    │
 * │                                                                                   │
 * │     ←─────────────→  (slow scan)                                                │
 * │    •               •                                                             │
 * │                                                                                   │
 * │   pause...     ...pause                                                         │
 * │                                                                                   │
 * │     DART! ──→ • (quick repositioning)                                          │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


var surveillance = {
    name: 'surveillance',
    emoji: '👁️',
    description: 'Searchlight scanning with paranoid watchfulness',
    
    /**
     * Initialize particle state for surveillance behavior
     */
    initialize(particle, config) {
        // Set particle color from emotion palette
        if (particle.emotionColors && particle.emotionColors.length > 0) {
            particle.color = selectWeightedColor(particle.emotionColors);
        }
        
        particle.behaviorState = {
            // Scanning properties
            scanAngle: Math.random() * Math.PI - Math.PI/2,  // Current scan angle
            scanDirection: Math.random() < 0.5 ? 1 : -1,      // Scan direction
            scanSpeed: 0.3 + Math.random() * 0.2,             // Individual scan rate
            scanRange: Math.PI/3 + Math.random() * Math.PI/4, // Scan arc size
            scanCenter: Math.random() * Math.PI * 2,          // Center of scan arc
            pauseTimer: 0,                                     // Pause at edges
            pauseDuration: 500 + Math.random() * 500,         // How long to pause
            
            // Movement states
            mode: 'scanning',  // 'scanning', 'darting', 'frozen', 'patrolling'
            modeTimer: 0,
            nextModeChange: 2000 + Math.random() * 3000,
            
            // Dart properties
            dartTarget: { x: 0, y: 0 },
            dartSpeed: 0,
            
            // Patrol properties
            patrolRadius: 150 + Math.random() * 100,
            patrolAngle: Math.random() * Math.PI * 2,
            
            // Threat response
            alertLevel: 0,
            lastPosition: { x: particle.x, y: particle.y }
        };
        
        // Assign roles: 70% scanners, 20% patrollers, 10% watchers
        const role = Math.random();
        if (role < 0.7) {
            particle.behaviorState.primaryRole = 'scanner';
        } else if (role < 0.9) {
            particle.behaviorState.primaryRole = 'patroller';
            particle.behaviorState.mode = 'patrolling';
        } else {
            particle.behaviorState.primaryRole = 'watcher';
            particle.behaviorState.mode = 'frozen';
        }
    },
    
    /**
     * Update particle physics for surveillance behavior
     */
    update(particle, dt, config) {
        const state = particle.behaviorState;
        if (!state) return;
        
        // Update mode timer
        state.modeTimer += dt * 16;
        
        // Check for mode changes
        if (state.modeTimer > state.nextModeChange) {
            this.changeMode(particle, state);
            state.modeTimer = 0;
            state.nextModeChange = 2000 + Math.random() * 4000;
        }
        
        // Update based on current mode
        switch(state.mode) {
        case 'scanning':
            this.updateScanning(particle, dt, state, config);
            break;
        case 'darting':
            this.updateDarting(particle, dt, state, config);
            break;
        case 'frozen':
            this.updateFrozen(particle, dt, state, config);
            break;
        case 'patrolling':
            this.updatePatrolling(particle, dt, state, config);
            break;
        }
        
        // Apply slight downward drift for weight
        particle.vy += 0.05 * dt;
        
        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Store last position
        state.lastPosition.x = particle.x;
        state.lastPosition.y = particle.y;
    },
    
    /**
     * Scanning mode - slow searchlight sweeps
     */
    updateScanning(particle, dt, state, config) {
        // Update scan angle
        if (state.pauseTimer > 0) {
            // Pausing at edge of scan
            state.pauseTimer -= dt * 16;
            particle.vx *= 0.9;  // Slow down during pause
            particle.vy *= 0.9;
        } else {
            // Active scanning
            state.scanAngle += state.scanDirection * state.scanSpeed * dt * 0.02;
            
            // Check scan limits and pause at edges
            if (Math.abs(state.scanAngle) > state.scanRange / 2) {
                state.scanDirection *= -1;
                state.pauseTimer = state.pauseDuration;
                state.scanAngle = Math.sign(state.scanAngle) * state.scanRange / 2;
            }
        }
        
        // Apply scanning motion
        const actualAngle = state.scanCenter + state.scanAngle;
        const speed = 0.8 + state.alertLevel * 0.5;
        particle.vx = Math.cos(actualAngle) * speed;
        particle.vy = Math.sin(actualAngle) * speed * 0.3;  // Less vertical movement
    },
    
    /**
     * Darting mode - quick repositioning
     */
    updateDarting(particle, dt, state, config) {
        const dx = state.dartTarget.x - particle.x;
        const dy = state.dartTarget.y - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
            // Move toward dart target quickly
            particle.vx = (dx / distance) * state.dartSpeed;
            particle.vy = (dy / distance) * state.dartSpeed;
        } else {
            // Reached target, switch back to scanning
            state.mode = 'scanning';
            state.modeTimer = 0;
        }
    },
    
    /**
     * Frozen mode - watchful stillness
     */
    updateFrozen(particle, dt, state, config) {
        // Almost no movement, just tiny vibrations
        particle.vx *= 0.95;
        particle.vy *= 0.95;
        
        // Occasional tiny twitch
        if (Math.random() < 0.01) {
            particle.vx += (Math.random() - 0.5) * 0.5;
            particle.vy += (Math.random() - 0.5) * 0.5;
        }
    },
    
    /**
     * Patrolling mode - edge surveillance
     */
    updatePatrolling(particle, dt, state, config) {
        // Patrol in a circle around the edge
        state.patrolAngle += 0.01 * dt;
        
        const targetX = Math.cos(state.patrolAngle) * state.patrolRadius;
        const targetY = Math.sin(state.patrolAngle) * state.patrolRadius;
        
        // Move toward patrol position
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;
        
        particle.vx = dx * 0.02;
        particle.vy = dy * 0.02;
    },
    
    /**
     * Change behavior mode
     */
    changeMode(particle, state) {
        const rand = Math.random();
        
        // Mode transition probabilities based on role
        if (state.primaryRole === 'scanner') {
            if (rand < 0.1) {
                // Dart to new position
                state.mode = 'darting';
                state.dartTarget = {
                    x: (Math.random() - 0.5) * 200,
                    y: (Math.random() - 0.5) * 200
                };
                state.dartSpeed = 3 + Math.random() * 2;
            } else if (rand < 0.2) {
                // Freeze and watch
                state.mode = 'frozen';
            } else {
                // Continue scanning
                state.mode = 'scanning';
            }
        } else if (state.primaryRole === 'patroller') {
            if (rand < 0.1) {
                state.mode = 'frozen';
            } else {
                state.mode = 'patrolling';
            }
        } else {
            // Watcher role
            if (rand < 0.3) {
                state.mode = 'scanning';
            } else {
                state.mode = 'frozen';
            }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glitchy Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Digital glitch behavior with stuttering orbits and corruption
 * @author Emotive Engine Team
 * @module particles/behaviors/glitchy
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Particles orbit like in love state but with digital glitches, stutters, and      
 * ║ corruption artifacts. Creates a captivating dubstep-like visual rhythm.           
 * ║ Combines smooth orbiting with sudden position jumps and digital artifacts.        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * BEHAVIOR PATTERN:
 * • Base orbiting motion (like love state)
 * • Random position jumps (teleportation glitches)
 * • Stuttering/freezing (frame drops)
 * • Trail duplication (ghosting artifacts)
 * • RGB channel separation
 * • Digital noise bursts
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  VISUAL: Glitched Orbiting                                                       │
 * │                                                                                   │
 * │       ░░▒▒▓▓█  ←─ Digital trail                                                 │
 * │     •  ┊  •                                                                      │
 * │   •┊  ⚡  ┊•  ←─ Glitch jump                                                    │
 * │     •  ┊  •                                                                      │
 * │       ░░▒▒▓▓█                                                                    │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


var glitchy = {
    name: 'glitchy',
    emoji: '⚡',
    description: 'Digital glitch with stuttering orbits and corruption',
    
    // Rhythm configuration for glitchy behavior
    rhythm: {
        enabled: true,
        
        // Glitch events sync to rhythm
        glitchTiming: {
            mode: 'subdivision',     // Glitch on subdivisions
            subdivision: 'sixteenth', // 16th notes for rapid glitches
            probability: 0.3,        // 30% chance on each 16th
            intensityOnBeat: 2.0,    // Stronger glitches on beat
            intensityOffBeat: 0.5    // Weaker between beats
        },
        
        // Stutter/freeze timing
        stutterSync: {
            mode: 'pattern',         // Based on rhythm pattern
            patterns: {
                'dubstep': {
                    freezeOnDrop: true,  // Freeze on the drop (beat 3)
                    dropDuration: 100    // Freeze for 100ms
                },
                'breakbeat': {
                    randomFreeze: 0.1,   // 10% chance per beat
                    duration: 50         // Short 50ms freezes
                }
            }
        },
        
        // Orbital speed modulation
        orbitRhythm: {
            baseSpeed: 'tempo',      // Speed scales with BPM
            wobbleSync: 'eighth',    // Wobble on 8th notes
            beatAcceleration: 1.5,   // Speed boost on beat
            barReset: true           // Reset orbit angle each bar
        },
        
        // RGB split effect rhythm
        rgbSync: {
            enabled: true,
            amount: 'intensity',     // Split based on musical intensity
            direction: 'beat',        // Change split direction on beat
            maxSplit: 10             // Maximum pixel split
        },
        
        // Digital noise bursts
        noiseRhythm: {
            trigger: 'accent',       // Noise on accented beats
            duration: 50,            // 50ms noise bursts
            intensity: 'drop'        // Scale with drop intensity
        }
    },
    
    /**
     * Initialize particle state for glitchy behavior
     */
    initialize(particle, config, centerX, centerY) {
        // Set particle color from emotion palette
        if (particle.emotionColors && particle.emotionColors.length > 0) {
            particle.color = selectWeightedColor(particle.emotionColors);
        }
        
        particle.behaviorState = {
            // Orbital properties (spread out from center)
            orbitAngle: Math.random() * Math.PI * 2,
            orbitRadius: 300 + Math.random() * 400,  // Dramatically increased to 300-700 for very wide spread
            orbitSpeed: 0.01 + Math.random() * 0.02,
            
            // Glitch properties
            glitchTimer: 0,
            nextGlitch: Math.random() * 500 + 100,
            isGlitching: false,
            glitchDuration: 0,
            glitchOffset: { x: 0, y: 0 },
            
            // Stutter properties
            stutterTimer: 0,
            nextStutter: Math.random() * 200 + 50,
            isFrozen: false,
            frozenPosition: { x: 0, y: 0 },
            frozenVelocity: { x: 0, y: 0 },
            
            // Trail ghost properties
            hasGhost: Math.random() < 0.3,
            ghostOffset: Math.random() * 20 + 10,
            ghostAngle: Math.random() * Math.PI * 2,
            
            // RGB separation
            rgbSplit: Math.random() < 0.4,
            rgbPhase: Math.random() * Math.PI * 2,
            
            // Digital noise
            noiseLevel: 0,
            noiseBurst: false,
            
            // Dubstep rhythm sync
            beatPhase: Math.random() * Math.PI * 2,
            beatFrequency: 0.05 + Math.random() * 0.03,
            dropIntensity: 0
        };
        
        // Special properties for glitch
        particle.lifeDecay = 0.0015; // Slower decay for trails
        particle.hasGlow = true; // Always glow for digital effect
        particle.glowSizeMultiplier = 3.0 + Math.random() * 2; // Much bigger glows for visibility
    },
    
    /**
     * Update particle physics for glitchy behavior
     */
    update(particle, dt, centerX, centerY) {
        const state = particle.behaviorState;
        if (!state) return;
        
        // centerX and centerY are passed correctly from updateBehavior
        // No need for fallbacks - they should always be provided
        
        // Update timers
        state.glitchTimer += dt * 16;
        state.stutterTimer += dt * 16;
        
        // Check for stutter/freeze
        if (state.stutterTimer > state.nextStutter) {
            if (!state.isFrozen) {
                // Start freeze
                state.isFrozen = true;
                state.frozenPosition = { x: particle.x, y: particle.y };
                state.frozenVelocity = { x: particle.vx, y: particle.vy };
                state.stutterTimer = 0;
                state.nextStutter = 20 + Math.random() * 40; // Short freeze
            } else {
                // End freeze
                state.isFrozen = false;
                state.stutterTimer = 0;
                state.nextStutter = 100 + Math.random() * 300;
                
                // Sometimes jump on unfreeze (larger jumps to maintain spread)
                if (Math.random() < 0.3) {
                    particle.x += (Math.random() - 0.5) * 60;  // Increased from 20 to 60
                    particle.y += (Math.random() - 0.5) * 60;  // Increased from 20 to 60
                }
            }
        }
        
        // Check for glitch events
        if (state.glitchTimer > state.nextGlitch && !state.isGlitching) {
            state.isGlitching = true;
            state.glitchDuration = 50 + Math.random() * 100;
            state.glitchOffset = {
                x: (Math.random() - 0.5) * 80,  // Increased from 30 to 80 for wider spread
                y: (Math.random() - 0.5) * 80   // Increased from 30 to 80 for wider spread
            };
            state.glitchTimer = 0;
            
            // Change color during glitch
            if (Math.random() < 0.5 && particle.emotionColors) {
                particle.color = selectWeightedColor(particle.emotionColors);
            }
        }
        
        // End glitch
        if (state.isGlitching && state.glitchTimer > state.glitchDuration) {
            state.isGlitching = false;
            state.glitchTimer = 0;
            state.nextGlitch = 200 + Math.random() * 800;
            state.glitchOffset = { x: 0, y: 0 };
        }
        
        // Update beat phase for dubstep rhythm
        state.beatPhase += state.beatFrequency * dt;
        const beatIntensity = Math.sin(state.beatPhase) * 0.5 + 0.5;
        
        // Calculate drop intensity (periodic bass drops)
        const dropCycle = state.beatPhase % (Math.PI * 4);
        if (dropCycle < Math.PI * 0.5) {
            state.dropIntensity = Math.min(1, state.dropIntensity + dt * 0.1);
        } else {
            state.dropIntensity = Math.max(0, state.dropIntensity - dt * 0.05);
        }
        
        if (!state.isFrozen) {
            // Update orbital position with beat modulation
            state.orbitAngle += state.orbitSpeed * dt * (1 + beatIntensity * 0.5);
            
            // Add drop wobble
            const wobbleRadius = state.orbitRadius * (1 + state.dropIntensity * 0.3 * Math.sin(state.beatPhase * 4));
            
            // Calculate target position relative to center
            let targetX = centerX + Math.cos(state.orbitAngle) * wobbleRadius;
            let targetY = centerY + Math.sin(state.orbitAngle) * wobbleRadius * 0.6; // Elliptical
            
            // Apply glitch offset (stronger effect for wider spread)
            if (state.isGlitching) {
                targetX += state.glitchOffset.x * Math.random() * 0.8;  // Increased from 0.5 to 0.8
                targetY += state.glitchOffset.y * Math.random() * 0.8;  // Increased from 0.5 to 0.8
            }
            
            // RGB split effect
            if (state.rgbSplit) {
                const splitAmount = 3 * (1 + state.dropIntensity);
                targetX += Math.sin(state.rgbPhase) * splitAmount;
                targetY += Math.cos(state.rgbPhase) * splitAmount;
                state.rgbPhase += 0.1 * dt;
            }
            
            // Digital noise bursts on drops (larger to maintain spread)
            if (state.dropIntensity > 0.8 && Math.random() < 0.1) {
                targetX += (Math.random() - 0.5) * 30;  // Increased from 10 to 30
                targetY += (Math.random() - 0.5) * 30;  // Increased from 10 to 30
            }
            
            // Minimal pull to center to allow maximum spread
            const smoothing = state.isGlitching ? 0.02 : 0.03;  // Further reduced from 0.03/0.05
            particle.vx = (targetX - particle.x) * smoothing;
            particle.vy = (targetY - particle.y) * smoothing;
            
            // Add jitter based on beat
            particle.vx += (Math.random() - 0.5) * beatIntensity * 2;
            particle.vy += (Math.random() - 0.5) * beatIntensity * 2;
            
        } else {
            // Frozen - vibrate in place
            particle.vx = (Math.random() - 0.5) * 0.5;
            particle.vy = (Math.random() - 0.5) * 0.5;
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Flicker opacity for digital effect
        if (Math.random() < 0.02) {
            particle.opacity = 0.1 + Math.random() * 0.9;
        }
        
        // Size pulsing with beat
        particle.size = particle.baseSize * (1 + beatIntensity * 0.3 + state.dropIntensity * 0.5);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Spaz Particle Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Ultra-aggressive particle behavior with explosive spread and chaotic motion
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module particles/behaviors/spaz
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates particles that explode outward in all directions with chaotic, erratic    
 * ║ motion. Particles spawn far from center and maintain aggressive spread patterns.  
 * ║ Perfect for high-energy emotions like glitch, anger, or excitement.              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

var spaz = {
    name: 'spaz',
    description: 'Ultra-aggressive particles with explosive spread and chaotic motion',
    
    /**
     * Initialize particle with spaz behavior
     * @param {Object} particle - Particle object to initialize
     * @param {Object} config - Configuration object
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    initialize(particle, config, centerX, centerY) {
        // Set basic particle properties
        particle.x = centerX;
        particle.y = centerY;
        particle.life = 1.0;
        particle.size = 3 + Math.random() * 4; // Larger particles for visibility
        
        // Explosive velocity - particles shoot out in random directions
        const angle = Math.random() * Math.PI * 2;
        const speed = 200 + Math.random() * 300; // Very fast initial velocity
        particle.vx = Math.cos(angle) * speed;
        particle.vy = Math.sin(angle) * speed;
        
        // Spaz-specific state
        particle.behaviorState = {
            // Explosive properties
            explosionPhase: 0, // 0 = initial explosion, 1 = chaotic motion
            explosionTimer: 0,
            explosionDuration: 1000 + Math.random() * 2000, // 1-3 seconds
            
            // Chaotic motion properties
            chaosTimer: 0,
            nextChaosChange: 100 + Math.random() * 200, // Change direction every 100-300ms
            chaosAngle: angle,
            chaosSpeed: 50 + Math.random() * 100,
            
            // Spaz-specific effects
            spazIntensity: 0.8 + Math.random() * 0.4, // How intense the spazzing is
            zigzagPattern: Math.random() < 0.5, // Some particles zigzag
            spiralPattern: Math.random() < 0.3, // Some particles spiral
            teleportChance: 0.02, // 2% chance to teleport to random position
            
            // Visual effects
            sizePulse: true,
            sizePulseSpeed: 0.1 + Math.random() * 0.05,
            sizePulsePhase: Math.random() * Math.PI * 2,
            colorShift: Math.random() < 0.3, // Some particles shift colors
            colorShiftSpeed: 0.05 + Math.random() * 0.03
        };
        
        // Special properties for spaz
        particle.lifeDecay = 0.0008; // Slower decay for longer trails
        particle.hasGlow = true; // Always glow for maximum visibility
        particle.glowSizeMultiplier = 4.0 + Math.random() * 3; // Very large glows
        particle.glowIntensity = 1.5 + Math.random() * 0.5; // Bright glows
    },
    
    /**
     * Update particle physics for spaz behavior
     * @param {Object} particle - Particle to update
     * @param {number} dt - Delta time in milliseconds
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    update(particle, dt, centerX, centerY) {
        const state = particle.behaviorState;
        
        // Update timers
        state.explosionTimer += dt;
        state.chaosTimer += dt;
        
        // Phase 1: Initial explosion (first 500ms)
        if (state.explosionPhase === 0 && state.explosionTimer < 500) {
            // Maintain explosive velocity with slight deceleration
            particle.vx *= 0.98;
            particle.vy *= 0.98;
            
            // Add random bursts during explosion
            if (Math.random() < 0.1) {
                particle.vx += (Math.random() - 0.5) * 100;
                particle.vy += (Math.random() - 0.5) * 100;
            }
        }
        // Phase 2: Transition to chaotic motion
        else if (state.explosionPhase === 0 && state.explosionTimer >= 500) {
            state.explosionPhase = 1;
            // Set up chaotic motion
            state.chaosAngle = Math.random() * Math.PI * 2;
            state.chaosSpeed = 30 + Math.random() * 70;
        }
        // Phase 3: Chaotic motion
        else if (state.explosionPhase === 1) {
            // Change direction periodically
            if (state.chaosTimer >= state.nextChaosChange) {
                state.chaosAngle = Math.random() * Math.PI * 2;
                state.chaosSpeed = 20 + Math.random() * 80;
                state.nextChaosChange = 50 + Math.random() * 150;
                state.chaosTimer = 0;
            }
            
            // Apply chaotic motion
            const chaosVx = Math.cos(state.chaosAngle) * state.chaosSpeed;
            const chaosVy = Math.sin(state.chaosAngle) * state.chaosSpeed;
            
            // Mix with current velocity for smooth transitions
            particle.vx = particle.vx * 0.7 + chaosVx * 0.3;
            particle.vy = particle.vy * 0.7 + chaosVy * 0.3;
            
            // Special patterns
            if (state.zigzagPattern) {
                // Zigzag motion
                const zigzagAngle = state.chaosTimer * 0.01;
                particle.vx += Math.sin(zigzagAngle) * 20;
                particle.vy += Math.cos(zigzagAngle) * 20;
            }
            
            if (state.spiralPattern) {
                // Spiral motion
                const spiralAngle = state.chaosTimer * 0.005;
                const spiralRadius = 50 + Math.sin(state.chaosTimer * 0.003) * 30;
                particle.vx += Math.cos(spiralAngle) * spiralRadius * 0.1;
                particle.vy += Math.sin(spiralAngle) * spiralRadius * 0.1;
            }
        }
        
        // Teleport effect (rare)
        if (Math.random() < state.teleportChance) {
            const teleportAngle = Math.random() * Math.PI * 2;
            const teleportDistance = 200 + Math.random() * 400;
            particle.x = centerX + Math.cos(teleportAngle) * teleportDistance;
            particle.y = centerY + Math.sin(teleportAngle) * teleportDistance;
            particle.vx = (Math.random() - 0.5) * 200;
            particle.vy = (Math.random() - 0.5) * 200;
        }
        
        // Update position
        particle.x += particle.vx * (dt / 1000);
        particle.y += particle.vy * (dt / 1000);
        
        // Size pulsing effect
        if (state.sizePulse) {
            state.sizePulsePhase += state.sizePulseSpeed * dt;
            const pulseMultiplier = 1.0 + Math.sin(state.sizePulsePhase) * 0.5;
            particle.size = (3 + Math.random() * 4) * pulseMultiplier;
        }
        
        // Color shifting effect
        if (state.colorShift) {
            state.colorShiftPhase = (state.colorShiftPhase || 0) + state.colorShiftSpeed * dt;
            // This would be handled by the renderer if color shifting is implemented
        }
        
        // Apply friction to prevent infinite acceleration
        particle.vx *= 0.995;
        particle.vy *= 0.995;
        
        // Decay life
        particle.life -= particle.lifeDecay * dt;
        
        // Reset particle if it goes too far or dies
        if (particle.life <= 0 || 
            Math.abs(particle.x - centerX) > 2000 || 
            Math.abs(particle.y - centerY) > 2000) {
            particle.life = 0;
        }
    },
    
    /**
     * Get spawn position for spaz particles
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     * @returns {Object} Spawn position {x, y}
     */
    getSpawnPosition(centerX, centerY) {
        // Spawn particles in a wide ring around the center
        const angle = Math.random() * Math.PI * 2;
        const radius = 100 + Math.random() * 200; // Spawn 100-300 pixels from center
        return {
            x: centerX + Math.cos(angle) * radius,
            y: centerY + Math.sin(angle) * radius
        };
    },
    
    /**
     * Get visual properties for spaz particles
     * @returns {Object} Visual properties
     */
    getVisualProperties() {
        return {
            glowColor: '#FF00AA', // Hot magenta
            glowIntensity: 2.0,
            particleColors: [
                { color: '#FF00AA', weight: 30 }, // Hot magenta
                { color: '#00FFAA', weight: 25 }, // Bright cyan-green
                { color: '#FFAA00', weight: 20 }, // Digital amber
                { color: '#AA00FF', weight: 15 }, // Purple
                { color: '#00AAFF', weight: 10 }  // Blue
            ]
        };
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Directed Particle Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Directed behavior - particles move in focused, straight paths
 * @author Emotive Engine Team
 * @module particles/behaviors/directed
 */

/**
 * DIRECTED BEHAVIOR - FOCUSED STRAIGHT PATHS
 * Used by: focused emotion
 * 
 * Particles move in deliberate, straight lines toward a target or direction,
 * representing intense concentration and focus.
 */
var directed = {
    name: 'directed',
    emoji: '🎯',
    description: 'Focused, straight-line movement toward target',
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ CONFIGURATION
    // └─────────────────────────────────────────────────────────────────────────────────
    config: {
        speed: 3.0,              // Fast movement
        acceleration: 0.15,      // Quick acceleration
        focusStrength: 0.8,      // Strong pull toward target
        randomness: 0.1,         // Minimal deviation
        edgeBuffer: 50           // Buffer from canvas edges
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ INITIALIZATION
    // └─────────────────────────────────────────────────────────────────────────────────
    initialize(particle, centerX, centerY, canvasWidth, canvasHeight) {
        // Set initial direction toward center
        const dx = centerX - particle.x;
        const dy = centerY - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
            particle.vx = (dx / distance) * this.config.speed;
            particle.vy = (dy / distance) * this.config.speed;
        } else {
            // Random initial direction if at center
            const angle = Math.random() * Math.PI * 2;
            particle.vx = Math.cos(angle) * this.config.speed;
            particle.vy = Math.sin(angle) * this.config.speed;
        }
        
        // Store target position
        particle.targetX = centerX;
        particle.targetY = centerY;
        particle.directedPhase = 0;
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ UPDATE LOOP
    // └─────────────────────────────────────────────────────────────────────────────────
    update(particle, dt, centerX, centerY, canvasWidth, canvasHeight) {
        // Update phase for variation
        particle.directedPhase += dt * 0.05;
        
        // Calculate direction to target
        const dx = particle.targetX - particle.x;
        const dy = particle.targetY - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 10) {
            // Move toward target with focus strength
            const targetVx = (dx / distance) * this.config.speed;
            const targetVy = (dy / distance) * this.config.speed;
            
            // Apply acceleration toward target velocity
            particle.vx += (targetVx - particle.vx) * this.config.acceleration * dt;
            particle.vy += (targetVy - particle.vy) * this.config.acceleration * dt;
            
            // Add minimal randomness for organic feel
            particle.vx += (Math.random() - 0.5) * this.config.randomness;
            particle.vy += (Math.random() - 0.5) * this.config.randomness;
        } else {
            // Near target, pick new target
            const angle = Math.random() * Math.PI * 2;
            const radius = 100 + Math.random() * 200;
            particle.targetX = centerX + Math.cos(angle) * radius;
            particle.targetY = centerY + Math.sin(angle) * radius;
            
            // Keep within canvas bounds
            particle.targetX = Math.max(this.config.edgeBuffer, 
                Math.min(canvasWidth - this.config.edgeBuffer, particle.targetX));
            particle.targetY = Math.max(this.config.edgeBuffer, 
                Math.min(canvasHeight - this.config.edgeBuffer, particle.targetY));
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Edge bouncing with dampening
        if (particle.x <= 0 || particle.x >= canvasWidth) {
            particle.vx *= -0.8;
            particle.x = Math.max(0, Math.min(canvasWidth, particle.x));
            // Pick new target after bounce
            particle.targetX = centerX + (Math.random() - 0.5) * 300;
        }
        if (particle.y <= 0 || particle.y >= canvasHeight) {
            particle.vy *= -0.8;
            particle.y = Math.max(0, Math.min(canvasHeight, particle.y));
            // Pick new target after bounce
            particle.targetY = centerY + (Math.random() - 0.5) * 300;
        }
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ VISUAL CHARACTERISTICS
    // └─────────────────────────────────────────────────────────────────────────────────
    visuals: {
        trailLength: 'medium',      // Medium trail for motion clarity
        opacity: 0.9,               // High opacity for focus
        sizeMultiplier: 1.0,        // Standard size
        blurAmount: 0.2             // Sharp, focused appearance
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fizzy Particle Behavior
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Fizzy behavior - bubbly, effervescent particle movement
 * @author Emotive Engine Team
 * @module particles/behaviors/fizzy
 */

/**
 * FIZZY BEHAVIOR - BUBBLY EFFERVESCENCE
 * Used by: excited emotion
 * 
 * Particles bubble upward with random pops and fizz, like carbonation in soda.
 * Creates an energetic, celebratory atmosphere.
 */
var fizzy = {
    name: 'fizzy',
    emoji: '🫧',
    description: 'Bubbly, effervescent movement like carbonation',
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ CONFIGURATION
    // └─────────────────────────────────────────────────────────────────────────────────
    config: {
        baseRiseSpeed: 2.5,      // Base upward velocity
        wobbleAmplitude: 30,     // Horizontal wobble range
        wobbleFrequency: 0.15,   // Wobble oscillation speed
        popChance: 0.002,        // Chance to "pop" per frame
        popForce: 8,             // Force of pop burst
        fizziness: 0.3,          // Random velocity variation
        gravity: -0.05           // Slight upward bias
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ INITIALIZATION
    // └─────────────────────────────────────────────────────────────────────────────────
    initialize(particle, centerX, centerY, canvasWidth, canvasHeight) {
        // Start with upward velocity
        particle.vx = (Math.random() - 0.5) * 2;
        particle.vy = -this.config.baseRiseSpeed - Math.random() * 2;
        
        // Fizzy properties
        particle.wobblePhase = Math.random() * Math.PI * 2;
        particle.wobbleSpeed = this.config.wobbleFrequency * (0.8 + Math.random() * 0.4);
        particle.bubbleSize = 0.5 + Math.random() * 0.5;
        particle.popTimer = 0;
        particle.isFizzing = true;
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ UPDATE LOOP
    // └─────────────────────────────────────────────────────────────────────────────────
    update(particle, dt, centerX, centerY, canvasWidth, canvasHeight) {
        // Update wobble phase
        particle.wobblePhase += particle.wobbleSpeed * dt;
        
        // Apply wobble to horizontal movement
        const wobble = Math.sin(particle.wobblePhase) * this.config.wobbleAmplitude;
        particle.vx = wobble * 0.05 + (Math.random() - 0.5) * this.config.fizziness;
        
        // Apply upward force with variation
        particle.vy += this.config.gravity * dt;
        particle.vy += (Math.random() - 0.5) * this.config.fizziness;
        
        // Random "pop" events
        if (Math.random() < this.config.popChance) {
            // Pop! Send particle in random direction
            const popAngle = Math.random() * Math.PI * 2;
            particle.vx = Math.cos(popAngle) * this.config.popForce;
            particle.vy = Math.sin(popAngle) * this.config.popForce * 0.7; // Slightly favor horizontal
            particle.popTimer = 1; // Visual feedback timer
            
            // Resize on pop
            particle.bubbleSize = 0.3 + Math.random() * 0.7;
        }
        
        // Decay pop effect
        if (particle.popTimer > 0) {
            particle.popTimer -= dt * 0.05;
            // Slow down after pop
            particle.vx *= 0.95;
            particle.vy *= 0.95;
        }
        
        // Apply velocity
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        
        // Wrap around vertically (bubbles rise and restart)
        if (particle.y < -50) {
            particle.y = canvasHeight + 50;
            particle.x = centerX + (Math.random() - 0.5) * 300;
            particle.vy = -this.config.baseRiseSpeed - Math.random() * 2;
            particle.bubbleSize = 0.5 + Math.random() * 0.5;
        }
        
        // Horizontal bounds with soft bounce
        if (particle.x <= 0 || particle.x >= canvasWidth) {
            particle.vx *= -0.5;
            particle.x = Math.max(0, Math.min(canvasWidth, particle.x));
        }
        
        // Bottom boundary (bubbles can spawn from bottom)
        if (particle.y > canvasHeight + 50) {
            particle.y = canvasHeight;
            particle.vy = -this.config.baseRiseSpeed * 1.5;
        }
        
        // Update size based on bubble properties
        particle.size = particle.baseSize * particle.bubbleSize * 
                       (1 + Math.sin(particle.wobblePhase * 2) * 0.1);
    },
    
    // ┌─────────────────────────────────────────────────────────────────────────────────
    // │ VISUAL CHARACTERISTICS
    // └─────────────────────────────────────────────────────────────────────────────────
    visuals: {
        trailLength: 'short',       // Short trails for bubbly feel
        opacity: 0.6,               // Semi-transparent like bubbles
        sizeMultiplier: 1.2,        // Slightly larger for bubble effect
        blurAmount: 0.5,            // Soft, bubble-like appearance
        sparkle: true               // Occasional sparkle effect
    }
};

/**
 * Calm Particle Behavior
 * Particles drift peacefully with minimal, smooth movement
 */


// Behavior configuration
const config = {
    breathingPeriod: 8000};

/**
 * Initialize a particle with calm properties
 * @param {Object} particle - The particle to initialize
 */
function initializeCalm(particle) {
    // Start with faster initial burst movement
    particle.vx = (Math.random() - 0.5) * 0.5;  // Increased 5x from 0.1
    particle.vy = (Math.random() - 0.5) * 0.5;  // Increased 5x from 0.1
    particle.lifeDecay = 0.003;  // Moderate fade (particles last ~5-6 seconds)

    // Use emotion colors if provided
    if (particle.emotionColors && particle.emotionColors.length > 0) {
        particle.color = selectWeightedColor(particle.emotionColors);
    }

    // Calm-specific behavior data
    particle.behaviorData = {
        orbitAngle: Math.random() * Math.PI * 2,  // Starting angle around center
        orbitRadius: 40 + Math.random() * 60,      // Distance from center (40-100 pixels)
        orbitSpeed: 0.0008 + Math.random() * 0.0006, // Faster orbit speed (4x)
        floatOffset: Math.random() * Math.PI * 2,
        breathingOffset: Math.random() * Math.PI * 2,
        lifetime: 0
    };
}

/**
 * Update calm behavior each frame
 * @param {Object} particle - The particle to update
 * @param {number} dt - Delta time
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 */
function updateCalm(particle, dt, centerX, centerY) {
    const data = particle.behaviorData;
    if (!data) return;

    data.lifetime += dt;

    // Breathing effect (very subtle size change)
    const breathPhase = (data.lifetime + data.breathingOffset * config.breathingPeriod) / config.breathingPeriod;
    const breathIntensity = Math.sin(breathPhase * Math.PI * 2) * 0.5 + 0.5;

    // Apply subtle size pulsing
    particle.size = particle.baseSize * (0.95 + breathIntensity * 0.05);

    // Slow orbital movement around the mascot
    data.orbitAngle += data.orbitSpeed * dt;

    // Vary the orbit radius slightly over time for organic movement
    const radiusVariation = Math.sin(data.lifetime * 0.0001 + data.floatOffset) * 10;
    const currentRadius = data.orbitRadius + radiusVariation;

    // Calculate target position in orbit
    const targetX = centerX + Math.cos(data.orbitAngle) * currentRadius;
    const targetY = centerY + Math.sin(data.orbitAngle) * currentRadius;

    // Add vertical floating motion
    const floatY = Math.sin(data.lifetime * 0.0003 + data.breathingOffset) * 15;

    // Smoothly move toward orbital position
    const dx = targetX - particle.x;
    const dy = (targetY + floatY) - particle.y;

    // Faster movement toward target position
    particle.vx = dx * 0.03;  // Faster following (3x)
    particle.vy = dy * 0.03;  // Faster following (3x)

    // Add more random drift for organic feel
    particle.vx += (Math.random() - 0.5) * 0.02;  // More drift
    particle.vy += (Math.random() - 0.5) * 0.02;  // More drift

    // Apply very light friction
    particle.vx *= 0.98;
    particle.vy *= 0.98;
}

// Export behavior definition for registry
var zen = {
    name: 'zen',
    emoji: '☯️',
    description: 'Peaceful orbital movement like a hovering aura',
    initialize: initializeCalm,
    update: updateCalm
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Plugin Behavior Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Adapter for plugin-defined particle behaviors
 * @author Emotive Engine Team
 * @module particles/behaviors/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Bridges the gap between the plugin system and modular particle behaviors.         
 * ║ Allows plugins to register custom particle behaviors that integrate seamlessly    
 * ║ with the modular particle system.                                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// Registry for plugin-defined behaviors
const pluginBehaviors = new Map();

/**
 * Register a custom particle behavior from a plugin
 * @param {string} name - Unique name for the behavior
 * @param {Object} behaviorDef - Behavior definition object
 * @returns {boolean} Success status
 */
function registerPluginBehavior(name, behaviorDef) {
    if (pluginBehaviors.has(name)) ;
    
    // Validate behavior definition
    if (!behaviorDef.initialize || typeof behaviorDef.initialize !== 'function') {
        return false;
    }
    
    if (!behaviorDef.update || typeof behaviorDef.update !== 'function') {
        return false;
    }
    
    // Store the behavior
    pluginBehaviors.set(name, {
        name,
        emoji: behaviorDef.emoji || '🔌',
        description: behaviorDef.description || `Plugin behavior: ${name}`,
        initialize: behaviorDef.initialize,
        update: behaviorDef.update,
        isPlugin: true
    });
    
    return true;
}

/**
 * Unregister a plugin behavior
 * @param {string} name - Name of the behavior to remove
 * @returns {boolean} Success status
 */
function unregisterPluginBehavior(name) {
    if (pluginBehaviors.has(name)) {
        pluginBehaviors.delete(name);
        return true;
    }
    return false;
}

/**
 * Get a plugin behavior by name
 * @param {string} name - Name of the behavior
 * @returns {Object|null} Behavior definition or null
 */
function getPluginBehavior(name) {
    return pluginBehaviors.get(name) || null;
}

/**
 * Get all registered plugin behaviors
 * @returns {Array} Array of behavior names
 */
function getAllPluginBehaviors() {
    return Array.from(pluginBehaviors.keys());
}

/**
 * Create a behavior wrapper for legacy plugin particle effects
 * Converts old-style particle definitions to modular behavior format
 * @param {Object} legacyBehavior - Legacy behavior configuration
 * @returns {Object} Modular behavior definition
 */
function createLegacyAdapter$1(legacyBehavior) {
    return {
        name: legacyBehavior.name || 'legacy',
        emoji: '🔄',
        description: legacyBehavior.description || 'Legacy plugin behavior',
        
        initialize(particle) {
            // Apply legacy configuration
            if (legacyBehavior.size) {
                particle.size = typeof legacyBehavior.size === 'object' ?
                    legacyBehavior.size.min + Math.random() * (legacyBehavior.size.max - legacyBehavior.size.min) :
                    legacyBehavior.size;
                particle.baseSize = particle.size;
            }
            
            if (legacyBehavior.speed) {
                const speed = typeof legacyBehavior.speed === 'object' ?
                    legacyBehavior.speed.min + Math.random() * (legacyBehavior.speed.max - legacyBehavior.speed.min) :
                    legacyBehavior.speed;
                const angle = Math.random() * Math.PI * 2;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
            }
            
            if (legacyBehavior.lifespan) {
                const lifespan = typeof legacyBehavior.lifespan === 'object' ?
                    legacyBehavior.lifespan.min + Math.random() * (legacyBehavior.lifespan.max - legacyBehavior.lifespan.min) :
                    legacyBehavior.lifespan;
                particle.lifeDecay = 1000 / lifespan; // Convert ms to decay rate
            }
            
            if (legacyBehavior.color) {
                particle.color = Array.isArray(legacyBehavior.color) ?
                    selectWeightedColor(legacyBehavior.color) :
                    legacyBehavior.color;
            }
            
            if (legacyBehavior.opacity) {
                particle.life = typeof legacyBehavior.opacity === 'object' ?
                    legacyBehavior.opacity.min + Math.random() * (legacyBehavior.opacity.max - legacyBehavior.opacity.min) :
                    legacyBehavior.opacity;
            }
            
            // Store legacy-specific data
            particle.behaviorData = {
                movementType: legacyBehavior.movementType || 'linear',
                turbulence: legacyBehavior.turbulence || 0,
                drift: legacyBehavior.drift || 0,
                acceleration: legacyBehavior.acceleration || 0,
                ...legacyBehavior.customData
            };
        },
        
        update(particle, dt, centerX, centerY) {
            const data = particle.behaviorData;
            
            // Apply movement based on type
            switch (data.movementType) {
            case 'wander':
                // Random wandering
                particle.vx += (Math.random() - 0.5) * data.turbulence * dt;
                particle.vy += (Math.random() - 0.5) * data.turbulence * dt;
                break;
                    
            case 'fall':
                // Falling with drift
                particle.vy += 0.1 * dt; // Gravity
                particle.vx += (Math.random() - 0.5) * data.drift * dt;
                break;
                    
            case 'rain':
                // Digital rain effect
                particle.vy += data.acceleration * dt;
                break;
                    
            case 'orbit': {
                // Orbital motion
                const dx = particle.x - centerX;
                const dy = particle.y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    const angle = Math.atan2(dy, dx) + 0.02 * dt;
                    particle.x = centerX + Math.cos(angle) * dist;
                    particle.y = centerY + Math.sin(angle) * dist;
                }
                break;
            }
            }
            
            // Call custom update if provided
            if (legacyBehavior.customUpdate) {
                legacyBehavior.customUpdate(particle, dt, centerX, centerY);
            }
        }
    };
}

// Export adapter functions for plugin system integration
var pluginAdapter$1 = {
    registerPluginBehavior,
    unregisterPluginBehavior,
    getPluginBehavior,
    getAllPluginBehaviors,
    createLegacyAdapter: createLegacyAdapter$1
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Behavior Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central registry for all particle behaviors with plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module particles/behaviors
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Control center for particle behaviors with plugin adapter integration.            
 * ║ • Each behavior defines unique particle physics and movement patterns             
 * ║ • Core behaviors loaded synchronously at startup                                  
 * ║ • Plugin behaviors registered dynamically via adapter                             
 * ║ • Value-agnostic design for easy physics tuning                                   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ BEHAVIOR COLLECTION
// └─────────────────────────────────────────────────────────────────────────────────────
const BEHAVIORS = [
    ambient,
    directed,
    fizzy,
    orbiting,
    rising,
    falling,
    popcorn,
    burst$1,
    aggressive,
    scattering,
    repelling,
    connecting,
    resting,
    radiant,
    ascending,
    erratic,
    cautious,
    surveillance,
    glitchy,
    spaz,
    zen
];

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ BEHAVIOR REGISTRY - Fast lookup by name
// └─────────────────────────────────────────────────────────────────────────────────────
const BEHAVIOR_REGISTRY = {};

// Build the registry from the behaviors array - SYNCHRONOUSLY
BEHAVIORS.forEach(behavior => {
    BEHAVIOR_REGISTRY[behavior.name] = behavior;
    // Debug logging removed for production
});

/**
 * Get a behavior by name (checks both core and plugin behaviors)
 * @param {string} name - Behavior name (e.g., 'ambient', 'orbiting')
 * @returns {Object|null} Behavior object or null if not found
 */
function getBehavior(name) {
    // Check core behaviors first
    if (BEHAVIOR_REGISTRY[name]) {
        return BEHAVIOR_REGISTRY[name];
    }
    // Check plugin behaviors
    const pluginBehavior = pluginAdapter$1.getPluginBehavior(name);
    if (pluginBehavior) {
        return pluginBehavior;
    }
    return null;
}

/**
 * Initialize a particle with a specific behavior
 * @param {Particle} particle - The particle to initialize
 * @param {string} behaviorName - Name of the behavior to apply
 * @returns {boolean} True if behavior was found and applied
 */
function initializeBehavior(particle, behaviorName) {
    const behavior = getBehavior(behaviorName);
    if (behavior && behavior.initialize) {
        // Debug logging removed for production
        behavior.initialize(particle);
        return true;
    }
    // Fallback to ambient if behavior not found
    if (behaviorName !== 'ambient') {
        console.warn(`⚠️ Behavior '${behaviorName}' not found, falling back to ambient`);
        return initializeBehavior(particle, 'ambient');
    }
    return false;
}

/**
 * Update a particle's behavior
 * @param {Particle} particle - The particle to update
 * @param {string} behaviorName - Name of the behavior
 * @param {number} dt - Delta time
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 * @returns {boolean} True if behavior was found and updated
 */
function updateBehavior(particle, behaviorName, dt, centerX, centerY) {
    const behavior = getBehavior(behaviorName);
    if (behavior && behavior.update) {
        behavior.update(particle, dt, centerX, centerY);
        return true;
    }
    return false;
}

/**
 * Get list of all available behaviors (core and plugin)
 * @returns {Array} Array of behavior names and descriptions
 */
function listBehaviors() {
    // Get core behaviors
    const coreBehaviors = Object.values(BEHAVIOR_REGISTRY).map(behavior => ({
        name: behavior.name,
        emoji: behavior.emoji || '🎯',
        description: behavior.description || 'No description',
        type: 'core'
    }));
    
    // Get plugin behaviors
    const pluginBehaviorNames = pluginAdapter$1.getAllPluginBehaviors();
    const pluginBehaviors = pluginBehaviorNames.map(name => {
        const behavior = pluginAdapter$1.getPluginBehavior(name);
        return {
            name: behavior.name,
            emoji: behavior.emoji || '🔌',
            description: behavior.description || 'Plugin behavior',
            type: 'plugin'
        };
    });
    
    return [...coreBehaviors, ...pluginBehaviors];
}

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ DEBUG UTILITIES
// └─────────────────────────────────────────────────────────────────────────────────────
if (typeof window !== 'undefined' && window.DEBUG_PARTICLES) {
    window.ParticleBehaviors = {
        registry: BEHAVIOR_REGISTRY,
        list: listBehaviors,
        get: getBehavior
    };
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Gesture Plugin Adapter
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bridge between plugin system and gesture registry
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module gestures/plugin-adapter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Adapter for dynamic gesture registration from plugins.                            
 * ║ • Maintains separate registry for plugin gestures                                 
 * ║ • Validates gesture definitions for required apply() function                     
 * ║ • Provides legacy format conversion for older plugins                             
 * ║ • Enables runtime registration and unregistration                                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Plugin gesture registry
 */
const pluginGestures = new Map();

/**
 * Register a plugin gesture
 * @param {string} name - Gesture name
 * @param {Object} gestureDef - Gesture definition object
 */
function registerPluginGesture(name, gestureDef) {
    // Ensure gesture has required properties
    if (!gestureDef.apply && !gestureDef.type) {
        return false;
    }
    
    // Add name if not present
    if (!gestureDef.name) {
        gestureDef.name = name;
    }
    
    // Set default type if not specified
    if (!gestureDef.type) {
        gestureDef.type = 'blending';
    }
    
    pluginGestures.set(name, gestureDef);
    
    return true;
}

/**
 * Unregister a plugin gesture
 * @param {string} name - Gesture name to remove
 */
function unregisterPluginGesture(name) {
    if (pluginGestures.has(name)) {
        pluginGestures.delete(name);
        
        return true;
    }
    return false;
}

/**
 * Get a plugin gesture by name
 * @param {string} name - Gesture name
 * @returns {Object|null} Gesture object or null if not found
 */
function getPluginGesture(name) {
    return pluginGestures.get(name) || null;
}

/**
 * Get all plugin gesture names
 * @returns {Array<string>} Array of gesture names
 */
function getAllPluginGestures() {
    return Array.from(pluginGestures.keys());
}

/**
 * Clear all plugin gestures
 */
function clearPluginGestures() {
    pluginGestures.clear();
}

/**
 * Convert legacy plugin gesture format to new format
 * @param {Object} legacyGesture - Old format gesture
 * @returns {Object} New format gesture
 */
function createLegacyAdapter(legacyGesture) {
    return {
        name: legacyGesture.name || 'unknown',
        type: legacyGesture.type || 'blending',
        emoji: legacyGesture.emoji || '🔌',
        description: legacyGesture.description || 'Plugin gesture',
        config: legacyGesture.config || {},
        
        apply(particle, progress, motion, dt, centerX, centerY) {
            // Adapt old plugin format to new format
            if (legacyGesture.animate) {
                // Old plugins might use 'animate' instead of 'apply'
                legacyGesture.animate(particle, progress, motion, dt, centerX, centerY);
            } else if (legacyGesture.apply) {
                legacyGesture.apply(particle, progress, motion, dt, centerX, centerY);
            }
        },
        
        cleanup: legacyGesture.cleanup || function(particle) {
            // Default cleanup
            if (particle.gestureData && particle.gestureData[this.name]) {
                delete particle.gestureData[this.name];
            }
        }
    };
}

// Export adapter interface
var pluginAdapter = {
    registerPluginGesture,
    unregisterPluginGesture,
    getPluginGesture,
    getAllPluginGestures,
    clearPluginGestures,
    createLegacyAdapter
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Bounce Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Bounce gesture - vertical oscillation motion
 * @author Emotive Engine Team
 * @module gestures/motions/bounce
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a bouncing motion with particles oscillating vertically.                  
 * ║ This is a BLENDING gesture that adds to existing particle motion.                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↑
 *       ⭐      <- peak
 *      ↗ ↘
 *     ↗   ↘
 *    ⭐     ⭐   <- midpoint
 *   ↗       ↘
 *  ↗         ↘
 * ⭐           ⭐ <- trough
 * 
 * USED BY:
 * - Joy emotions (playful bouncing)
 * - Excited states (energetic movement)
 * - Celebration gestures
 */

/**
 * Bounce gesture configuration and implementation
 */
var bounce = {
    name: 'bounce',
    emoji: '⬆️',
    type: 'blending', // Adds to existing motion
    description: 'Vertical oscillation with smooth easing',
    
    // Default configuration
    config: {
        duration: 800,      // Legacy fallback
        musicalDuration: { musical: true, beats: 2 }, // 2 beats
        amplitude: 30,      // Bounce height range
        frequency: 2,       // Number of oscillations
        axis: 'vertical',   // Movement axis: 'vertical' or 'horizontal'
        damping: true,      // Enable amplitude reduction over time
        easing: 'sine',     // Animation curve type
        strength: 0.6,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'bounce',
            axis: 'vertical',   // Oscillation direction
            strength: 0.6,      // Particle bounce strength
            frequency: 2        // Particle oscillation count
        }
    },
    
    // Rhythm configuration - bounce syncs perfectly to beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Each bounce lands on a beat
        timingSync: 'nextBeat',     // Start on next beat
        interruptible: true,         // Can interrupt mid-bounce
        priority: 3,                 // Lower priority
        blendable: true,             // Can blend with other effects
        crossfadePoint: 'anyBeat',   // Can transition out on any beat
        
        // Bounce height syncs to beat intensity
        amplitudeSync: {
            onBeat: 1.8,      // Higher bounce on beat
            offBeat: 0.6,     // Lower between beats
            curve: 'bounce'   // Natural bounce curve
        },
        
        // Frequency can sync to tempo
        frequencySync: {
            mode: 'tempo',    // Bounces per beat scale with BPM
            multiplier: 1.0   // 1 bounce per beat
        },
        
        // Duration syncs to musical time
        durationSync: {
            mode: 'beats',    // Duration in beats
            beats: 4          // Bounce for 4 beats (1 bar in 4/4)
        },
        
        // Accent response for stronger downbeats
        accentResponse: {
            enabled: true,
            multiplier: 1.5   // 50% higher on accented beats
        },
        
        // Pattern-specific bouncing styles
        patternOverrides: {
            'waltz': {
                // 3/4 time creates elegant triple bounce
                frequencySync: { multiplier: 0.75 },
                durationSync: { beats: 3 }
            },
            'swing': {
                // Jazzy swing bounce with syncopation
                amplitudeSync: { onBeat: 2.0, offBeat: 0.4, curve: 'ease' }
            },
            'dubstep': {
                // Heavy drop on beat 3
                amplitudeSync: { 
                    onBeat: 1.5,
                    dropBeat: 3.0,  // Massive bounce on the drop
                    curve: 'pulse'
                }
            },
            'breakbeat': {
                // Chaotic broken rhythm bouncing
                frequencySync: { multiplier: 1.5 },
                amplitudeSync: { onBeat: 2.2, offBeat: 0.3 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * Called once when gesture starts
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.bounce = {
            startY: particle.y,
            startX: particle.x,
            startVx: particle.vx,
            startVy: particle.vy,
            initialized: true
        };
    },
    
    /**
     * Apply bounce motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.bounce?.initialized) {
            this.initialize(particle, motion);
        }
        
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutCubic(progress);
        
        // Calculate oscillation
        let {frequency} = config;
        const phase = motion.phase || 0;
        
        // Apply rhythm modulation if present
        let amplitude = config.amplitude * strength * particle.scaleFactor;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            // Frequency modulation for tempo sync
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const oscillation = Math.sin((easeProgress + phase) * Math.PI * 2 * frequency);
        if (config.damping && progress > 0.7) {
            // Reduce amplitude toward end of animation
            const dampProgress = (progress - 0.7) / 0.3;
            amplitude *= (1 - dampProgress * 0.8);
        }
        
        // Apply motion based on axis
        if (config.axis === 'vertical') {
            particle.vy += oscillation * amplitude * 0.01 * dt;
            
            // Dampen horizontal movement slightly for stability
            if (progress > 0.9) {
                particle.vx *= 0.98;
            }
        } else if (config.axis === 'horizontal') {
            particle.vx += oscillation * amplitude * 0.01 * dt;
            
            // Dampen vertical movement slightly for stability
            if (progress > 0.9) {
                particle.vy *= 0.98;
            }
        }
        
        // Smooth ending - gradually reduce velocity modifications
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vx = particle.vx * (0.95 + endFactor * 0.05);
            particle.vy = particle.vy * (0.95 + endFactor * 0.05);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.bounce) {
            delete particle.gestureData.bounce;
        }
    },
    
    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Pulse Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Pulse gesture - radial expansion and contraction
 * @author Emotive Engine Team
 * @module gestures/motions/pulse
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a breathing/heartbeat effect with particles expanding and contracting      
 * ║ radially from the center. This is a BLENDING gesture that modifies positions.     
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Expand          Contract         Expand
 *    ← · · · →         → ⭐ ←         ← · · · →
 *    ↖ · · ↗           ↘ ↓ ↙           ↖ · · ↗
 *    · · ⭐ · ·   →    · ⭐ ·     →   · · ⭐ · ·
 *    ↙ · · ↘           ↗ ↑ ↖           ↙ · · ↘
 *    ← · · · →         → ⭐ ←         ← · · · →
 * 
 * USED BY:
 * - Love emotions (heartbeat rhythm)
 * - Breathing/calm states
 * - Emphasis gestures
 */

/**
 * Pulse gesture configuration and implementation
 */
var pulse = {
    name: 'pulse',
    emoji: '💗',
    type: 'blending', // Adds to existing motion
    description: 'Radial expansion and contraction from center',
    
    // Default configuration
    config: {
        duration: 600,      // Animation duration
        amplitude: 30,      // Expansion distance
        frequency: 1,       // Number of pulses
        holdPeak: 0.1,      // Peak expansion hold time
        easing: 'sine',     // Animation curve type
        scaleAmount: 0.2,   // Orb scale variation
        glowAmount: 0.3,    // Orb glow intensity change
        strength: 0.15,     // Particle motion strength
        direction: 'outward', // Radial direction
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 0.15,
            direction: 'outward',
            frequency: 1
        }
    },
    
    // Rhythm configuration - pulse as heartbeat synced to music
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Heartbeat on every beat
        
        // Pulse strength syncs to beat
        amplitudeSync: {
            onBeat: 1.6,      // Strong expansion on beat
            offBeat: 0.8,     // Gentle contraction off beat
            curve: 'pulse'    // Sharp attack, gradual release
        },
        
        // Frequency locks to tempo
        frequencySync: {
            mode: 'locked',   // One pulse per beat
            subdivision: 'quarter'  // Pulse on quarter notes
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 1          // One pulse per beat
        },
        
        // Stronger pulse on downbeats
        accentResponse: {
            enabled: true,
            multiplier: 2.0   // Double strength on accent
        },
        
        // Pattern-specific pulse styles
        patternOverrides: {
            'waltz': {
                // Elegant 3/4 heartbeat
                amplitudeSync: { onBeat: 2.0, offBeat: 0.5 },
                durationSync: { beats: 3 }
            },
            'swing': {
                // Syncopated jazz pulse
                amplitudeSync: { onBeat: 1.8, offBeat: 0.6, curve: 'ease' },
                frequencySync: { subdivision: 'swing' }
            },
            'dubstep': {
                // Deep bass pulse on drop
                amplitudeSync: {
                    onBeat: 1.2,
                    dropBeat: 4.0,  // Massive pulse on beat 3
                    curve: 'pulse'
                }
            },
            'breakbeat': {
                // Erratic heartbeat
                frequencySync: { mode: 'random', range: [0.5, 2.0] },
                amplitudeSync: { onBeat: 2.5, offBeat: 0.3 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial distance and angle from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        particle.gestureData.pulse = {
            baseDistance: distance,
            angle,
            startX: particle.x,
            startY: particle.y,
            initialized: true
        };
    },
    
    /**
     * Apply pulse motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.pulse?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.pulse;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutSine(progress);
        
        // Calculate pulse with optional peak hold
        let pulseValue;
        let {frequency} = config;
        let {amplitude} = config;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const rawPulse = (easeProgress * frequency * 2) % 2;
        
        if (config.holdPeak > 0 && rawPulse > (1 - config.holdPeak) && rawPulse < (1 + config.holdPeak)) {
            // Hold at peak
            pulseValue = 1;
        } else {
            // Normal sine wave
            pulseValue = Math.sin(easeProgress * Math.PI * 2 * frequency);
        }
        
        // Calculate expansion amount
        const expansion = pulseValue * amplitude * strength * particle.scaleFactor;
        
        // Calculate target position
        const targetDistance = data.baseDistance + expansion;
        const targetX = centerX + Math.cos(data.angle) * targetDistance;
        const targetY = centerY + Math.sin(data.angle) * targetDistance;
        
        // Smoothly move toward target
        const moveSpeed = 0.15 * dt;
        particle.vx += (targetX - particle.x) * moveSpeed * 0.1;
        particle.vy += (targetY - particle.y) * moveSpeed * 0.1;
        
        // Fade effect at the end
        if (progress > 0.9) {
            const fadeFactor = 1 - ((progress - 0.9) * 10);
            particle.vx *= (0.9 + fadeFactor * 0.1);
            particle.vy *= (0.9 + fadeFactor * 0.1);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.pulse) {
            delete particle.gestureData.pulse;
        }
    },
    
    /**
     * Sine easing for smooth breathing motion
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Shake Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Shake gesture - random jitter motion
 * @author Emotive Engine Team
 * @module gestures/motions/shake
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a shaking/vibrating effect with random jitter. Perfect for expressing     
 * ║ nervousness, excitement, or impact effects. This is a BLENDING gesture.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     Frame 1        Frame 2        Frame 3
 *        ⭐      →    ⭐       →      ⭐
 *       ↙↗↘↖         ↖↘↗↙          ↗↖↙↘
 *    (random)      (random)       (random)
 * 
 * USED BY:
 * - Nervous/anxious states
 * - Anger (trembling with rage)
 * - Cold/shivering effects
 * - Impact reactions
 */

/**
 * Shake gesture configuration and implementation
 */
var shake = {
    name: 'shake',
    emoji: '🫨',
    type: 'blending', // Adds to existing motion
    description: 'Random jitter movement for vibration effects',
    
    // Default configuration
    config: {
        duration: 400,      // Animation duration
        amplitude: 15,      // Shake movement range
        frequency: 15,      // Oscillation speed
        decay: 0.9,         // Intensity reduction over time
        smoothing: 0.1,     // Motion smoothness factor
        axes: 'both',       // Affected axes: 'both', 'horizontal', 'vertical'
        easing: 'linear',   // Animation curve type
        strength: 3.0,      // Overall shake intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'shake',
            strength: 3.0,      // Particle shake strength
            frequency: 15,      // Particle oscillation rate
            decay: false        // Maintain consistent intensity
        }
    },
    
    // Rhythm configuration - shake intensifies with tempo
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',  // Shake on subdivisions
        
        // Shake intensity modulation
        amplitudeSync: {
            subdivision: 'sixteenth',  // Shake on 16th notes
            onBeat: 2.5,              // Violent shake on beat
            offBeat: 0.7,             // Gentler between beats
            curve: 'pulse'            // Sharp attack
        },
        
        // Frequency scales with tempo
        frequencySync: {
            mode: 'tempo',
            baseFrequency: 15,        // Base at 120 BPM
            scaling: 'linear'         // Linear scaling with BPM
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 2                  // Shake for 2 beats
        },
        
        // Pattern-specific shake styles
        patternOverrides: {
            'breakbeat': {
                // Chaotic broken shake
                amplitudeSync: { onBeat: 3.0, offBeat: 0.2 },
                frequencySync: { mode: 'random', range: [8, 20] }
            },
            'dubstep': {
                // Bass wobble shake
                amplitudeSync: {
                    subdivision: 'eighth',
                    onBeat: 4.0,
                    dropBeat: 6.0,  // Massive shake on drop
                    curve: 'pulse'
                }
            },
            'swing': {
                // Jazzy shimmy shake
                amplitudeSync: { onBeat: 1.8, offBeat: 1.0, curve: 'ease' }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.shake = {
            originalX: particle.x,  // Store original position
            originalY: particle.y,  // Store original position
            randomAngle: Math.random() * Math.PI * 2, // Random shake direction per particle
            initialized: true
        };
    },
    
    /**
     * Apply shake motion to particle
     * Creates synchronized vibration effect matching orb shake
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.shake?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.shake;
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply rhythm modulation if present
        let {amplitude} = config;
        let {frequency} = config;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        // Match orb shake logic for synchronized movement
        // Apply decay if enabled to reduce intensity over time
        const decay = config.decay ? (1 - progress) : 1;
        const shake = Math.sin(progress * Math.PI * frequency) * amplitude * decay * strength * particle.scaleFactor;
        
        // Calculate directional offset using particle's random angle
        const offsetX = shake * Math.cos(data.randomAngle);
        const offsetY = shake * Math.sin(data.randomAngle);
        
        // Set particle position directly for perfect synchronization
        // Particles shake in unison with the orb
        particle.x = data.originalX + offsetX;
        particle.y = data.originalY + offsetY;
    },
    
    /**
     * Generate pseudo-random number from seed
     * @param {number} seed - Seed value
     * @returns {number} Pseudo-random value between 0 and 1
     */
    pseudoRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.shake) {
            // Restore original position
            particle.x = particle.gestureData.shake.originalX;
            particle.y = particle.gestureData.shake.originalY;
            delete particle.gestureData.shake;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Nod Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Nod gesture - vertical agreement motion
 * @author Emotive Engine Team
 * @module gestures/motions/nod
 */

var nod = {
    name: 'nod',
    emoji: '🙂',
    type: 'blending',
    description: 'Vertical nodding motion',
    
    // Default configuration
    config: {
        duration: 500,      // Animation duration
        amplitude: 15,      // Vertical movement range
        frequency: 2,       // Number of nod cycles
        easing: 'sine',     // Animation curve type
        strength: 0.4,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'bounce',
            axis: 'vertical',   // Movement direction
            strength: 0.4,      // Particle nod strength
            frequency: 2,       // Particle nod count
            phase: 0           // Synchronization with orb
        }
    },
    
    // Rhythm configuration - nod as agreement to the beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',     // Wait for next beat to start
        interruptible: false,        // Must complete the nod
        priority: 5,                 // Medium priority
        blendable: false,            // Don't blend with other motions
        minDuration: 'halfBar',      // Minimum time before interrupt
        
        // Nod frequency locks to beat
        frequencySync: {
            mode: 'subdivision',
            subdivision: 'half',  // Nod on half notes
            multiplier: 1.0
        },
        
        // Amplitude stronger on downbeats
        amplitudeSync: {
            onBeat: 1.4,
            offBeat: 0.8,
            curve: 'ease'
        },
        
        // Duration in beats
        durationSync: {
            mode: 'beats',
            beats: 2  // Nod for 2 beats
        },
        
        // Pattern-specific nodding
        patternOverrides: {
            'waltz': {
                // Graceful 3/4 nod
                frequencySync: { subdivision: 'quarter' },
                amplitudeSync: { onBeat: 1.6, curve: 'ease' }
            },
            'swing': {
                // Jazzy syncopated nod
                amplitudeSync: { onBeat: 1.5, offBeat: 0.9 }
            },
            'dubstep': {
                // Heavy head-bang on drop
                amplitudeSync: {
                    onBeat: 1.2,
                    dropBeat: 3.0,
                    curve: 'pulse'
                }
            }
        }
    },
    
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.nod = {
            startY: particle.y,
            initialized: true
        };
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.nod?.initialized) {
            this.initialize(particle, motion);
        }
        
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        let {frequency} = config;
        let {amplitude} = config;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        const oscillation = Math.sin(progress * Math.PI * 2 * frequency);
        amplitude = amplitude * strength * particle.scaleFactor;
        
        // Apply vertical nodding motion
        particle.vy += oscillation * amplitude * 0.01 * dt;
        
        // Dampen at the end
        if (progress > 0.9) {
            particle.vy *= 0.95;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.nod) {
            delete particle.gestureData.nod;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Vibrate Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Vibrate gesture - high frequency micro-shake
 * @author Emotive Engine Team
 * @module gestures/motions/vibrate
 */

var vibrate = {
    name: 'vibrate',
    emoji: '📳',
    type: 'blending',
    description: 'High frequency vibration',
    
    // Default configuration
    config: {
        duration: 500,      // Animation duration
        frequency: 20,      // Vibration frequency
        amplitude: 8,       // Vibration amplitude
        easing: 'linear',   // Animation curve type
        strength: 2.0,      // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'shake',
            strength: 2.0,
            frequency: 20,
            amplitude: 8
        }
    },
    
    // Rhythm configuration - vibrate as tremolo effect
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',
        
        // Vibration frequency syncs to tempo
        frequencySync: {
            subdivision: 'thirty-second',  // Very fast subdivisions
            baseFrequency: 20,
            tempoScaling: true  // Scale with BPM
        },
        
        // Amplitude pulses with beat
        amplitudeSync: {
            onBeat: 1.5,
            offBeat: 0.8,
            curve: 'pulse'
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 1  // Vibrate for 1 beat
        },
        
        // Pattern-specific vibration
        patternOverrides: {
            'dubstep': {
                // Bass wobble vibration
                frequencySync: { subdivision: 'sixteenth' },
                amplitudeSync: { onBeat: 2.0, dropBeat: 3.0 }
            },
            'breakbeat': {
                // Chaotic vibration
                frequencySync: { mode: 'random', range: [15, 30] }
            }
        }
    },
    
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.vibrate = {
            timer: 0,
            seed: Math.random() * 1000,
            initialized: true
        };
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.vibrate?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.vibrate;
        const config = { ...this.config, ...motion };
        const strength = config.strength || this.config.strength || 1.0;
        
        // Apply rhythm modulation if present
        let {amplitude} = config;
        let {frequency} = config;
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }
        
        // Update timer
        data.timer += dt * frequency;
        
        // High frequency vibration
        const vibrateX = (Math.random() - 0.5) * amplitude * strength;
        const vibrateY = (Math.random() - 0.5) * amplitude * strength;
        
        // Apply rapid vibration movements
        particle.vx += vibrateX * 0.5 * dt;
        particle.vy += vibrateY * 0.5 * dt;
        
        // Apply damping for control
        particle.vx *= 0.9;
        particle.vy *= 0.9;
        
        // Fade out at the end
        if (progress > 0.8) {
            const fadeFactor = 1 - ((progress - 0.8) * 5);
            particle.vx *= fadeFactor;
            particle.vy *= fadeFactor;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.vibrate) {
            delete particle.gestureData.vibrate;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbit Gesture Motion
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview 3D orbital motion where particles circle around the orb
 * @author Emotive Engine Team
 * @module gestures/motions/orbit
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a mesmerizing 3D orbit effect where particles circle around the orb,      
 * ║ dynamically transitioning between foreground and background layers using the      
 * ║ z-coordinate system. Like planets orbiting a star or a hula-hoop in motion.       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM (Top View):
 *     · → · → ·
 *   ↓           ↑
 *   ·    ⭐    ·   ← particles orbit around center
 *   ↑           ↓  
 *     · ← · ← ·
 * 
 * VISUAL DIAGRAM (Side View):
 *   front  ·····   back
 *         /     \
 *        ·   ⭐  ·  ← z-coordinate changes as particles orbit
 *         \     /
 *   back   ·····   front
 */

/**
 * Apply orbital motion to a particle
 * Particles orbit around the center with dynamic z-depth changes
 * 
 * @param {Object} particle - The particle to animate
 * @param {Object} gestureData - Persistent data for this particle's gesture
 * @param {Object} config - Gesture configuration
 * @param {number} progress - Gesture progress (0-1)
 * @param {number} strength - Gesture strength multiplier
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 */
function applyOrbit(particle, gestureData, config, progress, strength, centerX, centerY) {
    // Initialize gesture data if needed
    if (!gestureData.initialized) {
        // Store original position and velocity
        gestureData.originalX = particle.x;
        gestureData.originalY = particle.y;
        gestureData.originalZ = particle.z || 0;
        gestureData.originalVx = particle.vx || 0;
        gestureData.originalVy = particle.vy || 0;
        
        // Calculate initial angle and radius from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        gestureData.radius = Math.sqrt(dx * dx + dy * dy);
        
        // Ensure minimum radius to prevent clustering at center
        if (gestureData.radius < 50) {
            gestureData.radius = 50 + Math.random() * 100;
        }
        
        gestureData.initialAngle = Math.atan2(dy, dx);
        
        // Random orbit parameters for variety
        gestureData.orbitSpeed = config.speed * (0.8 + Math.random() * 0.4); // Speed variation
        gestureData.orbitTilt = Math.random() * 0.3; // Slight tilt for realism
        
        gestureData.initialized = true;
    }
    
    // Apply rhythm modulation if present
    let {rotations} = config;
    let radiusPulseAmount = 0.05;
    if (config.rhythmModulation) {
        if (config.rhythmModulation.speedMultiplier) {
            gestureData.orbitSpeed *= config.rhythmModulation.speedMultiplier;
        }
        if (config.rhythmModulation.rotationMultiplier) {
            rotations *= config.rhythmModulation.rotationMultiplier;
        }
        if (config.rhythmModulation.radiusPulse) {
            radiusPulseAmount = config.rhythmModulation.radiusPulse;
        }
    }
    
    // Smooth entry/exit transitions
    let transitionFactor = 1.0;
    let velocityTransition = 1.0;
    
    if (progress < 0.15) {
        // Smooth entry (first 15%)
        transitionFactor = progress / 0.15;
        transitionFactor = transitionFactor * transitionFactor * (3 - 2 * transitionFactor); // Smooth step
        velocityTransition = transitionFactor;
    } else if (progress > 0.85) {
        // Smooth exit (last 15%)
        transitionFactor = (1 - progress) / 0.15;
        transitionFactor = transitionFactor * transitionFactor * (3 - 2 * transitionFactor); // Smooth step
        velocityTransition = transitionFactor;
    }
    
    // Calculate current angle based on progress with smooth acceleration
    const angle = gestureData.initialAngle + (progress * Math.PI * 2 * rotations * transitionFactor);
    
    // Calculate orbital radius (can pulse slightly) with transition
    const radiusPulse = 1 + Math.sin(progress * Math.PI * 4) * radiusPulseAmount * transitionFactor;
    const currentRadius = gestureData.radius * strength * radiusPulse * transitionFactor;
    
    // Calculate new position in orbit
    const targetX = centerX + Math.cos(angle) * currentRadius;
    const targetY = centerY + Math.sin(angle) * currentRadius;
    
    // CRITICAL: Update z-coordinate for 3D effect with smooth transition
    // Particles in front (positive z) when at top of orbit, behind (negative z) at bottom
    const zAngle = angle * config.zRotations; // Can rotate in z-plane at different rate
    particle.z = Math.sin(zAngle) * 0.8 * transitionFactor + gestureData.originalZ * (1 - transitionFactor);
    
    // During entry, smoothly transition from original position
    if (progress < 0.15) {
        const entryLerp = transitionFactor * 0.3; // Slower entry
        particle.x = gestureData.originalX + (targetX - gestureData.originalX) * entryLerp;
        particle.y = gestureData.originalY + (targetY - gestureData.originalY) * entryLerp;
        
        // Smooth velocity transition
        const orbitalVx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        const orbitalVy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vx = gestureData.originalVx + (orbitalVx - gestureData.originalVx) * velocityTransition;
        particle.vy = gestureData.originalVy + (orbitalVy - gestureData.originalVy) * velocityTransition;
    } 
    // During exit, smoothly return to original
    else if (progress > 0.85) {
        particle.x = targetX + (gestureData.originalX - targetX) * (1 - transitionFactor);
        particle.y = targetY + (gestureData.originalY - targetY) * (1 - transitionFactor);
        
        // Smooth velocity transition back
        const orbitalVx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        const orbitalVy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vx = orbitalVx * velocityTransition + gestureData.originalVx * (1 - velocityTransition);
        particle.vy = orbitalVy * velocityTransition + gestureData.originalVy * (1 - velocityTransition);
    }
    // Normal orbit
    else {
        // Add vertical oscillation for hula-hoop effect if enabled
        if (config.verticalOscillation > 0) {
            const verticalOffset = Math.sin(angle * 2) * config.verticalOscillation * strength;
            particle.y = targetY + verticalOffset;
            particle.x = targetX;
        } else {
            // Smooth interpolation to target position
            const lerpFactor = config.smoothness || 0.1;
            particle.x += (targetX - particle.x) * lerpFactor;
            particle.y += (targetY - particle.y) * lerpFactor;
        }
        
        // Set orbital velocity
        particle.vx = -Math.sin(angle) * currentRadius * gestureData.orbitSpeed;
        particle.vy = Math.cos(angle) * currentRadius * gestureData.orbitSpeed;
    }
    
    // Apply centripetal acContinceleration effect (particles speed up when closer)
    if (config.centripetal) {
        const speed = 1 + (1 - Math.abs(particle.z)) * 0.3; // Speed varies with z-position
        const speedAngle = gestureData.initialAngle + (progress * Math.PI * 2 * config.rotations * speed);
        particle.x = centerX + Math.cos(speedAngle) * currentRadius;
        particle.y = centerY + Math.sin(speedAngle) * currentRadius;
    }
}

// Export gesture configuration
var orbit = {
    name: 'orbit',
    emoji: '🪐',
    description: '3D orbital motion around center',
    type: 'override', // Takes full control of particle position
    
    // Default configuration
    config: {
        speed: 1.0,              // Base orbital speed
        rotations: 1,            // Number of full rotations per gesture
        zRotations: 1,           // Z-plane rotation ratio (1 = same as xy, 2 = twice as fast)
        smoothness: 0.15,        // Position interpolation factor
        verticalOscillation: 0,  // Hula-hoop vertical movement (0 = flat orbit)
        centripetal: false,      // Enable speed variation based on position
    },
    
    // Rhythm configuration - orbital motion syncs to musical cycles
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Complete orbit per bar
        
        // Orbital speed syncs to tempo
        speedSync: {
            mode: 'tempo',
            baseSpeed: 1.0,
            scaling: 'linear'  // Speed scales with BPM
        },
        
        // Rotations per musical period
        rotationSync: {
            mode: 'bars',
            rotationsPerBar: 1,  // One full orbit per bar
            zSync: true  // Z-rotation also syncs
        },
        
        // Radius pulses with beat
        radiusSync: {
            subdivision: 'quarter',
            pulsAmount: 0.1,  // 10% radius variation
            curve: 'ease'
        },
        
        // Pattern-specific orbital styles
        patternOverrides: {
            'waltz': {
                // Elegant 3-step orbit
                rotationSync: { rotationsPerBar: 0.75 },
                radiusSync: { pulsAmount: 0.15 }
            },
            'swing': {
                // Jazzy elliptical orbit
                speedSync: { mode: 'swing', ratio: 0.67 },
                verticalOscillation: 0.2
            },
            'dubstep': {
                // Wobbling orbit with drops
                radiusSync: { 
                    subdivision: 'eighth',
                    pulsAmount: 0.3,
                    dropMultiplier: 2.0
                }
            },
            'breakbeat': {
                // Chaotic orbital patterns
                speedSync: { mode: 'random', range: [0.5, 2.0] },
                centripetal: true
            }
        }
    },
    
    // Apply function
    apply: applyOrbit,
    
    // Supported emotions (great for mystical/energetic states)
    emotions: ['zen', 'love', 'excited', 'surprise'],
    
    // Gesture-specific features
    features: {
        uses3D: true,           // Uses z-coordinate system
        smooth: true,           // Smooth continuous motion
        looping: true,          // Natural looping animation
        dramatic: true          // Visually impressive effect
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Twitch Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Paranoid twitching motion for suspicious/nervous states
 * @author Emotive Engine Team
 * @module gestures/motions/twitch
 * 
 * GESTURE TYPE:
 * type: 'blending' - Adds to existing particle motion
 * 
 * VISUAL EFFECT:
 * Random, sudden jerky movements that blend with existing behavior.
 * Creates a nervous, paranoid feeling with unpredictable micro-movements.
 */

var twitch = {
    name: 'twitch',
    emoji: '⚡',
    type: 'blending',
    description: 'Nervous, paranoid twitching',
    
    // Default configuration
    config: {
        intensity: 8,           // Twitch strength
        frequency: 0.08,        // Chance of twitching per frame
        duration: 100,          // How long each twitch lasts (ms)
        recovery: 200,          // Recovery time between twitches
        maxOffset: 15,          // Maximum twitch distance
        sharpness: 0.9         // How sudden the movements are
    },
    
    // Rhythm configuration - twitch syncs to nervous subdivisions
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',
        
        // Twitch probability increases on beat
        probabilitySync: {
            subdivision: 'sixteenth',
            onBeat: 0.3,        // 30% chance on beat
            offBeat: 0.05,      // 5% chance off beat
            accentBoost: 2.0    // Double on accents
        },
        
        // Intensity follows rhythm
        intensitySync: {
            onBeat: 2.0,
            offBeat: 0.8,
            curve: 'pulse'      // Sharp, sudden
        },
        
        // Pattern-specific twitching
        patternOverrides: {
            'breakbeat': {
                // Erratic broken twitches
                probabilitySync: { onBeat: 0.5, offBeat: 0.1 },
                intensitySync: { onBeat: 3.0, offBeat: 0.5 }
            },
            'dubstep': {
                // Heavy twitch on drop
                intensitySync: {
                    onBeat: 1.5,
                    dropBeat: 5.0,
                    curve: 'pulse'
                }
            }
        }
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize twitch data if needed
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        if (!particle.gestureData.twitch) {
            particle.gestureData.twitch = {
                twitchOffset: { x: 0, y: 0 },
                targetOffset: { x: 0, y: 0 },
                isTwitching: false,
                twitchTimer: 0,
                cooldownTimer: 0,
                lastTwitch: 0
            };
        }
        
        const data = particle.gestureData.twitch;
        const {config} = this;
        let intensity = motion.intensity || config.intensity;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            intensity *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            intensity *= (motion.rhythmModulation.accentMultiplier || 1);
        }
        
        // Update timers
        const currentTime = Date.now();
        
        // Check for new twitch
        if (!data.isTwitching && data.cooldownTimer <= 0) {
            if (Math.random() < (motion.frequency || config.frequency)) {
                // Start a new twitch
                data.isTwitching = true;
                data.twitchTimer = config.duration;
                data.cooldownTimer = config.recovery;
                
                // Random twitch direction and distance
                const angle = Math.random() * Math.PI * 2;
                const distance = (config.maxOffset * 0.5) + Math.random() * (config.maxOffset * 0.5);
                
                data.targetOffset = {
                    x: Math.cos(angle) * distance * intensity / 8,
                    y: Math.sin(angle) * distance * intensity / 8
                };
                
                data.lastTwitch = currentTime;
            }
        }
        
        // Update cooldown
        if (data.cooldownTimer > 0) {
            data.cooldownTimer -= dt * 16;
        }
        
        // Apply twitch motion
        if (data.isTwitching) {
            data.twitchTimer -= dt * 16;
            
            if (data.twitchTimer > 0) {
                // Sharp movement toward target
                const {sharpness} = config;
                data.twitchOffset.x += (data.targetOffset.x - data.twitchOffset.x) * sharpness;
                data.twitchOffset.y += (data.targetOffset.y - data.twitchOffset.y) * sharpness;
            } else {
                // Twitch complete, start returning
                data.isTwitching = false;
            }
        } else {
            // Return to normal position
            data.twitchOffset.x *= 0.85;
            data.twitchOffset.y *= 0.85;
        }
        
        // Apply the twitch offset to velocity (blending mode)
        particle.vx += data.twitchOffset.x * dt * 0.5;
        particle.vy += data.twitchOffset.y * dt * 0.5;
        
        // Add micro-jitter for constant nervousness
        if (Math.random() < 0.1) {
            particle.vx += (Math.random() - 0.5) * intensity * 0.3;
            particle.vy += (Math.random() - 0.5) * intensity * 0.3;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.twitch) {
            delete particle.gestureData.twitch;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sway Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var sway = {
    name: 'sway',
    type: 'blending',
    emoji: '🌊',
    description: 'Gentle side-to-side swaying motion',
    
    config: {
        duration: 2000,
        amplitude: 20,
        frequency: 1,
        strength: 0.5
    },
    
    // Rhythm configuration - sway naturally follows the beat
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Sway completes one cycle per bar
        
        // Amplitude increases on downbeats
        amplitudeSync: {
            onBeat: 1.2,
            offBeat: 0.9,
            curve: 'ease'  // Smooth transitions
        },
        
        // Duration syncs to bars for natural rhythm
        durationSync: {
            mode: 'bars',
            bars: 1  // One full sway per bar
        },
        
        // Pattern-specific swaying
        patternOverrides: {
            'waltz': {
                // 3/4 time creates elegant waltz sway
                durationSync: { bars: 1 },
                amplitudeSync: { onBeat: 1.5, curve: 'ease' }
            },
            'swing': {
                // Jazzy swing sway
                amplitudeSync: { onBeat: 1.3, offBeat: 0.7, curve: 'bounce' }
            }
        }
    },
    
    /**
     * Apply sway motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        const config = { ...this.config, ...motion };
        const amplitude = config.amplitude || this.config.amplitude;
        const frequency = config.frequency || this.config.frequency;
        const strength = config.strength || this.config.strength;
        
        // Smooth side-to-side motion
        const sway = Math.sin(progress * Math.PI * 2 * frequency) * amplitude;
        
        // Apply horizontal sway
        particle.vx += sway * 0.01 * dt * strength;
        
        // Slight vertical drift for natural feel
        particle.vy += Math.cos(progress * Math.PI * 4) * 0.5 * dt * strength;
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        // No cleanup needed for sway
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Float Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var float = {
    name: 'float',
    type: 'blending',
    emoji: '🎈',
    description: 'Gentle floating upward motion',
    
    config: {
        duration: 2000,
        amplitude: 80,  // Increased for more visible effect
        wobbleAmount: 20,  // More wobble
        strength: 1.0  // Full strength
    },
    
    // Rhythm configuration - defines how this gesture responds to musical timing
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // 'beat', 'bar', 'continuous', or 'none'
        
        // How amplitude changes with beat
        amplitudeSync: {
            onBeat: 1.5,      // Multiply amplitude on beat
            offBeat: 0.8,     // Reduce amplitude off beat
            curve: 'bounce'   // Animation curve: 'linear', 'ease', 'bounce', 'pulse'
        },
        
        // How wobble syncs to subdivisions
        wobbleSync: {
            subdivision: 'eighth',  // Sync to 8th notes
            intensity: 0.7          // How much rhythm affects wobble
        },
        
        // Duration can sync to musical time
        durationSync: {
            mode: 'bars',     // Duration in bars instead of milliseconds
            bars: 2           // Float for 2 bars
        },
        
        // Response to musical accents
        accentResponse: {
            enabled: true,
            multiplier: 1.3   // Boost effect on accented beats
        },
        
        // Optional: Different behavior for different patterns
        patternOverrides: {
            'waltz': {
                wobbleSync: { subdivision: 'quarter', intensity: 0.9 }
            },
            'dubstep': {
                amplitudeSync: { onBeat: 2.0, curve: 'pulse' }
            }
        }
    },
    
    /**
     * Apply float motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Store original values on first frame
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        if (!particle.gestureData.float) {
            particle.gestureData.float = {
                originalSize: particle.size,
                originalOpacity: particle.opacity || 1
            };
        }
        
        const config = { ...this.config, ...motion };
        let amplitude = config.amplitude || this.config.amplitude;
        let wobbleAmount = config.wobbleAmount || this.config.wobbleAmount;
        const strength = config.strength || this.config.strength;
        
        // Apply rhythm modulation if present (passed from GestureMotion.js)
        if (motion.rhythmModulation) {
            amplitude *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            amplitude *= (motion.rhythmModulation.accentMultiplier || 1);
            wobbleAmount *= (motion.rhythmModulation.wobbleMultiplier || 1);
        }
        
        // Upward floating with slight wobble
        const wobble = Math.sin(progress * Math.PI * 4) * wobbleAmount;
        
        // Apply upward force and wobble
        particle.vy -= amplitude * 0.01 * dt * strength * (1 - progress * 0.5);
        particle.vx += wobble * 0.01 * dt * strength;
        
        // Slight size variation for depth effect
        particle.size = particle.baseSize * (1 + progress * 0.1);
        
        // Fade slightly as it floats up
        particle.opacity = 1 - progress * 0.3;
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        // Reset to original values
        if (particle.gestureData?.float) {
            particle.opacity = particle.gestureData.float.originalOpacity;
            particle.size = particle.gestureData.float.originalSize;
            delete particle.gestureData.float;
        } else {
            // Fallback if no data stored
            particle.opacity = 1;
            particle.size = particle.baseSize;
        }
        
        // Dampen velocity to help particle settle
        particle.vx *= 0.5;
        particle.vy *= 0.5;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Jitter Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var jitter = {
    name: 'jitter',
    type: 'blending',
    emoji: '🫨',
    description: 'Nervous jittery movement',
    
    config: {
        duration: 1000,
        intensity: 15,  // Increased for more visible jitter
        frequency: 30,  // Higher frequency
        strength: 1.0  // Full strength
    },
    
    // Rhythm configuration - jitter intensifies on beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        
        // Jitter intensity syncs to beat
        amplitudeSync: {
            onBeat: 2.0,      // Double jitter on beat
            offBeat: 0.5,     // Calmer between beats
            curve: 'pulse'    // Sharp attack
        },
        
        // Different patterns create different nervousness
        patternOverrides: {
            'breakbeat': {
                // Chaotic jitter for breakbeat
                amplitudeSync: { onBeat: 3.0, offBeat: 0.3 }
            },
            'dubstep': {
                // Freeze then explode
                amplitudeSync: { onBeat: 5.0, offBeat: 0.1, curve: 'pulse' }
            }
        }
    },
    
    /**
     * Apply jitter motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Store original values on first frame
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        if (!particle.gestureData.jitter) {
            particle.gestureData.jitter = {
                originalSize: particle.size
            };
        }
        
        const config = { ...this.config, ...motion };
        let intensity = config.intensity || this.config.intensity;
        const strength = config.strength || this.config.strength;
        
        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            intensity *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            intensity *= (motion.rhythmModulation.accentMultiplier || 1);
        }
        
        // Random jitter in both directions
        const jitterX = (Math.random() - 0.5) * intensity * strength;
        const jitterY = (Math.random() - 0.5) * intensity * strength;
        
        // Apply jitter with decreasing intensity over time
        const fadeOut = 1 - progress * 0.5;
        particle.vx += jitterX * 0.1 * dt * fadeOut;
        particle.vy += jitterY * 0.1 * dt * fadeOut;
        
        // Slight size variation for nervous effect
        particle.size = particle.baseSize * (1 + (Math.random() - 0.5) * 0.1);
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        // Reset to original values
        if (particle.gestureData?.jitter) {
            particle.size = particle.gestureData.jitter.originalSize;
            delete particle.gestureData.jitter;
        } else {
            particle.size = particle.baseSize;
        }
        
        // Dampen velocity to help particle settle
        particle.vx *= 0.7;
        particle.vy *= 0.7;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Spin Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Spin gesture - orbital rotation around center
 * @author Emotive Engine Team
 * @module gestures/transforms/spin
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a spinning vortex effect with particles orbiting around the center.       
 * ║ This is an OVERRIDE gesture that completely replaces particle motion.             
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ↻ Clockwise rotation
 *      · → ·
 *     ↓     ↑
 *    · ← ⭐ → ·
 *     ↑     ↓  
 *      · ← ·
 * 
 * USED BY:
 * - Dizzy/confused states
 * - Celebration spins
 * - Whirlwind effects
 * - Portal/vortex animations
 */

/**
 * Spin gesture configuration and implementation
 */
var spin = {
    name: 'spin',
    emoji: '🌀',
    type: 'override', // Completely replaces motion
    description: 'Orbital rotation around center point',
    
    // Default configuration
    config: {
        duration: 600,          // Legacy fallback
        musicalDuration: { musical: true, beats: 1 }, // 1 beat (quarter note)
        rotations: 1,           // Number of full rotations
        direction: 'random',    // 'clockwise', 'counter-clockwise', or 'random'
        radiusMultiplier: 1.0,  // Orbital radius multiplier
        spiralOut: false,       // Spiral outward while spinning
        accelerate: true,       // Speed up then slow down
        maintainDistance: true, // Keep relative distance from center
        scaleAmount: 0.1,       // Scale change during spin
        easing: 'linear',       // Animation curve type
        strength: 0.7,          // Particle motion strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'spin',
            strength: 0.7,
            rotations: 1,
            radius: 1.0
        }
    },
    
    // Rhythm configuration - spin as a dance move
    rhythm: {
        enabled: true,
        syncMode: 'bar',
        
        // Rotations sync to musical time
        rotationSync: {
            mode: 'bars',
            rotationsPerBar: 1,  // One spin per bar
            accelerateOnBeat: true  // Speed up on downbeats
        },
        
        // Radius changes with beat
        radiusSync: {
            subdivision: 'quarter',
            expandOnBeat: 1.2,
            contractOffBeat: 0.9,
            curve: 'bounce'
        },
        
        // Duration in musical time
        durationSync: {
            mode: 'beats',
            beats: 4  // Spin for 4 beats (1 bar)
        },
        
        // Pattern-specific spins
        patternOverrides: {
            'waltz': {
                // Elegant waltz spin
                rotationSync: { rotationsPerBar: 0.75 },
                radiusSync: { curve: 'ease' }
            },
            'swing': {
                // Jazzy swing spin
                rotationSync: { accelerateOnBeat: false },
                direction: 'alternating'  // Change direction each bar
            },
            'dubstep': {
                // Aggressive spin with wobble
                radiusSync: {
                    subdivision: 'eighth',
                    expandOnBeat: 1.5,
                    dropMultiplier: 2.0
                },
                spiralOut: true
            },
            'breakbeat': {
                // Chaotic spin patterns
                rotationSync: { mode: 'random', range: [0.5, 2] },
                direction: 'random'
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate starting position relative to center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        // Determine spin direction
        let direction = motion.direction || this.config.direction;
        if (direction === 'random') {
            direction = Math.random() < 0.5 ? 'clockwise' : 'counter-clockwise';
        }
        
        particle.gestureData.spin = {
            startAngle: Math.atan2(dy, dx),
            startRadius: Math.sqrt(dx * dx + dy * dy) || 30, // Min radius if at center
            originalX: particle.x,
            originalY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            direction, // Store chosen direction
            initialized: true
        };
    },
    
    /**
     * Apply spin motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.spin?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.spin;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply rhythm modulation if present
        let {rotations} = config;
        let {radiusMultiplier} = config;
        if (motion.rhythmModulation) {
            if (motion.rhythmModulation.rotationMultiplier) {
                rotations *= motion.rhythmModulation.rotationMultiplier;
            }
            if (motion.rhythmModulation.radiusMultiplier) {
                radiusMultiplier *= motion.rhythmModulation.radiusMultiplier;
            }
        }
        
        // Apply acceleration curve if enabled
        let speedProgress = progress;
        if (config.accelerate) {
            // Speed up for first half, slow down for second half
            if (progress < 0.5) {
                speedProgress = this.easeInQuad(progress * 2) * 0.5;
            } else {
                speedProgress = 0.5 + this.easeOutQuad((progress - 0.5) * 2) * 0.5;
            }
        }
        
        // Calculate rotation angle using stored direction
        const rotationAmount = rotations * Math.PI * 2 * strength;
        const direction = data.direction === 'counter-clockwise' ? -1 : 1;
        const currentAngle = data.startAngle + (rotationAmount * speedProgress * direction);
        
        // Calculate radius (with optional spiral)
        let currentRadius = data.startRadius;
        if (config.spiralOut) {
            currentRadius *= (1 + progress * 0.5); // Expand outward during spin
        }
        if (radiusMultiplier !== 1) {
            // Apply radius multiplier with smooth curve
            const radiusCurve = Math.sin(progress * Math.PI); // Peak at middle
            currentRadius *= (1 + (radiusMultiplier - 1) * radiusCurve);
        }
        
        // Calculate target position
        const targetX = centerX + Math.cos(currentAngle) * currentRadius;
        const targetY = centerY + Math.sin(currentAngle) * currentRadius;
        
        // For override gesture, directly set position with smooth interpolation
        const moveSpeed = 0.25; // Adjust for smoothness
        particle.x += (targetX - particle.x) * moveSpeed;
        particle.y += (targetY - particle.y) * moveSpeed;
        
        // Set velocity to match movement (for trail effects)
        particle.vx = (targetX - particle.x) * 0.5;
        particle.vy = (targetY - particle.y) * 0.5;
        
        // Smooth ending - return to original velocities
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.spin) {
            // Restore original velocities
            const data = particle.gestureData.spin;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.spin;
        }
    },
    
    /**
     * Easing function for acceleration
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInQuad(t) {
        return t * t;
    },
    
    /**
     * Easing function for deceleration
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeOutQuad(t) {
        return t * (2 - t);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Jump Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Jump gesture - squash, leap, and land animation
 * @author Emotive Engine Team
 * @module gestures/transforms/jump
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a classic jump animation with squash & stretch principles. Particles       
 * ║ compress before jumping, stretch during flight, and squash on landing.            
 * ║ This is an OVERRIDE gesture that completely controls particle motion.             
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Phase 1: Squash    Phase 2: Jump      Phase 3: Land
 *         ⭐              ↗ ⭐ ↘              ⭐
 *         ___            /     \             ___
 *     (compressed)     (stretched)       (squashed)
 * 
 * USED BY:
 * - Joy/excitement expressions
 * - Surprise reactions
 * - Celebration animations
 * - Playful interactions
 */

/**
 * Jump gesture configuration and implementation
 */
var jump = {
    name: 'jump',
    emoji: '🦘',
    type: 'override', // Completely replaces motion
    description: 'Squash, leap, and land with classic animation principles',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        jumpHeight: 60,        // Maximum vertical leap distance
        squashAmount: 0.8,     // Compression ratio during squash
        stretchAmount: 1.2,    // Extension ratio during stretch
        anticipation: 0.2,     // Pre-jump preparation duration ratio
        hangTime: 0.1,         // Pause duration at jump peak
        landingImpact: true,   // Enable landing squash effect
        driftOutward: true,    // Particles spread during jump
        easing: 'quad',        // Animation curve type
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'jump',
            strength: 0.9,         // Jump motion intensity
            jumpHeight: 60,        // Particle jump height
            squash: 0.8,          // Particle compression amount
            stretch: 1.2          // Particle extension amount
        }
    },
    
    // Rhythm configuration - jump lands on beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Jump timing syncs to beat
        
        // Jump phases sync to rhythm
        phaseSync: {
            anticipation: 'eighth',    // Squash on 8th note before beat
            jump: 'beat',              // Launch on the beat
            landing: 'sixteenth'       // Land on 16th after beat
        },
        
        // Jump height modulation
        heightSync: {
            onBeat: 1.5,              // Higher jumps on strong beats
            offBeat: 0.8,             // Lower jumps on weak beats
            accent: 2.0,              // Extra high on accented beats
            curve: 'exponential'      // Sharp takeoff
        },
        
        // Squash and stretch intensity
        deformationSync: {
            squashOnBeat: 0.6,        // More squash on beat
            stretchOnBeat: 1.4,       // More stretch on beat
            timing: 'anticipatory'    // Deform before beat hits
        },
        
        // Hang time varies with tempo
        hangTimeSync: {
            mode: 'tempo',
            baseDuration: 0.1,        // Base hang at 120 BPM
            scaling: 'inverse'        // Slower tempo = longer hang
        },
        
        // Musical dynamics
        dynamics: {
            forte: { jumpHeight: 80, stretch: 1.3 },   // Big jumps on loud
            piano: { jumpHeight: 30, stretch: 1.1 }    // Small hops on soft
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        particle.gestureData.jump = {
            startX: particle.x,
            startY: particle.y,
            startSize: particle.size,
            originalVx: particle.vx,
            originalVy: particle.vy,
            driftDirection: (particle.x - centerX) * 0.1, // Drift away from center
            initialized: true
        };
    },
    
    /**
     * Apply jump motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.jump?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.jump;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        const jumpHeight = config.jumpHeight * strength * particle.scaleFactor;
        const squash = config.squashAmount;
        const stretch = config.stretchAmount;
        
        // Define phase breakpoints
        const anticipationEnd = config.anticipation;
        const jumpEnd = 1 - config.anticipation * 0.5; // Leave time for landing
        
        if (progress < anticipationEnd) {
            // PHASE 1: Anticipation (squash down)
            const squashProgress = progress / anticipationEnd;
            const easedSquash = this.easeOutQuad(squashProgress);
            
            // Squash size
            particle.size = data.startSize * (1 - (1 - squash) * easedSquash);
            
            // Slightly lower position (crouch)
            particle.y = data.startY + easedSquash * 5 * particle.scaleFactor;
            
            // Stop horizontal movement during anticipation
            particle.vx = 0;
            particle.vy = 0;
            
        } else if (progress < jumpEnd) {
            // PHASE 2: Jump (arc motion with stretch)
            const jumpProgress = (progress - anticipationEnd) / (jumpEnd - anticipationEnd);
            
            // Use sine curve for smooth arc
            let jumpCurve = Math.sin(jumpProgress * Math.PI);
            
            // Add hang time at peak
            if (config.hangTime > 0 && jumpProgress > 0.4 && jumpProgress < 0.6) {
                const hangProgress = (jumpProgress - 0.4) / 0.2;
                const hangCurve = this.easeInOutCubic(hangProgress);
                jumpCurve = 0.95 + hangCurve * 0.05; // Flatten at peak
            }
            
            // Vertical position
            particle.y = data.startY - jumpCurve * jumpHeight;
            
            // Horizontal drift if enabled
            if (config.driftOutward) {
                particle.x = data.startX + jumpCurve * data.driftDirection;
            }
            
            // Stretch/squash based on velocity
            if (jumpProgress < 0.5) {
                // Going up - stretch
                const stretchProgress = jumpProgress * 2;
                particle.size = data.startSize * (squash + (stretch - squash) * stretchProgress);
            } else {
                // Coming down - return to normal then squash slightly
                const fallProgress = (jumpProgress - 0.5) * 2;
                particle.size = data.startSize * (stretch - (stretch - 1) * fallProgress * 0.8);
            }
            
            // Set velocity for motion blur/trails
            particle.vx = data.driftDirection * 0.5;
            particle.vy = -Math.cos(jumpProgress * Math.PI) * jumpHeight * 0.1;
            
        } else {
            // PHASE 3: Landing (impact squash)
            const landProgress = (progress - jumpEnd) / (1 - jumpEnd);
            const easedLand = this.easeOutBounce(landProgress);
            
            // Return to ground with bounce
            particle.y = data.startY;
            
            if (config.landingImpact) {
                // Landing squash effect
                if (landProgress < 0.3) {
                    const impactProgress = landProgress / 0.3;
                    particle.size = data.startSize * (1 - (1 - squash * 0.8) * (1 - impactProgress));
                } else {
                    // Recover from squash
                    const recoverProgress = (landProgress - 0.3) / 0.7;
                    particle.size = data.startSize * (squash * 0.8 + (1 - squash * 0.8) * recoverProgress);
                }
            } else {
                // Simple size recovery
                particle.size = data.startSize * (squash + (1 - squash) * easedLand);
            }
            
            // Gradually stop motion
            particle.vx = data.originalVx * easedLand;
            particle.vy = data.originalVy * easedLand;
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.jump) {
            const data = particle.gestureData.jump;
            // Restore original properties
            particle.size = data.startSize;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.jump;
        }
    },
    
    /**
     * Easing functions
     */
    easeOutQuad(t) {
        return t * (2 - t);
    },
    
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeOutBounce(t) {
        const n1 = 7.5625;
        const d1 = 2.75;
        
        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Morph Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Morph gesture - form geometric patterns
 * @author Emotive Engine Team
 * @module gestures/transforms/morph
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Transforms the particle cloud into geometric shapes like circles, stars,          
 * ║ hearts, or other patterns. This is an OVERRIDE gesture that moves particles       
 * ║ to specific positions to form recognizable shapes.                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Random Cloud      →      Star Pattern      →      Heart Pattern
 *      · · ·                    ★                         ♥♥
 *     · · · ·          →      ·   ·           →         ♥   ♥
 *      · · ·                ·   ★   ·                  ♥     ♥
 *                             ·   ·                      ♥   ♥
 *                               ★                          ♥
 * 
 * USED BY:
 * - Love emotions (heart shape)
 * - Magic/special effects (star patterns)
 * - Achievement celebrations (trophy/medal shapes)
 * - Transitions between states
 */

/**
 * Morph gesture configuration and implementation
 */
var morph = {
    name: 'morph',
    emoji: '✨',
    type: 'override', // Completely replaces motion
    description: 'Form geometric patterns and shapes',
    
    // Default configuration
    config: {
        // Musical duration - morph over 2 beats
        musicalDuration: {
            musical: true,
            beats: 2,          // Default to half a bar
            minBeats: 1,       // Minimum quarter note
            maxBeats: 8        // Maximum 2 bars
        },
        
        // Musical phases of the morph
        phases: [
            { name: 'gather', beats: 0.25 },    // Particles gather
            { name: 'form', beats: 0.75 },      // Form the shape
            { name: 'hold', beats: 0.5 },       // Hold the shape
            { name: 'dissolve', beats: 0.5 }    // Dissolve back
        ],
        
        morphType: 'fluid',     // Type of morph animation
        pattern: 'star',        // Shape to morph into
        points: 5,              // Number of points (for star/polygon)
        innerRadius: 0.4,       // Inner radius ratio (for star)
        size: 80,               // Base size of the pattern
        amplitude: 20,          // Motion amplitude
        rotation: 0,            // Rotation angle in degrees
        smooth: true,           // Smooth movement to positions
        randomizeOrder: false,  // Randomize which particles go where
        easing: 'sine',         // Animation curve type
        strength: 1.2,          // Formation strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'morph',
            pattern: 'star',
            strength: 1.2,
            smooth: true,
            points: 5
        }
    },
    
    // Rhythm configuration - morphs on musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Morph on musical phrases
        
        // Pattern changes with musical structure
        patternSync: {
            verse: 'circle',          // Simple shape for verse
            chorus: 'star',           // Complex shape for chorus
            bridge: 'heart',          // Special shape for bridge
            drop: 'explosion'         // Dramatic for drops
        },
        
        // Morph timing syncs to measures
        timingSync: {
            formationBeat: 1,         // Start forming on beat 1
            holdBeats: 2,             // Hold shape for 2 beats
            dissolveBeat: 4,          // Dissolve on beat 4
            curve: 'anticipatory'     // Ease into formation
        },
        
        // Size pulses with rhythm
        sizeSync: {
            onBeat: 1.2,              // Expand on beat
            offBeat: 0.95,            // Contract off beat
            subdivision: 'quarter',    // Pulse every quarter note
            curve: 'elastic'          // Bouncy expansion
        },
        
        // Rotation syncs to bars
        rotationSync: {
            mode: 'continuous',       // Continuous rotation
            degreesPerBar: 90,        // Rotate 90° per bar
            direction: 'clockwise'    // Rotation direction
        },
        
        // Musical dynamics affect complexity
        dynamics: {
            forte: { points: 8, size: 100 },    // Complex shapes when loud
            piano: { points: 3, size: 60 }      // Simple shapes when soft
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     * @param {EmotiveMascot} mascot - The mascot instance for core morphing
     */
    initialize(particle, motion, centerX, centerY, _mascot) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const config = { ...this.config, ...motion };
        
        // Store original position
        const startX = particle.x;
        const startY = particle.y;
        
        // Calculate angle from center for position assignment
        const angle = Math.atan2(particle.y - centerY, particle.x - centerX);
        
        // Random rotation direction for the pattern
        const rotationDirection = Math.random() < 0.5 ? 1 : -1;
        
        // Calculate target position based on pattern
        let targetX, targetY;
        const size = config.size * particle.scaleFactor;
        const rotation = ((config.rotation || 0) * Math.PI / 180) * rotationDirection;
        
        switch (config.pattern) {
        case 'star':
            targetX = centerX;
            targetY = centerY;
            this.calculateStarPosition(particle, angle, size, config.points, config.innerRadius, rotation, centerX, centerY);
            break;
                
        case 'heart':
            this.calculateHeartPosition(particle, angle, size, rotation, centerX, centerY);
            break;
                
        case 'square':
            this.calculateSquarePosition(particle, angle, size, rotation, centerX, centerY);
            break;
                
        case 'triangle':
            this.calculateTrianglePosition(particle, angle, size, rotation, centerX, centerY);
            break;
                
        case 'circle':
        default: {
            // Simple circle pattern
            const targetRadius = size;
            targetX = centerX + Math.cos(angle + rotation) * targetRadius;
            targetY = centerY + Math.sin(angle + rotation) * targetRadius;
            break;
        }
        }
        
        particle.gestureData.morph = {
            startX,
            startY,
            targetX: particle.gestureData.morphTargetX || targetX,
            targetY: particle.gestureData.morphTargetY || targetY,
            originalVx: particle.vx,
            originalVy: particle.vy,
            rotationDirection, // Store random rotation direction
            initialized: true
        };
    },
    
    /**
     * Calculate star pattern position - mathematically correct 5-pointed star
     */
    calculateStarPosition(particle, angle, size, points, innerRadius, rotation, centerX, centerY) {
        // Create a proper 5-pointed star using mathematical formula
        // A 5-pointed star has 5 outer points and 5 inner valleys
        
        // Normalize angle to 0-2π
        const normalizedAngle = ((angle + Math.PI) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
        
        // For a 5-pointed star, we need to map to 10 positions
        // Positions 0,2,4,6,8 are outer points (tips)
        // Positions 1,3,5,7,9 are inner points (valleys)
        
        const totalPositions = 10; // Always 10 for a 5-pointed star
        const positionIndex = Math.floor((normalizedAngle / (Math.PI * 2)) * totalPositions);
        
        // Determine if this is an outer point (tip) or inner point (valley)
        const isOuterPoint = positionIndex % 2 === 0;
        const armIndex = Math.floor(positionIndex / 2);
        
        // Calculate the angle for this position
        // Outer points are at: 0°, 72°, 144°, 216°, 288°
        // Inner points are at: 36°, 108°, 180°, 252°, 324°
        let targetAngle;
        
        if (isOuterPoint) {
            // Outer point (tip of star)
            targetAngle = (armIndex * 72) * Math.PI / 180; // 72° = 360°/5
        } else {
            // Inner point (valley between arms)
            targetAngle = ((armIndex * 72) + 36) * Math.PI / 180; // 36° = 72°/2
        }
        
        // Apply rotation
        targetAngle += rotation;
        
        // Use appropriate radius
        const radius = isOuterPoint ? size : size * innerRadius;
        
        particle.gestureData.morphTargetX = centerX + Math.cos(targetAngle) * radius;
        particle.gestureData.morphTargetY = centerY + Math.sin(targetAngle) * radius;
    },
    
    /**
     * Calculate heart pattern position
     */
    calculateHeartPosition(particle, angle, size, rotation, centerX, centerY) {
        // Map angle to heart curve parameter
        const t = (angle + Math.PI) / (Math.PI * 2);
        
        // Heart parametric equations
        const scale = size * 0.05;
        const x = 16 * Math.pow(Math.sin(t * Math.PI * 2), 3);
        const y = -(13 * Math.cos(t * Math.PI * 2) - 5 * Math.cos(2 * t * Math.PI * 2) - 
                  2 * Math.cos(3 * t * Math.PI * 2) - Math.cos(4 * t * Math.PI * 2));
        
        // Scale and rotate
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX * scale;
        particle.gestureData.morphTargetY = centerY + rotY * scale;
    },
    
    /**
     * Calculate square pattern position
     */
    calculateSquarePosition(particle, angle, size, rotation, centerX, centerY) {
        // Determine which edge the particle should go to
        const rotatedAngle = angle + rotation;
        const normalizedAngle = ((rotatedAngle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
        
        let x, y;
        const halfSize = size;
        
        // Map to square edges
        if (normalizedAngle < Math.PI / 4 || normalizedAngle >= 7 * Math.PI / 4) {
            // Right edge
            x = halfSize;
            y = halfSize * Math.tan(normalizedAngle);
        } else if (normalizedAngle < 3 * Math.PI / 4) {
            // Top edge
            x = halfSize / Math.tan(normalizedAngle);
            y = halfSize;
        } else if (normalizedAngle < 5 * Math.PI / 4) {
            // Left edge
            x = -halfSize;
            y = -halfSize * Math.tan(normalizedAngle);
        } else {
            // Bottom edge
            x = -halfSize / Math.tan(normalizedAngle);
            y = -halfSize;
        }
        
        // Apply rotation
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX;
        particle.gestureData.morphTargetY = centerY + rotY;
    },
    
    /**
     * Calculate triangle pattern position
     */
    calculateTrianglePosition(particle, angle, size, rotation, centerX, centerY) {
        // Three vertices of equilateral triangle
        const vertices = [
            { x: 0, y: -size },                    // Top
            { x: -size * 0.866, y: size * 0.5 },   // Bottom left
            { x: size * 0.866, y: size * 0.5 }     // Bottom right
        ];
        
        // Determine which edge the particle should go to
        const edgeIndex = Math.floor(((angle + Math.PI) / (Math.PI * 2)) * 3) % 3;
        const nextIndex = (edgeIndex + 1) % 3;
        
        // Position along the edge
        const edgeProgress = Math.random();
        const x = vertices[edgeIndex].x + (vertices[nextIndex].x - vertices[edgeIndex].x) * edgeProgress;
        const y = vertices[edgeIndex].y + (vertices[nextIndex].y - vertices[edgeIndex].y) * edgeProgress;
        
        // Apply rotation
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const rotX = x * cosR - y * sinR;
        const rotY = x * sinR + y * cosR;
        
        particle.gestureData.morphTargetX = centerX + rotX;
        particle.gestureData.morphTargetY = centerY + rotY;
    },
    
    /**
     * Apply morph motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.morph?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.morph;
        const config = { ...this.config, ...motion };
        
        // Calculate eased progress
        let morphProgress = progress;
        
        // Add hold time at the shape
        if (config.holdTime > 0) {
            const holdStart = 0.5 - config.holdTime / 2;
            const holdEnd = 0.5 + config.holdTime / 2;
            
            if (progress < holdStart) {
                morphProgress = progress / holdStart * 0.5;
            } else if (progress < holdEnd) {
                morphProgress = 0.5; // Hold at shape
            } else {
                morphProgress = 0.5 + (progress - holdEnd) / (1 - holdEnd) * 0.5;
            }
        }
        
        // Calculate interpolated position
        let targetX, targetY;
        
        if (morphProgress <= 0.5) {
            // Moving to shape
            const moveProgress = morphProgress * 2;
            targetX = data.startX + (data.targetX - data.startX) * this.easeOutQuad(moveProgress);
            targetY = data.startY + (data.targetY - data.startY) * this.easeOutQuad(moveProgress);
        } else {
            // Returning from shape
            const returnProgress = (morphProgress - 0.5) * 2;
            targetX = data.targetX + (data.startX - data.targetX) * this.easeInQuad(returnProgress);
            targetY = data.targetY + (data.startY - data.targetY) * this.easeInQuad(returnProgress);
        }
        
        // Apply position
        if (config.smooth) {
            // Smooth movement
            const moveSpeed = 0.2;
            particle.x += (targetX - particle.x) * moveSpeed;
            particle.y += (targetY - particle.y) * moveSpeed;
        } else {
            // Direct positioning
            particle.x = targetX;
            particle.y = targetY;
        }
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.5;
        particle.vy = (targetY - particle.y) * 0.5;
        
        // Restore original velocities at the end
        if (progress > 0.9) {
            const blendFactor = (1 - progress) * 10;
            particle.vx = particle.vx * blendFactor + data.originalVx * (1 - blendFactor);
            particle.vy = particle.vy * blendFactor + data.originalVy * (1 - blendFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.morph) {
            const data = particle.gestureData.morph;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.morph;
            delete particle.gestureData.morphTargetX;
            delete particle.gestureData.morphTargetY;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeOutQuad(t) {
        return t * (2 - t);
    },
    
    easeInQuad(t) {
        return t * t;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Stretch Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Stretch gesture - scale particles along axes
 * @author Emotive Engine Team
 * @module gestures/transforms/stretch
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Stretches or squashes the particle cloud along X and Y axes independently.        
 * ║ This is an OVERRIDE gesture that directly controls particle positions to          
 * ║ create elastic deformation effects.                                               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Normal          Stretch X         Stretch Y        Squash
 *      ⭐             ← ⭐ →             ↑               ___
 *     ·⭐·           · · ⭐ · ·          ⭐              ·⭐·
 *      ⭐                                ·               ‾‾‾
 *                                        ·
 *                                        ↓
 * 
 * USED BY:
 * - Elastic animations
 * - Impact effects (squash on hit)
 * - Breathing/pulsing variations
 * - Transition effects
 */

/**
 * Stretch gesture configuration and implementation
 */
var stretch = {
    name: 'stretch',
    emoji: '↔️',
    type: 'override', // Completely replaces motion
    description: 'Scale particles along X and Y axes',
    
    // Default configuration
    config: {
        duration: 2000,        // Animation duration
        scaleX: 1.3,           // Horizontal scale factor
        scaleY: 0.9,           // Vertical scale factor
        alternate: false,      // Alternate between X and Y stretch
        elastic: true,         // Add elastic overshoot
        overshoot: 0.1,        // Elastic overshoot amount
        frequency: 1,          // Number of stretches
        easing: 'sine',        // Animation curve type
        strength: 1.0,         // Motion strength
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'stretch',
            scaleX: 1.8,       // Particle horizontal scale
            scaleY: 0.6,       // Particle vertical scale
            strength: 1.0
        },
        centerBased: true,     // Scale from center vs. origin
        preserveArea: false    // Keep total area constant
    },
    
    // Rhythm configuration - stretch pulses with rhythm
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Stretch on beats
        
        // Scale modulation with rhythm
        scaleSync: {
            onBeat: { x: 1.5, y: 0.7 },     // Stretch wide on beat
            offBeat: { x: 0.8, y: 1.3 },     // Stretch tall off beat
            subdivision: 'eighth',            // Change every 8th note
            curve: 'elastic'                 // Bouncy stretch
        },
        
        // Alternation pattern
        alternateSync: {
            pattern: 'XYXY',                 // X stretch, Y stretch pattern
            beatsPerChange: 1,               // Change axis each beat
            overlap: 0.1                      // Slight overlap in transitions
        },
        
        // Elastic overshoot on accents
        overshootSync: {
            normal: 0.1,                     // Standard overshoot
            accent: 0.3,                     // Big overshoot on accent
            downbeat: 0.2,                   // Medium on downbeat
            curve: 'spring'                  // Spring-like motion
        },
        
        // Area preservation modes
        preservationSync: {
            verse: true,                     // Maintain area in verse
            chorus: false,                   // Free deformation in chorus
            bridge: true                     // Back to preservation
        },
        
        // Musical dynamics
        dynamics: {
            forte: { scaleX: 2.0, scaleY: 0.5, overshoot: 0.4 },
            piano: { scaleX: 1.1, scaleY: 0.95, overshoot: 0.05 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate offset from center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        particle.gestureData.stretch = {
            offsetX: dx,
            offsetY: dy,
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            initialized: true
        };
    },
    
    /**
     * Apply stretch motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.stretch?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.stretch;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Calculate scale factors
        let {scaleX} = config;
        let {scaleY} = config;
        
        // Apply area preservation if enabled
        if (config.preserveArea && scaleX !== 1 && scaleY !== 1) {
            // Adjust scales to maintain area
            const targetArea = scaleX * scaleY;
            const factor = Math.sqrt(1 / targetArea);
            scaleX *= factor;
            scaleY *= factor;
        }
        
        // Handle alternating stretch
        if (config.alternate) {
            // First half: stretch X
            // Second half: stretch Y
            if (progress < 0.5) {
                const altProgress = progress * 2;
                scaleX = 1 + (scaleX - 1) * this.getElasticProgress(altProgress, config);
                scaleY = 1 + (1 / scaleX - 1) * (config.preserveArea ? 1 : 0); // Area compensation
            } else {
                const altProgress = (progress - 0.5) * 2;
                scaleX = scaleX + (1 - scaleX) * this.getElasticProgress(altProgress, config);
                scaleY = 1 + (scaleY - 1) * this.getElasticProgress(altProgress, config);
            }
        } else {
            // Apply both scales simultaneously
            const easeProgress = this.getElasticProgress(progress, config);
            scaleX = 1 + (scaleX - 1) * easeProgress * strength;
            scaleY = 1 + (scaleY - 1) * easeProgress * strength;
        }
        
        // Calculate target position
        let targetX, targetY;
        
        if (config.centerBased) {
            // Scale from center point
            targetX = centerX + data.offsetX * scaleX;
            targetY = centerY + data.offsetY * scaleY;
        } else {
            // Scale from original position
            targetX = data.startX * scaleX;
            targetY = data.startY * scaleY;
        }
        
        // Apply position
        particle.x = targetX;
        particle.y = targetY;
        
        // Set velocity based on stretch direction
        particle.vx = data.offsetX * (scaleX - 1) * strength * 0.1;
        particle.vy = data.offsetY * (scaleY - 1) * strength * 0.1;
        
        // Smooth ending
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Calculate progress with optional elastic overshoot
     * @param {number} progress - Raw progress (0-1)
     * @param {Object} config - Configuration with elastic settings
     * @returns {number} Modified progress value
     */
    getElasticProgress(progress, config) {
        if (!config.elastic) {
            return this.easeInOutCubic(progress);
        }
        
        // Elastic easing with overshoot
        if (progress === 0) return 0;
        if (progress === 1) return 1;
        
        const overshoot = config.overshoot || 0.1;
        
        if (progress < 0.5) {
            // Ease in with slight pull back
            const t = progress * 2;
            return 0.5 * this.easeInElastic(t, overshoot);
        } else {
            // Ease out with overshoot
            const t = (progress - 0.5) * 2;
            return 0.5 + 0.5 * this.easeOutElastic(t, overshoot);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.stretch) {
            const data = particle.gestureData.stretch;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.stretch;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeInElastic(t, overshoot) {
        if (t === 0) return 0;
        if (t === 1) return 1;
        const p = 0.3;
        const s = p / 4;
        return -(Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - s) * (2 * Math.PI) / p)) * (1 + overshoot);
    },
    
    easeOutElastic(t, overshoot) {
        if (t === 0) return 0;
        if (t === 1) return 1;
        const p = 0.3;
        const s = p / 4;
        return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) * (1 + overshoot) + 1;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Tilt Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Tilt gesture - particles gather and sway together
 * @author Emotive Engine Team
 * @module gestures/transforms/tilt
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a cohesive tilting motion where particles first gather toward the center, 
 * ║ then tilt and sway as a unified group. Perfect for curious or questioning         
 * ║ expressions, like a head tilt.                                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Phase 1: Gather    Phase 2: Tilt Left    Phase 3: Tilt Right
 *      · · ·               ↖ ⭐                    ⭐ ↗
 *     · · · ·      →      ↖ ⭐ ⭐        →      ⭐ ⭐ ↗
 *      · · ·               ↖ ⭐                    ⭐ ↗
 *    (scattered)         (tilted left)         (tilted right)
 * 
 * USED BY:
 * - Curiosity/questioning states
 * - Contemplation animations
 * - Playful head-tilt effects
 * - Character personality expressions
 */

/**
 * Tilt gesture configuration and implementation
 */
var tilt = {
    name: 'tilt',
    emoji: '🤔',
    type: 'override', // Completely replaces motion
    description: 'Gather particles then tilt as unified group',
    
    // Default configuration
    config: {
        duration: 500,         // Animation duration
        gatherPhase: 0.2,      // Gathering phase ratio
        tiltAngle: 45,         // Maximum tilt angle in degrees
        swayAmount: 80,        // Horizontal sway distance
        liftAmount: 60,        // Vertical lift distance during tilt
        frequency: 3,          // Number of tilt cycles
        homeRadius: 20,        // Gathering radius from center
        easing: 'sine',        // Animation curve type
        strength: 2.5,         // Overall motion intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'tilt',
            strength: 2.5,
            frequency: 3,
            swayAmount: 80,
            liftAmount: 60
        },
        smoothness: 0.25       // Movement smoothing factor
    },
    
    // Rhythm configuration - tilts sync to swing rhythm
    rhythm: {
        enabled: true,
        syncMode: 'swing',  // Tilt with swing feel
        
        // Tilt angle syncs to beat pattern
        angleSync: {
            onBeat: 45,                      // Full tilt on beat
            offBeat: -30,                    // Counter-tilt off beat
            swing: 15,                       // Extra tilt on swing beats
            subdivision: 'triplet',          // Triplet feel for smooth sway
            curve: 'ease-in-out'            // Smooth tilt transitions
        },
        
        // Gathering phase timing
        gatherSync: {
            beatsBefore: 0.5,                // Gather half beat before tilt
            releaseAfter: 0.25,              // Release quarter beat after
            intensity: 'dynamic'             // Gather speed varies with tempo
        },
        
        // Sway amount modulation
        swaySync: {
            verse: 60,                       // Gentle sway in verse
            chorus: 100,                     // Big sway in chorus
            bridge: 80,                      // Medium in bridge
            syncopated: true                 // Off-beat emphasis
        },
        
        // Lift coordination
        liftSync: {
            upOnTilt: true,                  // Lift when tilting
            heightOnAccent: 80,              // Higher lift on accents
            normalHeight: 40,                // Standard lift height
            curve: 'bounce'                  // Bouncy lift motion
        },
        
        // Musical expression
        dynamics: {
            forte: { tiltAngle: 60, swayAmount: 120, frequency: 4 },
            piano: { tiltAngle: 20, swayAmount: 40, frequency: 2 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial position and angle
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const angle = Math.atan2(dy, dx);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Assign a role for variation (some particles lag slightly)
        const role = Math.random();
        
        // Calculate home position (where particle gathers to)
        const config = { ...this.config, ...motion };
        const homeRadius = (config.homeRadius + Math.random() * 20) * particle.scaleFactor;
        
        particle.gestureData.tilt = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            angle,
            distance,
            homeRadius,
            homeX: centerX + Math.cos(angle) * homeRadius,
            homeY: centerY + Math.sin(angle) * homeRadius,
            role, // Variation factor for timing and smoothness
            initialized: true
        };
    },
    
    /**
     * Apply tilt motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.tilt?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.tilt;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        let targetX, targetY;
        
        if (progress < config.gatherPhase) {
            // PHASE 1: Gather toward center
            const gatherProgress = progress / config.gatherPhase;
            const easedGather = this.easeInOutCubic(gatherProgress);
            
            // Interpolate from start to home position
            targetX = data.startX + (data.homeX - data.startX) * easedGather;
            targetY = data.startY + (data.homeY - data.startY) * easedGather;
            
            // Apply gathering motion
            const speed = 0.6;  // Gathering speed factor
            particle.x += (targetX - particle.x) * speed;
            particle.y += (targetY - particle.y) * speed;
            
        } else {
            // PHASE 2: Tilting motion
            const tiltPhase = (progress - config.gatherPhase) / (1 - config.gatherPhase);
            const t = tiltPhase * Math.PI * config.frequency;
            const tiltProgress = Math.sin(t);
            
            // Convert tilt angle to radians
            const maxTiltRad = (config.tiltAngle * Math.PI / 180) * strength;
            
            // Calculate sway angle (oscillates left and right)
            const swayAngle = data.angle + (tiltProgress * maxTiltRad);
            
            // Add lift effect (particles rise slightly during tilt)
            const liftAmount = Math.abs(tiltProgress) * config.liftAmount * particle.scaleFactor;
            const currentRadius = data.homeRadius + liftAmount;
            
            // Calculate target position with tilt
            targetX = centerX + Math.cos(swayAngle) * currentRadius;
            targetY = centerY + Math.sin(swayAngle) * currentRadius - liftAmount * 0.3; // Add upward bias
            
            // Apply role-based variation (some particles lag)
            const smoothness = config.smoothness + data.role * 0.1;
            
            // Smooth movement to target
            particle.x += (targetX - particle.x) * smoothness;
            particle.y += (targetY - particle.y) * smoothness;
            
            // Add subtle rotation feel with velocity
            const tangentX = -Math.sin(swayAngle);
            const tangentY = Math.cos(swayAngle);
            particle.vx = tangentX * tiltProgress * 2;
            particle.vy = tangentY * tiltProgress * 2;
        }
        
        // Store current velocity for trails
        if (progress < config.gatherPhase) {
            particle.vx = (targetX - particle.x) * 0.25;
            particle.vy = (targetY - particle.y) * 0.25;
        }
        
        // Smooth ending - return to original velocities
        if (progress > 0.9) {
            const endFactor = (1 - progress) * 10;
            const returnX = data.startX + (particle.x - data.startX) * endFactor;
            const returnY = data.startY + (particle.y - data.startY) * endFactor;
            
            particle.x = returnX;
            particle.y = returnY;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.tilt) {
            const data = particle.gestureData.tilt;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.tilt;
        }
    },
    
    /**
     * Easing function for smooth animation
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Orbital Gesture with 3D Depth
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview 3D orbital gesture - particles orbit with dynamic z-depth changes
 * @author Emotive Engine Team
 * @module gestures/transforms/orbital
 * 
 * GESTURE TYPE:
 * type: 'override' - Takes complete control of particle motion
 * 
 * ACCEPTABLE TYPES:
 * - 'blending' : Adds motion to existing particle behavior (used in motions/)
 * - 'override' : Replaces particle motion completely (used in transforms/)
 * - 'effect'   : Visual effects without changing position (used in effects/)
 * 
 * VISUAL EFFECT:
 * Particles orbit around the center while transitioning between foreground and
 * background layers, creating a true 3D effect where particles pass behind and
 * in front of the orb.
 */

var orbital = {
    name: 'orbital',
    emoji: '🪐',
    type: 'override',
    description: 'Orbital motion around center',
    
    // Default configuration
    config: {
        speed: 0.02,              // Orbital rotation speed
        maintainRadius: true,     // Keep constant orbit radius
        elliptical: false,        // Use circular orbit
        use3D: true,              // Enable z-coordinate animation
        zPhaseOffset: 0,          // Phase offset for z-oscillation
        verticalOscillation: 0,   // Vertical movement for hula-hoop effect
        duration: 3000,           // Animation duration
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'orbital',
            strength: 1.0
        }
    },
    
    // Rhythm configuration - orbital paths sync to harmony
    rhythm: {
        enabled: true,
        syncMode: 'harmonic',  // Orbit follows harmonic intervals
        
        // Speed based on harmonic ratios
        speedSync: {
            tonic: 0.02,              // Base orbit speed
            fifth: 0.03,              // 3:2 ratio (perfect fifth)
            octave: 0.04,             // 2:1 ratio (octave)
            third: 0.025,             // 5:4 ratio (major third)
            curve: 'smooth'           // Smooth transitions
        },
        
        // Orbital layers by pitch
        radiusSync: {
            bass: 150,                // Outer orbit for low notes
            mid: 100,                 // Middle orbit for mids
            treble: 50,               // Inner orbit for highs
            scaling: 'logarithmic'    // Natural pitch scaling
        },
        
        // 3D depth syncs to chord progression
        depthSync: {
            major: { z: 1.0, phase: 0 },        // Front-facing for major
            minor: { z: -1, phase: Math.PI }, // Back-facing for minor
            diminished: { z: 0.5, phase: Math.PI/2 }, // Side angle
            augmented: { z: 0.8, phase: -Math.PI/2 }  // Other side
        },
        
        // Phase relationships
        phaseSync: {
            mode: 'harmonic',         // Particles phase-lock harmonically
            intervals: [1, 1.5, 2],   // Unison, fifth, octave
            drift: 0.05               // Slight phase drift for organic feel
        },
        
        // Musical dynamics
        dynamics: {
            forte: { speed: 0.04, maintainRadius: false }, // Chaotic orbits
            piano: { speed: 0.01, maintainRadius: true }   // Stable orbits
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const calculatedRadius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for orbit
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        // Set minimum radius to prevent center clustering - 3x larger spread
        const MIN_RADIUS = 100;
        const radius = Math.max(calculatedRadius, MIN_RADIUS + Math.random() * 180); // At least 180-360 pixels
        
        particle.gestureData.orbital = {
            radius,
            targetRadius: radius, // Store target for smooth transitions
            angle: calculatedRadius < 5 ? Math.random() * Math.PI * 2 : Math.atan2(dy, dx), // Random angle if at center
            originalVx: particle.vx,
            originalVy: particle.vy,
            originalZ: particle.z || 0,  // Store original z-coordinate
            zPhase: Math.random() * Math.PI * 2,  // Random phase for variety
            direction  // Random orbit direction
        };
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.orbital) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.orbital;
        const speed = (motion.speed || this.config.speed) * (motion.strength || 1);
        
        // Update angle with direction (dt is already normalized to 60fps)
        data.angle += speed * dt * data.direction;
        
        // Use the stored radius (which has minimum enforced)
        let {radius} = data;
        
        if (!motion.maintainRadius) {
            // Allow radius to vary slightly for organic motion
            radius = data.radius * (1 + Math.sin(progress * Math.PI * 2) * 0.1);
        }
        
        particle.x = centerX + Math.cos(data.angle) * radius;
        particle.y = centerY + Math.sin(data.angle) * radius;
        
        // 3D DEPTH: Animate z-coordinate for particles passing behind/in front
        if (motion.use3D !== false) {  // Default to true
            // Z oscillates as particle orbits, creating 3D effect
            // When angle is 0/2π (right side), z is positive (front)
            // When angle is π (left side), z is negative (back)
            const zAngle = data.angle + data.zPhase + (motion.zPhaseOffset || 0);
            particle.z = Math.sin(zAngle) * 0.8; // Z-depth range for layering
            
            // Add vertical oscillation for hula-hoop effect
            if (motion.verticalOscillation) {
                const verticalOffset = Math.cos(zAngle) * motion.verticalOscillation * radius * 0.1;
                particle.y += verticalOffset;
            }
        }
        
        // Set velocity to match motion
        particle.vx = -Math.sin(data.angle) * radius * speed;
        particle.vy = Math.cos(data.angle) * radius * speed;
        
        // Restore original velocity at end
        if (progress > 0.9) {
            const blendFactor = (1 - progress) * 10;
            particle.vx = particle.vx * blendFactor + data.originalVx * (1 - blendFactor);
            particle.vy = particle.vy * blendFactor + data.originalVy * (1 - blendFactor);
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.orbital) {
            const data = particle.gestureData.orbital;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.z = data.originalZ;  // Restore original z-coordinate
            delete particle.gestureData.orbital;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Hula-Hoop Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Hula-hoop variation of orbital with vertical oscillation
 * @author Emotive Engine Team
 * @module gestures/transforms/hula
 * 
 * VISUAL EFFECT:
 * Like a hula-hoop spinning around the orb - particles orbit horizontally while
 * oscillating vertically, creating a tilted ring effect with 3D depth.
 */

var hula = {
    name: 'hula',
    emoji: '🌀',
    type: 'override',
    description: 'Hula-hoop motion with vertical waves',
    
    // Default configuration
    config: {
        speed: 0.015,             // Rotation speed
        maintainRadius: false,     // Allow radius variation for organic feel
        elliptical: true,          // Elliptical orbit shape
        use3D: true,               // Enable 3D depth effect
        zPhaseOffset: Math.PI / 4, // Ring tilt angle
        verticalOscillation: 0.3,  // Vertical wave amount
        wobbleAmount: 0.15,        // Ring wobble intensity
        duration: 2500,            // Animation duration
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'hula',
            strength: 1.0,
            verticalOscillation: 0.3
        }
    },
    
    // Rhythm configuration - hula syncs to groove
    rhythm: {
        enabled: true,
        syncMode: 'bar',  // Full rotation per bar
        
        // Speed syncs to tempo for consistent rotation
        speedSync: {
            mode: 'tempo',
            baseSpeed: 0.015,      // Base speed at 120 BPM
            scaling: 'proportional' // Speed scales with BPM
        },
        
        // Wobble syncs to beat for rhythmic variation
        wobbleSync: {
            onBeat: 0.25,          // More wobble on beat
            offBeat: 0.1,          // Less wobble off beat
            curve: 'sine'          // Smooth transitions
        },
        
        // Vertical oscillation creates wave patterns
        verticalSync: {
            subdivision: 'quarter', // Wave every quarter note
            amplitude: 0.4,        // Wave height on beat
            phase: 'sequential'    // Waves follow rotation
        },
        
        // Musical expression
        dynamics: {
            forte: { wobbleAmount: 0.3, speed: 1.2 },  // Wilder on loud
            piano: { wobbleAmount: 0.05, speed: 0.8 }  // Gentler on soft
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const calculatedRadius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for hula-hoop
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        // Set minimum radius to prevent center clustering - 3x larger spread
        const MIN_RADIUS = 100; // Slightly larger for hula effect
        const radius = Math.max(calculatedRadius, MIN_RADIUS + Math.random() * 180); // At least 210-390 pixels
        
        particle.gestureData.hula = {
            radius,
            angle: calculatedRadius < 5 ? Math.random() * Math.PI * 2 : Math.atan2(dy, dx), // Random angle if at center
            originalVx: particle.vx,
            originalVy: particle.vy,
            originalZ: particle.z || 0,
            zPhase: Math.random() * Math.PI * 2,
            wobblePhase: Math.random() * Math.PI * 2,
            direction  // Random hula direction
        };
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.hula) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.hula;
        const speed = (motion.speed || this.config.speed) * (motion.strength || 1);
        
        // Smooth entry/exit transitions
        let transitionFactor = 1.0;
        if (progress < 0.1) {
            // Smooth entry (first 10%)
            transitionFactor = progress / 0.1;
            transitionFactor = Math.sin(transitionFactor * Math.PI * 0.5); // Smooth ease-in
        } else if (progress > 0.9) {
            // Smooth exit (last 10%)
            transitionFactor = (1 - progress) / 0.1;
            transitionFactor = Math.sin(transitionFactor * Math.PI * 0.5); // Smooth ease-out
        }
        
        // Update angle with direction (dt is already normalized to 60fps)
        data.angle += speed * dt * data.direction * transitionFactor;
        
        // Wobble effect - the hoop wobbles as it spins
        const wobble = Math.sin(data.angle * 2 + data.wobblePhase) * (motion.wobbleAmount || this.config.wobbleAmount) * transitionFactor;
        
        // Calculate elliptical radius with wobble and transition
        const radiusX = data.radius * (1 + wobble) * transitionFactor;
        const radiusY = data.radius * (0.7 + wobble) * transitionFactor; // Elliptical shape factor
        
        // Smoothly transition from original position to orbit position
        const targetX = centerX + Math.cos(data.angle) * radiusX;
        const targetY = centerY + Math.sin(data.angle) * radiusY;
        
        if (progress < 0.1) {
            // During entry, lerp from original position
            const dx = particle.x - centerX;
            const dy = particle.y - centerY;
            const currentRadius = Math.sqrt(dx * dx + dy * dy);
            if (currentRadius < 50) {
                // If particle is at center, move it out smoothly
                particle.x = centerX + Math.cos(data.angle) * radiusX;
                particle.y = centerY + Math.sin(data.angle) * radiusY;
            } else {
                particle.x = particle.x + (targetX - particle.x) * transitionFactor * 0.5;
                particle.y = particle.y + (targetY - particle.y) * transitionFactor * 0.5;
            }
        } else {
            particle.x = targetX;
            particle.y = targetY;
        }
        
        // 3D DEPTH with strong vertical oscillation
        const zAngle = data.angle + data.zPhase + (motion.zPhaseOffset || this.config.zPhaseOffset);
        
        // Z-coordinate for depth (behind/in front) with transition
        particle.z = Math.sin(zAngle) * 0.9 * transitionFactor;
        
        // Vertical oscillation synchronized with z-depth
        const verticalAmount = motion.verticalOscillation || this.config.verticalOscillation;
        const verticalOffset = Math.cos(zAngle * 2) * verticalAmount * data.radius * 0.2 * transitionFactor;
        particle.y += verticalOffset;
        
        // Tilt effect - particles higher when in front, lower when behind
        const tiltOffset = particle.z * data.radius * 0.1;
        particle.y -= tiltOffset;
        
        // Set velocity to match motion with smooth transitions
        const targetVx = -Math.sin(data.angle) * radiusX * speed;
        const targetVy = Math.cos(data.angle) * radiusY * speed;
        
        if (progress < 0.1) {
            // Smooth velocity transition during entry
            particle.vx = data.originalVx + (targetVx - data.originalVx) * transitionFactor;
            particle.vy = data.originalVy + (targetVy - data.originalVy) * transitionFactor;
        } else if (progress > 0.9) {
            // Smooth velocity transition during exit
            particle.vx = targetVx * transitionFactor + data.originalVx * (1 - transitionFactor);
            particle.vy = targetVy * transitionFactor + data.originalVy * (1 - transitionFactor);
            particle.z = particle.z * transitionFactor + data.originalZ * (1 - transitionFactor);
        } else {
            particle.vx = targetVx;
            particle.vy = targetVy;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.hula) {
            const data = particle.gestureData.hula;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.z = data.originalZ;
            delete particle.gestureData.hula;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Scan Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Searchlight scanning gesture for suspicious states
 * @author Emotive Engine Team
 * @module gestures/transforms/scan
 * 
 * GESTURE TYPE:
 * type: 'override' - Takes complete control of particle motion
 * 
 * VISUAL EFFECT:
 * Particles sweep back and forth in a searchlight pattern, pausing at edges
 * to simulate surveillance scanning or paranoid checking behavior.
 */

var scan = {
    name: 'scan',
    emoji: '🔍',
    type: 'override',
    description: 'Searchlight scanning motion',
    
    // Default configuration
    config: {
        scanSpeed: 0.008,         // Slow, deliberate scanning
        scanWidth: 120,           // Width of scan arc in pixels
        pauseDuration: 300,       // Pause at edges in ms
        scanHeight: 40,           // Vertical variation
        layers: 3,                // Number of scan layers
        duration: 3000            // Total animation duration
    },
    
    // Rhythm configuration - scanning syncs to measures
    rhythm: {
        enabled: true,
        syncMode: 'measure',  // Scan sweeps align with measures
        
        // Scan timing to musical structure
        sweepSync: {
            beatsPerSweep: 4,         // One sweep per measure
            pauseOnDownbeat: true,    // Pause at measure start
            reverseOnBar: true,       // Change direction each bar
            curve: 'linear'           // Steady scan motion
        },
        
        // Layer activation by dynamics
        layerSync: {
            quiet: 1,                 // Single layer when quiet
            moderate: 2,              // Two layers at medium
            loud: 3,                  // All layers when loud
            stagger: 'sequential'     // Layers activate in order
        },
        
        // Pause duration on beats
        pauseSync: {
            onBeat: 500,              // Longer pause on beat
            offBeat: 100,             // Quick pause off beat
            accent: 800,              // Extra pause on accent
            subdivision: 'quarter'    // Check every quarter note
        },
        
        // Width modulation
        widthSync: {
            verse: 80,                // Narrow scan in verse
            chorus: 140,              // Wide scan in chorus
            bridge: 100,              // Medium in bridge
            transition: 'smooth'      // Smooth width changes
        },
        
        // Musical tension mapping
        dynamics: {
            forte: { scanSpeed: 0.012, layers: 4 },    // Frantic scanning
            piano: { scanSpeed: 0.004, layers: 1 }     // Slow, single beam
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Assign particles to different scan layers
        const layer = Math.floor(Math.random() * this.config.layers);
        
        particle.gestureData.scan = {
            layer,
            phase: Math.random() * Math.PI * 2,  // Random starting phase
            direction: Math.random() < 0.5 ? 1 : -1,  // Start direction
            pauseTimer: 0,
            isPaused: false,
            originalX: particle.x,
            originalY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            scanOffset: (Math.random() - 0.5) * 20,  // Individual variation
            verticalOffset: layer * 30 - 30,  // Layer separation
            initialized: true,
            startTime: Date.now()
        };
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.scan) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.scan;
        const speed = motion.scanSpeed || this.config.scanSpeed;
        const width = motion.scanWidth || this.config.scanWidth;
        const pauseDuration = motion.pauseDuration || this.config.pauseDuration;
        
        // Handle pause at edges
        if (data.isPaused) {
            data.pauseTimer -= dt * 16;
            if (data.pauseTimer <= 0) {
                data.isPaused = false;
                data.direction *= -1;  // Reverse direction after pause
            }
        } else {
            // Update scan phase
            data.phase += speed * data.direction * dt;
            
            // Check for edge reached
            const scanPosition = Math.sin(data.phase);
            if (Math.abs(scanPosition) > 0.95) {
                data.isPaused = true;
                data.pauseTimer = pauseDuration;
            }
        }
        
        // Calculate position
        const scanX = Math.sin(data.phase) * width;
        const scanY = Math.cos(data.phase * 0.5) * (this.config.scanHeight / 2);
        
        // Smooth entry transition (first 15% of animation)
        let transitionFactor = 1.0;
        if (progress < 0.15) {
            transitionFactor = progress / 0.15;
            transitionFactor = transitionFactor * transitionFactor; // Ease in
        }
        // Smooth exit transition (last 15% of animation)
        else if (progress > 0.85) {
            transitionFactor = (1 - progress) / 0.15;
            transitionFactor = transitionFactor * transitionFactor; // Ease out
        }
        
        // Apply layer-specific positioning with smooth transitions
        const targetX = centerX + scanX + data.scanOffset;
        const targetY = centerY + scanY + data.verticalOffset;
        
        particle.x = data.originalX + (targetX - data.originalX) * transitionFactor;
        particle.y = data.originalY + (targetY - data.originalY) * transitionFactor;
        
        // Slow down during pauses for more realistic scanning
        if (data.isPaused) {
            particle.vx *= 0.85;
            particle.vy *= 0.85;
        } else {
            // Set velocity based on scan motion
            particle.vx = -Math.cos(data.phase) * width * speed * 60;
            particle.vy = -Math.sin(data.phase * 0.5) * this.config.scanHeight * speed * 30;
        }
        
        // Add slight jitter for realism
        if (Math.random() < 0.02) {
            particle.vx += (Math.random() - 0.5) * 2;
            particle.vy += (Math.random() - 0.5) * 2;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.scan) {
            const data = particle.gestureData.scan;
            // Restore original velocities for smooth exit
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.scan;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Twist Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Twist gesture - alternating rotational dance motion
 * @author Emotive Engine Team
 * @module gestures/transforms/twist
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a twisting dance motion with alternating rotation and contraction.
 * ║ This is an OVERRIDE gesture that replaces existing particle motion.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *     ↻ ⭐ ↺      <- twist left/right
 *    ╱     ╲
 *   ⭐       ⭐    <- particles contract
 *    ╲     ╱
 *     ↺ ⭐ ↻      <- twist opposite
 *
 * USED BY:
 * - Dance gestures
 * - Playful emotions
 * - Music synchronization
 */

/**
 * Twist gesture configuration and implementation
 */
var twist = {
    name: 'twist',
    emoji: '🌀',
    type: 'override', // Replaces existing motion
    description: 'Twisting dance motion with alternating rotation',

    // Default configuration
    config: {
        duration: 1200,      // Animation duration
        rotationAngle: 45,   // Max rotation angle in degrees
        contractionFactor: 0.8, // How much to contract during twist
        twistFrequency: 2,   // Number of twist cycles
        easing: 'smooth',    // Animation curve type
        strength: 0.8,       // Overall motion intensity
        // Particle motion configuration
        particleMotion: {
            type: 'twist',
            rotationAngle: 45,
            contractionFactor: 0.8,
            twistFrequency: 2
        }
    },

    // Rhythm configuration - twist syncs to beat
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',
        interruptible: true,
        priority: 4,
        blendable: false,  // Override gesture, no blending
        crossfadePoint: 'anyBeat',

        // Twist intensity syncs to beat
        amplitudeSync: {
            onBeat: 1.5,      // Stronger twist on beat
            offBeat: 0.7,     // Lighter between beats
            curve: 'elastic'  // Bouncy twist motion
        },

        // Pattern-specific twisting styles
        patternOverrides: {
            'funk': {
                // Funky twist with more rotation
                rotationAngle: 60,
                contractionFactor: 0.7
            },
            'disco': {
                // Classic disco twist
                twistFrequency: 3,
                rotationAngle: 50
            },
            'latin': {
                // Latin-style hip twist
                rotationAngle: 35,
                contractionFactor: 0.85,
                twistFrequency: 2.5
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     */
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        particle.gestureData.twist = {
            startX: particle.x,
            startY: particle.y,
            startAngle: Math.atan2(particle.y - motion.centerY, particle.x - motion.centerX),
            startDistance: Math.sqrt(
                Math.pow(particle.x - motion.centerX, 2) +
                Math.pow(particle.y - motion.centerY, 2)
            ),
            initialized: true
        };
    },

    /**
     * Apply twist motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.twist?.initialized) {
            this.initialize(particle, { ...motion, centerX, centerY });
        }

        const config = { ...this.config, ...motion };
        const data = particle.gestureData.twist;
        const strength = config.strength || this.config.strength || 1.0;

        // Calculate twist oscillation
        const twistProgress = progress * config.twistFrequency * Math.PI * 2;
        const twistAmount = Math.sin(twistProgress) * strength;

        // Apply rhythm modulation if present
        let {rotationAngle} = config;
        let {contractionFactor} = config;

        if (motion.rhythmModulation) {
            rotationAngle *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            contractionFactor = 1 - ((1 - contractionFactor) * (motion.rhythmModulation.amplitudeMultiplier || 1));
        }

        // Convert rotation to radians
        const rotationRad = (rotationAngle * Math.PI / 180) * twistAmount;

        // Calculate contraction (pull particles closer during twist)
        const currentContraction = 1 - ((1 - contractionFactor) * Math.abs(twistAmount));

        // Apply twist transformation
        const newAngle = data.startAngle + rotationRad;
        const newDistance = data.startDistance * currentContraction;

        // Calculate new position
        const targetX = centerX + Math.cos(newAngle) * newDistance;
        const targetY = centerY + Math.sin(newAngle) * newDistance;

        // Smoothly move to target position
        const moveStrength = 0.15 * strength;
        particle.x += (targetX - particle.x) * moveStrength;
        particle.y += (targetY - particle.y) * moveStrength;

        // Add some velocity for fluid motion
        particle.vx = (targetX - particle.x) * 0.05;
        particle.vy = (targetY - particle.y) * 0.05;

        // Add slight vertical bounce for more dynamic feel
        const bounceAmount = Math.sin(progress * Math.PI * 4) * 5 * strength;
        particle.y += bounceAmount * 0.1;

        // Smooth ending
        if (progress > 0.9) {
            const endFactor = 1 - ((progress - 0.9) * 10);
            particle.vx *= endFactor;
            particle.vy *= endFactor;
        }

    },

    /**
     * Clean up gesture data when complete
     */
    cleanup(particle) {
        if (particle.gestureData?.twist) {
            delete particle.gestureData.twist;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Wave Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Wave gesture - infinity pattern flow
 * @author Emotive Engine Team
 * @module gestures/effects/wave
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a flowing wave motion with particles moving in an infinity (∞) pattern.   
 * ║ This is an OVERRIDE gesture that creates smooth, hypnotic figure-8 movements.     
 * ║ Particles phase in and out for a dreamlike effect.                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *        ∞ Infinity Pattern
 *      ↗ → ↘     ↙ ← ↖
 *     ⭐     ⭐ ⭐     ⭐
 *      ↖ ← ↙     ↘ → ↗
 *         (continuous flow)
 * 
 * USED BY:
 * - Hypnotic/mesmerizing effects
 * - Dreamy transitions
 * - Magical gestures
 * - Flow states
 */

/**
 * Wave gesture configuration and implementation
 */
var wave = {
    name: 'wave',
    emoji: '🌊',
    type: 'override', // Completely replaces motion
    description: 'Infinity pattern flow with phasing',
    
    // Default configuration
    config: {
        // Musical duration - wave flows for exactly 1 bar
        musicalDuration: {
            musical: true,
            bars: 1,           // Default to 1 bar of wave motion
            minBeats: 4,       // Minimum 1 bar
            maxBeats: 16       // Maximum 4 bars
        },
        
        // Musical phases of the wave gesture
        phases: [
            { name: 'gather', beats: 0.5 },     // Particles gather
            { name: 'rise', beats: 0.5 },       // Begin rising motion
            { name: 'waveLeft', beats: 1 },     // Wave to the left
            { name: 'waveRight', beats: 1 },    // Wave to the right
            { name: 'settle', beats: 1 }        // Settle back to center
        ],
        
        amplitude: 40,         // Infinity pattern width
        frequency: 1,          // Complete cycle count
        phaseShift: 0.3,       // Particle timing offset
        liftHeight: 20,        // Vertical movement range
        fadeInOut: true,       // Enable opacity transitions
        smoothness: 0.1,       // Motion fluidity factor
        easing: 'sine',        // Animation curve type
        strength: 1.0,         // Overall effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'wave',
            strength: 1.0,     // Wave motion strength
            amplitude: 50      // Pattern size
        }
    },
    
    // Rhythm configuration - flowing wave patterns synchronized to musical waves and phrases
    rhythm: {
        enabled: true,
        syncMode: 'wave',    // Flow with musical wave patterns and melodic contours
        
        // Amplitude responds to musical dynamics and melodic range
        amplitudeSync: {
            onWave: 65,           // Large waves during musical waves
            onStatic: 25,         // Small waves during static sections
            curve: 'flowing'      // Smooth, continuous transitions
        },
        
        // Frequency matches musical phrase rhythm
        frequencySync: {
            mode: 'phrase',
            slow: 0.7,            // Slower waves for slow phrases
            fast: 1.8,            // Faster waves for quick phrases
            curve: 'melodic'      // Follows melodic contour
        },
        
        // Duration automatically syncs to bars via musicalDuration config
        durationSync: {
            mode: 'bars',         // Uses bars from musicalDuration
            adaptToPhrase: true,  // Extend to complete musical phrases
            sustain: true         // Maintain wave through phrase
        },
        
        // Phase shift creates ensemble wave effects
        phaseSync: {
            enabled: true,
            multiplier: 0.5,      // Moderate phase variation
            type: 'ensemble'      // Creates group wave patterns
        },
        
        // Response to melodic contour
        melodicResponse: {
            enabled: true,
            multiplier: 1.4,      // Wave amplitude follows melody
            type: 'amplitude'     // Affects wave size
        },
        
        // Style variations for different music types
        patternOverrides: {
            'ambient': {
                // Slow, hypnotic waves
                amplitudeSync: { onWave: 80, onStatic: 40, curve: 'hypnotic' },
                frequencySync: { slow: 0.5, fast: 1.2 },
                durationSync: { minBeats: 16, maxBeats: 64 }
            },
            'ocean': {
                // Natural, oceanic wave patterns
                amplitudeSync: { onWave: 90, onStatic: 20, curve: 'natural' },
                phaseSync: { multiplier: 0.8 },
                melodicResponse: { multiplier: 1.8 }
            },
            'electronic': {
                // Precise, digital wave forms
                amplitudeSync: { onWave: 70, onStatic: 30, curve: 'digital' },
                frequencySync: { slow: 0.8, fast: 2.5, curve: 'precise' }
            },
            'orchestral': {
                // Rich, complex wave interactions
                amplitudeSync: { onWave: 75, onStatic: 35 },
                phaseSync: { multiplier: 0.7 },
                melodicResponse: { multiplier: 2.0 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Powerful, sweeping waves
                amplitudeSync: { 
                    onWave: { multiplier: 1.8 },
                    onStatic: { multiplier: 1.4 }
                },
                frequencySync: { multiplier: 1.3 },
                melodicResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, subtle waves
                amplitudeSync: { 
                    onWave: { multiplier: 0.6 },
                    onStatic: { multiplier: 0.4 }
                },
                frequencySync: { multiplier: 0.7 },
                melodicResponse: { multiplier: 1.1 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate initial position relative to center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const angle = Math.atan2(dy, dx);
        const radius = Math.sqrt(dx * dx + dy * dy);
        
        // Random direction for wave motion
        const direction = Math.random() < 0.5 ? 1 : -1;
        
        particle.gestureData.wave = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            baseOpacity: particle.opacity || particle.life || 1,
            angle,
            radius,
            offset: Math.random() * Math.PI * 2, // Random phase offset
            role: Math.random(), // 0-1 for variation
            direction, // Random wave direction
            initialized: true
        };
    },
    
    /**
     * Apply wave motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.wave?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.wave;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing to progress
        const easeProgress = this.easeInOutSine(progress);
        
        // Add phase shift based on particle role (creates wave effect)
        const phaseShift = data.role * config.phaseShift;
        const adjustedPhase = Math.max(0, easeProgress - phaseShift);
        
        // Calculate infinity pattern (lemniscate) with direction
        const t = adjustedPhase * Math.PI * 2 * config.frequency * data.direction + data.offset;
        
        // Scale amplitude based on distance from center
        const radiusFactor = 0.5 + (data.radius / 100) * 0.5;
        const amplitude = config.amplitude * radiusFactor * strength * particle.scaleFactor;
        
        // Infinity pattern equations
        const infinityX = Math.sin(t) * amplitude;
        const infinityY = Math.sin(t * 2) * amplitude * 0.3; // Smaller vertical component
        
        // Add vertical lift effect
        const lift = -Math.abs(Math.sin(easeProgress * Math.PI)) * config.liftHeight * particle.scaleFactor;
        
        // Calculate target position
        const targetX = centerX + infinityX;
        const targetY = centerY + infinityY + lift;
        
        // Smooth movement with role-based variation
        const smoothness = config.smoothness + data.role * 0.12;
        
        // Apply position with smoothing
        particle.x += (targetX - particle.x) * smoothness;
        particle.y += (targetY - particle.y) * smoothness;
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.3;
        particle.vy = (targetY - particle.y) * 0.3;
        
        // Apply fade effect if enabled
        if (config.fadeInOut) {
            let fadeFactor;
            
            if (adjustedPhase < 0.1) {
                // Fade in
                fadeFactor = adjustedPhase / 0.1;
            } else if (adjustedPhase > 0.9) {
                // Fade out
                fadeFactor = (1 - adjustedPhase) / 0.1;
            } else {
                // Full opacity with sine variation
                fadeFactor = 0.5 + Math.sin(adjustedPhase * Math.PI) * 0.5;
            }
            
            particle.opacity = data.baseOpacity * (0.3 + fadeFactor * 0.7);
            
            // Update life for particles that use it instead of opacity
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
        }
        
        // Smooth ending
        if (progress >= 0.95) {
            const endFactor = (1 - progress) * 20;
            particle.vx = particle.vx * endFactor + data.originalVx * (1 - endFactor);
            particle.vy = particle.vy * endFactor + data.originalVy * (1 - endFactor);
            
            // Restore opacity
            if (config.fadeInOut) {
                particle.opacity = data.baseOpacity * endFactor;
                if (particle.life !== undefined) {
                    particle.life = particle.opacity;
                }
            }
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.wave) {
            const data = particle.gestureData.wave;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.opacity = data.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.wave;
        }
    },
    
    /**
     * Sine easing for smooth wave motion
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Drift Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Drift gesture - controlled floating motion
 * @author Emotive Engine Team
 * @module gestures/effects/drift
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a dreamy drifting effect where particles float outward then return home.  
 * ║ This is an OVERRIDE gesture with smooth, controlled movement and fading effects.  
 * ║ Perfect for transitions, sleepy states, or ethereal moments.                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Start         Drift Out        Hold         Return
 *      ⭐           · · ⭐           · · ·          ⭐
 *     ⭐⭐    →    · ⭐ · ⭐    →   · · · ·    →   ⭐⭐
 *      ⭐           ⭐ · ·           · · ·          ⭐
 *   (grouped)     (spread)        (faded)      (regrouped)
 * 
 * USED BY:
 * - Sleepy/drowsy states
 * - Dreamy transitions
 * - Dispersal effects
 * - Meditation/calm states
 */

/**
 * Drift gesture configuration and implementation
 */
var drift = {
    name: 'drift',
    emoji: '☁️',
    type: 'override', // Completely replaces motion
    description: 'Controlled floating with fade effects',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        distance: 50,          // Maximum drift distance
        angle: 45,             // Primary drift direction
        returnToOrigin: true,  // Return to starting position
        fadeOut: false,        // Apply fade effect during drift (disabled to prevent disappearing)
        holdTime: 0.2,         // Pause duration at drift peak
        turbulence: 0.1,       // Random movement variation amount
        angleSpread: 45,       // Directional spread range
        smoothness: 0.08,      // Movement fluidity factor
        easing: 'ease',        // Animation curve type
        strength: 1.0,         // Overall drift intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'drift',
            strength: 1.0,     // Drift motion strength
            distance: 60       // Maximum drift distance
        }
    },
    
    // Rhythm configuration - ethereal drift following ambient musical textures
    rhythm: {
        enabled: true,
        syncMode: 'ambient',  // Sync to ambient musical textures
        
        // Distance varies with musical dynamics
        distanceSync: {
            quiet: 30,            // Small drift in quiet sections
            loud: 80,             // Large drift in loud sections
            crescendo: 'expand',  // Expand drift on crescendos
            diminuendo: 'contract' // Contract drift on diminuendos
        },
        
        // Angle follows harmonic progression
        angleSync: {
            major: 45,            // Upward drift in major keys
            minor: 225,           // Downward drift in minor keys
            modulation: 'smooth', // Smooth angle changes
            cadence: 'return'     // Return to center on cadences
        },
        
        // Hold time syncs to phrase length
        holdSync: {
            shortPhrase: 0.1,     // Brief hold for short phrases
            longPhrase: 0.4,      // Extended hold for long phrases
            fermata: 'sustain'    // Sustain hold on fermatas
        },
        
        // Gentle accent response
        accentResponse: {
            enabled: true,
            multiplier: 1.3,      // Subtle drift increase on accents
            type: 'distance'      // Accent affects drift distance
        },
        
        // Pattern-specific drift styles
        patternOverrides: {
            'ambient': {
                // Slow, ethereal drifting
                distanceSync: { quiet: 40, loud: 100 },
                holdSync: { shortPhrase: 0.3, longPhrase: 0.6 }
            },
            'classical': {
                // Elegant, controlled drifting
                angleSync: { major: 30, minor: 210 },
                distanceSync: { quiet: 25, loud: 60 }
            },
            'jazz': {
                // Syncopated, unpredictable drifting
                angleSync: { 
                    major: 60, 
                    minor: 240,
                    swing: true,
                    syncopated: true
                }
            },
            'new_age': {
                // Meditative, flowing drift
                distanceSync: { quiet: 35, loud: 70 },
                holdSync: { shortPhrase: 0.4, longPhrase: 0.8 },
                angleSync: { modulation: 'gradual' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Expansive, bold drifting
                distanceSync: { 
                    quiet: { multiplier: 1.5 },
                    loud: { multiplier: 1.8 }
                },
                holdSync: { multiplier: 1.2 },
                accentResponse: { multiplier: 1.6 }
            },
            piano: {
                // Delicate, subtle drifting
                distanceSync: { 
                    quiet: { multiplier: 0.6 },
                    loud: { multiplier: 0.8 }
                },
                holdSync: { multiplier: 0.8 },
                accentResponse: { multiplier: 1.1 }
            }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate drift direction
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        let driftAngle = Math.atan2(dy, dx);
        
        // Add some spread to the drift angle
        const config = { ...this.config, ...motion };
        const spreadRad = (config.angleSpread * Math.PI / 180);
        const angleOffset = (Math.random() - 0.5) * spreadRad;
        driftAngle += angleOffset;
        
        // Determine home position (closer to center)
        const homeRadius = 30 + Math.random() * 30;
        
        particle.gestureData.drift = {
            startX: particle.x,
            startY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy,
            baseOpacity: particle.opacity || particle.life || 1,
            driftAngle,
            angleOffset,
            homeRadius: homeRadius * particle.scaleFactor,
            homeX: centerX + Math.cos(driftAngle) * homeRadius,
            homeY: centerY + Math.sin(driftAngle) * homeRadius,
            role: Math.random(), // 0-1 for timing variation
            turbulencePhase: Math.random() * Math.PI * 2,
            initialized: true
        };
    },
    
    /**
     * Apply drift motion to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.drift?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.drift;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Apply easing
        const easeProgress = this.easeInOutCubic(progress);
        
        // Add role-based phase shift for staggered movement
        const adjustedPhase = Math.max(0, easeProgress - data.role * 0.1);
        
        let targetX, targetY;
        let currentRadius;
        
        // Determine phase of drift
        if (!config.returnToOrigin) {
            // Simple outward drift
            const driftProgress = adjustedPhase;
            currentRadius = data.homeRadius + driftProgress * config.distance * strength * particle.scaleFactor;
            
        } else if (adjustedPhase < 0.4) {
            // Phase 1: Move to home position
            const homeProgress = adjustedPhase / 0.4;
            const easedHome = this.easeOutQuad(homeProgress);
            targetX = data.startX + (data.homeX - data.startX) * easedHome;
            targetY = data.startY + (data.homeY - data.startY) * easedHome;
            
        } else if (adjustedPhase < 0.6 + config.holdTime) {
            // Phase 2: Drift outward
            const driftPhase = (adjustedPhase - 0.4) / (0.2 + config.holdTime);
            currentRadius = data.homeRadius + 
                Math.sin(driftPhase * Math.PI * 0.5) * config.distance * strength * particle.scaleFactor;
            
        } else {
            // Phase 3: Return to origin
            const returnPhase = (adjustedPhase - 0.6 - config.holdTime) / (0.4 - config.holdTime);
            currentRadius = data.homeRadius + 
                Math.cos(returnPhase * Math.PI * 0.5) * config.distance * strength * particle.scaleFactor;
        }
        
        // Calculate position with turbulence
        if (currentRadius !== undefined) {
            // Add turbulence
            data.turbulencePhase += config.turbulence * dt;
            const turbulenceX = Math.sin(data.turbulencePhase) * config.turbulence * 10;
            const turbulenceY = Math.cos(data.turbulencePhase * 1.3) * config.turbulence * 10;
            
            const angle = data.driftAngle + data.angleOffset;
            targetX = centerX + Math.cos(angle) * currentRadius + turbulenceX;
            targetY = centerY + Math.sin(angle) * currentRadius + turbulenceY;
        }
        
        // Smooth movement with role variation
        const smoothness = config.smoothness + data.role * 0.08;
        particle.x += (targetX - particle.x) * smoothness;
        particle.y += (targetY - particle.y) * smoothness;
        
        // Set velocity for trails
        particle.vx = (targetX - particle.x) * 0.25;
        particle.vy = (targetY - particle.y) * 0.25;
        
        // Apply fade effect
        if (config.fadeOut) {
            let fadeFactor;
            
            if (progress < 0.25) {
                // Fade in
                fadeFactor = 0.3 + (progress / 0.25) * 0.7;
            } else if (progress < 0.75) {
                // Main phase with sine variation
                fadeFactor = 0.7 + Math.sin((progress - 0.25) * Math.PI / 0.5) * 0.3;
            } else {
                // Fade back
                fadeFactor = (1 - progress) * 4;
            }
            
            particle.opacity = data.baseOpacity * fadeFactor;
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
        }
        
        // Clean ending
        if (progress >= 0.99) {
            particle.vx = data.originalVx * 0.1;
            particle.vy = data.originalVy * 0.1;
            
            if (config.fadeOut) {
                particle.opacity = data.baseOpacity;
                if (particle.life !== undefined) {
                    particle.life = data.baseOpacity;
                }
            }
        }
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.drift) {
            const data = particle.gestureData.drift;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            particle.opacity = data.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.drift;
        }
    },
    
    /**
     * Easing functions
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    },
    
    easeOutQuad(t) {
        return t * (2 - t);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Flicker Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Flicker gesture - opacity and motion variation
 * @author Emotive Engine Team
 * @module gestures/effects/flicker
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a flickering effect with rapid opacity changes and subtle motion jitter.  
 * ║ This is a BLENDING gesture that adds visual instability, perfect for glitches,   
 * ║ electrical effects, or nervous energy.                                            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *    Frame 1      Frame 2      Frame 3      Frame 4
 *      ⭐          ·⭐·         ⭐⭐⭐         ·⭐
 *    (100%)       (30%)        (120%)        (50%)
 *    normal       dimmed       bright        partial
 * 
 * USED BY:
 * - Glitch/digital effects
 * - Electrical sparks
 * - Nervous/unstable states
 * - Teleportation effects
 * - Broken/malfunctioning states
 */

/**
 * Flicker gesture configuration and implementation
 */
var flicker = {
    name: 'flicker',
    emoji: '⚡',
    type: 'blending', // Adds to existing motion
    description: 'Rapid opacity changes with motion jitter',
    
    // Default configuration
    config: {
        duration: 800,         // Animation duration
        flickerRate: 15,       // Flicker speed
        frequency: 6,          // Flicker count
        minOpacity: 0.3,       // Minimum visibility
        maxOpacity: 1.0,       // Maximum visibility
        jitterAmount: 2,       // Position wobble range
        colorShift: false,     // Enable hue variation
        strobe: false,         // Regular vs random pattern
        pulseMode: false,      // Smooth vs sharp transitions
        groupFlicker: 0.3,     // Group synchronization probability
        easing: 'linear',      // Animation curve type
        strength: 0.7,         // Overall effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'flicker',
            strength: 0.7,     // Particle flicker strength
            frequency: 6       // Particle flicker rate
        }
    },
    
    // Rhythm configuration - flicker syncs to subdivisions
    rhythm: {
        enabled: true,
        syncMode: 'subdivision',  // Flicker on subdivisions
        
        // Flicker rate syncs to tempo
        rateSync: {
            subdivision: 'sixteenth',  // Flicker on 16th notes
            onBeat: 30,               // Rapid flicker on beat
            offBeat: 10,              // Slower between beats
            triplet: 20,              // Medium on triplets
            curve: 'step'             // Instant changes
        },
        
        // Opacity patterns with rhythm
        opacitySync: {
            pattern: 'HLMH',          // High-Low-Medium-High
            subdivision: 'eighth',     // Pattern rate
            onAccent: 0.1,           // Nearly off on accent (dramatic)
            regular: 0.5              // Medium normally
        },
        
        // Jitter amount varies
        jitterSync: {
            onBeat: 5,                // Big jitter on beat
            offBeat: 1,               // Minimal between
            accent: 10,               // Extreme on accent
            curve: 'random'           // Chaotic motion
        },
        
        // Strobe modes
        strobeSync: {
            verse: false,             // No strobe in verse
            chorus: true,             // Strobe in chorus
            drop: 'intense',          // Intense strobe on drop
            pattern: 'XOXO'          // Strobe pattern
        },
        
        // Musical dynamics
        dynamics: {
            forte: { flickerRate: 25, jitterAmount: 5, minOpacity: 0.1 },
            piano: { flickerRate: 8, jitterAmount: 1, minOpacity: 0.5 }
        }
    },
    
    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     */
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        const config = { ...this.config, ...motion };
        
        // Determine if this particle is part of a synchronized group
        const isGrouped = Math.random() < config.groupFlicker;
        
        particle.gestureData.flicker = {
            baseOpacity: particle.opacity || particle.life || 1,
            baseColor: particle.color,
            baseX: particle.x,
            baseY: particle.y,
            flickerTimer: 0,
            lastFlicker: 0,
            flickerState: true,
            isGrouped,
            groupId: isGrouped ? Math.floor(Math.random() * 3) : -1, // Assign to flicker group
            phase: Math.random() * Math.PI * 2,  // Random phase offset
            colorHue: 0,
            initialized: true
        };
    },
    
    /**
     * Apply flicker effect to particle
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.flicker?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.flicker;
        const config = { ...this.config, ...motion };
        const strength = motion.strength || 1.0;
        
        // Update flicker timer
        data.flickerTimer += dt * config.flickerRate;
        
        // Calculate opacity based on mode
        let opacityMultiplier;
        
        if (config.strobe) {
            // Strobe pattern - regular on/off
            const strobePhase = (data.flickerTimer + data.phase) % 1;
            opacityMultiplier = strobePhase < 0.5 ? 1 : config.minOpacity;
            
        } else if (config.pulseMode) {
            // Smooth pulsing
            const pulsePhase = data.flickerTimer + data.phase;
            opacityMultiplier = config.minOpacity + 
                (config.maxOpacity - config.minOpacity) * (Math.sin(pulsePhase) * 0.5 + 0.5);
            
        } else {
            // Random flicker
            if (data.flickerTimer - data.lastFlicker > 1) {
                data.lastFlicker = data.flickerTimer;
                
                // Group flicker logic
                if (data.isGrouped) {
                    // Flicker based on group timing
                    const groupPhase = Math.floor(data.flickerTimer) % 3;
                    data.flickerState = groupPhase === data.groupId;
                } else {
                    // Individual random flicker
                    data.flickerState = Math.random() > 0.3;
                }
            }
            
            // Calculate target opacity
            const targetOpacity = data.flickerState ? 
                config.maxOpacity : 
                config.minOpacity + Math.random() * 0.3;
            
            // Smooth transition for less harsh flicker
            const currentOpacity = particle.opacity / data.baseOpacity;
            opacityMultiplier = currentOpacity + (targetOpacity - currentOpacity) * 0.3;
        }
        
        // Apply opacity with strength
        const finalOpacity = data.baseOpacity * (1 + (opacityMultiplier - 1) * strength);
        particle.opacity = Math.max(0, Math.min(1, finalOpacity)); // Clamp to 0-1
        
        // Update life if used instead of opacity
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
        
        // Apply position jitter
        if (config.jitterAmount > 0 && opacityMultiplier > config.minOpacity) {
            const jitter = config.jitterAmount * strength * particle.scaleFactor;
            const jitterX = (Math.random() - 0.5) * jitter * opacityMultiplier;
            const jitterY = (Math.random() - 0.5) * jitter * opacityMultiplier;
            
            particle.vx += jitterX * 0.1 * dt;
            particle.vy += jitterY * 0.1 * dt;
        }
        
        // Apply color shift if enabled
        if (config.colorShift && particle.color) {
            data.colorHue += 0.01 * dt;
            const hueShift = Math.sin(data.colorHue) * 30; // ±30 degree hue shift
            particle.color = this.shiftHue(data.baseColor, hueShift * strength);
        }
        
        // Smooth fade in/out at gesture boundaries
        let fadeFactor = 1;
        if (progress < 0.1) {
            fadeFactor = progress / 0.1;  // Fade in
        } else if (progress > 0.9) {
            fadeFactor = (1 - progress) / 0.1;  // Fade out
        }
        
        particle.opacity *= fadeFactor;
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
        
        // Dampen velocity slightly for stability
        if (progress > 0.8) {
            particle.vx *= 0.95;
            particle.vy *= 0.95;
        }
    },
    
    /**
     * Shift the hue of a color
     * @param {string} color - Hex color string
     * @param {number} degrees - Degrees to shift hue
     * @returns {string} New hex color
     */
    shiftHue(color, degrees) {
        // Simple hue shift implementation
        // In production, use a proper color library
        if (!color || !color.startsWith('#')) return color;
        
        // Convert hex to RGB
        const hex = color.slice(1);
        const r = parseInt(hex.substr(0, 2), 16) / 255;
        const g = parseInt(hex.substr(2, 2), 16) / 255;
        const b = parseInt(hex.substr(4, 2), 16) / 255;
        
        // Simple hue rotation (approximate)
        const hueRad = degrees * Math.PI / 180;
        const cos = Math.cos(hueRad);
        const sin = Math.sin(hueRad);
        
        // Rotate around luminance axis (simplified)
        const newR = r * cos - g * sin;
        const newG = r * sin + g * cos;
        const newB = b;
        
        // Convert back to hex
        const toHex = n => {
            const val = Math.max(0, Math.min(255, Math.round(n * 255)));
            return val.toString(16).padStart(2, '0');
        };
        
        return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
    },
    
    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.flicker) {
            const data = particle.gestureData.flicker;
            particle.opacity = data.baseOpacity;
            particle.color = data.baseColor;
            if (particle.life !== undefined) {
                particle.life = data.baseOpacity;
            }
            delete particle.gestureData.flicker;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Burst Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Burst gesture - explosive outward motion
 * @author Emotive Engine Team
 * @module gestures/effects/burst
 */

var burst = {
    name: 'burst',
    emoji: '💥',
    type: 'blending',
    description: 'Explosive outward burst from center',
    
    // Default configuration
    config: {
        decay: 0.5,      // Force reduction over time
        strength: 2.0    // Initial explosion intensity
    },
    
    // Rhythm configuration - explosive bursts on strong beats
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Burst on strong beats and accents
        
        // Strength syncs to beat intensity
        strengthSync: {
            onBeat: 3.5,          // Powerful burst on beats
            offBeat: 1.0,         // Gentle burst off-beat
            curve: 'explosion'    // Sharp attack, rapid decay
        },
        
        // Decay rate responds to tempo
        decaySync: {
            mode: 'tempo',
            fast: 0.8,            // Quick decay for fast songs
            slow: 0.3,            // Slow decay for slow songs
            curve: 'exponential'
        },
        
        // Duration matches beat timing
        durationSync: {
            mode: 'beats',
            beats: 0.5,           // Half-beat burst duration
            sustain: false        // No sustain, pure burst
        },
        
        // Strong response to accents
        accentResponse: {
            enabled: true,
            multiplier: 2.5,      // Massive burst on accents
            type: 'strength'      // Accent affects burst power
        },
        
        // Pattern-specific burst styles
        patternOverrides: {
            'rock': {
                // Heavy, aggressive bursts
                strengthSync: { onBeat: 4.0, offBeat: 1.5 },
                decaySync: { fast: 0.6, slow: 0.4 }
            },
            'electronic': {
                // Sharp, precise bursts
                strengthSync: { onBeat: 3.8, offBeat: 0.8, curve: 'sharp' },
                decaySync: { fast: 0.9, slow: 0.7 }
            },
            'jazz': {
                // Syncopated, varied bursts
                strengthSync: { 
                    onBeat: 2.8, 
                    offBeat: 1.8,  // Strong off-beat emphasis
                    swing: true 
                },
                decaySync: { fast: 0.5, slow: 0.2 }
            },
            'orchestral': {
                // Dynamic, expressive bursts
                strengthSync: { onBeat: 3.2, offBeat: 0.5 },
                accentResponse: { multiplier: 3.0 }  // Very responsive to dynamics
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Explosive, powerful bursts
                strengthSync: { 
                    onBeat: { multiplier: 2.0 },
                    offBeat: { multiplier: 1.5 }
                },
                decaySync: { multiplier: 0.7 },  // Slower decay for impact
                accentResponse: { multiplier: 3.5 }
            },
            piano: {
                // Subtle, gentle bursts
                strengthSync: { 
                    onBeat: { multiplier: 0.6 },
                    offBeat: { multiplier: 0.3 }
                },
                decaySync: { multiplier: 1.3 },  // Faster decay for gentleness
                accentResponse: { multiplier: 1.8 }
            }
        }
    },
    
    /**
     * Apply explosive burst motion to particle
     * Pushes particles radially outward with decaying force
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Calculate force decay over gesture duration
        const decay = motion.decay || this.config.decay;
        const strength = (motion.strength || this.config.strength) * (1 - progress * decay);
        
        // Calculate direction from center to particle
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Apply outward force if particle isn't at center
        if (distance > 1) {
            // Normalize direction and apply explosive force
            particle.vx += (dx / distance) * strength * 2 * dt;
            particle.vy += (dy / distance) * strength * 2 * dt;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Directional Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Directional gesture - move particles in specific direction
 * @author Emotive Engine Team
 * @module gestures/effects/directional
 */

var directional = {
    name: 'directional',
    emoji: '➡️',
    type: 'blending',
    description: 'Move particles in a specific direction',
    
    // Default configuration
    config: {
        angle: 0,                // Movement direction in degrees
        returnToOrigin: false,   // Whether particles return to start
        strength: 1.0           // Force intensity
    },
    
    // Rhythm configuration - directional movement following musical flow
    rhythm: {
        enabled: true,
        syncMode: 'flow',  // Follow musical flow and direction
        
        // Direction changes with musical progression
        angleSync: {
            verse: 0,             // Right movement in verses
            chorus: 90,           // Upward movement in choruses  
            bridge: 180,          // Left movement in bridges
            outro: 270,           // Downward movement in outros
            transition: 'smooth'  // Smooth direction changes
        },
        
        // Strength pulses with rhythm
        strengthSync: {
            onBeat: 1.8,          // Strong push on beats
            offBeat: 0.6,         // Gentle drift off-beat
            curve: 'wave'         // Wave-like motion curve
        },
        
        // Return motion syncs to musical sections
        returnSync: {
            enabled: true,
            onSectionChange: true, // Return on section changes
            duration: 'transition', // Use transition timing
            strength: 1.2
        },
        
        // Accent response affects direction
        accentResponse: {
            enabled: true,
            multiplier: 2.0,      // Sharp directional push on accents
            type: 'strength'      // Accent affects movement force
        },
        
        // Pattern-specific directional styles
        patternOverrides: {
            'march': {
                // Military-style directional movement
                angleSync: { verse: 0, chorus: 0 }, // Always forward
                strengthSync: { onBeat: 2.5, offBeat: 1.0 }
            },
            'waltz': {
                // Flowing, circular directional movement
                angleSync: { 
                    verse: 45, 
                    chorus: 135,
                    bridge: 225,
                    outro: 315,
                    transition: 'circular'
                }
            },
            'swing': {
                // Syncopated directional swaying
                strengthSync: { 
                    onBeat: 1.6, 
                    offBeat: 1.4,  // Strong off-beat emphasis
                    swing: true 
                }
            },
            'electronic': {
                // Sharp, precise directional cuts
                angleSync: { transition: 'instant' },
                strengthSync: { onBeat: 2.2, offBeat: 0.4, curve: 'sharp' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, decisive direction changes
                strengthSync: { 
                    onBeat: { multiplier: 1.6 },
                    offBeat: { multiplier: 1.2 }
                },
                angleSync: { transition: 'sharp' },
                accentResponse: { multiplier: 2.5 }
            },
            piano: {
                // Gentle, subtle directional drift
                strengthSync: { 
                    onBeat: { multiplier: 0.7 },
                    offBeat: { multiplier: 0.8 }
                },
                angleSync: { transition: 'gradual' },
                accentResponse: { multiplier: 1.4 }
            }
        }
    },
    
    /**
     * Initialize directional movement data
     * Stores particle's starting position for return motion
     */
    initialize(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.directional = {
            initialX: particle.x,
            initialY: particle.y
        };
    },
    
    /**
     * Apply directional force to particle
     * Pushes particles in specified direction with optional return
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.directional) {
            this.initialize(particle);
        }
        
        // Convert angle to radians for calculation
        const angle = (motion.angle || this.config.angle) * Math.PI / 180;
        const strength = motion.strength || this.config.strength;
        
        // Apply directional force
        particle.vx += Math.cos(angle) * strength * 0.3 * dt;
        particle.vy += Math.sin(angle) * strength * 0.3 * dt;
        
        // Optional return motion in second half of gesture
        if (motion.returnToOrigin && progress > 0.5) {
            const returnProgress = (progress - 0.5) * 2;
            const data = particle.gestureData.directional;
            // Calculate return force toward initial position
            const dx = data.initialX - particle.x;
            const dy = data.initialY - particle.y;
            particle.vx += dx * returnProgress * 0.02 * dt;
            particle.vy += dy * returnProgress * 0.02 * dt;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Settle Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Settle gesture - gradually reduce velocity
 * @author Emotive Engine Team
 * @module gestures/effects/settle
 */

var settle = {
    name: 'settle',
    emoji: '🍃',
    type: 'blending',
    description: 'Gradually settle particles to rest',
    
    // Default configuration
    config: {
        damping: 0.02,     // Velocity reduction rate
        threshold: 0.01    // Minimum velocity before stop
    },
    
    // Rhythm configuration - gradual settling synchronized to musical resolution
    rhythm: {
        enabled: true,
        syncMode: 'resolution', // Settle during chord resolutions and phrase endings
        
        // Damping rate responds to musical tension/release
        dampingSync: {
            onResolution: 0.035,    // Faster settling on resolution
            onTension: 0.015,       // Slower settling during tension
            curve: 'gradual'        // Smooth, natural decay
        },
        
        // Threshold adapts to dynamic level
        thresholdSync: {
            mode: 'dynamics',
            forte: 0.02,            // Higher threshold for loud music
            piano: 0.005,           // Lower threshold for quiet music
            curve: 'exponential'
        },
        
        // Duration follows musical phrase structure
        durationSync: {
            mode: 'phrase',
            minBeats: 2,            // Minimum 2-beat settling
            maxBeats: 12,           // Maximum phrase-length settling
            sustain: true           // Maintain settling through resolution
        },
        
        // Response to cadential movements
        cadenceResponse: {
            enabled: true,
            multiplier: 1.6,        // Enhanced settling on cadences
            type: 'damping'         // Affects settling rate
        },
        
        // Style variations for different music types
        patternOverrides: {
            'ambient': {
                // Slow, atmospheric settling
                dampingSync: { onResolution: 0.025, onTension: 0.008, curve: 'atmospheric' },
                durationSync: { minBeats: 8, maxBeats: 32 }
            },
            'jazz': {
                // Smooth settling with swing feel
                dampingSync: { onResolution: 0.040, onTension: 0.020 },
                cadenceResponse: { multiplier: 1.8 }
            },
            'classical': {
                // Expressive settling following harmonic rhythm
                dampingSync: { onResolution: 0.045, onTension: 0.012, curve: 'expressive' },
                cadenceResponse: { multiplier: 2.0 }
            },
            'minimalist': {
                // Very gradual, meditative settling
                dampingSync: { onResolution: 0.020, onTension: 0.005 },
                durationSync: { minBeats: 16, maxBeats: 64 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Decisive, clear settling
                dampingSync: { 
                    onResolution: { multiplier: 1.4 },
                    onTension: { multiplier: 0.8 }
                },
                thresholdSync: { multiplier: 2.0 },
                cadenceResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, soft settling
                dampingSync: { 
                    onResolution: { multiplier: 0.7 },
                    onTension: { multiplier: 1.2 }
                },
                thresholdSync: { multiplier: 0.5 },
                cadenceResponse: { multiplier: 1.3 }
            }
        }
    },
    
    /**
     * Apply settling effect to particle
     * Gradually reduces velocity until particles come to rest
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        const damping = motion.damping || this.config.damping;
        const threshold = motion.threshold || this.config.threshold;
        
        // Apply exponential velocity damping
        particle.vx *= Math.max(0, 1 - damping * dt * 60);
        particle.vy *= Math.max(0, 1 - damping * dt * 60);
        
        // Stop completely when velocity falls below threshold
        if (Math.abs(particle.vx) < threshold) particle.vx = 0;
        if (Math.abs(particle.vy) < threshold) particle.vy = 0;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fade Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Fade gesture - opacity fade effect
 * @author Emotive Engine Team
 * @module gestures/effects/fade
 */

var fade = {
    name: 'fade',
    emoji: '👻',
    type: 'blending',
    description: 'Fade particle opacity',
    
    // Default configuration
    config: {
        fadeIn: false,      // Enable fade in effect
        fadeOut: true,      // Enable fade out effect
        minOpacity: 0,      // Minimum opacity level
        maxOpacity: 1       // Maximum opacity level
    },
    
    // Rhythm configuration - fades sync to musical dynamics
    rhythm: {
        enabled: true,
        syncMode: 'dynamic',  // Fade with volume/intensity changes
        
        // Opacity modulation with beat
        opacitySync: {
            onBeat: 0.9,              // Nearly visible on beat
            offBeat: 0.3,             // Ghostly between beats
            subdivision: 'eighth',     // Check every 8th note
            curve: 'exponential'      // Sharp opacity changes
        },
        
        // Fade timing with musical structure
        fadePhaseSync: {
            verse: { fadeIn: true, fadeOut: false },    // Build in verse
            chorus: { fadeIn: false, fadeOut: false },  // Full visibility
            bridge: { fadeIn: true, fadeOut: true },    // In and out
            outro: { fadeIn: false, fadeOut: true }     // Fade to end
        },
        
        // Pulse with rhythm
        pulseSync: {
            enabled: true,
            frequency: 'quarter',     // Pulse every quarter note
            intensity: 0.2,           // Pulse depth
            onAccent: 0.4            // Deeper pulse on accents
        },
        
        // Musical dynamics
        dynamics: {
            forte: { minOpacity: 0.5, maxOpacity: 1.0 },    // More visible when loud
            piano: { minOpacity: 0.0, maxOpacity: 0.4 }     // Ghostly when quiet
        }
    },
    
    /**
     * Initialize fade data
     * Stores particle's original opacity
     */
    initialize(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.fade = {
            baseOpacity: particle.opacity || particle.life || 1
        };
    },
    
    /**
     * Apply fade effect to particle
     * Smoothly transitions opacity based on configuration
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.fade) {
            this.initialize(particle);
        }
        
        const data = particle.gestureData.fade;
        const config = { ...this.config, ...motion };
        
        let targetOpacity;
        if (config.fadeIn && !config.fadeOut) {
            // Fade in only - opacity increases over time
            targetOpacity = config.minOpacity + (config.maxOpacity - config.minOpacity) * progress;
        } else if (config.fadeOut && !config.fadeIn) {
            // Fade out only - opacity decreases over time
            targetOpacity = config.maxOpacity - (config.maxOpacity - config.minOpacity) * progress;
        } else {
            // Fade in then out - peak opacity at midpoint
            if (progress < 0.5) {
                targetOpacity = config.minOpacity + (config.maxOpacity - config.minOpacity) * (progress * 2);
            } else {
                targetOpacity = config.maxOpacity - (config.maxOpacity - config.minOpacity) * ((progress - 0.5) * 2);
            }
        }
        
        // Apply calculated opacity
        particle.opacity = data.baseOpacity * targetOpacity;
        // Also update life property for particles that use it
        if (particle.life !== undefined) {
            particle.life = particle.opacity;
        }
    },
    
    /**
     * Clean up fade effect
     * Restores original opacity values
     */
    cleanup(particle) {
        if (particle.gestureData?.fade) {
            particle.opacity = particle.gestureData.fade.baseOpacity;
            if (particle.life !== undefined) {
                particle.life = particle.opacity;
            }
            delete particle.gestureData.fade;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Hold Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Hold gesture - freeze particles in place
 * @author Emotive Engine Team
 * @module gestures/effects/hold
 */

var hold = {
    name: 'hold',
    emoji: '⏸️',
    type: 'override',
    description: 'Hold particles in current position',
    
    // Default configuration
    config: {
        holdStrength: 0.95,  // Position retention strength
        allowDrift: false    // Enable slight movement
    },
    
    // Rhythm configuration - synchronized pause effects following musical structure
    rhythm: {
        enabled: true,
        syncMode: 'rest',    // Hold particles during musical rests and pauses
        
        // Hold strength responds to musical silence
        holdSync: {
            onRest: 0.98,         // Very strong hold during rests
            onSound: 0.80,        // Looser hold when music plays
            curve: 'immediate'    // Instant response to silence/sound
        },
        
        // Duration matches rest length
        durationSync: {
            mode: 'rests',
            minBeats: 0.5,        // Minimum half-beat hold
            maxBeats: 8,          // Maximum 8-beat hold
            sustain: true         // Maintain hold through entire rest
        },
        
        // Response to fermatas and caesuras
        pauseResponse: {
            enabled: true,
            multiplier: 1.5,      // Stronger hold during marked pauses
            type: 'strength'      // Affects hold strength
        },
        
        // Style variations for different music types
        patternOverrides: {
            'classical': {
                // Expressive holds for dramatic pauses
                holdSync: { onRest: 0.99, onSound: 0.75, curve: 'dramatic' },
                pauseResponse: { multiplier: 2.0 }
            },
            'minimal': {
                // Extended, meditative holds
                holdSync: { onRest: 0.95, onSound: 0.85 },
                durationSync: { minBeats: 2, maxBeats: 16 }
            },
            'jazz': {
                // Subtle holds that allow for swing
                holdSync: { onRest: 0.90, onSound: 0.70 },
                allowDrift: true  // Enable slight movement for swing feel
            },
            'electronic': {
                // Precise, digital-style holds
                holdSync: { onRest: 0.99, onSound: 0.60, curve: 'digital' },
                pauseResponse: { multiplier: 1.2 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Strong, definitive holds
                holdSync: { 
                    onRest: { multiplier: 1.02 },
                    onSound: { multiplier: 0.9 }
                },
                pauseResponse: { multiplier: 2.2 }
            },
            piano: {
                // Gentle, floating holds
                holdSync: { 
                    onRest: { multiplier: 0.97 },
                    onSound: { multiplier: 0.85 }
                },
                pauseResponse: { multiplier: 1.3 }
            }
        }
    },
    
    initialize(particle) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.hold = {
            holdX: particle.x,
            holdY: particle.y,
            originalVx: particle.vx,
            originalVy: particle.vy
        };
    },
    
    /**
     * Apply hold effect to particle
     * Freezes or slows particle movement based on configuration
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.hold) {
            this.initialize(particle);
        }
        
        const data = particle.gestureData.hold;
        const holdStrength = motion.holdStrength || this.config.holdStrength;
        
        if (motion.allowDrift) {
            // Allow slight drift with velocity damping
            particle.vx *= holdStrength;
            particle.vy *= holdStrength;
        } else {
            // Hard hold - lock to position
            particle.x += (data.holdX - particle.x) * (1 - holdStrength);
            particle.y += (data.holdY - particle.y) * (1 - holdStrength);
            particle.vx = 0;
            particle.vy = 0;
        }
        
        // Gradually restore velocity near end
        if (progress > 0.9) {
            const restoreFactor = (progress - 0.9) * 10;
            particle.vx = particle.vx * (1 - restoreFactor) + data.originalVx * restoreFactor;
            particle.vy = particle.vy * (1 - restoreFactor) + data.originalVy * restoreFactor;
        }
    },
    
    cleanup(particle) {
        if (particle.gestureData?.hold) {
            const data = particle.gestureData.hold;
            particle.vx = data.originalVx;
            particle.vy = data.originalVy;
            delete particle.gestureData.hold;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Breathe Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Breathe gesture - inhale/exhale particle motion
 * @author Emotive Engine Team
 * @module gestures/effects/breathe
 */

var breathe = {
    name: 'breathe',
    emoji: '🫁',
    type: 'blending',
    description: 'Breathing rhythm with inhale and exhale',
    
    // Default configuration
    config: {
        // Musical duration - one full breath per bar
        musicalDuration: {
            musical: true,
            bars: 1,           // Default to 1 bar breathing cycle
            minBeats: 2,       // Minimum half bar
            maxBeats: 16       // Maximum 4 bars for slow breathing
        },
        
        // Musical phases of breathing
        phases: [
            { name: 'inhale', beats: 1.5 },     // Inhale phase
            { name: 'hold_in', beats: 0.5 },    // Hold at peak
            { name: 'exhale', beats: 1.5 },     // Exhale phase
            { name: 'hold_out', beats: 0.5 }    // Hold at rest
        ],
        
        inhaleRadius: 1.5,     // Maximum expansion distance
        exhaleRadius: 0.3,     // Minimum contraction distance
        breathRate: 0.3,       // Breathing rhythm speed
        spiralStrength: 0.002, // Subtle spiral motion intensity
        scaleAmount: 0.25,     // Core size variation amount
        glowAmount: 0.4,       // Glow intensity variation
        frequency: 1,          // Number of breath cycles
        easing: 'sine',        // Smooth, natural curve type
        strength: 0.8,         // Overall motion influence
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'breathe',
            strength: 0.8,         // Particle response strength
            inhaleRadius: 1.5,     // Particle expansion limit
            exhaleRadius: 0.3      // Particle contraction limit
        }
    },
    
    // Rhythm configuration - breathing synced to musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Long breathing cycles across musical phrases
        
        // Breath rate syncs to musical tempo
        breathRateSync: {
            mode: 'tempo',
            bpm: 'auto',          // Match song tempo
            subdivision: 'whole', // Full breaths on whole notes
            curve: 'sine'         // Natural breathing curve
        },
        
        // Inhale/exhale expansion syncs to dynamics
        radiusSync: {
            inhale: {
                onUpbeat: 1.8,    // Deeper inhale on upbeats
                onDownbeat: 1.4,  // Standard inhale on downbeats
                curve: 'ease-in'
            },
            exhale: {
                onUpbeat: 0.2,    // Complete exhale on upbeats
                onDownbeat: 0.4,  // Gentle exhale on downbeats
                curve: 'ease-out'
            }
        },
        
        // Duration matches musical phrasing
        durationSync: {
            mode: 'phrases',
            phrases: 2,           // Breathe across 2 musical phrases
            hold: 'fermata'       // Hold breath on fermatas
        },
        
        // Respond to musical accents
        accentResponse: {
            enabled: true,
            multiplier: 1.5,      // Deeper breath on accents
            type: 'expansion'     // Accent affects radius expansion
        },
        
        // Pattern-specific breathing styles
        patternOverrides: {
            'ballad': {
                // Slow, deep breathing for emotional ballads
                breathRateSync: { subdivision: 'double-whole' },
                radiusSync: { 
                    inhale: { onUpbeat: 2.2, onDownbeat: 1.8 },
                    exhale: { onUpbeat: 0.1, onDownbeat: 0.2 }
                }
            },
            'uptempo': {
                // Quick, energetic breathing
                breathRateSync: { subdivision: 'half' },
                radiusSync: { 
                    inhale: { onUpbeat: 1.4, onDownbeat: 1.2 },
                    exhale: { onUpbeat: 0.3, onDownbeat: 0.4 }
                }
            },
            'ambient': {
                // Ethereal, floating breathing
                breathRateSync: { subdivision: 'whole', curve: 'ease' },
                radiusSync: { 
                    inhale: { onUpbeat: 1.6, onDownbeat: 1.6 },
                    exhale: { onUpbeat: 0.2, onDownbeat: 0.2 }
                }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, deep breathing
                radiusSync: { 
                    inhale: { multiplier: 1.8 },
                    exhale: { multiplier: 0.5 }
                },
                spiralStrength: 0.004,  // More spiral motion
                scaleAmount: 0.4
            },
            piano: {
                // Gentle, subtle breathing
                radiusSync: { 
                    inhale: { multiplier: 1.2 },
                    exhale: { multiplier: 0.8 }
                },
                spiralStrength: 0.001,  // Minimal spiral
                scaleAmount: 0.1
            }
        }
    },
    
    /**
     * Initialize breathing data for a particle
     * Stores particle's starting position and relationship to center
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        // Calculate particle's position relative to orb center
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        
        particle.gestureData.breathe = {
            startX: particle.x,                        // Original X position
            startY: particle.y,                        // Original Y position
            angle: Math.atan2(dy, dx),                // Direction from center
            baseRadius: Math.sqrt(dx * dx + dy * dy), // Distance from center
            phaseOffset: Math.random() * 0.2 - 0.1    // Slight timing variation for organic feel
        };
    },
    
    /**
     * Apply breathing motion to particle
     * Creates expansion/contraction movement synchronized with breath rhythm
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize particle data if needed
        if (!particle.gestureData?.breathe) {
            this.initialize(particle, motion, centerX, centerY);
        }
        const config = { ...this.config, ...motion };
        
        // Calculate breath phase - creates smooth sine wave between exhale and inhale
        // Result oscillates smoothly between 0 (exhale) and 1 (inhale)
        const breathPhase = (Math.sin(progress * Math.PI * 2 * config.breathRate) + 1) / 2;
        
        // Define breathing boundaries relative to orb size
        // Scale boundaries based on particle's size factor for consistent appearance
        const referenceRadius = 100 * (particle.scaleFactor || 1);
        const inhaleRadius = config.inhaleRadius * referenceRadius;
        const exhaleRadius = config.exhaleRadius * referenceRadius;
        
        // Interpolate target position between exhale and inhale boundaries
        const targetRadius = exhaleRadius + (inhaleRadius - exhaleRadius) * breathPhase;
        
        // Calculate particle's current distance from center
        const currentDx = particle.x - centerX;
        const currentDy = particle.y - centerY;
        const currentRadius = Math.sqrt(currentDx * currentDx + currentDy * currentDy);
        
        // Calculate radial movement needed to reach target breathing position
        const radiusDiff = targetRadius - currentRadius;
        const moveStrength = (motion.strength || 0.8) * 0.05 * dt;
        
        // Apply radial motion (move in/out from center)
        if (currentRadius > 0) {
            // Normalize direction and apply movement
            const moveX = (currentDx / currentRadius) * radiusDiff * moveStrength;
            const moveY = (currentDy / currentRadius) * radiusDiff * moveStrength;
            
            particle.vx += moveX;
            particle.vy += moveY;
            
            // Add organic spiral motion for more natural breathing feel
            // Creates slight circular drift during expansion/contraction
            const spiralStrength = config.spiralStrength * dt * (motion.strength || 1);
            const tangentX = -currentDy / currentRadius;  // Perpendicular to radial direction
            const tangentY = currentDx / currentRadius;
            
            // Spiral motion stronger during inhale, creating expanding spiral
            particle.vx += tangentX * spiralStrength * breathPhase;
            particle.vy += tangentY * spiralStrength * breathPhase;
        }
        
        // Apply velocity damping for smooth, controlled motion
        // Prevents particles from overshooting or oscillating
        particle.vx *= 0.98;
        particle.vy *= 0.98;
    },
    
    /**
     * Clean up breathing data when gesture completes
     * Removes stored data to free memory
     */
    cleanup(particle) {
        if (particle.gestureData?.breathe) {
            delete particle.gestureData.breathe;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Expand Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Expand gesture - particles move outward from center
 * @author Emotive Engine Team
 * @module gestures/effects/expand
 */

var expand = {
    name: 'expand',
    emoji: '💫',
    type: 'blending',
    description: 'Radial expansion from center',
    
    // Default configuration
    config: {
        duration: 600,        // Gesture duration
        scaleAmount: 3.0,     // Core scale expansion amount
        scaleTarget: 3.0,     // Target expansion distance ratio
        glowAmount: 0.5,      // Glow intensity increase
        easing: 'back',       // Overshoot animation curve
        strength: 3.0,        // Outward push force intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 3.0,        // Particle push strength
            direction: 'outward', // Movement away from center
            persist: true         // Maintain expanded position
        }
    },
    
    // Rhythm configuration - expansive growth synced to musical crescendos
    rhythm: {
        enabled: true,
        syncMode: 'crescendo',  // Expand during musical crescendos
        
        // Expansion strength follows dynamics
        strengthSync: {
            pianissimo: 1.5,      // Gentle expansion in quiet sections
            fortissimo: 5.0,      // Massive expansion in loud sections
            crescendo: 'build',   // Gradual build during crescendos
            sforzando: 'burst'    // Sudden expansion on sforzandos
        },
        
        // Scale target responds to musical intensity
        scaleTargetSync: {
            verse: 2.0,           // Moderate expansion in verses
            chorus: 4.5,          // Large expansion in choruses
            climax: 6.0,          // Maximum expansion at climax
            curve: 'exponential'  // Exponential growth curve
        },
        
        // Duration matches musical phrasing
        durationSync: {
            mode: 'phrases',
            build: 1.2,           // Extended duration during builds
            release: 0.8,         // Quick expansion on releases
            sustain: 'hold'       // Hold expansion during sustains
        },
        
        // Strong accent response
        accentResponse: {
            enabled: true,
            multiplier: 2.8,      // Massive expansion on accents
            type: 'strength'      // Accent affects expansion force
        },
        
        // Pattern-specific expansion styles
        patternOverrides: {
            'orchestral': {
                // Epic, cinematic expansion
                strengthSync: { 
                    pianissimo: 2.0, 
                    fortissimo: 6.5,
                    crescendo: 'dramatic'
                },
                scaleTargetSync: { climax: 8.0 }
            },
            'rock': {
                // Aggressive, powerful expansion
                strengthSync: { 
                    pianissimo: 1.8, 
                    fortissimo: 5.5,
                    curve: 'power'
                },
                accentResponse: { multiplier: 3.2 }
            },
            'ambient': {
                // Gentle, organic expansion
                strengthSync: { 
                    pianissimo: 1.2, 
                    fortissimo: 3.5,
                    crescendo: 'organic'
                },
                durationSync: { build: 1.8, release: 1.2 }
            },
            'electronic': {
                // Sharp, controlled expansion
                strengthSync: { 
                    pianissimo: 1.6, 
                    fortissimo: 4.8,
                    curve: 'digital'
                },
                scaleTargetSync: { curve: 'linear' }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, overwhelming expansion
                strengthSync: { 
                    pianissimo: { multiplier: 1.4 },
                    fortissimo: { multiplier: 1.8 }
                },
                scaleTargetSync: { multiplier: 1.6 },
                accentResponse: { multiplier: 3.5 }
            },
            piano: {
                // Delicate, controlled expansion
                strengthSync: { 
                    pianissimo: { multiplier: 0.8 },
                    fortissimo: { multiplier: 1.2 }
                },
                scaleTargetSync: { multiplier: 0.7 },
                accentResponse: { multiplier: 2.0 }
            }
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        particle.gestureData.expand = {
            startX: particle.x,
            startY: particle.y,
            angle: Math.atan2(dy, dx),
            baseRadius: Math.sqrt(dx * dx + dy * dy),
            initialized: true
        };
    },
    
    /**
     * Apply expansion motion to particle
     * Pushes particles outward from center with explosive force
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.expand?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.expand;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate expansion amount based on progress
        const expandFactor = 1 + (config.scaleTarget - 1) * progress * strength;
        const targetRadius = data.baseRadius * expandFactor;
        
        // Calculate target position farther from center
        const targetX = centerX + Math.cos(data.angle) * targetRadius;
        const targetY = centerY + Math.sin(data.angle) * targetRadius;
        
        // Apply strong outward push forces
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;
        particle.vx += dx * 0.8 * dt;  // Strong explosive push
        particle.vy += dy * 0.8 * dt;  // Strong explosive push
        
        // Apply velocity damping for controlled motion
        particle.vx *= 0.95;
        particle.vy *= 0.95;
    },
    
    cleanup(particle) {
        if (particle.gestureData?.expand) {
            delete particle.gestureData.expand;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Contract Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Contract gesture - particles move inward toward center
 * @author Emotive Engine Team
 * @module gestures/effects/contract
 */

var contract = {
    name: 'contract',
    emoji: '🌀',
    type: 'blending',
    description: 'Radial contraction toward center',
    
    // Default configuration
    config: {
        duration: 600,        // Gesture duration
        scaleAmount: 0.2,     // Core scale reduction amount
        scaleTarget: 0.2,     // Target contraction distance ratio
        glowAmount: -0.2,     // Glow intensity reduction
        easing: 'cubic',      // Smooth acceleration curve
        strength: 2.5,        // Inward pull force intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'pulse',
            strength: 2.5,        // Particle pull strength
            direction: 'inward',  // Movement toward center
            persist: true         // Effect continues after gesture
        }
    },
    
    // Rhythm configuration - magnetic contraction synced to musical tension
    rhythm: {
        enabled: true,
        syncMode: 'tension',  // Contract during musical tension builds
        
        // Contraction strength responds to musical intensity
        strengthSync: {
            onTension: 4.0,       // Strong pull during tension
            onRelease: 1.5,       // Gentle pull during release
            curve: 'magnetic'     // Smooth magnetic pull curve
        },
        
        // Scale target changes with dynamics
        scaleTargetSync: {
            forte: 0.1,           // Tight contraction for loud sections
            piano: 0.4,           // Gentle contraction for soft sections
            crescendo: 'gradual', // Gradual tightening on crescendos
            diminuendo: 'ease'    // Easy relaxation on diminuendos
        },
        
        // Duration responds to phrase length
        durationSync: {
            mode: 'phrases',
            shortPhrase: 0.8,     // Quick contraction for short phrases  
            longPhrase: 1.5,      // Extended contraction for long phrases
            hold: 'sustain'       // Maintain contraction during holds
        },
        
        // Strong accent response
        accentResponse: {
            enabled: true,
            multiplier: 2.2,      // Sharp contraction on accents
            type: 'strength'      // Accent affects pull force
        },
        
        // Pattern-specific contraction styles
        patternOverrides: {
            'classical': {
                // Elegant, controlled contraction
                strengthSync: { onTension: 3.5, onRelease: 1.8 },
                scaleTargetSync: { forte: 0.15, piano: 0.35 }
            },
            'metal': {
                // Aggressive, tight contraction
                strengthSync: { onTension: 5.0, onRelease: 2.0, curve: 'sharp' },
                scaleTargetSync: { forte: 0.05, piano: 0.25 }
            },
            'ambient': {
                // Slow, atmospheric contraction
                strengthSync: { onTension: 2.8, onRelease: 1.2, curve: 'ease' },
                durationSync: { shortPhrase: 1.2, longPhrase: 2.0 }
            },
            'trap': {
                // Sudden, rhythmic contraction on drops
                strengthSync: { 
                    onTension: 4.5, 
                    onRelease: 1.0,
                    dropBeat: 6.0   // Massive contraction on trap drops
                },
                scaleTargetSync: { forte: 0.08, piano: 0.3 }
            }
        },
        
        // Musical dynamics variations
        dynamics: {
            forte: {
                // Powerful, crushing contraction
                strengthSync: { 
                    onTension: { multiplier: 1.8 },
                    onRelease: { multiplier: 1.4 }
                },
                scaleTargetSync: { multiplier: 0.6 },  // Tighter contraction
                accentResponse: { multiplier: 2.8 }
            },
            piano: {
                // Gentle, subtle contraction
                strengthSync: { 
                    onTension: { multiplier: 0.7 },
                    onRelease: { multiplier: 0.8 }
                },
                scaleTargetSync: { multiplier: 1.4 },  // Looser contraction
                accentResponse: { multiplier: 1.6 }
            }
        }
    },
    
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        particle.gestureData.contract = {
            startX: particle.x,
            startY: particle.y,
            angle: Math.atan2(dy, dx),
            baseRadius: Math.sqrt(dx * dx + dy * dy),
            initialized: true
        };
    },
    
    /**
     * Apply contraction motion to particle
     * Pulls particles toward center with magnetic-like force
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.contract?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        
        const data = particle.gestureData.contract;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate contraction amount based on progress
        const contractFactor = 1 - (1 - config.scaleTarget) * progress * strength;
        const targetRadius = data.baseRadius * contractFactor;
        
        // Calculate target position closer to center
        const targetX = centerX + Math.cos(data.angle) * targetRadius;
        const targetY = centerY + Math.sin(data.angle) * targetRadius;
        
        // Apply strong inward pull forces
        const dx = targetX - particle.x;
        const dy = targetY - particle.y;
        particle.vx += dx * 0.5 * dt;  // Strong magnetic pull
        particle.vy += dy * 0.5 * dt;  // Strong magnetic pull
        
        // Apply velocity damping for controlled motion
        particle.vx *= 0.95;
        particle.vy *= 0.95;
    },
    
    cleanup(particle) {
        if (particle.gestureData?.contract) {
            delete particle.gestureData.contract;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Flash Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Flash gesture - bright burst effect
 * @author Emotive Engine Team
 * @module gestures/effects/flash
 */

var flash = {
    name: 'flash',
    emoji: '⚡',
    type: 'blending',
    description: 'Bright flash burst effect',
    
    // Default configuration
    config: {
        duration: 400,       // Animation duration
        glowAmount: 2.5,     // Overall brightness increase
        glowPeak: 3.0,       // Maximum intensity level
        scalePeak: 1.1,      // Size expansion at peak
        easing: 'cubic',     // Animation curve type
        strength: 1.0,       // Effect intensity
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'burst',
            strength: 1.0,   // Burst force intensity
            decay: 0.3       // Force reduction rate
        }
    },
    
    // Rhythm configuration - flash on beats and accents
    rhythm: {
        enabled: true,
        syncMode: 'beat',  // Flash on beats
        timingSync: 'immediate',    // Flash immediately (for impact)
        interruptible: true,         // Can interrupt
        priority: 8,                 // High priority
        blendable: true,             // Can layer over other effects
        
        // Flash intensity syncs to beat strength
        intensitySync: {
            onBeat: 3.5,              // Bright flash on beat
            offBeat: 1.0,             // Dim between beats
            accent: 5.0,              // Blinding on accent
            subdivision: 'quarter',    // Flash every quarter note
            curve: 'exponential'      // Sharp flash attack
        },
        
        // Duration varies with tempo
        durationSync: {
            mode: 'tempo',
            baseDuration: 400,        // Base at 120 BPM
            scaling: 'inverse'        // Faster tempo = shorter flash
        },
        
        // Scale pulse with flash
        scaleSync: {
            onBeat: 1.2,              // Expand on beat
            offBeat: 1.0,             // Normal size off beat
            accent: 1.4,              // Big expansion on accent
            curve: 'elastic'          // Bouncy scale
        },
        
        // Strobe patterns
        strobeSync: {
            enabled: false,           // Enable for strobe effect
            pattern: 'XXOX',          // X=flash, O=dark
            subdivision: 'sixteenth'  // Strobe rate
        },
        
        // Musical dynamics
        dynamics: {
            forte: { glowPeak: 4.0, scalePeak: 1.3, duration: 300 },
            piano: { glowPeak: 2.0, scalePeak: 1.05, duration: 500 }
        }
    },
    
    initialize(particle, motion) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        particle.gestureData.flash = {
            originalOpacity: particle.opacity,
            originalSize: particle.size,
            initialized: true
        };
    },
    
    /**
     * Apply flash effect to particle
     * Creates bright burst with size expansion and outward motion
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        if (!particle.gestureData?.flash?.initialized) {
            this.initialize(particle, motion);
        }
        
        const data = particle.gestureData.flash;
        const config = { ...this.config, ...motion };
        const strength = config.strength || 1.0;
        
        // Calculate flash intensity curve
        let flashIntensity;
        if (progress < 0.3) {
            // Quick rise to peak brightness
            flashIntensity = (progress / 0.3) * config.glowPeak;
        } else {
            // Gradual fade from peak
            flashIntensity = config.glowPeak * (1 - (progress - 0.3) / 0.7);
        }
        
        // Apply brightness and size changes
        particle.opacity = Math.min(1, data.originalOpacity * (1 + flashIntensity * strength));
        particle.size = data.originalSize * (1 + (config.scalePeak - 1) * flashIntensity * strength * 0.1);
        
        // Initial burst motion - particles briefly explode outward
        if (progress < 0.2) {
            const burstStrength = (1 - progress / 0.2) * strength;
            const angle = Math.atan2(particle.y - centerY, particle.x - centerX);
            particle.vx += Math.cos(angle) * burstStrength * 2 * dt;
            particle.vy += Math.sin(angle) * burstStrength * 2 * dt;
        }

        // Apply velocity decay for natural deceleration
        particle.vx *= (1 - config.particleMotion.decay * 0.1);
        particle.vy *= (1 - config.particleMotion.decay * 0.1);
    },
    
    cleanup(particle) {
        if (particle.gestureData?.flash) {
            particle.opacity = particle.gestureData.flash.originalOpacity;
            particle.size = particle.gestureData.flash.originalSize;
            delete particle.gestureData.flash;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Glow Gesture
 *  └─○═╝
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Glow gesture - based on pulse but focused on luminosity without movement
 * @author Emotive Engine Team
 * @module gestures/effects/glow
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Creates a pure luminous glow effect without particle movement.
 * ║ This is a BLENDING gesture that only modifies brightness/glow.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * VISUAL DIAGRAM:
 *      Dim            Bright           Dim
 *    · · · ·         ✨ ✨ ✨         · · · ·
 *    · · ⭐ · ·   →  ✨ 🌟 ✨    →   · · ⭐ · ·
 *    · · · ·         ✨ ✨ ✨         · · · ·
 *
 * USED BY:
 * - Emphasis effects
 * - Magic/mystical states
 * - Energy charging
 */

/**
 * Glow gesture configuration and implementation
 */
var glow = {
    name: 'glow',
    emoji: '✨',
    type: 'blending', // Adds to existing motion
    description: 'Pure luminous glow without movement',

    // Default configuration
    config: {
        duration: 1500,      // Animation duration (longer than pulse for sustained glow)
        amplitude: 0,        // NO expansion distance (removed from pulse)
        frequency: 1,        // Number of glow pulses
        holdPeak: 0.3,       // Peak glow hold time (longer for sustained effect)
        easing: 'sine',      // Animation curve type
        scaleAmount: 0.1,    // Very subtle orb scale variation (reduced from pulse)
        glowAmount: 0.8,     // Strong orb glow intensity change (increased from pulse)
        strength: 0,         // NO particle motion strength (removed from pulse)
        direction: 'none',   // No movement direction
        // Particle motion configuration for AnimationController
        particleMotion: {
            type: 'glow',
            strength: 0,     // No particle movement
            direction: 'none',
            frequency: 1
        }
    },

    // Rhythm configuration - glow pulses with musical phrases
    rhythm: {
        enabled: true,
        syncMode: 'phrase',  // Glow on musical phrases

        // Glow strength syncs to dynamics
        amplitudeSync: {
            onBeat: 2.0,      // Strong glow on beat
            offBeat: 1.2,     // Sustained glow off beat
            curve: 'smooth'   // Smooth transitions
        },

        // Frequency locks to phrase length
        frequencySync: {
            mode: 'phrase',
            subdivision: 'bar'
        },

        // Duration in musical time
        durationSync: {
            mode: 'bars',
            bars: 2           // Glow over 2 bars
        },

        // Stronger glow on accents
        accentResponse: {
            enabled: true,
            multiplier: 2.5   // Bright glow on accent
        },

        // Pattern-specific glow styles
        patternOverrides: {
            'ambient': {
                // Ethereal sustained glow
                amplitudeSync: { onBeat: 2.5, offBeat: 1.8 },
                durationSync: { bars: 4 }
            },
            'electronic': {
                // Pulsing neon glow
                amplitudeSync: { onBeat: 3.0, offBeat: 0.5, curve: 'sharp' },
                frequencySync: { subdivision: 'quarter' }
            }
        }
    },

    /**
     * Initialize gesture data for a particle
     * @param {Particle} particle - The particle to initialize
     * @param {Object} motion - Gesture motion configuration
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    initialize(particle, motion, centerX, centerY) {
        if (!particle.gestureData) {
            particle.gestureData = {};
        }

        // Store initial state (no position data needed for glow)
        particle.gestureData.glow = {
            startOpacity: particle.opacity,
            startGlow: particle.glowSizeMultiplier || 0,
            initialized: true
        };
    },

    /**
     * Apply glow effect to particle (no motion, just luminosity)
     * @param {Particle} particle - The particle to animate
     * @param {number} progress - Gesture progress (0-1)
     * @param {Object} motion - Gesture configuration
     * @param {number} dt - Delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize on first frame
        if (!particle.gestureData?.glow?.initialized) {
            this.initialize(particle, motion, centerX, centerY);
        }
        const config = { ...this.config, ...motion };

        // Apply easing
        const easeProgress = this.easeInOutSine(progress);

        // Calculate glow pulse with peak hold
        let glowValue;
        let {frequency} = config;
        let {glowAmount} = config;

        // Apply rhythm modulation if present
        if (motion.rhythmModulation) {
            glowAmount *= (motion.rhythmModulation.amplitudeMultiplier || 1);
            glowAmount *= (motion.rhythmModulation.accentMultiplier || 1);
            if (motion.rhythmModulation.frequencyMultiplier) {
                frequency *= motion.rhythmModulation.frequencyMultiplier;
            }
        }

        const rawPulse = (easeProgress * frequency * 2) % 2;

        if (config.holdPeak > 0 && rawPulse > (1 - config.holdPeak) && rawPulse < (1 + config.holdPeak)) {
            // Hold at peak glow
            glowValue = 1;
        } else {
            // Normal sine wave for glow
            glowValue = Math.sin(easeProgress * Math.PI * 2 * frequency);
        }

        // NO PARTICLE MOVEMENT - just glow effects
        // Unlike pulse, we don't calculate target positions or apply velocity

        // Apply glow fade effect at the end
        let glowMultiplier = 1;
        if (progress > 0.9) {
            const fadeFactor = 1 - ((progress - 0.9) * 10);
            glowMultiplier = (0.5 + fadeFactor * 0.5);
        }

        // Modify particle glow properties (if your system supports it)
        // This is where the actual glow effect happens
        // Note: The actual visual implementation depends on your renderer
        // Set glow intensity directly, don't multiply to prevent accumulation
        particle.glowIntensity = 1 + glowValue * glowAmount * glowMultiplier;
    },

    /**
     * Clean up gesture data when complete
     * @param {Particle} particle - The particle to clean up
     */
    cleanup(particle) {
        if (particle.gestureData?.glow) {
            // Reset any glow properties
            particle.glowIntensity = 1;
            delete particle.gestureData.glow;
        }
    },

    /**
     * Sine easing for smooth glow transitions
     * @param {number} t - Progress (0-1)
     * @returns {number} Eased value
     */
    easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Peek Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Quick peek/hide motion for suspicious checking behavior
 * @author Emotive Engine Team
 * @module gestures/effects/peek
 * 
 * GESTURE TYPE:
 * type: 'effect' - Visual effect without changing core position
 * 
 * VISUAL EFFECT:
 * Particles quickly expand outward (peeking) then contract back (hiding),
 * like peeking around a corner or quickly checking surroundings.
 */

var peek = {
    name: 'peek',
    emoji: '👀',
    type: 'effect',
    description: 'Quick peek and hide motion',
    
    // Default configuration
    config: {
        peekDistance: 40,       // How far to peek out
        peekSpeed: 0.15,        // Speed of peek motion
        holdDuration: 200,      // How long to hold peek position (ms)
        hideSpeed: 0.25,        // Speed of hiding (faster than peeking)
        stagger: true,          // Stagger particle peeks
        duration: 1500          // Total animation duration
    },
    
    // Rhythm configuration - quick glimpse movements synchronized to rhythmic accents
    rhythm: {
        enabled: true,
        syncMode: 'accent',  // Peek on rhythmic accents and syncopation
        
        // Peek distance responds to accent strength
        distanceSync: {
            onAccent: 60,         // Far peek on accents
            offAccent: 25,        // Short peek off-accent
            curve: 'quick'        // Sharp, sudden movement
        },
        
        // Speed adapts to musical tempo
        speedSync: {
            mode: 'tempo',
            fast: 0.25,           // Quick peeks for fast music
            slow: 0.10,           // Slower peeks for slow music
            hideMultiplier: 1.8   // Hide speed relative to peek speed
        },
        
        // Duration matches rhythmic subdivisions
        durationSync: {
            mode: 'subdivision',
            beats: 0.25,          // Quarter-beat peek duration
            staggerBeats: 0.125,  // Eighth-beat stagger delay
            sustain: false        // No sustain, quick action
        },
        
        // Strong response to syncopated rhythms
        syncopationResponse: {
            enabled: true,
            multiplier: 1.8,      // More dramatic peek on syncopation
            type: 'distance'      // Affects peek distance
        },
        
        // Style variations for different music types
        patternOverrides: {
            'funk': {
                // Sharp, syncopated peeks
                distanceSync: { onAccent: 70, offAccent: 35, curve: 'funky' },
                syncopationResponse: { multiplier: 2.2 }
            },
            'latin': {
                // Rhythmic, dance-like peeks
                speedSync: { fast: 0.30, slow: 0.12 },
                durationSync: { beats: 0.5, staggerBeats: 0.25 }
            },
            'breakbeat': {
                // Erratic, complex peek patterns
                distanceSync: { onAccent: 55, offAccent: 40 },
                syncopationResponse: { multiplier: 2.5 }
            },
            'classical': {
                // Subtle, expressive peeks
                distanceSync: { onAccent: 45, offAccent: 20, curve: 'elegant' },
                speedSync: { fast: 0.18, slow: 0.08 }
            }
        },
        
        // Musical dynamics
        dynamics: {
            forte: {
                // Bold, assertive peeks
                distanceSync: { 
                    onAccent: { multiplier: 1.6 },
                    offAccent: { multiplier: 1.3 }
                },
                speedSync: { multiplier: 1.4 },
                syncopationResponse: { multiplier: 2.8 }
            },
            piano: {
                // Cautious, subtle peeks
                distanceSync: { 
                    onAccent: { multiplier: 0.6 },
                    offAccent: { multiplier: 0.4 }
                },
                speedSync: { multiplier: 0.7 },
                syncopationResponse: { multiplier: 1.2 }
            }
        }
    },
    
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Initialize peek data if needed
        if (!particle.gestureData) {
            particle.gestureData = {};
        }
        
        if (!particle.gestureData.peek) {
            const dx = particle.x - centerX;
            const dy = particle.y - centerY;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            particle.gestureData.peek = {
                originalX: particle.x,
                originalY: particle.y,
                peekAngle: angle,
                originalDistance: distance,
                staggerDelay: this.config.stagger ? Math.random() * 0.3 : 0,
                phase: 'waiting',  // 'waiting', 'peeking', 'holding', 'hiding'
                phaseTimer: 0,
                peekOffset: { x: 0, y: 0 }
            };
        }
        
        const data = particle.gestureData.peek;
        const {config} = this;
        
        // Adjust progress for stagger
        const adjustedProgress = Math.max(0, Math.min(1, (progress - data.staggerDelay) / (1 - data.staggerDelay)));
        
        // Determine phase based on progress
        if (adjustedProgress === 0) {
            data.phase = 'waiting';
        } else if (adjustedProgress < 0.3) {
            data.phase = 'peeking';
        } else if (adjustedProgress < 0.6) {
            data.phase = 'holding';
        } else if (adjustedProgress < 1) {
            data.phase = 'hiding';
        }
        
        // Calculate peek offset based on phase
        let targetOffset = 0;
        
        switch (data.phase) {
        case 'peeking': {
            // Smooth peek out
            const peekProgress = adjustedProgress / 0.3;
            targetOffset = this.easeOutCubic(peekProgress) * config.peekDistance;
            break;
        }
                
        case 'holding':
            // Hold at peek position
            targetOffset = config.peekDistance;
            // Add slight tremor while holding
            if (Math.random() < 0.1) {
                data.peekOffset.x += (Math.random() - 0.5) * 2;
                data.peekOffset.y += (Math.random() - 0.5) * 2;
            }
            break;
                
        case 'hiding': {
            // Quick hide back
            const hideProgress = (adjustedProgress - 0.6) / 0.4;
            targetOffset = (1 - this.easeInCubic(hideProgress)) * config.peekDistance;
            break;
        }
        }
        
        // Apply the peek offset
        if (data.phase !== 'waiting') {
            const peekX = Math.cos(data.peekAngle) * targetOffset;
            const peekY = Math.sin(data.peekAngle) * targetOffset;
            
            // Smooth transition to target position
            data.peekOffset.x += (peekX - data.peekOffset.x) * config.peekSpeed;
            data.peekOffset.y += (peekY - data.peekOffset.y) * config.peekSpeed;
            
            // Apply offset to particle
            particle.x = data.originalX + data.peekOffset.x;
            particle.y = data.originalY + data.peekOffset.y;
        }
        
        // Add opacity effect - slightly fade during peek
        if (particle.alpha !== undefined) {
            if (data.phase === 'peeking' || data.phase === 'holding') {
                particle.alpha = 0.7 + Math.random() * 0.3;  // Flickering visibility
            } else {
                particle.alpha = 1.0;
            }
        }
    },
    
    // Easing functions
    easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    },
    
    easeInCubic(t) {
        return t * t * t;
    },
    
    cleanup(particle) {
        if (particle.gestureData?.peek) {
            // Restore original position
            particle.x = particle.gestureData.peek.originalX;
            particle.y = particle.gestureData.peek.originalY;
            if (particle.alpha !== undefined) {
                particle.alpha = 1.0;
            }
            delete particle.gestureData.peek;
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Running Man Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Running Man gesture - hip-hop shuffle dance move
 * @author Emotive Engine Team
 * @module gestures/effects/runningman
 */

var runningman = {
    name: 'runningman',
    emoji: '🏃',
    type: 'effect',
    description: 'Hip-hop running man shuffle',
    
    // Default configuration
    config: {
        duration: 2000,        // Animation duration
        slideDistance: 30,     // Horizontal slide distance
        stepHeight: 15,        // Vertical step height
        speed: 1.2,            // Animation speed multiplier
        strength: 0.8,         // Overall effect intensity
        // Particle motion configuration
        particleMotion: {
            type: 'runningman',
            strength: 0.7
        }
    },
    
    // Rhythm configuration - synchronized to beat
    rhythm: {
        enabled: true,
        syncToBeat: true,      // Snap to beat grid
        beatMultiplier: 1,     // Steps per beat
        accentBeats: [1, 3]    // Emphasized steps
    },
    
    /**
     * Apply running man motion - handled by GestureAnimator
     * This is a placeholder for the gesture system
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Motion is handled by GestureAnimator.applyRunningMan()
        return false;
    },
    
    /**
     * Blend with existing motion
     */
    blend(particle, progress, motion) {
        // Allow blending with other gestures
        return false;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Charleston Gesture
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Charleston gesture - classic hip-hop shuffle with modern twist
 * @author Emotive Engine Team
 * @module gestures/effects/charleston
 */

var charleston = {
    name: 'charleston',
    emoji: '🕺',
    type: 'effect',
    description: 'Hip-hop Charleston shuffle with crisscross',
    
    // Default configuration
    config: {
        duration: 2500,        // Animation duration
        kickDistance: 35,      // Kick extension distance
        swivelRange: 40,       // Hip swivel range
        bounceHeight: 12,      // Vertical bounce
        strength: 0.9,         // Overall effect intensity
        // Particle motion configuration
        particleMotion: {
            type: 'charleston',
            strength: 0.8
        }
    },
    
    // Rhythm configuration - tight sync with beat
    rhythm: {
        enabled: true,
        syncToBeat: true,      // Lock to beat grid
        beatMultiplier: 2,     // Double-time feel
        accentBeats: [1, 2.5, 3, 4.5]  // Syncopated accents
    },
    
    /**
     * Apply charleston motion - handled by GestureAnimator
     * This is a placeholder for the gesture system
     */
    apply(particle, progress, motion, dt, centerX, centerY) {
        // Motion is handled by GestureAnimator.applyCharleston()
        return false;
    },
    
    /**
     * Blend with existing motion
     */
    blend(particle, progress, motion) {
        // Allow blending with other gestures
        return false;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE v4.0 - Gesture Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central registry for all gesture animations with plugin support
 * @author Emotive Engine Team
 * @version 4.0.0
 * @module gestures
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Control center for all gestures with full plugin adapter integration.             
 * ║ • Three gesture types: blending (motions), override (transforms), effects        
 * ║ • Core gestures loaded synchronously at startup                                   
 * ║ • Plugin gestures registered dynamically via adapter                              
 * ║ • Value-agnostic configurations for easy tuning                                   
 * ║                                                                                    
 * ║ TO ADD A PLUGIN GESTURE:                                                          
 * ║ Use pluginAdapter.registerPluginGesture() from your plugin                        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ PLACEHOLDER GESTURES FOR NEW ANIMATIONS
// └─────────────────────────────────────────────────────────────────────────────────────
// These are handled by GestureAnimator but need registry entries for rhythm system
const createPlaceholderGesture = (name, emoji = '✨') => ({
    name,
    emoji,
    type: 'blending', // Use blending type so they don't interfere
    description: `${name} animation`,
    config: {
        duration: 1000, // Legacy fallback only
        musicalDuration: { musical: true, beats: 2 } // Default: 2 beats
    },
    rhythm: {
        enabled: true,
        syncMode: 'beat',
        timingSync: 'nextBeat',
        durationSync: { mode: 'beats', beats: 2 }, // Musical duration
        interruptible: true,
        priority: 3,
        blendable: true,
        crossfadePoint: 'anyBeat',
        maxQueue: 3
    },
    apply: (particle, progress, params) => {
        // No-op - handled by GestureAnimator
        return false;
    },
    blend: (particle, progress, params) => {
        // No-op - handled by GestureAnimator
        return false;
    }
});

const sparkle = createPlaceholderGesture('sparkle', '✨');

// Shimmer gesture - makes particles shimmer with wave effect
const shimmer = {
    name: 'shimmer',
    emoji: '🌟',
    type: 'particle',  // Particle type to affect particle behavior
    description: 'Shimmer effect with sparkling particles',
    config: {
        duration: 2000,  // Legacy fallback
        musicalDuration: { musical: true, bars: 1 }, // 1 bar (4 beats)
        particleMotion: 'radiant'  // Use radiant behavior for shimmering effect
    },
    rhythm: {
        enabled: true,
        syncType: 'beat',
        durationSync: { mode: 'bars', bars: 1 }, // Musical: 1 bar
        intensity: 0.8
    },
    override: (particle, progress, params) => {
        // Shimmer makes particles sparkle with wave effect
        particle.shimmerEffect = true;
        particle.shimmerProgress = progress;
        return true;
    },
    blend: (particle, progress, params) => {
        // Blend with other gestures
        return false;
    }
};
const wiggle = createPlaceholderGesture('wiggle', '〰️');
const groove = createPlaceholderGesture('groove', '🎵');
const point = createPlaceholderGesture('point', '👉');
const lean = createPlaceholderGesture('lean', '↗️');
const reach = createPlaceholderGesture('reach', '🤚');
const headBob = createPlaceholderGesture('headBob', '🎧');

// Rain gesture - applies doppler effect to particles
const rain = {
    name: 'rain',
    emoji: '🌧️',
    type: 'particle',  // Particle type to affect particle behavior
    description: 'Rain effect with falling particles',
    config: {
        duration: 3000,  // Legacy fallback
        musicalDuration: { musical: true, bars: 2 }, // 2 bars (8 beats)
        particleMotion: 'falling'  // Use the falling particle behavior
    },
    rhythm: {
        enabled: true,
        syncType: 'off-beat',
        durationSync: { mode: 'bars', bars: 2 }, // Musical: 2 bars
        intensity: 0.8
    },
    apply: (particle, progress, params) => {
        // The doppler behavior is handled by the particle system
        // This just marks particles as being affected by rain
        particle.rainEffect = true;
        particle.rainProgress = progress;
        return true;
    },
    blend: (particle, progress, params) => {
        // Blend with other gestures
        return false;
    }
};

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ GESTURE COLLECTIONS
// └─────────────────────────────────────────────────────────────────────────────────────
const MOTION_GESTURES = [
    bounce,
    pulse,
    shake,
    nod,
    vibrate,
    orbit,
    twitch,
    sway,
    float,
    jitter,
    // New gestures
    sparkle,
    shimmer,
    wiggle,
    groove,
    point,
    lean,
    reach,
    headBob,
    rain
];

const TRANSFORM_GESTURES = [
    spin,
    jump,
    morph,
    stretch,
    tilt,
    orbital,
    hula,
    scan,
    twist
];

const EFFECT_GESTURES = [
    wave,
    drift,
    flicker,
    burst,
    directional,
    settle,
    fade,
    hold,
    breathe,
    expand,
    contract,
    flash,
    glow,
    peek,
    runningman,
    charleston
];

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ GESTURE REGISTRY - Fast lookup by name
// └─────────────────────────────────────────────────────────────────────────────────────
const GESTURE_REGISTRY = {};

// Build the registry from all gesture arrays - SYNCHRONOUSLY
[...MOTION_GESTURES, ...TRANSFORM_GESTURES, ...EFFECT_GESTURES].forEach(gesture => {
    GESTURE_REGISTRY[gesture.name] = gesture;
});

// ┌─────────────────────────────────────────────────────────────────────────────────────
// │ GESTURE TYPE MAPPING - Quick type lookup
// └─────────────────────────────────────────────────────────────────────────────────────
const GESTURE_TYPES = {
    blending: MOTION_GESTURES.map(g => g.name),
    override: TRANSFORM_GESTURES.map(g => g.name),
    effect: EFFECT_GESTURES.map(g => g.name)
};

/**
 * Get a gesture by name (checks both core and plugin gestures)
 * @param {string} name - Gesture name (e.g., 'bounce', 'spin')
 * @returns {Object|null} Gesture object or null if not found
 */
function getGesture$1(name) {
    // Check core gestures first
    if (GESTURE_REGISTRY[name]) {
        return GESTURE_REGISTRY[name];
    }
    
    // Check plugin gestures
    const pluginGesture = pluginAdapter.getPluginGesture(name);
    if (pluginGesture) {
        return pluginGesture;
    }
    
    return null;
}

/**
 * Check if a gesture is a blending type
 * @param {string} name - Gesture name
 * @returns {boolean} True if gesture blends with existing motion
 */
function isBlendingGesture(name) {
    const gesture = getGesture$1(name);
    return gesture ? gesture.type === 'blending' : false;
}

/**
 * Check if a gesture is an override type
 * @param {string} name - Gesture name
 * @returns {boolean} True if gesture overrides existing motion
 */
function isOverrideGesture(name) {
    const gesture = getGesture$1(name);
    return gesture ? gesture.type === 'override' : false;
}

/**
 * Apply a gesture to a particle
 * @param {Particle} particle - The particle to animate
 * @param {string} gestureName - Name of the gesture
 * @param {number} progress - Animation progress (0-1)
 * @param {Object} motion - Motion configuration
 * @param {number} dt - Delta time
 * @param {number} centerX - Orb center X
 * @param {number} centerY - Orb center Y
 * @returns {boolean} True if gesture was applied
 */
function applyGesture(particle, gestureName, progress, motion, dt, centerX, centerY) {
    const gesture = getGesture$1(gestureName);
    
    if (!gesture) {
        return false;
    }
    
    // Apply the gesture
    if (gesture.apply) {
        gesture.apply(particle, progress, motion, dt, centerX, centerY);
    }
    
    // Clean up if complete
    if (progress >= 1 && gesture.cleanup) {
        gesture.cleanup(particle);
    }
    
    return true;
}

/**
 * Get list of all available gestures (core and plugin)
 * @returns {Array} Array of gesture info objects
 */
function listGestures() {
    const allGestures = [];
    
    // Add core gestures
    Object.values(GESTURE_REGISTRY).forEach(gesture => {
        allGestures.push({
            name: gesture.name,
            emoji: gesture.emoji || '🎭',
            type: gesture.type,
            description: gesture.description || 'No description',
            source: 'core'
        });
    });
    
    // Add plugin gestures
    const pluginGestureNames = pluginAdapter.getAllPluginGestures();
    pluginGestureNames.forEach(name => {
        const gesture = pluginAdapter.getPluginGesture(name);
        allGestures.push({
            name: gesture.name,
            emoji: gesture.emoji || '🔌',
            type: gesture.type,
            description: gesture.description || 'Plugin gesture',
            source: 'plugin'
        });
    });
    
    return allGestures;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rhythm Core
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 * 
 * @fileoverview Core rhythm timing engine for musical synchronization
 * @author Emotive Engine Team
 * @module core/rhythm
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Central timing engine that provides musical time references to all subsystems.    
 * ║ Does NOT dictate what animations do - only provides timing information.           
 * ║ Each subsystem maintains its own rhythm configuration in its files.              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * ARCHITECTURE:
 * • Provides beat events and musical time references
 * • Supports multiple time signatures and tempo changes
 * • Enables audio synchronization from external sources
 * • Each gesture/emotion/behavior defines its own rhythm response
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  TIMING FLOW                                                                      │
 * │                                                                                   │
 * │  Audio Input ──┐                                                                 │
 * │                ↓                                                                  │
 * │  [Rhythm Engine] ← Internal Clock                                                │
 * │        ↓                                                                          │
 * │   Beat Events → Subsystems (each with own rhythm config)                        │
 * │                                                                                   │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */

class RhythmEngine {
    constructor() {
        // Core timing properties
        this.bpm = 120;                    // Default BPM (beats per minute)
        this.timeSignature = [4, 4];       // Default 4/4 time
        this.isPlaying = false;            // Whether rhythm is active
        
        // Musical time tracking
        this.startTime = 0;                // When rhythm started
        this.currentBeat = 0;              // Current beat number
        this.currentBar = 0;               // Current bar/measure number
        this.beatProgress = 0;             // Progress within current beat (0-1)
        this.barProgress = 0;              // Progress within current bar (0-1)
        
        // Timing calculations
        this.beatDuration = 60000 / this.bpm;  // Milliseconds per beat
        this.barDuration = this.beatDuration * this.timeSignature[0];
        this.lastBeatTime = 0;             // Timestamp of last beat
        this.nextBeatTime = 0;             // Timestamp of next beat
        
        // Event listeners
        this.listeners = new Map();        // Event type -> Set of callbacks
        this.beatCallbacks = new Set();    // Callbacks for every beat
        this.barCallbacks = new Set();     // Callbacks for every bar
        
        // Subdivisions for finer timing
        this.subdivisions = {
            sixteenth: 0,    // 16th note position
            eighth: 0,       // 8th note position
            triplet: 0,      // Triplet position
            swing: 0         // Swing timing offset
        };
        
        // Sync state
        this.audioSync = null;             // External audio sync source
        this.syncOffset = 0;               // Timing offset for sync
        this.autoSync = false;             // Auto-detect tempo from audio
        
        // Musical dynamics
        this.intensity = 1.0;              // Current musical intensity (0-1)
        this.groove = 0;                   // Groove/swing amount (0-1)
        this.humanize = 0.05;              // Timing humanization factor
        
        // Pattern tracking
        this.patterns = new Map();         // Named rhythm patterns
        this.currentPattern = null;        // Active rhythm pattern
        
        // Initialize default patterns
        this.initializePatterns();
    }
    
    /**
     * Initialize default rhythm patterns
     */
    initializePatterns() {
        // Basic patterns - these are just timing references
        // Actual animations define their own responses to these patterns
        
        // Common time signatures
        this.patterns.set('4/4', {
            name: '4/4',
            description: 'Common time - 4 beats per bar',
            timeSignature: [4, 4],
            groove: 0,
            accents: [1, 0.5, 0.7, 0.5]  // Beat emphasis pattern
        });
        
        this.patterns.set('straight', {
            name: 'straight',
            description: 'Straight, even timing',
            groove: 0,
            accents: [1, 0.5, 0.7, 0.5]  // Beat emphasis pattern
        });
        
        this.patterns.set('swing', {
            name: 'swing',
            description: 'Swing/shuffle timing',
            groove: 0.67,  // 2:1 swing ratio
            accents: [1, 0.3, 0.8, 0.3]
        });
        
        this.patterns.set('3/4', {
            name: '3/4',
            description: 'Waltz time - 3 beats per bar',
            timeSignature: [3, 4],
            accents: [1, 0.5, 0.5]
        });
        
        this.patterns.set('waltz', {
            name: 'waltz',
            description: '3/4 waltz timing',
            timeSignature: [3, 4],
            accents: [1, 0.5, 0.5]
        });
        
        this.patterns.set('6/8', {
            name: '6/8',
            description: 'Compound duple time',
            timeSignature: [6, 8],
            accents: [1, 0.3, 0.3, 0.7, 0.3, 0.3]
        });
        
        this.patterns.set('5/4', {
            name: '5/4',
            description: 'Complex meter - 5 beats per bar',
            timeSignature: [5, 4],
            accents: [1, 0.5, 0.6, 0.5, 0.7]
        });
        
        this.patterns.set('7/8', {
            name: '7/8',
            description: 'Irregular meter',
            timeSignature: [7, 8],
            accents: [1, 0.5, 0.5, 0.7, 0.5, 0.5, 0.6]
        });
        
        this.patterns.set('dubstep', {
            name: 'dubstep',
            description: 'Dubstep half-time feel',
            accents: [0.2, 0.2, 1, 0.2],  // Heavy on beat 3
            subdivisions: { wobble: true }
        });
        
        this.patterns.set('breakbeat', {
            name: 'breakbeat',
            description: 'Broken beat pattern',
            accents: [1, 0.2, 0.7, 0.9, 0.2, 0.8, 0.4, 0.2]
        });
    }
    
    /**
     * Start the rhythm engine
     */
    start() {
        if (this.isPlaying) return;

        this.isPlaying = true;
        this.isRunning = true; // Add explicit running flag
        this.startTime = performance.now();
        this.lastBeatTime = this.startTime;
        this.nextBeatTime = this.startTime + this.beatDuration;
        this.currentBeat = 0;
        this.currentBar = 0;

        // Emit start event
        this.emit('start', {
            bpm: this.bpm,
            timeSignature: this.timeSignature,
            pattern: this.currentPattern
        });

        // Start update loop
        this.update();
    }
    
    /**
     * Stop the rhythm engine
     */
    stop() {
        if (!this.isPlaying) return;
        
        this.isPlaying = false;
        this.emit('stop', {
            totalBeats: this.currentBeat,
            totalBars: this.currentBar
        });
    }
    
    /**
     * Main update loop
     */
    update() {
        if (!this.isPlaying) return;
        
        const now = performance.now();
        const elapsed = now - this.startTime;
        
        // Calculate musical time positions
        const beatsSinceStart = elapsed / this.beatDuration;
        const newBeat = Math.floor(beatsSinceStart);
        this.beatProgress = beatsSinceStart % 1;
        
        // Check for beat change
        if (newBeat > this.currentBeat) {
            this.onBeat(newBeat);
        }
        
        // Calculate bar position
        const newBar = Math.floor(newBeat / this.timeSignature[0]);
        if (newBar > this.currentBar) {
            this.onBar(newBar);
        }
        
        this.currentBeat = newBeat;
        this.currentBar = newBar;
        this.barProgress = (newBeat % this.timeSignature[0]) / this.timeSignature[0];
        
        // Calculate subdivisions
        this.updateSubdivisions();
        
        // Emit continuous update
        this.emit('update', this.getTimeInfo());
        
        // Continue loop only if still playing
        if (this.isPlaying) {
            requestAnimationFrame(() => this.update());
        }
    }
    
    /**
     * Handle beat event
     */
    onBeat(beatNumber) {
        const beatInBar = beatNumber % this.timeSignature[0];
        const accent = this.getAccent(beatInBar);
        
        // Add humanization
        const humanTiming = this.humanize * (Math.random() - 0.5) * this.beatDuration;
        
        const beatInfo = {
            beat: beatNumber,
            beatInBar,
            bar: this.currentBar,
            accent,
            intensity: this.intensity * accent,
            humanTiming,
            timestamp: performance.now()
        };
        
        // Emit beat event
        this.emit('beat', beatInfo);
        
        // Call beat callbacks
        this.beatCallbacks.forEach(callback => callback(beatInfo));
        
        // Update timing
        this.lastBeatTime = performance.now();
        this.nextBeatTime = this.lastBeatTime + this.beatDuration;
    }
    
    /**
     * Handle bar event
     */
    onBar(barNumber) {
        const barInfo = {
            bar: barNumber,
            timeSignature: this.timeSignature,
            pattern: this.currentPattern,
            timestamp: performance.now()
        };
        
        // Emit bar event
        this.emit('bar', barInfo);
        
        // Call bar callbacks
        this.barCallbacks.forEach(callback => callback(barInfo));
    }
    
    /**
     * Update subdivision timings
     */
    updateSubdivisions() {
        // Calculate subdivision positions within beat
        this.subdivisions.sixteenth = (this.beatProgress * 4) % 1;
        this.subdivisions.eighth = (this.beatProgress * 2) % 1;
        this.subdivisions.triplet = (this.beatProgress * 3) % 1;
        
        // Apply swing/groove
        if (this.groove > 0) {
            const swingRatio = 0.5 + this.groove * 0.17; // Max 67% swing
            if (this.subdivisions.eighth < 0.5) {
                this.subdivisions.swing = this.subdivisions.eighth / swingRatio;
            } else {
                this.subdivisions.swing = 0.5 + (this.subdivisions.eighth - 0.5) / (1 - swingRatio);
            }
        } else {
            this.subdivisions.swing = this.subdivisions.eighth;
        }
    }
    
    /**
     * Get accent level for beat position
     */
    getAccent(beatInBar) {
        if (this.currentPattern && this.patterns.has(this.currentPattern)) {
            const pattern = this.patterns.get(this.currentPattern);
            if (pattern.accents && pattern.accents[beatInBar] !== undefined) {
                return pattern.accents[beatInBar];
            }
        }
        
        // Default accent pattern (strong on 1, medium on 3 in 4/4)
        if (beatInBar === 0) return 1.0;
        if (beatInBar === 2 && this.timeSignature[0] === 4) return 0.7;
        return 0.5;
    }
    
    /**
     * Get current time information
     */
    getTimeInfo() {
        return {
            // Absolute time
            elapsed: performance.now() - this.startTime,
            
            // Musical time
            beat: this.currentBeat,
            bar: this.currentBar,
            beatInBar: this.currentBeat % this.timeSignature[0],
            
            // Progress values (0-1)
            beatProgress: this.beatProgress,
            barProgress: this.barProgress,
            
            // Subdivisions
            subdivisions: { ...this.subdivisions },
            
            // Timing info
            bpm: this.bpm,
            beatDuration: this.beatDuration,
            timeSignature: [...this.timeSignature],
            
            // Musical properties
            intensity: this.intensity,
            groove: this.groove,
            pattern: this.currentPattern,
            
            // Next beat timing
            nextBeatIn: this.nextBeatTime - performance.now(),
            
            // Accent for current beat
            accent: this.getAccent(this.currentBeat % this.timeSignature[0])
        };
    }
    
    /**
     * Set BPM (beats per minute)
     */
    setBPM(bpm) {
        this.bpm = Math.max(20, Math.min(360, bpm));
        this.beatDuration = 60000 / this.bpm;
        this.barDuration = this.beatDuration * this.timeSignature[0];
        
        this.emit('tempoChange', { bpm: this.bpm });
    }
    
    /**
     * Set time signature
     */
    setTimeSignature(numerator, denominator) {
        this.timeSignature = [numerator, denominator];
        this.barDuration = this.beatDuration * numerator;
        
        this.emit('timeSignatureChange', { 
            timeSignature: this.timeSignature 
        });
    }
    
    /**
     * Set rhythm pattern
     */
    setPattern(patternName) {
        if (!this.patterns.has(patternName)) {
            return;
        }
        
        const pattern = this.patterns.get(patternName);
        this.currentPattern = patternName;
        
        // Apply pattern settings
        if (pattern.timeSignature) {
            this.setTimeSignature(...pattern.timeSignature);
        }
        if (pattern.groove !== undefined) {
            this.groove = pattern.groove;
        }
        
        this.emit('patternChange', { pattern: patternName });
    }
    
    /**
     * Register for beat events
     */
    onBeatCallback(callback) {
        this.beatCallbacks.add(callback);
        return () => this.beatCallbacks.delete(callback);
    }
    
    /**
     * Register for bar events
     */
    onBarCallback(callback) {
        this.barCallbacks.add(callback);
        return () => this.barCallbacks.delete(callback);
    }
    
    /**
     * Emit event to listeners
     */
    emit(event, data) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).forEach(callback => callback(data));
        }
    }
    
    /**
     * Listen for events
     */
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event).add(callback);
        
        // Return unsubscribe function
        return () => {
            if (this.listeners.has(event)) {
                this.listeners.get(event).delete(callback);
            }
        };
    }
    
    /**
     * Sync to audio source (stub for future implementation)
     */
    syncToAudio(audioContext, audioSource) {
        this.audioSync = { context: audioContext, source: audioSource };
        // Future: Implement beat detection and tempo extraction
    }
    
    /**
     * Get rhythm adapter for subsystems
     * Returns timing info and utilities for rhythm-aware animations
     */
    getAdapter() {
        return {
            // Current time info
            getTimeInfo: () => this.getTimeInfo(),
            
            // Check if on beat (with tolerance)
            isOnBeat: (tolerance = 0.1) => {
                return this.beatProgress < tolerance || this.beatProgress > (1 - tolerance);
            },
            
            // Check if on specific subdivision
            isOnSubdivision: (subdivision, tolerance = 0.1) => {
                const value = this.subdivisions[subdivision] || 0;
                return value < tolerance || value > (1 - tolerance);
            },
            
            // Get interpolated value synced to beat
            getBeatSync: (min = 0, max = 1, curve = 'linear') => {
                let progress = this.beatProgress;
                
                // Apply curve
                switch(curve) {
                case 'ease':
                    progress = 0.5 - Math.cos(progress * Math.PI) / 2;
                    break;
                case 'bounce':
                    progress = Math.abs(Math.sin(progress * Math.PI));
                    break;
                case 'pulse':
                    progress = Math.pow(Math.sin(progress * Math.PI), 2);
                    break;
                }
                
                return min + (max - min) * progress;
            },
            
            // Get value with musical accent
            getAccentedValue: (baseValue, accentMultiplier = 2) => {
                const accent = this.getAccent(this.currentBeat % this.timeSignature[0]);
                return baseValue * (1 + (accent - 0.5) * accentMultiplier);
            },
            
            // Subscribe to beat events
            onBeat: callback => this.onBeatCallback(callback),
            onBar: callback => this.onBarCallback(callback),
            
            // Musical time utilities
            beatsToMs: beats => beats * this.beatDuration,
            msToBeats: ms => ms / this.beatDuration,
            
            // Current musical state
            isPlaying: () => this.isPlaying,
            getBPM: () => this.bpm,
            getPattern: () => this.currentPattern
        };
    }
}

// Create singleton instance
const rhythmEngine = new RhythmEngine();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Rhythm Integration Module
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 * 
 * @fileoverview Integration layer between rhythm engine and existing subsystems
 * @author Emotive Engine Team
 * @module core/rhythmIntegration
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║ CONCEPT                                                                           
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This module connects the rhythm engine to existing subsystems without modifying   
 * ║ their core behavior. It reads rhythm configurations from individual files and     
 * ║ applies timing modulations based on musical events.                              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 * 
 * INTEGRATION POINTS:
 * • Particle System - Emission timing, behavior modulation
 * • Gesture System - Animation sync, duration adjustment
 * • Emotion System - Intensity mapping, transition timing
 * • Renderer - Glow pulsing, visual effects sync
 * 
 * ┌──────────────────────────────────────────────────────────────────────────────────┐
 * │  MODULAR RHYTHM FLOW                                                             │
 * │                                                                                   │
 * │  gesture.js ──┐                                                                  │
 * │  emotion.js ──┼→ [Integration] ← [Rhythm Engine]                                │
 * │  behavior.js ─┘         ↓                                                        │
 * │                   Apply Timing                                                   │
 * │                                                                                   │
 * └──────────────────────────────────────────────────────────────────────────────────┘
 */


class RhythmIntegration {
    constructor() {
        this.enabled = false;
        this.adapter = null;
        this.subsystemConfigs = new Map();
        this.activeModulations = new Map();
    }
    
    /**
     * Initialize rhythm integration
     */
    initialize() {
        this.adapter = rhythmEngine.getAdapter();
        this.enabled = true;
        
        // Subscribe to rhythm events
        this.adapter.onBeat(this.handleBeat.bind(this));
        this.adapter.onBar(this.handleBar.bind(this));
        
    }
    
    /**
     * Update BPM from detected audio
     * @param {number} newBPM - Detected BPM from audio analysis
     */
    updateBPM(newBPM) {
        if (newBPM >= 60 && newBPM <= 220) {
            // Check if rhythm was manually stopped
            if (window.rhythmManuallyStoppedForCurrentAudio) {
                return; // Don't auto-update if manually stopped
            }

            // Auto-start rhythm engine if not running
            if (!rhythmEngine.isRunning) {

                // Auto-start the rhythm engine for gesture sync
                this.start(newBPM, 'straight');

                // Trigger the rhythm sync visualizer to show BPM
                if (window.rhythmSyncVisualizer && !window.rhythmSyncVisualizer.state.active) {
                    // Rhythm integration logging removed for production
                    window.rhythmSyncVisualizer.start();
                }

                return;
            }
            
            // If running, always update BPM regardless of whether it changed
            // This ensures new tracks get their correct BPM
            rhythmEngine.setBPM(newBPM);
            
            // BPM is now shown visually through the beat histogram bars
        }
    }
    
    /**
     * Register a subsystem's rhythm configuration
     * Called when loading gestures, emotions, behaviors, etc.
     */
    registerConfig(type, name, config) {
        if (!config.rhythm || !config.rhythm.enabled) return;
        
        const key = `${type}:${name}`;
        this.subsystemConfigs.set(key, {
            type,
            name,
            rhythmConfig: config.rhythm,
            originalConfig: config
        });
        
    }
    
    /**
     * Apply rhythm modulation to a gesture
     */
    applyGestureRhythm(gesture, particle, progress, dt) {
        if (!this.enabled || !gesture.rhythm?.enabled) return {};
        
        this.adapter.getTimeInfo();
        const rhythmConfig = gesture.rhythm;
        const modulation = {};
        
        // Apply amplitude sync
        if (rhythmConfig.amplitudeSync) {
            const sync = rhythmConfig.amplitudeSync;
            const beatSync = this.adapter.getBeatSync(
                sync.offBeat || 0.8,
                sync.onBeat || 1.5,
                sync.curve || 'linear'
            );
            modulation.amplitudeMultiplier = beatSync;
        }
        
        // Apply wobble sync
        if (rhythmConfig.wobbleSync) {
            const sync = rhythmConfig.wobbleSync;
            if (this.adapter.isOnSubdivision(sync.subdivision, 0.1)) {
                modulation.wobbleMultiplier = 1 + sync.intensity;
            } else {
                modulation.wobbleMultiplier = 1;
            }
        }
        
        // Apply accent response
        if (rhythmConfig.accentResponse?.enabled) {
            const accentedValue = this.adapter.getAccentedValue(
                1,
                rhythmConfig.accentResponse.multiplier || 1.5
            );
            modulation.accentMultiplier = accentedValue;
        }
        
        // Apply pattern overrides
        const currentPattern = this.adapter.getPattern();
        if (currentPattern && rhythmConfig.patternOverrides?.[currentPattern]) {
            Object.assign(modulation, rhythmConfig.patternOverrides[currentPattern]);
        }
        
        return modulation;
    }
    
    /**
     * Apply rhythm modulation to particle emission
     */
    applyParticleRhythm(emotionState, particleSystem) {
        if (!this.enabled || !emotionState.rhythm?.enabled) return {};
        
        const timeInfo = this.adapter.getTimeInfo();
        const rhythmConfig = emotionState.rhythm;
        const modulation = {};
        
        // Particle emission sync
        if (rhythmConfig.particleEmission) {
            const emission = rhythmConfig.particleEmission;
            
            if (emission.syncMode === 'beat' && this.adapter.isOnBeat(0.1)) {
                // Emit burst on beat
                modulation.emitBurst = emission.burstSize || 3;
            } else if (emission.offBeatRate !== undefined) {
                // Reduce emission between beats
                modulation.emissionRate = emission.offBeatRate;
            }
        }
        
        // Glow sync
        if (rhythmConfig.glowSync) {
            const glow = rhythmConfig.glowSync;
            const glowIntensity = this.adapter.getBeatSync(
                glow.intensityRange[0] || 1.0,
                glow.intensityRange[1] || 2.0,
                'pulse'
            );
            modulation.glowIntensity = glowIntensity;
        }
        
        // Breathing sync
        if (rhythmConfig.breathSync?.mode === 'bars') {
            const breath = rhythmConfig.breathSync;
            const barsElapsed = timeInfo.bar % breath.barsPerBreath;
            const breathProgress = barsElapsed / breath.barsPerBreath;
            modulation.breathPhase = breathProgress * Math.PI * 2;
        }
        
        return modulation;
    }
    
    /**
     * Apply rhythm to particle behavior
     */
    applyBehaviorRhythm(behavior, particle, dt) {
        if (!this.enabled || !behavior.rhythm?.enabled) return {};
        
        const timeInfo = this.adapter.getTimeInfo();
        const rhythmConfig = behavior.rhythm;
        const modulation = {};
        
        // Glitch timing for glitchy behavior
        if (rhythmConfig.glitchTiming) {
            const glitch = rhythmConfig.glitchTiming;
            const isOnSubdivision = this.adapter.isOnSubdivision(glitch.subdivision, 0.05);
            
            if (isOnSubdivision && Math.random() < glitch.probability) {
                const intensity = this.adapter.isOnBeat() 
                    ? glitch.intensityOnBeat 
                    : glitch.intensityOffBeat;
                modulation.triggerGlitch = true;
                modulation.glitchIntensity = intensity;
            }
        }
        
        // Orbital rhythm
        if (rhythmConfig.orbitRhythm) {
            const orbit = rhythmConfig.orbitRhythm;
            
            if (orbit.baseSpeed === 'tempo') {
                modulation.speedMultiplier = this.adapter.getBPM() / 120; // Normalize to 120 BPM
            }
            
            if (orbit.beatAcceleration && this.adapter.isOnBeat(0.1)) {
                modulation.speedBoost = orbit.beatAcceleration;
            }
            
            if (orbit.barReset && timeInfo.beatInBar === 0) {
                modulation.resetOrbit = true;
            }
        }
        
        // Stutter sync
        if (rhythmConfig.stutterSync) {
            const stutter = rhythmConfig.stutterSync;
            const pattern = this.adapter.getPattern();
            
            if (pattern && stutter.patterns?.[pattern]) {
                const patternConfig = stutter.patterns[pattern];
                
                if (patternConfig.freezeOnDrop && timeInfo.beatInBar === 2) {
                    modulation.freeze = true;
                    modulation.freezeDuration = patternConfig.dropDuration;
                } else if (patternConfig.randomFreeze && Math.random() < patternConfig.randomFreeze) {
                    modulation.freeze = true;
                    modulation.freezeDuration = patternConfig.duration;
                }
            }
        }
        
        return modulation;
    }
    
    /**
     * Handle beat event
     */
    handleBeat(beatInfo) {
        // Store beat info for subsystems to access
        this.lastBeatInfo = beatInfo;
        
        // Could trigger specific effects here if needed
        // But mainly subsystems will query rhythm state during their update
    }
    
    /**
     * Handle bar event
     */
    handleBar(barInfo) {
        // Store bar info for subsystems to access
        this.lastBarInfo = barInfo;
    }
    
    /**
     * Get duration adjusted for musical time
     */
    getMusicalDuration(rhythmConfig, originalDuration) {
        if (!this.enabled || !rhythmConfig?.durationSync) return originalDuration;
        
        const sync = rhythmConfig.durationSync;
        
        if (sync.mode === 'bars') {
            return this.adapter.beatsToMs(sync.bars * 4); // Assuming 4/4 time
        } else if (sync.mode === 'beats') {
            return this.adapter.beatsToMs(sync.beats);
        }
        
        return originalDuration;
    }
    
    /**
     * Check if rhythm is enabled globally
     */
    isEnabled() {
        return this.enabled && this.adapter.isPlaying();
    }
    
    /**
     * Start rhythm playback
     */
    start(bpm = 120, pattern = 'straight') {
        if (bpm) rhythmEngine.setBPM(bpm);
        if (pattern) rhythmEngine.setPattern(pattern);
        rhythmEngine.start();
        this.enabled = true;
    }
    
    /**
     * Stop rhythm playback
     */
    stop() {
        rhythmEngine.stop();
        this.enabled = false;
        // Unlock BPM when stopping
        this.bpmLocked = false;
        this.lockedBPM = null;
    }
    
    /**
     * Set rhythm pattern
     */
    setPattern(pattern) {
        rhythmEngine.setPattern(pattern);
    }
    
    /**
     * Set BPM
     */
    setBPM(bpm) {
        rhythmEngine.setBPM(bpm);
        // Update the locked BPM if manually changed
        if (this.bpmLocked) {
            this.lockedBPM = bpm;
            // BPM locking logging removed for production
        }
    }
    
    /**
     * Resample BPM - unlocks detection for one update
     */
    resampleBPM() {
        // BPM resampling logging removed for production
        this.bpmLocked = false;
        this.lockedBPM = null;
    }
    
    /**
     * Set time signature from detected pattern
     */
    setTimeSignature(signature) {
        this.timeSignature = signature;
        
        // Update UI if available
        const timeSigDisplay = document.getElementById('time-sig-display');
        if (timeSigDisplay) {
            timeSigDisplay.textContent = signature;
        }
        
        // Could update rhythm patterns based on time signature here
        // For example, switch to waltz pattern for 3/4
        if (signature === '3/4' && rhythmEngine.getPattern() !== 'waltz') ;
    }
    
    /**
     * Sync to external audio
     */
    syncToAudio(audioContext, audioSource) {
        rhythmEngine.syncToAudio(audioContext, audioSource);
    }
}

// Create singleton instance
const rhythmIntegration = new RhythmIntegration();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Gesture Motion Orchestrator
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Orchestrator for modular gesture system - replaces monolithic switch
 * @author Emotive Engine Team
 * @module gestures/GestureMotion
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This orchestrator manages gesture application using the modular gesture system.   
 * ║ It replaces the old 538-line switch statement with clean, modular lookups.        
 * ║ Drop-in replacement for the old applyGestureMotion function.                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * Apply gesture motion to a particle using the modular system
 * This is a drop-in replacement for the old applyGestureMotion function
 * 
 * @param {Particle} particle - The particle to animate
 * @param {number} dt - Delta time (normalized to 60fps)
 * @param {Object} motion - Gesture motion configuration
 * @param {number} progress - Gesture progress (0-1)
 * @param {number} centerX - Orb center X position
 * @param {number} centerY - Orb center Y position
 */
function applyGestureMotion(particle, dt, motion, progress, centerX, centerY) {
    // Validate inputs
    if (!motion || !motion.type || progress >= 1) {
        return;
    }
    
    // Initialize gesture data if needed
    if (!particle.gestureData) {
        particle.gestureData = {
            originalVx: particle.vx,
            originalVy: particle.vy,
            initialX: particle.x,
            initialY: particle.y,
            // For compatibility with gestures that expect these
            startAngle: Math.atan2(particle.y - centerY, particle.x - centerX),
            startRadius: Math.sqrt(Math.pow(particle.x - centerX, 2) + Math.pow(particle.y - centerY, 2))
        };
    }
    
    // Look up the gesture from registry
    const gesture = getGesture$1(motion.type);
    
    if (!gesture) {
        return;
    }
    
    // Apply rhythm modulation if enabled
    let rhythmModifiedMotion = motion;
    if (rhythmIntegration.isEnabled() && gesture.rhythm?.enabled) {
        const modulation = rhythmIntegration.applyGestureRhythm(gesture, particle, progress, dt);
        
        // Create modified motion with rhythm adjustments
        rhythmModifiedMotion = {
            ...motion,
            amplitude: (motion.amplitude || 1) * (modulation.amplitudeMultiplier || 1) * (modulation.accentMultiplier || 1),
            wobbleAmount: (motion.wobbleAmount || 0) * (modulation.wobbleMultiplier || 1),
            // Allow rhythm to affect other parameters as needed
            rhythmModulation: modulation
        };
    }
    
    // Apply the gesture using its modular implementation
    if (gesture.apply) {
        gesture.apply(particle, progress, rhythmModifiedMotion, dt, centerX, centerY);
    }
    
    // Handle cleanup when gesture completes
    if (progress >= 0.99 && gesture.cleanup) {
        gesture.cleanup(particle);
        // Reset gesture data for next gesture
        particle.gestureData = null;
    }
}

/**
 * Helper function to check if a gesture should override particle behavior
 * Used by Particle.js to determine update flow
 * 
 * @param {string} gestureType - The gesture type name
 * @returns {boolean} True if gesture completely overrides particle motion
 */
function isGestureOverriding(gestureType) {
    return isOverrideGesture(gestureType);
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Modular Particle System with 3D Depth
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Orchestrator for the modular particle system with z-coordinate depth
 * @author Emotive Engine Team
 * @module core/Particle-modular
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                               MODULAR ARCHITECTURE                                
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ This is a drop-in replacement for the original Particle.js                        
 * ║ Same API, but with modular architecture for easier maintenance                    
 * ║                                                                                    
 * ║ STRUCTURE:                                                                         
 * ║ - Particle class (this file) - orchestrates everything                            
 * ║ - particles/behaviors/* - behavior modules                                     
 * ║ - particles/config/* - configuration constants                                    
 * ║ - particles/utils/* - utility functions                                           
 * ║ - gestures/* - modular gesture system                                             
 * ║                                                                                    
 * ║ 3D DEPTH SYSTEM:                                                                   
 * ║ - Z-coordinate ranges from -1 (behind orb) to +1 (in front)                       
 * ║ - 1/13 particles spawn in foreground, 12/13 in background                         
 * ║ - Depth affects visual size (20% scaling based on z)                              
 * ║ - Foreground particles spawn with offset to prevent stacking                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * Particle class - Individual particle with behavior and rendering
 * 
 * LIFECYCLE:
 * 1. Created by ParticleSystem with position and behavior
 * 2. Initialized with behavior-specific properties
 * 3. Updated each frame (position, behavior, lifecycle)
 * 4. Rendered to canvas
 * 5. Removed when life reaches 0
 */
class Particle {
    /**
     * Creates a new particle with specific behavior and appearance
     * 
     * @param {number} x - Starting X position on canvas
     * @param {number} y - Starting Y position on canvas
     * @param {string} behavior - Behavior type (ambient, rising, falling, etc.)
     * @param {number} scaleFactor - Global scale multiplier (affects size/distance)
     * @param {number} particleSizeMultiplier - Additional size multiplier
     * @param {Array} emotionColors - Array of color options with weights
     */
    constructor(x, y, behavior = 'ambient', scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null) {
        // Position and movement (now with z-coordinate for depth)
        // 1/13 chance of being in front (z > 0), 12/13 chance of being behind (z < 0)
        const zRoll = Math.random();
        this.z = zRoll < (1/13) ? 0.5 + Math.random() * 0.5 : -1 + Math.random() * 0.9;
        
        // Add spawn offset to prevent stacking
        // Much larger offset for foreground particles to completely avoid visual stacking
        const spawnRadius = this.z > 0 ? (20 + Math.random() * 20) * scaleFactor : 3 * scaleFactor;
        const angle = Math.random() * Math.PI * 2;
        this.x = x + Math.cos(angle) * spawnRadius;
        this.y = y + Math.sin(angle) * spawnRadius;
        this.vx = 0;
        this.vy = 0;
        this.vz = 0; // For future 3D motion effects
        
        // Lifecycle
        this.life = 0.0; // Start at 0 for fade-in
        this.maxLife = 1.0;
        this.lifeDecay = 0.01; // Life lost per frame
        this.fadeInTime = 0.15; // 15% of life for fade-in
        this.fadeOutTime = 0.3; // Last 30% of life for fade-out
        this.isFadingOut = false; // Track if particle is in fade-out phase
        this.age = 0; // Track particle age for smooth fading
        
        // Visual properties - matching original Emotive scale
        this.scaleFactor = scaleFactor;
        this.particleSizeMultiplier = particleSizeMultiplier;
        this.size = (4 + Math.random() * 6) * scaleFactor * particleSizeMultiplier; // 4-10 pixels scaled
        this.baseSize = this.size;
        this.emotionColors = emotionColors; // Store emotion colors for use in behaviors
        this.color = '#ffffff';
        this.opacity = 1.0;
        
        // Glow properties - 1/3 of particles have glow with varying sizes
        this.hasGlow = Math.random() < 0.333;  // 1/3 chance of glow
        this.glowSizeMultiplier = this.hasGlow ? (1.33 + Math.random() * 0.33) : 0;  // 1.33x to 1.66x particle size
        
        // Cell shading - 1/3 of particles are cell shaded (cartoon style)
        this.isCellShaded = Math.random() < 0.333;  // 1/3 chance of cell shading
        
        // Make particles more ephemeral
        this.baseOpacity = 0.3 + Math.random() * 0.4;  // 30-70% max opacity for ethereal look
        
        // Color caching for performance
        this.cachedColors = new Map(); // Cache RGBA strings
        this.lastColor = null;
        this.lastOpacity = -1;
        
        // Behavior properties
        this.behavior = behavior;
        this.behaviorData = {}; // Behavior-specific data
        
        // Gesture properties for motion system
        this.gestureData = {
            initialX: x,
            initialY: y
        };
        
        // Initialize behavior-specific properties
        initializeBehavior(this, behavior);
    }

    /**
     * Updates particle position and behavior
     * @param {number} deltaTime - Time since last update in milliseconds
     * @param {number} centerX - Center X coordinate for behavior calculations
     * @param {number} centerY - Center Y coordinate for behavior calculations
     * @param {Object} undertoneModifier - Optional undertone modifications
     * @param {Object} gestureMotion - Optional gesture motion to apply
     * @param {number} gestureProgress - Progress of the gesture (0-1)
     */
    update(deltaTime, centerX, centerY, undertoneModifier = null, gestureMotion = null, gestureProgress = 0) {
        // Cap deltaTime to prevent huge jumps
        const cappedDeltaTime = Math.min(deltaTime, 50);
        // Normalize to 60 FPS equivalent for consistent physics
        const dt = cappedDeltaTime / 16.67; // 16.67ms = 60 FPS frame time
        
        // Universal law: Gestures override state behavior based on their motion type
        // Use the modular gesture system to determine gesture behavior
        const gestureIsOverriding = gestureMotion && gestureMotion.type && gestureProgress > 0 && 
            isGestureOverriding(gestureMotion.type);
        
        if (gestureIsOverriding) {
            // Gesture completely controls particle - skip normal behavior
            this.applyGestureMotion(gestureMotion, gestureProgress, dt, centerX, centerY);
        } else if (this.gestureBehavior === 'falling') {
            // Rain gesture is active - use falling behavior instead of normal behavior
            updateBehavior(this, 'falling', dt, centerX, centerY);
        } else if (this.gestureBehavior === 'radiant') {
            // Shimmer gesture is active - use radiant behavior for shimmering effect
            updateBehavior(this, 'radiant', dt, centerX, centerY);
        } else {
            // Normal behavior update
            updateBehavior(this, this.behavior, dt, centerX, centerY);
            
            // Don't apply undertone modifications to particle motion
            // Undertones only affect color saturation and core behaviors
            
            // Apply non-overriding gesture motion if present
            if (gestureMotion && gestureProgress > 0) {
                this.applyGestureMotion(gestureMotion, gestureProgress, dt, centerX, centerY);
            }
        }
        
        // Apply velocity to position (unless gesture is directly controlling position)
        if (!gestureIsOverriding) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
        }
        
        // HARD BOUNDARY CONSTRAINTS - particles NEVER leave canvas
        // Get actual canvas dimensions from the DOM
        const canvas = document.getElementById('card-mascot') ||
                      document.getElementById('cherokee-guide-mascot') ||
                      document.querySelector('canvas');
        const canvasWidth = canvas ? canvas.width : centerX * 2;
        const canvasHeight = canvas ? canvas.height : centerY * 2;
        const margin = 20;
        
        // Bounce off boundaries
        if (this.x - this.size < margin) {
            this.x = margin + this.size;
            this.vx = Math.abs(this.vx) * 0.5;
        } else if (this.x + this.size > canvasWidth - margin) {
            this.x = canvasWidth - margin - this.size;
            this.vx = -Math.abs(this.vx) * 0.5;
        }
        
        if (this.y - this.size < margin) {
            this.y = margin + this.size;
            this.vy = Math.abs(this.vy) * 0.5;
        } else if (this.y + this.size > canvasHeight - margin) {
            this.y = canvasHeight - margin - this.size;
            this.vy = -Math.abs(this.vy) * 0.5;
        }
        
        // Update age and life (EXACT COPY FROM ORIGINAL)
        this.age += this.lifeDecay * dt;
        
        // Smooth fade-in at birth
        if (this.age < this.fadeInTime) {
            this.life = this.age / this.fadeInTime;
        }
        // Full opacity in middle of life
        else if (this.age < (1.0 - this.fadeOutTime)) {
            this.life = 1.0;
        }
        // Smooth fade-out at death
        else {
            this.life = (1.0 - this.age) / this.fadeOutTime;
            this.isFadingOut = true;
            
            // Dynamic size reduction for popcorn during fade-out
            if (this.behavior === 'popcorn') {
                this.size = this.baseSize * (0.5 + 0.5 * this.life);
            }
        }
        
        this.life = Math.max(0, Math.min(1, this.life));
        
        // Update opacity with easing for extra smoothness
        this.opacity = this.easeInOutCubic(this.life);
        
        // Update size based on life for some behaviors
        if (this.behavior === 'burst' && this.behaviorData && this.life < this.behaviorData.fadeStart) {
            this.size = this.baseSize * (this.life / this.behaviorData.fadeStart);
        }
    }


    /**
     * DEPRECATED - Undertones no longer affect particle motion
     * Kept for compatibility but does nothing
     * @param {number} dt - Normalized delta time
     * @param {Object} modifier - Undertone modifier settings
     */
    applyUndertoneModifier(dt, modifier) {
        // Undertones no longer affect particles
        // They only affect color saturation and core behaviors
        
    }

    /**
     * Apply gesture motion to particle
     * @param {Object} motion - Gesture motion configuration
     * @param {number} progress - Gesture progress (0-1)
     * @param {number} dt - Normalized delta time
     * @param {number} centerX - Orb center X
     * @param {number} centerY - Orb center Y
     */
    applyGestureMotion(motion, progress, dt, centerX, centerY) {
        // Use the full gesture system from the original
        applyGestureMotion(this, dt, motion, progress, centerX, centerY);
    }

    /**
     * Check if particle is out of bounds
     * @param {number} width - Canvas width
     * @param {number} height - Canvas height
     * @returns {boolean} True if particle is out of bounds
     */
    isOutOfBounds(width, height) {
        const margin = 50; // Allow some margin for particles to re-enter
        return this.x < -margin || this.x > width + margin || 
               this.y < -margin || this.y > height + margin;
    }

    /**
     * Check if particle is still alive
     * @returns {boolean} True if particle life > 0
     */
    isAlive() {
        return this.life > 0;
    }

    /**
     * Set outward velocity for gesture effects
     * @param {number} angle - Direction angle in radians
     */
    setOutwardVelocity(angle) {
        if (this.behaviorData && this.behaviorData.outwardSpeed !== undefined) {
            const speed = this.behaviorData.outwardSpeed;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed + (this.behaviorData.upwardBias || 0);
        }
    }

    /**
     * Get depth-adjusted size for 3D effect
     * Particles farther away (negative z) appear smaller for depth perception
     * 
     * @returns {number} Adjusted size based on z-depth
     * 
     * DEPTH SCALING:
     * - z = -1.0: 80% size (farthest back)
     * - z =  0.0: 100% size (orb plane)
     * - z = +1.0: 120% size (closest to viewer)
     */
    getDepthAdjustedSize() {
        // Map z from [-1, 1] to scale [0.8, 1.2]
        // Negative z (behind) = smaller, positive z (front) = larger
        const depthScale = 1 + (this.z * 0.2);
        return this.size * depthScale;
    }
    
    /**
     * Get particle state for debugging
     * @returns {Object} Current particle state
     */
    getState() {
        return {
            position: { x: this.x, y: this.y, z: this.z },
            velocity: { x: this.vx, y: this.vy, z: this.vz },
            life: this.life,
            behavior: this.behavior,
            size: this.size,
            opacity: this.opacity
        };
    }


    /**
     * Reset particle for reuse from pool
     * @param {number} x - New X position
     * @param {number} y - New Y position
     * @param {string} behavior - New behavior type
     * @param {number} scaleFactor - Scale factor
     * @param {number} particleSizeMultiplier - Size multiplier
     * @param {Array} emotionColors - Emotion colors
     */
    reset(x, y, behavior = 'ambient', scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null) {
        // 1/13 chance of being in front (z > 0), 12/13 chance of being behind (z < 0)
        const zRoll = Math.random();
        this.z = zRoll < (1/13) ? 0.5 + Math.random() * 0.5 : -1 + Math.random() * 0.9;
        
        // Add spawn offset to prevent stacking
        // Much larger offset for foreground particles to completely avoid visual stacking
        const spawnRadius = this.z > 0 ? (20 + Math.random() * 20) * scaleFactor : 3 * scaleFactor;
        const angle = Math.random() * Math.PI * 2;
        this.x = x + Math.cos(angle) * spawnRadius;
        this.y = y + Math.sin(angle) * spawnRadius;
        this.vx = 0;
        this.vy = 0;
        this.vz = 0;
        this.life = 0.0;  // Start at 0 for fade-in
        this.age = 0;  // Reset age
        this.scaleFactor = scaleFactor;
        this.particleSizeMultiplier = particleSizeMultiplier;
        this.size = (4 + Math.random() * 6) * scaleFactor * particleSizeMultiplier;  // Scaled size
        this.baseSize = this.size;
        this.emotionColors = emotionColors;  // Store emotion colors
        
        // Clear cached colors for reuse
        this.cachedColors.clear();
        this.opacity = 0.0;  // Start invisible
        this.isFadingOut = false;
        this.baseOpacity = 0.3 + Math.random() * 0.4;  // Reset base opacity
        this.color = '#ffffff';  // Reset color to white before reinitializing
        this.behavior = behavior;
        
        // Clear gesture data if it exists
        this.gestureData = null;
        
        // Reset behavior data
        if (!this.behaviorData) {
            this.behaviorData = {};
        } else {
            // Clear existing properties
            for (const key in this.behaviorData) {
                delete this.behaviorData[key];
            }
        }
        
        // Reinitialize behavior
        initializeBehavior(this, behavior);
    }

    /**
     * Get cached color string for performance
     * @param {string} hexColor - Hex color code
     * @param {number} opacity - Opacity value (0-1)
     * @returns {string} RGBA color string
     */
    getCachedColor(hexColor, opacity) {
        // Round opacity to reduce cache entries
        const roundedOpacity = Math.round(opacity * 100) / 100;
        const cacheKey = `${hexColor}_${roundedOpacity}`;
        
        if (!this.cachedColors.has(cacheKey)) {
            this.cachedColors.set(cacheKey, this.hexToRgba(hexColor, roundedOpacity));
        }
        
        return this.cachedColors.get(cacheKey);
    }

    /**
     * Convert hex color to RGBA string
     * @param {string} hex - Hex color code
     * @param {number} alpha - Alpha value (0-1)
     * @returns {string} RGBA color string
     */
    hexToRgba(hex, alpha) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!result) return `rgba(255, 255, 255, ${alpha})`;
        
        return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha})`;
    }

    /**
     * Cubic ease in/out function for smooth animations
     * @param {number} t - Progress value (0-1)
     * @returns {number} Eased value (0-1)
     */
    easeInOutCubic(t) {
        return t < 0.5 
            ? 4 * t * t * t 
            : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    /**
     * Render the particle to canvas
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {string} emotionColor - Color to use for rendering
     */
    render(ctx, emotionColor = '#ffffff') {
        if (this.life <= 0) return;
        
        // Validate position values to prevent rendering errors
        if (!isFinite(this.x) || !isFinite(this.y)) {
            return;
        }
        
        // Use sub-pixel accurate coordinates for smooth rendering
        const renderX = this.x;
        const renderY = this.y;
        
        // Ensure size is never negative
        const safeSize = Math.max(0.1, this.size);
        
        // Use the particle's own color if set, otherwise fall back to emotion color
        const particleColor = this.tempColor || this.color || emotionColor;
        
        ctx.save();
        
        if (this.isCellShaded) {
            // Cell shaded style - hard edges, no gradients
            
            // Draw outline (darker color)
            ctx.strokeStyle = this.getCachedColor(particleColor, this.opacity * 0.9);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(renderX, renderY, safeSize, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw flat color fill with discrete opacity levels
            const discreteOpacity = Math.floor(this.opacity * 3) / 3;
            ctx.fillStyle = this.getCachedColor(particleColor, discreteOpacity * (this.baseOpacity || 0.5) * 0.5);
            ctx.beginPath();
            ctx.arc(renderX, renderY, Math.max(0.1, safeSize - 1), 0, Math.PI * 2);
            ctx.fill();
            
            // Add hard-edged highlight
            if (discreteOpacity > 0.5) {
                ctx.fillStyle = this.getCachedColor('#FFFFFF', 0.3);
                ctx.beginPath();
                ctx.arc(renderX - safeSize * 0.3, renderY - safeSize * 0.3, safeSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        } else {
            // Standard gradient style
            
            // Create radial gradient for soft particle
            const gradient = ctx.createRadialGradient(renderX, renderY, 0, renderX, renderY, safeSize);
            
            // Core is full opacity with base opacity applied
            gradient.addColorStop(0, this.getCachedColor(particleColor, this.opacity * (this.baseOpacity || 0.5)));
            // Mid fade
            gradient.addColorStop(0.5, this.getCachedColor(particleColor, this.opacity * (this.baseOpacity || 0.5) * 0.5));
            // Edge is transparent
            gradient.addColorStop(1, this.getCachedColor(particleColor, 0));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(renderX, renderY, safeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Add glow effect if enabled
            if (this.hasGlow && this.glowSizeMultiplier > 0) {
                const glowSize = safeSize * this.glowSizeMultiplier;
                const glowGradient = ctx.createRadialGradient(renderX, renderY, safeSize * 0.5, renderX, renderY, glowSize);

                // Make glow visible even when particles are subdued
                // Use a minimum opacity for glow to ensure visibility
                const minGlowOpacity = 0.3; // Minimum glow visibility
                const particleOpacity = Math.max(minGlowOpacity, this.opacity);

                // Scale glow intensity based on glowSizeMultiplier
                // Higher multiplier = more intense glow (especially for gesture effects)
                const glowIntensity = Math.min(1.0, this.glowSizeMultiplier / 3); // More aggressive scaling

                // Create bright, visible glow with minimum opacity thresholds
                glowGradient.addColorStop(0, this.getCachedColor(particleColor, Math.max(0.5, particleOpacity * 0.8) * glowIntensity));
                glowGradient.addColorStop(0.25, this.getCachedColor(particleColor, Math.max(0.3, particleOpacity * 0.6) * glowIntensity));
                glowGradient.addColorStop(0.5, this.getCachedColor(particleColor, Math.max(0.2, particleOpacity * 0.4) * glowIntensity));
                glowGradient.addColorStop(0.75, this.getCachedColor(particleColor, Math.max(0.1, particleOpacity * 0.2) * glowIntensity));
                glowGradient.addColorStop(1, this.getCachedColor(particleColor, 0));

                // Use additive blending for brighter glow effect
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(renderX, renderY, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        ctx.restore();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  PARTICLE SYSTEM  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Particle System - Orchestrator of Emotional Atmosphere with 3D Depth
 * @author Emotive Engine Team
 * @version 2.4.0
 * @module ParticleSystem
 * @changelog 2.4.0 - Added z-coordinate depth system with split rendering layers
 * @changelog 2.3.0 - Batch rendering optimization for reduced state changes
 * @changelog 2.2.0 - Added undertone saturation system for dynamic particle depth
 * @changelog 2.1.0 - Added support for passing emotion colors to individual particles
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The CONDUCTOR of particle chaos. Manages the lifecycle, behavior, and             
 * ║ performance of all particles. Uses object pooling to prevent memory leaks         
 * ║ and coordinates particles to create emotional atmospheres around the orb.         
 * ║                                                                                    
 * ║ NEW: Undertone saturation dynamically adjusts particle colors based on emotional  
 * ║ intensity, creating visual depth through saturation levels.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 SYSTEM FEATURES                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Object pooling for performance (reuse dead particles)                           
 * │ • Time-based spawning with accumulator                                            
 * │ • Automatic cleanup every 5 seconds                                               
 * │ • Memory leak detection and prevention                                            
 * │ • Dynamic particle limits based on emotion                                        
 * │ • 13 different particle behaviors                                                 
 * │ • Undertone-based saturation adjustments for particle colors                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔄 OBJECT POOL STRATEGY                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Lazy initialization (create as needed)                                          
 * │ • Max pool size: 50 particles                                                     
 * │ • Reuse dead particles before creating new                                        
 * │ • Track pool hits/misses for optimization                                         
 * │ • Absolute max: 2x configured limit (prevents runaway)                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 PERFORMANCE LIMITS                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Default max particles  : 50                                                     
 * │ • Absolute max particles : 100 (2x default)                                       
 * │ • Pool size             : Min(maxParticles, 50)                                  
 * │ • Cleanup interval      : 5000ms                                                 
 * │ • Spawn rate            : Based on emotion config                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                              MEMORY MANAGEMENT                                    
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Critical for preventing memory leaks:                                             
 * ║ 1. Reuse particles from pool when available                                       
 * ║ 2. Clear references when returning to pool                                        
 * ║ 3. Periodic cleanup of excess particles                                           
 * ║ 4. Track creation/destruction for leak detection                                  
 * ║ 5. Hard limits prevent runaway particle creation                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class ParticleSystem {
    constructor(maxParticles = 50, errorBoundary = null) {
        this.errorBoundary = errorBoundary;
        this.maxParticles = maxParticles;
        this.absoluteMaxParticles = maxParticles * 2; // Hard limit to prevent leaks
        
        // Active particles
        this.particles = [];
        
        // Object pool for performance - reduced to prevent memory buildup
        this.pool = [];
        this.poolSize = Math.min(maxParticles, 50); // Limit pool to max 50 particles
        
        // Memory leak detection
        this.totalParticlesCreated = 0;
        this.totalParticlesDestroyed = 0;
        this.stateChangeCount = 0;
        this.lastMemoryCheck = Date.now();
        this.lastLeakedCount = 0;
        
        // TIME-BASED spawning using accumulation for smooth, consistent particle creation
        this.spawnAccumulator = 0; // Accumulates time to spawn particles
        
        // Performance tracking
        this.particleCount = 0;
        this.poolHits = 0;
        this.poolMisses = 0;
        
        // Cleanup timer to prevent memory buildup
        this.cleanupTimer = 0;
        this.cleanupInterval = 5000; // Clean up every 5 seconds
        
        // Initialize object pool
        this.initializePool();
        
        // ParticleSystem initialized
    }

    /**
     * Initialize the object pool with pre-created particles
     */
    initializePool() {
        // Don't pre-create particles - create them lazily as needed
        // This prevents memory buildup on initialization
        this.pool = [];
    }

    /**
     * Gets a particle from the pool or creates a new one
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} behavior - Particle behavior type
     * @returns {Particle} Particle instance
     */
    getParticleFromPool(x, y, behavior) {
        let particle;
        
        if (this.pool.length > 0) {
            // Reuse from pool
            particle = this.pool.pop();
            particle.reset(x, y, behavior, this.scaleFactor || 1, this.particleSizeMultiplier || 1, this.currentEmotionColors);
            this.poolHits++;
        } else {
            // Create new particle
            particle = new Particle(x, y, behavior, this.scaleFactor || 1, this.particleSizeMultiplier || 1, this.currentEmotionColors);
            this.poolMisses++;
            this.totalParticlesCreated++;
        }
        
        // Set the emotion for behavior customization
        particle.emotion = this.currentEmotion;
        
        // Apply gesture behavior if active (e.g., doppler for rain)
        if (this.gestureBehavior) {
            particle.gestureBehavior = this.gestureBehavior;
        }
        
        return particle;
    }

    /**
     * Returns a particle to the pool for reuse
     * @param {Particle} particle - Particle to return to pool
     */
    returnParticleToPool(particle) {
        if (this.pool.length < this.poolSize) {
            // Clear references before pooling
            particle.cachedGradient = null;
            particle.cachedGradientKey = null;
            // Clear behaviorData properties but keep the object
            if (particle.behaviorData) {
                for (const key in particle.behaviorData) {
                    delete particle.behaviorData[key];
                }
            }
            this.pool.push(particle);
        } else {
            // If pool is full, count as destroyed since it will be GC'd
            this.totalParticlesDestroyed++;
        }
    }

    /**
     * Spawns particles based on emotional state and particle rate
     * NEW APPROACH: Fixed timestep - only spawn at specific intervals
     * 
     * @param {string} behavior - Particle behavior type (ambient, rising, falling, etc.)
     * @param {string} emotion - Current emotional state
     * @param {number} particleRate - Rate of particle spawning (particles per second at 60fps)
     * @param {number} centerX - X coordinate of spawn center
     * @param {number} centerY - Y coordinate of spawn center
     * @param {number} deltaTime - Time since last frame in milliseconds
     * @param {number|null} count - Force spawn this many particles (null for rate-based)
     * @param {number} minParticles - Minimum particles to maintain
     * @param {number} maxParticles - Maximum particles allowed
     * @param {number} scaleFactor - Scale multiplier for particle sizes
     * @param {number} particleSizeMultiplier - Additional size multiplier
     * @param {Array|null} emotionColors - Array of color strings or weighted color objects
     * @param {string|null} undertone - Emotional undertone for saturation adjustment
     *                                   (intense, confident, nervous, clear, tired, subdued)
     *                                   Affects particle color saturation to create depth
     */
    spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count = null, minParticles = 0, maxParticles = 10, scaleFactor = 1, particleSizeMultiplier = 1, emotionColors = null, undertone = null) {
        this.scaleFactor = scaleFactor; // Store for particle creation
        this.particleSizeMultiplier = particleSizeMultiplier; // Store for particle sizing
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles, maxParticles, emotionColors, undertone);
            }, 'particle-spawn')();
        } else {
            this._spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles, maxParticles, emotionColors, undertone);
        }
    }
    
    /**
     * Resets the spawn accumulator (for tab switches)
     */
    resetAccumulator() {
        this.spawnAccumulator = 0;
    }

    /**
     * Internal spawn implementation - TIME-BASED accumulation for smooth spawning
     * 
     * Applies undertone saturation adjustments to particle colors before spawning.
     * The saturation system creates visual depth:
     * - Intense/Confident: Oversaturated colors appear to pop forward
     * - Clear: Normal midtone colors sit in the middle ground  
     * - Tired/Subdued: Desaturated colors recede into background
     * 
     * This creates a natural transition as particles cycle through their lifecycle,
     * with new particles spawning with current undertone saturation while existing
     * particles maintain their original colors until expiration.
     */
    _spawn(behavior, emotion, particleRate, centerX, centerY, deltaTime, count, minParticles = 0, maxParticles = 10, emotionColors = null, undertone = null) {
        // Store emotion for particle initialization
        this.currentEmotion = emotion;
        
        // Debug logging removed for production
        
        // Store base colors and undertone separately to ensure consistent application
        this.baseEmotionColors = emotionColors;
        this.currentUndertone = undertone;
        
        // Apply undertone saturation to emotion colors for all particles
        // This adjustment persists for the lifetime of each particle, creating
        // smooth visual transitions as particles naturally cycle
        this.currentEmotionColors = emotionColors && undertone ? 
            applyUndertoneSaturationToArray(emotionColors, undertone) : 
            emotionColors;
        
        // Apply rhythm modulation if enabled
        let rhythmModulatedRate = particleRate;
        if (rhythmIntegration.isEnabled()) {
            const emotionConfig = emotionCache && emotionCache.isInitialized ? 
                emotionCache.getEmotion(emotion) : getEmotion(emotion);
            if (emotionConfig) {
                const modulation = rhythmIntegration.applyParticleRhythm(emotionConfig, this);
                
                // Apply emission burst on beat
                if (modulation.emitBurst) {
                    for (let i = 0; i < modulation.emitBurst && this.particles.length < maxParticles; i++) {
                        this.spawnSingleParticle(behavior, centerX, centerY);
                    }
                }
                
                // Modulate emission rate
                if (modulation.emissionRate !== undefined) {
                    rhythmModulatedRate *= modulation.emissionRate;
                }
            }
        }
        
        
        // If specific count is provided, spawn that many
        if (count !== null) {
            for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                this.spawnSingleParticle(behavior, centerX, centerY);
            }
            return;
        }
        
        // Skip spawning if frame rate is too low (performance optimization)
        if (this.skipSpawnThisFrame) {
            return;
        }
        
        // Always maintain minimum particles
        while (this.particles.length < minParticles && this.particles.length < this.maxParticles) {
            this.spawnSingleParticle(behavior, centerX, centerY);
        }
        
        // If we're at or above max for this emotion, don't spawn more
        if (this.particles.length >= maxParticles) {
            return;
        }
        
        // Don't spawn if rate is 0
        if (rhythmModulatedRate <= 0) return;
        
        // TIME-BASED SPAWNING using accumulation
        // rhythmModulatedRate represents desired particles at 60 FPS
        // So rate of 1 = 1 particle per 60 frames = 1 particle per second at 60fps
        // Cap deltaTime to prevent huge accumulation spikes
        const cappedDeltaTime = Math.min(deltaTime, 50);
        const particlesPerSecond = rhythmModulatedRate; // Direct mapping: rate = particles/second
        const particlesPerMs = particlesPerSecond / 1000;
        
        // Accumulate spawn time with capped delta
        this.spawnAccumulator += particlesPerMs * cappedDeltaTime;
        
        // Cap accumulator to prevent excessive spawning after long pauses
        this.spawnAccumulator = Math.min(this.spawnAccumulator, 3.0);
        
        // Spawn accumulated particles smoothly
        while (this.spawnAccumulator >= 1.0 && this.particles.length < maxParticles) {
            this.spawnSingleParticle(behavior, centerX, centerY);
            this.spawnAccumulator -= 1.0;
        }
    }

    /**
     * Spawns a single particle with the specified behavior
     * @param {string} behavior - Particle behavior type
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    spawnSingleParticle(behavior, centerX, centerY) {
        // Hard limit check to prevent memory leaks
        if (this.particles.length >= this.absoluteMaxParticles) {
            return;
        }
        
        // Calculate spawn position based on behavior
        const spawnPos = this.getSpawnPosition(behavior, centerX, centerY);
        
        // CLAMP spawn position to canvas boundaries
        const clampedPos = this.clampToCanvas(spawnPos.x, spawnPos.y, centerX, centerY);
        spawnPos.x = clampedPos.x;
        spawnPos.y = clampedPos.y;
        
        // Get particle from pool
        const particle = this.getParticleFromPool(spawnPos.x, spawnPos.y, behavior);
        
        // Pass additional data for meditation_swirl
        if (behavior === 'meditation_swirl' && spawnPos.palmCenter) {
            particle.palmCenter = spawnPos.palmCenter;
            particle.swirlAngle = spawnPos.swirlAngle;
        }
        
        // Add to active particles
        this.particles.push(particle);
        this.particleCount++;
        
        // Debug logging disabled to prevent console spam
        // Only uncomment for debugging particle spawning issues
        // if (this.particleCount <= 3) {
        // }
    }

    /**
     * Calculates spawn position based on behavior type
     * @param {string} behavior - Particle behavior type
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     * @returns {Object} Spawn position {x, y}
     */
    getSpawnPosition(behavior, centerX, centerY) {
        // Calculate orb radius based on canvas size (matching EmotiveRenderer)
        const canvasSize = Math.min(centerX * 2, centerY * 2);
        const orbRadius = canvasSize / 12;  // Core radius
        const glowRadius = orbRadius * 2.5; // Glow extends this far
        
        // CONSTRAIN spawn positions to stay within canvas boundaries
        const margin = 30; // Keep spawns away from edges
        
        // Spawn particles outside the glow radius so they're visible
        const minSpawnRadius = glowRadius * 1.1; // 10% beyond glow edge
        const maxSpawnRadius = Math.min(glowRadius * 1.5, 
            centerX - margin, centerY - margin); // Constrain to canvas
        
        switch (behavior) {
        case 'ambient':
        case 'resting': {
            // Spawn at edge of glow where particles become visible
            // They'll move outward to create "emanating from center" effect
            const ambientAngle = Math.random() * Math.PI * 2;
            const ambientRadius = glowRadius * 0.9; // Just at glow edge
            return {
                x: centerX + Math.cos(ambientAngle) * ambientRadius,
                y: centerY + Math.sin(ambientAngle) * ambientRadius,
                angle: ambientAngle  // Pass angle for outward velocity
            };
        }
                
        case 'rising':
        case 'falling': {
            // These can spawn from outside for visibility
            const angle = Math.random() * Math.PI * 2;
            const radius = minSpawnRadius + Math.random() * (maxSpawnRadius - minSpawnRadius);
            return {
                x: centerX + Math.cos(angle) * radius,
                y: centerY + Math.sin(angle) * radius
            };
        }
                
        case 'aggressive': {
            // Spawn just outside the glow for aggressive burst effect
            const aggressiveAngle = Math.random() * Math.PI * 2;
            const aggressiveRadius = glowRadius + Math.random() * orbRadius;
            return {
                x: centerX + Math.cos(aggressiveAngle) * aggressiveRadius,
                y: centerY + Math.sin(aggressiveAngle) * aggressiveRadius
            };
        }
                
        case 'scattering':
            // Spawn at center for outward movement (scattering needs this)
            return { x: centerX, y: centerY };
                
        case 'burst': {
            // Spawn at edge of orb so particles are visible
            const burstAngle = Math.random() * Math.PI * 2;
            if (this.currentEmotion === 'suspicion') {
                const burstRadius = orbRadius * 1.5; // Further outside for suspicion
                return {
                    x: centerX + Math.cos(burstAngle) * burstRadius,
                    y: centerY + Math.sin(burstAngle) * burstRadius
                };
            } else if (this.currentEmotion === 'surprise') {
                // Surprise spawns around the orb edge for visibility
                const burstRadius = orbRadius * 1.2; // Just outside the orb
                return {
                    x: centerX + Math.cos(burstAngle) * burstRadius,
                    y: centerY + Math.sin(burstAngle) * burstRadius
                };
            } else {
                // Other emotions spawn at center
                return { x: centerX, y: centerY };
            }
        }
                
        case 'repelling': {
            // Spawn at edge of glow so particles are visible
            const repelAngle = Math.random() * Math.PI * 2;
            const repelRadius = glowRadius * 0.9; // Just at glow edge
            return {
                x: centerX + Math.cos(repelAngle) * repelRadius,
                y: centerY + Math.sin(repelAngle) * repelRadius
            };
        }
                
        case 'orbiting': {
            // Spawn at orbital distance outside the glow
            const orbitAngle = Math.random() * Math.PI * 2;
            const orbitRadius = glowRadius * 1.2 + Math.random() * glowRadius * 0.5;
            return {
                x: centerX + Math.cos(orbitAngle) * orbitRadius,
                y: centerY + Math.sin(orbitAngle) * orbitRadius
            };
        }
                
        case 'glitchy': {
            // Spawn glitch particles at various distances from center for wide spread
            const glitchAngle = Math.random() * Math.PI * 2;
            const glitchRadius = glowRadius * 3 + Math.random() * glowRadius * 4; // Much wider spread (3-7x glow radius)
            return {
                x: centerX + Math.cos(glitchAngle) * glitchRadius,
                y: centerY + Math.sin(glitchAngle) * glitchRadius
            };
        }
                
        case 'spaz': {
            // Spawn spaz particles in a wide ring around the center for explosive effect
            const spazAngle = Math.random() * Math.PI * 2;
            const spazRadius = glowRadius * 2 + Math.random() * glowRadius * 3; // Very wide spread (2-5x glow radius)
            return {
                x: centerX + Math.cos(spazAngle) * spazRadius,
                y: centerY + Math.sin(spazAngle) * spazRadius
            };
        }
                
        default:
            return { x: centerX, y: centerY };
        }
    }
    
    /**
     * Clamps a position to stay within canvas boundaries
     */
    clampToCanvas(x, y, centerX, centerY, margin = 30) {
        const canvasWidth = centerX * 2;
        const canvasHeight = centerY * 2;
        return {
            x: Math.max(margin, Math.min(canvasWidth - margin, x)),
            y: Math.max(margin, Math.min(canvasHeight - margin, y))
        };
    }

    /**
     * Updates all particles and manages lifecycle
     * @param {number} deltaTime - Time since last update in milliseconds
     * @param {number} centerX - Center X coordinate for behavior calculations
     * @param {number} centerY - Center Y coordinate for behavior calculations
     * @param {Object} gestureMotion - Optional gesture motion to apply
     * @param {number} gestureProgress - Progress of gesture (0-1)
     * @param {Object} undertoneModifier - Optional undertone modifications
     */
    update(deltaTime, centerX, centerY, gestureMotion = null, gestureProgress = 0, undertoneModifier = null) {
        if (this.errorBoundary) {
            const wrappedUpdate = this.errorBoundary.wrap(
                (dt, cx, cy, gm, gp, um) => this._update(dt, cx, cy, gm, gp, um), 
                'particle-update'
            );
            return wrappedUpdate(deltaTime, centerX, centerY, gestureMotion, gestureProgress, undertoneModifier);
        } else {
            this._update(deltaTime, centerX, centerY, gestureMotion, gestureProgress, undertoneModifier);
        }
    }

    /**
     * Internal update implementation
     */
    _update(deltaTime, centerX, centerY, gestureMotion = null, gestureProgress = 0, undertoneModifier = null) {
        // PERFORMANCE OPTIMIZATION: Skip cleanup for small particle counts
        // 50 particles don't need periodic cleanup overhead
        // Cleanup is unnecessary for such small numbers
        
        // PERFORMANCE OPTIMIZATION: Skip memory leak detection for small particle counts
        // 50 particles don't need memory tracking overhead
        // Memory leaks aren't a concern with such small numbers
        
        // PERFORMANCE OPTIMIZATION: Use simple filter instead of complex loop
        // More efficient for small particle counts
        this.particles = this.particles.filter(particle => {
            particle.update(deltaTime, centerX, centerY, undertoneModifier, gestureMotion, gestureProgress);
            return particle.isAlive();
        });
        
        // Enforce particle limit by removing oldest if necessary
        while (this.particles.length > this.maxParticles) {
            this.removeParticle(0); // Remove oldest (first in array)
        }
    }

    /**
     * Set a temporary gesture behavior for particles
     * @param {string} behaviorName - Name of the behavior (e.g., 'doppler')
     * @param {boolean} active - Whether the behavior is active
     */
    setGestureBehavior(behaviorName, active) {
        this.gestureBehavior = active ? behaviorName : null;
        
        // Apply gesture behavior to existing particles
        if (active) {
            this.particles.forEach(particle => {
                particle.gestureBehavior = behaviorName;
            });
        } else {
            // Clear gesture behavior from particles
            this.particles.forEach(particle => {
                particle.gestureBehavior = null;
            });
        }
    }

    /**
     * Removes a particle at the specified index
     * @param {number} index - Index of particle to remove
     */
    removeParticle(index) {
        if (index >= 0 && index < this.particles.length) {
            const particle = this.particles.splice(index, 1)[0];
            // Clear any cached data before returning to pool
            particle.cachedGradient = null;
            particle.cachedGradientKey = null;
            // Don't set behaviorData to null - let reset handle it properly
            this.returnParticleToPool(particle);
            this.particleCount = Math.max(0, this.particleCount - 1);
        }
    }

    /**
     * Renders all particles to the canvas context
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * @param {Object} gestureTransform - Optional gesture transform data
     */
    render(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._render(ctx, emotionColor, gestureTransform);
            }, 'particle-render')();
        } else {
            this._render(ctx, emotionColor, gestureTransform);
        }
    }
    
    /**
     * Renders particles in the background layer (behind orb)
     * Particles with z < 0 are rendered, appearing smaller based on depth
     * 
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * 
     * LAYER DISTRIBUTION:
     * - ~92% of particles render in background (z < 0)
     * - Particles scale from 80% to 100% size based on z-depth
     */
    renderBackground(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._renderLayer(ctx, emotionColor, false, gestureTransform); // false = background (z < 0)
            }, 'particle-render-bg')();
        } else {
            this._renderLayer(ctx, emotionColor, false, gestureTransform);
        }
    }
    
    /**
     * Renders particles in the foreground layer (in front of orb)
     * Particles with z >= 0 are rendered, appearing larger based on depth
     * 
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * 
     * LAYER DISTRIBUTION:
     * - ~8% of particles render in foreground (z >= 0) 
     * - Particles scale from 100% to 120% size based on z-depth
     * - Spawn with offset to prevent visual stacking
     */
    renderForeground(ctx, emotionColor = '#ffffff', gestureTransform = null) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._renderLayer(ctx, emotionColor, true, gestureTransform); // true = foreground (z >= 0)
            }, 'particle-render-fg')();
        } else {
            this._renderLayer(ctx, emotionColor, true, gestureTransform);
        }
    }

    /**
     * Internal render implementation for a specific layer
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {string} emotionColor - Color to use for particle rendering
     * @param {boolean} isForeground - true for foreground (z >= 0), false for background (z < 0)
     */
    _renderLayer(ctx, emotionColor, isForeground, gestureTransform = null) {
        // Sort particles by rendering properties to minimize state changes
        const visibleParticles = [];
        
        // First pass: cull off-screen, dead, and wrong-layer particles
        const margin = 50;
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        
        for (const particle of this.particles) {
            // Filter by z-layer
            const particleInForeground = particle.z >= 0;
            if (particleInForeground !== isForeground) {
                continue; // Skip particles in wrong layer
            }
            
            // Skip off-screen particles (culling)
            if (particle.x < -margin || particle.x > canvasWidth + margin ||
                particle.y < -margin || particle.y > canvasHeight + margin) {
                continue;
            }
            
            // Skip dead particles
            if (particle.life <= 0) continue;
            
            visibleParticles.push(particle);
        }
        
        // Sort by render type to minimize state changes
        visibleParticles.sort((a, b) => {
            if (a.isCellShaded !== b.isCellShaded) {
                return a.isCellShaded ? -1 : 1;
            }
            if (a.hasGlow !== b.hasGlow) {
                return a.hasGlow ? -1 : 1;
            }
            return 0;
        });
        
        // Actually render the particles
        this._renderParticles(ctx, visibleParticles, emotionColor, gestureTransform);
    }
    
    /**
     * Internal render implementation - batch optimized rendering (legacy, renders all)
     */
    _render(ctx, emotionColor, gestureTransform = null) {
        // Sort particles by rendering properties to minimize state changes
        const visibleParticles = [];
        
        // PERFORMANCE OPTIMIZATION: Skip off-screen culling for small particle counts
        // Canvas2D handles off-screen rendering efficiently
        // Culling overhead is unnecessary for 50 particles
        
        for (const particle of this.particles) {
            // Skip dead particles only
            if (particle.life <= 0) continue;
            
            visibleParticles.push(particle);
        }
        
        // PERFORMANCE OPTIMIZATION: Skip sorting for 50 particles
        // Sorting is expensive and unnecessary for small particle counts
        // Canvas2D handles rendering efficiently without sorting
        
        // Actually render the particles
        this._renderParticles(ctx, visibleParticles, emotionColor, gestureTransform);
    }
    
    /**
     * Render a list of particles with batch optimization
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {Array} visibleParticles - Array of particles to render
     * @param {string} emotionColor - Color to use for particle rendering
     * @param {Object} gestureTransform - Optional gesture transform data
     */
    _renderParticles(ctx, visibleParticles, emotionColor, gestureTransform = null) {
        // Batch render with minimized state changes
        ctx.save();
        let lastFillStyle = null;

        for (const particle of visibleParticles) {
            // For cell-shaded, use original render (they need complex stroke/fill combos)
            if (particle.isCellShaded) {
                particle.render(ctx, emotionColor);
                // Reset cached values since particle.render may have changed them
                lastFillStyle = null;
            } else {
                // Batch-optimized rendering for regular particles
                const particleColor = particle.color || emotionColor;
                
                // Only set fillStyle if it changed
                if (particleColor !== lastFillStyle) {
                    ctx.fillStyle = particleColor;
                    lastFillStyle = particleColor;
                }
                
                // Validate position once
                if (!isFinite(particle.x) || !isFinite(particle.y)) continue;
                
                // Use depth-adjusted size if particle has the method
                const depthSize = particle.getDepthAdjustedSize ? particle.getDepthAdjustedSize() : particle.size;
                let safeSize = Math.max(0.1, depthSize);
                
                // Apply firefly effect if sparkle gesture is active
                let fireflyGlow = 1.0;
                if (gestureTransform && gestureTransform.fireflyEffect) {
                    // Each particle gets unique phase for async firefly blinking
                    const particlePhase = (particle.x * 0.01 + particle.y * 0.01 + particle.size * 0.1) % (Math.PI * 2);
                    const time = gestureTransform.fireflyTime || (Date.now() * 0.001);
                    const intensity = gestureTransform.particleGlow || 2.0;
                    
                    // Create firefly pulse pattern
                    fireflyGlow = 0.3 + Math.max(0, Math.sin(time * 3 + particlePhase)) * intensity;
                }
                
                // Apply flicker effect if flicker gesture is active (now does particle shimmer)
                if (gestureTransform && gestureTransform.flickerEffect) {
                    // Each particle shimmers with a wave pattern
                    const particlePhase = (particle.x * 0.02 + particle.y * 0.02) % (Math.PI * 2);
                    const time = gestureTransform.flickerTime || (Date.now() * 0.001);
                    const intensity = gestureTransform.particleGlow || 2.0;
                    
                    // Create shimmer wave pattern - faster oscillation
                    fireflyGlow = 0.5 + Math.sin(time * 12 + particlePhase) * intensity * 0.5;
                }
                
                // Apply shimmer effect if shimmer gesture is active (subtle glow)
                if (gestureTransform && gestureTransform.shimmerEffect) {
                    // Each particle gets a subtle brightness variation based on distance from center
                    const dx = particle.x - (ctx.canvas.width / 2);
                    const dy = particle.y - (ctx.canvas.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const normalizedDistance = distance / 200; // Normalize to reasonable range
                    
                    const time = gestureTransform.shimmerTime || (Date.now() * 0.001);
                    const wave = gestureTransform.shimmerWave || 0;
                    const intensity = gestureTransform.particleGlow || 1.2;
                    
                    // Subtle traveling wave from center outward
                    const travelingWave = Math.sin(time * 3 - normalizedDistance + wave);
                    
                    // Very subtle glow modulation
                    fireflyGlow = 1 + travelingWave * 0.15 * intensity;
                }
                
                // Apply glow effect if glow gesture is active (radiant burst)
                if (gestureTransform && gestureTransform.glowEffect) {
                    const progress = gestureTransform.glowProgress || 0;
                    const intensity = gestureTransform.particleGlow || 2.0;

                    // Particles brighten based on distance - closer particles glow first
                    const dx = particle.x - (ctx.canvas.width / 2);
                    const dy = particle.y - (ctx.canvas.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const normalizedDistance = distance / 300;

                    // Glow radiates outward
                    const radiateDelay = Math.min(normalizedDistance * 0.3, 0.5);
                    const localProgress = Math.max(0, (progress - radiateDelay) / (1 - radiateDelay));
                    const localEnvelope = Math.sin(localProgress * Math.PI);

                    // ACTUALLY MAKE PARTICLES GLOW by temporarily setting glow properties
                    // Store original values if not already stored
                    if (!particle._originalGlow) {
                        particle._originalGlow = {
                            hasGlow: particle.hasGlow,
                            glowSizeMultiplier: particle.glowSizeMultiplier || 0
                        };
                    }

                    // Enable glow and set a large multiplier for visibility
                    particle.hasGlow = true;
                    particle.glowSizeMultiplier = Math.max(3.0, particle._originalGlow.glowSizeMultiplier) + localEnvelope * intensity * 3;

                    // Also boost particle size slightly
                    const glowSizeBoost = 1 + localEnvelope * 0.3;
                    safeSize = safeSize * glowSizeBoost;

                    // Cleanup flag - restore original values when effect ends
                    if (progress >= 0.99 && particle._originalGlow) {
                        particle.hasGlow = particle._originalGlow.hasGlow;
                        particle.glowSizeMultiplier = particle._originalGlow.glowSizeMultiplier;
                        delete particle._originalGlow;
                    }
                }
                
                // Draw glow layers if needed
                if (particle.hasGlow || fireflyGlow > 1.0) {
                    const glowRadius = Math.max(0.1, safeSize * (particle.glowSizeMultiplier || 1.5) * fireflyGlow);

                    // Use 'screen' composite mode to prevent glow accumulation
                    const originalCompositeOp = ctx.globalCompositeOperation;
                    ctx.globalCompositeOperation = 'screen';

                    // Outer glow (enhanced by firefly effect)
                    ctx.globalAlpha = particle.opacity * 0.15 * fireflyGlow;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner glow (enhanced by firefly effect)
                    ctx.globalAlpha = particle.opacity * 0.25 * fireflyGlow;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, glowRadius * 0.6, 0, Math.PI * 2);
                    ctx.fill();

                    // Restore original composite mode
                    ctx.globalCompositeOperation = originalCompositeOp;
                }
                
                // Draw core (also brightened by firefly effect)
                ctx.globalAlpha = particle.opacity * (particle.baseOpacity || 0.5) * 0.6 * Math.min(2.0, fireflyGlow);
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, safeSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }

    /**
     * Clears all particles and returns them to the pool
     */
    clear() {
        this.stateChangeCount++;
        
        // Return all particles to pool but avoid duplicates
        while (this.particles.length > 0) {
            const particle = this.particles.pop();
            // Clear cached data before returning
            if (particle.cachedColors) {
                particle.cachedColors.clear();
            }
            // Clear behaviorData properties but keep the object
            if (particle.behaviorData) {
                for (const key in particle.behaviorData) {
                    delete particle.behaviorData[key];
                }
            }
            // Only add to pool if it's not already there and pool has space
            if (this.pool.length < this.poolSize && !this.pool.includes(particle)) {
                this.pool.push(particle);
            }
        }
        
        this.particles.length = 0;
        this.particleCount = 0;
        this.spawnAccumulator = 0; // Reset accumulator when clearing
        
        // Trim pool if it's grown too large
        if (this.pool.length > this.poolSize) {
            // Actually remove excess particles from pool
            const excess = this.pool.length - this.poolSize;
            this.pool.splice(this.poolSize, excess);
        }
        
    }

    /**
     * Triggers a burst of particles for gesture effects
     * @param {number} count - Number of particles to burst
     * @param {string} behavior - Behavior type for burst particles
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate
     */
    burst(count, behavior, centerX, centerY) {
        if (this.errorBoundary) {
            return this.errorBoundary.wrap(() => {
                this._burst(count, behavior, centerX, centerY);
            }, 'particle-burst')();
        } else {
            this._burst(count, behavior, centerX, centerY);
        }
    }

    /**
     * Internal burst implementation
     */
    _burst(count, behavior, centerX, centerY) {
        const actualCount = Math.min(count, this.maxParticles - this.particles.length);
        
        for (let i = 0; i < actualCount; i++) {
            this.spawnSingleParticle(behavior, centerX, centerY);
        }
    }

    /**
     * Performs periodic cleanup to prevent memory buildup
     */
    performCleanup() {
        // Trim pool if it's grown too large
        if (this.pool.length > this.poolSize) {
            // Clear excess particles from pool
            const excess = this.pool.length - this.poolSize;
            for (let i = 0; i < excess; i++) {
                const particle = this.pool.pop();
                // Ensure all references are cleared
                if (particle) {
                    particle.cachedGradient = null;
                    particle.cachedGradientKey = null;
                    particle.behaviorData = null;
                }
            }
        }
        
        // Clear any cached data from active particles
        for (const particle of this.particles) {
            if (particle.cachedGradient && particle.life < 0.5) {
                // Clear gradient cache for fading particles
                particle.cachedGradient = null;
                particle.cachedGradientKey = null;
            }
        }
    }
    
    /**
     * Gets current particle system statistics
     * @returns {Object} Performance and state information
     */
    getStats() {
        return {
            activeParticles: this.particles.length,
            maxParticles: this.maxParticles,
            poolSize: this.pool.length,
            poolHits: this.poolHits,
            poolMisses: this.poolMisses,
            poolEfficiency: this.poolHits / Math.max(1, this.poolHits + this.poolMisses),
            spawnAccumulator: this.spawnAccumulator
        };
    }

    /**
     * Sets the maximum number of particles
     * @param {number} maxParticles - New maximum particle count
     */
    setMaxParticles(maxParticles) {
        this.originalMaxParticles = this.originalMaxParticles || this.maxParticles;
        this.maxParticles = Math.max(1, maxParticles);
        
        // Remove excess particles if new limit is lower
        while (this.particles.length > this.maxParticles) {
            this.removeParticle(0);
        }
    }
    
    /**
     * Cleans up dead particles and optimizes the pool
     */
    cleanupDeadParticles() {
        // Remove any dead particles that shouldn't be there
        const beforeCount = this.particles.length;
        this.particles = this.particles.filter(particle => particle.isAlive());
        const removed = beforeCount - this.particles.length;
        
        // Clear excess items from the pool to free memory
        if (this.pool.length > 20) {
            this.pool.length = 20;
        }
        
        return removed;
    }

    /**
     * Gets particles by behavior type for debugging
     * @param {string} behavior - Behavior type to filter by
     * @returns {Array} Particles with matching behavior
     */
    getParticlesByBehavior(behavior) {
        return this.particles.filter(particle => particle.behavior === behavior);
    }

    /**
     * Validates that all particles are in valid state
     * @returns {boolean} True if all particles are valid
     */
    validateParticles() {
        for (const particle of this.particles) {
            if (!particle.isAlive() || particle.life < 0 || particle.life > 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * Forces cleanup of dead particles (for testing)
     */
    cleanup() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            if (!this.particles[i].isAlive()) {
                this.removeParticle(i);
            }
        }
    }

    /**
     * Refreshes the particle pool by discarding all pooled particles
     * Used when scale changes to ensure new particles use updated scale factor
     */
    refreshPool() {
        // Clear the entire pool - forces creation of new particles with updated scale
        this.pool.length = 0;
        this.poolHits = 0;
        this.poolMisses = 0;

        // Also kill all active particles so they'll be replaced with properly scaled ones
        for (const particle of this.particles) {
            particle.life = 0; // Mark as dead - they'll be filtered out on next update
        }
    }

    /**
     * Destroys the particle system and cleans up resources
     */
    destroy() {
        this.clear();
        this.pool.length = 0;
        this.poolHits = 0;
        this.poolMisses = 0;
        // ParticleSystem destroyed
    }
}

var ParticleSystem$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: ParticleSystem
});

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Gesture Cache
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview High-performance gesture caching system
 * @author Emotive Engine Team
 * @module cache/GestureCache
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Pre-caches all gesture definitions, properties, and common combinations for       
 * ║ maximum performance. Reduces gesture lookup time by 50-75% and composition       
 * ║ time by 60-80%.                                                                  
 * ║                                                                                    
 * ║ CACHES:                                                                           
 * ║ • Gesture definitions (26+ gestures)                                              
 * ║ • Gesture properties (metadata, timing, easing)                                  
 * ║ • Common gesture combinations                                                     
 * ║ • Plugin gesture data                                                            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class GestureCache {
    constructor() {
        this.gestureCache = new Map();
        this.propertyCache = new Map();
        this.compositionCache = new Map();
        this.pluginCache = new Map();
        this.stats = { 
            hits: 0, 
            misses: 0, 
            loadTime: 0, 
            cacheSize: 0,
            gestureHits: 0,
            propertyHits: 0,
            compositionHits: 0
        };
        this.isInitialized = false;
        this.loadStartTime = 0;
        this.initialize();
    }

    /**
     * Initialize the gesture cache
     */
    initialize() {
        this.loadStartTime = performance.now();
        
        try {
            // Pre-cache all core gestures
            this.cacheCoreGestures();
            
            // Pre-cache gesture properties
            this.cacheGestureProperties();
            
            // Pre-cache common gesture combinations
            this.cacheCommonCombinations();
            
            // Pre-cache plugin gestures
            this.cachePluginGestures();
            
            this.stats.loadTime = performance.now() - this.loadStartTime;
            this.stats.cacheSize = this.gestureCache.size + this.propertyCache.size + this.compositionCache.size;
            this.isInitialized = true;
            
            console.warn(`🎭 GestureCache initialized: ${this.stats.cacheSize} items in ${this.stats.loadTime.toFixed(2)}ms`);
        } catch (error) {
            console.error('GestureCache initialization failed:', error);
            this.isInitialized = false;
        }
    }

    /**
     * Cache all core gestures from the registry
     */
    cacheCoreGestures() {
        Object.values(GESTURE_REGISTRY).forEach(gesture => {
            if (gesture && gesture.name) {
                this.gestureCache.set(gesture.name, {
                    ...gesture,
                    cached: true,
                    cacheTime: performance.now()
                });
            }
        });
    }

    /**
     * Cache gesture properties for fast access
     */
    cacheGestureProperties() {
        this.gestureCache.forEach((gesture, name) => {
            const properties = {
                type: gesture.type,
                emoji: gesture.emoji,
                description: gesture.description,
                config: gesture.config,
                rhythm: gesture.rhythm,
                duration: this.calculateGestureDuration(gesture),
                easing: this.extractEasingFunction(gesture),
                physics: this.extractPhysicsProperties(gesture),
                timing: this.extractTimingProperties(gesture)
            };
            
            this.propertyCache.set(name, properties);
        });
    }

    /**
     * Cache common gesture combinations
     */
    cacheCommonCombinations() {
        const commonPairs = [
            ['bounce', 'pulse'],
            ['shake', 'vibrate'],
            ['orbit', 'spin'],
            ['morph', 'glow'],
            ['breathe', 'fade'],
            ['wave', 'drift'],
            ['nod', 'sway'],
            ['jump', 'stretch']
        ];

        commonPairs.forEach(([gesture1, gesture2]) => {
            const key = `${gesture1}+${gesture2}`;
            const combination = this.calculateGestureCombination(gesture1, gesture2);
            if (combination) {
                this.compositionCache.set(key, combination);
            }
        });
    }

    /**
     * Cache plugin gestures
     */
    cachePluginGestures() {
        try {
            // Get all plugin gestures
            const pluginGestures = pluginAdapter.getAllPluginGestures();
            if (pluginGestures) {
                Object.entries(pluginGestures).forEach(([name, gesture]) => {
                    this.pluginCache.set(name, {
                        ...gesture,
                        cached: true,
                        cacheTime: performance.now(),
                        isPlugin: true
                    });
                });
            }
        } catch (error) {
            console.warn('Could not cache plugin gestures:', error);
        }
    }

    /**
     * Get a cached gesture
     */
    getGesture(name) {
        // Check core gesture cache first
        if (this.gestureCache.has(name)) {
            this.stats.hits++;
            this.stats.gestureHits++;
            return this.gestureCache.get(name);
        }

        // Check plugin cache
        if (this.pluginCache.has(name)) {
            this.stats.hits++;
            this.stats.gestureHits++;
            return this.pluginCache.get(name);
        }

        this.stats.misses++;
        return null;
    }

    /**
     * Get cached gesture properties
     */
    getGestureProperties(name) {
        if (this.propertyCache.has(name)) {
            this.stats.hits++;
            this.stats.propertyHits++;
            return this.propertyCache.get(name);
        }

        this.stats.misses++;
        return null;
    }

    /**
     * Get cached gesture combination
     */
    getGestureCombination(gesture1, gesture2) {
        const key = `${gesture1}+${gesture2}`;
        if (this.compositionCache.has(key)) {
            this.stats.hits++;
            this.stats.compositionHits++;
            return this.compositionCache.get(key);
        }

        this.stats.misses++;
        return null;
    }

    /**
     * Calculate gesture duration from config
     */
    calculateGestureDuration(gesture) {
        if (!gesture.config) return 1000; // Default 1 second

        const { musicalDuration, duration } = gesture.config;
        
        if (musicalDuration && musicalDuration.musical) {
            // Convert beats to milliseconds (assuming 120 BPM)
            const beats = musicalDuration.beats || 2;
            return (beats * 500); // 500ms per beat at 120 BPM
        }
        
        return duration || 1000;
    }

    /**
     * Extract easing function from gesture
     */
    extractEasingFunction(gesture) {
        if (!gesture.config) return 'sine';
        
        const { easing, particleMotion } = gesture.config;
        return easing || particleMotion?.easing || 'sine';
    }

    /**
     * Extract physics properties from gesture
     */
    extractPhysicsProperties(gesture) {
        if (!gesture.config) return {};

        const { amplitude, strength, size, rotation } = gesture.config;
        return {
            amplitude: amplitude || 20,
            strength: strength || 1.0,
            size: size || 80,
            rotation: rotation || 0
        };
    }

    /**
     * Extract timing properties from gesture
     */
    extractTimingProperties(gesture) {
        if (!gesture.config) return {};

        const { phases, timingSync } = gesture.config;
        return {
            phases: phases || [],
            timingSync: timingSync || {},
            hasPhases: !!(phases && phases.length > 0),
            hasTimingSync: !!(timingSync && Object.keys(timingSync).length > 0)
        };
    }

    /**
     * Calculate gesture combination properties
     */
    calculateGestureCombination(gesture1, gesture2) {
        const g1 = this.getGesture(gesture1);
        const g2 = this.getGesture(gesture2);
        
        if (!g1 || !g2) return null;

        return {
            gestures: [gesture1, gesture2],
            combinedDuration: Math.max(
                this.calculateGestureDuration(g1),
                this.calculateGestureDuration(g2)
            ),
            combinedType: g1.type === g2.type ? g1.type : 'mixed',
            combinedEasing: this.extractEasingFunction(g1),
            combinedPhysics: this.combinePhysicsProperties(g1, g2),
            compatibility: this.calculateCompatibility(g1, g2)
        };
    }

    /**
     * Combine physics properties from two gestures
     */
    combinePhysicsProperties(g1, g2) {
        const p1 = this.extractPhysicsProperties(g1);
        const p2 = this.extractPhysicsProperties(g2);
        
        return {
            amplitude: Math.max(p1.amplitude, p2.amplitude),
            strength: (p1.strength + p2.strength) / 2,
            size: Math.max(p1.size, p2.size),
            rotation: (p1.rotation + p2.rotation) / 2
        };
    }

    /**
     * Calculate compatibility between two gestures
     */
    calculateCompatibility(g1, g2) {
        if (g1.type === g2.type) return 'high';
        if (g1.type === 'blending' && g2.type === 'blending') return 'medium';
        if (g1.type === 'override' || g2.type === 'override') return 'low';
        return 'medium';
    }

    /**
     * Get cache statistics
     */
    getStats() {
        const hitRate = this.stats.hits + this.stats.misses > 0 ? 
            (this.stats.hits / (this.stats.hits + this.stats.misses) * 100).toFixed(1) : 0;
        
        return {
            ...this.stats,
            hitRate: `${hitRate}%`,
            isInitialized: this.isInitialized,
            cacheSize: this.stats.cacheSize,
            coreGestures: this.gestureCache.size,
            pluginGestures: this.pluginCache.size,
            properties: this.propertyCache.size,
            combinations: this.compositionCache.size
        };
    }

    /**
     * Clear the cache
     */
    clear() {
        this.gestureCache.clear();
        this.propertyCache.clear();
        this.compositionCache.clear();
        this.pluginCache.clear();
        this.stats = { 
            hits: 0, 
            misses: 0, 
            loadTime: 0, 
            cacheSize: 0,
            gestureHits: 0,
            propertyHits: 0,
            compositionHits: 0
        };
        this.isInitialized = false;
    }

    /**
     * Warm up the cache with specific gestures
     */
    warmUp(gestureNames) {
        gestureNames.forEach(name => {
            this.getGesture(name);
            this.getGestureProperties(name);
        });
    }
}

// Create and export singleton instance
const gestureCache = new GestureCache();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Gesture Cache Wrapper
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Wrapper to use gesture cache without circular dependencies
 * @author Emotive Engine Team
 * @module gestures/gestureCacheWrapper
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides cached gesture access without creating circular dependencies.             
 * ║ This wrapper can be safely imported by gesture consumers.                         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * Get a gesture with caching support
 * @param {string} name - Gesture name
 * @returns {Object|null} Gesture object or null if not found
 */
function getGesture(name) {
    // Use cached version if available
    if (gestureCache && gestureCache.isInitialized) {
        const cachedGesture = gestureCache.getGesture(name);
        if (cachedGesture) {
            return cachedGesture;
        }
    }
    
    // Fallback to original logic
    return getGesture$1(name);
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  UNDERTONE MODIFIERS  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Undertone Modifiers - Subtle Emotion Variations
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module UndertoneModifiers
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Undertones add NUANCE to emotions - like being "nervously happy" or              
 * ║ "confidently angry". These modifiers STACK on top of emotion modifiers            
 * ║ to create more complex, realistic emotional expressions.                          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 MULTIPLIER EFFECTS (Applied to Base Gesture)                                   
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • speed        : Animation speed (0.5=half speed, 2.0=double speed)               
 * │ • amplitude    : Movement size (0.5=smaller, 2.0=bigger)                          
 * │ • intensity    : Effect strength (0.5=subtle, 2.0=extreme)                        
 * │ • smoothness   : Animation smoothing (0.5=jerky, 1.5=very smooth)                 
 * │ • regularity   : Pattern consistency (0.5=chaotic, 1.0=regular)                   
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ SPECIAL EFFECTS (Boolean Flags)                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • addFlutter      : Butterfly-like motion (nervous)                               
 * │ • addMicroShake   : Tiny trembling (nervous, tired)                               
 * │ • addPower        : Strong, decisive motion (confident)                           
 * │ • addDrag         : Sluggish, heavy motion (tired)                                
 * │ • addTension      : Tight, controlled motion (intense)                            
 * │ • addSoftness     : Gentle, flowing motion (subdued)                              
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ DO NOT ADD HERE (Belongs in Other Files)                                       
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ Base gesture definitions   → use gestureConfig.js                              
 * │ ✗ Emotion modifiers         → use emotionModifiers.js                            
 * │ ✗ Visual properties         → use emotionMap.js                                  
 * │ ✗ Particle behaviors        → use Particle.js                                    
 * │ ✗ State logic              → use EmotiveStateMachine.js                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                           ADDING NEW UNDERTONES                                   
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ 1. Create new undertone object with all base multipliers (default to 1.0)         
 * ║ 2. Add special effect flags as needed (addXXX properties)                         
 * ║ 3. Test combinations with ALL emotions for unexpected interactions                
 * ║ 4. Document the intended "feel" and use cases                                     
 * ║ 5. Add to valid undertones in ErrorBoundary.js                                    
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

const UNDERTONE_MODIFIERS = {
    // No undertone - neutral multipliers
    none: {
        speed: 1.0,
        amplitude: 1.0,
        intensity: 1.0,
        smoothness: 1.0,
        regularity: 1.0
    },
    
    // Clear undertone - no modification
    clear: {
        speed: 1.0,
        amplitude: 1.0,
        intensity: 1.0,
        smoothness: 1.0,
        regularity: 1.0
    },
    
    nervous: {
        speed: 1.2,        // 20% faster
        amplitude: 0.9,    // 10% smaller (contained)
        intensity: 1.1,    // 10% more intense
        smoothness: 0.7,   // 30% less smooth (fluttery)
        regularity: 0.6,   // Irregular (butterflies)
        addFlutter: true,  // Butterfly-like flutter
        addMicroShake: true // Subtle tremor
    },
    
    confident: {
        speed: 0.9,        // 10% slower (deliberate)
        amplitude: 1.3,    // 30% bigger (bold)
        intensity: 1.2,    // 20% more intense
        smoothness: 1.1,   // 10% smoother (controlled)
        regularity: 1.2,   // Very regular (assured)
        addPower: true,    // Strong, decisive motion
        addHold: true      // Brief pause at peaks
    },
    
    tired: {
        speed: 0.7,        // 30% slower
        amplitude: 0.7,    // 30% smaller
        intensity: 0.8,    // 20% less intense
        smoothness: 1.3,   // 30% smoother (sluggish)
        regularity: 0.8,   // Slightly irregular (drowsy)
        addDroop: true,    // Downward tendency
        addPause: true     // Occasional hesitation
    },
    
    intense: {
        speed: 1.3,        // 30% faster
        amplitude: 1.2,    // 20% bigger
        intensity: 1.4,    // 40% more intense
        smoothness: 0.6,   // 40% less smooth (sharp)
        regularity: 0.9,   // Slightly irregular
        addPulse: true,    // Pulsing intensity
        addFocus: true     // Concentrated motion
    },
    
    subdued: {
        speed: 0.8,        // 20% slower
        amplitude: 0.8,    // 20% smaller
        intensity: 0.7,    // 30% less intense
        smoothness: 1.2,   // 20% smoother
        regularity: 1.1,   // Regular (restrained)
        addSoftness: true, // Gentle, muted motion
        addFade: true      // Fading at edges
    }
};

/**
 * Get undertone modifier
 * @param {string} undertone - Name of the undertone
 * @returns {Object} Modifier object with default values if undertone not found
 */
function getUndertoneModifier(undertone) {
    if (!undertone || undertone === '' || undertone === 'clear') {
        return UNDERTONE_MODIFIERS.clear;
    }
    return UNDERTONE_MODIFIERS[undertone] || UNDERTONE_MODIFIERS.clear;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                   ◐ ◑ ◒ ◓  GESTURE COMPOSITOR  ◓ ◒ ◑ ◐                   
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Gesture Compositor - Emotion-Modified Animation Synthesis
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module GestureCompositor
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The ANIMATOR'S MIXER. Takes base gestures (bounce, pulse, etc.) and blends        
 * ║ them with emotional modifiers and undertones to create nuanced animations.        
 * ║ A happy bounce is different from a sad bounce - this is where that happens!       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 COMPOSITION FORMULA                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ Final Animation = Base Gesture × Emotion Modifier × Undertone Modifier            
 * │                                                                                    
 * │ Example: Bounce + Joy + Confident                                                 
 * │   = Fast, big, springy bounce with extra confidence                               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔗 DEPENDENCIES                                                                    
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • gestures/index.js     : Modular gesture system with base configs                
 * │ • emotionModifiers.js   : How emotions affect movement                            
 * │ • undertoneModifiers.js : Subtle variations in expression                         
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class GestureCompositor {
    constructor() {
        // Cache for computed parameters
        this.cache = new Map();
        
        // Pre-calculate common easing curves for performance
        this.easingCache = new Map();
        this.preCalculateEasingCurves();
    }
    
    /**
     * Pre-calculate common easing curves to avoid repeated calculations
     */
    preCalculateEasingCurves() {
        const steps = 100;
        const easingTypes = ['linear', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'];
        
        for (const type of easingTypes) {
            const curve = new Float32Array(steps + 1);
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                curve[i] = this.calculateEasing(t, type);
            }
            this.easingCache.set(type, curve);
        }
    }
    
    /**
     * Calculate easing value
     */
    calculateEasing(t, type) {
        switch(type) {
        case 'ease-in':
            return t * t;
        case 'ease-out':
            return t * (2 - t);
        case 'ease-in-out':
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        case 'bounce':
            if (t < 0.363636) return 7.5625 * t * t;
            if (t < 0.727272) return 7.5625 * (t -= 0.545454) * t + 0.75;
            if (t < 0.909090) return 7.5625 * (t -= 0.818181) * t + 0.9375;
            return 7.5625 * (t -= 0.954545) * t + 0.984375;
        default:
            return t; // linear
        }
    }
    
    /**
     * Get easing value from cache
     */
    getEasingValue(progress, type) {
        const curve = this.easingCache.get(type);
        if (!curve) return progress; // Fallback to linear
        
        const index = Math.min(Math.floor(progress * 100), 100);
        return curve[index];
    }
    
    /**
     * Compose final gesture parameters
     * @param {string} gesture - Name of the gesture
     * @param {string} emotion - Current emotion state
     * @param {string} undertone - Current undertone (optional)
     * @returns {Object} Final composed parameters for the gesture
     */
    compose(gesture, emotion, undertone = null) {
        // Check cache first
        const cacheKey = `${gesture}-${emotion}-${undertone || 'none'}`;
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        
        // Get base configuration from modular gesture system
        const gestureModule = getGesture(gesture);
        const base = gestureModule ? gestureModule.config : {
            duration: 500,
            amplitude: 20,
            easing: 'sine'
        };
        
        // Use cached gesture properties if available for better performance
        // const cachedProperties = getGestureProperties(gesture);
        const emotionMod = emotionCache && emotionCache.isInitialized ? 
            emotionCache.getModifiers(emotion) : getEmotionModifiers(emotion);
        const undertoneMod = getUndertoneModifier(undertone);
        
        // Compose the final parameters
        const composed = this.applyModifiers(base, emotionMod, undertoneMod, gesture);
        
        // Cache the result with size limit
        if (this.cache.size > 100) {
            // Clear cache if it gets too large
            this.cache.clear();
        }
        this.cache.set(cacheKey, composed);
        
        return composed;
    }
    
    /**
     * Apply modifiers to base parameters
     * @param {Object} base - Base gesture configuration
     * @param {Object} emotionMod - Emotion modifiers
     * @param {Object} undertoneMod - Undertone modifiers
     * @param {string} gesture - Gesture name for special handling
     * @returns {Object} Modified parameters
     */
    applyModifiers(base, emotionMod, undertoneMod, gesture) {
        const result = { ...base };
        
        // Apply speed modifiers (affects duration inversely)
        const speedMultiplier = emotionMod.speed * undertoneMod.speed;
        result.duration = Math.round(base.duration / speedMultiplier);
        
        // Apply amplitude modifiers
        if (result.amplitude !== undefined) {
            result.amplitude = base.amplitude * emotionMod.amplitude * undertoneMod.amplitude;
        }
        
        // Apply scale modifiers
        if (result.scaleAmount !== undefined) {
            result.scaleAmount = base.scaleAmount * emotionMod.intensity * undertoneMod.intensity;
        }
        if (result.scaleTarget !== undefined) {
            const scaleModifier = emotionMod.amplitude * undertoneMod.amplitude;
            result.scaleTarget = 1 + (base.scaleTarget - 1) * scaleModifier;
        }
        
        // Apply glow modifiers
        if (result.glowAmount !== undefined) {
            result.glowAmount = base.glowAmount * emotionMod.intensity * undertoneMod.intensity;
        }
        if (result.glowPeak !== undefined) {
            result.glowPeak = 1 + (base.glowPeak - 1) * emotionMod.intensity * undertoneMod.intensity;
        }
        
        // Apply rotation modifiers
        if (result.rotations !== undefined) {
            result.rotations = base.rotations * emotionMod.amplitude * undertoneMod.amplitude;
        }
        if (result.angle !== undefined) {
            result.angle = base.angle * emotionMod.amplitude * undertoneMod.amplitude;
        }
        
        // Apply distance modifiers (for drift)
        if (result.distance !== undefined) {
            result.distance = base.distance * emotionMod.amplitude * undertoneMod.amplitude;
        }
        
        // Apply smoothness (affects easing)
        const smoothness = emotionMod.smoothness * undertoneMod.smoothness;
        result.smoothness = smoothness;
        result.easing = this.selectEasing(base.easing, smoothness);
        
        // Apply regularity (affects patterns)
        result.regularity = emotionMod.regularity * undertoneMod.regularity;
        
        // Add special effects based on emotion
        result.effects = [];
        if (emotionMod.addBounce) result.effects.push('bounce');
        if (emotionMod.addGravity) result.effects.push('gravity');
        if (emotionMod.addShake) result.effects.push('shake');
        if (emotionMod.addJitter) result.effects.push('shake');
        if (emotionMod.addPop) result.effects.push('pop');
        if (emotionMod.addRecoil) result.effects.push('recoil');
        if (emotionMod.addWarmth) result.effects.push('warmth');
        if (emotionMod.addFlow) result.effects.push('flow');
        if (emotionMod.addWobble) result.effects.push('wobble');
        if (emotionMod.addVibration) result.effects.push('vibration');
        if (emotionMod.addDrag) result.effects.push('drag');
        if (emotionMod.addWeight) result.effects.push('weight');
        if (emotionMod.addTension) result.effects.push('tension');
        if (emotionMod.addPrecision) result.effects.push('precision');
        
        // Add undertone effects
        if (undertoneMod.addFlutter) result.effects.push('flutter');
        if (undertoneMod.addMicroShake) result.effects.push('microShake');
        if (undertoneMod.addPower) result.effects.push('power');
        if (undertoneMod.addHold) result.effects.push('hold');
        if (undertoneMod.addDroop) result.effects.push('droop');
        if (undertoneMod.addPause) result.effects.push('pause');
        if (undertoneMod.addPulse) result.effects.push('pulse');
        if (undertoneMod.addFocus) result.effects.push('focus');
        if (undertoneMod.addSoftness) result.effects.push('softness');
        if (undertoneMod.addFade) result.effects.push('fade');
        
        // Apply gesture-specific modifications
        this.applyGestureSpecificMods(result, gesture, emotionMod, undertoneMod);
        
        // Include particleMotion if it exists in base config
        if (base.particleMotion) {
            result.particleMotion = { ...base.particleMotion };
            
            // Apply modifiers to particle motion strength
            if (result.particleMotion.strength !== undefined) {
                result.particleMotion.strength *= emotionMod.intensity * undertoneMod.intensity;
            }
            
            // Apply speed modifiers to particle motion frequency
            if (result.particleMotion.frequency !== undefined) {
                result.particleMotion.frequency *= speedMultiplier;
            }
            
            // Apply amplitude modifiers to particle motion amplitude
            if (result.particleMotion.amplitude !== undefined) {
                result.particleMotion.amplitude *= emotionMod.amplitude * undertoneMod.amplitude;
            }
        }
        
        return result;
    }
    
    /**
     * Select easing function based on smoothness
     * @param {string} baseEasing - Base easing type
     * @param {number} smoothness - Smoothness multiplier
     * @returns {string} Selected easing function
     */
    selectEasing(baseEasing, smoothness) {
        if (smoothness < 0.5) {
            return 'linear'; // Very sharp
        } else if (smoothness < 0.8) {
            return 'quad'; // Somewhat sharp
        } else if (smoothness < 1.2) {
            return baseEasing; // Normal
        } else if (smoothness < 1.5) {
            return 'cubic'; // Smooth
        } else {
            return 'sine'; // Very smooth
        }
    }
    
    /**
     * Apply gesture-specific modifications
     * @param {Object} result - Current parameters
     * @param {string} gesture - Gesture name
     * @param {Object} emotionMod - Emotion modifiers
     * @param {Object} undertoneMod - Undertone modifiers
     */
    applyGestureSpecificMods(result, gesture, emotionMod, undertoneMod) {
        switch(gesture) {
        case 'bounce':
            // Angry bounce is more violent
            if (emotionMod.addShake) {
                result.frequency = Math.floor(result.frequency * 1.5);
            }
            // Sad bounce barely leaves ground
            if (emotionMod.addGravity) {
                result.amplitude *= 0.6;
                result.frequency = 1;
            }
            break;
                
        case 'pulse':
            // Love pulse is like a heartbeat
            if (emotionMod.addWarmth) {
                result.frequency = 2; // Double beat
                result.glowAmount *= 1.5;
            }
            // Nervous pulse is irregular
            if (undertoneMod.addFlutter) {
                result.irregular = true;
            }
            break;
                
        case 'shake':
            // Fear shake is more intense
            if (emotionMod.addJitter) {
                result.frequency *= 1.5;
                result.amplitude *= 1.2;
            }
            // Anger shake is violent
            if (emotionMod.addShake) {
                result.amplitude *= 1.5;
                result.decay = false; // Sustained shaking
            }
            break;
                
        case 'spin':
            // Joy spin has extra rotations
            if (emotionMod.addBounce) {
                result.rotations *= 1.5;
            }
            // Confused spin reverses direction
            if (emotionMod.addWobble) {
                result.wobble = true;
            }
            break;
                
            // Add more gesture-specific modifications as needed
        }
    }
    
    /**
     * Clear the cache (useful when configs change)
     */
    clearCache() {
        this.cache.clear();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Zen Vortex Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Zen meditation vortex visual effect
 * @author Emotive Engine Team
 * @module effects/zen-vortex
 */

var zenVortex = {
    name: 'zen-vortex',
    emoji: '🌀',
    description: 'Swirling meditation vortex effect',
    
    // Configuration
    config: {
        vortexSpeed: 0.02,
        spiralTightness: 0.15,
        maxRadius: 1.5,
        lineWidth: 2,
        segments: 50,
        arms: 3,
        fadeStart: 0.7,
        baseOpacity: 0.3,
        pulseSpeed: 0.01
    },
    
    // State for animation
    state: {
        rotation: 0,
        pulsePhase: 0,
        intensity: 0
    },
    
    /**
     * Check if effect should be active
     * @param {Object} state - Renderer state
     * @returns {boolean}
     */
    shouldActivate(state) {
        return state.emotion === 'zen' || state.zenTransition?.active;
    },
    
    /**
     * Apply the zen vortex effect
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Object} params - Effect parameters
     */
    apply(ctx, params) {
        const { x, y, radius, intensity = 1.0, deltaTime = 16.67 } = params;
        
        // Update animation state
        this.state.rotation += this.config.vortexSpeed * (deltaTime / 16.67);
        this.state.pulsePhase += this.config.pulseSpeed * (deltaTime / 16.67);
        this.state.intensity = intensity;
        
        ctx.save();
        
        // Draw multiple spiral arms
        for (let arm = 0; arm < this.config.arms; arm++) {
            const armOffset = (Math.PI * 2 / this.config.arms) * arm;
            this.drawSpiralArm(ctx, x, y, radius, armOffset);
        }
        
        // Draw meditation circle (∩∩ shape)
        this.drawMeditationEyes(ctx, x, y, radius * 0.6, intensity);
        
        ctx.restore();
    },
    
    /**
     * Draw a single spiral arm
     */
    drawSpiralArm(ctx, centerX, centerY, baseRadius, offset) {
        ctx.beginPath();
        
        const pulseMod = 1 + Math.sin(this.state.pulsePhase) * 0.1;
        
        for (let i = 0; i <= this.config.segments; i++) {
            const t = i / this.config.segments;
            const angle = this.state.rotation + offset + t * Math.PI * 4;
            const spiralRadius = t * baseRadius * this.config.maxRadius * pulseMod;
            
            // Spiral equation
            const x = centerX + Math.cos(angle) * spiralRadius;
            const y = centerY + Math.sin(angle) * spiralRadius;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        // Create gradient for fade effect
        const gradient = ctx.createLinearGradient(
            centerX - baseRadius, centerY,
            centerX + baseRadius, centerY
        );
        
        const opacity = this.config.baseOpacity * this.state.intensity;
        gradient.addColorStop(0, 'rgba(147, 112, 219, 0)');
        gradient.addColorStop(0.3, `rgba(147, 112, 219, ${opacity * 0.5})`);
        gradient.addColorStop(this.config.fadeStart, `rgba(147, 112, 219, ${opacity})`);
        gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = this.config.lineWidth;
        ctx.stroke();
    },
    
    /**
     * Draw meditation eyes (∩∩)
     */
    drawMeditationEyes(ctx, x, y, radius, intensity) {
        ctx.save();
        
        const eyeWidth = radius * 0.4;
        const eyeSpacing = radius * 0.3;
        
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * intensity})`;
        ctx.lineWidth = 2;
        
        // Left eye (∩)
        ctx.beginPath();
        ctx.arc(x - eyeSpacing, y, eyeWidth, Math.PI, 0, true);
        ctx.stroke();
        
        // Right eye (∩)
        ctx.beginPath();
        ctx.arc(x + eyeSpacing, y, eyeWidth, Math.PI, 0, true);
        ctx.stroke();
        
        ctx.restore();
    },
    
    /**
     * Reset the effect state
     */
    reset() {
        this.state.rotation = 0;
        this.state.pulsePhase = 0;
        this.state.intensity = 0;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Recording Glow Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Pulsating red glow for recording state
 * @author Emotive Engine Team
 * @module effects/recording-glow
 */

var recordingGlow = {
    name: 'recording-glow',
    emoji: '🔴',
    description: 'Pulsating red recording indicator',
    
    // Configuration
    config: {
        color: '#FF0000',
        pulseSpeed: 0.08,
        minIntensity: 0.6,
        maxIntensity: 1.0,
        radiusMultiplier: 2.0,
        gradientStops: [
            { position: 0, opacity: 1.0 },
            { position: 0.3, opacity: 0.7 },
            { position: 0.6, opacity: 0.4 },
            { position: 0.85, opacity: 0.2 },
            { position: 1, opacity: 0 }
        ]
    },
    
    // State for animation
    state: {
        pulsePhase: 0,
        intensity: 0.8  // Start with visible intensity
    },
    
    /**
     * Check if effect should be active
     * @param {Object} state - Renderer state
     * @returns {boolean}
     */
    shouldActivate(state) {
        return state.recording === true;
    },
    
    /**
     * Apply the recording glow effect
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Object} params - Effect parameters
     */
    apply(ctx, params) {
        const { deltaTime = 16.67 } = params;
        
        // Update pulse animation for the indicator only
        this.state.pulsePhase += this.config.pulseSpeed * (deltaTime / 16.67);
        
        // Calculate pulsating intensity
        const pulse = (Math.sin(this.state.pulsePhase) + 1) / 2;
        this.state.intensity = this.config.minIntensity + 
            (this.config.maxIntensity - this.config.minIntensity) * pulse;
        
        // Don't draw any glow on the mascot - only update the animation state
        // The REC indicator will be drawn separately in drawRecordingIndicator
        return true; // Return true to indicate effect was applied
    },
    
    /**
     * Draw recording indicator text only
     */
    drawRecordingIndicator(ctx, canvasWidth, canvasHeight) {
        ctx.save();
        
        // Dynamic text size
        const baseSize = Math.min(canvasWidth, canvasHeight);
        const textSize = Math.floor(baseSize * 0.08);  // 8% of smallest dimension (bigger)
        
        // Position in upper-left corner with padding
        const x = textSize * 1.5;
        const y = textSize * 1.5;
        
        // Draw red recording dot
        const dotRadius = textSize * 0.3;
        ctx.fillStyle = this.hexToRgba('#FF0000', this.state.intensity);
        ctx.beginPath();
        ctx.arc(x - textSize, y, dotRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add white outline for visibility
        ctx.strokeStyle = this.hexToRgba('#FFFFFF', this.state.intensity * 0.8);
        ctx.lineWidth = 3;
        ctx.font = `bold ${textSize}px 'Arial', sans-serif`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.strokeText('REC', x, y);
        
        // Draw "REC" text on top
        ctx.fillStyle = this.hexToRgba('#FF0000', this.state.intensity);
        ctx.fillText('REC', x, y);
        
        ctx.restore();
    },
    
    /**
     * Convert hex to rgba
     */
    hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    },
    
    /**
     * Reset the effect state
     */
    reset() {
        this.state.pulsePhase = 0;
        this.state.intensity = 0;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Speaking Pulse Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var speakingPulse = {
    name: 'speaking-pulse',
    emoji: '🗣️',
    description: 'Audio-reactive pulse when speaking',
    
    config: {
        scaleMultiplier: 0.15,  // Max scale increase when speaking
        smoothing: 0.1,         // Smoothing factor for audio levels
        minPulse: 0.02,         // Minimum pulse even when quiet
        colorShift: true,       // Shift glow color when speaking
        ringEffect: true        // Show expanding rings
    },
    
    state: {
        audioLevel: 0,
        smoothedLevel: 0,
        rings: []  // Array of expanding rings
    },
    
    shouldActivate(state) {
        return state.speaking === true;
    },
    
    apply(ctx, params) {
        const { x, y, radius, audioLevel = 0, deltaTime = 16.67 } = params;
        
        // Smooth audio level
        this.state.smoothedLevel += (audioLevel - this.state.smoothedLevel) * this.config.smoothing;
        
        // Create expanding rings on audio peaks
        if (audioLevel > 0.5 && this.state.audioLevel <= 0.5) {
            this.state.rings.push({
                radius,
                opacity: 0.5,
                speed: 2
            });
        }
        
        // Update and draw rings
        if (this.config.ringEffect) {
            this.drawRings(ctx, x, y, deltaTime);
        }
        
        // Store for next frame
        this.state.audioLevel = audioLevel;
    },
    
    drawRings(ctx, x, y, deltaTime) {
        ctx.save();
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
        ctx.lineWidth = 2;
        
        // Update and draw each ring
        for (let i = this.state.rings.length - 1; i >= 0; i--) {
            const ring = this.state.rings[i];
            
            // Update ring
            ring.radius += ring.speed * (deltaTime / 16.67);
            ring.opacity -= 0.02 * (deltaTime / 16.67);
            
            // Remove if faded
            if (ring.opacity <= 0) {
                this.state.rings.splice(i, 1);
                continue;
            }
            
            // Draw ring
            ctx.globalAlpha = ring.opacity;
            ctx.beginPath();
            ctx.arc(x, y, ring.radius, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    },
    
    getScaleModifier() {
        return 1 + (this.state.smoothedLevel * this.config.scaleMultiplier);
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Sleeping Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var sleepingEffect = {
    name: 'sleeping',
    emoji: '😴',
    description: 'Sleeping with closed eyes and Z particles',
    
    config: {
        eyeClosedScale: 0.1,    // How closed the eyes are (0.1 = 90% closed)
        breathingDepth: 0.15,    // Deeper breathing when sleeping
        breathingRate: 0.8,      // Slower breathing
        zParticleInterval: 2000, // Spawn Z every 2 seconds
        zDriftSpeed: 1,          // Speed of Z particles floating up
        zFadeSpeed: 0.01,        // How fast Z's fade out
        orbDimming: 0.3,         // Dim orb to 30% brightness when sleeping
        glowDimming: 0.2         // Dim glow even more (20% brightness)
    },
    
    state: {
        lastZSpawn: 0,
        zParticles: []
    },
    
    shouldActivate(state) {
        return state.sleeping === true || state.emotion === 'resting';
    },
    
    apply(ctx, params) {
        const { x, y, radius, deltaTime = 16.67 } = params;
        const now = Date.now();
        
        // Spawn new Z particle
        if (now - this.state.lastZSpawn > this.config.zParticleInterval) {
            // Random Poppins font weights: 100-900
            const weights = [100, 200, 300, 400, 500, 600, 700, 800, 900];
            const randomWeight = weights[Math.floor(Math.random() * weights.length)];
            
            this.state.zParticles.push({
                x: x + radius,
                y: y - radius,
                opacity: 1.0,
                size: 12 + Math.random() * 8, // Random size 12-20px
                drift: Math.random() * 0.5 - 0.25, // Slight random drift
                weight: randomWeight, // Random font weight
                rotation: Math.random() * 30 - 15 // Random rotation -15 to 15 degrees
            });
            this.state.lastZSpawn = now;
        }
        
        // Update and draw Z particles
        this.drawZParticles(ctx, deltaTime);
    },
    
    drawZParticles(ctx, deltaTime) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (let i = this.state.zParticles.length - 1; i >= 0; i--) {
            const z = this.state.zParticles[i];
            
            // Update position
            z.y -= this.config.zDriftSpeed * (deltaTime / 16.67);
            z.x += z.drift * (deltaTime / 16.67);
            z.opacity -= this.config.zFadeSpeed * (deltaTime / 16.67);
            z.rotation += 0.5 * (deltaTime / 16.67); // Slow rotation
            
            // Remove if faded
            if (z.opacity <= 0) {
                this.state.zParticles.splice(i, 1);
                continue;
            }
            
            // Draw Z with random Poppins weight
            ctx.save();
            ctx.translate(z.x, z.y);
            ctx.rotate(z.rotation * Math.PI / 180);
            ctx.globalAlpha = z.opacity * 0.7; // Slightly transparent
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = `${z.weight} ${z.size}px 'Poppins', sans-serif`;
            ctx.fillText('Z', 0, 0);
            
            // Add a subtle shadow for depth
            ctx.shadowBlur = 3;
            ctx.shadowColor = 'rgba(147, 112, 219, 0.5)'; // Purple shadow for dreamy effect
            ctx.fillText('Z', 0, 0);
            ctx.restore();
        }
        
        ctx.restore();
    },
    
    getEyeOpenness() {
        return this.config.eyeClosedScale;
    },
    
    getBreathingModifiers() {
        return {
            rate: this.config.breathingRate,
            depth: this.config.breathingDepth
        };
    },
    
    getDimmingValues() {
        return {
            orbDimming: this.config.orbDimming,
            glowDimming: this.config.glowDimming
        };
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Suspicion Scan Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var suspicionScan = {
    name: 'suspicion-scan',
    emoji: '🔍',
    description: 'Suspicious scanning and squinting',
    
    config: {
        squintAmount: 0.4,      // 40% eye narrowing
        scanInterval: 5000,     // Scan every 5 seconds
        scanDuration: 800,      // Each scan takes 800ms
        scanAngle: 45,          // Degrees to look left/right
        squintSpeed: 0.02,      // Animation speed for squinting
        pupilShift: 0.3         // How much the pupil shifts when scanning
    },
    
    state: {
        currentSquint: 0,
        targetSquint: 0,
        lastScanTime: 0,
        scanPhase: 0,  // 0 = center, -1 = left, 1 = right
        scanning: false
    },
    
    shouldActivate(state) {
        return state.emotion === 'suspicion' || state.suspicious === true;
    },
    
    apply(ctx, params) {
        const { deltaTime = 16.67 } = params;
        const now = Date.now();
        
        // Update squint amount
        this.updateSquint(deltaTime);
        
        // Handle scanning motion
        if (now - this.state.lastScanTime > this.config.scanInterval) {
            this.startScan();
            this.state.lastScanTime = now;
        }
        
        if (this.state.scanning) {
            this.updateScan(now, deltaTime);
        }
    },
    
    updateSquint(deltaTime) {
        // Set target squint when suspicious
        this.state.targetSquint = this.config.squintAmount;
        
        // Animate toward target
        const diff = this.state.targetSquint - this.state.currentSquint;
        if (Math.abs(diff) > 0.01) {
            this.state.currentSquint += diff * this.config.squintSpeed * (deltaTime / 16.67);
        } else {
            this.state.currentSquint = this.state.targetSquint;
        }
    },
    
    startScan() {
        this.state.scanning = true;
        this.state.scanStartTime = Date.now();
        this.state.scanPhase = -1; // Start by looking left
    },
    
    updateScan(now, deltaTime) {
        const elapsed = now - this.state.scanStartTime;
        const progress = elapsed / this.config.scanDuration;
        
        if (progress < 0.33) {
            // Look left
            this.state.scanPhase = -1;
        } else if (progress < 0.66) {
            // Look right
            this.state.scanPhase = 1;
        } else if (progress < 1) {
            // Return to center
            this.state.scanPhase = 0;
        } else {
            // Scan complete
            this.state.scanning = false;
            this.state.scanPhase = 0;
        }
    },
    
    getEyeModifiers() {
        return {
            scaleY: 1 - this.state.currentSquint,  // Narrow vertically
            scaleX: 1 + this.state.currentSquint * 0.3,  // Widen horizontally slightly
            offsetX: this.state.scanPhase * this.config.pupilShift
        };
    },
    
    drawScanLines(ctx, x, y, radius) {
        if (!this.state.scanning) return;
        
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 165, 0, 0.3)'; // Orange scan lines
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        
        // Draw scanning beam
        const angle = this.state.scanPhase * (this.config.scanAngle * Math.PI / 180);
        const endX = x + Math.cos(angle) * radius * 2;
        const endY = y + Math.sin(angle) * radius * 0.5;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        ctx.restore();
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Gaze Narrowing Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 */

var gazeNarrowing = {
    name: 'gaze-narrowing',
    emoji: '👁️',
    description: 'Eye narrowing based on gaze proximity',
    
    config: {
        maxHorizontalScale: 1.3,  // Max horizontal widening (30%)
        maxVerticalScale: 0.5,    // Max vertical narrowing (50%)
        smoothing: 0.1,           // Smoothing factor for transitions
        focusThreshold: 0.3       // Intensity threshold to start narrowing
    },
    
    state: {
        currentScaleX: 1,
        currentScaleY: 1,
        targetScaleX: 1,
        targetScaleY: 1
    },
    
    shouldActivate(state) {
        return state.gazeIntensity > 0 || state.gazeLocked;
    },
    
    apply(ctx, params) {
        const { gazeIntensity = 0, deltaTime = 16.67 } = params;
        
        // Calculate target scales based on gaze intensity
        if (gazeIntensity > this.config.focusThreshold) {
            const narrowFactor = (gazeIntensity - this.config.focusThreshold) / 
                                (1 - this.config.focusThreshold);
            
            this.state.targetScaleX = 1 + (this.config.maxHorizontalScale - 1) * narrowFactor;
            this.state.targetScaleY = 1 - (1 - this.config.maxVerticalScale) * narrowFactor;
        } else {
            this.state.targetScaleX = 1;
            this.state.targetScaleY = 1;
        }
        
        // Smooth transitions
        this.animateScales(deltaTime);
    },
    
    animateScales(deltaTime) {
        const speed = this.config.smoothing * (deltaTime / 16.67);
        
        // Animate X scale
        const diffX = this.state.targetScaleX - this.state.currentScaleX;
        if (Math.abs(diffX) > 0.001) {
            this.state.currentScaleX += diffX * speed;
        }
        
        // Animate Y scale
        const diffY = this.state.targetScaleY - this.state.currentScaleY;
        if (Math.abs(diffY) > 0.001) {
            this.state.currentScaleY += diffY * speed;
        }
    },
    
    getEyeScales() {
        return {
            scaleX: this.state.currentScaleX,
            scaleY: this.state.currentScaleY
        };
    },
    
    drawFocusIndicator(ctx, x, y, radius, intensity) {
        if (intensity < this.config.focusThreshold) return;
        
        ctx.save();
        
        // Draw focus lines converging on target
        const alpha = (intensity - this.config.focusThreshold) * 0.5;
        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        
        // Draw converging lines
        const angles = [0, 60, 120, 180, 240, 300];
        for (const angle of angles) {
            const rad = angle * Math.PI / 180;
            const startDist = radius * 2;
            const endDist = radius * 1.2;
            
            ctx.beginPath();
            ctx.moveTo(
                x + Math.cos(rad) * startDist,
                y + Math.sin(rad) * startDist
            );
            ctx.lineTo(
                x + Math.cos(rad) * endDist,
                y + Math.sin(rad) * endDist
            );
            ctx.stroke();
        }
        
        ctx.restore();
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Fingerprint Effect
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Biometric fingerprint pattern effect
 * @author Emotive Engine Team
 * @module effects/fingerprint
 * 
 * Created from a happy accident in the resting state that produced
 * concentric circles resembling a fingerprint pattern!
 */

var fingerprint = {
    name: 'fingerprint',
    emoji: '👆',
    description: 'Biometric fingerprint pattern for authentication UI',
    
    // Configuration
    config: {
        rings: 8,                  // Number of concentric rings
        ringSpacing: 15,           // Pixels between rings
        lineWidth: 1.5,           // Width of fingerprint lines
        rotationSpeed: 0.001,     // Slow rotation for scanning effect
        pulseSpeed: 0.02,         // Breathing/pulse speed
        waveAmplitude: 3,         // Waviness of lines (realistic fingerprint)
        waveFrequency: 8,         // How many waves per ring
        breakPoints: 5,           // Random breaks in lines (like real fingerprints)
        opacity: 0.4,             // Base opacity
        scanLineSpeed: 0.01,      // Speed of scanning line
        scanLineWidth: 3,         // Width of scanning beam
        color: '#00CED1',         // Cyan for tech/biometric feel
        glowColor: '#00FFFF',     // Bright cyan for scan
        successColor: '#00FF00',  // Green for successful scan
        failColor: '#FF0000'      // Red for failed scan
    },
    
    // State for animation
    state: {
        rotation: 0,
        pulsePhase: 0,
        scanPosition: 0,
        scanDirection: 1,
        isScanning: false,
        scanResult: null,  // 'success', 'fail', or null
        breaks: [],        // Random break positions in rings
        whorls: []         // Whorl patterns for realism
    },
    
    /**
     * Check if effect should be active
     * @param {Object} state - Renderer state
     * @returns {boolean}
     */
    shouldActivate(state) {
        return state.biometric === true || state.fingerprint === true || state.authenticating === true;
    },
    
    /**
     * Initialize fingerprint pattern
     */
    initialize() {
        // Generate random breaks for each ring
        this.state.breaks = [];
        for (let i = 0; i < this.config.rings; i++) {
            const ringBreaks = [];
            for (let j = 0; j < this.config.breakPoints; j++) {
                ringBreaks.push(Math.random() * Math.PI * 2);
            }
            this.state.breaks.push(ringBreaks);
        }
        
        // Generate whorl centers for realistic pattern
        this.state.whorls = [
            { x: 0.2, y: -0.1, strength: 0.3 },
            { x: -0.15, y: 0.2, strength: 0.25 },
            { x: 0, y: 0, strength: 0.5 }  // Central whorl
        ];
    },
    
    /**
     * Apply the fingerprint effect
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Object} params - Effect parameters
     */
    apply(ctx, params) {
        const { x, y, radius, deltaTime = 16.67, scanning = false, authResult = null } = params;
        
        // Initialize on first run
        if (this.state.breaks.length === 0) {
            this.initialize();
        }
        
        // Update animation state
        this.state.rotation += this.config.rotationSpeed * (deltaTime / 16.67);
        this.state.pulsePhase += this.config.pulseSpeed * (deltaTime / 16.67);
        
        // Update scan position
        if (scanning || this.state.isScanning) {
            this.state.isScanning = true;
            this.state.scanPosition += this.config.scanLineSpeed * this.state.scanDirection * (deltaTime / 16.67);
            
            // Reverse at bounds
            if (this.state.scanPosition > 1) {
                this.state.scanPosition = 1;
                this.state.scanDirection = -1;
            } else if (this.state.scanPosition < -1) {
                this.state.scanPosition = -1;
                this.state.scanDirection = 1;
            }
        }
        
        ctx.save();
        
        // Draw fingerprint rings
        this.drawFingerprintPattern(ctx, x, y, radius);
        
        // Draw scanning line if active
        if (this.state.isScanning) {
            this.drawScanLine(ctx, x, y, radius);
        }
        
        // Show auth result
        if (authResult) {
            this.showAuthResult(ctx, x, y, radius, authResult);
        }
        
        ctx.restore();
    },
    
    /**
     * Draw the fingerprint pattern
     */
    drawFingerprintPattern(ctx, centerX, centerY, baseRadius) {
        const pulse = Math.sin(this.state.pulsePhase) * 0.1 + 1;
        
        for (let ring = 0; ring < this.config.rings; ring++) {
            const ringRadius = (ring + 1) * this.config.ringSpacing * pulse;
            
            // Skip if ring is outside visible area
            if (ringRadius > baseRadius * 2) continue;
            
            ctx.beginPath();
            ctx.strokeStyle = this.config.color;
            ctx.lineWidth = this.config.lineWidth;
            ctx.globalAlpha = this.config.opacity * (1 - ring / this.config.rings * 0.5);
            
            // Draw ring with breaks and distortions
            for (let angle = 0; angle < Math.PI * 2; angle += 0.05) {
                // Check for breaks
                let shouldBreak = false;
                for (const breakAngle of this.state.breaks[ring] || []) {
                    if (Math.abs(angle - breakAngle) < 0.1) {
                        shouldBreak = true;
                        break;
                    }
                }
                
                if (shouldBreak) {
                    ctx.stroke();
                    ctx.beginPath();
                    continue;
                }
                
                // Apply whorl distortions
                let distortedRadius = ringRadius;
                let distortedAngle = angle + this.state.rotation;
                
                for (const whorl of this.state.whorls) {
                    const whorldX = centerX + whorl.x * baseRadius;
                    const whorldY = centerY + whorl.y * baseRadius;
                    const pointX = centerX + Math.cos(distortedAngle) * distortedRadius;
                    const pointY = centerY + Math.sin(distortedAngle) * distortedRadius;
                    
                    const distance = Math.sqrt(
                        Math.pow(pointX - whorldX, 2) + 
                        Math.pow(pointY - whorldY, 2)
                    );
                    
                    const influence = Math.exp(-distance / (baseRadius * 0.5)) * whorl.strength;
                    distortedAngle += influence * 0.5;
                }
                
                // Add wave pattern
                const wave = Math.sin(angle * this.config.waveFrequency) * this.config.waveAmplitude;
                distortedRadius += wave;
                
                // Draw point
                const px = centerX + Math.cos(distortedAngle) * distortedRadius;
                const py = centerY + Math.sin(distortedAngle) * distortedRadius;
                
                if (angle === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            
            ctx.stroke();
        }
    },
    
    /**
     * Draw scanning line
     */
    drawScanLine(ctx, x, y, radius) {
        const scanY = y + this.state.scanPosition * radius;
        
        // Create gradient for scan line
        const gradient = ctx.createLinearGradient(x - radius, scanY, x + radius, scanY);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0)');
        gradient.addColorStop(0.5, this.config.glowColor);
        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = this.config.scanLineWidth;
        ctx.globalAlpha = 0.8;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.config.glowColor;
        
        ctx.beginPath();
        ctx.moveTo(x - radius, scanY);
        ctx.lineTo(x + radius, scanY);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
    },
    
    /**
     * Show authentication result
     */
    showAuthResult(ctx, x, y, radius, result) {
        const color = result === 'success' ? this.config.successColor : this.config.failColor;
        const text = result === 'success' ? '✓ AUTHENTICATED' : '✗ ACCESS DENIED';
        
        ctx.fillStyle = color;
        ctx.font = `bold ${radius * 0.15}px monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.globalAlpha = 0.9;
        
        ctx.fillText(text, x, y + radius * 1.3);
        
        // Draw result ring
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.1, 0, Math.PI * 2);
        ctx.stroke();
    },
    
    /**
     * Start authentication scan
     */
    startScan() {
        this.state.isScanning = true;
        this.state.scanPosition = -1;
        this.state.scanDirection = 1;
        this.state.scanResult = null;
    },
    
    /**
     * Complete authentication scan
     */
    completeScan(success = true) {
        this.state.isScanning = false;
        this.state.scanResult = success ? 'success' : 'fail';
        
        // Clear result after 2 seconds
        setTimeout(() => {
            this.state.scanResult = null;
        }, 2000);
    },
    
    /**
     * Reset the effect state
     */
    reset() {
        this.state.rotation = 0;
        this.state.pulsePhase = 0;
        this.state.scanPosition = 0;
        this.state.scanDirection = 1;
        this.state.isScanning = false;
        this.state.scanResult = null;
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Visual Effects Registry
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Central registry for visual effects like zen vortex, recording glow, etc.
 * @author Emotive Engine Team
 * @module effects
 */


// Registry to store all visual effects
const effectRegistry = new Map();

/**
 * Register a visual effect module
 * @param {Object} effectModule - The effect module to register
 */
function registerEffect(effectModule) {
    if (!effectModule.name) {
        return;
    }
    effectRegistry.set(effectModule.name, effectModule);
}

/**
 * Get effect by name
 * @param {string} effectName - Name of the effect
 * @returns {Object|null} The effect module or null
 */
function getEffect(effectName) {
    return effectRegistry.get(effectName) || null;
}

/**
 * Apply a visual effect
 * @param {string} effectName - Name of the effect to apply
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} params - Effect parameters
 * @returns {boolean} True if effect was applied
 */
function applyEffect(effectName, ctx, params) {
    const effect = getEffect(effectName);
    if (!effect) {
        return false;
    }
    
    if (effect.apply) {
        effect.apply(ctx, params);
        return true;
    }
    
    return false;
}

/**
 * Check if effect should be active
 * @param {string} effectName - Name of the effect
 * @param {Object} state - Current state
 * @returns {boolean} True if effect should be active
 */
function isEffectActive(effectName, state) {
    const effect = getEffect(effectName);
    if (!effect || !effect.shouldActivate) {
        return false;
    }
    return effect.shouldActivate(state);
}

// Register all built-in effects
registerEffect(zenVortex);
registerEffect(recordingGlow);
registerEffect(speakingPulse);
registerEffect(sleepingEffect);
registerEffect(suspicionScan);
registerEffect(gazeNarrowing);
registerEffect(fingerprint);

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Musical Duration System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Musical time calculation for tempo-aware gesture durations
 * @author Emotive Engine Team
 * @module core/MusicalDuration
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Converts between musical time (beats/bars) and clock time (milliseconds).        
 * ║ Ensures all gesture durations are perfect subdivisions of the beat, making        
 * ║ animations musically coherent at any tempo.                                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class MusicalDuration {
    constructor() {
        // Standard note durations in beats (4/4 time)
        this.noteDurations = {
            'whole': 4,
            'half': 2,
            'quarter': 1,
            'eighth': 0.5,
            'sixteenth': 0.25,
            'triplet': 0.333,
            'dotted-quarter': 1.5,
            'dotted-half': 3
        };
        
        // Cache for performance
        this.cache = new Map();
        this.lastBPM = 0;
        
        // Pre-warm cache with common BPMs and durations
        this.prewarmCache();
    }
    
    /**
     * Pre-calculate common durations to prevent first-run lag
     */
    prewarmCache() {
        const commonBPMs = [60, 90, 120, 140, 160, 180];
        const commonDurations = [
            { musical: true, beats: 1 },      // 1 beat
            { musical: true, bars: 1 },       // 1 bar
            { musical: true, beats: 0.5 },    // Half beat
            { musical: true, beats: 2 }       // 2 beats
        ];
        
        commonBPMs.forEach(bpm => {
            commonDurations.forEach(duration => {
                const key = `${bpm}_${JSON.stringify(duration)}`;
                const ms = this.toMilliseconds(duration, bpm);
                this.cache.set(key, ms);
            });
        });
    }
    
    /**
     * Convert musical duration to milliseconds
     * @param {Object} duration - Musical duration config
     * @param {number} [bpm] - Optional BPM override
     * @returns {number} Duration in milliseconds
     */
    toMilliseconds(duration, bpm = null) {
        const currentBPM = bpm || rhythmEngine.bpm || 120;
        
        // Handle different duration formats
        if (typeof duration === 'number') {
            // Already in milliseconds
            return duration;
        }
        
        if (typeof duration === 'object' && duration.musical) {
            const beatDuration = 60000 / currentBPM;
            
            if (duration.beats !== undefined) {
                // Specified in beats
                return duration.beats * beatDuration;
            } else if (duration.bars !== undefined) {
                // Specified in bars (assume 4/4)
                const timeSignature = rhythmEngine.timeSignature || [4, 4];
                return duration.bars * timeSignature[0] * beatDuration;
            } else if (duration.subdivision !== undefined) {
                // Specified as note value
                const beats = this.noteDurations[duration.subdivision] || 1;
                return beats * beatDuration;
            }
        }
        
        // Default fallback
        return 1000;
    }
    
    /**
     * Convert milliseconds to musical duration
     * @param {number} ms - Duration in milliseconds
     * @param {number} [bpm] - Optional BPM override
     * @returns {Object} Musical duration
     */
    toMusical(ms, bpm = null) {
        const currentBPM = bpm || rhythmEngine.bpm || 120;
        const beatDuration = 60000 / currentBPM;
        const beats = ms / beatDuration;
        
        // Find closest standard duration
        let closestNote = 'quarter';
        let closestDiff = Math.abs(beats - 1);
        
        for (const [note, duration] of Object.entries(this.noteDurations)) {
            const diff = Math.abs(beats - duration);
            if (diff < closestDiff) {
                closestDiff = diff;
                closestNote = note;
            }
        }
        
        return {
            musical: true,
            beats,
            bars: beats / 4,
            closestSubdivision: closestNote,
            exact: closestDiff < 0.01
        };
    }
    
    /**
     * Calculate gesture phases with musical timing
     * @param {Array} phases - Array of phase configurations
     * @param {number} totalBeats - Total duration in beats
     * @returns {Array} Phases with calculated timings
     */
    calculatePhases(phases, totalBeats) {
        if (!phases || phases.length === 0) {
            return [{ name: 'main', beats: totalBeats, start: 0, end: 1 }];
        }
        
        // Calculate total beats from phases
        const phaseBeats = phases.reduce((sum, phase) => sum + (phase.beats || 1), 0);
        const scaleFactor = totalBeats / phaseBeats;
        
        let cumulativeBeats = 0;
        return phases.map(phase => {
            const beats = (phase.beats || 1) * scaleFactor;
            const start = cumulativeBeats / totalBeats;
            cumulativeBeats += beats;
            const end = cumulativeBeats / totalBeats;
            
            return {
                name: phase.name,
                beats,
                start,
                end,
                duration: this.toMilliseconds({ musical: true, beats })
            };
        });
    }
    
    /**
     * Get progress through current beat
     * @returns {number} Progress 0-1 through current beat
     */
    getBeatProgress() {
        const timeInfo = rhythmEngine.getTimeInfo();
        return timeInfo ? timeInfo.beatProgress : 0;
    }
    
    /**
     * Get progress through current bar
     * @returns {number} Progress 0-1 through current bar
     */
    getBarProgress() {
        const timeInfo = rhythmEngine.getTimeInfo();
        return timeInfo ? timeInfo.barProgress : 0;
    }
    
    /**
     * Calculate when next musical boundary occurs
     * @param {string} boundary - 'beat', 'bar', 'phrase'
     * @returns {number} Milliseconds until boundary
     */
    timeToNextBoundary(boundary = 'beat') {
        const timeInfo = rhythmEngine.getTimeInfo();
        if (!timeInfo) return 100;
        
        switch (boundary) {
        case 'beat':
            return timeInfo.nextBeatIn;
        case 'bar': {
            const beatsInBar = timeInfo.timeSignature[0];
            const beatsToBar = beatsInBar - timeInfo.beatInBar;
            return beatsToBar * timeInfo.beatDuration;
        }
        case 'phrase': {
            // Assume 4-bar phrases
            const barsInPhrase = 4;
            const beatsInBar = timeInfo.timeSignature[0];
            const currentBar = timeInfo.bar || 0;
            const barsToPhrase = barsInPhrase - (currentBar % barsInPhrase);
            return barsToPhrase * beatsInBar * timeInfo.beatDuration;
        }
        default:
            return timeInfo.nextBeatIn;
        }
    }
    
    /**
     * Quantize a duration to nearest musical subdivision
     * @param {number} ms - Duration in milliseconds
     * @param {string} subdivision - Target subdivision
     * @returns {number} Quantized duration in ms
     */
    quantize(ms, subdivision = 'eighth') {
        const bpm = rhythmEngine.bpm || 120;
        const beatDuration = 60000 / bpm;
        const targetBeats = this.noteDurations[subdivision] || 1;
        const targetMs = targetBeats * beatDuration;
        
        // Round to nearest multiple of target
        const multiple = Math.round(ms / targetMs);
        return multiple * targetMs;
    }
    
    /**
     * Check if we're on a musical boundary
     * @param {string} boundary - 'beat', 'bar', 'phrase'
     * @param {number} tolerance - Tolerance in ms
     * @returns {boolean}
     */
    isOnBoundary(boundary = 'beat', tolerance = 50) {
        const timeToNext = this.timeToNextBoundary(boundary);
        const timeInfo = rhythmEngine.getTimeInfo();
        
        if (!timeInfo) return false;
        
        // Check if we just passed or are about to hit boundary
        return timeToNext < tolerance || 
               (timeInfo.beatDuration - timeToNext) < tolerance;
    }
    
    /**
     * Get tempo-adaptive animation parameters
     * @param {number} baseTempo - Reference tempo
     * @returns {Object} Animation adjustment factors
     */
    getTempoAdaptation(baseTempo = 120) {
        const currentTempo = rhythmEngine.bpm || 120;
        const tempoRatio = currentTempo / baseTempo;
        
        return {
            speed: tempoRatio,
            energy: Math.min(2, Math.max(0.5, tempoRatio)),
            smoothness: tempoRatio < 0.8 ? 1.2 : tempoRatio > 1.5 ? 0.8 : 1,
            intensity: tempoRatio > 1.3 ? 1.2 : tempoRatio < 0.7 ? 0.8 : 1
        };
    }
}

// Create singleton instance
const musicalDuration = new MusicalDuration();

/**
 * GestureAnimator - Handles all gesture animations for EmotiveRenderer
 * @module core/renderer/GestureAnimator
 */


class GestureAnimator {
    constructor(renderer) {
        this.renderer = renderer;
        this.activeGestures = new Map();
        this.scaleFactor = renderer.scaleFactor || 1;
        
        // Gesture animations state
        this.gestureAnimations = {
            bounce: { active: false, progress: 0, params: {} },
            pulse: { active: false, progress: 0, params: {} },
            shake: { active: false, progress: 0, params: {} },
            spin: { active: false, progress: 0, params: {} },
            nod: { active: false, progress: 0, params: {} },
            tilt: { active: false, progress: 0, params: {} },
            expand: { active: false, progress: 0, params: {} },
            contract: { active: false, progress: 0, params: {} },
            flash: { active: false, progress: 0, params: {} },
            drift: { active: false, progress: 0, params: {} },
            stretch: { active: false, progress: 0, params: {} },
            glow: { active: false, progress: 0, params: {} },
            flicker: { active: false, progress: 0, params: {} },
            vibrate: { active: false, progress: 0, params: {} },
            orbital: { active: false, progress: 0, params: {} },  // ADDED
            hula: { active: false, progress: 0, params: {} },     // ADDED
            wave: { active: false, progress: 0, params: {} },
            breathe: { active: false, progress: 0, params: {} },
            morph: { active: false, progress: 0, params: {} },
            slowBlink: { active: false, progress: 0, params: {} },
            look: { active: false, progress: 0, params: {} },
            settle: { active: false, progress: 0, params: {} },
            breathIn: { active: false, progress: 0, params: {} },
            breathOut: { active: false, progress: 0, params: {} },
            breathHold: { active: false, progress: 0, params: {} },
            breathHoldEmpty: { active: false, progress: 0, params: {} },
            jump: { active: false, progress: 0, params: {} },
            sway: { active: false, progress: 0, params: {} },
            float: { active: false, progress: 0, params: {} },
            sparkle: { active: false, progress: 0, params: {} },
            shimmer: { active: false, progress: 0, params: {} },
            wiggle: { active: false, progress: 0, params: {} },
            groove: { active: false, progress: 0, params: {} },
            point: { active: false, progress: 0, params: {} },
            lean: { active: false, progress: 0, params: {} },
            reach: { active: false, progress: 0, params: {} },
            headBob: { active: false, progress: 0, params: {} },
            orbit: { active: false, progress: 0, params: {} },
            rain: { active: false, progress: 0, params: {} },
            runningman: { active: false, progress: 0, params: {} },
            charleston: { active: false, progress: 0, params: {} }
        };
    }

    /**
     * Start a gesture animation
     * @param {string} gestureName - Name of the gesture to start
     */
    startGesture(gestureName) {
        
        // Get the gesture configuration (uses cache if available)
        const gesture = getGesture(gestureName);
        
        // Use cached properties for better performance
        // const cachedProperties = getGestureProperties(gestureName);
        
        // Trigger chromatic aberration for impact gestures
        const impactGestures = ['bounce', 'shake', 'pulse', 'flash', 'jump', 'slam', 'spin', 'flicker'];
        if (impactGestures.includes(gestureName) && this.renderer.specialEffects) {
            // Vary intensity based on gesture - all high for testing
            const intensities = {
                'flash': 1.0,
                'jump': 1.0,
                'shake': 0.9,
                'bounce': 0.8,
                'pulse': 0.7,
                'slam': 1.0,
                'spin': 0.8,
                'flicker': 1.0
            };
            const intensity = intensities[gestureName] || 0.8;
            this.renderer.specialEffects.triggerChromaticAberration(intensity);
            // Chromatic aberration logging removed for production
        }
        
        // Get composed parameters based on current emotion and undertone
        // Use the renderer's gestureCompositor if available
        let params;
        if (this.renderer.gestureCompositor) {
            params = this.renderer.gestureCompositor.compose(
                gestureName,
                this.renderer.state.emotion,
                this.renderer.currentUndertone
            );
        } else {
            // Fallback to gesture's default config if no compositor
            params = gesture?.config || {
                amplitude: 20,
                frequency: 2,
                duration: 1000,
                scaleAmount: 0.2,
                glowAmount: 0.3,
                rotations: 1,
                distance: 50,
                angle: 15,
                scaleTarget: 1.5,
                glowPeak: 2.0,
                scalePeak: 1.1,
                scaleX: 1.2,
                scaleY: 0.8,
                maxOpacity: 1,
                minOpacity: 0.5,
                lookDirection: 'random',
                lookDistance: 1,
                wobbleFreq: 4,
                squashAmount: 0.8,
                stretchAmount: 1.2,
                jumpHeight: 100,
                decay: true,
                easing: 'sine',
                effects: []
            };
        }
        
        // Calculate duration from gesture config
        let duration = 1000; // Default fallback
        if (gesture && gesture.config) {
            if (gesture.config.musicalDuration) {
                // Use musical duration system
                duration = musicalDuration.toMilliseconds(gesture.config.musicalDuration);
            } else if (gesture.config.duration) {
                // Use fixed duration
                const { duration: configDuration } = gesture.config;
                duration = configDuration;
            }
        }
        
        // Set up the animation
        const anim = this.gestureAnimations[gestureName];
        if (anim) {
            anim.active = true;
            anim.startTime = performance.now();
            anim.progress = 0;
            anim.params = params;
            anim.duration = duration; // Store calculated duration
            
            // Reset random values for gestures that use them
            if (gestureName === 'shake') {
                anim.randomAngle = undefined; // Will be regenerated
            } else if (gestureName === 'drift') {
                anim.startX = undefined;
                anim.startY = undefined;
                anim.currentDriftAngle = undefined; // Reset the angle for new random direction
            } else if (gestureName === 'tilt') {
                anim.tiltDirection = undefined; // Reset for new random direction
            } else if (gestureName === 'vibrate') {
                anim.vibrateAngles = undefined;
            }
            
        }
    }

    /**
     * Apply all active gesture animations
     * @returns {Object} Combined transformation values
     */
    applyGestureAnimations() {
        const now = performance.now();
        const transform = {
            offsetX: 0,
            offsetY: 0,
            scale: 1,
            rotation: 0,
            glow: 1
        };
        
        // Process each gesture animation
        for (const [gestureName, anim] of Object.entries(this.gestureAnimations)) {
            if (!anim.active) continue;
            
            const elapsed = now - anim.startTime;
            // Use stored duration or fallback to params duration
            const duration = anim.duration || (anim.params ? anim.params.duration : 1000);
            anim.progress = Math.min(elapsed / duration, 1);
            
            // Apply easing
            const easedProgress = this.applyEasing(anim.progress, anim.params.easing);
            
            // Apply gesture-specific transformations
            let gestureTransform = {};
            switch (gestureName) {
            case 'bounce':
                gestureTransform = this.applyBounce(anim, easedProgress);
                break;
            case 'pulse':
                gestureTransform = this.applyPulse(anim, easedProgress);
                break;
            case 'shake':
                gestureTransform = this.applyShake(anim, easedProgress);
                break;
            case 'spin':
                gestureTransform = this.applySpin(anim, easedProgress);
                break;
            case 'nod':
                gestureTransform = this.applyNod(anim, easedProgress);
                break;
            case 'tilt':
                gestureTransform = this.applyTilt(anim, easedProgress);
                break;
            case 'expand':
                gestureTransform = this.applyExpand(anim, easedProgress);
                break;
            case 'contract':
                gestureTransform = this.applyContract(anim, easedProgress);
                break;
            case 'flash':
                gestureTransform = this.applyFlash(anim, easedProgress);
                break;
            case 'drift':
                gestureTransform = this.applyDrift(anim, easedProgress);
                break;
            case 'stretch':
                gestureTransform = this.applyStretch(anim, easedProgress);
                break;
            case 'glow':
                gestureTransform = this.applyGlow(anim, easedProgress);
                break;
            case 'flicker':
                gestureTransform = this.applyFlicker(anim, easedProgress);
                break;
            case 'vibrate':
                gestureTransform = this.applyVibrate(anim, easedProgress);
                break;
            case 'orbital':
                gestureTransform = this.applyOrbital(anim, easedProgress);
                break;
            case 'hula':
                gestureTransform = this.applyHula(anim, easedProgress);
                break;
            case 'wave':
                gestureTransform = this.applyWave(anim, easedProgress);
                break;
            case 'breathe':
                gestureTransform = this.applyBreathe(anim, easedProgress);
                break;
            case 'morph':
                gestureTransform = this.applyMorph(anim, easedProgress);
                break;
            case 'slowBlink':
                gestureTransform = this.applySlowBlink(anim, easedProgress);
                break;
            case 'look':
                gestureTransform = this.applyLook(anim, easedProgress);
                break;
            case 'settle':
                gestureTransform = this.applySettle(anim, easedProgress);
                break;
            case 'breathIn':
                gestureTransform = this.applyBreathIn(anim, easedProgress);
                break;
            case 'breathOut':
                gestureTransform = this.applyBreathOut(anim, easedProgress);
                break;
            case 'breathHold':
                gestureTransform = this.applyBreathHold(anim, easedProgress);
                break;
            case 'breathHoldEmpty':
                gestureTransform = this.applyBreathHoldEmpty(anim, easedProgress);
                break;
            case 'jump':
                gestureTransform = this.applyJump(anim, easedProgress);
                break;
            case 'sway':
                gestureTransform = this.applySway(anim, easedProgress);
                break;
            case 'float':
                gestureTransform = this.applyFloat(anim, easedProgress);
                break;
            case 'rain':
                gestureTransform = this.applyRain(anim, easedProgress);
                break;
            case 'runningman':
                gestureTransform = this.applyRunningMan(anim, easedProgress);
                break;
            case 'charleston':
                gestureTransform = this.applyCharleston(anim, easedProgress);
                break;
            case 'sparkle':
                gestureTransform = this.applySparkle(anim, easedProgress);
                break;
            case 'shimmer':
                gestureTransform = this.applyShimmer(anim, easedProgress);
                break;
            case 'wiggle':
                gestureTransform = this.applyWiggle(anim, easedProgress);
                break;
            case 'groove':
                gestureTransform = this.applyGroove(anim, easedProgress);
                break;
            case 'point':
                gestureTransform = this.applyPoint(anim, easedProgress);
                break;
            case 'lean':
                gestureTransform = this.applyLean(anim, easedProgress);
                break;
            case 'reach':
                gestureTransform = this.applyReach(anim, easedProgress);
                break;
            case 'headBob':
                gestureTransform = this.applyHeadBob(anim, easedProgress);
                break;
            case 'orbit':
                gestureTransform = this.applyOrbit(anim, easedProgress);
                break;
            }
            
            // Combine transforms
            transform.offsetX += gestureTransform.offsetX || 0;
            transform.offsetY += gestureTransform.offsetY || 0;
            transform.scale *= gestureTransform.scale || 1;
            transform.rotation += gestureTransform.rotation || 0;
            // Use MAX for glow instead of multiplying to prevent accumulation
            transform.glow = Math.max(transform.glow, gestureTransform.glow || 1);
            
            // Pass flash wave data if present
            if (gestureTransform.flashWave) {
                transform.flashWave = gestureTransform.flashWave;
            }
            
            // Pass firefly effect data if present (for sparkle gesture)
            if (gestureTransform.fireflyEffect) {
                transform.fireflyEffect = gestureTransform.fireflyEffect;
                transform.particleGlow = gestureTransform.particleGlow;
                transform.fireflyTime = gestureTransform.fireflyTime;
            }
            
            // Pass flicker effect data if present (for flicker gesture - now does particle shimmer)
            if (gestureTransform.flickerEffect) {
                transform.flickerEffect = gestureTransform.flickerEffect;
                transform.particleGlow = gestureTransform.particleGlow;
                transform.flickerTime = gestureTransform.flickerTime;
            }
            
            // Pass shimmer effect data if present (for shimmer gesture - subtle glow)
            if (gestureTransform.shimmerEffect) {
                transform.shimmerEffect = gestureTransform.shimmerEffect;
                transform.particleGlow = gestureTransform.particleGlow;
                transform.shimmerTime = gestureTransform.shimmerTime;
                transform.shimmerWave = gestureTransform.shimmerWave;
            }
            
            // Pass glow effect data if present (for glow gesture)
            if (gestureTransform.glowEffect) {
                transform.glowEffect = gestureTransform.glowEffect;
                transform.particleGlow = gestureTransform.particleGlow;
                transform.glowTime = gestureTransform.glowTime;
                transform.glowProgress = gestureTransform.glowProgress;
                transform.glowEnvelope = gestureTransform.glowEnvelope;
            }
            
            // Check if animation is complete
            if (anim.progress >= 1) {
                anim.active = false;
                anim.progress = 0;
                anim.startTime = 0;
                // Clean up flash wave data
                if (gestureName === 'flash') {
                    anim.flashWave = null;
                    anim.flashWaveData = null;
                }
                // Clean up glow effect data to prevent accumulation
                if (gestureTransform.glowEffect) {
                    gestureTransform.glowEffect = null;
                    gestureTransform.particleGlow = null;
                    gestureTransform.glowTime = null;
                    gestureTransform.glowProgress = null;
                    gestureTransform.glowEnvelope = null;
                }
                // Clean up other effect data
                if (gestureTransform.fireflyEffect) {
                    gestureTransform.fireflyEffect = null;
                    gestureTransform.particleGlow = null;
                    gestureTransform.fireflyTime = null;
                }
                if (gestureTransform.flickerEffect) {
                    gestureTransform.flickerEffect = null;
                    gestureTransform.particleGlow = null;
                    gestureTransform.flickerTime = null;
                }
                if (gestureTransform.shimmerEffect) {
                    gestureTransform.shimmerEffect = null;
                    gestureTransform.particleGlow = null;
                    gestureTransform.shimmerTime = null;
                    gestureTransform.shimmerWave = null;
                }
            }
        }
        
        return transform;
    }

    /**
     * Update active gestures
     * @param {number} deltaTime - Time since last frame
     */
    update(deltaTime) {
        // Update logic moved to applyGestureAnimations
        return this.applyGestureAnimations();
    }

    /**
     * Stop all active gestures
     */
    stopAllGestures() {
        // Reset all gesture animations
        Object.keys(this.gestureAnimations).forEach(key => {
            const anim = this.gestureAnimations[key];
            anim.active = false;
            anim.startTime = 0;
            anim.progress = 0;
            anim.params = null;
            
            // Clean up all glow effect data to prevent accumulation
            if (anim.glowEffect) {
                anim.glowEffect = null;
                anim.particleGlow = null;
                anim.glowTime = null;
                anim.glowProgress = null;
                anim.glowEnvelope = null;
            }
            // Clean up other effect data
            if (anim.fireflyEffect) {
                anim.fireflyEffect = null;
                anim.particleGlow = null;
                anim.fireflyTime = null;
            }
            if (anim.flickerEffect) {
                anim.flickerEffect = null;
                anim.particleGlow = null;
                anim.flickerTime = null;
            }
            if (anim.shimmerEffect) {
                anim.shimmerEffect = null;
                anim.particleGlow = null;
                anim.shimmerTime = null;
                anim.shimmerWave = null;
            }
            // Clean up flash wave data
            if (anim.flashWave) {
                anim.flashWave = null;
                anim.flashWaveData = null;
            }
        });
        this.activeGestures.clear();
    }
    
    /**
     * Get current active gesture information for particle system
     * @returns {Object|null} Current gesture with particleMotion and progress, or null
     */
    getCurrentGesture() {
        // Priority: Find override gestures first (like orbital, hula), then other gestures
        const overrideGestures = ['orbital', 'hula', 'wave', 'spin'];
        
        // Check override gestures first
        for (const gestureName of overrideGestures) {
            const anim = this.gestureAnimations[gestureName];
            if (anim && anim.active) {
                // Get the actual gesture configuration (uses cache if available)
                const gesture = getGesture(gestureName);
                
                // Use the gesture's config for particleMotion, or create one from gesture type
                const particleMotion = gesture?.config?.particleMotion || {
                    type: gestureName,  // This ensures the modular gesture system will find it
                    strength: anim.params?.strength || 1.0
                };
                
                const gestureInfo = {
                    name: gestureName,
                    particleMotion,
                    progress: anim.progress || 0,
                    params: anim.params
                };
                
                return gestureInfo;
            }
        }
        
        // Then check all other gestures
        for (const [gestureName, anim] of Object.entries(this.gestureAnimations)) {
            if (anim.active) {
                // Get the actual gesture configuration (uses cache if available)
                const gesture = getGesture(gestureName);
                
                // Use the gesture's config for particleMotion, or params if available
                const particleMotion = gesture?.config?.particleMotion || 
                                      anim.params?.particleMotion || 
                                      { type: gestureName, strength: anim.params?.strength || 1.0 };
                
                const gestureInfo = {
                    name: gestureName,
                    particleMotion,
                    progress: anim.progress || 0,
                    params: anim.params
                };
                
                // Include breathPhase for breathe gesture
                if (gestureName === 'breathe' && anim.breathPhase !== undefined) {
                    gestureInfo.breathPhase = anim.breathPhase;
                }
                
                return gestureInfo;
            }
        }
        return null;
    }
    
    /**
     * Apply easing function to progress
     */
    applyEasing(progress, easing) {
        switch (easing) {
        case 'linear':
            return progress;
        case 'quad':
            return progress * progress;
        case 'cubic':
            return progress * progress * progress;
        case 'sine':
            return Math.sin(progress * Math.PI / 2);
        case 'back':
            return progress * progress * (2.7 * progress - 1.7);
        default:
            return progress;
        }
    }
    
    // Individual gesture application methods
    applyBounce(anim, progress) {
        const bounce = Math.abs(Math.sin(progress * Math.PI * anim.params.frequency)) * anim.params.amplitude * this.scaleFactor;
        // Apply effects
        const multiplier = anim.params.effects && anim.params.effects.includes('gravity') ? 0.6 : 1;
        return { offsetY: -bounce * multiplier };
    }
    
    applyPulse(anim, progress) {
        const pulse = Math.sin(progress * Math.PI * anim.params.frequency);
        return {
            scale: 1 + pulse * anim.params.scaleAmount,
            glow: 1 + pulse * anim.params.glowAmount
        };
    }
    
    applyShake(anim, progress) {
        // Initialize random direction for this shake if not set
        if (!anim.randomAngle) {
            anim.randomAngle = Math.random() * Math.PI * 2; // Random angle in radians
        }
        const decay = anim.params.decay ? (1 - progress) : 1;
        const shake = Math.sin(progress * Math.PI * anim.params.frequency) * anim.params.amplitude * decay * this.scaleFactor;
        return {
            offsetX: shake * Math.cos(anim.randomAngle),
            offsetY: shake * Math.sin(anim.randomAngle)
        };
    }
    
    applySpin(anim, progress) {
        // Ensure full rotation even if progress doesn't quite reach 1.0
        const actualProgress = Math.min(progress * 1.05, 1.0); // Slight overshoot to ensure completion
        return {
            rotation: actualProgress * anim.params.rotations * 360,
            scale: 1 + Math.sin(progress * Math.PI) * anim.params.scaleAmount
        };
    }
    
    applyNod(anim, progress) {
        const nod = Math.sin(progress * Math.PI * anim.params.frequency) * anim.params.amplitude * this.scaleFactor;
        return { offsetY: nod };
    }
    
    applyTilt(anim, progress) {
        if (!anim.tiltDirection) {
            // Randomly choose left (-1) or right (1) tilt
            anim.tiltDirection = Math.random() < 0.5 ? -1 : 1;
        }
        const frequency = anim.params.frequency || 2;
        const angle = (anim.params.angle || 15) * Math.PI / 180; // Convert to radians
        const tiltProgress = Math.sin(progress * Math.PI * frequency) * anim.tiltDirection;
        
        // Apply both rotation and skew to make tilt visible on circular orb
        return { 
            rotation: tiltProgress * angle,
            // Skew the orb slightly to show tilt motion
            scaleX: 1 + Math.abs(tiltProgress) * 0.1,  // Widen when tilted
            scaleY: 1 - Math.abs(tiltProgress) * 0.05, // Compress slightly
            // Move slightly with tilt
            offsetX: tiltProgress * 10,
            offsetY: Math.abs(tiltProgress) * -5  // Lift slightly when tilted
        };
    }
    
    applyExpand(anim, progress) {
        // Use scaleAmount or scaleTarget (handle both config formats)
        // Make sure we're expanding, not contracting
        const targetScale = Math.max(anim.params.scaleAmount || anim.params.scaleTarget || 1.5, 1.0);
        const easedProgress = Math.sin(progress * Math.PI / 2); // Smooth ease-out
        const scale = 1 + (targetScale - 1) * easedProgress;
        return {
            scale,
            glow: 1 + Math.abs(anim.params.glowAmount || 0.2) * easedProgress
        };
    }
    
    applyContract(anim, progress) {
        // Use scaleAmount or scaleTarget (handle both config formats)
        const targetScale = anim.params.scaleAmount || anim.params.scaleTarget || 0.7;
        const easedProgress = Math.sin(progress * Math.PI / 2); // Smooth ease-out
        const scale = 1 + (targetScale - 1) * easedProgress;
        return {
            scale,
            glow: 1 + (anim.params.glowAmount || -0.2) * easedProgress
        };
    }
    
    applyFlash(anim, progress) {
        const flash = Math.sin(progress * Math.PI); // Quick up and down
        const glowPeak = anim.params.glowPeak || 2.0;  // Default if not defined
        const scalePeak = anim.params.scalePeak || 1.1; // Default if not defined
        return {
            glow: 1 + (glowPeak - 1) * flash,
            scale: 1 + (scalePeak - 1) * flash
        };
    }
    
    applyDrift(anim, progress) {
        // Initialize drift angle when starting (progress near 0)
        if (progress <= 0.01 && !anim.currentDriftAngle) {
            // Always pick a random angle for drift
            anim.currentDriftAngle = Math.random() * Math.PI * 2; // Random direction in radians
        }
        
        const distance = anim.params.distance * Math.sin(progress * Math.PI) * this.scaleFactor;
        const angle = anim.currentDriftAngle || 0;
        
        // Clear the angle when animation completes
        if (progress >= 0.99) {
            anim.currentDriftAngle = null;
        }
        
        return {
            offsetX: Math.cos(angle) * distance,
            offsetY: Math.sin(angle) * distance
        };
    }
    
    applyStretch(anim, progress) {
        const stretch = Math.sin(progress * Math.PI * anim.params.frequency);
        // Note: We'd need to handle scaleX/scaleY separately for proper stretch
        // For now, average them
        const avgScale = (anim.params.scaleX + anim.params.scaleY) / 2;
        return { scale: 1 + (avgScale - 1) * stretch };
    }
    
    applyGlow(anim, progress) {
        // Glow effect - pure luminosity like pulse but without movement
        // Copy of pulse logic but focused only on glow

        const glowPulse = Math.sin(progress * Math.PI * anim.params.frequency);

        return {
            scale: 1 + glowPulse * (anim.params.scaleAmount || 0.1), // Very subtle scale like new glow config
            glow: 1 + glowPulse * (anim.params.glowAmount || 0.8)    // Strong glow like new glow config
        };
    }
    
    applyFlashWave(anim, progress) {
        // Wave-like flash that emanates outward
        // Store wave state in the animation object
        if (!anim.flashWave) {
            anim.flashWave = {
                innerRadius: 0,
                outerRadius: 0,
                maxRadius: 3.0 // How far the wave travels (relative to core)
            };
        }
        
        // Update wave radius based on progress
        anim.flashWave.outerRadius = progress * anim.flashWave.maxRadius;
        anim.flashWave.innerRadius = Math.max(0, (progress - 0.1) * anim.flashWave.maxRadius);
        
        // Fade intensity as wave travels outward
        const waveIntensity = Math.max(0, 1 - progress * 0.7);
        
        // Store wave data for renderer to use
        anim.flashWaveData = {
            innerRadius: anim.flashWave.innerRadius,
            outerRadius: anim.flashWave.outerRadius,
            intensity: waveIntensity
        };
        
        // Return a very subtle glow increase at the core
        return {
            glow: 1 + waveIntensity * 0.3, // Very subtle core glow
            flashWave: anim.flashWaveData // Pass wave data to renderer
        };
    }
    
    applyFlicker(anim, progress) {
        // Flicker effect - particles shimmer with wave-like pulsing
        const intensity = anim.params?.intensity || 2.0;
        const shimmerSpeed = anim.params?.speed || 3;
        
        // Smooth sine wave for shimmer
        const glow = 1 + Math.sin(progress * Math.PI * 2 * shimmerSpeed) * intensity * 0.3;
        
        // Slight horizontal wave motion
        const waveX = Math.sin(progress * Math.PI * 4) * 5 * this.scaleFactor;
        
        // Create time-based shimmer for particles
        const time = Date.now() * 0.001; // Convert to seconds
        
        // Main shimmer pulse
        const mainPulse = Math.sin(progress * Math.PI * shimmerSpeed * 2) * 0.5 + 0.5;
        
        return {
            offsetX: waveX,
            glow,
            particleGlow: intensity * mainPulse, // Intensity for particles
            flickerTime: time, // Pass time for particle calculations
            flickerEffect: true // Flag to enable flicker effect on particles (shimmer-like)
        };
    }
    
    applyVibrate(anim, progress) {
        // Initialize random vibration pattern if not set
        if (!anim.vibrateAngles) {
            anim.vibrateAngles = {
                x: Math.random() * 2 - 1, // Random factor between -1 and 1
                y: Math.random() * 2 - 1
            };
            // Normalize to unit vector
            const mag = Math.sqrt(anim.vibrateAngles.x ** 2 + anim.vibrateAngles.y ** 2);
            anim.vibrateAngles.x /= mag;
            anim.vibrateAngles.y /= mag;
        }
        const vibration = Math.sin(progress * Math.PI * 2 * anim.params.frequency) * anim.params.amplitude * this.scaleFactor;
        return {
            offsetX: vibration * anim.vibrateAngles.x,
            offsetY: vibration * anim.vibrateAngles.y
        };
    }
    
    applyWave(anim, progress) {
        // Completely rewritten wave - a graceful, flowing infinity symbol motion
        const amp = (anim.params.amplitude || 40) * this.scaleFactor;
        
        // Create a smooth infinity symbol (∞) pattern
        // This feels more like a natural greeting wave
        const t = progress * Math.PI * 2;
        
        // Infinity symbol parametric equations
        // X: figure-8 horizontal motion
        const infinityX = Math.sin(t) * amp;
        
        // Y: gentle vertical bob that rises during the wave
        // Creates a "lifting" feeling like a real wave hello
        const liftAmount = -Math.sin(progress * Math.PI) * amp * 0.3; // Lift up during wave
        const infinityY = Math.sin(t * 2) * amp * 0.2 + liftAmount;
        
        // Add a subtle tilt that follows the wave direction
        // Makes the orb "lean into" the wave
        const tilt = Math.sin(t) * 5; // ±5 degrees of tilt
        
        // Gentle scale pulse for emphasis
        const scalePulse = 1 + Math.sin(progress * Math.PI * 2) * 0.05; // 5% scale variation
        
        // Glow brightens slightly during wave
        const glowPulse = 1 + Math.sin(progress * Math.PI) * 0.2; // 20% glow increase
        
        return {
            offsetX: infinityX,
            offsetY: infinityY,
            rotation: tilt,
            scale: scalePulse,
            glow: glowPulse
        };
    }
    
    applyBreathe(anim, progress) {
        // Deliberate, mindful breathing animation
        const {params} = anim;
        const holdPercent = params.particleMotion?.holdPercent || 0.1;
        
        // Create a breathing curve with holds at peaks
        let breathPhase;
        if (progress < 0.4) {
            // Inhale phase (0-40%)
            breathPhase = Math.sin((progress / 0.4) * Math.PI / 2);
        } else if (progress < 0.4 + holdPercent) {
            // Hold at full inhale
            breathPhase = 1.0;
        } else if (progress < 0.9) {
            // Exhale phase  
            const exhaleProgress = (progress - 0.4 - holdPercent) / (0.5 - holdPercent);
            breathPhase = Math.cos(exhaleProgress * Math.PI / 2);
        } else {
            // Hold at full exhale
            breathPhase = 0;
        }
        
        // Apply scale changes - expand on inhale
        const scaleAmount = params.scaleAmount || 0.25;
        const scale = 1 + breathPhase * scaleAmount;
        
        // Apply glow changes - brighten on inhale
        const glowAmount = params.glowAmount || 0.4;
        const glow = 1 + breathPhase * glowAmount;
        
        // Store breath phase for particle system
        anim.breathPhase = breathPhase;
        
        return {
            scale,
            glow,
            breathPhase // Pass to particles for synchronized motion
        };
    }
    
    applyMorph(anim, progress) {
        // Fluid morphing effect
        const morph = Math.sin(progress * Math.PI * 2);
        return {
            scale: 1 + morph * 0.1,
            rotation: morph * 10
        };
    }
    
    applySlowBlink(anim, progress) {
        // Simulate blinking by scaling vertically
        let scaleY = 1;
        if (progress < 0.3) {
            // Closing
            scaleY = 1 - (progress / 0.3);
        } else if (progress < 0.5) {
            // Closed
            scaleY = 0;
        } else if (progress < 0.8) {
            // Opening
            scaleY = (progress - 0.5) / 0.3;
        } else {
            // Open
            scaleY = 1;
        }
        
        // Since we can't do scaleY separately, dim the orb instead
        return {
            glow: scaleY
        };
    }
    
    applyLook(anim, progress) {
        // Initialize target position if not set
        if (!anim.targetX) {
            const direction = anim.params.lookDirection;
            const distance = anim.params.lookDistance * 50 * this.scaleFactor; // Convert to pixels and scale
            
            switch(direction) {
            case 'left':
                anim.targetX = -distance;
                anim.targetY = 0;
                break;
            case 'right':
                anim.targetX = distance;
                anim.targetY = 0;
                break;
            case 'up':
                anim.targetX = 0;
                anim.targetY = -distance;
                break;
            case 'down':
                anim.targetX = 0;
                anim.targetY = distance;
                break;
            default: { // random
                const angle = Math.random() * Math.PI * 2;
                anim.targetX = Math.cos(angle) * distance;
                anim.targetY = Math.sin(angle) * distance;
                break;
            }
            }
        }
        
        // Smooth look with hold
        let lookProgress = progress;
        if (progress < 0.3) {
            // Move to target
            lookProgress = progress / 0.3;
        } else if (progress < 0.7) {
            // Hold
            lookProgress = 1;
        } else {
            // Return
            lookProgress = 1 - (progress - 0.7) / 0.3;
        }
        
        return {
            offsetX: anim.targetX * lookProgress,
            offsetY: anim.targetY * lookProgress
        };
    }
    
    applySettle(anim, progress) {
        // Damped oscillation
        const wobble = Math.sin(progress * Math.PI * anim.params.wobbleFreq) * 
                      Math.exp(-progress * 3) * 20 * this.scaleFactor;
        return {
            offsetY: wobble,
            scale: 1 + wobble * 0.01
        };
    }
    
    applyBreathIn(anim, progress) {
        const breathScale = 1 + (anim.params.scaleAmount - 1) * Math.sin(progress * Math.PI / 2);
        return {
            scale: breathScale
        };
    }
    
    applyBreathOut(anim, progress) {
        const breathScale = 1 - (1 - anim.params.scaleAmount) * Math.sin(progress * Math.PI / 2);
        return {
            scale: breathScale
        };
    }
    
    applyBreathHold(anim, progress) {
        // Hold at expanded state
        return {
            scale: anim.params.scaleAmount
        };
    }
    
    applyBreathHoldEmpty(anim, progress) {
        // Hold at contracted state
        return {
            scale: anim.params.scaleAmount
        };
    }
    
    applyJump(anim, progress) {
        let yOffset = 0;
        let scale = 1;
        
        if (progress < 0.2) {
            // Squash phase
            const squashProgress = progress / 0.2;
            scale = 1 - (1 - anim.params.squashAmount) * squashProgress;
        } else if (progress < 0.7) {
            // Jump phase
            const jumpProgress = (progress - 0.2) / 0.5;
            const jumpCurve = Math.sin(jumpProgress * Math.PI);
            yOffset = -anim.params.jumpHeight * jumpCurve * this.scaleFactor;
            scale = anim.params.squashAmount + 
                   (anim.params.stretchAmount - anim.params.squashAmount) * jumpCurve;
        } else {
            // Landing phase
            const landProgress = (progress - 0.7) / 0.3;
            scale = anim.params.stretchAmount - 
                   (anim.params.stretchAmount - 1) * landProgress;
        }
        
        return {
            offsetY: yOffset,
            scale
        };
    }
    
    applySway(anim, progress) {
        // Gentle pendulum-like swaying motion for the core
        const swayAmplitude = (anim.params?.amplitude || 30) * this.scaleFactor;
        const swayFrequency = anim.params?.frequency || 1;
        
        // Sway side to side with a gentle ease
        const swayX = Math.sin(progress * Math.PI * 2 * swayFrequency) * swayAmplitude;
        
        // Slight vertical bob for realism
        const bobY = Math.sin(progress * Math.PI * 4 * swayFrequency) * swayAmplitude * 0.1;
        
        // Slight rotation to match the sway
        const rotation = Math.sin(progress * Math.PI * 2 * swayFrequency) * 5; // 5 degrees max
        
        return {
            offsetX: swayX,
            offsetY: bobY,
            rotation
        };
    }
    
    applyRain(anim, progress) {
        // Rain effect - triggers falling particle behavior
        // The actual particle motion is handled by the particle system
        // This just adds a subtle downward drift to the core
        
        const rainIntensity = anim.params?.intensity || 1.0;
        
        // Gentle downward drift
        const driftY = progress * 10 * this.scaleFactor * rainIntensity;
        
        // Slight sway as if affected by wind
        const swayX = Math.sin(progress * Math.PI * 4) * 5 * this.scaleFactor;
        
        // Trigger particle falling effect through the renderer
        if (this.renderer && this.renderer.particleSystem) {
            // Enable falling behavior for particles during rain
            this.renderer.particleSystem.setGestureBehavior('falling', progress > 0 && progress < 1);
        }
        
        return {
            offsetX: swayX,
            offsetY: driftY,
            particleEffect: 'falling'  // Signal to particle system
        };
    }
    
    applyFloat(anim, progress) {
        // Ethereal floating motion with both vertical and horizontal drift
        const floatAmplitude = (anim.params?.amplitude || 20) * this.scaleFactor;
        const floatSpeed = anim.params?.speed || 1;
        
        // Primary vertical float with sine wave
        const floatY = Math.sin(progress * Math.PI * 2 * floatSpeed) * floatAmplitude;
        
        // Secondary horizontal drift for natural movement
        const driftX = Math.sin(progress * Math.PI * 3 * floatSpeed) * floatAmplitude * 0.3;
        
        // Slight scale pulsation for breathing effect
        const scalePulse = 1 + Math.sin(progress * Math.PI * 4 * floatSpeed) * 0.02;
        
        return {
            offsetX: driftX,
            offsetY: floatY,
            scale: scalePulse
        };
    }
    
    applyOrbital(anim, progress) {
        // Orbital motion - particles orbit around core, core stays still
        // This gesture is for particle motion only, not core movement
        return {
            // No core movement - orbital is a particle-only effect
            offsetX: 0,
            offsetY: 0
        };
    }
    
    applyHula(anim, progress) {
        // Hula motion - horizontal figure-8 pattern
        const amplitude = (anim.params?.amplitude || 40) * this.scaleFactor;
        const t = progress * Math.PI * 2;
        
        // Figure-8 parametric equations
        const x = Math.sin(t) * amplitude;
        const y = Math.sin(t * 2) * amplitude * 0.5;
        
        return {
            offsetX: x,
            offsetY: y
        };
    }
    
    applySparkle(anim, progress) {
        // Sparkle effect - make particles glow like fireflies
        // Each particle gets its own random phase for async blinking
        const intensity = anim.params?.intensity || 2.0;
        
        // Create firefly-like glow pattern for particles
        // Using time-based phase shifting for each particle
        const time = Date.now() * 0.001; // Convert to seconds
        
        // Main glow pulse for the effect
        const mainPulse = Math.sin(progress * Math.PI * 4) * 0.3 + 0.7;
        
        // This will be used by particles to create firefly effect
        // Each particle will add its own random offset to this
        return {
            particleGlow: intensity, // Intensity for individual particles
            glow: mainPulse, // Gentle overall glow
            fireflyTime: time, // Pass time for particle calculations
            fireflyEffect: true // Flag to enable firefly effect on particles
        };
    }
    
    applyShimmer(anim, progress) {
        // Shimmer effect - subtle, ethereal glow that travels across surface
        // Like moonlight on calm water
        
        const time = Date.now() * 0.001; // Current time in seconds
        const intensity = anim.params?.intensity || 0.3; // Very subtle
        
        // Single slow wave for gentle shimmer
        const wave = Math.sin(time * 2 + progress * Math.PI * 2);
        
        // Very subtle glow variation
        const glowEffect = 1 + wave * intensity;
        
        // Tiny breathing effect
        const scaleEffect = 1 + wave * 0.01; // Just 1% variation
        
        return {
            offsetX: 0, // No movement
            offsetY: 0, // No movement
            glow: glowEffect,
            scale: scaleEffect,
            // Particle-specific data
            particleGlow: 1 + wave * 0.2, // Very subtle particle effect
            shimmerTime: time,
            shimmerWave: wave,
            shimmerEffect: true // Flag to enable shimmer effect on particles
        };
    }
    
    applyWiggle(anim, progress) {
        // Hip-hop wiggle - 4 phase: center -> side -> opposite -> side -> center
        const amplitude = (anim.params?.amplitude || 15) * this.scaleFactor;
        
        // Random starting direction (1 for right, -1 for left)
        if (anim.wiggleDirection === undefined) {
            anim.wiggleDirection = Math.random() < 0.5 ? 1 : -1;
        }
        const direction = anim.wiggleDirection;
        
        // 4-phase movement pattern
        let wiggleX = 0;
        let rotation = 0;
        
        if (progress < 0.25) {
            // Phase 1: Center to first side (0-25%)
            const phase = progress / 0.25;
            wiggleX = amplitude * direction * phase;
            rotation = 3 * direction * phase;
        } else if (progress < 0.5) {
            // Phase 2: First side to opposite side (25-50%)
            const phase = (progress - 0.25) / 0.25;
            wiggleX = amplitude * direction * (1 - 2 * phase);
            rotation = 3 * direction * (1 - 2 * phase);
        } else if (progress < 0.75) {
            // Phase 3: Opposite side back to first side (50-75%)
            const phase = (progress - 0.5) / 0.25;
            wiggleX = amplitude * -direction * (1 - 2 * phase);
            rotation = 3 * -direction * (1 - 2 * phase);
        } else {
            // Phase 4: First side back to center (75-100%)
            const phase = (progress - 0.75) / 0.25;
            wiggleX = amplitude * direction * (1 - phase);
            rotation = 3 * direction * (1 - phase);
        }
        
        // Subtle bounce synced with movement
        const bounceY = Math.abs(Math.sin(progress * Math.PI * 4)) * amplitude * 0.15;
        
        return {
            offsetX: wiggleX,
            offsetY: -bounceY,
            rotation
        };
    }
    
    applyGroove(anim, progress) {
        // Groove motion - smooth, flowing dance movement
        const amplitude = (anim.params?.amplitude || 25) * this.scaleFactor;
        
        // Smoother wave pattern with organic flow
        const wave1 = Math.sin(progress * Math.PI * 2) * amplitude;
        const wave2 = Math.sin(progress * Math.PI * 3 + 0.5) * amplitude * 0.4;
        const grooveX = wave1 + wave2;
        
        // Gentle vertical bob with offset timing
        const grooveY = Math.sin(progress * Math.PI * 4 + 0.3) * amplitude * 0.25;
        
        // Subtle pulse that breathes naturally
        const scale = 1 + Math.sin(progress * Math.PI * 3 + 0.7) * 0.03;
        
        // Slight rotation for more natural movement
        const rotation = Math.sin(progress * Math.PI * 2 + 0.2) * 8;
        
        return {
            offsetX: grooveX,
            offsetY: grooveY,
            scale,
            rotation
        };
    }
    
    applyPoint(anim, progress) {
        // Point gesture - directional lean/stretch with return to center
        
        // Random direction if not specified - only left or right
        if (anim.pointDirection === undefined) {
            // Randomly choose left (1) or right (-1)
            anim.pointDirection = Math.random() < 0.5 ? -1 : 1;
        }
        
        const direction = anim.params?.direction !== undefined ? anim.params.direction : anim.pointDirection;
        const distance = (anim.params?.distance || 40) * this.scaleFactor;
        
        // Three-phase animation:
        // 0.0-0.4: Move to point position
        // 0.4-0.6: Hold at point
        // 0.6-1.0: Return to center
        let motionProgress;
        let scaleProgress;
        
        if (progress < 0.4) {
            // Phase 1: Move to point (ease out)
            motionProgress = 1 - Math.pow(1 - (progress / 0.4), 3);
            scaleProgress = motionProgress;
        } else if (progress < 0.6) {
            // Phase 2: Hold at point
            motionProgress = 1.0;
            scaleProgress = 1.0;
        } else {
            // Phase 3: Return to center (ease in)
            motionProgress = Math.pow(1 - ((progress - 0.6) / 0.4), 3);
            scaleProgress = motionProgress;
        }
        
        // Move in direction (direction is -1 for left, 1 for right)
        const offsetX = direction * distance * motionProgress;
        const offsetY = -Math.abs(distance * 0.15 * motionProgress); // Slight upward movement when pointing
        
        // Stretch effect in pointing direction
        const scale = 1 + 0.15 * scaleProgress; // 15% stretch
        
        // Add slight tilt when pointing
        const rotation = direction * 5 * scaleProgress; // Tilt 5 degrees in pointing direction
        
        return {
            offsetX,
            offsetY,
            scale,
            rotation
        };
    }
    
    applyLean(anim, progress) {
        // Lean gesture - tilt to one side
        const angle = anim.params?.angle || 15; // Degrees
        const side = anim.params?.side || 1; // 1 for right, -1 for left
        
        // Smooth ease in-out
        const easedProgress = Math.sin(progress * Math.PI);
        
        // Apply rotation and slight offset
        const rotation = angle * side * easedProgress;
        const offsetX = side * 10 * this.scaleFactor * easedProgress;
        
        return {
            offsetX,
            rotation
        };
    }
    
    applyReach(anim, progress) {
        // Reach gesture - stretch upward or outward
        const direction = anim.params?.direction || -Math.PI/2; // Default upward
        const distance = (anim.params?.distance || 40) * this.scaleFactor;
        
        // Two-phase motion: reach out, then return
        let motionProgress;
        if (progress < 0.4) {
            // Reaching phase
            motionProgress = progress / 0.4;
        } else if (progress < 0.6) {
            // Hold phase
            motionProgress = 1;
        } else {
            // Return phase
            motionProgress = 1 - (progress - 0.6) / 0.4;
        }
        
        // Apply easing
        motionProgress = motionProgress * motionProgress * (3 - 2 * motionProgress);
        
        const offsetX = Math.cos(direction) * distance * motionProgress;
        const offsetY = Math.sin(direction) * distance * motionProgress;
        
        // Stretch slightly when reaching
        const scale = 1 + motionProgress * 0.15;
        
        return {
            offsetX,
            offsetY,
            scale
        };
    }
    
    applyHeadBob(anim, progress) {
        // Head bob motion - rhythmic vertical movement
        const amplitude = (anim.params?.amplitude || 20) * this.scaleFactor;
        const frequency = anim.params?.frequency || 2;
        
        // Vertical bob with sharp down, smooth up
        const bobPhase = (progress * frequency) % 1;
        let bobY;
        if (bobPhase < 0.3) {
            // Quick down
            bobY = -amplitude * (bobPhase / 0.3);
        } else {
            // Smooth up
            bobY = -amplitude * (1 - (bobPhase - 0.3) / 0.7);
        }
        
        // Slight forward tilt on the down beat
        const rotation = bobPhase < 0.3 ? -3 : 0;
        
        return {
            offsetY: bobY,
            rotation
        };
    }
    
    applyOrbit(anim, progress) {
        // Orbit motion - circular path around center
        const radius = (anim.params?.radius || 30) * this.scaleFactor;
        const speed = anim.params?.speed || 1;
        
        // Circular motion
        const angle = progress * Math.PI * 2 * speed;
        const offsetX = Math.cos(angle) * radius;
        const offsetY = Math.sin(angle) * radius;
        
        return {
            offsetX,
            offsetY
        };
    }

    // Individual gesture methods - these will be moved from EmotiveRenderer
    startBounce() { this.startGesture('bounce'); }
    startPulse() { this.startGesture('pulse'); }
    startShake() { this.startGesture('shake'); }
    startSpin() { this.startGesture('spin'); }
    startNod() { this.startGesture('nod'); }
    startTilt() { this.startGesture('tilt'); }
    startExpand() { this.startGesture('expand'); }
    startContract() { this.startGesture('contract'); }
    startFlash() { this.startGesture('flash'); }
    startDrift() { this.startGesture('drift'); }
    startStretch() { this.startGesture('stretch'); }
    startGlow() { this.startGesture('glow'); }
    startFlicker() { this.startGesture('flicker'); }
    startVibrate() { this.startGesture('vibrate'); }
    startOrbital() { this.startGesture('orbital'); }
    startHula() { this.startGesture('hula'); }
    startWave() { this.startGesture('wave'); }
    startBreathe() { this.startGesture('breathe'); }
    startMorph() { this.startGesture('morph'); }
    startSlowBlink() { this.startGesture('slowBlink'); }
    startLook() { this.startGesture('look'); }
    startSettle() { this.startGesture('settle'); }
    startBreathIn() { this.startGesture('breathIn'); }
    startBreathOut() { this.startGesture('breathOut'); }
    startBreathHold() { this.startGesture('breathHold'); }
    startBreathHoldEmpty() { this.startGesture('breathHoldEmpty'); }
    startJump() { this.startGesture('jump'); }
    startSway() { this.startGesture('sway'); }
    startFloat() { this.startGesture('float'); }
    startRain() { this.startGesture('rain'); }
    startRunningMan() { this.startGesture('runningman'); }
    startCharleston() { this.startGesture('charleston'); }
    startSparkle() { this.startGesture('sparkle'); }
    startShimmer() { this.startGesture('shimmer'); }
    startWiggle() { this.startGesture('wiggle'); }
    startGroove() { this.startGesture('groove'); }
    startPoint() { this.startGesture('point'); }
    startLean() { this.startGesture('lean'); }
    startReach() { this.startGesture('reach'); }
    startHeadBob() { this.startGesture('headBob'); }
    startOrbit() { this.startGesture('orbit'); }
    
    applyRunningMan(anim, progress) {
        // Simple running shuffle - quick slide and step
        const slide = Math.sin(progress * Math.PI * 4) * 20 * this.scaleFactor;
        const step = -Math.abs(Math.sin(progress * Math.PI * 8)) * 10 * this.scaleFactor;
        
        return {
            offsetX: slide,
            offsetY: step,
            rotation: slide * 0.3,
            scaleY: 1 - Math.abs(Math.sin(progress * Math.PI * 8)) * 0.05
        };
    }
    
    applyCharleston(anim, progress) {
        // Charleston - crisscross kicks
        const kick = Math.sin(progress * Math.PI * 8) * 25 * this.scaleFactor;
        const hop = -Math.abs(Math.sin(progress * Math.PI * 8)) * 10 * this.scaleFactor;
        
        return {
            offsetX: kick,
            offsetY: hop,
            rotation: kick * 0.6,
            scaleY: 1 - Math.abs(Math.sin(progress * Math.PI * 8)) * 0.06
        };
    }
    
    startRunningManGesture() { this.startGesture('runningman'); }
    startCharlestonGesture() { this.startGesture('charleston'); }

    /**
     * Pause current animation (called on tab switch)
     */
    pauseCurrentAnimation() {
        // Store pause time for all active animations
        const now = performance.now();
        for (const [type, anim] of Object.entries(this.gestureAnimations)) {
            if (anim.active) {
                anim.pausedAt = now;
                anim.pausedProgress = anim.progress;
            }
        }
        this.isPaused = true;
    }

    /**
     * Resume animations after pause
     */
    resumeAnimation() {
        if (!this.isPaused) return;

        const now = performance.now();
        for (const [type, anim] of Object.entries(this.gestureAnimations)) {
            if (anim.active && anim.pausedAt) {
                // Adjust start time to account for pause
                const pauseDuration = now - anim.pausedAt;
                if (anim.startTime) {
                    anim.startTime += pauseDuration;
                }
                // Clear pause state
                delete anim.pausedAt;
                delete anim.pausedProgress;
            }
        }
        this.isPaused = false;
    }

    /**
     * Reset all gesture animations
     */
    reset() {
        // Clear all active animations
        for (const [type, anim] of Object.entries(this.gestureAnimations)) {
            anim.active = false;
            anim.progress = 0;
            anim.params = {};
            delete anim.startTime;
            delete anim.pausedAt;
            delete anim.pausedProgress;
        }
        this.activeGestures.clear();
        this.isPaused = false;
    }
}

/**
 * ColorUtilities - Color manipulation and transition utilities for EmotiveRenderer
 * @module core/renderer/ColorUtilities
 */

class ColorUtilities {
    constructor() {
        this.colorTransition = null;
    }

    /**
     * Apply undertone modifiers to current visual properties
     * Will be moved from EmotiveRenderer
     */
    applyUndertoneModifiers(undertone, visualProperties) {
        // Implementation will be moved here
        return visualProperties;
    }

    /**
     * Apply undertone to a color
     * @param {string} baseColor - Base hex color
     * @param {string|Object} undertone - Undertone modifier or weighted object
     * @returns {string} Modified hex color
     */
    applyUndertoneToColor(baseColor, undertone) {
        // Handle weighted modifier for smooth transitions
        if (undertone && typeof undertone === 'object' && undertone.weight !== undefined) {
            const {weight} = undertone;
            const undertoneType = undertone.type || 'clear';
            
            if (undertoneType === 'clear' || weight === 0) {
                return baseColor;
            }
            
            // Get full saturation adjustment for this undertone
            const fullySaturated = this.applyUndertoneSaturation(baseColor, undertoneType);
            
            // Interpolate between base and fully saturated based on weight
            const rgb1 = this.hexToRgb(baseColor);
            const rgb2 = this.hexToRgb(fullySaturated);
            
            const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * weight);
            const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * weight);
            const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * weight);
            
            return this.rgbToHex(r, g, b);
        }
        
        // Direct string-based undertone - use saturation system
        if (!undertone || undertone === 'clear') return baseColor;
        
        return this.applyUndertoneSaturation(baseColor, undertone);
    }

    /**
     * Convert hex color to RGB
     * @param {string} hex - Hex color string
     * @returns {Object} RGB values
     */
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    /**
     * Convert RGB to HSL
     */
    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
            case g: h = ((b - r) / d + 2) / 6; break;
            case b: h = ((r - g) / d + 4) / 6; break;
            }
        }

        return { h: h * 360, s: s * 100, l: l * 100 }; // Convert s and l to percentages
    }

    /**
     * Convert HSL to hex color
     */
    hslToHex(h, s, l) {
        h = h / 360;
        s = s / 100;
        l = l / 100;

        let r, g, b;

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        const toHex = x => {
            const hex = Math.round(x * 255).toString(16);
            return hex.length === 1 ? `0${hex}` : hex;
        };

        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    /**
     * Apply undertone saturation adjustment
     */
    applyUndertoneSaturation(baseColor, undertone) {
        const rgb = this.hexToRgb(baseColor);
        const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
        
        // Saturation adjustments by undertone
        const saturationModifiers = {
            // Positive undertones (higher saturation)
            'intense': 1.5,      // +50% saturation (very vivid)
            'confident': 1.3,    // +30% saturation (bold)
            'energetic': 1.2,    // +20% saturation (vibrant)
            'upbeat': 1.2,       // +20% saturation
            // Neutral/slightly nervous
            'nervous': 1.15,     // +15% saturation (slightly heightened)
            // Negative undertones (lower saturation)
            'mellow': 0.8,       // -20% saturation  
            'tired': 0.8,        // -20% saturation (washed out)
            'subdued': 0.5       // -50% saturation (ghostly)
        };
        
        const modifier = saturationModifiers[undertone] || 1.0;
        hsl.s = Math.min(100, hsl.s * modifier);
        
        return this.hslToHex(hsl.h, hsl.s, hsl.l);
    }
    
    /**
     * Convert RGB values to hex
     */
    rgbToHex(r, g, b) {
        const toHex = x => {
            const hex = Math.round(x).toString(16);
            return hex.length === 1 ? `0${hex}` : hex;
        };
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    
    /**
     * Start a color transition
     */
    startColorTransition(targetColor, targetIntensity, duration = 1500) {
        // Don't start a new transition if we're already at the target
        if (this.currentColor === targetColor && 
            this.currentIntensity === targetIntensity) {
            return;
        }
        
        this.colorTransition = {
            active: true,
            fromColor: this.currentColor || '#ffffff',
            toColor: targetColor,
            fromIntensity: this.currentIntensity || 1.0,
            toIntensity: targetIntensity,
            progress: 0,
            startTime: performance.now(),
            duration
        };
    }

    /**
     * Update color transition
     */
    updateColorTransition(deltaTime) {
        if (!this.colorTransition || !this.colorTransition.active) return null;
        
        const elapsed = performance.now() - this.colorTransition.startTime;
        const progress = Math.min(elapsed / this.colorTransition.duration, 1);
        
        // Use ease-out-quad for smooth deceleration
        const eased = 1 - Math.pow(1 - progress, 2);
        
        // Interpolate color
        const from = this.hexToRgb(this.colorTransition.fromColor);
        const to = this.hexToRgb(this.colorTransition.toColor);
        
        const r = Math.round(from.r + (to.r - from.r) * eased);
        const g = Math.round(from.g + (to.g - from.g) * eased);
        const b = Math.round(from.b + (to.b - from.b) * eased);
        
        const currentColor = this.rgbToHex(r, g, b);
        const currentIntensity = this.colorTransition.fromIntensity + 
            (this.colorTransition.toIntensity - this.colorTransition.fromIntensity) * eased;
        
        // Store current values
        this.currentColor = currentColor;
        this.currentIntensity = currentIntensity;
        
        // Complete transition if done
        if (progress >= 1) {
            this.colorTransition.active = false;
        }
        
        return {
            color: currentColor,
            intensity: currentIntensity
        };
    }
}

/**
 * SpecialEffects - Special visual effects for EmotiveRenderer
 * @module core/renderer/SpecialEffects
 */

class SpecialEffects {
    constructor(renderer) {
        this.renderer = renderer;
        this.ctx = renderer.ctx;
        this.canvas = renderer.canvasManager?.canvas || renderer.canvas;
        
        // Effect states
        this.recordingActive = false;
        this.sleepMode = false;
        this.speakingActive = false;
        this.zenModeActive = false;
        
        // Speaking rings
        this.speakingRings = [];
        this.ringSpawnTimer = 0;
        this.ringSpawnInterval = 300;
        this.maxRings = 3;
        
        // Sleep Z's
        this.sleepZ = [];
        
        // Sparkle particles
        this.sparkles = [];
        
        // Chromatic aberration effect
        this.chromaticAberration = {
            active: false,
            intensity: 0,
            targetIntensity: 0,
            fadeSpeed: 0.01, // Very slow fade for testing
            maxOffset: 30 // Much larger offset for testing
        };
        
        // Helper method references
        this.scaleValue = value => renderer.scaleValue(value);
        this.hexToRgba = (hex, alpha) => renderer.hexToRgba(hex, alpha);
    }

    /**
     * Render recording glow effect
     */
    renderRecordingGlow(x, y, radius, intensity) {
        const {ctx} = this;
        const glowSize = radius * 2.5;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize);
        
        gradient.addColorStop(0, `rgba(255, 0, 0, ${0.3 * intensity})`);
        gradient.addColorStop(0.5, `rgba(255, 0, 0, ${0.15 * intensity})`);
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = gradient;
        ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        ctx.restore();
    }

    /**
     * Render recording indicator
     */
    renderRecordingIndicator(x, y) {
        const time = Date.now() / 1000;
        const pulse = 0.8 + Math.sin(time * 2) * 0.2;
        
        this.ctx.save();
        this.ctx.translate(x, y);
        
        // Outer glow for text
        this.ctx.shadowBlur = this.scaleValue(15);
        this.ctx.shadowColor = `rgba(255, 0, 0, ${pulse * 0.8})`;
        
        // Main REC text
        const recSize = this.scaleValue(80);
        this.ctx.font = `italic 900 ${recSize}px "Poppins", sans-serif`;
        this.ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText('REC', 0, 0);
        
        // Inner highlight
        this.ctx.shadowBlur = 0;
        this.ctx.font = `italic 900 ${recSize - 1}px "Poppins", sans-serif`;
        this.ctx.fillStyle = `rgba(255, 255, 255, ${pulse * 0.3})`;
        this.ctx.fillText('REC', -0.5, -0.5);
        
        this.ctx.restore();
    }

    /**
     * Render sleep indicator with Z's
     */
    renderSleepIndicator(x, y, deltaTime) {
        // Spawn new Z periodically
        this.ringSpawnTimer += deltaTime;
        if (this.ringSpawnTimer >= 2000 && this.sleepZ.length < 3) {
            const weights = ['300', '500', '700', '900'];
            const randomWeight = weights[Math.floor(Math.random() * weights.length)];
            const randomCase = Math.random() > 0.5 ? 'Z' : 'z';
            
            this.sleepZ.push({
                x: x + Math.random() * this.scaleValue(30) - this.scaleValue(15),
                y: y + this.scaleValue(80),
                size: this.scaleValue((24 + Math.random() * 8) * 3),
                opacity: 1.0,
                speed: -0.025,
                drift: Math.random() * this.scaleValue(20) - this.scaleValue(10),
                lifetime: 0,
                rotation: Math.random() * 30 - 15,
                text: randomCase,
                weight: randomWeight
            });
            this.ringSpawnTimer = 0;
        }
        
        // Update and render Z's
        this.sleepZ = this.sleepZ.filter(z => {
            z.lifetime += deltaTime;
            z.y += z.speed * deltaTime;
            z.x += Math.sin(z.lifetime * 0.0008) * z.drift * 0.008;
            z.rotation += deltaTime * 0.01;
            
            // Gradient fade out
            const fadeStart = 2000;
            const fadeEnd = 4000;
            if (z.lifetime < fadeStart) {
                z.opacity = 1.0;
            } else if (z.lifetime < fadeEnd) {
                z.opacity = 1.0 - ((z.lifetime - fadeStart) / (fadeEnd - fadeStart));
            } else {
                z.opacity = 0;
            }
            
            if (z.opacity > 0.01) {
                this.ctx.save();
                this.ctx.translate(z.x, z.y);
                this.ctx.rotate(z.rotation * Math.PI / 180);
                
                const baseColor = this.renderer.state.glowColor || '#4a90e2';
                
                // Outer glow
                this.ctx.shadowBlur = this.scaleValue(15);
                this.ctx.shadowColor = this.hexToRgba(baseColor, z.opacity * 0.5);
                
                // Main Z with gradient
                const gradient = this.ctx.createLinearGradient(-z.size/2, -z.size/2, z.size/2, z.size/2);
                gradient.addColorStop(0, this.hexToRgba(baseColor, z.opacity));
                gradient.addColorStop(0.5, this.hexToRgba('#ffffff', z.opacity * 0.9));
                gradient.addColorStop(1, this.hexToRgba(baseColor, z.opacity * 0.7));
                
                this.ctx.font = `italic ${z.weight || '900'} ${z.size}px 'Poppins', sans-serif`;
                this.ctx.fillStyle = gradient;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(z.text || 'Z', 0, 0);
                
                // Inner highlight
                this.ctx.shadowBlur = 0;
                this.ctx.font = `italic ${z.weight || '900'} ${z.size * 0.9}px 'Poppins', sans-serif`;
                this.ctx.fillStyle = this.hexToRgba('#ffffff', z.opacity * 0.3);
                this.ctx.fillText(z.text || 'Z', -1, -1);
                
                this.ctx.restore();
                return true;
            }
            return false;
        });
    }

    /**
     * Render speaking rings effect
     */
    renderSpeakingRings(centerX, centerY, coreRadius, deltaTime) {
        // Spawn new rings periodically
        this.ringSpawnTimer += deltaTime;
        if (this.ringSpawnTimer >= this.ringSpawnInterval && this.speakingRings.length < this.maxRings) {
            this.speakingRings.push({
                radius: coreRadius,
                opacity: 0.8,
                speed: 0.15
            });
            this.ringSpawnTimer = 0;
        }
        
        // Update and render existing rings
        this.speakingRings = this.speakingRings.filter(ring => {
            ring.radius += ring.speed * deltaTime;
            ring.opacity = Math.max(0, 0.8 * (1 - (ring.radius - coreRadius) / (coreRadius * 2)));
            
            if (ring.opacity > 0.01) {
                this.ctx.strokeStyle = this.hexToRgba(this.renderer.state.glowColor, ring.opacity);
                this.ctx.lineWidth = this.scaleValue(2);
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, ring.radius, 0, Math.PI * 2);
                this.ctx.stroke();
                return true;
            }
            return false;
        });
    }

    /**
     * Render zen core effect
     */
    renderZenCore(x, y, radius, time) {
        const {ctx} = this;
        const breathPhase = Math.sin(time * 0.001) * 0.5 + 0.5;
        const zenRadius = radius * (0.9 + breathPhase * 0.1);
        
        // Inner glow
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, zenRadius);
        gradient.addColorStop(0, 'rgba(147, 112, 219, 0.8)');
        gradient.addColorStop(0.7, 'rgba(147, 112, 219, 0.3)');
        gradient.addColorStop(1, 'rgba(147, 112, 219, 0)');
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, zenRadius * 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    /**
     * Start recording effect
     */
    startRecording() {
        this.recordingActive = true;
    }

    /**
     * Stop recording effect
     */
    stopRecording() {
        this.recordingActive = false;
    }

    /**
     * Enter sleep mode
     */
    enterSleepMode() {
        this.sleepMode = true;
    }

    /**
     * Wake up from sleep
     */
    wakeUp() {
        this.sleepMode = false;
    }

    /**
     * Start speaking effect
     */
    startSpeaking() {
        this.speakingActive = true;
    }

    /**
     * Stop speaking effect
     */
    stopSpeaking() {
        this.speakingActive = false;
    }

    /**
     * Create a sparkle particle
     */
    createSparkle(x, y, options = {}) {
        this.sparkles.push({
            x,
            y,
            vx: options.velocity?.x || 0,
            vy: options.velocity?.y || 0,
            size: options.size || 3,
            color: options.color || 'hsl(50, 100%, 70%)',
            lifetime: options.lifetime || 1000,
            maxLifetime: options.lifetime || 1000,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.2
        });
    }
    
    /**
     * Render all sparkles
     */
    renderSparkles() {
        const {ctx} = this;
        
        this.sparkles.forEach(sparkle => {
            const progress = 1 - (sparkle.lifetime / sparkle.maxLifetime);
            const opacity = 1 - progress; // Fade out over time
            
            ctx.save();
            ctx.translate(sparkle.x, sparkle.y);
            ctx.rotate(sparkle.rotation);
            
            // Draw sparkle as a star shape
            const size = this.scaleValue(sparkle.size * (1 - progress * 0.5));
            
            // Draw a 5-pointed star with smoother interior angles
            ctx.beginPath();
            const points = 5;
            const outerRadius = size;
            const innerRadius = size * 0.38; // Golden ratio-ish for smoother interior angles
            
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI / points) - Math.PI / 2; // Start from top
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                
                if (i === 0) {
                    ctx.moveTo(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius
                    );
                } else {
                    ctx.lineTo(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius
                    );
                }
            }
            ctx.closePath();
            
            // Add glow effect
            ctx.shadowBlur = this.scaleValue(10);
            ctx.shadowColor = sparkle.color;
            
            ctx.fillStyle = sparkle.color.replace('70%', `${70 + progress * 30}%`).replace(')', `, ${opacity})`).replace('hsl', 'hsla');
            ctx.fill();
            
            ctx.restore();
        });
    }
    
    /**
     * Trigger chromatic aberration effect
     * @param {number} intensity - Effect intensity (0-1)
     */
    triggerChromaticAberration(intensity = 0.8) {
        this.chromaticAberration.active = true;
        this.chromaticAberration.targetIntensity = Math.min(1, intensity);
        this.chromaticAberration.intensity = this.chromaticAberration.targetIntensity;
        
        // Get the actual visible canvas from the document
        const visibleCanvas = document.getElementById('emotive-canvas') || 
                            document.querySelector('canvas') || 
                            this.canvas;
        
        // Chromatic aberration logging removed for production
        
        if (visibleCanvas) {
            // Remove any existing animation
            visibleCanvas.style.animation = 'none';
            
            // Add CSS styles if not already present
            if (!document.getElementById('chromatic-styles')) {
                const style = document.createElement('style');
                style.id = 'chromatic-styles';
                style.textContent = `
                    @keyframes chromaticGlitch {
                        0% {
                            filter: none;
                            transform: translateX(0);
                        }
                        15% {
                            filter: drop-shadow(-2px 0 0 rgba(255,0,0,0.7)) drop-shadow(2px 0 0 rgba(0,255,255,0.7));
                            transform: translateX(-0.5px);
                        }
                        30% {
                            filter: drop-shadow(-3px 0 0 rgba(255,0,0,0.8)) drop-shadow(3px 0 0 rgba(0,255,255,0.8));
                            transform: translateX(0.5px);
                        }
                        45% {
                            filter: drop-shadow(-2px 0 0 rgba(255,0,0,0.6)) drop-shadow(2px 0 0 rgba(0,255,255,0.6));
                            transform: translateX(-0.3px);
                        }
                        60% {
                            filter: drop-shadow(-1px 0 0 rgba(255,0,0,0.4)) drop-shadow(1px 0 0 rgba(0,255,255,0.4));
                            transform: translateX(0.2px);
                        }
                        100% {
                            filter: none;
                            transform: translateX(0);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Apply animation - shorter duration (300-500ms based on intensity)
            visibleCanvas.style.animation = `chromaticGlitch ${300 + 200 * intensity}ms ease-out`;
        }
    }
    
    /**
     * Apply chromatic aberration effect to canvas
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {HTMLCanvasElement} sourceCanvas - Source canvas to apply effect to
     */
    applyChromaticAberration(ctx, sourceCanvas) {
        if (!this.chromaticAberration.active || this.chromaticAberration.intensity <= 0) {
            return;
        }
        
        const {intensity} = this.chromaticAberration;
        const offset = this.scaleValue(this.chromaticAberration.maxOffset * intensity);
        
        // Store current composite operation
        const prevComposite = ctx.globalCompositeOperation;
        
        // Clear the canvas first
        ctx.save();
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        // Draw red channel (shifted left)
        ctx.globalCompositeOperation = 'source-over';
        ctx.filter = 'url(#red-channel)'; // Will use CSS filter fallback
        ctx.drawImage(sourceCanvas, -offset, 0);
        
        // Draw green channel (center)
        ctx.globalCompositeOperation = 'screen';
        ctx.filter = 'url(#green-channel)';
        ctx.drawImage(sourceCanvas, 0, 0);
        
        // Draw blue channel (shifted right)
        ctx.globalCompositeOperation = 'screen';
        ctx.filter = 'url(#blue-channel)';
        ctx.drawImage(sourceCanvas, offset, 0);
        
        // Reset
        ctx.filter = 'none';
        ctx.globalCompositeOperation = prevComposite;
        ctx.restore();
    }
    
    /**
     * Simple chromatic aberration using multiple draws
     * (Fallback method that doesn't require filters)
     */
    applyChromaticAberrationSimple(ctx, centerX, centerY, radius, drawFunction) {
        if (!this.chromaticAberration.active || this.chromaticAberration.intensity <= 0) {
            drawFunction();
            return;
        }
        
        const {intensity} = this.chromaticAberration;
        const offset = this.scaleValue(this.chromaticAberration.maxOffset * intensity);
        
        ctx.save();
        
        // Draw red channel (shifted left)
        ctx.globalCompositeOperation = 'source-over';
        ctx.translate(-offset, 0);
        ctx.globalAlpha = 0.33;
        ctx.fillStyle = '#ff0000';
        ctx.filter = 'brightness(3)';
        drawFunction();
        ctx.translate(offset, 0);
        
        // Draw green channel (center)
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.33;
        ctx.fillStyle = '#00ff00';
        drawFunction();
        
        // Draw blue channel (shifted right)
        ctx.translate(offset, 0);
        ctx.globalAlpha = 0.33;
        ctx.fillStyle = '#0000ff';
        drawFunction();
        
        ctx.restore();
    }
    
    /**
     * Update all active effects
     */
    update(deltaTime) {
        // Update sparkles
        this.sparkles = this.sparkles.filter(sparkle => {
            sparkle.x += sparkle.vx;
            sparkle.y += sparkle.vy;
            sparkle.rotation += sparkle.rotationSpeed;
            sparkle.lifetime -= deltaTime;
            sparkle.vy += 0.1; // Gravity
            
            return sparkle.lifetime > 0;
        });
        
        // Update chromatic aberration fade
        if (this.chromaticAberration.active) {
            // Fade out the effect
            this.chromaticAberration.intensity -= this.chromaticAberration.fadeSpeed;
            
            if (this.chromaticAberration.intensity <= 0) {
                this.chromaticAberration.intensity = 0;
                this.chromaticAberration.active = false;
                this.chromaticAberration.targetIntensity = 0;
                // CSS Chromatic effect completion logging removed for production
            }
        }
    }
}

/**
 * EyeRenderer - Handles eye expressions and blinking for EmotiveRenderer
 * @module core/renderer/EyeRenderer
 */

class EyeRenderer {
    constructor(renderer) {
        this.renderer = renderer;
        this.ctx = renderer.ctx;
        this.canvas = renderer.canvas;
        
        // Eye state
        this.blinking = false;
        this.blinkingEnabled = true;
        this.blinkTimer = 0;
        this.nextBlinkTime = this.getRandomBlinkTime();
        
        // Eye parameters
        this.squintAmount = 0;
        this.eyeClose = null;
        this.eyeOpen = null;
        
        // Helper method references
        this.scaleValue = value => renderer.scaleValue(value);
        this.hexToRgba = (hex, alpha) => renderer.hexToRgba(hex, alpha);
    }

    /**
     * Update blinking and eye animations
     * @param {number} deltaTime - Time since last frame
     */
    update(deltaTime) {
        // Update blink timer
        if (this.blinking) {
            this.blinkTimer += deltaTime;
            if (this.blinkTimer >= 150) {
                this.blinking = false;
                this.blinkTimer = 0;
                this.nextBlinkTime = Date.now() + this.getRandomBlinkTime();
            }
        }
        
        // Check for natural blink
        if (this.blinkingEnabled && !this.blinking && Date.now() >= this.nextBlinkTime) {
            this.startBlink();
        }
    }

    /**
     * Start a blink animation
     */
    startBlink() {
        if (!this.blinkingEnabled) return;
        this.blinking = true;
        this.blinkTimer = 0;
    }

    /**
     * Get random time until next blink (3-7 seconds)
     * @returns {number} Time in milliseconds
     */
    getRandomBlinkTime() {
        return 3000 + Math.random() * 4000;
    }

    /**
     * Calculate blink scale for core
     * @returns {number} Scale factor for blinking
     */
    getBlinkScale() {
        if (!this.blinking) return 1;
        
        const blinkProgress = Math.min(this.blinkTimer / 150, 1);
        const blinkCurve = Math.sin(blinkProgress * Math.PI);
        return 1 - blinkCurve * 0.7; // Squish vertically by 70%
    }

    /**
     * Draw eye expression
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {string} emotion - Current emotion
     * @param {Object} params - Eye parameters
     */
    drawEyes(x, y, radius, emotion, params = {}) {
        const {ctx} = this;
        
        // Get eye parameters
        const eyeOpenness = params.eyeOpenness || 1;
        const eyeExpression = params.eyeExpression || 'neutral';
        
        // Don't draw eyes for certain states
        if (emotion === 'zen' || emotion === 'neutral' || eyeOpenness <= 0) {
            return;
        }
        
        ctx.save();
        
        // Eye color (slightly darker than core)
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = this.scaleValue(2);
        ctx.lineCap = 'round';
        
        // Calculate eye positions
        const eyeSpacing = radius * 0.4;
        const eyeY = y - radius * 0.1;
        const eyeSize = radius * 0.25;
        
        // Draw based on expression
        switch (eyeExpression) {
        case 'happy':
            this.drawHappyEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
            break;
        case 'sad':
            this.drawSadEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
            break;
        case 'angry':
            this.drawAngryEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
            break;
        case 'surprised':
            this.drawSurprisedEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
            break;
        case 'focused':
            this.drawFocusedEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
            break;
        case 'sleepy':
            this.drawSleepyEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
            break;
        case 'suspicious':
            this.drawSuspiciousEyes(ctx, x, eyeY, eyeSpacing, eyeSize, eyeOpenness);
            break;
        }
        
        ctx.restore();
    }

    /**
     * Draw happy eyes (upward curves)
     */
    drawHappyEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.arc(x - spacing, y, size, Math.PI * 0.2, Math.PI * 0.8, false);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(x + spacing, y, size, Math.PI * 0.2, Math.PI * 0.8, false);
        ctx.stroke();
    }

    /**
     * Draw sad eyes (downward curves)
     */
    drawSadEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.arc(x - spacing, y + size * 0.5, size, Math.PI * 1.2, Math.PI * 1.8, false);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(x + spacing, y + size * 0.5, size, Math.PI * 1.2, Math.PI * 1.8, false);
        ctx.stroke();
    }

    /**
     * Draw angry eyes (angled lines)
     */
    drawAngryEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.moveTo(x - spacing - size, y - size * 0.3);
        ctx.lineTo(x - spacing + size * 0.5, y + size * 0.3);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.moveTo(x + spacing + size, y - size * 0.3);
        ctx.lineTo(x + spacing - size * 0.5, y + size * 0.3);
        ctx.stroke();
    }

    /**
     * Draw surprised eyes (wide circles)
     */
    drawSurprisedEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.arc(x - spacing, y, size * 1.2, 0, Math.PI * 2);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(x + spacing, y, size * 1.2, 0, Math.PI * 2);
        ctx.stroke();
    }

    /**
     * Draw focused eyes (dots)
     */
    drawFocusedEyes(ctx, x, y, spacing, size, openness) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        
        // Left eye
        ctx.beginPath();
        ctx.arc(x - spacing, y, size * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye
        ctx.beginPath();
        ctx.arc(x + spacing, y, size * 0.3, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * Draw sleepy eyes (half-closed)
     */
    drawSleepyEyes(ctx, x, y, spacing, size, openness) {
        // Left eye
        ctx.beginPath();
        ctx.moveTo(x - spacing - size, y);
        ctx.lineTo(x - spacing + size, y);
        ctx.stroke();
        
        // Right eye
        ctx.beginPath();
        ctx.moveTo(x + spacing - size, y);
        ctx.lineTo(x + spacing + size, y);
        ctx.stroke();
    }

    /**
     * Draw suspicious eyes (narrowed)
     */
    drawSuspiciousEyes(ctx, x, y, spacing, size, openness) {
        // Left eye - narrowed
        ctx.beginPath();
        ctx.moveTo(x - spacing - size, y);
        ctx.lineTo(x - spacing + size * 0.7, y);
        ctx.stroke();
        
        // Right eye - more open
        ctx.beginPath();
        ctx.arc(x + spacing, y, size * 0.8, Math.PI * 0.1, Math.PI * 0.9, false);
        ctx.stroke();
    }

    /**
     * Enable or disable blinking
     * @param {boolean} enabled - Whether blinking is enabled
     */
    setBlinkingEnabled(enabled) {
        this.blinkingEnabled = enabled;
        if (!enabled) {
            this.blinking = false;
            this.blinkTimer = 0;
        }
    }

    /**
     * Set squint amount for eye narrowing
     * @param {number} amount - Squint amount (0-1)
     */
    setSquintAmount(amount) {
        this.squintAmount = Math.max(0, Math.min(1, amount));
    }

    /**
     * Force a blink
     */
    forceBlink() {
        this.startBlink();
    }
}

/**
 * BreathingAnimator - Handles breathing animations for EmotiveRenderer
 * @module core/renderer/BreathingAnimator
 */

class BreathingAnimator {
    constructor(renderer) {
        this.renderer = renderer;
        
        // Breathing configuration
        this.breathingSpeed = 0.42; // 16 breaths/min (0.42 rad/s = 4 sec/cycle = 15-16 bpm)
        this.breathingDepth = 0.08; // 8% size variation for visible breathing
        
        // Breathing state
        this.breathingPhase = 0;
        this.breathRate = 1.0;
        this.breathDepth = this.breathingDepth;
        this.breathRateMult = 1.0;
        this.breathDepthMult = 1.0;
        this.breathIrregular = false;
        
        // Custom scale override
        this.customScale = null;
        
        // Emotion-specific breathing patterns
        this.emotionBreathPatterns = {
            happy: { rate: 1.1, depth: 1.2 },
            sad: { rate: 0.8, depth: 0.7 },
            angry: { rate: 1.4, depth: 1.3 },
            calm: { rate: 0.7, depth: 0.9 },
            excited: { rate: 1.5, depth: 1.4 },
            focused: { rate: 0.9, depth: 0.6 },
            neutral: { rate: 1.0, depth: 1.0 },
            love: { rate: 1.2, depth: 1.3 },
            surprised: { rate: 1.3, depth: 1.1 },
            confused: { rate: 1.1, depth: 0.9 },
            amused: { rate: 1.2, depth: 1.1 },
            bored: { rate: 0.6, depth: 0.8 },
            tired: { rate: 0.5, depth: 1.2 },
            anxious: { rate: 1.6, depth: 0.9 },
            determined: { rate: 1.1, depth: 1.0 },
            proud: { rate: 0.9, depth: 1.3 },
            content: { rate: 0.8, depth: 1.0 },
            hopeful: { rate: 1.0, depth: 1.1 },
            zen: { rate: 0.4, depth: 1.5 },
            intrigued: { rate: 1.1, depth: 0.8 },
            embarrassed: { rate: 1.3, depth: 0.7 },
            grateful: { rate: 0.9, depth: 1.1 },
            inspired: { rate: 1.0, depth: 1.3 },
            silly: { rate: 1.4, depth: 1.2 },
            sleepy: { rate: 0.3, depth: 1.4 }
        };
    }

    /**
     * Update breathing animation
     * @param {number} deltaTime - Time since last frame in ms
     * @param {string} emotion - Current emotion
     * @param {Object} undertone - Current undertone modifiers
     */
    update(deltaTime, emotion, undertone = {}) {
        // Ensure undertone is not null
        undertone = undertone || {};
        
        // Apply emotion-specific breathing pattern
        const pattern = this.emotionBreathPatterns[emotion] || { rate: 1.0, depth: 1.0 };
        
        // Apply undertone modifiers (safe access with null check)
        const undertoneRateMult = undertone?.breathRateMult || 1.0;
        const undertoneDepthMult = undertone?.breathDepthMult || 1.0;
        
        // Calculate final breathing parameters
        this.breathRate = pattern.rate * this.breathRateMult * undertoneRateMult;
        this.breathDepth = this.breathingDepth * pattern.depth * this.breathDepthMult * undertoneDepthMult;
        
        // Add irregularity if needed
        let phaseIncrement = this.breathingSpeed * this.breathRate * (deltaTime / 1000);
        if (this.breathIrregular && undertone?.breathIrregular) {
            phaseIncrement *= 0.8 + Math.sin(Date.now() * 0.0003) * 0.4;
        }
        
        // Update breathing phase
        this.breathingPhase += phaseIncrement;
        if (this.breathingPhase > Math.PI * 2) {
            this.breathingPhase -= Math.PI * 2;
        }
    }

    /**
     * Get current breathing scale
     * @returns {number} Scale factor for breathing
     */
    getBreathingScale() {
        // Return custom scale if set
        if (this.customScale !== null) {
            return this.customScale;
        }
        
        // Calculate breathing scale
        const breathAmount = Math.sin(this.breathingPhase);
        return 1 + breathAmount * this.breathDepth;
    }

    /**
     * Set custom breathing scale (overrides normal breathing)
     * @param {number} scale - Custom scale value, or null to use normal breathing
     */
    setCustomScale(scale) {
        this.customScale = scale;
    }

    /**
     * Set breathing speed
     * @param {number} speed - Breathing speed in radians per second
     */
    setBreathingSpeed(speed) {
        this.breathingSpeed = speed;
    }

    /**
     * Set breathing depth
     * @param {number} depth - Breathing depth as percentage (0-1)
     */
    setBreathingDepth(depth) {
        this.breathingDepth = Math.max(0, Math.min(1, depth));
    }

    /**
     * Set breathing rate multiplier
     * @param {number} mult - Rate multiplier
     */
    setBreathRateMultiplier(mult) {
        this.breathRateMult = mult;
    }

    /**
     * Set breathing depth multiplier
     * @param {number} mult - Depth multiplier
     */
    setBreathDepthMultiplier(mult) {
        this.breathDepthMult = mult;
    }

    /**
     * Enable/disable irregular breathing
     * @param {boolean} irregular - Whether breathing should be irregular
     */
    setIrregularBreathing(irregular) {
        this.breathIrregular = irregular;
    }

    /**
     * Reset breathing to default state
     */
    reset() {
        this.breathingPhase = 0;
        this.breathRate = 1.0;
        this.breathDepth = this.breathingDepth;
        this.breathRateMult = 1.0;
        this.breathDepthMult = 1.0;
        this.breathIrregular = false;
        this.customScale = null;
    }

    /**
     * Apply breath hold effect
     * @param {boolean} empty - Whether lungs are empty (true) or full (false)
     */
    holdBreath(empty = false) {
        // Set custom scale based on breath hold type
        this.customScale = empty ? 0.92 : 1.08;
    }

    /**
     * Release breath hold
     */
    releaseBreath() {
        this.customScale = null;
    }

    /**
     * Get breathing info for debugging
     * @returns {Object} Breathing state info
     */
    getBreathingInfo() {
        return {
            phase: this.breathingPhase,
            rate: this.breathRate,
            depth: this.breathDepth,
            scale: this.getBreathingScale(),
            isCustom: this.customScale !== null,
            isIrregular: this.breathIrregular
        };
    }
}

/**
 * Gradient Cache System
 * Caches canvas gradients to avoid recreating them every frame
 *
 * @module core/renderer/GradientCache
 * @version 1.0.0
 */

/**
 * Cache for canvas gradients to improve rendering performance
 */
class GradientCache {
    constructor() {
        // Cache storage with Map for efficient lookups
        this.cache = new Map();

        // Stats for monitoring
        this.stats = {
            hits: 0,
            misses: 0,
            evictions: 0
        };

        // Cache configuration
        this.maxSize = 100; // Maximum number of cached gradients
        this.ttl = 60000; // Time to live in milliseconds (1 minute)

        // LRU tracking
        this.accessOrder = [];
    }

    /**
     * Generate a unique key for gradient parameters
     * @private
     */
    generateKey(type, params) {
        if (type === 'radial') {
            const { x0, y0, r0, x1, y1, r1, stops } = params;
            const stopKey = stops.map(s => `${s.offset}:${s.color}`).join('|');
            return `radial:${x0},${y0},${r0},${x1},${y1},${r1}:${stopKey}`;
        } else if (type === 'linear') {
            const { x0, y0, x1, y1, stops } = params;
            const stopKey = stops.map(s => `${s.offset}:${s.color}`).join('|');
            return `linear:${x0},${y0},${x1},${y1}:${stopKey}`;
        }
        return null;
    }

    /**
     * Get or create a radial gradient
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x0 - Start circle center x
     * @param {number} y0 - Start circle center y
     * @param {number} r0 - Start circle radius
     * @param {number} x1 - End circle center x
     * @param {number} y1 - End circle center y
     * @param {number} r1 - End circle radius
     * @param {Array} stops - Color stops [{offset, color}]
     * @returns {CanvasGradient} Cached or new gradient
     */
    getRadialGradient(ctx, x0, y0, r0, x1, y1, r1, stops) {
        const key = this.generateKey('radial', { x0, y0, r0, x1, y1, r1, stops });

        // Check cache
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.ttl) {
            this.stats.hits++;
            this.updateAccessOrder(key);
            return cached.gradient;
        }

        // Create new gradient
        this.stats.misses++;
        const gradient = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);

        // Add color stops
        stops.forEach(stop => {
            gradient.addColorStop(stop.offset, stop.color);
        });

        // Cache it
        this.set(key, gradient);

        return gradient;
    }

    /**
     * Get or create a linear gradient
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x0 - Start point x
     * @param {number} y0 - Start point y
     * @param {number} x1 - End point x
     * @param {number} y1 - End point y
     * @param {Array} stops - Color stops [{offset, color}]
     * @returns {CanvasGradient} Cached or new gradient
     */
    getLinearGradient(ctx, x0, y0, x1, y1, stops) {
        const key = this.generateKey('linear', { x0, y0, x1, y1, stops });

        // Check cache
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.ttl) {
            this.stats.hits++;
            this.updateAccessOrder(key);
            return cached.gradient;
        }

        // Create new gradient
        this.stats.misses++;
        const gradient = ctx.createLinearGradient(x0, y0, x1, y1);

        // Add color stops
        stops.forEach(stop => {
            gradient.addColorStop(stop.offset, stop.color);
        });

        // Cache it
        this.set(key, gradient);

        return gradient;
    }

    /**
     * Store gradient in cache with LRU eviction
     * @private
     */
    set(key, gradient) {
        // Check if we need to evict
        if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
            this.evictLRU();
        }

        // Store with timestamp
        this.cache.set(key, {
            gradient,
            timestamp: Date.now()
        });

        this.updateAccessOrder(key);
    }

    /**
     * Update access order for LRU tracking
     * @private
     */
    updateAccessOrder(key) {
        // Remove from current position
        const index = this.accessOrder.indexOf(key);
        if (index > -1) {
            this.accessOrder.splice(index, 1);
        }
        // Add to end (most recently used)
        this.accessOrder.push(key);
    }

    /**
     * Evict least recently used item
     * @private
     */
    evictLRU() {
        if (this.accessOrder.length > 0) {
            const keyToEvict = this.accessOrder.shift();
            this.cache.delete(keyToEvict);
            this.stats.evictions++;
        }
    }

    /**
     * Clear all cached gradients
     */
    clear() {
        this.cache.clear();
        this.accessOrder = [];
    }

    /**
     * Clear expired entries
     */
    clearExpired() {
        const now = Date.now();
        const keysToDelete = [];

        for (const [key, value] of this.cache.entries()) {
            if (now - value.timestamp >= this.ttl) {
                keysToDelete.push(key);
            }
        }

        keysToDelete.forEach(key => {
            this.cache.delete(key);
            const index = this.accessOrder.indexOf(key);
            if (index > -1) {
                this.accessOrder.splice(index, 1);
            }
        });
    }

    /**
     * Get cache statistics
     * @returns {Object} Cache stats
     */
    getStats() {
        const hitRate = this.stats.hits + this.stats.misses > 0
            ? (this.stats.hits / (this.stats.hits + this.stats.misses) * 100).toFixed(2)
            : 0;

        return {
            size: this.cache.size,
            maxSize: this.maxSize,
            hits: this.stats.hits,
            misses: this.stats.misses,
            evictions: this.stats.evictions,
            hitRate: `${hitRate}%`
        };
    }

    /**
     * Create a gradient helper that automatically caches
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @returns {Object} Helper object with gradient methods
     */
    createHelper(ctx) {
        return {
            radial: (x0, y0, r0, x1, y1, r1, stops) =>
                this.getRadialGradient(ctx, x0, y0, r0, x1, y1, r1, stops),
            linear: (x0, y0, x1, y1, stops) =>
                this.getLinearGradient(ctx, x0, y0, x1, y1, stops)
        };
    }
}

// Create singleton instance
const gradientCache = new GradientCache();

/**
 * GlowRenderer - Handles glow effects rendering for EmotiveRenderer
 * @module core/renderer/GlowRenderer
 */


class GlowRenderer {
    constructor(renderer) {
        this.renderer = renderer;
        this.ctx = renderer.ctx;
        this.canvas = renderer.canvas;
        
        // Glow state
        this.glowIntensity = 1.0;
        this.glowColor = '#4a90e2';
        this.targetGlowColor = '#4a90e2';
        this.glowColorTransition = 0;
        this.glowColorTransitionSpeed = 0.05;
        
        // Offscreen canvas for caching glow gradients
        this.offscreenCanvas = null;
        this.offscreenCtx = null;
        this.cachedGlowColor = null;
        this.cachedGlowRadius = 0;
        
        // Helper method references
        this.scaleValue = value => renderer.scaleValue(value);
        this.hexToRgba = (hex, alpha) => renderer.hexToRgba(hex, alpha);
        
        this.initOffscreenCanvas();
    }

    /**
     * Initialize offscreen canvas for gradient caching
     */
    initOffscreenCanvas() {
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
    }

    /**
     * Update offscreen canvas size
     * @param {number} size - Size for the offscreen canvas
     */
    updateOffscreenSize(size) {
        if (this.offscreenCanvas.width !== size || this.offscreenCanvas.height !== size) {
            this.offscreenCanvas.width = size;
            this.offscreenCanvas.height = size;
            this.cachedGlowColor = null; // Invalidate cache
        }
    }

    /**
     * Render main glow effect
     * @param {number} x - Center X position
     * @param {number} y - Center Y position
     * @param {number} radius - Core radius
     * @param {Object} params - Additional parameters
     */
    renderGlow(x, y, radius, params = {}) {
        const {ctx} = this;
        const color = params.color || this.glowColor;
        const intensity = params.intensity !== undefined ? params.intensity : this.glowIntensity;
        
        // Skip if intensity is too low
        if (intensity < 0.01) return;

        // Always use direct rendering for consistent brightness
        this.renderGlowDirect(ctx, x, y, radius, color, intensity);
    }

    /**
     * Cache glow gradient to offscreen canvas
     * @param {string} color - Glow color
     * @param {number} size - Glow size
     */
    cacheGlowGradient(color, size) {
        const offCtx = this.offscreenCtx;
        const center = size;
        
        // Update offscreen canvas size
        this.updateOffscreenSize(size * 2);
        
        // Clear offscreen canvas
        offCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
        
        // Use cached gradient - higher opacity to match original brightness
        const gradient = gradientCache.getRadialGradient(
            offCtx, center, center, 0, center, center, size,
            [
                { offset: 0, color: this.hexToRgba(color, 0.4) },
                { offset: 0.3, color: this.hexToRgba(color, 0.2) },
                { offset: 0.6, color: this.hexToRgba(color, 0.1) },
                { offset: 1, color: this.hexToRgba(color, 0) }
            ]
        );

        // Draw gradient to offscreen canvas
        offCtx.fillStyle = gradient;
        offCtx.fillRect(0, 0, size * 2, size * 2);
        
        // Update cache info
        this.cachedGlowColor = color;
        this.cachedGlowRadius = size;
    }

    /**
     * Direct glow rendering (fallback)
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {string} color - Glow color
     * @param {number} intensity - Glow intensity
     */
    renderGlowDirect(ctx, x, y, radius, color, intensity) {
        // Use the EXACT original formula for consistent brightness
        ctx.save();

        // Use 'screen' blending to prevent glow accumulation
        ctx.globalCompositeOperation = 'screen';

        // Build gradient stops array
        const stops = 20;
        const gradientStops = [];
        for (let i = 0; i <= stops; i++) {
            const position = i / stops;
            const baseOpacity = 0.6 * Math.pow(1 - position, 2.2);
            // Clamp opacity to prevent accumulation at high intensities
            // and ensure visibility at low intensities
            const opacity = Math.max(0, Math.min(1, baseOpacity * intensity));
            gradientStops.push({ offset: position, color: this.hexToRgba(color, opacity) });
        }

        // Use cached gradient
        const gradient = gradientCache.getRadialGradient(
            ctx, x, y, 0, x, y, radius, gradientStops
        );

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    /**
     * Render recording glow effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {number} intensity - Glow intensity
     */
    renderRecordingGlow(x, y, radius, intensity) {
        const {ctx} = this;
        const glowSize = radius * 2.5;
        const gradient = gradientCache.getRadialGradient(
            ctx, x, y, 0, x, y, glowSize,
            [
                { offset: 0, color: `rgba(255, 0, 0, ${0.3 * intensity})` },
                { offset: 0.5, color: `rgba(255, 0, 0, ${0.15 * intensity})` },
                { offset: 1, color: 'rgba(255, 0, 0, 0)' }
            ]
        );
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = gradient;
        ctx.fillRect(x - glowSize, y - glowSize, glowSize * 2, glowSize * 2);
        ctx.restore();
    }

    /**
     * Render zen glow effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {number} time - Current time for animation
     */
    renderZenGlow(x, y, radius, time) {
        const {ctx} = this;
        const breathPhase = Math.sin(time * 0.001) * 0.5 + 0.5;
        const zenRadius = radius * (0.9 + breathPhase * 0.1);
        
        // Inner glow
        const gradient = gradientCache.getRadialGradient(
            ctx, x, y, 0, x, y, zenRadius,
            [
                { offset: 0, color: 'rgba(147, 112, 219, 0.8)' },
                { offset: 0.7, color: 'rgba(147, 112, 219, 0.3)' },
                { offset: 1, color: 'rgba(147, 112, 219, 0)' }
            ]
        );
        
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, zenRadius * 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    /**
     * Update glow color with transition
     * @param {string} targetColor - Target glow color
     * @param {number} _deltaTime - Time since last frame (unused)
     */
    updateGlowColor(targetColor, _deltaTime) {
        if (this.targetGlowColor !== targetColor) {
            this.targetGlowColor = targetColor;
            this.glowColorTransition = 0;
        }
        
        // Animate color transition
        if (this.glowColorTransition < 1) {
            this.glowColorTransition = Math.min(1, this.glowColorTransition + this.glowColorTransitionSpeed);
            this.glowColor = this.lerpColor(this.glowColor, this.targetGlowColor, this.glowColorTransition);
        }
    }

    /**
     * Lerp between two colors
     * @param {string} color1 - Start color
     * @param {string} color2 - End color
     * @param {number} t - Interpolation value (0-1)
     * @returns {string} Interpolated color
     */
    lerpColor(color1, color2, t) {
        // Convert hex to RGB
        const rgb1 = this.hexToRgb(color1);
        const rgb2 = this.hexToRgb(color2);
        
        // Interpolate
        const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);
        const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);
        const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);
        
        // Convert back to hex
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    /**
     * Convert hex color to RGB
     * @param {string} hex - Hex color
     * @returns {Object} RGB values
     */
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
    }

    /**
     * Set glow intensity
     * @param {number} intensity - Glow intensity (0-1)
     */
    setGlowIntensity(intensity) {
        this.glowIntensity = Math.max(0, Math.min(1, intensity));
    }

    /**
     * Set glow color instantly
     * @param {string} color - Glow color
     */
    setGlowColor(color) {
        this.glowColor = color;
        this.targetGlowColor = color;
        this.glowColorTransition = 1;
    }

    /**
     * Clean up resources
     */
    destroy() {
        this.offscreenCanvas = null;
        this.offscreenCtx = null;
        this.cachedGlowColor = null;
    }
}

/**
 * CoreRenderer - Handles core shape rendering for EmotiveRenderer
 * @module core/renderer/CoreRenderer
 */


class CoreRenderer {
    constructor(renderer) {
        this.renderer = renderer;
        this.ctx = renderer.ctx;
        this.canvas = renderer.canvas;
        
        // Core appearance
        this.coreColor = '#FFFFFF';
        this.coreOpacity = 1.0;
        this.coreBorderWidth = 0;
        this.coreBorderColor = null;
        
        // Shape state
        this.shapePoints = null;
        this.isMorphing = false;
        
        // Helper method references
        this.scaleValue = value => renderer.scaleValue(value);
        this.hexToRgba = (hex, alpha) => renderer.hexToRgba(hex, alpha);
    }

    /**
     * Render the main core shape
     * @param {number} x - Center X position
     * @param {number} y - Center Y position
     * @param {number} radius - Core radius
     * @param {Object} params - Rendering parameters
     */
    renderCore(x, y, radius, params = {}) {
        const {ctx} = this;
        
        // Extract parameters
        const scaleX = params.scaleX || 1;
        const scaleY = params.scaleY || 1;
        const rotation = params.rotation || 0;
        const opacity = params.opacity !== undefined ? params.opacity : this.coreOpacity;
        const color = params.color || this.coreColor;
        const shapePoints = params.shapePoints || this.shapePoints;
        
        ctx.save();
        
        // Apply transformations
        ctx.translate(x, y);
        if (rotation !== 0) {
            ctx.rotate(rotation);
        }
        ctx.scale(scaleX, scaleY);
        
        // Set core style
        ctx.fillStyle = this.hexToRgba(color, opacity);
        
        // Draw shape based on points or default circle
        if (shapePoints && shapePoints.length > 0) {
            this.drawMorphedShape(ctx, shapePoints, radius);
        } else {
            this.drawCircle(ctx, radius);
        }
        
        // Draw border if needed
        if (this.coreBorderWidth > 0 && this.coreBorderColor) {
            ctx.strokeStyle = this.coreBorderColor;
            ctx.lineWidth = this.scaleValue(this.coreBorderWidth);
            ctx.stroke();
        }
        
        ctx.restore();
    }

    /**
     * Draw drop shadow for depth
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} radius - Shape radius
     * @param {Array} shapePoints - Shape points
     */
    drawDropShadow(ctx, radius, shapePoints) {
        ctx.save();
        
        const shadowOffset = this.scaleValue(2);
        ctx.translate(0, shadowOffset);
        
        // Use simpler shadow for complex deformed shapes
        if (shapePoints && shapePoints.length > 32) {
            // Simple dark circle shadow when shape is complex
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.05, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Shadow gradient - dark center fading to transparent
            const shadowGradient = gradientCache.getRadialGradient(
                ctx, 0, 0, radius * 0.7, 0, 0, radius * 1.2,
                [
                    { offset: 0, color: 'rgba(0, 0, 0, 0.2)' },
                    { offset: 0.8, color: 'rgba(0, 0, 0, 0.1)' },
                    { offset: 1, color: 'rgba(0, 0, 0, 0)' }
                ]
            );

            ctx.fillStyle = shadowGradient;
            ctx.beginPath();
            if (shapePoints) {
                // Scale points for shadow
                const scale = 1.1;
                const step = shapePoints.length > 20 ? 2 : 1;
                ctx.moveTo(shapePoints[0].x * scale, shapePoints[0].y * scale);
                for (let i = step; i < shapePoints.length; i += step) {
                    ctx.lineTo(shapePoints[i].x * scale, shapePoints[i].y * scale);
                }
                ctx.closePath();
            } else {
                ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
            }
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    /**
     * Draw a simple circle
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {number} radius - Circle radius
     */
    drawCircle(ctx, radius) {
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();
    }

    /**
     * Draw a morphed shape from points
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Array} points - Shape points
     * @param {number} baseRadius - Base radius for scaling
     */
    drawMorphedShape(ctx, points, baseRadius) {
        if (!points || points.length < 3) {
            // Fallback to circle if not enough points
            this.drawCircle(ctx, baseRadius);
            return;
        }
        
        ctx.beginPath();
        
        // Points from getCanvasPoints are already in canvas coordinates
        // relative to the center (0,0) after translation
        points.forEach((point, i) => {
            if (i === 0) {
                ctx.moveTo(point.x, point.y);
            } else {
                ctx.lineTo(point.x, point.y);
            }
        });
        
        ctx.closePath();
        ctx.fill();
    }

    /**
     * Render zen core effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {number} time - Current time for animation
     */
    renderZenCore(x, y, radius, time) {
        const {ctx} = this;
        
        // Zen breathing effect
        const breathPhase = Math.sin(time * 0.001) * 0.5 + 0.5;
        const zenRadius = radius * (0.95 + breathPhase * 0.05);
        
        // Draw zen core with subtle inner glow
        ctx.save();
        
        // Inner shadow for depth
        ctx.shadowBlur = this.scaleValue(10);
        ctx.shadowColor = 'rgba(147, 112, 219, 0.3)';
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Main core
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(x, y, zenRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner ring
        ctx.strokeStyle = 'rgba(147, 112, 219, 0.2)';
        ctx.lineWidth = this.scaleValue(1);
        ctx.beginPath();
        ctx.arc(x, y, zenRadius * 0.9, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
    }

    /**
     * Render sleepy core effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     */
    renderSleepyCore(x, y, radius) {
        const {ctx} = this;
        
        // Slightly squished for sleepy look
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(1, 0.85);
        
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    /**
     * Render glitched core effect
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Core radius
     * @param {number} glitchIntensity - Glitch intensity (0-1)
     */
    renderGlitchedCore(x, y, radius, glitchIntensity) {
        const {ctx} = this;
        
        // Draw multiple offset cores for glitch effect
        const offsets = [
            { x: -2, y: 0, alpha: 0.3 },
            { x: 2, y: 0, alpha: 0.3 },
            { x: 0, y: -1, alpha: 0.2 }
        ];
        
        ctx.save();
        
        offsets.forEach(offset => {
            ctx.fillStyle = this.hexToRgba('#FFFFFF', offset.alpha * glitchIntensity);
            ctx.beginPath();
            ctx.arc(
                x + offset.x * glitchIntensity * this.scaleValue(5),
                y + offset.y * glitchIntensity * this.scaleValue(5),
                radius,
                0,
                Math.PI * 2
            );
            ctx.fill();
        });
        
        // Main core
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    /**
     * Set shape points for morphing
     * @param {Array} points - Array of normalized points
     */
    setShapePoints(points) {
        this.shapePoints = points;
        this.isMorphing = points && points.length > 0;
    }

    /**
     * Clear shape points (return to circle)
     */
    clearShapePoints() {
        this.shapePoints = null;
        this.isMorphing = false;
    }

    /**
     * Set core color
     * @param {string} color - Core color
     */
    setCoreColor(color) {
        this.coreColor = color;
    }

    /**
     * Set core opacity
     * @param {number} opacity - Core opacity (0-1)
     */
    setCoreOpacity(opacity) {
        this.coreOpacity = Math.max(0, Math.min(1, opacity));
    }

    /**
     * Set core border
     * @param {number} width - Border width
     * @param {string} color - Border color
     */
    setCoreBorder(width, color) {
        this.coreBorderWidth = width;
        this.coreBorderColor = color;
    }

    /**
     * Get core rendering info
     * @returns {Object} Core state info
     */
    getCoreInfo() {
        return {
            color: this.coreColor,
            opacity: this.coreOpacity,
            hasBorder: this.coreBorderWidth > 0,
            isMorphing: this.isMorphing,
            shapePointCount: this.shapePoints ? this.shapePoints.length : 0
        };
    }
}

/**
 * RotationBrake - Simple braking system using DEGREES like the working demo
 * @module core/animation/RotationBrake
 */

class RotationBrake {
    constructor(renderer) {
        this.renderer = renderer;

        // Braking state - EXACTLY like the demo
        this.brakeStartTime = null;
        this.brakeDuration = 2500; // Will be calculated dynamically
        this.brakeStartRotation = 0;
        this.brakeTargetRotation = 0;
        this.brakeStartVelocity = 0;

        // Callbacks
        this.onComplete = null;
        this.onProgress = null;

        // Constants
        this.DURATION_FACTOR = 14; // Tuned for natural deceleration feel
    }

    /**
     * Brake to upright position (0 degrees)
     * @param {Object} options - Brake options
     * @returns {Promise} Resolves when braking complete
     */
    brakeToUpright(options = {}) {
        return this.brakeToTarget(0, options);
    }

    /**
     * Brake to nearest multiple of given angle
     * @param {number} angleStep - Angle step in DEGREES (e.g., 90 for 90°)
     * @param {Object} options - Brake options
     * @returns {Promise} Resolves when braking complete
     */
    brakeToNearest(angleStep, options = {}) {
        const currentAngle = this.renderer.state.manualRotation || 0;
        const steps = Math.round(currentAngle / angleStep);
        const targetAngle = steps * angleStep;
        return this.brakeToTarget(targetAngle, options);
    }

    /**
     * Brake to specific target angle
     * @param {number} targetAngle - Target angle in DEGREES (0 = upright)
     * @param {Object} options - Brake options
     * @returns {Promise} Resolves when braking complete
     */
    brakeToTarget(targetAngle, options = {}) {
        return new Promise(resolve => {
            const {
                onProgress = null,
                onComplete = null
            } = options;

            this.onProgress = onProgress;
            this.onComplete = onComplete;

            // Get current state - ALL IN DEGREES
            const currentVelocity = this.renderer.state.rotationSpeed || 0;
            const rotation = this.renderer.state.manualRotation || 0;

            // Do nothing if not moving or already braking
            if (currentVelocity === 0 || this.brakeStartTime) {
                resolve();
                return;
            }

            // Initialize braking state
            this.brakeStartTime = performance.now();
            this.brakeStartRotation = rotation;
            this.brakeStartVelocity = currentVelocity;

            // Calculate the nearest upright target rotation
            if (targetAngle === 0) {
                // Special case for upright
                if (currentVelocity > 0) { // Spinning clockwise
                    this.brakeTargetRotation = (Math.floor(rotation / 360) + 1) * 360;
                } else { // Spinning counter-clockwise
                    this.brakeTargetRotation = Math.floor(rotation / 360) * 360;
                }
            } else {
                // General case
                const normalizedTarget = targetAngle % 360;
                const baseCycles = Math.floor(rotation / 360);

                if (currentVelocity > 0) {
                    if (normalizedTarget > (rotation % 360)) {
                        this.brakeTargetRotation = baseCycles * 360 + normalizedTarget;
                    } else {
                        this.brakeTargetRotation = (baseCycles + 1) * 360 + normalizedTarget;
                    }
                } else {
                    if (normalizedTarget < (rotation % 360)) {
                        this.brakeTargetRotation = baseCycles * 360 + normalizedTarget;
                    } else {
                        this.brakeTargetRotation = (baseCycles - 1) * 360 + normalizedTarget;
                    }
                }
            }

            // DYNAMIC DURATION CALCULATION - EXACTLY like the demo
            const angleToTravel = Math.abs(this.brakeTargetRotation - this.brakeStartRotation);
            this.brakeDuration = Math.max(500, (angleToTravel / Math.abs(currentVelocity)) * this.DURATION_FACTOR * 5);

            console.warn('Brake started:', {
                from: `${rotation.toFixed(1)}°`,
                to: `${this.brakeTargetRotation.toFixed(1)}°`,
                velocity: currentVelocity,
                duration: `${this.brakeDuration.toFixed(0)}ms`
            });

            // Stop adding velocity immediately
            this.renderer.setRotationSpeed(0);

            this.resolvePromise = resolve;
        });
    }

    /**
     * Update brake state - called by renderer each frame
     * @param {number} currentTime - Current timestamp from requestAnimationFrame
     * @returns {Object|null} - Rotation update or null if not braking
     */
    updateBrake(currentTime) {
        if (!this.brakeStartTime) {
            return null; // Not braking
        }

        const elapsed = currentTime - this.brakeStartTime;
        const progress = Math.min(elapsed / this.brakeDuration, 1);

        // Ease-out quartic for smooth deceleration (starts fast, ends slow)
        const easedProgress = 1 - Math.pow(1 - progress, 4);

        // Calculate new rotation based on eased progress
        const rotation = this.brakeStartRotation +
            (this.brakeTargetRotation - this.brakeStartRotation) * easedProgress;

        // Calculate virtual speed for UI (decreases with progress)
        const virtualSpeed = this.brakeStartVelocity * Math.pow(1 - easedProgress, 2);

        // Progress callback
        if (this.onProgress) {
            this.onProgress(easedProgress, virtualSpeed, rotation);
        }

        if (progress >= 1) {
            // Stop the animation when braking is complete
            this.brakeStartTime = null;

            console.warn('Brake complete:', {
                target: `${this.brakeTargetRotation.toFixed(1)}°`,
                duration: `${elapsed.toFixed(0)}ms`
            });

            this.complete();

            // Return final position
            return {
                rotation: this.brakeTargetRotation,
                speed: 0,
                complete: true
            };
        }

        // Continue braking
        return {
            rotation,
            speed: virtualSpeed,
            complete: false
        };
    }

    /**
     * Stop any active braking
     */
    stop() {
        this.brakeStartTime = null;
    }

    /**
     * Complete the braking operation
     * @private
     */
    complete() {
        if (this.onComplete) {
            this.onComplete();
        }

        if (this.resolvePromise) {
            this.resolvePromise();
            this.resolvePromise = null;
        }
    }

    /**
     * Check if currently braking
     * @returns {boolean}
     */
    isBraking() {
        return this.brakeStartTime !== null;
    }

    /**
     * Emergency stop - immediately halt rotation
     */
    emergencyStop() {
        this.stop();
        this.renderer.setRotationSpeed(0);
        this.complete();
    }

    /**
     * Get current brake progress
     * @returns {number} Progress from 0 to 1
     */
    getProgress() {
        if (!this.brakeStartTime) return 0;
        const elapsed = performance.now() - this.brakeStartTime;
        return Math.min(elapsed / this.brakeDuration, 1);
    }
}

/**
 * AmbientDanceAnimator - Connects ambient dance gestures to the renderer
 * Bridges the GestureBlender output with the actual rendering system
 */

class AmbientDanceAnimator {
    constructor(renderer) {
        this.renderer = renderer;

        // Animation states for ambient gestures
        this.animations = {
            grooveSway: null,
            grooveBob: null,
            grooveFlow: null,
            groovePulse: null,
            grooveStep: null
        };

        // Current active animation
        this.activeAnimation = null;

        // Blend state from GestureBlender
        this.blendState = {
            x: 0,
            y: 0,
            rotation: 0,
            scale: 1,
            opacity: 1
        };
    }

    /**
     * Start an ambient dance animation
     * @param {string} animationName - Name of the ambient gesture
     * @param {Object} options - Animation options
     */
    startAmbientAnimation(animationName, options = {}) {
        // Stop previous animation
        if (this.activeAnimation && this.activeAnimation !== animationName) {
            this.stopAmbientAnimation(this.activeAnimation);
        }

        this.activeAnimation = animationName;
        this.animations[animationName] = {
            startTime: Date.now(),
            intensity: options.intensity || 1.0,
            frequency: options.frequency || 1.0,
            options
        };
    }

    /**
     * Stop an ambient animation
     */
    stopAmbientAnimation(animationName) {
        if (this.animations[animationName]) {
            this.animations[animationName] = null;
        }
        if (this.activeAnimation === animationName) {
            this.activeAnimation = null;
        }
    }

    /**
     * Update blend state from GestureBlender
     */
    updateBlendState(blendState) {
        if (!blendState) return;

        // Smooth interpolation
        const lerpFactor = 0.2;
        this.blendState.x = this.lerp(this.blendState.x, blendState.x || 0, lerpFactor);
        this.blendState.y = this.lerp(this.blendState.y, blendState.y || 0, lerpFactor);
        this.blendState.rotation = this.lerp(this.blendState.rotation, blendState.rotation || 0, lerpFactor);
        this.blendState.scale = this.lerp(this.blendState.scale, blendState.scale || 1, lerpFactor);
        this.blendState.opacity = this.lerp(this.blendState.opacity, blendState.opacity || 1, lerpFactor);
    }

    /**
     * Get current animation transform
     */
    getTransform(deltaTime) {
        const transform = {
            x: this.blendState.x,
            y: this.blendState.y,
            rotation: this.blendState.rotation,
            scale: this.blendState.scale,
            opacity: this.blendState.opacity
        };

        // Apply active animation on top
        if (this.activeAnimation) {
            const animation = this.animations[this.activeAnimation];
            if (animation) {
                const elapsed = Date.now() - animation.startTime;

                switch (this.activeAnimation) {
                case 'grooveSway':
                    transform.x += Math.sin(elapsed / 500 * animation.frequency) * 15 * animation.intensity;
                    transform.rotation += Math.sin(elapsed / 500 * animation.frequency + Math.PI/4) * 5 * animation.intensity;
                    break;

                case 'grooveBob':
                    transform.y += Math.sin(elapsed / 400 * animation.frequency) * 10 * animation.intensity;
                    transform.scale *= 1 + Math.sin(elapsed / 400 * animation.frequency) * 0.03 * animation.intensity;
                    break;

                case 'grooveFlow': {
                    const t = elapsed / 1000 * animation.frequency;
                    transform.x += Math.sin(t) * Math.cos(t * 2) * 20 * animation.intensity;
                    transform.y += Math.cos(t) * Math.sin(t * 2) * 10 * animation.intensity;
                    transform.rotation += Math.sin(t * 2) * 8 * animation.intensity;
                    break;
                }

                case 'groovePulse': {
                    transform.scale *= 1 + Math.sin(elapsed / 250 * animation.frequency) * 0.05 * animation.intensity;
                    transform.opacity *= 0.9 + Math.sin(elapsed / 250 * animation.frequency) * 0.1 * animation.intensity;
                    break;
                }

                case 'grooveStep': {
                    const stepPhase = Math.floor(elapsed / 500 * animation.frequency) % 4;
                    const stepProgress = (elapsed / 500 * animation.frequency) % 1;
                    const smoothStep = this.smoothStep(stepProgress);

                    if (stepPhase === 0) transform.x += smoothStep * 25 * animation.intensity;
                    else if (stepPhase === 2) transform.x -= smoothStep * 25 * animation.intensity;

                    transform.y += Math.abs(Math.sin(elapsed / 250 * animation.frequency)) * 5 * animation.intensity;
                    break;
                }
                }
            }
        }

        return transform;
    }

    /**
     * Linear interpolation
     */
    lerp(a, b, t) {
        return a + (b - a) * t;
    }

    /**
     * Smooth step function
     */
    smoothStep(t) {
        return t * t * (3 - 2 * t);
    }
}

/**
 * Animation Loop Manager
 * Consolidates all requestAnimationFrame calls into a single, efficient loop
 *
 * @module core/AnimationLoopManager
 * @version 1.0.0
 */

/**
 * Priority levels for animations
 * @enum {number}
 */
const AnimationPriority = {
    CRITICAL: 0,    // Must run every frame (e.g., main render)
    HIGH: 1,        // Should run every frame if possible
    MEDIUM: 2,      // Can skip frames if needed
    LOW: 3,         // Background tasks, can be throttled
    IDLE: 4         // Only run when idle
};

/**
 * Centralized animation loop manager
 * Replaces multiple requestAnimationFrame calls with a single, optimized loop
 */
class AnimationLoopManager {
    constructor() {
        // Animation callbacks organized by priority
        this.callbacks = new Map();
        this.callbackIdCounter = 0;

        // Frame timing
        this.frameId = null;
        this.isRunning = false;
        this.lastFrameTime = 0;
        this.deltaTime = 0;
        this.fps = 60;
        this.frameCount = 0;

        // Performance
        this.targetFPS = 60;
        this.targetFrameTime = 1000 / this.targetFPS;
        this.frameBudget = 16.67; // ms

        // Frame skipping for low priority
        this.prioritySkipCounters = {
            [AnimationPriority.MEDIUM]: 0,
            [AnimationPriority.LOW]: 0,
            [AnimationPriority.IDLE]: 0
        };

        // Performance monitoring
        this.performanceMonitor = null;
        this.frameTimeHistory = [];
        this.maxHistorySize = 60;

        // Bind methods
        this.loop = this.loop.bind(this);
    }

    /**
     * Register an animation callback
     * @param {Function} callback - Function to call each frame (receives deltaTime, timestamp)
     * @param {number} priority - Priority level from AnimationPriority enum
     * @param {Object} context - Optional context for callback
     * @returns {number} Callback ID for later removal
     */
    register(callback, priority = AnimationPriority.MEDIUM, context = null) {
        if (typeof callback !== 'function') {
            throw new Error('Callback must be a function');
        }

        const id = ++this.callbackIdCounter;

        // Store callback with metadata
        this.callbacks.set(id, {
            callback,
            priority,
            context,
            lastRun: 0,
            runCount: 0,
            totalTime: 0,
            enabled: true
        });

        // Auto-start if this is the first callback
        if (this.callbacks.size === 1 && !this.isRunning) {
            this.start();
        }

        return id;
    }

    /**
     * Unregister an animation callback
     * @param {number} id - Callback ID returned from register()
     */
    unregister(id) {
        this.callbacks.delete(id);

        // Auto-stop if no callbacks remain
        if (this.callbacks.size === 0 && this.isRunning) {
            this.stop();
        }
    }

    /**
     * Enable/disable a callback without removing it
     * @param {number} id - Callback ID
     * @param {boolean} enabled - Whether to enable or disable
     */
    setEnabled(id, enabled) {
        const callback = this.callbacks.get(id);
        if (callback) {
            callback.enabled = enabled;
        }
    }

    /**
     * Start the animation loop
     */
    start() {
        if (this.isRunning) return;

        this.isRunning = true;
        this.lastFrameTime = performance.now();
        this.frameId = requestAnimationFrame(this.loop);
    }

    /**
     * Stop the animation loop
     */
    stop() {
        if (!this.isRunning) return;

        this.isRunning = false;
        if (this.frameId) {
            cancelAnimationFrame(this.frameId);
            this.frameId = null;
        }
    }

    /**
     * Main animation loop
     * @param {number} timestamp - Current timestamp from requestAnimationFrame
     */
    loop(timestamp) {
        if (!this.isRunning) return;

        // Calculate delta time
        this.deltaTime = timestamp - this.lastFrameTime;
        this.lastFrameTime = timestamp;

        // Update FPS
        this.frameCount++;
        if (this.frameCount % 60 === 0) {
            this.fps = Math.round(1000 / (this.deltaTime || 16.67));
        }

        // Track frame time
        this.frameTimeHistory.push(this.deltaTime);
        if (this.frameTimeHistory.length > this.maxHistorySize) {
            this.frameTimeHistory.shift();
        }

        // Performance marker start
        const frameStartTime = performance.now();

        // Group callbacks by priority
        const callbacksByPriority = this.groupCallbacksByPriority();

        // Execute callbacks by priority
        let timeSpent = 0;

        for (const priority of [
            AnimationPriority.CRITICAL,
            AnimationPriority.HIGH,
            AnimationPriority.MEDIUM,
            AnimationPriority.LOW,
            AnimationPriority.IDLE
        ]) {
            // Check frame budget (except for CRITICAL)
            if (priority > AnimationPriority.CRITICAL && timeSpent > this.frameBudget * 0.8) {
                break; // Skip lower priorities if running out of time
            }

            // Check if we should skip this priority level
            if (this.shouldSkipPriority(priority)) {
                continue;
            }

            // Execute callbacks at this priority
            const callbacks = callbacksByPriority.get(priority) || [];

            for (const callbackData of callbacks) {
                if (!callbackData.enabled) continue;

                const callbackStart = performance.now();

                try {
                    // Call with context if provided
                    if (callbackData.context) {
                        callbackData.callback.call(callbackData.context, this.deltaTime, timestamp);
                    } else {
                        callbackData.callback(this.deltaTime, timestamp);
                    }

                    // Track performance
                    const callbackTime = performance.now() - callbackStart;
                    callbackData.totalTime += callbackTime;
                    callbackData.runCount++;
                    callbackData.lastRun = timestamp;
                    timeSpent += callbackTime;

                } catch (error) {
                    console.error('Animation callback error:', error);
                    // Disable problematic callbacks
                    if (callbackData.runCount > 0 && callbackData.totalTime / callbackData.runCount > 10) {
                        console.warn('Disabling slow callback');
                        callbackData.enabled = false;
                    }
                }

                // Break if spending too much time
                if (timeSpent > this.frameBudget) {
                    break;
                }
            }
        }

        // Performance marker end
        const frameTime = performance.now() - frameStartTime;

        // Warn if frame took too long
        if (frameTime > this.frameBudget * 1.5) {
            console.warn(`Frame took ${frameTime.toFixed(2)}ms (target: ${this.frameBudget}ms)`);
        }

        // Schedule next frame
        this.frameId = requestAnimationFrame(this.loop);
    }

    /**
     * Group callbacks by priority for efficient execution
     * @returns {Map} Map of priority to callback arrays
     */
    groupCallbacksByPriority() {
        const groups = new Map();

        for (const [id, callbackData] of this.callbacks) {
            const {priority} = callbackData;

            if (!groups.has(priority)) {
                groups.set(priority, []);
            }

            groups.get(priority).push(callbackData);
        }

        return groups;
    }

    /**
     * Determine if we should skip a priority level this frame
     * @param {number} priority - Priority level to check
     * @returns {boolean} True if should skip
     */
    shouldSkipPriority(priority) {
        // Never skip critical
        if (priority === AnimationPriority.CRITICAL) return false;

        // Skip based on frame rate
        if (this.fps < 30 && priority >= AnimationPriority.LOW) return true;
        if (this.fps < 45 && priority === AnimationPriority.IDLE) return true;

        // Frame skipping for lower priorities
        if (priority === AnimationPriority.MEDIUM) {
            // Run every 2nd frame if FPS is low
            if (this.fps < 50) {
                this.prioritySkipCounters[priority]++;
                if (this.prioritySkipCounters[priority] % 2 !== 0) return true;
            }
        } else if (priority === AnimationPriority.LOW) {
            // Run every 3rd frame if FPS is low
            if (this.fps < 50) {
                this.prioritySkipCounters[priority]++;
                if (this.prioritySkipCounters[priority] % 3 !== 0) return true;
            }
        } else if (priority === AnimationPriority.IDLE) {
            // Run every 5th frame
            this.prioritySkipCounters[priority]++;
            if (this.prioritySkipCounters[priority] % 5 !== 0) return true;
        }

        return false;
    }

    /**
     * Get performance statistics
     * @returns {Object} Performance stats
     */
    getStats() {
        const stats = {
            fps: this.fps,
            frameCount: this.frameCount,
            callbackCount: this.callbacks.size,
            averageFrameTime: 0,
            maxFrameTime: 0,
            minFrameTime: Infinity
        };

        // Calculate frame time stats
        if (this.frameTimeHistory.length > 0) {
            let total = 0;
            for (const time of this.frameTimeHistory) {
                total += time;
                stats.maxFrameTime = Math.max(stats.maxFrameTime, time);
                stats.minFrameTime = Math.min(stats.minFrameTime, time);
            }
            stats.averageFrameTime = total / this.frameTimeHistory.length;
        }

        // Get callback stats by priority
        stats.callbacksByPriority = {};
        for (const [id, callback] of this.callbacks) {
            const {priority} = callback;
            if (!stats.callbacksByPriority[priority]) {
                stats.callbacksByPriority[priority] = {
                    count: 0,
                    totalTime: 0,
                    enabled: 0
                };
            }
            stats.callbacksByPriority[priority].count++;
            stats.callbacksByPriority[priority].totalTime += callback.totalTime;
            if (callback.enabled) stats.callbacksByPriority[priority].enabled++;
        }

        return stats;
    }

    /**
     * Set target FPS
     * @param {number} fps - Target frames per second
     */
    setTargetFPS(fps) {
        this.targetFPS = Math.max(15, Math.min(120, fps));
        this.targetFrameTime = 1000 / this.targetFPS;
        this.frameBudget = this.targetFrameTime;
    }

    /**
     * Set performance monitor
     * @param {PerformanceMonitor} monitor - Performance monitor instance
     */
    setPerformanceMonitor(monitor) {
        this.performanceMonitor = monitor;
    }

    /**
     * Destroy and cleanup
     */
    destroy() {
        this.stop();
        this.callbacks.clear();
        this.frameTimeHistory = [];
    }
}

// Create singleton instance
const animationLoopManager = new AnimationLoopManager();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  EMOTIVE RENDERER  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Emotive Renderer - Visual Rendering Engine
 * @author Emotive Engine Team
 * @version 2.4.0
 * @module EmotiveRenderer
 * @changelog 2.4.0 - Added offscreen canvas caching for glow gradients
 * @changelog 2.3.0 - Optimized color transitions to use main render loop
 * @changelog 2.2.0 - Dynamic visual resampling on resize for consistent quality
 * @changelog 2.1.0 - Implemented undertone saturation system for glow colors
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The VISUAL ARTIST of the Emotive Engine. Renders the iconic orb with its          
 * ║ glowing core, breathing animation, eye expressions, and gesture animations.       
 * ║ Creates the minimalist yet expressive visual that defines Emotive.                
 * ║                                                                                    
 * ║ NEW: Undertone saturation creates visual depth by adjusting glow color            
 * ║ saturation based on emotional intensity (intense→electric, subdued→ghostly)       
 * ║ NEW: Dynamic visual resampling ensures consistent quality at any canvas size      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎨 VISUAL COMPONENTS                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • White Core      : The solid center orb (#FFFFFF)                                
 * │ • Colored Glow    : Emotional aura surrounding the core                           
 * │ • Eye Shape       : Arc-based expressions (happiness, sadness, focus)             
 * │ • Breathing       : Subtle size pulsation for life-like quality                   
 * │ • Gesture Motion  : Position, scale, and rotation animations                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 RENDERING PIPELINE                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ 1. Clear canvas or apply motion blur                                              
 * │ 2. Calculate breathing scale factor                                               
 * │ 3. Apply gesture transformations (position, scale, rotation)                      
 * │ 4. Draw colored glow layers (3 gradient circles)                                  
 * │ 5. Draw white core circle                                                         
 * │ 6. Draw eye expression if not neutral                                             
 * │ 7. Apply special effects (jitter, zen morph, etc.)                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚙️  CONFIGURABLE PROPERTIES                                                       
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • coreSizeDivisor  : Orb size relative to canvas (default: 12)                    
 * │ • glowMultiplier   : Glow radius vs core (default: 2.5x)                          
 * │ • breathingSpeed   : Breaths per minute (default: 16)                             
 * │ • breathingDepth   : Scale variation % (default: 8%)                              
 * │ • renderingStyle   : 'classic' | 'soft' | 'sharp'                                 
 * │ • referenceSize    : Reference canvas size for scaling (default: 400)             
 * │ • baseScale        : Global scale multiplier (default: 1.0)                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 👁️ EYE EXPRESSION SYSTEM                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Openness    : 0.0 (closed) to 1.0 (fully open)                                  
 * │ • Arc         : -1.0 (sad ∩) to 1.0 (happy ∪)                                    
 * │ • Asymmetry   : Different shapes for left/right eyes                              
 * │ • Blinking    : Smooth open/close animations                                      
 * │ • Zen Morph   : Special ∩∩ shape for meditation                                   
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ PERFORMANCE CRITICAL                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ Gradient caching     → Recreating gradients kills FPS                          
 * │ ✗ Canvas save/restore  → Excessive use causes slowdown                           
 * │ ✗ Clear rect timing    → Motion blur depends on this                             
 * │ ✗ Animation frame IDs  → Must track to prevent memory leaks                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class EmotiveRenderer {
    constructor(canvasManager, options = {}) {
        this.canvasManager = canvasManager;
        this.ctx = canvasManager.getContext();
        
        // Gesture compositor for emotion/undertone modulation
        this.gestureCompositor = new GestureCompositor();
        
        // Initialize current undertone
        this.currentUndertone = null;
        
        // Initialize modular components
        this.gestureAnimator = new GestureAnimator(this);
        this.colorUtilities = new ColorUtilities();
        this.specialEffects = new SpecialEffects(this);
        this.eyeRenderer = new EyeRenderer(this);
        this.breathingAnimator = new BreathingAnimator(this);
        this.glowRenderer = new GlowRenderer(this);
        this.coreRenderer = new CoreRenderer(this);
        this.rotationBrake = new RotationBrake(this);
        this.ambientDanceAnimator = new AmbientDanceAnimator(this);

        // Configuration - matching original Emotive proportions
        this.config = {
            coreColor: options.coreColor || '#FFFFFF',
            coreSizeDivisor: options.coreSizeDivisor || 12,  // Core radius = min(width,height) / 12
            glowMultiplier: options.glowMultiplier || 2.5,   // Glow radius = core radius * 2.5
            defaultGlowColor: options.defaultGlowColor || '#14B8A6',  // Teal
            breathingSpeed: options.breathingSpeed || 0.42,  // 16 breaths/min (0.42 rad/s = 4 sec/cycle = 15-16 bpm)
            breathingDepth: options.breathingDepth || 0.08,  // 8% size variation for visible breathing
            renderingStyle: options.renderingStyle || 'classic',
            baseScale: options.baseScale || 1.0,  // Global scale multiplier for entire system
            referenceSize: 400,  // Reference canvas size for scale calculations
            topOffset: options.topOffset || 0,  // Vertical offset to align with layout
            positionController: options.positionController || null  // Position controller for eccentric positioning
        };
        
        // Initialize scaleFactor based on current canvas size
        const canvasSize = Math.min(
            this.canvasManager.width || 400, 
            this.canvasManager.height || 400
        );
        this.scaleFactor = (canvasSize / this.config.referenceSize) * this.config.baseScale;
        
        // State
        this.state = {
            emotion: 'neutral',
            glowColor: this.config.defaultGlowColor,
            glowIntensity: 1.0,
            breathRate: 1.0,
            breathDepth: this.config.breathingDepth,
            coreJitter: false,
            speaking: false,
            recording: false,
            sleeping: false,
            blinking: false,
            blinkingEnabled: true,  // Add flag to control blinking
            gazeOffset: { x: 0, y: 0 },
            gazeIntensity: 0,
            gazeLocked: false,
            gazeTrackingEnabled: false,  // Whether to track mouse/touch
            gazeTarget: { x: 0, y: 0 },  // Target position for gaze (-1 to 1)
            zenVortexIntensity: 1.0,  // Adjustable whirlpool intensity for zen
            effectiveCenter: { x: 0, y: 0, scale: 1.0 },  // Effective center with position offsets
            // Suspicion state
            squintAmount: 0,         // 0-1, how much the eye is narrowed
            targetSquintAmount: 0,   // Target squint amount to animate to
            scanPhase: 0,            // Current phase of scanning animation
            lastScanTime: 0,         // Last time we did a scan
            isSuspicious: false,     // Track if we're in suspicion mode
            // Custom scale for breathing
            customScale: null,       // When set, overrides normal breathing scale
            // Undertone modifiers - initialize with defaults
            sizeMultiplier: 1.0,
            jitterAmount: 0,
            episodicFlutter: false,
            glowRadiusMult: 1.0,
            breathRateMult: 1.0,
            breathDepthMult: 1.0,
            breathIrregular: false,
            particleRateMult: 1.0,
            // Glow and color effects - initialize with defaults
            glowPulse: 0,
            brightnessFlicker: 0,
            brightnessMult: 1.0,
            saturationMult: 1.0,
            hueShift: 0,
            // Manual rotation control (not BPM-locked)
            manualRotation: 0,        // Current rotation angle in DEGREES
            rotationSpeed: 0,         // Rotation speed in DEGREES per frame (like velocity in demo)
            lastRotationUpdate: performance.now()
        };
        
        // Animation state (now delegated to modules)
        // Breathing is handled by BreathingAnimator
        // Blinking is handled by EyeRenderer
        
        // Track animation frame IDs to prevent memory leaks
        this.animationFrameIds = {
            colorTransition: null,
            eyeClose: null,
            eyeOpen: null,
            zenEnter: null,
            zenExit: null
        };

        // Track loop manager callback IDs
        this.loopCallbackIds = {
            eyeClose: null,
            eyeOpen: null,
            zenEnter: null,
            zenExit: null
        };
        
        // Offscreen canvas for double buffering
        this.offscreenCanvas = null;
        this.offscreenCtx = null;
        this.initOffscreenCanvas();

        // Store canvas reference for gaze tracking
        this.canvas = canvasManager.canvas;
        
        // Cache for expensive gradients
        this.glowCache = new Map();
        this.maxCacheSize = 10;
        
        // Gesture animations
        this.gestureAnimations = {
            bounce: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            pulse: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            shake: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            spin: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            nod: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            tilt: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            expand: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            contract: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            flash: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            drift: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null,
                startX: 0,
                startY: 0
            },
            stretch: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            glow: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            flicker: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            vibrate: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            wave: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathe: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            morph: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            slowBlink: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            look: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null,
                targetX: 0,
                targetY: 0
            },
            settle: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathIn: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathOut: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathHold: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            breathHoldEmpty: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            jump: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            orbital: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            },
            hula: {
                active: false,
                startTime: 0,
                progress: 0,
                params: null
            }
        };
        
        // Episodic effects for undertones
        this.episodicEffects = {
            nervous: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 3000 + Math.random() * 2000 // 3-5 seconds
            },
            confident: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 4000 + Math.random() * 2000 // 4-6 seconds
            },
            tired: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 5000 + Math.random() * 2000 // 5-7 seconds
            },
            intense: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 3000 + Math.random() * 3000 // 3-6 seconds
            },
            subdued: {
                active: false,
                startTime: 0,
                duration: 0,
                intensity: 0,
                nextTrigger: 4000 + Math.random() * 3000 // 4-7 seconds
            }
        };
        
        // Speaking animation
        this.speakingRings = [];
        this.maxRings = 5;
        this.ringSpawnTimer = 0;
        this.ringSpawnInterval = 200; // ms between rings
        
        // Recording animation (rings move inward)
        this.recordingRings = [];
        this.recordingPulse = 0;
        
        // Sleep state - consolidated here for visualization
        this.sleepZ = [];
        
        // Zen state animation
        this.zenTransition = {
            active: false,
            phase: null, // 'entering', 'in', 'exiting'
            startTime: 0,
            previousEmotion: null,
            targetEmotion: null,
            scaleX: 1.0,
            scaleY: 1.0,
            arcHeight: 0,
            lotusMorph: 0, // 0 = circle, 1 = full lotus
            petalSpread: 0, // 0 = closed, 1 = fully open
            smileCurve: 0  // 0 = straight, 1 = full smile
        };
        
        // Standardized color transition system
        this.colorTransition = {
            active: false,
            fromColor: this.state.glowColor,
            toColor: this.state.glowColor,
            fromIntensity: this.state.glowIntensity,
            toIntensity: this.state.glowIntensity,
            progress: 0,
            startTime: 0,
            duration: 1500  // Default 1.5s
        };
        
        // Comprehensive undertone modifiers
        this.undertoneModifiers = {
            nervous: {
                // Color - subtle shimmer, no major shift
                hueShift: 0,          // No hue change
                saturationMult: 1.05, // Tiny bit more vivid
                brightnessMult: 1.0,  // Normal brightness
                brightnessFlicker: 0.05, // 5% brightness variation
                // Visual
                sizeMultiplier: 1.0,  // Normal size
                jitterAmount: 0,      // No constant jitter - handled by episodic flutter
                episodicFlutter: true, // Occasional butterfly moments
                glowRadiusMult: 1.0,  // Normal glow
                glowPulse: 0.05,      // 5% subtle heartbeat pulse
                // Breathing
                breathRateMult: 1.1,  // Slightly faster
                breathDepthMult: 0.9, // Slightly shallower
                breathIrregular: true, // Occasional catch in rhythm
            },
            confident: {
                // Color - warmer, vibrant
                hueShift: 15,         // Warmer but not overwhelming
                saturationMult: 1.2,  // More vibrant
                brightnessMult: 1.1,  // Slightly brighter
                // Visual
                sizeMultiplier: 1.0,  // Normal size until episodes
                jitterAmount: 0,      // Rock solid
                episodicPowerPose: true, // Occasional chest puffs
                glowRadiusMult: 1.15, // Slightly expanded glow
                // Breathing
                breathRateMult: 0.95, // Slightly slower, controlled
                breathDepthMult: 1.1, // Fuller breaths
                breathIrregular: false,
            },
            tired: {
                // Color - slightly cooler, less saturated
                hueShift: -5,         // Slightly cooler
                saturationMult: 0.7,  // Less vibrant
                brightnessMult: 0.85, // Slightly darker
                // Visual
                sizeMultiplier: 0.95, // Slightly smaller
                jitterAmount: 0,
                episodicMicroSleep: true, // Occasional drowsy sags
                glowRadiusMult: 0.9,  // Slightly reduced glow
                // Breathing
                breathRateMult: 0.8,  // Slower
                breathDepthMult: 1.2, // Deeper breaths
                breathIrregular: false,
            },
            intense: {
                // Color - high contrast, saturated
                hueShift: 5,          // Very slightly warmer
                saturationMult: 1.3,  // More saturated
                brightnessMult: 1.15, // Brighter
                // Visual
                sizeMultiplier: 1.0,  // Normal until focus moments
                jitterAmount: 0,      // Still, focused
                episodicLaserFocus: true, // Brief concentration moments
                glowRadiusMult: 1.2,  // Expanded glow
                // Breathing
                breathRateMult: 1.2,  // Faster but controlled
                breathDepthMult: 0.9, // Shallower, focused breaths
                breathIrregular: false,
            },
            subdued: {
                // Color - slightly muted
                hueShift: -10,        // Slightly cooler
                saturationMult: 0.75, // Somewhat muted
                brightnessMult: 0.9,  // Slightly dimmed
                // Visual
                sizeMultiplier: 0.95, // Slightly smaller
                jitterAmount: 0,
                episodicWithdrawal: true, // Brief inward pulls
                glowRadiusMult: 0.85, // Slightly reduced glow
                // Breathing
                breathRateMult: 0.9,  // Slightly slower
                breathDepthMult: 0.9, // Slightly shallow
                breathIrregular: false,
            }
        };
        
        // Performance
        this.lastFrameTime = 0;
        
    }
    
    /**
     * Scale a value based on current canvas size vs reference size
     * Used to scale hard-coded values like shadowBlur, lineWidth, etc.
     * @param {number} value - The base value to scale
     * @returns {number} The scaled value
     */
    scaleValue(value) {
        return value * this.scaleFactor;
    }
    
    /**
     * Initialize offscreen canvas for double buffering
     */
    initOffscreenCanvas() {
        // Create offscreen canvas
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d', {
            alpha: true,
            desynchronized: true,  // Reduces latency
            willReadFrequently: false
        });
        
        // Match dimensions
        this.updateOffscreenSize();
    }
    
    /**
     * Update offscreen canvas size to match main canvas
     */
    updateOffscreenSize() {
        if (this.offscreenCanvas && this.canvasManager) {
            const {width} = this.canvasManager.canvas;
            const {height} = this.canvasManager.canvas;

            if (this.offscreenCanvas.width !== width || this.offscreenCanvas.height !== height) {
                this.offscreenCanvas.width = width;
                this.offscreenCanvas.height = height;

                // CRITICAL: Only scale offscreen context if main canvas context is DPR-scaled
                // For fixed-size canvases (with width/height attributes), CanvasManager doesn't
                // apply DPR scaling, so we shouldn't scale the offscreen context either
                // Check if canvas is DPR-scaled: canvas.width > logical width means DPR scaling is applied
                const isDprScaled = this.canvasManager.canvas.width > this.canvasManager.width;

                if (this.offscreenCtx) {
                    this.offscreenCtx.setTransform(1, 0, 0, 1, 0, 0);
                    if (isDprScaled && this.canvasManager.dpr) {
                        this.offscreenCtx.scale(this.canvasManager.dpr, this.canvasManager.dpr);
                    }
                }
            }
        }
    }
    
    /**
     * Update effective center coordinates from position controller
     * @param {Object} effectiveCenter - {x, y, scale} coordinates
     */
    updateEffectiveCenter(effectiveCenter) {
        this.state.effectiveCenter = effectiveCenter;
    }
    
    /**
     * Get effective center coordinates (with position offsets applied)
     * @returns {Object} Effective center {x, y, scale}
     */
    getEffectiveCenter() {
        const baseCenter = this.canvasManager.getCenter();
        let effectiveCenter;
        if (this.config.positionController) {
            effectiveCenter = this.config.positionController.getEffectiveCenter(baseCenter.x, baseCenter.y);
        } else {
            effectiveCenter = { x: baseCenter.x, y: baseCenter.y, scale: 1.0 };
        }
        
        // Include gaze offset so particles spawn from the same center as the visual mascot
        effectiveCenter.x += this.state.gazeOffset.x;
        effectiveCenter.y += this.state.gazeOffset.y;
        
        return effectiveCenter;
    }
    
    /**
     * Main render method
     */
    render(state, deltaTime, gestureTransform = null) {
        // Performance marker: Frame start
        if (this.performanceMonitor) {
            this.performanceMonitor.markFrameStart();
        }
        const frameStartTime = performance.now();

        // Handle forced clean render after tab switch
        if (this.forceCleanRender) {
            this.forceCleanRender = false;
            // Clear any rendering artifacts
            if (this.canvas && this.ctx) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // Get ambient dance transform and merge with gesture transform
        const ambientTransform = this.ambientDanceAnimator.getTransform(deltaTime);
        if (gestureTransform) {
            // Merge transforms
            gestureTransform.x = (gestureTransform.x || 0) + (ambientTransform.x || 0);
            gestureTransform.y = (gestureTransform.y || 0) + (ambientTransform.y || 0);
            gestureTransform.rotation = (gestureTransform.rotation || 0) + (ambientTransform.rotation || 0);
            gestureTransform.scale = (gestureTransform.scale || 1) * (ambientTransform.scale || 1);
        } else {
            gestureTransform = ambientTransform;
        }

        // Store gestureTransform for use in other methods
        this.gestureTransform = gestureTransform;

        // Update offscreen canvas size if needed
        this.updateOffscreenSize();
        
        // Get logical dimensions from canvasManager (not scaled by DPR)
        const logicalWidth = this.canvasManager.width || this.canvas.width || 400;
        const logicalHeight = this.canvasManager.height || this.canvas.height || 400;
        
        // Store original context and switch to offscreen for double buffering
        const originalCtx = this.ctx;
        this.ctx = this.offscreenCtx;

        // Apply decay to main canvas to prevent glow accumulation
        // Scale decay with particle count to handle high-particle emotions like euphoria
        const particleCount = this.particleSystem ? this.particleSystem.particles.length : 0;
        // Base decay: 12%, increased up to 20% for high particle counts
        const decayRate = 0.12 + Math.min(0.08, particleCount * 0.003);

        originalCtx.save();
        originalCtx.globalCompositeOperation = 'destination-out';
        originalCtx.fillStyle = `rgba(0, 0, 0, ${decayRate})`;
        originalCtx.fillRect(0, 0, logicalWidth, logicalHeight);
        originalCtx.restore();

        // Clear offscreen canvas for fresh render
        this.ctx.clearRect(0, 0, logicalWidth, logicalHeight);
        
        // Update undertone modifiers every frame during transitions
        if (this.stateMachine && this.stateMachine.getWeightedUndertoneModifiers) {
            const weightedModifier = this.stateMachine.getWeightedUndertoneModifiers();
            if (weightedModifier) {
                this.applyUndertoneModifiers(weightedModifier);
            } else {
                // Reset to defaults when no undertone
                this.applyUndertoneModifiers(null);
            }
        }
        
        // Update color transition (if active)
        if (this.colorTransition && this.colorTransition.active) {
            this.updateColorTransition(deltaTime);
        }
        
        // Update animation timers
        this.updateTimers(deltaTime);
        
        // Update gaze offset
        if (this.state.gazeTrackingEnabled) {
            // When gaze tracking is enabled, follow mouse/touch
            const smoothing = 0.15;
            const maxOffset = 50; // Maximum pixels the orb can move
            this.state.gazeOffset.x += (this.state.gazeTarget.x * maxOffset - this.state.gazeOffset.x) * smoothing;
            this.state.gazeOffset.y += (this.state.gazeTarget.y * maxOffset - this.state.gazeOffset.y) * smoothing;
        } else {
            // When gaze tracking is disabled, return to center
            const smoothing = 0.1;
            this.state.gazeOffset.x += (0 - this.state.gazeOffset.x) * smoothing;
            this.state.gazeOffset.y += (0 - this.state.gazeOffset.y) * smoothing;
        }
        
        // Calculate dimensions - using logical size for proper scaling
        const canvasSize = Math.min(logicalWidth, logicalHeight);
        
        // Get effective center coordinates (with position offsets applied)
        const effectiveCenter = this.getEffectiveCenter();
        let centerX = effectiveCenter.x;
        let centerY = effectiveCenter.y - this.config.topOffset;
        
        // Apply vertical offset for certain emotions (like excited for exclamation mark)
        if (state.properties && state.properties.verticalOffset) {
            centerY = effectiveCenter.y - this.config.topOffset + (logicalHeight * state.properties.verticalOffset);
        }
        
        // Calculate global scale factor for core rendering (uses coreScale for independent control)
        this.scaleFactor = (canvasSize / this.config.referenceSize) * this.config.baseScale * (effectiveCenter.coreScale || effectiveCenter.scale);

        // Store particle scale factor separately for particle system
        this.particleScaleFactor = (canvasSize / this.config.referenceSize) * this.config.baseScale * (effectiveCenter.particleScale || effectiveCenter.scale);
        
        // Apply gesture transform if present
        let scaleMultiplier = 1;
        let rotationAngle = 0;
        let glowMultiplier = 1;
        
        if (gestureTransform) {
            centerX += gestureTransform.x || 0;
            centerY += gestureTransform.y || 0;
            scaleMultiplier = gestureTransform.scale || 1;
            rotationAngle = (gestureTransform.rotation || 0) * Math.PI / 180;
            glowMultiplier = gestureTransform.glowIntensity || 1;
        }

        // Apply gesture animations (delegate to GestureAnimator)
        const gestureTransforms = this.gestureAnimator.applyGestureAnimations();
        if (gestureTransforms) {
            centerX += gestureTransforms.offsetX || 0;
            centerY += gestureTransforms.offsetY || 0;
            scaleMultiplier *= gestureTransforms.scale || 1;
            rotationAngle += (gestureTransforms.rotation || 0) * Math.PI / 180;
            // DON'T MULTIPLY - just use the glow value directly to prevent accumulation
            glowMultiplier = gestureTransforms.glow || 1;
        }
        
        // Apply zen levitation - lazy floating when in zen state
        if (this.state.emotion === 'zen' && this.zenTransition.phase === 'in') {
            const time = Date.now() / 1000;
            // Lazy vertical float - slow sine wave
            const floatY = Math.sin(time * 0.3) * 15 * this.scaleFactor; // Very slow, 15px amplitude
            // Gentle horizontal sway - even slower
            const swayX = Math.sin(time * 0.2) * 8 * this.scaleFactor; // Subtle 8px sway
            // Small rotation for ethereal effect
            const floatRotation = Math.sin(time * 0.25) * 0.05; // ±3 degrees
            
            centerY += floatY;
            centerX += swayX;
            rotationAngle += floatRotation;
        }
        
        // Apply sleep state modifications (with animated dimming)
        let sleepOpacityMod = 1;
        let sleepScaleMod = 1;
        let glowOpacityMod = 1;
        if (this.state.sleeping || this.state.emotion === 'resting' || isEffectActive('sleeping', this.state)) {
            const sleepEffect = getEffect('sleeping');
            if (sleepEffect) {
                const dimming = sleepEffect.getDimmingValues();
                // Use effect's dimming values
                sleepOpacityMod = this.state.sleepDimness !== undefined ? this.state.sleepDimness : dimming.orbDimming;
                glowOpacityMod = dimming.glowDimming; // Dim glow even more
                sleepScaleMod = this.state.sleepScale !== undefined ? this.state.sleepScale : 0.9;
            } else {
                // Fallback values
                sleepOpacityMod = this.state.sleepDimness !== undefined ? this.state.sleepDimness : 0.3;
                glowOpacityMod = 0.2;
                sleepScaleMod = this.state.sleepScale !== undefined ? this.state.sleepScale : 0.9;
            }
            this.state.breathRate = 0.5;  // Slower breathing
            this.state.breathDepth = 0.15; // Deeper breaths
        }
        
        // Calculate breathing factors - INVERSE for core and glow
        // Use custom scale if set (for breathing exercises), otherwise use normal breathing
        let coreBreathFactor, glowBreathFactor;
        
        if (this.state.customScale !== null) {
            // Use custom scale directly for breathing exercises
            coreBreathFactor = this.state.customScale;
            glowBreathFactor = 1 + (this.state.customScale - 1) * 0.5; // Glow follows at half intensity
        } else {
            // Get breathing scale from BreathingAnimator
            const breathingScale = this.breathingAnimator.getBreathingScale();
            coreBreathFactor = breathingScale;
            glowBreathFactor = 1 - (breathingScale - 1) * 0.5; // Glow breathes opposite, less pronounced
        }
        
        // Add nervous glow pulse if needed
        if (this.state.undertone === 'nervous' && this.undertoneModifiers.nervous.glowPulse) {
            const nervousPulse = Math.sin(Date.now() / 200) * this.undertoneModifiers.nervous.glowPulse; // Fast subtle pulse
            glowBreathFactor *= (1 + nervousPulse);
        }
        
        // Calculate core dimensions - using unified scale factor
        const baseRadius = (this.config.referenceSize / this.config.coreSizeDivisor) * this.scaleFactor;
        
        // Apply emotion core size from state properties
        const emotionSizeMult = (state.properties && state.properties.coreSize) ? state.properties.coreSize : 1.0;
        
        // Apply undertone size multiplier
        const undertoneSizeMult = this.state.sizeMultiplier || 1.0;
        
        let coreRadius = baseRadius * emotionSizeMult * coreBreathFactor * scaleMultiplier * sleepScaleMod * undertoneSizeMult;
        let glowRadius = baseRadius * this.config.glowMultiplier * glowBreathFactor * this.state.glowIntensity * scaleMultiplier * sleepScaleMod * undertoneSizeMult * glowMultiplier;  // Apply gesture glow multiplier

        // Use state glow intensity directly multiplied by gesture glow
        const effectiveGlowIntensity = this.state.glowIntensity * glowMultiplier;
        
        
        // Apply blinking (only when not sleeping or zen)
        if (!this.state.sleeping && this.state.emotion !== 'zen') {
            const blinkScale = this.eyeRenderer.getBlinkScale();
            coreRadius *= blinkScale; // Apply blink squish
        }
        
        // Apply jitter if needed (anger, fear, or undertone jitter)
        let jitterX = 0, jitterY = 0;
        const jitterAmount = this.state.jitterAmount || 0;
        
        // Handle episodic effects for undertones
        if (this.currentUndertone && this.episodicEffects[this.currentUndertone]) {
            const episode = this.episodicEffects[this.currentUndertone];
            const now = performance.now();
            
            // Check if it's time to trigger a new episode
            if (!episode.active && now >= episode.nextTrigger) {
                episode.active = true;
                episode.startTime = now;
                
                // Set episode parameters based on undertone type
                switch(this.currentUndertone) {
                case 'nervous':
                    episode.duration = 500 + Math.random() * 500; // 0.5-1 second
                    episode.intensity = 2 + Math.random(); // 2-3px flutter
                    episode.nextTrigger = now + 3000 + Math.random() * 2000; // 3-5 seconds
                    break;
                case 'confident':
                    episode.duration = 1000 + Math.random() * 1000; // 1-2 seconds
                    episode.intensity = 0.15; // 15% size expansion
                    episode.nextTrigger = now + 4000 + Math.random() * 2000; // 4-6 seconds
                    break;
                case 'tired':
                    episode.duration = 1000 + Math.random() * 2000; // 1-3 seconds
                    episode.intensity = 0.2; // 20% size reduction
                    episode.nextTrigger = now + 5000 + Math.random() * 2000; // 5-7 seconds
                    break;
                case 'intense':
                    episode.duration = 500 + Math.random() * 500; // 0.5-1 second
                    episode.intensity = 0.5; // 50% glow boost, 5% size shrink
                    episode.nextTrigger = now + 3000 + Math.random() * 3000; // 3-6 seconds
                    break;
                case 'subdued':
                    episode.duration = 2000 + Math.random() * 1000; // 2-3 seconds
                    episode.intensity = 0.3; // 30% glow dim, 10% size shrink
                    episode.nextTrigger = now + 4000 + Math.random() * 3000; // 4-7 seconds
                    break;
                }
            }
            
            // Apply episode effects if active
            if (episode.active) {
                const elapsed = now - episode.startTime;
                
                if (elapsed < episode.duration) {
                    const progress = elapsed / episode.duration;
                    
                    // Apply different effects based on undertone
                    switch(this.currentUndertone) {
                    case 'nervous': {
                        // Quick shiver that settles
                        const damping = 1 - progress;
                        const frequency = 15;
                        const flutter = Math.sin(progress * Math.PI * frequency) * damping;
                        jitterX = flutter * episode.intensity;
                        jitterY = flutter * episode.intensity * 0.7;
                        break;
                    }
                            
                    case 'confident': {
                        // Smooth chest puff that settles
                        const puffCurve = Math.sin(progress * Math.PI); // Smooth rise and fall
                        coreRadius *= (1 + episode.intensity * puffCurve);
                        glowRadius *= (1 + episode.intensity * 0.5 * puffCurve);
                        break;
                    }
                            
                    case 'tired': {
                        // Drowsy sag with slow recovery
                        const sagCurve = Math.sin(progress * Math.PI * 0.5); // Slow droop
                        coreRadius *= (1 - episode.intensity * sagCurve);
                        // Also affect vertical position slightly
                        jitterY += sagCurve * 5; // Slight downward sag
                        break;
                    }
                            
                    case 'intense': {
                        // Sharp contraction with glow surge
                        const focusCurve = 1 - Math.cos(progress * Math.PI); // Quick in-out
                        coreRadius *= (1 - 0.05 * focusCurve); // 5% shrink
                        glowRadius *= (1 + episode.intensity * focusCurve); // 50% glow boost
                        break;
                    }
                            
                    case 'subdued': {
                        // Gentle inward pull
                        const withdrawCurve = Math.sin(progress * Math.PI * 0.5); // Slow pull
                        coreRadius *= (1 - 0.1 * withdrawCurve); // 10% shrink
                        glowRadius *= (1 - episode.intensity * withdrawCurve); // 30% glow dim
                        break;
                    }
                    }
                } else {
                    // Episode finished
                    episode.active = false;
                }
            }
        } else if (this.state.coreJitter || jitterAmount > 0) {
            // Regular jitter for other emotions
            const jitterStrength = Math.max(jitterAmount, this.state.coreJitter ? this.scaleValue(2) : 0);
            jitterX = (Math.random() - 0.5) * jitterStrength;
            jitterY = (Math.random() - 0.5) * jitterStrength;
        }
        
        // Calculate positions with gaze offset
        const coreX = centerX + this.state.gazeOffset.x + jitterX;
        const coreY = centerY + this.state.gazeOffset.y + jitterY;
        
        // Check if brake is active and update rotation accordingly
        const now = performance.now();

        if (this.rotationBrake && this.rotationBrake.isBraking()) {
            // Brake is active - let it control rotation
            const brakeUpdate = this.rotationBrake.updateBrake(now);
            if (brakeUpdate) {
                this.state.manualRotation = brakeUpdate.rotation;
                this.state.rotationSpeed = brakeUpdate.complete ? 0 : brakeUpdate.speed;
            }
        } else if (this.state.rotationSpeed !== 0) {
            // Normal rotation update - just add velocity each frame (DEGREES)
            this.state.manualRotation += this.state.rotationSpeed;
        }

        // Calculate total rotation (gestures + manual rotation)
        // Convert manual rotation from degrees to radians for rendering
        const totalRotation = rotationAngle + (this.state.manualRotation * Math.PI / 180);

        // Apply rotation if present
        if (totalRotation !== 0) {
            this.ctx.save();
            this.ctx.translate(coreX, coreY);
            this.ctx.rotate(totalRotation);
            this.ctx.translate(-coreX, -coreY);
        }
        
        // Render glow with visual effects
        if (isEffectActive('recording-glow', this.state)) {
            // Recording takes precedence over normal glow
            applyEffect('recording-glow', this.ctx, {
                x: coreX,
                y: coreY,
                radius: glowRadius,
                deltaTime
            });
        } else if (isEffectActive('zen-vortex', this.state)) ; else {
            // Normal glow with sleep dimming
            if (this.state.sleeping || this.state.emotion === 'resting' || isEffectActive('sleeping', this.state)) {
                this.ctx.save();
                this.ctx.globalAlpha = glowOpacityMod;
                this.glowRenderer.renderGlow(coreX, coreY, glowRadius, { intensity: effectiveGlowIntensity });
                this.ctx.restore();
            } else {
                this.glowRenderer.renderGlow(coreX, coreY, glowRadius, { intensity: effectiveGlowIntensity });
            }
        }
        
        // Render flash wave if present
        if (gestureTransforms && gestureTransforms.flashWave) {
            const wave = gestureTransforms.flashWave;
            const {ctx} = this;
            
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            // Create a ring gradient for the wave
            const innerR = coreRadius * wave.innerRadius;
            const outerR = coreRadius * wave.outerRadius;
            
            if (outerR > innerR) {
                // Use cached gradient for flash wave
                const gradient = gradientCache.getRadialGradient(
                    ctx, coreX, coreY, innerR, coreX, coreY, outerR,
                    [
                        { offset: 0, color: 'rgba(255, 255, 255, 0)' },
                        { offset: 0.2, color: `rgba(255, 255, 255, ${wave.intensity * 0.15})` },
                        { offset: 0.5, color: `rgba(255, 255, 255, ${wave.intensity * 0.25})` }, // Peak in center
                        { offset: 0.8, color: `rgba(255, 255, 255, ${wave.intensity * 0.15})` },
                        { offset: 1, color: 'rgba(255, 255, 255, 0)' }
                    ]
                );

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(coreX, coreY, outerR, 0, Math.PI * 2);
                ctx.arc(coreX, coreY, Math.max(0, innerR), 0, Math.PI * 2, true);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Apply speaking pulse effect
        if (isEffectActive('speaking-pulse', this.state)) {
            applyEffect('speaking-pulse', this.ctx, {
                x: coreX,
                y: coreY,
                radius: coreRadius,
                audioLevel: this.state.audioLevel || 0,
                deltaTime
            });
        }
        
        // Recording indicator will be drawn after all transforms are restored
        
        // Apply sleep opacity to core
        if (this.state.sleeping || this.state.emotion === 'resting') {
            this.ctx.globalAlpha = sleepOpacityMod;
        }
        
        // Render core (will cover REC if they overlap)
        // Delegate core rendering to CoreRenderer
        // First update the shape morpher if available
        let shapePoints = null;
        let currentShadow = null;
        if (this.shapeMorpher) {
            this.shapeMorpher.update();
            // Get the canvas points relative to center (0,0) since CoreRenderer will translate
            shapePoints = this.shapeMorpher.getCanvasPoints(0, 0, coreRadius);
            currentShadow = this.shapeMorpher.getCurrentShadow();
        }
        
        // Render sun effects BEFORE core (so they appear behind)
        let renderingSunEffects = false;
        if (currentShadow && (currentShadow.type === 'sun' || currentShadow.type === 'solar-hybrid')) {
            this.renderSunEffects(coreX, coreY, coreRadius, currentShadow);
            renderingSunEffects = true;
        }
        
        // Drop shadow removed - was causing dimming
        
        // Update core rotation based on BPM (like a record player)
        // Only rotate if BPM is greater than 0 (rhythm is active)
        // Shapes that should NOT rotate: moon, heart
        
        // Render the core shape with rotation
        // Note: We already applied rotation to the canvas, but CoreRenderer does its own transform
        // So we need to pass the rotation value to it
        this.coreRenderer.renderCore(coreX, coreY, coreRadius, {
            scaleX: 1,
            scaleY: 1,
            rotation: totalRotation,
            shapePoints
        });
        
        // Update and render sparkles BEFORE moon shadow so they don't cover it
        if (this.specialEffects) {
            this.specialEffects.update(deltaTime);
            this.specialEffects.renderSparkles();
        }
        
        // Check if we're dealing with solar transitions
        const currentShape = this.shapeMorpher ? this.shapeMorpher.currentShape : null;
        const targetShape = this.shapeMorpher ? this.shapeMorpher.targetShape : null;
        const isTransitioningToSolar = this.shapeMorpher && targetShape === 'solar' && this.shapeMorpher.isTransitioning;
        const isTransitioningFromSolar = this.shapeMorpher && currentShape === 'solar' && this.shapeMorpher.isTransitioning;
        const isAtSolar = currentShadow && currentShadow.type === 'solar-hybrid';
        
        // Check specific transition directions
        const isSolarToMoon = this.shapeMorpher && this.shapeMorpher.isTransitioning &&
            currentShape === 'solar' && targetShape === 'moon';
        const isMoonToSolar = this.shapeMorpher && this.shapeMorpher.isTransitioning &&
            currentShape === 'moon' && targetShape === 'solar';
        
        // Render moon/lunar shadows AFTER core AND sparkles (as top overlay)
        // Always render moon shadow EXCEPT when transitioning FROM moon TO solar
        if (currentShadow && (currentShadow.type === 'crescent' || currentShadow.type === 'lunar') && 
            !isMoonToSolar) {
            // Shadow is rendered in the already-rotated coordinate space
            this.renderMoonShadow(coreX, coreY, coreRadius, currentShadow, shapePoints, false, 0);
        }
        
        // For solar-hybrid, render lunar overlay on top of sun
        // Skip when transitioning FROM solar TO moon (let moon's shadow handle it)
        if (((isAtSolar && currentShadow.lunarOverlay) || isTransitioningToSolar || isTransitioningFromSolar) && 
            !isSolarToMoon) {
            // Use the lunar overlay from solar definition
            const lunarShadow = (isAtSolar && currentShadow.lunarOverlay) ? currentShadow.lunarOverlay : {
                type: 'lunar',
                coverage: 1.0,
                color: 'rgba(0, 0, 0, 1.0)',
                progression: 'center'
            };
            
            // Calculate shadow offset for Bailey's Beads
            let shadowOffsetX = 0;
            let shadowOffsetY = 0;
            let morphProgress = 0;
            
            if (this.shapeMorpher) {
                morphProgress = this.shapeMorpher.getProgress();
                
                const slideDistance = coreRadius * 2.5;
                
                if (isTransitioningToSolar && morphProgress < 1) {
                    // Shadow sliding in from bottom-left
                    shadowOffsetX = -slideDistance * (1 - morphProgress);
                    shadowOffsetY = slideDistance * (1 - morphProgress);
                } else if (isTransitioningFromSolar && morphProgress < 1) {
                    // Shadow sliding out to top-right
                    shadowOffsetX = slideDistance * morphProgress;
                    shadowOffsetY = -slideDistance * morphProgress;
                }
            }
            
            // Render the shadow
            this.renderMoonShadow(coreX, coreY, coreRadius, lunarShadow, shapePoints, true);
            
            // Render Bailey's Beads during transitions
            // Show beads when transitioning TO solar (which will have rays) or FROM solar (which had rays)
            // But only if we're actually rendering or about to render sun effects
            const willHaveSunEffects = isTransitioningToSolar || renderingSunEffects;
            
            if ((isTransitioningToSolar || isTransitioningFromSolar) && willHaveSunEffects) {
                this.renderBaileysBeads(coreX, coreY, coreRadius, shadowOffsetX, shadowOffsetY, morphProgress, isTransitioningToSolar, true);
                
                // Trigger chromatic aberration when shadow is near center
                const shadowNearCenter = Math.abs(shadowOffsetX) < 30 && Math.abs(shadowOffsetY) < 30;
                if (shadowNearCenter && this.specialEffects) {
                    // Stronger aberration as shadow gets closer to center
                    const distance = Math.sqrt(shadowOffsetX * shadowOffsetX + shadowOffsetY * shadowOffsetY);
                    const intensity = Math.max(0.1, 0.5 * (1 - distance / 30));
                    this.specialEffects.triggerChromaticAberration(intensity);
                }
            }
        }
        
        // Reset alpha
        if (this.state.sleeping || this.state.emotion === 'resting') {
            this.ctx.globalAlpha = 1;
        }
        
        // Restore context if rotated
        if (totalRotation !== 0) {
            this.ctx.restore();
        }
        
        // Recording indicator is now handled by the recording-glow effect module
        // which draws a small indicator in the corner
        
        // Add sleep indicator if sleeping
        if (this.state.sleeping) {
            this.renderSleepIndicator(centerX, centerY - glowRadius - this.scaleValue(20), deltaTime);
        }
        
        // Restore original context AFTER all rendering is done
        this.ctx = originalCtx;

        // Blit offscreen canvas to main canvas
        // CRITICAL: Specify dimensions to properly scale DPR-sized offscreen canvas
        // back to logical size on the main canvas
        originalCtx.drawImage(this.offscreenCanvas, 0, 0, logicalWidth, logicalHeight);
        
        // Draw recording indicator on TOP of everything, with no transforms
        if (isEffectActive('recording-glow', this.state)) {
            const recordingEffect = getEffect('recording-glow');
            if (recordingEffect && recordingEffect.drawRecordingIndicator) {
                // Use original context to draw on top of the blitted image
                recordingEffect.drawRecordingIndicator(originalCtx, this.canvas.width, this.canvas.height);
            }
        }

        // Performance marker: Frame end
        const frameEndTime = performance.now();
        const frameTime = frameEndTime - frameStartTime;
        if (this.performanceMonitor) {
            this.performanceMonitor.markFrameEnd();
            this.performanceMonitor.recordFrameTime(frameTime);
        }
    }
    
    // renderGlow method removed - now handled by GlowRenderer module
    
    // getCachedGlow method removed - now handled by GlowRenderer module
    
    /**
     * Render recording glow (pulsating red)
     */
    renderRecordingGlow(x, y, radius, intensity) {
        // Get canvas dimensions with fallbacks
        const canvasWidth = this.canvas?.width || 600;
        const canvasHeight = this.canvas?.height || 600;
        
        // Limit radius to prevent clipping at canvas boundaries
        const maxRadius = Math.min(radius, 
            x - 10,  // Distance to left edge
            y - 10,  // Distance to top edge
            canvasWidth - x - 10,  // Distance to right edge
            canvasHeight - y - 10  // Distance to bottom edge
        );
        const safeRadius = Math.max(50, maxRadius); // Ensure minimum radius
        
        // Use cached gradient for the recording glow
        const gradient = gradientCache.getRadialGradient(
            this.ctx, x, y, 0, x, y, safeRadius,
            [
                { offset: 0, color: this.hexToRgba('#FF0000', 0.7 * intensity) },
                { offset: 0.3, color: this.hexToRgba('#FF0000', 0.5 * intensity) },
                { offset: 0.6, color: this.hexToRgba('#FF0000', 0.3 * intensity) },
                { offset: 0.85, color: this.hexToRgba('#FF0000', 0.1 * intensity) }, // Fade earlier
                { offset: 1, color: this.hexToRgba('#FF0000', 0) }
            ]
        );
        
        // Draw the recording glow
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(x, y, safeRadius, 0, Math.PI * 2);
        this.ctx.fill();
    }
    

    /**
     * Render drop shadow for depth
     */
    renderDropShadow(x, y, radius, shapePoints) {
        const {ctx} = this;
        
        // Skip shadow during rapid animations for better performance
        const isAnimating = this.shapeMorpher && this.shapeMorpher.isTransitioning;
        const hasAudioDeformation = this.shapeMorpher && 
                                   (this.shapeMorpher.audioDeformation > 0.1 || 
                                    this.shapeMorpher.vocalEnergy > 0.1);
        
        if (!hasAudioDeformation && (!isAnimating || this.shapeMorpher.morphProgress > 0.8)) {
            ctx.save();
            ctx.translate(x, y);
            
            const shadowOffset = this.scaleValue(2);
            ctx.translate(0, shadowOffset);
            
            // Use simpler shadow for complex deformed shapes
            if (shapePoints && shapePoints.length > 32) {
                // Simple dark circle shadow when shape is complex
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.arc(0, 0, radius * 1.05, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Shadow gradient - dark center fading to transparent
                const shadowGradient = ctx.createRadialGradient(0, 0, radius * 0.7, 0, 0, radius * 1.2);
                shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.2)');
                shadowGradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.1)');
                shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = shadowGradient;
                ctx.beginPath();
                if (shapePoints) {
                    // Scale points for shadow
                    const scale = 1.1;
                    const step = shapePoints.length > 20 ? 2 : 1; // Skip points for performance
                    ctx.moveTo(shapePoints[0].x * scale, shapePoints[0].y * scale);
                    for (let i = step; i < shapePoints.length; i += step) {
                        ctx.lineTo(shapePoints[i].x * scale, shapePoints[i].y * scale);
                    }
                    ctx.closePath();
                } else {
                    ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
                }
                ctx.fill();
            }
            ctx.restore();
        }
    }
    
    /**
     * Render sun effects (corona, rays, etc)
     */
    renderSunEffects(x, y, radius, shadow) {
        const {ctx} = this;
        const time = Date.now() / 100;
        
        ctx.save();
        ctx.translate(x, y);
        
        // 1. Surface texture - turbulent plasma
        if (shadow.texture && (shadow.textureOpacity === undefined || shadow.textureOpacity > 0)) {
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = shadow.textureOpacity !== undefined ? shadow.textureOpacity : 1;
            
            const offset = time * 0.05 * (shadow.turbulence || 0.3) / 0.3;
            const textureGradient = ctx.createRadialGradient(
                Math.sin(offset) * radius * 0.15,
                Math.cos(offset * 0.7) * radius * 0.15,
                radius * 0.2,
                0, 0, radius
            );
            textureGradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
            textureGradient.addColorStop(0.4, 'rgba(255, 200, 100, 0.1)');
            textureGradient.addColorStop(0.7, 'rgba(255, 150, 50, 0.08)');
            textureGradient.addColorStop(1, 'rgba(255, 100, 30, 0.05)');
            
            ctx.fillStyle = textureGradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // 2. Bright corona layers
        const coronaOpacity = shadow.coronaOpacity !== undefined ? shadow.coronaOpacity : 1;
        if (coronaOpacity > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Inner bright glow
            const innerGlow = ctx.createRadialGradient(0, 0, radius * 0.5, 0, 0, radius * 1.1);
            innerGlow.addColorStop(0, `rgba(255, 255, 255, ${0.8 * coronaOpacity})`);
            innerGlow.addColorStop(0.3, `rgba(255, 250, 200, ${0.6 * coronaOpacity})`);
            innerGlow.addColorStop(0.5, `rgba(255, 200, 100, ${0.4 * coronaOpacity})`);
            innerGlow.addColorStop(0.7, `rgba(255, 150, 50, ${0.2 * coronaOpacity})`);
            innerGlow.addColorStop(1, 'rgba(255, 100, 20, 0)');
            
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
            ctx.fill();
            
            // Outer corona with animation
            for (let i = 0; i < 2; i++) {
                const scale = 1.3 + i * 0.4;
                const opacity = (0.35 - i * 0.15) * coronaOpacity;
                const wobble = Math.sin(time * 0.1 + i) * 0.05;
                
                const coronaGradient = ctx.createRadialGradient(
                    0, 0, radius * (0.9 + wobble), 
                    0, 0, radius * (scale + wobble)
                );
                coronaGradient.addColorStop(0, 'rgba(255, 255, 200, 0)');
                coronaGradient.addColorStop(0.4, `rgba(255, 200, 100, ${opacity * 0.5})`);
                coronaGradient.addColorStop(0.7, `rgba(255, 150, 50, ${opacity})`);
                coronaGradient.addColorStop(0.9, `rgba(255, 100, 30, ${opacity * 0.5})`);
                coronaGradient.addColorStop(1, 'rgba(255, 50, 10, 0)');
                
                ctx.fillStyle = coronaGradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius * (scale + wobble), 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // 3. Optimized ethereal flame pennants - TONS of rays
        if (shadow.flares) {
            ctx.save();
            
            // Pre-calculate common values
            const wave1 = Math.sin(time * 0.08);
            const wave2 = Math.sin(time * 0.12);
            const wave3 = Math.sin(time * 0.16);
            
            // Create single gradient for all flames
            const grad = ctx.createLinearGradient(0, -radius, 0, -radius * 3);
            grad.addColorStop(0, 'rgba(255, 255, 230, 0.4)');
            grad.addColorStop(0.2, 'rgba(255, 220, 150, 0.25)');
            grad.addColorStop(0.5, 'rgba(255, 180, 80, 0.15)');
            grad.addColorStop(0.8, 'rgba(255, 120, 40, 0.08)');
            grad.addColorStop(1, 'rgba(255, 60, 20, 0)');
            
            ctx.fillStyle = grad;
            ctx.globalCompositeOperation = 'screen';
            
            // Single path for ALL flames
            ctx.beginPath();
            
            // Helper function for flame shape
            const addFlame = (angle, length, width, wave) => {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const baseX = cos * radius;
                const baseY = sin * radius;
                const tipX = cos * (radius + length);
                const tipY = sin * (radius + length);
                const perpX = -sin * width * 0.5;
                const perpY = cos * width * 0.5;
                const waveOffset = wave * width * 0.3;
                
                // Simple triangle with slight curve
                ctx.moveTo(baseX - perpX, baseY - perpY);
                ctx.quadraticCurveTo(
                    (baseX + tipX) * 0.5 + perpX * waveOffset,
                    (baseY + tipY) * 0.5 + perpY * waveOffset,
                    tipX, tipY
                );
                ctx.quadraticCurveTo(
                    (baseX + tipX) * 0.5 - perpX * waveOffset,
                    (baseY + tipY) * 0.5 - perpY * waveOffset,
                    baseX + perpX, baseY + perpY
                );
            };
            
            // Layer 1: Long primary rays (8)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + wave1 * 0.1;
                const length = radius * (1.8 + Math.sin(time * 0.1 + i * 0.5) * 0.4);
                const width = radius * 0.18;
                const wave = Math.sin(time * 0.15 + i);
                addFlame(angle, length, width, wave);
            }
            
            // Layer 2: Medium rays between primaries (12)
            for (let i = 0; i < 12; i++) {
                const angle = ((i + 0.5) / 12) * Math.PI * 2 + wave2 * 0.08;
                const length = radius * (1.2 + Math.sin(time * 0.13 + i * 0.7) * 0.3);
                const width = radius * 0.12;
                const wave = Math.sin(time * 0.18 + i * 1.2);
                addFlame(angle, length, width, wave);
            }
            
            // Layer 3: Short rays filling gaps (15)
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2 + wave3 * 0.05;
                const length = radius * (0.7 + Math.sin(time * 0.17 + i * 0.9) * 0.25);
                const width = radius * 0.08;
                const wave = Math.sin(time * 0.2 + i * 1.5);
                addFlame(angle, length, width, wave);
            }
            
            // Layer 4: Tiny rays for density (15)
            for (let i = 0; i < 15; i++) {
                const angle = ((i + 0.25) / 15) * Math.PI * 2;
                const length = radius * (0.4 + Math.sin(time * 0.22 + i) * 0.2);
                const width = radius * 0.06;
                // Simple triangles for tiny rays
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const baseX = cos * radius;
                const baseY = sin * radius;
                const tipX = cos * (radius + length);
                const tipY = sin * (radius + length);
                const perpX = -sin * width * 0.5;
                const perpY = cos * width * 0.5;
                
                ctx.moveTo(baseX - perpX, baseY - perpY);
                ctx.lineTo(tipX, tipY);
                ctx.lineTo(baseX + perpX, baseY + perpY);
            }
            
            // Single fill operation for all rays!
            ctx.fill();
            ctx.restore();
        }
        
        // 4. Bright rim lighting
        const rimGradient = ctx.createRadialGradient(0, 0, radius * 0.95, 0, 0, radius * 1.05);
        rimGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
        rimGradient.addColorStop(0.7, 'rgba(255, 255, 200, 0.2)');
        rimGradient.addColorStop(0.9, 'rgba(255, 200, 100, 0.5)');
        rimGradient.addColorStop(1, 'rgba(255, 150, 50, 0.3)');
        
        ctx.fillStyle = rimGradient;
        ctx.beginPath();
        ctx.arc(0, 0, radius * 1.05, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    /**
     * Render Bailey's Beads for solar eclipse
     */
    renderBaileysBeads(x, y, radius, shadowOffsetX, shadowOffsetY, morphProgress, isTransitioningToSolar, hasSunRays) {
        const {ctx} = this;
        
        // NEVER show beads if there are no sun rays visible
        if (!hasSunRays) {
            this._beadStartTime = null;
            return;
        }
        
        // Check if this is a lunar-solar transition (shadow stays centered)
        const isLunarSolarTransition = Math.abs(shadowOffsetX) < 1 && Math.abs(shadowOffsetY) < 1;
        
        // Show beads when shadow is approaching center OR for lunar-solar transitions
        // Different thresholds for entering vs leaving
        const threshold = isTransitioningToSolar ? 30 : 15; // Disappear faster when leaving
        const shadowNearCenter = Math.abs(shadowOffsetX) < threshold && Math.abs(shadowOffsetY) < threshold;
        
        if (!shadowNearCenter && !isLunarSolarTransition) {
            // Reset when not near center (unless it's lunar-solar)
            this._beadStartTime = null;
            return;
        }
        
        // Check if we need to generate new beads (first time shadow centers for this transition)
        if (!this._beadStartTime) {
            const beadCount = Math.floor(Math.random() * 4) + 1; // 1-4 beads
            
            this._currentBeads = [];
            
            // Create beads with random order
            const angles = [];
            for (let i = 0; i < beadCount; i++) {
                angles.push(Math.random() * Math.PI * 2);
            }
            
            // Shuffle the order they'll appear
            const order = Array.from({length: beadCount}, (_, i) => i);
            for (let i = order.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [order[i], order[j]] = [order[j], order[i]];
            }
            
            for (let i = 0; i < beadCount; i++) {
                this._currentBeads.push({
                    angle: angles[i],
                    size: 3 + Math.random() * 5, // Random size 3-8
                    order: order[i], // Order in sequence
                    delay: order[i] * 200 // 200ms between each bead
                });
            }
            
            this._beadStartTime = Date.now();
        }
        
        const elapsedTime = Date.now() - this._beadStartTime;
        
        // Render the beads as chromatic lens flares (one at a time)
        const beads = this._currentBeads || [];
        
        beads.forEach(bead => {
            // Check if this bead should be visible yet
            if (elapsedTime < bead.delay) return;
            
            // Calculate fade in (300ms fade)
            const beadAge = elapsedTime - bead.delay;
            const fadeInDuration = 300;
            const opacity = Math.min(1, beadAge / fadeInDuration);
            
            // Calculate bead position on the edge of the sun (not shadow)
            const beadX = x + Math.cos(bead.angle) * radius;
            const beadY = y + Math.sin(bead.angle) * radius;
            
            ctx.save();
            ctx.translate(beadX, beadY);
            ctx.globalAlpha = opacity;
            
            // Draw chromatic aberration lens flare
            const size = this.scaleValue(bead.size);
            
            // Chromatic layers - RGB separated for aberration effect
            const colors = [
                { color: `rgba(255, 100, 100, ${0.6 * opacity})`, offset: -2 },  // Red
                { color: `rgba(100, 255, 100, ${0.6 * opacity})`, offset: 0 },   // Green  
                { color: `rgba(100, 100, 255, ${0.6 * opacity})`, offset: 2 }    // Blue
            ];
            
            ctx.globalCompositeOperation = 'screen';
            
            colors.forEach(({ color, offset }) => {
                // Create radial gradient for each color channel
                const gradient = ctx.createRadialGradient(
                    offset, offset, 0,
                    offset, offset, size * 2
                );
                
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.2, color.replace(`${0.6 * opacity}`, `${0.4 * opacity}`));
                gradient.addColorStop(0.5, color.replace(`${0.6 * opacity}`, `${0.2 * opacity}`));
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(offset, offset, size * 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Add bright white core
            ctx.globalCompositeOperation = 'lighter';
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            coreGradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
            coreGradient.addColorStop(0.3, `rgba(255, 255, 255, ${0.5 * opacity})`);
            coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        });
    }
    
    /**
     * Render moon/lunar shadow overlay
     * @param {boolean} isSolarOverlay - True if this is being called for solar eclipse effect
     * @param {number} rotation - Rotation angle to apply
     */
    renderMoonShadow(x, y, radius, shadow, shapePoints, isSolarOverlay = false, rotation = 0) {
        const {ctx} = this;

        ctx.save();
        ctx.globalAlpha = 1; // Always render shadow at full opacity, even in resting state
        ctx.translate(x, y);

        // Don't apply rotation - we're already in rotated coordinate space

        if (shadow.type === 'crescent') {
            // Crescent moon - smooth shadow without pixelation
            
            // Get morph progress to animate the shadow sliding in
            let shadowProgress = 1.0; // Default to fully visible
            let animatedOffset = shadow.offset || 0.7; // Default to the shadow's offset
            
            if (this.shapeMorpher) {
                const morphProgress = this.shapeMorpher.getProgress();
                const {targetShape} = this.shapeMorpher;
                
                // Animate shadow sliding in when morphing TO moon (and shadow.offset is not being controlled)
                if (targetShape === 'moon' && morphProgress !== undefined && morphProgress < 1 && !shadow.shadowX) {
                    // Shadow slides in from the left
                    shadowProgress = morphProgress;
                    const baseOffset = 0.7;
                    // Animate the offset - starts far left (-2) and slides to final position
                    animatedOffset = -2 + (baseOffset + 2) * shadowProgress;
                }
                // FROM MOON TO ANY SHAPE - ShapeMorpher is already controlling via shadow.offset
                // so we just use whatever offset is provided in the shadow object
            }
            // Calculate shadow offset - shadow rotates with the moon
            const angleRad = (shadow.angle || -30) * Math.PI / 180;
            const offsetX = Math.cos(angleRad) * radius * animatedOffset;
            const offsetY = Math.sin(angleRad) * radius * animatedOffset;
            
            // Enable high quality rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Clip to the moon shape
            ctx.beginPath();
            if (shapePoints) {
                ctx.moveTo(shapePoints[0].x, shapePoints[0].y);
                for (let i = 1; i < shapePoints.length; i++) {
                    ctx.lineTo(shapePoints[i].x, shapePoints[i].y);
                }
                ctx.closePath();
            } else {
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
            }
            ctx.clip();
            
            // Use a single smooth gradient for the entire shadow
            const shadowGradient = ctx.createRadialGradient(
                offsetX, offsetY, radius * 0.9,
                offsetX, offsetY, radius * 1.1
            );
            
            // More gradient stops for smoother transition
            // Also fade opacity based on shadowProgress for smoother appearance
            const baseCoverage = shadow.coverage !== undefined ? shadow.coverage : 0.85;
            const shadowOpacity = Math.min(1, shadowProgress * 1.2) * (baseCoverage / 0.85);
            shadowGradient.addColorStop(0, `rgba(0, 0, 0, ${1 * shadowOpacity})`);
            shadowGradient.addColorStop(0.80, `rgba(0, 0, 0, ${1 * shadowOpacity})`);
            shadowGradient.addColorStop(0.88, `rgba(0, 0, 0, ${0.98 * shadowOpacity})`);
            shadowGradient.addColorStop(0.91, `rgba(0, 0, 0, ${0.95 * shadowOpacity})`);
            shadowGradient.addColorStop(0.93, `rgba(0, 0, 0, ${0.9 * shadowOpacity})`);
            shadowGradient.addColorStop(0.95, `rgba(0, 0, 0, ${0.8 * shadowOpacity})`);
            shadowGradient.addColorStop(0.96, `rgba(0, 0, 0, ${0.65 * shadowOpacity})`);
            shadowGradient.addColorStop(0.97, `rgba(0, 0, 0, ${0.45 * shadowOpacity})`);
            shadowGradient.addColorStop(0.98, `rgba(0, 0, 0, ${0.25 * shadowOpacity})`);
            shadowGradient.addColorStop(0.99, `rgba(0, 0, 0, ${0.1 * shadowOpacity})`);
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = shadowGradient;
            ctx.beginPath();
            // Always use a circular shadow - crescent effect only works with circles
            ctx.arc(offsetX, offsetY, radius * 1.1, 0, Math.PI * 2);
            ctx.fill();
            
        } else if (shadow.type === 'lunar') {
            // Lunar eclipse - diffuse reddish shadow
            const diffusion = shadow.diffusion !== undefined ? shadow.diffusion : 1;
            const sharpness = 1 - diffusion;
            
            // Get morph progress to animate the shadow sliding in for solar
            let shadowOffsetX = 0;
            let shadowOffsetY = 0;
            
            if (this.shapeMorpher) {
                const morphProgress = this.shapeMorpher.getProgress();
                const {currentShape} = this.shapeMorpher;
                const {targetShape} = this.shapeMorpher;
                
                // Don't skip animation for moon-solar transitions anymore
                
                // Animate shadow sliding in when morphing TO solar (for solar overlay)
                if (isSolarOverlay && targetShape === 'solar' && morphProgress !== undefined && morphProgress < 1) {
                    // Shadow slides in from bottom-left
                    const slideDistance = radius * 2.5;
                    // Start from bottom-left, move to center
                    shadowOffsetX = -slideDistance * (1 - morphProgress);
                    shadowOffsetY = slideDistance * (1 - morphProgress);
                }
                // Animate shadow sliding out when morphing FROM solar
                else if (isSolarOverlay && currentShape === 'solar' && targetShape !== 'solar' && targetShape !== null && morphProgress !== undefined && morphProgress < 1) {
                    // Shadow slides out to top-right
                    const slideDistance = radius * 2.5;
                    // Move from center to top-right
                    shadowOffsetX = slideDistance * morphProgress;
                    shadowOffsetY = -slideDistance * morphProgress;
                }
            }
            
            // Apply translation for shadow animation
            ctx.translate(shadowOffsetX, shadowOffsetY);
            
            // For solar overlay, clip to the sun's core area only (not the corona)
            if (isSolarOverlay) {
                // Clip to a circle at the shadow's position that only covers the core
                ctx.save();
                ctx.beginPath();
                // Create a clipping region that's the intersection of the sun and the shadow
                ctx.arc(-shadowOffsetX, -shadowOffsetY, radius, 0, Math.PI * 2); // Sun position (inverse of shadow offset)
                ctx.clip();
            } else {
                // Regular lunar clipping
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.clip();
            }
            
            // Penumbra (diffuse outer shadow) - MUCH DARKER
            const penumbraRadius = radius * (1.8 - sharpness * 0.5);
            const penumbraGradient = ctx.createRadialGradient(
                0, 0, radius * 0.2,
                0, 0, penumbraRadius
            );
            
            const baseOpacity = shadow.coverage || 0.9;
            
            // Use custom color if specified (for solar eclipse), otherwise use default lunar red
            if (shadow.color && shadow.color.includes('0, 0, 0')) {
                // Black shadow for solar eclipse
                penumbraGradient.addColorStop(0, `rgba(0, 0, 0, ${baseOpacity})`);
                penumbraGradient.addColorStop(0.3 + sharpness * 0.2, `rgba(0, 0, 0, ${baseOpacity * 0.95})`);
                penumbraGradient.addColorStop(0.6 + sharpness * 0.2, `rgba(0, 0, 0, ${baseOpacity * 0.8})`);
                penumbraGradient.addColorStop(0.85, `rgba(0, 0, 0, ${baseOpacity * 0.4})`);
                penumbraGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            } else {
                // Default reddish lunar eclipse colors
                penumbraGradient.addColorStop(0, `rgba(10, 2, 0, ${baseOpacity})`);
                penumbraGradient.addColorStop(0.3 + sharpness * 0.2, `rgba(20, 5, 0, ${baseOpacity * 0.95})`);
                penumbraGradient.addColorStop(0.6 + sharpness * 0.2, `rgba(40, 10, 5, ${baseOpacity * 0.8})`);
                penumbraGradient.addColorStop(0.85, `rgba(60, 15, 10, ${baseOpacity * 0.4})`);
                penumbraGradient.addColorStop(1, 'rgba(80, 20, 15, 0)');
            }
            
            ctx.fillStyle = penumbraGradient;
            ctx.beginPath();
            ctx.arc(0, 0, penumbraRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Umbra (sharp inner shadow) - only when sharp
            if (sharpness > 0.3) {
                const umbraRadius = radius * (0.8 + sharpness * 0.3);
                const umbraGradient = ctx.createRadialGradient(
                    0, 0, 0,
                    0, 0, umbraRadius
                );
                
                // Use black for solar eclipse, reddish for lunar
                if (shadow.color && shadow.color.includes('0, 0, 0')) {
                    umbraGradient.addColorStop(0, `rgba(0, 0, 0, ${baseOpacity})`);
                    umbraGradient.addColorStop(0.5, `rgba(0, 0, 0, ${baseOpacity * 0.9})`);
                    umbraGradient.addColorStop(0.8, `rgba(0, 0, 0, ${baseOpacity * 0.5})`);
                    umbraGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                } else {
                    umbraGradient.addColorStop(0, `rgba(0, 0, 0, ${baseOpacity})`);
                    umbraGradient.addColorStop(0.5, `rgba(10, 2, 0, ${baseOpacity * 0.9})`);
                    umbraGradient.addColorStop(0.8, `rgba(20, 5, 0, ${baseOpacity * 0.5})`);
                    umbraGradient.addColorStop(1, 'rgba(30, 8, 5, 0)');
                }
                
                ctx.fillStyle = umbraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, umbraRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Restore extra save for solar overlay clipping
        if (isSolarOverlay) {
            ctx.restore();
        }
        
        ctx.restore();
    }
    
    /**
     * Render zen meditation core with arc shape
     */
    renderZenCore(x, y, radius) {
        this.ctx.save();
        
        // Apply shake offset if in awakening phase
        if (this.state.shakeOffset) {
            x += this.state.shakeOffset;
        }
        
        // Apply drift Y if in awakening phase
        if (this.state.driftY) {
            y += this.state.driftY;
        }
        
        this.ctx.translate(x, y);
        
        // Apply gesture rotation if present (for spin gesture)
        if (this.gestureTransform && this.gestureTransform.rotation !== undefined) {
            this.ctx.rotate(this.gestureTransform.rotation * Math.PI / 180);
        }
        
        // Calculate zen energy pulsation (slow breathing effect)
        const time = Date.now() / 1000; // Time in seconds
        const basePulse = Math.sin(time * 0.5) * 0.5 + 1.5; // Base pulsation
        
        // Scale glow intensity based on transition phase
        // Very dim during bloom/retract, bright when fully in zen
        let glowIntensity = 0.1; // Start very dim
        if (this.zenTransition.phase === 'in') {
            // Full brightness when fully in zen
            glowIntensity = 1.0;
        } else if (this.zenTransition.phase === 'entering') {
            // Gradually brighten only after lotus is mostly formed
            glowIntensity = Math.max(0.1, (this.zenTransition.lotusMorph - 0.7) * 3.3); // Stay dim until 70% bloomed
        } else if (this.zenTransition.phase === 'exiting') {
            // Quickly dim when exiting
            glowIntensity = Math.max(0.1, this.zenTransition.lotusMorph * 0.5);
        }
        const zenPulse = basePulse * glowIntensity; // Apply intensity scaling
        
        // Apply glow when lotus is morphing or fully formed
        if (this.zenTransition.lotusMorph > 0) {
            // Single smooth shadow glow 
            this.ctx.shadowBlur = this.scaleValue(100) * zenPulse;
            this.ctx.shadowColor = `rgba(255, 223, 0, ${0.5 * zenPulse})`;
            
            // INNER RADIANCE GRADIENT - Much darker during transitions
            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 4);
            
            // During transitions, use much darker colors to see lotus
            if (this.zenTransition.phase !== 'in') {
                // Dark golden during transition - lotus will show as even darker cutout
                gradient.addColorStop(0, `rgba(184, 134, 11, ${0.8})`); // Dark goldenrod core
                gradient.addColorStop(0.3, `rgba(153, 101, 21, ${0.6})`); // Darker gold
                gradient.addColorStop(0.6, `rgba(139, 69, 19, ${0.4})`); // Saddle brown
                gradient.addColorStop(1, 'rgba(101, 67, 33, 0)'); // Dark brown edge
            } else {
                // Full brightness only when fully in zen
                gradient.addColorStop(0, `rgba(255, 255, 255, ${1.0 * zenPulse})`); // Pure white core
                gradient.addColorStop(0.1, `rgba(255, 255, 240, ${1.0 * zenPulse})`); // Bright cream
                gradient.addColorStop(0.2, `rgba(255, 250, 205, ${0.95 * zenPulse})`); // Warm light
                gradient.addColorStop(0.35, `rgba(255, 240, 150, ${0.85 * zenPulse})`); // Bright gold
                gradient.addColorStop(0.5, `rgba(255, 223, 0, ${0.7 * zenPulse})`); // Vibrant gold
                gradient.addColorStop(0.65, `rgba(255, 215, 0, ${0.5 * zenPulse})`); // Fading gold
                gradient.addColorStop(0.8, `rgba(255, 215, 0, ${0.3 * zenPulse})`); // Softer edge
                gradient.addColorStop(0.9, `rgba(255, 215, 0, ${0.15 * zenPulse})`); // Very soft
                gradient.addColorStop(0.95, `rgba(255, 215, 0, ${0.05 * zenPulse})`); // Almost gone
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)'); // Fully transparent edge
            }
            
            this.ctx.fillStyle = gradient;
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.3})`; // Dimmer edge during transition
            this.ctx.lineWidth = this.scaleValue(2);
            
            // STEP 1: Draw a circle with lotus cutout using evenodd fill rule
            this.ctx.beginPath();
            
            // Draw outer circle (clockwise)
            this.ctx.arc(0, 0, radius, 0, Math.PI * 2, false);
            
            // MORPHING LOTUS PETALS - animated based on lotusMorph value
            const morph = this.zenTransition.lotusMorph;
            const spread = this.zenTransition.petalSpread;
            const smile = this.zenTransition.smileCurve;
            
            // Center/Top petal - morphs from small circle to full petal
            // Only draw lotus if morph is significant (avoid tiny artifacts)
            if (morph > 0.1) {
                const centerPetalBase = radius * (0.05 + 0.15 * morph);
                this.ctx.moveTo(0, centerPetalBase); // Start at base center
                this.ctx.bezierCurveTo(
                    -radius * (0.05 + 0.25 * morph * spread), radius * 0.1,    // Left control
                    -radius * (0.05 + 0.3 * morph * spread), -radius * (0.1 + 0.4 * morph),  // Left control up
                    0, -radius * (0.2 + 0.65 * morph)                // Top point
                );
                this.ctx.bezierCurveTo(
                    radius * (0.05 + 0.3 * morph * spread), -radius * (0.1 + 0.4 * morph),   // Right control up
                    radius * (0.05 + 0.25 * morph * spread), radius * 0.1,     // Right control
                    0, centerPetalBase                 // Back to base
                );
                
                if (morph > 0.3) { // Only show side petals after some morphing
                    const sidePetalAlpha = (morph - 0.3) / 0.7; // Fade in from 30% to 100%
                
                    // Left petal - fades in and spreads
                    this.ctx.moveTo(-radius * 0.1 * sidePetalAlpha, radius * 0.2); 
                    this.ctx.bezierCurveTo(
                        -radius * (0.1 + 0.4 * sidePetalAlpha * spread), radius * 0.1,    
                        -radius * (0.2 + 0.5 * sidePetalAlpha * spread), -radius * (0.1 + 0.2 * sidePetalAlpha),   
                        -radius * (0.1 + 0.4 * sidePetalAlpha * spread), -radius * (0.2 + 0.45 * sidePetalAlpha)   
                    );
                    this.ctx.bezierCurveTo(
                        -radius * (0.05 + 0.15 * sidePetalAlpha), -radius * (0.1 + 0.4 * sidePetalAlpha),   
                        -radius * 0.05 * sidePetalAlpha, radius * 0.1,   
                        -radius * 0.1 * sidePetalAlpha, radius * 0.2     
                    );
                
                    // Right petal - fades in and spreads
                    this.ctx.moveTo(radius * 0.1 * sidePetalAlpha, radius * 0.2); 
                    this.ctx.bezierCurveTo(
                        radius * (0.1 + 0.4 * sidePetalAlpha * spread), radius * 0.1,     
                        radius * (0.2 + 0.5 * sidePetalAlpha * spread), -radius * (0.1 + 0.2 * sidePetalAlpha),    
                        radius * (0.1 + 0.4 * sidePetalAlpha * spread), -radius * (0.2 + 0.45 * sidePetalAlpha)    
                    );
                    this.ctx.bezierCurveTo(
                        radius * (0.05 + 0.15 * sidePetalAlpha), -radius * (0.1 + 0.4 * sidePetalAlpha),    
                        radius * 0.05 * sidePetalAlpha, radius * 0.1,    
                        radius * 0.1 * sidePetalAlpha, radius * 0.2      
                    );
                }
            
                // Bottom smile - morphs from straight to curved smile
                if (smile > 0) {
                    this.ctx.moveTo(-radius * 0.6, radius * (0.5 - 0.1 * smile));   // Corners rise with smile
                    this.ctx.quadraticCurveTo(
                        0, radius * (0.5 + 0.1 * smile),     // Center dips for smile
                        radius * 0.6, radius * (0.5 - 0.1 * smile)  // Right corner rises
                    );
                }
            }
            
            this.ctx.closePath();
            
            // Fill with gradient using evenodd rule to create the lotus cutout
            this.ctx.fill('evenodd');
            // Don't stroke the lotus cutout, only the outer circle
            this.ctx.beginPath();
            this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Only add additional glow layers when fully in zen, not during transitions
            if (this.zenTransition.phase === 'in') {
                // Additional EXPANSIVE glow layers for inner radiance
                // Layer 1: BRILLIANT lotus core intensifier - from lower quarter
                const lotusRadius = radius * 2.0; // Larger radius for more expansion
                const arcHeight = this.zenTransition.arcHeight * radius; // Get arc height from transition state
                const glowOriginY = radius * 0.5; // Lower quarter origin
                const lotusGlow = this.ctx.createRadialGradient(0, glowOriginY, 0, 0, glowOriginY, lotusRadius * 1.2);
                lotusGlow.addColorStop(0, `rgba(255, 255, 255, ${1.0 * zenPulse})`);
                lotusGlow.addColorStop(0.25, `rgba(255, 252, 240, ${0.8 * zenPulse})`);
                lotusGlow.addColorStop(0.5, `rgba(255, 245, 200, ${0.6 * zenPulse})`);
                lotusGlow.addColorStop(0.75, `rgba(255, 235, 150, ${0.4 * zenPulse})`);
                lotusGlow.addColorStop(1, 'rgba(255, 223, 0, 0)');
                this.ctx.fillStyle = lotusGlow;
                this.ctx.fill();
                
                // Layer 2: GAUSSIAN outer halo for smooth falloff
                const outerHalo = this.ctx.createRadialGradient(0, -arcHeight/2, radius * 0.5, 0, -arcHeight/2, radius * 5);
                outerHalo.addColorStop(0, 'rgba(255, 223, 0, 0)');
                outerHalo.addColorStop(0.1, `rgba(255, 223, 0, ${0.25 * zenPulse})`);
                outerHalo.addColorStop(0.2, `rgba(255, 220, 0, ${0.2 * zenPulse})`);
                outerHalo.addColorStop(0.35, `rgba(255, 215, 0, ${0.15 * zenPulse})`);
                outerHalo.addColorStop(0.5, `rgba(255, 215, 0, ${0.1 * zenPulse})`);
                outerHalo.addColorStop(0.65, `rgba(255, 215, 0, ${0.06 * zenPulse})`);
                outerHalo.addColorStop(0.8, `rgba(255, 215, 0, ${0.03 * zenPulse})`);
                outerHalo.addColorStop(0.9, `rgba(255, 215, 0, ${0.01 * zenPulse})`);
                outerHalo.addColorStop(1, 'rgba(255, 215, 0, 0)');
                this.ctx.fillStyle = outerHalo;
                this.ctx.fill();
            }
        } else {
            // Draw horizontal line or circle during transition
            // Start with very dim golden color that brightens with lotus
            
            // No glow during transition to prevent flash
            this.ctx.shadowBlur = 0;
            this.ctx.shadowColor = 'transparent';
            
            // Use very dim golden color during transition
            const dimIntensity = 0.3; // Keep consistently dim during transition
            this.ctx.fillStyle = `rgba(255, 215, 0, ${dimIntensity})`;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, radius, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Very subtle gradient during transition to see lotus clearly
            const coreGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
            coreGradient.addColorStop(0.5, 'rgba(255, 250, 230, 0.1)');
            coreGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            this.ctx.fillStyle = coreGradient;
            this.ctx.fill();
        }
        
        this.ctx.restore();
    }
    
    /**
     * Render speaking animation rings
     */
    renderSpeakingRings(centerX, centerY, coreRadius, deltaTime) {
        return this.specialEffects.renderSpeakingRings(centerX, centerY, coreRadius, deltaTime);
    }
    
    
    // Recording rings method removed - now using pulsating glow instead
    
    /**
     * Render recording indicator - stylized REC text only
     */
    renderRecordingIndicator(x, y) {
        return this.specialEffects.renderRecordingIndicator(x, y);
    }
    
    
    /**
     * Render sleep indicator (Z's) with cell-shaded style and gradient fade
     */
    renderSleepIndicator(x, y, deltaTime) {
        return this.specialEffects.renderSleepIndicator(x, y, deltaTime);
    }
    
    
    /**
     * Update animation timers
     */
    updateTimers(deltaTime) {
        // Update breathing animation via BreathingAnimator
        this.breathingAnimator.update(deltaTime, this.state.emotion, this.currentUndertone);
        
        // Update special breathing modifiers
        if (this.state.emotion === 'zen') {
            this.breathingAnimator.setBreathRateMultiplier(0.15);
            this.breathingAnimator.setBreathDepthMultiplier(2.5);
        } else if (this.state.sleeping) {
            this.breathingAnimator.setBreathRateMultiplier(0.5);
            this.breathingAnimator.setBreathDepthMultiplier(1.2);
        } else {
            this.breathingAnimator.setBreathRateMultiplier(1.0);
            this.breathingAnimator.setBreathDepthMultiplier(1.0);
        }
        
        // Apply irregular breathing for nervous/tired
        this.breathingAnimator.setIrregularBreathing(this.state.breathIrregular);
        
        // Update blinking via EyeRenderer
        this.eyeRenderer.setBlinkingEnabled(this.state.blinkingEnabled && !this.state.sleeping && this.state.emotion !== 'zen');
        this.eyeRenderer.update(deltaTime);
        
        // Sync blinking state back to our state for compatibility
        this.state.blinking = this.eyeRenderer.blinking;
        
        // Note: Idle detection is handled by IdleBehavior.js, not here
    }
    
    /**
     * Apply all undertone modifiers to current state
     * @param {string|null|Object} undertone - Undertone name or weighted modifier object
     */
    applyUndertoneModifiers(undertone) {
        // Handle weighted modifier from state machine
        if (undertone && typeof undertone === 'object' && undertone.weight !== undefined) {
            const {weight} = undertone;
            
            // Apply weighted modifiers for smooth transitions
            // Use default value of 1.0 if property is undefined
            this.state.sizeMultiplier = 1.0 + ((undertone.sizeMultiplier || 1.0) - 1.0) * weight;
            this.state.jitterAmount = (undertone.jitterAmount || 0) * weight;
            this.state.episodicFlutter = weight > 0.5 ? (undertone.episodicFlutter || false) : false;
            this.state.glowRadiusMult = 1.0 + ((undertone.glowRadiusMult || 1.0) - 1.0) * weight;
            this.state.breathRateMult = 1.0 + ((undertone.breathRateMult || 1.0) - 1.0) * weight;
            this.state.breathDepthMult = 1.0 + ((undertone.breathDepthMult || 1.0) - 1.0) * weight;
            this.state.breathIrregular = weight > 0.5 ? (undertone.breathIrregular || false) : false;
            this.state.particleRateMult = 1.0;
            
            // Apply weighted glow and color effects
            this.state.glowPulse = (undertone.glowPulse || 0) * weight;
            this.state.brightnessFlicker = (undertone.brightnessFlicker || 0) * weight;
            this.state.brightnessMult = 1.0 + ((undertone.brightnessMult || 1.0) - 1.0) * weight;
            this.state.saturationMult = 1.0 + ((undertone.saturationMult || 1.0) - 1.0) * weight;
            this.state.hueShift = (undertone.hueShift || 0) * weight;
            return;
        }
        
        // String-based undertone handling
        if (!undertone || !this.undertoneModifiers[undertone]) {
            // Reset to defaults if no undertone - CLEAR ALL GLOW EFFECTS
            this.state.sizeMultiplier = 1.0;
            this.state.jitterAmount = 0;
            this.state.episodicFlutter = false;
            this.state.glowRadiusMult = 1.0;
            this.state.breathRateMult = 1.0;
            this.state.breathDepthMult = 1.0;
            this.state.breathIrregular = false;
            this.state.particleRateMult = 1.0;
            
            // Reset all glow and color effects to prevent accumulation
            this.state.glowPulse = 0;
            this.state.brightnessFlicker = 0;
            this.state.brightnessMult = 1.0;
            this.state.saturationMult = 1.0;
            this.state.hueShift = 0;
            return;
        }
        
        const modifier = this.undertoneModifiers[undertone];
        
        // Apply all modifiers directly
        this.state.sizeMultiplier = modifier.sizeMultiplier;
        this.state.jitterAmount = modifier.jitterAmount || 0;
        this.state.episodicFlutter = modifier.episodicFlutter || false;
        this.state.glowRadiusMult = modifier.glowRadiusMult;
        this.state.breathRateMult = modifier.breathRateMult;
        this.state.breathDepthMult = modifier.breathDepthMult;
        this.state.breathIrregular = modifier.breathIrregular || false;
        this.state.particleRateMult = 1.0;
        
        // Apply all glow and color effects
        this.state.glowPulse = modifier.glowPulse || 0;
        this.state.brightnessFlicker = modifier.brightnessFlicker || 0;
        this.state.brightnessMult = modifier.brightnessMult || 1.0;
        this.state.saturationMult = modifier.saturationMult || 1.0;
        this.state.hueShift = modifier.hueShift || 0;
    }
    
    /**
     * Apply undertone shifts to a color using saturation-based depth
     * @param {string} baseColor - Base hex color
     * @param {string|null|Object} undertone - Undertone name or weighted modifier object
     * @returns {string} Modified hex color
     * 
     * Undertone saturation creates visual depth:
     * - INTENSE   : +60% saturation (electric, overwhelming)
     * - CONFIDENT : +30% saturation (bold, present) 
     * - NERVOUS   : +15% saturation (slightly heightened)
     * - CLEAR     :   0% saturation (normal midtone)
     * - TIRED     : -20% saturation (washed out, fading)
     * - SUBDUED   : -50% saturation (ghostly, withdrawn)
     */
    applyUndertoneToColor(baseColor, undertone) {
        return this.colorUtilities.applyUndertoneToColor(baseColor, undertone);
    }
    
    hexToRgb(hex) {
        return this.colorUtilities.hexToRgb(hex);
    }
    
    rgbToHsl(r, g, b) {
        return this.colorUtilities.rgbToHsl(r, g, b);
    }
    
    hslToHex(h, s, l) {
        return this.colorUtilities.hslToHex(h, s, l);
    }
    
    hexToRgba(hex, alpha = 1) {
        const rgb = this.hexToRgb(hex);
        if (!rgb) return `rgba(255, 255, 255, ${alpha})`;
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    }
    
    startColorTransition(targetColor, targetIntensity, duration = 1500) {
        this.colorUtilities.currentColor = this.state.glowColor;
        this.colorUtilities.currentIntensity = this.state.glowIntensity;
        this.colorUtilities.startColorTransition(targetColor, targetIntensity, duration);
        this.colorTransition = this.colorUtilities.colorTransition;
    }
    
    updateColorTransition(deltaTime) {
        const result = this.colorUtilities.updateColorTransition(deltaTime);
        if (result) {
            this.state.glowColor = result.color;
            this.state.glowIntensity = result.intensity;
            this.colorTransition = this.colorUtilities.colorTransition;
        }
    }
    
    /**
     * Update just the undertone without resetting emotion
     */
    updateUndertone(undertone) {
        // Clear glow cache when undertone changes (colors will change)
        if (this.state.undertone !== undertone) {
            this.glowCache.clear();
        }
        
        // Store undertone for color processing
        this.state.undertone = undertone;
        this.currentUndertone = undertone;
        
        // Get weighted undertone modifier from state machine if available
        const weightedModifier = this.stateMachine && this.stateMachine.getWeightedUndertoneModifiers ? 
            this.stateMachine.getWeightedUndertoneModifiers() : null;
        
        // Apply all undertone modifiers (visual, breathing only - no particles)
        this.applyUndertoneModifiers(weightedModifier || undertone);
        
        // Update colors with the new undertone
        if (this.state.emotion) {
            const emotionConfig = emotionCache && emotionCache.isInitialized ? 
                emotionCache.getEmotion(this.state.emotion) : getEmotion(this.state.emotion);
            if (emotionConfig) {
                const baseColor = emotionConfig.glowColor || this.config.defaultGlowColor;
                const targetColor = this.applyUndertoneToColor(baseColor, weightedModifier || undertone);
                
                // Start color transition to new undertone color (faster for responsiveness)
                this.startColorTransition(targetColor, 200); // 200ms transition
            }
        }
    }
    
    /**
     * Set emotional state
     */
    setEmotionalState(emotion, properties, undertone = null) {
        
        // Clear glow cache when emotion or undertone changes (colors will change)
        if (this.state.emotion !== emotion || this.state.undertone !== undertone) {
            this.glowCache.clear();
        }
        
        // Store undertone for color processing
        this.state.undertone = undertone;
        this.currentUndertone = undertone;
        
        // Get weighted undertone modifier from state machine if available
        const weightedModifier = this.stateMachine && this.stateMachine.getWeightedUndertoneModifiers ? 
            this.stateMachine.getWeightedUndertoneModifiers() : null;
        
        // Apply all undertone modifiers (visual, breathing, particles)
        this.applyUndertoneModifiers(weightedModifier || undertone);
        
        // Get base color and apply undertone shifts
        const baseColor = properties.glowColor || this.config.defaultGlowColor;
        
        // Get target color - for suspicion, use the dynamic color directly
        let targetColor;
        if (emotion === 'suspicion') {
            // Use the dynamic color from properties (includes threat level)
            targetColor = properties.glowColor || baseColor;
        } else {
            targetColor = this.applyUndertoneToColor(baseColor, weightedModifier || undertone);
        }
        
        // Apply intensity modifier from undertone
        const modifier = weightedModifier || (undertone ? this.undertoneModifiers[undertone] : null);
        const baseIntensity = properties.glowIntensity || 1.0;
        
        // Get the glow multiplier - check for glowRadiusMult or use default of 1.0
        let glowMult = 1.0;
        if (modifier) {
            if (weightedModifier) {
                // For weighted modifiers, check if glowRadiusMult exists
                // Check for NaN in weight calculation
                const weight = modifier.weight || 0;
                if (modifier.glowRadiusMult !== undefined && isFinite(modifier.glowRadiusMult) && isFinite(weight)) {
                    glowMult = 1.0 + (modifier.glowRadiusMult - 1.0) * weight;
                } else {
                    glowMult = 1.0;
                }
            } else {
                // For non-weighted modifiers, use glowRadiusMult if it exists
                glowMult = modifier.glowRadiusMult !== undefined ? modifier.glowRadiusMult : 1.0;
            }
        }
        
        const targetIntensity = baseIntensity * glowMult;
        
        // Determine transition duration based on emotion
        let duration = 1500; // Default 1.5s
        if (emotion === 'anger' || emotion === 'fear') {
            duration = 800; // Quick transitions for urgent emotions
        } else if (emotion === 'sadness' || emotion === 'resting') {
            duration = 2000; // Slower for calming emotions
        } else if (emotion === 'zen') {
            duration = 2000; // Zen gets special timing during lotus bloom
        }
        
        // Update emotion state BEFORE handling transitions to avoid timing issues
        const previousEmotion = this.state.emotion;
        this.state.emotion = emotion;
        
        // Handle suspicion state
        if (emotion === 'suspicion') {
            this.state.isSuspicious = true;
            // Store target squint amount, we'll animate to it
            this.state.targetSquintAmount = properties && properties.coreSquint ? properties.coreSquint : 0.4;
            if (this.state.squintAmount === undefined) {
                this.state.squintAmount = 0; // Start from no squint
            }
            this.state.lastScanTime = Date.now();
            this.state.scanPhase = 0;
        } else {
            this.state.isSuspicious = false;
            this.state.targetSquintAmount = 0;
            if (this.state.squintAmount === undefined) {
                this.state.squintAmount = 0;
            }
        }
        
        // Handle zen state transitions specially
        if (emotion === 'zen' && previousEmotion !== 'zen') {
            // Entering zen - will handle its own color transition during lotus bloom
            this.enterZenMode(targetColor, targetIntensity);
        } else if (previousEmotion === 'zen' && emotion !== 'zen') {
            // Exiting zen - will handle its own color transition during lotus close
            this.exitZenMode(emotion, targetColor, targetIntensity);
        } else {
            // Standard color transition for all other state changes
            this.startColorTransition(targetColor, targetIntensity, duration);
        }
        
        // Apply breathing with undertone modifiers
        const baseBreathRate = properties.breathRate || 1.0;
        const baseBreathDepth = properties.breathDepth || this.config.breathingDepth;
        this.state.breathRate = modifier ? baseBreathRate * modifier.breathRateMult : baseBreathRate;
        this.state.breathDepth = modifier ? baseBreathDepth * modifier.breathDepthMult : baseBreathDepth;
        
        // Jitter combines emotion jitter with undertone jitter
        this.state.coreJitter = properties.coreJitter || (modifier && modifier.jitterAmount > 0);
        this.state.emotionEyeOpenness = properties.eyeOpenness;
        this.state.emotionEyeArc = properties.eyeArc;
    }
    
    /**
     * Set BPM for rhythm features
     * @param {number} bpm - Beats per minute
     */
    setBPM(bpm) {
        // BPM-locked rotation has been removed
        // This method is kept for other rhythm-related features
    }

    /**
     * Set manual rotation speed
     * @param {number} speed - Rotation speed in degrees per frame (like velocity)
     */
    setRotationSpeed(speed) {
        // Direct degrees per frame, no conversion needed
        this.state.rotationSpeed = speed;
    }

    /**
     * Set manual rotation angle directly (for scratching)
     * @param {number} angle - Rotation angle in DEGREES
     */
    setRotationAngle(angle) {
        this.state.manualRotation = angle;
    }
    
    /**
     * Set gaze data from GazeTracker
     * @param {Object} gazeData - Contains offset, proximity, and lock status
     */
    setGazeOffset(gazeData) {
        // Handle both old format (just offset) and new format (full data)
        if (typeof gazeData === 'object' && gazeData !== null) {
            if (Object.prototype.hasOwnProperty.call(gazeData, 'x') && Object.prototype.hasOwnProperty.call(gazeData, 'y')) {
                // Old format - just offset
                this.state.gazeOffset = gazeData;
            } else {
                // New format - full gaze data
                this.state.gazeOffset = gazeData.offset || { x: 0, y: 0 };
                this.state.gazeIntensity = gazeData.proximity || 0;
                this.state.gazeLocked = gazeData.isLocked || false;
            }
        }
        
        // Reset idle timer on interaction
        this.idleTimer = 0;
        if (this.isAsleep) {
            this.wakeUp();
        }
    }
    
    /**
     * Get current orb position (center + gaze offset)
     */
    getCurrentOrbPosition() {
        const logicalWidth = this.canvasManager.width;
        const logicalHeight = this.canvasManager.height;
        const centerX = logicalWidth / 2;
        const centerY = logicalHeight / 2 - this.config.topOffset;
        
        return {
            x: centerX + this.state.gazeOffset.x,
            y: centerY + this.state.gazeOffset.y
        };
    }
    
    /**
     * Sets a custom scale for the orb (used for breathing exercises)
     * @param {number} scale - Scale factor (1.0 = normal)
     */
    setCustomScale(scale) {
        this.state.customScale = scale;
    }
    
    /**
     * Start speaking animation
     */
    startSpeaking() {
        this.state.speaking = true;
        this.speakingRings = [];
        this.ringSpawnTimer = 0;
    }
    
    /**
     * Stop speaking animation
     */
    stopSpeaking() {
        this.state.speaking = false;
        this.speakingRings = [];
    }
    
    /**
     * Enter sleep mode with animation
     */
    enterSleepMode() {
        this.state.sleeping = true;
        this.sleepZ = []; // Reset Z's
        this.state.eyeOpenness = 1.0; // Start with eyes open
        
        // Initialize dimming values (start at full brightness)
        this.state.sleepDimness = 1.0;
        this.state.sleepScale = 1.0;
        
        // Force end any active blink
        this.state.blinking = false;
        
        // Animate eye closing, then dimming
        this.animateEyeClose();
        
    }
    
    /**
     * Animate eye closing for sleep, then dim
     */
    animateEyeClose() {
        // Cancel any existing eye animations
        if (this.loopCallbackIds.eyeClose) {
            animationLoopManager.unregister(this.loopCallbackIds.eyeClose);
            this.loopCallbackIds.eyeClose = null;
        }
        if (this.loopCallbackIds.eyeOpen) {
            animationLoopManager.unregister(this.loopCallbackIds.eyeOpen);
            this.loopCallbackIds.eyeOpen = null;
        }
        
        const startTime = performance.now();
        const eyeCloseDuration = 2000; // 2 seconds to close eyes
        const dimDuration = 1000; // 1 second to dim after eyes close
        
        const animate = () => {
            if (!this.state.sleeping) {
                // Clean up loop callback ID
                this.loopCallbackIds.eyeClose = null;
                return; // Stop if woken up
            }
            
            const elapsed = performance.now() - startTime;
            
            if (elapsed < eyeCloseDuration) {
                // Phase 1: Close eyes
                const progress = elapsed / eyeCloseDuration;
                const eased = 1 - Math.pow(progress, 2);
                this.state.eyeOpenness = 0.1 + eased * 0.9; // Close to 0.1 (nearly closed)
                
                // Keep full brightness during eye closing
                this.state.sleepDimness = 1.0;
                this.state.sleepScale = 1.0;
                
                // Continue animation on next frame
            } else if (elapsed < eyeCloseDuration + dimDuration) {
                // Phase 2: Dim the orb
                const dimProgress = (elapsed - eyeCloseDuration) / dimDuration;
                const dimEased = 1 - Math.pow(1 - dimProgress, 3); // Ease out cubic
                
                // Keep eyes closed
                this.state.eyeOpenness = 0.1;
                
                // Animate dimming and scaling
                this.state.sleepDimness = 1.0 - (dimEased * 0.4); // Dim to 0.6
                this.state.sleepScale = 1.0 - (dimEased * 0.1); // Scale to 0.9
                
                // Continue animation on next frame
            } else {
                // Final state
                this.state.eyeOpenness = 0.1;
                this.state.sleepDimness = 0.6;
                this.state.sleepScale = 0.9;
                // Clean up loop callback ID
                this.loopCallbackIds.eyeClose = null;
            }
        };

        // Register with AnimationLoopManager
        this.loopCallbackIds.eyeClose = animationLoopManager.register(
            animate,
            AnimationPriority.HIGH, // Eye animations are high priority
            this
        );
    }
    
    /**
     * Wake up from sleep with animation
     */
    wakeUp() {
        if (!this.state.sleeping) return;
        
        this.state.sleeping = false;
        this.state.breathRate = 1.0;
        this.state.breathDepth = this.config.breathingDepth;
        this.sleepZ = []; // Clear Z's
        
        // Reset blinking state
        this.state.blinking = false;
        // Blinking now handled by EyeRenderer
        this.eyeRenderer.blinking = false;
        this.eyeRenderer.blinkTimer = 0;
        
        // Animate eye opening
        this.animateEyeOpen();
        
        // Quick shake animation
        this.state.coreJitter = true;
        setTimeout(() => {
            this.state.coreJitter = false;
        }, 200);
        
    }
    
    /**
     * Animate eye opening after wake - brighten first, then open eyes
     */
    animateEyeOpen() {
        // Cancel any existing eye animations
        if (this.loopCallbackIds.eyeOpen) {
            animationLoopManager.unregister(this.loopCallbackIds.eyeOpen);
            this.loopCallbackIds.eyeOpen = null;
        }
        if (this.loopCallbackIds.eyeClose) {
            animationLoopManager.unregister(this.loopCallbackIds.eyeClose);
            this.loopCallbackIds.eyeClose = null;
        }
        
        const startTime = performance.now();
        const brightenDuration = 500; // 0.5 seconds to brighten
        const eyeOpenDuration = 1000; // 1 second to open eyes
        
        const animate = () => {
            const elapsed = performance.now() - startTime;
            
            if (elapsed < brightenDuration) {
                // Phase 1: Brighten the orb
                const progress = elapsed / brightenDuration;
                const eased = Math.sin(progress * Math.PI / 2); // Smooth acceleration
                
                // Animate brightening and scaling back
                this.state.sleepDimness = 0.6 + (eased * 0.4); // Brighten from 0.6 to 1.0
                this.state.sleepScale = 0.9 + (eased * 0.1); // Scale from 0.9 to 1.0
                
                // Keep eyes closed during brightening
                this.state.eyeOpenness = 0.1;
                
                // Continue animation on next frame
            } else if (elapsed < brightenDuration + eyeOpenDuration) {
                // Phase 2: Open eyes
                const eyeProgress = (elapsed - brightenDuration) / eyeOpenDuration;
                const eyeEased = Math.sin(eyeProgress * Math.PI / 2); // Smooth acceleration
                
                // Keep full brightness
                this.state.sleepDimness = 1.0;
                this.state.sleepScale = 1.0;
                
                // Animate eye opening
                this.state.eyeOpenness = 0.1 + eyeEased * 0.9; // Open from 0.1 to 1.0
                
                // Continue animation on next frame
            } else {
                // Final state
                this.state.eyeOpenness = 1.0;
                this.state.sleepDimness = 1.0;
                this.state.sleepScale = 1.0;
                // Clean up loop callback ID
                this.loopCallbackIds.eyeOpen = null;
            }
        };

        // Register with AnimationLoopManager
        this.loopCallbackIds.eyeOpen = animationLoopManager.register(
            animate,
            AnimationPriority.HIGH, // Eye animations are high priority
            this
        );
    }
    
    /**
     * Enter zen meditation mode with animation
     */
    enterZenMode(targetColor, targetIntensity) {
        // Cancel any existing zen animations
        if (this.animationFrameIds.zenEnter) {
            cancelAnimationFrame(this.animationFrameIds.zenEnter);
            this.animationFrameIds.zenEnter = null;
        }
        if (this.animationFrameIds.zenExit) {
            cancelAnimationFrame(this.animationFrameIds.zenExit);
            this.animationFrameIds.zenExit = null;
        }
        
        // Set to zen color with target intensity
        this.state.glowColor = targetColor;
        this.state.glowIntensity = targetIntensity; // Keep the glow
        
        // Cancel any active color transition
        this.colorTransition.active = false;
        
        this.zenTransition = {
            active: true,
            phase: 'entering',
            startTime: performance.now(),
            previousEmotion: this.state.emotion,
            targetEmotion: null,
            scaleX: 1.0,
            scaleY: 1.0,
            arcHeight: 0,
            lotusMorph: 0,     // 0 = no lotus, 1 = full lotus
            petalSpread: 0,    // 0 = closed petals, 1 = full spread
            smileCurve: 0      // 0 = no smile, 1 = full smile
        };
        
        const animate = () => {
            if (!this.zenTransition.active || this.zenTransition.phase !== 'entering') {
                // Clean up loop callback ID
                this.loopCallbackIds.zenEnter = null;
                return;
            }
            
            const elapsed = performance.now() - this.zenTransition.startTime;
            const lotusMorphDuration = 400; // 0.4s for lotus to bloom - smooth transition
            
            if (elapsed < lotusMorphDuration) {
                // Direct lotus blooming - no intro animation
                const lotusProgress = elapsed / lotusMorphDuration;
                const lotusEased = 1 - Math.pow(1 - lotusProgress, 2); // Ease out quad
                
                // Direct lotus bloom without arc or narrowing
                this.zenTransition.scaleX = 1.0;
                this.zenTransition.scaleY = 1.0;  // Full size
                this.zenTransition.arcHeight = 0;  // No arc
                
                // Morph the lotus shape directly
                this.zenTransition.lotusMorph = lotusEased; // 0 to 100%
                this.zenTransition.petalSpread = lotusEased;
                
                // Smile appears gradually
                this.zenTransition.smileCurve = Math.sin(lotusProgress * Math.PI / 2); // Smooth ease
                
                // Register with AnimationLoopManager
                this.loopCallbackIds.zenEnter = animationLoopManager.register(
                    animate,
                    AnimationPriority.MEDIUM, // Zen animations are medium priority
                    this
                );
            } else {
                // Final state - in meditation with full lotus, then start floating
                this.zenTransition.phase = 'in';
                this.zenTransition.scaleX = 1.0;
                this.zenTransition.scaleY = 1.0;  // Full size
                this.zenTransition.arcHeight = 0;  // No arc
                this.zenTransition.lotusMorph = 1.0;
                this.zenTransition.petalSpread = 1.0;
                this.zenTransition.smileCurve = 1.0;
                
                // Set gentle vortex for zen state
                this.state.zenVortexIntensity = 1.0;  // Can be adjusted: 0.5 = very gentle, 2.0 = strong
                // Clean up loop callback ID
                this.loopCallbackIds.zenEnter = null;
            }
        };
        
        // Register with AnimationLoopManager
        this.loopCallbackIds.zenEnter = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
    }
    
    /**
     * Exit zen meditation mode with awakening animation
     */
    exitZenMode(targetEmotion, targetColor, targetIntensity) {
        if (!this.zenTransition.active || this.zenTransition.phase !== 'in') return;
        
        // Cancel any existing zen animations
        if (this.animationFrameIds.zenEnter) {
            cancelAnimationFrame(this.animationFrameIds.zenEnter);
            this.animationFrameIds.zenEnter = null;
        }
        if (this.animationFrameIds.zenExit) {
            cancelAnimationFrame(this.animationFrameIds.zenExit);
            this.animationFrameIds.zenExit = null;
        }
        
        this.zenTransition.phase = 'exiting';
        this.zenTransition.startTime = performance.now();
        this.zenTransition.targetEmotion = targetEmotion;
        
        const animate = () => {
            if (!this.zenTransition.active || this.zenTransition.phase !== 'exiting') {
                // Clean up loop callback ID
                this.loopCallbackIds.zenExit = null;
                return;
            }
            
            const elapsed = performance.now() - this.zenTransition.startTime;
            const straightenDuration = 150; // 0.15s to straighten arc - FAST
            const awakeDuration = 200; // 0.2s for awakening gestures - FAST
            const expandDuration = 200; // 0.2s to expand back - FAST
            const settleDuration = 100; // 0.1s for final settle - FAST
            
            if (elapsed < straightenDuration) {
                // Phase 1: Lotus closing and arc straightening - start color transition
                const progress = elapsed / straightenDuration;
                const eased = 1 - Math.pow(1 - progress, 2);
                
                // Start color transition at beginning of exit
                if (progress === 0 || !this.colorTransition.active) {
                    this.startColorTransition(targetColor, targetIntensity, straightenDuration);
                }
                
                this.zenTransition.arcHeight = 1.5 * (1 - eased); // Flatten arc from full height
                
                // Close lotus petals quickly
                this.zenTransition.smileCurve = 1.0 * (1 - eased); // Smile fades first
                if (progress > 0.3) {
                    const petalProgress = (progress - 0.3) / 0.7;
                    this.zenTransition.petalSpread = 1.0 * (1 - petalProgress); // Petals close
                }
                if (progress > 0.5) {
                    const morphProgress = (progress - 0.5) / 0.5;
                    this.zenTransition.lotusMorph = 1.0 * (1 - morphProgress); // Lotus disappears
                }
                
                // Register with AnimationLoopManager
                this.loopCallbackIds.zenExit = animationLoopManager.register(
                    animate,
                    AnimationPriority.MEDIUM, // Zen animations are medium priority
                    this
                );
            } else if (elapsed < straightenDuration + awakeDuration) {
                // Phase 2: Awakening gestures
                const awakeProgress = (elapsed - straightenDuration) / awakeDuration;
                
                // Lotus is fully closed by now
                this.zenTransition.lotusMorph = 0;
                this.zenTransition.petalSpread = 0;
                this.zenTransition.smileCurve = 0;
                
                // Slow blink (0-0.3)
                if (awakeProgress < 0.2) {
                    const blinkProg = awakeProgress / 0.2;
                    this.zenTransition.scaleY = 1.0 - (Math.sin(blinkProg * Math.PI) * 0.8);
                }
                // Gentle shake (0.3-0.6)
                else if (awakeProgress < 0.6) {
                    const shakeProg = (awakeProgress - 0.2) / 0.4;
                    this.zenTransition.scaleY = 1.0;
                    // Add small X offset for shake (will be applied in render)
                    this.state.shakeOffset = Math.sin(shakeProg * Math.PI * 4) * 3;
                }
                // Upward drift with brighten (0.6-1.0)
                else {
                    const driftProg = (awakeProgress - 0.6) / 0.4;
                    this.state.driftY = -10 * driftProg;
                    this.state.glowIntensity = 1.0 + (0.5 * driftProg); // Brighten
                }
                
                // Register with AnimationLoopManager
                this.loopCallbackIds.zenExit = animationLoopManager.register(
                    animate,
                    AnimationPriority.MEDIUM, // Zen animations are medium priority
                    this
                );
            } else if (elapsed < straightenDuration + awakeDuration + expandDuration) {
                // Phase 3: Horizontal expansion (sunrise)
                const expandProgress = (elapsed - straightenDuration - awakeDuration) / expandDuration;
                const expandEased = Math.sin(expandProgress * Math.PI / 2);
                
                this.zenTransition.scaleX = 1.0;
                this.zenTransition.scaleY = 0.2 + (expandEased * 0.8); // Expand vertically back to 1.0 (sunrise)
                this.state.driftY = -10 * (1 - expandProgress); // Return to center
                this.state.glowIntensity = 1.5 - (0.5 * expandProgress); // Normal glow
                
                // Register with AnimationLoopManager
                this.loopCallbackIds.zenExit = animationLoopManager.register(
                    animate,
                    AnimationPriority.MEDIUM, // Zen animations are medium priority
                    this
                );
            } else if (elapsed < straightenDuration + awakeDuration + expandDuration + settleDuration) {
                // Phase 4: Final settle pulse
                const settleProgress = (elapsed - straightenDuration - awakeDuration - expandDuration) / settleDuration;
                const pulse = Math.sin(settleProgress * Math.PI);
                
                this.zenTransition.scaleX = 1.0 + (pulse * 0.05);
                this.zenTransition.scaleY = 1.0 + (pulse * 0.05);
                
                // Register with AnimationLoopManager
                this.loopCallbackIds.zenExit = animationLoopManager.register(
                    animate,
                    AnimationPriority.MEDIUM, // Zen animations are medium priority
                    this
                );
            } else {
                // Complete - reset to normal
                this.zenTransition.active = false;
                this.zenTransition.phase = null;
                this.zenTransition.scaleX = 1.0;
                this.zenTransition.scaleY = 1.0;
                this.zenTransition.arcHeight = 0;
                this.zenTransition.lotusMorph = 0;
                this.zenTransition.petalSpread = 0;
                this.zenTransition.smileCurve = 0;
                this.state.shakeOffset = 0;
                this.state.driftY = 0;
                // Clean up loop callback ID
                this.loopCallbackIds.zenExit = null;
            }
        };
        
        // Register with AnimationLoopManager
        this.loopCallbackIds.zenExit = animationLoopManager.register(
            animate,
            AnimationPriority.MEDIUM, // Zen animations are medium priority
            this
        );
    }
    
    /**
     * Start recording mode
     */
    startRecording() {
        this.state.recording = true;
    }
    
    /**
     * Stop recording mode
     */
    stopRecording() {
        this.state.recording = false;
    }
    
    /**
     * Get random blink time (2-6 seconds)
     */
    
    /**
     * Set whether blinking is enabled
     * @param {boolean} enabled - Whether blinking should be enabled
     */
    setBlinkingEnabled(enabled) {
        this.state.blinkingEnabled = enabled;
        if (!enabled) {
            // If disabling blinking, immediately stop any current blink
            this.state.blinking = false;
            // Reset blinking via EyeRenderer
            this.eyeRenderer.blinking = false;
            this.eyeRenderer.blinkTimer = 0;
        }
    }

    /**
     * Set gaze tracking enabled state
     * @param {boolean} enabled - Whether gaze tracking should be enabled
     */
    setGazeTracking(enabled) {
        this.state.gazeTrackingEnabled = enabled;
        if (enabled) {
            // Start tracking mouse/touch position
            if (!this.gazeTrackingInitialized) {
                this.initGazeTracking();
            }
        } else {
            // Reset gaze to center when disabled
            this.state.gazeTarget = { x: 0, y: 0 };
        }
    }

    /**
     * Initialize gaze tracking event listeners
     */
    initGazeTracking() {
        // Always set up listeners once
        if (this.gazeTrackingInitialized) return;

        this.handleMouseMove = e => {
            if (!this.state.gazeTrackingEnabled) return;

            const rect = this.canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const x = e.clientX - rect.left - centerX;
            const y = e.clientY - rect.top - centerY;

            // Normalize to -1 to 1 range
            this.state.gazeTarget = {
                x: x / centerX,
                y: y / centerY
            };
        };

        this.handleTouchMove = e => {
            if (!this.state.gazeTrackingEnabled) return;

            if (e.touches.length > 0) {
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                const x = touch.clientX - rect.left - centerX;
                const y = touch.clientY - rect.top - centerY;

                // Normalize to -1 to 1 range
                this.state.gazeTarget = {
                    x: x / centerX,
                    y: y / centerY
                };
            }
        };

        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('touchmove', this.handleTouchMove);
        this.gazeTrackingInitialized = true;
    }

    /**
     * Clean up gaze tracking event listeners
     */
    cleanupGazeTracking() {
        if (!this.gazeTrackingInitialized) return;

        if (this.handleMouseMove) {
            document.removeEventListener('mousemove', this.handleMouseMove);
        }
        if (this.handleTouchMove) {
            document.removeEventListener('touchmove', this.handleTouchMove);
        }
        this.gazeTrackingInitialized = false;
    }

    /**
     * Reset canvas context to fix rendering artifacts after tab switch
     */
    resetCanvasContext() {
        if (!this.canvas || !this.ctx) return;

        // Save current dimensions
        const {width} = this.canvas;
        const {height} = this.canvas;

        // Reset all canvas state
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.globalAlpha = 1;
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';

        // Clear the entire canvas
        this.ctx.clearRect(0, 0, width, height);

        // Also reset offscreen canvas if it exists
        if (this.offscreenCanvas && this.offscreenCtx) {
            this.offscreenCtx.setTransform(1, 0, 0, 1, 0, 0);
            this.offscreenCtx.globalAlpha = 1;
            this.offscreenCtx.globalCompositeOperation = 'source-over';
            this.offscreenCtx.imageSmoothingEnabled = true;
            this.offscreenCtx.imageSmoothingQuality = 'high';
            this.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
        }

        // Reset context state manager if it exists
        if (this.contextStateManager) {
            this.contextStateManager.reset();
        }

        // Force a clean render on next frame
        this.forceCleanRender = true;
    }

    
    /**
     * Set quality level for degradation manager compatibility
     * @param {number} quality - Quality level (0-1)
     */
    setQualityLevel(quality) {
        this.qualityLevel = Math.max(0, Math.min(1, quality));
        
        // Adjust rendering parameters based on quality
        if (this.qualityLevel < 0.5) {
            // Low quality mode
            this.ctx.imageSmoothingEnabled = false;
            this.state.breathDepth *= 0.5; // Reduce animation complexity
        } else if (this.qualityLevel < 0.8) {
            // Medium quality
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'medium';
        } else {
            // High quality
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = 'high';
        }
    }
    
    /**
     * Set quality reduction (for degradation manager)
     * @param {boolean} enabled - Whether quality reduction is enabled
     */
    setQualityReduction(enabled) {
        if (enabled) {
            this.setQualityLevel(0.5);
        } else {
            this.setQualityLevel(1.0);
        }
    }
    
    /**
     * Handle canvas context recovery
     * @param {CanvasRenderingContext2D} newContext - New context after recovery
     */
    handleContextRecovery(newContext) {
        this.ctx = newContext;
    }
    
    /**
     * Get the current undertone modifier for particle system
     * @returns {Object|null} Current undertone modifier or null
     */
    getUndertoneModifier() {
        // Use the new weighted method from state machine if available
        if (this.stateMachine && this.stateMachine.getWeightedUndertoneModifiers) {
            return this.stateMachine.getWeightedUndertoneModifiers();
        }
        
        // Fallback to old method
        if (!this.currentUndertone || !this.undertoneModifiers[this.currentUndertone]) {
            return null;
        }
        return this.undertoneModifiers[this.currentUndertone];
    }
    
    /**
     * Apply all active gesture animations
     * Returns combined transform object
     */
    // Gesture animations moved to GestureAnimator module
    applyGestureAnimations() {
        return this.gestureAnimator.applyGestureAnimations();
    }
      
    /**
     * Start a gesture animation - delegates to GestureAnimator
     */
    startGesture(gestureName) {
        // Simply delegate to GestureAnimator
        return this.gestureAnimator.startGesture(gestureName);
    }
    
    /**
     * Get current active gesture information for particle system
     * @returns {Object|null} Current gesture with particleMotion and progress, or null
     */
    getCurrentGesture() {
        // Delegate to GestureAnimator to get current gesture
        return this.gestureAnimator.getCurrentGesture();
    }
    
    // Individual start methods for each gesture - delegate to GestureAnimator
    startBounce() { this.gestureAnimator.startBounce(); }
    startPulse() { this.gestureAnimator.startPulse(); }
    startShake() { this.gestureAnimator.startShake(); }
    startSpin() { this.gestureAnimator.startSpin(); }
    startNod() { this.gestureAnimator.startNod(); }
    startTilt() { this.gestureAnimator.startTilt(); }
    startExpand() { this.gestureAnimator.startExpand(); }
    startContract() { this.gestureAnimator.startContract(); }
    startFlash() { this.gestureAnimator.startFlash(); }
    startDrift() { this.gestureAnimator.startDrift(); }
    startStretch() { this.gestureAnimator.startStretch(); }
    startGlow() { this.gestureAnimator.startGlow(); }
    startFlicker() { this.gestureAnimator.startFlicker(); }
    startVibrate() { this.gestureAnimator.startVibrate(); }
    startOrbital() { this.gestureAnimator.startOrbital(); }
    startHula() { this.gestureAnimator.startHula(); }
    startWave() { this.gestureAnimator.startWave(); }
    startBreathe() { this.gestureAnimator.startBreathe(); }
    startMorph() { this.gestureAnimator.startMorph(); }
    startSlowBlink() { this.gestureAnimator.startSlowBlink(); }
    startLook() { this.gestureAnimator.startLook(); }
    startSettle() { this.gestureAnimator.startSettle(); }
    startBreathIn() { this.gestureAnimator.startBreathIn(); }
    startBreathOut() { this.gestureAnimator.startBreathOut(); }
    startBreathHold() { this.gestureAnimator.startBreathHold(); }
    startBreathHoldEmpty() { this.gestureAnimator.startBreathHoldEmpty(); }
    startJump() { this.gestureAnimator.startJump(); }
    startSway() { this.gestureAnimator.startSway(); }
    startFloat() { this.gestureAnimator.startFloat(); }
    startRain() { this.gestureAnimator.startRain(); }
    startRunningMan() { this.gestureAnimator.startRunningMan(); }
    startCharleston() { this.gestureAnimator.startCharleston(); }

    // Ambient dance animations
    startGrooveSway(options) { this.ambientDanceAnimator.startAmbientAnimation('grooveSway', options); }
    startGrooveBob(options) { this.ambientDanceAnimator.startAmbientAnimation('grooveBob', options); }
    startGrooveFlow(options) { this.ambientDanceAnimator.startAmbientAnimation('grooveFlow', options); }
    startGroovePulse(options) { this.ambientDanceAnimator.startAmbientAnimation('groovePulse', options); }
    startGrooveStep(options) { this.ambientDanceAnimator.startAmbientAnimation('grooveStep', options); }
    startSparkle() { this.gestureAnimator.startSparkle(); }
    startShimmer() { this.gestureAnimator.startShimmer(); }
    startWiggle() { this.gestureAnimator.startWiggle(); }
    startGroove() { this.gestureAnimator.startGroove(); }
    startPoint() { this.gestureAnimator.startPoint(); }
    startLean() { this.gestureAnimator.startLean(); }
    startReach() { this.gestureAnimator.startReach(); }
    startHeadBob() { this.gestureAnimator.startHeadBob(); }
    startOrbit() { this.gestureAnimator.startOrbit(); }
    
    /**
     * Stop all active gestures - delegates to GestureAnimator
     */
    stopAllGestures() {
        this.gestureAnimator.stopAllGestures();
        this.currentGesture = null;
    }
    
    /**
     * Check if any gesture is active - delegates to GestureAnimator
     */
    isGestureActive() {
        return Object.values(this.gestureAnimator.gestureAnimations).some(anim => anim.active);
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        // Cancel all animation frames to prevent memory leaks
        for (const key in this.animationFrameIds) {
            if (this.animationFrameIds[key]) {
                cancelAnimationFrame(this.animationFrameIds[key]);
                this.animationFrameIds[key] = null;
            }
        }
        
        // Clear animation states
        this.colorTransition.active = false;
        if (this.zenTransition) {
            this.zenTransition.active = false;
        }
        
        // Clear other resources
        this.speakingRings = [];
        
        // Clear gesture compositor cache
        if (this.gestureCompositor) {
            this.gestureCompositor.clearCache();
        }
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  GAZE TRACKER  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Gaze Tracker - Interactive Eye Following & Cursor Awareness
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module GazeTracker
 * @changelog 2.1.0 - Cached canvas rect to eliminate reflows on mouse/touch moves
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Brings the orb to LIFE by making it aware of your cursor. Creates natural         
 * ║ eye-following behavior with smooth interpolation. When you move close,            
 * ║ the orb "looks" at you. Move away, and it relaxes back to center.                 
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 👁️ GAZE BEHAVIORS                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Smooth following with linear interpolation (lerp)                               
 * │ • Proximity-based engagement (closer = more response)                             
 * │ • Center lock when cursor is very close                                           
 * │ • Boundary constraints to keep pupils inside orb                                  
 * │ • Touch and mouse support                                                         
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎮 CONFIGURATION                                                                   
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • smoothing       : 0.1 (lerp factor, 0.05-0.15 recommended)                      
 * │ • maxOffset       : 0.3 (max gaze offset as % of core radius)                     
 * │ • lockDistance    : 30px (distance to trigger center lock)                        
 * │ • boundaryPadding : 0.8 (keep gaze within 80% of core)                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class GazeTracker {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        
        // Configuration
        this.config = {
            smoothing: options.smoothing || 0.1,  // Lerp factor (0.05-0.15 recommended)
            maxOffset: options.maxOffset || 0.3,  // Max gaze offset (30% of core radius)
            lockDistance: options.lockDistance || 30,  // Pixels from center to trigger lock
            enabled: options.enabled !== false,
            boundaryPadding: options.boundaryPadding || 0.8  // Keep gaze within 80% of core
        };
        
        // State
        this.canvasCenter = { x: 0, y: 0 };
        this.mousePos = { x: 0, y: 0 };  // Will be initialized to center after updateCanvasCenter
        this.targetGaze = { x: 0, y: 0 };
        this.currentGaze = { x: 0, y: 0 };
        this.isLocked = false;
        this.proximity = 0;  // 0-1 value for how close cursor is
        
        // Cache canvas rect to avoid reflows
        this.cachedRect = null;
        
        // Touch state
        this.touches = new Map();
        this.primaryTouch = null;
        
        // Bind event handlers
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseLeave = this.handleMouseLeave.bind(this);
        this.handleTouchStart = this.handleTouchStart.bind(this);
        this.handleTouchMove = this.handleTouchMove.bind(this);
        this.handleTouchEnd = this.handleTouchEnd.bind(this);
        
        // Interaction callback
        this.onInteraction = null;
        
        // Initialize
        this.updateCanvasCenter();
        this.attachEventListeners();
        
        // Handle canvas resize
        this.resizeObserver = new ResizeObserver(() => {
            this.updateCanvasCenter();
        });
        this.resizeObserver.observe(this.canvas);
    }
    
    /**
     * Update canvas center point
     */
    updateCanvasCenter() {
        // Cache the rect to avoid repeated reflows
        this.cachedRect = this.canvas.getBoundingClientRect();
        this.canvasCenter = {
            x: this.cachedRect.width / 2,
            y: this.cachedRect.height / 2
        };
        // Initialize mouse position to center if not set
        if (this.mousePos.x === 0 && this.mousePos.y === 0) {
            this.mousePos = { x: this.canvasCenter.x, y: this.canvasCenter.y };
        }
    }
    
    /**
     * Attach event listeners
     */
    attachEventListeners() {
        if (!this.config.enabled) return;
        
        // Mouse events
        this.canvas.addEventListener('mousemove', this.handleMouseMove);
        this.canvas.addEventListener('mouseleave', this.handleMouseLeave);
        
        // Touch events
        this.canvas.addEventListener('touchstart', this.handleTouchStart, { passive: true });
        this.canvas.addEventListener('touchmove', this.handleTouchMove, { passive: true });
        this.canvas.addEventListener('touchend', this.handleTouchEnd, { passive: true });
        this.canvas.addEventListener('touchcancel', this.handleTouchEnd, { passive: true });
    }
    
    /**
     * Handle mouse movement
     */
    handleMouseMove(event) {
        // Use cached rect to avoid reflow on every mouse move
        const rect = this.cachedRect || this.canvas.getBoundingClientRect();
        this.mousePos = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };
        this.updateTargetGaze();
        
        // Notify of interaction
        if (this.onInteraction) {
            this.onInteraction('mouse');
        }
    }
    
    /**
     * Handle mouse leave
     */
    handleMouseLeave() {
        // Return gaze to center when mouse leaves
        this.targetGaze = { x: 0, y: 0 };
        this.isLocked = false;
        this.proximity = 0;
        // Reset mouse position to center when leaving
        this.mousePos = { x: this.canvasCenter.x, y: this.canvasCenter.y };
    }
    
    /**
     * Handle touch start
     */
    handleTouchStart(event) {
        for (const touch of event.changedTouches) {
            this.touches.set(touch.identifier, {
                x: touch.clientX,
                y: touch.clientY
            });
            
            // Set first touch as primary
            if (!this.primaryTouch && this.touches.size === 1) {
                this.primaryTouch = touch.identifier;
            }
        }
        
        if (this.primaryTouch !== null) {
            this.updateTouchPosition(event.touches);
        }
    }
    
    /**
     * Handle touch move
     */
    handleTouchMove(event) {
        for (const touch of event.changedTouches) {
            if (this.touches.has(touch.identifier)) {
                this.touches.set(touch.identifier, {
                    x: touch.clientX,
                    y: touch.clientY
                });
            }
        }
        
        if (this.primaryTouch !== null) {
            this.updateTouchPosition(event.touches);
            
            // Notify of interaction
            if (this.onInteraction) {
                this.onInteraction('touch');
            }
        }
    }
    
    /**
     * Handle touch end
     */
    handleTouchEnd(event) {
        for (const touch of event.changedTouches) {
            this.touches.delete(touch.identifier);
            
            // Reset primary touch if it ended
            if (touch.identifier === this.primaryTouch) {
                this.primaryTouch = null;
                
                // Select new primary touch if available
                if (this.touches.size > 0) {
                    this.primaryTouch = this.touches.keys().next().value;
                } else {
                    // No touches left, return to center
                    this.handleMouseLeave();
                }
            }
        }
    }
    
    /**
     * Update position from touch
     */
    updateTouchPosition(touches) {
        for (const touch of touches) {
            if (touch.identifier === this.primaryTouch) {
                // Use cached rect to avoid reflow on every touch move
                const rect = this.cachedRect || this.canvas.getBoundingClientRect();
                this.mousePos = {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
                this.updateTargetGaze();
                break;
            }
        }
    }
    
    /**
     * Calculate target gaze position based on mouse/touch position
     */
    updateTargetGaze() {
        // Calculate vector from center to mouse
        const dx = this.mousePos.x - this.canvasCenter.x;
        const dy = this.mousePos.y - this.canvasCenter.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate proximity (0-1, closer = higher)
        const maxDistance = Math.min(this.canvasCenter.x, this.canvasCenter.y);
        this.proximity = Math.max(0, 1 - (distance / maxDistance));
        
        // Check for gaze lock (very close to center)
        this.isLocked = distance < this.config.lockDistance;
        
        if (this.isLocked) {
            // When locked, gaze moves more dramatically
            this.targetGaze = {
                x: dx * this.config.maxOffset * 2,
                y: dy * this.config.maxOffset * 2
            };
        } else {
            // Normal gaze following with boundary constraints
            const maxOffset = Math.min(this.canvasCenter.x, this.canvasCenter.y) * this.config.maxOffset;
            
            if (distance > 0) {
                // Normalize and apply max offset
                const factor = Math.min(1, distance / maxDistance);
                this.targetGaze = {
                    x: (dx / distance) * maxOffset * factor * this.config.boundaryPadding,
                    y: (dy / distance) * maxOffset * factor * this.config.boundaryPadding
                };
            } else {
                this.targetGaze = { x: 0, y: 0 };
            }
        }
    }
    
    /**
     * Update gaze position with smooth interpolation
     * @param {number} deltaTime - Time since last update in ms
     */
    update(deltaTime) {
        if (!this.config.enabled) return;
        
        // Smooth interpolation towards target
        const smoothing = 1 - Math.pow(1 - this.config.smoothing, deltaTime / 16.67); // Normalize to 60fps
        
        this.currentGaze.x += (this.targetGaze.x - this.currentGaze.x) * smoothing;
        this.currentGaze.y += (this.targetGaze.y - this.currentGaze.y) * smoothing;
        
        // Add micro jitter when locked for liveliness
        if (this.isLocked) {
            const jitter = 0.5;
            this.currentGaze.x += (Math.random() - 0.5) * jitter;
            this.currentGaze.y += (Math.random() - 0.5) * jitter;
        }
    }
    
    /**
     * Get current gaze offset for rendering
     * @param {number} coreRadius - The radius of the core
     * @returns {Object} Gaze offset {x, y}
     */
    getGazeOffset(coreRadius) {
        return {
            x: this.currentGaze.x,
            y: this.currentGaze.y
        };
    }
    
    /**
     * Get current state
     * @returns {Object} Current gaze state
     */
    getState() {
        return {
            gaze: { ...this.currentGaze },
            target: { ...this.targetGaze },
            proximity: this.proximity,
            isLocked: this.isLocked,
            isActive: this.config.enabled
        };
    }
    
    /**
     * Enable gaze tracking
     */
    enable() {
        if (!this.config.enabled) {
            this.config.enabled = true;
            this.attachEventListeners();
        }
    }
    
    /**
     * Disable gaze tracking
     */
    disable() {
        if (this.config.enabled) {
            this.config.enabled = false;
            this.detachEventListeners();
            this.targetGaze = { x: 0, y: 0 };
        }
    }
    
    /**
     * Detach event listeners
     */
    detachEventListeners() {
        this.canvas.removeEventListener('mousemove', this.handleMouseMove);
        this.canvas.removeEventListener('mouseleave', this.handleMouseLeave);
        this.canvas.removeEventListener('touchstart', this.handleTouchStart);
        this.canvas.removeEventListener('touchmove', this.handleTouchMove);
        this.canvas.removeEventListener('touchend', this.handleTouchEnd);
        this.canvas.removeEventListener('touchcancel', this.handleTouchEnd);
    }
    
    /**
     * Set interaction callback
     * @param {Function} callback - Function to call on interaction
     */
    setInteractionCallback(callback) {
        this.onInteraction = callback;
    }
    
    /**
     * Clean up resources
     */
    destroy() {
        this.detachEventListeners();
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
        this.touches.clear();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  IDLE BEHAVIOR  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Idle Behavior - Organic Life Through Subtle Animations
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module IdleBehavior
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Makes the orb feel ALIVE even when you're not interacting. Random blinks,         
 * ║ subtle swaying, gentle breathing - all the little unconscious movements           
 * ║ that make something feel like it has a soul rather than just code.                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 😴 IDLE ANIMATIONS                                                                
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Blinking     : Random intervals (3-7 seconds)                                   
 * │ • Swaying      : Subtle drift (20-40 second intervals)                            
 * │ • Breathing    : Continuous gentle pulsing                                        
 * │ • Sleep Mode   : After timeout (default: never)                                   
 * │ • Weight Shift : Occasional position adjustments                                  
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⏱️ TIMING CONFIGURATION                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ BEHAVIOR       MIN TIME    MAX TIME    DURATION                                  
 * │ Blinking       3000ms      7000ms      150ms                                     
 * │ Swaying        20000ms     40000ms     4000ms                                    
 * │ Sleep          Infinity    -            -                                        
 * │ Breathing      continuous  -            0.25 rad/s                               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class IdleBehavior {
    constructor(options = {}) {
        // Configuration
        this.config = {
            blinkInterval: options.blinkInterval || { min: 3000, max: 7000 }, // ms - less frequent
            blinkDuration: options.blinkDuration || 150, // ms
            swayInterval: options.swayInterval || { min: 20000, max: 40000 }, // ms - very infrequent weight shifts
            swayDuration: options.swayDuration || 4000, // ms - very slow, smooth transition
            swayIntensity: options.swayIntensity || 1.5, // pixels - extremely subtle drift
            sleepTimeout: options.sleepTimeout !== undefined ? options.sleepTimeout : Infinity, // Default: never auto-sleep
            breathingSpeed: options.breathingSpeed || 0.25, // radians per second
            breathingDepth: options.breathingDepth || 0.1, // 10% size variation
            enabled: options.enabled !== false
        };
        
        // State
        this.state = {
            isBlinking: false,
            isSwaying: false,
            isAsleep: false,
            breathingPhase: 0,
            breathRate: 1.0,
            breathDepth: this.config.breathingDepth
        };
        
        // Timers
        this.timers = {
            idle: 0,
            blink: 0,
            sway: 0,
            swayProgress: 0,  // 0 to 1 progress through sway animation
            nextBlink: this.getRandomInterval('blink'),
            nextSway: this.getRandomInterval('sway')
        };
        
        // Sway state - smooth weight shift
        this.swayOffset = { x: 0, y: 0 };
        this.swayTarget = { x: 0, y: 0 };
        this.swayStart = { x: 0, y: 0 };
        
        // Callbacks
        this.callbacks = {
            onBlink: null,
            onSway: null,
            onSleep: null,
            onWake: null
        };
        
    }
    
    /**
     * Update idle behaviors
     * @param {number} deltaTime - Time since last update in ms
     */
    update(deltaTime) {
        if (!this.config.enabled) return;
        
        // Update breathing
        this.updateBreathing(deltaTime);
        
        // Update idle timer
        this.timers.idle += deltaTime;
        
        // Check for sleep
        if (!this.state.isAsleep && this.timers.idle >= this.config.sleepTimeout) {
            this.enterSleep();
        }
        
        // Update blinking (only when awake)
        if (!this.state.isAsleep) {
            this.updateBlinking(deltaTime);
        }
        
        // Update swaying (only when awake)
        if (!this.state.isAsleep) {
            this.updateSwaying(deltaTime);
        }
    }
    
    /**
     * Update breathing animation
     */
    updateBreathing(deltaTime) {
        const speed = this.config.breathingSpeed * this.state.breathRate;
        this.state.breathingPhase += (speed * deltaTime) / 1000;
        
        // Keep phase in reasonable range
        if (this.state.breathingPhase > Math.PI * 2) {
            this.state.breathingPhase -= Math.PI * 2;
        }
    }
    
    /**
     * Update blinking behavior
     */
    updateBlinking(deltaTime) {
        // Check if blinking is disabled
        if (!this.isBlinkingEnabled()) {
            return;
        }
        
        if (!this.state.isBlinking) {
            // Wait for next blink
            this.timers.blink += deltaTime;
            if (this.timers.blink >= this.timers.nextBlink) {
                this.startBlink();
            }
        } else {
            // Currently blinking
            this.timers.blink += deltaTime;
            if (this.timers.blink >= this.config.blinkDuration) {
                this.endBlink();
            }
        }
    }
    
    /**
     * Update swaying behavior (smooth weight shift)
     */
    updateSwaying(deltaTime) {
        if (!this.state.isSwaying) {
            // Wait for next sway
            this.timers.sway += deltaTime;
            if (this.timers.sway >= this.timers.nextSway) {
                this.startSway();
            }
        } else {
            // Currently swaying - smooth interpolation
            this.timers.sway += deltaTime;
            const progress = Math.min(this.timers.sway / this.config.swayDuration, 1);
            
            // Use sine wave for smooth in-out easing
            const easedProgress = (Math.sin((progress - 0.5) * Math.PI) + 1) / 2;
            
            // Interpolate between start and target positions
            this.swayOffset.x = this.swayStart.x + (this.swayTarget.x - this.swayStart.x) * easedProgress;
            this.swayOffset.y = this.swayStart.y + (this.swayTarget.y - this.swayStart.y) * easedProgress;
            
            if (progress >= 1) {
                this.endSway();
            }
        }
    }
    
    /**
     * Start a blink
     */
    startBlink() {
        this.state.isBlinking = true;
        this.timers.blink = 0;
        
        if (this.callbacks.onBlink) {
            this.callbacks.onBlink({ phase: 'start' });
        }
    }
    
    /**
     * End a blink
     */
    endBlink() {
        this.state.isBlinking = false;
        this.timers.blink = 0;
        this.timers.nextBlink = this.getRandomInterval('blink');
        
        if (this.callbacks.onBlink) {
            this.callbacks.onBlink({ phase: 'end' });
        }
    }
    
    /**
     * Start a sway (smooth weight shift)
     */
    startSway() {
        this.state.isSwaying = true;
        this.timers.sway = 0;
        
        // Save current position as start
        this.swayStart = { ...this.swayOffset };
        
        // Generate subtle target offset - like shifting weight
        // Favor horizontal movement (side to side weight shift)
        const angle = Math.random() * Math.PI * 2;
        const distance = this.config.swayIntensity * (0.5 + Math.random() * 0.5);
        this.swayTarget = {
            x: Math.cos(angle) * distance * 1.5,  // Slightly more horizontal
            y: Math.sin(angle) * distance * 0.5   // Less vertical
        };
        
        if (this.callbacks.onSway) {
            this.callbacks.onSway({ 
                phase: 'start',
                offset: this.swayOffset
            });
        }
    }
    
    /**
     * End a sway
     */
    endSway() {
        this.state.isSwaying = false;
        this.timers.sway = 0;
        this.timers.nextSway = this.getRandomInterval('sway');
        
        // Start position for next sway is current position
        this.swayStart = { ...this.swayOffset };
        
        if (this.callbacks.onSway) {
            this.callbacks.onSway({ 
                phase: 'end',
                offset: this.swayOffset
            });
        }
    }
    
    /**
     * Enter sleep mode
     */
    enterSleep() {
        this.state.isAsleep = true;
        this.state.breathRate = 0.5; // Slower breathing
        this.state.breathDepth = 0.15; // Deeper breaths
        
        // Force end any active blink
        if (this.state.isBlinking) {
            this.state.isBlinking = false;
            this.timers.blink = 0;
            if (this.callbacks.onBlink) {
                this.callbacks.onBlink({ phase: 'end' });
            }
        }
        
        
        if (this.callbacks.onSleep) {
            this.callbacks.onSleep();
        }
    }
    
    /**
     * Wake up from sleep
     */
    wakeUp() {
        if (!this.state.isAsleep) return;
        
        this.state.isAsleep = false;
        this.state.breathRate = 1.0;
        this.state.breathDepth = this.config.breathingDepth;
        this.timers.idle = 0; // Reset idle timer
        
        
        // Trigger a shake animation
        if (this.callbacks.onWake) {
            this.callbacks.onWake();
        }
        
        // Quick twitch series for wake animation
        this.performWakeAnimation();
    }
    
    /**
     * Perform wake-up animation
     */
    performWakeAnimation() {
        // Gentle stretch animation when waking
        const stretchOffset = {
            x: this.config.swayIntensity * 0.5,
            y: -this.config.swayIntensity  // Slight upward stretch
        };
        
        // Animate from current position to stretch and back
        this.swayStart = { ...this.swayOffset };
        this.swayTarget = stretchOffset;
        this.state.isSwaying = true;
        this.timers.sway = 0;
        
        if (this.callbacks.onSway) {
            this.callbacks.onSway({ 
                phase: 'wake',
                offset: this.swayOffset
            });
        }
        
        // Return to neutral after stretch
        setTimeout(() => {
            this.swayStart = { ...this.swayOffset };
            this.swayTarget = { x: 0, y: 0 };
            this.timers.sway = 0;
        }, 1000);
    }
    
    /**
     * Reset idle timer (called on user interaction)
     */
    resetIdleTimer() {
        this.timers.idle = 0;
        if (this.state.isAsleep) {
            this.wakeUp();
        }
    }
    
    /**
     * Enable or disable blinking
     * @param {boolean} enabled - Whether blinking should be enabled
     */
    setBlinkingEnabled(enabled) {
        this.config.blinkingEnabled = enabled;
        if (!enabled && this.state.isBlinking) {
            // If currently blinking, finish the blink
            this.endBlink();
        }
    }
    
    /**
     * Check if blinking is enabled
     * @returns {boolean} Whether blinking is enabled
     */
    isBlinkingEnabled() {
        return this.config.blinkingEnabled !== false;
    }
    
    /**
     * Get breathing factor for current phase
     * @returns {number} Breathing factor (0.9 - 1.1 typically)
     */
    getBreathingFactor() {
        return 1 + Math.sin(this.state.breathingPhase) * this.state.breathDepth * this.state.breathRate;
    }
    
    /**
     * Get blink progress (0-1)
     * @returns {number} Blink progress
     */
    getBlinkProgress() {
        if (!this.state.isBlinking) return 0;
        return Math.min(this.timers.blink / this.config.blinkDuration, 1);
    }
    
    /**
     * Get current sway offset
     * @returns {Object} Sway offset {x, y}
     */
    getSwayOffset() {
        return this.swayOffset || { x: 0, y: 0 };
    }
    
    /**
     * Get random interval for behavior
     */
    getRandomInterval(type) {
        const interval = this.config[`${type}Interval`];
        return interval.min + Math.random() * (interval.max - interval.min);
    }
    
    /**
     * Set callback for behavior events
     */
    setCallback(event, callback) {
        if (Object.prototype.hasOwnProperty.call(this.callbacks, event)) {
            this.callbacks[event] = callback;
        }
    }
    
    /**
     * Get current state
     */
    getState() {
        return {
            ...this.state,
            breathingFactor: this.getBreathingFactor(),
            blinkProgress: this.getBlinkProgress(),
            swayOffset: this.getSwayOffset()
        };
    }
    
    /**
     * Enable idle behaviors
     */
    enable() {
        this.config.enabled = true;
    }
    
    /**
     * Disable idle behaviors
     */
    disable() {
        this.config.enabled = false;
        this.state.isBlinking = false;
        this.state.isSwaying = false;
        this.swayOffset = { x: 0, y: 0 };
    }
    
    /**
     * Clean up
     */
    destroy() {
        this.callbacks = {
            onBlink: null,
            onSway: null,
            onSleep: null,
            onWake: null
        };
    }
}

var IdleBehavior$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: IdleBehavior
});

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Element Targeting System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Element-based positioning methods for mascot targeting
 * @author Emotive Engine Team
 * @module positioning/ElementTargeting
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides methods to position the mascot relative to DOM elements dynamically.     
 * ║ Handles common UI elements like buttons, forms, modals, and navigation.           
 * ║ Automatically updates position when elements move or resize.                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

class ElementTargeting {
    constructor(positionController) {
        this.positionController = positionController;
        this.watchedElements = new Map();
        this.updateCallbacks = new Map();
    }

    /**
     * Move mascot to any element with flexible positioning
     * @param {string} targetSelector - CSS selector for target element
     * @param {string} position - 'right', 'left', 'above', 'below', 'center'
     * @param {Object} offset - {x, y} pixel offset
     * @param {Object} options - Additional options
     */
    moveToElement(targetSelector, position = 'right', offset = { x: 20, y: 0 }, options = {}) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const rect = element.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        let targetX, targetY;
        switch (position) {
        case 'right':
            targetX = rect.right + offset.x;
            targetY = centerY + offset.y;
            break;
        case 'left':
            targetX = rect.left - offset.x;
            targetY = centerY + offset.y;
            break;
        case 'above':
            targetX = centerX + offset.x;
            targetY = rect.top - offset.y;
            break;
        case 'below':
            targetX = centerX + offset.x;
            targetY = rect.bottom + offset.y;
            break;
        case 'center':
            targetX = centerX + offset.x;
            targetY = centerY + offset.y;
            break;
        default:
            targetX = rect.right + offset.x;
            targetY = centerY + offset.y;
        }

        // Convert to mascot coordinate system
        const mascotX = targetX - window.innerWidth / 2;
        const mascotY = targetY - window.innerHeight / 2;

        if (options.animate !== false) {
            this.positionController.animateOffset(mascotX, mascotY, 0, options.duration || 1000, options.easing || 'easeOutCubic');
        } else {
            this.positionController.setOffset(mascotX, mascotY, 0);
        }
    }

    /**
     * Move mascot to any button element
     * @param {string} selector - CSS selector for button (optional)
     * @param {string} position - Position relative to button
     * @param {Object} offset - Pixel offset
     */
    moveToButton(selector = 'button', position = 'right', offset = { x: 20, y: 0 }) {
        this.moveToElement(selector, position, offset);
    }

    /**
     * Move mascot to form elements
     * @param {string} selector - CSS selector for form
     * @param {string} position - Position relative to form
     * @param {Object} offset - Pixel offset
     */
    moveToForm(selector = 'form', position = 'right', offset = { x: 20, y: 0 }) {
        this.moveToElement(selector, position, offset);
    }

    /**
     * Move mascot to modal/dialog elements
     * @param {string} selector - CSS selector for modal
     * @param {string} position - Position relative to modal
     * @param {Object} offset - Pixel offset
     */
    moveToModal(selector = '[role="dialog"], .modal', position = 'center', offset = { x: 0, y: 0 }) {
        this.moveToElement(selector, position, offset);
    }

    /**
     * Move mascot to navigation elements
     * @param {string} selector - CSS selector for navigation
     * @param {string} position - Position relative to navigation
     * @param {Object} offset - Pixel offset
     */
    moveToNavigation(selector = 'nav, .navigation', position = 'below', offset = { x: 0, y: 20 }) {
        this.moveToElement(selector, position, offset);
    }

    /**
     * Move mascot to main content areas
     * @param {string} selector - CSS selector for content
     * @param {string} position - Position relative to content
     * @param {Object} offset - Pixel offset
     */
    moveToContent(selector = 'main, .content', position = 'center', offset = { x: 0, y: 0 }) {
        this.moveToElement(selector, position, offset);
    }

    /**
     * Move mascot to sidebar elements
     * @param {string} selector - CSS selector for sidebar
     * @param {string} position - Position relative to sidebar
     * @param {Object} offset - Pixel offset
     */
    moveToSidebar(selector = '.sidebar, aside', position = 'right', offset = { x: 20, y: 0 }) {
        this.moveToElement(selector, position, offset);
    }

    /**
     * Move mascot to header elements
     * @param {string} selector - CSS selector for header
     * @param {string} position - Position relative to header
     * @param {Object} offset - Pixel offset
     */
    moveToHeader(selector = 'header, .header', position = 'below', offset = { x: 0, y: 20 }) {
        this.moveToElement(selector, position, offset);
    }

    /**
     * Move mascot to footer elements
     * @param {string} selector - CSS selector for footer
     * @param {string} position - Position relative to footer
     * @param {Object} offset - Pixel offset
     */
    moveToFooter(selector = 'footer, .footer', position = 'above', offset = { x: 0, y: 20 }) {
        this.moveToElement(selector, position, offset);
    }

    /**
     * Watch an element and update mascot position when it moves
     * @param {string} targetSelector - CSS selector for target element
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     * @returns {Function} Cleanup function to stop watching
     */
    watchElement(targetSelector, position = 'right', offset = { x: 20, y: 0 }) {
        const updatePosition = () => {
            this.moveToElement(targetSelector, position, offset, { animate: false });
        };

        // Store the callback for cleanup
        const callbackId = `${targetSelector}-${position}-${JSON.stringify(offset)}`;
        this.updateCallbacks.set(callbackId, updatePosition);

        // Add event listeners
        window.addEventListener('scroll', updatePosition);
        window.addEventListener('resize', updatePosition);
        
        // Initial positioning
        updatePosition();

        // Return cleanup function
        return () => {
            window.removeEventListener('scroll', updatePosition);
            window.removeEventListener('resize', updatePosition);
            this.updateCallbacks.delete(callbackId);
        };
    }

    /**
     * Stop watching all elements
     */
    stopWatchingAll() {
        this.updateCallbacks.forEach(callback => {
            window.removeEventListener('scroll', callback);
            window.removeEventListener('resize', callback);
        });
        this.updateCallbacks.clear();
    }

    /**
     * Destroy the targeting system
     */
    destroy() {
        this.stopWatchingAll();
        this.positionController = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Element Targeting with Callbacks
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Element targeting with callback functionality for mascot positioning
 * @author Emotive Engine Team
 * @module positioning/elementTargeting/ElementTargetingCallbacks
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides callback-based element targeting methods. Allows mascot to move to      
 * ║ elements and execute callbacks when reaching them. Supports sequences, delays,   
 * ║ conditions, and proximity-based triggers.                                        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class ElementTargetingCallbacks extends ElementTargeting {
    constructor(positionController) {
        super(positionController);
        this.activeCallbacks = new Map();
        this.callbackStates = new Map();
    }

    /**
     * Move mascot to element and execute callback when reached
     * @param {string} targetSelector - CSS selector for target element
     * @param {Function} callback - Callback to execute when mascot reaches element
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     * @param {Object} options - Additional options
     */
    moveToElementWithCallback(targetSelector, callback, position = 'right', offset = { x: 20, y: 0 }, options = {}) {
        const callbackId = `callback-${Date.now()}-${Math.random()}`;
        
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        // Store callback state
        this.callbackStates.set(callbackId, {
            executed: false,
            element,
            callback,
            options
        });

        // Move to element
        this.moveToElement(targetSelector, position, offset, options);

        // Check if mascot has reached the element
        const checkProximity = () => {
            if (this.isMascotNearElement(element, options.proximity || 50)) {
                const state = this.callbackStates.get(callbackId);
                if (state && !state.executed) {
                    state.executed = true;
                    callback();
                    
                    // Clean up if not repeating
                    if (!options.repeat) {
                        this.callbackStates.delete(callbackId);
                    }
                }
            }
            
            if (this.callbackStates.has(callbackId)) {
                requestAnimationFrame(checkProximity);
            }
        };

        this.activeCallbacks.set(callbackId, checkProximity);
        checkProximity();

        return () => {
            this.activeCallbacks.delete(callbackId);
            this.callbackStates.delete(callbackId);
        };
    }

    /**
     * Move mascot through a sequence of elements with callbacks
     * @param {Array} sequence - Array of {selector, callback, position, offset} objects
     * @param {Object} options - Sequence options
     */
    moveToElementSequence(sequence = [], options = {}) {
        let currentIndex = 0;
        const cleanupFunctions = [];

        const executeNext = () => {
            if (currentIndex >= sequence.length) {
                if (options.onComplete) options.onComplete();
                return;
            }

            const step = sequence[currentIndex];
            const cleanup = this.moveToElementWithCallback(
                step.selector,
                () => {
                    if (step.callback) step.callback();
                    currentIndex++;
                    setTimeout(executeNext, step.delay || 0);
                },
                step.position || 'right',
                step.offset || { x: 20, y: 0 },
                { ...options, ...step.options }
            );

            if (cleanup) cleanupFunctions.push(cleanup);
        };

        executeNext();

        return () => {
            cleanupFunctions.forEach(cleanup => cleanup());
        };
    }

    /**
     * Move mascot to element with delay before callback
     * @param {string} targetSelector - CSS selector for target element
     * @param {Function} callback - Callback to execute after delay
     * @param {number} delay - Delay in milliseconds
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithDelay(targetSelector, callback, delay = 1000, position = 'right', offset = { x: 20, y: 0 }) {
        return this.moveToElementWithCallback(
            targetSelector,
            () => {
                setTimeout(callback, delay);
            },
            position,
            offset
        );
    }

    /**
     * Move mascot to element with conditional callback
     * @param {string} targetSelector - CSS selector for target element
     * @param {Function} condition - Condition function that returns boolean
     * @param {Function} callback - Callback to execute if condition is true
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithCondition(targetSelector, condition, callback, position = 'right', offset = { x: 20, y: 0 }) {
        return this.moveToElementWithCallback(
            targetSelector,
            () => {
                if (condition()) {
                    callback();
                }
            },
            position,
            offset
        );
    }

    /**
     * Move mascot to element with repeating callback
     * @param {string} targetSelector - CSS selector for target element
     * @param {Function} callback - Callback to repeat while at element
     * @param {number} interval - Repeat interval in milliseconds
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithRepeat(targetSelector, callback, interval = 1000, position = 'right', offset = { x: 20, y: 0 }) {
        return this.moveToElementWithCallback(
            targetSelector,
            () => {
                setInterval(callback, interval);
            },
            position,
            offset,
            { repeat: true }
        );
    }

    /**
     * Move mascot to element with proximity-based callback
     * @param {string} targetSelector - CSS selector for target element
     * @param {Function} callback - Callback to execute when within proximity
     * @param {number} proximity - Proximity threshold in pixels
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithProximity(targetSelector, callback, proximity = 100, position = 'right', offset = { x: 20, y: 0 }) {
        return this.moveToElementWithCallback(
            targetSelector,
            callback,
            position,
            offset,
            { proximity }
        );
    }

    /**
     * Check if mascot is near an element
     * @param {HTMLElement} element - Target element
     * @param {number} threshold - Distance threshold in pixels
     * @returns {boolean} True if mascot is within threshold
     */
    isMascotNearElement(element, threshold = 50) {
        if (!this.positionController || !element) return false;

        const elementRect = element.getBoundingClientRect();
        const elementCenterX = elementRect.left + elementRect.width / 2;
        const elementCenterY = elementRect.top + elementRect.height / 2;

        const mascotOffset = this.positionController.getOffset();
        const mascotX = mascotOffset.x + window.innerWidth / 2;
        const mascotY = mascotOffset.y + window.innerHeight / 2;

        const distance = Math.sqrt(
            Math.pow(mascotX - elementCenterX, 2) + 
            Math.pow(mascotY - elementCenterY, 2)
        );

        return distance <= threshold;
    }

    /**
     * Stop all active callbacks
     */
    stopAllCallbacks() {
        this.activeCallbacks.forEach((callback, id) => {
            this.activeCallbacks.delete(id);
        });
        this.callbackStates.clear();
    }

    /**
     * Destroy the callback system
     */
    destroy() {
        this.stopAllCallbacks();
        super.destroy();
    }
}

/**
 * Advanced Element Targeting utilities.
 * Provides path following, easing, collision detection, audio-reactive movement, and gaze features.
 */


class ElementTargetingAdvanced extends ElementTargeting {
    constructor(positionController) {
        super(positionController);
        this.activePaths = new Map();
        this.obstacles = new Set();
        this.audioContext = null;
        this.audioAnalyser = null;
        this.gazeTracker = null;
    }

    /**
     * Move mascot to element following a custom path
     * @param {string} targetSelector - CSS selector for target element
     * @param {Array} pathPoints - Array of {x, y} points defining the path
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     * @param {Object} options - Path options
     */
    moveToElementWithPath(targetSelector, pathPoints = [], position = 'right', offset = { x: 20, y: 0 }, options = {}) {
        const pathId = `path-${Date.now()}-${Math.random()}`;
        const element = document.querySelector(targetSelector);

        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const viewportWidth = window.innerWidth || 1;
        const viewportHeight = window.innerHeight || 1;
        const halfViewportWidth = viewportWidth / 2;
        const halfViewportHeight = viewportHeight / 2;

        const coordinateSystem = options.coordinateSystem || 'auto';

        const normalizePoint = (point = {}) => {
            const rawX = typeof point.x === 'number' ? point.x : 0;
            const rawY = typeof point.y === 'number' ? point.y : 0;

            const useRelative = coordinateSystem === 'relative' || (coordinateSystem === 'auto' && rawX >= 0 && rawX <= 1 && rawY >= 0 && rawY <= 1);
            if (useRelative) {
                return {
                    x: rawX * viewportWidth - halfViewportWidth,
                    y: rawY * viewportHeight - halfViewportHeight
                };
            }

            if (coordinateSystem === 'offset' || (coordinateSystem === 'auto' && Math.abs(rawX) <= halfViewportWidth && Math.abs(rawY) <= halfViewportHeight)) {
                return { x: rawX, y: rawY };
            }

            return {
                x: rawX - halfViewportWidth,
                y: rawY - halfViewportHeight
            };
        };

        const processedPathPoints = Array.isArray(pathPoints) ? pathPoints.map(normalizePoint) : [];

        const rect = element.getBoundingClientRect();
        const targetPoint = {
            x: rect.left + rect.width / 2 + offset.x - halfViewportWidth,
            y: rect.top + rect.height / 2 + offset.y - halfViewportHeight
        };

        const startOffsetRaw = this.positionController.getOffset ? this.positionController.getOffset() : { x: 0, y: 0 };
        const startOffset = {
            x: typeof startOffsetRaw.x === 'number' ? startOffsetRaw.x : 0,
            y: typeof startOffsetRaw.y === 'number' ? startOffsetRaw.y : 0
        };

        const path = [startOffset, ...processedPathPoints, targetPoint];

        if (path.length < 2) {
            this.positionController.setOffset(targetPoint.x, targetPoint.y, 0);
            if (typeof options.onComplete === 'function') {
                options.onComplete();
            }
            return;
        }

        const segmentLengths = [];
        const cumulativeLengths = [0];
        let totalLength = 0;

        for (let i = 0; i < path.length - 1; i++) {
            const dx = path[i + 1].x - path[i].x;
            const dy = path[i + 1].y - path[i].y;
            const length = Math.hypot(dx, dy);
            segmentLengths.push(length);
            totalLength += length;
            cumulativeLengths.push(totalLength);
        }

        if (totalLength === 0) {
            this.positionController.setOffset(targetPoint.x, targetPoint.y, 0);
            if (typeof options.onComplete === 'function') {
                options.onComplete();
            }
            return;
        }

        const speed = typeof options.speed === 'number' && options.speed > 0 ? options.speed : 250;
        const loop = options.loop === true;
        const easing = options.easing || 'linear';

        const state = {
            covered: 0,
            lastTimestamp: null
        };

        const resolvePointOnPath = distance => {
            if (!loop) {
                if (distance <= 0) {
                    return path[0];
                }
                if (distance >= totalLength) {
                    return path[path.length - 1];
                }
            } else {
                distance = distance % totalLength;
            }

            for (let i = 0; i < segmentLengths.length; i++) {
                const segmentStart = cumulativeLengths[i];
                const segmentEnd = cumulativeLengths[i + 1];
                if (distance <= segmentEnd) {
                    const segmentLength = segmentLengths[i] || 1;
                    const progress = segmentLength === 0 ? 0 : (distance - segmentStart) / segmentLength;
                    const eased = this.positionController && typeof this.positionController.applyEasing === 'function'
                        ? this.positionController.applyEasing(progress, easing)
                        : progress;
                    const startPoint = path[i];
                    const endPoint = path[i + 1];
                    return {
                        x: startPoint.x + (endPoint.x - startPoint.x) * eased,
                        y: startPoint.y + (endPoint.y - startPoint.y) * eased
                    };
                }
            }

            return path[path.length - 1];
        };

        const pathEntry = {
            stop: () => {
                if (pathEntry.frameId) {
                    cancelAnimationFrame(pathEntry.frameId);
                }
                this.activePaths.delete(pathId);
            },
            frameId: null
        };

        this.activePaths.set(pathId, pathEntry);

        this.positionController.setOffset(path[0].x, path[0].y, 0);

        const step = timestamp => {
            if (!this.activePaths.has(pathId)) {
                return;
            }

            if (state.lastTimestamp === null) {
                state.lastTimestamp = timestamp;
            }

            const delta = timestamp - state.lastTimestamp;
            state.lastTimestamp = timestamp;

            state.covered += speed * (delta / 1000);

            if (!loop && state.covered >= totalLength) {
                this.positionController.setOffset(targetPoint.x, targetPoint.y, 0);
                pathEntry.stop();
                if (typeof options.onComplete === 'function') {
                    options.onComplete();
                }
                return;
            }

            const point = resolvePointOnPath(state.covered);
            this.positionController.setOffset(point.x, point.y, 0);

            pathEntry.frameId = requestAnimationFrame(step);
        };

        pathEntry.frameId = requestAnimationFrame(step);

        return () => {
            pathEntry.stop();
        };
    }

    /**
     * Move mascot to element with custom easing
     * @param {string} targetSelector - CSS selector for target element
     * @param {Function} easingFunction - Custom easing function
     * @param {number} duration - Animation duration in milliseconds
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithEasing(targetSelector, easingFunction, duration = 1000, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const startOffset = this.positionController.getOffset();
        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easingFunction(progress);

            const currentX = startOffset.x + (targetX - startOffset.x) * easedProgress;
            const currentY = startOffset.y + (targetY - startOffset.y) * easedProgress;

            this.positionController.setOffset(currentX, currentY, 0);

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        requestAnimationFrame(animate);
    }

    /**
     * Move mascot to element while avoiding obstacles
     * @param {string} targetSelector - CSS selector for target element
     * @param {Array} obstacles - Array of obstacle selectors or positions
     * @param {number} avoidanceDistance - Distance to maintain from obstacles
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithCollision(targetSelector, obstacles = [], avoidanceDistance = 100, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const startOffset = this.positionController.getOffset();
        const steps = 100;
        const stepSize = 1 / steps;

        const navigate = () => {
            let currentX = startOffset.x;
            let currentY = startOffset.y;

            for (let i = 0; i <= steps; i++) {
                const progress = i * stepSize;
                const nextX = startOffset.x + (targetX - startOffset.x) * progress;
                const nextY = startOffset.y + (targetY - startOffset.y) * progress;

                // Check for obstacles
                let hasCollision = false;
                obstacles.forEach(obstacle => {
                    let obstacleX, obstacleY;
                    
                    if (typeof obstacle === 'string') {
                        const obstacleElement = document.querySelector(obstacle);
                        if (obstacleElement) {
                            const obstacleRect = obstacleElement.getBoundingClientRect();
                            obstacleX = obstacleRect.left + obstacleRect.width / 2 - window.innerWidth / 2;
                            obstacleY = obstacleRect.top + obstacleRect.height / 2 - window.innerHeight / 2;
                        } else {
                            return;
                        }
                    } else {
                        obstacleX = obstacle.x - window.innerWidth / 2;
                        obstacleY = obstacle.y - window.innerHeight / 2;
                    }

                    const distance = Math.sqrt(
                        Math.pow(nextX - obstacleX, 2) + 
                        Math.pow(nextY - obstacleY, 2)
                    );

                    if (distance < avoidanceDistance) {
                        hasCollision = true;
                        // Calculate avoidance vector
                        const angle = Math.atan2(nextY - obstacleY, nextX - obstacleX);
                        const avoidanceX = obstacleX + Math.cos(angle) * avoidanceDistance;
                        const avoidanceY = obstacleY + Math.sin(angle) * avoidanceDistance;
                        
                        currentX = avoidanceX;
                        currentY = avoidanceY;
                    }
                });

                if (!hasCollision) {
                    currentX = nextX;
                    currentY = nextY;
                }
            }

            this.positionController.setOffset(currentX, currentY, 0);
        };

        navigate();
    }

    /**
     * Move mascot to element with audio-reactive movement
     * @param {string} targetSelector - CSS selector for target element
     * @param {MediaStream} audioStream - Audio stream for analysis
     * @param {number} sensitivity - Audio sensitivity multiplier
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithAudio(targetSelector, audioStream, sensitivity = 50, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        // Initialize audio context if not already done
        if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.audioAnalyser = this.audioContext.createAnalyser();
            this.audioAnalyser.fftSize = 256;
        }

        const source = this.audioContext.createMediaStreamSource(audioStream);
        source.connect(this.audioAnalyser);

        const audioData = new Uint8Array(this.audioAnalyser.frequencyBinCount);
        const rect = element.getBoundingClientRect();
        const baseX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const baseY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const updatePosition = () => {
            this.audioAnalyser.getByteFrequencyData(audioData);
            
            let sum = 0;
            for (let i = 0; i < audioData.length; i++) {
                sum += audioData[i];
            }
            const averageLevel = (sum / audioData.length) / 255;
            
            const audioOffset = averageLevel * sensitivity;
            const currentX = baseX + audioOffset;
            const currentY = baseY + (audioOffset * 0.5);
            
            this.positionController.setOffset(currentX, currentY, 0);
            requestAnimationFrame(updatePosition);
        };

        updatePosition();
    }

    /**
     * Move mascot to element following user's gaze
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} gazeOptions - Gaze tracking options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithGaze(targetSelector, gazeOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        // Initialize gaze tracker if not already done
        if (!this.gazeTracker) {
            this.gazeTracker = {
                x: window.innerWidth / 2,
                y: window.innerHeight / 2
            };
        }

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const updatePosition = () => {
            // Simulate gaze tracking (replace with actual gaze tracking implementation)
            const gazeX = this.gazeTracker.x - window.innerWidth / 2;
            const gazeY = this.gazeTracker.y - window.innerHeight / 2;
            
            // Interpolate between gaze position and target
            const gazeWeight = gazeOptions.gazeWeight || 0.3;
            const currentX = targetX + (gazeX - targetX) * gazeWeight;
            const currentY = targetY + (gazeY - targetY) * gazeWeight;
            
            this.positionController.setOffset(currentX, currentY, 0);
            requestAnimationFrame(updatePosition);
        };

        updatePosition();
    }

    /**
     * Add obstacle for collision detection
     * @param {string|Object} obstacle - Obstacle selector or position object
     */
    addObstacle(obstacle) {
        this.obstacles.add(obstacle);
    }

    /**
     * Remove obstacle from collision detection
     * @param {string|Object} obstacle - Obstacle to remove
     */
    removeObstacle(obstacle) {
        this.obstacles.delete(obstacle);
    }

    /**
     * Clear all obstacles
     */
    clearObstacles() {
        this.obstacles.clear();
    }

    /**
     * Destroy the advanced targeting system
     */
    destroy() {
        const activePathEntries = Array.from(this.activePaths.values());
        activePathEntries.forEach(entry => {
            if (entry && typeof entry.stop === 'function') {
                entry.stop();
            } else if (entry && entry.frameId) {
                cancelAnimationFrame(entry.frameId);
            }
        });
        this.activePaths.clear();
        this.obstacles.clear();
        
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
        }
        
        this.audioAnalyser = null;
        this.gazeTracker = null;
        
        super.destroy();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Context-Aware Element Targeting
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Context-aware element targeting with scroll, physics, group, responsive, and accessibility features
 * @author Emotive Engine Team
 * @module positioning/elementTargeting/ElementTargetingContext
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides context-aware element targeting that adapts to scroll position, physics  
 * ║ simulation, multiple elements, responsive breakpoints, and accessibility needs.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class ElementTargetingContext extends ElementTargeting {
    constructor(positionController) {
        super(positionController);
        this.scrollCallbacks = new Map();
        this.physicsSimulations = new Map();
        this.responsiveBreakpoints = {
            mobile: 768,
            tablet: 1024,
            desktop: 1200
        };
        this.currentBreakpoint = this.getCurrentBreakpoint();
        this.accessibilityEnabled = false;
    }

    /**
     * Move mascot to element with scroll-based movement
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} scrollOptions - Scroll-based movement options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithScroll(targetSelector, scrollOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const scrollId = `scroll-${Date.now()}-${Math.random()}`;
        const {
            startScroll = 50,
            endScroll = 300,
            onProgress = null,
            onStart = null,
            onComplete = null
        } = scrollOptions;

        let hasStarted = false;
        let hasCompleted = false;

        const handleScroll = () => {
            const {scrollY} = window;
            const progress = Math.min(Math.max((scrollY - startScroll) / (endScroll - startScroll), 0), 1);

            if (progress > 0 && !hasStarted) {
                hasStarted = true;
                if (onStart) onStart();
            }

            if (progress >= 1 && !hasCompleted) {
                hasCompleted = true;
                if (onComplete) onComplete();
            }

            // Update position based on scroll progress
            const rect = element.getBoundingClientRect();
            const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
            const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

            // Get original position (when scroll is 0)
            const isDesktop = window.innerWidth > 1024;
            const mascotRadius = 50;
            const originalX = isDesktop ? (window.innerWidth * 0.25) : (window.innerWidth * 0.33) - mascotRadius;
            const originalY = isDesktop ? -(window.innerHeight * 0.25) - mascotRadius + (window.innerHeight * 0.15) : -(window.innerHeight * 0.35) - mascotRadius + (window.innerHeight * 0.08);

            // Interpolate between original and target positions
            const currentX = originalX + (targetX - originalX) * progress;
            const currentY = originalY + (targetY - originalY) * progress;

            this.positionController.setOffset(currentX, currentY, 0);

            if (onProgress) {
                onProgress(progress, { scrollY, currentX, currentY });
            }
        };

        this.scrollCallbacks.set(scrollId, handleScroll);
        window.addEventListener('scroll', handleScroll);
        handleScroll(); // Initial call

        return () => {
            this.scrollCallbacks.delete(scrollId);
            window.removeEventListener('scroll', handleScroll);
        };
    }

    /**
     * Move mascot to element with physics-based movement
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} physicsOptions - Physics simulation options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithPhysics(targetSelector, physicsOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const physicsId = `physics-${Date.now()}-${Math.random()}`;
        const {
            mass = 1,
            damping = 0.98,
            springConstant = 0.1,
            maxVelocity = 10,
            onUpdate = null
        } = physicsOptions;

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const currentOffset = this.positionController.getOffset();
        let positionX = currentOffset.x;
        let positionY = currentOffset.y;
        let velocityX = 0;
        let velocityY = 0;

        const simulate = () => {
            // Calculate spring force
            const forceX = (targetX - positionX) * springConstant;
            const forceY = (targetY - positionY) * springConstant;

            // Apply force to velocity
            velocityX += forceX / mass;
            velocityY += forceY / mass;

            // Apply damping
            velocityX *= damping;
            velocityY *= damping;

            // Limit velocity
            const velocityMagnitude = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
            if (velocityMagnitude > maxVelocity) {
                velocityX = (velocityX / velocityMagnitude) * maxVelocity;
                velocityY = (velocityY / velocityMagnitude) * maxVelocity;
            }

            // Update position
            positionX += velocityX;
            positionY += velocityY;

            this.positionController.setOffset(positionX, positionY, 0);

            if (onUpdate) {
                onUpdate({ positionX, positionY, velocityX, velocityY });
            }

            // Continue simulation
            if (this.physicsSimulations.has(physicsId)) {
                requestAnimationFrame(simulate);
            }
        };

        this.physicsSimulations.set(physicsId, simulate);
        simulate();

        return () => {
            this.physicsSimulations.delete(physicsId);
        };
    }

    /**
     * Move mascot to center of multiple elements
     * @param {Array} elementSelectors - Array of CSS selectors
     * @param {string} position - Position relative to group center
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithGroup(elementSelectors = [], position = 'center', offset = { x: 0, y: 0 }) {
        if (elementSelectors.length === 0) {
            console.warn('No element selectors provided');
            return;
        }

        let groupX = 0, groupY = 0, groupWidth = 0, groupHeight = 0;
        let validElements = 0;

        elementSelectors.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                const rect = element.getBoundingClientRect();
                groupX += rect.left;
                groupY += rect.top;
                groupWidth = Math.max(groupWidth, rect.left + rect.width);
                groupHeight = Math.max(groupHeight, rect.top + rect.height);
                validElements++;
            }
        });

        if (validElements === 0) return;

        // Calculate group center
        const centerX = groupX / validElements;
        const centerY = groupY / validElements;

        let targetX, targetY;

        switch (position) {
        case 'center':
            targetX = centerX + offset.x - window.innerWidth / 2;
            targetY = centerY + offset.y - window.innerHeight / 2;
            break;
        case 'left':
            targetX = groupX + offset.x - window.innerWidth / 2;
            targetY = centerY + offset.y - window.innerHeight / 2;
            break;
        case 'right':
            targetX = groupWidth + offset.x - window.innerWidth / 2;
            targetY = centerY + offset.y - window.innerHeight / 2;
            break;
        case 'top':
            targetX = centerX + offset.x - window.innerWidth / 2;
            targetY = groupY + offset.y - window.innerHeight / 2;
            break;
        case 'bottom':
            targetX = centerX + offset.x - window.innerWidth / 2;
            targetY = groupHeight + offset.y - window.innerHeight / 2;
            break;
        default:
            targetX = centerX + offset.x - window.innerWidth / 2;
            targetY = centerY + offset.y - window.innerHeight / 2;
        }

        this.positionController.setOffset(targetX, targetY, 0);
    }

    /**
     * Move mascot to element with responsive behavior
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} responsiveOptions - Responsive behavior options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithResponsive(targetSelector, responsiveOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const updateResponsivePosition = () => {
            const currentBreakpoint = this.getCurrentBreakpoint();
            const breakpointOptions = responsiveOptions[currentBreakpoint] || responsiveOptions.default || {};
            
            const rect = element.getBoundingClientRect();
            const targetX = rect.left + rect.width / 2 + (breakpointOptions.offsetX || offset.x) - window.innerWidth / 2;
            const targetY = rect.top + rect.height / 2 + (breakpointOptions.offsetY || offset.y) - window.innerHeight / 2;

            this.positionController.setOffset(targetX, targetY, 0);
        };

        // Listen for resize events
        const handleResize = () => {
            const newBreakpoint = this.getCurrentBreakpoint();
            if (newBreakpoint !== this.currentBreakpoint) {
                this.currentBreakpoint = newBreakpoint;
                updateResponsivePosition();
            }
        };

        window.addEventListener('resize', handleResize);
        updateResponsivePosition();

        return () => {
            window.removeEventListener('resize', handleResize);
        };
    }

    /**
     * Move mascot to element with accessibility features
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} accessibilityOptions - Accessibility options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithAccessibility(targetSelector, accessibilityOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const {
            announce = true,
            announcements = [],
            screenReaderPosition = 'bottom-right'
        } = accessibilityOptions;

        // Position mascot in accessibility-friendly location
        let targetX, targetY;

        switch (screenReaderPosition) {
        case 'bottom-right':
            targetX = window.innerWidth - 100 - window.innerWidth / 2;
            targetY = window.innerHeight - 100 - window.innerHeight / 2;
            break;
        case 'bottom-left':
            targetX = 100 - window.innerWidth / 2;
            targetY = window.innerHeight - 100 - window.innerHeight / 2;
            break;
        case 'top-right':
            targetX = window.innerWidth - 100 - window.innerWidth / 2;
            targetY = 100 - window.innerHeight / 2;
            break;
        case 'top-left':
            targetX = 100 - window.innerWidth / 2;
            targetY = 100 - window.innerHeight / 2;
            break;
        default:
            targetX = window.innerWidth - 100 - window.innerWidth / 2;
            targetY = window.innerHeight - 100 - window.innerHeight / 2;
        }

        this.positionController.setOffset(targetX, targetY, 0);

        // Announce to screen reader
        if (announce && window.speechSynthesis) {
            announcements.forEach(announcement => {
                if (announcement.condition && announcement.condition()) {
                    const utterance = new SpeechSynthesisUtterance(announcement.text);
                    utterance.volume = 0.5;
                    utterance.rate = 0.8;
                    window.speechSynthesis.speak(utterance);
                }
            });
        }
    }

    /**
     * Get current breakpoint based on window width
     * @returns {string} Current breakpoint name
     */
    getCurrentBreakpoint() {
        const width = window.innerWidth;
        if (width < this.responsiveBreakpoints.mobile) return 'mobile';
        if (width < this.responsiveBreakpoints.tablet) return 'tablet';
        if (width < this.responsiveBreakpoints.desktop) return 'desktop';
        return 'large';
    }

    /**
     * Set custom breakpoints
     * @param {Object} breakpoints - Custom breakpoint values
     */
    setBreakpoints(breakpoints) {
        this.responsiveBreakpoints = { ...this.responsiveBreakpoints, ...breakpoints };
        this.currentBreakpoint = this.getCurrentBreakpoint();
    }

    /**
     * Enable accessibility features
     */
    enableAccessibility() {
        this.accessibilityEnabled = true;
    }

    /**
     * Disable accessibility features
     */
    disableAccessibility() {
        this.accessibilityEnabled = false;
    }

    /**
     * Destroy the context-aware targeting system
     */
    destroy() {
        this.scrollCallbacks.forEach((callback, id) => {
            window.removeEventListener('scroll', callback);
        });
        this.scrollCallbacks.clear();
        
        this.physicsSimulations.clear();
        
        super.destroy();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Element Targeting Interactions
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Element targeting with mouse and touch interaction capabilities
 * @author Emotive Engine Team
 * @module positioning/elementTargeting/ElementTargetingInteractions
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides element targeting with interactive capabilities including mouse hover,    
 * ║ click tracking, touch gestures, and element interaction detection.                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class ElementTargetingInteractions extends ElementTargeting {
    constructor(positionController) {
        super(positionController);
        this.activeInteractions = new Map();
        this.hoverStates = new Map();
        this.clickStates = new Map();
        this.touchStates = new Map();
    }

    /**
     * Move mascot to element and follow mouse hover
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} hoverOptions - Hover interaction options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithHover(targetSelector, hoverOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const interactionId = `hover-${Date.now()}-${Math.random()}`;
        const {
            onMouseEnter = null,
            onMouseLeave = null,
            onHover = null,
            followMouse = false,
            hoverDistance = 50
        } = hoverOptions;

        let isHovering = false;
        let mouseX = 0;
        let mouseY = 0;

        const handleMouseEnter = event => {
            isHovering = true;
            if (onMouseEnter) onMouseEnter(event);
        };

        const handleMouseLeave = event => {
            isHovering = false;
            if (onMouseLeave) onMouseLeave(event);
        };

        const handleMouseMove = event => {
            mouseX = event.clientX;
            mouseY = event.clientY;

            if (isHovering && onHover) {
                onHover(event);
            }

            if (followMouse && isHovering) {
                const rect = element.getBoundingClientRect();
                const elementCenterX = rect.left + rect.width / 2;
                const elementCenterY = rect.top + rect.height / 2;

                const distance = Math.sqrt(
                    Math.pow(mouseX - elementCenterX, 2) + 
                    Math.pow(mouseY - elementCenterY, 2)
                );

                if (distance <= hoverDistance) {
                    const targetX = mouseX + offset.x - window.innerWidth / 2;
                    const targetY = mouseY + offset.y - window.innerHeight / 2;
                    this.positionController.setOffset(targetX, targetY, 0);
                }
            }
        };

        element.addEventListener('mouseenter', handleMouseEnter);
        element.addEventListener('mouseleave', handleMouseLeave);
        element.addEventListener('mousemove', handleMouseMove);

        this.activeInteractions.set(interactionId, {
            element,
            events: [
                { event: 'mouseenter', handler: handleMouseEnter },
                { event: 'mouseleave', handler: handleMouseLeave },
                { event: 'mousemove', handler: handleMouseMove }
            ]
        });

        return () => {
            const interaction = this.activeInteractions.get(interactionId);
            if (interaction) {
                interaction.events.forEach(({ event, handler }) => {
                    interaction.element.removeEventListener(event, handler);
                });
                this.activeInteractions.delete(interactionId);
            }
        };
    }

    /**
     * Move mascot to element and track clicks
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} clickOptions - Click interaction options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithClick(targetSelector, clickOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const interactionId = `click-${Date.now()}-${Math.random()}`;
        const {
            onClick = null,
            onDoubleClick = null,
            maxClicks = 3
        } = clickOptions;

        let clickCount_current = 0;

        const handleClick = event => {
            clickCount_current++;
            if (onClick) onClick(event, clickCount_current);

            if (clickCount_current >= maxClicks) {
                // Move mascot to clicked element
                const rect = element.getBoundingClientRect();
                const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
                const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;
                this.positionController.setOffset(targetX, targetY, 0);
            }
        };

        const handleDoubleClick = event => {
            if (onDoubleClick) onDoubleClick(event);
        };

        element.addEventListener('click', handleClick);
        element.addEventListener('dblclick', handleDoubleClick);

        this.activeInteractions.set(interactionId, {
            element,
            events: [
                { event: 'click', handler: handleClick },
                { event: 'dblclick', handler: handleDoubleClick }
            ]
        });

        return () => {
            const interaction = this.activeInteractions.get(interactionId);
            if (interaction) {
                interaction.events.forEach(({ event, handler }) => {
                    interaction.element.removeEventListener(event, handler);
                });
                this.activeInteractions.delete(interactionId);
            }
        };
    }

    /**
     * Move mascot to element and track touch gestures
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} touchOptions - Touch interaction options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithTouch(targetSelector, touchOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const interactionId = `touch-${Date.now()}-${Math.random()}`;
        const {
            onTouchStart = null,
            onTouchMove = null,
            onTouchEnd = null,
            onSwipe = null,
            swipeThreshold = 50
        } = touchOptions;

        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        const handleTouchStart = event => {
            if (event.touches.length > 0) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                if (onTouchStart) onTouchStart(event);
            }
        };

        const handleTouchMove = event => {
            if (event.touches.length > 0) {
                const touchX = event.touches[0].clientX;
                const touchY = event.touches[0].clientY;
                if (onTouchMove) onTouchMove(event);

                // Move mascot to follow touch
                const targetX = touchX + offset.x - window.innerWidth / 2;
                const targetY = touchY + offset.y - window.innerHeight / 2;
                this.positionController.setOffset(targetX, targetY, 0);
            }
        };

        const handleTouchEnd = event => {
            if (event.changedTouches.length > 0) {
                touchEndX = event.changedTouches[0].clientX;
                touchEndY = event.changedTouches[0].clientY;
                if (onTouchEnd) onTouchEnd(event);

                // Detect swipe
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                if (distance > swipeThreshold && onSwipe) {
                    const direction = Math.abs(deltaX) > Math.abs(deltaY) 
                        ? (deltaX > 0 ? 'right' : 'left')
                        : (deltaY > 0 ? 'down' : 'up');
                    onSwipe(direction, distance);
                }
            }
        };

        element.addEventListener('touchstart', handleTouchStart);
        element.addEventListener('touchmove', handleTouchMove);
        element.addEventListener('touchend', handleTouchEnd);

        this.activeInteractions.set(interactionId, {
            element,
            events: [
                { event: 'touchstart', handler: handleTouchStart },
                { event: 'touchmove', handler: handleTouchMove },
                { event: 'touchend', handler: handleTouchEnd }
            ]
        });

        return () => {
            const interaction = this.activeInteractions.get(interactionId);
            if (interaction) {
                interaction.events.forEach(({ event, handler }) => {
                    interaction.element.removeEventListener(event, handler);
                });
                this.activeInteractions.delete(interactionId);
            }
        };
    }

    /**
     * Move mascot to element and track focus events
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} focusOptions - Focus interaction options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithFocus(targetSelector, focusOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const interactionId = `focus-${Date.now()}-${Math.random()}`;
        const {
            onFocus = null,
            onBlur = null,
            onFocusIn = null,
            onFocusOut = null
        } = focusOptions;

        const handleFocus = event => {
            if (onFocus) onFocus(event);
            
            // Move mascot to focused element
            const rect = element.getBoundingClientRect();
            const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
            const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;
            this.positionController.setOffset(targetX, targetY, 0);
        };

        const handleBlur = event => {
            if (onBlur) onBlur(event);
        };

        const handleFocusIn = event => {
            if (onFocusIn) onFocusIn(event);
        };

        const handleFocusOut = event => {
            if (onFocusOut) onFocusOut(event);
        };

        element.addEventListener('focus', handleFocus);
        element.addEventListener('blur', handleBlur);
        element.addEventListener('focusin', handleFocusIn);
        element.addEventListener('focusout', handleFocusOut);

        this.activeInteractions.set(interactionId, {
            element,
            events: [
                { event: 'focus', handler: handleFocus },
                { event: 'blur', handler: handleBlur },
                { event: 'focusin', handler: handleFocusIn },
                { event: 'focusout', handler: handleFocusOut }
            ]
        });

        return () => {
            const interaction = this.activeInteractions.get(interactionId);
            if (interaction) {
                interaction.events.forEach(({ event, handler }) => {
                    interaction.element.removeEventListener(event, handler);
                });
                this.activeInteractions.delete(interactionId);
            }
        };
    }

    /**
     * Move mascot to element and track keyboard events
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} keyboardOptions - Keyboard interaction options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithKeyboard(targetSelector, keyboardOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const interactionId = `keyboard-${Date.now()}-${Math.random()}`;
        const {
            onKeyDown = null,
            onKeyUp = null,
            onKeyPress = null,
            targetKeys = ['Enter', 'Space']
        } = keyboardOptions;

        const handleKeyDown = event => {
            if (onKeyDown) onKeyDown(event);

            if (targetKeys.includes(event.key)) {
                // Move mascot to element when target key is pressed
                const rect = element.getBoundingClientRect();
                const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
                const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;
                this.positionController.setOffset(targetX, targetY, 0);
            }
        };

        const handleKeyUp = event => {
            if (onKeyUp) onKeyUp(event);
        };

        const handleKeyPress = event => {
            if (onKeyPress) onKeyPress(event);
        };

        element.addEventListener('keydown', handleKeyDown);
        element.addEventListener('keyup', handleKeyUp);
        element.addEventListener('keypress', handleKeyPress);

        this.activeInteractions.set(interactionId, {
            element,
            events: [
                { event: 'keydown', handler: handleKeyDown },
                { event: 'keyup', handler: handleKeyUp },
                { event: 'keypress', handler: handleKeyPress }
            ]
        });

        return () => {
            const interaction = this.activeInteractions.get(interactionId);
            if (interaction) {
                interaction.events.forEach(({ event, handler }) => {
                    interaction.element.removeEventListener(event, handler);
                });
                this.activeInteractions.delete(interactionId);
            }
        };
    }

    /**
     * Stop all active interactions
     */
    stopAllInteractions() {
        this.activeInteractions.forEach((interaction, id) => {
            interaction.events.forEach(({ event, handler }) => {
                interaction.element.removeEventListener(event, handler);
            });
            this.activeInteractions.delete(id);
        });
        this.hoverStates.clear();
        this.clickStates.clear();
        this.touchStates.clear();
    }

    /**
     * Destroy the interaction system
     */
    destroy() {
        this.stopAllInteractions();
        super.destroy();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Element Targeting Animations
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Element targeting with animation capabilities for mascot movement
 * @author Emotive Engine Team
 * @module positioning/elementTargeting/ElementTargetingAnimations
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides element targeting with animation capabilities including bounce, shake,    
 * ║ pulse, wiggle, and custom animation effects for mascot movement.                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class ElementTargetingAnimations extends ElementTargeting {
    constructor(positionController) {
        super(positionController);
        this.activeAnimations = new Map();
        this.animationQueue = [];
        this.isAnimating = false;
    }

    /**
     * Move mascot to element with bounce animation
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} bounceOptions - Bounce animation options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithBounce(targetSelector, bounceOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const animationId = `bounce-${Date.now()}-${Math.random()}`;
        const {
            duration = 1000,
            intensity = 50,
            bounces = 3,
            onComplete = null
        } = bounceOptions;

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const startOffset = this.positionController.getOffset();
        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Bounce easing function
            const bounceProgress = 1 - Math.pow(1 - progress, 3);
            const bounceOffset = Math.sin(bounceProgress * Math.PI * bounces) * intensity * (1 - progress);

            const currentX = startOffset.x + (targetX - startOffset.x) * progress;
            const currentY = startOffset.y + (targetY - startOffset.y) * progress + bounceOffset;

            this.positionController.setOffset(currentX, currentY, 0);

            if (progress < 1) {
                this.activeAnimations.set(animationId, animate);
                requestAnimationFrame(animate);
            } else {
                this.activeAnimations.delete(animationId);
                if (onComplete) onComplete();
            }
        };

        this.activeAnimations.set(animationId, animate);
        requestAnimationFrame(animate);

        return () => {
            this.activeAnimations.delete(animationId);
        };
    }

    /**
     * Move mascot to element with shake animation
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} shakeOptions - Shake animation options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithShake(targetSelector, shakeOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const animationId = `shake-${Date.now()}-${Math.random()}`;
        const {
            duration = 500,
            intensity = 10,
            frequency = 20,
            onComplete = null
        } = shakeOptions;

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Shake effect
            const shakeX = (Math.random() - 0.5) * intensity * (1 - progress);
            const shakeY = (Math.random() - 0.5) * intensity * (1 - progress);

            const currentX = targetX + shakeX;
            const currentY = targetY + shakeY;

            this.positionController.setOffset(currentX, currentY, 0);

            if (progress < 1) {
                this.activeAnimations.set(animationId, animate);
                setTimeout(() => requestAnimationFrame(animate), 1000 / frequency);
            } else {
                this.activeAnimations.delete(animationId);
                if (onComplete) onComplete();
            }
        };

        this.activeAnimations.set(animationId, animate);
        requestAnimationFrame(animate);

        return () => {
            this.activeAnimations.delete(animationId);
        };
    }

    /**
     * Move mascot to element with pulse animation
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} pulseOptions - Pulse animation options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithPulse(targetSelector, pulseOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const animationId = `pulse-${Date.now()}-${Math.random()}`;
        const {
            duration = 2000,
            intensity = 20,
            frequency = 2,
            onComplete = null
        } = pulseOptions;

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Pulse effect
            const pulseScale = Math.sin(elapsed * frequency * 0.01) * intensity * (1 - progress);
            const currentX = targetX + pulseScale;
            const currentY = targetY + pulseScale;

            this.positionController.setOffset(currentX, currentY, 0);

            if (progress < 1) {
                this.activeAnimations.set(animationId, animate);
                requestAnimationFrame(animate);
            } else {
                this.activeAnimations.delete(animationId);
                if (onComplete) onComplete();
            }
        };

        this.activeAnimations.set(animationId, animate);
        requestAnimationFrame(animate);

        return () => {
            this.activeAnimations.delete(animationId);
        };
    }

    /**
     * Move mascot to element with wiggle animation
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} wiggleOptions - Wiggle animation options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithWiggle(targetSelector, wiggleOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const animationId = `wiggle-${Date.now()}-${Math.random()}`;
        const {
            duration = 1000,
            intensity = 15,
            frequency = 8,
            onComplete = null
        } = wiggleOptions;

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Wiggle effect
            const wiggleX = Math.sin(elapsed * frequency * 0.01) * intensity * (1 - progress);
            const wiggleY = Math.cos(elapsed * frequency * 0.01) * intensity * (1 - progress);

            const currentX = targetX + wiggleX;
            const currentY = targetY + wiggleY;

            this.positionController.setOffset(currentX, currentY, 0);

            if (progress < 1) {
                this.activeAnimations.set(animationId, animate);
                requestAnimationFrame(animate);
            } else {
                this.activeAnimations.delete(animationId);
                if (onComplete) onComplete();
            }
        };

        this.activeAnimations.set(animationId, animate);
        requestAnimationFrame(animate);

        return () => {
            this.activeAnimations.delete(animationId);
        };
    }

    /**
     * Move mascot to element with custom animation
     * @param {string} targetSelector - CSS selector for target element
     * @param {Function} animationFunction - Custom animation function
     * @param {Object} animationOptions - Animation options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithCustom(targetSelector, animationFunction, animationOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const animationId = `custom-${Date.now()}-${Math.random()}`;
        const {
            duration = 1000,
            onComplete = null
        } = animationOptions;

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x - window.innerWidth / 2;
        const targetY = rect.top + rect.height / 2 + offset.y - window.innerHeight / 2;

        const startOffset = this.positionController.getOffset();
        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Execute custom animation function
            const animationResult = animationFunction(progress, {
                elapsed,
                startOffset,
                targetX,
                targetY,
                currentTime
            });

            if (animationResult && typeof animationResult === 'object') {
                const currentX = animationResult.x !== undefined ? animationResult.x : targetX;
                const currentY = animationResult.y !== undefined ? animationResult.y : targetY;
                this.positionController.setOffset(currentX, currentY, 0);
            }

            if (progress < 1) {
                this.activeAnimations.set(animationId, animate);
                requestAnimationFrame(animate);
            } else {
                this.activeAnimations.delete(animationId);
                if (onComplete) onComplete();
            }
        };

        this.activeAnimations.set(animationId, animate);
        requestAnimationFrame(animate);

        return () => {
            this.activeAnimations.delete(animationId);
        };
    }

    /**
     * Queue multiple animations to play in sequence
     * @param {Array} animationQueue - Array of animation objects
     */
    queueAnimations(animationQueue = []) {
        this.animationQueue = [...this.animationQueue, ...animationQueue];
        this.processAnimationQueue();
    }

    /**
     * Process the animation queue
     */
    processAnimationQueue() {
        if (this.isAnimating || this.animationQueue.length === 0) return;

        this.isAnimating = true;
        const animation = this.animationQueue.shift();

        if (animation) {
            const cleanup = this.executeAnimation(animation);
            if (cleanup) {
                setTimeout(() => {
                    cleanup();
                    this.isAnimating = false;
                    this.processAnimationQueue();
                }, animation.duration || 1000);
            }
        }
    }

    /**
     * Execute a single animation from the queue
     * @param {Object} animation - Animation object
     * @returns {Function} Cleanup function
     */
    executeAnimation(animation) {
        const { type, targetSelector, options = {}, position = 'right', offset = { x: 20, y: 0 } } = animation;

        switch (type) {
        case 'bounce':
            return this.moveToElementWithBounce(targetSelector, options, position, offset);
        case 'shake':
            return this.moveToElementWithShake(targetSelector, options, position, offset);
        case 'pulse':
            return this.moveToElementWithPulse(targetSelector, options, position, offset);
        case 'wiggle':
            return this.moveToElementWithWiggle(targetSelector, options, position, offset);
        case 'custom':
            return this.moveToElementWithCustom(targetSelector, options.animationFunction, options, position, offset);
        default:
            return this.moveToElement(targetSelector, position, offset);
        }
    }

    /**
     * Stop all active animations
     */
    stopAllAnimations() {
        this.activeAnimations.forEach((animation, id) => {
            this.activeAnimations.delete(id);
        });
        this.animationQueue = [];
        this.isAnimating = false;
    }

    /**
     * Destroy the animation system
     */
    destroy() {
        this.stopAllAnimations();
        super.destroy();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Element Targeting Effects
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Element targeting with visual effects for mascot movement
 * @author Emotive Engine Team
 * @module positioning/elementTargeting/ElementTargetingEffects
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides element targeting with visual effects including trails, particles,       
 * ║ glow effects, and other visual enhancements for mascot movement.                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class ElementTargetingEffects extends ElementTargeting {
    constructor(positionController) {
        super(positionController);
        this.activeEffects = new Map();
        this.trailPoints = [];
        this.particles = [];
        this.effectCanvas = null;
        this.effectContext = null;
        this.maxTrailPoints = 50;
        this.maxParticles = 100;
    }

    /**
     * Move mascot to element with trail effect
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} trailOptions - Trail effect options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithTrail(targetSelector, trailOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const effectId = `trail-${Date.now()}-${Math.random()}`;
        const {
            color = '#00ff88',
            width = 3,
            opacity = 0.8,
            fadeSpeed = 0.95,
            onComplete = null
        } = trailOptions;

        this.initializeEffectCanvas();

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x;
        const targetY = rect.top + rect.height / 2 + offset.y;

        const startOffset = this.positionController.getOffset();
        const startX = startOffset.x + window.innerWidth / 2;
        const startY = startOffset.y + window.innerHeight / 2;

        const startTime = performance.now();
        const duration = 1000;

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Calculate current position
            const currentX = startX + (targetX - startX) * progress;
            const currentY = startY + (targetY - startY) * progress;

            // Add point to trail
            this.trailPoints.push({
                x: currentX,
                y: currentY,
                opacity: opacity * (1 - progress),
                timestamp: currentTime
            });

            // Remove old trail points
            if (this.trailPoints.length > this.maxTrailPoints) {
                this.trailPoints.shift();
            }

            // Fade trail points
            this.trailPoints.forEach(point => {
                point.opacity *= fadeSpeed;
            });

            // Remove faded points
            this.trailPoints = this.trailPoints.filter(point => point.opacity > 0.01);

            // Draw trail
            this.drawTrail(color, width);

            // Update mascot position
            this.positionController.setOffset(currentX - window.innerWidth / 2, currentY - window.innerHeight / 2, 0);

            if (progress < 1) {
                this.activeEffects.set(effectId, animate);
                requestAnimationFrame(animate);
            } else {
                this.activeEffects.delete(effectId);
                if (onComplete) onComplete();
            }
        };

        this.activeEffects.set(effectId, animate);
        requestAnimationFrame(animate);

        return () => {
            this.activeEffects.delete(effectId);
        };
    }

    /**
     * Move mascot to element with particle effect
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} particleOptions - Particle effect options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithParticles(targetSelector, particleOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const effectId = `particles-${Date.now()}-${Math.random()}`;
        const {
            count = 20,
            color = '#00ff88',
            size = 2,
            speed = 2,
            life = 1000,
            onComplete = null
        } = particleOptions;

        this.initializeEffectCanvas();

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x;
        const targetY = rect.top + rect.height / 2 + offset.y;

        const startOffset = this.positionController.getOffset();
        const startX = startOffset.x + window.innerWidth / 2;
        const startY = startOffset.y + window.innerHeight / 2;

        const startTime = performance.now();
        const duration = 1000;

        // Create initial particles
        for (let i = 0; i < count; i++) {
            this.particles.push({
                x: startX,
                y: startY,
                vx: (Math.random() - 0.5) * speed,
                vy: (Math.random() - 0.5) * speed,
                life,
                maxLife: life,
                color,
                size
            });
        }

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Update particles
            this.particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 16; // Assuming 60fps

                // Fade particle
                particle.opacity = particle.life / particle.maxLife;
            });

            // Remove dead particles
            this.particles = this.particles.filter(particle => particle.life > 0);

            // Draw particles
            this.drawParticles();

            // Update mascot position
            const currentX = startX + (targetX - startX) * progress;
            const currentY = startY + (targetY - startY) * progress;
            this.positionController.setOffset(currentX - window.innerWidth / 2, currentY - window.innerHeight / 2, 0);

            if (progress < 1 || this.particles.length > 0) {
                this.activeEffects.set(effectId, animate);
                requestAnimationFrame(animate);
            } else {
                this.activeEffects.delete(effectId);
                if (onComplete) onComplete();
            }
        };

        this.activeEffects.set(effectId, animate);
        requestAnimationFrame(animate);

        return () => {
            this.activeEffects.delete(effectId);
        };
    }

    /**
     * Move mascot to element with glow effect
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} glowOptions - Glow effect options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithGlow(targetSelector, glowOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const effectId = `glow-${Date.now()}-${Math.random()}`;
        const {
            color = '#00ff88',
            intensity = 50,
            radius = 100,
            duration = 1000,
            onComplete = null
        } = glowOptions;

        this.initializeEffectCanvas();

        const rect = element.getBoundingClientRect();
        const targetX = rect.left + rect.width / 2 + offset.x;
        const targetY = rect.top + rect.height / 2 + offset.y;

        const startOffset = this.positionController.getOffset();
        const startX = startOffset.x + window.innerWidth / 2;
        const startY = startOffset.y + window.innerHeight / 2;

        const startTime = performance.now();

        const animate = currentTime => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Calculate current position
            const currentX = startX + (targetX - startX) * progress;
            const currentY = startY + (targetY - startY) * progress;

            // Draw glow effect
            this.drawGlow(currentX, currentY, color, intensity, radius, progress);

            // Update mascot position
            this.positionController.setOffset(currentX - window.innerWidth / 2, currentY - window.innerHeight / 2, 0);

            if (progress < 1) {
                this.activeEffects.set(effectId, animate);
                requestAnimationFrame(animate);
            } else {
                this.activeEffects.delete(effectId);
                if (onComplete) onComplete();
            }
        };

        this.activeEffects.set(effectId, animate);
        requestAnimationFrame(animate);

        return () => {
            this.activeEffects.delete(effectId);
        };
    }

    /**
     * Initialize the effect canvas
     */
    initializeEffectCanvas() {
        if (!this.effectCanvas) {
            this.effectCanvas = document.createElement('canvas');
            this.effectCanvas.style.position = 'fixed';
            this.effectCanvas.style.top = '0';
            this.effectCanvas.style.left = '0';
            this.effectCanvas.style.width = '100%';
            this.effectCanvas.style.height = '100%';
            this.effectCanvas.style.pointerEvents = 'none';
            this.effectCanvas.style.zIndex = '1000';
            document.body.appendChild(this.effectCanvas);

            this.effectContext = this.effectCanvas.getContext('2d');
            this.resizeEffectCanvas();
        }
    }

    /**
     * Resize the effect canvas
     */
    resizeEffectCanvas() {
        if (this.effectCanvas) {
            this.effectCanvas.width = window.innerWidth;
            this.effectCanvas.height = window.innerHeight;
        }
    }

    /**
     * Draw trail effect
     * @param {string} color - Trail color
     * @param {number} width - Trail width
     */
    drawTrail(color, width) {
        if (!this.effectContext || this.trailPoints.length < 2) return;

        this.effectContext.clearRect(0, 0, this.effectCanvas.width, this.effectCanvas.height);

        this.effectContext.strokeStyle = color;
        this.effectContext.lineWidth = width;
        this.effectContext.lineCap = 'round';
        this.effectContext.lineJoin = 'round';

        this.effectContext.beginPath();
        this.effectContext.moveTo(this.trailPoints[0].x, this.trailPoints[0].y);

        for (let i = 1; i < this.trailPoints.length; i++) {
            const point = this.trailPoints[i];
            this.effectContext.globalAlpha = point.opacity;
            this.effectContext.lineTo(point.x, point.y);
        }

        this.effectContext.stroke();
        this.effectContext.globalAlpha = 1;
    }

    /**
     * Draw particles
     */
    drawParticles() {
        if (!this.effectContext) return;

        this.effectContext.clearRect(0, 0, this.effectCanvas.width, this.effectCanvas.height);

        this.particles.forEach(particle => {
            this.effectContext.globalAlpha = particle.opacity;
            this.effectContext.fillStyle = particle.color;
            this.effectContext.beginPath();
            this.effectContext.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.effectContext.fill();
        });

        this.effectContext.globalAlpha = 1;
    }

    /**
     * Draw glow effect
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} color - Glow color
     * @param {number} intensity - Glow intensity
     * @param {number} radius - Glow radius
     * @param {number} progress - Animation progress
     */
    drawGlow(x, y, color, intensity, radius, progress) {
        if (!this.effectContext) return;

        this.effectContext.clearRect(0, 0, this.effectCanvas.width, this.effectCanvas.height);

        const gradient = this.effectContext.createRadialGradient(x, y, 0, x, y, radius);
        // Ensure color is valid hex format and add alpha channel
        const alpha = Math.floor(intensity * progress).toString(16).padStart(2, '0');
        const validColor = color.startsWith('#') ? color : `#${color}`;
        
        gradient.addColorStop(0, `${validColor}${alpha}`);
        gradient.addColorStop(1, `${validColor}00`);

        this.effectContext.fillStyle = gradient;
        this.effectContext.beginPath();
        this.effectContext.arc(x, y, radius, 0, Math.PI * 2);
        this.effectContext.fill();
    }

    /**
     * Stop all active effects
     */
    stopAllEffects() {
        this.activeEffects.forEach((effect, id) => {
            this.activeEffects.delete(id);
        });
        this.trailPoints = [];
        this.particles = [];
    }

    /**
     * Destroy the effect system
     */
    destroy() {
        this.stopAllEffects();
        
        if (this.effectCanvas) {
            document.body.removeChild(this.effectCanvas);
            this.effectCanvas = null;
            this.effectContext = null;
        }
        
        super.destroy();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Element Targeting Accessibility
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Element targeting with accessibility features for mascot movement
 * @author Emotive Engine Team
 * @module positioning/elementTargeting/ElementTargetingAccessibility
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides element targeting with accessibility features including screen reader      
 * ║ support, keyboard navigation, high contrast mode, and reduced motion support.      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class ElementTargetingAccessibility extends ElementTargeting {
    constructor(positionController) {
        super(positionController);
        this.accessibilityOptions = {
            screenReader: true,
            keyboardNavigation: true,
            highContrast: false,
            reducedMotion: false,
            announcements: true
        };
        this.announcements = [];
        this.keyboardListeners = new Map();
        this.focusableElements = new Set();
        this.currentFocusIndex = 0;
        this.focusOrder = [];
    }

    /**
     * Move mascot to element with screen reader support
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} screenReaderOptions - Screen reader options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithScreenReader(targetSelector, screenReaderOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const {
            announce = true,
            announcement = 'Mascot moved to element',
            role = 'button',
            label = element.textContent || element.alt || 'Interactive element'
        } = screenReaderOptions;

        // Move mascot to element
        this.moveToElement(targetSelector, position, offset);

        // Announce to screen reader
        if (announce && this.accessibilityOptions.screenReader) {
            this.announceToScreenReader(announcement);
        }

        // Set ARIA attributes
        if (element) {
            element.setAttribute('role', role);
            element.setAttribute('aria-label', label);
            element.setAttribute('aria-live', 'polite');
        }
    }

    /**
     * Move mascot to element with keyboard navigation
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} keyboardOptions - Keyboard navigation options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithKeyboard(targetSelector, keyboardOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const {
            onKeyDown = null,
            onKeyUp = null,
            onEnter = null,
            onEscape = null,
            onArrowKeys = null
        } = keyboardOptions;

        const keyboardId = `keyboard-${Date.now()}-${Math.random()}`;

        const handleKeyDown = event => {
            if (onKeyDown) onKeyDown(event);

            switch (event.key) {
            case 'Enter':
            case ' ':
                if (onEnter) onEnter(event);
                break;
            case 'Escape':
                if (onEscape) onEscape(event);
                break;
            case 'ArrowUp':
            case 'ArrowDown':
            case 'ArrowLeft':
            case 'ArrowRight':
                if (onArrowKeys) onArrowKeys(event);
                break;
            }
        };

        const handleKeyUp = event => {
            if (onKeyUp) onKeyUp(event);
        };

        // Make element focusable
        if (!element.hasAttribute('tabindex')) {
            element.setAttribute('tabindex', '0');
        }

        // Add keyboard listeners
        element.addEventListener('keydown', handleKeyDown);
        element.addEventListener('keyup', handleKeyUp);

        this.keyboardListeners.set(keyboardId, {
            element,
            events: [
                { event: 'keydown', handler: handleKeyDown },
                { event: 'keyup', handler: handleKeyUp }
            ]
        });

        // Move mascot to element
        this.moveToElement(targetSelector, position, offset);

        return () => {
            const listener = this.keyboardListeners.get(keyboardId);
            if (listener) {
                listener.events.forEach(({ event, handler }) => {
                    listener.element.removeEventListener(event, handler);
                });
                this.keyboardListeners.delete(keyboardId);
            }
        };
    }

    /**
     * Move mascot to element with high contrast mode
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} contrastOptions - High contrast options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithHighContrast(targetSelector, contrastOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const {
            backgroundColor = '#000000',
            textColor = '#ffffff',
            borderColor = '#ffffff',
            borderWidth = 2
        } = contrastOptions;

        // Apply high contrast styles
        if (this.accessibilityOptions.highContrast) {
            element.style.backgroundColor = backgroundColor;
            element.style.color = textColor;
            element.style.border = `${borderWidth}px solid ${borderColor}`;
            element.style.outline = `${borderWidth}px solid ${borderColor}`;
        }

        // Move mascot to element
        this.moveToElement(targetSelector, position, offset);
    }

    /**
     * Move mascot to element with reduced motion support
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} motionOptions - Reduced motion options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithReducedMotion(targetSelector, motionOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const {
            duration = 0,
            easing = 'linear'
        } = motionOptions;

        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        if (prefersReducedMotion || this.accessibilityOptions.reducedMotion) {
            // Instant movement without animation
            this.moveToElement(targetSelector, position, offset);
        } else {
            // Normal movement with animation
            this.moveToElement(targetSelector, position, offset, { duration, easing });
        }
    }

    /**
     * Move mascot to element with focus management
     * @param {string} targetSelector - CSS selector for target element
     * @param {Object} focusOptions - Focus management options
     * @param {string} position - Position relative to element
     * @param {Object} offset - Pixel offset
     */
    moveToElementWithFocus(targetSelector, focusOptions = {}, position = 'right', offset = { x: 20, y: 0 }) {
        const element = document.querySelector(targetSelector);
        if (!element) {
            console.warn(`Element not found: ${targetSelector}`);
            return;
        }

        const {
            autoFocus = false,
            focusRing = true,
            focusOrder = []
        } = focusOptions;

        // Add to focus order
        if (focusOrder.length > 0) {
            this.focusOrder = focusOrder;
        } else if (!this.focusOrder.includes(targetSelector)) {
            this.focusOrder.push(targetSelector);
        }

        // Make element focusable
        if (!element.hasAttribute('tabindex')) {
            element.setAttribute('tabindex', '0');
        }

        // Apply focus ring styles
        if (focusRing) {
            element.style.outline = '2px solid #0066cc';
            element.style.outlineOffset = '2px';
        }

        // Auto focus if requested
        if (autoFocus) {
            element.focus();
        }

        // Move mascot to element
        this.moveToElement(targetSelector, position, offset);
    }

    /**
     * Navigate focus order
     * @param {string} direction - 'next' or 'previous'
     */
    navigateFocus(direction = 'next') {
        if (this.focusOrder.length === 0) return;

        if (direction === 'next') {
            this.currentFocusIndex = (this.currentFocusIndex + 1) % this.focusOrder.length;
        } else {
            this.currentFocusIndex = (this.currentFocusIndex - 1 + this.focusOrder.length) % this.focusOrder.length;
        }

        const targetSelector = this.focusOrder[this.currentFocusIndex];
        const element = document.querySelector(targetSelector);
        
        if (element) {
            element.focus();
            this.moveToElement(targetSelector, 'right', { x: 20, y: 0 });
        }
    }

    /**
     * Announce message to screen reader
     * @param {string} message - Message to announce
     */
    announceToScreenReader(message) {
        if (!this.accessibilityOptions.announcements) return;

        // Create or update live region
        let liveRegion = document.getElementById('mascot-live-region');
        if (!liveRegion) {
            liveRegion = document.createElement('div');
            liveRegion.id = 'mascot-live-region';
            liveRegion.setAttribute('aria-live', 'polite');
            liveRegion.setAttribute('aria-atomic', 'true');
            liveRegion.style.position = 'absolute';
            liveRegion.style.left = '-10000px';
            liveRegion.style.width = '1px';
            liveRegion.style.height = '1px';
            liveRegion.style.overflow = 'hidden';
            document.body.appendChild(liveRegion);
        }

        // Announce message
        liveRegion.textContent = message;
        
        // Clear after announcement
        setTimeout(() => {
            liveRegion.textContent = '';
        }, 1000);
    }

    /**
     * Enable accessibility features
     * @param {Object} options - Accessibility options to enable
     */
    enableAccessibility(options = {}) {
        this.accessibilityOptions = { ...this.accessibilityOptions, ...options };
    }

    /**
     * Disable accessibility features
     * @param {Object} options - Accessibility options to disable
     */
    disableAccessibility(options = {}) {
        Object.keys(options).forEach(key => {
            if (Object.prototype.hasOwnProperty.call(this.accessibilityOptions, key)) {
                this.accessibilityOptions[key] = false;
            }
        });
    }

    /**
     * Check if accessibility feature is enabled
     * @param {string} feature - Feature name
     * @returns {boolean} True if feature is enabled
     */
    isAccessibilityEnabled(feature) {
        return this.accessibilityOptions[feature] || false;
    }

    /**
     * Get current accessibility options
     * @returns {Object} Current accessibility options
     */
    getAccessibilityOptions() {
        return { ...this.accessibilityOptions };
    }

    /**
     * Destroy the accessibility system
     */
    destroy() {
        // Remove keyboard listeners
        this.keyboardListeners.forEach((listener, id) => {
            listener.events.forEach(({ event, handler }) => {
                listener.element.removeEventListener(event, handler);
            });
        });
        this.keyboardListeners.clear();

        // Remove live region
        const liveRegion = document.getElementById('mascot-live-region');
        if (liveRegion) {
            document.body.removeChild(liveRegion);
        }

        // Clear focus order
        this.focusOrder = [];
        this.currentFocusIndex = 0;

        super.destroy();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Element Targeting Module Index
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Export all element targeting modules for easy importing
 * @author Emotive Engine Team
 * @module positioning/elementTargeting/index
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides a single import point for all element targeting functionality, making    
 * ║ it easy to use any combination of targeting features in the engine.               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


// Combined class that includes all features
class ElementTargetingAll {
    constructor(positionController) {
        this.positionController = positionController;
        
        // Initialize all targeting modules
        this.callbacks = new ElementTargetingCallbacks(positionController);
        this.advanced = new ElementTargetingAdvanced(positionController);
        this.context = new ElementTargetingContext(positionController);
        this.interactions = new ElementTargetingInteractions(positionController);
        this.animations = new ElementTargetingAnimations(positionController);
        this.effects = new ElementTargetingEffects(positionController);
        this.accessibility = new ElementTargetingAccessibility(positionController);
    }

    // Delegate methods to appropriate modules
    moveToElementWithCallback(...args) { return this.callbacks.moveToElementWithCallback(...args); }
    moveToElementSequence(...args) { return this.callbacks.moveToElementSequence(...args); }
    moveToElementWithDelay(...args) { return this.callbacks.moveToElementWithDelay(...args); }
    moveToElementWithCondition(...args) { return this.callbacks.moveToElementWithCondition(...args); }
    moveToElementWithRepeat(...args) { return this.callbacks.moveToElementWithRepeat(...args); }
    moveToElementWithProximity(...args) { return this.callbacks.moveToElementWithProximity(...args); }

    moveToElementWithPath(...args) { return this.advanced.moveToElementWithPath(...args); }
    moveToElementWithEasing(...args) { return this.advanced.moveToElementWithEasing(...args); }
    moveToElementWithCollision(...args) { return this.advanced.moveToElementWithCollision(...args); }
    moveToElementWithAudio(...args) { return this.advanced.moveToElementWithAudio(...args); }
    moveToElementWithGaze(...args) { return this.advanced.moveToElementWithGaze(...args); }

    moveToElementWithScroll(...args) { return this.context.moveToElementWithScroll(...args); }
    moveToElementWithPhysics(...args) { return this.context.moveToElementWithPhysics(...args); }
    moveToElementWithGroup(...args) { return this.context.moveToElementWithGroup(...args); }
    moveToElementWithResponsive(...args) { return this.context.moveToElementWithResponsive(...args); }
    moveToElementWithAccessibility(...args) { return this.context.moveToElementWithAccessibility(...args); }

    moveToElementWithHover(...args) { return this.interactions.moveToElementWithHover(...args); }
    moveToElementWithClick(...args) { return this.interactions.moveToElementWithClick(...args); }
    moveToElementWithTouch(...args) { return this.interactions.moveToElementWithTouch(...args); }
    moveToElementWithFocus(...args) { return this.interactions.moveToElementWithFocus(...args); }
    moveToElementWithKeyboard(...args) { return this.interactions.moveToElementWithKeyboard(...args); }

    moveToElementWithBounce(...args) { return this.animations.moveToElementWithBounce(...args); }
    moveToElementWithShake(...args) { return this.animations.moveToElementWithShake(...args); }
    moveToElementWithPulse(...args) { return this.animations.moveToElementWithPulse(...args); }
    moveToElementWithWiggle(...args) { return this.animations.moveToElementWithWiggle(...args); }
    moveToElementWithCustom(...args) { return this.animations.moveToElementWithCustom(...args); }

    moveToElementWithTrail(...args) { return this.effects.moveToElementWithTrail(...args); }
    moveToElementWithParticles(...args) { return this.effects.moveToElementWithParticles(...args); }
    moveToElementWithGlow(...args) { return this.effects.moveToElementWithGlow(...args); }

    moveToElementWithScreenReader(...args) { return this.accessibility.moveToElementWithScreenReader(...args); }
    moveToElementWithKeyboardAccessible(...args) { return this.accessibility.moveToElementWithKeyboard(...args); }
    moveToElementWithHighContrast(...args) { return this.accessibility.moveToElementWithHighContrast(...args); }
    moveToElementWithReducedMotion(...args) { return this.accessibility.moveToElementWithReducedMotion(...args); }
    moveToElementWithFocusAccessible(...args) { return this.accessibility.moveToElementWithFocus(...args); }

    // Utility methods
    announceToScreenReader(...args) { return this.accessibility.announceToScreenReader(...args); }
    navigateFocus(...args) { return this.accessibility.navigateFocus(...args); }
    enableAccessibility(...args) { return this.accessibility.enableAccessibility(...args); }
    disableAccessibility(...args) { return this.accessibility.disableAccessibility(...args); }

    // Destroy all modules
    destroy() {
        this.callbacks.destroy();
        this.advanced.destroy();
        this.context.destroy();
        this.interactions.destroy();
        this.animations.destroy();
        this.effects.destroy();
        this.accessibility.destroy();
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Input Tracking System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Input-based positioning methods for mascot tracking
 * @author Emotive Engine Team
 * @module positioning/InputTracking
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides methods to position the mascot based on user input like mouse movement,   
 * ║ touch gestures, and audio levels. Creates interactive and responsive positioning.  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

class InputTracking {
    constructor(positionController) {
        this.positionController = positionController;
        this.isTracking = false;
        this.trackingCallbacks = new Map();
        this.audioContext = null;
        this.audioAnalyser = null;
        this.audioData = null;
    }

    /**
     * Move mascot to follow mouse cursor
     * @param {Object} offset - {x, y} offset from cursor
     * @param {Object} options - Tracking options
     */
    moveToMouse(offset = { x: 20, y: 20 }, options = {}) {
        const callbackId = 'mouse-tracking';
        
        const handleMouseMove = event => {
            const targetX = event.clientX + offset.x;
            const targetY = event.clientY + offset.y;
            
            // Convert to mascot coordinate system
            const mascotX = targetX - window.innerWidth / 2;
            const mascotY = targetY - window.innerHeight / 2;
            
            if (options.smooth !== false) {
                this.positionController.animateOffset(mascotX, mascotY, 0, options.duration || 200, 'easeOutQuad');
            } else {
                this.positionController.setOffset(mascotX, mascotY, 0);
            }
        };

        this.trackingCallbacks.set(callbackId, handleMouseMove);
        window.addEventListener('mousemove', handleMouseMove);
        
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            this.trackingCallbacks.delete(callbackId);
        };
    }

    /**
     * Move mascot to follow touch position
     * @param {Object} offset - {x, y} offset from touch
     * @param {Object} options - Tracking options
     */
    moveToTouch(offset = { x: 20, y: 20 }, options = {}) {
        const callbackId = 'touch-tracking';
        
        const handleTouchMove = event => {
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                const targetX = touch.clientX + offset.x;
                const targetY = touch.clientY + offset.y;
                
                // Convert to mascot coordinate system
                const mascotX = targetX - window.innerWidth / 2;
                const mascotY = targetY - window.innerHeight / 2;
                
                if (options.smooth !== false) {
                    this.positionController.animateOffset(mascotX, mascotY, 0, options.duration || 200, 'easeOutQuad');
                } else {
                    this.positionController.setOffset(mascotX, mascotY, 0);
                }
            }
        };

        this.trackingCallbacks.set(callbackId, handleTouchMove);
        window.addEventListener('touchmove', handleTouchMove);
        
        return () => {
            window.removeEventListener('touchmove', handleTouchMove);
            this.trackingCallbacks.delete(callbackId);
        };
    }

    /**
     * Move mascot based on audio levels
     * @param {number} level - Audio level (0-1)
     * @param {number} sensitivity - Sensitivity multiplier
     * @param {Object} options - Audio tracking options
     */
    moveToAudio(level = 0, sensitivity = 50, options = {}) {
        if (!this.audioContext) {
            this.initAudioContext();
        }

        if (!this.audioContext || !this.audioAnalyser) {
            console.warn('Audio context not available');
            return;
        }

        const callbackId = 'audio-tracking';
        
        const updateAudioPosition = () => {
            if (!this.isTracking) return;
            
            this.audioAnalyser.getByteFrequencyData(this.audioData);
            
            // Calculate average audio level
            let sum = 0;
            for (let i = 0; i < this.audioData.length; i++) {
                sum += this.audioData[i];
            }
            const averageLevel = (sum / this.audioData.length) / 255;
            
            // Apply sensitivity and offset
            const audioOffset = averageLevel * sensitivity;
            const targetX = (options.centerX || 0) + audioOffset;
            const targetY = (options.centerY || 0) + (audioOffset * 0.5);
            
            // Convert to mascot coordinate system
            const mascotX = targetX - window.innerWidth / 2;
            const mascotY = targetY - window.innerHeight / 2;
            
            this.positionController.setOffset(mascotX, mascotY, 0);
            
            if (this.isTracking) {
                requestAnimationFrame(updateAudioPosition);
            }
        };

        this.trackingCallbacks.set(callbackId, updateAudioPosition);
        this.isTracking = true;
        updateAudioPosition();
        
        return () => {
            this.isTracking = false;
            this.trackingCallbacks.delete(callbackId);
        };
    }

    /**
     * Initialize audio context for audio tracking
     */
    initAudioContext() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.audioAnalyser = this.audioContext.createAnalyser();
            this.audioAnalyser.fftSize = 256;
            this.audioData = new Uint8Array(this.audioAnalyser.frequencyBinCount);
        } catch (error) {
            console.warn('Failed to initialize audio context:', error);
        }
    }

    /**
     * Connect audio source to analyser
     * @param {MediaStream} stream - Audio stream
     */
    connectAudioSource(stream) {
        if (!this.audioContext || !this.audioAnalyser) {
            this.initAudioContext();
        }
        
        if (this.audioContext && this.audioAnalyser) {
            const source = this.audioContext.createMediaStreamSource(stream);
            source.connect(this.audioAnalyser);
        }
    }

    /**
     * Move mascot to viewport edges
     * @param {string} position - 'top', 'bottom', 'left', 'right', 'top-left', etc.
     * @param {Object} offset - Pixel offset from edge
     */
    moveToViewport(position = 'right', offset = { x: 20, y: 20 }) {
        let targetX, targetY;
        
        switch (position) {
        case 'top':
            targetX = window.innerWidth / 2;
            targetY = offset.y;
            break;
        case 'bottom':
            targetX = window.innerWidth / 2;
            targetY = window.innerHeight - offset.y;
            break;
        case 'left':
            targetX = offset.x;
            targetY = window.innerHeight / 2;
            break;
        case 'right':
            targetX = window.innerWidth - offset.x;
            targetY = window.innerHeight / 2;
            break;
        case 'top-left':
            targetX = offset.x;
            targetY = offset.y;
            break;
        case 'top-right':
            targetX = window.innerWidth - offset.x;
            targetY = offset.y;
            break;
        case 'bottom-left':
            targetX = offset.x;
            targetY = window.innerHeight - offset.y;
            break;
        case 'bottom-right':
            targetX = window.innerWidth - offset.x;
            targetY = window.innerHeight - offset.y;
            break;
        default:
            targetX = window.innerWidth - offset.x;
            targetY = window.innerHeight / 2;
        }
        
        // Convert to mascot coordinate system
        const mascotX = targetX - window.innerWidth / 2;
        const mascotY = targetY - window.innerHeight / 2;
        
        this.positionController.setOffset(mascotX, mascotY, 0);
    }

    /**
     * Stop all input tracking
     */
    stopAllTracking() {
        this.trackingCallbacks.forEach((callback, id) => {
            if (id === 'mouse-tracking') {
                window.removeEventListener('mousemove', callback);
            } else if (id === 'touch-tracking') {
                window.removeEventListener('touchmove', callback);
            }
        });
        this.trackingCallbacks.clear();
        this.isTracking = false;
    }

    /**
     * Destroy the input tracking system
     */
    destroy() {
        this.stopAllTracking();
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
        }
        this.positionController = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Physics-Based Positioning
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Physics-based positioning methods for natural mascot movement
 * @author Emotive Engine Team
 * @module positioning/Physics
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides physics-based positioning methods like gravity, magnetism, and avoidance. 
 * ║ Creates natural, organic movement patterns for the mascot.                         
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

class Physics {
    constructor(positionController) {
        this.positionController = positionController;
        this.isRunning = false;
        this.physicsCallbacks = new Map();
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.lastTime = 0;
    }

    /**
     * Move mascot to grid position
     * @param {number} x - Grid X coordinate
     * @param {number} y - Grid Y coordinate
     * @param {Object} offset - Pixel offset
     * @param {Object} options - Grid options
     */
    moveToGrid(x, y, offset = { x: 0, y: 0 }, options = {}) {
        const gridSize = options.gridSize || 100;
        const targetX = (x * gridSize) + offset.x;
        const targetY = (y * gridSize) + offset.y;
        
        // Convert to mascot coordinate system
        const mascotX = targetX - window.innerWidth / 2;
        const mascotY = targetY - window.innerHeight / 2;
        
        if (options.animate !== false) {
            this.positionController.animateOffset(mascotX, mascotY, 0, options.duration || 1000, options.easing || 'easeOutCubic');
        } else {
            this.positionController.setOffset(mascotX, mascotY, 0);
        }
    }

    /**
     * Apply gravity effect to mascot
     * @param {Object} center - {x, y} gravity center
     * @param {number} strength - Gravity strength
     * @param {Object} options - Gravity options
     */
    moveToGravity(center = { x: 0, y: 0 }, strength = 0.1, options = {}) {
        const callbackId = 'gravity';
        
        const applyGravity = currentTime => {
            if (!this.isRunning) return;
            
            const deltaTime = currentTime - this.lastTime;
            this.lastTime = currentTime;
            
            if (deltaTime > 0) {
                // Get current position
                const currentOffset = this.positionController.getOffset();
                const currentX = currentOffset.x;
                const currentY = currentOffset.y;
                
                // Calculate distance to gravity center
                const dx = center.x - currentX;
                const dy = center.y - currentY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Apply gravity force
                    const force = strength / (distance * distance);
                    this.acceleration.x = (dx / distance) * force;
                    this.acceleration.y = (dy / distance) * force;
                    
                    // Update velocity
                    this.velocity.x += this.acceleration.x * deltaTime;
                    this.velocity.y += this.acceleration.y * deltaTime;
                    
                    // Apply damping
                    const damping = options.damping || 0.98;
                    this.velocity.x *= damping;
                    this.velocity.y *= damping;
                    
                    // Update position
                    const newX = currentX + this.velocity.x * deltaTime;
                    const newY = currentY + this.velocity.y * deltaTime;
                    
                    this.positionController.setOffset(newX, newY, 0);
                }
            }
            
            if (this.isRunning) {
                requestAnimationFrame(applyGravity);
            }
        };
        
        this.physicsCallbacks.set(callbackId, applyGravity);
        this.isRunning = true;
        this.lastTime = performance.now();
        applyGravity(this.lastTime);
        
        return () => {
            this.isRunning = false;
            this.physicsCallbacks.delete(callbackId);
        };
    }

    /**
     * Apply magnetic attraction to elements
     * @param {Array} targets - Array of target elements or positions
     * @param {number} strength - Magnetic strength
     * @param {Object} options - Magnetic options
     */
    moveToMagnetic(targets = [], strength = 0.05, options = {}) {
        const callbackId = 'magnetic';
        
        const applyMagnetism = currentTime => {
            if (!this.isRunning) return;
            
            const deltaTime = currentTime - this.lastTime;
            this.lastTime = currentTime;
            
            if (deltaTime > 0) {
                // Get current position
                const currentOffset = this.positionController.getOffset();
                const currentX = currentOffset.x;
                const currentY = currentOffset.y;
                
                let totalForceX = 0;
                let totalForceY = 0;
                
                // Calculate forces from all targets
                targets.forEach(target => {
                    let targetX, targetY;
                    
                    if (typeof target === 'string') {
                        // CSS selector
                        const element = document.querySelector(target);
                        if (element) {
                            const rect = element.getBoundingClientRect();
                            targetX = rect.left + rect.width / 2 - window.innerWidth / 2;
                            targetY = rect.top + rect.height / 2 - window.innerHeight / 2;
                        } else {
                            return;
                        }
                    } else if (target.x !== undefined && target.y !== undefined) {
                        // Position object
                        targetX = target.x - window.innerWidth / 2;
                        targetY = target.y - window.innerHeight / 2;
                    } else {
                        return;
                    }
                    
                    // Calculate distance and force
                    const dx = targetX - currentX;
                    const dy = targetY - currentY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const force = strength / (distance * distance);
                        totalForceX += (dx / distance) * force;
                        totalForceY += (dy / distance) * force;
                    }
                });
                
                // Apply magnetic force
                this.acceleration.x = totalForceX;
                this.acceleration.y = totalForceY;
                
                // Update velocity
                this.velocity.x += this.acceleration.x * deltaTime;
                this.velocity.y += this.acceleration.y * deltaTime;
                
                // Apply damping
                const damping = options.damping || 0.95;
                this.velocity.x *= damping;
                this.velocity.y *= damping;
                
                // Update position
                const newX = currentX + this.velocity.x * deltaTime;
                const newY = currentY + this.velocity.y * deltaTime;
                
                this.positionController.setOffset(newX, newY, 0);
            }
            
            if (this.isRunning) {
                requestAnimationFrame(applyMagnetism);
            }
        };
        
        this.physicsCallbacks.set(callbackId, applyMagnetism);
        this.isRunning = true;
        this.lastTime = performance.now();
        applyMagnetism(this.lastTime);
        
        return () => {
            this.isRunning = false;
            this.physicsCallbacks.delete(callbackId);
        };
    }

    /**
     * Avoid obstacles and elements
     * @param {Array} obstacles - Array of obstacle elements or positions
     * @param {number} distance - Minimum distance to maintain
     * @param {Object} options - Avoidance options
     */
    moveToAvoid(obstacles = [], distance = 100, options = {}) {
        const callbackId = 'avoid';
        
        const applyAvoidance = currentTime => {
            if (!this.isRunning) return;
            
            const deltaTime = currentTime - this.lastTime;
            this.lastTime = currentTime;
            
            if (deltaTime > 0) {
                // Get current position
                const currentOffset = this.positionController.getOffset();
                const currentX = currentOffset.x;
                const currentY = currentOffset.y;
                
                let totalForceX = 0;
                let totalForceY = 0;
                
                // Calculate avoidance forces from all obstacles
                obstacles.forEach(obstacle => {
                    let obstacleX, obstacleY;
                    
                    if (typeof obstacle === 'string') {
                        // CSS selector
                        const element = document.querySelector(obstacle);
                        if (element) {
                            const rect = element.getBoundingClientRect();
                            obstacleX = rect.left + rect.width / 2 - window.innerWidth / 2;
                            obstacleY = rect.top + rect.height / 2 - window.innerHeight / 2;
                        } else {
                            return;
                        }
                    } else if (obstacle.x !== undefined && obstacle.y !== undefined) {
                        // Position object
                        obstacleX = obstacle.x - window.innerWidth / 2;
                        obstacleY = obstacle.y - window.innerHeight / 2;
                    } else {
                        return;
                    }
                    
                    // Calculate distance to obstacle
                    const dx = currentX - obstacleX;
                    const dy = currentY - obstacleY;
                    const obstacleDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (obstacleDistance < distance && obstacleDistance > 0) {
                        // Apply repulsion force
                        const force = (distance - obstacleDistance) / distance;
                        totalForceX += (dx / obstacleDistance) * force;
                        totalForceY += (dy / obstacleDistance) * force;
                    }
                });
                
                // Apply avoidance force
                this.acceleration.x = totalForceX;
                this.acceleration.y = totalForceY;
                
                // Update velocity
                this.velocity.x += this.acceleration.x * deltaTime;
                this.velocity.y += this.acceleration.y * deltaTime;
                
                // Apply damping
                const damping = options.damping || 0.9;
                this.velocity.x *= damping;
                this.velocity.y *= damping;
                
                // Update position
                const newX = currentX + this.velocity.x * deltaTime;
                const newY = currentY + this.velocity.y * deltaTime;
                
                this.positionController.setOffset(newX, newY, 0);
            }
            
            if (this.isRunning) {
                requestAnimationFrame(applyAvoidance);
            }
        };
        
        this.physicsCallbacks.set(callbackId, applyAvoidance);
        this.isRunning = true;
        this.lastTime = performance.now();
        applyAvoidance(this.lastTime);
        
        return () => {
            this.isRunning = false;
            this.physicsCallbacks.delete(callbackId);
        };
    }

    /**
     * Move mascot to random positions within bounds
     * @param {Object} bounds - {x, y, width, height} bounds
     * @param {number} frequency - How often to change position (ms)
     * @param {Object} options - Random movement options
     */
    moveToRandom(bounds = { x: 0, y: 0, width: 400, height: 400 }, frequency = 3000, options = {}) {
        const callbackId = 'random';
        
        const randomizePosition = () => {
            if (!this.isRunning) return;
            
            const randomX = bounds.x + Math.random() * bounds.width;
            const randomY = bounds.y + Math.random() * bounds.height;
            
            // Convert to mascot coordinate system
            const mascotX = randomX - window.innerWidth / 2;
            const mascotY = randomY - window.innerHeight / 2;
            
            if (options.animate !== false) {
                this.positionController.animateOffset(mascotX, mascotY, 0, options.duration || 1000, options.easing || 'easeOutCubic');
            } else {
                this.positionController.setOffset(mascotX, mascotY, 0);
            }
            
            if (this.isRunning) {
                setTimeout(randomizePosition, frequency);
            }
        };
        
        this.physicsCallbacks.set(callbackId, randomizePosition);
        this.isRunning = true;
        randomizePosition();
        
        return () => {
            this.isRunning = false;
            this.physicsCallbacks.delete(callbackId);
        };
    }

    /**
     * Stop all physics simulations
     */
    stopAllPhysics() {
        this.isRunning = false;
        this.physicsCallbacks.clear();
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
    }

    /**
     * Destroy the physics system
     */
    destroy() {
        this.stopAllPhysics();
        this.positionController = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Animation-Based Positioning
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Animation-based positioning methods for mascot movement
 * @author Emotive Engine Team
 * @module positioning/Animation
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides animation-based positioning methods like path following, time-based       
 * ║ movement, and scroll-based positioning. Creates smooth, predictable animations.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

class Animation {
    constructor(positionController) {
        this.positionController = positionController;
        this.isRunning = false;
        this.animationCallbacks = new Map();
        this.pathProgress = 0;
        this.timeProgress = 0;
        this.scrollProgress = 0;
    }

    /**
     * Move mascot along a path
     * @param {Array} points - Array of {x, y} points
     * @param {number} speed - Movement speed (points per second)
     * @param {Object} options - Path options
     */
    moveToPath(points = [], speed = 1, options = {}) {
        if (points.length < 2) {
            console.warn('Path requires at least 2 points');
            return;
        }

        const callbackId = 'path';
        const loop = options.loop !== false;
        const reverse = options.reverse || false;
        
        const followPath = currentTime => {
            if (!this.isRunning) return;
            
            const deltaTime = currentTime - (this.lastTime || currentTime);
            this.lastTime = currentTime;
            
            if (deltaTime > 0) {
                // Update progress
                this.pathProgress += (speed * deltaTime) / 1000;
                
                if (loop) {
                    this.pathProgress = this.pathProgress % points.length;
                } else {
                    this.pathProgress = Math.min(this.pathProgress, points.length - 1);
                }
                
                // Get current position on path
                const segmentIndex = Math.floor(this.pathProgress);
                const segmentProgress = this.pathProgress - segmentIndex;
                
                let currentPoint, nextPoint;
                
                if (reverse) {
                    currentPoint = points[points.length - 1 - segmentIndex];
                    nextPoint = points[points.length - 2 - segmentIndex] || points[0];
                } else {
                    currentPoint = points[segmentIndex];
                    nextPoint = points[segmentIndex + 1] || points[0];
                }
                
                // Interpolate between points
                const targetX = currentPoint.x + (nextPoint.x - currentPoint.x) * segmentProgress;
                const targetY = currentPoint.y + (nextPoint.y - currentPoint.y) * segmentProgress;
                
                // Convert to mascot coordinate system
                const mascotX = targetX - window.innerWidth / 2;
                const mascotY = targetY - window.innerHeight / 2;
                
                this.positionController.setOffset(mascotX, mascotY, 0);
                
                // Check if path is complete
                if (!loop && this.pathProgress >= points.length - 1) {
                    this.isRunning = false;
                    this.animationCallbacks.delete(callbackId);
                    if (options.onComplete) options.onComplete();
                    return;
                }
            }
            
            if (this.isRunning) {
                requestAnimationFrame(followPath);
            }
        };
        
        this.animationCallbacks.set(callbackId, followPath);
        this.isRunning = true;
        this.lastTime = performance.now();
        followPath(this.lastTime);
        
        return () => {
            this.isRunning = false;
            this.animationCallbacks.delete(callbackId);
        };
    }

    /**
     * Move mascot based on time
     * @param {number} duration - Animation duration in ms
     * @param {string} easing - Easing function name
     * @param {Object} options - Time-based options
     */
    moveToTime(duration = 2000, easing = 'easeInOutCubic', options = {}) {
        const callbackId = 'time';
        const startTime = performance.now();
        const startPosition = this.positionController.getOffset();
        const targetPosition = options.target || { x: 0, y: 0 };
        
        const animateTime = currentTime => {
            if (!this.isRunning) return;
            
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Apply easing
            const easedProgress = this.applyEasing(progress, easing);
            
            // Interpolate position
            const currentX = startPosition.x + (targetPosition.x - startPosition.x) * easedProgress;
            const currentY = startPosition.y + (targetPosition.y - startPosition.y) * easedProgress;
            
            this.positionController.setOffset(currentX, currentY, 0);
            
            if (progress >= 1) {
                this.isRunning = false;
                this.animationCallbacks.delete(callbackId);
                if (options.onComplete) options.onComplete();
            } else {
                requestAnimationFrame(animateTime);
            }
        };
        
        this.animationCallbacks.set(callbackId, animateTime);
        this.isRunning = true;
        animateTime(startTime);
        
        return () => {
            this.isRunning = false;
            this.animationCallbacks.delete(callbackId);
        };
    }

    /**
     * Move mascot based on scroll progress
     * @param {number} progress - Scroll progress (0-1)
     * @param {Object} offset - Pixel offset
     * @param {Object} options - Scroll-based options
     */
    moveToScroll(progress = 0, offset = { x: 0, y: 0 }, options = {}) {
        const callbackId = 'scroll';
        
        const updateScrollPosition = () => {
            if (!this.isRunning) return;
            
            // Calculate position based on scroll progress
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            let targetX, targetY;
            
            if (options.direction === 'horizontal') {
                targetX = (progress * viewportWidth) + offset.x;
                targetY = (viewportHeight / 2) + offset.y;
            } else if (options.direction === 'vertical') {
                targetX = (viewportWidth / 2) + offset.x;
                targetY = (progress * viewportHeight) + offset.y;
            } else {
                // Circular or custom path
                const angle = progress * Math.PI * 2;
                const radius = options.radius || Math.min(viewportWidth, viewportHeight) / 4;
                targetX = (viewportWidth / 2) + Math.cos(angle) * radius + offset.x;
                targetY = (viewportHeight / 2) + Math.sin(angle) * radius + offset.y;
            }
            
            // Convert to mascot coordinate system
            const mascotX = targetX - viewportWidth / 2;
            const mascotY = targetY - viewportHeight / 2;
            
            this.positionController.setOffset(mascotX, mascotY, 0);
        };
        
        this.animationCallbacks.set(callbackId, updateScrollPosition);
        this.isRunning = true;
        updateScrollPosition();
        
        return () => {
            this.isRunning = false;
            this.animationCallbacks.delete(callbackId);
        };
    }

    /**
     * Animate to specific coordinates
     * @param {number} x - Target X coordinate
     * @param {number} y - Target Y coordinate
     * @param {number} duration - Animation duration
     * @param {string} easing - Easing function
     */
    animateTo(x, y, duration = 1000, easing = 'easeOutCubic') {
        this.positionController.animateOffset(x, y, 0, duration, easing);
    }

    /**
     * Apply easing function
     * @param {number} t - Input value (0-1)
     * @param {string} easing - Easing function name
     * @returns {number} Eased value
     */
    applyEasing(t, easing) {
        switch (easing) {
        case 'linear':
            return t;
        case 'easeInQuad':
            return t * t;
        case 'easeOutQuad':
            return 1 - (1 - t) * (1 - t);
        case 'easeInOutQuad':
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        case 'easeInCubic':
            return t * t * t;
        case 'easeOutCubic':
            return 1 - Math.pow(1 - t, 3);
        case 'easeInOutCubic':
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        case 'easeInBack': {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return c3 * t * t * t - c1 * t * t;
        }
        case 'easeOutBack': {
            const c1_back = 1.70158;
            const c3_back = c1_back + 1;
            return 1 + c3_back * Math.pow(t - 1, 3) + c1_back * Math.pow(t - 1, 2);
        }
        case 'easeInElastic':
            return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * ((2 * Math.PI) / 3));
        case 'easeOutElastic':
            return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1;
        default:
            return t;
        }
    }

    /**
     * Stop all animations
     */
    stopAllAnimations() {
        this.isRunning = false;
        this.animationCallbacks.clear();
        this.pathProgress = 0;
        this.timeProgress = 0;
        this.scrollProgress = 0;
    }

    /**
     * Destroy the animation system
     */
    destroy() {
        this.stopAllAnimations();
        this.positionController = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Responsive Positioning
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Responsive positioning methods for mascot across different screen sizes
 * @author Emotive Engine Team
 * @module positioning/Responsive
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides responsive positioning methods that adapt to different screen sizes and   
 * ║ accessibility requirements. Ensures mascot positioning works across all devices.   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */

class Responsive {
    constructor(positionController) {
        this.positionController = positionController;
        this.breakpoints = {
            mobile: 768,
            tablet: 1024,
            desktop: 1200
        };
        this.currentBreakpoint = this.getCurrentBreakpoint();
        this.responsiveCallbacks = new Map();
    }

    /**
     * Get current breakpoint based on window width
     * @returns {string} Current breakpoint name
     */
    getCurrentBreakpoint() {
        const width = window.innerWidth;
        if (width < this.breakpoints.mobile) return 'mobile';
        if (width < this.breakpoints.tablet) return 'tablet';
        if (width < this.breakpoints.desktop) return 'desktop';
        return 'large';
    }

    /**
     * Move mascot to responsive position based on breakpoints
     * @param {Object} breakpoints - Object with breakpoint-specific positions
     * @param {Object} options - Responsive options
     */
    moveToResponsive(breakpoints = {}, options = {}) {
        const callbackId = 'responsive';
        
        const updateResponsivePosition = () => {
            if (!this.isRunning) return;
            
            const currentBreakpoint = this.getCurrentBreakpoint();
            const position = breakpoints[currentBreakpoint] || breakpoints.default || { x: 0, y: 0 };
            
            // Convert to mascot coordinate system
            const mascotX = position.x - window.innerWidth / 2;
            const mascotY = position.y - window.innerHeight / 2;
            
            if (options.animate !== false) {
                this.positionController.animateOffset(mascotX, mascotY, 0, options.duration || 500, options.easing || 'easeOutCubic');
            } else {
                this.positionController.setOffset(mascotX, mascotY, 0);
            }
        };
        
        this.responsiveCallbacks.set(callbackId, updateResponsivePosition);
        this.isRunning = true;
        updateResponsivePosition();
        
        // Listen for resize events
        const handleResize = () => {
            const newBreakpoint = this.getCurrentBreakpoint();
            if (newBreakpoint !== this.currentBreakpoint) {
                this.currentBreakpoint = newBreakpoint;
                updateResponsivePosition();
            }
        };
        
        window.addEventListener('resize', handleResize);
        
        return () => {
            this.isRunning = false;
            this.responsiveCallbacks.delete(callbackId);
            window.removeEventListener('resize', handleResize);
        };
    }

    /**
     * Move mascot to group of elements
     * @param {Array} elements - Array of element selectors or positions
     * @param {string} position - Position relative to group
     * @param {Object} offset - Pixel offset
     */
    moveToGroup(elements = [], position = 'center', offset = { x: 0, y: 0 }) {
        if (elements.length === 0) return;
        
        let groupX = 0, groupY = 0, groupWidth = 0, groupHeight = 0;
        let validElements = 0;
        
        elements.forEach(element => {
            let elementX, elementY, elementWidth, elementHeight;
            
            if (typeof element === 'string') {
                // CSS selector
                const el = document.querySelector(element);
                if (el) {
                    const rect = el.getBoundingClientRect();
                    elementX = rect.left;
                    elementY = rect.top;
                    elementWidth = rect.width;
                    elementHeight = rect.height;
                } else {
                    return;
                }
            } else if (element.x !== undefined && element.y !== undefined) {
                // Position object
                elementX = element.x;
                elementY = element.y;
                elementWidth = element.width || 0;
                elementHeight = element.height || 0;
            } else {
                return;
            }
            
            groupX += elementX;
            groupY += elementY;
            groupWidth = Math.max(groupWidth, elementX + elementWidth);
            groupHeight = Math.max(groupHeight, elementY + elementHeight);
            validElements++;
        });
        
        if (validElements === 0) return;
        
        // Calculate group center
        const centerX = groupX / validElements;
        const centerY = groupY / validElements;
        
        let targetX, targetY;
        
        switch (position) {
        case 'center':
            targetX = centerX + offset.x;
            targetY = centerY + offset.y;
            break;
        case 'left':
            targetX = groupX + offset.x;
            targetY = centerY + offset.y;
            break;
        case 'right':
            targetX = groupWidth + offset.x;
            targetY = centerY + offset.y;
            break;
        case 'top':
            targetX = centerX + offset.x;
            targetY = groupY + offset.y;
            break;
        case 'bottom':
            targetX = centerX + offset.x;
            targetY = groupHeight + offset.y;
            break;
        default:
            targetX = centerX + offset.x;
            targetY = centerY + offset.y;
        }
        
        // Convert to mascot coordinate system
        const mascotX = targetX - window.innerWidth / 2;
        const mascotY = targetY - window.innerHeight / 2;
        
        this.positionController.setOffset(mascotX, mascotY, 0);
    }

    /**
     * Move mascot to accessibility-friendly position
     * @param {Array} announcements - Array of screen reader announcements
     * @param {string} position - Position relative to content
     * @param {Object} options - Accessibility options
     */
    moveToAccessibility(announcements = [], position = 'bottom-right', options = {}) {
        const callbackId = 'accessibility';
        
        const updateAccessibilityPosition = () => {
            if (!this.isRunning) return;
            
            // Check for screen reader
            const hasScreenReader = window.speechSynthesis || window.webkitSpeechSynthesis;
            
            if (hasScreenReader && options.announce) {
                // Announce current position
                announcements.forEach(announcement => {
                    if (announcement.condition && announcement.condition()) {
                        this.announceToScreenReader(announcement.text);
                    }
                });
            }
            
            // Position mascot in accessibility-friendly location
            let targetX, targetY;
            
            switch (position) {
            case 'bottom-right':
                targetX = window.innerWidth - 100;
                targetY = window.innerHeight - 100;
                break;
            case 'bottom-left':
                targetX = 100;
                targetY = window.innerHeight - 100;
                break;
            case 'top-right':
                targetX = window.innerWidth - 100;
                targetY = 100;
                break;
            case 'top-left':
                targetX = 100;
                targetY = 100;
                break;
            case 'center':
                targetX = window.innerWidth / 2;
                targetY = window.innerHeight / 2;
                break;
            default:
                targetX = window.innerWidth - 100;
                targetY = window.innerHeight - 100;
            }
            
            // Convert to mascot coordinate system
            const mascotX = targetX - window.innerWidth / 2;
            const mascotY = targetY - window.innerHeight / 2;
            
            this.positionController.setOffset(mascotX, mascotY, 0);
        };
        
        this.responsiveCallbacks.set(callbackId, updateAccessibilityPosition);
        this.isRunning = true;
        updateAccessibilityPosition();
        
        return () => {
            this.isRunning = false;
            this.responsiveCallbacks.delete(callbackId);
        };
    }

    /**
     * Announce text to screen reader
     * @param {string} text - Text to announce
     */
    announceToScreenReader(text) {
        if (window.speechSynthesis) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.volume = 0.5;
            utterance.rate = 0.8;
            window.speechSynthesis.speak(utterance);
        }
    }

    /**
     * Set custom breakpoints
     * @param {Object} breakpoints - Custom breakpoint values
     */
    setBreakpoints(breakpoints) {
        this.breakpoints = { ...this.breakpoints, ...breakpoints };
        this.currentBreakpoint = this.getCurrentBreakpoint();
    }

    /**
     * Get current breakpoint name
     * @returns {string} Current breakpoint
     */
    getCurrentBreakpointName() {
        return this.currentBreakpoint;
    }

    /**
     * Check if current breakpoint matches
     * @param {string} breakpoint - Breakpoint to check
     * @returns {boolean} True if current breakpoint matches
     */
    isBreakpoint(breakpoint) {
        return this.currentBreakpoint === breakpoint;
    }

    /**
     * Stop all responsive positioning
     */
    stopAllResponsive() {
        this.isRunning = false;
        this.responsiveCallbacks.clear();
    }

    /**
     * Destroy the responsive system
     */
    destroy() {
        this.stopAllResponsive();
        this.positionController = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Positioning System Index
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Main positioning system that orchestrates all positioning modules
 * @author Emotive Engine Team
 * @module positioning/index
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Provides a unified interface for all positioning methods. Combines element        
 * ║ targeting, input tracking, physics, animation, and responsive positioning.        
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


class PositioningSystem {
    constructor(positionController) {
        this.positionController = positionController;
        
        // Initialize all positioning modules
        this.elementTargeting = new ElementTargeting(positionController);
        this.inputTracking = new InputTracking(positionController);
        this.physics = new Physics(positionController);
        this.animation = new Animation(positionController);
        this.responsive = new Responsive(positionController);
        
        // Method registry for easy access
        this.methods = new Map();
        this.registerMethods();
    }

    /**
     * Register all positioning methods for easy access
     */
    registerMethods() {
        // Element targeting methods
        this.methods.set('moveToElement', this.elementTargeting.moveToElement.bind(this.elementTargeting));
        this.methods.set('moveToButton', this.elementTargeting.moveToButton.bind(this.elementTargeting));
        this.methods.set('moveToForm', this.elementTargeting.moveToForm.bind(this.elementTargeting));
        this.methods.set('moveToModal', this.elementTargeting.moveToModal.bind(this.elementTargeting));
        this.methods.set('moveToNavigation', this.elementTargeting.moveToNavigation.bind(this.elementTargeting));
        this.methods.set('moveToContent', this.elementTargeting.moveToContent.bind(this.elementTargeting));
        this.methods.set('moveToSidebar', this.elementTargeting.moveToSidebar.bind(this.elementTargeting));
        this.methods.set('moveToHeader', this.elementTargeting.moveToHeader.bind(this.elementTargeting));
        this.methods.set('moveToFooter', this.elementTargeting.moveToFooter.bind(this.elementTargeting));
        this.methods.set('watchElement', this.elementTargeting.watchElement.bind(this.elementTargeting));

        // Input tracking methods
        this.methods.set('moveToMouse', this.inputTracking.moveToMouse.bind(this.inputTracking));
        this.methods.set('moveToTouch', this.inputTracking.moveToTouch.bind(this.inputTracking));
        this.methods.set('moveToAudio', this.inputTracking.moveToAudio.bind(this.inputTracking));
        this.methods.set('moveToViewport', this.inputTracking.moveToViewport.bind(this.inputTracking));

        // Physics methods
        this.methods.set('moveToGrid', this.physics.moveToGrid.bind(this.physics));
        this.methods.set('moveToGravity', this.physics.moveToGravity.bind(this.physics));
        this.methods.set('moveToMagnetic', this.physics.moveToMagnetic.bind(this.physics));
        this.methods.set('moveToAvoid', this.physics.moveToAvoid.bind(this.physics));
        this.methods.set('moveToRandom', this.physics.moveToRandom.bind(this.physics));

        // Animation methods
        this.methods.set('moveToPath', this.animation.moveToPath.bind(this.animation));
        this.methods.set('moveToTime', this.animation.moveToTime.bind(this.animation));
        this.methods.set('moveToScroll', this.animation.moveToScroll.bind(this.animation));
        this.methods.set('animateTo', this.animation.animateTo.bind(this.animation));

        // Responsive methods
        this.methods.set('moveToResponsive', this.responsive.moveToResponsive.bind(this.responsive));
        this.methods.set('moveToGroup', this.responsive.moveToGroup.bind(this.responsive));
        this.methods.set('moveToAccessibility', this.responsive.moveToAccessibility.bind(this.responsive));
    }

    /**
     * Call a positioning method by name
     * @param {string} methodName - Name of the method to call
     * @param {...any} args - Arguments to pass to the method
     * @returns {any} Result of the method call
     */
    call(methodName, ...args) {
        const method = this.methods.get(methodName);
        if (method) {
            return method(...args);
        } else {
            console.warn(`Positioning method not found: ${methodName}`);
            return null;
        }
    }

    /**
     * Get list of available positioning methods
     * @returns {Array} Array of method names
     */
    getAvailableMethods() {
        return Array.from(this.methods.keys());
    }

    /**
     * Check if a positioning method exists
     * @param {string} methodName - Name of the method to check
     * @returns {boolean} True if method exists
     */
    hasMethod(methodName) {
        return this.methods.has(methodName);
    }

    /**
     * Stop all positioning systems
     */
    stopAll() {
        this.elementTargeting.stopWatchingAll();
        this.inputTracking.stopAllTracking();
        this.physics.stopAllPhysics();
        this.animation.stopAllAnimations();
        this.responsive.stopAllResponsive();
    }

    /**
     * Destroy the positioning system
     */
    destroy() {
        this.stopAll();
        this.elementTargeting.destroy();
        this.inputTracking.destroy();
        this.physics.destroy();
        this.animation.destroy();
        this.responsive.destroy();
        this.methods.clear();
        this.positionController = null;
    }
}

/**
 * PositionController manages mascot offsets, pseudo-3D scaling, easing, and access to advanced positioning.
 * @module utils/PositionController
 */


class PositionController {
    constructor(config = {}) {
        // Current offset values
        this.offsetX = config.offsetX || 0;
        this.offsetY = config.offsetY || 0;
        this.offsetZ = config.offsetZ || 0;
        
        // Animation state
        this.isAnimating = false;
        this.animationId = null;
        this.animationStartTime = 0;
        this.animationDuration = 0;
        this.animationEasing = 'easeOutCubic';
        this.startOffset = { x: 0, y: 0, z: 0 };
        this.targetOffset = { x: 0, y: 0, z: 0 };
        
        // Callbacks
        this.onUpdate = config.onUpdate || (() => {});
        this.onAnimationComplete = config.onAnimationComplete || (() => {});
        
        // Z-depth scaling factors
        this.minScale = config.minScale || 0.5;
        this.maxScale = config.maxScale || 2.0;
        this.zScaleRange = config.zScaleRange || 1000; // Z units for full scale range

        // Global scale multiplier (independent of Z-depth)
        this.globalScale = 1.0;

        // Component-specific scale overrides
        this.coreScaleOverride = 1.0;
        this.particleScaleOverride = 1.0;
        
        // Initialize modular positioning system
        this.positioning = new PositioningSystem(this);
        
        // Initialize element targeting system
        this.elementTargeting = new ElementTargetingAll(this);
    }
    
    /**
     * Set offset values immediately
     * @param {number} x - X offset
     * @param {number} y - Y offset  
     * @param {number} z - Z offset (for pseudo-3D scaling)
     */
    setOffset(x, y, z = 0) {
        this.stopAnimation();
        this.offsetX = x;
        this.offsetY = y;
        this.offsetZ = z;
        this.onUpdate(this.getEffectiveCenter());
    }
    
    /**
     * Get current offset values
     * @returns {Object} Current offset {x, y, z}
     */
    getOffset() {
        return {
            x: this.offsetX,
            y: this.offsetY,
            z: this.offsetZ
        };
    }
    
    /**
     * Get current position (offset + effective center)
     * @param {number} centerX - Base center X (default: viewport center)
     * @param {number} centerY - Base center Y (default: viewport center)
     * @returns {Object} Current position {x, y, z, scale}
     */
    getPosition(centerX = window.innerWidth / 2, centerY = window.innerHeight / 2) {
        return {
            x: centerX + this.offsetX,
            y: centerY + this.offsetY,
            z: this.offsetZ,
            scale: this.getZScale()
        };
    }
    
    /**
     * Animate to new offset values
     * @param {number} x - Target X offset
     * @param {number} y - Target Y offset
     * @param {number} z - Target Z offset
     * @param {number} duration - Animation duration in ms
     * @param {string} easing - Easing function name
     */
    animateOffset(x, y, z = 0, duration = 1000, easing = 'easeOutCubic') {
        this.stopAnimation();
        
        this.startOffset = { x: this.offsetX, y: this.offsetY, z: this.offsetZ };
        this.targetOffset = { x, y, z };
        this.animationDuration = duration;
        this.animationEasing = easing;
        this.animationStartTime = performance.now();
        this.isAnimating = true;
        
        this.startAnimation();
    }
    
    /**
     * Stop current animation
     */
    stopAnimation() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        this.isAnimating = false;
    }
    
    /**
     * Start animation loop
     */
    startAnimation() {
        const animate = currentTime => {
            if (!this.isAnimating) return;
            
            const elapsed = currentTime - this.animationStartTime;
            const progress = Math.min(elapsed / this.animationDuration, 1);
            
            // Apply easing
            const easedProgress = this.applyEasing(progress, this.animationEasing);
            
            // Interpolate values
            this.offsetX = this.lerp(this.startOffset.x, this.targetOffset.x, easedProgress);
            this.offsetY = this.lerp(this.startOffset.y, this.targetOffset.y, easedProgress);
            this.offsetZ = this.lerp(this.startOffset.z, this.targetOffset.z, easedProgress);
            
            // Update callback
            this.onUpdate(this.getEffectiveCenter());
            
            if (progress >= 1) {
                this.isAnimating = false;
                this.onAnimationComplete();
            } else {
                this.animationId = requestAnimationFrame(animate);
            }
        };
        
        this.animationId = requestAnimationFrame(animate);
    }
    
    /**
     * Calculate effective center coordinates
     * @param {number} centerX - Base center X
     * @param {number} centerY - Base center Y
     * @returns {Object} Effective center {x, y, scale, coreScale, particleScale}
     */
    getEffectiveCenter(centerX = 0, centerY = 0) {
        return {
            x: centerX + this.offsetX,
            y: centerY + this.offsetY,
            scale: this.getZScale(),
            coreScale: this.getCoreScale(),
            particleScale: this.getParticleScale()
        };
    }
    
    /**
     * Calculate scale based on Z offset for pseudo-3D effect
     * @returns {number} Scale factor
     */
    getZScale() {
        // Convert Z offset to scale (negative Z = closer/larger, positive Z = farther/smaller)
        const normalizedZ = -this.offsetZ / this.zScaleRange; // Negative for intuitive behavior
        const clampedZ = Math.max(-1, Math.min(1, normalizedZ));
        const baseZScale = this.lerp(this.minScale, this.maxScale, (clampedZ + 1) / 2);
        
        // Apply global scale multiplier
        return baseZScale * this.globalScale;
    }
    
    /**
     * Set global scale multiplier for the entire mascot
     * @param {number} scale - Global scale factor (1.0 = normal size)
     */
    setGlobalScale(scale) {
        this.globalScale = Math.max(0.1, scale); // Prevent zero/negative scale
        this.onUpdate(this.getEffectiveCenter());
    }

    /**
     * Set component-specific scale overrides
     * @param {Object} options - Scale options { global, core, particles }
     */
    setScaleOverrides(options) {
        if (typeof options === 'number') {
            // Backward compatible: number sets global scale
            this.globalScale = Math.max(0.1, options);
            this.coreScaleOverride = 1.0;
            this.particleScaleOverride = 1.0;
        } else {
            // Options object
            if (options.global !== undefined) {
                this.globalScale = Math.max(0.1, options.global);
            }
            if (options.core !== undefined) {
                this.coreScaleOverride = Math.max(0.1, options.core);
            }
            if (options.particles !== undefined) {
                this.particleScaleOverride = Math.max(0.1, options.particles);
            }
        }
        this.onUpdate(this.getEffectiveCenter());
    }

    /**
     * Get composite scale for core rendering
     * @returns {number} Core scale factor (globalScale * coreScaleOverride)
     */
    getCoreScale() {
        const baseZScale = this.calculateBaseZScale();
        return baseZScale * this.globalScale * this.coreScaleOverride;
    }

    /**
     * Get composite scale for particle rendering
     * @returns {number} Particle scale factor (globalScale * particleScaleOverride)
     */
    getParticleScale() {
        const baseZScale = this.calculateBaseZScale();
        return baseZScale * this.globalScale * this.particleScaleOverride;
    }

    /**
     * Calculate base Z scale without global multipliers
     * @returns {number} Base Z scale
     */
    calculateBaseZScale() {
        const normalizedZ = -this.offsetZ / this.zScaleRange;
        const clampedZ = Math.max(-1, Math.min(1, normalizedZ));
        return this.lerp(this.minScale, this.maxScale, (clampedZ + 1) / 2);
    }
    
    /**
     * Linear interpolation
     * @param {number} start - Start value
     * @param {number} end - End value
     * @param {number} t - Interpolation factor (0-1)
     * @returns {number} Interpolated value
     */
    lerp(start, end, t) {
        return start + (end - start) * t;
    }
    
    /**
     * Apply easing function
     * @param {number} t - Input value (0-1)
     * @param {string} easing - Easing function name
     * @returns {number} Eased value
     */
    applyEasing(t, easing) {
        switch (easing) {
        case 'linear':
            return t;
        case 'easeInQuad':
            return t * t;
        case 'easeOutQuad':
            return 1 - (1 - t) * (1 - t);
        case 'easeInOutQuad':
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        case 'easeInCubic':
            return t * t * t;
        case 'easeOutCubic':
            return 1 - Math.pow(1 - t, 3);
        case 'easeInOutCubic':
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        case 'easeInBack': {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return c3 * t * t * t - c1 * t * t;
        }
        case 'easeOutBack': {
            const c1_back = 1.70158;
            const c3_back = c1_back + 1;
            return 1 + c3_back * Math.pow(t - 1, 3) + c1_back * Math.pow(t - 1, 2);
        }
        default:
            return t;
        }
    }
    
    /**
     * Get the positioning system for advanced targeting
     * @returns {PositioningSystem} The positioning system instance
     */
    getPositioning() {
        return this.positioning;
    }

    /**
     * Get the element targeting system for DOM element targeting
     * @returns {ElementTargetingAll} The element targeting system instance
     */
    getElementTargeting() {
        return this.elementTargeting;
    }

    /**
     * Call a positioning method by name
     * @param {string} methodName - Name of the method to call
     * @param {...any} args - Arguments to pass to the method
     * @returns {any} Result of the method call
     */
    callPositioning(methodName, ...args) {
        return this.positioning.call(methodName, ...args);
    }

    /**
     * Destroy the controller and clean up
     */
    destroy() {
        this.stopAnimation();
        if (this.positioning) {
            this.positioning.destroy();
            this.positioning = null;
        }
        if (this.elementTargeting) {
            this.elementTargeting.destroy();
            this.elementTargeting = null;
        }
        this.onUpdate = null;
        this.onAnimationComplete = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ♪ ♫ ♬ ♭  MUSIC THEORY SYSTEM  ♭ ♬ ♫ ♪                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Music Theory System - Musical Intelligence & Harmonic Generation
 * @author Emotive Engine Team
 * @version 1.0.0
 * @module MusicTheory
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The MUSICAL BRAIN of the system. Provides comprehensive music theory utilities    
 * ║ for generating scales, chords, progressions, and harmonic relationships that      
 * ║ respond to emotional states and user interactions.                                
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎼 MUSIC THEORY FEATURES                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Note frequency calculation (Equal Temperament)                                  
 * │ • Scale generation (Major, Minor, Modal, Exotic)                                  
 * │ • Chord construction (Triads, 7ths, Extensions)                                   
 * │ • Circle of Fifths navigation                                                     
 * │ • Interval relationships                                                          
 * │ • Chord progression generation                                                    
 * │ • Key signature management                                                        
 * │ • Emotion-to-mode mapping                                                         
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class MusicTheory {
    constructor() {
        // A4 = 440Hz standard tuning
        this.A4_FREQUENCY = 440;
        
        // Note names in chromatic scale
        this.NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Interval definitions (in semitones)
        this.INTERVALS = {
            unison: 0,
            minorSecond: 1,
            majorSecond: 2,
            minorThird: 3,
            majorThird: 4,
            perfectFourth: 5,
            tritone: 6,
            perfectFifth: 7,
            minorSixth: 8,
            majorSixth: 9,
            minorSeventh: 10,
            majorSeventh: 11,
            octave: 12
        };
        
        // Scale patterns (in semitones from root)
        this.SCALES = {
            // Traditional scales
            major: [0, 2, 4, 5, 7, 9, 11],
            naturalMinor: [0, 2, 3, 5, 7, 8, 10],
            harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
            melodicMinor: [0, 2, 3, 5, 7, 9, 11],
            
            // Modes
            ionian: [0, 2, 4, 5, 7, 9, 11],      // Major
            dorian: [0, 2, 3, 5, 7, 9, 10],      // Minor with raised 6th
            phrygian: [0, 1, 3, 5, 7, 8, 10],    // Spanish/Flamenco feel
            lydian: [0, 2, 4, 6, 7, 9, 11],      // Dreamy, ethereal
            mixolydian: [0, 2, 4, 5, 7, 9, 10],  // Bluesy major
            aeolian: [0, 2, 3, 5, 7, 8, 10],     // Natural minor
            locrian: [0, 1, 3, 5, 6, 8, 10],     // Diminished, unstable
            
            // Pentatonic scales
            majorPentatonic: [0, 2, 4, 7, 9],
            minorPentatonic: [0, 3, 5, 7, 10],
            
            // Exotic scales
            blues: [0, 3, 5, 6, 7, 10],
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
            wholeHalfDiminished: [0, 2, 3, 5, 6, 8, 9, 11],
            arabic: [0, 1, 4, 5, 7, 8, 11],       // Hijaz scale
            japanese: [0, 1, 5, 7, 8],            // Hirajoshi scale
            hungarian: [0, 2, 3, 6, 7, 8, 11],    // Hungarian minor
            bebopMajor: [0, 2, 4, 5, 7, 8, 9, 11] // Jazz bebop
        };
        
        // Chord patterns (intervals from root)
        this.CHORDS = {
            // Triads
            major: [0, 4, 7],
            minor: [0, 3, 7],
            diminished: [0, 3, 6],
            augmented: [0, 4, 8],
            sus2: [0, 2, 7],
            sus4: [0, 5, 7],
            
            // Seventh chords
            maj7: [0, 4, 7, 11],
            min7: [0, 3, 7, 10],
            dom7: [0, 4, 7, 10],
            min7b5: [0, 3, 6, 10],
            dim7: [0, 3, 6, 9],
            
            // Extended chords
            maj9: [0, 4, 7, 11, 14],
            min9: [0, 3, 7, 10, 14],
            dom9: [0, 4, 7, 10, 14],
            add9: [0, 4, 7, 14],
            maj11: [0, 4, 7, 11, 14, 17],
            min11: [0, 3, 7, 10, 14, 17],
            maj13: [0, 4, 7, 11, 14, 17, 21],
            min13: [0, 3, 7, 10, 14, 17, 21]
        };
        
        // Emotion to musical mode mapping
        this.EMOTION_MODES = {
            excited: {
                scale: 'lydian',
                tempo: 140,
                dynamics: 'forte',
                articulation: 'staccato'
            },
            calm: {
                scale: 'major',
                tempo: 60,
                dynamics: 'piano',
                articulation: 'legato'
            },
            curious: {
                scale: 'mixolydian',
                tempo: 100,
                dynamics: 'mezzoForte',
                articulation: 'tenuto'
            },
            sleepy: {
                scale: 'aeolian',
                tempo: 50,
                dynamics: 'pianissimo',
                articulation: 'legato'
            },
            alert: {
                scale: 'dorian',
                tempo: 120,
                dynamics: 'forte',
                articulation: 'marcato'
            },
            pleased: {
                scale: 'majorPentatonic',
                tempo: 90,
                dynamics: 'mezzoForte',
                articulation: 'legato'
            },
            confused: {
                scale: 'wholeHalfDiminished',
                tempo: 80,
                dynamics: 'mezzoPiano',
                articulation: 'rubato'
            },
            energetic: {
                scale: 'bebopMajor',
                tempo: 160,
                dynamics: 'fortissimo',
                articulation: 'staccato'
            },
            melancholy: {
                scale: 'harmonicMinor',
                tempo: 70,
                dynamics: 'mezzoPiano',
                articulation: 'legato'
            },
            playful: {
                scale: 'blues',
                tempo: 110,
                dynamics: 'mezzoForte',
                articulation: 'swing'
            }
        };
        
        // Common chord progressions
        this.PROGRESSIONS = {
            // Pop/Rock progressions
            I_V_vi_IV: [1, 5, 6, 4],           // Most common pop progression
            I_IV_V: [1, 4, 5],                 // Classic rock/blues
            ii_V_I: [2, 5, 1],                 // Jazz standard
            I_vi_IV_V: [1, 6, 4, 5],           // 50s doo-wop
            vi_IV_I_V: [6, 4, 1, 5],           // Alternative pop
            
            // Jazz progressions
            I_VI_ii_V: [1, 6, 2, 5],           // Rhythm changes A
            iii_vi_ii_V: [3, 6, 2, 5],         // Turnaround
            I_ii_iii_IV: [1, 2, 3, 4],         // Modal jazz
            
            // Blues progressions
            I_I_I_I_IV_IV_I_I_V_IV_I_V: [1, 1, 1, 1, 4, 4, 1, 1, 5, 4, 1, 5], // 12-bar blues
            
            // Modal progressions
            i_VII_VI_VII: [1, 7, 6, 7],        // Aeolian vamp
            I_II_IV_I: [1, 2, 4, 1],           // Lydian progression
        };
    }
    
    /**
     * Convert note name to MIDI note number
     * @param {string} note - Note name (e.g., 'C4', 'A#3')
     * @returns {number} MIDI note number
     */
    noteToMidi(note) {
        const noteName = note.slice(0, -1);
        const octave = parseInt(note.slice(-1), 10);
        const noteIndex = this.NOTES.indexOf(noteName);
        
        if (noteIndex === -1) {
            throw new Error(`Invalid note: ${note}`);
        }
        
        // C4 = MIDI 60
        return (octave + 1) * 12 + noteIndex;
    }
    
    /**
     * Convert MIDI note number to frequency
     * @param {number} midiNote - MIDI note number
     * @returns {number} Frequency in Hz
     */
    midiToFrequency(midiNote) {
        // f = 440 * 2^((n - 69) / 12)
        return this.A4_FREQUENCY * Math.pow(2, (midiNote - 69) / 12);
    }
    
    /**
     * Convert note name to frequency
     * @param {string} note - Note name (e.g., 'C4', 'A#3')
     * @returns {number} Frequency in Hz
     */
    noteToFrequency(note) {
        return this.midiToFrequency(this.noteToMidi(note));
    }
    
    /**
     * Generate a scale from a root note
     * @param {string} root - Root note (e.g., 'C4')
     * @param {string} scaleType - Scale type from SCALES
     * @returns {Array} Array of frequencies
     */
    generateScale(root, scaleType = 'major') {
        const scale = this.SCALES[scaleType];
        if (!scale) {
            throw new Error(`Unknown scale type: ${scaleType}`);
        }
        
        const rootMidi = this.noteToMidi(root);
        return scale.map(interval => this.midiToFrequency(rootMidi + interval));
    }
    
    /**
     * Generate a chord from a root note
     * @param {string} root - Root note (e.g., 'C4')
     * @param {string} chordType - Chord type from CHORDS
     * @returns {Array} Array of frequencies
     */
    generateChord(root, chordType = 'major') {
        const chord = this.CHORDS[chordType];
        if (!chord) {
            throw new Error(`Unknown chord type: ${chordType}`);
        }
        
        const rootMidi = this.noteToMidi(root);
        return chord.map(interval => this.midiToFrequency(rootMidi + interval));
    }
    
    /**
     * Generate a chord progression
     * @param {string} key - Key center (e.g., 'C4')
     * @param {string} scaleType - Scale type for the key
     * @param {Array} progression - Array of scale degrees
     * @returns {Array} Array of chord arrays
     */
    generateProgression(key, scaleType = 'major', progression = this.PROGRESSIONS.I_V_vi_IV) {
        const scale = this.generateScale(key, scaleType);
        const chords = [];
        
        for (const degree of progression) {
            const chordRoot = scale[(degree - 1) % scale.length];
            
            // Determine chord quality based on scale degree
            let chordType = 'major';
            if (scaleType === 'major') {
                if (degree === 2 || degree === 3 || degree === 6) {
                    chordType = 'minor';
                } else if (degree === 7) {
                    chordType = 'diminished';
                }
            } else if (scaleType === 'naturalMinor') {
                if (degree === 1 || degree === 4 || degree === 5) {
                    chordType = 'minor';
                } else if (degree === 2) {
                    chordType = 'diminished';
                } else {
                    chordType = 'major';
                }
            }
            
            // Convert frequency back to note for chord generation
            const midiNote = Math.round(12 * Math.log2(chordRoot / this.A4_FREQUENCY) + 69);
            const octave = Math.floor(midiNote / 12) - 1;
            const noteIndex = midiNote % 12;
            const noteName = this.NOTES[noteIndex] + octave;
            
            chords.push({
                degree,
                root: chordRoot,
                frequencies: this.generateChord(noteName, chordType),
                type: chordType
            });
        }
        
        return chords;
    }
    
    /**
     * Get musical parameters for an emotion
     * @param {string} emotion - Emotion name
     * @returns {Object} Musical parameters
     */
    getEmotionMusic(emotion) {
        return this.EMOTION_MODES[emotion] || this.EMOTION_MODES.calm;
    }
    
    /**
     * Generate Circle of Fifths progression
     * @param {string} startNote - Starting note
     * @param {number} steps - Number of steps around the circle
     * @param {boolean} clockwise - Direction (true = sharps, false = flats)
     * @returns {Array} Array of note names
     */
    circleOfFifths(startNote = 'C', steps = 12, clockwise = true) {
        const noteBase = startNote.replace(/\d/, '');
        let currentIndex = this.NOTES.indexOf(noteBase);
        const notes = [startNote];
        
        for (let i = 1; i < steps; i++) {
            // Perfect fifth = 7 semitones (clockwise) or 5 semitones (counter-clockwise)
            currentIndex = clockwise ? 
                (currentIndex + 7) % 12 : 
                (currentIndex + 5) % 12;
            
            notes.push(this.NOTES[currentIndex]);
        }
        
        return notes;
    }
    
    /**
     * Analyze interval between two notes
     * @param {string} note1 - First note
     * @param {string} note2 - Second note
     * @returns {Object} Interval information
     */
    analyzeInterval(note1, note2) {
        const midi1 = this.noteToMidi(note1);
        const midi2 = this.noteToMidi(note2);
        const semitones = Math.abs(midi2 - midi1);
        
        // Find interval name
        let intervalName = 'unknown';
        for (const [name, value] of Object.entries(this.INTERVALS)) {
            if (value === semitones % 12) {
                intervalName = name;
                break;
            }
        }
        
        return {
            semitones,
            intervalName,
            octaves: Math.floor(semitones / 12),
            consonant: [0, 3, 4, 5, 7, 8, 9, 12].includes(semitones % 12),
            ratio: this.getIntervalRatio(semitones % 12)
        };
    }
    
    /**
     * Get frequency ratio for an interval
     * @param {number} semitones - Number of semitones
     * @returns {string} Simplified ratio
     */
    getIntervalRatio(semitones) {
        const ratios = {
            0: '1:1',    // Unison
            1: '16:15',  // Minor second
            2: '9:8',    // Major second
            3: '6:5',    // Minor third
            4: '5:4',    // Major third
            5: '4:3',    // Perfect fourth
            6: '45:32',  // Tritone
            7: '3:2',    // Perfect fifth
            8: '8:5',    // Minor sixth
            9: '5:3',    // Major sixth
            10: '16:9',  // Minor seventh
            11: '15:8',  // Major seventh
            12: '2:1'    // Octave
        };
        
        return ratios[semitones] || 'complex';
    }
    
    /**
     * Generate a melody based on parameters
     * @param {Object} params - Melody parameters
     * @returns {Array} Array of note objects with timing
     */
    generateMelody(params = {}) {
        const {
            key = 'C4',
            scale = 'major',
            length = 8,
            stepProbability = 0.7,  // Probability of stepwise motion
            restProbability = 0.1    // Probability of rest
        } = params;
        
        const scaleNotes = this.generateScale(key, scale);
        const melody = [];
        let currentIndex = 0;
        
        for (let i = 0; i < length; i++) {
            // Decide if this is a rest
            if (Math.random() < restProbability) {
                melody.push({ frequency: 0, duration: 0.25, isRest: true });
                continue;
            }
            
            // Decide step size
            let nextIndex;
            if (Math.random() < stepProbability) {
                // Stepwise motion
                const direction = Math.random() < 0.5 ? -1 : 1;
                nextIndex = Math.max(0, Math.min(scaleNotes.length - 1, currentIndex + direction));
            } else {
                // Leap
                const leap = Math.floor(Math.random() * 3) + 2; // 2-4 scale degrees
                const direction = Math.random() < 0.5 ? -1 : 1;
                nextIndex = Math.max(0, Math.min(scaleNotes.length - 1, currentIndex + (leap * direction)));
            }
            
            currentIndex = nextIndex;
            
            // Random duration
            const durations = [0.25, 0.5, 0.75, 1];
            const duration = durations[Math.floor(Math.random() * durations.length)];
            
            melody.push({
                frequency: scaleNotes[currentIndex],
                duration,
                isRest: false
            });
        }
        
        return melody;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ♬ ♭ ♮ ♯  HARMONIC SYSTEM  ♯ ♮ ♭ ♬                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Harmonic System - Real-time Musical Intelligence
 * @author Emotive Engine Team
 * @version 1.0.0
 * @module HarmonicSystem
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The CONDUCTOR of musical experiences. Orchestrates the music theory system with   
 * ║ the sound engine to create emotionally-responsive, harmonically-rich audio that   
 * ║ adapts in real-time to mascot states and user interactions.                       
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 HARMONIC FEATURES                                                              
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Real-time harmonic generation                                                   
 * │ • Emotion-driven key modulation                                                   
 * │ • Adaptive tempo and dynamics                                                     
 * │ • Gesture-to-chord mapping                                                        
 * │ • Harmonic tension and release                                                    
 * │ • Polyrhythmic patterns                                                           
 * │ • Voice leading and smooth transitions                                            
 * │ • Ambient pad generation                                                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class HarmonicSystem {
    constructor(audioContext) {
        this.audioContext = audioContext;
        this.musicTheory = new MusicTheory();
        
        // Current musical state
        this.currentKey = 'C4';
        this.currentScale = 'major';
        this.currentTempo = 120; // BPM
        this.currentEmotion = 'calm';
        
        // Active voices (oscillators and gains)
        this.voices = new Map();
        
        // Harmonic layers
        this.layers = {
            bass: { active: false, gain: 0.3 },
            chord: { active: false, gain: 0.2 },
            melody: { active: false, gain: 0.4 },
            pad: { active: false, gain: 0.15 }
        };
        
        // Master output
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.audioContext.destination);
        
        // Effects chain
        this.reverb = this.createReverb();
        this.delay = this.createDelay();
        this.filter = this.createFilter();
        
        // Connect effects
        this.filter.connect(this.delay);
        this.delay.connect(this.reverb);
        this.reverb.connect(this.masterGain);
        
        // Dry signal path
        this.dryGain = this.audioContext.createGain();
        this.dryGain.gain.value = 0.7;
        this.dryGain.connect(this.masterGain);
        
        // Wet signal path
        this.wetGain = this.audioContext.createGain();
        this.wetGain.gain.value = 0.3;
        this.wetGain.connect(this.filter);
        
        // Rhythm tracking
        this.nextNoteTime = 0;
        this.noteResolution = 0; // 0 = 16th, 1 = 8th, 2 = quarter
        this.noteLength = 0.05; // Length of "beep" (staccato)
        
        // Sequence tracking
        this.currentChordIndex = 0;
        this.currentMelodyNote = 0;
        this.progression = null;
        
        // Performance optimization
        this.isPlaying = false;
        this.lookahead = 25.0; // How frequently to call scheduling function (ms)
        this.scheduleAheadTime = 0.1; // How far ahead to schedule audio (sec)
    }
    
    /**
     * Create reverb effect using convolver
     */
    createReverb() {
        const convolver = this.audioContext.createConvolver();
        const length = this.audioContext.sampleRate * 2; // 2 second reverb
        const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                // Exponential decay
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }
        }
        
        convolver.buffer = impulse;
        return convolver;
    }
    
    /**
     * Create delay effect
     */
    createDelay() {
        const delay = this.audioContext.createDelay(1.0);
        delay.delayTime.value = 0.15; // 150ms delay
        
        const feedback = this.audioContext.createGain();
        feedback.gain.value = 0.3;
        
        delay.connect(feedback);
        feedback.connect(delay);
        
        return delay;
    }
    
    /**
     * Create filter for tone shaping
     */
    createFilter() {
        const filter = this.audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000;
        filter.Q.value = 1;
        return filter;
    }
    
    /**
     * Update emotion and adapt musical parameters
     */
    setEmotion(emotion) {
        this.currentEmotion = emotion;
        const musicParams = this.musicTheory.getEmotionMusic(emotion);
        
        // Update scale and tempo
        this.currentScale = musicParams.scale;
        this.currentTempo = musicParams.tempo;
        
        // Adapt filter based on emotion
        const filterSettings = {
            excited: { freq: 4000, Q: 2 },
            calm: { freq: 1500, Q: 0.7 },
            curious: { freq: 2500, Q: 1.5 },
            sleepy: { freq: 800, Q: 0.5 },
            alert: { freq: 3000, Q: 1.8 },
            energetic: { freq: 5000, Q: 2.5 }
        };
        
        const settings = filterSettings[emotion] || { freq: 2000, Q: 1 };
        this.filter.frequency.exponentialRampToValueAtTime(
            settings.freq,
            this.audioContext.currentTime + 0.5
        );
        this.filter.Q.linearRampToValueAtTime(
            settings.Q,
            this.audioContext.currentTime + 0.5
        );
        
        // Generate new progression for this emotion
        this.generateEmotionProgression();
    }
    
    /**
     * Generate chord progression based on current emotion
     */
    generateEmotionProgression() {
        const progressionMap = {
            excited: 'I_V_vi_IV',
            calm: 'I_vi_IV_V',
            curious: 'ii_V_I',
            sleepy: 'vi_IV_I_V',
            alert: 'I_IV_V',
            energetic: 'I_V_vi_IV'
        };
        
        const progressionType = progressionMap[this.currentEmotion] || 'I_V_vi_IV';
        this.progression = this.musicTheory.generateProgression(
            this.currentKey,
            this.currentScale,
            this.musicTheory.PROGRESSIONS[progressionType]
        );
    }
    
    /**
     * Play a chord with voice leading
     */
    playChord(frequencies, duration = 1.0, attack = 0.01) {
        const startTime = this.audioContext.currentTime;
        const chordGain = this.audioContext.createGain();
        
        // ADSR envelope
        chordGain.gain.setValueAtTime(0, startTime);
        chordGain.gain.linearRampToValueAtTime(this.layers.chord.gain, startTime + attack);
        chordGain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
        
        // Connect to wet/dry mix
        chordGain.connect(this.dryGain);
        chordGain.connect(this.wetGain);
        
        // Create oscillators for each note
        const oscillators = frequencies.map((freq, index) => {
            const osc = this.audioContext.createOscillator();
            osc.frequency.value = freq;
            
            // Different waveforms for different voices
            if (index === 0) osc.type = 'sine';        // Root
            else if (index === 1) osc.type = 'triangle'; // Third
            else osc.type = 'sawtooth';                // Fifth and extensions
            
            // Slight detuning for richness
            osc.detune.value = (Math.random() - 0.5) * 10;
            
            osc.connect(chordGain);
            osc.start(startTime);
            osc.stop(startTime + duration);
            
            return osc;
        });
        
        // Store for potential manipulation
        const chordId = `chord_${Date.now()}`;
        this.voices.set(chordId, { oscillators, gain: chordGain });
        
        // Cleanup
        setTimeout(() => {
            this.voices.delete(chordId);
        }, (duration + 0.1) * 1000);
    }
    
    /**
     * Play a melodic sequence
     */
    playMelody(notes, baseTime = 0) {
        const startTime = baseTime || this.audioContext.currentTime;
        let currentTime = startTime;
        
        notes.forEach((note, index) => {
            if (note.isRest) {
                currentTime += note.duration;
                return;
            }
            
            const osc = this.audioContext.createOscillator();
            const noteGain = this.audioContext.createGain();
            
            osc.frequency.value = note.frequency;
            osc.type = 'sine';
            
            // Vibrato for expressiveness
            const vibrato = this.audioContext.createOscillator();
            const vibratoGain = this.audioContext.createGain();
            vibrato.frequency.value = 5; // 5 Hz vibrato
            vibratoGain.gain.value = 5; // 5 cents depth
            
            vibrato.connect(vibratoGain);
            vibratoGain.connect(osc.frequency);
            
            // Note envelope
            noteGain.gain.setValueAtTime(0, currentTime);
            noteGain.gain.linearRampToValueAtTime(this.layers.melody.gain, currentTime + 0.01);
            noteGain.gain.exponentialRampToValueAtTime(0.01, currentTime + note.duration * 0.9);
            
            osc.connect(noteGain);
            noteGain.connect(this.dryGain);
            noteGain.connect(this.wetGain);
            
            osc.start(currentTime);
            osc.stop(currentTime + note.duration);
            vibrato.start(currentTime);
            vibrato.stop(currentTime + note.duration);
            
            currentTime += note.duration;
        });
    }
    
    /**
     * Create ambient pad layer
     */
    createPad(frequency, duration = 4.0) {
        const startTime = this.audioContext.currentTime;
        const voices = 4; // Number of detuned voices
        const padGain = this.audioContext.createGain();
        
        // Slow attack and release for pad
        padGain.gain.setValueAtTime(0, startTime);
        padGain.gain.linearRampToValueAtTime(this.layers.pad.gain, startTime + 1.0);
        padGain.gain.linearRampToValueAtTime(this.layers.pad.gain, startTime + duration - 1.0);
        padGain.gain.linearRampToValueAtTime(0, startTime + duration);
        
        padGain.connect(this.wetGain); // Pads sound better with effects
        
        for (let i = 0; i < voices; i++) {
            const osc = this.audioContext.createOscillator();
            osc.frequency.value = frequency;
            osc.type = 'sawtooth';
            
            // Detune each voice
            osc.detune.value = (i - voices / 2) * 15;
            
            // Individual voice gain for stereo spread
            const voiceGain = this.audioContext.createGain();
            voiceGain.gain.value = 1 / voices;
            
            // Add slow LFO for movement
            const lfo = this.audioContext.createOscillator();
            const lfoGain = this.audioContext.createGain();
            lfo.frequency.value = 0.2 + (i * 0.1); // Slightly different LFO rates
            lfoGain.gain.value = 10; // Subtle pitch modulation
            
            lfo.connect(lfoGain);
            lfoGain.connect(osc.frequency);
            
            osc.connect(voiceGain);
            voiceGain.connect(padGain);
            
            osc.start(startTime);
            osc.stop(startTime + duration);
            lfo.start(startTime);
            lfo.stop(startTime + duration);
        }
    }
    
    /**
     * Map gesture to musical response
     */
    playGestureSound(gesture) {
        const gestureMap = {
            breathe: () => {
                // Breathing creates slow, expanding chords
                const chord = this.musicTheory.generateChord(this.currentKey, 'maj7');
                this.playChord(chord, 2.0, 0.5);
                this.createPad(chord[0] / 2, 3.0); // Sub bass pad
            },
            
            excited: () => {
                // Excited creates ascending arpeggios
                const scale = this.musicTheory.generateScale(this.currentKey, 'lydian');
                const arpeggio = scale.map((freq, i) => ({
                    frequency: freq,
                    duration: 0.1,
                    isRest: false
                }));
                this.playMelody(arpeggio);
            },
            
            wave: () => {
                // Wave creates a glissando effect
                const startFreq = this.musicTheory.noteToFrequency(this.currentKey);
                const endFreq = startFreq * 2; // Octave up
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.frequency.setValueAtTime(startFreq, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(endFreq, this.audioContext.currentTime + 0.5);
                osc.frequency.exponentialRampToValueAtTime(startFreq, this.audioContext.currentTime + 1.0);
                
                gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.1);
                gain.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.9);
                gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 1.0);
                
                osc.connect(gain);
                gain.connect(this.wetGain);
                
                osc.start();
                osc.stop(this.audioContext.currentTime + 1.0);
            },
            
            morph: () => {
                // Morph creates harmonic morphing between chords
                const chord1 = this.musicTheory.generateChord(this.currentKey, 'minor');
                const chord2 = this.musicTheory.generateChord(this.currentKey, 'major');
                
                // Play first chord
                this.playChord(chord1, 0.5);
                
                // Morph to second chord
                setTimeout(() => {
                    this.playChord(chord2, 1.0);
                }, 400);
            },
            
            jump: () => {
                // Jump creates staccato chord stabs
                const chord = this.musicTheory.generateChord(this.currentKey, 'dom7');
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        this.playChord(chord.map(f => f * Math.pow(2, i/12)), 0.1, 0.001);
                    }, i * 100);
                }
            },
            
            curious: () => {
                // Curious creates questioning melodic phrases
                const melody = this.musicTheory.generateMelody({
                    key: this.currentKey,
                    scale: 'mixolydian',
                    length: 5,
                    stepProbability: 0.3
                });
                this.playMelody(melody);
            }
        };
        
        const soundFunction = gestureMap[gesture];
        if (soundFunction) {
            soundFunction();
        }
    }
    
    /**
     * Start background harmony generation
     */
    startHarmony() {
        if (this.isPlaying) return;
        
        this.isPlaying = true;
        this.currentChordIndex = 0;
        this.nextNoteTime = this.audioContext.currentTime;
        
        // Generate initial progression
        this.generateEmotionProgression();
        
        // Start the scheduling loop
        this.scheduleHarmony();
    }
    
    /**
     * Schedule harmony playback
     */
    scheduleHarmony() {
        if (!this.isPlaying) return;
        
        // Schedule notes that need to play in the next interval
        while (this.nextNoteTime < this.audioContext.currentTime + this.scheduleAheadTime) {
            // Play current chord in progression
            if (this.progression && this.layers.chord.active) {
                const chord = this.progression[this.currentChordIndex];
                this.playChord(chord.frequencies, 0.5);
                
                // Advance to next chord
                this.currentChordIndex = (this.currentChordIndex + 1) % this.progression.length;
            }
            
            // Generate and play bass line
            if (this.layers.bass.active && this.progression) {
                const bassNote = this.progression[this.currentChordIndex].frequencies[0] / 2;
                this.playBassNote(bassNote, 0.25);
            }
            
            // Advance time based on tempo
            const secondsPerBeat = 60.0 / this.currentTempo;
            this.nextNoteTime += 0.25 * secondsPerBeat; // 16th notes
        }
        
        // Continue scheduling
        setTimeout(() => this.scheduleHarmony(), this.lookahead);
    }
    
    /**
     * Play a bass note
     */
    playBassNote(frequency, duration) {
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.frequency.value = frequency;
        osc.type = 'sine';
        
        gain.gain.setValueAtTime(0, this.audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(this.layers.bass.gain, this.audioContext.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.dryGain);
        
        osc.start();
        osc.stop(this.audioContext.currentTime + duration);
    }
    
    /**
     * Stop harmony generation
     */
    stopHarmony() {
        this.isPlaying = false;
    }
    
    /**
     * Set layer active state
     */
    setLayerActive(layer, active) {
        if (this.layers[layer]) {
            this.layers[layer].active = active;
        }
    }
    
    /**
     * Set master volume
     */
    setMasterVolume(volume) {
        this.masterGain.gain.exponentialRampToValueAtTime(
            Math.max(0.01, volume),
            this.audioContext.currentTime + 0.1
        );
    }
    
    /**
     * Set wet/dry mix for effects
     */
    setEffectsMix(wetness) {
        const dry = 1 - wetness;
        this.dryGain.gain.linearRampToValueAtTime(dry, this.audioContext.currentTime + 0.1);
        this.wetGain.gain.linearRampToValueAtTime(wetness, this.audioContext.currentTime + 0.1);
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  SOUND SYSTEM  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Sound System - Web Audio API Integration for Emotional Audio
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module SoundSystem
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Adds the VOICE of emotion through sound. Generates ambient tones that match       
 * ║ emotional states and plays gesture sound effects. Uses Web Audio API for          
 * ║ programmatic sound generation - no external audio files needed!                   
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎵 AUDIO FEATURES                                                                  
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Emotional ambient tones (frequency based on emotion)                            
 * │ • Gesture sound effects (pops, sweeps, chimes)                                    
 * │ • Volume control with fade in/out                                                 
 * │ • Warning throttling to reduce console spam                                       
 * │ • Graceful degradation if Web Audio unavailable                                   
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎼 EMOTIONAL TONE MAPPING                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ EMOTION        FREQUENCY    WAVEFORM    VOLUME                                   
 * │ neutral        220Hz        sine        0.1                                      
 * │ joy            440Hz        sine        0.15                                     
 * │ sadness        110Hz        sine        0.08                                     
 * │ anger          330Hz        sawtooth    0.2                                      
 * │ fear           550Hz        square      0.12                                     
 * │ love           262Hz        sine        0.12                                     
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class SoundSystem {
    constructor() {
        this.context = null;
        this.isEnabled = false;
        this.isInitialized = false;
    
        // Audio nodes
        this.nodes = {
            master: null,      // Master gain node
            ambient: null,     // Ambient oscillator for emotional tones
            effects: null      // Effects gain node for gesture sounds
        };
    
        // Harmonic system for musical intelligence
        this.harmonicSystem = null;
        this.useHarmonicSystem = false; // Toggle between old and new system
    
        // Track warning frequency to reduce spam
        this.warningTimestamps = {};
        this.warningThrottle = 5000; // Only show same warning every 5 seconds
    
        // Current ambient oscillator
        this.currentOscillator = null;
        this.currentGain = null;
    
        // Default settings
        this.masterVolume = 0.5;
        this.ambientVolume = 0.1;
    
        // Emotional tone mappings
        this.emotionalTones = new Map([
            ['neutral', { frequency: 220, waveform: 'sine', volume: 0.1 }],
            ['joy', { frequency: 440, waveform: 'triangle', volume: 0.15 }],
            ['sadness', { frequency: 165, waveform: 'sine', volume: 0.08 }],
            ['anger', { frequency: 330, waveform: 'sawtooth', volume: 0.12 }],
            ['fear', { frequency: 880, waveform: 'square', volume: 0.09 }],
            ['surprise', { frequency: 660, waveform: 'triangle', volume: 0.13 }],
            ['disgust', { frequency: 110, waveform: 'sawtooth', volume: 0.07 }],
            ['love', { frequency: 528, waveform: 'sine', volume: 0.11 }]
        ]);
    }

    /**
   * Initialize Web Audio API and create node architecture
   * @returns {boolean} Success status
   */
    initialize() {
        try {
            // Check for Web Audio API support
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (!AudioContextClass) {
                // SoundSystem: Web Audio API not supported, continuing without audio
                return false;
            }

            // Create audio context
            this.context = new AudioContextClass();
      
            // Initialize harmonic system
            this.harmonicSystem = new HarmonicSystem(this.context);

            // Create master gain node with default volume
            this.nodes.master = this.context.createGain();
            this.nodes.master.gain.setValueAtTime(this.masterVolume, this.context.currentTime);
            this.nodes.master.connect(this.context.destination);

            // Create effects gain node for gesture sounds
            this.nodes.effects = this.context.createGain();
            this.nodes.effects.gain.setValueAtTime(1.0, this.context.currentTime);
            this.nodes.effects.connect(this.nodes.master);

            this.isEnabled = true;
            this.isInitialized = true;
      
            // SoundSystem: Successfully initialized Web Audio API
            return true;

        } catch (error) {
            // SoundSystem: Failed to initialize Web Audio API
            this.isEnabled = false;
            return false;
        }
    }

    /**
   * Resume audio context if suspended (call on user interaction)
   */
    async resumeContext() {
        if (this.context && this.context.state === 'suspended') {
            try {
                await this.context.resume();
                // Silently resume without logging
            } catch (error) {
                // Silently fail - this is expected before user interaction
            }
        }
    }

    /**
   * Set master volume for all audio output
   * @param {number} volume - Volume level (0.0 to 1.0)
   * @param {string} currentEmotion - Current emotion for ambient tone volume update
   */
    setMasterVolume(volume, currentEmotion = null) {
        this.masterVolume = Math.max(0, Math.min(1, volume));
    
        if (this.isEnabled && this.nodes.master) {
            this.nodes.master.gain.setValueAtTime(
                this.masterVolume, 
                this.context.currentTime
            );

            // Update ambient tone volume if active
            if (currentEmotion) {
                this.updateAmbientVolume(currentEmotion);
            }
        }
    }

    /**
   * Get current master volume
   * @returns {number} Current master volume
   */
    getMasterVolume() {
        return this.masterVolume;
    }

    /**
   * Check if sound system is available and enabled
   * @returns {boolean} Availability status
   */
    isAvailable() {
        return this.isEnabled && this.isInitialized;
    }
  
    /**
   * Enable or disable the harmonic music system
   * @param {boolean} enabled - Whether to enable harmonic system
   */
    setHarmonicMode(enabled) {
        this.useHarmonicSystem = enabled;
    
        if (enabled && this.harmonicSystem) {
            // Stop simple ambient tone when switching to harmonic mode
            this.stopAmbientTone();
            // SoundSystem: Switched to harmonic music mode
        } else if (!enabled && this.harmonicSystem) {
            // Stop harmonic system when switching back
            this.harmonicSystem.stopHarmony();
            // SoundSystem: Switched to simple sound mode
        }
    }
  
    /**
   * Start harmonic background music
   */
    startHarmony() {
        if (this.harmonicSystem && this.useHarmonicSystem && this.isAvailable()) {
            this.harmonicSystem.startHarmony();
        }
    }
  
    /**
   * Stop harmonic background music
   */
    stopHarmony() {
        if (this.harmonicSystem) {
            this.harmonicSystem.stopHarmony();
        }
    }
  
    /**
   * Set harmonic layer active state
   * @param {string} layer - Layer name (bass, chord, melody, pad)
   * @param {boolean} active - Whether layer should be active
   */
    setHarmonicLayer(layer, active) {
        if (this.harmonicSystem) {
            this.harmonicSystem.setLayerActive(layer, active);
        }
    }
  
    /**
   * Set harmonic effects mix
   * @param {number} wetness - Wet/dry mix (0-1)
   */
    setHarmonicEffects(wetness) {
        if (this.harmonicSystem) {
            this.harmonicSystem.setEffectsMix(wetness);
        }
    }

    /**
   * Clean up audio resources
   */
    cleanup() {
        try {
            // Stop current ambient oscillator
            if (this.currentOscillator) {
                this.currentOscillator.stop();
                this.currentOscillator = null;
            }
      
            if (this.currentGain) {
                this.currentGain = null;
            }

            // Close audio context
            if (this.context && this.context.state !== 'closed') {
                this.context.close();
            }

            // SoundSystem: Cleaned up audio resources
        } catch (error) {
            // SoundSystem: Error during cleanup
        } finally {
            // Always reset state regardless of errors
            this.context = null;
            this.nodes = { master: null, ambient: null, effects: null };
            this.currentOscillator = null;
            this.currentGain = null;
            this.isEnabled = false;
            this.isInitialized = false;
        }
    }

    /**
   * Get emotional tone configuration for given emotion
   * @param {string} emotion - Emotion name
   * @returns {Object|null} Tone configuration or null if not found
   */
    getEmotionalTone(emotion) {
        return this.emotionalTones.get(emotion) || null;
    }

    /**
   * Start ambient emotional tone for given emotion
   * @param {string} emotion - Emotion name
   * @param {number} transitionDuration - Transition duration in milliseconds (default: 500)
   */
    setAmbientTone(emotion, transitionDuration = 500) {
        if (!this.isAvailable()) {
            return;
        }

        // Use harmonic system if enabled
        if (this.useHarmonicSystem && this.harmonicSystem) {
            this.harmonicSystem.setEmotion(emotion);
            return;
        }

        const toneConfig = this.getEmotionalTone(emotion);
        if (!toneConfig) {
            // SoundSystem: Unknown emotion, cannot set ambient tone
            return;
        }

        try {
            // Resume context if suspended
            this.resumeContext();

            const {currentTime} = this.context;
            const transitionTime = transitionDuration / 1000; // Convert to seconds

            // Stop current oscillator with fade out
            if (this.currentOscillator && this.currentGain) {
                this.currentGain.gain.exponentialRampToValueAtTime(0.001, currentTime + transitionTime * 0.5);
                this.currentOscillator.stop(currentTime + transitionTime * 0.5);
            }

            // Create new oscillator and gain for the new tone
            const oscillator = this.context.createOscillator();
            const gainNode = this.context.createGain();

            // Configure oscillator
            oscillator.type = toneConfig.waveform;
            oscillator.frequency.setValueAtTime(toneConfig.frequency, currentTime);

            // Configure gain with smooth transition
            const targetVolume = toneConfig.volume * this.masterVolume;
            gainNode.gain.setValueAtTime(0.001, currentTime); // Start silent
            gainNode.gain.exponentialRampToValueAtTime(targetVolume, currentTime + transitionTime);

            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(this.nodes.master);

            // Start oscillator
            oscillator.start(currentTime);

            // Store references
            this.currentOscillator = oscillator;
            this.currentGain = gainNode;

            // SoundSystem: Started ambient tone

        } catch (error) {
            // SoundSystem: Failed to set ambient tone
        }
    }

    /**
   * Stop current ambient tone
   * @param {number} fadeOutDuration - Fade out duration in milliseconds (default: 500)
   */
    stopAmbientTone(fadeOutDuration = 500) {
        if (!this.isAvailable() || !this.currentOscillator) {
            return;
        }

        try {
            const {currentTime} = this.context;
            const fadeTime = fadeOutDuration / 1000; // Convert to seconds

            // Fade out current tone
            if (this.currentGain) {
                this.currentGain.gain.exponentialRampToValueAtTime(0.001, currentTime + fadeTime);
            }

            // Stop oscillator after fade
            this.currentOscillator.stop(currentTime + fadeTime);

            // Clear references
            this.currentOscillator = null;
            this.currentGain = null;

            // SoundSystem: Stopped ambient tone

        } catch (error) {
            // SoundSystem: Failed to stop ambient tone
        }
    }

    /**
   * Update ambient tone volume based on master volume changes
   * @param {string} currentEmotion - Current emotion for volume calculation
   */
    updateAmbientVolume(currentEmotion) {
        if (!this.isAvailable() || !this.currentGain || !currentEmotion) {
            return;
        }

        const toneConfig = this.getEmotionalTone(currentEmotion);
        if (!toneConfig) {
            return;
        }

        try {
            const targetVolume = toneConfig.volume * this.masterVolume;
            const {currentTime} = this.context;
      
            this.currentGain.gain.exponentialRampToValueAtTime(targetVolume, currentTime + 0.1);
        } catch (error) {
            // SoundSystem: Failed to update ambient volume
        }
    }

    /**
   * Play gesture sound effect with frequency envelope
   * @param {string} gestureId - Gesture identifier
   * @param {string} emotionalContext - Current emotion for intensity modifiers
   */
    playGestureSound(gestureId, emotionalContext = 'neutral') {
        if (!this.isAvailable()) {
            return;
        }

        // Use harmonic system if enabled
        if (this.useHarmonicSystem && this.harmonicSystem) {
            this.harmonicSystem.playGestureSound(gestureId);
            return;
        }

        const soundConfig = this.getGestureSoundConfig(gestureId);
        if (!soundConfig) {
            // Throttled warning for unknown gestures
            this.throttledWarn(`Unknown gesture "${gestureId}", cannot play sound`, `gesture_${gestureId}`);
            return;
        }

        try {
            // Resume context if suspended
            this.resumeContext();

            const {currentTime} = this.context;
            const duration = soundConfig.duration / 1000; // Convert to seconds

            // Apply emotional modifiers
            const modifiers = this.getEmotionalModifiers(emotionalContext);
            const baseVolume = soundConfig.volume * this.masterVolume * modifiers.intensity;

            // Create oscillator and gain for the effect
            const oscillator = this.context.createOscillator();
            const gainNode = this.context.createGain();

            // Configure oscillator
            oscillator.type = soundConfig.waveform;

            // Apply frequency envelope
            this.applyFrequencyEnvelope(oscillator, soundConfig.frequencyEnvelope, currentTime, duration);

            // Apply volume envelope
            this.applyVolumeEnvelope(gainNode, soundConfig.volumeEnvelope, currentTime, duration, baseVolume);

            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(this.nodes.effects);

            // Start and stop oscillator
            oscillator.start(currentTime);
            oscillator.stop(currentTime + duration);

            // SoundSystem: Playing gesture sound

        } catch (error) {
            // SoundSystem: Failed to play gesture sound
        }
    }

    /**
   * Get gesture sound configuration
   * @param {string} gestureId - Gesture identifier
   * @returns {Object|null} Sound configuration or null if not found
   */
    getGestureSoundConfig(gestureId) {
        const gestureSounds = new Map([
            ['bounce', {
                duration: 100,
                waveform: 'triangle',
                volume: 0.3,
                frequencyEnvelope: [
                    { time: 0, frequency: 200 },
                    { time: 0.5, frequency: 400 },
                    { time: 1, frequency: 300 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 1.0 },
                    { time: 0.1, volume: 0.8 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['pulse', {
                duration: 300,
                waveform: 'sine',
                volume: 0.25,
                frequencyEnvelope: [
                    { time: 0, frequency: 300 },
                    { time: 0.5, frequency: 450 },
                    { time: 1, frequency: 300 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.3, volume: 1.0 },
                    { time: 0.7, volume: 1.0 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['shake', {
                duration: 200,
                waveform: 'sawtooth',
                volume: 0.2,
                frequencyEnvelope: [
                    { time: 0, frequency: 150 },
                    { time: 0.25, frequency: 200 },
                    { time: 0.5, frequency: 150 },
                    { time: 0.75, frequency: 200 },
                    { time: 1, frequency: 150 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.8 },
                    { time: 0.5, volume: 1.0 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['spin', {
                duration: 600,
                waveform: 'triangle',
                volume: 0.35,
                frequencyEnvelope: [
                    { time: 0, frequency: 220 },
                    { time: 0.3, frequency: 440 },
                    { time: 0.7, frequency: 660 },
                    { time: 1, frequency: 330 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.2, volume: 1.0 },
                    { time: 0.8, volume: 0.8 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['nod', {
                duration: 150,
                waveform: 'sine',
                volume: 0.15,
                frequencyEnvelope: [
                    { time: 0, frequency: 180 },
                    { time: 0.5, frequency: 220 },
                    { time: 1, frequency: 180 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.5 },
                    { time: 0.3, volume: 1.0 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['tilt', {
                duration: 200,
                waveform: 'triangle',
                volume: 0.18,
                frequencyEnvelope: [
                    { time: 0, frequency: 250 },
                    { time: 0.6, frequency: 350 },
                    { time: 1, frequency: 280 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.4, volume: 1.0 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['expand', {
                duration: 500,
                waveform: 'sine',
                volume: 0.4,
                frequencyEnvelope: [
                    { time: 0, frequency: 200 },
                    { time: 0.7, frequency: 500 },
                    { time: 1, frequency: 400 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.3, volume: 1.0 },
                    { time: 0.9, volume: 0.8 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['contract', {
                duration: 400,
                waveform: 'triangle',
                volume: 0.22,
                frequencyEnvelope: [
                    { time: 0, frequency: 400 },
                    { time: 0.8, frequency: 200 },
                    { time: 1, frequency: 180 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 1.0 },
                    { time: 0.6, volume: 0.8 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['flash', {
                duration: 200,
                waveform: 'square',
                volume: 0.3,
                frequencyEnvelope: [
                    { time: 0, frequency: 800 },
                    { time: 0.1, frequency: 1200 },
                    { time: 0.2, frequency: 800 },
                    { time: 1, frequency: 600 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.05, volume: 1.0 },
                    { time: 0.15, volume: 0.3 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['wave', {
                duration: 400,
                waveform: 'sine',
                volume: 0.25,
                frequencyEnvelope: [
                    { time: 0, frequency: 300 },
                    { time: 0.3, frequency: 500 },
                    { time: 0.6, frequency: 400 },
                    { time: 1, frequency: 350 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.2, volume: 0.8 },
                    { time: 0.7, volume: 0.6 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['breathe', {
                duration: 800,  // Slightly shorter for more impact
                waveform: 'triangle',  // Changed from sine for more harmonics
                volume: 0.6,  // Much louder
                frequencyEnvelope: [
                    { time: 0, frequency: 300 },
                    { time: 0.3, frequency: 500 },
                    { time: 0.5, frequency: 600 },
                    { time: 0.7, frequency: 400 },
                    { time: 1, frequency: 250 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.2 },  // Start with some volume
                    { time: 0.2, volume: 1.0 }, // Quick attack
                    { time: 0.5, volume: 0.9 }, // Strong sustain
                    { time: 0.8, volume: 0.7 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['morph', {
                duration: 600,
                waveform: 'triangle',
                volume: 0.3,
                frequencyEnvelope: [
                    { time: 0, frequency: 100 },
                    { time: 0.2, frequency: 300 },
                    { time: 0.5, frequency: 600 },
                    { time: 0.8, frequency: 400 },
                    { time: 1, frequency: 200 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.5 },
                    { time: 0.3, volume: 1.0 },
                    { time: 0.7, volume: 0.8 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['jump', {
                duration: 250,
                waveform: 'square',
                volume: 0.35,
                frequencyEnvelope: [
                    { time: 0, frequency: 200 },
                    { time: 0.2, frequency: 600 },
                    { time: 0.4, frequency: 800 },
                    { time: 0.8, frequency: 400 },
                    { time: 1, frequency: 100 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.8 },
                    { time: 0.1, volume: 1.0 },
                    { time: 0.3, volume: 0.6 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['drift', {
                duration: 800,
                waveform: 'sine',
                volume: 0.12,
                frequencyEnvelope: [
                    { time: 0, frequency: 160 },
                    { time: 0.4, frequency: 240 },
                    { time: 0.8, frequency: 200 },
                    { time: 1, frequency: 180 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.2, volume: 1.0 },
                    { time: 0.8, volume: 0.8 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['wave', {
                duration: 400,
                waveform: 'sine',
                volume: 0.25,
                frequencyEnvelope: [
                    { time: 0, frequency: 200 },
                    { time: 0.25, frequency: 300 },
                    { time: 0.5, frequency: 250 },
                    { time: 0.75, frequency: 280 },
                    { time: 1, frequency: 200 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.2, volume: 0.8 },
                    { time: 0.8, volume: 0.8 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['breathe', {
                duration: 3500,  // Match gesture duration
                waveform: 'sine',
                volume: 0.2,
                // Deep, calming breath sound - low frequencies
                frequencyEnvelope: [
                    { time: 0, frequency: 80 },    // Start low (exhale)
                    { time: 0.4, frequency: 150 },  // Rise during inhale
                    { time: 0.5, frequency: 160 },  // Peak at full inhale
                    { time: 0.9, frequency: 100 },  // Fall during exhale
                    { time: 1, frequency: 80 }      // Back to low
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.3 },     // Quiet start
                    { time: 0.4, volume: 0.8 },   // Louder inhale
                    { time: 0.5, volume: 0.7 },   // Hold
                    { time: 0.9, volume: 0.6 },   // Quieter exhale
                    { time: 1, volume: 0.2 }      // Fade out
                ]
            }],
            ['flicker', {
                duration: 300,
                waveform: 'square',
                volume: 0.2,
                frequencyEnvelope: [
                    { time: 0, frequency: 600 },
                    { time: 0.1, frequency: 400 },
                    { time: 0.2, frequency: 800 },
                    { time: 0.3, frequency: 300 },
                    { time: 0.5, frequency: 700 },
                    { time: 1, frequency: 500 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 1.0 },
                    { time: 0.1, volume: 0.2 },
                    { time: 0.2, volume: 0.9 },
                    { time: 0.3, volume: 0.3 },
                    { time: 0.5, volume: 0.8 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['vibrate', {
                duration: 250,
                waveform: 'sawtooth',
                volume: 0.3,
                frequencyEnvelope: [
                    { time: 0, frequency: 100 },
                    { time: 0.1, frequency: 150 },
                    { time: 0.2, frequency: 100 },
                    { time: 0.3, frequency: 150 },
                    { time: 0.4, frequency: 100 },
                    { time: 0.5, frequency: 150 },
                    { time: 0.6, frequency: 100 },
                    { time: 0.7, frequency: 150 },
                    { time: 1, frequency: 80 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 1.0 },
                    { time: 0.8, volume: 1.0 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['glow', {
                duration: 600,
                waveform: 'sine',
                volume: 0.15,
                frequencyEnvelope: [
                    { time: 0, frequency: 300 },
                    { time: 0.5, frequency: 500 },
                    { time: 1, frequency: 400 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.0 },
                    { time: 0.3, volume: 1.0 },
                    { time: 0.7, volume: 1.0 },
                    { time: 1, volume: 0.0 }
                ]
            }],
            ['stretch', {
                duration: 450,
                waveform: 'triangle',
                volume: 0.2,
                frequencyEnvelope: [
                    { time: 0, frequency: 250 },
                    { time: 0.3, frequency: 180 },
                    { time: 0.7, frequency: 320 },
                    { time: 1, frequency: 250 }
                ],
                volumeEnvelope: [
                    { time: 0, volume: 0.6 },
                    { time: 0.2, volume: 1.0 },
                    { time: 0.8, volume: 0.9 },
                    { time: 1, volume: 0.0 }
                ]
            }]
        ]);

        return gestureSounds.get(gestureId) || null;
    }

    /**
   * Apply frequency envelope to oscillator
   * @param {OscillatorNode} oscillator - Web Audio oscillator
   * @param {Array} envelope - Frequency envelope points
   * @param {number} startTime - Start time in audio context
   * @param {number} duration - Total duration in seconds
   */
    applyFrequencyEnvelope(oscillator, envelope, startTime, duration) {
        envelope.forEach(point => {
            const time = startTime + (point.time * duration);
            oscillator.frequency.linearRampToValueAtTime(point.frequency, time);
        });
    }

    /**
   * Apply volume envelope to gain node
   * @param {GainNode} gainNode - Web Audio gain node
   * @param {Array} envelope - Volume envelope points
   * @param {number} startTime - Start time in audio context
   * @param {number} duration - Total duration in seconds
   * @param {number} baseVolume - Base volume level
   */
    applyVolumeEnvelope(gainNode, envelope, startTime, duration, baseVolume) {
        envelope.forEach((point, index) => {
            const time = startTime + (point.time * duration);
            const volume = point.volume * baseVolume;
      
            if (index === 0) {
                gainNode.gain.setValueAtTime(volume, time);
            } else {
                gainNode.gain.linearRampToValueAtTime(volume, time);
            }
        });
    }

    /**
   * Get emotional modifiers for gesture sounds
   * @param {string} emotion - Current emotion
   * @returns {Object} Modifier values
   */
    getEmotionalModifiers(emotion) {
        const modifiers = new Map([
            ['neutral', { intensity: 1.0, speed: 1.0 }],
            ['joy', { intensity: 1.3, speed: 1.2 }],
            ['sadness', { intensity: 0.6, speed: 0.8 }],
            ['anger', { intensity: 1.5, speed: 1.4 }],
            ['fear', { intensity: 0.8, speed: 1.3 }],
            ['surprise', { intensity: 1.4, speed: 1.5 }],
            ['disgust', { intensity: 0.7, speed: 0.9 }],
            ['love', { intensity: 1.1, speed: 0.9 }]
        ]);

        return modifiers.get(emotion) || modifiers.get('neutral');
    }

    /**
   * Enable/disable quality reduction for performance
   * @param {boolean} enabled - Whether to reduce quality
   */
    setQualityReduction(enabled) {
        this.qualityReduction = enabled;
    
        if (enabled && this.audioContext) {
            // Reduce active oscillators
            this.maxOscillators = 2;
        } else {
            // Restore full quality
            this.maxOscillators = 4;
        }
    }
  
    /**
   * Check if Web Audio API is supported in current browser
   * @returns {boolean} Support status
   */
    static isSupported() {
        return !!(window.AudioContext || window.webkitAudioContext);
    }
  
    /**
   * Throttled warning to reduce console spam
   * @param {string} message - Warning message
   * @param {string} key - Unique key for this warning type
   */
    throttledWarn(message, key) {
        const now = Date.now();
        const lastWarning = this.warningTimestamps[key] || 0;
    
        if (now - lastWarning > this.warningThrottle) {
            // SoundSystem warning
            this.warningTimestamps[key] = now;
        }
    }
}

/**
 * Performance monitoring system for the Emotive Engine
 * Tracks FPS, memory usage, render times, and other metrics
 */

class PerformanceMonitor {
    constructor(options = {}) {
        this.enabled = options.enabled !== false;
        this.sampleInterval = options.sampleInterval || 1000; // 1 second
        this.maxSamples = options.maxSamples || 60; // Keep 1 minute of data
        this.enableMemoryTracking = options.enableMemoryTracking !== false;
        this.enableNetworkTracking = options.enableNetworkTracking !== false;

        this.metrics = {
            fps: { samples: [], current: 0, avg: 0, min: Infinity, max: 0 },
            frameTime: { samples: [], current: 0, avg: 0, min: Infinity, max: 0 },
            memory: { samples: [], current: 0, avg: 0, min: Infinity, max: 0 },
            renderTime: { samples: [], current: 0, avg: 0, min: Infinity, max: 0 },
            updateTime: { samples: [], current: 0, avg: 0, min: Infinity, max: 0 },
            particleCount: { samples: [], current: 0, avg: 0, min: Infinity, max: 0 },
            drawCalls: { samples: [], current: 0, avg: 0, min: Infinity, max: 0 },
            canvasOperations: { samples: [], current: 0, avg: 0, min: Infinity, max: 0 }
        };

        this.frameCount = 0;
        this.lastFrameTime = 0;
        this.lastSampleTime = 0;
        this.marks = new Map();
        this.measures = new Map();

        this.thresholds = {
            fps: { warning: 50, critical: 30 },
            frameTime: { warning: 20, critical: 33 },
            memory: { warning: 100, critical: 200 }, // MB
            renderTime: { warning: 10, critical: 16 },
            ...options.thresholds
        };

        this.callbacks = {
            onWarning: options.onWarning || null,
            onCritical: options.onCritical || null,
            onSample: options.onSample || null
        };

        if (this.enabled) {
            this.start();
        }
    }

    start() {
        if (!this.enabled) return;

        this.lastSampleTime = performance.now();
        this.lastFrameTime = performance.now();
        this.frameCount = 0;

        // Start sampling interval
        this.sampleIntervalId = setInterval(() => this.sample(), this.sampleInterval);
    }

    stop() {
        if (this.sampleIntervalId) {
            clearInterval(this.sampleIntervalId);
            this.sampleIntervalId = null;
        }
    }

    frame(timestamp = performance.now()) {
        if (!this.enabled) return;

        this.frameCount++;
        const deltaTime = timestamp - this.lastFrameTime;

        // Update frame time
        this.metrics.frameTime.current = deltaTime;

        // Calculate instant FPS
        if (deltaTime > 0) {
            this.metrics.fps.current = 1000 / deltaTime;
        }

        this.lastFrameTime = timestamp;
    }

    mark(name, timestamp = performance.now()) {
        if (!this.enabled) return;

        this.marks.set(name, timestamp);
    }

    measure(name, startMark, endMark = null) {
        if (!this.enabled) return 0;

        const startTime = this.marks.get(startMark);
        if (!startTime) return 0;

        const endTime = endMark ? this.marks.get(endMark) : performance.now();
        const duration = endTime - startTime;

        let measures = this.measures.get(name);
        if (!measures) {
            measures = [];
            this.measures.set(name, measures);
        }

        measures.push(duration);

        // Keep only recent measures
        if (measures.length > this.maxSamples) {
            measures.shift();
        }

        // Update specific metrics if they match known patterns
        if (name === 'render') {
            this.metrics.renderTime.current = duration;
        } else if (name === 'update') {
            this.metrics.updateTime.current = duration;
        }

        return duration;
    }

    recordMetric(name, value) {
        if (!this.enabled) return;

        if (this.metrics[name]) {
            this.metrics[name].current = value;
        }
    }

    sample() {
        const now = performance.now();
        const deltaTime = now - this.lastSampleTime;

        // Calculate average FPS over the sample interval
        const avgFPS = (this.frameCount * 1000) / deltaTime;

        // Update FPS metrics
        this.updateMetric('fps', avgFPS);

        // Update memory if available
        if (this.enableMemoryTracking && performance.memory) {
            const memoryMB = performance.memory.usedJSHeapSize / (1024 * 1024);
            this.updateMetric('memory', memoryMB);
        }

        // Update other current metrics
        for (const key in this.metrics) {
            if (key !== 'fps' && key !== 'memory') {
                this.updateMetric(key, this.metrics[key].current);
            }
        }

        // Check thresholds
        this.checkThresholds();

        // Reset frame counter
        this.frameCount = 0;
        this.lastSampleTime = now;

        // Call sample callback
        if (this.callbacks.onSample) {
            this.callbacks.onSample(this.getStats());
        }
    }

    updateMetric(name, value) {
        const metric = this.metrics[name];
        if (!metric) return;

        metric.current = value;
        metric.samples.push(value);

        // Keep only recent samples
        if (metric.samples.length > this.maxSamples) {
            metric.samples.shift();
        }

        // Calculate statistics
        if (metric.samples.length > 0) {
            metric.avg = metric.samples.reduce((a, b) => a + b, 0) / metric.samples.length;
            metric.min = Math.min(metric.min, value);
            metric.max = Math.max(metric.max, value);
        }
    }

    checkThresholds() {
        for (const [key, threshold] of Object.entries(this.thresholds)) {
            const metric = this.metrics[key];
            if (!metric) continue;

            const value = metric.current;
            const isInverted = key === 'fps'; // Lower values are worse for FPS

            let level = 'normal';
            if (isInverted) {
                if (value <= threshold.critical) {
                    level = 'critical';
                } else if (value <= threshold.warning) {
                    level = 'warning';
                }
            } else {
                if (value >= threshold.critical) {
                    level = 'critical';
                } else if (value >= threshold.warning) {
                    level = 'warning';
                }
            }

            if (level === 'critical' && this.callbacks.onCritical) {
                this.callbacks.onCritical(key, value, threshold.critical);
            } else if (level === 'warning' && this.callbacks.onWarning) {
                this.callbacks.onWarning(key, value, threshold.warning);
            }
        }
    }

    getStats() {
        const stats = {};

        for (const [key, metric] of Object.entries(this.metrics)) {
            stats[key] = {
                current: metric.current,
                average: metric.avg,
                min: metric.min === Infinity ? 0 : metric.min,
                max: metric.max,
                samples: metric.samples.length
            };
        }

        // Add computed metrics
        stats.performance = this.getPerformanceScore();
        stats.health = this.getHealthStatus();

        return stats;
    }

    getPerformanceScore() {
        // Calculate a 0-100 performance score based on metrics
        let score = 100;

        // FPS impact (max 40 points)
        const fpsRatio = Math.min(this.metrics.fps.current / 60, 1);
        score -= (1 - fpsRatio) * 40;

        // Frame time impact (max 30 points)
        const frameTimeRatio = Math.min(16.67 / Math.max(this.metrics.frameTime.current, 1), 1);
        score -= (1 - frameTimeRatio) * 30;

        // Memory impact (max 20 points)
        if (this.metrics.memory.current > 0) {
            const memoryRatio = Math.min(100 / Math.max(this.metrics.memory.current, 1), 1);
            score -= (1 - memoryRatio) * 20;
        }

        // Render time impact (max 10 points)
        const renderRatio = Math.min(10 / Math.max(this.metrics.renderTime.current, 1), 1);
        score -= (1 - renderRatio) * 10;

        return Math.max(0, Math.round(score));
    }

    getHealthStatus() {
        const score = this.getPerformanceScore();

        if (score >= 90) return 'excellent';
        if (score >= 75) return 'good';
        if (score >= 50) return 'fair';
        if (score >= 25) return 'poor';
        return 'critical';
    }

    reset() {
        for (const metric of Object.values(this.metrics)) {
            metric.samples = [];
            metric.current = 0;
            metric.avg = 0;
            metric.min = Infinity;
            metric.max = 0;
        }

        this.marks.clear();
        this.measures.clear();
        this.frameCount = 0;
    }

    exportData() {
        return {
            timestamp: Date.now(),
            metrics: this.getStats(),
            measures: Array.from(this.measures.entries()).map(([name, values]) => ({
                name,
                values,
                average: values.reduce((a, b) => a + b, 0) / values.length,
                min: Math.min(...values),
                max: Math.max(...values)
            })),
            thresholds: this.thresholds
        };
    }

    setThreshold(metric, warning, critical) {
        if (this.thresholds[metric]) {
            this.thresholds[metric] = { warning, critical };
        }
    }

    enable() {
        this.enabled = true;
        this.start();
    }

    disable() {
        this.enabled = false;
        this.stop();
    }
}

// Create singleton instance
const performanceMonitor = new PerformanceMonitor({
    enabled: true,
    sampleInterval: 1000,
    maxSamples: 60,
    thresholds: {
        fps: { warning: 50, critical: 30 },
        frameTime: { warning: 20, critical: 33 },
        memory: { warning: 150, critical: 300 },
        renderTime: { warning: 10, critical: 16 },
        updateTime: { warning: 5, critical: 10 }
    }
});

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                     ◐ ◑ ◒ ◓  SIMPLE FPS COUNTER  ◓ ◒ ◑ ◐                     
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Simple FPS Counter - Accurate Frame Rate Measurement
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module SimpleFPSCounter
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The SPEEDOMETER of the engine. Accurately measures frames per second using        
 * ║ a rolling timestamp array. Shows exactly how smooth the animation is running.     
 * ║ Critical for performance monitoring and automatic quality degradation.            
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📊 FPS CALCULATION METHOD                                                         
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Stores timestamps from the last second                                          
 * │ • Counts frames within 1000ms window                                              
 * │ • More accurate than delta time averaging                                         
 * │ • Updates every frame for real-time monitoring                                    
 * │ • Based on 2025 best practices for JavaScript FPS                                 
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ PERFORMANCE TARGETS                                                             
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • 60 FPS   : Smooth animation (16.67ms per frame)                                 
 * │ • 30 FPS   : Acceptable minimum (33.33ms per frame)                               
 * │ • < 30 FPS : Triggers quality degradation                                         
 * │ • < 15 FPS : Critical performance issues                                          
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ═══════════════════════════════════════════════════════════════════════════════════
 */
class SimpleFPSCounter {
    constructor() {
        // Array to store timestamps from the last second
        this.timestamps = [];
        
        // Current FPS value
        this.fps = 0;
        
        // Smoothed FPS for display (to reduce jitter)
        this.smoothedFPS = 0;
        this.smoothingFactor = 0.9; // Higher = more smoothing
        
        // Frame time tracking
        this.lastFrameTime = 0;
        this.frameTime = 0;
        
        // Average frame time over last N frames
        this.frameTimes = [];
        this.maxFrameTimeSamples = 10;
        this.averageFrameTime = 0;
    }
    
    /**
     * Update FPS calculation with new frame
     * Call this in your animation loop with the timestamp from requestAnimationFrame
     * @param {number} timestamp - High resolution timestamp from requestAnimationFrame
     */
    update(timestamp) {
        // Remove timestamps older than 1 second
        while (this.timestamps.length > 0 && this.timestamps[0] <= timestamp - 1000) {
            this.timestamps.shift();
        }
        
        // Add current timestamp
        this.timestamps.push(timestamp);
        
        // FPS is the number of frames in the last second
        this.fps = this.timestamps.length;
        
        // Apply smoothing to reduce display jitter
        if (this.smoothedFPS === 0) {
            this.smoothedFPS = this.fps;
        } else {
            this.smoothedFPS = this.smoothedFPS * this.smoothingFactor + 
                               this.fps * (1 - this.smoothingFactor);
        }
        
        // Calculate frame time
        if (this.lastFrameTime > 0) {
            this.frameTime = timestamp - this.lastFrameTime;
            
            // Track frame times for averaging
            this.frameTimes.push(this.frameTime);
            if (this.frameTimes.length > this.maxFrameTimeSamples) {
                this.frameTimes.shift();
            }
            
            // Calculate average frame time
            if (this.frameTimes.length > 0) {
                const sum = this.frameTimes.reduce((a, b) => a + b, 0);
                this.averageFrameTime = sum / this.frameTimes.length;
            }
        }
        this.lastFrameTime = timestamp;
    }
    
    /**
     * Get current FPS
     * @returns {number} Current FPS (integer)
     */
    getFPS() {
        return Math.round(this.fps);
    }
    
    /**
     * Get smoothed FPS for display
     * @returns {number} Smoothed FPS (integer)
     */
    getSmoothedFPS() {
        return Math.round(this.smoothedFPS);
    }
    
    /**
     * Get last frame time in milliseconds
     * @returns {number} Frame time in ms
     */
    getFrameTime() {
        return this.frameTime;
    }
    
    /**
     * Get average frame time over recent frames
     * @returns {number} Average frame time in ms
     */
    getAverageFrameTime() {
        return this.averageFrameTime;
    }
    
    /**
     * Reset the FPS counter
     */
    reset() {
        this.timestamps = [];
        this.fps = 0;
        this.smoothedFPS = 0;
        this.lastFrameTime = 0;
        this.frameTime = 0;
        this.frameTimes = [];
        this.averageFrameTime = 0;
    }
    
    /**
     * Get all metrics
     * @returns {Object} Object containing all FPS metrics
     */
    getMetrics() {
        return {
            fps: this.getFPS(),
            smoothedFPS: this.getSmoothedFPS(),
            frameTime: this.getFrameTime(),
            averageFrameTime: this.getAverageFrameTime(),
            // Performance status based on FPS
            status: this.fps >= 55 ? 'good' : this.fps >= 30 ? 'okay' : 'poor'
        };
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝
 *                    ◐ ◑ ◒ ◓  ANIMATION CONTROLLER  ◓ ◒ ◑ ◐
 *
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Animation Controller - Main Loop & Performance Management
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module AnimationController
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The HEARTBEAT of the Emotive Engine. Manages the main animation loop,             
 * ║ coordinates all subsystems, monitors performance, and ensures smooth              
 * ║ frame rates through adaptive quality control.                                     
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎬 CORE RESPONSIBILITIES                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Main requestAnimationFrame loop management                                      
 * │ • Frame timing and deltaTime calculation                                          
 * │ • Performance monitoring and FPS tracking                                         
 * │ • Adaptive quality degradation when performance drops                             
 * │ • Subsystem update coordination (render, particles, state)                        
 * │ • Visibility and pause state handling                                             
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ⚡ PERFORMANCE FEATURES                                                           
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Dynamic FPS targeting (15, 30, 45, 60 FPS)                                      
 * │ • Frame skipping for consistent timing                                            
 * │ • Automatic quality reduction when FPS drops                                      
 * │ • Recovery system when performance improves                                       
 * │ • Memory leak detection and prevention                                            
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔧 CONFIGURATION OPTIONS                                                          
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • targetFPS         : Desired frame rate (default: 60)                            
 * │ • enableDegradation : Allow quality reduction (default: true)                     
 * │ • performanceMode   : 'adaptive' | 'fixed' | 'maximum'                           
 * │ • monitoringInterval: Performance check frequency (default: 1000ms)               
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ ❌ CRITICAL - DO NOT MODIFY                                                       
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ ✗ Frame timing logic       → Breaks animation smoothness                         
 * │ ✗ Update order            → Causes render/state desync                           
 * │ ✗ Performance thresholds   → May cause excessive degradation                     
 * │ ✗ Memory cleanup          → Creates memory leaks                                 
 * │ ✗ RAF loop management     → Breaks entire animation system                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                          SUBSYSTEM UPDATE ORDER                                   
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ 1. Performance monitoring (FPS calculation)                                       
 * ║ 2. State machine update (emotions, transitions)                                   
 * ║ 3. Gesture processing (animation progress)                                        
 * ║ 4. Particle system update (movement, spawning)                                    
 * ║ 5. Renderer update (draw orb and particles)                                       
 * ║ 6. Cleanup and memory management                                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class AnimationController {
    constructor(errorBoundary, config = {}) {
        this.errorBoundary = errorBoundary;
        this.config = config;
        this.config.targetFPS = config.targetFPS || 60;
        
        // Animation state
        this.isRunning = false;
        this.animationFrameId = null;
        this.loopCallbackId = null; // For AnimationLoopManager
        this.lastFrameTime = 0;
        this.deltaTime = 0;
        this.isPaused = false;
        
        // Set up visibility change and window focus handling
        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
        this.handleWindowBlur = this.handleWindowBlur.bind(this);
        this.handleWindowFocus = this.handleWindowFocus.bind(this);

        if (typeof document !== 'undefined') {
            document.addEventListener('visibilitychange', this.handleVisibilityChange);
            window.addEventListener('blur', this.handleWindowBlur);
            window.addEventListener('focus', this.handleWindowFocus);
        }
        
        // PerformanceMonitor DISABLED - no FPS interference
        this.performanceMonitor = null;
        /* 
        this.performanceMonitor = new PerformanceMonitor(config);
        this.performanceMonitor.setEventCallback((event, data) => {
            this.emit(event, data);
        });
        */
        
        // Simple FPS counter for accurate display
        this.fpsCounter = new SimpleFPSCounter();
        
        // Subsystem references (injected via setSubsystems)
        this.subsystems = {};
        
        // Event callback for external integration
        this.eventCallback = null;
        
        // Reference to parent EmotiveMascot for audio level updates
        this.parentMascot = null;
        
    }

    /**
     * Injects subsystem dependencies
     * @param {Object} subsystems - Object containing all required subsystems
     */
    setSubsystems(subsystems) {
        this.subsystems = {
            stateMachine: subsystems.stateMachine,
            particleSystem: subsystems.particleSystem,
            renderer: subsystems.renderer,
            soundSystem: subsystems.soundSystem,
            canvasManager: subsystems.canvasManager
        };
        
        // Validate required subsystems
        const required = ['stateMachine', 'particleSystem', 'renderer'];
        for (const system of required) {
            if (!this.subsystems[system]) {
                throw new Error(`Required subsystem '${system}' not provided`);
            }
        }
        
        // PerformanceMonitor disabled
        if (this.performanceMonitor) {
            this.performanceMonitor.setSubsystems(this.subsystems);
        }
        
    }

    /**
     * Sets the event callback for external integration
     * @param {Function} callback - Function to call for event emission
     */
    setEventCallback(callback) {
        if (typeof callback !== 'function') {
            throw new Error('Event callback must be a function');
        }
        this.eventCallback = callback;
    }

    /**
     * Sets the parent EmotiveMascot reference for audio level updates
     * @param {EmotiveMascot} mascot - Parent mascot instance
     */
    setParentMascot(mascot) {
        this.parentMascot = mascot;
    }

    /**
     * Emits an event through the callback if available
     * @param {string} event - Event name
     * @param {*} data - Event data
     */
    emit(event, data = null) {
        if (this.eventCallback) {
            this.eventCallback(event, data);
        }
    }

    /**
     * Starts the animation loop
     * @returns {boolean} Success status
     */
    start() {
        return this.errorBoundary.wrap(() => {
            if (this.isRunning) {
                return false;
            }

            if (!this.subsystems.stateMachine) {
                throw new Error('Cannot start animation without subsystems configured');
            }
            
            // Initialize animation state
            this.isRunning = true;
            this.lastFrameTime = performance.now();
            
            // Resume audio context if available
            if (this.subsystems.soundSystem && this.subsystems.soundSystem.isAvailable()) {
                this.subsystems.soundSystem.resumeContext();
            }

            // Register with AnimationLoopManager instead of direct RAF
            this.loopCallbackId = animationLoopManager.register(
                (deltaTime, timestamp) => this.animate(deltaTime, timestamp),
                AnimationPriority.CRITICAL, // Main render loop is critical priority
                this
            );

            // Emit start event
            this.emit('animationStarted', { targetFPS: this.targetFPS });
            
            return true;
        }, 'animation-start')();
    }

    /**
     * Stops the animation loop
     * @returns {boolean} Success status
     */
    stop() {
        return this.errorBoundary.wrap(() => {
            if (!this.isRunning) {
                return false;
            }
            
            // Stop animation loop
            this.isRunning = false;

            // Unregister from AnimationLoopManager
            if (this.loopCallbackId) {
                animationLoopManager.unregister(this.loopCallbackId);
                this.loopCallbackId = null;
            }

            // Clean up old RAF if it exists (for backwards compatibility)
            if (this.animationFrameId) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }


            
            // Stop all active gestures
            if (this.subsystems.renderer && this.subsystems.renderer.stopAllGestures) {
                this.subsystems.renderer.stopAllGestures();
            }
            
            // Stop ambient audio
            if (this.subsystems.soundSystem && this.subsystems.soundSystem.isAvailable()) {
                this.subsystems.soundSystem.stopAmbientTone();
            }
            
            // Clear particles
            if (this.subsystems.particleSystem) {
                this.subsystems.particleSystem.clear();
            }
            
            // Emit stop event
            this.emit('animationStopped');
            
            return true;
        }, 'animation-stop')();
    }

    /**
     * Handles window blur event
     */
    handleWindowBlur() {
        // Use same logic as visibility change
        if (!document.hidden) {
            // Only pause if document isn't already hidden (avoid double-pause)
            this.handleVisibilityChange();
        }
    }

    /**
     * Handles window focus event
     */
    handleWindowFocus() {
        // Force a resume check
        if (!document.hidden && this.isPaused) {
            // Simulate visibility change to visible
            this.handleVisibilityChange();
        }
    }

    /**
     * Handles document visibility changes to pause/resume animation
     */
    handleVisibilityChange() {
        if (document.hidden) {
            // Tab became hidden - pause animation
            this.wasRunning = this.isRunning;
            this.isPaused = true;

            // Store current time to calculate gap when resuming
            this.pauseTime = performance.now();

            // TAB FOCUS FIX: Don't clear particles immediately - let them fade naturally
            if (this.subsystems?.particleSystem) {
                // Just reset accumulator, don't clear particles
                this.subsystems.particleSystem.resetAccumulator();
                // Store particle count for debugging
                this.pausedParticleCount = this.subsystems.particleSystem.particles?.length || 0;
            }

            // Pause gesture animations if any are active
            if (this.subsystems?.renderer?.gestureAnimator) {
                this.subsystems.renderer.gestureAnimator.pauseCurrentAnimation?.();
            }

            // Notify parent mascot to pause
            if (this.parentMascot?.pause) {
                this.parentMascot.pause();
            }
        } else {
            // Tab became visible - resume animation smoothly
            if (this.isPaused && this.wasRunning) {
                // Calculate time gap
                const resumeTime = performance.now();
                const gap = resumeTime - this.pauseTime;

                // TAB FOCUS FIX: Reset timing more gently
                this.lastFrameTime = resumeTime;
                this.frameTimeAccumulator = 0;

                // TAB FOCUS FIX: Reset FPS counter to prevent false low FPS readings
                if (this.fpsCounter) {
                    this.fpsCounter.reset();
                }

                // TAB FOCUS FIX: Gradual particle recovery instead of clearing all
                if (this.subsystems?.particleSystem) {
                    // Clear accumulator again to be safe
                    this.subsystems.particleSystem.resetAccumulator();
                    
                    // Only clear particles if gap was VERY long (30+ seconds)
                    if (gap > 30000) {
                        this.subsystems.particleSystem.particles = [];
                    } else if (gap > 10000) {
                        // For medium gaps (10-30s), reduce particle count gradually
                        const targetCount = Math.max(10, Math.floor(this.pausedParticleCount * 0.5));
                        while (this.subsystems.particleSystem.particles.length > targetCount) {
                            this.subsystems.particleSystem.removeParticle(0);
                        }
                    }
                    // For short gaps (<10s), keep all particles
                }

                // TAB FOCUS FIX: Don't reset canvas context aggressively
                if (this.renderer) {
                    // Only reset if gap was very long
                    if (gap > 30000) {
                        this.renderer.resetCanvasContext();
                    }
                    
                    // Reset any active animations
                    if (this.renderer.gestureAnimator) {
                        this.renderer.gestureAnimator.resumeAnimation?.();
                    }

                    // Only force clean render for very long gaps
                    if (gap > 30000) {
                        this.renderer.forceCleanRender = true;
                    }
                }

                // Reset state machine timing
                if (this.subsystems?.stateMachine) {
                    // Update state machine's last update time
                    this.subsystems.stateMachine.lastUpdateTime = resumeTime;
                }

                // Notify parent mascot to resume
                if (this.parentMascot?.resume) {
                    this.parentMascot.resume();
                }

                // Finally unpause
                this.isPaused = false;

                // Log for debugging
                if (this.performanceMonitor) {
                    console.warn(`TAB FOCUS FIX: Resumed after ${(gap/1000).toFixed(1)}s pause. Particles kept: ${this.subsystems?.particleSystem?.particles?.length || 0}/${this.pausedParticleCount || 0}`);
                }
            }
        }
    }
    
    /**
     * Main animation loop - SIMPLIFIED for performance
     * Removed AnimationLoopManager overhead
     */
    animate(deltaTime, timestamp) {
        if (!this.isRunning || this.isPaused) return;

        // Simple deltaTime calculation
        const currentTime = timestamp || performance.now();
        this.deltaTime = deltaTime || (currentTime - this.lastFrameTime);
        
        // TAB FOCUS FIX: More aggressive deltaTime cap for smooth recovery
        // After tab focus, browsers can give inconsistent timing
        if (this.deltaTime > 20) {
            this.deltaTime = 20; // Reduced from 50ms to 20ms for smoother recovery
        }
        
        // TAB FOCUS FIX: Detect and handle tab focus recovery
        if (this.deltaTime > 16.67 && this.deltaTime < 20) {
            // Likely tab focus recovery - use target frame time
            this.deltaTime = 16.67; // Force 60fps timing
        }
        
        this.lastFrameTime = currentTime;
        
        // Simple update and render - no overhead
        this.update(this.deltaTime);
        this.render();
    }

    /**
     * Updates all subsystems
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    update(deltaTime) {
        // Update state machine
        if (this.subsystems.stateMachine) {
            this.subsystems.stateMachine.update(deltaTime);
        }
        
        // Gesture updates now handled by renderer
        
        // Update parent mascot for audio level monitoring
        if (this.parentMascot && typeof this.parentMascot.update === 'function') {
            this.parentMascot.update(deltaTime);
        }
        
        // Only handle particles here if NOT in classic rendering mode
        // Classic mode handles its own particles in EmotiveMascot.render()
        const isClassicMode = this.parentMascot?.config?.renderingStyle === 'classic';
        
        if (!isClassicMode) {
            // Get current emotional properties and center for particle system (advanced mode only)
            if (this.subsystems.particleSystem && this.subsystems.stateMachine && this.subsystems.canvasManager) {
                const emotionalProps = this.subsystems.stateMachine.getCurrentEmotionalProperties();
                const center = this.subsystems.canvasManager.getCenter();
                
                // Get current gesture info from renderer if available
                let gestureMotion = null;
                let gestureProgress = 0;
                
                if (this.subsystems.renderer && this.subsystems.renderer.getCurrentGesture) {
                    const currentGesture = this.subsystems.renderer.getCurrentGesture();
                    if (currentGesture && currentGesture.particleMotion) {
                        gestureMotion = currentGesture.particleMotion;
                        gestureProgress = currentGesture.progress || 0;
                    }
                }
                
                // Update particle system with current emotional context
                this.subsystems.particleSystem.spawn(
                    emotionalProps.particleBehavior,
                    this.subsystems.stateMachine.getCurrentState().emotion,
                    emotionalProps.particleRate,
                    center.x,
                    center.y,
                    deltaTime
                );
                
                // Update particles with gesture motion if available
                this.subsystems.particleSystem.update(deltaTime, center.x, center.y, gestureMotion, gestureProgress);
            }
        }
        
        // PerformanceMonitor disabled
        if (this.performanceMonitor) {
            this.performanceMonitor.updateMetrics({
                particleCount: this.subsystems.particleSystem?.getActiveParticleCount?.() || 0,
                audioLatency: this.subsystems.soundSystem?.getLatency?.() || 0
            });
        }
    }

    /**
     * Renders the current frame
     */
    render() {
        // Call parent mascot's render method if available
        if (this.parentMascot && typeof this.parentMascot.render === 'function') {
            this.parentMascot.render();
        } else if (this.subsystems.renderer) {
            // Fallback to direct renderer call
            this.subsystems.renderer.render();
        }
    }



    /**
     * Gets current performance metrics (delegated to PerformanceMonitor)
     * @returns {Object} Performance data
     */
    getPerformanceMetrics() {
        // PerformanceMonitor disabled - use simple FPS counter only
        const fpsMetrics = this.fpsCounter ? this.fpsCounter.getMetrics() : {};
        return {
            fps: fpsMetrics.fps || 60,
            instantFps: fpsMetrics.smoothedFPS || 60,
            frameTime: fpsMetrics.frameTime || 16.67,
            averageFrameTime: fpsMetrics.averageFrameTime || 16.67,
            isRunning: this.isRunning,
            deltaTime: this.deltaTime
        };
    }

    /**
     * Sets the target FPS (delegated to PerformanceMonitor)
     * @param {number} fps - Target FPS value
     */
    setTargetFPS(fps) {
        // DISABLED - no FPS changes allowed
        
    }

    /**
     * Gets the target FPS
     * @returns {number} Target FPS value
     */
    get targetFPS() {
        return this.config.targetFPS || 60;
    }

    /**
     * Checks if the animation is currently running
     * @returns {boolean} Running status
     */
    isAnimating() {
        return this.isRunning;
    }

    /**
     * Destroys the animation controller and cleans up resources
     */
    destroy() {
        this.stop();
        
        // Remove visibility change and focus listeners
        if (typeof document !== 'undefined') {
            document.removeEventListener('visibilitychange', this.handleVisibilityChange);
            window.removeEventListener('blur', this.handleWindowBlur);
            window.removeEventListener('focus', this.handleWindowFocus);
        }
        
        // Destroy performance monitor
        if (this.performanceMonitor) {
            this.performanceMonitor.destroy();
            this.performanceMonitor = null;
        }
        
        // Clear subsystem references
        this.subsystems = {};
        this.eventCallback = null;
        
    }
}

/**
 * AudioLevelProcessor analyzes microphone input to compute RMS levels, detect volume spikes,
 * and emit events that drive audio-reactive mascot animations.
 * @module core/AudioLevelProcessor
 */

class AudioLevelProcessor {
    constructor(config = {}) {
        // Configuration with defaults
        this.config = {
            spikeThreshold: config.spikeThreshold || 1.5,
            minimumSpikeLevel: config.minimumSpikeLevel || 0.1,
            spikeMinInterval: config.spikeMinInterval || 1000, // ms between spikes
            historySize: config.historySize || 10,
            smoothingTimeConstant: config.smoothingTimeConstant || 0.8,
            fftSize: config.fftSize || 256,
            levelUpdateThrottle: config.levelUpdateThrottle || 100, // ms
            ...config
        };
        
        // Audio context and analysis
        this.audioContext = null;
        this.analyser = null;
        this.dataArray = null;
        
        // Audio level state
        this.currentLevel = 0;
        this.levelHistory = [];
        this.isActive = false;
        
        // Spike detection state
        this.lastVolumeSpike = 0;
        
        // Event throttling
        this.lastLevelEmit = 0;
        
        // Event callbacks
        this.callbacks = {
            levelUpdate: null,
            volumeSpike: null,
            error: null
        };
    }

    /**
     * Initialize audio level processing with provided audio context
     * @param {AudioContext} audioContext - Web Audio API context
     * @returns {boolean} Success status
     */
    initialize(audioContext) {
        try {
            if (!audioContext) {
                throw new Error('AudioContext is required for audio level processing');
            }
            
            // Validate AudioContext
            if (typeof audioContext.createAnalyser !== 'function') {
                throw new Error('Invalid AudioContext provided');
            }
            
            // Store audio context
            this.audioContext = audioContext;
            
            // Create audio analyser for level monitoring
            this.analyser = audioContext.createAnalyser();
            this.analyser.fftSize = this.config.fftSize;
            this.analyser.smoothingTimeConstant = this.config.smoothingTimeConstant;
            
            // Create data array for frequency analysis
            this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
            
            // Initialize state
            this.currentLevel = 0;
            this.levelHistory = [];
            this.lastVolumeSpike = 0;
            this.isActive = true;
            
            // Resume audio context if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(error => {
                    this.emitError('Failed to resume AudioContext', error);
                });
            }
            
            return true;
            
        } catch (error) {
            this.emitError('Failed to initialize AudioLevelProcessor', error);
            return false;
        }
    }

    /**
     * Clean up audio level processing resources
     */
    cleanup() {
        try {
            // Reset state
            this.isActive = false;
            this.currentLevel = 0;
            this.levelHistory = [];
            this.lastVolumeSpike = 0;
            this.lastLevelEmit = 0;
            
            // Clear references
            this.audioContext = null;
            this.analyser = null;
            this.dataArray = null;
            
            
        } catch (error) {
            this.emitError('Error during AudioLevelProcessor cleanup', error);
        }
    }

    /**
     * Update audio level from analyser (called each frame)
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    updateAudioLevel(deltaTime = 16) {
        if (!this.isActive || !this.analyser || !this.dataArray) {
            return;
        }
        
        try {
            // Get frequency data from analyser
            this.analyser.getByteFrequencyData(this.dataArray);
            
            // Calculate RMS (Root Mean Square) for accurate level detection
            const rms = this.calculateRMS();
            
            // Update current level with normalization and amplification
            this.currentLevel = Math.min(1, rms * 2); // Amplify for better sensitivity
            
            // Update audio level history for spike detection
            this.updateLevelHistory();
            
            // Check for volume spikes and trigger events
            this.detectVolumeSpikes();
            
            // Emit throttled level update events
            this.emitLevelUpdate();
            
        } catch (error) {
            this.emitError('Error updating audio level', error);
            this.currentLevel = 0;
        }
    }

    /**
     * Calculate RMS (Root Mean Square) from frequency data
     * @returns {number} RMS value normalized to 0-1 range
     */
    calculateRMS() {
        if (!this.dataArray || this.dataArray.length === 0) {
            return 0;
        }
        
        let sumSquares = 0;
        
        // Calculate sum of squares for all frequency bins
        for (let i = 0; i < this.dataArray.length; i++) {
            const normalized = this.dataArray[i] / 255; // Normalize to 0-1
            sumSquares += normalized * normalized;
        }
        
        // Return RMS value
        return Math.sqrt(sumSquares / this.dataArray.length);
    }

    /**
     * Update audio level history for spike detection analysis
     */
    updateLevelHistory() {
        // Add current level to history
        this.levelHistory.push(this.currentLevel);
        
        // Maintain history size limit
        if (this.levelHistory.length > this.config.historySize) {
            this.levelHistory.shift();
        }
    }

    /**
     * Detect volume spikes and emit events for gesture triggering
     */
    detectVolumeSpikes() {
        // Need sufficient history for spike detection
        if (this.levelHistory.length < 5) {
            return;
        }
        
        const currentTime = performance.now();
        
        // Prevent too frequent spike detection
        if (currentTime - this.lastVolumeSpike < this.config.spikeMinInterval) {
            return;
        }
        
        // Calculate average of previous levels (excluding current)
        const previousLevels = this.levelHistory.slice(0, -1);
        const averagePrevious = previousLevels.reduce((sum, level) => sum + level, 0) / previousLevels.length;
        
        // Check for volume spike conditions
        const isSpike = this.currentLevel >= averagePrevious * this.config.spikeThreshold &&
                       averagePrevious >= this.config.minimumSpikeLevel &&
                       this.currentLevel >= this.config.minimumSpikeLevel * 2;
        
        if (isSpike) {
            this.lastVolumeSpike = currentTime;
            
            // Emit volume spike event with detailed information
            this.emitVolumeSpike({
                level: this.currentLevel,
                previousAverage: averagePrevious,
                spikeRatio: this.currentLevel / averagePrevious,
                timestamp: currentTime,
                threshold: this.config.spikeThreshold,
                minimumLevel: this.config.minimumSpikeLevel
            });
            
        }
    }

    /**
     * Clear audio level history
     */
    clearHistory() {
        this.levelHistory = [];
    }

    /**
     * Get current audio level
     * @returns {number} Current audio level (0-1)
     */
    getCurrentLevel() {
        return this.currentLevel;
    }

    /**
     * Get audio level history
     * @returns {Array<number>} Array of recent audio levels
     */
    getLevelHistory() {
        return [...this.levelHistory]; // Return copy to prevent external modification
    }

    /**
     * Get analyser node for external audio source connection
     * @returns {AnalyserNode|null} Web Audio analyser node
     */
    getAnalyser() {
        return this.analyser;
    }

    /**
     * Get current frequency data as array
     * @returns {Uint8Array|null} Frequency data array
     */
    getFrequencyData() {
        if (!this.dataArray) {
            return null;
        }
        
        // Return copy of current frequency data
        return new Uint8Array(this.dataArray);
    }

    /**
     * Check if audio level processing is active
     * @returns {boolean} Active status
     */
    isProcessingActive() {
        return this.isActive;
    }

    /**
     * Set callback for audio level updates
     * @param {Function} callback - Callback function receiving level data
     */
    onLevelUpdate(callback) {
        if (typeof callback === 'function') {
            this.callbacks.levelUpdate = callback;
        } else {
            throw new Error('Level update callback must be a function');
        }
    }

    /**
     * Set callback for volume spike events
     * @param {Function} callback - Callback function receiving spike data
     */
    onVolumeSpike(callback) {
        if (typeof callback === 'function') {
            this.callbacks.volumeSpike = callback;
        } else {
            throw new Error('Volume spike callback must be a function');
        }
    }

    /**
     * Set callback for error events
     * @param {Function} callback - Callback function receiving error data
     */
    onError(callback) {
        if (typeof callback === 'function') {
            this.callbacks.error = callback;
        } else {
            throw new Error('Error callback must be a function');
        }
    }

    /**
     * Remove all event callbacks
     */
    removeAllCallbacks() {
        this.callbacks = {
            levelUpdate: null,
            volumeSpike: null,
            error: null
        };
    }

    /**
     * Update configuration settings
     * @param {Object} newConfig - New configuration options
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        
        // Update analyser settings if active
        if (this.analyser) {
            if (newConfig.fftSize) {
                this.analyser.fftSize = this.config.fftSize;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
            }
            
            if (newConfig.smoothingTimeConstant !== undefined) {
                this.analyser.smoothingTimeConstant = this.config.smoothingTimeConstant;
            }
        }
        
    }

    /**
     * Get current configuration
     * @returns {Object} Current configuration object
     */
    getConfig() {
        return { ...this.config }; // Return copy to prevent external modification
    }

    /**
     * Get processing statistics
     * @returns {Object} Statistics object
     */
    getStats() {
        return {
            isActive: this.isActive,
            currentLevel: this.currentLevel,
            historySize: this.levelHistory.length,
            maxHistorySize: this.config.historySize,
            lastSpikeTime: this.lastVolumeSpike,
            timeSinceLastSpike: this.lastVolumeSpike > 0 ? performance.now() - this.lastVolumeSpike : 0,
            averageLevel: this.levelHistory.length > 0 ? 
                this.levelHistory.reduce((sum, level) => sum + level, 0) / this.levelHistory.length : 0
        };
    }

    /**
     * Emit throttled audio level update event
     */
    emitLevelUpdate() {
        const currentTime = performance.now();
        
        // Throttle level update events
        if (currentTime - this.lastLevelEmit < this.config.levelUpdateThrottle) {
            return;
        }
        
        this.lastLevelEmit = currentTime;
        
        if (this.callbacks.levelUpdate) {
            try {
                this.callbacks.levelUpdate({
                    level: this.currentLevel,
                    rawData: this.getFrequencyData(),
                    timestamp: currentTime,
                    history: this.getLevelHistory()
                });
            } catch (_error) {
                // Ignore callback errors
            }
        }
    }

    /**
     * Emit volume spike event
     * @param {Object} spikeData - Spike detection data
     */
    emitVolumeSpike(spikeData) {
        if (this.callbacks.volumeSpike) {
            try {
                this.callbacks.volumeSpike(spikeData);
            } catch (_error) {
                // Ignore callback errors
            }
        }
    }

    /**
     * Emit error event
     * @param {string} message - Error message
     * @param {Error} error - Original error object
     */
    emitError(message, error) {
        
        if (this.callbacks.error) {
            try {
                this.callbacks.error({
                    message,
                    error,
                    timestamp: performance.now()
                });
            } catch (_callbackError) {
                // Ignore callback errors
            }
        }
    }

    /**
     * Check if Web Audio API is supported
     * @returns {boolean} Support status
     */
    static isSupported() {
        return !!(window.AudioContext || window.webkitAudioContext);
    }
}

/**
 * Event Manager
 * Centralized event listener management to prevent memory leaks
 *
 * @module core/EventManager
 * @version 1.0.0
 */

/**
 * Manages all event listeners to ensure proper cleanup
 */
class EventManager {
    constructor() {
        // Track all registered listeners
        this.listeners = new Map();

        // Track listener groups for batch operations
        this.groups = new Map();

        // Auto-cleanup on page unload
        // Removed unload handler - not needed and causes violations

        // Stats
        this.stats = {
            registered: 0,
            removed: 0,
            active: 0
        };
    }

    /**
     * Register an event listener
     * @param {EventTarget} target - Event target (element, window, document, etc.)
     * @param {string} eventType - Event type (click, resize, etc.)
     * @param {Function} handler - Event handler function
     * @param {Object} options - addEventListener options
     * @param {string} group - Optional group name for batch operations
     * @returns {string} Listener ID for later removal
     */
    addEventListener(target, eventType, handler, options = {}, group = 'default') {
        // Generate unique ID
        const id = this.generateId();

        // Create listener info
        const listenerInfo = {
            id,
            target,
            eventType,
            handler,
            options,
            group,
            active: true
        };

        // Store listener
        this.listeners.set(id, listenerInfo);

        // Add to group
        if (!this.groups.has(group)) {
            this.groups.set(group, new Set());
        }
        this.groups.get(group).add(id);

        // Actually add the listener
        target.addEventListener(eventType, handler, options);

        // Update stats
        this.stats.registered++;
        this.stats.active++;

        return id;
    }

    /**
     * Remove an event listener by ID
     * @param {string} id - Listener ID
     * @returns {boolean} Success status
     */
    removeEventListener(id) {
        const listenerInfo = this.listeners.get(id);

        if (!listenerInfo || !listenerInfo.active) {
            return false;
        }

        // Remove the actual listener
        listenerInfo.target.removeEventListener(
            listenerInfo.eventType,
            listenerInfo.handler,
            listenerInfo.options
        );

        // Mark as inactive
        listenerInfo.active = false;

        // Remove from group
        const group = this.groups.get(listenerInfo.group);
        if (group) {
            group.delete(id);
            if (group.size === 0) {
                this.groups.delete(listenerInfo.group);
            }
        }

        // Remove from listeners map
        this.listeners.delete(id);

        // Update stats
        this.stats.removed++;
        this.stats.active--;

        return true;
    }

    /**
     * Remove all listeners in a group
     * @param {string} group - Group name
     * @returns {number} Number of listeners removed
     */
    removeGroup(group) {
        const groupSet = this.groups.get(group);

        if (!groupSet) {
            return 0;
        }

        let removed = 0;

        for (const id of groupSet) {
            if (this.removeEventListener(id)) {
                removed++;
            }
        }

        return removed;
    }

    /**
     * Remove all listeners for a specific target
     * @param {EventTarget} target - Event target
     * @returns {number} Number of listeners removed
     */
    removeAllForTarget(target) {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.target === target && info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Remove all listeners of a specific type
     * @param {string} eventType - Event type
     * @returns {number} Number of listeners removed
     */
    removeAllOfType(eventType) {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.eventType === eventType && info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Remove all listeners
     * @returns {number} Number of listeners removed
     */
    removeAll() {
        let removed = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (info.active) {
                if (this.removeEventListener(id)) {
                    removed++;
                }
            }
        }

        return removed;
    }

    /**
     * Create a bound listener that auto-removes
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {Object} options - Options
     * @returns {Object} Controller with remove method
     */
    createAutoRemove(target, eventType, handler, options = {}) {
        const id = this.addEventListener(target, eventType, handler, options);

        return {
            id,
            remove: () => this.removeEventListener(id)
        };
    }

    /**
     * Add listener that fires only once
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    once(target, eventType, handler, options = {}) {
        const wrappedHandler = event => {
            handler(event);
            this.removeEventListener(id);
        };

        const id = this.addEventListener(target, eventType, wrappedHandler, options);

        return id;
    }

    /**
     * Debounced event listener
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {number} delay - Debounce delay in ms
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    debounced(target, eventType, handler, delay = 250, options = {}) {
        let timeoutId;

        const debouncedHandler = event => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => handler(event), delay);
        };

        return this.addEventListener(target, eventType, debouncedHandler, options);
    }

    /**
     * Throttled event listener
     * @param {EventTarget} target - Event target
     * @param {string} eventType - Event type
     * @param {Function} handler - Event handler
     * @param {number} limit - Throttle limit in ms
     * @param {Object} options - Options
     * @returns {string} Listener ID
     */
    throttled(target, eventType, handler, limit = 100, options = {}) {
        let inThrottle = false;

        const throttledHandler = event => {
            if (!inThrottle) {
                handler(event);
                inThrottle = true;
                setTimeout(() => {
                    inThrottle = false;
                }, limit);
            }
        };

        return this.addEventListener(target, eventType, throttledHandler, options);
    }

    // Removed setupUnloadHandler - causes permission violations
    // Browser automatically cleans up event listeners on unload

    /**
     * Generate unique ID
     * @private
     * @returns {string} Unique ID
     */
    generateId() {
        return `listener_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Get statistics
     * @returns {Object} Statistics
     */
    getStats() {
        return {
            ...this.stats,
            groups: this.groups.size,
            listeners: this.listeners.size
        };
    }

    /**
     * Get active listeners for debugging
     * @returns {Array} Active listener info
     */
    getActiveListeners() {
        const active = [];

        for (const [id, info] of this.listeners.entries()) {
            if (info.active) {
                active.push({
                    id,
                    eventType: info.eventType,
                    group: info.group,
                    target: info.target.constructor.name
                });
            }
        }

        return active;
    }

    /**
     * Check for potential memory leaks
     * @returns {Object} Leak analysis
     */
    analyzeLeaks() {
        const analysis = {
            totalListeners: this.listeners.size,
            activeListeners: this.stats.active,
            inactiveButNotRemoved: 0,
            byTarget: new Map(),
            byType: new Map(),
            potentialLeaks: []
        };

        for (const [id, info] of this.listeners.entries()) {
            // Count by target
            const targetName = info.target.constructor.name;
            analysis.byTarget.set(
                targetName,
                (analysis.byTarget.get(targetName) || 0) + 1
            );

            // Count by type
            analysis.byType.set(
                info.eventType,
                (analysis.byType.get(info.eventType) || 0) + 1
            );

            // Check for inactive but not removed
            if (!info.active) {
                analysis.inactiveButNotRemoved++;
                analysis.potentialLeaks.push({
                    id,
                    eventType: info.eventType,
                    target: targetName
                });
            }
        }

        // Convert maps to objects for easier reading
        analysis.byTarget = Object.fromEntries(analysis.byTarget);
        analysis.byType = Object.fromEntries(analysis.byType);

        return analysis;
    }

    /**
     * Clean up inactive listeners
     * @returns {number} Number cleaned
     */
    cleanup() {
        let cleaned = 0;

        for (const [id, info] of this.listeners.entries()) {
            if (!info.active) {
                this.listeners.delete(id);
                cleaned++;
            }
        }

        return cleaned;
    }
}

// Create singleton instance
const eventManager = new EventManager();

/**
 * AccessibilityManager provides reduced-motion handling, screen-reader announcements,
 * keyboard navigation support, and color/contrast adaptations for the Emotive Engine.
 * @module core/AccessibilityManager
 */

class AccessibilityManager {
    constructor(config = {}) {
        this.config = {
            enableReducedMotion: config.enableReducedMotion !== false,
            enableHighContrast: config.enableHighContrast !== false,
            enableScreenReaderSupport: config.enableScreenReaderSupport !== false,
            enableKeyboardNavigation: config.enableKeyboardNavigation !== false,
            enableFocusIndicators: config.enableFocusIndicators !== false,
            announceStateChanges: config.announceStateChanges !== false,
            colorBlindMode: config.colorBlindMode || 'none', // none, protanopia, deuteranopia, tritanopia
            ...config
        };
        
        // Accessibility state
        this.reducedMotionPreferred = false;
        this.highContrastEnabled = false;
        this.screenReaderActive = false;
        this.keyboardNavigationActive = false;
        this.currentColorBlindMode = this.config.colorBlindMode;
        
        // Focus management
        this.focusableElements = new Map();
        this.currentFocusIndex = -1;
        this.focusHistory = [];
        
        // ARIA live region for announcements
        this.liveRegion = null;
        this.announcementQueue = [];
        
        // Color schemes for different accessibility needs
        this.colorSchemes = {
            normal: null, // Will be set from current colors
            highContrast: {
                primary: '#FFFFFF',
                secondary: '#000000',
                accent: '#FFFF00',
                background: '#000000',
                particles: '#FFFFFF'
            },
            protanopia: { // Red-blind
                primary: '#0066CC',
                secondary: '#FFCC00',
                accent: '#00CCFF',
                background: '#1A1A1A',
                particles: '#66CCFF'
            },
            deuteranopia: { // Green-blind
                primary: '#0099FF',
                secondary: '#FF9900',
                accent: '#FF00FF',
                background: '#1A1A1A',
                particles: '#9966FF'
            },
            tritanopia: { // Blue-blind
                primary: '#FF0066',
                secondary: '#00FF66',
                accent: '#FF6600',
                background: '#1A1A1A',
                particles: '#FFCC00'
            }
        };
        
        // Pattern overlays for color-blind modes
        this.patterns = {
            dots: 'dots',
            stripes: 'stripes',
            crosshatch: 'crosshatch',
            solid: 'solid'
        };
        
        // Emotional state patterns for color-blind users
        this.statePatterns = {
            idle: this.patterns.solid,
            happy: this.patterns.dots,
            excited: this.patterns.stripes,
            calm: this.patterns.solid,
            curious: this.patterns.crosshatch,
            frustrated: this.patterns.stripes,
            sad: this.patterns.dots,
            neutral: this.patterns.solid
        };
        
        // Initialize accessibility features
        this.initialize();
    }
    
    /**
     * Initialize accessibility features
     */
    initialize() {
        // Detect user preferences
        this.detectUserPreferences();
        
        // Set up ARIA live region
        this.setupLiveRegion();
        
        // Set up keyboard navigation if enabled
        if (this.config.enableKeyboardNavigation) {
            this.setupKeyboardNavigation();
        }
        
        // Listen for preference changes
        this.setupPreferenceListeners();
        
    }
    
    /**
     * Detect user accessibility preferences
     */
    detectUserPreferences() {
        // Detect reduced motion preference
        if (this.config.enableReducedMotion && window.matchMedia) {
            const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
            this.reducedMotionPreferred = motionQuery.matches;
        }
        
        // Detect high contrast preference
        if (this.config.enableHighContrast && window.matchMedia) {
            const contrastQuery = window.matchMedia('(prefers-contrast: high)');
            this.highContrastEnabled = contrastQuery.matches;
            
            // Also check for Windows high contrast mode
            if (!this.highContrastEnabled) {
                const windowsHCQuery = window.matchMedia('(-ms-high-contrast: active)');
                this.highContrastEnabled = windowsHCQuery.matches;
            }
        }
        
        // Detect screen reader (heuristic approach)
        this.detectScreenReader();
    }
    
    /**
     * Detect if a screen reader is likely active
     */
    detectScreenReader() {
        // Check for ARIA attributes being actively used
        const hasAriaLive = document.querySelector('[aria-live]');
        const hasAriaAtomic = document.querySelector('[aria-atomic]');
        
        // Check for screen reader specific attributes
        const hasRole = document.querySelector('[role="application"]');
        
        // Check user agent for assistive technology hints
        const userAgent = navigator.userAgent.toLowerCase();
        const hasATHints = userAgent.includes('nvda') || 
                          userAgent.includes('jaws') || 
                          userAgent.includes('voiceover');
        
        this.screenReaderActive = !!(hasAriaLive || hasAriaAtomic || hasRole || hasATHints);
    }
    
    /**
     * Set up ARIA live region for announcements
     */
    setupLiveRegion() {
        if (!this.config.enableScreenReaderSupport) return;
        
        // Create live region if it doesn't exist
        this.liveRegion = document.getElementById('mascot-announcements');
        if (!this.liveRegion) {
            this.liveRegion = document.createElement('div');
            this.liveRegion.id = 'mascot-announcements';
            this.liveRegion.setAttribute('aria-live', 'polite');
            this.liveRegion.setAttribute('aria-atomic', 'true');
            this.liveRegion.style.position = 'absolute';
            this.liveRegion.style.left = '-10000px';
            this.liveRegion.style.width = '1px';
            this.liveRegion.style.height = '1px';
            this.liveRegion.style.overflow = 'hidden';
            document.body.appendChild(this.liveRegion);
        }
    }
    
    /**
     * Set up keyboard navigation
     */
    setupKeyboardNavigation() {
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
    }
    
    /**
     * Set up listeners for preference changes
     */
    setupPreferenceListeners() {
        if (window.matchMedia) {
            // Listen for reduced motion changes
            const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
            motionQuery.addListener(e => {
                this.reducedMotionPreferred = e.matches;
                this.onPreferenceChange('reducedMotion', e.matches);
            });
            
            // Listen for high contrast changes
            const contrastQuery = window.matchMedia('(prefers-contrast: high)');
            contrastQuery.addListener(e => {
                this.highContrastEnabled = e.matches;
                this.onPreferenceChange('highContrast', e.matches);
            });
        }
    }
    
    /**
     * Handle keyboard navigation
     * @param {KeyboardEvent} event - Keyboard event
     */
    handleKeyDown(event) {
        if (!this.config.enableKeyboardNavigation) return;
        
        switch (event.key) {
        case 'Tab':
            event.preventDefault();
            this.navigateFocus(event.shiftKey ? -1 : 1);
            break;
        case 'Enter':
        case ' ':
            this.activateCurrentFocus();
            break;
        case 'Escape':
            this.clearFocus();
            break;
        case 'ArrowLeft':
        case 'ArrowRight':
        case 'ArrowUp':
        case 'ArrowDown':
            this.handleArrowNavigation(event.key);
            break;
        }
        
        this.keyboardNavigationActive = true;
    }
    
    /**
     * Handle key up events
     * @param {KeyboardEvent} event - Keyboard event
     */
    handleKeyUp(event) {
        // Could be used for specific key release actions
    }
    
    /**
     * Navigate focus between elements
     * @param {number} direction - Direction to navigate (1 or -1)
     */
    navigateFocus(direction) {
        const focusableArray = Array.from(this.focusableElements.values());
        if (focusableArray.length === 0) return;
        
        this.currentFocusIndex += direction;
        
        // Wrap around
        if (this.currentFocusIndex < 0) {
            this.currentFocusIndex = focusableArray.length - 1;
        } else if (this.currentFocusIndex >= focusableArray.length) {
            this.currentFocusIndex = 0;
        }
        
        const element = focusableArray[this.currentFocusIndex];
        this.setFocus(element);
        
        // Announce focus change
        if (element.label) {
            this.announce(`Focused on ${element.label}`);
        }
    }
    
    /**
     * Handle arrow key navigation
     * @param {string} key - Arrow key pressed
     */
    handleArrowNavigation(key) {
        // This would be implemented based on spatial navigation needs
        const directions = {
            'ArrowLeft': { x: -1, y: 0 },
            'ArrowRight': { x: 1, y: 0 },
            'ArrowUp': { x: 0, y: -1 },
            'ArrowDown': { x: 0, y: 1 }
        };
        
        const direction = directions[key];
        if (direction && this.onArrowNavigation) {
            this.onArrowNavigation(direction);
        }
    }
    
    /**
     * Register a focusable element
     * @param {string} id - Element identifier
     * @param {Object} element - Element properties
     */
    registerFocusableElement(id, element) {
        this.focusableElements.set(id, {
            id,
            label: element.label || id,
            bounds: element.bounds || null,
            action: element.action || null,
            type: element.type || 'button'
        });
    }
    
    /**
     * Unregister a focusable element
     * @param {string} id - Element identifier
     */
    unregisterFocusableElement(id) {
        this.focusableElements.delete(id);
    }
    
    /**
     * Set focus on an element
     * @param {Object} element - Element to focus
     */
    setFocus(element) {
        if (this.onFocusChange) {
            this.onFocusChange(element);
        }
        
        this.focusHistory.push(element.id);
        if (this.focusHistory.length > 10) {
            this.focusHistory.shift();
        }
    }
    
    /**
     * Clear current focus
     */
    clearFocus() {
        this.currentFocusIndex = -1;
        if (this.onFocusChange) {
            this.onFocusChange(null);
        }
        
        this.announce('Focus cleared');
    }
    
    /**
     * Activate the currently focused element
     */
    activateCurrentFocus() {
        const focusableArray = Array.from(this.focusableElements.values());
        if (this.currentFocusIndex >= 0 && this.currentFocusIndex < focusableArray.length) {
            const element = focusableArray[this.currentFocusIndex];
            if (element.action) {
                element.action();
                this.announce(`Activated ${element.label}`);
            }
        }
    }
    
    /**
     * Announce a message to screen readers
     * @param {string} message - Message to announce
     * @param {string} priority - Priority level (polite, assertive)
     */
    announce(message, priority = 'polite') {
        if (!this.config.enableScreenReaderSupport || !this.liveRegion) return;
        
        // Queue the announcement
        this.announcementQueue.push({ message, priority });
        
        // Process queue
        this.processAnnouncementQueue();
    }
    
    /**
     * Process announcement queue
     */
    processAnnouncementQueue() {
        if (this.announcementQueue.length === 0) return;
        
        const { message, priority } = this.announcementQueue.shift();
        
        // Update live region
        this.liveRegion.setAttribute('aria-live', priority);
        this.liveRegion.textContent = message;
        
        // Clear after a delay to allow screen reader to announce
        setTimeout(() => {
            if (this.liveRegion) {
                this.liveRegion.textContent = '';
            }
            
            // Process next announcement if any
            if (this.announcementQueue.length > 0) {
                this.processAnnouncementQueue();
            }
        }, 100);
    }
    
    /**
     * Get adjusted animation settings based on accessibility preferences
     * @param {Object} originalSettings - Original animation settings
     * @returns {Object} Adjusted settings
     */
    getAnimationSettings(originalSettings = {}) {
        if (!this.reducedMotionPreferred) {
            return originalSettings;
        }
        
        // Reduce or disable animations for users who prefer reduced motion
        return {
            ...originalSettings,
            duration: originalSettings.duration ? originalSettings.duration * 0.5 : 0,
            iterations: 1,
            easing: 'linear',
            particlesEnabled: false,
            complexAnimations: false,
            autoPlay: false
        };
    }
    
    /**
     * Get adjusted color scheme based on accessibility preferences
     * @param {Object} originalColors - Original color scheme
     * @returns {Object} Adjusted colors
     */
    getColorScheme(originalColors = {}) {
        // Store original colors if not set
        if (!this.colorSchemes.normal) {
            this.colorSchemes.normal = { ...originalColors };
        }
        
        // Apply high contrast if needed
        if (this.highContrastEnabled) {
            return this.colorSchemes.highContrast;
        }
        
        // Apply color blind mode if set
        if (this.currentColorBlindMode !== 'none' && this.colorSchemes[this.currentColorBlindMode]) {
            return this.colorSchemes[this.currentColorBlindMode];
        }
        
        return originalColors;
    }
    
    /**
     * Get pattern for current state (for color blind users)
     * @param {string} state - Current emotional state
     * @returns {string} Pattern identifier
     */
    getStatePattern(state) {
        if (this.currentColorBlindMode === 'none') {
            return this.patterns.solid;
        }
        
        return this.statePatterns[state] || this.patterns.solid;
    }
    
    /**
     * Apply pattern overlay to canvas
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {string} pattern - Pattern type
     * @param {Object} bounds - Area to apply pattern
     */
    applyPatternOverlay(ctx, pattern, bounds) {
        if (pattern === this.patterns.solid) return;
        
        ctx.save();
        
        const patternCanvas = document.createElement('canvas');
        const patternCtx = patternCanvas.getContext('2d');
        
        switch (pattern) {
        case this.patterns.dots:
            this.createDotPattern(patternCtx, patternCanvas);
            break;
        case this.patterns.stripes:
            this.createStripePattern(patternCtx, patternCanvas);
            break;
        case this.patterns.crosshatch:
            this.createCrosshatchPattern(patternCtx, patternCanvas);
            break;
        }
        
        const canvasPattern = ctx.createPattern(patternCanvas, 'repeat');
        ctx.fillStyle = canvasPattern;
        ctx.globalAlpha = 0.3; // Semi-transparent overlay
        ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
        
        ctx.restore();
    }
    
    /**
     * Create dot pattern
     * @param {CanvasRenderingContext2D} ctx - Pattern canvas context
     * @param {HTMLCanvasElement} canvas - Pattern canvas
     */
    createDotPattern(ctx, canvas) {
        canvas.width = 10;
        canvas.height = 10;
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(5, 5, 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    /**
     * Create stripe pattern
     * @param {CanvasRenderingContext2D} ctx - Pattern canvas context
     * @param {HTMLCanvasElement} canvas - Pattern canvas
     */
    createStripePattern(ctx, canvas) {
        canvas.width = 10;
        canvas.height = 10;
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 10);
        ctx.lineTo(10, 0);
        ctx.stroke();
    }
    
    /**
     * Create crosshatch pattern
     * @param {CanvasRenderingContext2D} ctx - Pattern canvas context
     * @param {HTMLCanvasElement} canvas - Pattern canvas
     */
    createCrosshatchPattern(ctx, canvas) {
        canvas.width = 10;
        canvas.height = 10;
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        
        // Diagonal lines
        ctx.beginPath();
        ctx.moveTo(0, 10);
        ctx.lineTo(10, 0);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(10, 10);
        ctx.stroke();
    }
    
    /**
     * Set color blind mode
     * @param {string} mode - Color blind mode
     */
    setColorBlindMode(mode) {
        const validModes = ['none', 'protanopia', 'deuteranopia', 'tritanopia'];
        if (!validModes.includes(mode)) {
            return;
        }
        
        this.currentColorBlindMode = mode;
        this.announce(`Color blind mode set to ${mode}`);
        
        if (this.onColorSchemeChange) {
            this.onColorSchemeChange(this.getColorScheme());
        }
    }
    
    /**
     * Get accessibility status report
     * @returns {Object} Accessibility status
     */
    getStatus() {
        return {
            reducedMotion: this.reducedMotionPreferred,
            highContrast: this.highContrastEnabled,
            screenReader: this.screenReaderActive,
            keyboardNavigation: this.keyboardNavigationActive,
            colorBlindMode: this.currentColorBlindMode,
            focusedElement: this.currentFocusIndex >= 0 ? 
                Array.from(this.focusableElements.values())[this.currentFocusIndex] : null,
            registeredElements: this.focusableElements.size
        };
    }
    
    /**
     * Handle preference change
     * @param {string} preference - Preference that changed
     * @param {*} value - New value
     */
    onPreferenceChange(preference, value) {
        
        // Notify about the change
        this.announce(`${preference} is now ${value ? 'enabled' : 'disabled'}`);
        
        // Trigger callbacks if set
        if (preference === 'reducedMotion' && this.onReducedMotionChange) {
            this.onReducedMotionChange(value);
        }
        
        if (preference === 'highContrast' && this.onHighContrastChange) {
            this.onHighContrastChange(value);
        }
    }
    
    /**
     * Create ARIA description for mascot state
     * @param {Object} state - Current mascot state
     * @returns {string} ARIA description
     */
    createStateDescription(state) {
        const descriptions = {
            idle: 'Mascot is idle and gently breathing',
            happy: 'Mascot is happy and bouncing',
            excited: 'Mascot is excited with particles flying',
            calm: 'Mascot is calm and peaceful',
            curious: 'Mascot is curious and looking around',
            frustrated: 'Mascot is frustrated and shaking',
            sad: 'Mascot is sad and drooping',
            neutral: 'Mascot is in a neutral state'
        };
        
        return descriptions[state.emotional] || 'Mascot is active';
    }
    
    /**
     * Destroy accessibility manager
     */
    destroy() {
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyDown);
        document.removeEventListener('keyup', this.handleKeyUp);
        
        // Remove live region
        if (this.liveRegion && this.liveRegion.parentNode) {
            this.liveRegion.parentNode.removeChild(this.liveRegion);
        }
        
        // Clear data
        this.focusableElements.clear();
        this.announcementQueue = [];
        this.focusHistory = [];
        
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                  ◐ ◑ ◒ ◓  MOBILE OPTIMIZATION  ◓ ◒ ◑ ◐                  
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Mobile Optimization - Touch & Mobile Device Support
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module MobileOptimization
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Makes the orb TOUCHABLE and mobile-friendly. Handles all the quirks of           
 * ║ mobile browsers, touch events, viewport changes, and battery optimization.        
 * ║ Ensures smooth performance even on low-end phones.                               
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📱 MOBILE FEATURES                                                                 
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Touch event handling (tap, swipe, pinch)                                        
 * │ • Viewport resize handling                                                        
 * │ • Orientation change detection                                                    
 * │ • Battery-aware performance                                                       
 * │ • Reduced particle count on mobile                                                
 * │ • Touch-friendly interaction zones                                                
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class MobileOptimization {
    constructor(config = {}) {
        this.config = {
            enableTouchOptimization: config.enableTouchOptimization !== false,
            enableViewportHandling: config.enableViewportHandling !== false,
            enableBatteryOptimization: config.enableBatteryOptimization !== false,
            enableOrientationSupport: config.enableOrientationSupport !== false,
            enableResponsiveScaling: config.enableResponsiveScaling !== false,
            touchSensitivity: config.touchSensitivity || 1.0,
            doubleTapDelay: config.doubleTapDelay || 300,
            swipeThreshold: config.swipeThreshold || 50,
            pinchThreshold: config.pinchThreshold || 0.1,
            ...config
        };
        
        // Device detection
        this.isMobile = this.detectMobile();
        this.isTablet = this.detectTablet();
        this.isTouchDevice = this.detectTouch();
        this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        this.isAndroid = /Android/.test(navigator.userAgent);
        
        // Touch state
        this.touches = new Map();
        this.lastTouchTime = 0;
        this.lastTapTime = 0;
        this.tapCount = 0;
        this.touchStartPosition = null;
        this.isPinching = false;
        this.isRotating = false;
        this.lastPinchDistance = 0;
        this.lastRotation = 0;
        
        // Gesture recognition
        this.currentGesture = null;
        this.gestureStartTime = 0;
        this.gestureHistory = [];
        
        // Viewport state
        this.viewportSize = { width: window.innerWidth, height: window.innerHeight };
        this.orientation = this.getOrientation();
        this.pixelRatio = window.devicePixelRatio || 1;
        this.lastViewportChange = 0;
        
        // Battery state
        this.batteryLevel = 1.0;
        this.isCharging = true;
        this.lowPowerMode = false;
        
        // Performance adjustments for mobile
        this.mobilePerformanceSettings = {
            reducedParticles: this.isMobile,
            simplifiedAnimations: this.isMobile,
            lowerFrameRate: this.isMobile,
            reducedEffects: this.isMobile || this.isTablet,
            targetFPS: this.isMobile ? 30 : 60,
            maxParticles: this.isMobile ? 20 : 50
        };
        
        // Canvas optimization
        this.canvasScale = 1.0;
        this.useOffscreenCanvas = this.supportsOffscreenCanvas();
        
        // Event handlers bound to this
        this.handleTouchStart = this.handleTouchStart.bind(this);
        this.handleTouchMove = this.handleTouchMove.bind(this);
        this.handleTouchEnd = this.handleTouchEnd.bind(this);
        this.handleTouchCancel = this.handleTouchCancel.bind(this);
        this.handleOrientationChange = this.handleOrientationChange.bind(this);
        this.handleViewportChange = this.handleViewportChange.bind(this);
        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
        
        // Initialize
        this.initialize();
    }
    
    /**
     * Initialize mobile optimization
     */
    initialize() {
        if (this.config.enableTouchOptimization && this.isTouchDevice) {
            this.setupTouchHandlers();
        }
        
        if (this.config.enableViewportHandling) {
            this.setupViewportHandlers();
        }
        
        if (this.config.enableBatteryOptimization) {
            this.setupBatteryMonitoring();
        }
        
        if (this.config.enableOrientationSupport) {
            this.setupOrientationHandlers();
        }
        
        // Apply initial optimizations
        this.applyMobileOptimizations();
    }
    
    /**
     * Detect if device is mobile
     * @returns {boolean} True if mobile device
     */
    detectMobile() {
        const userAgent = navigator.userAgent.toLowerCase();
        const mobileKeywords = ['android', 'iphone', 'ipod', 'windows phone', 'blackberry'];
        
        // Check user agent
        const isMobileUA = mobileKeywords.some(keyword => userAgent.includes(keyword));
        
        // Check screen size
        const isMobileSize = window.innerWidth <= 768;
        
        // Check for touch and small screen
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        return isMobileUA || (isMobileSize && hasTouch);
    }
    
    /**
     * Detect if device is tablet
     * @returns {boolean} True if tablet device
     */
    detectTablet() {
        const userAgent = navigator.userAgent.toLowerCase();
        const isIPad = /ipad/.test(userAgent);
        const isAndroidTablet = /android/.test(userAgent) && !/mobile/.test(userAgent);
        const isWindowsTablet = /windows/.test(userAgent) && /touch/.test(userAgent);
        
        // Check screen size for tablet range
        const isTabletSize = window.innerWidth > 768 && window.innerWidth <= 1024;
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        return isIPad || isAndroidTablet || isWindowsTablet || (isTabletSize && hasTouch);
    }
    
    /**
     * Detect touch support
     * @returns {boolean} True if touch is supported
     */
    detectTouch() {
        return 'ontouchstart' in window || 
               navigator.maxTouchPoints > 0 || 
               navigator.msMaxTouchPoints > 0;
    }
    
    /**
     * Check if offscreen canvas is supported
     * @returns {boolean} True if OffscreenCanvas is supported
     */
    supportsOffscreenCanvas() {
        return typeof OffscreenCanvas !== 'undefined';
    }
    
    /**
     * Set up touch event handlers
     */
    setupTouchHandlers() {
        const canvas = this.getCanvas();
        if (!canvas) return;
        
        // Prevent default touch behaviors
        canvas.style.touchAction = 'none';
        canvas.style.userSelect = 'none';
        canvas.style.webkitUserSelect = 'none';
        
        // Add touch event listeners
        canvas.addEventListener('touchstart', this.handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', this.handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', this.handleTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', this.handleTouchCancel, { passive: false });
        
        // Prevent context menu on long press
        canvas.addEventListener('contextmenu', e => e.preventDefault());
    }
    
    /**
     * Set up viewport change handlers
     */
    setupViewportHandlers() {
        window.addEventListener('resize', this.handleViewportChange);
        window.addEventListener('orientationchange', this.handleOrientationChange);
        
        // Handle visibility changes for battery optimization
        document.addEventListener('visibilitychange', this.handleVisibilityChange);
        
        // Handle viewport meta changes
        this.setupViewportMeta();
    }
    
    /**
     * Set up viewport meta tag for mobile
     */
    setupViewportMeta() {
        let viewportMeta = document.querySelector('meta[name="viewport"]');
        
        if (!viewportMeta) {
            viewportMeta = document.createElement('meta');
            viewportMeta.name = 'viewport';
            document.head.appendChild(viewportMeta);
        }
        
        // Set optimal viewport for mobile
        viewportMeta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
    }
    
    /**
     * Set up battery monitoring
     */
    async setupBatteryMonitoring() {
        if (!navigator.getBattery) return;
        
        try {
            const battery = await navigator.getBattery();
            
            this.batteryLevel = battery.level;
            this.isCharging = battery.charging;
            
            // Listen for battery changes
            battery.addEventListener('levelchange', () => {
                this.batteryLevel = battery.level;
                this.onBatteryChange();
            });
            
            battery.addEventListener('chargingchange', () => {
                this.isCharging = battery.charging;
                this.onBatteryChange();
            });
            
            // Initial battery optimization
            this.onBatteryChange();
        } catch (_error) {
            // Ignore battery optimization errors
        }
    }
    
    /**
     * Set up orientation change handlers
     */
    setupOrientationHandlers() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', event => {
                this.handleDeviceOrientation(event);
            });
        }
    }
    
    /**
     * Handle touch start
     * @param {TouchEvent} event - Touch event
     */
    handleTouchStart(event) {
        event.preventDefault();
        
        const now = Date.now();
        this.gestureStartTime = now;
        
        // Store all touches
        for (const touch of event.touches) {
            this.touches.set(touch.identifier, {
                id: touch.identifier,
                startX: touch.clientX,
                startY: touch.clientY,
                currentX: touch.clientX,
                currentY: touch.clientY,
                startTime: now
            });
        }
        
        // Handle different touch counts
        if (event.touches.length === 1) {
            this.handleSingleTouchStart(event.touches[0]);
        } else if (event.touches.length === 2) {
            this.handleMultiTouchStart(event.touches);
        }
        
        // Emit touch event
        this.emitTouchEvent('touchStart', {
            touches: Array.from(this.touches.values()),
            timestamp: now
        });
    }
    
    /**
     * Handle single touch start
     * @param {Touch} touch - Touch object
     */
    handleSingleTouchStart(touch) {
        const now = Date.now();
        
        // Check for double tap
        if (now - this.lastTapTime < this.config.doubleTapDelay) {
            this.tapCount++;
        } else {
            this.tapCount = 1;
        }
        
        this.lastTapTime = now;
        this.touchStartPosition = { x: touch.clientX, y: touch.clientY };
    }
    
    /**
     * Handle multi-touch start
     * @param {TouchList} touches - Touch list
     */
    handleMultiTouchStart(touches) {
        if (touches.length === 2) {
            // Initialize pinch/rotate
            const touch1 = touches[0];
            const touch2 = touches[1];
            
            this.lastPinchDistance = this.getDistance(
                touch1.clientX, touch1.clientY,
                touch2.clientX, touch2.clientY
            );
            
            this.lastRotation = this.getAngle(
                touch1.clientX, touch1.clientY,
                touch2.clientX, touch2.clientY
            );
            
            this.isPinching = true;
        }
    }
    
    /**
     * Handle touch move
     * @param {TouchEvent} event - Touch event
     */
    handleTouchMove(event) {
        event.preventDefault();
        
        // Update touch positions
        for (const touch of event.touches) {
            const storedTouch = this.touches.get(touch.identifier);
            if (storedTouch) {
                storedTouch.currentX = touch.clientX;
                storedTouch.currentY = touch.clientY;
            }
        }
        
        // Handle gestures based on touch count
        if (event.touches.length === 1) {
            this.handleSingleTouchMove(event.touches[0]);
        } else if (event.touches.length === 2) {
            this.handleMultiTouchMove(event.touches);
        }
        
        // Emit touch event
        this.emitTouchEvent('touchMove', {
            touches: Array.from(this.touches.values()),
            gesture: this.currentGesture
        });
    }
    
    /**
     * Handle single touch move
     * @param {Touch} touch - Touch object
     */
    handleSingleTouchMove(touch) {
        const storedTouch = this.touches.get(touch.identifier);
        if (!storedTouch) return;
        
        const deltaX = touch.clientX - storedTouch.startX;
        const deltaY = touch.clientY - storedTouch.startY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // Detect swipe gesture
        if (distance > this.config.swipeThreshold) {
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                this.currentGesture = deltaX > 0 ? 'swipeRight' : 'swipeLeft';
            } else {
                this.currentGesture = deltaY > 0 ? 'swipeDown' : 'swipeUp';
            }
        } else {
            this.currentGesture = 'pan';
        }
    }
    
    /**
     * Handle multi-touch move
     * @param {TouchList} touches - Touch list
     */
    handleMultiTouchMove(touches) {
        if (touches.length !== 2) return;
        
        const touch1 = touches[0];
        const touch2 = touches[1];
        
        // Calculate pinch
        const currentDistance = this.getDistance(
            touch1.clientX, touch1.clientY,
            touch2.clientX, touch2.clientY
        );
        
        const pinchDelta = currentDistance - this.lastPinchDistance;
        const pinchRatio = currentDistance / this.lastPinchDistance;
        
        if (Math.abs(pinchDelta) > this.config.pinchThreshold) {
            this.currentGesture = pinchRatio > 1 ? 'pinchOut' : 'pinchIn';
            
            // Emit pinch event
            this.emitTouchEvent('pinch', {
                scale: pinchRatio,
                delta: pinchDelta
            });
        }
        
        // Calculate rotation
        const currentRotation = this.getAngle(
            touch1.clientX, touch1.clientY,
            touch2.clientX, touch2.clientY
        );
        
        const rotationDelta = currentRotation - this.lastRotation;
        
        if (Math.abs(rotationDelta) > 5) { // 5 degree threshold
            this.currentGesture = 'rotate';
            
            // Emit rotation event
            this.emitTouchEvent('rotate', {
                angle: currentRotation,
                delta: rotationDelta
            });
        }
        
        this.lastPinchDistance = currentDistance;
        this.lastRotation = currentRotation;
    }
    
    /**
     * Handle touch end
     * @param {TouchEvent} event - Touch event
     */
    handleTouchEnd(event) {
        event.preventDefault();
        
        const now = Date.now();
        
        // Process ended touches
        for (const touch of event.changedTouches) {
            const storedTouch = this.touches.get(touch.identifier);
            
            if (storedTouch) {
                const duration = now - storedTouch.startTime;
                const deltaX = storedTouch.currentX - storedTouch.startX;
                const deltaY = storedTouch.currentY - storedTouch.startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                // Detect tap
                if (duration < 300 && distance < 10) {
                    if (this.tapCount === 2) {
                        this.emitTouchEvent('doubleTap', {
                            x: storedTouch.currentX,
                            y: storedTouch.currentY
                        });
                        this.tapCount = 0;
                    } else {
                        this.emitTouchEvent('tap', {
                            x: storedTouch.currentX,
                            y: storedTouch.currentY
                        });
                    }
                }
                
                // Detect long press
                if (duration > 500 && distance < 10) {
                    this.emitTouchEvent('longPress', {
                        x: storedTouch.currentX,
                        y: storedTouch.currentY
                    });
                }
                
                this.touches.delete(touch.identifier);
            }
        }
        
        // Reset gesture state
        if (event.touches.length === 0) {
            this.currentGesture = null;
            this.isPinching = false;
            this.isRotating = false;
        }
        
        // Emit touch end event
        this.emitTouchEvent('touchEnd', {
            gesture: this.currentGesture,
            duration: now - this.gestureStartTime
        });
    }
    
    /**
     * Handle touch cancel
     * @param {TouchEvent} event - Touch event
     */
    handleTouchCancel(event) {
        // Clear all touches
        this.touches.clear();
        this.currentGesture = null;
        this.isPinching = false;
        this.isRotating = false;
        
        this.emitTouchEvent('touchCancel', {});
    }
    
    /**
     * Handle orientation change
     * @param {Event} event - Orientation change event
     */
    handleOrientationChange(event) {
        this.orientation = this.getOrientation();
        
        // Emit orientation change event
        this.emitTouchEvent('orientationChange', {
            orientation: this.orientation,
            angle: window.orientation || 0
        });
        
        // Apply orientation-specific optimizations
        this.applyOrientationOptimizations();
    }
    
    /**
     * Handle device orientation
     * @param {DeviceOrientationEvent} event - Device orientation event
     */
    handleDeviceOrientation(event) {
        // Could be used for gyroscope-based interactions
        const { alpha, beta, gamma } = event;
        
        this.emitTouchEvent('deviceOrientation', {
            alpha, // Z axis rotation
            beta,  // X axis rotation
            gamma  // Y axis rotation
        });
    }
    
    /**
     * Handle viewport change
     * @param {Event} event - Resize event
     */
    handleViewportChange(event) {
        const now = Date.now();
        
        // Debounce viewport changes
        if (now - this.lastViewportChange < 100) return;
        
        this.lastViewportChange = now;
        this.viewportSize = {
            width: window.innerWidth,
            height: window.innerHeight
        };
        
        // Update pixel ratio
        this.pixelRatio = window.devicePixelRatio || 1;
        
        // Emit viewport change event
        this.emitTouchEvent('viewportChange', {
            size: this.viewportSize,
            pixelRatio: this.pixelRatio,
            orientation: this.getOrientation()
        });
        
        // Apply responsive scaling
        if (this.config.enableResponsiveScaling) {
            this.applyResponsiveScaling();
        }
    }
    
    /**
     * Handle visibility change
     * @param {Event} event - Visibility change event
     */
    handleVisibilityChange(event) {
        const isVisible = !document.hidden;
        
        this.emitTouchEvent('visibilityChange', {
            visible: isVisible
        });
        
        // Apply optimizations based on visibility
        if (!isVisible && this.config.enableBatteryOptimization) {
            // Reduce performance when app is in background
            this.applyBackgroundOptimizations();
        } else {
            // Restore performance when app is visible
            this.restorePerformance();
        }
    }
    
    /**
     * Get current orientation
     * @returns {string} Orientation (portrait or landscape)
     */
    getOrientation() {
        return window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
    }
    
    /**
     * Get distance between two points
     * @param {number} x1 - First X coordinate
     * @param {number} y1 - First Y coordinate
     * @param {number} x2 - Second X coordinate
     * @param {number} y2 - Second Y coordinate
     * @returns {number} Distance
     */
    getDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Get angle between two points
     * @param {number} x1 - First X coordinate
     * @param {number} y1 - First Y coordinate
     * @param {number} x2 - Second X coordinate
     * @param {number} y2 - Second Y coordinate
     * @returns {number} Angle in degrees
     */
    getAngle(x1, y1, x2, y2) {
        return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
    }
    
    /**
     * Apply mobile optimizations
     */
    applyMobileOptimizations() {
        if (!this.isMobile && !this.isTablet) return;
        
        const optimizations = {
            ...this.mobilePerformanceSettings,
            canvasScale: this.calculateOptimalCanvasScale(),
            useWebGL: false, // Disable WebGL on mobile for battery
            useOffscreenCanvas: this.useOffscreenCanvas
        };
        
        // Emit optimization settings
        this.emitTouchEvent('mobileOptimizations', optimizations);
        
        return optimizations;
    }
    
    /**
     * Apply orientation-specific optimizations
     */
    applyOrientationOptimizations() {
        const isLandscape = this.orientation === 'landscape';
        
        const optimizations = {
            layoutMode: isLandscape ? 'horizontal' : 'vertical',
            particleDirection: isLandscape ? 'horizontal' : 'vertical',
            uiScale: isLandscape ? 0.8 : 1.0
        };
        
        this.emitTouchEvent('orientationOptimizations', optimizations);
        
        return optimizations;
    }
    
    /**
     * Apply responsive scaling
     */
    applyResponsiveScaling() {
        const baseWidth = 375; // iPhone 6/7/8 width as base
        const scaleFactor = Math.min(
            this.viewportSize.width / baseWidth,
            2.0 // Max scale factor
        );
        
        this.canvasScale = scaleFactor;
        
        this.emitTouchEvent('responsiveScale', {
            scale: this.canvasScale,
            viewport: this.viewportSize
        });
        
        return this.canvasScale;
    }
    
    /**
     * Apply background optimizations for battery saving
     */
    applyBackgroundOptimizations() {
        const optimizations = {
            targetFPS: 5, // Very low FPS in background
            particlesEnabled: false,
            animationsEnabled: false,
            audioEnabled: false
        };
        
        this.emitTouchEvent('backgroundOptimizations', optimizations);
        
        return optimizations;
    }
    
    /**
     * Restore performance settings
     */
    restorePerformance() {
        const settings = this.applyMobileOptimizations();
        
        this.emitTouchEvent('performanceRestore', settings);
        
        return settings;
    }
    
    /**
     * Handle battery change
     */
    onBatteryChange() {
        this.lowPowerMode = this.batteryLevel < 0.2 && !this.isCharging;
        
        if (this.lowPowerMode) {
            // Apply low power optimizations
            const optimizations = {
                targetFPS: 15,
                maxParticles: 5,
                reducedEffects: true,
                audioEnabled: false
            };
            
            this.emitTouchEvent('lowPowerMode', {
                batteryLevel: this.batteryLevel,
                isCharging: this.isCharging,
                optimizations
            });
        }
    }
    
    /**
     * Calculate optimal canvas scale for device
     * @returns {number} Scale factor
     */
    calculateOptimalCanvasScale() {
        // Balance between quality and performance
        if (this.isMobile) {
            return Math.min(this.pixelRatio, 2); // Cap at 2x for mobile
        } else if (this.isTablet) {
            return Math.min(this.pixelRatio, 2.5); // Slightly higher for tablets
        }
        
        return this.pixelRatio; // Full resolution for desktop
    }
    
    /**
     * Get canvas element
     * @returns {HTMLCanvasElement} Canvas element
     */
    getCanvas() {
        // This would be set by the main application
        return this.canvas || document.querySelector('canvas');
    }
    
    /**
     * Set canvas element
     * @param {HTMLCanvasElement} canvas - Canvas element
     */
    setCanvas(canvas) {
        this.canvas = canvas;
        
        if (this.config.enableTouchOptimization && this.isTouchDevice) {
            this.setupTouchHandlers();
        }
    }
    
    /**
     * Emit touch event
     * @param {string} eventType - Event type
     * @param {Object} data - Event data
     */
    emitTouchEvent(eventType, data) {
        if (this.onTouchEvent) {
            this.onTouchEvent(eventType, data);
        }
    }
    
    /**
     * Get mobile optimization status
     * @returns {Object} Status report
     */
    getStatus() {
        return {
            device: {
                isMobile: this.isMobile,
                isTablet: this.isTablet,
                isTouchDevice: this.isTouchDevice,
                isIOS: this.isIOS,
                isAndroid: this.isAndroid
            },
            viewport: {
                size: this.viewportSize,
                orientation: this.orientation,
                pixelRatio: this.pixelRatio,
                canvasScale: this.canvasScale
            },
            battery: {
                level: this.batteryLevel,
                isCharging: this.isCharging,
                lowPowerMode: this.lowPowerMode
            },
            touch: {
                activeTouches: this.touches.size,
                currentGesture: this.currentGesture,
                isPinching: this.isPinching,
                isRotating: this.isRotating
            },
            performance: this.mobilePerformanceSettings
        };
    }
    
    /**
     * Destroy mobile optimization
     */
    destroy() {
        const canvas = this.getCanvas();
        
        if (canvas) {
            canvas.removeEventListener('touchstart', this.handleTouchStart);
            canvas.removeEventListener('touchmove', this.handleTouchMove);
            canvas.removeEventListener('touchend', this.handleTouchEnd);
            canvas.removeEventListener('touchcancel', this.handleTouchCancel);
        }
        
        window.removeEventListener('resize', this.handleViewportChange);
        window.removeEventListener('orientationchange', this.handleOrientationChange);
        document.removeEventListener('visibilitychange', this.handleVisibilityChange);
        
        this.touches.clear();
        this.gestureHistory = [];
        
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  PLUGIN SYSTEM  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Plugin System - Extensible Architecture for Custom Behaviors
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module PluginSystem
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The EXPANSION SLOT for creativity. Allows developers to extend the mascot         
 * ║ with custom emotions, gestures, particles, and behaviors without modifying        
 * ║ core code. Build your own emotional expressions!                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔌 PLUGIN TYPES                                                                    
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • emotion  : Add custom emotional states                                          
 * │ • gesture  : Define new gesture animations                                        
 * │ • particle : Create custom particle behaviors                                     
 * │ • audio    : Add sound effects and tones                                          
 * │ • renderer : Modify rendering pipeline                                            
 * │ • behavior : Add complex behavioral patterns                                      
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎯 LIFECYCLE HOOKS                                                                 
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • init()     : Called when plugin is registered                                   
 * │ • update()   : Called every frame                                                 
 * │ • render()   : Called during render phase                                         
 * │ • destroy()  : Called when plugin is unregistered                                 
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class PluginSystem {
    constructor(config = {}) {
        this.config = {
            enablePlugins: config.enablePlugins !== false,
            validatePlugins: config.validatePlugins !== false,
            sandboxPlugins: config.sandboxPlugins !== false,
            maxPlugins: config.maxPlugins || 50,
            pluginTimeout: config.pluginTimeout || 5000,
            allowOverrides: config.allowOverrides !== false,
            ...config
        };
        
        // Plugin registry
        this.plugins = new Map();
        this.pluginTypes = ['emotion', 'gesture', 'particle', 'audio', 'renderer', 'animation'];
        this.pluginsByType = new Map(this.pluginTypes.map(type => [type, new Set()]));
        
        // Plugin dependencies
        this.dependencies = new Map();
        this.dependencyGraph = new Map();
        
        // Plugin lifecycle states
        this.pluginStates = new Map();
        this.loadingPlugins = new Set();
        this.activePlugins = new Set();
        
        // Plugin hooks
        this.hooks = new Map([
            ['beforeInit', new Set()],
            ['afterInit', new Set()],
            ['beforeUpdate', new Set()],
            ['afterUpdate', new Set()],
            ['beforeRender', new Set()],
            ['afterRender', new Set()],
            ['beforeDestroy', new Set()],
            ['afterDestroy', new Set()]
        ]);
        
        // Plugin API exposed to plugins
        this.pluginAPI = this.createPluginAPI();
        
        // Conflict resolution
        this.conflicts = new Map();
        this.resolutionStrategies = {
            'override': this.overrideConflict.bind(this),
            'merge': this.mergeConflict.bind(this),
            'reject': this.rejectConflict.bind(this),
            'queue': this.queueConflict.bind(this)
        };
        
        // Plugin validation schemas
        this.validationSchemas = this.createValidationSchemas();
        
        // Sandbox environment for plugins
        this.sandbox = null;
        if (this.config.sandboxPlugins) {
            this.sandbox = this.createSandbox();
        }
        
        // PluginSystem initialized
    }
    
    /**
     * Create plugin API exposed to plugins
     * @returns {Object} Plugin API
     */
    createPluginAPI() {
        return {
            // Core functionality
            registerHook: this.registerHook.bind(this),
            emit: this.emitPluginEvent.bind(this),
            on: this.onPluginEvent.bind(this),
            
            // Access to other plugins
            getPlugin: this.getPlugin.bind(this),
            hasPlugin: this.hasPlugin.bind(this),
            
            // Utilities
            log: this.logFromPlugin.bind(this),
            error: this.errorFromPlugin.bind(this),
            
            // State management
            setState: this.setPluginState.bind(this),
            getState: this.getPluginState.bind(this),
            
            // Configuration
            getConfig: () => ({ ...this.config }),
            
            // Version info
            version: '1.0.0'
        };
    }
    
    /**
     * Create validation schemas for different plugin types
     * @returns {Map} Validation schemas
     */
    createValidationSchemas() {
        const schemas = new Map();
        
        // Base schema for all plugins
        const baseSchema = {
            name: { type: 'string', required: true },
            version: { type: 'string', required: true },
            type: { type: 'string', required: true, enum: this.pluginTypes },
            description: { type: 'string', required: false },
            author: { type: 'string', required: false },
            dependencies: { type: 'array', required: false },
            conflicts: { type: 'array', required: false },
            init: { type: 'function', required: true },
            destroy: { type: 'function', required: true }
        };
        
        // Emotion plugin schema
        schemas.set('emotion', {
            ...baseSchema,
            emotion: {
                type: 'object',
                required: true,
                properties: {
                    name: { type: 'string', required: true },
                    color: { type: 'string', required: true },
                    particleColor: { type: 'string', required: false },
                    animation: { type: 'object', required: true },
                    transitions: { type: 'object', required: false }
                }
            },
            updateEmotion: { type: 'function', required: true },
            renderEmotion: { type: 'function', required: false }
        });
        
        // Gesture plugin schema
        schemas.set('gesture', {
            ...baseSchema,
            gesture: {
                type: 'object',
                required: true,
                properties: {
                    name: { type: 'string', required: true },
                    duration: { type: 'number', required: true },
                    keyframes: { type: 'array', required: true },
                    compatibility: { type: 'object', required: false }
                }
            },
            executeGesture: { type: 'function', required: true },
            canExecute: { type: 'function', required: false }
        });
        
        // Particle plugin schema
        schemas.set('particle', {
            ...baseSchema,
            particle: {
                type: 'object',
                required: true,
                properties: {
                    name: { type: 'string', required: true },
                    maxParticles: { type: 'number', required: false },
                    behavior: { type: 'function', required: true },
                    render: { type: 'function', required: true }
                }
            },
            updateParticles: { type: 'function', required: true },
            spawnParticle: { type: 'function', required: false }
        });
        
        // Audio plugin schema
        schemas.set('audio', {
            ...baseSchema,
            audio: {
                type: 'object',
                required: true,
                properties: {
                    name: { type: 'string', required: true },
                    sounds: { type: 'object', required: true },
                    effects: { type: 'array', required: false }
                }
            },
            playSound: { type: 'function', required: true },
            processAudio: { type: 'function', required: false }
        });
        
        return schemas;
    }
    
    /**
     * Create sandbox environment for plugin execution
     * @returns {Object} Sandbox environment
     */
    createSandbox() {
        // Create a limited execution environment
        const sandbox = {
            // Safe global objects
            Math,
            Date,
            JSON,
            
            // Limited console
            console: {
                log: (...args) => null,
                warn: (...args) => null,
                error: (...args) => null
            },
            
            // No access to window, document, or other globals
            window: undefined,
            document: undefined,
            localStorage: undefined,
            sessionStorage: undefined,
            fetch: undefined,
            XMLHttpRequest: undefined,
            
            // Plugin API
            api: this.pluginAPI
        };
        
        return sandbox;
    }
    
    /**
     * Register a plugin
     * @param {Object} plugin - Plugin to register
     * @returns {boolean} Success status
     */
    async registerPlugin(plugin) {
        if (!this.config.enablePlugins) {
            // Plugins are disabled
            return false;
        }
        
        // Check plugin limit
        if (this.plugins.size >= this.config.maxPlugins) {
            // Maximum plugin limit reached
            return false;
        }
        
        // Validate plugin
        if (this.config.validatePlugins) {
            const validation = this.validatePlugin(plugin);
            if (!validation.valid) {
                // Plugin validation failed
                return false;
            }
        }
        
        // Check for conflicts
        const conflicts = this.checkConflicts(plugin);
        if (conflicts.length > 0 && !this.config.allowOverrides) {
            // Plugin conflicts detected
            return false;
        }
        
        // Resolve dependencies
        const dependencies = await this.resolveDependencies(plugin);
        if (!dependencies.resolved) {
            // Plugin dependencies not met
            return false;
        }
        
        // Initialize plugin in sandbox if enabled
        try {
            this.loadingPlugins.add(plugin.name);
            
            const context = this.config.sandboxPlugins ? this.sandbox : window;
            const initialized = await this.initializePlugin(plugin, context);
            
            if (!initialized) {
                throw new Error('Plugin initialization failed');
            }
            
            // Register plugin
            this.plugins.set(plugin.name, plugin);
            this.pluginsByType.get(plugin.type).add(plugin.name);
            this.pluginStates.set(plugin.name, 'active');
            this.activePlugins.add(plugin.name);
            
            // Store dependencies
            if (plugin.dependencies) {
                this.dependencies.set(plugin.name, plugin.dependencies);
                this.updateDependencyGraph(plugin.name, plugin.dependencies);
            }
            
            // Register hooks if provided
            if (plugin.hooks) {
                Object.entries(plugin.hooks).forEach(([hook, handler]) => {
                    this.registerHook(hook, handler, plugin.name);
                });
            }
            
            // Plugin registered
            
            // Emit registration event
            this.emitPluginEvent('pluginRegistered', {
                name: plugin.name,
                type: plugin.type,
                version: plugin.version
            });
            
            return true;
            
        } catch (error) {
            // Failed to register plugin
            return false;
        } finally {
            this.loadingPlugins.delete(plugin.name);
        }
    }
    
    /**
     * Validate a plugin against its schema
     * @param {Object} plugin - Plugin to validate
     * @returns {Object} Validation result
     */
    validatePlugin(plugin) {
        const errors = [];
        
        // Check required base properties
        if (!plugin.name || typeof plugin.name !== 'string') {
            errors.push('Plugin must have a valid name');
        }
        
        if (!plugin.type || !this.pluginTypes.includes(plugin.type)) {
            errors.push(`Plugin type must be one of: ${this.pluginTypes.join(', ')}`);
        }
        
        if (!plugin.version || typeof plugin.version !== 'string') {
            errors.push('Plugin must have a version');
        }
        
        if (typeof plugin.init !== 'function') {
            errors.push('Plugin must have an init function');
        }
        
        if (typeof plugin.destroy !== 'function') {
            errors.push('Plugin must have a destroy function');
        }
        
        // Validate type-specific schema
        if (plugin.type && this.validationSchemas.has(plugin.type)) {
            const schema = this.validationSchemas.get(plugin.type);
            const typeErrors = this.validateAgainstSchema(plugin, schema);
            errors.push(...typeErrors);
        }
        
        return {
            valid: errors.length === 0,
            errors
        };
    }
    
    /**
     * Validate object against schema
     * @param {Object} obj - Object to validate
     * @param {Object} schema - Schema to validate against
     * @returns {Array} Array of errors
     */
    validateAgainstSchema(obj, schema) {
        const errors = [];
        
        Object.entries(schema).forEach(([key, rules]) => {
            if (rules.required && !(key in obj)) {
                errors.push(`Missing required property: ${key}`);
            }
            
            if (key in obj) {
                const value = obj[key];
                
                if (rules.type && typeof value !== rules.type) {
                    errors.push(`Property ${key} must be of type ${rules.type}`);
                }
                
                if (rules.enum && !rules.enum.includes(value)) {
                    errors.push(`Property ${key} must be one of: ${rules.enum.join(', ')}`);
                }
                
                if (rules.properties && typeof value === 'object') {
                    const subErrors = this.validateAgainstSchema(value, rules.properties);
                    errors.push(...subErrors.map(e => `${key}.${e}`));
                }
            }
        });
        
        return errors;
    }
    
    /**
     * Check for plugin conflicts
     * @param {Object} plugin - Plugin to check
     * @returns {Array} Array of conflicts
     */
    checkConflicts(plugin) {
        const conflicts = [];
        
        // Check explicit conflicts
        if (plugin.conflicts) {
            plugin.conflicts.forEach(conflictName => {
                if (this.plugins.has(conflictName)) {
                    conflicts.push(conflictName);
                }
            });
        }
        
        // Check type-specific conflicts
        if (plugin.type === 'emotion' || plugin.type === 'gesture') {
            // Check for name collisions
            this.plugins.forEach(existingPlugin => {
                if (existingPlugin.type === plugin.type) {
                    const existingName = existingPlugin[plugin.type]?.name;
                    const newName = plugin[plugin.type]?.name;
                    
                    if (existingName === newName) {
                        conflicts.push(`${plugin.type} name collision: ${newName}`);
                    }
                }
            });
        }
        
        return conflicts;
    }
    
    /**
     * Resolve plugin dependencies
     * @param {Object} plugin - Plugin to resolve dependencies for
     * @returns {Object} Resolution result
     */
    async resolveDependencies(plugin) {
        if (!plugin.dependencies || plugin.dependencies.length === 0) {
            return { resolved: true, missing: [] };
        }
        
        const missing = [];
        
        for (const dep of plugin.dependencies) {
            // Check if dependency is already loaded
            if (!this.plugins.has(dep)) {
                // Try to load dependency
                const loaded = await this.tryLoadDependency(dep);
                if (!loaded) {
                    missing.push(dep);
                }
            }
        }
        
        return {
            resolved: missing.length === 0,
            missing
        };
    }
    
    /**
     * Try to load a dependency
     * @param {string} dependencyName - Dependency name
     * @returns {boolean} Success status
     */
    tryLoadDependency(dependencyName) {
        // This would attempt to load the dependency
        // For now, just check if it exists
        return this.plugins.has(dependencyName);
    }
    
    /**
     * Update dependency graph
     * @param {string} pluginName - Plugin name
     * @param {Array} dependencies - Dependencies
     */
    updateDependencyGraph(pluginName, dependencies) {
        this.dependencyGraph.set(pluginName, new Set(dependencies));
        
        // Update reverse dependencies
        dependencies.forEach(dep => {
            if (!this.dependencyGraph.has(dep)) {
                this.dependencyGraph.set(dep, new Set());
            }
        });
    }
    
    /**
     * Initialize a plugin
     * @param {Object} plugin - Plugin to initialize
     * @param {Object} context - Execution context
     * @returns {boolean} Success status
     */
    async initializePlugin(plugin, context) {
        try {
            // Set timeout for initialization
            const timeout = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Plugin initialization timeout')), this.config.pluginTimeout);
            });
            
            // Initialize plugin
            const init = plugin.init.bind(context);
            const result = await Promise.race([
                init(this.pluginAPI),
                timeout
            ]);
            
            return result !== false;
        } catch (error) {
            // Plugin initialization error
            return false;
        }
    }
    
    /**
     * Unregister a plugin
     * @param {string} pluginName - Name of plugin to unregister
     * @returns {boolean} Success status
     */
    async unregisterPlugin(pluginName) {
        const plugin = this.plugins.get(pluginName);
        if (!plugin) {
            // Plugin not found
            return false;
        }
        
        // Check for dependent plugins
        const dependents = this.getDependentPlugins(pluginName);
        if (dependents.length > 0) {
            // Cannot unregister plugin - required by dependents
            return false;
        }
        
        try {
            // Call destroy method
            if (typeof plugin.destroy === 'function') {
                await plugin.destroy();
            }
            
            // Remove from registries
            this.plugins.delete(pluginName);
            this.pluginsByType.get(plugin.type).delete(pluginName);
            this.pluginStates.delete(pluginName);
            this.activePlugins.delete(pluginName);
            this.dependencies.delete(pluginName);
            this.dependencyGraph.delete(pluginName);
            
            // Remove hooks
            this.hooks.forEach(hookSet => {
                hookSet.forEach(hook => {
                    if (hook.pluginName === pluginName) {
                        hookSet.delete(hook);
                    }
                });
            });
            
            // Plugin unregistered
            
            // Emit unregistration event
            this.emitPluginEvent('pluginUnregistered', { name: pluginName });
            
            return true;
        } catch (error) {
            // Failed to unregister plugin
            return false;
        }
    }
    
    /**
     * Get plugins dependent on a given plugin
     * @param {string} pluginName - Plugin name
     * @returns {Array} Array of dependent plugin names
     */
    getDependentPlugins(pluginName) {
        const dependents = [];
        
        this.dependencies.forEach((deps, name) => {
            if (deps.includes(pluginName)) {
                dependents.push(name);
            }
        });
        
        return dependents;
    }
    
    /**
     * Register a hook handler
     * @param {string} hookName - Hook name
     * @param {Function} handler - Handler function
     * @param {string} pluginName - Plugin name
     */
    registerHook(hookName, handler, pluginName) {
        if (!this.hooks.has(hookName)) {
            this.hooks.set(hookName, new Set());
        }
        
        this.hooks.get(hookName).add({
            handler,
            pluginName
        });
    }
    
    /**
     * Execute hooks for a given event
     * @param {string} hookName - Hook name
     * @param {*} data - Data to pass to hooks
     * @returns {Array} Results from hooks
     */
    async executeHooks(hookName, data) {
        const hooks = this.hooks.get(hookName);
        if (!hooks || hooks.size === 0) return [];
        
        const results = [];
        
        for (const hook of hooks) {
            try {
                const result = await hook.handler(data);
                results.push({ pluginName: hook.pluginName, result });
            } catch (error) {
                // Hook error in plugin
            }
        }
        
        return results;
    }
    
    /**
     * Get a plugin by name
     * @param {string} pluginName - Plugin name
     * @returns {Object} Plugin or null
     */
    getPlugin(pluginName) {
        return this.plugins.get(pluginName) || null;
    }
    
    /**
     * Check if a plugin exists
     * @param {string} pluginName - Plugin name
     * @returns {boolean} True if plugin exists
     */
    hasPlugin(pluginName) {
        return this.plugins.has(pluginName);
    }
    
    /**
     * Get plugins by type
     * @param {string} type - Plugin type
     * @returns {Array} Array of plugins
     */
    getPluginsByType(type) {
        const pluginNames = this.pluginsByType.get(type);
        if (!pluginNames) return [];
        
        return Array.from(pluginNames).map(name => this.plugins.get(name));
    }
    
    /**
     * Enable a plugin
     * @param {string} pluginName - Plugin name
     */
    enablePlugin(pluginName) {
        if (!this.plugins.has(pluginName)) return;
        
        this.pluginStates.set(pluginName, 'active');
        this.activePlugins.add(pluginName);
        
        const plugin = this.plugins.get(pluginName);
        if (plugin.onEnable) {
            plugin.onEnable();
        }
        
        this.emitPluginEvent('pluginEnabled', { name: pluginName });
    }
    
    /**
     * Disable a plugin
     * @param {string} pluginName - Plugin name
     */
    disablePlugin(pluginName) {
        if (!this.plugins.has(pluginName)) return;
        
        // Check dependents
        this.getDependentPlugins(pluginName);
        
        this.pluginStates.set(pluginName, 'disabled');
        this.activePlugins.delete(pluginName);
        
        const plugin = this.plugins.get(pluginName);
        if (plugin.onDisable) {
            plugin.onDisable();
        }
        
        this.emitPluginEvent('pluginDisabled', { name: pluginName });
    }
    
    /**
     * Emit plugin event
     * @param {string} eventName - Event name
     * @param {*} data - Event data
     */
    emitPluginEvent(eventName, data) {
        // This would integrate with the main event system
        if (this.onPluginEvent) {
            this.onPluginEvent(eventName, data);
        }
    }
    
    /**
     * Listen for plugin events
     * @param {string} eventName - Event name
     * @param {Function} handler - Event handler
     */
    onPluginEvent(eventName, handler) {
        // This would integrate with the main event system
        // Placeholder for event listening
    }
    
    /**
     * Log from plugin context
     * @param {string} pluginName - Plugin name
     * @param {...*} args - Log arguments
     */
    logFromPlugin(pluginName, ...args) {
        // Plugin log message
    }
    
    /**
     * Error from plugin context
     * @param {string} pluginName - Plugin name
     * @param {...*} args - Error arguments
     */
    errorFromPlugin(pluginName, ...args) {
        // Plugin error message
    }
    
    /**
     * Set plugin state
     * @param {string} pluginName - Plugin name
     * @param {string} key - State key
     * @param {*} value - State value
     */
    setPluginState(pluginName, key, value) {
        if (!this.pluginStates.has(pluginName)) {
            this.pluginStates.set(pluginName, {});
        }
        
        const state = this.pluginStates.get(pluginName);
        if (typeof state === 'object') {
            state[key] = value;
        }
    }
    
    /**
     * Get plugin state
     * @param {string} pluginName - Plugin name
     * @param {string} key - State key
     * @returns {*} State value
     */
    getPluginState(pluginName, key) {
        const state = this.pluginStates.get(pluginName);
        if (typeof state === 'object') {
            return state[key];
        }
        return undefined;
    }
    
    /**
     * Conflict resolution strategies
     */
    overrideConflict(existing, incoming) {
        return incoming; // New plugin overrides existing
    }
    
    mergeConflict(existing, incoming) {
        return { ...existing, ...incoming }; // Merge properties
    }
    
    rejectConflict(existing, incoming) {
        return existing; // Keep existing, reject new
    }
    
    queueConflict(existing, incoming) {
        return [existing, incoming]; // Queue both
    }
    
    /**
     * Get plugin system status
     * @returns {Object} Status report
     */
    getStatus() {
        return {
            enabled: this.config.enablePlugins,
            totalPlugins: this.plugins.size,
            activePlugins: this.activePlugins.size,
            loadingPlugins: this.loadingPlugins.size,
            pluginsByType: Object.fromEntries(
                Array.from(this.pluginsByType.entries()).map(([type, plugins]) => [type, plugins.size])
            ),
            hooks: Object.fromEntries(
                Array.from(this.hooks.entries()).map(([hook, handlers]) => [hook, handlers.size])
            )
        };
    }
    
    /**
     * Destroy plugin system
     */
    async destroy() {
        // Unregister all plugins
        const pluginNames = Array.from(this.plugins.keys());
        
        for (const name of pluginNames) {
            await this.unregisterPlugin(name);
        }
        
        // Clear all data
        this.plugins.clear();
        this.pluginsByType.clear();
        this.dependencies.clear();
        this.dependencyGraph.clear();
        this.pluginStates.clear();
        this.activePlugins.clear();
        this.loadingPlugins.clear();
        this.hooks.clear();
        this.conflicts.clear();
        
        // PluginSystem destroyed
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                 ◐ ◑ ◒ ◓  BROWSER COMPATIBILITY  ◓ ◒ ◑ ◐                 
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Browser Compatibility - Feature Detection & Graceful Degradation
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module BrowserCompatibility
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The COMPATIBILITY LAYER of the engine. Ensures the Emotive Engine runs           
 * ║ smoothly across all modern browsers by detecting features, providing              
 * ║ polyfills, and enabling graceful degradation when features are missing.           
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🌐 BROWSER FEATURES                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Web Audio API detection and fallbacks                                           
 * │ • Canvas 2D context recovery and management                                       
 * │ • RequestAnimationFrame polyfills                                                 
 * │ • Device pixel ratio handling                                                     
 * │ • Performance API detection                                                       
 * │ • Media device capabilities                                                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Feature detection utilities
 */
class FeatureDetection {
    constructor() {
        // Cache detection results to avoid repeated expensive checks
        if (FeatureDetection._cachedFeatures) {
            this.features = FeatureDetection._cachedFeatures;
            this.capabilities = FeatureDetection._cachedCapabilities;
            return;
        }
        
        this.features = {
            webAudio: this.detectWebAudio(),
            canvas2d: this.detectCanvas2D(),
            requestAnimationFrame: this.detectRequestAnimationFrame(),
            devicePixelRatio: this.detectDevicePixelRatio(),
            audioContext: this.detectAudioContext(),
            mediaDevices: this.detectMediaDevices(),
            performance: this.detectPerformance(),
            intersectionObserver: this.detectIntersectionObserver()
        };
        
        this.capabilities = this.assessCapabilities();
        
        // Cache results for future instantiations
        FeatureDetection._cachedFeatures = this.features;
        FeatureDetection._cachedCapabilities = this.capabilities;
    }

    /**
     * Detect Web Audio API support
     * @returns {boolean} True if Web Audio API is supported
     */
    detectWebAudio() {
        try {
            return !!(window.AudioContext || window.webkitAudioContext);
        } catch (e) {
            return false;
        }
    }

    /**
     * Detect Canvas 2D support
     * @returns {boolean} True if Canvas 2D is supported
     */
    detectCanvas2D() {
        try {
            const canvas = document.createElement('canvas');
            return !!(canvas.getContext && canvas.getContext('2d'));
        } catch (e) {
            return false;
        }
    }

    /**
     * Detect requestAnimationFrame support
     * @returns {boolean} True if requestAnimationFrame is supported
     */
    detectRequestAnimationFrame() {
        return !!(window.requestAnimationFrame || 
                 window.webkitRequestAnimationFrame || 
                 window.mozRequestAnimationFrame || 
                 window.oRequestAnimationFrame || 
                 window.msRequestAnimationFrame);
    }

    /**
     * Detect device pixel ratio support
     * @returns {boolean} True if devicePixelRatio is supported
     */
    detectDevicePixelRatio() {
        return typeof window.devicePixelRatio === 'number';
    }

    /**
     * Detect AudioContext support (more specific than Web Audio)
     * @returns {boolean} True if AudioContext is supported
     */
    detectAudioContext() {
        try {
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (!AudioContextClass) return false;
            
            // Don't create a test context - just check if the class exists
            // Creating contexts is expensive and has limits
            return true;
        } catch (e) {
            return false;
        }
    }

    /**
     * Detect MediaDevices API support
     * @returns {boolean} True if MediaDevices API is supported
     */
    detectMediaDevices() {
        return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
    }

    /**
     * Detect Performance API support
     * @returns {boolean} True if Performance API is supported
     */
    detectPerformance() {
        return !!(window.performance && window.performance.now);
    }

    /**
     * Detect Intersection Observer support
     * @returns {boolean} True if Intersection Observer is supported
     */
    detectIntersectionObserver() {
        return typeof window.IntersectionObserver === 'function';
    }

    /**
     * Assess overall browser capabilities
     * @returns {Object} Capability assessment
     */
    assessCapabilities() {
        const score = Object.values(this.features).filter(Boolean).length;
        const total = Object.keys(this.features).length;
        const percentage = (score / total) * 100;

        let level = 'basic';
        if (percentage >= 90) level = 'full';
        else if (percentage >= 70) level = 'good';
        else if (percentage >= 50) level = 'limited';

        return {
            score,
            total,
            percentage,
            level,
            recommendations: this.getRecommendations(level)
        };
    }

    /**
     * Get recommendations based on capability level
     * @param {string} level - Capability level
     * @returns {Array<string>} Array of recommendations
     */
    getRecommendations(level) {
        const recommendations = [];

        if (!this.features.webAudio) {
            recommendations.push('Audio features will be disabled');
        }
        if (!this.features.requestAnimationFrame) {
            recommendations.push('Animation will use setTimeout fallback');
        }
        if (!this.features.performance) {
            recommendations.push('Performance monitoring will be limited');
        }
        if (level === 'basic') {
            recommendations.push('Consider using minimal build for better performance');
        }

        return recommendations;
    }

    /**
     * Get all detected features
     * @returns {Object} Feature detection results
     */
    getFeatures() {
        return { ...this.features };
    }

    /**
     * Get capability assessment
     * @returns {Object} Capability assessment
     */
    getCapabilities() {
        return { ...this.capabilities };
    }
}

/**
 * Polyfill manager for missing browser features
 */
class PolyfillManager {
    constructor() {
        this.polyfills = new Map();
        this.applied = new Set();
    }

    /**
     * Register a polyfill
     * @param {string} feature - Feature name
     * @param {Function} polyfillFn - Polyfill function
     */
    register(feature, polyfillFn) {
        this.polyfills.set(feature, polyfillFn);
    }

    /**
     * Apply a specific polyfill
     * @param {string} feature - Feature name
     * @returns {boolean} True if polyfill was applied
     */
    apply(feature) {
        if (this.applied.has(feature)) {
            return true; // Already applied
        }

        const polyfillFn = this.polyfills.get(feature);
        if (!polyfillFn) {
            // No polyfill registered for feature
            return false;
        }

        try {
            polyfillFn();
            this.applied.add(feature);
            // Applied polyfill for feature
            return true;
        } catch (error) {
            // Failed to apply polyfill for feature
            return false;
        }
    }

    /**
     * Apply all registered polyfills
     * @returns {Array<string>} Array of successfully applied polyfills
     */
    applyAll() {
        const applied = [];
        for (const feature of this.polyfills.keys()) {
            if (this.apply(feature)) {
                applied.push(feature);
            }
        }
        return applied;
    }

    /**
     * Check if a polyfill has been applied
     * @param {string} feature - Feature name
     * @returns {boolean} True if polyfill has been applied
     */
    isApplied(feature) {
        return this.applied.has(feature);
    }
}

/**
 * RequestAnimationFrame polyfill
 */
function polyfillRequestAnimationFrame() {
    if (window.requestAnimationFrame) return;

    // Try vendor prefixes first
    window.requestAnimationFrame = 
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
            return window.setTimeout(() => {
                callback(Date.now());
            }, 1000 / 60); // 60 FPS fallback
        };

    window.cancelAnimationFrame = 
        window.webkitCancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        window.oCancelAnimationFrame ||
        window.msCancelAnimationFrame ||
        function(id) {
            window.clearTimeout(id);
        };
}

/**
 * Performance.now polyfill
 */
function polyfillPerformanceNow() {
    if (window.performance && window.performance.now) return;

    if (!window.performance) {
        window.performance = {};
    }

    const startTime = Date.now();
    window.performance.now = function() {
        return Date.now() - startTime;
    };
}

/**
 * Web Audio API polyfill (basic fallback)
 */
function polyfillWebAudio() {
    if (window.AudioContext || window.webkitAudioContext) return;

    // Create a minimal AudioContext-like interface
    window.AudioContext = function() {
        this.state = 'suspended';
        this.sampleRate = 44100;
        this.currentTime = 0;
        this.destination = {
            connect() {},
            disconnect() {}
        };

        this.createGain = function() {
            return {
                gain: { value: 1 },
                connect() {},
                disconnect() {}
            };
        };

        this.createOscillator = function() {
            return {
                frequency: { value: 440 },
                type: 'sine',
                start() {},
                stop() {},
                connect() {},
                disconnect() {}
            };
        };

        this.createAnalyser = function() {
            return {
                fftSize: 2048,
                frequencyBinCount: 1024,
                getByteFrequencyData(array) {
                    // Fill with zeros
                    for (let i = 0; i < array.length; i++) {
                        array[i] = 0;
                    }
                },
                connect() {},
                disconnect() {}
            };
        };

        this.resume = function() {
            this.state = 'running';
            return Promise.resolve();
        };

        this.suspend = function() {
            this.state = 'suspended';
            return Promise.resolve();
        };

        this.close = function() {
            this.state = 'closed';
            return Promise.resolve();
        };
    };

    // Web Audio API not supported - using fallback implementation
}

/**
 * Canvas context recovery utilities
 */
class CanvasContextRecovery {
    constructor(canvas) {
        this.canvas = canvas;
        this.context = null;
        this.isContextLost = false;
        this.recoveryCallbacks = [];
        
        this.setupContextLossHandling();
    }

    /**
     * Set up context loss and recovery handling
     */
    setupContextLossHandling() {
        this.canvas.addEventListener('webglcontextlost', event => {
            event.preventDefault();
            this.isContextLost = true;
            // Canvas context lost
        });

        this.canvas.addEventListener('webglcontextrestored', () => {
            this.isContextLost = false;
            this.context = this.canvas.getContext('2d');
            // Canvas context restored
            
            // Execute recovery callbacks
            this.recoveryCallbacks.forEach(callback => {
                try {
                    callback(this.context);
                } catch (error) {
                    // Context recovery callback failed
                }
            });
        });
    }

    /**
     * Get the canvas context with recovery handling
     * @returns {CanvasRenderingContext2D|null} Canvas context or null if lost
     */
    getContext() {
        if (this.isContextLost) {
            return null;
        }

        if (!this.context) {
            try {
                this.context = this.canvas.getContext('2d');
            } catch (error) {
                // Failed to get canvas context
                return null;
            }
        }

        return this.context;
    }

    /**
     * Add a callback to execute when context is recovered
     * @param {Function} callback - Recovery callback
     */
    onRecovery(callback) {
        this.recoveryCallbacks.push(callback);
    }

    /**
     * Check if context is currently lost
     * @returns {boolean} True if context is lost
     */
    isLost() {
        return this.isContextLost;
    }

    /**
     * Attempt to recover the context manually
     * @returns {boolean} True if recovery was successful
     */
    recover() {
        if (!this.isContextLost) {
            return true;
        }

        try {
            this.context = this.canvas.getContext('2d');
            if (this.context) {
                this.isContextLost = false;
                return true;
            }
        } catch (error) {
            // Manual context recovery failed
        }

        return false;
    }
}

/**
 * Browser-specific optimization manager
 */
class BrowserOptimizations {
    constructor() {
        // Cache browser detection
        if (BrowserOptimizations._cachedBrowser) {
            this.browser = BrowserOptimizations._cachedBrowser;
            this.optimizations = BrowserOptimizations._cachedOptimizations;
            return;
        }
        
        this.browser = this.detectBrowser();
        this.optimizations = new Map();
        this.setupOptimizations();
        
        // Cache for future instances
        BrowserOptimizations._cachedBrowser = this.browser;
        BrowserOptimizations._cachedOptimizations = this.optimizations;
    }

    /**
     * Detect the current browser
     * @returns {Object} Browser information
     */
    detectBrowser() {
        const {userAgent} = navigator;
        
        let name = 'unknown';
        let version = 'unknown';
        
        if (userAgent.includes('Chrome')) {
            name = 'chrome';
            const match = userAgent.match(/Chrome\/(\d+)/);
            version = match ? match[1] : 'unknown';
        } else if (userAgent.includes('Firefox')) {
            name = 'firefox';
            const match = userAgent.match(/Firefox\/(\d+)/);
            version = match ? match[1] : 'unknown';
        } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
            name = 'safari';
            const match = userAgent.match(/Version\/(\d+)/);
            version = match ? match[1] : 'unknown';
        } else if (userAgent.includes('Edge')) {
            name = 'edge';
            const match = userAgent.match(/Edge\/(\d+)/);
            version = match ? match[1] : 'unknown';
        }

        return { name, version, userAgent };
    }

    /**
     * Set up browser-specific optimizations
     */
    setupOptimizations() {
        // Chrome optimizations
        this.optimizations.set('chrome', {
            preferredAnimationMethod: 'requestAnimationFrame',
            audioContextOptions: { latencyHint: 'interactive' },
            canvasOptimizations: ['willReadFrequently'],
            particleLimit: 50
        });

        // Firefox optimizations
        this.optimizations.set('firefox', {
            preferredAnimationMethod: 'requestAnimationFrame',
            audioContextOptions: { latencyHint: 'balanced' },
            canvasOptimizations: [],
            particleLimit: 40
        });

        // Safari optimizations
        this.optimizations.set('safari', {
            preferredAnimationMethod: 'requestAnimationFrame',
            audioContextOptions: { latencyHint: 'playback' },
            canvasOptimizations: [],
            particleLimit: 30
        });

        // Edge optimizations
        this.optimizations.set('edge', {
            preferredAnimationMethod: 'requestAnimationFrame',
            audioContextOptions: { latencyHint: 'interactive' },
            canvasOptimizations: ['willReadFrequently'],
            particleLimit: 45
        });
    }

    /**
     * Get optimizations for the current browser
     * @returns {Object} Browser-specific optimizations
     */
    getOptimizations() {
        return this.optimizations.get(this.browser.name) || this.optimizations.get('chrome');
    }

    /**
     * Get browser information
     * @returns {Object} Browser information
     */
    getBrowser() {
        return { ...this.browser };
    }

    /**
     * Apply canvas optimizations
     * @param {HTMLCanvasElement} canvas - Canvas element
     * @param {CanvasRenderingContext2D} context - Canvas context
     */
    applyCanvasOptimizations(canvas, context) {
        const opts = this.getOptimizations();
        
        if (opts.canvasOptimizations.includes('willReadFrequently')) {
            try {
                // Re-get context with optimization hint
                canvas.getContext('2d', { willReadFrequently: true });
            } catch (error) {
                // Failed to apply canvas optimization
            }
        }
    }

    /**
     * Get recommended particle limit for current browser
     * @returns {number} Recommended particle limit
     */
    getRecommendedParticleLimit() {
        return this.getOptimizations().particleLimit;
    }

    /**
     * Get audio context options for current browser
     * @returns {Object} Audio context options
     */
    getAudioContextOptions() {
        return this.getOptimizations().audioContextOptions;
    }
}

/**
 * Initialize all polyfills and compatibility features
 * @returns {Object} Initialization results
 */
let _initializationCache = null;

function initializeBrowserCompatibility() {
    // Return cached result if already initialized
    if (_initializationCache) {
        return _initializationCache;
    }
    
    const featureDetection = new FeatureDetection();
    const polyfillManager = new PolyfillManager();
    const browserOptimizations = new BrowserOptimizations();

    // Register polyfills
    polyfillManager.register('requestAnimationFrame', polyfillRequestAnimationFrame);
    polyfillManager.register('performanceNow', polyfillPerformanceNow);
    polyfillManager.register('webAudio', polyfillWebAudio);

    // Apply necessary polyfills based on feature detection
    const appliedPolyfills = [];
    
    if (!featureDetection.features.requestAnimationFrame) {
        if (polyfillManager.apply('requestAnimationFrame')) {
            appliedPolyfills.push('requestAnimationFrame');
        }
    }
    
    if (!featureDetection.features.performance) {
        if (polyfillManager.apply('performanceNow')) {
            appliedPolyfills.push('performanceNow');
        }
    }
    
    if (!featureDetection.features.webAudio) {
        if (polyfillManager.apply('webAudio')) {
            appliedPolyfills.push('webAudio');
        }
    }

    // Cache the result
    _initializationCache = {
        featureDetection,
        polyfillManager,
        browserOptimizations,
        appliedPolyfills,
        capabilities: featureDetection.getCapabilities(),
        browser: browserOptimizations.getBrowser()
    };
    
    return _initializationCache;
}

// Create singleton instance lazily
let _browserCompatibilityInstance = null;

function getBrowserCompatibility() {
    if (!_browserCompatibilityInstance) {
        _browserCompatibilityInstance = initializeBrowserCompatibility();
    }
    return _browserCompatibilityInstance;
}

// Export getter for backward compatibility
const browserCompatibility = getBrowserCompatibility();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  DEBUGGER  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Debugger - Enhanced Logging & Performance Profiling
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module Debugger
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The DIAGNOSTIC CENTER of the engine. Provides comprehensive debugging tools,      
 * ║ performance profiling, memory tracking, and runtime diagnostics to ensure         
 * ║ smooth operation and help developers optimize their implementations.              
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🐛 DEBUG FEATURES                                                                 
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Multi-level logging (NONE, ERROR, WARN, INFO, DEBUG, TRACE)                     
 * │ • Performance profiling with timing metrics                                       
 * │ • Memory usage tracking and leak detection                                        
 * │ • Error tracking and stack trace capture                                          
 * │ • Runtime capability detection                                                    
 * │ • Visual debugging overlays                                                       
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

/**
 * Debug levels for controlling log output
 */
const DebugLevel = {
    NONE: 0,
    ERROR: 1,
    WARN: 2,
    INFO: 3,
    DEBUG: 4,
    TRACE: 5
};

/**
 * Enhanced debugger with performance profiling and error tracking
 */
class EmotiveDebugger {
    constructor(config = {}) {
        this.config = {
            enabled: config.enabled !== false,
            level: config.level || DebugLevel.INFO,
            enableProfiling: config.enableProfiling !== false,
            enableErrorTracking: config.enableErrorTracking !== false,
            enableMemoryTracking: config.enableMemoryTracking !== false,
            maxLogEntries: config.maxLogEntries || 1000,
            maxProfileEntries: config.maxProfileEntries || 500,
            ...config
        };

        // Log storage
        this.logs = [];
        this.errors = [];
        this.profiles = new Map();
        this.memorySnapshots = [];
        
        // Performance tracking
        this.frameTimings = [];
        this.maxFrameTimings = 120; // 2 seconds at 60fps
        
        // Error tracking
        this.errorCounts = new Map();
        this.lastErrors = new Map();
        
        // Feature detection for debugging capabilities
        this.capabilities = {
            performance: typeof performance !== 'undefined' && performance.now,
            memory: typeof performance !== 'undefined' && performance.memory,
            console: typeof console !== 'undefined',
            stackTrace: typeof Error !== 'undefined'
        };

        // Initialize
        this.startTime = this.now();
        this.setupErrorHandling();
        
        if (this.config.enabled) {
            this.log('DEBUG', 'EmotiveDebugger initialized', {
                config: this.config,
                capabilities: this.capabilities
            });
        }
    }

    /**
     * Get current high-resolution timestamp
     * @returns {number} Timestamp in milliseconds
     */
    now() {
        if (this.capabilities.performance) {
            return performance.now();
        }
        return Date.now() - this.startTime;
    }

    /**
     * Set up global error handling
     */
    setupErrorHandling() {
        if (!this.config.enableErrorTracking || typeof window === 'undefined') {
            return;
        }

        // Capture unhandled errors
        window.addEventListener('error', event => {
            this.trackError('UNHANDLED_ERROR', event.error || new Error(event.message), {
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });

        // Capture unhandled promise rejections
        window.addEventListener('unhandledrejection', event => {
            this.trackError('UNHANDLED_REJECTION', event.reason, {
                promise: event.promise
            });
        });
    }

    /**
     * Log a message with specified level
     * @param {string} level - Log level
     * @param {string} message - Log message
     * @param {*} data - Additional data
     */
    log(level, message, data = null) {
        if (!this.config.enabled) return;

        const levelValue = DebugLevel[level] || DebugLevel.INFO;
        if (levelValue > this.config.level) return;

        const timestamp = this.now();
        const logEntry = {
            timestamp,
            level,
            message,
            data,
            stackTrace: this.getStackTrace()
        };

        // Store log entry
        this.logs.push(logEntry);
        if (this.logs.length > this.config.maxLogEntries) {
            this.logs.shift();
        }

        // Console output
        if (this.capabilities.console) {
            const consoleMethod = this.getConsoleMethod(level);
            const timeStr = `[${(timestamp / 1000).toFixed(3)}s]`;
            
            if (data) {
                consoleMethod(`${timeStr} [${level}] ${message}`, data);
            } else {
                consoleMethod(`${timeStr} [${level}] ${message}`);
            }
        }
    }

    /**
     * Get appropriate console method for log level
     * @param {string} level - Log level
     * @returns {Function} Console method
     */
    getConsoleMethod(level) {
        switch (level) {
        case 'ERROR': return (() => {}).bind(console);
        case 'WARN': return (() => {}).bind(console);
        case 'DEBUG': return (() => {}).bind(console);
        case 'TRACE': return (() => {}).bind(console);
        default: return (() => {}).bind(console);
        }
    }

    /**
     * Get current stack trace
     * @returns {string|null} Stack trace or null if not available
     */
    getStackTrace() {
        if (!this.capabilities.stackTrace) return null;
        
        try {
            throw new Error();
        } catch (e) {
            return e.stack;
        }
    }

    /**
     * Track an error with context
     * @param {string} type - Error type
     * @param {Error} error - Error object
     * @param {Object} context - Additional context
     */
    trackError(type, error, context = {}) {
        if (!this.config.enableErrorTracking) return;

        const timestamp = this.now();
        const errorEntry = {
            timestamp,
            type,
            message: error.message || String(error),
            stack: error.stack,
            context,
            count: 1
        };

        // Update error counts
        const errorKey = `${type}:${error.message}`;
        if (this.errorCounts.has(errorKey)) {
            this.errorCounts.set(errorKey, this.errorCounts.get(errorKey) + 1);
            errorEntry.count = this.errorCounts.get(errorKey);
        } else {
            this.errorCounts.set(errorKey, 1);
        }

        // Store error
        this.errors.push(errorEntry);
        this.lastErrors.set(type, errorEntry);

        // Log error
        this.log('ERROR', `${type}: ${error.message}`, {
            error: errorEntry,
            context
        });
    }

    /**
     * Start profiling a named operation
     * @param {string} name - Profile name
     * @param {Object} metadata - Additional metadata
     */
    startProfile(name, metadata = {}) {
        if (!this.config.enableProfiling) return;

        const profile = {
            name,
            startTime: this.now(),
            metadata,
            samples: [],
            isActive: true
        };

        this.profiles.set(name, profile);
        this.log('TRACE', `Started profiling: ${name}`, metadata);
    }

    /**
     * Add a sample to an active profile
     * @param {string} name - Profile name
     * @param {string} label - Sample label
     * @param {*} data - Sample data
     */
    profileSample(name, label, data = null) {
        if (!this.config.enableProfiling) return;

        const profile = this.profiles.get(name);
        if (!profile || !profile.isActive) return;

        const sample = {
            timestamp: this.now(),
            label,
            data,
            relativeTime: this.now() - profile.startTime
        };

        profile.samples.push(sample);
    }

    /**
     * End profiling and get results
     * @param {string} name - Profile name
     * @returns {Object|null} Profile results or null if not found
     */
    endProfile(name) {
        if (!this.config.enableProfiling) return null;

        const profile = this.profiles.get(name);
        if (!profile || !profile.isActive) return null;

        profile.endTime = this.now();
        profile.duration = profile.endTime - profile.startTime;
        profile.isActive = false;

        // Calculate statistics
        profile.stats = this.calculateProfileStats(profile);

        this.log('TRACE', `Ended profiling: ${name}`, {
            duration: profile.duration,
            samples: profile.samples.length,
            stats: profile.stats
        });

        // Limit stored profiles
        if (this.profiles.size > this.config.maxProfileEntries) {
            const oldestKey = this.profiles.keys().next().value;
            this.profiles.delete(oldestKey);
        }

        return { ...profile };
    }

    /**
     * Calculate statistics for a profile
     * @param {Object} profile - Profile data
     * @returns {Object} Profile statistics
     */
    calculateProfileStats(profile) {
        if (profile.samples.length === 0) {
            return { sampleCount: 0 };
        }

        const durations = [];
        for (let i = 1; i < profile.samples.length; i++) {
            durations.push(profile.samples[i].relativeTime - profile.samples[i - 1].relativeTime);
        }

        if (durations.length === 0) {
            return { sampleCount: profile.samples.length };
        }

        const sum = durations.reduce((a, b) => a + b, 0);
        const avg = sum / durations.length;
        const min = Math.min(...durations);
        const max = Math.max(...durations);

        return {
            sampleCount: profile.samples.length,
            avgSampleDuration: avg,
            minSampleDuration: min,
            maxSampleDuration: max,
            totalDuration: profile.duration
        };
    }

    /**
     * Track frame timing for performance analysis
     * @param {number} frameTime - Frame time in milliseconds
     */
    trackFrameTiming(frameTime) {
        if (!this.config.enableProfiling) return;

        this.frameTimings.push({
            timestamp: this.now(),
            frameTime,
            fps: 1000 / frameTime
        });

        if (this.frameTimings.length > this.maxFrameTimings) {
            this.frameTimings.shift();
        }
    }

    /**
     * Take a memory snapshot (if supported)
     * @param {string} label - Snapshot label
     */
    takeMemorySnapshot(label = 'snapshot') {
        if (!this.config.enableMemoryTracking || !this.capabilities.memory) return;

        const snapshot = {
            timestamp: this.now(),
            label,
            memory: {
                usedJSHeapSize: performance.memory.usedJSHeapSize,
                totalJSHeapSize: performance.memory.totalJSHeapSize,
                jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
            }
        };

        this.memorySnapshots.push(snapshot);
        
        // Limit snapshots
        if (this.memorySnapshots.length > 100) {
            this.memorySnapshots.shift();
        }

        this.log('DEBUG', `Memory snapshot: ${label}`, snapshot.memory);
    }

    /**
     * Get comprehensive debug report
     * @returns {Object} Debug report
     */
    getDebugReport() {
        const report = {
            timestamp: this.now(),
            uptime: this.now() - 0,
            config: this.config,
            capabilities: this.capabilities,
            
            // Logs
            logCount: this.logs.length,
            recentLogs: this.logs.slice(-10),
            
            // Errors
            errorCount: this.errors.length,
            uniqueErrors: this.errorCounts.size,
            recentErrors: this.errors.slice(-5),
            errorCounts: Object.fromEntries(this.errorCounts),
            
            // Profiles
            activeProfiles: Array.from(this.profiles.values()).filter(p => p.isActive).length,
            completedProfiles: Array.from(this.profiles.values()).filter(p => !p.isActive).length,
            
            // Performance
            frameTimings: this.getFrameTimingStats(),
            
            // Memory
            memorySnapshots: this.memorySnapshots.slice(-5)
        };

        return report;
    }

    /**
     * Get frame timing statistics
     * @returns {Object} Frame timing stats
     */
    getFrameTimingStats() {
        if (this.frameTimings.length === 0) {
            return { sampleCount: 0 };
        }

        const frameTimes = this.frameTimings.map(f => f.frameTime);
        const fps = this.frameTimings.map(f => f.fps);

        return {
            sampleCount: this.frameTimings.length,
            avgFrameTime: frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length,
            minFrameTime: Math.min(...frameTimes),
            maxFrameTime: Math.max(...frameTimes),
            avgFPS: fps.reduce((a, b) => a + b, 0) / fps.length,
            minFPS: Math.min(...fps),
            maxFPS: Math.max(...fps)
        };
    }

    /**
     * Export debug data for external analysis
     * @returns {Object} Exportable debug data
     */
    exportDebugData() {
        return {
            metadata: {
                exportTime: Date.now(),
                debuggerUptime: this.now(),
                config: this.config,
                capabilities: this.capabilities
            },
            logs: [...this.logs],
            errors: [...this.errors],
            profiles: Object.fromEntries(this.profiles),
            frameTimings: [...this.frameTimings],
            memorySnapshots: [...this.memorySnapshots],
            errorCounts: Object.fromEntries(this.errorCounts)
        };
    }

    /**
     * Clear all debug data
     */
    clear() {
        this.logs = [];
        this.errors = [];
        this.profiles.clear();
        this.frameTimings = [];
        this.memorySnapshots = [];
        this.errorCounts.clear();
        this.lastErrors.clear();
        
        this.log('INFO', 'Debug data cleared');
    }

    /**
     * Destroy the debugger and clean up
     */
    destroy() {
        this.clear();
        this.config.enabled = false;
    }
}

/**
 * Runtime feature detection and capability reporting
 */
class RuntimeCapabilities {
    constructor() {
        this.capabilities = this.detectCapabilities();
        this.performance = this.measurePerformance();
    }

    /**
     * Detect runtime capabilities
     * @returns {Object} Capability detection results
     */
    detectCapabilities() {
        const caps = {
            // JavaScript features
            es6: this.detectES6(),
            es2017: this.detectES2017(),
            modules: this.detectModules(),
            
            // Browser APIs
            webGL: this.detectWebGL(),
            webGL2: this.detectWebGL2(),
            webWorkers: this.detectWebWorkers(),
            serviceWorkers: this.detectServiceWorkers(),
            
            // Performance APIs
            performanceObserver: this.detectPerformanceObserver(),
            intersectionObserver: this.detectIntersectionObserver(),
            resizeObserver: this.detectResizeObserver(),
            
            // Storage
            localStorage: this.detectLocalStorage(),
            sessionStorage: this.detectSessionStorage(),
            indexedDB: this.detectIndexedDB(),
            
            // Network
            fetch: this.detectFetch(),
            webSockets: this.detectWebSockets(),
            
            // Device capabilities
            touchEvents: this.detectTouchEvents(),
            pointerEvents: this.detectPointerEvents(),
            deviceOrientation: this.detectDeviceOrientation(),
            
            // Graphics
            canvas2d: this.detectCanvas2D(),
            canvasFilters: this.detectCanvasFilters(),
            offscreenCanvas: this.detectOffscreenCanvas()
        };

        return caps;
    }

    detectES6() {
        try {
            // Check for arrow functions and classes without eval
            return typeof Symbol !== 'undefined' && 
                   typeof Promise !== 'undefined' && 
                   typeof Map !== 'undefined' && 
                   typeof Set !== 'undefined';
        } catch (e) {
            return false;
        }
    }

    detectES2017() {
        try {
            // Check for async/await support
            return typeof async !== 'undefined' || 
                   (function() { 
                       try { 
                           // Check if async functions are supported without using Function constructor
                           return typeof (async function(){}).constructor === 'function'; 
                       } catch(e) { 
                           return false; 
                       } 
                   })();
        } catch (e) {
            return false;
        }
    }

    detectModules() {
        try {
            return typeof document !== 'undefined' && 'noModule' in document.createElement('script');
        } catch (e) {
            return false;
        }
    }

    detectWebGL() {
        try {
            const canvas = document.createElement('canvas');
            return !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
        } catch (e) {
            return false;
        }
    }

    detectWebGL2() {
        try {
            const canvas = document.createElement('canvas');
            return !!canvas.getContext('webgl2');
        } catch (e) {
            return false;
        }
    }

    detectWebWorkers() {
        return typeof Worker !== 'undefined';
    }

    detectServiceWorkers() {
        return 'serviceWorker' in navigator;
    }

    detectPerformanceObserver() {
        return typeof PerformanceObserver !== 'undefined';
    }

    detectIntersectionObserver() {
        return typeof IntersectionObserver !== 'undefined';
    }

    detectResizeObserver() {
        return typeof ResizeObserver !== 'undefined';
    }

    detectLocalStorage() {
        try {
            return typeof localStorage !== 'undefined' && localStorage !== null;
        } catch (e) {
            return false;
        }
    }

    detectSessionStorage() {
        try {
            return typeof sessionStorage !== 'undefined' && sessionStorage !== null;
        } catch (e) {
            return false;
        }
    }

    detectIndexedDB() {
        return typeof indexedDB !== 'undefined';
    }

    detectFetch() {
        return typeof fetch !== 'undefined';
    }

    detectWebSockets() {
        return typeof WebSocket !== 'undefined';
    }

    detectTouchEvents() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }

    detectPointerEvents() {
        return typeof PointerEvent !== 'undefined';
    }

    detectDeviceOrientation() {
        return 'ondeviceorientation' in window;
    }

    detectCanvas2D() {
        try {
            const canvas = document.createElement('canvas');
            return !!canvas.getContext('2d');
        } catch (e) {
            return false;
        }
    }

    detectCanvasFilters() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            return 'filter' in ctx;
        } catch (e) {
            return false;
        }
    }

    detectOffscreenCanvas() {
        return typeof OffscreenCanvas !== 'undefined';
    }

    /**
     * Measure basic performance characteristics
     * @returns {Object} Performance measurements
     */
    measurePerformance() {
        const measurements = {};

        // Measure JavaScript execution speed
        const start = performance.now();
        measurements.jsExecutionSpeed = performance.now() - start;

        // Measure canvas performance
        try {
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            
            const canvasStart = performance.now();
            for (let i = 0; i < 1000; i++) {
                ctx.fillRect(Math.random() * 100, Math.random() * 100, 10, 10);
            }
            measurements.canvasPerformance = performance.now() - canvasStart;
        } catch (e) {
            measurements.canvasPerformance = null;
        }

        return measurements;
    }

    /**
     * Get all capabilities
     * @returns {Object} All detected capabilities
     */
    getCapabilities() {
        return { ...this.capabilities };
    }

    /**
     * Get performance measurements
     * @returns {Object} Performance measurements
     */
    getPerformance() {
        return { ...this.performance };
    }

    /**
     * Generate capability report
     * @returns {Object} Comprehensive capability report
     */
    generateReport() {
        const supportedFeatures = Object.entries(this.capabilities)
            .filter(([, supported]) => supported)
            .map(([feature]) => feature);

        const unsupportedFeatures = Object.entries(this.capabilities)
            .filter(([, supported]) => !supported)
            .map(([feature]) => feature);

        const supportPercentage = (supportedFeatures.length / Object.keys(this.capabilities).length) * 100;

        return {
            timestamp: Date.now(),
            userAgent: navigator.userAgent,
            supportedFeatures,
            unsupportedFeatures,
            supportPercentage: Math.round(supportPercentage),
            performance: this.performance,
            recommendations: this.generateRecommendations(supportPercentage)
        };
    }

    /**
     * Generate recommendations based on capabilities
     * @param {number} supportPercentage - Percentage of supported features
     * @returns {Array<string>} Recommendations
     */
    generateRecommendations(supportPercentage) {
        const recommendations = [];

        if (supportPercentage < 50) {
            recommendations.push('Consider using the minimal build for better compatibility');
        }

        if (!this.capabilities.webGL) {
            recommendations.push('WebGL not supported - advanced graphics features unavailable');
        }

        if (!this.capabilities.webWorkers) {
            recommendations.push('Web Workers not supported - background processing unavailable');
        }

        if (!this.capabilities.fetch) {
            recommendations.push('Fetch API not supported - consider using XMLHttpRequest polyfill');
        }

        if (this.performance.jsExecutionSpeed > 50) {
            recommendations.push('Slow JavaScript execution detected - consider performance optimizations');
        }

        if (this.performance.canvasPerformance > 100) {
            recommendations.push('Slow canvas performance detected - consider reducing visual complexity');
        }

        return recommendations;
    }
}

// Create singleton instances for convenience
const emotiveDebugger = new EmotiveDebugger({
    enabled: typeof window !== 'undefined' && window.location && window.location.search.includes('debug=true'),
    level: DebugLevel.INFO
});

const runtimeCapabilities = new RuntimeCapabilities();

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Shape Definitions
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Static shape definitions for immediate loading
 * @author Emotive Engine Team
 * @module shapes/shapeDefinitions
 */

/**
 * Generate circle points
 */
function generateCircle(numPoints) {
    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const angle = (i / numPoints) * Math.PI * 2;
        points.push({
            x: 0.5 + Math.cos(angle) * 0.5,
            y: 0.5 + Math.sin(angle) * 0.5
        });
    }
    return points;
}

/**
 * Generate heart shape
 */
function generateHeart(numPoints) {
    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const t = (i / numPoints) * Math.PI * 2;

        // Heart parametric equations
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) -
                  2 * Math.cos(3 * t) - Math.cos(4 * t));

        // Normalize and scale
        points.push({
            x: 0.5 + x / 32,
            y: 0.5 + y / 32
        });
    }
    return points;
}

/**
 * Generate moon shape - keep it as a circle
 * The crescent effect should be done with visual shadows, not shape morphing
 */
function generateMoon(numPoints) {
    // Moon should stay as a circle - the crescent is a visual effect
    return generateCircle(numPoints);
}

/**
 * Generate star shape - mathematically correct 5-pointed star
 */
function generateStar(numPoints, _starPoints = 5) {
    const points = [];
    
    // Create a proper 5-pointed star using mathematical formula
    // A 5-pointed star has 10 vertices: 5 outer points + 5 inner valleys
    
    for (let i = 0; i < numPoints; i++) {
        const t = i / numPoints;
        
        // Map to star vertices (10 total for a 5-pointed star)
        const vertexIndex = Math.floor(t * 10);
        const isOuterPoint = vertexIndex % 2 === 0;
        const armIndex = Math.floor(vertexIndex / 2);
        
        // Calculate angle for this vertex
        // Outer points: -90°, -18°, 54°, 126°, 198° (rotated to be upright)
        // Inner points: -54°, 18°, 90°, 162°, 234° (rotated to be upright)
        let angle;
        if (isOuterPoint) {
            angle = (armIndex * 72 - 90) * Math.PI / 180; // 72° = 360°/5, -90° to rotate upright
        } else {
            angle = ((armIndex * 72) + 36 - 90) * Math.PI / 180; // 36° = 72°/2, -90° to rotate upright
        }
        
        // Use appropriate radius
        const outerRadius = 0.5;
        const innerRadius = 0.2;
        const radius = isOuterPoint ? outerRadius : innerRadius;
        
        points.push({
            x: 0.5 + Math.cos(angle) * radius,
            y: 0.5 + Math.sin(angle) * radius
        });
    }
    
    return points;
}

/**
 * Generate sun shape - just a circle, rays are visual effects only
 */
function generateSun(numPoints, _numRays = 12) {
    // Sun is just a circle - the rays are rendered as effects, not part of the shape
    return generateCircle(numPoints);
}


/**
 * Generate suspicion shape (sly grin)
 */
function generateSuspicion(numPoints) {
    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const t = (i / numPoints) * Math.PI * 2;
        
        let x, y;
        if (t < Math.PI) {
            // Right side - outer arc of the grin
            x = Math.cos(t) * 0.45;
            y = Math.sin(t) * 0.45;
        } else {
            // Left side - inner arc for the mischievous smile
            const innerT = Math.PI * 2 - t;
            x = Math.cos(innerT) * 0.25 - 0.1;
            y = Math.sin(innerT) * 0.35;
        }
        
        points.push({
            x: 0.5 + x,
            y: 0.5 + y
        });
    }
    return points;
}

/**
 * Generate square shape
 */
function generateSquare(numPoints) {
    const points = [];
    const pointsPerSide = Math.floor(numPoints / 4);
    
    for (let side = 0; side < 4; side++) {
        for (let i = 0; i < pointsPerSide; i++) {
            const t = i / pointsPerSide;
            let x, y;
            
            switch (side) {
            case 0: // Top
                x = -0.5 + t;
                y = -0.5;
                break;
            case 1: // Right
                x = 0.5;
                y = -0.5 + t;
                break;
            case 2: // Bottom
                x = 0.5 - t;
                y = 0.5;
                break;
            case 3: // Left
                x = -0.5;
                y = 0.5 - t;
                break;
            }
            
            points.push({
                x: 0.5 + x * 0.8,
                y: 0.5 + y * 0.8
            });
        }
    }
    return points;
}

/**
 * Generate triangle shape
 */
function generateTriangle(numPoints) {
    const points = [];
    
    const vertices = [
        { x: 0, y: -0.5 },           // Top
        { x: -0.433, y: 0.25 },      // Bottom left
        { x: 0.433, y: 0.25 }        // Bottom right
    ];
    
    // Calculate perimeter of triangle
    const sides = [
        Math.sqrt(Math.pow(vertices[1].x - vertices[0].x, 2) + Math.pow(vertices[1].y - vertices[0].y, 2)),
        Math.sqrt(Math.pow(vertices[2].x - vertices[1].x, 2) + Math.pow(vertices[2].y - vertices[1].y, 2)),
        Math.sqrt(Math.pow(vertices[0].x - vertices[2].x, 2) + Math.pow(vertices[0].y - vertices[2].y, 2))
    ];
    const perimeter = sides[0] + sides[1] + sides[2];
    
    // Distribute points based on side length
    const pointsPerSide = sides.map(s => Math.round(numPoints * s / perimeter));
    
    // Adjust for rounding errors
    const totalPoints = pointsPerSide.reduce((a, b) => a + b, 0);
    if (totalPoints < numPoints) {
        pointsPerSide[0] += numPoints - totalPoints;
    }
    
    // Generate points along each edge
    for (let side = 0; side < 3; side++) {
        const v1 = vertices[side];
        const v2 = vertices[(side + 1) % 3];
        const sidePoints = pointsPerSide[side];
        
        for (let i = 0; i < sidePoints; i++) {
            // Don't duplicate the corner point
            if (i === sidePoints - 1 && side < 2) continue;
            
            const t = i / sidePoints;
            const x = v1.x + (v2.x - v1.x) * t;
            const y = v1.y + (v2.y - v1.y) * t;
            
            points.push({
                x: 0.5 + x * 0.9,
                y: 0.5 + y * 0.9
            });
        }
    }
    
    // Ensure we have exactly numPoints
    while (points.length < numPoints) {
        points.push(points[points.length - 1]);
    }
    while (points.length > numPoints) {
        points.pop();
    }
    
    return points;
}

/**
 * Shape definitions with their properties
 */
const SHAPE_DEFINITIONS = {
    circle: {
        points: generateCircle(64),
        shadow: { type: 'none' }
    },
    heart: {
        points: generateHeart(64),
        shadow: { type: 'none' }
    },
    star: {
        points: generateStar(64, 5),
        shadow: { type: 'none' }
    },
    sun: {
        points: generateSun(64, 12),
        shadow: {
            type: 'sun',
            corona: true,
            intensity: 1.5,
            flares: true,
            texture: true,
            turbulence: 0.3
        }
    },
    moon: {
        points: generateMoon(64),
        shadow: {
            type: 'crescent',
            coverage: 0.85,
            angle: -30,
            softness: 0.05,
            offset: 0.7
        }
    },
    lunar: {
        points: generateCircle(64),
        shadow: {
            type: 'lunar',
            coverage: 0.7,
            color: 'rgba(80, 20, 0, 0.8)',
            progression: 'center'
        }
    },
    suspicion: {
        points: generateSuspicion(64),
        shadow: { type: 'none' }
    },
    eclipse: {
        points: generateCircle(64),
        shadow: {
            type: 'lunar',
            coverage: 0.7,
            color: 'rgba(80, 20, 0, 0.8)'
        }
    },
    square: {
        points: generateSquare(64),
        shadow: { type: 'none' }
    },
    triangle: {
        points: generateTriangle(64),
        shadow: { type: 'none' }
    },
    solar: {
        points: generateSun(64, 12),
        shadow: {
            type: 'solar-hybrid',
            // Sun properties (rendered first)
            corona: true,
            intensity: 1.5,
            flares: true,
            texture: true,
            turbulence: 0.3,
            // Lunar shadow overlay (rendered on top) - BLACK for solar eclipse
            lunarOverlay: {
                type: 'lunar',
                coverage: 1.0,  // Full coverage for total eclipse
                color: 'rgba(0, 0, 0, 1.0)',  // Pure black shadow
                progression: 'center'
            }
        }
    }
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Shape Cache System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Pre-cached shape system for instant shape morphing
 * @author Emotive Engine Team
 * @module cache/ShapeCache
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ Pre-caches all shape definitions, morph transitions, and properties for instant
 * ║ access. Eliminates the need to calculate shape data on-demand, improving morphing
 * ║ performance from ~2-5ms to <0.5ms.
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 */


/**
 * ShapeCache - Pre-caches all shape configurations for instant access
 */
class ShapeCache {
    constructor() {
        // Cache storage
        this.shapeCache = new Map();
        this.morphCache = new Map();
        this.propertyCache = new Map();
        
        // Performance tracking
        this.stats = {
            hits: 0,
            misses: 0,
            loadTime: 0,
            cacheSize: 0
        };
        
        // Cache configuration
        this.isInitialized = false;
        this.loadStartTime = 0;
        
        // Initialize cache
        this.initialize();
    }
    
    /**
     * Initialize the shape cache by pre-loading all shapes
     */
    initialize() {
        this.loadStartTime = performance.now();
        
        try {
            // Get all available shapes
            const shapes = Object.keys(SHAPE_DEFINITIONS);
            
            // Pre-cache each shape
            shapes.forEach(shapeName => {
                this.cacheShape(shapeName);
            });
            
            // Pre-cache common morph transitions
            this.cacheCommonMorphs(shapes);
            
            this.isInitialized = true;
            this.stats.loadTime = performance.now() - this.loadStartTime;
            this.stats.cacheSize = this.shapeCache.size;
            
            console.warn(`[ShapeCache] Initialized with ${this.shapeCache.size} shapes in ${this.stats.loadTime.toFixed(2)}ms`);
            
        } catch (error) {
            console.error('[ShapeCache] Initialization failed:', error);
            this.isInitialized = false;
        }
    }
    
    /**
     * Cache a single shape and its related data
     * @param {string} shapeName - Name of the shape to cache
     */
    cacheShape(shapeName) {
        try {
            // Cache main shape definition
            const shapeDef = SHAPE_DEFINITIONS[shapeName];
            if (shapeDef) {
                this.shapeCache.set(shapeName, shapeDef);
                
                // Cache shape properties
                const properties = {
                    pointCount: shapeDef.points?.length || 64,
                    hasShadow: shapeDef.shadow?.type !== 'none',
                    shadowType: shapeDef.shadow?.type || 'none',
                    isRadial: this.isRadialShape(shapeName),
                    bounds: this.calculateBounds(shapeDef.points)
                };
                this.propertyCache.set(shapeName, properties);
            }
            
        } catch (error) {
            console.warn(`[ShapeCache] Failed to cache shape '${shapeName}':`, error);
        }
    }
    
    /**
     * Cache common morph transitions
     * @param {Array<string>} shapes - List of available shapes
     */
    cacheCommonMorphs(shapes) {
        // Common morph pairs that are frequently used
        const commonPairs = [
            ['circle', 'heart'],
            ['circle', 'star'],
            ['circle', 'square'],
            ['heart', 'star'],
            ['star', 'circle'],
            ['square', 'circle'],
            ['triangle', 'circle'],
            ['moon', 'sun'],
            ['lunar', 'eclipse']
        ];
        
        commonPairs.forEach(([from, to]) => {
            if (shapes.includes(from) && shapes.includes(to)) {
                try {
                    const morphData = this.calculateMorphSteps(from, to);
                    const key = `${from}->${to}`;
                    this.morphCache.set(key, morphData);
                } catch (error) {
                    console.warn(`[ShapeCache] Failed to cache morph '${from}->${to}':`, error);
                }
            }
        });
    }
    
    /**
     * Calculate morph steps between two shapes
     * @param {string} fromShape - Source shape
     * @param {string} toShape - Target shape
     * @returns {Object} Morph data with intermediate steps
     */
    calculateMorphSteps(fromShape, toShape) {
        const fromDef = this.shapeCache.get(fromShape);
        const toDef = this.shapeCache.get(toShape);
        
        if (!fromDef || !toDef) {
            return null;
        }
        
        const steps = [];
        const stepCount = 5; // 0%, 25%, 50%, 75%, 100%
        
        for (let i = 0; i < stepCount; i++) {
            const progress = i / (stepCount - 1);
            const interpolatedPoints = this.interpolateShapePoints(
                fromDef.points,
                toDef.points,
                progress
            );
            
            steps.push({
                progress,
                points: interpolatedPoints
            });
        }
        
        return {
            from: fromShape,
            to: toShape,
            steps,
            isRadial: this.isRadialShape(fromShape) || this.isRadialShape(toShape)
        };
    }
    
    /**
     * Interpolate between two shape point arrays
     * @param {Array} fromPoints - Source points
     * @param {Array} toPoints - Target points
     * @param {number} progress - Interpolation progress (0-1)
     * @returns {Array} Interpolated points
     */
    interpolateShapePoints(fromPoints, toPoints, progress) {
        if (!fromPoints || !toPoints) {
            return fromPoints || toPoints || [];
        }
        
        const maxPoints = Math.max(fromPoints.length, toPoints.length);
        const interpolated = [];
        
        for (let i = 0; i < maxPoints; i++) {
            const fromPoint = fromPoints[i] || fromPoints[0] || { x: 0.5, y: 0.5 };
            const toPoint = toPoints[i] || toPoints[0] || { x: 0.5, y: 0.5 };
            
            interpolated.push({
                x: fromPoint.x + (toPoint.x - fromPoint.x) * progress,
                y: fromPoint.y + (toPoint.y - fromPoint.y) * progress
            });
        }
        
        return interpolated;
    }
    
    /**
     * Check if a shape is radial (expands from center)
     * @param {string} shapeName - Name of the shape
     * @returns {boolean} True if shape is radial
     */
    isRadialShape(shapeName) {
        const radialShapes = ['circle', 'star', 'square', 'triangle', 'sun', 'moon'];
        return radialShapes.includes(shapeName);
    }
    
    /**
     * Calculate shape bounds
     * @param {Array} points - Shape points
     * @returns {Object} Bounds object
     */
    calculateBounds(points) {
        if (!points || points.length === 0) {
            return { minX: 0, minY: 0, maxX: 1, maxY: 1, width: 1, height: 1 };
        }
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        points.forEach(point => {
            minX = Math.min(minX, point.x);
            minY = Math.min(minY, point.y);
            maxX = Math.max(maxX, point.x);
            maxY = Math.max(maxY, point.y);
        });
        
        return {
            minX,
            minY,
            maxX,
            maxY,
            width: maxX - minX,
            height: maxY - minY
        };
    }
    
    /**
     * Get cached shape definition
     * @param {string} shapeName - Name of the shape
     * @returns {Object|null} Cached shape definition
     */
    getShape(shapeName) {
        if (!this.isInitialized) {
            console.warn('[ShapeCache] Cache not initialized, falling back to direct access');
            return SHAPE_DEFINITIONS[shapeName] || null;
        }
        
        const cached = this.shapeCache.get(shapeName);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        console.warn(`[ShapeCache] Cache miss for shape '${shapeName}', consider adding to pre-cache`);
        return SHAPE_DEFINITIONS[shapeName] || null;
    }
    
    /**
     * Get cached shape properties
     * @param {string} shapeName - Name of the shape
     * @returns {Object} Cached shape properties
     */
    getProperties(shapeName) {
        if (!this.isInitialized) {
            const shapeDef = SHAPE_DEFINITIONS[shapeName];
            return shapeDef ? {
                pointCount: shapeDef.points?.length || 64,
                hasShadow: shapeDef.shadow?.type !== 'none',
                shadowType: shapeDef.shadow?.type || 'none',
                isRadial: this.isRadialShape(shapeName),
                bounds: this.calculateBounds(shapeDef.points)
            } : {};
        }
        
        const cached = this.propertyCache.get(shapeName);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        return {};
    }
    
    /**
     * Get cached morph data
     * @param {string} fromShape - Source shape
     * @param {string} toShape - Target shape
     * @returns {Object|null} Cached morph data
     */
    getMorph(fromShape, toShape) {
        if (!this.isInitialized) {
            return this.calculateMorphSteps(fromShape, toShape);
        }
        
        const key = `${fromShape}->${toShape}`;
        const cached = this.morphCache.get(key);
        if (cached) {
            this.stats.hits++;
            return cached;
        }
        
        this.stats.misses++;
        return this.calculateMorphSteps(fromShape, toShape);
    }
    
    /**
     * Check if shape is cached
     * @param {string} shapeName - Name of the shape
     * @returns {boolean} True if cached
     */
    hasShape(shapeName) {
        return this.shapeCache.has(shapeName);
    }
    
    /**
     * Get cache statistics
     * @returns {Object} Cache statistics
     */
    getStats() {
        const total = this.stats.hits + this.stats.misses;
        return {
            ...this.stats,
            hitRate: total > 0 ? `${(this.stats.hits / total * 100).toFixed(1)}%` : '0%',
            shapes: this.shapeCache.size,
            morphs: this.morphCache.size,
            properties: this.propertyCache.size
        };
    }
    
    /**
     * Clear all caches
     */
    clear() {
        this.shapeCache.clear();
        this.morphCache.clear();
        this.propertyCache.clear();
        this.stats = { hits: 0, misses: 0, loadTime: 0, cacheSize: 0 };
        this.isInitialized = false;
    }
}

// Create singleton instance
const shapeCache = new ShapeCache();

/**
 * ArrayPool - Reusable array pool to reduce garbage collection
 * @module ArrayPool
 */

class ArrayPool {
    constructor() {
        this.pools = new Map(); // Key: size, Value: array of available arrays
        this.inUse = new Set(); // Track arrays currently in use
    }

    /**
     * Get an array from the pool or create a new one
     * @param {number} size - Size of array needed
     * @param {string} type - Type of array ('float32', 'array', 'uint8')
     * @returns {Array|Float32Array|Uint8Array}
     */
    acquire(size, type = 'array') {
        const key = `${type}_${size}`;
        
        if (!this.pools.has(key)) {
            this.pools.set(key, []);
        }
        
        const pool = this.pools.get(key);
        
        // Try to get from pool
        if (pool.length > 0) {
            const array = pool.pop();
            this.inUse.add(array);
            return array;
        }
        
        // Create new array if pool is empty
        let newArray;
        switch (type) {
        case 'float32':
            newArray = new Float32Array(size);
            break;
        case 'uint8':
            newArray = new Uint8Array(size);
            break;
        default:
            newArray = new Array(size).fill(0);
        }
        
        this.inUse.add(newArray);
        return newArray;
    }

    /**
     * Return an array to the pool
     * @param {Array|Float32Array|Uint8Array} array - Array to return
     */
    release(array) {
        if (!this.inUse.has(array)) {
            return; // Not from this pool
        }
        
        this.inUse.delete(array);
        
        // Determine type and size
        let type = 'array';
        if (array instanceof Float32Array) type = 'float32';
        else if (array instanceof Uint8Array) type = 'uint8';
        
        const size = array.length;
        const key = `${type}_${size}`;
        
        // Clear the array
        if (type === 'array') {
            array.fill(0);
        } else {
            array.fill(0);
        }
        
        // Return to pool
        if (!this.pools.has(key)) {
            this.pools.set(key, []);
        }
        
        const pool = this.pools.get(key);
        if (pool.length < 10) { // Keep max 10 arrays of each size
            pool.push(array);
        }
    }

    /**
     * Clear all pools
     */
    clear() {
        this.pools.clear();
        this.inUse.clear();
    }
}

// Create singleton instance
const arrayPool = new ArrayPool();

/**
 * AudioDeformer - Handles audio-based shape deformation
 * @module core/morpher/AudioDeformer
 */

class AudioDeformer {
    constructor(morpher) {
        this.morpher = morpher;
        
        // Audio deformation state
        this.audioDeformation = 0;
        this.vocalEnergy = 0;
        this.vocalEffectActive = false;
        this.beatGlitchIntensity = 0;
        this.glitchPoints = [];
        
        // Frequency analysis
        this.bassEnergy = 0;
        this.vocalPresence = 0;
        this.highFreqEnergy = 0;
        
        // Transient detection
        this.transientActive = false;
        this.transientStrength = 0;
        this.transientDecay = 0.92;
        this.transientHoldTime = 8;
        this.transientHoldCounter = 0;
    }

    /**
     * Apply audio deformation to shape points
     * @param {Array} points - Shape points to deform
     * @returns {Array} Deformed points
     */
    applyAudioDeformation(points) {
        // Validate points
        if (!points || points.length === 0) {
            return this.morpher.generateFallbackCircle();
        }
        
        // Get fresh frequency data if analyzer is available
        if (this.morpher.audioAnalyzer && this.morpher.audioAnalyzer.currentFrequencies && this.morpher.audioAnalyzer.currentFrequencies.length > 0) {
            this.morpher.frequencyData = [...this.morpher.audioAnalyzer.currentFrequencies];
            
            
            // We have 32 frequency bands (0-31) that cover the full spectrum
            // Approximate mapping: each band covers ~750 Hz (24000 Hz / 32 bands)
            // Band 0-1: Sub-bass
            // Band 2-4: Bass
            // Band 5-15: Midrange
            // Band 16-25: Upper mids/presence
            // Band 26-31: Treble
            
            // BASS THUMP DETECTION: Only trigger on meaty kicks
            let currentBassEnergy = 0;
            let bassCount = 0;
            
            // Focus on low bass (bands 0-2) for the real thumps
            for (let i = 0; i <= 2 && i < this.morpher.frequencyData.length; i++) {
                currentBassEnergy += this.morpher.frequencyData[i];
                bassCount++;
            }
            if (bassCount > 0) {
                currentBassEnergy /= bassCount;
            }
            
            // Initialize bass thump detection
            if (!this.morpher.bassPeakHistory) {
                this.morpher.bassPeakHistory = [];
                this.morpher.bassThumpTimer = 0;
            }
            
            // Track recent bass peaks
            this.morpher.bassPeakHistory.push(currentBassEnergy);
            if (this.morpher.bassPeakHistory.length > 20) { // ~0.6 seconds of history
                this.morpher.bassPeakHistory.shift();
            }
            
            // Calculate dynamic threshold
            const avgBass = this.morpher.bassPeakHistory.reduce((a, b) => a + b, 0) / this.morpher.bassPeakHistory.length;
            
            // THUMP = small increase above baseline
            // Check if we're using microphone (lower levels) or audio file (higher levels)
            const isMicrophoneMode = this.morpher.audioAnalyzer && this.morpher.audioAnalyzer.microphoneStream;
            const minThreshold = isMicrophoneMode ? 0.15 : 0.25; // Lower threshold for both, but mic is lowest
            
            const isThump = currentBassEnergy > avgBass * 1.08 && // Just 8% above average
                           currentBassEnergy > minThreshold;
            
            if (isThump) {
                // Boost the effect more for microphone input
                const effectMultiplier = isMicrophoneMode ? 8 : 6; // Increase audio multiplier too
                this.bassEnergy = Math.min(1.0, (currentBassEnergy - avgBass) * effectMultiplier);
                this.morpher.bassThumpTimer = 12; // Shorter hold (12 frames ~0.4 seconds)
            } else if (this.morpher.bassThumpTimer > 0) {
                this.morpher.bassThumpTimer--;
                this.bassEnergy *= 0.9; // Slower decay for smooth wobble
            } else {
                this.bassEnergy = 0;
            }
            
            // SPECTRAL FLUX: Detect onsets in the VOCAL RANGE you identified (bands 4-15, emphasis on 11)
            // This targets the actual vocal/lead frequencies in Electric Glow
            
            // Initialize spectral history if needed
            if (!this.morpher.spectralHistory) {
                this.morpher.spectralHistory = [];
                this.morpher.spectralFluxHistory = [];
                // Music detection initialization
                this.morpher.onsetThreshold = 0;
                this.morpher.musicDetector.reset();
                this.morpher.detectedBPM = 0;
                
                // Time signature detection
                this.morpher.onsetStrengths = []; // Array of {time: ms, strength: 0-1, bassWeight: 0-1}
                this.morpher.detectedTimeSignature = null;
                this.morpher.timeSignatureConfidence = 0;
                this.morpher.measureStartTime = 0;
                this.morpher.timeSignatureHistory = [];
                this.morpher.timeSignatureLocked = false;
            }
            
            // Store current spectrum
            const currentSpectrum = [...this.morpher.frequencyData];
            
            // SIMPLER APPROACH: Look for changes in vocal bands with bass rejection
            let spectralFlux = 0;
            let bassFlux = 0;
            
            if (this.morpher.spectralHistory.length > 0) {
                const prevSpectrum = this.morpher.spectralHistory[this.morpher.spectralHistory.length - 1];
                
                // Calculate bass flux (bands 0-2)
                for (let i = 0; i <= 2 && i < currentSpectrum.length; i++) {
                    const diff = currentSpectrum[i] - prevSpectrum[i];
                    if (diff > 0) bassFlux += diff;
                }
                
                // Calculate flux in extended vocal range (bands 4-15)
                // But weight the center (9-13) more heavily
                for (let i = 4; i <= 15 && i < currentSpectrum.length; i++) {
                    const diff = currentSpectrum[i] - prevSpectrum[i];
                    if (diff > 0) {
                        // Extra weight for bands 9-13
                        const weight = (i >= 9 && i <= 13) ? 2.0 : 1.0;
                        spectralFlux += diff * weight;
                    }
                }
                
                // Suppress if there's a strong bass hit (likely a drum)
                if (bassFlux > 0.15) {
                    spectralFlux *= 0.3; // Reduce by 70% for drum hits
                }
            }
            
            // Store history (keep last 30 frames for ~1 second at 30fps)
            this.morpher.spectralHistory.push(currentSpectrum);
            if (this.morpher.spectralHistory.length > 30) {
                this.morpher.spectralHistory.shift();
            }
            
            // Store flux history for adaptive thresholding
            this.morpher.spectralFluxHistory.push(spectralFlux);
            if (this.morpher.spectralFluxHistory.length > 30) {
                this.morpher.spectralFluxHistory.shift();
            }
            
            // Calculate adaptive threshold (median + margin)
            if (this.morpher.spectralFluxHistory.length >= 10) {
                const sorted = [...this.morpher.spectralFluxHistory].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                const mean = sorted.reduce((a, b) => a + b, 0) / sorted.length;
                
                // Threshold is slightly above the median to catch significant onsets
                this.morpher.onsetThreshold = median + (mean - median) * 0.5;
            }
            
            // Detect onset (transient/attack) - focus on stronger transients for BPM
            // Use higher threshold for BPM detection vs vocal detection
            const isVocalOnset = spectralFlux > this.morpher.onsetThreshold * 1.2 && spectralFlux > 0.02;
            const isBeatOnset = spectralFlux > this.morpher.onsetThreshold * 2.0 && spectralFlux > 0.05; // Stronger threshold for beats
            
            // Smooth the detection with a short hold time
            if (isVocalOnset) {
                this.transientHoldTime = 8; // Hold for 8 frames (~250ms) for visible glitches
                this.morpher.vocalGlowBoost = 0.3; // Add 30% glow boost on vocal onset
            }
            
            // BPM DETECTION: Only track stronger onsets that are likely beats
            if (isBeatOnset) {
                const now = performance.now();
                
                // Store onset strength for time signature detection
                const onsetStrength = {
                    time: now,
                    strength: spectralFlux / (this.morpher.onsetThreshold || 1), // Normalized strength
                    bassWeight: bassFlux // Keep bass weight for downbeat detection
                };
                this.morpher.onsetStrengths.push(onsetStrength);
                // Keep last 40 onsets (about 16-20 beats)
                if (this.morpher.onsetStrengths.length > 40) {
                    this.morpher.onsetStrengths.shift();
                }
                
                // Delegate onset tracking to music detector
                this.morpher.musicDetector.addOnset(now, spectralFlux);
                
            }
            
            // Update BPM detection through music detector
            this.morpher.musicDetector.update(performance.now());
            this.morpher.detectedBPM = this.morpher.musicDetector.detectedBPM;
            this.morpher.bpmConfidence = this.morpher.musicDetector.bpmConfidence;
            
            // Update local references for compatibility
            if (this.morpher.detectedBPM > 0 && this.morpher.bpmConfidence > 0.8) {
                // Clear fast mode once we've detected BPM with confidence
                if (this.morpher.forceFastDetection) {
                    this.morpher.forceFastDetection = false;
                }
            }
            
            if (this.transientHoldTime > 0) {
                this.transientHoldTime--;
            }
            
            // Decay glow boost smoothly
            if (this.morpher.vocalGlowBoost > 0) {
                this.morpher.vocalGlowBoost *= 0.92; // Smooth decay
            }
            
            // Set vocal presence based on flux intensity
            this.vocalPresence = spectralFlux;
            
            // Update rolling averages for smarter detection
            this.morpher.bassHistory[this.morpher.historyIndex] = this.bassEnergy;
            this.morpher.vocalHistory[this.morpher.historyIndex] = this.vocalPresence;
            this.morpher.historyIndex = (this.morpher.historyIndex + 1) % this.morpher.bassHistory.length;
            
            // Calculate averages
            this.morpher.bassHistory.reduce((a, b) => a + b, 0) / this.morpher.bassHistory.length;
            this.morpher.vocalHistory.reduce((a, b) => a + b, 0) / this.morpher.vocalHistory.length;
            
            // Bass effect is now controlled by thump detection above
            this.morpher.bassEffectActive = this.morpher.bassThumpTimer > 0;
            
            // ENHANCED VOCAL DETECTION
            // Vocals are present when:
            // 1. Bands 9-13 have high contrast vs background
            // 2. Energy is above minimum threshold
            // 3. Either sudden spike OR sustained presence
            
            this.morpher.lastVocalPresence = this.morpher.lastVocalPresence || 0;
            this.morpher.lastVocalPresence = this.vocalPresence;
            
            // Transient detection - triggers on musical onsets
            this.vocalEffectActive = this.transientHoldTime > 0;
            
        }
        
        // If no analyzer or no frequency data, fallback to using audioDeformation for effects
        // This is especially important for microphone input where bass frequencies might be weak
        const hasFrequencyData = this.morpher.frequencyData && this.morpher.frequencyData.some(f => f > 0.01);
        if (!this.morpher.audioAnalyzer || !hasFrequencyData) {
            // Enhanced fallback for microphone input
            // Use audioDeformation as a proxy for bass effect when no frequency data
            if (this.audioDeformation > 0.15) { // Lower threshold for mic sensitivity
                this.morpher.bassEffectActive = true;
                this.bassEnergy = Math.min(1.0, this.audioDeformation * 0.8); // Stronger response
                
                // Simulate bass thump timer for wobble effect
                if (!this.morpher.bassThumpTimer || this.morpher.bassThumpTimer <= 0) {
                    this.morpher.bassThumpTimer = 12; // Start wobble
                }
            } else if (this.morpher.bassThumpTimer > 0) {
                // Decay the wobble
                this.morpher.bassThumpTimer--;
                this.bassEnergy *= 0.9;
            }
            
            // Use vocalEnergy for vocal effects
            if (this.vocalEnergy > 0.2) { // Lower threshold for mic
                this.vocalEffectActive = true;
                this.vocalPresence = this.vocalEnergy;
            }
        }
        
        // ONLY apply fallback bass wobble for microphone input when no frequency data
        // This ensures wobble works for mic but NOT for web audio
        if (!hasFrequencyData && this.audioDeformation > 0.15 && !this.morpher.bassEffectActive) {
            this.morpher.bassEffectActive = true;
            this.bassEnergy = Math.max(this.bassEnergy, this.audioDeformation * 0.8);
            if (!this.morpher.bassThumpTimer || this.morpher.bassThumpTimer <= 0) {
                this.morpher.bassThumpTimer = 12;
            }
        }
        
        // No deformation if no audio
        const hasAudio = this.audioDeformation !== 0 || this.bassEnergy > 0.01 || 
                        this.vocalPresence > 0.01;
        if (!hasAudio) {
            return points;
        }
        
        const deformed = [];
        const center = { x: 0.5, y: 0.5 };
        
        // Update undulation phase only when bass is active
        if (this.morpher.bassEffectActive) {
            // Randomly change direction occasionally
            if (Math.random() < 0.05) { // 5% chance per frame
                this.morpher.undulationDirection *= -1; // Reverse direction
            }
            this.morpher.undulationPhase += 0.08 * this.morpher.undulationDirection; // Apply direction
        }
        
        // Update glitch points on beat
        if (this.morpher.audioAnalyzer && this.beatGlitchIntensity > 0) {
            this.beatGlitchIntensity *= 0.9; // Decay glitch intensity
        }
        
        // Create SUBTLE glitch points when vocal presence is detected
        if (this.vocalEffectActive && Math.random() < 0.2) { // 20% chance (reduced)
            this.glitchPoints = [];
            const numGlitches = 2 + Math.floor(Math.random() * 2); // 2-3 points (fewer)
            for (let i = 0; i < numGlitches; i++) {
                this.glitchPoints.push({
                    index: Math.floor(Math.random() * points.length),
                    intensity: 0.02 + Math.random() * 0.03, // 0.02-0.05 intensity (much subtler)
                    decay: 0.94 + Math.random() * 0.02 // Slightly slower decay for smoothness
                });
            }
        }
        
        // Update existing glitch points
        this.glitchPoints = this.glitchPoints.filter(g => {
            g.intensity *= g.decay;
            return g.intensity > 0.01;
        });
        
        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            
            // Handle invalid point
            if (!point || typeof point.x === 'undefined' || typeof point.y === 'undefined') {
                const angle = (i / points.length) * Math.PI * 2;
                deformed.push({
                    x: 0.5 + Math.cos(angle) * 0.5,
                    y: 0.5 + Math.sin(angle) * 0.5
                });
                continue;
            }
            
            // Calculate base position
            const dx = point.x - center.x;
            const dy = point.y - center.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            // 1. Base expansion from overall amplitude - always active for responsiveness
            const baseExpansion = Math.abs(this.audioDeformation) * 0.12; // Reduced to 12%
            
            // 2. Bass-triggered wiggle effect
            let undulation = 0;
            let breathPulse = 0;
            
            if (this.morpher.bassEffectActive) {
                // Strong bass-driven undulation
                const waveCount = 2; // 2 waves for clean look
                const wiggleIntensity = this.bassEnergy * 0.25; // Increased from 0.15 to 0.25
                undulation = Math.sin(angle * waveCount + this.morpher.undulationPhase) * wiggleIntensity;
                
                // Subtle breathing pulse synced with undulation
                breathPulse = Math.sin(this.morpher.undulationPhase * 0.5) * this.bassEnergy * 0.08; // Increased from 0.05
            }
            
            // 5. Check for glitch points - SUBTLE shimmer/ripple effect
            let glitchOffset = 0;
            const glitchPoint = this.glitchPoints.find(g => g.index === i);
            if (glitchPoint) {
                // Create a subtle ripple/shimmer instead of harsh glitch
                const shimmerTime = Date.now() * 0.015; // Slower oscillation
                const shimmer = Math.sin(shimmerTime + i * 0.5) * Math.cos(shimmerTime * 0.7);
                glitchOffset = glitchPoint.intensity * shimmer * 0.5; // Can go in or out, very subtle
            }
            
            // Combine all deformations - simpler, more selective
            const totalDeformation = 1 + baseExpansion + undulation + breathPulse + glitchOffset;
            
            const newDistance = distance * Math.max(0.8, totalDeformation); // Never shrink below 80%
            
            deformed.push({
                x: center.x + Math.cos(angle) * newDistance,
                y: center.y + Math.sin(angle) * newDistance
            });
        }
        
        return deformed;
    }

    /**
     * Set audio deformation value
     * @param {number} value - Deformation value (0-1)
     */
    setAudioDeformation(value) {
        this.audioDeformation = Math.max(0, Math.min(1, value));
        this.vocalEffectActive = value > 0.01;
    }

    /**
     * Set vocal energy for shape pulsing
     * @param {number} value - Energy value (0-1)
     */
    setVocalEnergy(value) {
        this.vocalEnergy = Math.max(0, Math.min(1, value));
        this.vocalEffectActive = value > 0.01;
    }

    /**
     * Update frequency band energies
     * @param {Object} frequencyData - Frequency analysis data
     */
    updateFrequencyBands(frequencyData) {
        if (frequencyData) {
            this.bassEnergy = frequencyData.bass || 0;
            this.vocalPresence = frequencyData.vocal || 0;
            this.highFreqEnergy = frequencyData.high || 0;
        }
    }

    /**
     * Process transient/beat detection
     * @param {number} amplitude - Current audio amplitude
     * @param {number} threshold - Beat threshold
     */
    processTransient(amplitude, threshold) {
        if (amplitude > threshold) {
            this.transientActive = true;
            this.transientStrength = amplitude;
            this.transientHoldCounter = this.transientHoldTime;
        } else if (this.transientHoldCounter > 0) {
            this.transientHoldCounter--;
        } else {
            this.transientStrength *= this.transientDecay;
            if (this.transientStrength < 0.01) {
                this.transientActive = false;
            }
        }
    }

    /**
     * Get current deformation state
     */
    getState() {
        return {
            audioDeformation: this.audioDeformation,
            vocalEnergy: this.vocalEnergy,
            vocalEffectActive: this.vocalEffectActive,
            beatGlitchIntensity: this.beatGlitchIntensity,
            transientActive: this.transientActive,
            transientStrength: this.transientStrength
        };
    }

    /**
     * Reset all audio effects
     */
    reset() {
        this.audioDeformation = 0;
        this.vocalEnergy = 0;
        this.vocalEffectActive = false;
        this.beatGlitchIntensity = 0;
        this.glitchPoints = [];
        this.transientActive = false;
        this.transientStrength = 0;
    }
}

/**
 * AgentBPMDetector - Fast, agent-based BPM detection
 * Uses multiple competing hypotheses that converge on the true tempo
 * @module core/morpher/AgentBPMDetector
 */

class AgentBPMDetector {
    constructor() {
        // Agent pool
        this.agents = [];
        this.maxAgents = 8;

        // Detection state
        this.isActive = false;
        this.confidence = 0;
        this.lockedBPM = 0;
        this.lastBeatTime = 0;

        // Audio analysis
        this.peakHistory = [];
        this.maxHistoryLength = 100; // ~3 seconds at 30fps

        // Configuration
        this.minBPM = 40;
        this.maxBPM = 300;
        this.convergenceThreshold = 0.7; // Lower threshold for faster lock
        this.subdivisionPreference = {
            slow: { min: 40, max: 80, prefer: 1 },     // Keep normal for slow (40-80 is already slow)
            normal: { min: 80, max: 140, prefer: 1 },  // Normal for mid
            fast: { min: 140, max: 180, prefer: 0.5 }, // Half for moderately fast
            veryfast: { min: 180, max: 300, prefer: 0.5 } // Half for very fast
        };
    }

    /**
     * BPM Agent - represents one tempo hypothesis
     */
    createAgent(bpm, subdivision = 1) {
        return {
            bpm,
            subdivision,
            effectiveBPM: bpm * subdivision,
            phase: 0,
            confidence: 0.5,
            hits: 0,
            misses: 0,
            lastBeatTime: performance.now(),
            beatInterval: 60000 / (bpm * subdivision)
        };
    }

    /**
     * Initialize agents with diverse starting hypotheses
     */
    initializeAgents(initialGuess = 120) {
        this.agents = [];

        // Prefer lower subdivisions - if initial guess is high, try halving it
        let subdivisions = [1]; // Start with normal

        if (initialGuess > 180) {
            // Very fast - prefer half speed
            subdivisions = [0.5, 0.75, 1];
        } else if (initialGuess > 140) {
            // Fast - try half and normal
            subdivisions = [0.5, 0.75, 1];
        } else if (initialGuess < 60) {
            // Very slow - try doubling
            subdivisions = [1, 1.5, 2];
        } else {
            // Normal range - try various
            subdivisions = [0.5, 1, 1.5];
        }

        subdivisions.forEach(sub => {
            const agent = this.createAgent(initialGuess, sub);
            // Give preference to lower effective BPMs
            if (initialGuess * sub < 140) {
                agent.confidence = 0.6; // Slight boost for sensible BPMs
            }
            this.agents.push(agent);
        });

        // Add some agents that try to find a lower BPM if initial is high
        if (initialGuess > 140) {
            this.agents.push(this.createAgent(initialGuess / 2, 1));
            this.agents.push(this.createAgent(initialGuess / 2, 1.5));
        }
    }

    /**
     * Process new audio peak/onset
     */
    processPeak(strength, time = performance.now()) {
        // Add to history
        this.peakHistory.push({ strength, time });
        if (this.peakHistory.length > this.maxHistoryLength) {
            this.peakHistory.shift();
        }

        // Only process if we have enough history
        if (this.peakHistory.length < 4) return;

        // If not active, initialize from FFT guess
        if (!this.isActive || this.agents.length === 0) {
            const fftGuess = this.getFFTEstimate();
            this.initializeAgents(fftGuess);
            this.isActive = true;
        }

        // If already locked, be more conservative about changes
        if (this.lockedBPM > 0 && this.confidence > 0.7) {
            // Only update agents, don't evolve as aggressively
            this.agents.forEach(agent => {
                this.scoreAgent(agent, time, strength);
            });

            // Only evolve if confidence has dropped significantly
            if (this.confidence < 0.6) {
                this.evolveAgents();
                this.checkConvergence();
            }
        } else {
            // Not locked yet, be aggressive
            // Score each agent against the peak
            this.agents.forEach(agent => {
                this.scoreAgent(agent, time, strength);
            });

            // Evolution step
            this.evolveAgents();

            // Check for convergence
            this.checkConvergence();
        }
    }

    /**
     * Score agent based on how well it predicts this peak
     */
    scoreAgent(agent, peakTime, peakStrength) {
        const timeSinceLastBeat = peakTime - agent.lastBeatTime;
        const expectedNextBeat = agent.beatInterval;

        // Calculate phase alignment (0-1, where 1 is perfect)
        const phaseDiff = Math.abs((timeSinceLastBeat % expectedNextBeat) / expectedNextBeat - 0.5) * 2;
        const alignment = 1 - phaseDiff;

        // Update agent stats (more aggressive confidence building)
        if (alignment > 0.7) { // Lower threshold
            agent.hits++;
            agent.confidence = Math.min(1, agent.confidence + 0.1); // Faster increase

            // Update phase if we're close
            if (alignment > 0.85) {
                agent.lastBeatTime = peakTime;
            }
        } else if (alignment < 0.3) {
            agent.misses++;
            agent.confidence = Math.max(0, agent.confidence - 0.03);
        }

        // Decay confidence slowly for inactive agents
        agent.confidence *= 0.998; // Slower decay
    }

    /**
     * Evolve agents - kill weak ones, spawn variations of strong ones
     */
    evolveAgents() {
        // Sort by confidence
        this.agents.sort((a, b) => b.confidence - a.confidence);

        // Kill weakest if we have too many
        if (this.agents.length > this.maxAgents) {
            this.agents = this.agents.slice(0, this.maxAgents);
        }

        // If top agent is very confident, spawn slight variations
        const bestAgent = this.agents[0];
        if (bestAgent.confidence > 0.7 && this.agents.length < this.maxAgents) {
            // Try slight BPM variations
            const variation = 1 + (Math.random() - 0.5) * 0.02; // ±1%
            const newAgent = this.createAgent(
                bestAgent.bpm * variation,
                bestAgent.subdivision
            );
            newAgent.confidence = bestAgent.confidence * 0.8;
            this.agents.push(newAgent);
        }

        // Kill agents with very low confidence
        this.agents = this.agents.filter(a => a.confidence > 0.1);
    }

    /**
     * Check if agents have converged on a tempo
     */
    checkConvergence() {
        if (this.agents.length === 0) return;

        const bestAgent = this.agents[0];

        // Need high confidence and clear winner
        if (bestAgent.confidence > this.convergenceThreshold) {
            // Check if other top agents agree (within 5% for faster convergence)
            const similarAgents = this.agents.filter(a =>
                Math.abs(a.effectiveBPM - bestAgent.effectiveBPM) / bestAgent.effectiveBPM < 0.05
            );

            // Only need 2 agents to agree for faster lock
            if (similarAgents.length >= Math.min(2, this.agents.length * 0.3)) {
                // We have convergence!
                this.lockedBPM = Math.round(bestAgent.bpm);
                this.confidence = bestAgent.confidence;

                // Auto-select best subdivision
                this.autoSelectSubdivision();

                return true;
            }
        }

        return false;
    }

    /**
     * Auto-select subdivision based on BPM range
     */
    autoSelectSubdivision() {
        for (const [range, config] of Object.entries(this.subdivisionPreference)) {
            if (this.lockedBPM >= config.min && this.lockedBPM < config.max) {
                // Find agent with preferred subdivision
                const preferredAgent = this.agents.find(a =>
                    Math.abs(a.bpm - this.lockedBPM) < 2 &&
                    Math.abs(a.subdivision - config.prefer) < 0.1
                );

                if (preferredAgent) {
                    return config.prefer;
                }
            }
        }
        return 1; // Default
    }

    /**
     * Get rough BPM estimate from FFT (frequency domain)
     */
    getFFTEstimate() {
        if (this.peakHistory.length < 4) return 120; // Default

        // Calculate intervals between recent peaks
        const recentPeaks = this.peakHistory.slice(-10);
        const intervals = [];

        for (let i = 1; i < recentPeaks.length; i++) {
            intervals.push(recentPeaks[i].time - recentPeaks[i-1].time);
        }

        if (intervals.length === 0) return 120;

        // Find most common interval (mode)
        intervals.sort((a, b) => a - b);
        const median = intervals[Math.floor(intervals.length / 2)];

        // Convert to BPM
        let estimatedBPM = 60000 / median;

        // Sanity check - if way out of range, try doubling/halving
        if (estimatedBPM < this.minBPM) {
            estimatedBPM *= 2;
        } else if (estimatedBPM > this.maxBPM) {
            estimatedBPM /= 2;
        }

        return Math.max(this.minBPM, Math.min(this.maxBPM, estimatedBPM));
    }

    /**
     * Force reset detection with new seed
     */
    reset(seedBPM = null) {
        this.agents = [];
        this.confidence = 0;
        this.lockedBPM = 0;
        this.peakHistory = [];

        if (seedBPM) {
            this.initializeAgents(seedBPM);
        }
    }

    /**
     * Get current best BPM estimate
     */
    getBPM() {
        if (this.lockedBPM > 0 && this.confidence > 0.8) {
            return this.lockedBPM;
        }

        if (this.agents.length > 0) {
            return Math.round(this.agents[0].bpm);
        }

        return 0;
    }

    /**
     * Get recommended subdivision
     */
    getSubdivision() {
        if (this.agents.length > 0) {
            const bestAgent = this.agents[0];

            // Check BPM range preferences
            const {bpm} = bestAgent;
            for (const [range, config] of Object.entries(this.subdivisionPreference)) {
                if (bpm >= config.min && bpm < config.max) {
                    return config.prefer;
                }
            }

            return bestAgent.subdivision;
        }
        return 1;
    }

    /**
     * Get detection status
     */
    getStatus() {
        return {
            bpm: this.getBPM(),
            subdivision: this.getSubdivision(),
            confidence: this.confidence,
            locked: this.lockedBPM > 0 && this.confidence > 0.8,
            agentCount: this.agents.length,
            topAgents: this.agents.slice(0, 3).map(a => ({
                bpm: Math.round(a.bpm),
                subdivision: a.subdivision,
                confidence: a.confidence.toFixed(2)
            }))
        };
    }
}

/**
 * MusicDetector - Handles BPM and time signature detection
 * @module core/morpher/MusicDetector
 */


class MusicDetector {
    constructor() {
        // Beat detection state
        this.onsetIntervals = [];
        this.onsetStrengths = [];
        this.lastOnsetTime = 0;
        this.onsetThreshold = 0.3;

        // BPM detection
        this.detectedBPM = 0;
        this.bpmConfidence = 0;
        this.lastBPMCalculation = 0;
        this.bpmCalculationInterval = 2000; // Recalculate every 2 seconds

        // BPM tracking
        this.bpmHistory = [];
        this.tempoLocked = false;
        this.fundamentalBPM = 0;

        // Agent-based detector for fast convergence
        this.agentDetector = new AgentBPMDetector();
        this.useAgentDetection = true; // Flag to enable/disable

        // Time signature detection
        this.timeSignature = '4/4';
        this.detectedTimeSignature = null;
        this.timeSignatureConfidence = 0;
        this.timeSignatureHistory = [];
        this.timeSignatureLocked = false;
        this.downbeatPhase = 0;
        this.measureLength = 4;
        this.measureStartTime = 0;

        // Music state
        this.isMusicalContent = false;
        this.musicalityScore = 0;

        // Fast detection mode
        this.forceFastDetection = false;
    }

    /**
     * Calculate BPM from onset intervals with improved stability
     * @returns {number} Detected BPM
     */
    calculateBPM() {
        // Try agent detector first for faster results
        if (this.useAgentDetection) {
            const agentStatus = this.agentDetector.getStatus();
            if (agentStatus.locked && agentStatus.confidence > 0.6) { // Lower threshold
                // Use agent's locked BPM
                this.detectedBPM = agentStatus.bpm;
                this.bpmConfidence = agentStatus.confidence;
                this.tempoLocked = true;
                this.fundamentalBPM = agentStatus.bpm;

                // Update history
                this.bpmHistory.push(this.detectedBPM);
                if (this.bpmHistory.length > 10) {
                    this.bpmHistory.shift();
                }

                return this.detectedBPM;
            } else if (agentStatus.bpm > 0 && agentStatus.confidence > 0.4) { // Lower threshold
                // Use agent's estimate if somewhat confident
                this.detectedBPM = agentStatus.bpm;
                this.bpmConfidence = agentStatus.confidence;

                // Also mark as tempo locked if confidence is decent
                if (agentStatus.confidence > 0.6) {
                    this.tempoLocked = true;
                }

                return this.detectedBPM;
            }
        }

        // Fall back to original method if agent not ready
        if (this.onsetIntervals.length < 4) return this.detectedBPM;
        
        // Use appropriate window size based on available data
        const analysisWindow = this.onsetIntervals.slice(-15);
        
        // Find tempo candidates using autocorrelation-like approach
        const tempoCandidates = this.findTempoCandidates(analysisWindow);
        if (tempoCandidates.length === 0) return this.detectedBPM;
        
        // Get the best tempo candidate
        const bestCandidate = tempoCandidates[0];
        const candidateBPM = Math.round(60000 / bestCandidate.interval);
        
        // If we haven't locked a tempo yet, establish the fundamental
        if (!this.tempoLocked && this.bpmHistory.length > 3) {
            // Check if we have consistent readings
            const recentBPMs = this.bpmHistory.slice(-3);
            const avgRecent = recentBPMs.reduce((a, b) => a + b, 0) / recentBPMs.length;
            const variance = recentBPMs.reduce((sum, bpm) => sum + Math.pow(bpm - avgRecent, 2), 0) / recentBPMs.length;
            
            // Lock faster with tighter variance requirement
            if (variance < 5) { // Less than ~2 BPM standard deviation - much tighter
                this.fundamentalBPM = Math.round(avgRecent);
                this.tempoLocked = true;
                this.bpmConfidence = 1.0;
            }
        }
        
        // Check if new BPM is a harmonic of the fundamental
        let finalBPM = candidateBPM;
        if (this.tempoLocked) {
            const harmonic = this.checkHarmonicRelation(candidateBPM, this.fundamentalBPM);
            if (harmonic) {
                // It's a valid harmonic, adjust to fundamental
                finalBPM = this.fundamentalBPM;
                this.bpmConfidence = Math.min(1.0, this.bpmConfidence + 0.1);
            } else {
                // Not a harmonic - check if we should update fundamental
                this.bpmConfidence *= 0.9;
                
                // Only change if confidence is very low and new tempo is strong
                if (this.bpmConfidence < 0.3 && bestCandidate.strength > 0.8) {
                    this.fundamentalBPM = candidateBPM;
                    this.bpmConfidence = 0.5;
                } else {
                    // Stick with fundamental
                    finalBPM = this.fundamentalBPM;
                }
            }
        }
        
        // Update history
        this.bpmHistory.push(finalBPM);
        if (this.bpmHistory.length > 10) {
            this.bpmHistory.shift();
        }
        
        // Apply smoothing
        if (this.detectedBPM === 0) {
            this.detectedBPM = finalBPM;
        } else {
            const maxChange = this.tempoLocked ? 1 : 2; // Reduced from 5 to 2 for stability
            const diff = finalBPM - this.detectedBPM;
            if (Math.abs(diff) <= maxChange) {
                this.detectedBPM = finalBPM;
            } else {
                this.detectedBPM += Math.sign(diff) * maxChange;
            }
        }
        
        // Update rhythm engine if available
        if (window.rhythmIntegration && window.rhythmIntegration.updateBPM) {
            if (!window.rhythmManuallyStoppedForCurrentAudio) {
                window.rhythmIntegration.updateBPM(this.detectedBPM);
            }
        }
        
        return this.detectedBPM;
    }

    /**
     * Find tempo candidates from intervals
     * @param {Array} intervals - Time intervals between onsets
     * @returns {Array} Tempo candidates with confidence scores
     */
    findTempoCandidates(intervals) {
        const candidates = [];
        
        // Test different interval groupings (1x, 2x, 4x) for beat patterns
        for (const multiplier of [1, 2, 4]) {
            const testIntervals = intervals.map(i => i * multiplier);
            
            // Find clusters of similar intervals
            const clusters = this.clusterIntervals(testIntervals);
            
            for (const cluster of clusters) {
                const avgInterval = cluster.intervals.reduce((a, b) => a + b, 0) / cluster.intervals.length;
                const actualInterval = avgInterval / multiplier;
                
                // Calculate strength based on cluster size and consistency
                const strength = (cluster.intervals.length / intervals.length) * cluster.consistency;
                
                // Only consider if it would result in reasonable BPM
                const bpm = 60000 / actualInterval;
                // Prefer common BPM ranges (120-140 is very common)
                const commonBPMBonus = (bpm >= 120 && bpm <= 140) ? 0.2 : 0;
                if (bpm >= 60 && bpm <= 220) {
                    candidates.push({
                        interval: actualInterval,
                        strength: strength + commonBPMBonus,
                        multiplier
                    });
                }
            }
        }
        
        // Sort by strength
        return candidates.sort((a, b) => b.strength - a.strength);
    }

    /**
     * Cluster similar intervals together
     * @param {Array} intervals - Time intervals
     * @returns {Array} Clustered intervals
     */
    clusterIntervals(intervals) {
        const sorted = [...intervals].sort((a, b) => a - b);
        const clusters = [];
        let currentCluster = [sorted[0]];
        
        for (let i = 1; i < sorted.length; i++) {
            const tolerance = currentCluster[0] * 0.03; // 3% tolerance - tighter for stable BPM
            if (sorted[i] - currentCluster[0] <= tolerance) {
                currentCluster.push(sorted[i]);
            } else {
                if (currentCluster.length >= 2) {
                    // Calculate consistency (inverse of variance)
                    const avg = currentCluster.reduce((a, b) => a + b, 0) / currentCluster.length;
                    const variance = currentCluster.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / currentCluster.length;
                    const consistency = 1 / (1 + variance / (avg * avg)); // Normalized by average
                    
                    clusters.push({
                        intervals: currentCluster,
                        consistency
                    });
                }
                currentCluster = [sorted[i]];
            }
        }
        
        // Don't forget the last cluster
        if (currentCluster.length >= 3) {
            const avg = currentCluster.reduce((a, b) => a + b, 0) / currentCluster.length;
            const variance = currentCluster.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / currentCluster.length;
            const consistency = 1 / (1 + variance / (avg * avg));
            clusters.push({
                intervals: currentCluster,
                consistency
            });
        }
        
        return clusters;
    }

    /**
     * Check if two BPMs are harmonically related
     * @param {number} bpm1 - First BPM
     * @param {number} bpm2 - Second BPM
     * @returns {boolean} True if harmonically related
     */
    checkHarmonicRelation(bpm1, bpm2) {
        const ratio = Math.max(bpm1, bpm2) / Math.min(bpm1, bpm2);
        const tolerance = 0.03;
        
        // Check for simple ratios (2:1, 3:2, 4:3, etc.)
        const simpleRatios = [2, 1.5, 1.333, 1.25];
        return simpleRatios.some(r => Math.abs(ratio - r) < tolerance);
    }

    /**
     * Detect time signature from onset patterns
     * @returns {string} Detected time signature
     */
    detectTimeSignature() {
        // Need at least a detected BPM and some onset data
        const minOnsets = this.forceFastDetection ? 6 : 12;
        if (this.detectedBPM === 0 || this.onsetStrengths.length < minOnsets) {
            return this.timeSignature;
        }
        
        // If already locked, don't change unless we're in fast mode (just reset)
        if (this.timeSignatureLocked && !this.forceFastDetection) {
            return this.detectedTimeSignature || this.timeSignature;
        }
        
        const beatInterval = 60000 / this.detectedBPM;
        
        // Only test the most common measure length first (4 beats)
        // We'll be conservative and mostly detect 4/4 unless very clear pattern
        const measureLength = 4;
        const beatBins = new Array(measureLength).fill(0).map(() => ({
            strength: 0,
            bassWeight: 0,
            count: 0
        }));
        
        // Align recent onsets to a 4-beat grid
        const recentOnsets = this.onsetStrengths.slice(-Math.min(20, this.onsetStrengths.length));
        if (recentOnsets.length === 0) return this.timeSignature;
        const startTime = recentOnsets[0].time;
        
        for (const onset of recentOnsets) {
            const timeSinceStart = onset.time - startTime;
            const beatPosition = (timeSinceStart / beatInterval) % measureLength;
            const binIndex = Math.round(beatPosition) % measureLength;
            
            beatBins[binIndex].strength += onset.strength;
            beatBins[binIndex].bassWeight += onset.bassWeight || 0;
            beatBins[binIndex].count++;
        }
        for (const bin of beatBins) {
            if (bin.count > 0) {
                bin.strength /= bin.count;
                bin.bassWeight /= bin.count;
            }
        }
        
        // Default to 4/4 for most music
        let detectedSig = '4/4';
        
        // Only detect 3/4 if we have a VERY clear waltz pattern
        // (strong-weak-weak with no emphasis on beat 4)
        if (beatBins[0].strength > beatBins[1].strength * 2 &&
            beatBins[0].strength > beatBins[2].strength * 2 &&
            beatBins[3].count < beatBins[0].count * 0.5) {
            // Might be 3/4, but need more confidence
            const waltzConfidence = this.testWaltzPattern(recentOnsets, beatInterval);
            if (waltzConfidence > 0.8) {
                detectedSig = '3/4';
            }
        }
        
        // Add to history
        this.timeSignatureHistory.push(detectedSig);
        if (this.timeSignatureHistory.length > 3) {
            this.timeSignatureHistory.shift();
        }
        
        // Lock faster - only need 2 readings in fast mode, 3 normally
        const minReadings = this.forceFastDetection ? 2 : 3;
        if (this.timeSignatureHistory.length >= minReadings) {
            const counts = {};
            for (const sig of this.timeSignatureHistory) {
                counts[sig] = (counts[sig] || 0) + 1;
            }
            
            // Find most common
            let mostCommon = '4/4';
            let maxCount = 0;
            for (const [sig, count] of Object.entries(counts)) {
                if (count > maxCount) {
                    maxCount = count;
                    mostCommon = sig;
                }
            }
            
            // Lock if we have agreement (at least 2 out of 3)
            if (maxCount >= 2) {
                this.detectedTimeSignature = mostCommon;
                this.timeSignatureLocked = true;
                this.timeSignatureConfidence = maxCount / 3;
                
                // Update rhythm engine if available
                if (window.rhythmIntegration && window.rhythmIntegration.setTimeSignature) {
                    window.rhythmIntegration.setTimeSignature(this.detectedTimeSignature);
                }
                
                
                // Also directly update UI in case rhythmIntegration doesn't
                const timeSigDisplay = document.getElementById('time-sig-display');
                if (timeSigDisplay) {
                    timeSigDisplay.textContent = this.detectedTimeSignature;
                }
            }
        }
        
        return this.detectedTimeSignature || this.timeSignature;
    }

    /**
     * Test for waltz pattern (3/4 time)
     * @param {Array} onsets - Onset times and strengths
     * @param {number} beatInterval - Beat interval in ms
     * @returns {number} Confidence score (0-1) for waltz pattern
     */
    testWaltzPattern(onsets, beatInterval) {
        // Look for groups of 3 beats with strong-weak-weak pattern
        let waltzGroups = 0;
        let totalGroups = 0;
        
        for (let i = 0; i < onsets.length - 2; i += 3) {
            if (i + 2 < onsets.length) {
                totalGroups++;
                const first = onsets[i].strength + (onsets[i].bassWeight || 0);
                const second = onsets[i + 1].strength + (onsets[i + 1].bassWeight || 0);
                const third = onsets[i + 2].strength + (onsets[i + 2].bassWeight || 0);
                
                // Check for strong-weak-weak pattern
                if (first > second * 1.5 && first > third * 1.5) {
                    waltzGroups++;
                }
            }
        }
        
        return totalGroups > 0 ? waltzGroups / totalGroups : 0;
    }

    /**
     * Add onset event for analysis
     * @param {number} time - Onset time
     * @param {number} strength - Onset strength
     * @param {number} bassWeight - Optional bass weight for downbeat detection
     */
    addOnset(time, strength, bassWeight = 0) {
        // Feed to agent detector for fast convergence
        if (this.useAgentDetection) {
            this.agentDetector.processPeak(strength, time);
        }

        if (this.lastOnsetTime > 0) {
            const interval = time - this.lastOnsetTime;
            // Filter reasonable intervals (60-220 BPM range)
            if (interval > 273 && interval < 1000) {
                this.onsetIntervals.push(interval);
                if (this.onsetIntervals.length > 20) {
                    this.onsetIntervals.shift();
                }
            }
        }

        this.onsetStrengths.push({ time, strength, bassWeight });
        if (this.onsetStrengths.length > 40) {
            this.onsetStrengths.shift();
        }

        this.lastOnsetTime = time;
    }

    /**
     * Update music detection
     * @param {number} now - Current time
     */
    update(now) {
        // Periodically recalculate BPM
        if (now - this.lastBPMCalculation > this.bpmCalculationInterval) {
            this.calculateBPM();
            this.detectTimeSignature();
            this.lastBPMCalculation = now;
        }
    }

    /**
     * Get recommended subdivision for current BPM
     */
    getRecommendedSubdivision() {
        if (this.useAgentDetection) {
            return this.agentDetector.getSubdivision();
        }

        // Fallback logic based on BPM ranges - prefer lower subdivisions
        if (this.detectedBPM < 60) return 2;     // Double for very slow
        if (this.detectedBPM < 80) return 1;     // Normal for slow
        if (this.detectedBPM > 180) return 0.5;  // Half for very fast
        if (this.detectedBPM > 140) return 0.5;  // Half for fast
        return 1; // Normal for mid-range (80-140)
    }

    /**
     * Reset music detection state
     */
    reset() {
        this.onsetIntervals = [];
        this.onsetStrengths = [];
        this.lastOnsetTime = 0;
        this.detectedBPM = 0;
        this.bpmConfidence = 0;
        this.bpmHistory = [];
        this.tempoLocked = false;
        this.fundamentalBPM = 0;
        this.timeSignature = '4/4';
        this.detectedTimeSignature = null;
        this.timeSignatureConfidence = 0;
        this.timeSignatureHistory = [];

        // Reset agent detector
        if (this.agentDetector) {
            this.agentDetector.reset();
        }
        this.timeSignatureLocked = false;
        this.isMusicalContent = false;
        this.forceFastDetection = false;
    }

    /**
     * Get current music information
     */
    getMusicInfo() {
        return {
            bpm: this.detectedBPM,
            confidence: this.bpmConfidence,
            timeSignature: this.timeSignature,
            isMusical: this.isMusicalContent,
            musicalityScore: this.musicalityScore
        };
    }
}

/**
 * TransitionManager - Manages shape transitions and morphing queue
 * @module core/morpher/TransitionManager
 */

// import { shapeCache } from '../cache/ShapeCache.js';

class TransitionManager {
    constructor(morpher) {
        this.morpher = morpher;
        
        // Transition state
        this.isTransitioning = false;
        this.transitionStartTime = 0;
        this.transitionDuration = 800;
        this.transitionProgress = 0;
        this.easingFunction = 'easeInOutQuad';
        
        // Shape state
        this.currentShape = 'circle';
        this.targetShape = null;
        this.previousShape = null;
        
        // Morph queue
        this.morphQueue = [];
        this.maxQueueSize = 3;
        
        // Shadow effects
        this.shadowConfig = null;
        this.shadowProgress = 0;
    }

    /**
     * Start a shape transition
     * @param {string} targetShape - Target shape name
     * @param {Object} options - Transition options
     */
    startTransition(targetShape, options = {}) {
        // If already transitioning, queue it
        if (this.isTransitioning && this.morphQueue.length < this.maxQueueSize) {
            this.morphQueue.push({ shape: targetShape, options });
            return;
        }
        
        this.previousShape = this.currentShape;
        this.targetShape = targetShape;
        this.isTransitioning = true;
        this.transitionStartTime = performance.now();
        this.transitionDuration = options.duration || 800;
        this.easingFunction = options.easing || 'easeInOutQuad';
        this.transitionProgress = 0;
        
        // Get transition config for special effects
        this.shadowConfig = this.getTransitionConfig(this.currentShape, targetShape);
    }

    /**
     * Update transition progress
     * @param {number} deltaTime - Time since last frame
     */
    update(deltaTime) {
        if (!this.isTransitioning) return;
        
        const now = performance.now();
        const elapsed = now - this.transitionStartTime;
        const rawProgress = Math.min(1, elapsed / this.transitionDuration);
        
        // Apply easing
        this.transitionProgress = this.applyEasing(rawProgress);
        
        // Update shadow progress if configured
        if (this.shadowConfig) {
            this.shadowProgress = this.calculateShadowProgress(rawProgress);
        }
        
        // Complete transition if done
        if (rawProgress >= 1) {
            this.completeTransition();
        }
    }

    /**
     * Complete current transition
     */
    completeTransition() {
        this.currentShape = this.targetShape;
        this.targetShape = null;
        this.isTransitioning = false;
        this.transitionProgress = 0;
        this.shadowConfig = null;
        
        // Process queue if there are pending morphs
        if (this.morphQueue.length > 0) {
            const next = this.morphQueue.shift();
            this.startTransition(next.shape, next.options);
        }
    }

    /**
     * Get transition configuration for special effects
     * @param {string} from - Source shape
     * @param {string} to - Target shape
     * @returns {Object} Transition configuration
     */
    getTransitionConfig(from, to) {
        // Special transition effects for certain shape combinations
        const transitions = {
            'circle-heart': {
                type: 'bloom',
                shadowColor: '#ff69b4',
                shadowIntensity: 0.3
            },
            'heart-circle': {
                type: 'contract',
                shadowColor: '#ff69b4',
                shadowIntensity: 0.2
            },
            'circle-star': {
                type: 'burst',
                shadowColor: '#ffd700',
                shadowIntensity: 0.4
            },
            'star-circle': {
                type: 'collapse',
                shadowColor: '#ffd700',
                shadowIntensity: 0.3
            }
        };
        
        const key = `${from}-${to}`;
        return transitions[key] || null;
    }

    /**
     * Calculate shadow progress for special effects
     * @param {number} progress - Raw transition progress
     * @returns {number} Shadow effect progress
     */
    calculateShadowProgress(progress) {
        if (!this.shadowConfig) return 0;
        
        switch (this.shadowConfig.type) {
        case 'bloom':
            // Expand then fade
            return progress < 0.5 
                ? progress * 2 
                : 2 - (progress * 2);
            
        case 'burst':
            // Quick expand and fade
            return Math.pow(1 - progress, 2);
            
        case 'contract':
        case 'collapse':
            // Fade in then shrink
            return Math.sin(progress * Math.PI);
            
        default:
            return 0;
        }
    }

    /**
     * Apply easing function to progress
     * @param {number} t - Linear progress (0-1)
     * @returns {number} Eased progress
     */
    applyEasing(t) {
        switch (this.easingFunction) {
        case 'linear':
            return t;
        case 'easeInQuad':
            return t * t;
        case 'easeOutQuad':
            return t * (2 - t);
        case 'easeInOutQuad':
            return t < 0.5 
                ? 2 * t * t 
                : -1 + (4 - 2 * t) * t;
        case 'easeInCubic':
            return t * t * t;
        case 'easeOutCubic':
            return (--t) * t * t + 1;
        case 'easeInOutCubic':
            return t < 0.5 
                ? 4 * t * t * t 
                : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        default:
            return t;
        }
    }

    /**
     * Clear morph queue
     */
    clearQueue() {
        this.morphQueue = [];
    }

    /**
     * Check if has queued morphs
     */
    hasQueuedMorphs() {
        return this.morphQueue.length > 0;
    }

    /**
     * Get current state
     */
    getState() {
        return {
            isTransitioning: this.isTransitioning,
            currentShape: this.currentShape,
            targetShape: this.targetShape,
            progress: this.transitionProgress,
            queueLength: this.morphQueue.length
        };
    }

    /**
     * Reset to default state
     */
    reset() {
        this.isTransitioning = false;
        this.currentShape = 'circle';
        this.targetShape = null;
        this.transitionProgress = 0;
        this.morphQueue = [];
        this.shadowConfig = null;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Shape Morphing System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Musical shape morphing system using modular shapes
 * @author Emotive Engine Team
 * @module core/ShapeMorpher
 */


/**
 * ShapeMorpher class - manages smooth transitions between shapes
 */
class ShapeMorpher {
    constructor(options = {}) {
        // Configuration
        this.numPoints = options.numPoints || 64;
        this.morphDuration = options.morphDuration || 1000; // Default 1 second
        this.easing = options.easing || 'easeInOutCubic';
        
        // Initialize modular components
        this.transitionManager = new TransitionManager(this);
        this.audioDeformer = new AudioDeformer(this);
        this.musicDetector = new MusicDetector();
        
        // State - delegated to TransitionManager
        this.currentShape = 'circle';
        this.targetShape = null;
        this.morphProgress = 0;
        this.visualProgress = 0; // Smoothed visual progress for rendering
        this.morphStartTime = null;
        this.isTransitioning = false;
        
        // Shape data cache
        this.shapeCache = new Map();
        this.currentPoints = [];
        this.targetPoints = [];
        
        // Musical timing
        this.musicalDuration = null;
        this.onBeat = false;
        
        // Audio deformation with throttling - delegated to AudioDeformer
        this.audioDeformation = 0;
        this.vocalEnergy = 0;
        this.lastAudioUpdate = 0;
        this.lastVocalUpdate = 0;  // Separate timestamp for vocal updates
        this.audioUpdateInterval = 33; // Update at ~30fps max
        
        // Enhanced audio visualization
        this.audioAnalyzer = null; // Reference to audio analyzer for frequency data
        this.frequencyData = arrayPool.acquire(32, 'float32'); // Store frequency bands
        this.glitchPoints = []; // Track points that are glitching
        this.undulationPhase = 0; // Phase for wave animation
        this.undulationDirection = 1; // Random direction for bass wobble
        this.beatGlitchIntensity = 0; // Intensity of beat-triggered glitches
        
        // Frequency-specific energy tracking
        this.bassEnergy = 0; // Low frequency energy (20-250 Hz)
        this.vocalPresence = 0; // Mid frequency energy (250-4000 Hz)
        
        // Rolling averages for dynamic thresholds
        this.bassHistory = arrayPool.acquire(60, 'float32'); // 2 seconds at 30fps
        this.vocalHistory = arrayPool.acquire(60, 'float32');
        this.historyIndex = 0;
        
        // Cooldown timers to prevent effect spam
        this.bassEffectCooldown = 0;
        this.vocalEffectCooldown = 0;
        
        // Threshold multipliers (can be adjusted for mic vs audio)
        this.bassThresholdMultiplier = 1.2;  // Lowered from 1.8 for testing
        this.vocalThresholdMultiplier = 1.1;  // Even lower for more frequent vocal triggers
        
        // Effect states
        this.bassEffectActive = false;
        this.vocalEffectActive = false;
        
        // Transient detection
        this.transientHoldTime = 0;
        this.vocalGlowBoost = 0;
        
        // Callbacks
        this.onComplete = null;
        this.onProgress = null;
        
        // Morph queue
        this.queuedMorph = null;
        
        // Initialize with circle shape
        this.currentPoints = this.getShapePoints('circle');
        this.shapesLoaded = true; // Static definitions are always loaded
        
        // Pre-warm the shape cache to prevent first-run choppiness
        this.prewarmCache();
    }
    
    /**
     * Pre-warm the shape cache to prevent first-run lag
     */
    prewarmCache() {
        // Pre-generate all common shapes
        const commonShapes = [
            'circle', 'heart', 'star', 'sun', 'moon', 
            'lunar', 'square', 'triangle'
        ];
        
        
        commonShapes.forEach(shape => {
            if (shapeCache && shapeCache.isInitialized ? shapeCache.hasShape(shape) : SHAPE_DEFINITIONS[shape]) {
                // Generate and cache the points
                this.getShapePoints(shape);
            }
        });
        
        // Also pre-calculate some common easing values
        const testProgress = [0, 0.25, 0.5, 0.75, 1];
        testProgress.forEach(t => {
            this.applyEasing(t); // Warm up easing calculations
        });
    }
    
    /**
     * Get shape points from cache or generate
     */
    getShapePoints(shapeName) {
        if (!this.shapeCache.has(shapeName)) {
            const shapeDef = shapeCache && shapeCache.isInitialized ? 
                shapeCache.getShape(shapeName) : SHAPE_DEFINITIONS[shapeName];
            if (!shapeDef || !shapeDef.points) {
                const circlePoints = SHAPE_DEFINITIONS.circle.points;
                this.shapeCache.set(shapeName, circlePoints);
                return circlePoints;
            }
            // Store reference directly - shapes are immutable
            const {points} = shapeDef;
            this.shapeCache.set(shapeName, points);
            return points;
        }
        return this.shapeCache.get(shapeName);
    }
    
    /**
     * Start morphing to a new shape
     * @param {string} targetShape - Target shape name
     * @param {Object} options - Morph options
     */
    morphTo(targetShape, options = {}) {
        if (!this.shapesLoaded) {
            return;
        }
        
        if (targetShape === this.currentShape && !this.isTransitioning) {
            return; // Already at target shape
        }
        
        // Handle queueing or forcing
        if (this.isTransitioning && !options.force) {
            // Queue this morph for after current one completes
            this.queuedMorph = { targetShape, options };
            return 'queued'; // Return status so caller knows it was queued
        } else if (this.isTransitioning && options.force) {
            // Force interrupt current morph
            this.completeMorph(true); // Skip to end without processing queue
        }
        
        // Get transition configuration
        const transitionConfig = this.getTransitionConfig(this.currentShape, targetShape);
        
        // Set up transition
        this.targetShape = targetShape;
        this.targetPoints = this.getShapePoints(targetShape);
        this.morphStartTime = Date.now();
        this.isTransitioning = true;
        this.morphProgress = 0;
        this.visualProgress = 0; // Reset visual progress

        
        // Configure timing - use transition config duration if available
        if (options.duration === 'bar' || options.duration === 'beat') {
            // Musical timing - calculate duration based on current BPM
            const bpm = rhythmEngine.bpm || 120;
            const beatDuration = 60000 / bpm; // ms per beat
            
            if (options.duration === 'bar') {
                // Assume 4/4 time signature
                this.morphDuration = beatDuration * 4; // 4 beats per bar
            } else {
                this.morphDuration = beatDuration; // 1 beat
            }
            
            this.musicalDuration = true; // Flag for musical timing
            this.onBeat = options.onBeat !== false; // Default true for musical timing
        } else {
            // Fixed duration - prefer transition config duration
            this.morphDuration = transitionConfig?.duration || options.duration || 1000;
            this.musicalDuration = null;
            this.onBeat = false;
        }
        
        // Store options
        this.morphMode = options.mode || 'smooth';
        this.transitionConfig = transitionConfig;
        
        // Callbacks
        this.onComplete = options.onComplete;
        this.onProgress = options.onProgress;
        
    }
    
    /**
     * Update morph animation
     * @param {number} deltaTime - Time since last update (can be from RAF timestamp)
     */
    update(deltaTime) {
        // Always update frequency data from audio analyzer if available
        if (this.audioAnalyzer && this.audioAnalyzer.isAnalyzing) {
            const audioData = this.audioAnalyzer.getShapeMorpherData();
            if (audioData && audioData.frequencies) {
                // Copy frequency data for visualization
                let hasNonZero = false;
                for (let i = 0; i < Math.min(audioData.frequencies.length, this.frequencyData.length); i++) {
                    this.frequencyData[i] = audioData.frequencies[i];
                    if (audioData.frequencies[i] > 0) hasNonZero = true;
                }
                // Log once if we start getting data
                if (hasNonZero && !this._loggedAudioData) {
                    console.warn('ShapeMorpher: Receiving audio frequency data');
                    this._loggedAudioData = true;
                }
            }
        }

        // Update music detector BPM calculation
        if (this.musicDetector) {
            this.musicDetector.update(performance.now());
        }

        // Return early if not transitioning
        if (!this.isTransitioning || !this.targetShape) return;
        
        // Calculate progress based on total elapsed time
        const currentTime = Date.now();
        const elapsed = currentTime - this.morphStartTime;
        
        // Recalculate duration if BPM changed during morph (for rhythm sync)
        if (this.musicalDuration) {
            const currentBpm = rhythmEngine.bpm || 120;
            const beatDuration = 60000 / currentBpm;
            // Recalculate based on original intention (bar or beat)
            const originalDuration = this.morphDuration;
            const wasBar = originalDuration > beatDuration * 2; // Heuristic: if > 2 beats, it was a bar
            this.morphDuration = wasBar ? beatDuration * 4 : beatDuration;
        }
        
        let progress = Math.min(elapsed / this.morphDuration, 1);
        
        // Apply musical quantization if needed
        if (this.musicalDuration && this.onBeat) {
            const bpm = rhythmEngine.bpm || 120;
            
            // Adaptive granularity - use coarser quantization at higher BPMs
            let subdivision;
            if (bpm > 140) {
                subdivision = 2; // 8th notes for fast tempos
            } else if (bpm > 100) {
                subdivision = 4; // 16th notes for medium tempos  
            } else {
                subdivision = 8; // 32nd notes for slow tempos
            }
            
            // Quantize to nearest subdivision
            const beatDuration = 60000 / bpm;
            const totalBeats = this.morphDuration / beatDuration;
            const currentBeat = progress * totalBeats;
            const quantizedBeat = Math.round(currentBeat * subdivision) / subdivision;
            const quantizedProgress = Math.min(1, quantizedBeat / totalBeats);
            
            // BPM-based strength - weaker quantization at extremes (very slow or very fast)
            const bpmFactor = bpm < 90 ? 
                Math.max(0.3, (bpm - 60) / 30) :  // 0.3 at 60bpm, 1.0 at 90bpm (weaker for slow)
                Math.max(0.4, Math.min(1, 1 - ((bpm - 90) / 90))); // 1.0 at 90bpm, 0.4 at 180bpm (weaker for fast)
            const baseStrength = 0.3 + (bpmFactor * 0.5); // Range: 0.3 to 0.8 based on BPM
            
            // Phase-aware quantization - weaker at start/end, stronger in middle
            const phaseMultiplier = Math.sin(progress * Math.PI); // 0 at edges, 1 at center
            const quantizationStrength = baseStrength * (0.3 + phaseMultiplier * 0.7); // Further modulated by phase
            
            // Apply smoothed quantization with cubic interpolation (smoothstep)
            const t = quantizationStrength;
            const cubicT = t * t * (3 - 2 * t); // Smoothstep for S-curve blending
            progress = progress + (quantizedProgress - progress) * cubicT;
        }
        
        // Apply easing
        this.morphProgress = this.applyEasing(progress);

        // Smooth visual progress for ultra-smooth rendering
        // Heavy smoothing: 80% of previous frame, 20% of new
        this.visualProgress = this.visualProgress * 0.8 + this.morphProgress * 0.2;

        // Snap to final value when very close to avoid infinite approach
        if (Math.abs(this.visualProgress - this.morphProgress) < 0.001) {
            this.visualProgress = this.morphProgress;
        }
        
        // Notify progress
        if (this.onProgress) {
            this.onProgress(this.morphProgress);
        }
        
        // Check if complete (use logical progress, not visual)
        if (this.morphProgress >= 1) {
            this.visualProgress = 1; // Ensure visual completes too
            this.completeMorph();
        }
    }
    
    /**
     * Complete the morph transition
     * @param {boolean} skipQueue - Skip processing queued morphs (for force override)
     */
    completeMorph(skipQueue = false) {
        // Only update current shape if we actually have a target
        if (this.targetShape) {
            this.currentShape = this.targetShape;
            this.currentPoints = [...this.targetPoints];
        }
        this.targetShape = null;
        this.isTransitioning = false;
        this.morphProgress = 0;
        this.visualProgress = 0; // Reset visual progress
        
        if (this.onComplete) {
            this.onComplete(this.currentShape);
        }
        
        // Process queued morph if exists and not skipping
        if (!skipQueue && this.queuedMorph) {
            const queued = this.queuedMorph;
            this.queuedMorph = null; // Clear queue before morphing
            
            // Small delay to ensure smooth transition
            setTimeout(() => {
                this.morphTo(queued.targetShape, queued.options);
            }, 50);
        }
    }
    
    /**
     * Check if there's a queued morph
     * @returns {boolean} True if morph is queued
     */
    hasQueuedMorph() {
        return this.queuedMorph !== null;
    }
    
    /**
     * Clear the morph queue
     */
    clearQueue() {
        this.queuedMorph = null;
    }
    
    /**
     * Get shape points in canvas coordinates
     * @param {number} centerX - Center X coordinate
     * @param {number} centerY - Center Y coordinate  
     * @param {number} radius - Shape radius
     * @returns {Array} Points in canvas coordinates
     */
    getCanvasPoints(centerX, centerY, radius) {
        let normalizedPoints;
        
        try {
            normalizedPoints = this.getInterpolatedPoints();
        } catch (e) {
            normalizedPoints = this.generateFallbackCircle();
        }
        
        // Reuse canvas points array
        if (!this.canvasPointsCache) {
            this.canvasPointsCache = [];
        }
        const canvasPoints = this.canvasPointsCache;
        canvasPoints.length = 0; // Clear without allocating new array
        
        // Handle case where points aren't loaded yet
        if (!normalizedPoints || normalizedPoints.length === 0) {
            // Return fallback circle points
            for (let i = 0; i < this.numPoints; i++) {
                const angle = (i / this.numPoints) * Math.PI * 2;
                canvasPoints.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            }
            return canvasPoints;
        }
        
        // Ensure we're working with an array
        const pointsArray = Array.isArray(normalizedPoints) ? normalizedPoints : [];
        
        for (let i = 0; i < pointsArray.length; i++) {
            const point = pointsArray[i];
            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {
                // Add fallback point
                const angle = (i / pointsArray.length) * Math.PI * 2;
                canvasPoints.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            } else {
                // Convert normalized (0-1) to canvas coordinates
                const x = centerX + (point.x - 0.5) * radius * 2;
                const y = centerY + (point.y - 0.5) * radius * 2;
                canvasPoints.push({ x, y });
            }
        }
        
        // Ensure we have enough points
        while (canvasPoints.length < this.numPoints) {
            const i = canvasPoints.length;
            const angle = (i / this.numPoints) * Math.PI * 2;
            canvasPoints.push({
                x: centerX + Math.cos(angle) * radius,
                y: centerY + Math.sin(angle) * radius
            });
        }
        
        return canvasPoints;
    }
    
    /**
     * Get interpolated shape points
     * @returns {Array} Current interpolated points
     */
    getInterpolatedPoints() {
        // Ensure we always have points
        if (!this.currentPoints || this.currentPoints.length === 0) {
            this.currentPoints = this.generateFallbackCircle();
        }
        
        if (!this.isTransitioning) {
            return this.applyAudioDeformation(this.currentPoints);
        }
        
        const points = [];
        for (let i = 0; i < this.numPoints; i++) {
            const current = this.currentPoints[i];
            const target = this.targetPoints[i];
            
            // Handle missing points
            if (!current || !target) {
                const angle = (i / this.numPoints) * Math.PI * 2;
                points.push({
                    x: 0.5 + Math.cos(angle) * 0.5,
                    y: 0.5 + Math.sin(angle) * 0.5
                });
                continue;
            }
            
            // Interpolate based on mode - use visualProgress for smooth rendering
            const progress = this.visualProgress;
            let x, y;
            
            // RADIAL MORPH: These shapes radiate from/to center
            const radialShapes = ['square', 'circle', 'star', 'triangle'];
            const currentIsRadial = radialShapes.includes(this.currentShape);
            const targetIsRadial = radialShapes.includes(this.targetShape);
            const needsRadialMorph = currentIsRadial || targetIsRadial;
            
            if (needsRadialMorph) {
                // RADIATE FROM/TO CENTER
                const cx = 0.5, cy = 0.5;
                
                // Calculate radial interpolation
                if (targetIsRadial && !currentIsRadial) {
                    // Morphing TO a radial shape - expand from center
                    // Start at center, expand to target position
                    const targetDx = target.x - cx;
                    const targetDy = target.y - cy;
                    
                    // Ease the expansion with a smooth curve
                    this.applyEasing(progress);
                    
                    // Start from center point for first half, then expand outward
                    if (progress < 0.3) {
                        // Gather at center
                        const gatherProgress = progress / 0.3;
                        x = current.x + (cx - current.x) * gatherProgress;
                        y = current.y + (cy - current.y) * gatherProgress;
                    } else {
                        // Expand from center to target
                        const expandPhase = (progress - 0.3) / 0.7;
                        x = cx + targetDx * expandPhase;
                        y = cy + targetDy * expandPhase;
                    }
                } else if (currentIsRadial && !targetIsRadial) {
                    // Morphing FROM a radial shape - collapse to center then expand to target
                    const currentDx = current.x - cx;
                    const currentDy = current.y - cy;
                    
                    if (progress < 0.5) {
                        // Collapse to center
                        const collapseProgress = progress / 0.5;
                        x = current.x - currentDx * collapseProgress;
                        y = current.y - currentDy * collapseProgress;
                    } else {
                        // Expand from center to target
                        const expandProgress = (progress - 0.5) / 0.5;
                        x = cx + (target.x - cx) * expandProgress;
                        y = cy + (target.y - cy) * expandProgress;
                    }
                } else {
                    // Both are radial shapes - morph through center
                    const currentDx = current.x - cx;
                    const currentDy = current.y - cy;
                    const targetDx = target.x - cx;
                    const targetDy = target.y - cy;
                    
                    if (progress < 0.5) {
                        // Collapse current shape to center
                        const collapseProgress = progress / 0.5;
                        x = current.x - currentDx * collapseProgress;
                        y = current.y - currentDy * collapseProgress;
                    } else {
                        // Expand from center to target shape
                        const expandProgress = (progress - 0.5) / 0.5;
                        x = cx + targetDx * expandProgress;
                        y = cy + targetDy * expandProgress;
                    }
                }
            } else if (this.morphMode === 'spiral') {
                // Spiral interpolation
                const angle = progress * Math.PI * 2;
                const spiral = Math.sin(angle + i * 0.2) * 0.02 * (1 - Math.abs(progress - 0.5) * 2);
                x = current.x + (target.x - current.x) * progress + spiral;
                y = current.y + (target.y - current.y) * progress + spiral;
            } else if (this.morphMode === 'wave') {
                // Wave interpolation
                const wave = Math.sin(i * 0.3 + progress * Math.PI * 4) * 0.01;
                x = current.x + (target.x - current.x) * progress + wave;
                y = current.y + (target.y - current.y) * progress + wave;
            } else {
                // Smooth interpolation
                x = current.x + (target.x - current.x) * progress;
                y = current.y + (target.y - current.y) * progress;
            }
            
            points.push({ x, y });
        }
        
        return this.applyAudioDeformation(points);
    }
    
    /**
     * Apply audio-reactive deformation to points
     */
    applyAudioDeformation(points) {
        // Delegate to AudioDeformer module
        return this.audioDeformer.applyAudioDeformation(points);
    }
    
    /**
     * Set audio deformation from analyzer with throttling
     * @param {number} value - Deformation value (-1 to 1)
     */
    setAudioDeformation(value) {
        const now = Date.now();
        if (now - this.lastAudioUpdate > this.audioUpdateInterval) {
            this.audioDeformation = Math.max(-1, Math.min(1, value));
            this.lastAudioUpdate = now;
            // CRITICAL: Also update the AudioDeformer module!
            if (this.audioDeformer) {
                this.audioDeformer.setAudioDeformation(Math.abs(this.audioDeformation)); // Pass absolute value
            }
        }
    }
    
    /**
     * Set vocal energy from analyzer with throttling
     * @param {number} value - Energy value (0 to 1)
     */
    setVocalEnergy(value) {
        const now = Date.now();
        if (now - this.lastVocalUpdate > this.audioUpdateInterval) {
            this.vocalEnergy = Math.max(0, Math.min(1, value));
            this.lastVocalUpdate = now;
            // Also update the AudioDeformer module
            if (this.audioDeformer) {
                this.audioDeformer.setVocalEnergy(this.vocalEnergy);
            }
        }
    }
    
    /**
     * Get transition configuration
     */
    getTransitionConfig(from, to) {
        const fromShape = shapeCache && shapeCache.isInitialized ? 
            shapeCache.getShape(from) : SHAPE_DEFINITIONS[from];
        const toShape = shapeCache && shapeCache.isInitialized ? 
            shapeCache.getShape(to) : SHAPE_DEFINITIONS[to];
        
        // Special transitions for moon - add a dreamy quality
        if (to === 'moon') {
            return {
                type: 'to_moon',
                easing: 'easeInOutCubic',  // Smooth acceleration/deceleration
                duration: 1500,  // Slightly longer for dramatic effect
                glowIntensity: 1.5,  // Extra glow during transition
                fadeInCrescent: true  // Fade in the crescent shadow
            };
        }
        
        
        // Moon to lunar - special eclipse transition
        if (from === 'moon' && to === 'lunar') {
            return {
                type: 'moon_to_lunar',
                easing: 'easeInOutSine',
                duration: 2000,  // Slower for dramatic effect
                slideOutCrescent: false, // Don't use standard slide
                description: 'Crescent shadow moves to center and becomes lunar eclipse'
            };
        }
        
        // All other moon transitions - shadow slides away first
        if (from === 'moon') {
            return {
                type: 'from_moon', 
                easing: 'easeInOutCubic',
                duration: 1000,
                slideOutCrescent: true,  // Shadow ALWAYS slides away
                shadowSlideRatio: 0.4,   // First 40% for shadow slide
                description: 'Moon shadow slides away THEN morphs to target'
            };
        }
        
        
        // Other shapes to lunar - morph to circle first, then eclipse comes in
        if (to === 'lunar') {
            return {
                type: 'eclipse_enter_lunar',
                startAngle: -30  // Eclipse enters from top-left like moon crescent
            };
        }
        
        // Lunar to moon - special case: shadow exits to crescent position and stays
        if (from === 'lunar' && to === 'moon') {
            return {
                type: 'lunar_to_moon',
                exitAngle: -30
            };
        }
        
        // Lunar to other shapes - eclipse exits first, then morph to target shape
        if (from === 'lunar') {
            return {
                type: 'eclipse_exit_lunar',
                exitAngle: -30  // Eclipse exits at same angle
            };
        }
        
        // Special eclipse transitions for other shapes
        if (fromShape?.shadow?.type === 'none' && toShape?.shadow?.type === 'solar') {
            return {
                type: 'eclipse_enter',
                direction: 'right'
            };
        }
        
        if (fromShape?.shadow?.type === 'solar' && toShape?.shadow?.type === 'none') {
            return {
                type: 'eclipse_exit',
                direction: 'left'
            };
        }
        
        // Sun transitions need effect fading/blooming
        if (from === 'sun' && to !== 'sun') {
            return {
                type: 'sun_fade',
                fadeEffects: true
            };
        }
        
        if (from !== 'sun' && to === 'sun') {
            return {
                type: 'sun_bloom',
                bloomEffects: true
            };
        }
        
        return {
            type: 'standard'
        };
    }
    
    /**
     * Get current shadow configuration
     * @returns {Object} Shadow configuration
     */
    getCurrentShadow() {
        // Default to circle if currentShape is somehow null/undefined
        const shapeName = this.currentShape || 'circle';
        const currentDef = shapeCache && shapeCache.isInitialized ? 
            shapeCache.getShape(shapeName) : SHAPE_DEFINITIONS[shapeName];
        const targetDef = this.targetShape ? (shapeCache && shapeCache.isInitialized ? 
            shapeCache.getShape(this.targetShape) : SHAPE_DEFINITIONS[this.targetShape]) : null;
        
        const currentShadow = currentDef?.shadow || { type: 'none' };
        const targetShadow = targetDef?.shadow || null;
        
        
        // If not transitioning, return current shadow
        if (!this.isTransitioning || !targetShadow) {
            return currentShadow;
        }
        
        // Handle eclipse progressions and other special transitions
        const easedProgress = this.morphProgress;
        
        
        // FROM MOON - ALWAYS slide shadow away first (other shapes)
        if (this.transitionConfig && this.transitionConfig.type === 'from_moon' && this.transitionConfig.slideOutCrescent) {
            const slideRatio = this.transitionConfig.shadowSlideRatio || 0.4;
            
            // PHASE 1: Shadow slides away
            if (easedProgress < slideRatio) {
                const slideProgress = easedProgress / slideRatio; // 0 to 1 during slide
                const angle = -30 * Math.PI / 180; // Moon shadow angle (bottom-left)
                
                // Shadow continues sliding in its direction (away to bottom-left)
                const startOffset = 0.7;  // Where moon shadow normally sits
                const endOffset = 2.5;    // Far off screen
                const currentOffset = startOffset + (endOffset - startOffset) * slideProgress;
                
                const offsetX = Math.cos(angle) * currentOffset;
                const offsetY = Math.sin(angle) * currentOffset;
                
                // Keep full opacity while sliding, slight fade at the end
                const coverage = slideProgress > 0.8 ? 0.85 * (1 - (slideProgress - 0.8) * 5) : 0.85;
                
                return {
                    type: 'crescent',
                    coverage,
                    angle: -30,
                    offset: currentOffset,
                    shadowX: offsetX,
                    shadowY: offsetY
                };
            }
            
            // PHASE 2: No shadow, morph can proceed
            return { type: 'none' };
        }
        
        // Moon to lunar - smooth crescent to eclipse transition
        if (this.transitionConfig && this.transitionConfig.type === 'moon_to_lunar') {
            const angle = this.transitionConfig.startAngle * Math.PI / 180;
            const offsetProgress = 1 - easedProgress; // Goes from 1 to 0 (crescent position to center)
            const offsetX = Math.cos(angle) * 0.7 * offsetProgress;
            const offsetY = Math.sin(angle) * 0.7 * offsetProgress;
            
            // Smooth transition from crescent to lunar
            const lunarBlend = Math.pow(easedProgress, 2); // Quadratic for smooth blend
            
            // Gradually change from crescent to lunar shadow
            if (easedProgress < 0.6) {
                // Still mostly crescent, moving to center
                return {
                    type: 'crescent',
                    coverage: 0.85 * (1 - lunarBlend * 0.2), // Slight fade
                    angle: this.transitionConfig.startAngle,
                    offset: 0.7 * offsetProgress,
                    shadowX: offsetX,
                    shadowY: offsetY
                };
            } else {
                // Smooth blend to lunar shadow
                const blendPhase = (easedProgress - 0.6) / 0.4; // 0 to 1 for last 40%
                const smoothBlend = Math.sin(blendPhase * Math.PI / 2); // Smooth S-curve
                
                return {
                    type: 'lunar',
                    coverage: 0.85 + 0.1 * smoothBlend, // Gradually increase to 0.95
                    color: `rgba(80, 20, 0, ${0.7 + 0.2 * smoothBlend})`, // Fade in red
                    shadowX: offsetX * (1 - smoothBlend), // Smooth center
                    shadowY: offsetY * (1 - smoothBlend),
                    diffusion: smoothBlend,
                    shadowProgress: easedProgress
                };
            }
        }
        
        // Eclipse entering lunar - smooth shadow entry
        if (this.transitionConfig && this.transitionConfig.type === 'eclipse_enter_lunar') {
            // First 30%: Just morph shape, no shadow (reduced from 40%)
            if (easedProgress < 0.3) {
                return { type: 'none' };
            }
            
            // Last 70%: Shadow smoothly enters and transforms
            const shadowProgress = (easedProgress - 0.3) / 0.7; // 0 to 1 for shadow animation
            const smoothProgress = Math.sin(shadowProgress * Math.PI / 2); // Smooth ease-in
            const angle = this.transitionConfig.startAngle * Math.PI / 180;
            const offsetProgress = 1 - smoothProgress; // Goes from 1 to 0
            const offsetX = Math.cos(angle) * 0.7 * offsetProgress;
            const offsetY = Math.sin(angle) * 0.7 * offsetProgress;
            
            // Smooth transition throughout
            if (shadowProgress < 0.7) {
                // Crescent shadow sliding in with gradual fade
                const fadeIn = Math.pow(shadowProgress / 0.7, 0.5); // Smooth fade in
                return {
                    type: 'crescent',
                    coverage: 0.85 * fadeIn,
                    angle: this.transitionConfig.startAngle,
                    offset: 0.7 * offsetProgress,
                    shadowX: offsetX,
                    shadowY: offsetY
                };
            } else {
                // Smooth blend to lunar
                const blendProgress = (shadowProgress - 0.7) / 0.3; // Last 30% for blend
                const smoothBlend = Math.sin(blendProgress * Math.PI / 2); // Smooth curve
                
                return {
                    type: 'lunar',
                    coverage: 0.85 + 0.1 * smoothBlend,
                    color: `rgba(80, 20, 0, ${0.6 + 0.3 * smoothBlend})`,
                    shadowX: offsetX * (1 - smoothBlend),
                    shadowY: offsetY * (1 - smoothBlend),
                    diffusion: smoothBlend,
                    shadowProgress
                };
            }
        }
        
        // Lunar to moon - smooth shadow transformation and movement
        if (this.transitionConfig && this.transitionConfig.type === 'lunar_to_moon') {
            const angle = this.transitionConfig.exitAngle * Math.PI / 180;
            
            // Smooth movement curve
            const movementCurve = Math.sin(easedProgress * Math.PI / 2); // Smooth ease-out
            const offsetX = Math.cos(angle) * 0.7 * movementCurve;
            const offsetY = Math.sin(angle) * 0.7 * movementCurve;
            
            // Smooth blend between lunar and crescent
            if (easedProgress < 0.6) {
                // Lunar shadow gradually transforming
                const transformPhase = easedProgress / 0.6;
                const smoothTransform = Math.pow(transformPhase, 0.7);
                
                return {
                    type: 'lunar',
                    coverage: 0.95 - (0.1 * smoothTransform),
                    color: `rgba(80, 20, 0, ${0.9 - 0.3 * smoothTransform})`,
                    shadowX: offsetX * 0.7, // Start moving earlier
                    shadowY: offsetY * 0.7,
                    diffusion: 1 - smoothTransform
                };
            } else {
                // Smooth transition to crescent
                const crescentPhase = (easedProgress - 0.6) / 0.4;
                const fadeIn = Math.sin(crescentPhase * Math.PI / 2);
                
                return {
                    type: 'crescent',
                    coverage: 0.85 * fadeIn + 0.1, // Smooth fade in
                    angle: this.transitionConfig.exitAngle,
                    offset: 0.7,
                    shadowX: offsetX,
                    shadowY: offsetY
                };
            }
        }
        
        // Eclipse exiting lunar - smooth shadow exit
        if (this.transitionConfig && this.transitionConfig.type === 'eclipse_exit_lunar') {
            // First 70%: Shadow smoothly exits
            if (easedProgress < 0.7) {
                const shadowProgress = easedProgress / 0.7; // 0 to 1 for shadow exit
                const angle = this.transitionConfig.exitAngle * Math.PI / 180;
                
                // Gradual transformation and movement
                if (shadowProgress < 0.4) {
                    // Lunar shadow gradually transforming
                    const transformPhase = shadowProgress / 0.4;
                    const diffusion = 1 - transformPhase;
                    const moveStart = transformPhase * 0.3; // Start moving early
                    
                    return {
                        type: 'lunar',
                        coverage: 0.95 - (0.1 * transformPhase),
                        color: `rgba(80, 20, 0, ${0.9 - 0.2 * transformPhase})`,
                        shadowX: Math.cos(angle) * 0.7 * moveStart,
                        shadowY: Math.sin(angle) * 0.7 * moveStart,
                        diffusion
                    };
                } else {
                    // Smooth exit as crescent
                    const exitPhase = (shadowProgress - 0.4) / 0.6;
                    const smoothMove = Math.pow(exitPhase, 0.8);
                    const offsetX = Math.cos(angle) * 0.7 * smoothMove;
                    const offsetY = Math.sin(angle) * 0.7 * smoothMove;
                    const fadeOut = 1 - Math.pow(exitPhase, 2); // Gradual fade
                    
                    return {
                        type: 'crescent',
                        coverage: 0.85 * fadeOut,
                        angle: this.transitionConfig.exitAngle,
                        offset: 0.7 * smoothMove,
                        shadowX: offsetX,
                        shadowY: offsetY
                    };
                }
            }
            
            // Last 30%: Just morph shape, no shadow
            return { type: 'none' };
        }
        
        // Solar eclipse transitions
        if (this.transitionConfig && this.transitionConfig.type === 'eclipse_enter') {
            const shadowX = 1.5 - (easedProgress * 1.5); // From right
            
            return {
                ...targetShadow,
                shadowX,
                shadowProgress: easedProgress
            };
        } else if (this.transitionConfig.type === 'eclipse_exit') {
            const shadowX = -easedProgress * 1.5; // To left
            
            return {
                ...currentShadow,
                coverage: currentShadow.coverage * (1 - easedProgress),
                shadowX,
                shadowProgress: 1 - easedProgress
            };
        } else if (this.transitionConfig.type === 'sun_fade') {
            // Smooth fading of sun effects
            const fadeMultiplier = 1 - easedProgress;
            
            // Gradual fade with different timing for each effect
            return {
                ...currentShadow,
                intensity: (currentShadow.intensity || 1) * Math.pow(fadeMultiplier, 0.7), // Slower fade
                corona: currentShadow.corona,
                coronaOpacity: fadeMultiplier, // Fade corona smoothly
                flares: currentShadow.flares,
                flaresOpacity: Math.pow(fadeMultiplier, 1.5), // Flares fade faster
                texture: currentShadow.texture,
                textureOpacity: Math.pow(fadeMultiplier, 2), // Texture fades fastest
                turbulence: (currentShadow.turbulence || 0.3) * fadeMultiplier
            };
        } else if (this.transitionConfig.type === 'sun_bloom') {
            // Smooth blooming of sun effects
            const bloomProgress = easedProgress;
            
            // Gradual bloom with different timing for each effect
            return {
                ...targetShadow,
                intensity: (targetShadow.intensity || 1) * Math.pow(bloomProgress, 1.5), // Start slow
                corona: targetShadow.corona,
                coronaOpacity: Math.pow(bloomProgress, 0.8), // Corona blooms gradually
                flares: targetShadow.flares,
                flaresOpacity: bloomProgress > 0.3 ? Math.pow((bloomProgress - 0.3) / 0.7, 0.7) : 0, // Flares appear later
                texture: targetShadow.texture,
                textureOpacity: bloomProgress > 0.5 ? Math.pow((bloomProgress - 0.5) / 0.5, 2) : 0, // Texture appears last
                turbulence: (targetShadow.turbulence || 0.3) * bloomProgress
            };
        }
        
        // Standard transition
        if (currentShadow.type !== 'none' || targetShadow.type !== 'none') {
            const coverage = (currentShadow.coverage || 0) + 
                           ((targetShadow.coverage || 0) - (currentShadow.coverage || 0)) * easedProgress;
            
            return {
                type: targetShadow.type !== 'none' ? targetShadow.type : currentShadow.type,
                coverage,
                angle: targetShadow.angle || currentShadow.angle || 0,
                softness: targetShadow.softness || currentShadow.softness || 0.2,
                progress: easedProgress
            };
        }
        
        return currentShadow;
    }
    
    /**
     * Get custom renderer for current shape
     * @returns {Function|null} Custom render function
     */
    getCurrentRenderer() {
        // For now, return null - rendering is handled by EmotiveRenderer
        // This can be extended later if we want shape-specific rendering
        return null;
    }
    
    /**
     * Apply easing function
     */
    applyEasing(t) {
        const easing = this.transitionConfig?.easing || this.easing || 'linear';
        switch (easing) {
        case 'linear':
            return t;
        case 'easeInQuad':
            return t * t;
        case 'easeOutQuad':
            return t * (2 - t);
        case 'easeInOutQuad':
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        case 'easeInOutSine':
            return -(Math.cos(Math.PI * t) - 1) / 2;
        case 'easeInOutCubic':
        default:
            return t < 0.5 
                ? 4 * t * t * t 
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
    }
    
    /**
     * Calculate BPM from onset intervals with improved stability
     */
    calculateBPM() {
        return this.musicDetector.calculateBPM();
    }
    
    /**
     * Find tempo candidates from onset intervals
     */
    findTempoCandidates(intervals) {
        return this.musicDetector.findTempoCandidates(intervals);
    }
    
    /**
     * Cluster similar intervals together
     */
    clusterIntervals(intervals) {
        return this.musicDetector.clusterIntervals(intervals);
    }
    
    /**
     * Check if BPM is a harmonic of the fundamental
     */
    checkHarmonicRelation(bpm1, bpm2) {
        return this.musicDetector.checkHarmonicRelation(bpm1, bpm2);
    }
    
    /**
     * Detect time signature from onset patterns - delegated to MusicDetector
     */
    detectTimeSignature() {
        // Set fast detection mode if needed
        this.musicDetector.forceFastDetection = this.forceFastDetection;
        
        // Delegate to MusicDetector
        const timeSignature = this.musicDetector.detectTimeSignature();
        
        // Update local references for compatibility
        this.detectedTimeSignature = this.musicDetector.detectedTimeSignature;
        this.timeSignatureConfidence = this.musicDetector.timeSignatureConfidence;
        this.timeSignatureLocked = this.musicDetector.timeSignatureLocked;
        
        return timeSignature;
    }
    
    /**
     * Test specifically for 3/4 waltz pattern - delegated to MusicDetector
     */
    testWaltzPattern(onsets, beatInterval) {
        return this.musicDetector.testWaltzPattern(onsets, beatInterval);
    }
    
    
    /**
     * Reset music detection when new audio is loaded
     */
    resetMusicDetection() {
        // Store if we should force fast detection (for resampling)
        this.forceFastDetection = true;
        
        // Reset music detector
        this.musicDetector.reset();
        
        // Set fast detection on the music detector
        this.musicDetector.forceFastDetection = true;
        
        // Reset local references
        this.onsetThreshold = 0;
        this.detectedBPM = 0;
        this.bpmConfidence = 0;
        
        // Reset time signature detection (still local for now)
        this.onsetStrengths = [];
        this.detectedTimeSignature = null;
        this.timeSignatureConfidence = 0;
        
        // Force immediate resampling on next update
        this.musicDetector.lastBPMCalculation = 0;
        this.measureStartTime = 0;
        this.timeSignatureHistory = [];
        this.timeSignatureLocked = false;
        
        // Reset spectral analysis
        this.spectralHistory = [];
        this.spectralFluxHistory = [];
        
        // Clear UI displays
        const timeSigDisplay = document.getElementById('time-sig-display');
        if (timeSigDisplay) {
            timeSigDisplay.textContent = '—';
        }
        
    }
    
    /**
     * Get current detected BPM and time signature
     */
    getCurrentMusicInfo() {
        return {
            bpm: this.detectedBPM,
            timeSignature: this.detectedTimeSignature,
            bpmLocked: this.tempoLocked,
            timeSigLocked: this.timeSignatureLocked
        };
    }
    
    /**
     * Fallback circle generation
     */
    generateFallbackCircle() {
        const points = [];
        for (let i = 0; i < this.numPoints; i++) {
            const angle = (i / this.numPoints) * Math.PI * 2;
            points.push({
                x: 0.5 + Math.cos(angle) * 0.5,
                y: 0.5 + Math.sin(angle) * 0.5
            });
        }
        return points;
    }
    
    /**
     * Get current state
     */
    getState() {
        return {
            currentShape: this.currentShape,
            targetShape: this.targetShape,
            isTransitioning: this.isTransitioning,
            progress: this.morphProgress,
            audioDeformation: this.audioDeformation,
            vocalEnergy: this.vocalEnergy
        };
    }
    
    /**
     * Get progress (0-1)
     * @param {boolean} visual - Return smoothed visual progress instead of logical
     */
    getProgress(visual = true) {
        // Default to visual progress for smooth rendering
        return visual ? this.visualProgress : this.morphProgress;
    }
    
    /**
     * Check if currently transitioning
     */
    isInTransition() {
        return this.isTransitioning;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE - Audio Analysis System
 *  └─○═╝                                                                             
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Real-time audio analysis for vocal visualization
 * @author Emotive Engine Team
 * @module core/AudioAnalyzer
 */

/**
 * AudioAnalyzer - Analyzes audio for vocal visualization
 */
class AudioAnalyzer {
    constructor() {
        this.audioContext = null;
        this.analyser = null;
        this.source = null;
        this.elementSource = null;  // Track audio element source separately
        this.dataArray = null;
        this.isAnalyzing = false;
        this.connectedElement = null;
        this.gainNode = null;  // Store gain node for cleanup
        
        // Frequency band configuration
        this.frequencyBands = 32;
        this.smoothingFactor = 0.3; // Lower smoothing for better responsiveness
        
        // Vocal detection
        this.vocalRange = { min: 80, max: 1000 }; // Hz - typical vocal range
        this.currentAmplitude = 0;
        this.currentFrequencies = new Array(this.frequencyBands).fill(0);
        
        // Beat detection (for rhythm sync)
        this.beatThreshold = 0.3;
        this.lastBeatTime = 0;
        this.beatCallbacks = [];
    }
    
    /**
     * Initialize audio context and analyzer (only after user interaction)
     */
    init() {
        try {
            // Only create AudioContext if we don't already have one
            if (!this.audioContext) {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // Resume context if it's suspended (common after user interaction)
            if (this.audioContext.state === 'suspended') {
                return this.audioContext.resume().then(() => {
                    this.createAnalyser();
                    return true;
                }).catch(() => false);
            } else {
                this.createAnalyser();
                return true;
            }
        } catch (error) {
            console.warn('AudioAnalyzer init failed:', error);
            return false;
        }
    }
    
    /**
     * Create analyser node and related components
     */
    createAnalyser() {
        if (!this.audioContext) return;
        
        if (!this.analyser) {
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048; // Good balance of frequency/time resolution
            this.analyser.smoothingTimeConstant = 0.5; // Moderate smoothing
            
            const bufferLength = this.analyser.frequencyBinCount;
            this.dataArray = new Uint8Array(bufferLength);
        }
    }
    
    /**
     * Connect audio element for analysis
     * @param {HTMLAudioElement} audioElement - Audio element to analyze
     */
    connectAudioElement(audioElement) {
        if (!this.audioContext) {
            return;
        }
        
        try {
            // Create source from audio element (only if not already created)
            if (!this.elementSource || this.connectedElement !== audioElement) {
                this.elementSource = this.audioContext.createMediaElementSource(audioElement);
                this.elementSource.connect(this.analyser);
                this.elementSource.connect(this.audioContext.destination); // Pass through audio
            }
            this.source = this.elementSource;  // Set current source
            this.connectedElement = audioElement;
            this.isAnalyzing = true;
            
            // Start analysis loop
            this.analyze();
        } catch (error) {
            // If already connected, just restart analysis
            if (error.message && error.message.includes('already been used')) {
                this.source = this.elementSource;  // Use existing source
                this.connectedElement = audioElement;
                this.isAnalyzing = true;
                this.analyze();
            }
        }
    }
    
    
    /**
     * Main analysis loop
     */
    analyze() {
        if (!this.isAnalyzing) return;
        
        requestAnimationFrame(() => this.analyze());
        
        // Get frequency data
        this.analyser.getByteFrequencyData(this.dataArray);
        
        // Also try time domain data to see if mic is working
        const timeData = new Uint8Array(this.analyser.frequencyBinCount);
        this.analyser.getByteTimeDomainData(timeData);
        
        // Calculate overall amplitude
        let sum = 0;
        let vocalSum = 0;
        let vocalCount = 0;
        
        // Frequency to bin conversion
        const nyquist = this.audioContext.sampleRate / 2;
        const binHz = nyquist / this.dataArray.length;
        const vocalMinBin = Math.floor(this.vocalRange.min / binHz);
        const vocalMaxBin = Math.ceil(this.vocalRange.max / binHz);
        
        // Process frequency data
        for (let i = 0; i < this.dataArray.length; i++) {
            const value = this.dataArray[i] / 255; // Normalize to 0-1
            sum += value;
            
            // Check if in vocal range
            if (i >= vocalMinBin && i <= vocalMaxBin) {
                vocalSum += value;
                vocalCount++;
            }
        }
        
        // Calculate amplitudes
        this.currentAmplitude = sum / this.dataArray.length;
        const vocalAmplitude = vocalCount > 0 ? vocalSum / vocalCount : 0;
        
        // Extract frequency bands for visualization
        this.extractFrequencyBands();
        
        // Detect beats
        this.detectBeat(this.currentAmplitude);
        
        // Return analysis data
        return {
            amplitude: this.currentAmplitude,
            vocalAmplitude,
            frequencies: this.currentFrequencies,
            rawData: this.dataArray
        };
    }
    
    /**
     * Extract frequency bands for shape deformation
     */
    extractFrequencyBands() {
        const bandsPerBin = Math.floor(this.dataArray.length / this.frequencyBands);
        
        for (let i = 0; i < this.frequencyBands; i++) {
            let sum = 0;
            const startBin = i * bandsPerBin;
            const endBin = Math.min(startBin + bandsPerBin, this.dataArray.length);
            
            for (let j = startBin; j < endBin; j++) {
                sum += this.dataArray[j] / 255; // Normalize
            }
            
            // Apply smoothing
            const newValue = sum / bandsPerBin;
            this.currentFrequencies[i] = this.currentFrequencies[i] * this.smoothingFactor + 
                                         newValue * (1 - this.smoothingFactor);
        }
    }
    
    /**
     * Simple beat detection
     */
    detectBeat(amplitude) {
        const now = performance.now();
        
        // Simple threshold-based beat detection
        // Allow faster beats - 273ms = 220 BPM, but go down to 60ms for very fast tapping
        if (amplitude > this.beatThreshold && now - this.lastBeatTime > 60) {
            this.lastBeatTime = now;
            
            // Trigger beat callbacks
            this.beatCallbacks.forEach(callback => callback(amplitude));
        }
    }
    
    /**
     * Get current vocal instability (0-1)
     */
    getVocalInstability() {
        // Calculate instability based on frequency variance
        let variance = 0;
        const mean = this.currentFrequencies.reduce((a, b) => a + b, 0) / this.frequencyBands;
        
        for (let i = 0; i < this.frequencyBands; i++) {
            variance += Math.pow(this.currentFrequencies[i] - mean, 2);
        }
        
        variance = Math.sqrt(variance / this.frequencyBands);
        
        // Combine with amplitude for overall instability
        const instability = Math.min(1, variance * 2 + this.currentAmplitude * 0.5);
        return instability;
    }
    
    /**
     * Get analysis data formatted for ShapeMorpher
     */
    getShapeMorpherData() {
        return {
            instability: this.getVocalInstability(),
            frequencies: [...this.currentFrequencies],
            amplitude: this.currentAmplitude
        };
    }
    
    /**
     * Add beat detection callback
     */
    onBeat(callback) {
        this.beatCallbacks.push(callback);
    }
    
    /**
     * Stop analysis
     */
    stop() {
        this.isAnalyzing = false;
        
        if (this.gainNode) {
            try {
                this.gainNode.disconnect();
            } catch (_e) {
                // Ignore disconnect errors
            }
            this.gainNode = null;
        }
        
        // Reconnect element source to analyser if it was disconnected
        if (this.elementSource && this.connectedElement) {
            try {
                this.elementSource.connect(this.analyser);
            } catch (_e) {
                // Already connected, that's fine
            }
            this.source = this.elementSource;
        }
    }
    
    /**
     * Resume audio context (needed after user interaction)
     */
    async resume() {
        if (this.audioContext && this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
        }
    }
    
    /**
     * Cleanup
     */
    destroy() {
        this.stop();
        
        if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
        }
        
        this.analyser = null;
        this.dataArray = null;
        this.beatCallbacks = [];
    }
}

var AudioAnalyzer$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AudioAnalyzer: AudioAnalyzer
});

/**
 * GestureCompatibility - Core gesture compatibility and chord system
 * Defines which gestures can execute simultaneously vs sequentially
 * Part of the Emotive Engine core
 */

class GestureCompatibility {
    constructor() {
        // Musical timing classes - defines when gestures should fire
        this.timingClasses = {
            downbeat: {
                gestures: ['bounce', 'jump', 'headBob', 'spin', 'orbit'],
                timing: 1.0,  // Fire on the beat
                priority: 1,
                description: 'Strong emphasis on the downbeat'
            },
            upbeat: {
                gestures: ['wave', 'nod', 'point', 'reach'],
                timing: 0.5,  // Fire on the half-beat
                priority: 2,
                description: 'Medium emphasis on upbeat'
            },
            offbeat: {
                gestures: ['wiggle', 'sway', 'lean', 'tilt', 'groove'],
                timing: 0.5,  // Fire between beats (syncopated)
                priority: 3,
                description: 'Syncopated, creates groove'
            },
            subdivision: {
                gestures: ['pulse', 'sparkle', 'flash', 'shimmer', 'flicker'],
                timing: 0.25,  // Can fire on quarter beats
                priority: 4,
                description: 'Quick accents and fills'
            },
            continuous: {
                gestures: ['breathe', 'float', 'rain'],
                timing: -1,  // Can start anytime, flows across beats
                priority: 5,
                description: 'Ambient, continuous motion'
            }
        };

        // Fill patterns for automatic motion between gestures
        this.fillPatterns = {
            subtle: ['breathe', 'float'],
            rhythmic: ['pulse', 'shimmer'],
            energetic: ['wiggle', 'sparkle'],
            smooth: ['sway', 'glow']
        };

        // Dynamic density settings based on BPM
        this.densityProfiles = {
            sparse: {
                fillProbability: 0.1,
                subdivisionLevel: 2,  // Half notes only
                description: 'Minimal movement'
            },
            moderate: {
                fillProbability: 0.3,
                subdivisionLevel: 4,  // Quarter notes
                description: 'Balanced movement'
            },
            dense: {
                fillProbability: 0.5,
                subdivisionLevel: 8,  // Eighth notes
                description: 'Busy, energetic'
            },
            chaos: {
                fillProbability: 0.8,
                subdivisionLevel: 16,  // Sixteenth notes
                description: 'Maximum energy'
            }
        };

        // Gesture group definitions
        this.groups = {
            // Primary movement - only one can execute at a time
            movement: {
                gestures: ['bounce', 'spin', 'orbit', 'sway', 'hula', 'jump', 'twist', 'groove'],
                maxSimultaneous: 1,
                priority: 1,
                description: 'Primary body movements - mutually exclusive'
            },

            // Secondary movements - can layer 2 together
            expression: {
                gestures: ['wave', 'nod', 'shake', 'point', 'lean', 'tilt', 'reach'],
                maxSimultaneous: 2,
                priority: 2,
                description: 'Expressive gestures - can combine up to 2'
            },

            // Dance moves - special category that can combine with effects
            dance: {
                gestures: ['headBob', 'wiggle', 'runningman', 'charleston'],
                maxSimultaneous: 1,
                priority: 2,
                description: 'Dance moves - one at a time but can add effects'
            },

            // Visual effects - all can stack
            effects: {
                gestures: ['pulse', 'glow', 'sparkle', 'flash', 'shimmer', 'flicker'],
                maxSimultaneous: -1, // Unlimited
                priority: 3,
                description: 'Visual effects - all can layer together'
            },

            // Ambient modifiers - always allowed to layer
            modifiers: {
                gestures: ['breathe', 'float', 'rain'],
                maxSimultaneous: -1, // Unlimited
                priority: 4,
                description: 'Ambient effects - always allowed'
            }
        };

        // Specific combinations that work well together
        this.enhancingCombinations = [
            ['bounce', 'sparkle'],
            ['spin', 'glow'],
            ['wave', 'pulse'],
            ['nod', 'pulse'],
            ['jump', 'flash'],
            ['sway', 'breathe'],
            ['float', 'shimmer'],
            ['orbit', 'sparkle'],
            ['headBob', 'pulse']
        ];

        // Gestures that should never combine
        this.incompatiblePairs = [
            ['bounce', 'jump'],
            ['spin', 'orbit'],
            ['wave', 'point'],
            ['nod', 'shake'],
            ['lean', 'tilt']
        ];

        // Pre-defined chord combinations
        this.chords = {
            celebrate: ['bounce', 'sparkle', 'pulse'],
            greeting: ['wave', 'nod', 'glow'],
            excited: ['jump', 'flash', 'wiggle'],
            mystical: ['float', 'shimmer', 'breathe'],
            party: ['headBob', 'pulse', 'sparkle'],
            smooth: ['sway', 'glow', 'breathe'],
            dramatic: ['spin', 'flash', 'sparkle']
        };

        // Chain definitions with simultaneous markers
        // '+' means simultaneous, '>' means sequential
        this.chains = {
            // Original chains renamed - USING REAL GESTURES ONLY
            rise: 'breathe > sway+lean+tilt',
            flow: 'sway > lean+tilt > spin > bounce',
            burst: 'jump > nod > shake > flash',
            drift: 'sway+breathe+float+drift',
            chaos: 'shake+shake > spin+flash > bounce+pulse > twist+sparkle',
            morph: 'expand > contract > morph+glow > expand+flash',
            
            // New chains - NO CONFLICTS WITH GESTURE NAMES
            rhythm: 'pulse > pulse+sparkle > pulse+flicker',
            spiral: 'spin > orbital > twist > orbital+sparkle',
            routine: 'nod > bounce > spin+sparkle > sway+pulse > nod+flash',
            radiance: 'sparkle > pulse+flicker > shimmer',
            twinkle: 'sparkle > flash > pulse+sparkle > shimmer+flicker',
            stream: 'wave > nod+pulse > sparkle > flash',
            
            // Legacy names for backward compatibility
            buildup: 'pulse > pulse > bounce+sparkle > spin+flash',
            cascade: 'wave > lean > tilt > spin > bounce+glow',
            celebrate: 'bounce+sparkle > spin > jump+flash > nod+pulse',
            smooth: 'sway+breathe > float > orbit+shimmer > sway+glow',
            custom: 'expand > contract > morph > expand+glow',
            greeting: 'wave+glow > nod+pulse > wave',
            mystical: 'float+shimmer > orbit+breathe > spin+sparkle > float+glow'
        };
    }

    /**
     * Check if two gestures can execute simultaneously
     * @param {string} gesture1 - First gesture name
     * @param {string} gesture2 - Second gesture name
     * @returns {boolean} - True if they can execute together
     */
    canExecuteSimultaneously(gesture1, gesture2) {
        // Check if they're the same gesture
        if (gesture1 === gesture2) return false;

        // Check if they're in incompatible list
        const incompatible = this.incompatiblePairs.some(pair =>
            (pair.includes(gesture1) && pair.includes(gesture2))
        );
        if (incompatible) return false;

        // Get groups for each gesture
        const group1 = this.getGestureGroup(gesture1);
        const group2 = this.getGestureGroup(gesture2);

        // If same group, check maxSimultaneous
        if (group1 === group2) {
            const group = this.groups[group1];
            return group && group.maxSimultaneous !== 1;
        }

        // Different groups can usually combine
        // Movement can't combine with other movement
        if (group1 === 'movement' && group2 === 'movement') return false;
        if (group1 === 'dance' && group2 === 'dance') return false;

        return true;
    }

    /**
     * Get the group a gesture belongs to
     * @param {string} gesture - Gesture name
     * @returns {string|null} - Group name or null
     */
    getGestureGroup(gesture) {
        for (const [groupName, group] of Object.entries(this.groups)) {
            if (group.gestures.includes(gesture)) {
                return groupName;
            }
        }
        return null;
    }

    /**
     * Get priority of a gesture
     * @param {string} gesture - Gesture name
     * @returns {number} - Priority value (lower = higher priority)
     */
    getGesturePriority(gesture) {
        const group = this.getGestureGroup(gesture);
        return group ? this.groups[group].priority : 99;
    }

    /**
     * Get compatible gestures from a list that can execute together
     * @param {Array} gestures - Array of gesture objects or names
     * @returns {Array} - Gestures that can execute simultaneously
     */
    getCompatibleGestures(gestures) {
        if (!gestures || gestures.length === 0) return [];
        if (gestures.length === 1) return gestures;

        const chord = [];
        const used = new Set();

        // Normalize to gesture names
        const normalizeGesture = g => typeof g === 'string' ? g : g.gestureName;

        // Sort by priority
        const sorted = [...gestures].sort((a, b) => {
            const priorityA = this.getGesturePriority(normalizeGesture(a));
            const priorityB = this.getGesturePriority(normalizeGesture(b));
            return priorityA - priorityB;
        });

        for (const gesture of sorted) {
            if (used.has(gesture)) continue;

            const gestureName = normalizeGesture(gesture);

            // Check if this gesture can combine with all in chord
            let canAdd = true;
            for (const chordItem of chord) {
                const chordGestureName = normalizeGesture(chordItem);
                if (!this.canExecuteSimultaneously(gestureName, chordGestureName)) {
                    canAdd = false;
                    break;
                }
            }

            if (canAdd) {
                // Check group limits
                const group = this.groups[this.getGestureGroup(gestureName)];
                if (group && group.maxSimultaneous > 0) {
                    const groupCount = chord.filter(c =>
                        this.getGestureGroup(normalizeGesture(c)) === this.getGestureGroup(gestureName)
                    ).length;
                    if (groupCount >= group.maxSimultaneous) {
                        continue; // Skip, group limit reached
                    }
                }

                chord.push(gesture);
                used.add(gesture);
            }
        }

        return chord;
    }

    /**
     * Parse a chain string into steps of simultaneous gestures
     * @param {string} chainString - Chain definition string
     * @returns {Array<Array<string>>} - Array of steps, each containing simultaneous gestures
     */
    parseChain(chainString) {
        if (!chainString) return [];

        // Handle predefined chains
        if (this.chains[chainString]) {
            chainString = this.chains[chainString];
        }

        const steps = chainString.split('>').map(s => s.trim());
        return steps.map(step => {
            // Split by + for simultaneous gestures
            return step.split('+').map(g => g.trim()).filter(g => g);
        });
    }

    /**
     * Check if gestures form an enhancing combination
     * @param {Array} gestures - Array of gesture names
     * @returns {boolean} - True if they enhance each other
     */
    isEnhancingCombination(gestures) {
        const gestureNames = gestures.map(g =>
            typeof g === 'string' ? g : g.gestureName
        );

        return this.enhancingCombinations.some(combo =>
            combo.every(gesture => gestureNames.includes(gesture))
        );
    }

    /**
     * Get a predefined chord by name
     * @param {string} chordName - Name of the chord
     * @returns {Array<string>|null} - Array of gesture names or null
     */
    getChord(chordName) {
        return this.chords[chordName] || null;
    }

    /**
     * Create a gesture chord command
     * @param {Array<string>} gestures - Gestures to combine
     * @returns {Object} - Chord command object
     */
    createChord(gestures) {
        const compatible = this.getCompatibleGestures(gestures);
        const isEnhancing = this.isEnhancingCombination(compatible);

        return {
            type: 'chord',
            gestures: compatible.map(g => typeof g === 'string' ? g : g.gestureName),
            isEnhancing,
            timestamp: Date.now()
        };
    }

    /**
     * Validate if a gesture exists in the system
     * @param {string} gesture - Gesture name
     * @returns {boolean} - True if gesture is valid
     */
    isValidGesture(gesture) {
        return this.getGestureGroup(gesture) !== null;
    }

    /**
     * Get all available gestures
     * @returns {Array<string>} - All gesture names
     */
    getAllGestures() {
        const gestures = [];
        for (const group of Object.values(this.groups)) {
            gestures.push(...group.gestures);
        }
        return [...new Set(gestures)];
    }

    /**
     * Get timing class for a gesture
     * @param {string} gesture - Gesture name
     * @returns {Object|null} - Timing class info
     */
    getGestureTiming(gesture) {
        for (const [className, timingClass] of Object.entries(this.timingClasses)) {
            if (timingClass.gestures.includes(gesture)) {
                return {
                    name: className,
                    ...timingClass
                };
            }
        }
        return null;
    }

    /**
     * Get next subdivision beat for a gesture
     * @param {string} gesture - Gesture name
     * @param {number} currentBeat - Current beat number
     * @param {number} subdivision - Beat subdivision (1, 0.5, 0.25, etc)
     * @returns {number} - Next beat to fire on
     */
    getNextBeatForGesture(gesture, currentBeat, subdivision = 1) {
        const timing = this.getGestureTiming(gesture);
        if (!timing) return currentBeat + 1;

        // Continuous gestures can start immediately
        if (timing.timing === -1) return currentBeat;

        // Calculate next appropriate beat based on timing class
        const beatInterval = timing.timing / subdivision;
        const nextBeat = Math.ceil(currentBeat / beatInterval) * beatInterval;

        // For offbeat gestures, add half beat offset
        if (timing.name === 'offbeat') {
            return nextBeat + 0.5;
        }

        return nextBeat;
    }

    /**
     * Get fill gestures based on density and BPM
     * @param {number} bpm - Current BPM
     * @param {string} intensity - Intensity level (sparse, moderate, dense, chaos)
     * @returns {Array<string>} - Suggested fill gestures
     */
    getFillGestures(bpm, intensity = 'moderate') {
        const profile = this.densityProfiles[intensity] || this.densityProfiles.moderate;

        // Determine fill pattern based on BPM
        let pattern;
        if (bpm < 80) {
            pattern = 'energetic';  // More movement for slow tempos
        } else if (bpm < 120) {
            pattern = 'rhythmic';
        } else if (bpm < 160) {
            pattern = 'smooth';
        } else {
            pattern = 'subtle';  // Less movement for fast tempos
        }

        // Return fills based on probability
        if (Math.random() < profile.fillProbability) {
            return this.fillPatterns[pattern] || [];
        }
        return [];
    }

    /**
     * Get next beat timing for a gesture (for rhythm game mode)
     * @param {string} gestureName - Name of the gesture
     * @param {number} currentBeat - Current beat number
     * @param {number} bpm - Current BPM
     * @returns {number} - Next beat to trigger on
     */
    getNextBeatTiming(gestureName, currentBeat, bpm) {
        // In rhythm game mode, this will be determined by the game logic
        // For now, just return the next appropriate beat based on gesture type
        const nextBeat = this.getNextBeatForGesture(gestureName, currentBeat);
        return nextBeat;
    }

    /**
     * Get intensity profile based on BPM
     * @param {number} bpm - Current BPM
     * @returns {string} - Intensity level
     */
    getIntensityFromBPM(bpm) {
        if (bpm < 60) return 'dense';      // Very slow needs more fills
        if (bpm < 100) return 'moderate';
        if (bpm < 140) return 'moderate';
        if (bpm < 180) return 'sparse';
        return 'sparse';  // Very fast needs less
    }

    /**
     * Create swing/shuffle timing
     * @param {number} straightBeat - Straight beat number
     * @param {number} swingRatio - Swing ratio (0.5 = straight, 0.67 = swing)
     * @returns {number} - Adjusted beat with swing
     */
    applySwingTiming(straightBeat, swingRatio = 0.67) {
        const beatPart = straightBeat % 1;
        if (beatPart === 0.5) {
            // Delay the offbeat for swing feel
            return Math.floor(straightBeat) + swingRatio;
        }
        return straightBeat;
    }
}

// Create singleton instance
const gestureCompatibility = new GestureCompatibility();

var GestureCompatibility$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    GestureCompatibility: GestureCompatibility,
    default: gestureCompatibility
});

/**
 * GrooveTemplates - Musical rhythm patterns and groove definitions
 * Provides pre-defined rhythmic patterns that make the mascot dance musically
 */

class GrooveTemplates {
    constructor() {
        // Core groove definitions with emphasis patterns
        this.templates = {
            straight: {
                name: 'Straight',
                timeSignature: '4/4',
                baseMovement: 'grooveBob', // Continuous base layer
                transitionStyle: 'transitionLean',
                pattern: {
                    emphasis: [1, 0, 0.5, 0], // Strong on 1, medium on 3
                    velocities: [1.0, 0, 0.6, 0],
                    subdivisions: [0, 0.5] // Only play on beats and offbeats
                },
                swing: 0,
                humanization: 0.05, // 5% timing variance for human feel
                preferredGestures: {
                    downbeat: ['bounce', 'headBob', 'jump'],
                    offbeat: ['pulse', 'breathe'],
                    fills: ['sparkle', 'glow']
                },
                compositeMove: null, // No special composite for straight
                intensity: 'moderate',
                description: 'Standard 4/4 rhythm, good for pop/rock'
            },

            swing: {
                name: 'Swing',
                timeSignature: '4/4',
                baseMovement: 'grooveFlow',
                transitionStyle: 'transitionGlide',
                compositeMove: 'swingOut',
                pattern: {
                    emphasis: [1, 0, 0.66, 0], // Swung eighth notes
                    velocities: [1.0, 0, 0.7, 0],
                    subdivisions: [0, 0.66] // Delayed upbeat for swing feel
                },
                swing: 0.67, // 67% swing ratio (2:1 triplet feel)
                humanization: 0.08,
                preferredGestures: {
                    downbeat: ['sway', 'lean', 'bounce'],
                    offbeat: ['wiggle', 'pulse'],
                    fills: ['shimmer', 'float']
                },
                intensity: 'moderate',
                description: 'Jazz swing feel with triplet subdivision'
            },

            shuffle: {
                name: 'Shuffle',
                timeSignature: '4/4',
                baseMovement: 'grooveBob',
                transitionStyle: 'transitionLean',
                compositeMove: null,
                pattern: {
                    emphasis: [1, 0.25, 0.5, 0.75], // Driving shuffle
                    velocities: [1.0, 0.3, 0.7, 0.3],
                    subdivisions: [0, 0.25, 0.5, 0.75]
                },
                swing: 0.75, // Heavy shuffle
                humanization: 0.06,
                preferredGestures: {
                    downbeat: ['bounce', 'headBob'],
                    upbeat: ['twist', 'wiggle'],
                    offbeat: ['pulse', 'breathe'],
                    fills: ['sparkle', 'flash']
                },
                intensity: 'dense',
                description: 'Blues/rock shuffle with heavy swing'
            },

            latin: {
                name: 'Latin',
                timeSignature: '4/4',
                baseMovement: 'grooveSway',
                transitionStyle: 'transitionRoll',
                compositeMove: 'latinHips',
                pattern: {
                    // Clave-inspired pattern: 1 e + a 2 e + a 3 e + a 4 e + a
                    emphasis: [1, 0, 0.375, 0.5, 0, 0.75, 0, 0],
                    velocities: [1.0, 0, 0.8, 0.9, 0, 0.8, 0, 0],
                    subdivisions: [0, 0.375, 0.5, 0.75] // Syncopated
                },
                swing: 0,
                humanization: 0.04,
                preferredGestures: {
                    downbeat: ['sway', 'wiggle'],
                    syncopation: ['twist', 'lean'],
                    offbeat: ['pulse', 'shimmer'],
                    fills: ['sparkle', 'shake']
                },
                intensity: 'dense',
                description: 'Latin clave rhythm with syncopation'
            },

            breakbeat: {
                name: 'Breakbeat',
                timeSignature: '4/4',
                baseMovement: 'grooveStep',
                transitionStyle: 'transitionGlide',
                compositeMove: null,
                pattern: {
                    // Classic Amen break pattern simplified
                    emphasis: [1, 0, 0, 0.75, 0.25, 0.5, 0, 0.625],
                    velocities: [1.0, 0, 0, 0.9, 0.6, 0.8, 0, 0.7],
                    subdivisions: [0, 0.25, 0.5, 0.625, 0.75] // Complex syncopation
                },
                swing: 0,
                humanization: 0.03, // Tighter timing for electronic feel
                preferredGestures: {
                    downbeat: ['bounce', 'twist'],
                    syncopation: ['flash', 'shake'],
                    offbeat: ['pulse', 'wiggle'],
                    fills: ['sparkle', 'glitch']
                },
                intensity: 'chaos',
                description: 'Hip-hop/DnB breakbeat pattern'
            },

            waltz: {
                name: 'Waltz',
                timeSignature: '3/4',
                baseMovement: 'grooveFlow',
                transitionStyle: 'transitionGlide',
                compositeMove: null,
                pattern: {
                    emphasis: [1, 0.33, 0.67], // 1-2-3, 1-2-3
                    velocities: [1.0, 0.5, 0.5],
                    subdivisions: [0, 0.33, 0.67]
                },
                swing: 0,
                humanization: 0.07,
                preferredGestures: {
                    downbeat: ['sway', 'float'],
                    weak: ['breathe', 'lean'],
                    fills: ['shimmer', 'glow']
                },
                intensity: 'sparse',
                description: '3/4 waltz time'
            },

            techno: {
                name: 'Techno',
                timeSignature: '4/4',
                baseMovement: 'groovePulse',
                transitionStyle: 'transitionLean',
                compositeMove: 'robotPop',
                pattern: {
                    // Four-on-the-floor with 16th note variations
                    emphasis: [1, 0.25, 0.5, 0.75, 1, 0.25, 0.5, 0.75],
                    velocities: [1.0, 0.6, 1.0, 0.6, 1.0, 0.6, 1.0, 0.6],
                    subdivisions: [0, 0.25, 0.5, 0.75] // All subdivisions
                },
                swing: 0,
                humanization: 0.02, // Very tight, machine-like
                preferredGestures: {
                    downbeat: ['pulse', 'bounce'],
                    subdivision: ['flash', 'glitch'],
                    fills: ['sparkle', 'strobe']
                },
                intensity: 'dense',
                description: 'Driving techno four-on-the-floor'
            },

            ambient: {
                name: 'Ambient',
                timeSignature: '4/4',
                baseMovement: 'groovePulse',
                transitionStyle: 'transitionGlide',
                compositeMove: null,
                pattern: {
                    emphasis: [0.8, 0, 0.3, 0, 0.5, 0, 0.3, 0],
                    velocities: [0.8, 0, 0.3, 0, 0.5, 0, 0.3, 0],
                    subdivisions: [0, 0.5] // Sparse
                },
                swing: 0,
                humanization: 0.15, // Very loose timing
                preferredGestures: {
                    downbeat: ['float', 'breathe'],
                    offbeat: ['sway', 'shimmer'],
                    fills: ['glow', 'pulse']
                },
                intensity: 'sparse',
                description: 'Floating ambient rhythm'
            },

            funk: {
                name: 'Funk',
                timeSignature: '4/4',
                baseMovement: 'grooveSway',
                transitionStyle: 'transitionRoll',
                compositeMove: 'funkChicken',
                pattern: {
                    // "One" emphasis with 16th note ghost notes
                    emphasis: [1.2, 0.125, 0.25, 0, 0.625, 0.75, 0, 0.875],
                    velocities: [1.2, 0.3, 0.4, 0, 0.8, 0.6, 0, 0.4],
                    subdivisions: [0, 0.125, 0.25, 0.625, 0.75, 0.875]
                },
                swing: 0.1, // Slight swing
                humanization: 0.06,
                preferredGestures: {
                    one: ['bounce', 'twist'], // THE ONE
                    ghost: ['wiggle', 'pulse'], // Ghost notes
                    syncopation: ['lean', 'shake'],
                    fills: ['flash', 'sparkle']
                },
                intensity: 'chaos',
                description: 'Funky syncopated rhythm with THE ONE'
            },

            trap: {
                name: 'Trap',
                timeSignature: '4/4',
                baseMovement: 'grooveStep',
                transitionStyle: 'transitionLean',
                compositeMove: null,
                pattern: {
                    // Hi-hat rolls and syncopated kicks
                    emphasis: [1, 0, 0, 0.375, 0, 0.75, 0.875, 0],
                    velocities: [1.0, 0, 0, 0.7, 0, 0.8, 0.6, 0],
                    subdivisions: [0, 0.375, 0.75, 0.875] // Triplet feel
                },
                swing: 0,
                humanization: 0.03,
                preferredGestures: {
                    downbeat: ['bounce', 'lean'],
                    hihat: ['shake', 'shimmer'],
                    syncopation: ['twist', 'flash'],
                    fills: ['sparkle', 'glitch']
                },
                intensity: 'moderate',
                description: 'Trap rhythm with triplet hi-hats'
            }
        };

        // Transition rules for smooth groove changes
        this.transitions = {
            instant: 0, // Change immediately
            nextBar: 1, // Change on next bar line
            nextPhrase: 4, // Change on next 4-bar phrase
            fadeIn: 8 // Gradually introduce over 8 beats
        };

        // Current active groove
        this.currentGroove = null;
        this.transitionMode = 'nextBar';
        this.pendingGroove = null;
    }

    /**
     * Get a groove template by name
     */
    getTemplate(name) {
        return this.templates[name.toLowerCase()] || this.templates.straight;
    }

    /**
     * Get emphasis for current beat and subdivision
     */
    getEmphasis(groove, beatNumber, subdivision) {
        if (!groove || !groove.pattern) return 0;

        // Find closest pattern position
        const patternIndex = groove.pattern.subdivisions.findIndex(
            sub => Math.abs(sub - subdivision) < 0.01
        );

        if (patternIndex === -1) return 0;

        return groove.pattern.emphasis[patternIndex] || 0;
    }

    /**
     * Get velocity for current position
     */
    getVelocity(groove, beatNumber, subdivision) {
        if (!groove || !groove.pattern) return 1.0;

        const patternIndex = groove.pattern.subdivisions.findIndex(
            sub => Math.abs(sub - subdivision) < 0.01
        );

        if (patternIndex === -1) return 0;

        return groove.pattern.velocities[patternIndex] || 0;
    }

    /**
     * Get preferred gesture for current position
     */
    getPreferredGesture(groove, beatNumber, subdivision, availableGestures = []) {
        if (!groove || !groove.preferredGestures) return null;

        // Determine the beat type
        let beatType;
        if (subdivision === 0) {
            beatType = 'downbeat';
        } else if (subdivision === 0.5) {
            beatType = 'offbeat';
        } else if (subdivision === 0.25 || subdivision === 0.75) {
            beatType = 'subdivision';
        } else {
            beatType = 'syncopation';
        }

        // Special case for THE ONE in funk
        if (groove.name === 'Funk' && beatNumber % 4 === 0 && subdivision === 0) {
            beatType = 'one';
        }

        const preferred = groove.preferredGestures[beatType] || groove.preferredGestures.fills;
        if (!preferred || preferred.length === 0) return null;

        // Filter to available gestures if provided
        if (availableGestures.length > 0) {
            const available = preferred.filter(g => availableGestures.includes(g));
            if (available.length > 0) {
                return available[Math.floor(Math.random() * available.length)];
            }
        }

        // Return random from preferred
        return preferred[Math.floor(Math.random() * preferred.length)];
    }

    /**
     * Apply humanization to timing
     */
    humanizeTiming(groove, timing) {
        if (!groove || !groove.humanization) return timing;

        const variance = groove.humanization;
        const offset = (Math.random() - 0.5) * variance;
        return Math.max(0, Math.min(1, timing + offset));
    }

    /**
     * Apply swing to subdivision
     */
    applySwing(groove, subdivision) {
        if (!groove || !groove.swing || groove.swing === 0) return subdivision;

        // Apply swing to upbeats (0.5)
        if (Math.abs(subdivision - 0.5) < 0.01) {
            return 0.5 + (groove.swing - 0.5) * 0.5;
        }

        // Apply swing to 16th note upbeats (0.25, 0.75)
        if (Math.abs(subdivision - 0.25) < 0.01) {
            return 0.25 + (groove.swing - 0.5) * 0.25;
        }
        if (Math.abs(subdivision - 0.75) < 0.01) {
            return 0.75 + (groove.swing - 0.5) * 0.25;
        }

        return subdivision;
    }

    /**
     * Set active groove with optional transition
     */
    setGroove(name, transitionMode = null) {
        const groove = this.getTemplate(name);
        if (!groove) return false;

        const mode = transitionMode || this.transitionMode;

        if (mode === 'instant' || !this.currentGroove) {
            this.currentGroove = groove;
            this.pendingGroove = null;
        } else {
            this.pendingGroove = groove;
            // Transition will happen based on mode
        }

        return true;
    }

    /**
     * Handle beat transition
     */
    onBeat(beatNumber) {
        if (!this.pendingGroove) return;

        const shouldTransition =
            (this.transitionMode === 'nextBar' && beatNumber % 4 === 0) ||
            (this.transitionMode === 'nextPhrase' && beatNumber % 16 === 0);

        if (shouldTransition) {
            this.currentGroove = this.pendingGroove;
            this.pendingGroove = null;
        }
    }

    /**
     * Get base movement for current groove
     */
    getBaseMovement() {
        return this.currentGroove?.baseMovement || null;
    }

    /**
     * Get transition style for current groove
     */
    getTransitionStyle() {
        return this.currentGroove?.transitionStyle || 'transitionLean';
    }

    /**
     * Get composite move for current groove
     */
    getCompositeMove() {
        return this.currentGroove?.compositeMove || null;
    }

    /**
     * Check if we should trigger composite move
     * @param {number} beatNumber - Current beat number
     * @returns {boolean} True if composite should trigger
     */
    shouldTriggerComposite(beatNumber) {
        if (!this.currentGroove?.compositeMove) return false;

        // Trigger composite every 4 or 8 bars depending on intensity
        const interval = this.currentGroove.intensity === 'sparse' ? 32 : 16;
        return beatNumber % interval === 0;
    }

    /**
     * Get layered gesture configuration for current position
     * @param {number} beatNumber - Current beat number
     * @param {number} subdivision - Current subdivision (0, 0.25, 0.5, 0.75)
     * @returns {Object} Configuration with base, accent, and transition layers
     */
    getLayeredGestures(beatNumber, subdivision) {
        if (!this.currentGroove) return null;

        const config = {
            base: this.getBaseMovement(),
            accent: null,
            transition: null,
            composite: null,
            velocity: 1.0
        };

        // Check for composite move trigger
        if (this.shouldTriggerComposite(beatNumber) && subdivision === 0) {
            config.composite = this.getCompositeMove();
        }

        // Get accent gesture based on emphasis
        const emphasis = this.getEmphasis(this.currentGroove, beatNumber, subdivision);
        const velocity = this.getVelocity(this.currentGroove, beatNumber, subdivision);

        if (emphasis > 0.3 && velocity > 0.3) {
            config.accent = this.getPreferredGesture(
                this.currentGroove,
                beatNumber,
                subdivision
            );
            config.velocity = velocity;
        }

        // Add transition if changing positions
        if (config.accent && Math.random() < 0.3) {
            config.transition = this.getTransitionStyle();
        }

        return config;
    }

    /**
     * Get all available groove names
     */
    getGrooveNames() {
        return Object.keys(this.templates);
    }

    /**
     * Get groove info for UI
     */
    getGrooveInfo(name) {
        const template = this.templates[name];
        if (!template) return null;

        return {
            name: template.name,
            timeSignature: template.timeSignature,
            description: template.description,
            intensity: template.intensity,
            swing: template.swing,
            baseMovement: template.baseMovement,
            compositeMove: template.compositeMove
        };
    }
}

/**
 * AudioHandler - Manages all audio-related functionality for EmotiveMascot
 * @module mascot/AudioHandler
 */

class AudioHandler {
    constructor(mascot) {
        this.mascot = mascot;
        this.vocalUpdateInterval = null;
    }

    /**
     * Initialize audio handler
     */
    init() {
        // Will contain initialization logic
    }


    /**
     * Disconnect audio analysis
     * @returns {Object} The mascot instance for chaining
     */
    disconnectAudio() {
        // Stop analysis
        if (this.mascot.audioAnalyzer) {
            this.mascot.audioAnalyzer.stop();
        }
        
        // Clear update interval
        if (this.vocalUpdateInterval) {
            clearInterval(this.vocalUpdateInterval);
            this.vocalUpdateInterval = null;
        }
        
        
        // Clear vocal data and analyzer reference
        if (this.mascot.shapeMorpher) {
            this.mascot.shapeMorpher.setVocalEnergy(0);
            this.mascot.shapeMorpher.setAudioDeformation(0);
            this.mascot.shapeMorpher.audioAnalyzer = null;
            this.mascot.shapeMorpher.beatGlitchIntensity = 0;
            this.mascot.shapeMorpher.glitchPoints = [];
        }

        // Stop ambient groove animation when audio stops
        if (this.mascot.renderer) {
            this.mascot.renderer.ambientDanceAnimator.stopAmbientAnimation('grooveBob');
        }

        return this.mascot;
    }

    /**
     * Connect audio element for vocal visualization
     * @param {HTMLAudioElement} audioElement - Audio element to analyze
     * @returns {Object} The mascot instance for chaining
     */
    async connectAudio(audioElement) {
        if (!this.mascot.audioAnalyzer) {
            return this.mascot;
        }
        
        // Initialize audio context if needed - this will only happen after user interaction
        if (!this.mascot.audioAnalyzer.audioContext) {
            try {
                await this.mascot.audioAnalyzer.init();
            } catch (error) {
                console.warn('Failed to initialize AudioContext:', error);
                return this.mascot;
            }
        }
        
        // Resume AudioContext if it's suspended (common after user interaction)
        if (this.mascot.audioAnalyzer.audioContext && this.mascot.audioAnalyzer.audioContext.state === 'suspended') {
            try {
                await this.mascot.audioAnalyzer.audioContext.resume();
            } catch (error) {
                console.warn('Failed to resume AudioContext:', error);
            }
        }
        
        // Connect the audio element
        this.mascot.audioAnalyzer.connectAudioElement(audioElement);
        
        // Pass analyzer reference to shape morpher for frequency data
        if (this.mascot.shapeMorpher) {
            this.mascot.shapeMorpher.audioAnalyzer = this.mascot.audioAnalyzer;
            
            // Set up beat detection callback for glitches and rhythm detection
            this.mascot.audioAnalyzer.onBeat(amplitude => {
                if (this.mascot.shapeMorpher) {
                    // Feed beat to music detector for BPM detection
                    if (this.mascot.shapeMorpher.musicDetector) {
                        const now = performance.now();
                        this.mascot.shapeMorpher.musicDetector.addOnset(now, amplitude);
                    }

                    // Only trigger beat glitches when vocals are active
                    if (this.mascot.shapeMorpher.vocalEffectActive) {
                        this.mascot.shapeMorpher.beatGlitchIntensity = amplitude * 0.3;
                    }
                }
            });
        }
        
        // Start updating shape morpher with vocal data
        if (this.vocalUpdateInterval) {
            clearInterval(this.vocalUpdateInterval);
        }
        
        // Start ambient groove animation when audio starts
        // This provides the continuous background movement
        if (this.mascot.renderer) {
            this.mascot.renderer.startGrooveBob({ intensity: 0.5, frequency: 1.0 });
        }

        this.vocalUpdateInterval = setInterval(() => {
            if (this.mascot.audioAnalyzer.isAnalyzing && this.mascot.shapeMorpher) {
                // Get current analysis data directly from properties
                const amplitude = this.mascot.audioAnalyzer.currentAmplitude || 0;
                const vocalInstability = this.mascot.audioAnalyzer.getVocalInstability() || 0;

                // Set vocal energy for shape pulsing
                this.mascot.shapeMorpher.setVocalEnergy(vocalInstability);

                // Set overall deformation based on amplitude (0 to 1, no shrinking)
                this.mascot.shapeMorpher.setAudioDeformation(amplitude * 2); // Keep positive for expansion only
            }
        }, 50); // Update at 20 FPS
        
        // Pass audio analyzer to renderer
        if (this.mascot.renderer) {
            this.mascot.renderer.audioAnalyzer = this.mascot.audioAnalyzer;
        }
        
        return this.mascot;
    }

    /**
     * Stops speech reactivity mode and returns to base emotional state
     * @returns {Object} The mascot instance for chaining
     */
    stopSpeaking() {
        if (!this.mascot.speaking) {
            return this.mascot;
        }
        
        // Store previous state for event
        const previousAudioLevel = this.mascot.audioLevelProcessor.getCurrentLevel();
        
        // Clean up audio level processor
        this.mascot.audioLevelProcessor.cleanup();
        
        // Reset speech state
        this.mascot.speaking = false;
        
        // Notify renderer about speech stop (triggers 500ms return-to-base transition)
        this.mascot.renderer.onSpeechStop();
        
        // Emit speech stop event
        this.mascot.emit('speechStopped', { 
            previousAudioLevel,
            returnToBaseTime: 500
        });
        
        return this.mascot;
    }

    /**
     * Sets master volume for all audio output
     * @param {number} volume - Volume level (0.0 to 1.0)
     * @returns {Object} The mascot instance for chaining
     */
    setVolume(volume) {
        const clampedVolume = Math.max(0, Math.min(1, volume));
        this.mascot.config.masterVolume = clampedVolume;
        
        if (this.mascot.soundSystem.isAvailable()) {
            const currentEmotion = this.mascot.stateMachine.getCurrentState().emotion;
            this.mascot.soundSystem.setMasterVolume(clampedVolume, currentEmotion);
        }
        
        this.mascot.emit('volumeChanged', { volume: clampedVolume });
        
        return this.mascot;
    }

    /**
     * Cleanup
     */
    destroy() {
        this.disconnectAudio();
    }
}

/**
 * GestureController - Manages gesture animations and protocols
 * @module mascot/GestureController
 */

class GestureController {
    constructor(mascot) {
        this.mascot = mascot;
        this.currentGesture = null;
    }

    /**
     * Initialize gesture controller
     */
    init() {
        // Will contain initialization logic
    }

    /**
     * Methods to be moved here:
     * - setGestureProtocol()
     * - performGesture()
     * - Gesture animation logic
     */

    /**
     * Cleanup
     */
    destroy() {
        this.currentGesture = null;
    }
}

/**
 * StateCoordinator - Manages emotion states and transitions
 * @module mascot/StateCoordinator
 */


class StateCoordinator {
    constructor(mascot) {
        this.mascot = mascot;
        this.currentEmotion = 'neutral';
        this.emotionIntensity = 1.0;
    }

    /**
     * Initialize state coordinator
     */
    init() {
        // Will contain initialization logic
    }

    /**
     * Sets the emotional state with optional undertone
     * @param {string} emotion - The emotion to set
     * @param {Object|string|null} options - Options object or undertone string for backward compatibility
     * @returns {Object} The mascot instance for chaining
     */
    setEmotion(emotion, options = null) {
        // Map common aliases to actual emotion states
        const emotionMapping = {
            'happy': 'joy',
            'curious': 'surprise',
            'frustrated': 'anger',
            'sad': 'sadness'
        };
        
        // Use mapped emotion or original if not an alias
        const mappedEmotion = emotionMapping[emotion] || emotion;
        
        // Handle backward compatibility - if options is a string, treat as undertone
        let undertone = null;
        let duration = 500;
        
        if (typeof options === 'string') {
            undertone = options;
        } else if (options && typeof options === 'object') {
            undertone = options.undertone || null;
            duration = options.duration || 500;
        }
        
        // Set emotional state in state machine
        const success = this.mascot.stateMachine.setEmotion(mappedEmotion, undertone, duration);
        
        if (success) {
            // Register emotion's rhythm configuration
            const emotionConfig = getEmotion(mappedEmotion);
            if (emotionConfig) {
                rhythmIntegration.registerConfig('emotion', mappedEmotion, emotionConfig);
            }
            // Clear and reset particles when changing emotional states
            if (this.mascot.particleSystem) {
                // Clear all existing particles
                this.mascot.particleSystem.clear();
                
                // Get the new emotional properties
                const emotionalProps = this.mascot.stateMachine.getCurrentEmotionalProperties();
                
                // Spawn initial particles for the new state
                // Use burst to immediately populate with a few particles
                // DECIMATED neutral
                let initialCount;
                if (mappedEmotion === 'neutral') {
                    initialCount = 1;  // DECIMATED to 1 particle
                } else if (mappedEmotion === 'resting') {
                    initialCount = 4;  // Keep resting at 4
                } else {
                    initialCount = Math.min(3, Math.floor(emotionalProps.particleRate / 4));
                }
                
                if (initialCount > 0) {
                    // Always spawn from canvas center, not gaze-adjusted position
                    const centerX = this.mascot.canvasManager.width / 2;
                    const centerY = this.mascot.canvasManager.height / 2;
                    
                    this.mascot.particleSystem.burst(
                        initialCount, 
                        emotionalProps.particleBehavior,
                        centerX,
                        centerY
                    );
                }
            }
            
            // Update sound system ambient tone - DISABLED (annoying)
            // if (this.mascot.soundSystem.isAvailable()) {
            //     this.mascot.soundSystem.setAmbientTone(mappedEmotion, duration);
            // }
            
            // Update Emotive renderer if in classic mode
            if (this.mascot.config.renderingStyle === 'classic' && this.mascot.renderer.setEmotionalState) {
                const emotionParams = getEmotionVisualParams(mappedEmotion);
                this.mascot.renderer.setEmotionalState(mappedEmotion, emotionParams, undertone);
            }
            
            // Emit emotion change event
            this.mascot.emit('emotionChanged', { emotion: mappedEmotion, undertone, duration });
            
        }
        
        this.currentEmotion = mappedEmotion;
        return this.mascot;
    }

    /**
     * Methods to be moved here:
     * - getEmotion()
     * - setUndertoneModifier()
     * - transitionToEmotion() (new smooth transition)
     * - setEmotionVector() (new 2D control)
     * - Emotion blending logic
     */

    /**
     * Cleanup
     */
    destroy() {
        this.currentEmotion = 'neutral';
    }
}

/**
 * VisualizationRunner - Manages the main animation loop and rendering
 * @module mascot/VisualizationRunner
 */


class VisualizationRunner {
    constructor(mascot) {
        this.mascot = mascot;
        this.animationId = null;
        this.isRunning = false;
        this.lastTime = 0;
    }

    /**
     * Initialize visualization runner
     */
    init() {
        // Will contain initialization logic
    }

    /**
     * Starts the animation loop at target 60 FPS
     * @returns {Object} The mascot instance for chaining
     */
    start() {
        if (this.mascot.animationController.isAnimating()) {
            return this.mascot;
        }
        
        // Start the animation controller
        const success = this.mascot.animationController.start();
        
        if (success) {
            this.mascot.isRunning = true;
            this.isRunning = true;
            
            // Spawn initial particles for classic mode
            if (this.mascot.config.renderingStyle === 'classic' && this.mascot.particleSystem) {
                const currentState = this.mascot.stateMachine.getCurrentState();
                const {emotion} = currentState;
                const emotionParams = getEmotionVisualParams(emotion);
                
                // Get the actual orb position from the renderer (includes gaze offset)
                let orbX, orbY;
                if (this.mascot.renderer && this.mascot.renderer.getCurrentOrbPosition) {
                    const orbPos = this.mascot.renderer.getCurrentOrbPosition();
                    orbX = orbPos.x;
                    orbY = orbPos.y;
                } else {
                    // Fallback to center if method doesn't exist
                    orbX = this.mascot.canvasManager.width / 2;
                    orbY = this.mascot.canvasManager.height / 2;
                }
                
                // Clear any existing particles first
                this.mascot.particleSystem.clear();
                
                // Check if emotion has specific particle configuration
                if (emotionParams.particleRate > 0) {
                    // Spawn initial burst of particles
                    const initialCount = Math.min(3, Math.floor(emotionParams.particleRate / 4));
                    
                    if (initialCount > 0) {
                        this.mascot.particleSystem.burst(
                            initialCount,
                            emotionParams.particleBehavior,
                            orbX,
                            orbY
                        );
                    }
                }
            }
            
            // Start degradation monitoring
            if (this.mascot.degradationManager) {
                this.mascot.degradationManager.startMonitoring();
            }
            
            // Emit start event
            this.mascot.emit('started');
        }
        
        return this.mascot;
    }

    /**
     * Stops the animation loop and cleans up resources
     * @returns {Object} The mascot instance for chaining
     */
    stop() {
        if (!this.mascot.animationController.isAnimating()) {
            return this.mascot;
        }
        
        // Stop speech reactivity if active
        if (this.mascot.speaking) {
            this.mascot.audioHandler.stopSpeaking();
        }
        
        // Stop the animation controller
        const success = this.mascot.animationController.stop();
        
        if (success) {
            this.mascot.isRunning = false;
            this.isRunning = false;
            
            // Stop degradation monitoring
            if (this.mascot.degradationManager) {
                this.mascot.degradationManager.stopMonitoring();
            }
            
            // Emit stop event
            this.mascot.emit('stopped');
        }
        
        return this.mascot;
    }

    /**
     * Updates audio level monitoring and other per-frame updates
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    update(deltaTime) {
        // Update audio level monitoring if speaking
        if (this.mascot.speaking && this.mascot.audioLevelProcessor.isProcessingActive()) {
            this.mascot.audioLevelProcessor.updateAudioLevel(deltaTime);
        }
        
        // Update classic mode components
        if (this.mascot.config.renderingStyle === 'classic') {
            // Update gaze tracker
            if (this.mascot.gazeTracker) {
                this.mascot.gazeTracker.update(deltaTime);
                
                // Update threat level for suspicion emotion
                const currentEmotion = this.mascot.stateMachine.getCurrentState().emotion;
                if (currentEmotion === 'suspicion') {
                    // Get mouse position and calculate distance to center
                    const {mousePos} = this.mascot.gazeTracker;
                    const centerX = this.mascot.canvas.width / 2;
                    const centerY = this.mascot.canvas.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(mousePos.x - centerX, 2) + 
                        Math.pow(mousePos.y - centerY, 2)
                    );
                    
                    // Get emotion configuration
                    const suspicionEmotion = getEmotion('suspicion');
                    if (suspicionEmotion && suspicionEmotion.visual) {
                        const maxDistance = Math.min(centerX, centerY);
                        const threatLevel = Math.max(0, Math.min(1, 1 - (distance / maxDistance)));
                        suspicionEmotion.visual.threatLevel = threatLevel;
                    }
                }
            }
            
            // Update idle behaviors
            if (this.mascot.idleBehavior) {
                this.mascot.idleBehavior.update(deltaTime);
            }
            
            // Combine gaze and sway offsets
            if (this.mascot.gazeTracker && this.mascot.idleBehavior) {
                const gazeOffset = this.mascot.gazeTracker.getGazeOffset();
                const swayOffset = this.mascot.idleBehavior.getSwayOffset();
                
                // Get full gaze state including proximity for eye narrowing
                const gazeState = this.mascot.gazeTracker.getState();
                
                // Combine the offsets and include proximity data
                const gazeData = {
                    offset: {
                        x: gazeOffset.x + swayOffset.x,
                        y: gazeOffset.y + swayOffset.y
                    },
                    proximity: gazeState.proximity,
                    isFocused: gazeState.isFocused
                };
                
                // Pass to renderer
                if (this.mascot.renderer.setGazeData) {
                    this.mascot.renderer.setGazeData(gazeData);
                }
            }
        }
    }

    /**
     * Cleanup
     */
    destroy() {
        this.stop();
    }
}

/**
 * ConfigurationManager - Manages settings and configuration
 * @module mascot/ConfigurationManager
 */

class ConfigurationManager {
    constructor(mascot, config = {}) {
        this.mascot = mascot;
        this.config = this.validateConfig(config);
    }

    /**
     * Validate and set defaults for configuration
     */
    validateConfig(config) {
        return {
            canvasId: config.canvasId || 'emotive-canvas',
            startingEmotion: config.startingEmotion || 'neutral',
            emotionalResponsiveness: config.emotionalResponsiveness ?? 0.5,
            particleIntensity: config.particleIntensity ?? 1.0,
            glowIntensity: config.glowIntensity ?? 1.0,
            audioEnabled: config.audioEnabled ?? false,
            showFPS: config.showFPS ?? false,
            debugMode: config.debugMode ?? false,
            renderMode: config.renderMode || 'default',
            maxParticles: config.maxParticles || 100,
            ...config
        };
    }

    /**
     * Methods to be moved here:
     * - getConfig()
     * - updateConfig()
     * - Configuration validation
     */

    /**
     * Get current configuration
     */
    getConfig() {
        return { ...this.config };
    }

    /**
     * Update configuration
     */
    updateConfig(updates) {
        this.config = { ...this.config, ...updates };
        return this.config;
    }
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                   ◐ ◑ ◒ ◓  EMOTIVE MASCOT  ◓ ◒ ◑ ◐                   
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview EmotiveMascot - Main API Class for the Emotive Engine
 * @author Emotive Engine Team
 * @version 2.1.0
 * @module EmotiveMascot
 * @changelog 2.1.0 - Added resize handling with visual resampling for consistent quality
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The MAIN ORCHESTRATOR of the Emotive Engine. This is the primary API class        
 * ║ that developers interact with. It coordinates all subsystems, manages the         
 * ║ lifecycle, and provides the fluent API for emotional expression.                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎭 CORE FEATURES                                                                  
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Emotional state management with smooth transitions                              
 * │ • Gesture triggering and animation control                                        
 * │ • Particle system orchestration                                                   
 * │ • Dynamic visual resampling on resize                                             
 * │ • Plugin system for extensibility                                                 
 * │ • Event handling and listener management                                          
 * │ • Performance optimization and degradation                                        
 * │ • Accessibility features                                                          
 * │ • Mobile optimization                                                             
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class EmotiveMascot {
    constructor(config = {}) {
        // Initialize error boundary first
        this.errorBoundary = new ErrorBoundary();
        
        // Initialize EventManager with simple event emitter functionality
        this.eventManager = new EventManager({
            maxListeners: config.maxEventListeners || 100,
            enableDebugging: config.enableEventDebugging || false,
            enableMonitoring: config.enableEventMonitoring || true,
            memoryWarningThreshold: config.eventMemoryWarningThreshold || 50
        });

        // Add simple event emitter methods if not present
        if (!this.eventManager.emit) {
            this.eventManager._listeners = {};
            this.eventManager.emit = (event, data) => {
                const listeners = this.eventManager._listeners[event];
                if (listeners) {
                    listeners.forEach(listener => listener(data));
                }
            };
            this.eventManager.on = (event, listener) => {
                if (!this.eventManager._listeners[event]) {
                    this.eventManager._listeners[event] = [];
                }
                this.eventManager._listeners[event].push(listener);
            };
            this.eventManager.off = (event, listener) => {
                const listeners = this.eventManager._listeners[event];
                if (listeners) {
                    const index = listeners.indexOf(listener);
                    if (index > -1) {
                        listeners.splice(index, 1);
                    }
                }
            };
        }
        
        // Wrap initialization in error boundary
        this.errorBoundary.wrap(() => {
            this.initialize(config);
        }, 'initialization')();
    }

    /**
     * Get default duration for a gesture
     */
    /**
     * Initialize the mascot system
     * @param {Object} config - Configuration options
     */
    initialize(config) {
        // Get browser-specific optimizations
        const browserOpts = browserCompatibility.browserOptimizations.getOptimizations();
        
        // Default configuration with browser-specific optimizations
        const defaults = {
            canvasId: 'emotive-mascot',
            targetFPS: 60,
            enableAudio: browserCompatibility.featureDetection.features.webAudio,
            soundEnabled: false,  // Disable gesture sounds by default
            masterVolume: 0.5,
            maxParticles: browserOpts.particleLimit,
            defaultEmotion: 'neutral',
            enableAutoOptimization: true,
            enableGracefulDegradation: true,
            renderingStyle: 'classic',  // 'classic' (Emotive) or 'advanced' (3-layer)
            enableGazeTracking: true,
            enableIdleBehaviors: true,
            renderSize: null,  // { width: number, height: number } - if set, engine renders at this exact size
            offsetX: 0,        // X offset for eccentric positioning
            offsetY: 0,        // Y offset for eccentric positioning
            offsetZ: 0,        // Z offset for pseudo-3D scaling
            classicConfig: {
                coreColor: '#FFFFFF',
                coreSizeDivisor: 12,      // Core radius = canvas_size / 12 (original Emotive)
                glowMultiplier: 2.5,      // Glow radius = core * 2.5 (original Emotive)
                defaultGlowColor: '#14B8A6'
            },
            topOffset: 0  // Vertical offset to shift mascot upward (in pixels)
        };
        
        this.config = { ...defaults, ...config };
        
        // Get canvas element
        this.canvas = typeof this.config.canvasId === 'string' 
            ? document.getElementById(this.config.canvasId)
            : this.config.canvasId;
            
        if (!this.canvas) {
            throw new Error(`Canvas with ID '${this.config.canvasId}' not found`);
        }

        // Initialize core systems with browser compatibility
        this.canvasManager = new CanvasManager(this.canvas);
        
        // Initialize position controller for eccentric positioning
        this.positionController = new PositionController({
            offsetX: this.config.offsetX,
            offsetY: this.config.offsetY,
            offsetZ: this.config.offsetZ,
            onUpdate: effectiveCenter => {
                // Update renderer with new effective center
                if (this.renderer) {
                    this.renderer.updateEffectiveCenter(effectiveCenter);
                }
            }
        });
        
        // Set render size if specified in config
        if (this.config.renderSize && this.config.renderSize.width && this.config.renderSize.height) {
            this.canvasManager.setRenderSize(this.config.renderSize.width, this.config.renderSize.height);
        }
        
        // Set up canvas context recovery
        this.contextRecovery = new CanvasContextRecovery(this.canvas);
        this.contextRecovery.onRecovery(context => {
            // Canvas context recovered, reinitializing renderer
            if (this.renderer) {
                this.renderer.handleContextRecovery(context);
            }
        });
        
        // Apply browser-specific canvas optimizations
        browserCompatibility.browserOptimizations.applyCanvasOptimizations(
            this.canvas, 
            this.canvasManager.getContext()
        );
        
        this.stateMachine = new EmotiveStateMachine(this.errorBoundary);
        this.particleSystem = new ParticleSystem(this.config.maxParticles, this.errorBoundary);
        
        // Always use EmotiveRenderer, pass full config including topOffset and position controller
        this.renderer = new EmotiveRenderer(this.canvasManager, {
            ...this.config.classicConfig,
            topOffset: this.config.topOffset || 0,
            positionController: this.positionController
        });
        
        // Initialize shape morphing and audio analysis early
        this.shapeMorpher = new ShapeMorpher();
        this.audioAnalyzer = new AudioAnalyzer();

        // Gesture compatibility system
        this.gestureCompatibility = gestureCompatibility;

        // Groove templates for musical rhythm patterns
        this.grooveTemplates = new GrooveTemplates();
        
        // Pass audioAnalyzer to shapeMorpher for audio-reactive deformation
        this.shapeMorpher.audioAnalyzer = this.audioAnalyzer;
        
        // Pass them to renderer
        this.renderer.shapeMorpher = this.shapeMorpher;
        this.renderer.audioAnalyzer = this.audioAnalyzer;
        
        // Connect renderer and state machine for undertone modifiers
        this.renderer.stateMachine = this.stateMachine;
        this.stateMachine.renderer = this.renderer;
        
        // Initialize gaze tracking
        if (this.config.enableGazeTracking) {
            this.gazeTracker = new GazeTracker(this.canvas, {
                smoothing: 0.1,
                maxOffset: 0.15,
                enabled: true
            });
            
            // Reset idle timer on interaction and wake if sleeping
            this.gazeTracker.setInteractionCallback(() => {
                if (this.sleeping) {
                    // Wake with full animation sequence
                    this.wake();
                } else if (this.idleBehavior) {
                    // Just reset idle timer if not sleeping
                    this.idleBehavior.resetIdleTimer();
                }
            });
        }
        
        // Initialize idle behaviors
        if (this.config.enableIdleBehaviors) {
            this.idleBehavior = new IdleBehavior({
                enabled: true,
                sleepTimeout: Infinity  // Disable automatic sleep
            });
            
            // Connect idle behavior callbacks to renderer
            this.idleBehavior.setCallback('onBlink', data => {
                if (this.renderer && this.renderer.state) {
                    this.renderer.state.blinking = data.phase === 'start';
                }
            });
            
            this.idleBehavior.setCallback('onSleep', () => {
                if (this.renderer && this.renderer.enterSleepMode) {
                    this.renderer.enterSleepMode();
                }
            });
            
            this.idleBehavior.setCallback('onWake', () => {
                if (this.renderer && this.renderer.wakeUp) {
                    this.renderer.wakeUp();
                }
            });
        }
        
        this.soundSystem = new SoundSystem();
        
        // DegradationManager removed - no performance interference
        this.degradationManager = null;
        
        // Initialize accessibility manager
        this.accessibilityManager = new AccessibilityManager({
            enableReducedMotion: this.config.enableReducedMotion !== false,
            enableHighContrast: this.config.enableHighContrast !== false,
            enableScreenReaderSupport: this.config.enableScreenReaderSupport !== false,
            enableKeyboardNavigation: this.config.enableKeyboardNavigation !== false,
            colorBlindMode: this.config.colorBlindMode || 'none'
        });
        
        // Initialize mobile optimization
        this.mobileOptimization = new MobileOptimization({
            enableTouchOptimization: this.config.enableTouchOptimization !== false,
            enableViewportHandling: this.config.enableViewportHandling !== false,
            enableBatteryOptimization: this.config.enableBatteryOptimization !== false
        });
        
        // Set canvas for mobile optimization
        this.mobileOptimization.setCanvas(this.canvas);
        
        // Initialize plugin system
        this.pluginSystem = new PluginSystem({
            enablePlugins: this.config.enablePlugins !== false,
            validatePlugins: this.config.validatePlugins !== false,
            sandboxPlugins: this.config.sandboxPlugins !== false
        });
        
        // Initialize audio level processor for speech reactivity
        this.audioLevelProcessor = new AudioLevelProcessor({
            spikeThreshold: this.config.spikeThreshold || 1.5,
            minimumSpikeLevel: this.config.minimumSpikeLevel || 0.1,
            spikeMinInterval: this.config.spikeMinInterval || 1000
        });
        
        // Initialize animation controller
        try {
            this.animationController = new AnimationController(this.errorBoundary, {
                targetFPS: this.config.targetFPS
            });
        } catch (_error) {
            // Failed to initialize AnimationController
            // Fallback: create a minimal animation controller interface
            this.animationController = {
                isAnimating: () => this.isRunning,
                start: () => { this.isRunning = true; return true; },
                stop: () => { this.isRunning = false; return true; },
                setTargetFPS: () => {},
                targetFPS: this.config.targetFPS,
                getPerformanceMetrics: () => ({ fps: 0, isRunning: this.isRunning, performanceDegradation: false, deltaTime: 16, frameCount: 0, targetFPS: this.config.targetFPS }),
                setSubsystems: () => {},
                setEventCallback: () => {},
                setParentMascot: () => {},
                destroy: () => {},
                deltaTime: 16
            };
        }
        
        // Configure animation controller with subsystems
        this.animationController.setSubsystems({
            stateMachine: this.stateMachine,
            particleSystem: this.particleSystem,
            renderer: this.renderer,
            soundSystem: this.soundSystem,
            canvasManager: this.canvasManager
        });
        
        // Set up event forwarding from animation controller
        this.animationController.setEventCallback((event, data) => {
            this.emit(event, data);
        });
        
        // Set parent mascot reference for audio level updates
        this.animationController.setParentMascot(this);
        
        // Runtime state
        this.isRunning = false;
        
        // Initialize sound system if enabled
        if (this.config.enableAudio) {
            this.soundSystem.initialize().then(success => {
                if (success) {
                    this.soundSystem.setMasterVolume(this.config.masterVolume);
                    // Sound system initialized successfully
                }
            });
        }
        
        // Speech reactivity state
        this.speaking = false;
        
        // Track warning frequency to reduce spam
        this.warningTimestamps = {};
        
        // Initialize rhythm integration
        this.rhythmEnabled = false;
        rhythmIntegration.initialize();

        // Expose rhythmIntegration globally for UI controls
        // Store rhythm integration internally instead of global
        this.rhythmIntegration = rhythmIntegration;
        this.warningThrottle = 5000; // Only show same warning every 5 seconds
        
        // Recording state (listening/capturing)
        this.recording = false;
        
        // Sleeping state
        this.sleeping = false;
        
        // TTS (Text-to-Speech) state
        this.tts = {
            available: typeof window !== 'undefined' && 'speechSynthesis' in window,
            speaking: false,
            currentUtterance: null
        };
        
        // Initialize modular handlers
        this.audioHandler = new AudioHandler(this);
        this.gestureController = new GestureController(this);
        this.stateCoordinator = new StateCoordinator(this);
        this.visualizationRunner = new VisualizationRunner(this);
        this.configurationManager = new ConfigurationManager(this, config);
        
        // Initialize the handlers
        this.audioHandler.init();
        this.gestureController.init();
        this.stateCoordinator.init();
        this.visualizationRunner.init();
        
        // EventManager already initialized in constructor
        
        // Initialize debugging if enabled
        this.debugMode = this.config.enableDebug || false;
        if (this.debugMode) {
            emotiveDebugger.log('INFO', 'Debug mode enabled for EmotiveMascot', {
                config: this.config,
                runtimeCapabilities: runtimeCapabilities.generateReport()
            });
            
            // Start profiling initialization
            emotiveDebugger.startProfile('mascot-initialization', {
                canvasId: this.config.canvasId,
                maxParticles: this.config.maxParticles
            });
        }
        
        // Set up audio level processor callbacks
        this.setupAudioLevelProcessorCallbacks();
        
        // Set initial emotional state
        this.stateMachine.setEmotion(this.config.defaultEmotion);
        
        // Register for canvas resize events to trigger visual resampling
        this.canvasManager.onResize((width, height, dpr) => {
            this.handleResize(width, height, dpr);
        });
        
        // Log browser compatibility information
        // EmotiveMascot initialized successfully
        
        // Complete initialization profiling
        if (this.debugMode) {
            emotiveDebugger.endProfile('mascot-initialization');
            emotiveDebugger.takeMemorySnapshot('post-initialization');
        }
    }

    /**
     * Handle degradation manager events
     * @param {string} event - Event type
     * @param {Object} data - Event data
     */
    handleDegradationEvent(event, data) {
        switch (event) {
        case 'degradationApplied':
            // Silently handle performance degradation
            this.applyDegradationSettings(data.settings);
            this.emit('performanceDegradation', data);
            break;
                
        case 'recoveryApplied':
            // Silently handle performance recovery
            this.applyDegradationSettings(data.settings);
            this.emit('performanceRecovery', data);
            break;
                
        case 'levelChanged':
            // Silently handle degradation level change
            this.applyDegradationSettings(data.settings);
            this.emit('degradationLevelChanged', data);
            break;
        }
    }

    /**
     * Apply degradation settings to all systems
     * @param {Object} settings - Degradation settings
     */
    applyDegradationSettings(settings) {
        // Update particle system limits
        if (this.particleSystem && settings.particleLimit !== undefined) {
            this.particleSystem.setMaxParticles(settings.particleLimit);
        }
        
        // Update audio system
        if (this.soundSystem && settings.audioEnabled !== undefined) {
            if (!settings.audioEnabled && this.soundSystem.isAvailable()) {
                this.soundSystem.stopAmbientTone(200);
            }
        }
        
        // DISABLED - Don't change FPS based on degradation
        /*
        // Update animation controller target FPS
        if (this.animationController && settings.targetFPS !== undefined) {
            this.animationController.setTargetFPS(settings.targetFPS);
        }
        */
        
        // Update renderer quality
        if (this.renderer && settings.qualityLevel !== undefined) {
            this.renderer.setQualityLevel(settings.qualityLevel);
        }
    }

    /**
     * Set up callbacks for the audio level processor
     */
    setupAudioLevelProcessorCallbacks() {
        // Handle audio level updates
        this.audioLevelProcessor.onLevelUpdate(data => {
            // Update renderer with current audio level
            this.renderer.updateAudioLevel(data.level);
            
            // Emit audio level update event
            this.emit('audioLevelUpdate', {
                level: data.level,
                rawData: Array.from(data.rawData),
                timestamp: data.timestamp
            });
        });
        
        // Handle volume spikes for gesture triggering
        this.audioLevelProcessor.onVolumeSpike(spikeData => {
            // Trigger pulse gesture if not already active
            // Check if any particle has an active gesture
            const hasActiveGesture = this.particleSystem.particles.some(p => p.gestureProgress < 1);
            if (!hasActiveGesture) {
                ({
                    emotion: this.stateMachine.getCurrentState().emotion,
                    properties: this.stateMachine.getCurrentEmotionalProperties()
                });
                
                // Execute pulse gesture through express method
                this.express('pulse');
                
                {
                    // Emit volume spike event with gesture trigger info
                    this.emit('volumeSpike', {
                        ...spikeData,
                        gestureTriggered: true
                    });
                    
                    // Volume spike detected - triggered pulse gesture
                }
            }
        });
        
        // Handle audio processing errors
        this.audioLevelProcessor.onError(errorData => {
            // AudioLevelProcessor error
            this.emit('audioProcessingError', errorData);
        });
    }

    /**
     * Sets the emotional state with optional undertone
     * @param {string} emotion - The emotion to set
     * @param {Object|string|null} options - Options object or undertone string
     * @returns {EmotiveMascot} This instance for chaining
     */
    setEmotion(emotion, options = null) {
        return this.errorBoundary.wrap(() => {
            return this.stateCoordinator.setEmotion(emotion, options);
        }, 'emotion-setting', this)();
    }
    
    /**
     * Update the undertone without resetting emotion
     * @param {string|null} undertone - The undertone to apply (subdued, tired, nervous, energetic, confident, intense, or null)
     * @returns {EmotiveMascot} This instance for chaining
     */
    updateUndertone(undertone) {
        return this.errorBoundary.wrap(() => {
            // Update state machine's undertone
            this.stateMachine.applyUndertoneModifier(undertone);
            // Update renderer's undertone without resetting emotion
            if (this.renderer && this.renderer.updateUndertone) {
                this.renderer.updateUndertone(undertone);
            }
            return this;
        }, 'undertone-update', this)();
    }
    
    /**
     * Set BPM for rhythm-linked subsystems
     * @param {number} bpm - Beats per minute (forwarded to audio/rhythm helpers)
     * @note Manual rotation now uses degrees per frame; BPM no longer drives rotation speed directly.
     * @returns {EmotiveMascot} This instance for chaining
     */
    setBPM(bpm) {
        return this.errorBoundary.wrap(() => {
            if (this.renderer && this.renderer.setBPM) {
                this.renderer.setBPM(bpm);
            }
            return this;
        }, 'bpm-update', this)();
    }

    /**
     * Set manual rotation speed for the shape
     * @param {number} speed - Rotation speed in degrees per frame (negative for reverse)
     * @note Speeds between -10 and 10 feel natural; higher values may cause motion blur.
     * @returns {EmotiveMascot} This instance for chaining
     */
    setRotationSpeed(speed) {
        return this.errorBoundary.wrap(() => {
            if (this.renderer && this.renderer.setRotationSpeed) {
                this.renderer.setRotationSpeed(speed);
            }
            return this;
        }, 'rotation-speed-update', this)();
    }

    /**
     * Set manual rotation angle directly (for scratching)
     * @param {number} angle - Rotation angle in degrees
     * @returns {EmotiveMascot} This instance for chaining
     */
    setRotationAngle(angle) {
        return this.errorBoundary.wrap(() => {
            if (this.renderer && this.renderer.setRotationAngle) {
                this.renderer.setRotationAngle(angle);
            }
            return this;
        }, 'rotation-angle-update', this)();
    }

    /**
     * Get the current position information
     * @returns {Object|null} Current position metadata or null if not available
     */
    getPosition() {
        return this.errorBoundary.wrap(() => {
            if (!this.positionController || typeof this.positionController.getPosition !== 'function') {
                return null;
            }

            const hasWindow = typeof window !== 'undefined';
            const centerX = hasWindow ? window.innerWidth / 2 : 0;
            const centerY = hasWindow ? window.innerHeight / 2 : 0;

            return this.positionController.getPosition(centerX, centerY);
        }, 'get-position', this)();
    }

    /**
     * Enable or disable gaze tracking
     * @param {boolean} enabled - Whether to enable gaze tracking
     * @returns {EmotiveMascot} This instance for chaining
     */
    setGazeTracking(enabled) {
        return this.errorBoundary.wrap(() => {
            if (this.renderer && this.renderer.setGazeTracking) {
                this.renderer.setGazeTracking(enabled);
            }
            return this;
        }, 'gaze-tracking-update', this)();
    }

    /**
     * Executes a single gesture or chord (multiple simultaneous gestures)
     * @param {string|Array<string>|Object} gesture - Single gesture, array of gestures, or chord object
     * @param {Object} options - Options for the gesture execution
     * @returns {EmotiveMascot} This instance for chaining
     */
    express(gesture, options = {}) {
        return this.errorBoundary.wrap(() => {
            // Performance marker: Gesture start
            const gestureStartTime = performance.now();
            const gestureName = Array.isArray(gesture) ? 'chord' :
                (typeof gesture === 'object' && gesture.type === 'chord') ? 'chord' :
                    gesture;

            if (this.performanceMonitor) {
                this.performanceMonitor.markGestureStart(gestureName);
            }

            if (!gesture) {
                // No gesture provided to express()
                if (this.performanceMonitor) {
                    this.performanceMonitor.markGestureEnd(gestureName);
                }
                return this;
            }

            // Handle chord (multiple simultaneous gestures)
            if (Array.isArray(gesture)) {
                return this.expressChord(gesture, options);
            }

            // Handle chord object
            if (typeof gesture === 'object' && gesture.type === 'chord') {
                return this.expressChord(gesture.gestures, options);
            }

            // Express called with single gesture
            // In rhythm game mode, gestures will be triggered directly by gameplay
            // No queuing needed - immediate response to player actions

            // Direct mapping to renderer methods for all gestures
            const rendererMethods = {
                'bounce': 'startBounce',
                'pulse': 'startPulse',
                'shake': 'startShake',
                'spin': 'startSpin',
                'nod': 'startNod',
                'tilt': 'startTilt',
                'expand': 'startExpand',
                'contract': 'startContract',
                'flash': 'startFlash',
                'drift': 'startDrift',
                'stretch': 'startStretch',
                'glow': 'startGlow',
                'sparkle': 'startSparkle',
                'shimmer': 'startShimmer',
                'wiggle': 'startWiggle',
                'groove': 'startGroove',
                'point': 'startPoint',
                'lean': 'startLean',
                'reach': 'startReach',
                'headBob': 'startHeadBob',
                'orbit': 'startOrbit',
                'flicker': 'startFlicker',
                'vibrate': 'startVibrate',
                'wave': 'startWave',
                'breathe': 'startBreathe',
                'morph': 'startMorph',
                'slowBlink': 'startSlowBlink',
                'look': 'startLook',
                'settle': 'startSettle',
                'orbital': 'startOrbital',  // Alias for backwards compatibility
                'hula': 'startHula',
                'sway': 'startSway',
                'breathIn': 'startBreathIn',
                'breathOut': 'startBreathOut',
                'breathHold': 'startBreathHold',
                'breathHoldEmpty': 'startBreathHoldEmpty',
                'jump': 'startJump',
                'rain': 'startRain',
                'runningman': 'startRunningMan',
                'charleston': 'startCharleston',
                // Ambient dance gestures
                'grooveSway': 'startGrooveSway',
                'grooveBob': 'startGrooveBob',
                'grooveFlow': 'startGrooveFlow',
                'groovePulse': 'startGroovePulse',
                'grooveStep': 'startGrooveStep'
                // Note: burst, peek, hold, scan, twitch, jitter, float
                // are handled by the gesture system below
            };
            
            // Check if this gesture has a direct renderer method
            const methodName = rendererMethods[gesture];
            if (methodName && this.renderer && this.renderer[methodName]) {
                // Call the renderer method directly
                this.renderer[methodName](options);

                // Play gesture sound effect if available and enabled
                if (this.config.soundEnabled && this.soundSystem.isAvailable()) {
                    this.soundSystem.playGestureSound(gesture);
                }

                // Performance marker: Gesture end
                if (this.performanceMonitor) {
                    const gestureEndTime = performance.now();
                    this.performanceMonitor.markGestureEnd(gestureName);
                    this.performanceMonitor.recordGestureTime(gestureName, gestureEndTime - gestureStartTime);
                }

                return this;
            }
            
            // Try to execute gesture through the particle system
            // This handles modular gestures from the gesture registry
            // Check if gesture exists in the gesture registry
            const gestureConfig = getGesture$1(gesture);
            
            if (gestureConfig) {
                // Register gesture's rhythm configuration
                rhythmIntegration.registerConfig('gesture', gesture, gestureConfig);
                
                // Store the current gesture info for the particle system to use
                this.currentModularGesture = {
                    type: gesture,
                    config: gestureConfig,
                    startTime: performance.now(),
                    duration: gestureConfig.defaultParams?.duration || 1000,
                    progress: 0
                };
                
                // Executed gesture through particle system
                
                // Play gesture sound effect if available and enabled
                if (this.config.soundEnabled && this.soundSystem.isAvailable()) {
                    this.soundSystem.playGestureSound(gesture);
                }

                // Performance marker: Gesture end
                if (this.performanceMonitor) {
                    const gestureEndTime = performance.now();
                    this.performanceMonitor.markGestureEnd(gestureName);
                    this.performanceMonitor.recordGestureTime(gestureName, gestureEndTime - gestureStartTime);
                }

                return this;
            }
            
            // Unknown gesture - throttled warning
            this.throttledWarn(`Unknown gesture: ${gesture}`, `gesture_${gesture}`);

            // Performance marker: Gesture end (failed)
            if (this.performanceMonitor) {
                this.performanceMonitor.markGestureEnd(gestureName);
            }

            return this;
        }, 'gesture-expression', this)();
    }

    /**
     * Express multiple gestures simultaneously (chord)
     * @param {Array<string>} gestures - Array of gesture names to execute together
     * @param {Object} options - Options for the chord execution
     * @returns {EmotiveMascot} This instance for chaining
     */
    expressChord(gestures, options = {}) {
        return this.errorBoundary.wrap(() => {
            if (!gestures || !Array.isArray(gestures) || gestures.length === 0) {
                return this;
            }

            // Import gesture compatibility if not loaded
            if (!this.gestureCompatibility) {
                // Try to load it dynamically
                Promise.resolve().then(function () { return GestureCompatibility$1; }).then(module => {
                    this.gestureCompatibility = module.default;
                }).catch(err => {
                    console.warn('GestureCompatibility not available:', err);
                });
            }

            // Use compatibility system if available
            const compatibleGestures = this.gestureCompatibility ?
                this.gestureCompatibility.getCompatibleGestures(gestures) :
                gestures;

            console.warn('Executing gesture chord:', compatibleGestures);

            // Execute all compatible gestures simultaneously
            compatibleGestures.forEach(gestureName => {
                const normalizedGesture = typeof gestureName === 'string' ?
                    gestureName : gestureName.gestureName;

                // Execute directly to ensure simultaneity
                this.executeGestureDirectly(normalizedGesture, options);
            });

            // Check for enhancing combination
            if (this.gestureCompatibility?.isEnhancingCombination?.(compatibleGestures)) {
                // Add extra visual flair
                this.renderer?.specialEffects?.addSparkle?.();
            }

            return this;
        }, 'gesture-chord', this)();
    }

    /**
     * Execute a gesture directly on the renderer (bypasses routing)
     * @private
     */
    executeGestureDirectly(gesture, options = {}) {
        // Direct mapping to renderer methods
        const rendererMethods = {
            'bounce': 'startBounce',
            'pulse': 'startPulse',
            'shake': 'startShake',
            'spin': 'startSpin',
            'nod': 'startNod',
            'tilt': 'startTilt',
            'flash': 'startFlash',
            'glow': 'startGlow',
            'sparkle': 'startSparkle',
            'shimmer': 'startShimmer',
            'wiggle': 'startWiggle',
            'groove': 'startGroove',
            'point': 'startPoint',
            'lean': 'startLean',
            'reach': 'startReach',
            'headBob': 'startHeadBob',
            'orbit': 'startOrbit',
            'sway': 'startSway',
            'jump': 'startJump',
            'wave': 'startWave',
            'flicker': 'startFlicker',
            'breathe': 'startBreathe',
            'float': 'startFloat',
            'rain': 'startRain',
            'hula': 'startHula',
            'twist': 'startTwist'
        };

        const methodName = rendererMethods[gesture];
        if (methodName && this.renderer && typeof this.renderer[methodName] === 'function') {
            this.renderer[methodName](options);
        }

        // Emit event
        this.emit('gesture', { name: gesture, options });
    }

    /**
     * Chains multiple gestures for sequential execution
     * @param {...string} gestures - Gestures to chain
     * @returns {EmotiveMascot} This instance for chaining
     */
    chain(...gestures) {
        // Parse the chain using GestureCompatibility if available
        if (this.gestureCompatibility) {
            const chainString = gestures.join('>');
            const steps = this.gestureCompatibility.parseChain(chainString);
            
            // Execute all steps with proper timing
            this.executeChainSequence(steps);
        } else {
            console.warn('🔗 No gestureCompatibility available, falling back to first gesture');
            // Fallback: execute first gesture
            if (gestures.length > 0) {
                this.express(gestures[0]);
            }
        }
        return this;
    }

    /**
     * Execute a sequence of gesture steps with proper timing
     * @param {Array<Array<string>>} steps - Array of steps, each containing simultaneous gestures
     */
    executeChainSequence(steps) {
        if (!steps || steps.length === 0) return;

        let currentStep = 0;
        const stepDuration = 800; // Base duration per step (ms)

        const executeStep = () => {
            if (currentStep >= steps.length) return;

            const step = steps[currentStep];
            
            if (step.length === 1) {
                // Single gesture
                this.express(step[0]);
            } else {
                // Multiple simultaneous gestures
                this.expressChord(step);
            }

            currentStep++;
            
            // Schedule next step
            if (currentStep < steps.length) {
                setTimeout(executeStep, stepDuration);
            }
        };

        // Start the sequence
        executeStep();
    }

    /**
     * Starts speech reactivity mode with audio level monitoring
     * @param {AudioContext} audioContext - Web Audio API context
     * @returns {EmotiveMascot} This instance for chaining
     */
    startSpeaking(audioContext) {
        return this.errorBoundary.wrap(() => {
            if (!audioContext) {
                throw new Error('AudioContext is required for speech reactivity');
            }
            
            if (!this.config.enableAudio) {
                // Audio is disabled, cannot start speech reactivity
                return this;
            }
            
            if (this.speaking) {
                // Speech reactivity is already active
                return this;
            }
            
            // Initialize audio level processor
            const success = this.audioLevelProcessor.initialize(audioContext);
            
            if (!success) {
                // Failed to initialize audio level processor
                return this;
            }
            
            // Update speech state
            this.speaking = true;
            
            // Notify renderer about speech start
            this.renderer.onSpeechStart(audioContext);
            
            // Emit speech start event with analyser for external connection
            this.emit('speechStarted', { 
                audioContext, 
                analyser: this.audioLevelProcessor.getAnalyser(),
                mascot: this
            });
            
            // Speech reactivity started - connect audio source to analyser
            return this;
        }, 'speech-start', this)();
    }

    /**
     * Stops speech reactivity mode and returns to base emotional state
     * @returns {EmotiveMascot} This instance for chaining
     */
    stopSpeaking() {
        return this.errorBoundary.wrap(() => {
            return this.audioHandler.stopSpeaking();
        }, 'speech-stop', this)();
    }

    
    
    /**
     * Start recording state (listening/capturing mode)
     * @returns {EmotiveMascot} This instance for chaining
     */
    startRecording() {
        return this.errorBoundary.wrap(() => {
            if (this.recording) {
                // Already recording
                return this;
            }
            
            this.recording = true;
            
            // Update renderer if using Emotive style
            if (this.renderer && this.renderer.startRecording) {
                this.renderer.startRecording();
            }
            
            // Emit recording started event
            this.emit('recordingStarted');
            
            // Recording started
            return this;
        }, 'recording-start', this)();
    }
    
    /**
     * Stop recording state
     * @returns {EmotiveMascot} This instance for chaining
     */
    stopRecording() {
        return this.errorBoundary.wrap(() => {
            if (!this.recording) {
                // Not currently recording
                return this;
            }
            
            this.recording = false;
            
            // Update renderer if using Emotive style
            if (this.renderer && this.renderer.stopRecording) {
                this.renderer.stopRecording();
            }
            
            // Emit recording stopped event
            this.emit('recordingStopped');
            
            // Recording stopped
            return this;
        }, 'recording-stop', this)();
    }
    
    /**
     * Enter sleep state with animation sequence
     * @returns {EmotiveMascot} This instance for chaining
     */
    sleep() {
        return this.errorBoundary.wrap(async () => {
            if (this.sleeping) {
                // Already sleeping
                return this;
            }
            
            // Sleep entry animation sequence
            // Starting sleep sequence...
            
            // First: Yawn
            this.express('yawn');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Second: Drowsy sway
            this.express('sway');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Now enter sleep state
            this.sleeping = true;
            
            // Update renderer if using Emotive style (handles eye closing)
            if (this.renderer && this.renderer.enterSleepMode) {
                this.renderer.enterSleepMode();
            }
            
            // Update idle behavior if available
            if (this.idleBehavior && this.idleBehavior.enterSleep) {
                this.idleBehavior.enterSleep();
            }
            
            // Emit sleep event
            this.emit('sleep');
            
            // Mascot entered sleep state
            return this;
        }, 'sleep', this)();
    }
    
    /**
     * Wake up from sleep state with animation sequence
     * @returns {EmotiveMascot} This instance for chaining
     */
    wake() {
        return this.errorBoundary.wrap(async () => {
            if (!this.sleeping) {
                // Not currently sleeping
                return this;
            }
            
            // Exit sleep state first
            this.sleeping = false;
            
            // Update renderer if using Emotive style (handles eye opening)
            if (this.renderer && this.renderer.wakeUp) {
                this.renderer.wakeUp();
            }
            
            // Update idle behavior if available
            if (this.idleBehavior && this.idleBehavior.wakeUp) {
                this.idleBehavior.wakeUp();
            }
            
            // Wake animation sequence
            // Starting wake sequence...
            
            // First: Stretch
            this.express('stretch');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Second: Slow blink
            this.express('slowBlink');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Third: Small shake to fully wake
            this.express('shake');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Emit wake event
            this.emit('wake');
            
            // Mascot fully awake
            return this;
        }, 'wake', this)();
    }
    
    /**
     * Gets available TTS voices
     * @returns {Array} Array of available voice objects
     */
    getTTSVoices() {
        if (!this.tts.available) {
            return [];
        }
        
        return window.speechSynthesis.getVoices();
    }
    
    /**
     * Checks if TTS is currently speaking
     * @returns {boolean} True if currently speaking
     */
    isTTSSpeaking() {
        return this.tts.speaking;
    }

    /**
     * Starts the animation loop at target 60 FPS
     * @returns {EmotiveMascot} This instance for chaining
     */
    start() {
        return this.errorBoundary.wrap(() => {
            return this.visualizationRunner.start();
        }, 'start', this)();
    }

    /**
     * Stops the animation loop and cleans up resources
     * @returns {EmotiveMascot} This instance for chaining
     */
    stop() {
        return this.errorBoundary.wrap(() => {
            return this.visualizationRunner.stop();
        }, 'stop', this)();
    }



    /**
     * Sets a breathing pattern for the orb
     * @param {number} inhale - Inhale duration in seconds
     * @param {number} hold1 - Hold after inhale in seconds
     * @param {number} exhale - Exhale duration in seconds
     * @param {number} hold2 - Hold after exhale in seconds
     * @returns {EmotiveMascot} This instance for chaining
     */
    setBreathePattern(inhale, hold1, exhale, hold2) {
        return this.errorBoundary.wrap(() => {
            // Calculate total cycle time
            const totalCycle = inhale + hold1 + exhale + hold2;
            
            // Store pattern for custom animation
            this.breathePattern = {
                inhale,
                hold1,
                exhale,
                hold2,
                totalCycle,
                currentPhase: 'inhale',
                phaseStartTime: Date.now(),
                phaseProgress: 0
            };
            
            // Start custom breathing animation
            this.startBreathingAnimation();
            
            return this;
        }, 'setBreathePattern', this)();
    }
    
    /**
     * Directly sets the orb scale with animation
     * @param {number} scale - Target scale (1.0 = normal)
     * @param {number} duration - Animation duration in milliseconds
     * @param {string} easing - Easing function ('linear', 'ease', 'easeIn', 'easeOut', 'easeInOut')
     * @returns {EmotiveMascot} This instance for chaining
     */
    setOrbScale(scale, duration = 1000, easing = 'easeInOut') {
        return this.errorBoundary.wrap(() => {
            if (this.renderer) {
                // Create scale animation
                const startScale = this.currentOrbScale || 1.0;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Apply easing
                    let easedProgress = progress;
                    if (easing === 'easeIn') {
                        easedProgress = progress * progress;
                    } else if (easing === 'easeOut') {
                        easedProgress = progress * (2 - progress);
                    } else if (easing === 'easeInOut') {
                        easedProgress = progress < 0.5
                            ? 2 * progress * progress
                            : -1 + (4 - 2 * progress) * progress;
                    }
                    
                    // Calculate current scale
                    this.currentOrbScale = startScale + (scale - startScale) * easedProgress;
                    
                    // Apply to renderer
                    if (this.renderer.setCustomScale) {
                        this.renderer.setCustomScale(this.currentOrbScale);
                    }
                    
                    // Continue animation
                    if (progress < 1 && this.isRunning) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            return this;
        }, 'setOrbScale', this)();
    }
    
    /**
     * Applies a preset breathing pattern
     * @param {string} type - Preset type: 'calm', 'anxious', 'meditative', 'deep'
     * @returns {EmotiveMascot} This instance for chaining
     */
    breathe(type = 'calm') {
        return this.errorBoundary.wrap(() => {
            const presets = {
                calm: { inhale: 4, hold1: 0, exhale: 4, hold2: 0 },        // 4-4 breathing
                anxious: { inhale: 2, hold1: 0, exhale: 2, hold2: 0 },    // Quick shallow
                meditative: { inhale: 4, hold1: 7, exhale: 8, hold2: 0 }, // 4-7-8 breathing
                deep: { inhale: 5, hold1: 5, exhale: 5, hold2: 5 },       // Box breathing
                sleep: { inhale: 6, hold1: 0, exhale: 8, hold2: 2 }       // Sleep breathing
            };
            
            const pattern = presets[type] || presets.calm;
            return this.setBreathePattern(pattern.inhale, pattern.hold1, pattern.exhale, pattern.hold2);
        }, 'breathe', this)();
    }
    
    /**
     * Starts the custom breathing animation
     * @private
     */
    startBreathingAnimation() {
        // Cancel any existing breathing animation
        if (this.breathingAnimationId) {
            cancelAnimationFrame(this.breathingAnimationId);
        }
        
        const animate = () => {
            if (!this.breathePattern || !this.isRunning) return;
            
            const pattern = this.breathePattern;
            const now = Date.now();
            const phaseElapsed = (now - pattern.phaseStartTime) / 1000; // Convert to seconds
            
            let scale = 1.0;
            let nextPhase = pattern.currentPhase;
            
            // Determine current phase and scale
            switch (pattern.currentPhase) {
            case 'inhale':
                if (phaseElapsed >= pattern.inhale) {
                    nextPhase = 'hold1';
                    pattern.phaseStartTime = now;
                    this.emit('hold-start', { type: 'post-inhale' });
                } else {
                    // Scale up during inhale
                    const progress = phaseElapsed / pattern.inhale;
                    scale = 1.0 + (0.3 * progress); // Expand to 1.3x
                }
                break;
                    
            case 'hold1':
                if (phaseElapsed >= pattern.hold1) {
                    nextPhase = 'exhale';
                    pattern.phaseStartTime = now;
                    this.emit('exhale-start');
                }
                scale = 1.3; // Stay expanded
                break;
                    
            case 'exhale':
                if (phaseElapsed >= pattern.exhale) {
                    nextPhase = 'hold2';
                    pattern.phaseStartTime = now;
                    this.emit('hold-start', { type: 'post-exhale' });
                } else {
                    // Scale down during exhale
                    const progress = phaseElapsed / pattern.exhale;
                    scale = 1.3 - (0.4 * progress); // Contract to 0.9x
                }
                break;
                    
            case 'hold2':
                if (phaseElapsed >= pattern.hold2) {
                    nextPhase = 'inhale';
                    pattern.phaseStartTime = now;
                    this.emit('inhale-start');
                }
                scale = 0.9; // Stay contracted
                break;
            }
            
            // Update phase
            if (nextPhase !== pattern.currentPhase) {
                pattern.currentPhase = nextPhase;
            }
            
            // Apply scale to renderer
            if (this.renderer && this.renderer.setCustomScale) {
                this.renderer.setCustomScale(scale);
            }
            
            // Continue animation
            this.breathingAnimationId = requestAnimationFrame(animate);
        };
        
        // Start with inhale
        this.breathePattern.currentPhase = 'inhale';
        this.breathePattern.phaseStartTime = Date.now();
        this.emit('inhale-start');
        animate();
    }
    
    /**
     * Stops any active breathing animation
     * @returns {EmotiveMascot} This instance for chaining
     */
    stopBreathing() {
        return this.errorBoundary.wrap(() => {
            if (this.breathingAnimationId) {
                cancelAnimationFrame(this.breathingAnimationId);
                this.breathingAnimationId = null;
            }
            
            this.breathePattern = null;
            
            // Reset scale
            if (this.renderer && this.renderer.setCustomScale) {
                this.renderer.setCustomScale(1.0);
            }
            
            return this;
        }, 'stopBreathing', this)();
    }
    
    /**
     * Adds an event listener for external integration hooks
     * @param {string} event - Event name
     * @param {Function} callback - Event callback function
     * @returns {EmotiveMascot} This instance for chaining
     */
    on(event, callback) {
        return this.errorBoundary.wrap(() => {
            this.eventManager.on(event, callback);
            return this;
        }, 'event-listener-add', this)();
    }

    /**
     * Removes an event listener
     * @param {string} event - Event name
     * @param {Function} callback - Event callback function to remove
     * @returns {EmotiveMascot} This instance for chaining
     */
    off(event, callback) {
        return this.errorBoundary.wrap(() => {
            this.eventManager.off(event, callback);
            return this;
        }, 'event-listener-remove', this)();
    }

    /**
     * Adds a one-time event listener that removes itself after first execution
     * @param {string} event - Event name
     * @param {Function} callback - Event callback function
     * @returns {EmotiveMascot} This instance for chaining
     */
    once(event, callback) {
        return this.errorBoundary.wrap(() => {
            this.eventManager.once(event, callback);
            return this;
        }, 'event-listener-once', this)();
    }

    /**
     * Removes all listeners for a specific event or all events
     * @param {string|null} event - Event name to clear, or null to clear all
     * @returns {EmotiveMascot} This instance for chaining
     */
    removeAllListeners(event = null) {
        return this.errorBoundary.wrap(() => {
            this.eventManager.removeAllListeners(event);
            return this;
        }, 'event-listeners-clear', this)();
    }

    /**
     * Gets the number of listeners for an event
     * @param {string} event - Event name
     * @returns {number} Number of listeners
     */
    listenerCount(event) {
        return this.eventManager.listenerCount(event);
    }

    /**
     * Gets all registered event names
     * @returns {Array<string>} Array of event names
     */
    getEventNames() {
        return this.eventManager.getEventNames();
    }

    /**
     * Gets comprehensive event system statistics
     * @returns {Object} Event system statistics and monitoring data
     */
    getEventStats() {
        return this.eventManager.getEventStats();
    }

    /**
     * Gets EventManager debugging information
     * @returns {Object} Debug information about the event system
     */
    getEventDebugInfo() {
        return this.eventManager.getDebugInfo();
    }

    /**
     * Gets browser compatibility information
     * @returns {Object} Browser compatibility details
     */
    getBrowserCompatibility() {
        return {
            browser: browserCompatibility.browser,
            features: browserCompatibility.featureDetection.getFeatures(),
            capabilities: browserCompatibility.capabilities,
            appliedPolyfills: browserCompatibility.appliedPolyfills,
            optimizations: browserCompatibility.browserOptimizations.getOptimizations()
        };
    }

    /**
     * Gets degradation manager status and settings
     * @returns {Object|null} Degradation manager information or null if disabled
     */
    getDegradationStatus() {
        if (!this.degradationManager) {
            return null;
        }
        
        return {
            currentLevel: this.degradationManager.getCurrentLevel(),
            availableFeatures: this.degradationManager.getAvailableFeatures(),
            recommendedSettings: this.degradationManager.getRecommendedSettings(),
            performanceStats: this.degradationManager.getPerformanceStats(),
            allLevels: this.degradationManager.getAllLevels()
        };
    }

    /**
     * Manually set degradation level
     * @param {number|string} level - Degradation level index or name
     * @returns {boolean} True if level was set successfully
     */
    setDegradationLevel(level) {
        if (!this.degradationManager) {
            // Degradation manager is not enabled
            return false;
        }
        
        return this.degradationManager.setLevel(level);
    }

    /**
     * Check if a specific feature is available in current degradation level
     * @param {string} feature - Feature name (audio, particles, fullEffects, etc.)
     * @returns {boolean} True if feature is available
     */
    isFeatureAvailable(feature) {
        if (!this.degradationManager) {
            // Fallback to basic feature detection
            const features = browserCompatibility.featureDetection.getFeatures();
            return features[feature] || false;
        }
        
        return this.degradationManager.isFeatureAvailable(feature);
    }

    /**
     * Force canvas context recovery
     * @returns {boolean} True if recovery was successful
     */
    recoverCanvasContext() {
        if (!this.contextRecovery) {
            return false;
        }
        
        return this.contextRecovery.recover();
    }

    /**
     * Check if canvas context is currently lost
     * @returns {boolean} True if context is lost
     */
    isCanvasContextLost() {
        if (!this.contextRecovery) {
            return false;
        }
        
        return this.contextRecovery.isLost();
    }


    /**
     * Get comprehensive debug report
     * @returns {Object} Debug report including all system states
     */
    getDebugReport() {
        const report = {
            timestamp: Date.now(),
            mascot: {
                isRunning: this.isRunning,
                speaking: this.speaking,
                debugMode: this.debugMode,
                config: this.config
            },
            
            // System states
            currentState: this.getCurrentState(),
            performanceMetrics: this.getPerformanceMetrics(),
            audioStats: this.getAudioStats(),
            eventStats: this.getEventStats(),
            
            // Browser compatibility
            browserCompatibility: this.getBrowserCompatibility(),
            degradationStatus: this.getDegradationStatus(),
            
            // Runtime capabilities
            runtimeCapabilities: runtimeCapabilities.generateReport(),
            
            // Debugger data
            debuggerReport: emotiveDebugger.getDebugReport()
        };

        if (this.debugMode) {
            emotiveDebugger.log('DEBUG', 'Generated debug report', {
                reportSize: JSON.stringify(report).length,
                sections: Object.keys(report)
            });
        }

        return report;
    }

    /**
     * Export debug data for external analysis
     * @returns {Object} Exportable debug data
     */
    exportDebugData() {
        const data = {
            metadata: {
                exportTime: Date.now(),
                version: '1.0.0', // Should be dynamically set
                userAgent: navigator.userAgent,
                url: window.location?.href
            },
            
            mascotState: {
                config: this.config,
                currentState: this.getCurrentState(),
                isRunning: this.isRunning,
                speaking: this.speaking
            },
            
            performance: {
                metrics: this.getPerformanceMetrics(),
                degradationStatus: this.getDegradationStatus(),
                frameTimings: emotiveDebugger.frameTimings
            },
            
            compatibility: {
                browser: this.getBrowserCompatibility(),
                runtimeCapabilities: runtimeCapabilities.generateReport()
            },
            
            debuggerData: emotiveDebugger.exportDebugData()
        };

        if (this.debugMode) {
            emotiveDebugger.log('INFO', 'Exported debug data', {
                dataSize: JSON.stringify(data).length
            });
        }

        return data;
    }

    /**
     * Start profiling a named operation
     * @param {string} name - Profile name
     * @param {Object} metadata - Additional metadata
     */
    startProfiling(name, metadata = {}) {
        if (this.debugMode) {
            emotiveDebugger.startProfile(name, metadata);
        }
    }

    /**
     * End profiling and get results
     * @param {string} name - Profile name
     * @returns {Object|null} Profile results
     */
    endProfiling(name) {
        if (this.debugMode) {
            return emotiveDebugger.endProfile(name);
        }
        return null;
    }

    /**
     * Take a memory snapshot
     * @param {string} label - Snapshot label
     */
    takeMemorySnapshot(label) {
        if (this.debugMode) {
            emotiveDebugger.takeMemorySnapshot(label);
        }
    }

    /**
     * Clear all debug data
     */
    clearDebugData() {
        emotiveDebugger.clear();
        
        if (this.debugMode) {
            emotiveDebugger.log('INFO', 'Debug data cleared');
        }
    }

    /**
     * Get runtime performance capabilities
     * @returns {Object} Runtime capabilities report
     */
    getRuntimeCapabilities() {
        return runtimeCapabilities.generateReport();
    }

    /**
     * Emits an event to all registered listeners with error boundary protection
     * @param {string} event - Event name
     * @param {*} data - Event data
     */
    emit(event, data = null) {
        this.eventManager.emit(event, data);
    }

    /**
     * Updates audio level monitoring (called by AnimationController)
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    update(deltaTime) {
        this.errorBoundary.wrap(() => {
            this.visualizationRunner.update(deltaTime);
        }, 'audio-update')();
    }





    /**
     * Renders the current frame (called by AnimationController)
     */
    render() {
        let deltaTime = 16.67; // Default fallback value
        let renderStart = 0;
        
        try {
            renderStart = this.debugMode ? performance.now() : 0;
            
            // Get deltaTime from animation controller
            deltaTime = this.animationController ? this.animationController.deltaTime : 16.67;
            
            // Prepare render state
            const renderState = {
                properties: this.stateMachine.getCurrentEmotionalProperties(),
                emotion: this.stateMachine.getCurrentState().emotion,
                undertone: this.stateMachine.getCurrentState().undertone,
                particleSystem: this.particleSystem,
                speaking: this.speaking,
                audioLevel: this.audioLevelProcessor.getCurrentLevel(),
                gazeOffset: this.gazeTracker ? this.gazeTracker.currentGaze : { x: 0, y: 0 }
            };
            
            
            // Track frame timing for debugging
            if (this.debugMode) {
                emotiveDebugger.trackFrameTiming(deltaTime);
            }
            
            // Always use EmotiveRenderer
            // Clear canvas ONCE at the beginning
            this.canvasManager.clear();
            
            // Update gaze tracker
            if (this.gazeTracker) {
                this.gazeTracker.update(deltaTime);
            }
            
            // Update threat level for suspicion state based on gaze distance
            if (renderState.emotion === 'suspicion' && this.gazeTracker) {
                const suspicionEmotion = getEmotion('suspicion');
                if (suspicionEmotion && suspicionEmotion.visual) {
                    this.gazeTracker.getState();
                    const {mousePos} = this.gazeTracker;
                    const centerX = this.canvasManager.width / 2;
                    const centerY = this.canvasManager.height / 2 - this.config.topOffset;
                    
                    // Calculate distance from mouse to center
                    const distance = Math.sqrt(
                        Math.pow(mousePos.x - centerX, 2) + 
                        Math.pow(mousePos.y - centerY, 2)
                    );
                    
                    // Maximum distance for threat calculation (canvas diagonal / 3)
                    const maxDist = Math.min(this.canvasManager.width, this.canvasManager.height) / 2;
                    
                    // Closer = higher threat (inverted distance)
                    const threatLevel = Math.max(0, Math.min(1, 1 - (distance / maxDist)));
                    
                    // Update the threat level
                    suspicionEmotion.visual.threatLevel = threatLevel;
                }
            }
            
            // For Emotive style, convert emotion to visual params (AFTER updating threat level)
            const emotionParams = getEmotionVisualParams(renderState.emotion);
            
            this.renderer.setEmotionalState(renderState.emotion, emotionParams, renderState.undertone);
            
            // Always use effective center for particle spawning (with position offsets applied)
            const effectiveCenter = this.renderer.getEffectiveCenter();
            const orbX = effectiveCenter.x;
            let orbY = effectiveCenter.y - this.config.topOffset;

            // Spawn new particles based on emotion at ORB position
            // Get min/max from state machine
            const stateProps = this.stateMachine.getCurrentEmotionalProperties();

            // Apply vertical offset for certain emotions (like excited for exclamation mark)
            if (stateProps.verticalOffset) {
                orbY = effectiveCenter.y - this.config.topOffset + (this.canvasManager.height * stateProps.verticalOffset);
            }
            
            // Apply undertone modifiers to particle behavior
            let particleBehavior = emotionParams.particleBehavior || 'ambient';
            let particleRate = emotionParams.particleRate || 15;
            
            // Debug logging for glitch emotion
            if (renderState.emotion === 'glitch') {
                console.log('🔍 Glitch emotion debug:', {
                    emotion: renderState.emotion,
                    emotionParams,
                    particleBehavior,
                    hasParticleBehavior: 'particleBehavior' in emotionParams,
                    particleBehaviorValue: emotionParams.particleBehavior
                });
            }
            // Use emotionParams min/max if available, otherwise fall back to stateProps
            const minParticles = emotionParams.minParticles !== undefined ? emotionParams.minParticles : (stateProps.minParticles || 0);
            let maxParticles = emotionParams.maxParticles !== undefined ? emotionParams.maxParticles : (stateProps.maxParticles || 10);
            
            
            // Special case for zen: mix falling and orbiting behaviors
            if (renderState.emotion === 'zen') {
                // Randomly choose between falling (sad) and orbiting (love) for each spawn
                particleBehavior = Math.random() < 0.6 ? 'falling' : 'orbiting';
            }
            
            // Check if renderer has undertone overrides
            if (this.renderer.state && this.renderer.state.particleBehaviorOverride) {
                particleBehavior = this.renderer.state.particleBehaviorOverride;
            }
            if (this.renderer.state && this.renderer.state.particleRateMult) {
                particleRate = Math.floor(particleRate * this.renderer.state.particleRateMult);
                maxParticles = Math.floor(maxParticles * this.renderer.state.particleRateMult);
            }
            
            this.particleSystem.spawn(
                particleBehavior,
                renderState.emotion,
                particleRate,
                orbX,
                orbY,
                deltaTime,
                null,  // no forced count
                minParticles,
                maxParticles,
                this.renderer.particleScaleFactor || this.renderer.scaleFactor || 1,  // Use particle-specific scale factor
                this.config.classicConfig?.particleSizeMultiplier || 1,  // Pass particle size multiplier
                emotionParams.particleColors || null,  // Pass emotion colors
                renderState.undertone  // Pass undertone for saturation adjustments
            );
            
            // Debug logging disabled to prevent console spam
            // Uncomment only for debugging particle issues
            // if (!this._particleDebugCounter) this._particleDebugCounter = 0;
            // this._particleDebugCounter++;
            // if (this._particleDebugCounter % 120 === 0) {  // Log every 2 seconds at 60fps
            //     Particle status:
            //         behavior: particleBehavior,
            //         rate: particleRate,
            //         emotion: renderState.emotion,
            //         minParticles,
            //         maxParticles,
            //         currentCount: this.particleSystem.particles.length,
            //         stats: this.particleSystem.getStats(),
            //         position: { x: orbX, y: orbY }
            //     });
            // }
            
            // Get undertone modifier from renderer if present
            const undertoneModifier = this.renderer.getUndertoneModifier ? 
                this.renderer.getUndertoneModifier() : null;
            
            // Add zen vortex intensity to undertone modifier if in zen state
            let particleModifier = undertoneModifier;
            if (renderState.emotion === 'zen' && this.renderer.state.zenVortexIntensity) {
                particleModifier = { ...(undertoneModifier || {}), zenVortexIntensity: this.renderer.state.zenVortexIntensity };
            }
            
            // Get current gesture info from renderer or modular gesture
            let gestureMotion = null;
            let gestureProgress = 0;
            
            // First check for modular gesture
            if (this.currentModularGesture) {
                const elapsed = performance.now() - this.currentModularGesture.startTime;
                gestureProgress = Math.min(elapsed / this.currentModularGesture.duration, 1);
                
                if (gestureProgress >= 1) {
                    // Ensure cleanup happens before clearing gesture
                    gestureMotion = {
                        type: this.currentModularGesture.type,
                        amplitude: 1.0,
                        frequency: 1.0,
                        intensity: 1.0
                    };
                    // Pass progress = 1 to trigger cleanup
                    gestureProgress = 1.0;
                    // Clear gesture on next frame after cleanup
                    if (!this.currentModularGesture.cleanupPending) {
                        this.currentModularGesture.cleanupPending = true;
                    } else {
                        // Cleanup was called last frame, now clear the gesture
                        this.currentModularGesture = null;
                    }
                } else {
                    // Set gesture motion for particles
                    gestureMotion = {
                        type: this.currentModularGesture.type,
                        amplitude: 1.0,
                        frequency: 1.0,
                        intensity: 1.0
                    };
                }
            }
            // Fallback to renderer gesture
            else if (this.renderer && this.renderer.getCurrentGesture) {
                const currentGesture = this.renderer.getCurrentGesture();
                if (currentGesture && currentGesture.particleMotion) {
                    gestureMotion = currentGesture.particleMotion;
                    gestureProgress = currentGesture.progress || 0;
                }
            }
            
            // Update particles with orb position, gesture motion, and modifier
            this.particleSystem.update(deltaTime, orbX, orbY, gestureMotion, gestureProgress, particleModifier);

            // Get gesture transform from renderer
            const gestureTransform = this.renderer.gestureAnimator ?
                this.renderer.gestureAnimator.applyGestureAnimations() : null;

            // Render BACKGROUND particles (behind orb)
            this.particleSystem.renderBackground(this.canvasManager.getContext(), emotionParams.glowColor, gestureTransform);

            // Render the Emotive orb in the MIDDLE layer
            this.renderer.render(renderState, deltaTime, gestureTransform);

            // Render FOREGROUND particles (in front of orb)
            this.particleSystem.renderForeground(this.canvasManager.getContext(), emotionParams.glowColor, gestureTransform);
            
            // Draw debug information if enabled
            if (this.config.showFPS || this.config.showDebug) {
                this.renderDebugInfo(deltaTime);
            }
            
            // Log render performance if debugging
            if (this.debugMode) {
                const renderTime = performance.now() - renderStart;
                if (renderTime > 16.67) { // Longer than 60fps frame
                    emotiveDebugger.log('WARN', 'Slow render frame detected', {
                        renderTime,
                        deltaTime,
                        particleCount: this.particleSystem.getStats().activeParticles
                    });
                }
            }
        } catch (error) {
            this.errorBoundary.logError(error, 'main-render');
        }
    }

    /**
     * Renders debug information overlay
     * @param {number} deltaTime - Time since last frame in milliseconds
     */
    renderDebugInfo(deltaTime) {
        const ctx = this.canvasManager.getContext();
        ctx.save();
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px monospace';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        
        let y = 20;
        const lineHeight = 16;
        
        if (this.config.showFPS) {
            const metrics = this.animationController.getPerformanceMetrics();
            // Use smoothed FPS for stable display
            const fps = metrics.instantFps || metrics.fps || 0;
            const frameTime = metrics.averageFrameTime ? metrics.averageFrameTime.toFixed(1) : '0.0';
            const particleStats = this.particleSystem.getStats();
            
            // Build simple display
            const lines = [
                `FPS: ${fps}`,
                `Frame: ${frameTime}ms`,
                `Particles: ${particleStats.activeParticles}`
            ];
            
            // Draw each line
            const padding = 8;
            let maxWidth = 0;
            lines.forEach(line => {
                const {width} = ctx.measureText(line);
                if (width > maxWidth) maxWidth = width;
            });
            
            const x = this.canvasManager.width - maxWidth - padding - 10;
            
            // Background box with semi-transparent dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - padding, y - 14, maxWidth + padding * 2, 18 * lines.length + 4);
            
            // Border color based on FPS
            let borderColor;
            if (fps >= 55) {
                borderColor = '#00ff00';  // Green for good FPS
            } else if (fps >= 30) {
                borderColor = '#ffff00';  // Yellow for okay FPS
            } else {
                borderColor = '#ff0000';  // Red for poor FPS
            }
            
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(x - padding, y - 14, maxWidth + padding * 2, 18 * lines.length + 4);
            
            // Draw each line of text
            lines.forEach((line, i) => {
                const lineY = y + (i * lineHeight);
                // No stroke for cleaner look
                ctx.fillStyle = '#ffffff';
                ctx.fillText(line, x, lineY);
            });
            
            y += lineHeight * lines.length;
        }
        
        if (this.config.showDebug) {
            const state = this.stateMachine.getCurrentState();
            const particleStats = this.particleSystem.getStats();
            
            const debugInfo = [
                `Emotion: ${state.emotion}${state.undertone ? ` (${state.undertone})` : ''}`,
                `Particles: ${particleStats.activeParticles}/${particleStats.maxParticles}`,
                `Gesture: ${this.currentModularGesture ? this.currentModularGesture.type : 'none'}`,
                `Speaking: ${this.speaking ? 'yes' : 'no'}`,
                `Audio Level: ${(this.audioLevel * 100).toFixed(1)}%`
            ];
            
            // Draw debug info with background for readability
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            const debugWidth = Math.max(...debugInfo.map(line => ctx.measureText(line).width));
            ctx.fillRect(8, y - 14, debugWidth + 16, debugInfo.length * lineHeight + 4);
            
            ctx.fillStyle = '#ffffff';
            for (const info of debugInfo) {
                ctx.fillText(info, 10, y);
                y += lineHeight;
            }
        }
        
        ctx.restore();
    }

    /**
     * Gets the current emotional color
     * @returns {string} Hex color for current emotion
     */
    getEmotionalColor() {
        const properties = this.stateMachine.getCurrentEmotionalProperties();
        // Fallback to neutral gray if properties are undefined
        return properties?.primaryColor || '#B0B0B0';
    }

    /**
     * Gets the current emotional state information
     * @returns {Object} Current state with properties
     */
    getCurrentState() {
        return this.stateMachine.getCurrentState();
    }

    /**
     * Gets all available emotions
     * @returns {Array<string>} Array of emotion names
     */
    getAvailableEmotions() {
        return this.stateMachine.getAvailableEmotions();
    }

    /**
     * Gets all available undertones
     * @returns {Array<string>} Array of undertone names
     */
    getAvailableUndertones() {
        return this.stateMachine.getAvailableUndertones();
    }


    /**
     * Gets audio level processing statistics
     * @returns {Object} Audio processing statistics
     */
    getAudioStats() {
        return this.audioLevelProcessor.getStats();
    }

    /**
     * Updates audio level processor configuration
     * @param {Object} config - New configuration options
     */
    updateAudioConfig(config) {
        this.audioLevelProcessor.updateConfig(config);
    }

    /**
     * Gets all available gestures
     * @returns {Array<string>} Array of gesture names
     */
    getAvailableGestures() {
        return [
            'bounce', 'pulse', 'shake', 'spin', 'drift', 
            'nod', 'tilt', 'expand', 'contract', 'flash',
            'stretch', 'glow', 'flicker', 'vibrate', 'wave',
            'morph', 'slowBlink', 'look', 'settle',
            'breathIn', 'breathOut', 'breathHold', 'breathHoldEmpty', 'jump'
        ];
    }

    /**
     * Connects an audio source to the speech analyser
     * @param {AudioNode} audioSource - Web Audio API source node
     * @returns {EmotiveMascot} This instance for chaining
     */
    connectAudioSource(audioSource) {
        return this.errorBoundary.wrap(() => {
            if (!this.audioAnalyser) {
                // Speech reactivity not started. Call startSpeaking() first.
                return this;
            }
            
            if (!audioSource || typeof audioSource.connect !== 'function') {
                // Invalid audio source provided to connectAudioSource()
                return this;
            }
            
            // Connect the audio source to our analyser
            audioSource.connect(this.audioAnalyser);
            
            // Audio source connected to speech analyser
            this.emit('audioSourceConnected', { audioSource });
            
            return this;
        }, 'audio-source-connection', this)();
    }

    /**
     * Sets master volume for all audio output
     * @param {number} volume - Volume level (0.0 to 1.0)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setVolume(volume) {
        return this.errorBoundary.wrap(() => {
            return this.audioHandler.setVolume(volume);
        }, 'volume-setting', this)();
    }

    /**
     * Gets current master volume
     * @returns {number} Current volume level (0.0 to 1.0)
     */
    getVolume() {
        return this.config.masterVolume;
    }

    /**
     * Enable or disable gesture sounds
     * @param {boolean} enabled - Whether to enable gesture sounds
     * @returns {EmotiveMascot} This instance for chaining
     */
    setSoundEnabled(enabled) {
        this.config.soundEnabled = enabled;
        return this;
    }

    /**
     * Check if gesture sounds are enabled
     * @returns {boolean} Whether gesture sounds are enabled
     */
    isSoundEnabled() {
        return this.config.soundEnabled;
    }

    /**
     * Pauses the animation loop (can be resumed with start())
     * @returns {EmotiveMascot} This instance for chaining
     */
    pause() {
        return this.errorBoundary.wrap(() => {
            if (!this.animationController.isAnimating()) {
                // EmotiveMascot is not running
                return this;
            }
            
            // Stop animation controller
            this.animationController.stop();
            this.isRunning = false;
            
            // Pause ambient audio
            if (this.soundSystem.isAvailable()) {
                this.soundSystem.stopAmbientTone(200); // Quick fade out
            }
            
            this.emit('paused');
            // EmotiveMascot paused
            return this;
        }, 'pause', this)();
    }

    /**
     * Resumes the animation loop from paused state
     * @returns {EmotiveMascot} This instance for chaining
     */
    resume() {
        return this.errorBoundary.wrap(() => {
            if (this.animationController.isAnimating()) {
                // EmotiveMascot is already running
                return this;
            }
            
            // Start animation controller
            this.animationController.start();
            this.isRunning = true;
            
            // Resume ambient audio
            // Update ambient tone based on emotional state - DISABLED (annoying)
            // if (this.soundSystem.isAvailable()) {
            //     const currentEmotion = this.stateMachine.getCurrentState().emotion;
            //     this.soundSystem.setAmbientTone(currentEmotion, 200);
            // }
            
            this.emit('resumed');
            // EmotiveMascot resumed
            return this;
        }, 'resume', this)();
    }

    /**
     * Checks if the mascot is currently running
     * @returns {boolean} True if animation loop is active
     */
    isActive() {
        return this.animationController.isAnimating();
    }

    /**
     * Sets the target FPS for performance monitoring
     * @param {number} targetFPS - Target frames per second (default: 60)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setTargetFPS(targetFPS) {
        const clampedFPS = Math.max(15, Math.min(120, targetFPS)); // Clamp between 15-120 FPS
        this.config.targetFPS = clampedFPS;
        this.animationController.setTargetFPS(clampedFPS);
        
        // Target FPS set
        this.emit('targetFPSChanged', { targetFPS: clampedFPS });
        
        return this;
    }

    /**
     * Gets the current target FPS
     * @returns {number} Target frames per second
     */
    getTargetFPS() {
        return this.animationController.targetFPS;
    }

    /**
     * Set mascot position offset from viewport center
     * @param {number} x - X offset from center
     * @param {number} y - Y offset from center
     * @param {number} z - Z offset for scaling (optional)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setPosition(x, y, z = 0) {
        if (this.positionController) {
            // Ensure onUpdate callback exists
            if (!this.positionController.onUpdate) {
                this.positionController.onUpdate = () => {};
            }
            this.positionController.setOffset(x, y, z);
        }
        return this;
    }

    /**
     * Animate mascot to position offset from viewport center
     * @param {number} x - Target X offset from center
     * @param {number} y - Target Y offset from center
     * @param {number} z - Target Z offset for scaling (optional)
     * @param {number} duration - Animation duration in milliseconds
     * @param {string} easing - Easing function name (optional)
     * @returns {EmotiveMascot} This instance for chaining
     */
    animateToPosition(x, y, z = 0, duration = 1000, easing = 'easeOutCubic') {
        if (this.positionController) {
            // Ensure onUpdate callback exists
            if (!this.positionController.onUpdate) {
                this.positionController.onUpdate = () => {};
            }
            this.positionController.animateOffset(x, y, z, duration, easing);
        }
        return this;
    }

    /**
     * Clear all particles from the particle system
     * Useful when repositioning mascot to remove particles from old position
     * @returns {EmotiveMascot} This instance for chaining
     */
    clearParticles() {
        if (this.particleSystem) {
            this.particleSystem.clear();
        }
        return this;
    }

    /**
     * Forces performance degradation mode (for testing)
     * @param {boolean} enabled - Whether to enable degradation mode
     * @returns {EmotiveMascot} This instance for chaining
     */
    setPerformanceDegradation(enabled) {
        const metrics = this.animationController.getPerformanceMetrics();
        
        if (enabled && !metrics.performanceDegradation) {
            const currentMax = this.particleSystem.maxParticles;
            const newMax = Math.max(5, Math.floor(currentMax * 0.5));
            this.particleSystem.setMaxParticles(newMax);
            
            // Forced performance degradation
        } else if (!enabled && metrics.performanceDegradation) {
            this.particleSystem.setMaxParticles(this.config.maxParticles);
            
            // Disabled performance degradation
        }
        
        return this;
    }

    /**
     * Gets the current audio level (0-1) if speech reactivity is active
     * @returns {number} Current audio level or 0 if not speaking
     */
    getAudioLevel() {
        return this.speaking ? this.audioLevel : 0;
    }

    /**
     * Checks if speech reactivity is currently active
     * @returns {boolean} True if speech monitoring is active
     */
    isSpeaking() {
        return this.speaking;
    }

    /**
     * Sets the audio analyser smoothing time constant
     * @param {number} smoothing - Smoothing value (0-1, default: 0.8)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setAudioSmoothing(smoothing) {
        return this.errorBoundary.wrap(() => {
            const clampedSmoothing = Math.max(0, Math.min(1, smoothing));
            
            if (this.audioAnalyser) {
                this.audioAnalyser.smoothingTimeConstant = clampedSmoothing;
                // Audio smoothing set
            }
            
            return this;
        }, 'audio-smoothing', this)();
    }

    /**
     * Gets comprehensive system status for debugging and monitoring
     * @returns {Object} Complete system status
     */
    getSystemStatus() {
        return this.errorBoundary.wrap(() => {
            const state = this.stateMachine.getCurrentState();
            const particleStats = this.particleSystem.getStats();
            const rendererStats = this.renderer.getStats();
            
            const animationMetrics = this.animationController.getPerformanceMetrics();
            
            return {
                // Core status
                isRunning: animationMetrics.isRunning,
                fps: animationMetrics.fps,
                targetFPS: animationMetrics.targetFPS,
                performanceDegradation: animationMetrics.performanceDegradation,
                
                // Emotional state
                emotion: state.emotion,
                undertone: state.undertone,
                isTransitioning: state.isTransitioning,
                transitionProgress: state.transitionProgress,
                
                // Gesture system
                currentGesture: this.renderer?.currentGesture || null,
                gestureActive: this.renderer?.isGestureActive() || false,
                
                // Particle system
                particles: {
                    active: particleStats.activeParticles,
                    max: particleStats.maxParticles,
                    poolEfficiency: particleStats.poolEfficiency
                },
                
                // Audio system
                audioEnabled: this.config.enableAudio,
                soundSystemAvailable: this.soundSystem.isAvailable(),
                speaking: this.speaking,
                audioLevel: this.audioLevel,
                masterVolume: this.config.masterVolume,
                
                // Renderer
                renderer: {
                    gradientCacheSize: rendererStats.gradientCacheSize,
                    breathingPhase: rendererStats.breathingPhase,
                    layers: rendererStats.layers
                },
                
                // Event system
                eventListeners: this.getEventNames().length,
                
                // Error boundary
                errorStats: this.errorBoundary.getErrorStats()
            };
        }, 'system-status', {})();
    }

    /**
     * Enables or disables debug mode
     * @param {boolean} enabled - Whether to enable debug mode
     * @returns {EmotiveMascot} This instance for chaining
     */
    setDebugMode(enabled) {
        this.config.showDebug = !!enabled;
        this.config.showFPS = !!enabled;
        
        return this;
    }

    /**
     * Triggers a manual error for testing error boundary
     * @param {string} context - Error context for testing
     * @returns {EmotiveMascot} This instance for chaining
     */
    triggerTestError(context = 'manual-test') {
        return this.errorBoundary.wrap(() => {
            throw new Error(`Test error triggered in context: ${context}`);
        }, context, this)();
    }

    /**
     * Gets current performance metrics
     * @returns {Object} Performance data
     */
    getPerformanceMetrics() {
        const animationMetrics = this.animationController.getPerformanceMetrics();
        const state = this.stateMachine.getCurrentState();
        
        return {
            ...animationMetrics,
            currentEmotion: state.emotion,
            currentUndertone: state.undertone,
            isTransitioning: state.isTransitioning,
            errorStats: this.errorBoundary.getErrorStats()
        };
    }

    /**
     * Register a plugin
     * @param {Object} plugin - Plugin to register
     * @returns {Promise<boolean>} Success status
     */
    registerPlugin(plugin) {
        return this.pluginSystem.registerPlugin(plugin);
    }
    
    /**
     * Set accessibility options
     * @param {Object} options - Accessibility options
     */
    setAccessibility(options) {
        if (options.colorBlindMode) {
            this.accessibilityManager.setColorBlindMode(options.colorBlindMode);
        }
        if (options.reducedMotion !== undefined) {
            this.accessibilityManager.reducedMotionPreferred = options.reducedMotion;
        }
        if (options.highContrast !== undefined) {
            this.accessibilityManager.highContrastEnabled = options.highContrast;
        }
    }
    
    /**
     * Get mobile optimization status
     * @returns {Object} Mobile optimization status
     */
    getMobileStatus() {
        return this.mobileOptimization.getStatus();
    }
    
    /**
     * Get accessibility status
     * @returns {Object} Accessibility status
     */
    getAccessibilityStatus() {
        return this.accessibilityManager.getStatus();
    }
    
    /**
     * Set the emotional state (alias for setEmotion for compatibility)
     * @param {string} newState - The emotion/state to set
     * @returns {EmotiveMascot} This instance for chaining
     */
    setState(newState) {
        return this.setEmotion(newState);
    }
    
    /**
     * Speak text using TTS with synchronized animation
     * @param {string} text - The text to speak
     * @param {Object} options - TTS options
     * @returns {SpeechSynthesisUtterance} The utterance object for additional control
     */
    speak(text, options = {}) {
        // Check if speech synthesis is available
        if (!window.speechSynthesis) {
            // Speech synthesis not available in this browser
            return null;
        }
        
        // Create utterance
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Apply options
        if (options.voice) utterance.voice = options.voice;
        if (options.rate) utterance.rate = options.rate;
        if (options.pitch) utterance.pitch = options.pitch;
        if (options.volume) utterance.volume = options.volume;
        if (options.lang) utterance.lang = options.lang;
        
        // Set up event handlers for animation sync
        utterance.onstart = () => {
            // TTS: Starting speech
            this.setTTSSpeaking(true);
            this.emit('tts:start', { text });
        };
        
        utterance.onend = () => {
            // TTS: Speech ended
            this.setTTSSpeaking(false);
            this.emit('tts:end');
        };
        
        utterance.onerror = event => {
            // TTS: Speech error
            this.setTTSSpeaking(false);
            this.emit('tts:error', { error: event });
        };
        
        utterance.onboundary = event => {
            // Word/sentence boundaries for potential lip-sync
            this.emit('tts:boundary', { 
                name: event.name,
                charIndex: event.charIndex,
                charLength: event.charLength
            });
        };
        
        // Speak the text
        window.speechSynthesis.speak(utterance);
        
        return utterance;
    }
    
    /**
     * Set TTS speaking state (triggers visual animation)
     * @param {boolean} speaking - Whether TTS is speaking
     */
    setTTSSpeaking(speaking) {
        this.ttsSpeaking = speaking;
        
        // Update renderer if using Emotive style
        if (this.renderer && this.renderer.startSpeaking) {
            if (speaking) {
                this.renderer.startSpeaking();
            } else {
                this.renderer.stopSpeaking();
            }
        }
        
        // Also update the speaking flag for compatibility
        this.speaking = speaking;
    }
    
    /**
     * Get available TTS voices
     * @returns {Array} Array of available voices
     */
    getVoices() {
        if (!window.speechSynthesis) {
            return [];
        }
        return window.speechSynthesis.getVoices();
    }
    
    /**
     * Stop any ongoing TTS speech
     */
    stopTTS() {
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
            this.setTTSSpeaking(false);
        }
    }
    
    /**
     * Handle canvas resize events to trigger visual resampling
     * This ensures visuals look crisp at any size
     * @param {number} width - New canvas width
     * @param {number} height - New canvas height
     * @param {number} dpr - Device pixel ratio
     */
    handleResize(width, height, dpr) {
        // EmotiveMascot handleResize
        
        // Force a re-initialization of the offscreen canvas in renderer
        if (this.renderer && this.renderer.initOffscreenCanvas) {
            this.renderer.initOffscreenCanvas();
        }
        
        // Trigger a state update to recalculate all visual parameters
        if (this.stateMachine) {
            const {currentEmotion} = this.stateMachine;
            const {currentUndertone} = this.stateMachine;
            
            // Re-apply current emotion to trigger fresh calculations
            if (currentEmotion) {
                this.stateMachine.setEmotion(currentEmotion);
            }
            
            // Re-apply current undertone if any
            if (currentUndertone && currentUndertone !== 'none') {
                this.stateMachine.setUndertone(currentUndertone);
            }
        }
        
        // Emit resize event for any listeners
        this.emit('resize', { width, height, dpr });
    }
    
    /**
     * Morph the core to a different shape
     * @param {string} shape - Target shape name (circle, heart, star, sun, moon, eclipse, square, triangle)
     * @param {Object} config - Morph configuration
     * @returns {EmotiveMascot} This instance for chaining
     */
    morphTo(shape, config = {}) {
        return this.errorBoundary.wrap(() => {
            if (!this.shapeMorpher) {
                // ShapeMorpher not initialized
                return this;
            }
            
            // Start the morph
            this.shapeMorpher.morphTo(shape, config);
            
            // Pass shape morpher to renderer
            if (this.renderer) {
                this.renderer.shapeMorpher = this.shapeMorpher;
            }
            
            // Emit event
            this.emit('shapeMorphStarted', { from: this.shapeMorpher.currentShape, to: shape });
            
            // Morphing to new shape
            return this;
        }, 'morphTo', this)();
    }
    
    /**
     * Connect audio element for vocal visualization
     * @param {HTMLAudioElement} audioElement - Audio element to analyze
     * @returns {EmotiveMascot} This instance for chaining
     */
    connectAudio(audioElement) {
        return this.errorBoundary.wrap(() => {
            return this.audioHandler.connectAudio(audioElement);
        }, 'connectAudio', this)();
    }
    
    /**
     * Disconnect audio analysis
     * @returns {EmotiveMascot} This instance for chaining
     */
    disconnectAudio() {
        return this.errorBoundary.wrap(() => {
            return this.audioHandler.disconnectAudio();
        }, 'disconnectAudio', this)();
    }
    
    /**
     * Set offset values for eccentric positioning
     * @param {number} x - X offset
     * @param {number} y - Y offset  
     * @param {number} z - Z offset (for pseudo-3D scaling)
     * @returns {EmotiveMascot} This instance for chaining
     */
    setOffset(x, y, z = 0) {
        return this.errorBoundary.wrap(() => {
            this.positionController.setOffset(x, y, z);
            return this;
        }, 'offset-setting', this)();
    }
    
    /**
     * Get current offset values
     * @returns {Object} Current offset {x, y, z}
     */
    getOffset() {
        return this.errorBoundary.wrap(() => {
            return this.positionController.getOffset();
        }, 'offset-getting', this)();
    }
    
    /**
     * Animate to new offset values
     * @param {number} x - Target X offset
     * @param {number} y - Target Y offset
     * @param {number} z - Target Z offset
     * @param {number} duration - Animation duration in ms
     * @param {string} easing - Easing function name
     * @returns {EmotiveMascot} This instance for chaining
     */
    animateOffset(x, y, z = 0, duration = 1000, easing = 'easeOutCubic') {
        return this.errorBoundary.wrap(() => {
            this.positionController.animateOffset(x, y, z, duration, easing);
            return this;
        }, 'offset-animation', this)();
    }
    
    /**
     * Get available shapes for morphing
     * @returns {Array} List of available shape names
     */
    getAvailableShapes() {
        return ShapeMorpher.getAvailableShapes();
    }
    
    /**
     * Destroys the mascot instance and cleans up resources
     */
    destroy() {
        this.errorBoundary.wrap(() => {
            // Stop animation
            this.stop();
            
            // Stop speech reactivity
            if (this.speaking) {
                this.stopSpeaking();
            }
            
            // Destroy animation controller
            if (this.animationController) {
                this.animationController.destroy();
            }
            
            // Destroy position controller
            if (this.positionController) {
                this.positionController.destroy();
            }
            
            // Clean up all subsystems
            if (this.soundSystem) {
                this.soundSystem.cleanup();
            }
            
            if (this.audioLevelProcessor) {
                this.audioLevelProcessor.cleanup();
            }
            
            if (this.particleSystem) {
                this.particleSystem.destroy();
            }
            
            if (this.renderer) {
                // Stop all active gestures
                this.renderer.stopAllGestures();
                this.renderer.destroy();
            }
            
            if (this.canvasManager) {
                this.canvasManager.destroy();
            }
            
            // Clear event listeners
            if (this.eventManager) {
                this.eventManager.destroy();
            }
            
            // Destroy new systems
            if (this.accessibilityManager) {
                this.accessibilityManager.destroy();
            }
            
            if (this.mobileOptimization) {
                this.mobileOptimization.destroy();
            }
            
            if (this.pluginSystem) {
                this.pluginSystem.destroy();
            }
            
            // Clean up shape morpher and audio analyzer
            if (this.audioAnalyzer) {
                this.disconnectAudio();
                this.audioAnalyzer.destroy();
            }
            
            if (this.shapeMorpher) {
                this.shapeMorpher.reset();
            }
            
            // DegradationManager removed
            
            // Clear error boundary
            this.errorBoundary.clearErrors();
            
            // EmotiveMascot destroyed
        }, 'destruction')();
    }
    
    /**
     * Throttled warning to reduce console spam
     * @param {string} message - Warning message
     * @param {string} key - Unique key for this warning type
     */
    throttledWarn(message, key) {
        const now = Date.now();
        const lastWarning = this.warningTimestamps[key] || 0;
        
        if (now - lastWarning > this.warningThrottle) {
            // Warning message throttled
            this.warningTimestamps[key] = now;
        }
    }
}

/**
 * EmotiveMascotPublic - Public API wrapper for Emotive Engine
 * Provides safe, controlled access to engine functionality
 * @module EmotiveMascotPublic
 */


class EmotiveMascotPublic {
    constructor(config = {}) {
        // Store config for later initialization
        this._config = this._sanitizeConfig(config);
        this._engine = null;
        this._timeline = [];
        this._isRecording = false;
        this._recordingStartTime = 0;
        this._playbackStartTime = 0;
        this._isPlaying = false;
        this._audioBlob = null;
        this._audioDuration = 0;
        this._initialized = false;
        
        // Bind public methods
        this.init = this.init.bind(this);
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this.pause = this.pause.bind(this);
        this.resume = this.resume.bind(this);
        this.setPosition = this.setPosition.bind(this);
        this.animateToPosition = this.animateToPosition.bind(this);
        this.clearParticles = this.clearParticles.bind(this);
    }

    /**
     * Get real engine for internal use
     * @private
     */
    _getReal() {
        return this._realEngine || this._engine;
    }
    
    /**
     * Sanitize configuration to prevent access to internal features
     * @private
     */
    _sanitizeConfig(config) {
        const safeConfig = { ...config };
        
        // Remove any debug or internal flags
        delete safeConfig.enableDebug;
        delete safeConfig.enableInternalAPIs;
        delete safeConfig.exposeInternals;
        
        // Force production mode
        safeConfig.mode = 'production';
        
        // Enable gaze tracking by default
        if (safeConfig.enableGazeTracking === undefined) {
            safeConfig.enableGazeTracking = true;
        }
        
        return safeConfig;
    }

    /**
     * Initialize the engine
     * @param {HTMLCanvasElement} canvas - Canvas element to render to
     * @returns {Promise<void>}
     */
    init(canvas) {
        if (this._initialized) {
            return Promise.resolve();
        }

        try {
            // Create engine instance with canvas
            const engineConfig = {
                ...this._config,
                canvasId: canvas  // This accepts either string ID or element
            };

            // Create and initialize the engine - wrap in protective proxy
            const engine = new EmotiveMascot(engineConfig);

            // Keep real engine reference for internal use (hidden from external access)
            Object.defineProperty(this, '_realEngine', {
                value: engine,
                writable: false,
                enumerable: false,  // Hide from Object.keys()
                configurable: false
            });

            // Create a protective proxy that hides internal components
            this._engine = new Proxy(engine, {
            get(target, prop) {
                // Block access to sensitive internal components
                const blockedProps = [
                    'soundSystem', 'stateMachine', 'emotionLibrary',
                    'audioLevelProcessor', 'particleSystem', 'errorBoundary',
                    'performanceMonitor', 'config', 'debugMode'
                ];
                
                if (blockedProps.includes(prop)) {
                    // Return a dummy object that looks empty
                    return new Proxy({}, {
                        get() { return undefined; },
                        set() { return false; },
                        has() { return false; },
                        ownKeys() { return []; },
                        getOwnPropertyDescriptor() { return undefined; }
                    });
                }
                
                // For allowed components, wrap them too
                if (prop === 'renderer' || prop === 'shapeMorpher' || 
                    prop === 'audioAnalyzer' || prop === 'gazeTracker') {
                    const component = target[prop];
                    if (!component) return undefined;
                    
                    // Return wrapped version that hides internals
                    return new Proxy(component, {
                        get(compTarget, compProp) {
                            // Only expose essential methods
                            const allowedMethods = {
                                'renderer': ['setBlinkingEnabled'],
                                'shapeMorpher': ['resetMusicDetection', 'frequencyData'],
                                'audioAnalyzer': ['microphoneStream', 'currentFrequencies'],
                                'gazeTracker': ['enable', 'disable', 'mousePos', 'updateTargetGaze', 'currentGaze', 'getState']
                            };
                            
                            if (allowedMethods[prop]?.includes(compProp)) {
                                return compTarget[compProp];
                            }
                            return undefined;
                        },
                        set() { return false; },
                        has() { return false; },
                        ownKeys() { return []; }
                    });
                }
                
                // Allow safe methods
                return target[prop];
            },
            set() {
                return false; // Prevent any modifications
            },
            has(target, prop) {
                // Hide internal properties from 'in' operator
                const blockedProps = ['soundSystem', 'stateMachine', 'emotionLibrary'];
                return !blockedProps.includes(prop) && prop in target;
            },
            ownKeys(target) {
                // Hide internal properties from Object.keys()
                const allowedKeys = ['canvas', 'start', 'stop', 'pause', 'resume', 
                    'setEmotion', 'morphTo', 'express'];
                return allowedKeys.filter(key => key in target);
            }
        });

            // Store canvas reference
            this.canvas = this._engine.canvas;
            this._initialized = true;

            // The initialize method is synchronous, but we keep async for future compatibility
            return Promise.resolve();
        } catch (error) {
            console.error('Failed to initialize Emotive Engine:', error);
            throw error;
        }
    }

    /**
     * Start the animation engine
     */
    start() {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        engine.start();
    }

    /**
     * Stop the animation engine
     */
    stop() {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        engine.stop();
    }

    /**
     * Pause the animation
     */
    pause() {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        engine.pause();
    }

    /**
     * Resume the animation
     */
    resume() {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        engine.resume();
    }

    // === Audio Management ===

    /**
     * Load audio from URL or Blob
     * @param {string|Blob} source - Audio URL or Blob
     * @returns {Promise<void>}
     */
    async loadAudio(source) {
        if (source instanceof Blob) {
            this._audioBlob = source;
            const audioUrl = URL.createObjectURL(source);
            await this._loadAudioFromUrl(audioUrl);
            URL.revokeObjectURL(audioUrl);
        } else {
            await this._loadAudioFromUrl(source);
        }
    }

    /**
     * Load audio from URL
     * @private
     */
    async _loadAudioFromUrl(url) {
        // Load audio and get duration
        const audio = new Audio(url);
        await new Promise((resolve, reject) => {
            audio.addEventListener('loadedmetadata', () => {
                this._audioDuration = audio.duration * 1000; // Convert to ms
                resolve();
            });
            audio.addEventListener('error', reject);
            audio.load();
        });
        
        // Connect to engine's audio system using real engine reference
        if (this._realEngine && this._realEngine.soundSystem) {
            await this._realEngine.soundSystem.loadAudioFromURL(url);
        }
    }

    /**
     * Get audio analysis data
     * @returns {Object} Audio analysis (beats, tempo, energy)
     */
    getAudioAnalysis() {
        const engine = this._getReal();
        if (!engine || !engine.audioAnalyzer) return null;
        
        return {
            bpm: engine.rhythmIntegration?.getBPM() || 0,
            beats: engine.rhythmIntegration?.getBeatMarkers() || [],
            energy: engine.audioAnalyzer?.getEnergyLevel() || 0,
            frequencies: engine.audioAnalyzer?.getFrequencyData() || []
        };
    }
    
    /**
     * Connect audio element for visualization
     * @param {HTMLAudioElement} audioElement - Audio element to connect
     */
    connectAudio(audioElement) {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        
        if (engine.connectAudio) {
            engine.connectAudio(audioElement);
        }
    }
    
    /**
     * Disconnect audio element
     * @param {HTMLAudioElement} [audioElement] - Audio element to disconnect
     */
    disconnectAudio(audioElement) {
        const engine = this._getReal();
        if (!engine) return;
        
        if (engine.disconnectAudio) {
            engine.disconnectAudio(audioElement);
        }
    }
    
    /**
     * Get spectrum data for visualization
     * @returns {Array} Frequency spectrum data
     */
    getSpectrumData() {
        const engine = this._getReal();
        if (!engine || !engine.audioAnalyzer) return [];
        
        // Get raw frequency data from the analyzer
        if (engine.audioAnalyzer.dataArray) {
            // Convert Uint8Array to regular array and normalize to 0-1
            return Array.from(engine.audioAnalyzer.dataArray).map(v => v / 255);
        }
        
        // Try alternative sources
        if (engine.shapeMorpher && engine.shapeMorpher.frequencyData) {
            return Array.from(engine.shapeMorpher.frequencyData);
        }
        
        return [];
    }
    
    /**
     * Start rhythm sync
     * @param {number} [bpm] - Optional BPM to sync to
     */
    startRhythmSync(bpm) {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        
        if (engine.rhythmIntegration) {
            if (bpm) {
                engine.rhythmIntegration.setBPM(bpm);
            }
            engine.rhythmIntegration.start();
        }
    }
    
    /**
     * Stop rhythm sync
     */
    stopRhythmSync() {
        const engine = this._getReal();
        if (!engine) return;
        
        if (engine.rhythmIntegration) {
            engine.rhythmIntegration.stop();
        }
    }
    
    /**
     * Get performance metrics
     * @returns {Object} Performance data
     */
    getPerformanceMetrics() {
        const engine = this._getReal();
        if (!engine) return { fps: 0, frameTime: 0 };
        
        // Try to get from performance monitor
        if (this._engine.performanceMonitor) {
            return {
                fps: this._engine.performanceMonitor.getCurrentFPS() || 0,
                frameTime: this._engine.performanceMonitor.getAverageFrameTime() || 0,
                particleCount: this._engine.particleSystem?.activeParticles || 0
            };
        }
        
        // Fallback to animation controller
        if (this._engine.animationController) {
            return {
                fps: this._engine.animationController.currentFPS || 0,
                frameTime: 1000 / 60, // Default to 60fps timing
                particleCount: 0
            };
        }
        
        return { fps: 0, frameTime: 0, particleCount: 0 };
    }

    // === Animation Control ===

    /**
     * Trigger a gesture
     * @param {string} gestureName - Name of gesture to trigger
     * @param {number} [timestamp] - Optional timestamp for recording
     */
    triggerGesture(gestureName, timestamp) {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        
        // Record if in recording mode
        if (this._isRecording) {
            const time = timestamp || (Date.now() - this._recordingStartTime);
            this._timeline.push({
                type: 'gesture',
                name: gestureName,
                time
            });
        }
        
        // Trigger in engine
        engine.express(gestureName);
    }

    /**
     * Set emotion state
     * @param {string} emotion - Emotion name
     * @param {string|number|Object} [undertoneOrDurationOrOptions] - Undertone string, duration number, or options object
     * @param {number} [timestamp] - Optional timestamp for recording
     */
    setEmotion(emotion, undertoneOrDurationOrOptions, timestamp) {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');

        // Handle different parameter formats
        let undertone = null;
        let duration = 500; // Default 500ms transition
        let recordTime = timestamp;

        if (typeof undertoneOrDurationOrOptions === 'string') {
            // It's an undertone
            undertone = undertoneOrDurationOrOptions;
        } else if (typeof undertoneOrDurationOrOptions === 'number') {
            // Could be duration or timestamp - check if timestamp param is provided
            if (timestamp !== undefined) {
                // It's duration, timestamp is separate
                duration = undertoneOrDurationOrOptions;
            } else {
                // It's a timestamp (backwards compatibility)
                recordTime = undertoneOrDurationOrOptions;
            }
        } else if (undertoneOrDurationOrOptions && typeof undertoneOrDurationOrOptions === 'object') {
            // It's an options object
            const {undertone: newUndertone, duration: newDuration} = undertoneOrDurationOrOptions;
            undertone = newUndertone;
            if (newDuration !== undefined) duration = newDuration;
        }

        // Record if in recording mode
        if (this._isRecording) {
            const time = recordTime || (Date.now() - this._recordingStartTime);
            this._timeline.push({
                type: 'emotion',
                name: emotion,
                undertone,
                time
            });
        }

        // Set in engine with undertone and duration
        if (undertone) {
            engine.setEmotion(emotion, { undertone }, duration);
        } else {
            engine.setEmotion(emotion, null, duration);
        }
    }

    /**
     * Enable or disable sound
     * @param {boolean} enabled - Whether sound should be enabled
     */
    setSoundEnabled(enabled) {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        
        // Set sound state in the engine's sound system
        if (engine.soundSystem) {
            engine.soundSystem.enabled = enabled;
        }
    }

    /**
     * Set shape
     * @param {string} shape - Shape name
     * @param {Object|number} [configOrTimestamp] - Config object or timestamp for recording
     */
    setShape(shape, configOrTimestamp) {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        
        let config = {};
        let timestamp = undefined;
        
        // Handle parameter overloading
        if (typeof configOrTimestamp === 'number') {
            timestamp = configOrTimestamp;
        } else if (configOrTimestamp && typeof configOrTimestamp === 'object') {
            const {timestamp: newTimestamp, ...restConfig} = configOrTimestamp;
            config = restConfig;
            timestamp = newTimestamp;
        }
        
        // Record if in recording mode
        if (this._isRecording) {
            const time = timestamp || (Date.now() - this._recordingStartTime);
            this._timeline.push({
                type: 'shape',
                name: shape,
                time,
                config
            });
        }
        
        // Set in engine with config for rhythm sync
        if (engine) engine.morphTo(shape, config);
    }

    /**
     * Enable gaze tracking
     */
    enableGazeTracking() {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        if (engine.gazeTracker) {
            engine.gazeTracker.enable();
        }
    }

    /**
     * Disable gaze tracking
     */
    disableGazeTracking() {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        if (engine.gazeTracker) {
            engine.gazeTracker.disable();
        }
    }

    /**
     * Set gaze target position
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     */
    setGazeTarget(x, y) {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        if (engine.gazeTracker) {
            // Update the mouse position directly
            engine.gazeTracker.mousePos = { x, y };
            engine.gazeTracker.updateTargetGaze();
        }
    }

    /**
     * Set mascot position offset from viewport center
     * @param {number} x - X offset from center
     * @param {number} y - Y offset from center
     * @param {number} z - Z offset for scaling (optional)
     */
    setPosition(x, y, z = 0) {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        if (engine.positionController) {
            // Ensure onUpdate callback exists
            if (!engine.positionController.onUpdate) {
                engine.positionController.onUpdate = () => {};
            }
            engine.positionController.setOffset(x, y, z);
        }
    }

    /**
     * Animate mascot to position offset from viewport center
     * @param {number} x - Target X offset from center
     * @param {number} y - Target Y offset from center
     * @param {number} z - Target Z offset for scaling (optional)
     * @param {number} duration - Animation duration in milliseconds
     * @param {string} easing - Easing function name (optional)
     */
    animateToPosition(x, y, z = 0, duration = 1000, easing = 'easeOutCubic') {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        if (engine.positionController) {
            // Ensure onUpdate callback exists
            if (!engine.positionController.onUpdate) {
                engine.positionController.onUpdate = () => {};
            }
            engine.positionController.animateOffset(x, y, z, duration, easing);
        }
    }

    /**
     * Clear all particles from the particle system
     * Useful when repositioning mascot to remove particles from old position
     */
    clearParticles() {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        if (engine.particleSystem) {
            engine.particleSystem.clear();
        }
    }

    /**
     * Get gaze tracker state
     * @returns {Object} Gaze state
     */
    getGazeState() {
        const engine = this._getReal();
        if (!engine) throw new Error('Engine not initialized. Call init() first.');
        if (engine.gazeTracker) {
            return engine.gazeTracker.getState();
        }
        return null;
    }

    /**
     * Set BPM manually
     * @param {number} bpm - Beats per minute
     */
    setBPM(bpm) {
        const engine = this._getReal();
        if (engine && engine.rhythmIntegration) {
            engine.rhythmIntegration.setBPM(bpm);
        }
    }

    /**
     * Set quality level for performance
     * @param {string} level - 'low', 'medium', 'high'
     */
    setQuality(level) {
        const qualityMap = {
            'low': { particleCount: 50, fps: 30 },
            'medium': { particleCount: 100, fps: 60 },
            'high': { particleCount: 200, fps: 60 }
        };

        const settings = qualityMap[level] || qualityMap['medium'];

        if (this._engine.performanceMonitor) {
            this._engine.performanceMonitor.setTargetFPS(settings.fps);
        }

        if (this._engine.particleSystem) {
            this._engine.particleSystem.setMaxParticles(settings.particleCount);
        }
    }

    // ═══════════════════════════════════════════════════════════════════
    // EXTENDED PUBLIC API
    // ═══════════════════════════════════════════════════════════════════

    /**
     * Set maximum number of particles
     * @param {number} maxParticles - Maximum particle count
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    setMaxParticles(maxParticles) {
        const engine = this._getReal();
        if (engine && engine.particleSystem) {
            engine.particleSystem.setMaxParticles(maxParticles);
        }
        return this;
    }

    /**
     * Get current particle count
     * @returns {number} Current number of active particles
     */
    getParticleCount() {
        const engine = this._getReal();
        if (engine && engine.particleSystem && engine.particleSystem.particles) {
            return engine.particleSystem.particles.length;
        }
        return 0;
    }

    /**
     * Set mascot opacity
     * @param {number} opacity - Opacity value (0.0 to 1.0)
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    setOpacity(opacity) {
        const engine = this._getReal();
        opacity = Math.max(0, Math.min(1, opacity));

        if (engine && engine.renderer) {
            // Store opacity on canvas context
            const ctx = engine.canvasManager?.getContext();
            if (ctx) {
                ctx.globalAlpha = opacity;
            }
        }

        this._currentOpacity = opacity;
        return this;
    }

    /**
     * Get current opacity
     * @returns {number} Current opacity value
     */
    getOpacity() {
        return this._currentOpacity !== undefined ? this._currentOpacity : 1.0;
    }

    /**
     * Fade in the mascot
     * @param {number} duration - Fade duration in ms (default 1000)
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    fadeIn(duration = 1000) {
        const startOpacity = this.getOpacity();
        const startTime = performance.now();

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const opacity = startOpacity + (1.0 - startOpacity) * progress;

            this.setOpacity(opacity);

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        requestAnimationFrame(animate);
        return this;
    }

    /**
     * Fade out the mascot
     * @param {number} duration - Fade duration in ms (default 1000)
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    fadeOut(duration = 1000) {
        const startOpacity = this.getOpacity();
        const startTime = performance.now();

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const opacity = startOpacity * (1 - progress);

            this.setOpacity(opacity);

            if (progress < 1) {
                requestAnimationFrame(animate);
            }
        };

        requestAnimationFrame(animate);
        return this;
    }

    /**
     * Set core color
     * @param {string} color - Hex color code (e.g., '#FFFFFF')
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    setColor(color) {
        const engine = this._getReal();
        if (engine && engine.renderer && engine.renderer.config) {
            engine.renderer.config.coreColor = color;
        }
        return this;
    }

    /**
     * Set glow color
     * @param {string} color - Hex color code (e.g., '#667eea')
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    setGlowColor(color) {
        const engine = this._getReal();
        if (engine && engine.renderer && engine.renderer.config) {
            engine.renderer.config.defaultGlowColor = color;
        }
        return this;
    }

    /**
     * Set color theme (sets both core and glow colors)
     * @param {Object} theme - Theme object with { core, glow } properties
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    setTheme(theme) {
        if (theme.core) {
            this.setColor(theme.core);
        }
        if (theme.glow) {
            this.setGlowColor(theme.glow);
        }
        return this;
    }

    /**
     * Set animation speed multiplier
     * @param {number} speed - Speed multiplier (1.0 = normal, 2.0 = double speed, 0.5 = half speed)
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    setSpeed(speed) {
        this._getReal();
        speed = Math.max(0.1, Math.min(10, speed));

        // Store speed multiplier for potential future use
        this._speedMultiplier = speed;

        // Note: Actual speed control would need deeper engine integration
        // This is a placeholder for the API surface
        return this;
    }

    /**
     * Get current speed multiplier
     * @returns {number} Current speed multiplier
     */
    getSpeed() {
        return this._speedMultiplier || 1.0;
    }

    /**
     * Set target FPS
     * @param {number} fps - Target frames per second (default 60)
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    setFPS(fps) {
        const engine = this._getReal();
        fps = Math.max(1, Math.min(120, fps));

        if (engine && engine.animationController) {
            engine.animationController.setTargetFPS(fps);
        }

        return this;
    }

    /**
     * Get current target FPS
     * @returns {number} Target FPS
     */
    getFPS() {
        const engine = this._getReal();
        if (engine && engine.animationController) {
            return engine.animationController.targetFPS || 60;
        }
        return 60;
    }

    /**
     * Check if mascot is paused
     * @returns {boolean} True if paused
     */
    isPaused() {
        const engine = this._getReal();
        if (engine && engine.animationController) {
            return engine.animationController.isPaused === true;
        }
        return false;
    }

    /**
     * Execute multiple updates in a batch for better performance
     * @param {Function} callback - Function containing batch updates
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    batch(callback) {
        // Pause rendering during batch updates
        const wasPaused = this.isPaused();
        if (!wasPaused) {
            this.pause();
        }

        // Execute callback
        if (typeof callback === 'function') {
            callback(this);
        }

        // Resume rendering if it wasn't paused before
        if (!wasPaused) {
            this.resume();
        }

        return this;
    }

    /**
     * Register an event listener
     * @param {string} event - Event name
     * @param {Function} listener - Listener function
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    on(event, listener) {
        const engine = this._getReal();
        if (engine && engine.eventManager) {
            engine.eventManager.on(event, listener);
        }
        return this;
    }

    /**
     * Remove an event listener
     * @param {string} event - Event name
     * @param {Function} listener - Listener function
     * @returns {EmotiveMascotPublic} This instance for chaining
     */
    off(event, listener) {
        const engine = this._getReal();
        if (engine && engine.eventManager) {
            engine.eventManager.off(event, listener);
        }
        return this;
    }

    /**
     * Set global scale multiplier (independent of viewport size)
     * @param {number|Object} scaleOrOptions - Scale factor or options object
     *   - number: Global scale (1.0 = normal, 0.5 = half size, 2.0 = double size)
     *   - object: { global, core, particles } for independent control
     *     - global: Scale both core and particles (backward compatible)
     *     - core: Scale only the core
     *     - particles: Scale only the particles
     * @returns {EmotiveMascotPublic} This instance for chaining
     * @example
     * // Scale everything to 60%
     * mascot.setScale(0.6)
     *
     * // Scale everything using explicit global property
     * mascot.setScale({ global: 0.6 })
     *
     * // Independent control: larger particles, smaller core
     * mascot.setScale({ particles: 1.2, core: 0.8 })
     *
     * // Adjust only particles, keep core unchanged
     * mascot.setScale({ particles: 1.5 })
     */
    setScale(scaleOrOptions) {
        const engine = this._getReal();
        if (engine && engine.positionController) {
            if (typeof scaleOrOptions === 'number') {
                // Backward compatible: number sets global scale
                engine.positionController.setScaleOverrides(scaleOrOptions);
            } else {
                // Options object for independent control
                engine.positionController.setScaleOverrides(scaleOrOptions);
            }

            // Refresh particle pool when particle scale changes
            if (typeof scaleOrOptions === 'object' && scaleOrOptions.particles !== undefined) {
                if (engine.particleSystem && typeof engine.particleSystem.refreshPool === 'function') {
                    engine.particleSystem.refreshPool();
                }
            }
        }
        return this;
    }

    /**
     * Get current scale
     * @returns {number} Current scale factor
     */
    getScale() {
        const engine = this._getReal();
        if (engine && engine.positionController) {
            return engine.positionController.globalScale || 1.0;
        }
        return 1.0;
    }

    // === Timeline Recording ===

    /**
     * Start recording animation sequence
     */
    startRecording() {
        this._timeline = [];
        this._isRecording = true;
        this._recordingStartTime = Date.now();
    }

    /**
     * Stop recording
     * @returns {Array} Recorded timeline
     */
    stopRecording() {
        this._isRecording = false;
        return this._timeline;
    }

    /**
     * Play recorded timeline
     * @param {Array} timeline - Timeline to play
     */
    playTimeline(timeline) {
        if (!timeline || !timeline.length) return;
        
        this._isPlaying = true;
        this._playbackStartTime = Date.now();
        
        // Schedule all events
        timeline.forEach(event => {
            setTimeout(() => {
                if (!this._isPlaying) return;
                
                const engine = this._getReal();
                if (!engine) return;
                
                switch (event.type) {
                case 'gesture':
                    engine.express(event.name);
                    break;
                case 'emotion':
                    engine.setEmotion(event.name);
                    break;
                case 'shape':
                    engine.morphTo(event.name);
                    break;
                }
            }, event.time);
        });
        
        // Stop playback after last event
        const lastEventTime = Math.max(...timeline.map(e => e.time));
        setTimeout(() => {
            this._isPlaying = false;
        }, lastEventTime);
    }

    /**
     * Stop timeline playback
     */
    stopPlayback() {
        this._isPlaying = false;
    }

    /**
     * Get current timeline
     * @returns {Array} Current timeline
     */
    getTimeline() {
        return [...this._timeline];
    }

    /**
     * Load timeline
     * @param {Array} timeline - Timeline to load
     */
    loadTimeline(timeline) {
        this._timeline = [...timeline];
    }

    /**
     * Export timeline as JSON
     * @returns {string} JSON string
     */
    exportTimeline() {
        return JSON.stringify({
            version: '1.0',
            duration: this._audioDuration || 0,
            events: this._timeline
        });
    }

    /**
     * Import timeline from JSON
     * @param {string} json - JSON string
     */
    importTimeline(json) {
        const data = JSON.parse(json);
        this._timeline = data.events || [];
        this._audioDuration = data.duration || 0;
    }

    // === Playback Control ===

    /**
     * Get current playback time
     * @returns {number} Current time in milliseconds
     */
    getCurrentTime() {
        if (this._isPlaying) {
            return Date.now() - this._playbackStartTime;
        }
        return 0;
    }

    /**
     * Seek to specific time
     * @param {number} time - Time in milliseconds
     */
    seek(time) {
        // Find all events up to this time and apply them
        const eventsToApply = this._timeline.filter(e => e.time <= time);
        
        // Apply the last event of each type
        const lastEvents = {};
        eventsToApply.forEach(event => {
            lastEvents[event.type] = event;
        });
        
        // Apply states
        const engine = this._getReal();
        if (engine) {
            if (lastEvents.emotion) {
                engine.setEmotion(lastEvents.emotion.name);
            }
            if (lastEvents.shape) {
                engine.morphTo(lastEvents.shape.name);
            }
        }
    }

    // === Export Capabilities ===

    /**
     * Get current frame as data URL
     * @param {string} [format='png'] - Image format
     * @returns {string} Data URL
     */
    getFrameData(format = 'png') {
        const canvas = this.canvas || this._engine.canvas;
        if (!canvas) return null;
        
        return canvas.toDataURL(`image/${format}`);
    }

    /**
     * Get current frame as Blob
     * @param {string} [format='png'] - Image format
     * @returns {Promise<Blob>} Image blob
     */
    getFrameBlob(format = 'png') {
        const canvas = this.canvas || this._engine.canvas;
        if (!canvas) return null;
        
        return new Promise(resolve => {
            canvas.toBlob(blob => resolve(blob), `image/${format}`);
        });
    }

    /**
     * Export animation data
     * @returns {Object} Animation state
     */
    getAnimationData() {
        return {
            timeline: this._timeline,
            duration: this._audioDuration,
            currentTime: this.getCurrentTime(),
            emotion: this._engine.state?.emotion || 'neutral',
            shape: this._engine.state?.currentShape || 'circle'
        };
    }

    // === Query Methods ===

    /**
     * Get available gestures
     * @returns {Array<string>} List of gesture names
     */
    getAvailableGestures() {
        return [
            // Motion
            'bounce', 'pulse', 'shake', 'spin', 'nod', 'tilt',
            'drift', 'vibrate', 'sway', 'float', 'wave',
            // Transform
            'expand', 'contract', 'stretch', 'morph', 'jump',
            // Effects
            'flash', 'glow', 'flicker',
            // Complex
            'scan', 'hula', 'orbit', 'breathe', 'settle'
        ];
    }

    /**
     * Get available emotions
     * @returns {Array<string>} List of emotion names
     */
    getAvailableEmotions() {
        return [
            'neutral', 'joy', 'sadness', 'anger', 'fear',
            'surprise', 'disgust', 'love', 'euphoria',
            'excited', 'suspicion', 'resting'
        ];
    }

    /**
     * Get available shapes
     * @returns {Array<string>} List of shape names
     */
    getAvailableShapes() {
        return [
            'circle', 'square', 'triangle', 'star',
            'heart', 'moon', 'sun'
        ];
    }

    /**
     * Get engine version
     * @returns {string} Version string
     */
    getVersion() {
        return '2.4.0';
    }

    /**
     * Get engine capabilities
     * @returns {Object} Capabilities object
     */
    getCapabilities() {
        return {
            audio: true,
            recording: true,
            timeline: true,
            export: true,
            shapes: true,
            gestures: true,
            emotions: true,
            particles: true,
            gazeTracking: true
        };
    }

    // Getter properties for components needed by demo - return safe proxies
    get renderer() {
        const engine = this._getReal();
        if (!engine || !engine.renderer) return null;
        
        // Return safe proxy that only exposes necessary methods
        return new Proxy(engine.renderer, {
            get(target, prop) {
                const allowed = ['setBlinkingEnabled'];
                return allowed.includes(prop) ? target[prop] : undefined;
            }
        });
    }

    get shapeMorpher() {
        const engine = this._getReal();
        if (!engine || !engine.shapeMorpher) return null;
        
        // Return safe proxy
        return new Proxy(engine.shapeMorpher, {
            get(target, prop) {
                const allowed = ['resetMusicDetection', 'frequencyData'];
                return allowed.includes(prop) ? target[prop] : undefined;
            }
        });
    }

    get gazeTracker() {
        const engine = this._getReal();
        if (!engine || !engine.gazeTracker) return null;
        
        // Return safe proxy
        return new Proxy(engine.gazeTracker, {
            get(target, prop) {
                const allowed = ['enable', 'disable', 'mousePos', 'updateTargetGaze', 'currentGaze', 'getState'];
                return allowed.includes(prop) ? target[prop] : undefined;
            }
        });
    }

    /**
     * Destroy the engine and clean up resources
     */
    destroy() {
        this.stop();
        this._timeline = [];
        this._isRecording = false;
        this._isPlaying = false;
        
        const engine = this._getReal();
        if (engine && engine.destroy) {
            engine.destroy();
        }
    }
}

/**
 * State Store
 * Centralized state management for the Emotive Engine
 *
 * @module core/StateStore
 * @version 1.0.0
 */

/**
 * Observable state store with immutable updates
 */
class StateStore {
    constructor(initialState = {}) {
        // The actual state object (private)
        this._state = this.deepClone(initialState);

        // Previous state for comparison
        this._prevState = this.deepClone(initialState);

        // Subscribers for state changes
        this._subscribers = new Map();

        // State change history for debugging
        this._history = [];
        this._maxHistorySize = 50;

        // Middleware functions
        this._middleware = [];

        // State validation rules
        this._validators = new Map();

        // Computed values cache
        this._computed = new Map();
        this._computedDeps = new Map();

        // Performance tracking
        this._stats = {
            updates: 0,
            notifications: 0,
            computedCacheHits: 0,
            computedCacheMisses: 0
        };
    }

    /**
     * Get current state or a specific path
     * @param {string} path - Optional dot-notation path (e.g., 'renderer.color')
     * @returns {*} State value
     */
    getState(path = null) {
        if (!path) {
            return this.deepClone(this._state);
        }

        return this.deepClone(this.getNestedValue(this._state, path));
    }

    /**
     * Set state with immutable update
     * @param {string|Object} pathOrUpdates - Path or object with updates
     * @param {*} value - Value if path is provided
     * @returns {boolean} Success status
     */
    setState(pathOrUpdates, value = undefined) {
        let updates;

        // Handle both setState('path', value) and setState({updates})
        if (typeof pathOrUpdates === 'string') {
            updates = { [pathOrUpdates]: value };
        } else {
            updates = pathOrUpdates;
        }

        // Apply middleware
        for (const middleware of this._middleware) {
            updates = middleware(updates, this._state);
            if (!updates) return false; // Middleware can cancel update
        }

        // Create new state
        const newState = this.deepClone(this._state);

        // Apply updates
        for (const [path, val] of Object.entries(updates)) {
            // Validate update
            if (this._validators.has(path)) {
                const validator = this._validators.get(path);
                if (!validator(val)) {
                    console.error(`Validation failed for path: ${path}`);
                    return false;
                }
            }

            this.setNestedValue(newState, path, val);
        }

        // Store previous state
        this._prevState = this._state;
        this._state = newState;

        // Add to history
        this.addToHistory(updates);

        // Invalidate computed values that depend on changed paths
        this.invalidateComputed(Object.keys(updates));

        // Notify subscribers
        this.notifySubscribers(updates);

        // Update stats
        this._stats.updates++;

        return true;
    }

    /**
     * Subscribe to state changes
     * @param {string|Function} pathOrCallback - Path to watch or callback for all changes
     * @param {Function} callback - Callback if path is provided
     * @returns {Function} Unsubscribe function
     */
    subscribe(pathOrCallback, callback = null) {
        let path = null;
        let cb = pathOrCallback;

        if (typeof pathOrCallback === 'string') {
            path = pathOrCallback;
            cb = callback;
        }

        const id = Symbol('subscriber');
        const subscriber = {
            path,
            callback: cb,
            id
        };

        this._subscribers.set(id, subscriber);

        // Return unsubscribe function
        return () => {
            this._subscribers.delete(id);
        };
    }

    /**
     * Create computed value that auto-updates
     * @param {string} name - Computed value name
     * @param {Array} deps - Dependency paths
     * @param {Function} compute - Compute function
     */
    computed(name, deps, compute) {
        this._computedDeps.set(name, deps);

        // Define getter
        Object.defineProperty(this, name, {
            get: () => {
                // Check cache
                if (this._computed.has(name)) {
                    this._stats.computedCacheHits++;
                    return this._computed.get(name);
                }

                // Compute value
                this._stats.computedCacheMisses++;
                const values = deps.map(dep => this.getState(dep));
                const result = compute(...values);

                // Cache result
                this._computed.set(name, result);

                return result;
            }
        });
    }

    /**
     * Add validation rule for a path
     * @param {string} path - State path
     * @param {Function} validator - Validation function
     */
    addValidator(path, validator) {
        this._validators.set(path, validator);
    }

    /**
     * Add middleware for state updates
     * @param {Function} middleware - Middleware function
     */
    addMiddleware(middleware) {
        this._middleware.push(middleware);
    }

    /**
     * Reset to initial state
     * @param {Object} initialState - New initial state
     */
    reset(initialState = {}) {
        this._state = this.deepClone(initialState);
        this._prevState = this.deepClone(initialState);
        this._history = [];
        this._computed.clear();
        this.notifySubscribers({ '*': 'reset' });
    }

    /**
     * Get state diff between current and previous
     * @returns {Object} Diff object
     */
    getDiff() {
        return this.objectDiff(this._prevState, this._state);
    }

    /**
     * Time travel to previous state
     * @param {number} steps - Number of steps back
     */
    undo(steps = 1) {
        if (this._history.length < steps) {
            console.warn('Cannot undo: insufficient history');
            return false;
        }

        // Get state from history
        const targetIndex = Math.max(0, this._history.length - steps - 1);
        const targetEntry = this._history[targetIndex];

        if (targetEntry) {
            this._state = this.deepClone(targetEntry.state);
            this._history = this._history.slice(0, targetIndex + 1);
            this.notifySubscribers({ '*': 'undo' });
            return true;
        }

        return false;
    }

    /**
     * Batch multiple updates
     * @param {Function} updateFn - Function with multiple setState calls
     */
    batch(updateFn) {
        const updates = {};

        // Temporarily override setState to collect updates
        const originalSetState = this.setState.bind(this);
        this.setState = (path, value) => {
            if (typeof path === 'string') {
                updates[path] = value;
            } else {
                Object.assign(updates, path);
            }
            return true;
        };

        // Execute update function
        updateFn();

        // Restore original setState
        this.setState = originalSetState;

        // Apply all updates at once
        return this.setState(updates);
    }

    /**
     * Create a selector for derived state
     * @param {Function} selector - Selector function
     * @returns {Function} Memoized selector
     */
    createSelector(selector) {
        let lastState = null;
        let lastResult = null;

        return () => {
            const currentState = this._state;
            if (currentState === lastState) {
                return lastResult;
            }

            lastState = currentState;
            lastResult = selector(currentState);
            return lastResult;
        };
    }

    // Private helper methods

    /**
     * Notify subscribers of state changes
     * @private
     */
    notifySubscribers(updates) {
        for (const subscriber of this._subscribers.values()) {
            // Check if subscriber cares about these updates
            if (!subscriber.path || Object.keys(updates).some(path =>
                path.startsWith(subscriber.path) || subscriber.path.startsWith(path)
            )) {
                subscriber.callback(this._state, updates);
                this._stats.notifications++;
            }
        }
    }

    /**
     * Invalidate computed values
     * @private
     */
    invalidateComputed(changedPaths) {
        for (const [name, deps] of this._computedDeps.entries()) {
            if (deps.some(dep => changedPaths.some(path =>
                dep.startsWith(path) || path.startsWith(dep)
            ))) {
                this._computed.delete(name);
            }
        }
    }

    /**
     * Add to history
     * @private
     */
    addToHistory(updates) {
        this._history.push({
            timestamp: Date.now(),
            updates,
            state: this.deepClone(this._state)
        });

        // Limit history size
        if (this._history.length > this._maxHistorySize) {
            this._history.shift();
        }
    }

    /**
     * Deep clone an object
     * @private
     */
    deepClone(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof Array) return obj.map(item => this.deepClone(item));
        if (obj instanceof Object) {
            const clonedObj = {};
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    clonedObj[key] = this.deepClone(obj[key]);
                }
            }
            return clonedObj;
        }
    }

    /**
     * Get nested value from object
     * @private
     */
    getNestedValue(obj, path) {
        return path.split('.').reduce((current, key) =>
            current && current[key] !== undefined ? current[key] : undefined, obj);
    }

    /**
     * Set nested value in object
     * @private
     */
    setNestedValue(obj, path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((current, key) => {
            if (!current[key]) current[key] = {};
            return current[key];
        }, obj);
        target[lastKey] = value;
    }

    /**
     * Get object diff
     * @private
     */
    objectDiff(oldObj, newObj) {
        const diff = {};

        // Check for additions and changes
        for (const key in newObj) {
            if (!(key in oldObj)) {
                diff[key] = { type: 'added', value: newObj[key] };
            } else if (JSON.stringify(oldObj[key]) !== JSON.stringify(newObj[key])) {
                diff[key] = {
                    type: 'changed',
                    oldValue: oldObj[key],
                    newValue: newObj[key]
                };
            }
        }

        // Check for deletions
        for (const key in oldObj) {
            if (!(key in newObj)) {
                diff[key] = { type: 'deleted', oldValue: oldObj[key] };
            }
        }

        return diff;
    }

    /**
     * Get statistics
     * @returns {Object} Statistics
     */
    getStats() {
        return {
            ...this._stats,
            subscribers: this._subscribers.size,
            historySize: this._history.length,
            computedValues: this._computed.size,
            validators: this._validators.size
        };
    }
}

// Create singleton instance for the engine
const engineState = new StateStore({
    // Core engine state
    engine: {
        initialized: false,
        running: false,
        paused: false,
        fps: 60,
        frameCount: 0
    },

    // Renderer state
    renderer: {
        color: '#4a90e2',
        intensity: 1.0,
        eyeOpenness: 1.0,
        breathRate: 1.0,
        breathDepth: 1.0,
        sleeping: false,
        zenMode: false
    },

    // Animation state
    animation: {
        currentGesture: null,
        activeLoops: 0
    },

    // Emotion state
    emotion: {
        current: 'neutral',
        intensity: 1.0,
        undertone: null,
        transitioning: false
    },

    // Particle state
    particles: {
        active: true,
        count: 0,
        maxParticles: 100
    },

    // Sound state
    sound: {
        enabled: false,
        volume: 1.0,
        bpm: 120,
        rhythmEnabled: false
    },

    // Performance state
    performance: {
        quality: 'high',
        adaptiveQuality: true,
        targetFPS: 60,
        actualFPS: 60
    }
});

/**
 * Context State Manager
 * Minimizes context save/restore operations and tracks state changes
 *
 * @module core/renderer/ContextStateManager
 * @version 1.0.0
 */

/**
 * Manages canvas context state to minimize redundant operations
 */
class ContextStateManager {
    constructor(ctx) {
        this.ctx = ctx;

        // Current state tracking
        this.currentState = {
            fillStyle: null,
            strokeStyle: null,
            globalAlpha: 1,
            globalCompositeOperation: 'source-over',
            lineWidth: 1,
            lineCap: 'butt',
            lineJoin: 'miter',
            shadowBlur: 0,
            shadowColor: 'transparent',
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            font: '10px sans-serif'
        };

        // State stack for save/restore
        this.stateStack = [];

        // Performance stats
        this.stats = {
            saves: 0,
            restores: 0,
            stateChanges: 0,
            redundantChanges: 0
        };
    }

    /**
     * Set fill style only if different from current
     * @param {string|CanvasGradient|CanvasPattern} style - Fill style
     */
    setFillStyle(style) {
        if (this.currentState.fillStyle !== style) {
            this.ctx.fillStyle = style;
            this.currentState.fillStyle = style;
            this.stats.stateChanges++;
        } else {
            this.stats.redundantChanges++;
        }
    }

    /**
     * Set stroke style only if different from current
     * @param {string|CanvasGradient|CanvasPattern} style - Stroke style
     */
    setStrokeStyle(style) {
        if (this.currentState.strokeStyle !== style) {
            this.ctx.strokeStyle = style;
            this.currentState.strokeStyle = style;
            this.stats.stateChanges++;
        } else {
            this.stats.redundantChanges++;
        }
    }

    /**
     * Set global alpha only if different from current
     * @param {number} alpha - Alpha value (0-1)
     */
    setGlobalAlpha(alpha) {
        if (Math.abs(this.currentState.globalAlpha - alpha) > 0.001) {
            this.ctx.globalAlpha = alpha;
            this.currentState.globalAlpha = alpha;
            this.stats.stateChanges++;
        } else {
            this.stats.redundantChanges++;
        }
    }

    /**
     * Set composite operation only if different from current
     * @param {string} operation - Composite operation
     */
    setGlobalCompositeOperation(operation) {
        if (this.currentState.globalCompositeOperation !== operation) {
            this.ctx.globalCompositeOperation = operation;
            this.currentState.globalCompositeOperation = operation;
            this.stats.stateChanges++;
        } else {
            this.stats.redundantChanges++;
        }
    }

    /**
     * Set line width only if different from current
     * @param {number} width - Line width
     */
    setLineWidth(width) {
        if (Math.abs(this.currentState.lineWidth - width) > 0.001) {
            this.ctx.lineWidth = width;
            this.currentState.lineWidth = width;
            this.stats.stateChanges++;
        } else {
            this.stats.redundantChanges++;
        }
    }

    /**
     * Set shadow properties only if different from current
     * @param {Object} shadow - Shadow properties
     */
    setShadow(blur = 0, color = 'transparent', offsetX = 0, offsetY = 0) {
        let changed = false;

        if (Math.abs(this.currentState.shadowBlur - blur) > 0.001) {
            this.ctx.shadowBlur = blur;
            this.currentState.shadowBlur = blur;
            changed = true;
        }

        if (this.currentState.shadowColor !== color) {
            this.ctx.shadowColor = color;
            this.currentState.shadowColor = color;
            changed = true;
        }

        if (Math.abs(this.currentState.shadowOffsetX - offsetX) > 0.001) {
            this.ctx.shadowOffsetX = offsetX;
            this.currentState.shadowOffsetX = offsetX;
            changed = true;
        }

        if (Math.abs(this.currentState.shadowOffsetY - offsetY) > 0.001) {
            this.ctx.shadowOffsetY = offsetY;
            this.currentState.shadowOffsetY = offsetY;
            changed = true;
        }

        if (changed) {
            this.stats.stateChanges++;
        } else {
            this.stats.redundantChanges++;
        }
    }

    /**
     * Clear shadows efficiently
     */
    clearShadow() {
        if (this.currentState.shadowBlur !== 0 ||
            this.currentState.shadowColor !== 'transparent') {
            this.setShadow(0, 'transparent', 0, 0);
        }
    }

    /**
     * Save current state
     */
    save() {
        this.ctx.save();
        this.stateStack.push({ ...this.currentState });
        this.stats.saves++;
    }

    /**
     * Restore previous state
     */
    restore() {
        this.ctx.restore();
        if (this.stateStack.length > 0) {
            this.currentState = this.stateStack.pop();
        }
        this.stats.restores++;
    }


    /**
     * Get performance statistics
     * @returns {Object} Stats object
     */
    getStats() {
        const totalOperations = this.stats.stateChanges + this.stats.redundantChanges;
        const redundancyRate = totalOperations > 0
            ? (this.stats.redundantChanges / totalOperations * 100).toFixed(2)
            : 0;

        return {
            saves: this.stats.saves,
            restores: this.stats.restores,
            stateChanges: this.stats.stateChanges,
            redundantChanges: this.stats.redundantChanges,
            redundancyRate: `${redundancyRate}%`,
            stackDepth: this.stateStack.length
        };
    }

    /**
     * Reset statistics
     */
    resetStats() {
        this.stats = {
            saves: 0,
            restores: 0,
            stateChanges: 0,
            redundantChanges: 0
        };
    }

    /**
     * Reset context state to defaults
     */
    reset() {
        // Reset tracked state
        this.currentState = {
            fillStyle: null,
            strokeStyle: null,
            globalAlpha: 1,
            globalCompositeOperation: 'source-over',
            lineWidth: 1,
            lineCap: 'butt',
            lineJoin: 'miter',
            shadowBlur: 0,
            shadowColor: 'transparent',
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            font: '10px sans-serif'
        };

        // Clear state stack
        this.stateStack = [];

        // Reset stats
        this.resetStats();
    }

    /**
     * Create a scoped operation that automatically saves/restores
     * @param {Function} operation - Operation to perform
     */
    scoped(operation) {
        this.save();
        try {
            operation();
        } finally {
            this.restore();
        }
    }

    /**
     * Batch multiple state changes together
     * @param {Object} states - Object with state properties to set
     */
    batch(states) {
        if (states.fillStyle !== undefined) {
            this.setFillStyle(states.fillStyle);
        }
        if (states.strokeStyle !== undefined) {
            this.setStrokeStyle(states.strokeStyle);
        }
        if (states.globalAlpha !== undefined) {
            this.setGlobalAlpha(states.globalAlpha);
        }
        if (states.globalCompositeOperation !== undefined) {
            this.setGlobalCompositeOperation(states.globalCompositeOperation);
        }
        if (states.lineWidth !== undefined) {
            this.setLineWidth(states.lineWidth);
        }
        if (states.shadow) {
            this.setShadow(
                states.shadow.blur,
                states.shadow.color,
                states.shadow.offsetX,
                states.shadow.offsetY
            );
        }
    }
}

/**
 * Error tracking and reporting system for the Emotive Engine
 * Captures, categorizes, and reports errors with context
 */

class ErrorTracker {
    constructor(options = {}) {
        this.enabled = options.enabled !== false;
        this.maxErrors = options.maxErrors || 100;
        this.maxStackFrames = options.maxStackFrames || 10;
        this.reportingThreshold = options.reportingThreshold || 10;
        this.reportingInterval = options.reportingInterval || 60000; // 1 minute

        this.errors = [];
        this.errorCounts = new Map();
        this.errorPatterns = new Map();
        this.suppressedErrors = new Set(options.suppressedErrors || []);

        this.metadata = {
            sessionId: this.generateSessionId(),
            startTime: Date.now(),
            userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',
            url: typeof window !== 'undefined' ? window.location.href : 'unknown',
            version: '2.4.0'
        };

        this.callbacks = {
            onError: options.onError || null,
            onReport: options.onReport || null,
            onCritical: options.onCritical || null
        };

        this.severityLevels = {
            LOW: 'low',
            MEDIUM: 'medium',
            HIGH: 'high',
            CRITICAL: 'critical'
        };

        this.errorCategories = {
            RENDERING: 'rendering',
            ANIMATION: 'animation',
            STATE: 'state',
            NETWORK: 'network',
            PLUGIN: 'plugin',
            USER_INPUT: 'user_input',
            PERFORMANCE: 'performance',
            UNKNOWN: 'unknown'
        };

        if (this.enabled) {
            this.attachGlobalHandlers();
            this.startReportingInterval();
        }
    }

    generateSessionId() {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    attachGlobalHandlers() {
        if (typeof window === 'undefined') return;

        // Handle uncaught errors
        this.originalOnError = window.onerror;
        window.onerror = (message, source, lineno, colno, error) => {
            this.captureError(error || new Error(message), {
                source,
                lineno,
                colno,
                uncaught: true
            });

            if (this.originalOnError) {
                return this.originalOnError(message, source, lineno, colno, error);
            }
            return true;
        };

        // Handle unhandled promise rejections
        this.originalOnUnhandledRejection = window.onunhandledrejection;
        window.onunhandledrejection = event => {
            this.captureError(new Error(event.reason), {
                type: 'unhandledRejection',
                promise: event.promise,
                uncaught: true
            });

            if (this.originalOnUnhandledRejection) {
                return this.originalOnUnhandledRejection(event);
            }
        };
    }

    detachGlobalHandlers() {
        if (typeof window === 'undefined') return;

        if (this.originalOnError) {
            window.onerror = this.originalOnError;
        }

        if (this.originalOnUnhandledRejection) {
            window.onunhandledrejection = this.originalOnUnhandledRejection;
        }
    }

    captureError(error, context = {}) {
        if (!this.enabled) return;

        // Check if error should be suppressed
        if (this.shouldSuppress(error)) return;

        const errorInfo = this.processError(error, context);

        // Categorize error
        errorInfo.category = this.categorizeError(error, context);
        errorInfo.severity = this.determineSeverity(error, errorInfo.category);

        // Add to errors array
        this.errors.push(errorInfo);

        // Maintain max errors limit
        if (this.errors.length > this.maxErrors) {
            this.errors.shift();
        }

        // Update error counts
        const errorKey = `${errorInfo.name}:${errorInfo.message}`;
        this.errorCounts.set(errorKey, (this.errorCounts.get(errorKey) || 0) + 1);

        // Detect patterns
        this.detectPatterns(errorInfo);

        // Call error callback
        if (this.callbacks.onError) {
            this.callbacks.onError(errorInfo);
        }

        // Check for critical errors
        if (errorInfo.severity === this.severityLevels.CRITICAL) {
            this.handleCriticalError(errorInfo);
        }

        return errorInfo;
    }

    processError(error, context) {
        const timestamp = Date.now();
        const stack = this.parseStackTrace(error.stack);

        return {
            id: `${timestamp}-${Math.random().toString(36).substr(2, 9)}`,
            timestamp,
            name: error.name || 'Error',
            message: error.message || String(error),
            stack: stack.slice(0, this.maxStackFrames),
            fullStack: error.stack,
            context: {
                ...context,
                url: typeof window !== 'undefined' ? window.location.href : 'unknown',
                userAgent: this.metadata.userAgent,
                sessionId: this.metadata.sessionId
            },
            metadata: this.collectMetadata()
        };
    }

    parseStackTrace(stack) {
        if (!stack) return [];

        const lines = stack.split('\n');
        const frames = [];

        for (const line of lines) {
            const match = line.match(/at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/);
            if (match) {
                frames.push({
                    function: match[1],
                    file: match[2],
                    line: parseInt(match[3], 10),
                    column: parseInt(match[4], 10)
                });
            }
        }

        return frames;
    }

    categorizeError(error, context) {
        const message = error.message.toLowerCase();
        const stack = error.stack || '';

        if (message.includes('canvas') || message.includes('render') || stack.includes('Renderer')) {
            return this.errorCategories.RENDERING;
        }

        if (message.includes('animation') || stack.includes('Animation')) {
            return this.errorCategories.ANIMATION;
        }

        if (message.includes('state') || stack.includes('State')) {
            return this.errorCategories.STATE;
        }

        if (message.includes('network') || message.includes('fetch') || message.includes('xhr')) {
            return this.errorCategories.NETWORK;
        }

        if (message.includes('plugin') || stack.includes('Plugin')) {
            return this.errorCategories.PLUGIN;
        }

        if (context.source === 'user_input') {
            return this.errorCategories.USER_INPUT;
        }

        if (message.includes('performance') || message.includes('memory')) {
            return this.errorCategories.PERFORMANCE;
        }

        return this.errorCategories.UNKNOWN;
    }

    determineSeverity(error, category) {
        // Critical errors
        if (error.name === 'ReferenceError' || error.name === 'TypeError') {
            return this.severityLevels.CRITICAL;
        }

        if (category === this.errorCategories.RENDERING || category === this.errorCategories.ANIMATION) {
            return this.severityLevels.HIGH;
        }

        if (category === this.errorCategories.NETWORK) {
            return this.severityLevels.MEDIUM;
        }

        return this.severityLevels.LOW;
    }

    shouldSuppress(error) {
        const message = error.message || '';

        for (const pattern of this.suppressedErrors) {
            if (typeof pattern === 'string' && message.includes(pattern)) {
                return true;
            }
            if (pattern instanceof RegExp && pattern.test(message)) {
                return true;
            }
        }

        return false;
    }

    detectPatterns(errorInfo) {
        const key = `${errorInfo.category}:${errorInfo.severity}`;
        const pattern = this.errorPatterns.get(key) || { count: 0, firstSeen: Date.now(), lastSeen: null };

        pattern.count++;
        pattern.lastSeen = Date.now();

        this.errorPatterns.set(key, pattern);

        // Detect error storms (many errors in short time)
        const recentErrors = this.errors.filter(e =>
            Date.now() - e.timestamp < 5000
        );

        if (recentErrors.length > 10) {
            this.handleErrorStorm(recentErrors);
        }
    }

    handleCriticalError(errorInfo) {
        console.error('Critical error detected:', errorInfo);

        if (this.callbacks.onCritical) {
            this.callbacks.onCritical(errorInfo);
        }

        // Immediately report critical errors
        this.sendReport([errorInfo], 'critical');
    }

    handleErrorStorm(errors) {
        console.warn(`Error storm detected: ${errors.length} errors in 5 seconds`);

        // Group errors by type
        const grouped = new Map();
        for (const error of errors) {
            const key = `${error.name}:${error.message}`;
            if (!grouped.has(key)) {
                grouped.set(key, []);
            }
            grouped.get(key).push(error);
        }

        // Report grouped errors
        this.sendReport(errors, 'storm');
    }

    collectMetadata() {
        const metadata = {};

        if (typeof window !== 'undefined') {
            metadata.viewport = {
                width: window.innerWidth,
                height: window.innerHeight
            };

            metadata.screen = {
                width: window.screen.width,
                height: window.screen.height,
                pixelRatio: window.devicePixelRatio
            };

            if (performance.memory) {
                metadata.memory = {
                    used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                    total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                    limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
                };
            }
        }

        return metadata;
    }

    startReportingInterval() {
        this.reportingIntervalId = setInterval(() => {
            this.checkAndReport();
        }, this.reportingInterval);
    }

    stopReportingInterval() {
        if (this.reportingIntervalId) {
            clearInterval(this.reportingIntervalId);
            this.reportingIntervalId = null;
        }
    }

    checkAndReport() {
        if (this.errors.length >= this.reportingThreshold) {
            this.sendReport(this.errors.slice());
            this.errors = [];
        }
    }

    sendReport(errors, type = 'batch') {
        const report = {
            sessionId: this.metadata.sessionId,
            timestamp: Date.now(),
            type,
            errors,
            patterns: Array.from(this.errorPatterns.entries()),
            counts: Array.from(this.errorCounts.entries()),
            metadata: this.metadata
        };

        if (this.callbacks.onReport) {
            this.callbacks.onReport(report);
        }

        // In production, you would send this to your error tracking service
        console.warn('Error report generated:', report);

        return report;
    }

    getErrors(filter = {}) {
        let filtered = [...this.errors];

        if (filter.category) {
            filtered = filtered.filter(e => e.category === filter.category);
        }

        if (filter.severity) {
            filtered = filtered.filter(e => e.severity === filter.severity);
        }

        if (filter.since) {
            filtered = filtered.filter(e => e.timestamp >= filter.since);
        }

        return filtered;
    }

    getStats() {
        const stats = {
            total: this.errors.length,
            byCategory: {},
            bySeverity: {},
            patterns: this.errorPatterns.size,
            topErrors: []
        };

        // Count by category
        for (const category of Object.values(this.errorCategories)) {
            stats.byCategory[category] = this.errors.filter(e => e.category === category).length;
        }

        // Count by severity
        for (const severity of Object.values(this.severityLevels)) {
            stats.bySeverity[severity] = this.errors.filter(e => e.severity === severity).length;
        }

        // Get top errors
        const sorted = Array.from(this.errorCounts.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);

        stats.topErrors = sorted.map(([key, count]) => ({ error: key, count }));

        return stats;
    }

    clearErrors() {
        this.errors = [];
        this.errorCounts.clear();
        this.errorPatterns.clear();
    }

    suppressError(pattern) {
        this.suppressedErrors.add(pattern);
    }

    unsuppressError(pattern) {
        this.suppressedErrors.delete(pattern);
    }

    enable() {
        this.enabled = true;
        this.attachGlobalHandlers();
        this.startReportingInterval();
    }

    disable() {
        this.enabled = false;
        this.detachGlobalHandlers();
        this.stopReportingInterval();
    }

    destroy() {
        this.disable();
        this.clearErrors();
    }
}

// Create singleton instance
const errorTracker = new ErrorTracker({
    enabled: true,
    maxErrors: 100,
    reportingThreshold: 10,
    reportingInterval: 60000,
    suppressedErrors: [
        'ResizeObserver loop limit exceeded',
        'Non-Error promise rejection captured'
    ]
});

/**
 * Lazy loading system for on-demand feature loading
 * Reduces initial bundle size by loading features when needed
 */

class LazyLoader {
    constructor(options = {}) {
        this.baseUrl = options.baseUrl || '/dist/modules/';
        this.cache = new Map();
        this.loading = new Map();
        this.moduleMap = new Map([
            // Core modules
            ['core', () => Promise.resolve().then(function () { return coreExports; })],
            ['features', () => Promise.resolve().then(function () { return featuresExports; })],
            ['plugins', () => Promise.resolve().then(function () { return pluginsExports; })],

            // Individual features
            ['particles', () => Promise.resolve().then(function () { return ParticleSystem$1; })],
            ['audio', () => Promise.resolve().then(function () { return AudioAnalyzer$1; })],

            // Behaviors
            ['idle-behavior', () => Promise.resolve().then(function () { return IdleBehavior$1; })]
        ]);

        this.preloadQueue = [];
        this.preloading = false;

        // Feature detection
        this.features = {
            dynamicImport: this.checkDynamicImport(),
            modulePreload: 'modulepreload' in document.createElement('link').relList,
            prefetch: 'prefetch' in document.createElement('link').relList
        };
    }

    checkDynamicImport() {
        try {
            // Check if dynamic import is supported without using Function constructor
            return typeof window !== 'undefined' && typeof window.import === 'function';
        } catch {
            return false;
        }
    }

    async load(moduleName) {
        // Check cache first
        if (this.cache.has(moduleName)) {
            return this.cache.get(moduleName);
        }

        // Check if already loading
        if (this.loading.has(moduleName)) {
            return this.loading.get(moduleName);
        }

        // Start loading
        const loadPromise = this._loadModule(moduleName);
        this.loading.set(moduleName, loadPromise);

        try {
            const module = await loadPromise;
            this.cache.set(moduleName, module);
            this.loading.delete(moduleName);
            return module;
        } catch (error) {
            this.loading.delete(moduleName);
            throw new Error(`Failed to load module '${moduleName}': ${error.message}`);
        }
    }

    _loadModule(moduleName) {
        const loader = this.moduleMap.get(moduleName);

        if (loader) {
            // Use dynamic import
            return loader();
        }

        // Fallback to URL-based loading
        const url = `${this.baseUrl}${moduleName}.js`;

        if (this.features.dynamicImport) {
            return import(url);
        }

        // Fallback for older browsers
        return this._loadScript(url);
    }

    _loadScript(url) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.type = 'module';
            script.src = url;

            script.onload = () => {
                // Module should have registered itself globally
                const moduleName = url.split('/').pop().replace('.js', '');
                const module = window[moduleName] || window.EmotiveEngine[moduleName];

                if (module) {
                    resolve(module);
                } else {
                    reject(new Error(`Module not found after loading: ${url}`));
                }
            };

            script.onerror = () => reject(new Error(`Failed to load script: ${url}`));

            document.head.appendChild(script);
        });
    }

    preload(moduleNames) {
        if (!Array.isArray(moduleNames)) {
            moduleNames = [moduleNames];
        }

        for (const name of moduleNames) {
            if (!this.cache.has(name) && !this.preloadQueue.includes(name)) {
                this.preloadQueue.push(name);
            }
        }

        if (!this.preloading) {
            this._processPreloadQueue();
        }
    }

    async _processPreloadQueue() {
        if (this.preloadQueue.length === 0) {
            this.preloading = false;
            return;
        }

        this.preloading = true;
        const moduleName = this.preloadQueue.shift();

        try {
            await this.load(moduleName);
        } catch (error) {
            console.warn(`Failed to preload module '${moduleName}':`, error);
        }

        // Continue with next module
        this._processPreloadQueue();
    }

    prefetch(moduleNames) {
        if (!this.features.prefetch) return;

        if (!Array.isArray(moduleNames)) {
            moduleNames = [moduleNames];
        }

        for (const name of moduleNames) {
            const url = `${this.baseUrl}${name}.js`;
            const link = document.createElement('link');
            link.rel = 'prefetch';
            link.as = 'script';
            link.href = url;
            document.head.appendChild(link);
        }
    }

    modulePreload(moduleNames) {
        if (!this.features.modulePreload) return;

        if (!Array.isArray(moduleNames)) {
            moduleNames = [moduleNames];
        }

        for (const name of moduleNames) {
            const url = `${this.baseUrl}${name}.js`;
            const link = document.createElement('link');
            link.rel = 'modulepreload';
            link.href = url;
            document.head.appendChild(link);
        }
    }

    loadFeature(featureName) {
        const featureMap = {
            particles: ['particles'],
            audio: ['audio'],
            behaviors: ['idle-behavior'],
            plugins: ['plugins']
        };

        const modules = featureMap[featureName];
        if (!modules) {
            throw new Error(`Unknown feature: ${featureName}`);
        }

        const loadPromises = modules.map(m => this.load(m));
        return Promise.all(loadPromises);
    }

    whenReady(moduleNames) {
        if (!Array.isArray(moduleNames)) {
            moduleNames = [moduleNames];
        }

        const promises = moduleNames.map(name => {
            if (this.cache.has(name)) {
                return Promise.resolve(this.cache.get(name));
            }
            if (this.loading.has(name)) {
                return this.loading.get(name);
            }
            return this.load(name);
        });

        return Promise.all(promises);
    }

    isLoaded(moduleName) {
        return this.cache.has(moduleName);
    }

    getLoadedModules() {
        return Array.from(this.cache.keys());
    }

    clearCache(moduleName = null) {
        if (moduleName) {
            this.cache.delete(moduleName);
        } else {
            this.cache.clear();
        }
    }

    getStats() {
        return {
            loaded: this.cache.size,
            loading: this.loading.size,
            queued: this.preloadQueue.length,
            features: this.features,
            modules: this.getLoadedModules()
        };
    }
}

// Create singleton instance
const lazyLoader = new LazyLoader();

// Helper function for easy loading
function lazyLoad(moduleName) {
    return lazyLoader.load(moduleName);
}

// Helper function for preloading
function preloadModules(...moduleNames) {
    lazyLoader.preload(moduleNames.flat());
}

// Helper function for prefetching
function prefetchModules(...moduleNames) {
    lazyLoader.prefetch(moduleNames.flat());
}

/**
 * Security Manager for Emotive Engine
 * Handles Content Security Policy, sanitization, and security best practices
 */

class SecurityManager {
    constructor(options = {}) {
        this.enabled = options.enabled !== false;
        this.strict = options.strict || false;
        this.reportUri = options.reportUri || null;
        this.nonce = this.generateNonce();

        this.cspDirectives = {
            'default-src': ["'self'"],
            'script-src': ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
            'style-src': ["'self'", "'unsafe-inline'"],
            'img-src': ["'self'", 'data:', 'blob:'],
            'font-src': ["'self'", 'data:'],
            'connect-src': ["'self'"],
            'media-src': ["'self'"],
            'object-src': ["'none'"],
            'frame-src': ["'none'"],
            'worker-src': ["'self'", 'blob:'],
            'form-action': ["'self'"],
            'frame-ancestors': ["'none'"],
            'base-uri': ["'self'"],
            'manifest-src': ["'self'"],
            ...options.cspDirectives
        };

        if (this.strict) {
            this.applyStrictCSP();
        }

        if (this.enabled) {
            this.initialize();
        }
    }

    generateNonce() {
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
            return crypto.randomUUID();
        }
        return Math.random().toString(36).substr(2, 15);
    }

    applyStrictCSP() {
        // Remove unsafe-inline and unsafe-eval in strict mode
        this.cspDirectives['script-src'] = ["'self'", `'nonce-${this.nonce}'`];
        this.cspDirectives['style-src'] = ["'self'", `'nonce-${this.nonce}'`];

        // Add additional strict directives
        this.cspDirectives['require-trusted-types-for'] = ["'script'"];
        this.cspDirectives['trusted-types'] = ['default'];
    }

    initialize() {
        if (typeof document === 'undefined') return;

        // Set CSP meta tag
        this.setCSPMeta();

        // Initialize trusted types if available
        this.initTrustedTypes();

        // Set security headers via meta tags
        this.setSecurityHeaders();

        // Monitor violations
        this.monitorViolations();
    }

    setCSPMeta() {
        const existingCSP = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
        if (existingCSP) {
            existingCSP.remove();
        }

        const cspMeta = document.createElement('meta');
        cspMeta.httpEquiv = 'Content-Security-Policy';
        cspMeta.content = this.buildCSPString();
        document.head.appendChild(cspMeta);
    }

    buildCSPString() {
        const directives = [];

        for (const [directive, values] of Object.entries(this.cspDirectives)) {
            if (values && values.length > 0) {
                directives.push(`${directive} ${values.join(' ')}`);
            }
        }

        if (this.reportUri) {
            directives.push(`report-uri ${this.reportUri}`);
        }

        return directives.join('; ');
    }

    setSecurityHeaders() {
        // X-Content-Type-Options
        const xContentType = document.createElement('meta');
        xContentType.httpEquiv = 'X-Content-Type-Options';
        xContentType.content = 'nosniff';
        document.head.appendChild(xContentType);

        // X-Frame-Options
        const xFrame = document.createElement('meta');
        xFrame.httpEquiv = 'X-Frame-Options';
        xFrame.content = 'DENY';
        document.head.appendChild(xFrame);

        // Referrer-Policy
        const referrer = document.createElement('meta');
        referrer.name = 'referrer';
        referrer.content = 'strict-origin-when-cross-origin';
        document.head.appendChild(referrer);

        // Permissions-Policy
        const permissions = document.createElement('meta');
        permissions.httpEquiv = 'Permissions-Policy';
        permissions.content = 'geolocation=(), microphone=(), camera=()';
        document.head.appendChild(permissions);
    }

    initTrustedTypes() {
        if (typeof window === 'undefined' || !window.trustedTypes) return;

        try {
            const policy = window.trustedTypes.createPolicy('emotive-engine', {
                createHTML: string => this.sanitizeHTML(string),
                createScript: string => this.sanitizeScript(string),
                createScriptURL: url => this.sanitizeURL(url)
            });

            window.EmotiveEngineTrustedPolicy = policy;
        } catch (error) {
            console.warn('Failed to create Trusted Types policy:', error);
        }
    }

    monitorViolations() {
        if (typeof window === 'undefined') return;

        // Listen for CSP violations
        window.addEventListener('securitypolicyviolation', event => {
            this.handleViolation(event);
        });

        // Monitor other security events
        this.monitorXSSAttempts();
        this.monitorClickjacking();
    }

    handleViolation(event) {
        const violation = {
            documentURI: event.documentURI,
            violatedDirective: event.violatedDirective,
            effectiveDirective: event.effectiveDirective,
            originalPolicy: event.originalPolicy,
            blockedURI: event.blockedURI,
            statusCode: event.statusCode,
            timestamp: Date.now()
        };

        console.warn('CSP Violation:', violation);

        // Report to server if configured
        if (this.reportUri) {
            this.reportViolation(violation);
        }
    }

    reportViolation(violation) {
        if (!this.reportUri) return;

        try {
            fetch(this.reportUri, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    'csp-report': violation
                })
            }).catch(error => {
                console.error('Failed to report CSP violation:', error);
            });
        } catch (error) {
            console.error('Error reporting CSP violation:', error);
        }
    }

    monitorXSSAttempts() {
        // Override dangerous methods to monitor usage
        // eslint-disable-next-line no-eval
        const originalEval = window.eval;
        // eslint-disable-next-line no-eval
        window.eval = (...args) => {
            console.warn('eval() usage detected:', args);
            if (this.strict) {
                throw new Error('eval() is disabled in strict mode');
            }
            return originalEval.apply(window, args);
        };

        // Monitor innerHTML usage
        const originalInnerHTML = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML');
        Object.defineProperty(Element.prototype, 'innerHTML', {
            set(value) {
                if (typeof value === 'string' && value.includes('<script')) {
                    console.warn('Potential XSS: Script tag in innerHTML');
                    if (this.strict) {
                        throw new Error('Script tags not allowed in innerHTML');
                    }
                }
                originalInnerHTML.set.call(this, value);
            },
            get: originalInnerHTML.get
        });
    }

    monitorClickjacking() {
        if (window.self !== window.top) {
            console.warn('Page is being framed - potential clickjacking attempt');
            if (this.strict) {
                // Break out of frame
                window.top.location = window.self.location;
            }
        }
    }

    sanitizeHTML(html) {
        if (typeof DOMPurify !== 'undefined') {
            return DOMPurify.sanitize(html);
        }

        // Basic sanitization fallback
        const div = document.createElement('div');
        div.textContent = html;
        return div.innerHTML;
    }

    sanitizeScript(script) {
        // Remove potentially dangerous patterns
        const dangerous = [
            /eval\s*\(/g,
            /new\s+Function\s*\(/g,
            /setTimeout\s*\([^,]*,/g,
            /setInterval\s*\([^,]*,/g,
            /document\.write/g,
            /window\.location/g,
            /document\.cookie/g
        ];

        const sanitized = script;
        for (const pattern of dangerous) {
            if (pattern.test(sanitized)) {
                console.warn('Dangerous pattern detected in script:', pattern);
                if (this.strict) {
                    throw new Error('Script contains dangerous patterns');
                }
            }
        }

        return sanitized;
    }

    sanitizeURL(url) {
        try {
            const parsed = new URL(url, window.location.origin);

            // Check protocol
            if (!['http:', 'https:', 'data:', 'blob:'].includes(parsed.protocol)) {
                console.warn('Unsafe URL protocol:', parsed.protocol);
                if (this.strict) {
                    throw new Error('Unsafe URL protocol');
                }
            }

            // Check for javascript: URLs
            if (url.toLowerCase().includes('javascript:')) {
                console.warn('JavaScript URL detected');
                if (this.strict) {
                    throw new Error('JavaScript URLs not allowed');
                }
            }

            return url;
        } catch (error) {
            console.error('Invalid URL:', url, error);
            return '';
        }
    }

    validateInput(input, type = 'text') {
        const validators = {
            text: /^[\w\s\-@.]+$/,
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            number: /^\d+$/,
            alphanumeric: /^[a-zA-Z0-9]+$/,
            url: /^https?:\/\/.+$/
        };

        const validator = validators[type];
        if (!validator) {
            console.warn('Unknown input type:', type);
            return false;
        }

        return validator.test(input);
    }

    createSecureContext() {
        return {
            eval: () => {
                throw new Error('eval is not allowed in secure context');
            },
            Function: () => {
                throw new Error('Function constructor is not allowed in secure context');
            },
            setTimeout: (fn, delay) => {
                if (typeof fn !== 'function') {
                    throw new Error('setTimeout with string is not allowed');
                }
                return setTimeout(fn, delay);
            },
            setInterval: (fn, delay) => {
                if (typeof fn !== 'function') {
                    throw new Error('setInterval with string is not allowed');
                }
                return setInterval(fn, delay);
            }
        };
    }

    getNonce() {
        return this.nonce;
    }

    updateCSP(directives) {
        Object.assign(this.cspDirectives, directives);
        this.setCSPMeta();
    }

    getSecurityReport() {
        return {
            enabled: this.enabled,
            strict: this.strict,
            csp: this.buildCSPString(),
            nonce: this.nonce,
            features: {
                trustedTypes: typeof window !== 'undefined' && !!window.trustedTypes,
                csp: true,
                secureContext: typeof window !== 'undefined' && window.isSecureContext
            }
        };
    }
}

// Create singleton instance (disabled by default to avoid console warnings)
// Users can enable via: securityManager.enabled = true; securityManager.initialize();
const securityManager = new SecurityManager({
    enabled: false,
    strict: false,
    cspDirectives: {
        'connect-src': ["'self'", 'https://api.anthropic.com', 'https://*.firebaseio.com']
    }
});

/**
 * Health Check System for Emotive Engine
 * Provides real-time health monitoring and diagnostics
 */

class HealthCheck {
    constructor(options = {}) {
        this.enabled = options.enabled !== false;
        this.interval = options.interval || 30000; // 30 seconds
        this.thresholds = {
            memory: options.memoryThreshold || 500, // MB
            fps: options.fpsThreshold || 30,
            errorRate: options.errorRateThreshold || 0.1, // 10%
            responseTime: options.responseTimeThreshold || 1000, // ms
            ...options.thresholds
        };

        this.checks = new Map();
        this.history = [];
        this.maxHistory = options.maxHistory || 100;
        this.status = 'initializing';
        this.lastCheck = null;

        this.dependencies = {
            animationLoop: null,
            stateStore: null,
            eventManager: null,
            performanceMonitor: null,
            errorTracker: null
        };

        this.callbacks = {
            onHealthy: options.onHealthy || null,
            onWarning: options.onWarning || null,
            onCritical: options.onCritical || null,
            onStatusChange: options.onStatusChange || null
        };

        this.registerDefaultChecks();

        if (this.enabled) {
            this.start();
        }
    }

    registerDefaultChecks() {
        // System checks
        this.registerCheck('memory', () => this.checkMemory());
        this.registerCheck('performance', () => this.checkPerformance());
        this.registerCheck('errors', () => this.checkErrors());
        this.registerCheck('dom', () => this.checkDOM());
        this.registerCheck('animation', () => this.checkAnimation());
        this.registerCheck('state', () => this.checkState());
        this.registerCheck('events', () => this.checkEvents());
        this.registerCheck('storage', () => this.checkStorage());
        this.registerCheck('network', () => this.checkNetwork());
        this.registerCheck('browser', () => this.checkBrowser());
    }

    registerCheck(name, checkFn, options = {}) {
        this.checks.set(name, {
            fn: checkFn,
            critical: options.critical || false,
            weight: options.weight || 1,
            timeout: options.timeout || 5000,
            lastResult: null,
            lastRun: null
        });
    }

    checkMemory() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (performance.memory) {
            const used = performance.memory.usedJSHeapSize / (1024 * 1024);
            const total = performance.memory.totalJSHeapSize / (1024 * 1024);
            const limit = performance.memory.jsHeapSizeLimit / (1024 * 1024);

            result.details = {
                used: Math.round(used),
                total: Math.round(total),
                limit: Math.round(limit),
                percentage: Math.round((used / limit) * 100)
            };

            if (used > this.thresholds.memory) {
                result.status = 'critical';
                result.message = `Memory usage too high: ${Math.round(used)}MB`;
            } else if (used > this.thresholds.memory * 0.8) {
                result.status = 'warning';
                result.message = `Memory usage approaching limit: ${Math.round(used)}MB`;
            }
        } else {
            result.status = 'unknown';
            result.message = 'Memory API not available';
        }

        return result;
    }

    checkPerformance() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (this.dependencies.performanceMonitor) {
            const stats = this.dependencies.performanceMonitor.getStats();
            result.details = {
                fps: stats.fps.current,
                frameTime: stats.frameTime.current,
                health: stats.health,
                score: stats.performance
            };

            if (stats.fps.current < this.thresholds.fps) {
                result.status = 'warning';
                result.message = `Low FPS: ${stats.fps.current}`;
            }

            if (stats.health === 'critical' || stats.health === 'poor') {
                result.status = 'critical';
                result.message = 'Performance is critically low';
            }
        }

        return result;
    }

    checkErrors() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (this.dependencies.errorTracker) {
            const stats = this.dependencies.errorTracker.getStats();
            const recentErrors = this.dependencies.errorTracker.getErrors({
                since: Date.now() - 60000 // Last minute
            });

            result.details = {
                total: stats.total,
                recent: recentErrors.length,
                critical: stats.bySeverity.critical || 0,
                patterns: stats.patterns
            };

            const errorRate = recentErrors.length / 60; // Errors per second

            if (errorRate > this.thresholds.errorRate) {
                result.status = 'critical';
                result.message = `High error rate: ${errorRate.toFixed(2)}/s`;
            } else if (stats.bySeverity.critical > 0) {
                result.status = 'warning';
                result.message = `${stats.bySeverity.critical} critical errors`;
            }
        }

        return result;
    }

    checkDOM() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (typeof document !== 'undefined') {
            const nodeCount = document.querySelectorAll('*').length;
            const canvasCount = document.querySelectorAll('canvas').length;
            const listenerCount = this.countEventListeners();

            result.details = {
                nodes: nodeCount,
                canvases: canvasCount,
                listeners: listenerCount
            };

            if (nodeCount > 10000) {
                result.status = 'warning';
                result.message = `High DOM node count: ${nodeCount}`;
            }

            if (listenerCount > 1000) {
                result.status = 'warning';
                result.message = `High event listener count: ${listenerCount}`;
            }
        }

        return result;
    }

    checkAnimation() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (this.dependencies.animationLoop) {
            const stats = this.dependencies.animationLoop.getStats();
            result.details = {
                callbacks: stats.callbackCount,
                fps: stats.fps,
                running: stats.isRunning,
                dropped: stats.droppedFrames
            };

            if (!stats.isRunning) {
                result.status = 'warning';
                result.message = 'Animation loop not running';
            }

            if (stats.droppedFrames > 100) {
                result.status = 'warning';
                result.message = `Dropped frames: ${stats.droppedFrames}`;
            }
        }

        return result;
    }

    checkState() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (this.dependencies.stateStore) {
            const state = this.dependencies.stateStore.getState();
            const stateSize = JSON.stringify(state).length;

            result.details = {
                size: stateSize,
                keys: Object.keys(state).length
            };

            if (stateSize > 1000000) { // 1MB
                result.status = 'warning';
                result.message = `Large state size: ${(stateSize / 1024).toFixed(2)}KB`;
            }
        }

        return result;
    }

    checkEvents() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (this.dependencies.eventManager) {
            const listeners = this.dependencies.eventManager.getActiveListeners();
            const leaks = this.dependencies.eventManager.analyzeLeaks();

            result.details = {
                active: listeners.length,
                potentialLeaks: leaks.potentialLeaks.length,
                byGroup: leaks.byGroup
            };

            if (leaks.potentialLeaks.length > 10) {
                result.status = 'warning';
                result.message = `Potential memory leaks: ${leaks.potentialLeaks.length}`;
            }

            if (listeners.length > 500) {
                result.status = 'warning';
                result.message = `High listener count: ${listeners.length}`;
            }
        }

        return result;
    }

    async checkStorage() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (typeof navigator !== 'undefined' && navigator.storage && navigator.storage.estimate) {
            try {
                const estimate = await navigator.storage.estimate();
                const used = estimate.usage || 0;
                const quota = estimate.quota || 0;
                const percentage = quota > 0 ? (used / quota) * 100 : 0;

                result.details = {
                    used: Math.round(used / (1024 * 1024)), // MB
                    quota: Math.round(quota / (1024 * 1024)), // MB
                    percentage: Math.round(percentage)
                };

                if (percentage > 90) {
                    result.status = 'critical';
                    result.message = `Storage almost full: ${percentage.toFixed(1)}%`;
                } else if (percentage > 70) {
                    result.status = 'warning';
                    result.message = `Storage usage high: ${percentage.toFixed(1)}%`;
                }
            } catch (_error) {
                result.status = 'unknown';
                result.message = 'Storage API error';
            }
        }

        return result;
    }

    async checkNetwork() {
        const result = {
            status: 'healthy',
            details: {}
        };

        if (typeof navigator !== 'undefined' && navigator.connection) {
            const {connection} = navigator;
            result.details = {
                effectiveType: connection.effectiveType,
                downlink: connection.downlink,
                rtt: connection.rtt,
                saveData: connection.saveData
            };

            if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
                result.status = 'warning';
                result.message = 'Slow network connection detected';
            }

            if (connection.saveData) {
                result.status = 'warning';
                result.message = 'Data saver mode enabled';
            }
        }

        // Test connectivity
        try {
            const start = performance.now();
            const response = await fetch('/health', {
                method: 'HEAD',
                cache: 'no-cache'
            });
            const responseTime = performance.now() - start;

            result.details.responseTime = Math.round(responseTime);
            result.details.online = response.ok;

            if (responseTime > this.thresholds.responseTime) {
                result.status = 'warning';
                result.message = `Slow response time: ${responseTime.toFixed(0)}ms`;
            }
        } catch (_error) {
            result.details.online = navigator.onLine;
            if (!navigator.onLine) {
                result.status = 'critical';
                result.message = 'No network connection';
            }
        }

        return result;
    }

    checkBrowser() {
        const result = {
            status: 'healthy',
            details: {}
        };

        result.details = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            cookiesEnabled: navigator.cookieEnabled,
            doNotTrack: navigator.doNotTrack,
            hardwareConcurrency: navigator.hardwareConcurrency,
            maxTouchPoints: navigator.maxTouchPoints
        };

        // Check for required features
        const requiredFeatures = {
            webGL: !!document.createElement('canvas').getContext('webgl'),
            webAudio: typeof AudioContext !== 'undefined',
            localStorage: typeof localStorage !== 'undefined',
            serviceWorker: 'serviceWorker' in navigator,
            webWorker: typeof Worker !== 'undefined'
        };

        result.details.features = requiredFeatures;

        const missingFeatures = Object.entries(requiredFeatures)
            .filter(([_, supported]) => !supported)
            .map(([feature]) => feature);

        if (missingFeatures.length > 0) {
            result.status = 'warning';
            result.message = `Missing features: ${missingFeatures.join(', ')}`;
        }

        return result;
    }

    countEventListeners() {
        let count = 0;
        const allElements = document.querySelectorAll('*');

        for (const element of allElements) {
            const listeners = (typeof getEventListeners !== 'undefined' && getEventListeners) ? getEventListeners(element) : {};
            for (const event in listeners) {
                count += listeners[event].length;
            }
        }

        return count;
    }

    async runCheck(name) {
        const check = this.checks.get(name);
        if (!check) {
            return { status: 'unknown', message: `Check '${name}' not found` };
        }

        try {
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Check timeout')), check.timeout);
            });

            const result = await Promise.race([check.fn(), timeoutPromise]);
            check.lastResult = result;
            check.lastRun = Date.now();
            return result;
        } catch (error) {
            return {
                status: 'error',
                message: error.message,
                error: error.stack
            };
        }
    }

    async runAllChecks() {
        const results = {};
        const promises = [];

        for (const [name, _check] of this.checks) {
            promises.push(
                this.runCheck(name).then(result => {
                    results[name] = result;
                })
            );
        }

        await Promise.all(promises);
        return results;
    }

    async performHealthCheck() {
        const startTime = performance.now();
        const results = await this.runAllChecks();
        const duration = performance.now() - startTime;

        const health = this.calculateOverallHealth(results);

        const report = {
            timestamp: Date.now(),
            status: health.status,
            score: health.score,
            duration: Math.round(duration),
            checks: results,
            summary: health.summary
        };

        this.lastCheck = report;
        this.addToHistory(report);
        this.updateStatus(health.status);

        return report;
    }

    calculateOverallHealth(results) {
        let totalScore = 0;
        let totalWeight = 0;
        let criticalFailed = false;
        const issues = [];

        for (const [name, result] of Object.entries(results)) {
            const check = this.checks.get(name);
            const weight = check ? check.weight : 1;

            let score = 0;
            switch (result.status) {
            case 'healthy':
                score = 100;
                break;
            case 'warning':
                score = 70;
                issues.push({ name, level: 'warning', message: result.message });
                break;
            case 'critical':
                score = 30;
                issues.push({ name, level: 'critical', message: result.message });
                if (check && check.critical) {
                    criticalFailed = true;
                }
                break;
            case 'error':
                score = 0;
                issues.push({ name, level: 'error', message: result.message });
                break;
            case 'unknown':
                score = 50;
                break;
            }

            totalScore += score * weight;
            totalWeight += weight;
        }

        const overallScore = totalWeight > 0 ? Math.round(totalScore / totalWeight) : 0;

        let status;
        if (criticalFailed || overallScore < 30) {
            status = 'critical';
        } else if (overallScore < 70) {
            status = 'degraded';
        } else if (overallScore < 90) {
            status = 'warning';
        } else {
            status = 'healthy';
        }

        return {
            status,
            score: overallScore,
            summary: {
                total: Object.keys(results).length,
                healthy: Object.values(results).filter(r => r.status === 'healthy').length,
                warning: Object.values(results).filter(r => r.status === 'warning').length,
                critical: Object.values(results).filter(r => r.status === 'critical').length,
                issues
            }
        };
    }

    updateStatus(newStatus) {
        if (this.status !== newStatus) {
            const oldStatus = this.status;
            this.status = newStatus;

            if (this.callbacks.onStatusChange) {
                this.callbacks.onStatusChange(newStatus, oldStatus);
            }

            switch (newStatus) {
            case 'healthy':
                if (this.callbacks.onHealthy) {
                    this.callbacks.onHealthy();
                }
                break;
            case 'warning':
            case 'degraded':
                if (this.callbacks.onWarning) {
                    this.callbacks.onWarning(this.lastCheck);
                }
                break;
            case 'critical':
                if (this.callbacks.onCritical) {
                    this.callbacks.onCritical(this.lastCheck);
                }
                break;
            }
        }
    }

    addToHistory(report) {
        this.history.push(report);
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        }
    }

    start() {
        if (this.intervalId) return;

        // Initial check
        this.performHealthCheck();

        // Schedule regular checks
        this.intervalId = setInterval(() => {
            this.performHealthCheck();
        }, this.interval);
    }

    stop() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }
    }

    setDependencies(deps) {
        Object.assign(this.dependencies, deps);
    }

    getStatus() {
        return this.status;
    }

    getLastCheck() {
        return this.lastCheck;
    }

    getHistory() {
        return [...this.history];
    }

    async getFullReport() {
        const report = await this.performHealthCheck();

        return {
            ...report,
            history: this.getHistory(),
            uptime: this.getUptime(),
            configuration: {
                interval: this.interval,
                thresholds: this.thresholds,
                checks: Array.from(this.checks.keys())
            }
        };
    }

    getUptime() {
        if (!this.history.length) return 0;

        const firstCheck = this.history[0].timestamp;
        const now = Date.now();
        return now - firstCheck;
    }

    // Endpoint for external health checks
    async handleHealthRequest(_req, _res) {
        const report = await this.performHealthCheck();

        const statusCode = report.status === 'healthy' ? 200 :
            report.status === 'warning' ? 200 :
                report.status === 'degraded' ? 503 :
                    503;

        return {
            statusCode,
            headers: {
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache'
            },
            body: JSON.stringify({
                status: report.status,
                score: report.score,
                timestamp: report.timestamp,
                checks: report.checks,
                version: '2.4.0'
            })
        };
    }
}

// Create singleton instance (disabled by default to avoid 404 errors)
// Users can enable via: healthCheck.enabled = true; healthCheck.start();
const healthCheck = new HealthCheck({
    enabled: false,
    interval: 30000
});

/**
 * Feature Flags System for Emotive Engine
 * Enables controlled rollout and A/B testing of features
 */

class FeatureFlags {
    constructor(options = {}) {
        this.flags = new Map();
        this.overrides = new Map();
        this.variants = new Map();
        this.evaluations = new Map();

        this.config = {
            endpoint: options.endpoint || '/api/feature-flags',
            refreshInterval: options.refreshInterval || 300000, // 5 minutes
            storage: options.storage || 'localStorage',
            storageKey: options.storageKey || 'emotive-feature-flags',
            userId: options.userId || this.generateUserId(),
            attributes: options.attributes || {},
            enableAnalytics: options.enableAnalytics !== false,
            enableCache: options.enableCache !== false,
            defaultFlags: options.defaultFlags || {}
        };

        this.callbacks = {
            onFlagChange: options.onFlagChange || null,
            onEvaluation: options.onEvaluation || null,
            onError: options.onError || null
        };

        this.refreshTimer = null;
        this.initialized = false;

        // Initialize with defaults
        this.loadDefaultFlags();

        // Load from storage if available
        if (this.config.enableCache) {
            this.loadFromStorage();
        }

        // Start auto-refresh
        if (this.config.endpoint) {
            this.startAutoRefresh();
        }
    }

    generateUserId() {
        const stored = this.getStoredUserId();
        if (stored) return stored;

        const userId = `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        this.storeUserId(userId);
        return userId;
    }

    getStoredUserId() {
        try {
            if (typeof localStorage !== 'undefined') {
                return localStorage.getItem('emotive-user-id');
            }
        } catch (e) {
            // Storage not available
        }
        return null;
    }

    storeUserId(userId) {
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem('emotive-user-id', userId);
            }
        } catch (e) {
            // Storage not available
        }
    }

    loadDefaultFlags() {
        const defaults = {
            // Core features
            enableParticles: { enabled: true, variant: 'default' },
            enableAudio: { enabled: true, variant: 'default' },
            enableEmotions: { enabled: true, variant: 'default' },
            enableGestures: { enabled: true, variant: 'default' },

            // Performance features
            enableGradientCache: { enabled: true, variant: 'default' },
            enableLazyLoading: { enabled: true, variant: 'default' },
            enableCodeSplitting: { enabled: false, variant: 'default' },

            // Experimental features
            enableWebGL: { enabled: false, variant: 'default' },
            enableWebGPU: { enabled: false, variant: 'default' },
            enableOffscreenCanvas: { enabled: false, variant: 'default' },

            // Debug features
            enableDebugMode: { enabled: false, variant: 'default' },
            enablePerformanceOverlay: { enabled: false, variant: 'default' },
            enableErrorReporting: { enabled: true, variant: 'default' },

            // A/B test examples
            buttonColor: { enabled: true, variant: 'blue' },
            animationSpeed: { enabled: true, variant: 'normal' },
            particleDensity: { enabled: true, variant: 'medium' },

            ...this.config.defaultFlags
        };

        for (const [key, value] of Object.entries(defaults)) {
            this.flags.set(key, value);
        }
    }

    async fetchFlags() {
        if (!this.config.endpoint) return;

        try {
            const response = await fetch(this.config.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    userId: this.config.userId,
                    attributes: this.config.attributes,
                    flags: Array.from(this.flags.keys())
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            this.updateFlags(data.flags);

            if (this.config.enableCache) {
                this.saveToStorage();
            }

            return data.flags;
        } catch (error) {
            if (this.callbacks.onError) {
                this.callbacks.onError(error);
            }
            console.error('Failed to fetch feature flags:', error);
        }
    }

    updateFlags(newFlags) {
        const changes = [];

        for (const [key, value] of Object.entries(newFlags)) {
            const oldValue = this.flags.get(key);

            if (!this.isEqual(oldValue, value)) {
                this.flags.set(key, value);
                changes.push({ key, oldValue, newValue: value });
            }
        }

        if (changes.length > 0 && this.callbacks.onFlagChange) {
            this.callbacks.onFlagChange(changes);
        }
    }

    isEqual(a, b) {
        if (a === b) return true;
        if (!a || !b) return false;
        return a.enabled === b.enabled && a.variant === b.variant;
    }

    isEnabled(flagKey, defaultValue = false) {
        // Check overrides first
        if (this.overrides.has(flagKey)) {
            return this.overrides.get(flagKey);
        }

        const flag = this.flags.get(flagKey);
        const enabled = flag ? flag.enabled : defaultValue;

        this.trackEvaluation(flagKey, enabled, flag?.variant || 'default');

        return enabled;
    }

    getVariant(flagKey, defaultVariant = 'default') {
        // Check variant overrides
        if (this.variants.has(flagKey)) {
            return this.variants.get(flagKey);
        }

        const flag = this.flags.get(flagKey);
        const variant = flag ? flag.variant : defaultVariant;

        this.trackEvaluation(flagKey, flag?.enabled || false, variant);

        return variant;
    }

    evaluate(flagKey, options = {}) {
        const {
            defaultEnabled = false,
            defaultVariant = 'default',
            attributes = {}
        } = options;

        // Merge attributes
        const evalAttributes = { ...this.config.attributes, ...attributes };

        // Check for targeted rules
        const flag = this.flags.get(flagKey);

        if (flag && flag.rules) {
            for (const rule of flag.rules) {
                if (this.evaluateRule(rule, evalAttributes)) {
                    const result = {
                        enabled: rule.enabled !== undefined ? rule.enabled : flag.enabled,
                        variant: rule.variant || flag.variant
                    };

                    this.trackEvaluation(flagKey, result.enabled, result.variant);
                    return result;
                }
            }
        }

        // Default evaluation
        const result = {
            enabled: this.isEnabled(flagKey, defaultEnabled),
            variant: this.getVariant(flagKey, defaultVariant)
        };

        return result;
    }

    evaluateRule(rule, attributes) {
        if (!rule.conditions) return true;

        for (const condition of rule.conditions) {
            if (!this.evaluateCondition(condition, attributes)) {
                return false;
            }
        }

        return true;
    }

    evaluateCondition(condition, attributes) {
        const { attribute, operator, value } = condition;
        const attrValue = attributes[attribute];

        switch (operator) {
        case 'equals':
            return attrValue === value;
        case 'not_equals':
            return attrValue !== value;
        case 'contains':
            return String(attrValue).includes(value);
        case 'not_contains':
            return !String(attrValue).includes(value);
        case 'greater_than':
            return Number(attrValue) > Number(value);
        case 'less_than':
            return Number(attrValue) < Number(value);
        case 'in':
            return value.includes(attrValue);
        case 'not_in':
            return !value.includes(attrValue);
        case 'matches':
            return new RegExp(value).test(String(attrValue));
        default:
            return false;
        }
    }

    trackEvaluation(flagKey, enabled, variant) {
        if (!this.config.enableAnalytics) return;

        const evaluation = {
            flagKey,
            enabled,
            variant,
            timestamp: Date.now(),
            userId: this.config.userId,
            attributes: this.config.attributes
        };

        // Track locally
        if (!this.evaluations.has(flagKey)) {
            this.evaluations.set(flagKey, []);
        }
        this.evaluations.get(flagKey).push(evaluation);

        // Callback
        if (this.callbacks.onEvaluation) {
            this.callbacks.onEvaluation(evaluation);
        }
    }

    override(flagKey, enabled, variant = null) {
        this.overrides.set(flagKey, enabled);

        if (variant !== null) {
            this.variants.set(flagKey, variant);
        }
    }

    clearOverride(flagKey) {
        this.overrides.delete(flagKey);
        this.variants.delete(flagKey);
    }

    clearAllOverrides() {
        this.overrides.clear();
        this.variants.clear();
    }

    getAllFlags() {
        const result = {};

        for (const [key, value] of this.flags) {
            result[key] = {
                ...value,
                overridden: this.overrides.has(key)
            };
        }

        return result;
    }

    getEnabledFlags() {
        const enabled = [];

        for (const [key, value] of this.flags) {
            if (this.isEnabled(key)) {
                enabled.push(key);
            }
        }

        return enabled;
    }

    saveToStorage() {
        if (!this.config.enableCache) return;

        try {
            const storage = this.getStorage();
            if (!storage) return;

            const data = {
                flags: Object.fromEntries(this.flags),
                timestamp: Date.now(),
                userId: this.config.userId
            };

            storage.setItem(this.config.storageKey, JSON.stringify(data));
        } catch (error) {
            console.error('Failed to save feature flags to storage:', error);
        }
    }

    loadFromStorage() {
        if (!this.config.enableCache) return;

        try {
            const storage = this.getStorage();
            if (!storage) return;

            const stored = storage.getItem(this.config.storageKey);
            if (!stored) return;

            const data = JSON.parse(stored);

            // Check if data is stale (older than refresh interval)
            if (Date.now() - data.timestamp > this.config.refreshInterval) {
                return;
            }

            this.updateFlags(data.flags);
        } catch (error) {
            console.error('Failed to load feature flags from storage:', error);
        }
    }

    getStorage() {
        try {
            if (this.config.storage === 'localStorage' && typeof localStorage !== 'undefined') {
                return localStorage;
            }
            if (this.config.storage === 'sessionStorage' && typeof sessionStorage !== 'undefined') {
                return sessionStorage;
            }
        } catch (e) {
            // Storage not available
        }
        return null;
    }

    startAutoRefresh() {
        if (this.refreshTimer) return;

        // Initial fetch
        this.fetchFlags();

        // Schedule periodic updates
        this.refreshTimer = setInterval(() => {
            this.fetchFlags();
        }, this.config.refreshInterval);
    }

    stopAutoRefresh() {
        if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
            this.refreshTimer = null;
        }
    }

    updateAttributes(attributes) {
        this.config.attributes = { ...this.config.attributes, ...attributes };

        // Refetch flags with new attributes
        if (this.config.endpoint) {
            this.fetchFlags();
        }
    }

    getAnalytics() {
        const analytics = {
            evaluations: {},
            summary: {
                total: 0,
                byFlag: {},
                byVariant: {}
            }
        };

        for (const [flagKey, evals] of this.evaluations) {
            analytics.evaluations[flagKey] = evals;
            analytics.summary.total += evals.length;

            analytics.summary.byFlag[flagKey] = {
                count: evals.length,
                enabled: evals.filter(e => e.enabled).length,
                variants: {}
            };

            for (const evaluation of evals) {
                if (!analytics.summary.byVariant[evaluation.variant]) {
                    analytics.summary.byVariant[evaluation.variant] = 0;
                }
                analytics.summary.byVariant[evaluation.variant]++;

                if (!analytics.summary.byFlag[flagKey].variants[evaluation.variant]) {
                    analytics.summary.byFlag[flagKey].variants[evaluation.variant] = 0;
                }
                analytics.summary.byFlag[flagKey].variants[evaluation.variant]++;
            }
        }

        return analytics;
    }

    reset() {
        this.flags.clear();
        this.overrides.clear();
        this.variants.clear();
        this.evaluations.clear();
        this.loadDefaultFlags();
    }

    destroy() {
        this.stopAutoRefresh();
        this.reset();
    }
}

// Create singleton instance (no endpoint configured to avoid 404 errors)
// Users can configure endpoint via: featureFlags.config.endpoint = '/api/feature-flags'; featureFlags.fetchFlags();
const featureFlags = new FeatureFlags({
    endpoint: null, // Disable auto-fetch to prevent 404 errors
    enableCache: true,
    enableAnalytics: false // Disable analytics since we're not fetching
});

// Helper functions
function isFeatureEnabled(flagKey, defaultValue = false) {
    return featureFlags.isEnabled(flagKey, defaultValue);
}

function getFeatureVariant(flagKey, defaultVariant = 'default') {
    return featureFlags.getVariant(flagKey, defaultVariant);
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                      ◐ ◑ ◒ ◓  ERROR RESPONSE  ◓ ◒ ◑ ◐                      
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Error Response - Standardized Error Formats & Recovery
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module ErrorResponse
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The ERROR STANDARDIZATION system of the engine. Provides consistent error        
 * ║ formats, recovery suggestions, and severity classifications for all              
 * ║ error conditions throughout the Emotive Engine.                                  
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🚨 ERROR TYPES                                                                    
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Validation Errors: Invalid emotions, gestures, parameters                       
 * │ • System Errors: Canvas/audio context, initialization failures                    
 * │ • Performance Errors: Degradation, memory limits, frame drops                     
 * │ • Resource Errors: Load/cleanup failures                                          
 * │ • Network Errors: Connectivity, audio loading                                     
 * │ • Compatibility Errors: Feature/browser support                                   
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */

class ErrorResponse {
    constructor(type, message, context = {}, severity = 'error') {
        this.success = false;
        this.error = {
            type,
            message,
            context,
            severity,
            timestamp: Date.now(),
            recoveryActions: this.generateRecoveryActions(type, context)
        };
    }

    /**
   * Create a successful response
   * @param {*} data - Response data
   * @returns {Object} Success response object
   */
    static success(data = null) {
        return { 
            success: true, 
            data,
            timestamp: Date.now()
        };
    }

    /**
   * Create a failure response
   * @param {string} type - Error type
   * @param {string} message - Error message
   * @param {Object} context - Error context
   * @param {string} severity - Error severity level
   * @returns {ErrorResponse} Error response object
   */
    static failure(type, message, context = {}, severity = 'error') {
        return new ErrorResponse(type, message, context, severity);
    }

    /**
   * Create a warning response (non-blocking)
   * @param {string} type - Warning type
   * @param {string} message - Warning message
   * @param {Object} context - Warning context
   * @returns {ErrorResponse} Warning response object
   */
    static warning(type, message, context = {}) {
        return new ErrorResponse(type, message, context, 'warning');
    }

    /**
   * Generate recovery actions based on error type
   * @param {string} type - Error type
   * @param {Object} context - Error context
   * @returns {Array} Array of recovery suggestions
   */
    generateRecoveryActions(type, context) {
        const recoveryMap = {
            'INVALID_EMOTION': [
                'Check if emotion is one of: joy, sadness, anger, fear, surprise, disgust, contempt, neutral',
                'Use EmotiveMascot.getAvailableEmotions() to see valid options'
            ],
            'INVALID_GESTURE': [
                'Verify gesture name matches available gestures',
                'Use EmotiveMascot.getAvailableGestures() to see valid options'
            ],
            'CANVAS_CONTEXT_LOST': [
                'Canvas context will attempt automatic recovery',
                'Reduce canvas size if problem persists',
                'Check for memory pressure or GPU issues'
            ],
            'AUDIO_CONTEXT_FAILED': [
                'Audio features will be disabled, visual features continue',
                'Check browser audio permissions',
                'Ensure user interaction occurred before audio initialization'
            ],
            'PERFORMANCE_DEGRADED': [
                'Particle count has been automatically reduced',
                'Consider reducing canvas size or complexity',
                'Monitor performance metrics for recovery'
            ],
            'MEMORY_LIMIT_EXCEEDED': [
                'System has automatically reduced resource usage',
                'Consider destroying unused mascot instances',
                'Monitor memory usage patterns'
            ],
            'VALIDATION_ERROR': [
                'Check parameter types and ranges',
                'Refer to API documentation for valid values',
                'Use default values if unsure'
            ],
            'INITIALIZATION_ERROR': [
                'Ensure canvas element exists and is accessible',
                'Check browser compatibility',
                'Verify all required dependencies are loaded'
            ]
        };

        return recoveryMap[type] || [
            'Check console for additional error details',
            'Refer to troubleshooting documentation',
            'Consider reporting this issue if it persists'
        ];
    }

    /**
   * Log error with appropriate level
   */
    log() {
        const logMethod = this.error.severity === 'warning' ? 'warn' : 'error';
        if (logMethod === 'warn') {
            console.warn(`[EmotiveMascot] ${this.error.type}: ${this.error.message}`, {
                context: this.error.context,
                recoveryActions: this.error.recoveryActions,
                timestamp: new Date(this.error.timestamp).toISOString()
            });
        } else {
            console.error(`[EmotiveMascot] ${this.error.type}: ${this.error.message}`, {
                context: this.error.context,
                recoveryActions: this.error.recoveryActions,
                timestamp: new Date(this.error.timestamp).toISOString()
            });
        }
    }

    /**
   * Get formatted error message for display
   * @returns {string} Formatted error message
   */
    getDisplayMessage() {
        return `${this.error.type}: ${this.error.message}`;
    }

    /**
   * Check if error is recoverable
   * @returns {boolean} True if error has recovery actions
   */
    isRecoverable() {
        return this.error.recoveryActions && this.error.recoveryActions.length > 0;
    }

    /**
   * Get error severity level
   * @returns {string} Severity level
   */
    getSeverity() {
        return this.error.severity;
    }

    /**
   * Convert to JSON for serialization
   * @returns {Object} JSON representation
   */
    toJSON() {
        return {
            success: this.success,
            error: this.error
        };
    }
}

/**
 * Error categories for consistent classification
 */
const ErrorTypes = {
    INVALID_PARAMETER: 'INVALID_PARAMETER',
    // Performance errors
    PERFORMANCE_DEGRADED: 'PERFORMANCE_DEGRADED',
    // Browser compatibility
    FEATURE_NOT_SUPPORTED: 'FEATURE_NOT_SUPPORTED'};

/**
 * Severity levels for error classification
 */
const ErrorSeverity = {
    CRITICAL: 'critical',  // System cannot continue
    ERROR: 'error',        // Feature fails but system continues
    WARNING: 'warning',    // Degraded functionality
    INFO: 'info'          // Informational only
};

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                       ◐ ◑ ◒ ◓  ERROR LOGGER  ◓ ◒ ◑ ◐                       
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Error Logger - Centralized Error Tracking & Diagnostics
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module ErrorLogger
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The DIAGNOSTICS CENTER of the engine. Tracks, logs, and reports errors           
 * ║ with full context preservation. Essential for debugging and monitoring            
 * ║ the health of the Emotive Engine in production environments.                      
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 📝 LOGGING FEATURES                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Structured error logging with severity levels                                   
 * │ • Context preservation (component, timestamp, stack trace)                        
 * │ • Error frequency tracking and throttling                                         
 * │ • Performance impact monitoring                                                   
 * │ • Automatic error suppression after threshold                                     
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class ErrorLogger {
    constructor(config = {}) {
        this.config = {
            enableConsoleLogging: config.enableConsoleLogging !== false,
            enableContextPreservation: config.enableContextPreservation !== false,
            maxLogEntries: config.maxLogEntries || 1000,
            logLevel: config.logLevel || ErrorSeverity.WARNING,
            ...config
        };
    
        this.logs = [];
        this.errorCounts = new Map();
        this.contextHistory = new Map();
        this.startTime = Date.now();
    }

    /**
   * Log an error with full context preservation
   * @param {ErrorResponse} errorResponse - Error response object
   * @param {Object} additionalContext - Additional context information
   */
    logError(errorResponse, additionalContext = {}) {
        const logEntry = this.createLogEntry(errorResponse, additionalContext);
    
        // Store log entry
        this.storeLogEntry(logEntry);
    
        // Update error counts
        this.updateErrorCounts(errorResponse.error.type);
    
        // Console logging if enabled
        if (this.config.enableConsoleLogging && this.shouldLog(errorResponse.error.severity)) {
            this.consoleLog(logEntry);
        }
    
        // Preserve context for debugging
        if (this.config.enableContextPreservation) {
            this.preserveContext(errorResponse.error.type, logEntry);
        }
    
        return logEntry;
    }

    /**
   * Create structured log entry
   * @param {ErrorResponse} errorResponse - Error response
   * @param {Object} additionalContext - Additional context
   * @returns {Object} Log entry object
   */
    createLogEntry(errorResponse, additionalContext) {
        return {
            id: this.generateLogId(),
            timestamp: Date.now(),
            relativeTime: Date.now() - this.startTime,
            type: errorResponse.error.type,
            message: errorResponse.error.message,
            severity: errorResponse.error.severity,
            context: {
                ...errorResponse.error.context,
                ...additionalContext,
                stackTrace: this.captureStackTrace(),
                userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',
                url: typeof window !== 'undefined' ? window.location.href : 'unknown'
            },
            recoveryActions: errorResponse.error.recoveryActions,
            errorCount: this.getErrorCount(errorResponse.error.type) + 1
        };
    }

    /**
   * Store log entry with size management
   * @param {Object} logEntry - Log entry to store
   */
    storeLogEntry(logEntry) {
        this.logs.push(logEntry);
    
        // Maintain maximum log size
        if (this.logs.length > this.config.maxLogEntries) {
            this.logs.shift(); // Remove oldest entry
        }
    }

    /**
   * Update error occurrence counts
   * @param {string} errorType - Error type
   */
    updateErrorCounts(errorType) {
        const currentCount = this.errorCounts.get(errorType) || 0;
        this.errorCounts.set(errorType, currentCount + 1);
    }

    /**
   * Preserve context for debugging
   * @param {string} errorType - Error type
   * @param {Object} logEntry - Log entry
   */
    preserveContext(errorType, logEntry) {
        if (!this.contextHistory.has(errorType)) {
            this.contextHistory.set(errorType, []);
        }
    
        const contexts = this.contextHistory.get(errorType);
        contexts.push({
            timestamp: logEntry.timestamp,
            context: logEntry.context,
            message: logEntry.message
        });
    
        // Keep only last 10 contexts per error type
        if (contexts.length > 10) {
            contexts.shift();
        }
    }

    /**
   * Console logging with appropriate formatting
   * @param {Object} logEntry - Log entry to log
   */
    consoleLog(logEntry) {
        const logMethod = this.getConsoleMethod(logEntry.severity);
        const timestamp = new Date(logEntry.timestamp).toISOString();
    
        if (logMethod === 'warn') {
            console.warn(
                `[EmotiveMascot] ${timestamp} ${logEntry.type}: ${logEntry.message}`,
                {
                    severity: logEntry.severity,
                    context: logEntry.context,
                    recoveryActions: logEntry.recoveryActions,
                    errorCount: logEntry.errorCount
                }
            );
        } else {
            console.error(
                `[EmotiveMascot] ${timestamp} ${logEntry.type}: ${logEntry.message}`,
                {
                    severity: logEntry.severity,
                    context: logEntry.context,
                    recoveryActions: logEntry.recoveryActions,
                    errorCount: logEntry.errorCount
                }
            );
        }
    }

    /**
   * Get appropriate console method for severity
   * @param {string} severity - Error severity
   * @returns {string} Console method name
   */
    getConsoleMethod(severity) {
        switch (severity) {
        case ErrorSeverity.CRITICAL:
            return 'error';
        case ErrorSeverity.ERROR:
            return 'error';
        case ErrorSeverity.WARNING:
            return 'warn';
        case ErrorSeverity.INFO:
            return 'warn';
        default:
            return 'warn';
        }
    }

    /**
   * Check if error should be logged based on level
   * @param {string} severity - Error severity
   * @returns {boolean} True if should log
   */
    shouldLog(severity) {
        const severityLevels = {
            [ErrorSeverity.CRITICAL]: 4,
            [ErrorSeverity.ERROR]: 3,
            [ErrorSeverity.WARNING]: 2,
            [ErrorSeverity.INFO]: 1
        };
    
        return severityLevels[severity] >= severityLevels[this.config.logLevel];
    }

    /**
   * Capture stack trace for debugging
   * @returns {string} Stack trace string
   */
    captureStackTrace() {
        try {
            throw new Error();
        } catch (e) {
            return e.stack || 'Stack trace not available';
        }
    }

    /**
   * Generate unique log ID
   * @returns {string} Unique log identifier
   */
    generateLogId() {
        return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
   * Get error count for specific type
   * @param {string} errorType - Error type
   * @returns {number} Error count
   */
    getErrorCount(errorType) {
        return this.errorCounts.get(errorType) || 0;
    }

    /**
   * Get all logs with optional filtering
   * @param {Object} filters - Filter criteria
   * @returns {Array} Filtered log entries
   */
    getLogs(filters = {}) {
        let filteredLogs = [...this.logs];
    
        if (filters.type) {
            filteredLogs = filteredLogs.filter(log => log.type === filters.type);
        }
    
        if (filters.severity) {
            filteredLogs = filteredLogs.filter(log => log.severity === filters.severity);
        }
    
        if (filters.since) {
            filteredLogs = filteredLogs.filter(log => log.timestamp >= filters.since);
        }
    
        if (filters.limit) {
            filteredLogs = filteredLogs.slice(-filters.limit);
        }
    
        return filteredLogs;
    }

    /**
   * Get error statistics
   * @returns {Object} Error statistics
   */
    getErrorStatistics() {
        const stats = {
            totalErrors: this.logs.length,
            errorsByType: Object.fromEntries(this.errorCounts),
            errorsBySeverity: {},
            recentErrors: this.logs.slice(-10),
            uptime: Date.now() - this.startTime
        };
    
        // Count by severity
        this.logs.forEach(log => {
            stats.errorsBySeverity[log.severity] = (stats.errorsBySeverity[log.severity] || 0) + 1;
        });
    
        return stats;
    }

    /**
   * Clear all logs
   */
    clearLogs() {
        this.logs = [];
        this.errorCounts.clear();
        this.contextHistory.clear();
    }

    /**
   * Export logs for external analysis
   * @param {string} format - Export format ('json' or 'csv')
   * @returns {string} Exported data
   */
    exportLogs(format = 'json') {
        if (format === 'json') {
            return JSON.stringify({
                logs: this.logs,
                statistics: this.getErrorStatistics(),
                exportTime: Date.now()
            }, null, 2);
        }
    
        if (format === 'csv') {
            const headers = ['timestamp', 'type', 'severity', 'message', 'errorCount'];
            const rows = this.logs.map(log => [
                new Date(log.timestamp).toISOString(),
                log.type,
                log.severity,
                log.message.replace(/"/g, '""'),
                log.errorCount
            ]);
      
            return [headers, ...rows]
                .map(row => row.map(cell => `"${cell}"`).join(','))
                .join('\n');
        }
    
        throw new Error(`Unsupported export format: ${format}`);
    }
}

// Global error logger instance
let globalErrorLogger = null;

/**
 * Get or create global error logger instance
 * @param {Object} config - Logger configuration
 * @returns {ErrorLogger} Global logger instance
 */
function getErrorLogger(config = {}) {
    if (!globalErrorLogger) {
        globalErrorLogger = new ErrorLogger(config);
    }
    return globalErrorLogger;
}

/**
 * Reset global error logger (mainly for testing)
 */
function resetErrorLogger() {
    globalErrorLogger = null;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *  ╔═○─┐ emotive
 *    ●●  ENGINE
 *  └─○═╝                                                                             
 *                   ◐ ◑ ◒ ◓  DEGRADATION MANAGER  ◓ ◒ ◑ ◐                   
 *                                                                                    
 * ═══════════════════════════════════════════════════════════════════════════════════════
 *
 * @fileoverview Degradation Manager - Graceful Performance Optimization
 * @author Emotive Engine Team
 * @version 2.0.0
 * @module DegradationManager
 * 
 * ╔═══════════════════════════════════════════════════════════════════════════════════
 * ║                                   PURPOSE                                         
 * ╠═══════════════════════════════════════════════════════════════════════════════════
 * ║ The ADAPTIVE BRAIN that ensures smooth performance across all devices.            
 * ║ Detects browser capabilities and system performance, then gracefully              
 * ║ degrades features to maintain 60fps. Better to look simpler than to lag!          
 * ╚═══════════════════════════════════════════════════════════════════════════════════
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🎯 QUALITY LEVELS                                                                  
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • HIGH    : All features enabled, max particles                                   
 * │ • MEDIUM  : Reduced particles, simpler effects                                    
 * │ • LOW     : Minimal particles, basic animations                                   
 * │ • MINIMAL : Core functionality only, no particles                                 
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ┌───────────────────────────────────────────────────────────────────────────────────
 * │ 🔍 DETECTION METHODS                                                               
 * ├───────────────────────────────────────────────────────────────────────────────────
 * │ • Browser capability detection                                                    
 * │ • FPS monitoring (degrades if < 30fps)                                            
 * │ • Device memory estimation                                                        
 * │ • GPU tier detection                                                              
 * │ • Battery level monitoring                                                        
 * └───────────────────────────────────────────────────────────────────────────────────
 *
 * ════════════════════════════════════════════════════════════════════════════════════
 */


class DegradationManager {
    constructor(config = {}) {
        this.config = {
            enableAutoOptimization: false, // TEMPORARILY DISABLED
            performanceThreshold: config.performanceThreshold || 30, // FPS
            memoryThreshold: config.memoryThreshold || 50, // MB
            degradationSteps: config.degradationSteps || 4,
            recoveryDelay: config.recoveryDelay || 1000, // ms - faster recovery
            enableManualControls: config.enableManualControls !== false,
            enableProgressiveEnhancement: config.enableProgressiveEnhancement !== false,
            ...config
        };

        // Error logger for degradation events
        this.errorLogger = getErrorLogger();

        // Degradation levels from optimal to emergency
        this.degradationLevels = [
            {
                name: 'optimal',
                particleLimit: 50,
                audioEnabled: true,
                fullEffects: true,
                targetFPS: 60,
                qualityLevel: 1.0,
                canvasScale: 1.0,
                animationComplexity: 1.0,
                description: 'Full features and effects',
                features: ['particles', 'audio', 'fullEffects', 'animations', 'highQuality']
            },
            {
                name: 'reduced',
                particleLimit: 25,
                audioEnabled: true,
                fullEffects: false,
                targetFPS: 45,
                qualityLevel: 0.8,
                canvasScale: 0.9,
                animationComplexity: 0.8,
                description: 'Reduced visual effects',
                features: ['particles', 'audio', 'animations', 'mediumQuality']
            },
            {
                name: 'minimal',
                particleLimit: 10,
                audioEnabled: false,
                fullEffects: false,
                targetFPS: 30,
                qualityLevel: 0.6,
                canvasScale: 0.8,
                animationComplexity: 0.6,
                description: 'Minimal visual effects, no audio',
                features: ['particles', 'animations', 'lowQuality']
            },
            {
                name: 'emergency',
                particleLimit: 5,  // Keep minimum particles even in emergency mode
                audioEnabled: false,
                fullEffects: false,
                targetFPS: 15,
                qualityLevel: 0.4,
                canvasScale: 0.7,
                animationComplexity: 0.4,
                description: 'Emergency mode - basic animation only',
                features: ['animations', 'particles']
            }
        ];

        this.currentLevel = 0; // Set to optimal since auto-optimization is disabled
        this.lastDegradationTime = 0;
        this.performanceHistory = [];
        this.maxHistorySize = 30; // 30 samples for averaging
        
        // Feature availability based on browser capabilities
        this.availableFeatures = this.assessAvailableFeatures();
        
        // Performance monitoring
        this.isMonitoring = false;
        this.monitoringInterval = null;
        
        // Recovery management
        this.recoveryTimeout = null;
        this.consecutiveGoodFrames = 0;
        this.requiredGoodFrames = 30; // 0.5 seconds at 60fps - faster recovery
        
        // Manual degradation controls
        this.manualOverride = null;
        this.disabledFeatures = new Set();
        
        // Progressive enhancement tracking
        this.enhancementHistory = [];
        this.capabilityTests = new Map();
        
        // DegradationManager initialized
    }

    /**
     * Assess available features based on browser capabilities
     * @returns {Object} Available features
     */
    assessAvailableFeatures() {
        const features = browserCompatibility.featureDetection.getFeatures();
        const {capabilities} = browserCompatibility;
        
        return {
            audio: features.webAudio && features.audioContext,
            particles: features.canvas2d,
            animations: features.requestAnimationFrame,
            performance: features.performance,
            fullQuality: capabilities.level === 'full',
            reducedMotion: this.detectReducedMotion(),
            highContrast: this.detectHighContrast()
        };
    }

    /**
     * Detect user preference for reduced motion
     * @returns {boolean} True if reduced motion is preferred
     */
    detectReducedMotion() {
        try {
            return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        } catch (e) {
            return false;
        }
    }

    /**
     * Detect high contrast mode
     * @returns {boolean} True if high contrast is enabled
     */
    detectHighContrast() {
        try {
            return window.matchMedia('(prefers-contrast: high)').matches;
        } catch (e) {
            return false;
        }
    }

    /**
     * Start performance monitoring
     */
    startMonitoring() {
        // TEMPORARILY DISABLED - DO NOT MONITOR
        return;
        
        // Performance monitoring started
    }

    /**
     * Stop performance monitoring
     */
    stopMonitoring() {
        if (!this.isMonitoring) return;
        
        this.isMonitoring = false;
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
        
        if (this.recoveryTimeout) {
            clearTimeout(this.recoveryTimeout);
            this.recoveryTimeout = null;
        }
        
        // Performance monitoring stopped
    }

    /**
     * Check current performance and apply degradation if needed
     * @param {Object} metrics - Performance metrics
     */
    checkPerformance(metrics = {}) {
        if (!this.config.enableAutoOptimization) return;
        
        const fps = metrics.fps || 60;
        const memoryUsage = metrics.memoryUsage || 0;
        
        // Add to performance history
        this.performanceHistory.push({ fps, memoryUsage, timestamp: Date.now() });
        if (this.performanceHistory.length > this.maxHistorySize) {
            this.performanceHistory.shift();
        }
        
        // Calculate average performance
        const avgFPS = this.performanceHistory.reduce((sum, sample) => sum + sample.fps, 0) / this.performanceHistory.length;
        const avgMemory = this.performanceHistory.reduce((sum, sample) => sum + sample.memoryUsage, 0) / this.performanceHistory.length;
        
        // Check if degradation is needed
        const needsDegradation = avgFPS < this.config.performanceThreshold || 
                                avgMemory > this.config.memoryThreshold;
        
        if (needsDegradation && this.canDegrade()) {
            this.applyDegradation();
        } else if (!needsDegradation && avgFPS > this.config.performanceThreshold * 1.1) {
            // Good performance - track for potential recovery (lower threshold for faster scaling up)
            this.consecutiveGoodFrames++;
            if (this.consecutiveGoodFrames >= this.requiredGoodFrames && this.canRecover()) {
                this.scheduleRecovery();
            }
        } else {
            this.consecutiveGoodFrames = 0;
        }
    }

    /**
     * Check if degradation can be applied
     * @returns {boolean} True if degradation is possible
     */
    canDegrade() {
        const now = Date.now();
        const timeSinceLastDegradation = now - this.lastDegradationTime;
        
        return this.currentLevel < this.degradationLevels.length - 1 && 
               timeSinceLastDegradation > 2000; // Minimum 2 seconds between degradations
    }

    /**
     * Check if recovery can be applied
     * @returns {boolean} True if recovery is possible
     */
    canRecover() {
        return this.currentLevel > 0;
    }

    /**
     * Apply degradation to the next level
     */
    applyDegradation() {
        if (!this.canDegrade()) return;
        
        this.currentLevel++;
        this.lastDegradationTime = Date.now();
        this.consecutiveGoodFrames = 0;
        
        const level = this.getCurrentLevel();
        // Silently apply performance degradation
        
        // Cancel any pending recovery
        if (this.recoveryTimeout) {
            clearTimeout(this.recoveryTimeout);
            this.recoveryTimeout = null;
        }
        
        // Emit degradation event
        this.emit('degradationApplied', {
            level: level.name,
            index: this.currentLevel,
            reason: 'performance',
            settings: level
        });
    }

    /**
     * Schedule recovery to a better performance level
     */
    scheduleRecovery() {
        if (this.recoveryTimeout) return; // Already scheduled
        
        this.recoveryTimeout = setTimeout(() => {
            this.applyRecovery();
            this.recoveryTimeout = null;
        }, this.config.recoveryDelay);
        
        // Recovery scheduled
    }

    /**
     * Apply recovery to the previous level
     */
    applyRecovery() {
        if (!this.canRecover()) return;
        
        this.currentLevel--;
        this.consecutiveGoodFrames = 0;
        
        const level = this.getCurrentLevel();
        // Performance recovery applied
        
        // Emit recovery event
        this.emit('recoveryApplied', {
            level: level.name,
            index: this.currentLevel,
            settings: level
        });
    }

    /**
     * Manually set degradation level
     * @param {number|string} level - Level index or name
     */
    setLevel(level) {
        let targetLevel;
        
        if (typeof level === 'string') {
            targetLevel = this.degradationLevels.findIndex(l => l.name === level);
            if (targetLevel === -1) {
                // Unknown degradation level
                return false;
            }
        } else if (typeof level === 'number') {
            targetLevel = Math.max(0, Math.min(this.degradationLevels.length - 1, level));
        } else {
            // Invalid degradation level type
            return false;
        }
        
        const previousLevel = this.currentLevel;
        this.currentLevel = targetLevel;
        
        const levelInfo = this.getCurrentLevel();
        // Degradation level manually set
        
        // Emit level change event
        this.emit('levelChanged', {
            previousLevel: this.degradationLevels[previousLevel].name,
            currentLevel: levelInfo.name,
            index: this.currentLevel,
            manual: true,
            settings: levelInfo
        });
        
        return true;
    }

    /**
     * Get current degradation level
     * @returns {Object} Current level configuration
     */
    getCurrentLevel() {
        return { ...this.degradationLevels[this.currentLevel] };
    }

    /**
     * Get all available degradation levels
     * @returns {Array<Object>} All degradation levels
     */
    getAllLevels() {
        return this.degradationLevels.map(level => ({ ...level }));
    }

    /**
     * Get feature availability
     * @returns {Object} Available features
     */
    getAvailableFeatures() {
        return { ...this.availableFeatures };
    }

    /**
     * Check if a specific feature is available
     * @param {string} feature - Feature name
     * @returns {boolean} True if feature is available
     */
    isFeatureAvailable(feature) {
        // Check if manually disabled first
        if (this.disabledFeatures.has(feature)) {
            return false;
        }
        
        const currentLevel = this.getCurrentLevel();
        
        switch (feature) {
        case 'audio':
            return this.availableFeatures.audio && currentLevel.audioEnabled;
        case 'particles':
            return this.availableFeatures.particles && currentLevel.particleLimit > 0;
        case 'fullEffects':
            return this.availableFeatures.fullQuality && currentLevel.fullEffects;
        case 'animations':
            return this.availableFeatures.animations;
        default:
            return this.availableFeatures[feature] || false;
        }
    }

    /**
     * Get recommended settings for current level
     * @returns {Object} Recommended settings
     */
    getRecommendedSettings() {
        const level = this.getCurrentLevel();
        const browserOpts = browserCompatibility.browserOptimizations.getOptimizations();
        
        return {
            maxParticles: Math.min(level.particleLimit, browserOpts.particleLimit),
            enableAudio: level.audioEnabled && this.availableFeatures.audio,
            enableFullEffects: level.fullEffects && this.availableFeatures.fullQuality,
            targetFPS: level.targetFPS,
            qualityLevel: level.qualityLevel,
            reducedMotion: this.availableFeatures.reducedMotion,
            highContrast: this.availableFeatures.highContrast
        };
    }

    /**
     * Get performance statistics
     * @returns {Object} Performance statistics
     */
    getPerformanceStats() {
        if (this.performanceHistory.length === 0) {
            return {
                avgFPS: 0,
                avgMemory: 0,
                samples: 0,
                currentLevel: this.getCurrentLevel().name
            };
        }
        
        const avgFPS = this.performanceHistory.reduce((sum, sample) => sum + sample.fps, 0) / this.performanceHistory.length;
        const avgMemory = this.performanceHistory.reduce((sum, sample) => sum + sample.memoryUsage, 0) / this.performanceHistory.length;
        const minFPS = Math.min(...this.performanceHistory.map(s => s.fps));
        const maxFPS = Math.max(...this.performanceHistory.map(s => s.fps));
        
        return {
            avgFPS: Math.round(avgFPS * 10) / 10,
            avgMemory: Math.round(avgMemory * 10) / 10,
            minFPS,
            maxFPS,
            samples: this.performanceHistory.length,
            currentLevel: this.getCurrentLevel().name,
            consecutiveGoodFrames: this.consecutiveGoodFrames,
            isMonitoring: this.isMonitoring
        };
    }

    /**
     * Reset to optimal level
     */
    reset() {
        this.currentLevel = 0;
        this.performanceHistory = [];
        this.consecutiveGoodFrames = 0;
        this.lastDegradationTime = 0;
        
        if (this.recoveryTimeout) {
            clearTimeout(this.recoveryTimeout);
            this.recoveryTimeout = null;
        }
        
        // DegradationManager reset to optimal level
        
        this.emit('reset', {
            level: this.getCurrentLevel().name
        });
    }

    /**
     * Event emitter functionality
     */
    emit(event, data) {
        // Simple event emission - can be enhanced with proper EventEmitter
        if (this.onEvent) {
            this.onEvent(event, data);
        }
    }

    /**
     * Set event callback
     * @param {Function} callback - Event callback function
     */
    setEventCallback(callback) {
        this.onEvent = callback;
    }

    /**
     * Manual degradation controls
     */

    /**
     * Manually disable a specific feature
     * @param {string} feature - Feature to disable
     * @returns {Object} Operation result
     */
    disableFeature(feature) {
        if (!this.config.enableManualControls) {
            return ErrorResponse.failure(
                ErrorTypes.FEATURE_NOT_SUPPORTED,
                'Manual controls are disabled',
                { feature, enableManualControls: this.config.enableManualControls }
            );
        }

        const validFeatures = ['particles', 'audio', 'fullEffects', 'animations'];
        if (!validFeatures.includes(feature)) {
            return ErrorResponse.failure(
                ErrorTypes.INVALID_PARAMETER,
                `Invalid feature: ${feature}`,
                { feature, validFeatures }
            );
        }

        this.disabledFeatures.add(feature);
        
        this.errorLogger.logError(
            ErrorResponse.warning(
                ErrorTypes.FEATURE_NOT_SUPPORTED,
                `Feature manually disabled: ${feature}`,
                { feature, disabledFeatures: Array.from(this.disabledFeatures) }
            )
        );

        this.emit('featureDisabled', { feature, manual: true });
        return ErrorResponse.success({ feature, disabled: true });
    }

    /**
     * Manually enable a specific feature
     * @param {string} feature - Feature to enable
     * @returns {Object} Operation result
     */
    enableFeature(feature) {
        if (!this.config.enableManualControls) {
            return ErrorResponse.failure(
                ErrorTypes.FEATURE_NOT_SUPPORTED,
                'Manual controls are disabled',
                { feature, enableManualControls: this.config.enableManualControls }
            );
        }

        if (!this.availableFeatures[feature]) {
            return ErrorResponse.failure(
                ErrorTypes.FEATURE_NOT_SUPPORTED,
                `Feature not available in browser: ${feature}`,
                { feature, availableFeatures: this.availableFeatures }
            );
        }

        this.disabledFeatures.delete(feature);
        
        // Feature manually enabled

        this.emit('featureEnabled', { feature, manual: true });
        return ErrorResponse.success({ feature, enabled: true });
    }

    /**
     * Set manual override for degradation level
     * @param {string|number|null} level - Level to override to, or null to remove override
     * @returns {Object} Operation result
     */
    setManualOverride(level) {
        if (!this.config.enableManualControls) {
            return ErrorResponse.failure(
                ErrorTypes.FEATURE_NOT_SUPPORTED,
                'Manual controls are disabled'
            );
        }

        if (level === null) {
            this.manualOverride = null;
            // Manual override removed
            this.emit('manualOverrideRemoved', {});
            return ErrorResponse.success({ override: null });
        }

        const setResult = this.setLevel(level);
        if (setResult) {
            this.manualOverride = this.currentLevel;
            // Manual override set
            this.emit('manualOverrideSet', { level: this.getCurrentLevel().name });
            return ErrorResponse.success({ override: this.getCurrentLevel().name });
        }

        return ErrorResponse.failure(
            ErrorTypes.INVALID_PARAMETER,
            'Failed to set manual override',
            { level }
        );
    }

    /**
     * Progressive enhancement features
     */

    /**
     * Test browser capability for a specific feature
     * @param {string} feature - Feature to test
     * @param {Function} testFn - Test function that returns boolean
     * @returns {Object} Test result
     */
    testCapability(feature, testFn) {
        if (!this.config.enableProgressiveEnhancement) {
            return ErrorResponse.failure(
                ErrorTypes.FEATURE_NOT_SUPPORTED,
                'Progressive enhancement is disabled'
            );
        }

        try {
            const startTime = performance.now();
            const result = testFn();
            const duration = performance.now() - startTime;

            const testResult = {
                feature,
                supported: Boolean(result),
                duration,
                timestamp: Date.now()
            };

            this.capabilityTests.set(feature, testResult);
            
            // Capability test completed

            return ErrorResponse.success(testResult);
        } catch (error) {
            const testResult = {
                feature,
                supported: false,
                error: error.message,
                timestamp: Date.now()
            };

            this.capabilityTests.set(feature, testResult);
            
            this.errorLogger.logError(
                ErrorResponse.failure(
                    ErrorTypes.FEATURE_NOT_SUPPORTED,
                    `Capability test failed: ${feature}`,
                    { error: error.message, feature }
                )
            );

            return ErrorResponse.failure(
                ErrorTypes.FEATURE_NOT_SUPPORTED,
                `Capability test failed: ${error.message}`,
                testResult
            );
        }
    }

    /**
     * Get capability test results
     * @returns {Object} All capability test results
     */
    getCapabilityTests() {
        return Object.fromEntries(this.capabilityTests);
    }

    /**
     * Progressive enhancement based on detected capabilities
     * @returns {Object} Enhancement result
     */
    applyProgressiveEnhancement() {
        if (!this.config.enableProgressiveEnhancement) {
            return ErrorResponse.failure(
                ErrorTypes.FEATURE_NOT_SUPPORTED,
                'Progressive enhancement is disabled'
            );
        }

        const enhancements = [];
        const currentLevel = this.getCurrentLevel();

        // Test for enhanced audio capabilities
        if (this.availableFeatures.audio && currentLevel.audioEnabled) {
            const audioTest = this.capabilityTests.get('advancedAudio');
            if (audioTest && audioTest.supported) {
                enhancements.push('advancedAudio');
            }
        }

        // Test for enhanced particle capabilities
        if (this.availableFeatures.particles && currentLevel.particleLimit > 0) {
            const particleTest = this.capabilityTests.get('advancedParticles');
            if (particleTest && particleTest.supported) {
                enhancements.push('advancedParticles');
            }
        }

        // Test for enhanced animation capabilities
        if (this.availableFeatures.animations) {
            const animationTest = this.capabilityTests.get('advancedAnimations');
            if (animationTest && animationTest.supported) {
                enhancements.push('advancedAnimations');
            }
        }

        this.enhancementHistory.push({
            timestamp: Date.now(),
            level: currentLevel.name,
            enhancements: [...enhancements]
        });

        // Progressive enhancement applied

        this.emit('progressiveEnhancementApplied', { enhancements });
        return ErrorResponse.success({ enhancements });
    }

    /**
     * Enhanced feature availability detection
     */

    /**
     * Get detailed feature availability report
     * @returns {Object} Detailed feature report
     */
    getFeatureAvailabilityReport() {
        const currentLevel = this.getCurrentLevel();
        const report = {
            currentLevel: currentLevel.name,
            availableFeatures: {},
            disabledFeatures: Array.from(this.disabledFeatures),
            manualOverride: this.manualOverride,
            browserCapabilities: this.availableFeatures,
            capabilityTests: this.getCapabilityTests(),
            recommendations: []
        };

        // Check each feature availability
        for (const feature of ['particles', 'audio', 'fullEffects', 'animations']) {
            const available = this.isFeatureAvailable(feature);
            const browserSupported = this.availableFeatures[feature];
            const levelSupported = currentLevel.features.includes(feature);
            const manuallyDisabled = this.disabledFeatures.has(feature);

            report.availableFeatures[feature] = {
                available,
                browserSupported,
                levelSupported,
                manuallyDisabled,
                reason: !available ? this.getFeatureUnavailableReason(feature) : null
            };

            // Generate recommendations
            if (!available && browserSupported && !manuallyDisabled) {
                if (!levelSupported) {
                    report.recommendations.push(`${feature} disabled due to performance level - consider improving performance`);
                }
            }
        }

        return report;
    }

    /**
     * Get reason why a feature is unavailable
     * @param {string} feature - Feature name
     * @returns {string} Reason for unavailability
     */
    getFeatureUnavailableReason(feature) {
        if (!this.availableFeatures[feature]) {
            return 'Browser does not support this feature';
        }
        
        if (this.disabledFeatures.has(feature)) {
            return 'Feature manually disabled';
        }
        
        const currentLevel = this.getCurrentLevel();
        if (!currentLevel.features.includes(feature)) {
            return `Feature disabled at ${currentLevel.name} performance level`;
        }
        
        return 'Unknown reason';
    }

    /**
     * Enhanced performance monitoring with degradation context
     */

    /**
     * Check performance with enhanced error handling
     * @param {Object} metrics - Performance metrics
     * @returns {Object} Performance check result
     */
    checkPerformanceEnhanced(metrics = {}) {
        try {
            // Skip if manual override is active
            if (this.manualOverride !== null) {
                return ErrorResponse.success({
                    message: 'Performance check skipped - manual override active',
                    manualOverride: this.getCurrentLevel().name
                });
            }

            this.checkPerformance(metrics);
            
            return ErrorResponse.success({
                message: 'Performance check completed',
                currentLevel: this.getCurrentLevel().name,
                metrics: this.getPerformanceStats()
            });
        } catch (error) {
            this.errorLogger.logError(
                ErrorResponse.failure(
                    ErrorTypes.PERFORMANCE_DEGRADED,
                    'Performance check failed',
                    { error: error.message, metrics }
                )
            );
            
            return ErrorResponse.failure(
                ErrorTypes.PERFORMANCE_DEGRADED,
                'Performance check failed',
                { error: error.message }
            );
        }
    }

    /**
     * Get comprehensive degradation status
     * @returns {Object} Complete degradation status
     */
    getDegradationStatus() {
        return {
            currentLevel: this.getCurrentLevel(),
            availableFeatures: this.getAvailableFeatures(),
            featureReport: this.getFeatureAvailabilityReport(),
            performanceStats: this.getPerformanceStats(),
            config: {
                enableAutoOptimization: this.config.enableAutoOptimization,
                enableManualControls: this.config.enableManualControls,
                enableProgressiveEnhancement: this.config.enableProgressiveEnhancement,
                performanceThreshold: this.config.performanceThreshold,
                memoryThreshold: this.config.memoryThreshold
            },
            history: {
                performance: this.performanceHistory.slice(-10), // Last 10 samples
                enhancements: this.enhancementHistory.slice(-5) // Last 5 enhancements
            }
        };
    }

    /**
     * Cleanup resources
     */
    destroy() {
        this.stopMonitoring();
        this.performanceHistory = [];
        this.enhancementHistory = [];
        this.capabilityTests.clear();
        this.disabledFeatures.clear();
        this.onEvent = null;
        this.manualOverride = null;
        
        // DegradationManager destroyed
    }
}

/**
 * SiteController - thin wrapper around EmotiveMascot for site integrations.
 * Provides a stable entry point for positioning, gesture, and playback helpers.
 */
class SiteController {
  /**
   * @param {{ mascot: any, onError?: (error: Error) => void }} [options]
   */
  constructor(options = {}) {
    const { mascot = null, onError } = options;
    this.mascot = mascot;
    this._onError = onError ?? ((error) => {
      if (process.env.NODE_ENV !== 'production') {
        console.error('SiteController error:', error);
      }
    });
  }

  /**
   * Update the mascot reference if the caller reinitialises the engine.
   * @param {any} mascot
   */
  updateMascot(mascot) {
    this.mascot = mascot;
    return this
  }

  /**
   * @returns {any|null}
   */
  get positionController() {
    return this.mascot?.positionController ?? null
  }

  /**
   * @returns {any|null}
   */
  getElementTargeting() {
    return this.positionController?.getElementTargeting?.() ?? null
  }

  /**
   * Move the mascot toward a DOM element using the engine path helper when available.
   * @param {string} selector
   * @param {{ offset?: { x: number; y: number }, speed?: number, easing?: string, coordinateSystem?: string }} [options]
   */
  moveToElement(selector, options = {}) {
    return this.moveToElementWithPath(selector, [], 'center', options.offset ?? { x: 0, y: 0 }, options)
  }

  /**
   * Move the mascot using explicit path points.
   * @param {string} selector
   * @param {Array<{ x: number; y: number }>} pathPoints
   * @param {'center' | 'start' | 'end'} [alignment]
   * @param {{ x: number; y: number }} [offset]
   * @param {{ speed?: number; easing?: string; coordinateSystem?: string }} [options]
   */
  moveToElementWithPath(selector, pathPoints = [], alignment = 'center', offset = { x: 0, y: 0 }, options = {}) {
    const controller = this.positionController;
    if (!controller) {
      return undefined
    }

    const elementTargeting = controller.getElementTargeting?.();
    const speed = options.speed ?? 320;
    const easing = options.easing ?? 'easeInOutCubic';
    const coordinateSystem = options.coordinateSystem ?? 'viewport';

    if (elementTargeting?.moveToElementWithPath) {
      try {
        return elementTargeting.moveToElementWithPath(
          selector,
          pathPoints,
          alignment,
          offset,
          { coordinateSystem, speed, easing }
        )
      } catch (error) {
        this._handleError(error);
      }
    }

    if (controller.setOffset) {
      controller.setOffset(offset.x, offset.y, 0);
    }

    return undefined
  }

  /**
   * Directly set the mascot offset.
   */
  setOffset(x, y, z = 0) {
    try {
      this.positionController?.setOffset?.(x, y, z);
    } catch (error) {
      this._handleError(error);
    }
  }

  /**
   * Get the current offset from the position controller.
   */
  getOffset() {
    try {
      return this.positionController?.getOffset?.() ?? { x: 0, y: 0 }
    } catch (error) {
      this._handleError(error);
      return { x: 0, y: 0 }
    }
  }

  /**
   * Update mascot emotion.
   */
  setEmotion(emotion) {
    try {
      this.mascot?.setEmotion?.(emotion);
    } catch (error) {
      this._handleError(error);
    }
  }

  /**
   * Trigger gesture or chain.
   */
  express(gesture, options = {}) {
    try {
      if (options.chain && this.mascot?.chain) {
        this.mascot.chain(gesture);
        return
      }
      this.mascot?.express?.(gesture);
    } catch (error) {
      this._handleError(error);
    }
  }

  /**
   * Stop active paths/animations without destroying configuration.
   */
  stop() {
    try {
      const controller = this.positionController;
      controller?.stopCurrentPath?.();
      controller?.stop?.();
      this.mascot?.pause?.();
    } catch (error) {
      this._handleError(error);
    }
  }

  /**
   * Resume mascot playback.
   */
  play() {
    try {
      this.mascot?.play?.();
    } catch (error) {
      this._handleError(error);
    }
  }

  /**
   * Destroy controller references and clear listeners.
   */
  destroy() {
    this.stop();
    this.mascot = null;
  }

  _handleError(error) {
    if (error instanceof Error) {
      this._onError(error);
    } else {
      this._onError(new Error(String(error)));
    }
  }
}

/**
 * Emotive Engine - Main Export
 *
 * This is the primary entry point for the Emotive Engine library.
 * It provides a clean API surface for consumers.
 *
 * @module emotive-engine
 * @version 2.4.0
 */


// ============================================================================
// VERSION INFO
// ============================================================================

const VERSION = '2.4.0';
const ENGINE_NAME = 'Emotive Engine';

// ============================================================================
// FEATURE FLAGS
// ============================================================================

const FEATURES = {
    rhythmSync: true,
    grooveTemplates: true,
    gestureBlending: true,
    audioReactive: true,
    particleSystem: true,
    accessibility: true,
    mobileOptimization: true,
    performanceMonitoring: true
};

/**
 * Core exports for code splitting
 * Contains essential systems needed for basic functionality
 */

var coreExports = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AnimationController: AnimationController,
    AnimationLoopManager: AnimationLoopManager,
    AnimationPriority: AnimationPriority,
    CanvasManager: CanvasManager,
    ContextStateManager: ContextStateManager,
    EmotiveRenderer: EmotiveRenderer,
    EmotiveStateMachine: EmotiveStateMachine,
    ErrorTracker: ErrorTracker,
    EventManager: EventManager,
    GradientCache: GradientCache,
    PerformanceMonitor: PerformanceMonitor,
    StateStore: StateStore,
    animationLoopManager: animationLoopManager,
    engineState: engineState,
    errorTracker: errorTracker,
    eventManager: eventManager,
    gradientCache: gradientCache,
    performanceMonitor: performanceMonitor
});

/**
 * Feature exports for code splitting
 * Contains optional features that can be loaded on-demand
 */

var featuresExports = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AudioAnalyzer: AudioAnalyzer,
    AudioLevelProcessor: AudioLevelProcessor,
    IdleBehavior: IdleBehavior,
    ParticleSystem: ParticleSystem,
    SoundSystem: SoundSystem
});

/**
 * Plugin exports for code splitting
 * Contains plugin system and extensions
 */


// Note: Plugin files are example templates only
// No actual plugin classes exist yet in production

var pluginsExports = /*#__PURE__*/Object.freeze({
    __proto__: null,
    EMOTIONAL_COLORS: EMOTIONAL_COLORS,
    EMOTIONAL_COLORS_RGB: EMOTIONAL_COLORS_RGB,
    UNDERTONE_SATURATION: UNDERTONE_SATURATION,
    adjustBrightness: adjustBrightness,
    adjustSaturation: adjustSaturation,
    applyUndertoneSaturation: applyUndertoneSaturation,
    applyUndertoneSaturationToArray: applyUndertoneSaturationToArray,
    getContrastRatio: getContrastRatio,
    getLuminance: getLuminance,
    getUndertoneSaturationFactor: getUndertoneSaturationFactor,
    hexToRgb: hexToRgb,
    hexToRgba: hexToRgba,
    hslToRgb: hslToRgb,
    interpolateHsl: interpolateHsl,
    interpolateRgb: interpolateRgb,
    rgbToHex: rgbToHex,
    rgbToHsl: rgbToHsl
});

export { AccessibilityManager, AnimationController, AnimationLoopManager, AnimationPriority, AudioAnalyzer, AudioLevelProcessor, CanvasManager, ContextStateManager, DegradationManager, ENGINE_NAME, EmotiveMascot, EmotiveMascotPublic, EmotiveRenderer, EmotiveStateMachine, ErrorBoundary, ErrorLogger, ErrorTracker, EventManager, FEATURES, FeatureFlags, GESTURE_REGISTRY, GESTURE_TYPES, GazeTracker, GradientCache, GrooveTemplates, HealthCheck, IdleBehavior, LazyLoader, MobileOptimization, ParticleSystem, PerformanceMonitor, SecurityManager, SiteController, SoundSystem, StateStore, UNDERTONE_MODIFIERS, VERSION, animationLoopManager, applyGesture, browserCompatibility, EmotiveMascotPublic as default, engineState, errorTracker, eventManager, featureFlags, getBrowserCompatibility, getEmotion, getEmotionGestures, getEmotionVisualParams, getErrorLogger, getFeatureVariant, getGesture$1 as getGesture, gradientCache, hasEmotion, healthCheck, initializeBrowserCompatibility, isBlendingGesture, isFeatureEnabled, isOverrideGesture, lazyLoad, lazyLoader, listEmotions, listGestures, performanceMonitor, polyfillPerformanceNow, polyfillRequestAnimationFrame, polyfillWebAudio, prefetchModules, preloadModules, resetErrorLogger, securityManager };
