<!DOCTYPE html>
<!--
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  GROOVE SYSTEM - Emotive Engine 3D Demo
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  A comprehensive demonstration of the Emotive Engine's audio-reactive groove
  system. This demo showcases real-time BPM detection, groove presets, and
  the Dance Choreographer that automatically triggers gestures to music.

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  WHAT YOU'LL LEARN                                                          â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚  1. Audio Integration                                                       â”‚
  â”‚     - Connecting audio sources (files, drag-drop, built-in tracks)          â”‚
  â”‚     - Web Audio API integration with AudioContext                           â”‚
  â”‚     - CORS-friendly audio decoding for cross-origin sources                 â”‚
  â”‚                                                                             â”‚
  â”‚  2. BPM Detection                                                           â”‚
  â”‚     - Agent-based tempo detection with confidence scoring                   â”‚
  â”‚     - Multi-stage lock system (detecting â†’ locked â†’ finalized)              â”‚
  â”‚     - Tap tempo as manual fallback                                          â”‚
  â”‚                                                                             â”‚
  â”‚  3. Groove System                                                           â”‚
  â”‚     - Three preset grooves: Subtle, Energetic, Flowing                      â”‚
  â”‚     - Beat-synced transitions (1, 2, 4, or 8 bars)                          â”‚
  â”‚     - Groove blending with intensity control                                â”‚
  â”‚                                                                             â”‚
  â”‚  4. Dance Choreographer                                                     â”‚
  â”‚     - Automatic gesture triggering based on audio energy                    â”‚
  â”‚     - Accent gestures (pop, bob, swell) that enhance groove                 â”‚
  â”‚     - Climactic gestures (burst, spin) for high-energy moments              â”‚
  â”‚     - Rate-limited glow effects for visual safety                           â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Complexity: â­â­â­â­ Advanced
  Features: Audio analysis, BPM detection, groove presets, dance choreography
  Prerequisites: Basic understanding of Web Audio API helpful but not required
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Groove System Test - Emotive Engine 3D</title>
    <meta name="description" content="Test BPM detection and groove presets with real-time audio analysis">

    <!-- Shared 3D example styles -->
    <link rel="stylesheet" href="/examples/3d-example-style.css">

    <style>
        /* Theme: Purple/violet for groove */
        :root {
            --accent: #7c3aed;
            --accent-rgb: 124, 58, 237;
        }

        body {
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
        }

        /* BPM Display */
        .bpm-display {
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        .bpm-main {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .bpm-value {
            font-size: 2rem;
            font-weight: 700;
            font-family: 'Monaco', 'Consolas', monospace;
            color: var(--accent);
            transition: color 0.3s;
        }

        .bpm-value.locked {
            color: #fbbf24; /* Gold for final lock */
        }

        .bpm-value.stage1 {
            color: #f97316; /* Orange for Stage 1 */
        }

        .bpm-value.stage2 {
            color: #facc15; /* Yellow for Stage 2 */
        }

        .bpm-value.stage3 {
            color: #22c55e; /* Green for Stage 3 */
        }

        .bpm-label {
            font-size: 0.75rem;
            color: #808080;
            text-transform: uppercase;
        }

        .confidence-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 0.75rem;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #f59e0b, #10b981);
            border-radius: 2px;
            transition: width 0.2s;
            width: 0%;
        }

        .lock-status {
            font-size: 0.65rem;
            color: #808080;
            margin-top: 0.25rem;
            display: flex;
            justify-content: space-between;
        }

        .lock-status.locked {
            color: #fbbf24; /* Gold for final lock */
        }

        .lock-status.stage1 {
            color: #f97316; /* Orange */
        }

        .lock-status.stage2 {
            color: #facc15; /* Yellow */
        }

        .lock-status.stage3 {
            color: #22c55e; /* Green */
        }

        .beat-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(124, 58, 237, 0.3);
            transition: all 0.1s;
        }

        .beat-indicator.on {
            background: var(--accent);
            box-shadow: 0 0 20px rgba(124, 58, 237, 0.8);
        }

        /* Audio Controls */
        .audio-row {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .track-select {
            flex: 1;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.875rem;
        }

        input[type="file"] {
            display: none;
        }

        /* Global drop overlay - covers entire viewport */
        .global-drop-overlay {
            position: fixed;
            inset: 0;
            background: rgba(124, 58, 237, 0.15);
            backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .global-drop-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .global-drop-content {
            background: rgba(20, 20, 30, 0.95);
            border: 3px dashed var(--accent);
            border-radius: 24px;
            padding: 3rem 4rem;
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .global-drop-overlay.active .global-drop-content {
            transform: scale(1);
            box-shadow: 0 0 60px rgba(124, 58, 237, 0.4);
        }

        .global-drop-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: bounce 0.6s ease infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .global-drop-text {
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.5rem;
        }

        .global-drop-hint {
            font-size: 0.9rem;
            color: #a0a0a0;
        }

        /* Audio source - mutually exclusive rows */
        .audio-source-row,
        .custom-file-row {
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
            margin-bottom: 0.5rem;
        }

        .audio-source-row .track-select {
            flex: 1 1 auto;
            min-width: 0;  /* Allow shrinking below content size */
        }

        .audio-source-row button {
            flex: 0 0 auto;
            white-space: nowrap;
        }

        /* Custom file row - replaces track selector when file loaded */
        .custom-file-row {
            display: none;
        }

        .custom-file-row.visible {
            display: flex;
        }

        .custom-file-row.visible + .audio-source-row,
        .audio-source-row.hidden {
            display: none;
        }

        .custom-file-display {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-button);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            min-width: 0;
            cursor: pointer;
        }

        .custom-file-display:hover {
            background: var(--bg-button-hover);
            border-color: rgba(var(--accent-rgb), 0.3);
        }

        .custom-file-display .file-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }

        .custom-file-display .file-meta {
            font-size: 0.65rem;
            color: var(--text-muted);
            white-space: nowrap;
            flex-shrink: 0;
        }

        .clear-btn {
            width: 32px;
            min-width: 32px;
            padding: 0;
            font-size: 1.1rem;
            line-height: 1;
            color: var(--text-muted);
        }

        .clear-btn:hover {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.4);
            color: #f87171;
        }

        /* Groove Presets */
        .groove-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .groove-btn {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            color: white;
        }

        .groove-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .groove-btn.active {
            border-color: var(--accent);
            background: rgba(124, 58, 237, 0.1);
        }

        .groove-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            flex-shrink: 0;
        }

        .groove-btn[data-groove="groove1"] .groove-icon {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
        }

        .groove-btn[data-groove="groove2"] .groove-icon {
            background: linear-gradient(135deg, #f59e0b, #ef4444);
        }

        .groove-btn[data-groove="groove3"] .groove-icon {
            background: linear-gradient(135deg, #10b981, #06b6d4);
        }

        .groove-info h3 {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.25rem;
        }

        .groove-info p {
            font-size: 0.75rem;
            color: #808080;
        }

        /* Transition Controls */
        .transition-row {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.75rem;
        }

        .transition-row label {
            font-size: 0.75rem;
            color: #a0a0a0;
            white-space: nowrap;
        }

        .transition-row select {
            flex: 1;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.875rem;
        }

        /* Status Log */
        .log {
            height: 150px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
        }

        .log-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: #606060;
            margin-right: 0.5rem;
        }

        .log-groove { color: #7c3aed; }
        .log-bpm { color: #f59e0b; }
        .log-info { color: #10b981; }
        .log-error { color: #ef4444; }
        .log-gesture { color: #ec4899; }

        /* Footer info */
        .footer-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #606060;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .current-groove {
            color: var(--accent);
            font-weight: 600;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           COMPACT BPM DISPLAY (inactive state)
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .bpm-display.compact {
            padding: 0.5rem 0.75rem;
        }

        .bpm-display.compact .bpm-value {
            font-size: 1.25rem;
        }

        .bpm-display.compact .confidence-bar,
        .bpm-display.compact .lock-status {
            display: none;
        }

        .bpm-display.compact .bpm-main {
            margin-bottom: 0;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           COLLAPSIBLE ADVANCED GESTURES SECTION
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .advanced-gestures {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .advanced-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 0.7rem;
            color: #808080;
            margin-bottom: 0.5rem;
            user-select: none;
        }

        .advanced-toggle:hover {
            color: #a0a0a0;
        }

        .advanced-toggle .chevron {
            transition: transform 0.2s;
            font-size: 0.6rem;
        }

        .advanced-toggle.collapsed .chevron {
            transform: rotate(-90deg);
        }

        .advanced-content {
            display: block;
        }

        .advanced-toggle.collapsed + .advanced-content {
            display: none;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HIDE KEYBOARD SHORTCUTS ON TOUCH DEVICES
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (pointer: coarse) {
            .keyboard-shortcuts-info {
                display: none;
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           DEBUG SECTION (collapsed by default)
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .debug-section .section-content {
            display: block;
        }

        .debug-section.collapsed .section-content {
            display: none;
        }

        .debug-section h2 {
            cursor: pointer;
            user-select: none;
        }

        .debug-section h2::after {
            content: 'â–¼';
            font-size: 0.6rem;
            margin-left: 0.5rem;
            opacity: 0.5;
            transition: transform 0.2s;
        }

        .debug-section.collapsed h2::after {
            transform: rotate(-90deg);
        }

        .debug-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .debug-buttons button {
            flex: 1;
            font-size: 0.75rem;
            padding: 0.4rem;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           DANCE CHOREOGRAPHER PANEL
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .dance-panel {
            max-height: 400px;
            overflow-y: auto;
        }

        .dance-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .dance-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .intensity-slider {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .intensity-slider label {
            font-size: 0.7rem;
            color: #a0a0a0;
            white-space: nowrap;
        }

        .intensity-slider input[type="range"] {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
        }

        .intensity-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .intensity-value {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent);
            min-width: 2.5rem;
            text-align: right;
        }

        .gesture-section {
            margin-bottom: 0.75rem;
        }

        .gesture-section-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            color: #808080;
            margin-bottom: 0.4rem;
            letter-spacing: 0.5px;
        }

        .gesture-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .gesture-chip {
            padding: 0.25rem 0.5rem;
            font-size: 0.65rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: #a0a0a0;
            transition: all 0.15s ease;
        }

        .gesture-chip.active {
            background: rgba(124, 58, 237, 0.3);
            border-color: var(--accent);
            color: #fff;
            box-shadow: 0 0 8px rgba(124, 58, 237, 0.4);
        }

        .gesture-chip.glow-type {
            border-color: rgba(251, 191, 36, 0.3);
        }

        .gesture-chip.glow-type.active {
            background: rgba(251, 191, 36, 0.3);
            border-color: #fbbf24;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
        }

        /* Accent gestures - dance-friendly, work WITH groove */
        .gesture-chip.accent-type {
            border-color: rgba(16, 185, 129, 0.4);
            background: rgba(16, 185, 129, 0.08);
        }

        .gesture-chip.accent-type:hover {
            border-color: rgba(16, 185, 129, 0.6);
            background: rgba(16, 185, 129, 0.15);
        }

        .gesture-chip.accent-type.active {
            background: rgba(16, 185, 129, 0.35);
            border-color: #10b981;
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
        }

        .combo-chip {
            padding: 0.3rem 0.6rem;
            font-size: 0.7rem;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 4px;
            color: #10b981;
            transition: all 0.15s ease;
        }

        .combo-chip.active {
            background: rgba(16, 185, 129, 0.3);
            border-color: #10b981;
            color: #fff;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }

        .dance-status {
            display: flex;
            gap: 0.75rem;
            margin-top: 0.75rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            font-size: 0.65rem;
        }

        .dance-stat {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
        }

        .dance-stat-label {
            color: #606060;
            text-transform: uppercase;
            font-size: 0.55rem;
        }

        .dance-stat-value {
            color: #a0a0a0;
            font-weight: 500;
        }

        .dance-stat-value.highlight {
            color: var(--accent);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LLM INTERPRETER PANEL
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .llm-input-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .llm-input-row input[type="text"],
        .llm-input-row input[type="password"] {
            flex: 1;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.8rem;
        }

        .llm-input-row input::placeholder {
            color: #606060;
        }

        .llm-test-area {
            margin-top: 0.75rem;
        }

        .llm-test-input {
            width: 100%;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }

        .llm-test-input::placeholder {
            color: #606060;
        }

        .llm-action-log {
            font-size: 0.7rem;
            color: #808080;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.5rem;
            border-radius: 4px;
            max-height: 100px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .llm-action {
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .llm-action:last-child {
            border-bottom: none;
        }

        .llm-action .action-time {
            color: #505050;
            margin-right: 0.5rem;
        }

        .llm-action .action-type {
            color: var(--accent);
            font-weight: 500;
        }

        .llm-status {
            font-size: 0.65rem;
            color: #606060;
            margin-top: 0.5rem;
            display: flex;
            justify-content: space-between;
        }

        .llm-status.active {
            color: #10b981;
        }

        .llm-status.error {
            color: #ef4444;
        }

        .llm-lyrics-area {
            margin-top: 0.5rem;
        }

        .llm-lyrics-area textarea {
            width: 100%;
            min-height: 80px;
            max-height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 0.5rem;
            color: #e0e0e0;
            font-size: 0.75rem;
            font-family: 'Monaco', 'Consolas', monospace;
            resize: vertical;
        }

        .llm-lyrics-area textarea::placeholder {
            color: #505050;
        }

        .llm-lyrics-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }

        .llm-lyrics-controls button {
            padding: 0.25rem 0.75rem;
            font-size: 0.7rem;
        }

        .llm-current-line {
            font-size: 0.7rem;
            color: var(--accent);
            padding: 0.25rem 0.5rem;
            background: rgba(124, 58, 237, 0.1);
            border-radius: 4px;
            margin-top: 0.25rem;
            min-height: 1.5em;
            font-style: italic;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MOBILE RESPONSIVE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (max-width: 1000px) {
            /* Groove buttons - horizontal on tablet */
            .groove-buttons {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .groove-btn {
                flex: 1 1 calc(50% - 0.5rem);
                min-width: 140px;
                padding: 0.75rem;
            }

            .groove-info p {
                display: none;
            }

            .groove-icon {
                width: 32px;
                height: 32px;
                font-size: 1rem;
            }

            /* Compact BPM display */
            .bpm-display {
                padding: 0.75rem;
            }

            .bpm-value {
                font-size: 1.5rem;
            }

            /* Compact audio rows */
            .audio-row,
            .audio-source-row,
            .custom-file-row {
                flex-wrap: wrap;
            }

            .track-select {
                min-width: 100%;
                margin-bottom: 0.5rem;
            }

            .audio-source-row button {
                flex: 1;
            }

            /* Dance panel - scrollable */
            .dance-panel {
                max-height: none;
            }

            /* Gesture grid - tighter */
            .gesture-grid {
                gap: 3px;
            }

            .gesture-chip {
                padding: 0.2rem 0.4rem;
                font-size: 0.6rem;
            }

            /* Status log - shorter on mobile */
            .log {
                height: 100px;
            }
        }

        @media (max-width: 600px) {
            /* Small phone - stack groove buttons */
            .groove-buttons {
                flex-direction: column;
            }

            .groove-btn {
                flex: 1 1 auto;
                min-width: 0;
            }

            /* Even more compact BPM */
            .bpm-value {
                font-size: 1.25rem;
            }

            /* Smaller gesture chips */
            .gesture-chip {
                padding: 0.15rem 0.35rem;
                font-size: 0.55rem;
            }

            .gesture-section-title {
                font-size: 0.6rem;
            }

            /* Dance status - compact */
            .dance-status {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .dance-stat {
                flex: 1 1 calc(50% - 0.5rem);
            }

            /* Intensity slider - full width label */
            .intensity-slider {
                flex-wrap: wrap;
            }

            .intensity-slider label {
                width: 100%;
                margin-bottom: 0.25rem;
            }

            /* Transition row - stack */
            .transition-row {
                flex-wrap: wrap;
            }

            .transition-row label {
                width: 100%;
                margin-bottom: 0.25rem;
            }

            .transition-row select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="left-menu">
        <!-- Audio Panel -->
        <div class="section">
            <h2>Audio Source</h2>
            <div class="section-content">
                <!-- Track selector (hidden when custom file loaded) -->
                <div class="audio-source-row" id="trackSourceRow">
                    <select class="track-select" id="trackSelect">
                        <optgroup label="Music">
                            <option value="female">Electric Glow (Female)</option>
                            <option value="male">Electric Glow (Male)</option>
                        </optgroup>
                        <optgroup label="Calibration - Pure">
                            <option value="click-60">Click 60 BPM</option>
                            <option value="click-90">Click 90 BPM</option>
                            <option value="click-120">Click 120 BPM</option>
                            <option value="click-150">Click 150 BPM</option>
                        </optgroup>
                        <optgroup label="Calibration - Subdivision">
                            <option value="click-120-kicksnare">120 BPM Kick+Snare</option>
                            <option value="click-120-hihat">120 BPM Kick+HiHat</option>
                        </optgroup>
                    </select>
                    <button id="browseBtn">Browse</button>
                    <input type="file" id="audioFile" accept="audio/*">
                </div>

                <!-- Custom file display (shown when custom file loaded, replaces track selector) -->
                <div class="custom-file-row" id="customFileRow">
                    <span class="custom-file-display" id="customFileDisplay">
                        <span class="file-name" id="fileName"></span>
                        <span class="file-meta"><span id="fileSize"></span> Â· <span id="fileDuration"></span></span>
                    </span>
                    <button class="clear-btn" id="clearFileBtn" title="Remove custom file">Ã—</button>
                </div>
                <div class="button-grid">
                    <button id="playBtn">Play</button>
                    <button id="stopBtn" disabled>Stop</button>
                    <button id="tapTempoBtn">Tap Tempo</button>
                </div>
                <div class="bpm-display compact">
                    <div class="bpm-main">
                        <div>
                            <div class="bpm-value" id="bpmValue">120</div>
                            <div class="bpm-label">BPM</div>
                        </div>
                        <div class="beat-indicator" id="beatIndicator"></div>
                    </div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidenceFill"></div>
                    </div>
                    <div class="lock-status" id="lockStatus">
                        <span>Detecting...</span>
                        <span id="agentCount">0 agents</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Groove Panel -->
        <div class="section">
            <h2>Groove Presets</h2>
            <div class="section-content">
                <div class="groove-buttons">
                    <button class="groove-btn active" data-groove="groove1">
                        <div class="groove-icon">~</div>
                        <div class="groove-info">
                            <h3>Subtle</h3>
                            <p>Elegant, gentle bounce and sway</p>
                        </div>
                    </button>
                    <button class="groove-btn" data-groove="groove2">
                        <div class="groove-icon">^</div>
                        <div class="groove-info">
                            <h3>Energetic</h3>
                            <p>Bouncy, pronounced vertical motion</p>
                        </div>
                    </button>
                    <button class="groove-btn" data-groove="groove3">
                        <div class="groove-icon">S</div>
                        <div class="groove-info">
                            <h3>Flowing</h3>
                            <p>Smooth, emphasis on rotation</p>
                        </div>
                    </button>
                </div>
                <div class="transition-row">
                    <label>Blend over:</label>
                    <select id="transitionMode">
                        <option value="instant">Instant</option>
                        <option value="1">1 bar</option>
                        <option value="2" selected>2 bars</option>
                        <option value="4">4 bars</option>
                        <option value="8">8 bars</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <div class="center-content">
        <div id="mascot-container"></div>
        <div class="camera-hint">Drag to rotate â€¢ Pinch or scroll to zoom</div>
    </div>

    <div class="right-menu">
        <!-- Dance Choreographer Panel -->
        <div class="section">
            <h2 class="has-toggle">
                <span>Dance Choreographer</span>
                <div class="toggle-switch active" id="dance-toggle">On</div>
            </h2>
            <div class="section-content dance-panel">
                <!-- Intensity Slider -->
                <div class="intensity-slider">
                    <label>Intensity</label>
                    <input type="range" id="danceIntensity" min="0" max="100" value="100">
                    <span class="intensity-value" id="intensityValue">100%</span>
                </div>

                <!-- ğŸ¼ COMBOS - Primary interaction (shown prominently) -->
                <div class="gesture-section">
                    <div class="gesture-section-title">ğŸ¼ Quick Combos</div>
                    <div class="gesture-grid" id="combos">
                        <span class="combo-chip" data-combo="subtle">subtle</span>
                        <span class="combo-chip" data-combo="moderate">moderate</span>
                        <span class="combo-chip" data-combo="energetic">energetic</span>
                        <span class="combo-chip" data-combo="climactic">climactic</span>
                    </div>
                </div>

                <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                     ADVANCED GESTURES (collapsed by default)
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
                <div class="advanced-gestures">
                    <div class="advanced-toggle collapsed" id="advancedToggle">
                        <span class="chevron">â–¼</span>
                        <span>Individual Gestures</span>
                    </div>
                    <div class="advanced-content">
                        <!-- âœ¨ ACCENT GESTURES (Dance-friendly - work WITH groove) -->
                        <div class="gesture-section">
                            <div class="gesture-section-title">âœ¨ Accent</div>
                            <div class="gesture-grid" id="accentGestures">
                                <span class="gesture-chip accent-type" data-gesture="pop">pop</span>
                                <span class="gesture-chip accent-type" data-gesture="bob">bob</span>
                                <span class="gesture-chip accent-type" data-gesture="swell">swell</span>
                                <span class="gesture-chip accent-type" data-gesture="swagger">swagger</span>
                                <span class="gesture-chip accent-type" data-gesture="dip">dip</span>
                                <span class="gesture-chip accent-type" data-gesture="flare">flare</span>
                            </div>
                        </div>

                        <!-- ğŸ”„ RHYTHMIC GESTURES -->
                        <div class="gesture-section">
                            <div class="gesture-section-title">ğŸ”„ Rhythmic</div>
                            <div class="gesture-grid" id="rhythmicGestures">
                                <span class="gesture-chip" data-gesture="bounce">bounce</span>
                                <span class="gesture-chip" data-gesture="pulse">pulse</span>
                                <span class="gesture-chip" data-gesture="nod">nod</span>
                                <span class="gesture-chip" data-gesture="sway">sway</span>
                                <span class="gesture-chip" data-gesture="wiggle">wiggle</span>
                                <span class="gesture-chip" data-gesture="headBob">headBob</span>
                            </div>
                        </div>

                        <!-- ğŸš€ EXPRESSIVE GESTURES -->
                        <div class="gesture-section">
                            <div class="gesture-section-title">ğŸš€ Expressive</div>
                            <div class="gesture-grid" id="expressiveGestures">
                                <span class="gesture-chip" data-gesture="spin">spin</span>
                                <span class="gesture-chip" data-gesture="jump">jump</span>
                                <span class="gesture-chip" data-gesture="twist">twist</span>
                                <span class="gesture-chip" data-gesture="hula">hula</span>
                            </div>
                        </div>

                        <!-- Subtle Emphasis -->
                        <div class="gesture-section">
                            <div class="gesture-section-title">Subtle</div>
                            <div class="gesture-grid" id="subtleGestures">
                                <span class="gesture-chip" data-gesture="twitch">twitch</span>
                                <span class="gesture-chip" data-gesture="lean">lean</span>
                                <span class="gesture-chip" data-gesture="tilt">tilt</span>
                            </div>
                        </div>

                        <!-- âš¡ Glow Effects -->
                        <div class="gesture-section">
                            <div class="gesture-section-title">âš¡ Glow</div>
                            <div class="gesture-grid" id="glowGestures">
                                <span class="gesture-chip glow-type" data-gesture="flash">flash</span>
                                <span class="gesture-chip glow-type" data-gesture="glow">glow</span>
                                <span class="gesture-chip glow-type" data-gesture="burst">burst</span>
                                <span class="gesture-chip glow-type" data-gesture="flicker">flicker</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Status (single instance - removed duplicate) -->
                <div class="dance-status">
                    <div class="dance-stat">
                        <span class="dance-stat-label">Groove</span>
                        <span class="dance-stat-value" id="danceGroove">groove1</span>
                    </div>
                    <div class="dance-stat">
                        <span class="dance-stat-label">Bass</span>
                        <span class="dance-stat-value" id="danceBass">0.00</span>
                    </div>
                    <div class="dance-stat">
                        <span class="dance-stat-label">Vocals</span>
                        <span class="dance-stat-value" id="danceVocal">0.00</span>
                    </div>
                    <div class="dance-stat">
                        <span class="dance-stat-label">Bar</span>
                        <span class="dance-stat-value" id="danceBar">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- LLM Audio Interpreter Panel -->
        <div class="section">
            <h2 class="has-toggle">
                <span>LLM Interpreter</span>
                <div class="toggle-switch" id="llm-toggle">Off</div>
            </h2>
            <div class="section-content">
                <div class="llm-input-row">
                    <select id="llmProvider" style="flex: 0 0 auto; min-width: 100px;">
                        <option value="anthropic">Claude</option>
                        <option value="openai">OpenAI</option>
                        <option value="grok">Grok</option>
                    </select>
                    <input type="password" id="llmApiKey" placeholder="API Key" style="flex: 1;">
                </div>
                <div class="llm-input-row">
                    <input type="text" id="llmModel" placeholder="Model (optional)">
                </div>
                <!-- Lyrics textarea for timed interpretation -->
                <div class="llm-lyrics-area">
                    <label style="font-size: 0.75rem; color: #888; display: block; margin-bottom: 4px;">
                        Lyrics (paste with timestamps or plain text)
                    </label>
                    <textarea id="llmLyrics" placeholder="[00:15] First line of lyrics
[00:20] Second line
[00:25] Third line...

Or just paste plain lyrics and they'll be fed line by line every few seconds."></textarea>
                    <div class="llm-lyrics-controls">
                        <button id="llmParseLyrics" title="Parse and prepare lyrics">Parse</button>
                        <span id="llmLyricsStatus" style="font-size: 0.7rem; color: #666;">No lyrics loaded</span>
                    </div>
                </div>
                <!-- Manual test input -->
                <div class="llm-test-area">
                    <input type="text" class="llm-test-input" id="llmTestInput" placeholder="Or type manually to test...">
                    <button id="llmTestBtn" style="width: 100%;">Interpret</button>
                </div>
                <div class="llm-action-log" id="llmActionLog">
                    <div style="color: #505050; text-align: center;">Actions will appear here...</div>
                </div>
                <div class="llm-status" id="llmStatus">
                    <span>Status: Disabled</span>
                    <span id="llmRequestCount">0 requests</span>
                </div>
            </div>
        </div>

        <div class="section visual-controls">
            <h2 class="has-toggle">
                <span>Visuals</span>
                <div class="toggle-switch active" id="particles-toggle">Particles</div>
            </h2>
            <div class="section-content">
                <div class="toggle-control">
                    <span class="toggle-label">Breathing</span>
                    <div class="toggle-switch active" data-action="toggle-breathing"></div>
                </div>
                <div class="toggle-control">
                    <span class="toggle-label">Auto-Rotate</span>
                    <div class="toggle-switch active" data-action="toggle-auto-rotate"></div>
                </div>
            </div>
        </div>

        <!-- Debug Section (collapsed by default) -->
        <div class="section debug-section collapsed">
            <h2>Debug</h2>
            <div class="section-content">
                <div class="debug-buttons">
                    <button id="copyLogBtn" title="Copy BPM debug log to clipboard">Copy BPM Log</button>
                </div>
                <div class="log" id="log"></div>
                <div class="footer-info">
                    <span>Groove: <span class="current-groove" id="currentGroove">groove1</span></span>
                    <span id="frameInfo">-- fps</span>
                </div>
            </div>
        </div>

        <!-- Keyboard shortcuts (hidden on touch devices via CSS) -->
        <div class="section keyboard-shortcuts-info">
            <div class="info-box">
                <strong>Keyboard:</strong>
                Space = play/stop Â· T = tap Â· 1/2/3 = grooves
            </div>
        </div>
    </div>

    <!-- Global drop overlay -->
    <div class="global-drop-overlay" id="globalDropOverlay">
        <div class="global-drop-content">
            <div class="global-drop-icon">ğŸµ</div>
            <div class="global-drop-text">Drop audio file</div>
            <div class="global-drop-hint">MP3, WAV, OGG, FLAC supported</div>
        </div>
    </div>

    <script type="module">
        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * IMPORTS
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * EmotiveMascot3D: Main 3D mascot class with audio-reactive features
         * demo-utils: Shared utilities for toggle controls and visual settings
         */
        import EmotiveMascot3D, { AudioInterpreter, LLM_ENDPOINTS } from '/emotive-engine-3d.bundled.js';
        import { setupParticlesToggle, setupVisualToggles } from '/examples/3d/demo-utils.js';

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * CONFIGURATION CONSTANTS
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * Centralized configuration makes the demo easier to customize and maintain.
         * Junior devs: Modify these values to experiment with different behaviors!
         */

        // Available demo audio tracks
        // Each track is optimized for different BPM detection scenarios
        const DEMO_TRACKS = {
            // Music tracks - full songs for realistic testing
            female: '/assets/tracks/music/electric-glow-f.wav',
            male: '/assets/tracks/music/electric-glow-m.wav',

            // Calibration - pure metronome clicks at specific BPMs
            // Use these to verify BPM detection accuracy
            'click-60': '/assets/tracks/test/click-60.wav',
            'click-90': '/assets/tracks/test/click-90.wav',
            'click-120': '/assets/tracks/test/click-120.wav',
            'click-150': '/assets/tracks/test/click-150.wav',

            // Calibration - subdivision tests for complex rhythm detection
            'click-120-kicksnare': '/assets/tracks/test/click-120-kicksnare.wav',
            'click-120-hihat': '/assets/tracks/test/click-120-hihat.wav'
        };

        // LRC lyrics files for demo tracks (optional sidecar files)
        const TRACK_LYRICS = {
            female: '/assets/tracks/music/electric-glow.lrc',
            male: '/assets/tracks/music/electric-glow.lrc'  // Same lyrics for both versions
        };

        // Mascot configuration - these match EmotiveMascot3D constructor options
        const MASCOT_CONFIG = {
            coreGeometry: 'crystal',      // Starting geometry (crystal, moon, sun)
            enableParticles: true,        // Floating particle effects
            enablePostProcessing: true,   // Bloom and glow effects
            enableBlinking: true,         // Periodic "blink" animation
            enableBreathing: true,        // Subtle scale oscillation
            autoRotate: true,             // Slow rotation when idle
            autoRotateSpeed: 0.3,         // Rotation speed (0.1 = slow, 1.0 = fast)
            enableControls: true,         // Mouse/touch camera controls
            cameraDistance: 1.2,          // Distance from center (1.0 = close)
            fov: 30,                      // Field of view (lower = less distortion)
            minZoom: 0.9,                 // Minimum zoom level
            maxZoom: 2.0,                 // Maximum zoom level
            assetBasePath: '/assets'      // Path to OBJ models and textures
        };

        // Tap tempo configuration
        const TAP_TEMPO_CONFIG = {
            maxTaps: 8,          // Number of taps to average
            minBPM: 60,          // Minimum allowed BPM
            maxBPM: 200,         // Maximum allowed BPM
            resetTimeout: 2000   // Reset taps after 2 seconds of inactivity
        };

        // UI update intervals (in milliseconds)
        const UPDATE_INTERVALS = {
            danceStatus: 250,    // How often to refresh dance choreographer stats
            fps: 1000            // FPS counter update rate
        };

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * APPLICATION STATE
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * Mutable state variables that track the current application status.
         * Keeping state in one place makes debugging easier.
         */
        let mascot = null;           // EmotiveMascot3D instance
        let audioElement = null;     // HTML Audio element for playback
        let audioContext = null;     // Web Audio API context (created by mascot)
        let isPlaying = false;       // Playback state flag
        let tapTimes = [];           // Timestamps for tap tempo calculation
        let lastFrameTime = performance.now();  // For FPS calculation
        let frameCount = 0;          // Frame counter for FPS
        let currentTrack = 'female'; // Currently selected demo track
        let currentFile = null;      // Custom file object (if user imported one)
        let audioInterpreter = null; // LLM Audio Interpreter instance
        let llmRequestCount = 0;     // Count of LLM requests made

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * DOM ELEMENT REFERENCES
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * Cache DOM elements once at startup for better performance.
         * Tip: Group related elements together for easier maintenance.
         */

        // Container for the 3D mascot
        const container = document.getElementById('mascot-container');

        // Audio playback controls
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const tapTempoBtn = document.getElementById('tapTempoBtn');
        const trackSelect = document.getElementById('trackSelect');
        const audioFileInput = document.getElementById('audioFile');
        const browseBtn = document.getElementById('browseBtn');
        const copyLogBtn = document.getElementById('copyLogBtn');

        // File import UI (switches between preset tracks and custom file)
        const trackSourceRow = document.getElementById('trackSourceRow');
        const customFileRow = document.getElementById('customFileRow');
        const customFileDisplay = document.getElementById('customFileDisplay');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const fileDuration = document.getElementById('fileDuration');
        const clearFileBtn = document.getElementById('clearFileBtn');
        const globalDropOverlay = document.getElementById('globalDropOverlay');

        // BPM detection display
        const bpmDisplay = document.querySelector('.bpm-display');
        const bpmValue = document.getElementById('bpmValue');
        const beatIndicator = document.getElementById('beatIndicator');
        const confidenceFill = document.getElementById('confidenceFill');
        const lockStatus = document.getElementById('lockStatus');
        const agentCount = document.getElementById('agentCount');

        // Groove preset controls
        const transitionMode = document.getElementById('transitionMode');
        const grooveButtons = document.querySelectorAll('.groove-btn');
        const currentGrooveEl = document.getElementById('currentGroove');

        // Status log and FPS
        const logEl = document.getElementById('log');
        const frameInfoEl = document.getElementById('frameInfo');

        // Dance choreographer panel elements
        const danceToggle = document.getElementById('dance-toggle');
        const danceIntensitySlider = document.getElementById('danceIntensity');
        const intensityValueEl = document.getElementById('intensityValue');
        const danceGrooveEl = document.getElementById('danceGroove');
        const danceBassEl = document.getElementById('danceBass');
        const danceVocalEl = document.getElementById('danceVocal');
        const danceBarEl = document.getElementById('danceBar');
        const gestureChips = document.querySelectorAll('.gesture-chip');
        const comboChips = document.querySelectorAll('.combo-chip');

        // Track active gestures for visual feedback (gesture name -> timeout ID)
        const activeGestures = new Map();

        // LLM Interpreter panel elements
        const llmToggle = document.getElementById('llm-toggle');
        const llmProviderSelect = document.getElementById('llmProvider');
        const llmApiKeyInput = document.getElementById('llmApiKey');
        const llmModelInput = document.getElementById('llmModel');
        const llmTestInput = document.getElementById('llmTestInput');
        const llmTestBtn = document.getElementById('llmTestBtn');
        const llmActionLog = document.getElementById('llmActionLog');
        const llmStatus = document.getElementById('llmStatus');
        const llmRequestCountEl = document.getElementById('llmRequestCount');
        const llmLyricsTextarea = document.getElementById('llmLyrics');
        const llmParseLyricsBtn = document.getElementById('llmParseLyrics');
        const llmLyricsStatusEl = document.getElementById('llmLyricsStatus');

        // Lyrics timing system
        let parsedLyrics = [];        // Array of { time: seconds, text: string }
        let currentLyricIndex = -1;   // Current line being played
        let lyricsUpdateInterval = null;

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * UTILITY FUNCTIONS
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         */

        /**
         * Add a timestamped entry to the status log panel.
         * Color-coded by type for easy scanning:
         *   - info (green): General status updates
         *   - bpm (amber): BPM detection events
         *   - groove (purple): Groove changes
         *   - gesture (pink): Gesture triggers
         *   - error (red): Error messages
         *
         * @param {string} message - The log message to display
         * @param {string} type - Log type: 'info' | 'bpm' | 'groove' | 'gesture' | 'error'
         */
        function log(message, type = 'info') {
            const time = new Date().toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">${time}</span><span class="log-${type}">${message}</span>`;

            // Insert at top (newest first)
            logEl.insertBefore(entry, logEl.firstChild);

            // Limit log size to prevent memory issues
            const MAX_LOG_ENTRIES = 50;
            while (logEl.children.length > MAX_LOG_ENTRIES) {
                logEl.removeChild(logEl.lastChild);
            }
        }

        /**
         * Format file size for display (bytes â†’ KB/MB)
         * @param {number} bytes - File size in bytes
         * @returns {string} Human-readable file size
         */
        function formatFileSize(bytes) {
            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
        }

        /**
         * Format duration in seconds to MM:SS
         * @param {number} seconds - Duration in seconds
         * @returns {string} Formatted duration (e.g., "3:45")
         */
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * MASCOT INITIALIZATION
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         */

        /**
         * Initialize the 3D mascot with audio-reactive features.
         *
         * This function demonstrates:
         * 1. Creating an EmotiveMascot3D instance with configuration
         * 2. Awaiting async initialization (loads OBJ models, textures)
         * 3. Starting the render loop
         * 4. Enabling groove system for beat-synced animation
         *
         * KEY EMOTIVE ENGINE APIS USED:
         * - new EmotiveMascot3D(config) - Create mascot with options
         * - mascot.init(container)      - Initialize and mount to DOM
         * - mascot.start()              - Begin animation loop
         * - mascot.setEmotion(name)     - Set emotional state (affects colors/speed)
         * - mascot.enableGroove()       - Enable beat-synced animation system
         * - mascot.getGroovePresets()   - List available groove configurations
         */
        async function initMascot() {
            log('Initializing 3D mascot...', 'info');

            // Create mascot instance with configuration from constants
            mascot = new EmotiveMascot3D(MASCOT_CONFIG);

            // Initialize (async - loads geometry, textures, shaders)
            await mascot.init(container);

            // Start the render loop
            mascot.start();

            // Set initial emotion - this affects glow color and animation speed
            // Available emotions: neutral, joy, sadness, anger, fear, surprise,
            // disgust, love, calm, excited, focused, suspicion, resting, euphoria
            mascot.setEmotion('calm');

            // Enable the groove system - this creates the rhythm adapter and
            // allows the mascot to sync with BPM for beat-matched animations
            mascot.enableGroove();

            log('Mascot ready, groove enabled', 'groove');
            log(`Available presets: ${mascot.getGroovePresets().join(', ')}`, 'info');

            // Start FPS counter for performance monitoring
            requestAnimationFrame(updateFPS);

            // Preload the default audio track
            await loadTrack('female');
        }

        /**
         * Update FPS counter display.
         * Uses requestAnimationFrame for accurate frame counting.
         */
        function updateFPS() {
            frameCount++;
            const now = performance.now();

            // Update display once per second
            if (now - lastFrameTime >= UPDATE_INTERVALS.fps) {
                frameInfoEl.textContent = `${frameCount} fps`;
                frameCount = 0;
                lastFrameTime = now;
            }

            requestAnimationFrame(updateFPS);
        }

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * AUDIO HANDLING
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * The Emotive Engine's audio system works with the Web Audio API:
         * 1. Audio is loaded via an HTML Audio element
         * 2. mascot.connectAudio() creates an AudioContext and analyzer
         * 3. The analyzer extracts frequency data for BPM detection
         * 4. BPM drives the groove system for beat-synced animation
         *
         * IMPORTANT: Due to browser autoplay policies, audio can only play
         * after a user gesture (click/tap). That's why we use play buttons.
         */

        /**
         * Load a demo track by ID.
         *
         * KEY API USED:
         * - mascot.disconnectAudio() - Clean up previous audio connection
         *
         * @param {string} trackId - Key from DEMO_TRACKS object
         */
        async function loadTrack(trackId) {
            const url = DEMO_TRACKS[trackId];
            if (!url) {
                log(`Unknown track: ${trackId}`, 'error');
                return;
            }

            log(`Loading: ${trackId} track...`, 'info');
            currentTrack = trackId;

            try {
                // Clean up previous audio element (prevents memory leaks)
                if (audioElement) {
                    audioElement.pause();
                    // Revoke blob URLs to free memory
                    if (audioElement.src.startsWith('blob:')) {
                        URL.revokeObjectURL(audioElement.src);
                    }
                    mascot.disconnectAudio();
                }

                // Create audio element
                // crossOrigin='anonymous' is required for Web Audio API access
                // to same-origin audio files served with CORS headers
                audioElement = new Audio();
                audioElement.crossOrigin = 'anonymous';
                audioElement.src = url;

                // Wait for metadata (duration, etc.) to load
                await new Promise((resolve, reject) => {
                    audioElement.onloadedmetadata = resolve;
                    audioElement.onerror = () => reject(new Error(`Failed to load ${url}`));
                });

                log(`Loaded: ${(audioElement.duration / 60).toFixed(1)} min`, 'info');

                // Try to auto-load lyrics if available
                await loadTrackLyrics(trackId);

            } catch (err) {
                log(`Error loading track: ${err.message}`, 'error');
                console.error('Track load error:', err);
            }
        }

        /**
         * Load LRC lyrics file for a track if available
         * @param {string} trackId - Key from DEMO_TRACKS object
         */
        async function loadTrackLyrics(trackId) {
            const lrcUrl = TRACK_LYRICS[trackId];
            if (!lrcUrl) {
                // No lyrics for this track - clear any existing
                parsedLyrics = [];
                llmLyricsTextarea.value = '';
                llmLyricsStatusEl.textContent = 'No lyrics available';
                return;
            }

            try {
                const response = await fetch(lrcUrl);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const lrcText = await response.text();
                llmLyricsTextarea.value = lrcText;

                // Auto-parse the lyrics
                parsedLyrics = parseLyrics(lrcText);
                const hasTimestamps = parsedLyrics.some((l, i) => i > 0 && l.time !== i * 5);
                const mode = hasTimestamps ? 'timed' : 'auto';
                llmLyricsStatusEl.textContent = `${parsedLyrics.length} lines (${mode})`;
                log(`Lyrics loaded: ${parsedLyrics.length} lines`, 'info');

            } catch (err) {
                // Lyrics file not found - that's OK, not all tracks have lyrics
                parsedLyrics = [];
                llmLyricsTextarea.value = '';
                llmLyricsStatusEl.textContent = 'No lyrics available';
            }
        }

        /**
         * Show custom file info in the UI.
         * Switches from preset track dropdown to file display mode.
         */
        function showFileLoaded(file, duration = null) {
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileDuration.textContent = duration ? formatDuration(duration) : '--:--';

            // Switch from track selector to custom file display
            trackSourceRow.classList.add('hidden');
            customFileRow.classList.add('visible');
        }

        /**
         * Hide custom file info, return to preset track selector.
         */
        function hideFileLoaded() {
            customFileRow.classList.remove('visible');
            trackSourceRow.classList.remove('hidden');
        }

        /**
         * Load a user-provided audio file (drag-drop or file picker).
         *
         * Uses URL.createObjectURL() to create a playable URL from a File object.
         * Remember to revoke the URL when done to prevent memory leaks!
         *
         * @param {File} file - Audio file from input or drag-drop
         */
        async function loadAudioFile(file) {
            log(`Loading: ${file.name}`, 'info');

            try {
                // Create a blob URL for the file
                const url = URL.createObjectURL(file);

                // Clean up previous audio element
                if (audioElement) {
                    audioElement.pause();
                    if (audioElement.src.startsWith('blob:')) {
                        URL.revokeObjectURL(audioElement.src);
                    }
                    mascot.disconnectAudio();
                }

                // Create and configure audio element
                audioElement = new Audio();
                audioElement.crossOrigin = 'anonymous';
                audioElement.src = url;

                // Wait for metadata
                await new Promise((resolve, reject) => {
                    audioElement.onloadedmetadata = resolve;
                    audioElement.onerror = () => reject(new Error('Failed to decode audio file'));
                });

                log(`Loaded: ${(audioElement.duration / 60).toFixed(1)} min`, 'info');
                currentTrack = 'custom';
                currentFile = file;

                // Clear lyrics for custom files (user can paste their own)
                parsedLyrics = [];
                llmLyricsTextarea.value = '';
                llmLyricsStatusEl.textContent = 'Paste lyrics for custom file';

                // Update UI to show file info
                showFileLoaded(file, audioElement.duration);

            } catch (err) {
                log(`Error loading audio: ${err.message}`, 'error');
                console.error('Audio file load error:', err);
                hideFileLoaded();
            }
        }

        /**
         * Start audio playback and connect to the mascot for BPM detection.
         *
         * KEY APIS USED:
         * - mascot.connectAudio(audioElement) - Connect audio for analysis
         *   This creates an AudioContext, analyzer node, and starts BPM detection.
         *   Returns a promise that resolves when connection is established.
         *
         * - mascot.startRhythm(bpm) - Called automatically when BPM is detected
         *
         * BROWSER AUTOPLAY POLICY:
         * AudioContext must be created/resumed after a user gesture.
         * That's why playAudio() should only be called from a click handler.
         */
        async function playAudio() {
            if (!audioElement) {
                log('No audio loaded', 'error');
                return;
            }

            try {
                // Resume AudioContext if suspended (browser autoplay policy)
                // This can happen if the context was created before user interaction
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // Connect audio to mascot for analysis and BPM detection
                // This is the key integration point with the Emotive Engine
                await mascot.connectAudio(audioElement);
                log('Audio connected for BPM detection', 'bpm');

                // Start playback
                await audioElement.play();
                isPlaying = true;
                playBtn.disabled = true;
                stopBtn.disabled = false;

                // Expand BPM display when playing
                bpmDisplay.classList.remove('compact');

                log('Playing audio...', 'bpm');

                // Start monitoring BPM detection status
                startBPMMonitor();

                // Start lyrics tracking if lyrics are loaded
                if (parsedLyrics.length > 0) {
                    startLyricsTracking();
                    log(`Lyrics tracking started (${parsedLyrics.length} lines)`, 'groove');
                }

                // Handle end of track
                audioElement.onended = () => {
                    isPlaying = false;
                    playBtn.disabled = false;
                    stopBtn.disabled = true;
                    stopLyricsTracking();
                    log('Playback ended', 'info');
                };

            } catch (err) {
                log(`Playback error: ${err.message}`, 'error');
                console.error('Playback error:', err);
            }
        }

        /**
         * Stop audio playback and reset rhythm.
         *
         * KEY API USED:
         * - mascot.stopRhythm() - Stops beat-synced animation
         */
        function stopAudio() {
            if (audioElement) {
                audioElement.pause();
                audioElement.currentTime = 0;
            }
            isPlaying = false;
            playBtn.disabled = false;
            stopBtn.disabled = true;

            // Compact BPM display when stopped
            bpmDisplay.classList.add('compact');

            // Stop lyrics tracking
            stopLyricsTracking();

            mascot.stopRhythm();
            log('Stopped', 'info');
        }

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * BPM DETECTION & MONITORING
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * The Emotive Engine uses an agent-based BPM detection system:
         * 1. Multiple "agents" analyze audio at different tempo hypotheses
         * 2. Agents vote based on detected beat patterns
         * 3. Lock progresses through stages: Detecting â†’ Stage 1 â†’ Stage 2 â†’ Stage 3 â†’ Locked
         * 4. Locked BPM drives the groove system for beat-synced animation
         *
         * LOCK STAGES:
         * - Stage 0: Detecting - gathering initial data
         * - Stage 1: Initial Lock (orange) - first tempo hypothesis
         * - Stage 2: Refinement (yellow) - adjusting for accuracy
         * - Stage 3: Final Lock (green) - confirming tempo
         * - Locked: Finalized (gold) - BPM confirmed and stable
         *
         * KEY API USED:
         * - mascot.getBPMStatus() - Returns detection status object
         */

        // Track lock state for detecting transitions
        let lastLockedState = false;

        /**
         * Start monitoring BPM detection status and update the UI.
         * Updates confidence bar, lock stage indicator, and beat flash.
         */
        function startBPMMonitor() {
            const updateBPM = () => {
                if (!isPlaying) {
                    // Reset UI when stopped
                    confidenceFill.style.width = '0%';
                    lockStatus.classList.remove('locked');
                    lockStatus.querySelector('span').textContent = 'Detecting...';
                    bpmValue.classList.remove('locked');
                    return;
                }

                // Get full BPM status from agent detector
                const status = mascot.getBPMStatus ? mascot.getBPMStatus() : { bpm: mascot.getRhythmBPM(), confidence: 0, locked: false, agentCount: 0 };

                // Update BPM display
                bpmValue.textContent = Math.round(status.bpm);

                // Update confidence bar
                const confidencePercent = Math.round(status.confidence * 100);
                confidenceFill.style.width = `${confidencePercent}%`;

                // Update lock status based on stage
                // Remove all stage classes first
                bpmValue.classList.remove('locked', 'stage1', 'stage2', 'stage3');
                lockStatus.classList.remove('locked', 'stage1', 'stage2', 'stage3');

                const lockStage = status.lockStage || 0;
                const correctionType = status.correctionType || 'none';
                const isFinalized = status.finalized || false;  // Only true after memory cleanup

                if (lockStage === 0) {
                    // Stage 0: Detecting
                    lockStatus.querySelector('span').textContent = `Detecting... ${confidencePercent}%`;
                } else if (lockStage === 1) {
                    // Stage 1: Initial Lock (orange)
                    bpmValue.classList.add('stage1');
                    lockStatus.classList.add('stage1');
                    lockStatus.querySelector('span').textContent = `Locking [Stage 1]: ${status.bpm} BPM`;
                } else if (lockStage === 2) {
                    // Stage 2: Refinement (yellow)
                    bpmValue.classList.add('stage2');
                    lockStatus.classList.add('stage2');
                    const corrStr = correctionType !== 'none' ? ` (${correctionType})` : '';
                    lockStatus.querySelector('span').textContent = `Locking [Stage 2]: ${status.bpm} BPM${corrStr}`;
                } else if (lockStage === 3 && !isFinalized) {
                    // Stage 3: Final lock phase (green)
                    bpmValue.classList.add('stage3');
                    lockStatus.classList.add('stage3');
                    const corrStr = correctionType !== 'none' ? ` (${correctionType})` : '';
                    lockStatus.querySelector('span').textContent = `Locking [Stage 3]: ${status.bpm} BPM${corrStr}`;
                } else if (isFinalized) {
                    // Finalized: Locked (gold with lock icon)
                    bpmValue.classList.add('locked');
                    lockStatus.classList.add('locked');
                    const corrStr = correctionType !== 'none' ? ` (${correctionType})` : '';
                    lockStatus.querySelector('span').textContent = `ğŸ”’ Locked: ${status.bpm} BPM${corrStr}`;

                    // Log when first locked
                    if (!lastLockedState) {
                        log(`BPM LOCKED: ${status.bpm} (${confidencePercent}% confidence)`, 'bpm');
                    }
                }
                lastLockedState = isFinalized;

                // Update agent count
                agentCount.textContent = `${status.agentCount} agents`;

                // Flash beat indicator on beat
                if (mascot.core3D && mascot.core3D.rhythm3DAdapter) {
                    const adapter = mascot.core3D.rhythm3DAdapter;
                    if (adapter.isOnBeatNow && adapter.isOnBeatNow(0.1)) {
                        beatIndicator.classList.add('on');
                        setTimeout(() => beatIndicator.classList.remove('on'), 100);
                    }
                }

                requestAnimationFrame(updateBPM);
            };
            requestAnimationFrame(updateBPM);
        }

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * TAP TEMPO
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * Tap tempo provides a manual fallback when BPM detection doesn't work
         * (e.g., for music without clear beats, or for testing specific tempos).
         *
         * How it works:
         * 1. User taps button in rhythm with the music
         * 2. We track timestamps of last N taps
         * 3. Calculate average interval between taps
         * 4. Convert interval to BPM: 60000ms / interval = BPM
         *
         * KEY APIS USED:
         * - mascot.setRhythmBPM(bpm) - Override the detected BPM
         * - mascot.startRhythm(bpm)  - Start rhythm without audio
         */

        /**
         * Handle a tap tempo button press.
         * Calculates BPM from the intervals between taps.
         */
        function handleTapTempo() {
            const now = performance.now();
            tapTimes.push(now);

            // Keep only the last N taps (configurable via TAP_TEMPO_CONFIG)
            if (tapTimes.length > TAP_TEMPO_CONFIG.maxTaps) {
                tapTimes.shift();
            }

            // Need at least 2 taps to calculate interval
            if (tapTimes.length < 2) {
                log('Tap again...', 'info');
                return;
            }

            // Calculate average interval between consecutive taps
            let totalInterval = 0;
            for (let i = 1; i < tapTimes.length; i++) {
                totalInterval += tapTimes[i] - tapTimes[i - 1];
            }
            const avgInterval = totalInterval / (tapTimes.length - 1);

            // Convert interval to BPM (60 seconds = 60000 ms)
            const bpm = Math.round(60000 / avgInterval);

            // Clamp to reasonable range to prevent extreme values
            const clampedBPM = Math.max(
                TAP_TEMPO_CONFIG.minBPM,
                Math.min(TAP_TEMPO_CONFIG.maxBPM, bpm)
            );

            // Update display and set BPM
            bpmValue.textContent = clampedBPM;
            mascot.setRhythmBPM(clampedBPM);

            // Start rhythm if not already playing audio
            // This allows manual tempo without audio file
            if (!isPlaying) {
                mascot.startRhythm(clampedBPM);
            }

            log(`Tap tempo: ${clampedBPM} BPM`, 'bpm');

            // Reset tap buffer after period of inactivity
            setTimeout(() => {
                if (performance.now() - tapTimes[tapTimes.length - 1] > TAP_TEMPO_CONFIG.resetTimeout) {
                    tapTimes = [];
                }
            }, TAP_TEMPO_CONFIG.resetTimeout + 100);
        }

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * GROOVE CONTROLS
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * Groove presets define how the mascot moves to the beat:
         * - subtle:    Gentle swaying, minimal movement (for calm moments)
         * - energetic: Dynamic bouncing, larger movements (for high energy)
         * - flowing:   Smooth, continuous motion (for ambient/chill tracks)
         *
         * Transitions can be:
         * - instant: Immediate switch (may look abrupt)
         * - 1-8 bars: Gradual crossfade over musical bars (looks natural)
         *
         * KEY APIS USED:
         * - mascot.setGroove(name, options) - Set groove with optional transition
         * - mascot.getGroovePresets()       - List available presets
         */

        /**
         * Apply a groove preset with the selected transition mode.
         * @param {string} grooveName - Groove preset name (subtle, energetic, flowing)
         */
        function setGroove(grooveName) {
            const mode = transitionMode.value;

            // Update button active states
            grooveButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.groove === grooveName);
            });
            currentGrooveEl.textContent = grooveName;

            // Apply groove with appropriate transition
            if (mode === 'instant') {
                // Immediate switch - no crossfade
                mascot.setGroove(grooveName);
                log(`Set groove: ${grooveName} (instant)`, 'groove');
            } else {
                // Gradual transition over N bars
                const bars = parseInt(mode, 10);
                mascot.setGroove(grooveName, { bars });
                log(`Set groove: ${grooveName} (${bars} bar transition)`, 'groove');
            }
        }

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * EVENT LISTENERS
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * All UI event handlers are grouped here for easy maintenance.
         * Each handler is documented with its purpose.
         */

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // AUDIO SOURCE CONTROLS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        // Handle preset track selection
        trackSelect.addEventListener('change', async (e) => {
            const value = e.target.value;
            hideFileLoaded();
            currentFile = null;
            if (isPlaying) stopAudio();
            await loadTrack(value);
        });

        // Open file picker when Browse button is clicked
        browseBtn.addEventListener('click', () => {
            audioFileInput.click();
        });

        // Handle file selection from file picker
        audioFileInput.addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                if (isPlaying) stopAudio();
                await loadAudioFile(e.target.files[0]);
            }
        });

        // Click on custom file display opens file picker (to change file)
        customFileDisplay.addEventListener('click', () => {
            audioFileInput.click();
        });

        // Clear custom file and revert to preset track
        clearFileBtn.addEventListener('click', () => {
            if (isPlaying) stopAudio();

            // Clean up blob URL to prevent memory leak
            if (audioElement && audioElement.src.startsWith('blob:')) {
                URL.revokeObjectURL(audioElement.src);
            }

            audioElement = null;
            currentFile = null;
            hideFileLoaded();
            audioFileInput.value = '';

            // Load default track
            loadTrack('female');
            trackSelect.value = 'female';
            log('Custom file removed', 'info');
        });

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // DEBUG TOOLS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        // Copy BPM detection debug log to clipboard (for debugging/reporting)
        copyLogBtn.addEventListener('click', async () => {
            const trackName = trackSelect.options[trackSelect.selectedIndex]?.text || currentTrack;

            // Get the actual debug log from the detector
            let logText = mascot?.getBPMDebugLog?.() || 'No debug log available.';

            // Add track info header
            logText = `Track: ${trackName}\n\n${logText}`;

            try {
                await navigator.clipboard.writeText(logText);
                copyLogBtn.textContent = 'Copied!';
                setTimeout(() => { copyLogBtn.textContent = 'Copy Log'; }, 1500);
                log('BPM debug log copied to clipboard', 'info');
            } catch (err) {
                log(`Failed to copy: ${err.message}`, 'error');
            }
        });

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * GLOBAL DRAG & DROP
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * Allows users to drag audio files anywhere onto the page.
         * The overlay provides visual feedback during drag operations.
         *
         * IMPLEMENTATION NOTES:
         * - dragCounter tracks nested drag events (drag into child elements)
         * - Must call e.preventDefault() on all drag events to enable drop
         * - Validate file type before loading to prevent errors
         */

        // Track nested drag events for proper overlay show/hide
        let dragCounter = 0;

        // Show overlay when dragging files over the page
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            if (e.dataTransfer.types.includes('Files')) {
                globalDropOverlay.classList.add('active');
            }
        });

        // Hide overlay when drag leaves the page
        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                globalDropOverlay.classList.remove('active');
            }
        });

        // Required to enable drop
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        // Handle dropped files
        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            dragCounter = 0;
            globalDropOverlay.classList.remove('active');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];

                // Validate file type (check MIME type or extension)
                const isAudio = file.type.startsWith('audio/') ||
                    /\.(mp3|wav|ogg|flac|m4a|aac)$/i.test(file.name);

                if (isAudio) {
                    if (isPlaying) stopAudio();
                    await loadAudioFile(file);
                } else {
                    log('Please drop an audio file (MP3, WAV, OGG, FLAC)', 'error');
                }
            }
        });

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // PLAYBACK CONTROLS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        playBtn.addEventListener('click', playAudio);
        stopBtn.addEventListener('click', stopAudio);
        tapTempoBtn.addEventListener('click', handleTapTempo);

        // Groove preset buttons
        grooveButtons.forEach(btn => {
            btn.addEventListener('click', () => setGroove(btn.dataset.groove));
        });

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // KEYBOARD SHORTCUTS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Space: Play/Stop | T: Tap Tempo | 1/2/3: Switch Groove

        document.addEventListener('keydown', (e) => {
            // Ignore shortcuts when typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            switch (e.key) {
            case ' ': // Space: Toggle playback
                e.preventDefault();
                if (isPlaying) stopAudio();
                else playAudio();
                break;
            case 't': // T: Tap tempo
            case 'T':
                handleTapTempo();
                break;
            case '1': // 1/2/3: Switch groove presets
                setGroove('groove1');
                break;
            case '2':
                setGroove('groove2');
                break;
            case '3':
                setGroove('groove3');
                break;
            }
        });

        // Setup shared toggle handlers from demo-utils.js
        // These handle particles, glow, breathing, and auto-rotate toggles
        setupParticlesToggle(mascot);
        setupVisualToggles(mascot);

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // COLLAPSIBLE SECTIONS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        // Advanced gestures toggle (collapsed by default)
        const advancedToggle = document.getElementById('advancedToggle');
        advancedToggle.addEventListener('click', () => {
            advancedToggle.classList.toggle('collapsed');
        });

        // Debug section toggle (collapsed by default)
        const debugSection = document.querySelector('.debug-section');
        debugSection.querySelector('h2').addEventListener('click', () => {
            debugSection.classList.toggle('collapsed');
        });

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * DANCE CHOREOGRAPHER PANEL
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * The Dance Choreographer automatically triggers gestures based on audio:
         *
         * GESTURE TYPES:
         * - Accent gestures (pop, bob, swell): Enhance groove without overriding it
         * - Absolute gestures (nod, burst, spin): Create distinct movements
         * - Glow gestures (flash, glow): Visual brightness changes (rate-limited)
         *
         * TRIGGER SOURCES:
         * - Bass energy: Triggers on low-frequency peaks (kick drums, bass drops)
         * - Vocal/mid energy: Triggers on mid-frequency peaks (vocals, melody)
         * - Beat timing: Aligns gestures to detected BPM
         *
         * KEY APIS USED:
         * - mascot.enableDance()         - Enable automatic gesture triggering
         * - mascot.disableDance()        - Disable choreographer
         * - mascot.setDanceIntensity(n)  - Set intensity 0-1 (affects gesture frequency)
         */

        // Toggle dance choreographer on/off
        danceToggle.addEventListener('click', () => {
            const isActive = danceToggle.classList.toggle('active');
            danceToggle.textContent = isActive ? 'On' : 'Off';

            if (isActive) {
                mascot?.enableDance?.();
                log('Dance choreographer enabled', 'groove');
            } else {
                mascot?.disableDance?.();
                log('Dance choreographer disabled', 'info');
            }
        });

        // Adjust dance intensity (0-100%)
        // Higher intensity = more frequent gestures
        danceIntensitySlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value, 10);
            intensityValueEl.textContent = `${value}%`;
            mascot?.setDanceIntensity?.(value / 100);
        });

        /**
         * Highlight a gesture chip when fired.
         * Provides visual feedback for which gestures are being triggered.
         * @param {string} gestureName - Name of the gesture
         * @param {number} duration - How long to keep highlighted (ms)
         */
        function highlightGesture(gestureName, duration = 800) {
            const chip = document.querySelector(`.gesture-chip[data-gesture="${gestureName}"]`);
            if (!chip) return;

            // Clear any existing timeout (in case same gesture fires rapidly)
            if (activeGestures.has(gestureName)) {
                clearTimeout(activeGestures.get(gestureName));
            }

            // Activate the chip visually
            chip.classList.add('active');

            // Deactivate after duration
            const timeoutId = setTimeout(() => {
                chip.classList.remove('active');
                activeGestures.delete(gestureName);
            }, duration);

            activeGestures.set(gestureName, timeoutId);
        }

        /**
         * Highlight a combo chip when a combo is triggered.
         * Combos are sequences of gestures (like burst+spin for climactic moments).
         */
        function highlightCombo(comboType, duration = 1200) {
            const chip = document.querySelector(`.combo-chip[data-combo="${comboType}"]`);
            if (!chip) return;

            chip.classList.add('active');
            setTimeout(() => chip.classList.remove('active'), duration);
        }

        /**
         * Hook into gesture triggers to show visual feedback.
         * This demonstrates a useful debugging technique: patching methods
         * to intercept calls without modifying the original library.
         */
        function patchGestureTracking() {
            if (!mascot) return;

            // Patch mascot.express() to intercept gesture calls
            const originalExpress = mascot.express.bind(mascot);
            mascot.express = function(gestureName) {
                // Show visual feedback in UI
                highlightGesture(gestureName);

                // Log for debugging
                log(`Gesture: ${gestureName}`, 'gesture');

                // Call the original method
                return originalExpress(gestureName);
            };

            // Also patch gesture() if it exists (used internally by choreographer)
            if (mascot.gesture) {
                const originalGesture = mascot.gesture.bind(mascot);
                mascot.gesture = function(gestureName, options = {}) {
                    highlightGesture(gestureName);
                    return originalGesture(gestureName, options);
                };
            }
        }

        /**
         * Update the dance status display panel.
         * Shows real-time choreographer state for debugging.
         *
         * KEY API USED:
         * - mascot.getDanceStatus() - Returns choreographer state:
         *   {
         *     enabled: boolean,       // Is choreographer active
         *     intensity: number,      // Current intensity (0-1)
         *     currentGroove: string,  // Active groove preset
         *     avgBass: string,        // Smoothed bass energy
         *     avgVocal: string,       // Smoothed mid/vocal energy
         *     barCount: number        // Bars since rhythm started
         *   }
         */
        function updateDanceStatus() {
            if (!mascot?.getDanceStatus) return;

            const status = mascot.getDanceStatus();

            // Update display values
            danceGrooveEl.textContent = status.currentGroove || 'groove1';
            danceBassEl.textContent = status.avgBass || '0.00';
            danceVocalEl.textContent = status.avgVocal || '0.00';
            danceBarEl.textContent = status.barCount || '0';

            // Highlight groove when enabled
            if (status.currentGroove) {
                danceGrooveEl.classList.toggle('highlight', status.enabled);
            }

            // Sync toggle UI with actual state
            // (handles auto-enable when BPM locks)
            const isEnabled = status.enabled;
            const intensity = status.intensity || 0.5;

            if (isEnabled && !danceToggle.classList.contains('active')) {
                danceToggle.classList.add('active');
                danceToggle.textContent = 'On';
                log('Dance auto-enabled (BPM locked)', 'groove');
            }

            // Sync slider with current intensity
            const sliderValue = Math.round(intensity * 100);
            if (parseInt(danceIntensitySlider.value, 10) !== sliderValue) {
                danceIntensitySlider.value = sliderValue;
                intensityValueEl.textContent = `${sliderValue}%`;
            }
        }

        // Update dance status periodically
        setInterval(updateDanceStatus, UPDATE_INTERVALS.danceStatus);

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // INTERACTIVE GESTURE CHIPS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Click gesture chips to manually trigger them (great for testing!)

        gestureChips.forEach(chip => {
            chip.addEventListener('click', () => {
                const gestureName = chip.dataset.gesture;
                if (gestureName && mascot) {
                    mascot.express(gestureName);
                }
            });
            chip.style.cursor = 'pointer';
        });

        // Combo chips trigger a random gesture from their category
        const COMBO_GESTURES = {
            subtle: ['nod', 'sway', 'pulse', 'wiggle'],
            moderate: ['bounce', 'headBob', 'lean'],
            energetic: ['spin', 'jump', 'twist', 'hula']
        };

        comboChips.forEach(chip => {
            chip.addEventListener('click', () => {
                const comboType = chip.dataset.combo;
                const gestures = COMBO_GESTURES[comboType];

                if (gestures && mascot) {
                    // Pick a random gesture from the category
                    const gesture = gestures[Math.floor(Math.random() * gestures.length)];
                    highlightCombo(comboType);
                    mascot.express(gesture);
                }
            });
            chip.style.cursor = 'pointer';
        });

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * LLM AUDIO INTERPRETER
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * The AudioInterpreter uses a BYOK (Bring Your Own Key) LLM to interpret
         * semantic content from audio (lyrics, mood) and map it to engine actions.
         *
         * WORKFLOW:
         * 1. User enters OpenAI API key
         * 2. Type lyrics/mood text or feed from transcription
         * 3. LLM interprets and returns { geometry, sss, emotion, gesture }
         * 4. Actions are applied to the mascot
         */

        /**
         * Initialize the LLM Audio Interpreter
         */
        function initAudioInterpreter() {
            audioInterpreter = new AudioInterpreter({
                onAction: handleLLMAction,
                onError: handleLLMError
            });
        }

        /**
         * Parse lyrics text into timed entries
         * Supports formats:
         * - [MM:SS] lyrics text
         * - [MM:SS.ms] lyrics text
         * - Plain text (will be auto-timed every 5 seconds)
         */
        function parseLyrics(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const result = [];
            let autoTime = 0;
            const autoInterval = 5; // seconds between auto-timed lines

            // Timestamp regex: [00:15] or [00:15.500] or [0:15]
            const timestampRegex = /^\[(\d{1,2}):(\d{2})(?:\.(\d+))?\]\s*(.+)/;

            for (const line of lines) {
                const match = line.match(timestampRegex);
                if (match) {
                    const minutes = parseInt(match[1], 10);
                    const seconds = parseInt(match[2], 10);
                    const ms = match[3] ? parseInt(match[3].padEnd(3, '0').slice(0, 3), 10) : 0;
                    const text = match[4].trim();

                    if (text) {
                        result.push({
                            time: minutes * 60 + seconds + ms / 1000,
                            text
                        });
                    }
                } else if (line.trim()) {
                    // No timestamp - auto-time it
                    result.push({
                        time: autoTime,
                        text: line.trim()
                    });
                    autoTime += autoInterval;
                }
            }

            // Sort by time
            result.sort((a, b) => a.time - b.time);
            return result;
        }

        /**
         * Start tracking lyrics with audio playback
         */
        function startLyricsTracking() {
            if (lyricsUpdateInterval) {
                clearInterval(lyricsUpdateInterval);
            }

            currentLyricIndex = -1;
            console.log('[LyricsTracker] Started - tracking', parsedLyrics.length, 'lines');

            // Check every 250ms for next lyric line
            lyricsUpdateInterval = setInterval(() => {
                if (!audioElement || !isPlaying || parsedLyrics.length === 0) return;
                if (!audioInterpreter?.enabled) return;

                const currentTime = audioElement.currentTime;

                // Find the current lyric line based on audio time
                let newIndex = -1;
                for (let i = parsedLyrics.length - 1; i >= 0; i--) {
                    if (currentTime >= parsedLyrics[i].time) {
                        newIndex = i;
                        break;
                    }
                }

                // If we moved to a new line, feed it to the interpreter
                if (newIndex !== currentLyricIndex && newIndex >= 0) {
                    currentLyricIndex = newIndex;
                    const lyric = parsedLyrics[newIndex];
                    const audioTime = formatTimestamp(currentTime);
                    const lyricTime = formatTimestamp(lyric.time);
                    console.log(`[LyricsTracker] ${audioTime} | Line ${newIndex + 1}/${parsedLyrics.length} @ ${lyricTime}: "${lyric.text}"`);
                    log(`[${lyricTime}] "${lyric.text}"`, 'info');
                    audioInterpreter.feedText(lyric.text);
                }
            }, 250);
        }

        /**
         * Format seconds to MM:SS timestamp
         */
        function formatTimestamp(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        /**
         * Stop lyrics tracking
         */
        function stopLyricsTracking() {
            if (lyricsUpdateInterval) {
                clearInterval(lyricsUpdateInterval);
                lyricsUpdateInterval = null;
            }
            currentLyricIndex = -1;
        }

        /**
         * Handle action from LLM interpreter
         * @param {Object} action - { geometry, sss, emotion, gesture }
         */
        function handleLLMAction(action) {
            if (!mascot || !action) return;

            llmRequestCount++;
            llmRequestCountEl.textContent = `${llmRequestCount} requests`;

            // Get audio time for logging
            const audioTime = audioElement ? formatTimestamp(audioElement.currentTime) : '--:--';

            // Detailed console logging
            console.log(`[LLM Action] @ ${audioTime}`, JSON.stringify(action, null, 2));

            // Log the action
            const time = new Date().toLocaleTimeString('en-US', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const actionParts = [];
            if (action.geometry) actionParts.push(`geo:${action.geometry}`);
            if (action.sss) actionParts.push(`sss:${action.sss}`);
            if (action.emotion) actionParts.push(`emo:${action.emotion}`);
            if (action.gesture) {
                const gesStr = Array.isArray(action.gesture) ? action.gesture.join('+') : action.gesture;
                actionParts.push(`ges:${gesStr}`);
            }
            if (action.then) {
                const thenStr = Array.isArray(action.then) ? action.then.join('+') : action.then;
                actionParts.push(`â†’${thenStr}`);
            }

            const entry = document.createElement('div');
            entry.className = 'llm-action';
            entry.innerHTML = `<span class="action-time">${audioTime}</span><span class="action-type">${actionParts.join(' ')}</span>`;
            llmActionLog.insertBefore(entry, llmActionLog.firstChild);

            // Limit log size
            while (llmActionLog.children.length > 20) {
                llmActionLog.removeChild(llmActionLog.lastChild);
            }

            // Apply actions to mascot with detailed logging
            if (action.geometry) {
                console.log(`  â†’ morphTo('${action.geometry}')`);
                mascot.morphTo(action.geometry);
                log(`LLM â†’ Geometry: ${action.geometry}`, 'groove');
            }

            if (action.sss) {
                console.log(`  â†’ setSSSPreset('${action.sss}')`);
                mascot.setSSSPreset(action.sss);
                log(`LLM â†’ SSS: ${action.sss}`, 'groove');
            }

            if (action.emotion) {
                console.log(`  â†’ setEmotion('${action.emotion}')`);
                mascot.setEmotion(action.emotion);
                log(`LLM â†’ Emotion: ${action.emotion}`, 'groove');
            }

            // Handle gesture - supports single, array (layered), and sequential (then)
            if (action.gesture) {
                const gestures = Array.isArray(action.gesture) ? action.gesture : [action.gesture];

                // Execute all gestures (layered/simultaneous)
                for (const g of gestures) {
                    console.log(`  â†’ express('${g}')`);
                    mascot.express(g);
                }

                const gestureStr = gestures.join('+');
                log(`LLM â†’ Gesture: ${gestureStr}`, 'gesture');

                // Handle sequential "then" gesture after a delay
                if (action.then) {
                    const thenGestures = Array.isArray(action.then) ? action.then : [action.then];
                    setTimeout(() => {
                        for (const g of thenGestures) {
                            mascot.express(g);
                        }
                        log(`LLM â†’ Then: ${thenGestures.join('+')}`, 'gesture');
                    }, 400); // Delay for accent to land before settling
                }
            }
        }

        /**
         * Handle LLM error
         * @param {Error} err - Error object
         */
        function handleLLMError(err) {
            log(`LLM Error: ${err.message}`, 'error');
            llmStatus.classList.remove('active');
            llmStatus.classList.add('error');
            llmStatus.querySelector('span').textContent = `Error: ${err.message}`;
        }

        // LLM Toggle - enable/disable interpreter
        llmToggle.addEventListener('click', () => {
            const isActive = llmToggle.classList.toggle('active');
            llmToggle.textContent = isActive ? 'On' : 'Off';

            if (isActive) {
                const apiKey = llmApiKeyInput.value.trim();
                if (!apiKey) {
                    log('LLM: Enter API key first', 'error');
                    llmToggle.classList.remove('active');
                    llmToggle.textContent = 'Off';
                    return;
                }

                const provider = llmProviderSelect.value;
                const endpoint = LLM_ENDPOINTS[provider];
                const model = llmModelInput.value.trim() || null; // Let AudioInterpreter use defaults

                audioInterpreter.configure({
                    apiKey,
                    endpoint,
                    model
                });

                // Update current mascot state
                audioInterpreter.updateCurrentState({
                    geometry: mascot?.core3D?.geometryType || 'crystal',
                    emotion: 'calm'
                });

                if (audioInterpreter.enable()) {
                    llmStatus.classList.remove('error');
                    llmStatus.classList.add('active');
                    llmStatus.querySelector('span').textContent = `Active (${provider})`;
                    log(`LLM Interpreter enabled: ${provider}`, 'groove');
                }
            } else {
                audioInterpreter.disable();
                llmStatus.classList.remove('active', 'error');
                llmStatus.querySelector('span').textContent = 'Status: Disabled';
                log('LLM Interpreter disabled', 'info');
            }
        });

        // LLM Test button - interpret text input
        llmTestBtn.addEventListener('click', async () => {
            const text = llmTestInput.value.trim();
            if (!text) return;

            if (!audioInterpreter.enabled) {
                log('LLM: Enable interpreter first', 'error');
                return;
            }

            llmTestBtn.disabled = true;
            llmTestBtn.textContent = 'Interpreting...';

            try {
                await audioInterpreter.interpret(text);
            } finally {
                llmTestBtn.disabled = false;
                llmTestBtn.textContent = 'Interpret';
            }
        });

        // Allow Enter key to trigger interpretation
        llmTestInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                llmTestBtn.click();
            }
        });

        // Parse lyrics button
        llmParseLyricsBtn.addEventListener('click', () => {
            const text = llmLyricsTextarea.value.trim();
            if (!text) {
                parsedLyrics = [];
                llmLyricsStatusEl.textContent = 'No lyrics loaded';
                log('Lyrics cleared', 'info');
                return;
            }

            parsedLyrics = parseLyrics(text);
            const hasTimestamps = parsedLyrics.some((l, i) => i > 0 && l.time !== i * 5);
            const mode = hasTimestamps ? 'timed' : 'auto (5s intervals)';
            llmLyricsStatusEl.textContent = `${parsedLyrics.length} lines (${mode})`;
            log(`Parsed ${parsedLyrics.length} lyrics lines (${mode})`, 'groove');
        });

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * INITIALIZATION
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * Everything starts here! The async initMascot() function:
         * 1. Creates the EmotiveMascot3D instance
         * 2. Initializes WebGL renderer (loads geometry, shaders)
         * 3. Starts the animation loop
         * 4. Enables the groove system
         * 5. Preloads the default audio track
         *
         * After initialization, we:
         * - Patch gesture tracking for visual feedback
         * - Enable the dance choreographer at full intensity
         * - Log that we're ready to go!
         */
        initMascot()
            .then(() => {
                // Patch gesture tracking after mascot is initialized
                patchGestureTracking();

                // Enable dance choreographer at full intensity
                // It will activate automatically when BPM locks
                mascot?.enableDance?.();
                mascot?.setDanceIntensity?.(1.0);

                log('Dance choreographer ready (will activate on BPM lock)', 'groove');

                // Initialize LLM Audio Interpreter
                initAudioInterpreter();
                log('LLM Interpreter ready (enter API key to enable)', 'info');
            })
            .catch(err => {
                log(`Init error: ${err.message}`, 'error');
                console.error('Initialization failed:', err);
            });

        log('Groove Test initialized - press PLAY to start!', 'info');
    </script>
</body>
</html>
