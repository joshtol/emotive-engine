<!DOCTYPE html>
<!--
  ELEMENTAL GESTURES - Emotive Engine 3D

  Showcase for elemental destruction gestures with their enhanced animation systems.
  Features fire, ice, electric, water, void, light, earth, and nature elements.

  Each element has unique visual characteristics:
  - Fire: Flash enter, high flicker, additive blending, chaotic variance
  - Ice: Grow enter, slow shimmer, geometric precision
  - Electric: Flash/pop enter, extreme flicker, chaotic rotation
  - Water: Pop/fade enter, flowing drift, organic variance
  - Void: Fade enter, inward drift, shrink exit, dark absorption
  - Light: Flash enter, high emissive, radiant additive blending
  - Earth: Grow enter, minimal animation, heavy stability
  - Nature: Grow enter, organic drift, living motion
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elemental Gestures - Emotive Engine</title>
    <link rel="stylesheet" href="/examples/3d-example-style.css">
    <style>
        /* Theme: Cyan/Teal for elemental magic */
        :root {
            --accent: #06b6d4;
            --accent-rgb: 6, 182, 212;
        }

        body {
            /* Colorful photo background for refraction testing */
            background: url('/assets/images/ice-test-bg.jpg') center/cover no-repeat;
        }

        /* Element color accents */
        .element-fire { --element-color: #f97316; }
        .element-ice { --element-color: #38bdf8; }
        .element-electric { --element-color: #facc15; }
        .element-water { --element-color: #3b82f6; }
        .element-poison { --element-color: #84cc16; }
        .element-void { --element-color: #a855f7; }
        .element-light { --element-color: #fef08a; }
        .element-earth { --element-color: #a3a3a3; }
        .element-nature { --element-color: #4ade80; }

        /* Search box styling */
        .search-box {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .search-box input {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            padding: 8px 12px;
            color: #fff;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s, background 0.2s;
        }

        .search-box input:focus {
            border-color: var(--accent);
            background: rgba(255, 255, 255, 0.12);
        }

        .search-box input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        /* Filter checkboxes with element colors */
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .filter-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .filter-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .filter-item label {
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .filter-item .element-icon {
            font-size: 14px;
        }

        .filter-count {
            font-size: 10px;
            opacity: 0.6;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 5px;
            border-radius: 10px;
        }

        /* Stats display */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.6;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Gesture button enhancements */
        .gesture-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 10px 8px;
            min-height: 60px;
            font-size: 11px;
            line-height: 1.2;
            transition: transform 0.15s, background 0.15s, border-color 0.15s;
        }

        .gesture-btn .emoji {
            font-size: 18px;
        }

        .gesture-btn .name {
            word-break: break-word;
            text-align: center;
        }

        .gesture-btn:hover {
            transform: scale(1.05);
        }

        .gesture-btn.hidden {
            display: none;
        }

        /* Element-specific button styling */
        .gesture-btn[data-element="fire"]:hover {
            border-color: rgba(249, 115, 22, 0.5);
            background: rgba(249, 115, 22, 0.15);
        }
        .gesture-btn[data-element="ice"]:hover {
            border-color: rgba(56, 189, 248, 0.5);
            background: rgba(56, 189, 248, 0.15);
        }
        .gesture-btn[data-element="electric"]:hover {
            border-color: rgba(250, 204, 21, 0.5);
            background: rgba(250, 204, 21, 0.15);
        }
        .gesture-btn[data-element="water"]:hover {
            border-color: rgba(59, 130, 246, 0.5);
            background: rgba(59, 130, 246, 0.15);
        }
        .gesture-btn[data-element="poison"]:hover {
            border-color: rgba(132, 204, 22, 0.5);
            background: rgba(132, 204, 22, 0.15);
        }
        .gesture-btn[data-element="void"]:hover {
            border-color: rgba(168, 85, 247, 0.5);
            background: rgba(168, 85, 247, 0.15);
        }
        .gesture-btn[data-element="light"]:hover {
            border-color: rgba(254, 240, 138, 0.5);
            background: rgba(254, 240, 138, 0.15);
        }
        .gesture-btn[data-element="earth"]:hover {
            border-color: rgba(163, 163, 163, 0.5);
            background: rgba(163, 163, 163, 0.15);
        }
        .gesture-btn[data-element="nature"]:hover {
            border-color: rgba(74, 222, 128, 0.5);
            background: rgba(74, 222, 128, 0.15);
        }

        /* Section headers with counts */
        .section h2 .gesture-count {
            font-size: 11px;
            font-weight: normal;
            opacity: 0.6;
            margin-left: 6px;
        }

        /* Section header element icons */
        .section h2 .element-icon {
            margin-right: 6px;
        }

        /* Hide collapsed sections properly */
        .section-content.collapsed {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            overflow: hidden !important;
        }

        /* Left-menu collapsible section */
        .left-menu #filters-section > h2 {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .left-menu #filters-section > h2::after {
            content: '+';
            font-size: 16px;
            font-weight: bold;
            color: #888;
            margin-left: 8px;
        }

        .left-menu #filters-section > h2:not(.collapsed)::after {
            content: '‚àí';
        }

        /* Right-menu sections */
        .right-menu {
            display: flex;
            flex-direction: column;
        }

        .right-menu > .section {
            display: block;
            position: relative;
            flex-shrink: 0;
        }

        .right-menu .section-content {
            display: block;
        }

        .right-menu .section > h2 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            background: none !important;
            border: none !important;
            padding: 0 !important;
            min-height: auto !important;
            font-size: clamp(11px, 1vw, 13px);
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 1.2px;
            cursor: pointer;
        }

        /* Button grid scrollable */
        .right-menu .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 4px;
        }

        /* Custom scrollbar */
        .right-menu .button-grid::-webkit-scrollbar {
            width: 4px;
        }

        .right-menu .button-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .right-menu .button-grid::-webkit-scrollbar-thumb {
            background: rgba(var(--accent-rgb), 0.4);
            border-radius: 2px;
        }

        .right-menu .button-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(var(--accent-rgb), 0.6);
        }

        .right-menu .button-grid > .gesture-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .button-grid > .loading-state,
        .button-grid > .empty-state {
            grid-column: 1 / -1;
            text-align: center;
        }

        .empty-state {
            text-align: center;
            padding: 20px;
            opacity: 0.5;
            font-size: 13px;
        }

        .loading-state {
            text-align: center;
            padding: 30px;
            opacity: 0.6;
        }

        .loading-state .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Gesture tooltip */
        .gesture-tooltip {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(var(--accent-rgb), 0.5);
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 12px;
            line-height: 1.4;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.15s;
            text-align: center;
            white-space: nowrap;
        }

        .gesture-tooltip.visible {
            opacity: 1;
        }

        body:has(.gesture-tooltip.visible) .camera-hint {
            opacity: 0 !important;
            animation: none !important;
        }

        .gesture-tooltip .tooltip-name {
            font-weight: bold;
            color: var(--accent);
        }

        .gesture-tooltip .tooltip-element {
            font-size: 10px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-left: 8px;
        }

        .gesture-tooltip .tooltip-desc {
            opacity: 0.8;
            margin-left: 8px;
        }

        /* Info box gesture display */
        .info-gesture {
            display: none;
        }

        .info-box.showing-gesture .info-default {
            display: none;
        }

        .info-box.showing-gesture .info-gesture {
            display: block;
        }

        .info-box.showing-gesture {
            background: rgba(var(--accent-rgb), 0.15);
            border-color: rgba(var(--accent-rgb), 0.4);
        }

        .info-gesture .gesture-name {
            font-weight: bold;
            color: var(--accent);
        }

        .info-gesture .gesture-element {
            font-size: 10px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-left: 6px;
        }

        .info-gesture .gesture-desc {
            display: block;
            margin-top: 4px;
            opacity: 0.8;
        }

        /* Element legend */
        .element-legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 12px;
            font-size: 11px;
        }

        .element-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0.7;
        }

        .element-legend-item .swatch {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        @media (max-width: 1000px) {
            .gesture-tooltip {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <!-- LEFT MENU -->
    <div class="left-menu">
        <div class="section">
            <h2>Geometry</h2>
            <div class="section-content">
                <div class="button-grid" style="max-height: none;">
                    <button data-action="geometry" data-value="crystal" class="active">üíé Crystal</button>
                    <button data-action="geometry" data-value="heart">üíó Heart</button>
                    <button data-action="geometry" data-value="rough">ü™® Rough</button>
                    <button data-action="geometry" data-value="star">‚≠ê Star</button>
                    <button data-action="geometry" data-value="moon">üåô Moon</button>
                    <button data-action="geometry" data-value="sun">‚òÄÔ∏è Sun</button>
                </div>
            </div>
        </div>

        <div class="section" id="filters-section">
            <h2 class="collapsed">Search & Filters</h2>
            <div class="section-content collapsed">
                <div class="search-box">
                    <input type="text" id="gesture-search" placeholder="Filter elemental gestures...">
                </div>
                <div class="filter-group">
                    <div class="filter-item">
                        <input type="checkbox" id="filter-fire" checked>
                        <label for="filter-fire">
                            <span class="element-icon">üî•</span> Fire
                            <span class="filter-count" id="count-fire">0</span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filter-ice" checked>
                        <label for="filter-ice">
                            <span class="element-icon">‚ùÑÔ∏è</span> Ice
                            <span class="filter-count" id="count-ice">0</span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filter-electric" checked>
                        <label for="filter-electric">
                            <span class="element-icon">‚ö°</span> Electric
                            <span class="filter-count" id="count-electric">0</span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filter-water" checked>
                        <label for="filter-water">
                            <span class="element-icon">üíß</span> Water
                            <span class="filter-count" id="count-water">0</span>
                        </label>
                    </div>
                    <!-- Poison filter removed - no element spawning -->
                    <div class="filter-item">
                        <input type="checkbox" id="filter-void" checked>
                        <label for="filter-void">
                            <span class="element-icon">üåë</span> Void
                            <span class="filter-count" id="count-void">0</span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filter-light" checked>
                        <label for="filter-light">
                            <span class="element-icon">‚ú®</span> Light
                            <span class="filter-count" id="count-light">0</span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filter-earth" checked>
                        <label for="filter-earth">
                            <span class="element-icon">ü™®</span> Earth
                            <span class="filter-count" id="count-earth">0</span>
                        </label>
                    </div>
                    <div class="filter-item">
                        <input type="checkbox" id="filter-nature" checked>
                        <label for="filter-nature">
                            <span class="element-icon">üåø</span> Nature
                            <span class="filter-count" id="count-nature">0</span>
                        </label>
                    </div>
                </div>
                <div class="stats-grid" style="margin-top: 12px;">
                    <div class="stat-item">
                        <div class="stat-value" id="stat-total">-</div>
                        <div class="stat-label">Elemental</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-visible">-</div>
                        <div class="stat-label">Visible</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="info-section">
            <div class="info-box" id="info-box">
                <div class="info-default">
                    <strong>Elemental Gestures</strong><br>
                    Destruction effects powered by fire, ice, electricity, water, void, light, earth, and nature.
                </div>
                <div class="info-gesture" id="info-gesture"></div>
            </div>
        </div>
    </div>

    <!-- CENTER ANIMATION -->
    <div class="center-content">
        <div id="animation-container"></div>
        <div class="camera-hint">Drag to rotate | Scroll to zoom | Click elements to unleash</div>
        <div class="gesture-tooltip" id="gesture-tooltip">
            <span class="tooltip-name"></span>
            <span class="tooltip-element"></span>
            <span class="tooltip-desc"></span>
        </div>
    </div>

    <!-- RIGHT MENU -->
    <div class="right-menu">
        <div class="section" id="section-fire">
            <h2><span class="element-icon">üî•</span> Fire <span class="gesture-count" id="header-count-fire"></span></h2>
            <div class="section-content">
                <div class="button-grid" id="grid-fire">
                    <div class="loading-state">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="section-ice">
            <h2 class="collapsed"><span class="element-icon">‚ùÑÔ∏è</span> Ice <span class="gesture-count" id="header-count-ice"></span></h2>
            <div class="section-content collapsed">
                <div class="button-grid" id="grid-ice">
                    <div class="loading-state">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="section-electric">
            <h2 class="collapsed"><span class="element-icon">‚ö°</span> Electric <span class="gesture-count" id="header-count-electric"></span></h2>
            <div class="section-content collapsed">
                <div class="button-grid" id="grid-electric">
                    <div class="loading-state">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="section-water">
            <h2 class="collapsed"><span class="element-icon">üíß</span> Water <span class="gesture-count" id="header-count-water"></span></h2>
            <div class="section-content collapsed">
                <div class="button-grid" id="grid-water">
                    <div class="loading-state">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <!-- Poison section removed - no element spawning -->

        <div class="section" id="section-void">
            <h2 class="collapsed"><span class="element-icon">üåë</span> Void <span class="gesture-count" id="header-count-void"></span></h2>
            <div class="section-content collapsed">
                <div class="button-grid" id="grid-void">
                    <div class="loading-state">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="section-light">
            <h2 class="collapsed"><span class="element-icon">‚ú®</span> Light <span class="gesture-count" id="header-count-light"></span></h2>
            <div class="section-content collapsed">
                <div class="button-grid" id="grid-light">
                    <div class="loading-state">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="section-earth">
            <h2 class="collapsed"><span class="element-icon">ü™®</span> Earth <span class="gesture-count" id="header-count-earth"></span></h2>
            <div class="section-content collapsed">
                <div class="button-grid" id="grid-earth">
                    <div class="loading-state">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="section-nature">
            <h2 class="collapsed"><span class="element-icon">üåø</span> Nature <span class="gesture-count" id="header-count-nature"></span></h2>
            <div class="section-content collapsed">
                <div class="button-grid" id="grid-nature">
                    <div class="loading-state">
                        <div class="spinner"></div>
                        Loading...
                    </div>
                </div>
            </div>
        </div>

        <div class="section visual-controls">
            <h2 class="has-toggle">
                <span>Visuals</span>
                <div class="toggle-switch active" id="particles-toggle">Particles</div>
            </h2>
            <div class="section-content">
                <div class="toggle-control">
                    <span class="toggle-label">Core Glow</span>
                    <div class="toggle-switch active" data-action="toggle-glow"></div>
                </div>
                <div class="toggle-control">
                    <span class="toggle-label">Auto-Rotate</span>
                    <div class="toggle-switch active" data-action="toggle-auto-rotate"></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import EmotiveMascot3D, { profiler } from '/emotive-engine-3d.bundled.js';
        import { setupParticlesToggle, setupVisualToggles } from '/examples/3d/demo-utils.js';

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZE MASCOT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const container = document.getElementById('animation-container');
        const mascot = new EmotiveMascot3D({
            coreGeometry: 'crystal',
            enableParticles: true,
            enablePostProcessing: true,
            enableShadows: false,
            enableControls: true,
            enableShatter: true,
            autoRotate: true,
            cameraDistance: 1.2,
            fov: 30,
            minZoom: 0.9,
            maxZoom: 2.0,
            materialVariant: 'multiplexer',
            assetBasePath: '/assets',
            preloadElements: [],
            backgroundPrewarm: false
        });

        mascot.init(container);
        mascot.start();

        // Set the CSS background image as refraction background so water/ice
        // can refract the page background, not just 3D geometry
        if (mascot.core3D?.renderer) {
            mascot.core3D.renderer.setRefractionBackground('/assets/images/ice-test-bg.jpg');
        }

        // Expose for console debugging
        window.mascot = mascot;
        window.profiler = profiler;

        // Setup shared toggles
        setupParticlesToggle(mascot);
        setupVisualToggles(mascot);

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ELEMENTAL GESTURE DISCOVERY
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Elemental types for testing (all elements - shatter gestures filtered by usesShatter)
        const elements = ['fire', 'ice', 'electric', 'water', 'void', 'light', 'earth', 'nature'];

        // Element metadata for display
        const elementMeta = {
            fire: { emoji: 'üî•', name: 'Fire' },
            ice: { emoji: '‚ùÑÔ∏è', name: 'Ice' },
            electric: { emoji: '‚ö°', name: 'Electric' },
            water: { emoji: 'üíß', name: 'Water' },
            void: { emoji: 'üåë', name: 'Void' },
            light: { emoji: '‚ú®', name: 'Light' },
            earth: { emoji: 'ü™®', name: 'Earth' },
            nature: { emoji: 'üåø', name: 'Nature' }
        };

        // Storage for gesture data
        let allElementalGestures = [];

        // Elements
        const grids = {};
        const sections = {};
        const filters = {};
        const counts = {};
        const headerCounts = {};

        elements.forEach(el => {
            grids[el] = document.getElementById(`grid-${el}`);
            sections[el] = document.getElementById(`section-${el}`);
            filters[el] = document.getElementById(`filter-${el}`);
            counts[el] = document.getElementById(`count-${el}`);
            headerCounts[el] = document.getElementById(`header-count-${el}`);
        });

        const searchInput = document.getElementById('gesture-search');
        const statTotal = document.getElementById('stat-total');
        const statVisible = document.getElementById('stat-visible');
        const tooltip = document.getElementById('gesture-tooltip');
        const infoBox = document.getElementById('info-box');
        const infoGesture = document.getElementById('info-gesture');

        /**
         * Detect element type from gesture name
         * Uses prefix-based detection first, then specific keywords
         */
        function detectElement(gestureName) {
            const name = gestureName.toLowerCase();

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // PREFIX-BASED DETECTION (most reliable)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if (name.startsWith('poison')) return 'poison';
            if (name.startsWith('light')) return 'light';
            if (name.startsWith('fire')) return 'fire';
            if (name.startsWith('ice')) return 'ice';
            if (name.startsWith('electric')) return 'electric';
            if (name.startsWith('water')) return 'water';
            if (name.startsWith('void')) return 'void';
            if (name.startsWith('earth')) return 'earth';
            if (name.startsWith('nature')) return 'nature';

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // KEYWORD-BASED DETECTION (for unprefixed gestures)
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            // Fire keywords (flame-vortex matches on 'flame', phoenix is fire rebirth)
            if (name.includes('burn') || name.includes('blaze') || name.includes('scorch') ||
                name.includes('combust') || name.includes('smolder') ||
                name.includes('inferno') || name.includes('flame') ||
                name.includes('radiate') || name.includes('phoenix') || name.includes('firedance')) {
                return 'fire';
            }

            // Ice keywords
            if (name.includes('freeze') || name.includes('frost') ||
                name.includes('crystal') || name.includes('glacial') || name.includes('chill') ||
                name.includes('frozen')) {
                return 'ice';
            }

            // Electric keywords (use exact match for ambiguous terms to avoid false positives)
            if (name.includes('shock') || name.includes('zap') ||
                name === 'crackle' || name === 'chargeup' || name.includes('volt') ||
                name.includes('lightning') || name.includes('thunder') ||
                name === 'staticdischarge' ||
                name.includes('overload') || name.includes('glitch')) {
                return 'electric';
            }

            // Water keywords (specific to actual water gestures)
            if (name.includes('splash') || name.includes('drench') || name.includes('soak') ||
                name.includes('tide') || name.includes('liquefy') || name.includes('pool') ||
                name.includes('flood') || name.includes('drown') || name.includes('aqua') ||
                name === 'flow') {
                return 'water';
            }

            // Poison keywords
            if (name.includes('toxic') || name.includes('corrode') || name.includes('ooze') ||
                name.includes('seep') || name.includes('infect') || name.includes('sicken') ||
                name.includes('melt') || name.includes('decay') || name.includes('acid') ||
                name.includes('venom')) {
                return 'poison';
            }

            // Void keywords
            if (name.includes('drain') || name.includes('consume') ||
                name.includes('singularity') || name.includes('abyss') || name.includes('dark') ||
                name.includes('hollow') || name.includes('null') || name.includes('devour') ||
                name.includes('corrupt')) {
                return 'void';
            }

            // Light keywords
            if (name.includes('blind') || name.includes('purify') || name.includes('cleanse') ||
                name.includes('ascend') || name.includes('shine') || name.includes('illuminate') ||
                name.includes('luminous') || name.includes('bright') || name.includes('beam') ||
                name.includes('beacon') || name.includes('holy')) {
                return 'light';
            }

            // Earth keywords
            if (name.includes('petrify') || name.includes('stone') ||
                name.includes('quake') || name.includes('tremor') ||
                name.includes('rubble') || name.includes('boulder') || name.includes('mineral')) {
                return 'earth';
            }

            // Nature keywords
            if (name.includes('entangle') || name.includes('root') || name.includes('vine') ||
                name.includes('sprout') || name.includes('flourish') ||
                name.includes('plant') || name.includes('grow') ||
                name.includes('constrict') || name.includes('thorn') || name.includes('leaf') ||
                name === 'wilt' || name === 'overgrow' || name === 'blossom') {
                return 'nature';
            }

            return null;
        }

        /**
         * Create a gesture button element
         */
        function createGestureButton(gesture, element) {
            const btn = document.createElement('button');
            btn.className = 'gesture-btn';
            btn.dataset.gesture = gesture.name;
            btn.dataset.element = element;
            btn.dataset.description = gesture.description || '';

            // Pure DOM API ‚Äî no innerHTML parsing overhead
            const emojiSpan = document.createElement('span');
            emojiSpan.className = 'emoji';
            emojiSpan.textContent = gesture.emoji || elementMeta[element].emoji;
            const nameSpan = document.createElement('span');
            nameSpan.className = 'name';
            nameSpan.textContent = gesture.name;
            btn.appendChild(emojiSpan);
            btn.appendChild(nameSpan);

            return btn;
        }

        /**
         * Populate gesture grids from registry names.
         * warmUpGestures yields names WITHOUT triggering lazy factory getters,
         * so this is instant ‚Äî zero module evaluation, zero frame drops.
         * Factories load on-demand when the user actually clicks a gesture.
         */
        function populateGesturesProgressively() {
            Object.values(grids).forEach(grid => {
                if (grid) grid.innerHTML = '';
            });

            const gestureCounts = {};
            elements.forEach(el => { gestureCounts[el] = 0; });

            mascot.warmUpGestures({
                prewarmFactories: false, // factories resolve on-demand at click time
                onBatch(batch) {
                    const frags = {};
                    batch.forEach(gesture => {
                        if (gesture.name.startsWith('shatter')) return;
                        const element = detectElement(gesture.name);
                        if (!element || !grids[element]) return;

                        if (!frags[element]) frags[element] = document.createDocumentFragment();
                        frags[element].appendChild(createGestureButton(gesture, element));
                        allElementalGestures.push({ ...gesture, element });
                        gestureCounts[element]++;
                    });

                    Object.entries(frags).forEach(([element, frag]) => {
                        grids[element].appendChild(frag);
                    });
                },
                onComplete() {
                    elements.forEach(el => {
                        const c = gestureCounts[el];
                        if (c === 0 && grids[el]) {
                            grids[el].innerHTML = '<div class="empty-state">No gestures</div>';
                        }
                        if (counts[el]) counts[el].textContent = c;
                        if (headerCounts[el]) headerCounts[el].textContent = `(${c})`;
                    });
                    statTotal.textContent = allElementalGestures.length;
                    updateVisibleCount();
                }
            });
        }

        /**
         * Filter gestures based on search and element filters
         */
        function filterGestures() {
            const searchTerm = searchInput.value.toLowerCase().trim();

            // Check which elements are enabled
            const enabledElements = {};
            elements.forEach(el => {
                enabledElements[el] = filters[el]?.checked ?? true;
            });

            // Show/hide sections based on element filters
            Object.entries(sections).forEach(([element, section]) => {
                if (section) {
                    section.style.display = enabledElements[element] ? '' : 'none';
                }
            });

            // Filter individual buttons
            document.querySelectorAll('.gesture-btn').forEach(btn => {
                const name = btn.dataset.gesture.toLowerCase();
                const element = btn.dataset.element;

                const matchesSearch = !searchTerm || name.includes(searchTerm);
                const matchesElement = enabledElements[element];

                btn.classList.toggle('hidden', !matchesSearch || !matchesElement);
            });

            updateVisibleCount();
        }

        /**
         * Update visible gesture count
         */
        function updateVisibleCount() {
            const visible = document.querySelectorAll('.gesture-btn:not(.hidden)').length;
            statVisible.textContent = visible;
        }

        /**
         * Show tooltip for gesture
         */
        function showTooltip(btn) {
            const name = btn.dataset.gesture;
            const gesture = allElementalGestures.find(g => g.name === name);
            if (!gesture) return;

            const element = btn.dataset.element;
            const meta = elementMeta[element];

            // Desktop: floating tooltip
            tooltip.querySelector('.tooltip-name').textContent = `${gesture.emoji || meta.emoji} ${gesture.name}`;
            tooltip.querySelector('.tooltip-element').textContent = `[${meta.name}]`;
            tooltip.querySelector('.tooltip-desc').textContent = `‚Äî ${gesture.description || 'Elemental destruction'}`;
            tooltip.classList.add('visible');

            // Mobile: info-box replacement
            infoGesture.innerHTML = `
                <span class="gesture-name">${gesture.emoji || meta.emoji} ${gesture.name}</span>
                <span class="gesture-element">[${meta.name}]</span>
                <span class="gesture-desc">${gesture.description || 'Elemental destruction effect'}</span>
            `;
            infoBox.classList.add('showing-gesture');
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // EVENT HANDLERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Left-menu section toggle (Search & Filters)
        const filtersSection = document.getElementById('filters-section');
        if (filtersSection) {
            const header = filtersSection.querySelector('h2');
            const content = filtersSection.querySelector('.section-content');
            if (header && content) {
                header.style.cursor = 'pointer';
                header.addEventListener('click', () => {
                    header.classList.toggle('collapsed');
                    content.classList.toggle('collapsed');
                });
            }
        }

        // Geometry button clicks
        document.addEventListener('click', e => {
            const btn = e.target.closest('[data-action="geometry"]');
            if (!btn) return;

            const value = btn.dataset.value;
            mascot.morphTo(value);

            document.querySelectorAll('[data-action="geometry"]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        });

        // Gesture button clicks
        document.addEventListener('click', e => {
            const btn = e.target.closest('[data-gesture]');
            if (!btn) return;

            showTooltip(btn);

            const gestureName = btn.dataset.gesture;
            mascot.express(gestureName);
        });

        // Search input
        searchInput.addEventListener('input', filterGestures);

        // Filter checkboxes
        Object.values(filters).forEach(checkbox => {
            if (checkbox) {
                checkbox.addEventListener('change', filterGestures);
            }
        });

        // Tooltip on hover
        let tooltipTimeout;
        let currentTooltipBtn = null;

        document.addEventListener('mouseover', e => {
            const btn = e.target.closest('.gesture-btn');
            if (btn && btn !== currentTooltipBtn) {
                clearTimeout(tooltipTimeout);
                currentTooltipBtn = btn;
                tooltipTimeout = setTimeout(() => {
                    showTooltip(btn);
                }, 400);
            }
        });

        document.addEventListener('mouseout', e => {
            const btn = e.target.closest('.gesture-btn');
            if (btn) {
                clearTimeout(tooltipTimeout);
                currentTooltipBtn = null;
                hideTooltip();
            }
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GPU MEMORY MONITOR - Enhanced diagnostic tool
        // Features: peaks, FPS, trends, warnings, instance pools, copy to clipboard
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const gpuMonitor = {
            // Persisted data (survives crash)
            snapshots: JSON.parse(localStorage.getItem('gpu_snapshots') || '[]'),
            peaks: JSON.parse(localStorage.getItem('gpu_peaks') || '{"geometries":0,"textures":0,"programs":0,"triangles":0}'),
            gestureCount: parseInt(localStorage.getItem('gpu_gesture_count') || '0', 10),

            // Runtime state
            lastSnapshotTime: 0,
            pendingTimeout: null,
            visible: true,
            expanded: false,

            // Previous values for trend detection
            previous: null,

            // FPS tracking
            fps: { frames: 0, lastTime: performance.now(), current: 0, min: Infinity, max: 0, avg: 0, samples: [] },

            // Frame time tracking
            frameTime: { current: 0, min: Infinity, max: 0, samples: [] },

            // Gesture timing
            gestureTimings: [],
            currentGesture: null,

            // Warning thresholds (adjust based on your hardware)
            thresholds: { geometries: 100, textures: 100, programs: 50 },

            getStats() {
                const renderer = mascot.core3D?.renderer?.renderer;
                if (!renderer) return null;
                const info = renderer.info;
                return {
                    geometries: info.memory.geometries,
                    textures: info.memory.textures,
                    programs: info.programs?.length || 0,
                    calls: info.render.calls,
                    triangles: info.render.triangles
                };
            },

            getInstancePoolStats() {
                // Path: mascot.core3D.elementSpawner.pools (Map)
                const spawner = mascot.core3D?.elementSpawner;
                if (!spawner?.pools) return null;

                const stats = {};
                for (const [type, pool] of spawner.pools) {
                    if (pool.mesh) {
                        // pool.activeCount = active elements
                        // pool.maxInstances = total capacity (usually 64)
                        // pool.mesh.count = GPU instances currently rendered
                        stats[type] = {
                            active: pool.activeCount || 0,
                            total: pool.maxInstances || 64,
                            gpu: pool.mesh.count || 0
                        };
                    }
                }
                return Object.keys(stats).length > 0 ? stats : null;
            },

            getTrend(current, prev, key) {
                if (!prev) return '‚Üí';
                const diff = current[key] - prev[key];
                if (diff > 0) return '‚Üë';
                if (diff < 0) return '‚Üì';
                return '‚Üí';
            },

            getWarningLevel(value, threshold) {
                const ratio = value / threshold;
                if (ratio >= 0.9) return 'critical';
                if (ratio >= 0.8) return 'warning';
                return 'normal';
            },

            estimateMemory(stats) {
                // Rough estimates: geometry ~50KB avg, texture ~1MB avg, program ~10KB
                const geoMB = (stats.geometries * 50) / 1024;
                const texMB = stats.textures * 1;
                const progMB = (stats.programs * 10) / 1024;
                return (geoMB + texMB + progMB).toFixed(1);
            },

            updateFPS() {
                this.fps.frames++;
                const now = performance.now();
                const elapsed = now - this.fps.lastTime;

                if (elapsed >= 1000) {
                    this.fps.current = Math.round((this.fps.frames * 1000) / elapsed);
                    this.fps.frames = 0;
                    this.fps.lastTime = now;

                    // Track min/max/avg
                    if (this.fps.current > 0) {
                        this.fps.min = Math.min(this.fps.min, this.fps.current);
                        this.fps.max = Math.max(this.fps.max, this.fps.current);
                        this.fps.samples.push(this.fps.current);
                        if (this.fps.samples.length > 60) this.fps.samples.shift();
                        this.fps.avg = Math.round(this.fps.samples.reduce((a, b) => a + b, 0) / this.fps.samples.length);
                    }
                }

                // Frame time
                this.frameTime.current = elapsed / Math.max(this.fps.frames, 1);
            },

            snapshot(label) {
                const now = Date.now();
                if (now - this.lastSnapshotTime < 500) return;
                this.lastSnapshotTime = now;

                const stats = this.getStats();
                if (!stats) return;

                // Check for delta alerts (resource jump > 2)
                if (this.previous) {
                    const geoJump = stats.geometries - this.previous.geometries;
                    const texJump = stats.textures - this.previous.textures;
                    if (geoJump > 2 || texJump > 2) {
                        this.flashWarning();
                        console.warn(`[GPU] ‚ö†Ô∏è Resource jump: Œîgeo=${geoJump} Œîtex=${texJump}`);
                    }
                }

                // Update peaks and persist
                this.peaks.geometries = Math.max(this.peaks.geometries, stats.geometries);
                this.peaks.textures = Math.max(this.peaks.textures, stats.textures);
                this.peaks.programs = Math.max(this.peaks.programs, stats.programs);
                this.peaks.triangles = Math.max(this.peaks.triangles, stats.triangles);
                localStorage.setItem('gpu_peaks', JSON.stringify(this.peaks));

                const entry = {
                    label,
                    time: new Date().toISOString(),
                    gestureNum: this.gestureCount,
                    ...stats,
                    pools: this.getInstancePoolStats(),
                    fps: this.fps.current,
                    memoryEstMB: this.estimateMemory(stats)
                };

                this.snapshots.push(entry);
                if (this.snapshots.length > 30) this.snapshots.shift();
                localStorage.setItem('gpu_snapshots', JSON.stringify(this.snapshots));

                this.updateDisplay(stats);
                this.previous = { ...stats };

                console.log(`[GPU] ${label}: geo=${stats.geometries} tex=${stats.textures} prog=${stats.programs} fps=${this.fps.current}`);
            },

            flashWarning() {
                const display = document.getElementById('gpu-monitor-display');
                if (display) {
                    display.style.borderColor = '#e85d5d';
                    display.style.boxShadow = '0 0 12px rgba(232,93,93,0.3)';
                    setTimeout(() => {
                        display.style.borderColor = '';
                        display.style.boxShadow = '';
                    }, 400);
                }
            },

            createDisplay() {
                let display = document.getElementById('gpu-monitor-display');
                if (display) return display;

                // Parent container: .center-content (has position:relative)
                const parent = document.querySelector('.center-content') || document.body;

                // Hide tab (visible when monitor is hidden)
                const showTab = document.createElement('div');
                showTab.id = 'gpu-monitor-tab';
                showTab.style.cssText = `
                    position: absolute; right: 0; top: 8px;
                    background: var(--bg-panel); color: var(--text-muted);
                    font-family: 'SF Mono', Monaco, Inconsolata, monospace; font-size: 9px;
                    padding: 4px 6px; border-radius: 4px 0 0 4px; z-index: 10;
                    cursor: pointer; user-select: none;
                    border: 1px solid var(--border-color); border-right: none;
                    backdrop-filter: blur(10px); display: none;
                    transition: color 0.2s;
                `;
                showTab.textContent = 'GPU';
                showTab.onmouseenter = () => showTab.style.color = 'var(--accent)';
                showTab.onmouseleave = () => showTab.style.color = 'var(--text-muted)';
                showTab.onclick = () => this.toggle();
                parent.appendChild(showTab);

                // Main HUD panel
                display = document.createElement('div');
                display.id = 'gpu-monitor-display';
                display.style.cssText = `
                    position: absolute; right: 8px; top: 8px;
                    background: var(--bg-panel); color: var(--text-secondary);
                    font-family: 'SF Mono', Monaco, Inconsolata, monospace;
                    font-size: 10px; padding: 10px 10px; border-radius: 6px; z-index: 10;
                    user-select: none; min-width: 72px;
                    border: 1px solid var(--border-color); backdrop-filter: blur(10px);
                    transition: opacity 0.2s;
                `;
                parent.appendChild(display);
                return display;
            },

            updateDisplay(stats) {
                if (!this.visible) return;
                const display = this.createDisplay();

                const geoTrend = this.getTrend(stats, this.previous, 'geometries');
                const texTrend = this.getTrend(stats, this.previous, 'textures');
                const progTrend = this.getTrend(stats, this.previous, 'programs');

                const geoLevel = this.getWarningLevel(stats.geometries, this.thresholds.geometries);
                const texLevel = this.getWarningLevel(stats.textures, this.thresholds.textures);

                const colorFor = (level) => level === 'critical' ? '#e85d5d' : level === 'warning' ? '#f0c040' : 'var(--accent)';

                // Vertical HUD rows
                const row = (label, value, trend, color) =>
                    `<div style="display:flex;justify-content:space-between;gap:6px;padding:2px 0;">` +
                    `<span style="color:var(--text-muted);font-size:9px;">${label}</span>` +
                    `<span style="color:${color || 'var(--text-secondary)'}">${value}${trend || ''}</span></div>`;

                let html = '';

                // Header with hide button
                html += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">`;
                html += `<span style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;">GPU</span>`;
                html += `<span onclick="event.stopPropagation();gpuMonitor.toggle()" style="cursor:pointer;font-size:9px;color:var(--text-muted);opacity:0.5;transition:opacity 0.2s;" onmouseenter="this.style.opacity='1'" onmouseleave="this.style.opacity='0.5'">&times;</span>`;
                html += `</div>`;

                // Divider
                html += `<div style="border-top:1px solid var(--border-color);margin-bottom:4px;"></div>`;

                // Core stats
                html += row('FPS', this.fps.current || '--', '', 'var(--accent)');
                html += row('GEO', stats.geometries, geoTrend, colorFor(geoLevel));
                html += row('TEX', stats.textures, texTrend, colorFor(texLevel));
                html += row('PRG', stats.programs, progTrend);
                html += row('G#', this.gestureCount, '', 'var(--text-muted)');

                if (this.expanded) {
                    // Divider
                    html += `<div style="border-top:1px solid var(--border-color);margin:4px 0;"></div>`;

                    // Peaks
                    html += `<div style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:2px;">Peaks</div>`;
                    html += row('GEO', this.peaks.geometries);
                    html += row('TEX', this.peaks.textures);
                    html += row('PRG', this.peaks.programs);

                    // FPS range
                    const fpsMin = this.fps.min === Infinity ? '--' : this.fps.min;
                    const fpsMax = this.fps.max === 0 ? '--' : this.fps.max;
                    html += `<div style="border-top:1px solid var(--border-color);margin:4px 0;"></div>`;
                    html += row('MIN', fpsMin);
                    html += row('MAX', fpsMax);
                    html += row('AVG', this.fps.avg || '--');

                    // Memory
                    html += row('~MB', this.estimateMemory(stats));

                    // Instance pools
                    const pools = this.getInstancePoolStats();
                    if (pools) {
                        html += `<div style="border-top:1px solid var(--border-color);margin:4px 0;"></div>`;
                        html += `<div style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:2px;">Pools</div>`;
                        for (const [k, v] of Object.entries(pools)) {
                            const shortName = k.length > 6 ? k.slice(0, 6) : k;
                            html += row(shortName, `${v.active}/${v.gpu}`);
                        }
                    }

                    // Recent gesture timings
                    if (this.gestureTimings.length > 0) {
                        html += `<div style="border-top:1px solid var(--border-color);margin:4px 0;"></div>`;
                        this.gestureTimings.slice(-3).forEach(g => {
                            const shortName = g.name.length > 6 ? g.name.slice(0, 6) : g.name;
                            html += row(shortName, g.duration + 'ms', '', 'var(--text-muted)');
                        });
                    }

                    // Action buttons
                    html += `<div style="border-top:1px solid var(--border-color);margin:4px 0;"></div>`;
                    const btnStyle = `font-size:9px;padding:3px 0;cursor:pointer;background:none;border:none;color:var(--text-muted);text-align:center;width:100%;transition:color 0.15s;`;
                    html += `<button onclick="event.stopPropagation();gpuMonitor.copyToClipboard()" style="${btnStyle}" onmouseenter="this.style.color='var(--accent)'" onmouseleave="this.style.color=''">Copy</button>`;
                    html += `<button onclick="event.stopPropagation();gpuMonitor.resetPeaks()" style="${btnStyle}" onmouseenter="this.style.color='var(--accent)'" onmouseleave="this.style.color=''">Reset</button>`;
                    html += `<button onclick="event.stopPropagation();gpuMonitor.clear()" style="${btnStyle}" onmouseenter="this.style.color='#e85d5d'" onmouseleave="this.style.color=''">Clear</button>`;
                }

                // Click area for expand/collapse (bottom)
                html += `<div onclick="gpuMonitor.toggleExpanded()" style="text-align:center;padding:3px 0 0;cursor:pointer;font-size:8px;color:var(--text-muted);opacity:0.4;transition:opacity 0.2s;" onmouseenter="this.style.opacity='1'" onmouseleave="this.style.opacity='0.4'">${this.expanded ? '\u25B2' : '\u25BC'}</div>`;

                display.innerHTML = html;
            },

            toggleExpanded() {
                this.expanded = !this.expanded;
                const stats = this.getStats();
                if (stats) this.updateDisplay(stats);
            },

            toggle() {
                this.visible = !this.visible;
                const display = document.getElementById('gpu-monitor-display');
                const tab = document.getElementById('gpu-monitor-tab');
                if (display) {
                    display.style.display = this.visible ? 'block' : 'none';
                }
                if (tab) {
                    tab.style.display = this.visible ? 'none' : 'block';
                }
                console.log(`[GPU Monitor] ${this.visible ? 'Visible' : 'Hidden'} (press G to toggle)`);
            },

            resetPeaks() {
                this.peaks = { geometries: 0, textures: 0, programs: 0, triangles: 0 };
                localStorage.setItem('gpu_peaks', JSON.stringify(this.peaks));
                this.fps.min = Infinity;
                this.fps.max = 0;
                this.fps.samples = [];
                console.log('[GPU] Peaks reset');
                const stats = this.getStats();
                if (stats) this.updateDisplay(stats);
            },

            copyToClipboard() {
                const data = {
                    timestamp: new Date().toISOString(),
                    current: this.getStats(),
                    peaks: this.peaks,
                    fps: { current: this.fps.current, min: this.fps.min === Infinity ? null : this.fps.min, max: this.fps.max, avg: this.fps.avg },
                    pools: this.getInstancePoolStats(),
                    gestureCount: this.gestureCount,
                    recentTimings: this.gestureTimings.slice(-10),
                    snapshots: this.snapshots
                };
                navigator.clipboard.writeText(JSON.stringify(data, null, 2)).then(() => {
                    console.log('[GPU] Data copied to clipboard');
                    const display = document.getElementById('gpu-monitor-display');
                    if (display) {
                        display.style.borderColor = 'var(--accent)';
                        display.style.boxShadow = '0 0 12px rgba(var(--accent-rgb),0.3)';
                        setTimeout(() => { display.style.borderColor = ''; display.style.boxShadow = ''; }, 400);
                    }
                });
            },

            report() {
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('GPU MEMORY MONITOR REPORT');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log(`Peaks: geo=${this.peaks.geometries} tex=${this.peaks.textures} prog=${this.peaks.programs}`);
                console.log(`FPS: current=${this.fps.current} min=${this.fps.min} max=${this.fps.max} avg=${this.fps.avg}`);
                console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                this.snapshots.forEach((s, i) => {
                    console.log(`[${i}] ${s.label} (#${s.gestureNum}): geo=${s.geometries} tex=${s.textures} prog=${s.programs} fps=${s.fps || '?'}`);
                });
                if (this.snapshots.length >= 2) {
                    const first = this.snapshots[0];
                    const last = this.snapshots[this.snapshots.length - 1];
                    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                    console.log(`DELTA: Œîgeo=${last.geometries - first.geometries} Œîtex=${last.textures - first.textures} Œîprog=${last.programs - first.programs}`);
                }
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            },

            clear() {
                this.snapshots = [];
                this.gestureCount = 0;
                this.gestureTimings = [];
                this.resetPeaks();
                localStorage.removeItem('gpu_snapshots');
                localStorage.removeItem('gpu_peaks');
                localStorage.removeItem('gpu_gesture_count');
                console.log('[GPU] All data cleared');
            },

            // Start FPS tracking loop
            startTracking() {
                const tick = () => {
                    this.updateFPS();
                    if (this.visible && !this.pendingTimeout) {
                        const stats = this.getStats();
                        if (stats) this.updateDisplay(stats);
                    }
                    requestAnimationFrame(tick);
                };
                requestAnimationFrame(tick);
            }
        };

        // Expose globally
        window.gpuMonitor = gpuMonitor;

        // Keyboard toggle (G key)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'g' || e.key === 'G') {
                if (!e.target.matches('input, textarea')) {
                    gpuMonitor.toggle();
                }
            }
        });

        // Hook into gesture execution with timing
        // Uses gestureController._state.currentModularGesture for accurate duration
        const originalExpress = mascot.express.bind(mascot);
        mascot.express = function(gestureName, ...args) {
            gpuMonitor.gestureCount++;
            localStorage.setItem('gpu_gesture_count', gpuMonitor.gestureCount.toString());
            const startTime = performance.now();
            gpuMonitor.snapshot(`before: ${gestureName}`);

            const result = originalExpress(gestureName, ...args);

            // Get actual gesture duration from gestureController state
            const gestureState = mascot.gestureController?._state?.currentModularGesture;
            const duration = gestureState?.duration || 1000; // fallback 1s

            // Mid-gesture snapshot (at ~40% through - when instances are fully spawned)
            // Force-save by temporarily clearing throttle
            setTimeout(() => {
                gpuMonitor.lastSnapshotTime = 0; // bypass throttle for critical snapshot
                gpuMonitor.snapshot(`PEAK: ${gestureName}`);
            }, Math.min(duration * 0.4, 400)); // 40% or 400ms max

            // Schedule completion snapshot based on actual gesture duration
            setTimeout(() => {
                const elapsed = Math.round(performance.now() - startTime);
                gpuMonitor.gestureTimings.push({ name: gestureName, duration: elapsed });
                if (gpuMonitor.gestureTimings.length > 20) gpuMonitor.gestureTimings.shift();
                gpuMonitor.lastSnapshotTime = 0; // bypass throttle
                gpuMonitor.snapshot(`done: ${gestureName} (${elapsed}ms)`);
            }, duration + 100); // +100ms buffer for cleanup

            return result;
        };

        console.log('[GPU Monitor] Using gesture duration from gestureController state');

        // Start FPS tracking
        gpuMonitor.startTracking();

        console.log('[GPU Monitor] Enhanced. Press G to toggle, click to expand.');
        console.log('[GPU Monitor] Console: gpuMonitor.report() | gpuMonitor.copyToClipboard()');

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        setTimeout(() => {
            populateGesturesProgressively();
            // Initial snapshot taken in onComplete callback
            gpuMonitor.snapshot('initial');
        }, 100);
    </script>
</body>
</html>
