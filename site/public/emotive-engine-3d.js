import*as e from"three";import{Mesh as t,OrthographicCamera as i,BufferGeometry as a,Float32BufferAttribute as n,ShaderMaterial as s,UniformsUtils as r,Vector2 as o,WebGLRenderTarget as l,HalfFloatType as c,NoBlending as h,Clock as u,Color as d,RGBAFormat as m,LinearFilter as p,Vector3 as g,OneFactor as f,ZeroFactor as y,CustomBlending as v,MeshBasicMaterial as b,Controls as w,MOUSE as M,TOUCH as S,Quaternion as x,Spherical as C,Ray as P,Plane as k,MathUtils as D,Loader as A,FileLoader as _,SRGBColorSpace as T,Group as I,LineBasicMaterial as O,Material as R,PointsMaterial as E,MeshPhongMaterial as B,LineSegments as F,Points as z,TrianglesDrawMode as L,TriangleFanDrawMode as G,TriangleStripDrawMode as V,LoaderUtils as N,MeshPhysicalMaterial as j,LinearSRGBColorSpace as q,SpotLight as U,PointLight as W,DirectionalLight as H,Matrix4 as $,InstancedMesh as Y,InstancedBufferAttribute as X,Object3D as Q,TextureLoader as K,ImageBitmapLoader as Z,BufferAttribute as J,InterleavedBuffer as ee,InterleavedBufferAttribute as te,LinearMipmapLinearFilter as ie,NearestMipmapLinearFilter as ae,LinearMipmapNearestFilter as ne,NearestMipmapNearestFilter as se,NearestFilter as re,RepeatWrapping as oe,MirroredRepeatWrapping as le,ClampToEdgeWrapping as ce,MeshStandardMaterial as he,DoubleSide as ue,PropertyBinding as de,SkinnedMesh as me,Line as pe,LineLoop as ge,PerspectiveCamera as fe,Skeleton as ye,AnimationClip as ve,Bone as be,InterpolateDiscrete as we,InterpolateLinear as Me,Texture as Se,VectorKeyframeTrack as xe,NumberKeyframeTrack as Ce,QuaternionKeyframeTrack as Pe,ColorManagement as ke,FrontSide as De,Interpolant as Ae,Box3 as _e,Sphere as Te,DataTextureLoader as Ie,FloatType as Oe,DataUtils as Re}from"three";const Ee={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class Be{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const Fe=new i(-1,1,1,-1,0,1),ze=new class extends a{constructor(){super(),this.setAttribute("position",new n([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new n([0,2,0,0,2,0],2))}};class Le{constructor(e){this._mesh=new t(ze,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,Fe)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class Ge extends Be{constructor(e,t="tDiffuse"){super(),this.textureID=t,this.uniforms=null,this.material=null,e instanceof s?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=r.clone(e.uniforms),this.material=new s({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this._fsQuad=new Le(this.material)}render(e,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this._fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this._fsQuad.render(e))}dispose(){this.material.dispose(),this._fsQuad.dispose()}}class Ve extends Be{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,i){const a=e.getContext(),n=e.state;let s,r;n.buffers.color.setMask(!1),n.buffers.depth.setMask(!1),n.buffers.color.setLocked(!0),n.buffers.depth.setLocked(!0),this.inverse?(s=0,r=1):(s=1,r=0),n.buffers.stencil.setTest(!0),n.buffers.stencil.setOp(a.REPLACE,a.REPLACE,a.REPLACE),n.buffers.stencil.setFunc(a.ALWAYS,s,4294967295),n.buffers.stencil.setClear(r),n.buffers.stencil.setLocked(!0),e.setRenderTarget(i),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),n.buffers.color.setLocked(!1),n.buffers.depth.setLocked(!1),n.buffers.color.setMask(!0),n.buffers.depth.setMask(!0),n.buffers.stencil.setLocked(!1),n.buffers.stencil.setFunc(a.EQUAL,1,4294967295),n.buffers.stencil.setOp(a.KEEP,a.KEEP,a.KEEP),n.buffers.stencil.setLocked(!0)}}class Ne extends Be{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class je{constructor(e,t){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===t){const i=e.getSize(new o);this._width=i.width,this._height=i.height,(t=new l(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:c})).texture.name="EffectComposer.rt1"}else this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new Ge(Ee),this.copyPass.material.blending=h,this.clock=new u}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let i=!1;for(let t=0,a=this.passes.length;t<a;t++){const a=this.passes[t];if(!1!==a.enabled){if(a.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),a.render(this.renderer,this.writeBuffer,this.readBuffer,e,i),a.needsSwap){if(i){const t=this.renderer.getContext(),i=this.renderer.state.buffers.stencil;i.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),i.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==Ve&&(a instanceof Ve?i=!0:a instanceof Ne&&(i=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new o);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const i=this._width*this._pixelRatio,a=this._height*this._pixelRatio;this.renderTarget1.setSize(i,a),this.renderTarget2.setSize(i,a);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(i,a)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class qe extends Be{constructor(e,t,i=null,a=null,n=null){super(),this.scene=e,this.camera=t,this.overrideMaterial=i,this.clearColor=a,this.clearAlpha=n,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new d}render(e,t,i){const a=e.autoClear;let n,s;e.autoClear=!1,null!==this.overrideMaterial&&(s=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor,e.getClearAlpha())),null!==this.clearAlpha&&(n=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:i),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(n),null!==this.overrideMaterial&&(this.scene.overrideMaterial=s),e.autoClear=a}}class Ue extends Be{constructor(e,t,i,a){super(),this.strength=void 0!==t?t:1,this.radius=i,this.threshold=a,this.resolution=void 0!==e?new o(e.x,e.y):new o(256,256);const n={minFilter:p,magFilter:p,format:m,type:c};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let r=Math.round(.75*this.resolution.x),u=Math.round(.75*this.resolution.y);this.renderTargetBright=new l(r,u,n),this.renderTargetBright.texture.name="UnrealBloomPassAlpha.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this.nMips;e++){const t=new l(r,u,n);t.texture.name=`UnrealBloomPassAlpha.h${e}`,t.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(t);const i=new l(r,u,n);i.texture.name=`UnrealBloomPassAlpha.v${e}`,i.texture.generateMipmaps=!1,this.renderTargetsVertical.push(i),r=Math.round(r/2),u=Math.round(u/2)}this.highPassUniforms={tDiffuse:{value:null},luminosityThreshold:{value:a},smoothWidth:{value:.1}},this.materialHighPassFilter=new s({uniforms:this.highPassUniforms,vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                uniform float luminosityThreshold;\n                uniform float smoothWidth;\n                varying vec2 vUv;\n\n                void main() {\n                    vec4 texel = texture2D(tDiffuse, vUv);\n                    vec3 luma = vec3(0.299, 0.587, 0.114);\n                    float v = dot(texel.xyz, luma);\n                    float alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);\n\n                    // CRITICAL: Preserve original alpha, only filter by luminosity\n                    gl_FragColor = vec4(texel.rgb * alpha, texel.a);\n                }"}),this.separableBlurMaterials=[];const w=[3,5,7,9,11];r=Math.round(.75*this.resolution.x),u=Math.round(.75*this.resolution.y);for(let e=0;e<this.nMips;e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(w[e])),this.separableBlurMaterials[e].uniforms.texSize.value=new o(r,u),r=Math.round(r/2),u=Math.round(u/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new g(1,1,1),new g(1,1,1),new g(1,1,1),new g(1,1,1),new g(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,this.materialCopy=new s({uniforms:{tDiffuse:{value:null},texelSize:{value:new o(1/256,1/256)}},vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                uniform vec2 texelSize;\n                varying vec2 vUv;\n                void main() {\n                    // B-spline bicubic upsampling — 4 bilinear taps, all-positive weights.\n                    // Smoothly upscales 0.75-resolution bloom to canvas without pixel grid\n                    // artifacts or ringing. Slightly smoother than Catmull-Rom (no negative\n                    // lobes) which is ideal for bloom halos.\n                    vec2 coord = vUv / texelSize - 0.5;\n                    vec2 f = fract(coord);\n                    coord = floor(coord);\n\n                    vec2 f2 = f * f;\n                    vec2 f3 = f2 * f;\n                    vec2 omf = 1.0 - f;\n\n                    // B-spline weights (unnormalized — divided out via s0/s1 pairs)\n                    vec2 w0 = omf * omf * omf;\n                    vec2 w1 = 3.0 * f3 - 6.0 * f2 + 4.0;\n                    vec2 w2 = -3.0 * f3 + 3.0 * f2 + 3.0 * f + 1.0;\n                    vec2 w3 = f3;\n\n                    // Pair sums normalized to [0,1] range (weights sum to 6 per axis)\n                    vec2 s0 = (w0 + w1) / 6.0;\n                    vec2 s1 = (w2 + w3) / 6.0;\n\n                    // Bilinear tap offsets within each pair\n                    vec2 f0 = w1 / (w0 + w1);\n                    vec2 f1 = w3 / max(w2 + w3, 1e-4);\n\n                    // 4 sample positions\n                    vec2 t0 = (coord - 0.5 + f0) * texelSize;\n                    vec2 t1 = (coord + 1.5 + f1) * texelSize;\n\n                    vec4 color =\n                        (texture2D(tDiffuse, vec2(t0.x, t0.y)) * s0.x +\n                         texture2D(tDiffuse, vec2(t1.x, t0.y)) * s1.x) * s0.y +\n                        (texture2D(tDiffuse, vec2(t0.x, t1.y)) * s0.x +\n                         texture2D(tDiffuse, vec2(t1.x, t1.y)) * s1.x) * s1.y;\n\n                    // Interleaved Gradient Noise dithering (Jimenez 2014)\n                    // Breaks 8-bit display banding into imperceptible noise\n                    float ign = fract(52.9829189 * fract(0.06711056 * gl_FragCoord.x + 0.00583715 * gl_FragCoord.y));\n                    gl_FragColor = color + (ign - 0.5) / 255.0;\n                }",blending:v,blendSrc:f,blendDst:f,blendSrcAlpha:y,blendDstAlpha:f,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new d,this.oldClearAlpha=1,this.clearColor=new d(0,0,0),this.basic=new b({transparent:!1,depthTest:!1,depthWrite:!1,blending:h}),this.fsQuad=new Le(null)}dispose(){if(this.renderTargetsHorizontal)for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e]?.dispose();if(this.renderTargetsVertical)for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e]?.dispose();if(this.renderTargetBright?.dispose(),this.separableBlurMaterials)for(let e=0;e<this.separableBlurMaterials.length;e++)this.separableBlurMaterials[e]?.dispose();this.compositeMaterial?.dispose(),this.blendMaterial?.dispose(),this.basic?.dispose(),this.fsQuad?.dispose()}clearBloomBuffers(e){const t=e.getRenderTarget(),i=e.getClearColor(this._oldClearColor),a=e.getClearAlpha();e.setClearColor(0,0),e.setRenderTarget(this.renderTargetBright),e.clear();for(let t=0;t<this.renderTargetsHorizontal.length;t++)e.setRenderTarget(this.renderTargetsHorizontal[t]),e.clear();for(let t=0;t<this.renderTargetsVertical.length;t++)e.setRenderTarget(this.renderTargetsVertical[t]),e.clear();e.setRenderTarget(t),e.setClearColor(i,a)}setSize(e,t){this.resolution.set(e,t);let i=Math.round(.75*e),a=Math.round(.75*t);this.renderTargetBright.setSize(i,a);for(let e=0;e<this.nMips;e++)this.renderTargetsHorizontal[e].setSize(i,a),this.renderTargetsVertical[e].setSize(i,a),this.separableBlurMaterials[e].uniforms.texSize.value=new o(i,a),i=Math.round(i/2),a=Math.round(a/2)}render(e,t,i,a,n){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const s=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),n&&e.state.buffers.stencil.setTest(!1),this.renderToScreen&&!this.skipBaseCopy&&(this.fsQuad.material=this.basic,this.basic.map=i.texture,e.setRenderTarget(null),this.fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=i.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this.fsQuad.render(e);let r=this.renderTargetBright;for(let t=0;t<this.nMips;t++)this.fsQuad.material=this.separableBlurMaterials[t],this.separableBlurMaterials[t].uniforms.colorTexture.value=r.texture,this.separableBlurMaterials[t].uniforms.direction.value=Ue.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[t]),e.clear(),this.fsQuad.render(e),this.separableBlurMaterials[t].uniforms.colorTexture.value=this.renderTargetsHorizontal[t].texture,this.separableBlurMaterials[t].uniforms.direction.value=Ue.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[t]),e.clear(),this.fsQuad.render(e),r=this.renderTargetsVertical[t];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this.fsQuad.render(e);const o=this.renderTargetsHorizontal[0];this.fsQuad.material=this.materialCopy,this.materialCopy.uniforms.tDiffuse.value=o.texture,this.materialCopy.uniforms.texelSize.value.set(1/o.width,1/o.height),n&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(i),this.fsQuad.render(e)),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=s}getSeperableBlurMaterial(e){return new s({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new o(.5,.5)},direction:{value:new o(.5,.5)},kernelRadius:{value:1}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",fragmentShader:"\n                #include <common>\n                varying vec2 vUv;\n                uniform sampler2D colorTexture;\n                uniform vec2 texSize;\n                uniform vec2 direction;\n                uniform float kernelRadius;\n\n                float gaussianPdf(in float x, in float sigma) {\n                    return 0.39894 * exp( -0.5 * x * x / ( sigma * sigma ) ) / sigma;\n                }\n\n                void main() {\n                    vec2 invSize = 1.0 / texSize;\n                    float sigma = kernelRadius / 2.0;\n                    float weightSum = gaussianPdf(0.0, sigma);\n\n                    // CRITICAL: Accumulate RGB and alpha SEPARATELY\n                    // Include center pixel for BOTH RGB and alpha\n                    vec4 centerPixel = texture2D(colorTexture, vUv);\n                    vec3 diffuseSum = centerPixel.rgb * weightSum;\n                    float alphaSum = centerPixel.a * weightSum;\n\n                    vec2 delta = direction * invSize * kernelRadius / float(MAX_RADIUS);\n\n                    for( int i = 1; i < MAX_RADIUS; i ++ ) {\n                        float x = kernelRadius * float(i) / float(MAX_RADIUS);\n                        float w = gaussianPdf(x, sigma);\n\n                        vec2 uvOffset = delta * float(i);\n                        vec4 sample1 = texture2D(colorTexture, vUv + uvOffset);\n                        vec4 sample2 = texture2D(colorTexture, vUv - uvOffset);\n\n                        // Accumulate RGB and alpha separately\n                        diffuseSum += (sample1.rgb + sample2.rgb) * w;\n                        alphaSum += (sample1.a + sample2.a) * w;\n                        weightSum += 2.0 * w;\n                    }\n\n                    // Output with separately normalized alpha\n                    gl_FragColor = vec4(diffuseSum / weightSum, alphaSum / weightSum);\n                }"})}getCompositeMaterial(e){return new s({uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",fragmentShader:"\n                varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[5];\n                uniform vec3 bloomTintColors[5];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    // ALPHA PRESERVATION: Sample all textures and preserve their alpha\n                    vec4 sample1 = texture2D(blurTexture1, vUv);\n                    vec4 sample2 = texture2D(blurTexture2, vUv);\n                    vec4 sample3 = texture2D(blurTexture3, vUv);\n                    vec4 sample4 = texture2D(blurTexture4, vUv);\n                    vec4 sample5 = texture2D(blurTexture5, vUv);\n\n                    // Apply tint to RGB only, preserve alpha from samples\n                    vec4 color = bloomStrength * (\n                        lerpBloomFactor(bloomFactors[0]) * vec4(sample1.rgb * bloomTintColors[0], sample1.a) +\n                        lerpBloomFactor(bloomFactors[1]) * vec4(sample2.rgb * bloomTintColors[1], sample2.a) +\n                        lerpBloomFactor(bloomFactors[2]) * vec4(sample3.rgb * bloomTintColors[2], sample3.a) +\n                        lerpBloomFactor(bloomFactors[3]) * vec4(sample4.rgb * bloomTintColors[3], sample4.a) +\n                        lerpBloomFactor(bloomFactors[4]) * vec4(sample5.rgb * bloomTintColors[4], sample5.a)\n                    );\n\n                    gl_FragColor = color;\n                }"})}}Ue.BlurDirectionX=new o(1,0),Ue.BlurDirectionY=new o(0,1);const We={name:"DistortionShader",uniforms:{tDiffuse:{value:null},tDistortion:{value:null},uGlobalStrength:{value:1}},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n    ",fragmentShader:"\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDistortion;\n        uniform float uGlobalStrength;\n        varying vec2 vUv;\n\n        void main() {\n            // Sample distortion map raw (all 4 channels)\n            vec4 distSample = texture2D(tDistortion, vUv);\n\n            // R/G = signed UV offset (pre-multiplied by strength/falloff)\n            vec2 offset = distSample.rg * uGlobalStrength;\n\n            // Hard clamp: safety rail against runaway accumulation\n            offset = clamp(offset, vec2(-0.04), vec2(0.04));\n\n            // Apply UV warp to scene\n            vec4 color = texture2D(tDiffuse, vUv + offset);\n\n            gl_FragColor = color;\n        }\n    "};class He{constructor(t,i){this.renderer=t,this.camera=i,this.distortionScene=new e.Scene,this.elementMeshes=new Map,this.configs=new Map,this._tmpMatrix=new e.Matrix4,this._tmpPos=new e.Vector3,this._tmpQuat=new e.Quaternion,this._tmpScl=new e.Vector3,this._savedClearColor=new e.Color,this._savedClearAlpha=1}hasElement(e){return this.elementMeshes.has(e)}registerElement(t,i){if(this.elementMeshes.has(t))return;i.material.uniforms.uStrength&&(i.material.uniforms.uStrength.value=i.strength);const a=new e.InstancedMesh(i.geometry,i.material,64);a.count=0,a.visible=!1,a.frustumCulled=!1,this.distortionScene.add(a),this.elementMeshes.set(t,a),this.configs.set(t,i)}syncInstances(e,t,i){const a=this.elementMeshes.get(e);if(!a)return;const n=Math.min(i,64);if(0===n)return void(0!==a.count&&(a.count=0,a.visible=!1));const s=this.configs.get(e),r=this._tmpMatrix,o=this._tmpPos,l=this._tmpQuat,c=this._tmpScl;let h=1/0,u=1/0,d=1/0,m=-1/0,p=-1/0,g=-1/0;for(let e=0;e<n;e++){t.getMatrixAt(e,r);const i=r.elements[12],a=r.elements[13],n=r.elements[14];i<h&&(h=i),i>m&&(m=i),a<u&&(u=a),a>p&&(p=a),n<d&&(d=n),n>g&&(g=n)}o.set(.5*(h+m),.5*(u+p),.5*(d+g));const{centerOffset:f}=s.transform;f&&(o.x+=f.x,o.y+=f.y,o.z+=f.z);const{padding:y}=s.transform,v=m-h+2*y.x,b=p-u+2*y.y;c.set(Math.max(v,y.x),Math.max(b,y.y),1),s.billboard?l.copy(this.camera.quaternion):l.identity(),r.compose(o,l,c),a.setMatrixAt(0,r),a.count=1,a.visible=!0,a.instanceMatrix.needsUpdate=!0}hasActiveSources(){for(const[,e]of this.elementMeshes)if(e.count>0)return!0;return!1}render(e){this.hasActiveSources()&&(this.renderer.getClearColor(this._savedClearColor),this._savedClearAlpha=this.renderer.getClearAlpha(),this.renderer.setRenderTarget(e),this.renderer.setClearColor(0,0),this.renderer.clear(),this.renderer.render(this.distortionScene,this.camera),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this._savedClearColor,this._savedClearAlpha))}update(e){for(const[,t]of this.elementMeshes)t.material.uniforms.uTime&&(t.material.uniforms.uTime.value+=e)}setElectricFlash(e){const t=this.elementMeshes.get("electricity");t?.material?.uniforms?.uFlashIntensity&&(t.material.uniforms.uFlashIntensity.value=e)}dispose(){for(const[,e]of this.elementMeshes)e.geometry.dispose(),e.material.dispose(),this.distortionScene.remove(e);this.elementMeshes.clear(),this.configs.clear()}}const $e={smoke:function(t){return new e.ShaderMaterial({name:"SmokeParticle",uniforms:{uTime:{value:0},uOpacity:{value:t.opacity??.4},uColorWarm:{value:new e.Color(...t.colorWarm??[.45,.38,.3])},uColorCool:{value:new e.Color(...t.colorCool??[.3,.3,.3])},uBuoyancy:{value:t.buoyancy??.3},uDrag:{value:t.drag??1.5},uTurbulenceStrength:{value:t.turbulence??.4},uEndSizeMultiplier:{value:t.endSizeMultiplier??3.5},uRotationSpeedMax:{value:t.rotationSpeedMax??1.5}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\n// Size over life: fast growth then plateau\nfloat sizeOverLife(float life) {\n    return 0.3 + 0.7 * (smoothstep(0.0, 0.3, life) + 0.3 * smoothstep(0.3, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    // === POSITION: deterministic from spawn constants ===\n\n    // Drag: v(t) = v0 * e^(-drag*t)\n    // Integrated: p(t) = p0 + v0 * (1 - e^(-drag*t)) / drag\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    // Buoyancy: constant upward accel, drag-limited\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n\n    // Turbulence: deterministic sinusoidal displacement\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp, 0.0) + turbulence;\n\n    // === SIZE: grows over life ===\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    // === ROTATION: initial angle + speed derived from seed ===\n    float rotSpeed = (fract(aSeed * 7.31) - 0.5) * 2.0 * uRotationSpeedMax;\n    float rot = aRotation + rotSpeed * age;\n    float c = cos(rot), s = sin(rot);\n    vec2 rotated = mat2(c, s, -s, c) * position.xy;\n\n    // === BILLBOARD: expand in view space (always faces camera) ===\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform vec3 uColorWarm;\nuniform vec3 uColorCool;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\n// Simple hash for noise perturbation\nfloat hash(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h) * 43758.5453);\n}\n\n// Value noise (one octave)\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid main() {\n    // Center UV to [-0.5, 0.5]\n    vec2 centered = vUv - 0.5;\n    float dist = length(centered);\n\n    // Noise-perturbed distance for irregular silhouette\n    float angle = atan(centered.y, centered.x);\n    float seed2 = vSeed * 17.3;\n    float n = noise(vec2(angle * 2.0 + seed2, dist * 4.0 + seed2 * 0.7)) * 0.15\n            + noise(vec2(angle * 4.0 - seed2 * 1.3, dist * 8.0 + seed2)) * 0.08;\n    float perturbedDist = dist + n - 0.07;\n\n    // Soft radial falloff — smoke puff shape\n    float radial = 1.0 - smoothstep(0.15, 0.50, perturbedDist);\n\n    // Life-based fade: quick in (10%), long hold, gradual out (last 45%)\n    float fadeIn = smoothstep(0.0, 0.10, vLife);\n    float fadeOut = 1.0 - smoothstep(0.55, 1.0, vLife);\n    float lifeFade = fadeIn * fadeOut;\n\n    // Combined alpha\n    float alpha = radial * lifeFade * uOpacity;\n\n    // Discard fully transparent fragments\n    if (alpha < 0.003) discard;\n\n    // Color: warm near birth → cool as it dissipates\n    float colorShift = smoothstep(0.0, 0.6, vLife);\n    vec3 color = mix(uColorWarm, uColorCool, colorShift);\n\n    // Premultiplied alpha output (blending: ONE + ONE_MINUS_SRC_ALPHA)\n    gl_FragColor = vec4(color * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:e.DoubleSide,blending:e.CustomBlending,blendSrc:e.OneFactor,blendDst:e.OneMinusSrcAlphaFactor,blendSrcAlpha:e.OneFactor,blendDstAlpha:e.OneMinusSrcAlphaFactor})},mist:function(t){return new e.ShaderMaterial({name:"MistParticle",uniforms:{uTime:{value:0},uOpacity:{value:t.opacity??.1},uColor:{value:new e.Color(...t.color??[.75,.85,.95])},uBuoyancy:{value:t.buoyancy??-.02},uDrag:{value:t.drag??.8},uTurbulenceStrength:{value:t.turbulence??.08},uEndSizeMultiplier:{value:t.endSizeMultiplier??1.5},uRotationSpeedMax:{value:t.rotationSpeedMax??.4}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat sizeOverLife(float life) {\n    return 0.3 + 0.7 * (smoothstep(0.0, 0.3, life) + 0.3 * smoothstep(0.3, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp, 0.0) + turbulence;\n\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    float rotSpeed = (fract(aSeed * 7.31) - 0.5) * 2.0 * uRotationSpeedMax;\n    float rot = aRotation + rotSpeed * age;\n    float c = cos(rot), s = sin(rot);\n    vec2 rotated = mat2(c, s, -s, c) * position.xy;\n\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform vec3 uColor;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat pHash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }\nfloat pNoise(vec2 p) {\n    vec2 i = floor(p); vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(mix(pHash(i), pHash(i + vec2(1.0, 0.0)), f.x),\n               mix(pHash(i + vec2(0.0, 1.0)), pHash(i + vec2(1.0, 1.0)), f.x), f.y);\n}\n\nvoid main() {\n    vec2 center = vUv - 0.5;\n\n    // Per-particle wisp direction — each particle stretches differently\n    float wispAngle = vSeed * 6.283;\n    vec2 wispDir = vec2(cos(wispAngle), sin(wispAngle));\n    vec2 wispPerp = vec2(-wispDir.y, wispDir.x);\n\n    // Anisotropic distance: stretch along wisp direction for tendril shape\n    float along = dot(center, wispDir);\n    float across = dot(center, wispPerp);\n    float anisoDist = length(vec2(along * 0.7, across * 1.3));\n\n    // 3-octave FBM for organic cloud structure\n    float seedOff = vSeed * 73.0;\n    float fbm = pNoise(center * 3.0 + seedOff) * 0.50\n              + pNoise(center * 7.0 + seedOff * 1.7 + vec2(3.7, 1.2)) * 0.25\n              + pNoise(center * 14.0 + seedOff * 2.3 + vec2(7.1, 5.3)) * 0.125;\n\n    // Shape: anisotropic falloff with FBM erosion at edges\n    float shape = 1.0 - smoothstep(0.05, 0.42, anisoDist + (fbm - 0.4) * 0.20);\n\n    // Internal density variation — wisps and gaps through the body\n    float density = smoothstep(0.25, 0.55, fbm);\n    shape *= mix(0.3, 1.0, density);\n\n    // Fade over lifetime\n    float fadeIn = smoothstep(0.0, 0.15, vLife);\n    float fadeOut = 1.0 - smoothstep(0.60, 1.0, vLife);\n    float lifeAlpha = fadeIn * fadeOut;\n\n    float alpha = shape * lifeAlpha * uOpacity;\n    if (alpha < 0.003) discard;\n\n    // Premultiplied alpha output — constant pale color\n    gl_FragColor = vec4(uColor * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:e.DoubleSide,blending:e.CustomBlending,blendSrc:e.OneFactor,blendDst:e.OneMinusSrcAlphaFactor,blendSrcAlpha:e.OneFactor,blendDstAlpha:e.OneMinusSrcAlphaFactor})},spray:function(t){return new e.ShaderMaterial({name:"SprayParticle",uniforms:{uTime:{value:0},uOpacity:{value:t.opacity??.1},uColor:{value:new e.Color(...t.color??[.4,.7,1])},uBuoyancy:{value:t.buoyancy??-.01},uDrag:{value:t.drag??1.2},uTurbulenceStrength:{value:t.turbulence??.12},uEndSizeMultiplier:{value:t.endSizeMultiplier??1.3},uRotationSpeedMax:{value:t.rotationSpeedMax??.6}},vertexShader:"\nattribute vec3 aSpawnPos;\nattribute vec3 aSpawnVelocity;\nattribute float aSpawnTime;\nattribute float aLifetime;\nattribute float aSize;\nattribute float aRotation;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uBuoyancy;\nuniform float uDrag;\nuniform float uTurbulenceStrength;\nuniform float uEndSizeMultiplier;\nuniform float uRotationSpeedMax;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat sizeOverLife(float life) {\n    return 0.3 + 0.7 * (smoothstep(0.0, 0.3, life) + 0.3 * smoothstep(0.3, 1.0, life));\n}\n\nvoid main() {\n    float age = uTime - aSpawnTime;\n    float life = clamp(age / aLifetime, 0.0, 1.0);\n\n    vUv = position.xy + 0.5;\n    vLife = life;\n    vSeed = aSeed;\n\n    float dragDecay = 1.0 - exp(-uDrag * age);\n    float invDrag = 1.0 / max(uDrag, 0.001);\n    vec3 driftPos = aSpawnVelocity * dragDecay * invDrag;\n\n    float buoyancyDisp = uBuoyancy * (age - dragDecay * invDrag);\n\n    float turbT = age * 1.3 + aSeed * 100.0;\n    float turbX = sin(turbT) * cos(turbT * 0.7 + 3.0);\n    float turbZ = cos(turbT * 1.1) * sin(turbT * 0.6 + 1.7);\n    vec3 turbulence = vec3(turbX, 0.0, turbZ) * uTurbulenceStrength * age * 0.5;\n\n    vec3 worldPos = aSpawnPos + driftPos + vec3(0.0, buoyancyDisp, 0.0) + turbulence;\n\n    float size = aSize * mix(1.0, uEndSizeMultiplier, sizeOverLife(life));\n\n    float rotSpeed = (fract(aSeed * 7.31) - 0.5) * 2.0 * uRotationSpeedMax;\n    float rot = aRotation + rotSpeed * age;\n    float c = cos(rot), s = sin(rot);\n    vec2 rotated = mat2(c, s, -s, c) * position.xy;\n\n    vec4 viewPos = viewMatrix * vec4(worldPos, 1.0);\n    viewPos.xy += rotated * size;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:"\nuniform float uOpacity;\nuniform vec3 uColor;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSeed;\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvoid main() {\n    vec2 center = vUv - 0.5;\n    float dist = length(center);\n\n    // Soft radial fade — billboards blend seamlessly at overlapping edges\n    float radialFade = 1.0 - smoothstep(0.15, 0.48, dist);\n    if (radialFade < 0.01) discard;\n\n    float seed = floor(vSeed * 1000.0);\n    float totalDroplet = 0.0;\n\n    // Scale 1: coarse droplets — ~6 cells across, ~20% contain a bright speck\n    // At typical billboard size (~30px), each dot is ~1px — barely visible\n    vec2 p1 = vUv * 6.0;\n    vec2 cell1 = floor(p1);\n    vec2 local1 = fract(p1);\n    float presence1 = step(0.80, hash21(cell1 + seed));\n    vec2 dropPos1 = vec2(hash21(cell1 * 1.7 + seed), hash21(cell1 * 2.3 + seed + 5.0));\n    float d1 = length(local1 - dropPos1);\n    float bright1 = 0.6 + 0.4 * hash21(cell1 * 5.3 + seed);\n    totalDroplet += (1.0 - smoothstep(0.0, 0.22, d1)) * presence1 * bright1;\n\n    // Scale 2: fine shimmer — ~12 cells across, ~15% occupied, dimmer\n    vec2 p2 = vUv * 12.0 + 7.3;\n    vec2 cell2 = floor(p2);\n    vec2 local2 = fract(p2);\n    float presence2 = step(0.85, hash21(cell2 + seed * 1.3));\n    vec2 dropPos2 = vec2(hash21(cell2 * 1.9 + seed), hash21(cell2 * 3.1 + seed + 3.0));\n    float d2 = length(local2 - dropPos2);\n    float bright2 = 0.5 + 0.5 * hash21(cell2 * 7.1 + seed);\n    totalDroplet += (1.0 - smoothstep(0.0, 0.15, d2)) * presence2 * bright2 * 0.5;\n\n    totalDroplet = min(totalDroplet, 1.2);\n\n    // Life fade: fast in, fast out\n    float fadeIn = smoothstep(0.0, 0.08, vLife);\n    float fadeOut = 1.0 - smoothstep(0.4, 1.0, vLife);\n    float lifeFade = fadeIn * fadeOut;\n\n    float alpha = totalDroplet * radialFade * lifeFade * uOpacity;\n    if (alpha < 0.003) discard;\n\n    // Premultiplied alpha output\n    gl_FragColor = vec4(uColor * alpha, alpha);\n}\n",transparent:!0,depthWrite:!1,depthTest:!0,side:e.DoubleSide,blending:e.CustomBlending,blendSrc:e.OneFactor,blendDst:e.OneMinusSrcAlphaFactor,blendSrcAlpha:e.OneFactor,blendDstAlpha:e.OneMinusSrcAlphaFactor})}},Ye={smoke:{materialType:"smoke",maxParticles:64,spawnRate:18,lifetimeMin:1.5,lifetimeMax:2.5,sizeMin:.1,sizeMax:.18,spawnOffsetY:0,initialSpeedMin:.1,initialSpeedMax:.25,spreadXZ:.15,directionY:1,buoyancy:.04,drag:1.8,turbulence:.2,rotationSpeedMax:1,endSizeMultiplier:1.8,opacity:.2,colorWarm:[.25,.22,.18],colorCool:[.18,.18,.2]},mist:{materialType:"mist",maxParticles:48,spawnRate:8,lifetimeMin:1.5,lifetimeMax:3,sizeMin:.25,sizeMax:.5,spawnOffsetY:-.1,initialSpeedMin:.02,initialSpeedMax:.06,spreadXZ:.2,directionY:-.05,buoyancy:-.005,drag:.8,turbulence:.08,rotationSpeedMax:.4,endSizeMultiplier:1.5,opacity:.12,color:[.75,.82,.9]},steam:{materialType:"smoke",maxParticles:32,spawnRate:15,lifetimeMin:.8,lifetimeMax:1.5,sizeMin:.08,sizeMax:.18,spawnOffsetY:.05,initialSpeedMin:1.5,initialSpeedMax:2.5,spreadXZ:.15,directionY:1,buoyancy:.5,drag:2,turbulence:.2,rotationSpeedMax:2,endSizeMultiplier:2.5,opacity:.25,colorWarm:[.8,.8,.8],colorCool:[.6,.6,.6]},fog:{materialType:"mist",maxParticles:16,spawnRate:1,lifetimeMin:6,lifetimeMax:10,sizeMin:.5,sizeMax:1,spawnOffsetY:0,initialSpeedMin:.01,initialSpeedMax:.03,spreadXZ:.3,directionY:0,buoyancy:0,drag:.5,turbulence:.03,rotationSpeedMax:.15,endSizeMultiplier:1.1,opacity:.03,color:[.65,.7,.75]},ozone:{materialType:"smoke",maxParticles:32,spawnRate:10,lifetimeMin:.6,lifetimeMax:1.2,sizeMin:.06,sizeMax:.12,spawnOffsetY:0,initialSpeedMin:.3,initialSpeedMax:.8,spreadXZ:.1,directionY:1,buoyancy:.15,drag:2.5,turbulence:.15,rotationSpeedMax:2,endSizeMultiplier:2,opacity:.15,colorWarm:[.6,.7,.85],colorCool:[.4,.45,.55]},spray:{materialType:"spray",maxParticles:180,spawnRate:60,lifetimeMin:.5,lifetimeMax:1.2,sizeMin:.14,sizeMax:.3,spawnOffsetY:.05,spawnRadius:.35,initialSpeedMin:.8,initialSpeedMax:1.6,spreadXZ:.4,directionY:.5,buoyancy:-.8,drag:1,turbulence:.06,rotationSpeedMax:.3,endSizeMultiplier:.8,opacity:.55,color:[.4,.7,1]}};function Xe(e,t,i){const a=Math.max(0,Math.min(1,(i-e)/(t-e)));return a*a*(3-2*a)}function Qe(e){const t=e.preset||"smoke",i=Ye[t];if(!i)return console.warn(`[AtmosphericPresets] Unknown preset "${t}", falling back to smoke`),Qe({...e,preset:"smoke"});const a=e.intensity??1,n=e.sizeScale??1,s=e.speedScale??1,r={...i};r.spawnRate=i.spawnRate*a,r.opacity=i.opacity*Math.sqrt(Math.min(a,1.5)),r.sizeMin=i.sizeMin*n,r.sizeMax=i.sizeMax*n,r.initialSpeedMin=i.initialSpeedMin*s,r.initialSpeedMax=i.initialSpeedMax*s,e.colorTint&&("smoke"===i.materialType?(r.colorWarm=e.colorTint,r.colorCool=e.colorTint):r.color=e.colorTint);const o=e.anchor||"above";let{spawnOffsetY:l}=i;const c=e.anchorOffset??0;switch(o){case"above":l=Math.abs(i.spawnOffsetY)+c,r.directionY=1;break;case"below":l=-Math.abs(i.spawnOffsetY)+c,r.directionY=i.directionY??-.3;break;case"around":l=c,r.spreadXZ=1.5*i.spreadXZ;break;case"trailing":l=c}return r.spawnOffsetY=l,{material:(0,$e[i.materialType])(r),maxParticles:r.maxParticles,spawnRate:r.spawnRate,lifetimeMin:r.lifetimeMin,lifetimeMax:r.lifetimeMax,sizeMin:r.sizeMin,sizeMax:r.sizeMax,spawnOffsetY:r.spawnOffsetY,initialSpeedMin:r.initialSpeedMin,initialSpeedMax:r.initialSpeedMax,spreadXZ:r.spreadXZ,directionY:r.directionY,spawnRadius:r.spawnRadius||0,targetModels:e.targets||null,anchor:o,progressCurve:e.progressCurve||"sustain",burstCount:e.burstCount||0,baseSpawnRate:r.spawnRate,velocityInheritance:e.velocityInheritance||0,centrifugal:e.centrifugal||null}}const Ke=new e.Vector3;class Ze{constructor(t){this.config=t,this.activeCount=0,this.spawnAccumulator=0,this.sourceCount=0,this.spawning=!0,this._dirty=!1,this._progress=0,this._energy=null,this._sourcePositions=new Float32Array(192),this._prevSourcePositions=new Float32Array(192),this._sourceVelocities=new Float32Array(192),this._prevSourceCount=0,this._hasVelocityData=!1;const i=t.maxParticles;this._spawnPosBuffer=new Float32Array(3*i),this._spawnVelBuffer=new Float32Array(3*i),this._spawnTimeBuffer=new Float32Array(i),this._lifetimeBuffer=new Float32Array(i),this._sizeBuffer=new Float32Array(i),this._rotationBuffer=new Float32Array(i),this._seedBuffer=new Float32Array(i),this.geometry=this._createGeometry(i),this.mesh=new e.Mesh(this.geometry,t.material),this.mesh.frustumCulled=!1,this.mesh.visible=!1,this.mesh.renderOrder=100}_createGeometry(t){const i=new e.InstancedBufferGeometry,a=new Float32Array([-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0]),n=new Uint16Array([0,1,2,0,2,3]);i.setAttribute("position",new e.BufferAttribute(a,3)),i.setIndex(new e.BufferAttribute(n,1));const s=[["aSpawnPos",this._spawnPosBuffer,3],["aSpawnVelocity",this._spawnVelBuffer,3],["aSpawnTime",this._spawnTimeBuffer,1],["aLifetime",this._lifetimeBuffer,1],["aSize",this._sizeBuffer,1],["aRotation",this._rotationBuffer,1],["aSeed",this._seedBuffer,1]];for(const[t,a,n]of s){const s=new e.InstancedBufferAttribute(a,n);s.setUsage(e.DynamicDrawUsage),i.setAttribute(t,s)}return i.instanceCount=0,i}setSourcePositions(e,t){if(this.sourceCount=Math.min(t,64),0!==this.sourceCount)for(let t=0;t<3*this.sourceCount;t++)this._sourcePositions[t]=e[t]}_updateSourceVelocities(e){if(e<.001||0===this._prevSourceCount||0===this.sourceCount){for(let e=0;e<3*this.sourceCount;e++)this._prevSourcePositions[e]=this._sourcePositions[e];return this._prevSourceCount=this.sourceCount,void(this._hasVelocityData=this._prevSourceCount>0)}const t=1/e,i=Math.min(this.sourceCount,this._prevSourceCount);for(let e=0;e<i;e++){const i=3*e;this._sourceVelocities[i]=(this._sourcePositions[i]-this._prevSourcePositions[i])*t,this._sourceVelocities[i+1]=(this._sourcePositions[i+1]-this._prevSourcePositions[i+1])*t,this._sourceVelocities[i+2]=(this._sourcePositions[i+2]-this._prevSourcePositions[i+2])*t}for(let e=3*i;e<3*this.sourceCount;e++)this._sourceVelocities[e]=0;for(let e=0;e<3*this.sourceCount;e++)this._prevSourcePositions[e]=this._sourcePositions[e];this._prevSourceCount=this.sourceCount,this._hasVelocityData=!0}update(e,t){this._updateSourceVelocities(e);for(let e=0;e<this.activeCount;e++)t-this._spawnTimeBuffer[e]>=this._lifetimeBuffer[e]&&(this._kill(e),e--);if(this.spawning&&this.sourceCount>0){const i=function(e,t){switch(e){case"sustain":default:return 1;case"rampUp":return Xe(0,.5,t);case"rampDown":return 1-Xe(.5,1,t);case"pulse":return Math.sin(t*Math.PI);case"burst":return 1-Xe(0,.3,t)}}(this.config.progressCurve,this._progress),a=this.config.baseSpawnRate*i,n=null!==this._energy?this._energy:i;for(this.spawnAccumulator+=a*e;this.spawnAccumulator>=1&&this.activeCount<this.config.maxParticles;)this.spawnAccumulator-=1,this._spawnOne(t,n)}else this.spawning,this.spawnAccumulator=0;if(this._dirty){this.geometry.instanceCount=this.activeCount;const e=this.geometry.attributes,t=this.activeCount;this._markDirty(e.aSpawnPos,t),this._markDirty(e.aSpawnVelocity,t),this._markDirty(e.aSpawnTime,t),this._markDirty(e.aLifetime,t),this._markDirty(e.aSize,t),this._markDirty(e.aRotation,t),this._markDirty(e.aSeed,t),this.mesh.visible=t>0,this._dirty=!1}this.mesh.material.uniforms.uTime.value=t}_markDirty(e,t){e&&(e.needsUpdate=!0)}burstSpawn(e,t){if(0!==this.sourceCount)for(let i=0;i<e&&this.activeCount<this.config.maxParticles;i++)this._spawnOne(t,1)}_spawnOne(e,t=1){const i=this.config,a=this.activeCount,n=.3+.7*t,s=Math.floor(Math.random()*this.sourceCount),r=this._sourcePositions[3*s],o=this._sourcePositions[3*s+1],l=this._sourcePositions[3*s+2],c=(i.initialSpeedMin+Math.random()*(i.initialSpeedMax-i.initialSpeedMin))*n,h=i.spawnRadius||0;let u=0,d=0,m=0,p=0;if(h>0){const e=Math.random()*Math.PI*2,t=Math.sqrt(Math.random())*h,i=Math.cos(e),a=Math.sin(e);u=i*t,d=a*t,m=i*c*.5,p=a*c*.5}this._spawnPosBuffer[3*a]=r+u+.05*(Math.random()-.5),this._spawnPosBuffer[3*a+1]=o+(i.spawnOffsetY??0),this._spawnPosBuffer[3*a+2]=l+d+.05*(Math.random()-.5);let g=m+(Math.random()-.5)*i.spreadXZ,f=c*(i.directionY??1),y=p+(Math.random()-.5)*i.spreadXZ;const v=i.velocityInheritance||0;v>0&&this._hasVelocityData&&(g+=this._sourceVelocities[3*s]*v,f+=this._sourceVelocities[3*s+1]*v,y+=this._sourceVelocities[3*s+2]*v);const b=i.centrifugal;if(b&&(0!==u||0!==d)){const e=Math.sqrt(u*u+d*d);if(e>.01){const t=b.speed*n,i=1-(b.tangentialBias||0);g+=u/e*t*i,y+=d/e*t*i;const a=b.tangentialBias||0;a>0&&(g+=-d/e*t*a,y+=u/e*t*a)}}this._spawnVelBuffer[3*a]=g,this._spawnVelBuffer[3*a+1]=f,this._spawnVelBuffer[3*a+2]=y,this._spawnTimeBuffer[a]=e,this._lifetimeBuffer[a]=i.lifetimeMin+Math.random()*(i.lifetimeMax-i.lifetimeMin);const w=.7+.3*t;this._sizeBuffer[a]=(i.sizeMin+Math.random()*(i.sizeMax-i.sizeMin))*w,this._rotationBuffer[a]=Math.random()*Math.PI*2,this._seedBuffer[a]=Math.random(),this.activeCount++,this._dirty=!0}_kill(e){const t=this.activeCount-1;e!==t&&(this._spawnPosBuffer[3*e]=this._spawnPosBuffer[3*t],this._spawnPosBuffer[3*e+1]=this._spawnPosBuffer[3*t+1],this._spawnPosBuffer[3*e+2]=this._spawnPosBuffer[3*t+2],this._spawnVelBuffer[3*e]=this._spawnVelBuffer[3*t],this._spawnVelBuffer[3*e+1]=this._spawnVelBuffer[3*t+1],this._spawnVelBuffer[3*e+2]=this._spawnVelBuffer[3*t+2],this._spawnTimeBuffer[e]=this._spawnTimeBuffer[t],this._lifetimeBuffer[e]=this._lifetimeBuffer[t],this._sizeBuffer[e]=this._sizeBuffer[t],this._rotationBuffer[e]=this._rotationBuffer[t],this._seedBuffer[e]=this._seedBuffer[t]),this.activeCount--,this._dirty=!0}isDead(){return!this.spawning&&0===this.activeCount}dispose(){this.mesh.visible=!1,this.geometry.instanceCount=0,this.geometry.dispose(),this.mesh.material.dispose(),this.activeCount=0,this.spawning=!1}}class Je{constructor(e,t){this.scene=e,this.camera=t,this._elapsedTime=0,this._activeEmitters=new Map,this._filteredPositions=new Float32Array(192)}startGesture(e,t){if(!t||!Array.isArray(t)||0===t.length)return;this._activeEmitters.has(e)||this._activeEmitters.set(e,[]);const i=this._activeEmitters.get(e);for(const e of t){const t=Qe(e),a=new Ze(t);this.scene.add(a.mesh),i.push(a)}}stopGesture(e){const t=this._activeEmitters.get(e);if(t)for(const e of t)e.spawning=!1}forceStopGesture(e){const t=this._activeEmitters.get(e);if(t){for(const e of t)this.scene.remove(e.mesh),e.dispose();this._activeEmitters.delete(e)}}syncSources(e,t,i){const a=this._activeEmitters.get(e);if(a)for(const n of a){const{targetModels:a}=n.config;let s=0;for(const[,n]of t)if(n.type===e){if(s>=64)break;a&&!a.includes(n.modelName)||(Ke.copy(n.position),i&&i.localToWorld(Ke),this._filteredPositions[3*s]=Ke.x,this._filteredPositions[3*s+1]=Ke.y,this._filteredPositions[3*s+2]=Ke.z,s++)}n.setSourcePositions(this._filteredPositions,s)}}setGestureProgress(e,t){const i=this._activeEmitters.get(e);if(i&&null!==t)for(const e of i)e.config.burstCount>0&&0===e._progress&&t>0&&(e.burstSpawn(e.config.burstCount,this._elapsedTime),e.spawning=!1),e._progress=t}setEnergy(e,t){const i=this._activeEmitters.get(e);if(i)for(const e of i)e._energy=t}update(e){const t=Math.min(e,.1);this._elapsedTime+=t;for(const[e,i]of this._activeEmitters){for(let e=i.length-1;e>=0;e--){const a=i[e];a.update(t,this._elapsedTime),a.isDead()&&(this.scene.remove(a.mesh),a.dispose(),i.splice(e,1))}0===i.length&&this._activeEmitters.delete(e)}}hasActiveSources(){for(const[,e]of this._activeEmitters)for(const t of e)if(t.activeCount>0||t.spawning&&t.sourceCount>0)return!0;return!1}dispose(){for(const[,e]of this._activeEmitters)for(const t of e)this.scene.remove(t.mesh),t.dispose();this._activeEmitters.clear()}}const et={type:"change"},tt={type:"start"},it={type:"end"},at=new P,nt=new k,st=Math.cos(70*D.DEG2RAD),rt=new g,ot=2*Math.PI,lt=-1,ct=1e-6;class ht extends w{constructor(e,t=null){super(e,t),this.state=lt,this.target=new g,this.cursor=new g,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.keyRotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:M.ROTATE,MIDDLE:M.DOLLY,RIGHT:M.PAN},this.touches={ONE:S.ROTATE,TWO:S.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new g,this._lastQuaternion=new x,this._lastTargetPosition=new g,this._quat=(new x).setFromUnitVectors(e.up,new g(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new C,this._sphericalDelta=new C,this._scale=1,this._panOffset=new g,this._rotateStart=new o,this._rotateEnd=new o,this._rotateDelta=new o,this._panStart=new o,this._panEnd=new o,this._panDelta=new o,this._dollyStart=new o,this._dollyEnd=new o,this._dollyDelta=new o,this._dollyDirection=new g,this._mouse=new o,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=dt.bind(this),this._onPointerDown=ut.bind(this),this._onPointerUp=mt.bind(this),this._onContextMenu=wt.bind(this),this._onMouseWheel=ft.bind(this),this._onKeyDown=yt.bind(this),this._onTouchStart=vt.bind(this),this._onTouchMove=bt.bind(this),this._onMouseDown=pt.bind(this),this._onMouseMove=gt.bind(this),this._interceptControlDown=Mt.bind(this),this._interceptControlUp=St.bind(this),null!==this.domElement&&this.connect(this.domElement),this.update()}connect(e){super.connect(e),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(e){e.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=e}stopListenToKeyEvents(){null!==this._domElementKeyEvents&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(et),this.update(),this.state=lt}update(e=null){const t=this.object.position;rt.copy(t).sub(this.target),rt.applyQuaternion(this._quat),this._spherical.setFromVector3(rt),this.autoRotate&&this.state===lt&&this._rotateLeft(this._getAutoRotationAngle(e)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let i=this.minAzimuthAngle,a=this.maxAzimuthAngle;isFinite(i)&&isFinite(a)&&(i<-Math.PI?i+=ot:i>Math.PI&&(i-=ot),a<-Math.PI?a+=ot:a>Math.PI&&(a-=ot),this._spherical.theta=i<=a?Math.max(i,Math.min(a,this._spherical.theta)):this._spherical.theta>(i+a)/2?Math.max(i,this._spherical.theta):Math.min(a,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),!0===this.enableDamping?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let n=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const e=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),n=e!=this._spherical.radius}if(rt.setFromSpherical(this._spherical),rt.applyQuaternion(this._quatInverse),t.copy(this.target).add(rt),this.object.lookAt(this.target),!0===this.enableDamping?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let e=null;if(this.object.isPerspectiveCamera){const t=rt.length();e=this._clampDistance(t*this._scale);const i=t-e;this.object.position.addScaledVector(this._dollyDirection,i),this.object.updateMatrixWorld(),n=!!i}else if(this.object.isOrthographicCamera){const t=new g(this._mouse.x,this._mouse.y,0);t.unproject(this.object);const i=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),n=i!==this.object.zoom;const a=new g(this._mouse.x,this._mouse.y,0);a.unproject(this.object),this.object.position.sub(a).add(t),this.object.updateMatrixWorld(),e=rt.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;null!==e&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(e).add(this.object.position):(at.origin.copy(this.object.position),at.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(at.direction))<st?this.object.lookAt(this.target):(nt.setFromNormalAndCoplanarPoint(this.object.up,this.target),at.intersectPlane(nt,this.target))))}else if(this.object.isOrthographicCamera){const e=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),e!==this.object.zoom&&(this.object.updateProjectionMatrix(),n=!0)}return this._scale=1,this._performCursorZoom=!1,!!(n||this._lastPosition.distanceToSquared(this.object.position)>ct||8*(1-this._lastQuaternion.dot(this.object.quaternion))>ct||this._lastTargetPosition.distanceToSquared(this.target)>ct)&&(this.dispatchEvent(et),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0)}_getAutoRotationAngle(e){return null!==e?ot/60*this.autoRotateSpeed*e:ot/60/60*this.autoRotateSpeed}_getZoomScale(e){const t=Math.abs(.01*e);return Math.pow(.95,this.zoomSpeed*t)}_rotateLeft(e){this._sphericalDelta.theta-=e}_rotateUp(e){this._sphericalDelta.phi-=e}_panLeft(e,t){rt.setFromMatrixColumn(t,0),rt.multiplyScalar(-e),this._panOffset.add(rt)}_panUp(e,t){!0===this.screenSpacePanning?rt.setFromMatrixColumn(t,1):(rt.setFromMatrixColumn(t,0),rt.crossVectors(this.object.up,rt)),rt.multiplyScalar(e),this._panOffset.add(rt)}_pan(e,t){const i=this.domElement;if(this.object.isPerspectiveCamera){const a=this.object.position;rt.copy(a).sub(this.target);let n=rt.length();n*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*e*n/i.clientHeight,this.object.matrix),this._panUp(2*t*n/i.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(e*(this.object.right-this.object.left)/this.object.zoom/i.clientWidth,this.object.matrix),this._panUp(t*(this.object.top-this.object.bottom)/this.object.zoom/i.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(e,t){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const i=this.domElement.getBoundingClientRect(),a=e-i.left,n=t-i.top,s=i.width,r=i.height;this._mouse.x=a/s*2-1,this._mouse.y=-n/r*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(e){return Math.max(this.minDistance,Math.min(this.maxDistance,e))}_handleMouseDownRotate(e){this._rotateStart.set(e.clientX,e.clientY)}_handleMouseDownDolly(e){this._updateZoomParameters(e.clientX,e.clientX),this._dollyStart.set(e.clientX,e.clientY)}_handleMouseDownPan(e){this._panStart.set(e.clientX,e.clientY)}_handleMouseMoveRotate(e){this._rotateEnd.set(e.clientX,e.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(ot*this._rotateDelta.x/t.clientHeight),this._rotateUp(ot*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(e){this._dollyEnd.set(e.clientX,e.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(e){this._panEnd.set(e.clientX,e.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(e){this._updateZoomParameters(e.clientX,e.clientY),e.deltaY<0?this._dollyIn(this._getZoomScale(e.deltaY)):e.deltaY>0&&this._dollyOut(this._getZoomScale(e.deltaY)),this.update()}_handleKeyDown(e){let t=!1;switch(e.code){case this.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(ot*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,this.keyPanSpeed),t=!0;break;case this.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(-ot*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,-this.keyPanSpeed),t=!0;break;case this.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(ot*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(this.keyPanSpeed,0),t=!0;break;case this.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(-ot*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(-this.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),this.update())}_handleTouchStartRotate(e){if(1===this._pointers.length)this._rotateStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),i=.5*(e.pageX+t.x),a=.5*(e.pageY+t.y);this._rotateStart.set(i,a)}}_handleTouchStartPan(e){if(1===this._pointers.length)this._panStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),i=.5*(e.pageX+t.x),a=.5*(e.pageY+t.y);this._panStart.set(i,a)}}_handleTouchStartDolly(e){const t=this._getSecondPointerPosition(e),i=e.pageX-t.x,a=e.pageY-t.y,n=Math.sqrt(i*i+a*a);this._dollyStart.set(0,n)}_handleTouchStartDollyPan(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enablePan&&this._handleTouchStartPan(e)}_handleTouchStartDollyRotate(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enableRotate&&this._handleTouchStartRotate(e)}_handleTouchMoveRotate(e){if(1==this._pointers.length)this._rotateEnd.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),i=.5*(e.pageX+t.x),a=.5*(e.pageY+t.y);this._rotateEnd.set(i,a)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(ot*this._rotateDelta.x/t.clientHeight),this._rotateUp(ot*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(e){if(1===this._pointers.length)this._panEnd.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),i=.5*(e.pageX+t.x),a=.5*(e.pageY+t.y);this._panEnd.set(i,a)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(e){const t=this._getSecondPointerPosition(e),i=e.pageX-t.x,a=e.pageY-t.y,n=Math.sqrt(i*i+a*a);this._dollyEnd.set(0,n),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const s=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);this._updateZoomParameters(s,r)}_handleTouchMoveDollyPan(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enablePan&&this._handleTouchMovePan(e)}_handleTouchMoveDollyRotate(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enableRotate&&this._handleTouchMoveRotate(e)}_addPointer(e){this._pointers.push(e.pointerId)}_removePointer(e){delete this._pointerPositions[e.pointerId];for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId)return void this._pointers.splice(t,1)}_isTrackingPointer(e){for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId)return!0;return!1}_trackPointer(e){let t=this._pointerPositions[e.pointerId];void 0===t&&(t=new o,this._pointerPositions[e.pointerId]=t),t.set(e.pageX,e.pageY)}_getSecondPointerPosition(e){const t=e.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[t]}_customWheelEvent(e){const t=e.deltaMode,i={clientX:e.clientX,clientY:e.clientY,deltaY:e.deltaY};switch(t){case 1:i.deltaY*=16;break;case 2:i.deltaY*=100}return e.ctrlKey&&!this._controlActive&&(i.deltaY*=10),i}}function ut(e){!1!==this.enabled&&(0===this._pointers.length&&(this.domElement.setPointerCapture(e.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._isTrackingPointer(e)||(this._addPointer(e),"touch"===e.pointerType?this._onTouchStart(e):this._onMouseDown(e)))}function dt(e){!1!==this.enabled&&("touch"===e.pointerType?this._onTouchMove(e):this._onMouseMove(e))}function mt(e){switch(this._removePointer(e),this._pointers.length){case 0:this.domElement.releasePointerCapture(e.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(it),this.state=lt;break;case 1:const t=this._pointers[0],i=this._pointerPositions[t];this._onTouchStart({pointerId:t,pageX:i.x,pageY:i.y})}}function pt(e){let t;switch(e.button){case 0:t=this.mouseButtons.LEFT;break;case 1:t=this.mouseButtons.MIDDLE;break;case 2:t=this.mouseButtons.RIGHT;break;default:t=-1}switch(t){case M.DOLLY:if(!1===this.enableZoom)return;this._handleMouseDownDolly(e),this.state=1;break;case M.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===this.enablePan)return;this._handleMouseDownPan(e),this.state=2}else{if(!1===this.enableRotate)return;this._handleMouseDownRotate(e),this.state=0}break;case M.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===this.enableRotate)return;this._handleMouseDownRotate(e),this.state=0}else{if(!1===this.enablePan)return;this._handleMouseDownPan(e),this.state=2}break;default:this.state=lt}this.state!==lt&&this.dispatchEvent(tt)}function gt(e){switch(this.state){case 0:if(!1===this.enableRotate)return;this._handleMouseMoveRotate(e);break;case 1:if(!1===this.enableZoom)return;this._handleMouseMoveDolly(e);break;case 2:if(!1===this.enablePan)return;this._handleMouseMovePan(e)}}function ft(e){!1!==this.enabled&&!1!==this.enableZoom&&this.state===lt&&(e.preventDefault(),this.dispatchEvent(tt),this._handleMouseWheel(this._customWheelEvent(e)),this.dispatchEvent(it))}function yt(e){!1!==this.enabled&&this._handleKeyDown(e)}function vt(e){switch(this._trackPointer(e),this._pointers.length){case 1:switch(this.touches.ONE){case S.ROTATE:if(!1===this.enableRotate)return;this._handleTouchStartRotate(e),this.state=3;break;case S.PAN:if(!1===this.enablePan)return;this._handleTouchStartPan(e),this.state=4;break;default:this.state=lt}break;case 2:switch(this.touches.TWO){case S.DOLLY_PAN:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchStartDollyPan(e),this.state=5;break;case S.DOLLY_ROTATE:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchStartDollyRotate(e),this.state=6;break;default:this.state=lt}break;default:this.state=lt}this.state!==lt&&this.dispatchEvent(tt)}function bt(e){switch(this._trackPointer(e),this.state){case 3:if(!1===this.enableRotate)return;this._handleTouchMoveRotate(e),this.update();break;case 4:if(!1===this.enablePan)return;this._handleTouchMovePan(e),this.update();break;case 5:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchMoveDollyPan(e),this.update();break;case 6:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchMoveDollyRotate(e),this.update();break;default:this.state=lt}}function wt(e){!1!==this.enabled&&e.preventDefault()}function Mt(e){"Control"===e.key&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function St(e){"Control"===e.key&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}class xt{constructor(t){this.renderer=t,this.glowAmount=0,this.targetGlowAmount=0,this.glowColor=new e.Color(1,1,1),this.targetGlowColor=new e.Color(1,1,1),this.worldPosition=new e.Vector3(0,0,0),this.time=0,this.ringPhase=0,this.scene=new e.Scene,this.camera=new e.OrthographicCamera(-1,1,1,-1,.1,10),this.camera.position.z=1,this.createGlowMesh(),this._tempVector=new e.Vector3,this._tempColor=new e.Color}createGlowMesh(){const t=new e.PlaneGeometry(2,2),i=new e.ShaderMaterial({uniforms:{glowAmount:{value:0},glowColor:{value:new e.Color(1,1,1)},centerUV:{value:new e.Vector2(.5,.5)},time:{value:0},ringPhase:{value:0},aspectRatio:{value:1}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);\n                }\n            ",fragmentShader:"\n                uniform float glowAmount;\n                uniform vec3 glowColor;\n                uniform vec2 centerUV;\n                uniform float time;\n                uniform float ringPhase;\n                uniform float aspectRatio;\n\n                varying vec2 vUv;\n\n                void main() {\n                    // Aspect-correct UV coordinates - apply aspect to Y instead\n                    // This prevents horizontal clipping on wide screens\n                    vec2 centeredUV = vUv - centerUV;\n                    // Don't multiply by aspect - let glow be circular in screen space\n\n                    float dist = length(centeredUV);\n\n                    // Ring parameters that evolve with ringPhase\n                    // MUCH LARGER radii to prevent clipping - glow can extend to screen edges\n                    // At ringPhase=0: tight ring close to center\n                    // At ringPhase=1: expanded ring that can fill most of screen\n                    float innerRadius = mix(0.02, 0.08, ringPhase);\n                    float outerRadius = mix(0.15, 1.2, ringPhase);  // Can extend beyond screen!\n                    float peakRadius = mix(0.06, 0.25, ringPhase);\n\n                    // Create soft ring falloff\n                    // Inner falloff: 0 at center, 1 at peak\n                    float innerFalloff = smoothstep(innerRadius * 0.3, peakRadius, dist);\n\n                    // Outer falloff: 1 at peak, 0 at outer edge (very gradual fade)\n                    float outerFalloff = 1.0 - smoothstep(peakRadius, outerRadius, dist);\n\n                    // Combine for ring shape\n                    float ringIntensity = innerFalloff * outerFalloff;\n\n                    // Add subtle shimmer/undulation\n                    float shimmer = 0.9 + 0.1 * sin(time * 3.0 + dist * 20.0);\n\n                    // Final intensity with glow amount control\n                    float intensity = ringIntensity * glowAmount * shimmer;\n\n                    // Soft glow color with intensity\n                    // Use HDR values (>1.0) for bloom pickup\n                    vec3 color = glowColor * intensity * 2.0;\n\n                    // Alpha for blending - GlowLayer needs true alpha transparency\n                    // for its overlay effect (unlike water which uses opaque additive)\n                    float alpha = intensity * 0.6;\n\n                    gl_FragColor = vec4(color, alpha);\n                }\n            ",transparent:!0,blending:e.AdditiveBlending,depthTest:!1,depthWrite:!1});this.glowMesh=new e.Mesh(t,i),this.scene.add(this.glowMesh)}setGlow(e,t,i){this.targetGlowAmount=Math.max(0,e),t&&(Array.isArray(t)?this.targetGlowColor.setRGB(t[0],t[1],t[2]):this.targetGlowColor.copy(t)),i&&this.worldPosition.copy(i)}update(e,t){const i=e/1e3;this.time+=i,this.glowAmount+=(this.targetGlowAmount-this.glowAmount)*Math.min(1,8*i),this.glowColor.lerp(this.targetGlowColor,Math.min(1,8*i));const a=Math.min(1,this.glowAmount);if(this.ringPhase+=(a-this.ringPhase)*Math.min(1,4*i),t){this._tempVector.copy(this.worldPosition),this._tempVector.project(t);const e=(this._tempVector.x+1)/2,i=(this._tempVector.y+1)/2;this.glowMesh.material.uniforms.centerUV.value.set(e,i)}this.glowMesh.material.uniforms.glowAmount.value=this.glowAmount,this.glowMesh.material.uniforms.glowColor.value.copy(this.glowColor),this.glowMesh.material.uniforms.time.value=this.time,this.glowMesh.material.uniforms.ringPhase.value=this.ringPhase;const n=this.renderer.domElement;this.glowMesh.material.uniforms.aspectRatio.value=n.width/n.height}render(e){if(this.glowAmount<.001)return;const{autoClear:t}=e;e.autoClear=!1,e.render(this.scene,this.camera),e.autoClear=t}isActive(){return this.glowAmount>.001||this.targetGlowAmount>0}dispose(){this.glowMesh&&(this.glowMesh.geometry.dispose(),this.glowMesh.material.dispose(),this.scene.remove(this.glowMesh),this.glowMesh=null),this.scene=null,this.camera=null,this._tempVector=null,this._tempColor=null}}class Ct{constructor(t){this.renderer=t,this.impacts=[],this.crackColor=new e.Color(.15,.08,.05),this.crackGlowColor=new e.Color(1,.6,.2),this.glowStrength=.5,this.isHealing=!1,this.healProgress=0,this.time=0,this.depthTexture=null,this.scene=new e.Scene,this.camera=new e.OrthographicCamera(-1,1,1,-1,.1,10),this.camera.position.z=1,this.createCrackMesh(),this._tempVector=new e.Vector3}createCrackMesh(){const t=new e.PlaneGeometry(2,2),i=new e.ShaderMaterial({uniforms:{impactData0:{value:new e.Vector4(0,0,0,0)},impactData1:{value:new e.Vector4(0,0,0,0)},impactData2:{value:new e.Vector4(0,0,0,0)},impactParams0:{value:new e.Vector2(0,0)},impactParams1:{value:new e.Vector2(0,0)},impactParams2:{value:new e.Vector2(0,0)},impactSeeds:{value:new e.Vector3(0,0,0)},numImpacts:{value:0},crackColor:{value:new e.Color(.05,.03,.02)},crackGlowColor:{value:new e.Color(1,.8,.4)},glowStrength:{value:.3},time:{value:0},aspectRatio:{value:1},depthTexture:{value:null},cameraNear:{value:.1},cameraFar:{value:100},hasDepth:{value:0}},vertexShader:"\n                varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4(position.xy, 0.0, 1.0);\n                }\n            ",fragmentShader:"\n                // Impact data\n                uniform vec4 impactData0;  // xy=center, zw=direction\n                uniform vec4 impactData1;\n                uniform vec4 impactData2;\n                uniform vec2 impactParams0; // x=propagation, y=amount\n                uniform vec2 impactParams1;\n                uniform vec2 impactParams2;\n                uniform vec3 impactSeeds;\n                uniform int numImpacts;\n\n                // Visual params\n                uniform vec3 crackColor;\n                uniform vec3 crackGlowColor;\n                uniform float glowStrength;\n                uniform float time;\n                uniform float aspectRatio;\n\n                // Depth masking\n                uniform sampler2D depthTexture;\n                uniform float cameraNear;\n                uniform float cameraFar;\n                uniform float hasDepth;\n\n                varying vec2 vUv;\n\n                // Hash functions\n                float hash(vec2 p) {\n                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n                }\n\n                vec2 hash2(vec2 p) {\n                    return vec2(\n                        fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453),\n                        fract(sin(dot(p, vec2(269.5, 183.3))) * 43758.5453)\n                    );\n                }\n\n                float noise(vec2 p) {\n                    vec2 i = floor(p);\n                    vec2 f = fract(p);\n                    f = f * f * (3.0 - 2.0 * f);\n                    float a = hash(i);\n                    float b = hash(i + vec2(1.0, 0.0));\n                    float c = hash(i + vec2(0.0, 1.0));\n                    float d = hash(i + vec2(1.0, 1.0));\n                    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n                }\n\n                float voronoiEdge(vec2 p) {\n                    vec2 i = floor(p);\n                    vec2 f = fract(p);\n                    float minDist = 1.0;\n                    float secondDist = 1.0;\n                    for (int y = -1; y <= 1; y++) {\n                        for (int x = -1; x <= 1; x++) {\n                            vec2 neighbor = vec2(float(x), float(y));\n                            vec2 cellPoint = neighbor + hash2(i + neighbor) * 0.8;\n                            float dist = length(f - cellPoint);\n                            if (dist < minDist) {\n                                secondDist = minDist;\n                                minDist = dist;\n                            } else if (dist < secondDist) {\n                                secondDist = dist;\n                            }\n                        }\n                    }\n                    return secondDist - minDist;\n                }\n\n                // Crack line with wobble\n                float crackLine(vec2 uv, vec2 origin, vec2 dir, float seed) {\n                    vec2 toPoint = uv - origin;\n                    float along = dot(toPoint, dir);\n                    float perp = abs(dot(toPoint, vec2(-dir.y, dir.x)));\n                    if (along < 0.0) return 1.0;\n                    float wobble = noise(vec2(along * 8.0 + seed, seed)) * 0.03;\n                    perp += wobble * along;\n                    float width = 0.015 * (1.0 - along * 0.5);\n                    width = max(width, 0.003);\n                    return perp / width;\n                }\n\n                // Generate crack pattern for a single impact\n                float singleImpactCrack(vec2 uv, vec2 center, vec2 direction, float propagation, float seed) {\n                    vec2 toPixel = uv - center;\n                    float distFromCenter = length(toPixel);\n\n                    float meshRadius = 0.4;\n                    float maxRadius = propagation * meshRadius;\n\n                    // Outside propagation radius = no crack\n                    if (distFromCenter > maxRadius && propagation < 0.99) {\n                        return 1.0;\n                    }\n\n                    float crack = 1.0;\n                    bool isRadial = length(direction) < 0.1;\n\n                    if (isRadial) {\n                        // Radial cracks from center\n                        vec2 crackUV = (uv - center) * 15.0 + seed * 10.0;\n                        crackUV += vec2(noise(uv * 10.0 + seed), noise(uv * 10.0 + 100.0 + seed)) * 0.3;\n                        float edge = voronoiEdge(crackUV);\n\n                        float angle = atan(toPixel.y, toPixel.x);\n                        float radialLines = abs(sin(angle * 8.0 + seed * 3.14159 + noise(vec2(distFromCenter * 5.0 + seed)) * 2.0));\n                        radialLines = smoothstep(0.0, 0.15, radialLines);\n\n                        crack = min(edge * 2.0, radialLines + 0.3);\n                    } else {\n                        // Directional cracks\n                        vec2 dir = normalize(direction);\n                        vec2 perp = vec2(-dir.y, dir.x);\n\n                        for (float i = -2.0; i <= 2.0; i += 1.0) {\n                            vec2 offset = perp * i * 0.06;\n                            vec2 crackOrigin = center + offset;\n\n                            float angleVar = noise(vec2(i * 10.0 + seed, seed)) * 0.3 - 0.15;\n                            vec2 crackDir = vec2(\n                                dir.x * cos(angleVar) - dir.y * sin(angleVar),\n                                dir.x * sin(angleVar) + dir.y * cos(angleVar)\n                            );\n\n                            float line = crackLine(uv, crackOrigin, crackDir, i * 17.3 + seed * 100.0);\n                            crack = min(crack, line);\n\n                            // Branch\n                            float branchPoint = 0.1 + hash(vec2(i + seed, seed)) * 0.15;\n                            vec2 branchOrigin = crackOrigin + crackDir * branchPoint;\n                            vec2 branchDir = normalize(crackDir + perp * (hash(vec2(i + seed, 1.0 + seed)) - 0.5) * 0.8);\n                            float branch = crackLine(uv, branchOrigin, branchDir, i * 23.7 + seed * 50.0);\n                            crack = min(crack, branch * 1.2);\n                        }\n\n                        // Web cracks\n                        vec2 webUV = uv * 20.0 + seed * 5.0;\n                        float web = voronoiEdge(webUV) * 3.0;\n                        float crackReach = dot(toPixel, dir);\n                        if (crackReach > 0.0 && crackReach < maxRadius) {\n                            crack = min(crack, web + 0.5);\n                        }\n                    }\n\n                    // Fade at propagation edge\n                    float edgeFade = 1.0 - smoothstep(maxRadius * 0.5, maxRadius, distFromCenter);\n\n                    return crack / max(edgeFade, 0.3);\n                }\n\n                void main() {\n                    if (numImpacts == 0) discard;\n\n                    // Work in centered UV space\n                    vec2 uv = vUv - 0.5;\n                    uv.x *= aspectRatio;\n\n                    // Elliptical mesh bounds check - crystal is taller than wide\n                    // Use ellipse: (x/a)^2 + (y/b)^2 <= 1\n                    // a = horizontal radius (narrower), b = vertical radius (taller)\n                    float meshRadiusX = 0.18;  // Narrow horizontal\n                    float meshRadiusY = 0.38;  // Tall vertical\n                    float ellipseDist = (uv.x * uv.x) / (meshRadiusX * meshRadiusX) +\n                                        (uv.y * uv.y) / (meshRadiusY * meshRadiusY);\n\n                    // Soft edge fade instead of hard cutoff\n                    float meshMask = 1.0 - smoothstep(0.7, 1.0, ellipseDist);\n                    if (meshMask < 0.01) {\n                        discard;\n                    }\n\n                    // Depth check (if depth texture available)\n                    if (hasDepth > 0.5) {\n                        float depth = texture2D(depthTexture, vUv).r;\n                        if (depth >= 0.9999) {\n                            discard;\n                        }\n                    }\n\n                    float distFromMeshCenter = length(uv);\n\n                    // Combine all impacts\n                    float combinedCrack = 1.0;\n                    float maxAmount = 0.0;\n\n                    // Impact 0\n                    if (numImpacts >= 1 && impactParams0.y > 0.01) {\n                        vec2 center0 = (impactData0.xy - 0.5);\n                        center0.x *= aspectRatio;\n                        float crack0 = singleImpactCrack(uv, center0, impactData0.zw, impactParams0.x, impactSeeds.x);\n                        combinedCrack = min(combinedCrack, crack0);\n                        maxAmount = max(maxAmount, impactParams0.y);\n                    }\n\n                    // Impact 1\n                    if (numImpacts >= 2 && impactParams1.y > 0.01) {\n                        vec2 center1 = (impactData1.xy - 0.5);\n                        center1.x *= aspectRatio;\n                        float crack1 = singleImpactCrack(uv, center1, impactData1.zw, impactParams1.x, impactSeeds.y);\n                        combinedCrack = min(combinedCrack, crack1);\n                        maxAmount = max(maxAmount, impactParams1.y);\n                    }\n\n                    // Impact 2\n                    if (numImpacts >= 3 && impactParams2.y > 0.01) {\n                        vec2 center2 = (impactData2.xy - 0.5);\n                        center2.x *= aspectRatio;\n                        float crack2 = singleImpactCrack(uv, center2, impactData2.zw, impactParams2.x, impactSeeds.z);\n                        combinedCrack = min(combinedCrack, crack2);\n                        maxAmount = max(maxAmount, impactParams2.y);\n                    }\n\n                    // Convert to line visibility - INCREASED WIDTH for visibility\n                    float crackWidth = 0.12;  // Wider cracks (was 0.08)\n                    float crackLine = 1.0 - smoothstep(0.0, crackWidth, combinedCrack);\n\n                    // Edge glow - wider and brighter\n                    float glowWidth = crackWidth * 4.0;  // Wider glow (was 3.0)\n                    float edgeGlow = 1.0 - smoothstep(crackWidth * 0.3, glowWidth, combinedCrack);\n                    edgeGlow = max(0.0, edgeGlow - crackLine * 0.3);\n\n                    // Apply amount - this is the FADE control\n                    crackLine *= maxAmount;\n                    edgeGlow *= maxAmount * glowStrength;\n\n                    // Shimmer on glow\n                    float shimmer = 0.85 + 0.15 * sin(time * 3.0 + distFromMeshCenter * 20.0);\n                    edgeGlow *= shimmer;\n\n                    // Final output - INCREASED ALPHA for visibility\n                    vec3 color = crackColor * crackLine * 1.5 + crackGlowColor * edgeGlow * 3.0;\n                    float alpha = crackLine * 1.0 + edgeGlow * 0.8;  // Full opacity on crack lines\n\n                    if (alpha < 0.001) discard;\n\n                    gl_FragColor = vec4(color, alpha);\n                }\n            ",transparent:!0,blending:e.NormalBlending,depthTest:!1,depthWrite:!1});this.crackMesh=new e.Mesh(t,i),this.scene.add(this.crackMesh)}addImpact(t){const i=100*Math.random(),a={centerUV:t.centerUV?t.centerUV.clone():new e.Vector2(.5,.5),direction:t.direction?t.direction.clone():new e.Vector2(0,0),propagation:t.propagation??.8,amount:t.amount??1,seed:i};this.impacts.length>=3&&this.impacts.shift(),this.impacts.push(a),this._updateUniforms()}startHealing(e=1500){this.isHealing=!0,this.healDuration=e,this.healStartTime=performance.now()}clearAll(){this.impacts=[],this.isHealing=!1,this.healProgress=0,this._updateUniforms()}hasCracks(){return this.impacts.length>0}_updateUniforms(){const{uniforms:e}=this.crackMesh.material;e.numImpacts.value=this.impacts.length;for(let t=0;t<3;t++){const i=this.impacts[t],a=e[`impactData${t}`],n=e[`impactParams${t}`];i?(a.value.set(i.centerUV.x,i.centerUV.y,i.direction.x,i.direction.y),n.value.set(i.propagation,i.amount)):(a.value.set(0,0,0,0),n.value.set(0,0))}e.impactSeeds.value.set(this.impacts[0]?.seed??0,this.impacts[1]?.seed??0,this.impacts[2]?.seed??0)}setDepthTexture(e){this.depthTexture=e,this.crackMesh&&(this.crackMesh.material.uniforms.depthTexture.value=e,this.crackMesh.material.uniforms.hasDepth.value=e?1:0)}setCameraParams(e,t){this.crackMesh&&(this.crackMesh.material.uniforms.cameraNear.value=e,this.crackMesh.material.uniforms.cameraFar.value=t)}setGlowColor(e){Array.isArray(e)?this.crackGlowColor.setRGB(e[0],e[1],e[2]):e&&this.crackGlowColor.copy(e),this.crackMesh.material.uniforms.crackGlowColor.value.copy(this.crackGlowColor)}update(e,t){const i=e/1e3;if(this.time+=i,this.isHealing&&this.impacts.length>0){const e=performance.now()-this.healStartTime;this.healProgress=Math.min(e/this.healDuration,1);const t=this.healProgress,i=1-t*t*(3-2*t);for(const e of this.impacts)void 0===e.originalAmount&&(e.originalAmount=e.amount,e.originalPropagation=e.propagation),e.amount=e.originalAmount*i,e.propagation=e.originalPropagation*(.3+.7*i);this.healProgress>=1?this.clearAll():this._updateUniforms()}const{uniforms:a}=this.crackMesh.material;a.time.value=this.time,a.glowStrength.value=this.glowStrength;const n=this.renderer.domElement;a.aspectRatio.value=n.width/n.height,t&&(a.cameraNear.value=t.near,a.cameraFar.value=t.far)}render(e){if(0===this.impacts.length)return;const{autoClear:t}=e;e.autoClear=!1,e.render(this.scene,this.camera),e.autoClear=t}isActive(){return this.impacts.length>0}reset(){this.clearAll()}dispose(){this.crackMesh&&(this.crackMesh.geometry.dispose(),this.crackMesh.material.dispose(),this.scene.remove(this.crackMesh),this.crackMesh=null),this.scene=null,this.camera=null,this.depthTexture=null,this._tempVector=null,this.impacts=[]}}const Pt=e=>({front:{x:0,y:0,z:e},side:{x:e,y:0,z:0},top:{x:0,y:e,z:0},angle:{x:.67*e,y:.5*e,z:.67*e},back:{x:0,y:0,z:-e},bottom:{x:0,y:-e,z:0}});class kt{constructor(e,t,i=3){this.camera=e,this.controls=t,this.cameraDistance=i,this.animationId=null}getAvailablePresets(){return Object.keys(Pt(this.cameraDistance))}setPreset(e,t=1e3,i=!1){if(!this.controls)return;const a=Pt(this.cameraDistance)[e];if(!a)return void console.warn(`Unknown camera preset: ${e}`);this.cancelAnimation();const n=i?this.controls.target.clone():null;0!==t?this._animateTo(a,t,n,i):this._setInstant(a,n)}_setInstant(e,t){this.controls.reset(),this.camera.position.set(e.x,e.y,e.z),t?(this.controls.target.copy(t),this.camera.lookAt(t)):(this.controls.target.set(0,0,0),this.camera.lookAt(0,0,0)),this.controls.update()}_animateTo(t,i,a,n){n||this.controls.target.set(0,0,0);const s=this.camera.position.clone(),r=new e.Vector3(t.x,t.y,t.z),o=performance.now(),l=e=>{const t=e-o,a=Math.min(t/i,1),n=1-Math.pow(1-a,3);this.camera.position.lerpVectors(s,r,n),this.camera.lookAt(0,0,0),this.controls.update(),this.animationId=a<1?requestAnimationFrame(l):null};this.animationId=requestAnimationFrame(l)}isAnimating(){return null!==this.animationId}cancelAnimation(){null!==this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null)}reset(e=1e3){this.setPreset("front",e)}setCameraDistance(e){this.cameraDistance=e}dispose(){this.cancelAnimation(),this.camera=null,this.controls=null}}class Dt{constructor(t,i={}){this.canvas=t,this.options=i,this._destroyed=!1,this.assetBasePath=i.assetBasePath||"",this.scene=new e.Scene,this.scene.background=null,this.renderer=new e.WebGLRenderer({canvas:t,alpha:!0,premultipliedAlpha:!0,antialias:!1,powerPreference:"high-performance",preserveDrawingBuffer:!1,precision:"highp",logarithmicDepthBuffer:!1,stencil:!1}),this.renderer.outputColorSpace=e.SRGBColorSpace,this.renderer.toneMapping=e.ACESFilmicToneMapping,this.renderer.toneMappingExposure=1,this.renderer.setClearColor(0,0),this.renderer.clear(),this.renderer.autoClear=!1,this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,1.5)),this.renderer.setSize(t.width,t.height,!1),i.enableShadows&&(this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=e.PCFSoftShadowMap),this._contextLost=!1,this._boundHandleContextLost=this.handleContextLost.bind(this),this._boundHandleContextRestored=this.handleContextRestored.bind(this),this.renderer.domElement.addEventListener("webglcontextlost",this._boundHandleContextLost,!1),this.renderer.domElement.addEventListener("webglcontextrestored",this._boundHandleContextRestored,!1),this._wasHidden=!1,this._boundHandleVisibilityChange=this._handleVisibilityChange.bind(this),document.addEventListener("visibilitychange",this._boundHandleVisibilityChange),this._boundHandleFocusRecovery=this._handleFocusRecovery.bind(this),window.addEventListener("focus",this._boundHandleFocusRecovery);const a=void 0!==i.fov?i.fov:45;this.camera=new e.PerspectiveCamera(a,t.width/t.height,.1,100),this.cameraDistance=void 0!==i.cameraDistance?i.cameraDistance:3,this.camera.position.set(0,0,this.cameraDistance),this.camera.lookAt(0,0,0),!1!==i.enableControls&&this.setupCameraControls(),this.setupLights(),!1!==i.enablePostProcessing&&this.setupPostProcessing(),this.coreMesh=null,this.materialMode="glow",this.glowMaterial=null,this.glassMaterial=null,this.mixer=null,this.clock=new e.Clock,this._tempColor=new e.Color,this._tempColor2=new e.Color,this._white=new e.Color(1,1,1),this._tempQuat=new e.Quaternion,this._tempEuler=new e.Euler,this._quatX=new e.Quaternion,this._quatY=new e.Quaternion,this._quatZ=new e.Quaternion,this._rollQuat=new e.Quaternion,this._meshQuat=new e.Quaternion,this._xAxis=new e.Vector3(1,0,0),this._yAxis=new e.Vector3(0,1,0),this._zAxis=new e.Vector3(0,0,1),this._cameraToMesh=new e.Vector3,this._cameraDir=new e.Vector3,this._soulPosTemp=new e.Vector3,this._cachedSoulMesh=null,this._drawingBufferSize=new e.Vector2}setupCameraControls(){this.controls=new ht(this.camera,this.renderer.domElement),this.controls.enableDamping=!0,this.controls.dampingFactor=.1;const e=void 0!==this.options.minZoom?this.options.minZoom:.5*this.cameraDistance,t=void 0!==this.options.maxZoom?this.options.maxZoom:2*this.cameraDistance;this.controls.minDistance=e,this.controls.maxDistance=t,this.controls.enablePan=!1,this.controls.autoRotate=!0===this.options.autoRotate,this.controls.autoRotateSpeed=void 0!==this.options.autoRotateSpeed?this.options.autoRotateSpeed:.5,this.controls.minPolarAngle=.2*Math.PI,this.controls.maxPolarAngle=.8*Math.PI,this.controls.rotateSpeed=.8,this.controls.zoomSpeed=1.5,("ontouchstart"in window||navigator.maxTouchPoints>0)&&(this.controls.rotateSpeed=1,this.controls.zoomSpeed=1.2),this.renderer.domElement.style.touchAction="none";const i=()=>{this.controls&&this.controls.update()};this.renderer.domElement.addEventListener("pointermove",i,{passive:!0}),this.renderer.domElement.addEventListener("pointerdown",i,{passive:!0}),this.cameraPresetManager=new kt(this.camera,this.controls,this.cameraDistance)}setupLights(){this.ambientLight=new e.AmbientLight(16777215,.3),this.ambientLight.name="ambientLight",this.scene.add(this.ambientLight),this.keyLight=new e.DirectionalLight(16777215,.8),this.keyLight.position.set(2,2,2),this.keyLight.name="keyLight",this.options.enableShadows&&(this.keyLight.castShadow=!0,this.keyLight.shadow.mapSize.width=1024,this.keyLight.shadow.mapSize.height=1024,this.keyLight.shadow.camera.near=.5,this.keyLight.shadow.camera.far=10),this.scene.add(this.keyLight),this.fillLight=new e.DirectionalLight(16777215,.5),this.fillLight.position.set(-2,1,1),this.fillLight.name="fillLight",this.scene.add(this.fillLight),this.rimLight=new e.DirectionalLight(16777215,.7),this.rimLight.position.set(0,1,-2),this.rimLight.name="rimLight",this.scene.add(this.rimLight),this.accentLight1=new e.PointLight(54527,.3,10),this.accentLight1.position.set(-3,0,1),this.accentLight1.name="accentLight1",this.scene.add(this.accentLight1),this.accentLight2=new e.PointLight(16716947,.2,10),this.accentLight2.position.set(3,0,1),this.accentLight2.name="accentLight2",this.scene.add(this.accentLight2),this.accentLight3=new e.PointLight(16739125,.2,10),this.accentLight3.position.set(0,3,-1),this.accentLight3.name="accentLight3",this.scene.add(this.accentLight3),this.createEnvironmentMap()}async createEnvironmentMap(){if(this._destroyed)return;this._envMapLoading=!0;try{const{HDRLoader:t}=await Promise.resolve().then(function(){return $y});if(this._destroyed)return;const i=new e.PMREMGenerator(this.renderer);i.compileEquirectangularShader();try{const a=new t,n="studio_1k.hdr";let s;if(this.assetBasePath){let e=this.assetBasePath.replace(/\/$/,"");e.endsWith("/assets")&&(e=e.slice(0,-7)),s=e?`${e}/hdri/${n}`:`/hdri/${n}`}else{const e=window.location.pathname.split("/");let t="";e.length>2&&e[1]&&(t=`/${e[1]}`),s=t?`${t}/hdri/${n}`:`/hdri/${n}`}let r=null;try{r=await a.loadAsync(s)}catch{}if(!r||!r.image)throw new Error(`HDR texture not found at ${s}`);return this._destroyed?(r.dispose(),void i.dispose()):(r.mapping=e.EquirectangularReflectionMapping,this.envMap=i.fromEquirectangular(r).texture,r.dispose(),i.dispose(),void(this._envMapLoading=!1))}catch{i.dispose()}}catch{}if(this._destroyed)return;const t=new e.WebGLCubeRenderTarget(512),i=new e.Scene,a=new e.Color(5609983),n=new e.Color(16739229),s=new e.Color(1710638),r=new e.HemisphereLight(a,s,1.5);i.add(r);const o=new e.PointLight(54527,2,20);o.position.set(-5,2,-5),i.add(o);const l=new e.PointLight(16716947,2,20);l.position.set(5,2,-5),i.add(l);const c=new e.PointLight(16755200,1.5,20);c.position.set(0,5,0),i.add(c),i.background=n;const h=new e.CubeCamera(.1,100,t);h.update(this.renderer,i),this.envMap=t.texture,this._envCubeRenderTarget=t,this._envScene=i,this._envCubeCamera=h,this._envMapLoading=!1}setupPostProcessing(){const t=new e.Vector2;this.renderer.getDrawingBufferSize(t);const i=new e.WebGLRenderTarget(t.x,t.y,{format:e.RGBAFormat,type:e.HalfFloatType,minFilter:e.NearestFilter,magFilter:e.NearestFilter,stencilBuffer:!1,depthBuffer:!0});this.composer=new je(this.renderer,i),this.renderer.setRenderTarget(i),this.renderer.clear(),this.renderer.setRenderTarget(this.composer.readBuffer),this.renderer.clear(),this.renderer.setRenderTarget(this.composer.writeBuffer),this.renderer.clear(),this.renderer.setRenderTarget(null);const a=new qe(this.scene,this.camera);a.clearColor=new e.Color(0,0,0),a.clearAlpha=0,this.composer.addPass(a),this._distortionPassIndex=this.composer.passes.length;const n=new e.Vector2(Math.floor(.5*t.x),Math.floor(.5*t.y));this.bloomPass=new Ue(n,1.5,.4,.9),this.bloomPass.name="bloomPass",this.bloomPass.enabled=!0,this.composer.addPass(this.bloomPass),this.bloomPass.clearBloomBuffers(this.renderer),this.particleRenderTarget=new e.WebGLRenderTarget(t.x,t.y,{format:e.RGBAFormat,type:e.HalfFloatType,minFilter:e.LinearFilter,magFilter:e.LinearFilter,stencilBuffer:!1,depthBuffer:!0}),this.renderer.setRenderTarget(this.particleRenderTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this.particleBloomPass=new Ue(n,.5,.4,.3),this.particleBloomPass.name="particleBloomPass",this.particleBloomPass.enabled=!0,this.particleBloomPass.clearColor=new e.Color(1,1,1),this.particleBloomPass.skipBaseCopy=!0,this.particleBloomPass.clearBloomBuffers(this.renderer),this.soulRenderTarget=new e.WebGLRenderTarget(t.x,t.y,{format:e.RGBAFormat,type:e.HalfFloatType,minFilter:e.LinearFilter,magFilter:e.LinearFilter,stencilBuffer:!1,depthBuffer:!0}),this.renderer.setRenderTarget(this.soulRenderTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this.iceRefractionTarget=new e.WebGLRenderTarget(t.x,t.y,{format:e.RGBAFormat,type:e.HalfFloatType,minFilter:e.LinearFilter,magFilter:e.LinearFilter,stencilBuffer:!1,depthBuffer:!0}),this.renderer.setRenderTarget(this.iceRefractionTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this._refractionMeshes=new Set;const s=Math.floor(.5*t.x),r=Math.floor(.5*t.y);this.distortionTarget=new e.WebGLRenderTarget(s,r,{format:e.RGBAFormat,type:e.HalfFloatType,minFilter:e.LinearFilter,magFilter:e.LinearFilter,depthBuffer:!1}),this.renderer.setRenderTarget(this.distortionTarget),this.renderer.clear(),this.renderer.setRenderTarget(null),this.distortionPass=new Ge(We),this.distortionPass.enabled=!1,this.composer.passes.splice(this._distortionPassIndex,0,this.distortionPass),this.distortionManager=new He(this.renderer,this.camera),this.particleAtmospherics=new Je(this.scene,this.camera),this.particleCompositeShader={uniforms:{tDiffuse:{value:null},tParticles:{value:null}},vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            ",fragmentShader:"\n                uniform sampler2D tDiffuse;\n                uniform sampler2D tParticles;\n                varying vec2 vUv;\n\n                void main() {\n                    vec4 base = texture2D(tDiffuse, vUv);\n                    vec4 particles = texture2D(tParticles, vUv);\n\n                    // Alpha-preserving composite: particles over base\n                    // Use particle alpha to blend\n                    vec3 blended = mix(base.rgb, particles.rgb, particles.a);\n                    float alpha = base.a + particles.a * (1.0 - base.a);\n\n                    gl_FragColor = vec4(blended, alpha);\n                }\n            "},this.glowLayer=new xt(this.renderer),this.crackLayer=new Ct(this.renderer)}handleContextLost(e){e.preventDefault(),this._contextLost=!0,console.warn("⚠️ WebGL context lost - rendering paused"),this.cameraAnimationId&&(cancelAnimationFrame(this.cameraAnimationId),this.cameraAnimationId=null)}handleContextRestored(){this._contextLost=!1,this.recreateResources(),this.onContextRestored&&this.onContextRestored()}recreateResources(){this.createEnvironmentMap(),"glow"===this.materialMode?(this.glowMaterial=this.createGlowMaterial(),this.coreMesh&&(this.coreMesh.material=this.glowMaterial)):"glass"===this.materialMode&&(this.glassMaterial=this.createGlassMaterial(),this.coreMesh&&(this.coreMesh.material=this.glassMaterial),this.coreMesh&&this.createInnerCore())}_recreateDistortionTarget(){if(!this.distortionTarget)return;this.distortionTarget.dispose();const t=this.renderer.getDrawingBufferSize(new e.Vector2);this.distortionTarget=new e.WebGLRenderTarget(Math.floor(.5*t.x),Math.floor(.5*t.y),{format:e.RGBAFormat,type:e.HalfFloatType,minFilter:e.LinearFilter,magFilter:e.LinearFilter,depthBuffer:!1}),this.renderer.setRenderTarget(this.distortionTarget),this.renderer.clear(),this.renderer.setRenderTarget(null)}_handleFocusRecovery(){this._destroyed||this._wasHidden&&(this._wasHidden=!1,this._recreateDistortionTarget())}_handleVisibilityChange(){if(!this._destroyed)if(document.hidden)this._wasHidden=!0;else if(this._wasHidden=!1,!document.hidden){const e=this.renderer?.getContext();if(e&&e.isContextLost())console.warn("⚠️ WebGL context lost detected on visibility change"),this._contextLost=!0;else if(this._recreateDistortionTarget(),this.coreMesh?.material){const{material:e}=this.coreMesh;e.map&&!e.map.image&&(console.warn("⚠️ Texture invalidated on visibility change - triggering reload"),this.onContextRestored&&this.onContextRestored())}}}createCoreMesh(t,i=null){if(this.coreMesh&&(this.scene.remove(this.coreMesh),this.coreMesh.isGroup?this.coreMesh.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&this.disposeMaterial(e.material)}):(this.coreMesh.geometry&&this.coreMesh.geometry.dispose(),this.coreMesh.material&&this.disposeMaterial(this.coreMesh.material)),this.coreMesh=null),t.isGroup)return this.coreMesh=t,this.coreMesh.name="coreMascot",this.options.enableShadows&&this.coreMesh.traverse(e=>{e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0)}),this.scene.add(this.coreMesh),this.coreMesh;let a;return i?a=i:(this.glowMaterial||(this.glowMaterial=this.createGlowMaterial()),a="glass"===this.materialMode?this.glassMaterial||this.createGlassMaterial():this.glowMaterial),this.coreMesh=new e.Mesh(t,a),this.coreMesh.name="coreMascot",this.options.enableShadows&&(this.coreMesh.castShadow=!0,this.coreMesh.receiveShadow=!0),this.scene.add(this.coreMesh),"glass"===this.materialMode&&this.createInnerCore(),this.coreMesh}swapGeometry(t,i=null){if(!this.coreMesh)return;this.bloomPass&&this.bloomPass.clearBloomBuffers(this.renderer),this.particleBloomPass&&this.particleBloomPass.clearBloomBuffers(this.renderer);const a=this.coreMesh.geometry;if(a&&a.dispose(),this.coreMesh.geometry=t,i){if(this.coreMesh.material&&this.coreMesh.material!==this.glowMaterial&&this.coreMesh.material!==this.glassMaterial&&this.disposeMaterial(this.coreMesh.material),this.coreMesh.material=i,i.uniforms?.resolution){const t=this.renderer.getDrawingBufferSize(new e.Vector2);i.uniforms.resolution.value.set(t.x,t.y)}}else{const e="glass"===this.materialMode?this.glassMaterial||this.createGlassMaterial():this.glowMaterial;this.coreMesh.material!==e&&(this.coreMesh.material&&this.coreMesh.material!==this.glowMaterial&&this.coreMesh.material!==this.glassMaterial&&this.disposeMaterial(this.coreMesh.material),this.coreMesh.material=e)}"glass"!==this.materialMode||i||this.createInnerCore()}createGlowMaterial(){return new e.ShaderMaterial({uniforms:{glowColor:{value:new e.Color(1,1,1)},glowIntensity:{value:1},coreColor:{value:new e.Color(1,1,1)},fresnelPower:{value:3},uOpacity:{value:1}},vertexShader:"\n                varying vec3 vNormal;\n                varying vec3 vViewPosition;\n\n                void main() {\n                    // Transform normal to view space\n                    vNormal = normalize(normalMatrix * normal);\n\n                    // Calculate view space position\n                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                    vViewPosition = -mvPosition.xyz;\n\n                    // Output clip space position\n                    gl_Position = projectionMatrix * mvPosition;\n                }\n            ",fragmentShader:"\n                uniform vec3 glowColor;\n                uniform vec3 coreColor;\n                uniform float glowIntensity;\n                uniform float fresnelPower;\n                uniform float uOpacity;\n\n                varying vec3 vNormal;\n                varying vec3 vViewPosition;\n\n                void main() {\n                    // Discard fully transparent pixels\n                    if (uOpacity < 0.01) discard;\n\n                    // Fresnel effect: edges glow more than center\n                    vec3 viewDir = normalize(vViewPosition);\n                    float fresnel = pow(1.0 - abs(dot(vNormal, viewDir)), fresnelPower);\n\n                    // Combine white core with colored glow\n                    // Both core and glow respect glowIntensity for proper on/off toggle\n                    vec3 finalColor = (coreColor * glowIntensity) + (glowColor * glowIntensity * fresnel);\n\n                    gl_FragColor = vec4(finalColor, uOpacity);\n                }\n            ",transparent:!0,side:e.FrontSide})}createGlassMaterial(){this.glassEmissiveMultiplier=.6;const t=new e.MeshPhysicalMaterial({transmission:1,thickness:2.7,roughness:.37,metalness:0,ior:1.5,reflectivity:.5,envMapIntensity:1.2,side:e.DoubleSide,transparent:!0,opacity:1,color:16777215,emissive:16777215,emissiveIntensity:.6,clearcoat:.8,clearcoatRoughness:.05,iridescence:.4,iridescenceIOR:1.3,iridescenceThicknessRange:[100,400]});return this.envMap&&(t.envMap=this.envMap),t}createInnerCore(){if(this.innerCore&&(this.coreMesh&&this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null),!this.coreMesh||!this.coreMesh.geometry)return;const t=this.coreMesh.geometry;let i;if("TorusGeometry"===t.type||void 0!==t.parameters?.tube){const a=t.parameters,n=a.radius||1,s=.25*(a.tube||.4),r=a.radialSegments||16,o=a.tubularSegments||100;i=new e.TorusGeometry(n,s,r,o)}else if("SphereGeometry"===t.type){const a=.2*(t.parameters.radius||1);i=new e.SphereGeometry(a,32,32)}else if("BoxGeometry"===t.type){const a=t.parameters,n=.2*(a.width||1),s=.2*(a.height||1),r=.2*(a.depth||1);i=new e.BoxGeometry(n,s,r)}else if("IcosahedronGeometry"===t.type||"OctahedronGeometry"===t.type){const a=t.parameters,n=.2*(a.radius||1),s=a.detail||2;i="IcosahedronGeometry"===t.type?new e.IcosahedronGeometry(n,s):new e.OctahedronGeometry(n,s)}else i=new e.IcosahedronGeometry(.2,2);const a=t.userData?.geometryType,n="IcosahedronGeometry"===t.type||"OctahedronGeometry"===t.type||"crystal"===a||"diamond"===a,s=new e.MeshStandardMaterial({emissive:16777215,emissiveIntensity:n?3.5:2,color:16777215,transparent:!1,opacity:1});this.innerCoreMaterial=s,this.innerCore=new e.Mesh(i,s),this.innerCore.name="innerCore",this.coreMesh.add(this.innerCore)}setMaterialMode(e){if(!this.coreMesh)return console.warn("Cannot set material mode: core mesh not created yet"),void(this.materialMode=e);if(e===this.materialMode)return;this.materialMode=e,"glass"!==e||this.glassMaterial?"glow"!==e||this.glowMaterial||(this.glowMaterial=this.createGlowMaterial()):this.glassMaterial=this.createGlassMaterial();const t="glass"===e?this.glassMaterial:this.glowMaterial;this.coreMesh.material=t,"glass"===e?this.createInnerCore():this.innerCore&&(this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null)}updateGlassProperties(e){this.glassMaterial&&(void 0!==e.transmission&&(this.glassMaterial.transmission=e.transmission,this.glassMaterial.needsUpdate=!0),void 0!==e.thickness&&(this.glassMaterial.thickness=e.thickness,this.glassMaterial.needsUpdate=!0),void 0!==e.roughness&&(this.glassMaterial.roughness=e.roughness,this.glassMaterial.needsUpdate=!0),void 0!==e.emissiveMultiplier&&(this.glassEmissiveMultiplier=e.emissiveMultiplier))}updateLighting(e,t,i=.15){if(!t||!t.visual)return;const a=t.visual.glowColor||"#FFFFFF";this._tempColor.set(a);const n=t.visual.glowIntensity||1;if(this.keyLight&&(this.keyLight.color.lerp(this._tempColor,i),this.keyLight.intensity+=(.8*n-this.keyLight.intensity)*i),this.fillLight&&(this._tempColor2.copy(this._tempColor).lerp(this._white,.7),this.fillLight.color.lerp(this._tempColor2,.5*i),this.fillLight.intensity+=(.3*n-this.fillLight.intensity)*i),this.ambientLight){const e=.4*n;this.ambientLight.intensity+=(e-this.ambientLight.intensity)*i}}normalizeIntensity(e){return.8+Math.log(e+1)/Math.log(11)*.4}calculateColorLuminance(e,t,i){const a=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4);return.2126*a(e)+.7152*a(t)+.0722*a(i)}updateBloom(e,t=.1,i=null){if(this.bloomPass){const a=this.normalizeIntensity(e);let n,s,r;"sun"===i?(s=1.5,r=.4,n=.3):"crystal"===i||"rough"===i||"heart"===i?(s=1.5,r=.5,n=.5):"glass"===this.materialMode?(s=.3,r=.2,n=.85):(s=1+.8*a,r=.4,n=.85),this.bloomPass.strength+=(s-this.bloomPass.strength)*t,this.bloomPass.threshold+=(n-this.bloomPass.threshold)*t,this.bloomPass.radius=r}}setCameraPreset(t,i=1e3,a=!1){if(!this.controls)return;const n=this.cameraDistance,s={front:{x:0,y:0,z:n},side:{x:n,y:0,z:0},top:{x:0,y:n,z:0},angle:{x:.67*n,y:.5*n,z:.67*n},back:{x:0,y:0,z:-n},bottom:{x:0,y:-n,z:0}}[t];if(!s)return void console.warn(`Unknown camera preset: ${t}`);const r=a?this.controls.target.clone():null;if(0===i)return this.controls.reset(),this.camera.position.set(s.x,s.y,s.z),r?(this.controls.target.copy(r),this.camera.lookAt(r)):(this.controls.target.set(0,0,0),this.camera.lookAt(0,0,0)),void this.controls.update();a||this.controls.target.set(0,0,0);const o=this.camera.position.clone(),l=new e.Vector3(s.x,s.y,s.z),c=performance.now(),h=e=>{const t=e-c,a=Math.min(t/i,1),n=1-Math.pow(1-a,3);this.camera.position.lerpVectors(o,l,n),this.camera.lookAt(0,0,0),this.controls.update(),this.cameraAnimationId=a<1?requestAnimationFrame(h):null};this.cameraAnimationId=requestAnimationFrame(h)}resetCamera(){this.setCameraPreset("front",1e3)}toggleAutoRotate(e){this.controls&&(this.controls.autoRotate=void 0!==e?e:!this.controls.autoRotate)}isAutoRotateEnabled(){return!!this.controls&&this.controls.autoRotate}render(t={}){if(this._destroyed)return;if(this._contextLost)return;if(!this.scene||!this.camera||!this.renderer)return;if(!this.coreMesh)return;if(this._envMapLoading)return;if(!this._firstFrameRendered)return this._firstFrameRendered=!0,this.renderer.setRenderTarget(null),this.renderer.setClearColor(0,0),void this.renderer.clear();const{position:i=[0,0,0],rotation:a=[0,0,0],scale:n=1,nonUniformScale:s=null,glowColor:r=[1,1,1],glowIntensity:o=1,hasActiveGesture:l=!1,calibrationRotation:c=[0,0,0],cameraRoll:h=0,solarEclipse:u=null,deltaTime:d=0,morphProgress:m=null,hasSoul:p=!1,hasParticles:g=!0}=t;if(this.controls&&this.controls.update(),this.coreMesh){if(this.coreMesh.position.set(...i),this._tempEuler.set(a[0],a[1],a[2],"XYZ"),this._tempQuat.setFromEuler(this._tempEuler),this._quatX.setFromAxisAngle(this._xAxis,c[0]),this._quatY.setFromAxisAngle(this._yAxis,c[1]),this._cameraToMesh.subVectors(this.coreMesh.position,this.camera.position).normalize(),this._quatZ.setFromAxisAngle(this._cameraToMesh,c[2]),this._tempQuat.multiply(this._quatX),this._tempQuat.multiply(this._quatY),this._tempQuat.multiply(this._quatZ),this.coreMesh.rotation.setFromQuaternion(this._tempQuat),0!==h&&(this._cameraDir.subVectors(this.coreMesh.position,this.camera.position).normalize(),this._rollQuat.setFromAxisAngle(this._cameraDir,h),this._meshQuat.setFromEuler(this.coreMesh.rotation),this._meshQuat.premultiply(this._rollQuat),this.coreMesh.rotation.setFromQuaternion(this._meshQuat)),s?this.coreMesh.scale.set(s[0],s[1],s[2]):this.coreMesh.scale.setScalar(n),u&&u.update(this.camera,this.coreMesh,d,m),this.coreMesh.material&&this.coreMesh.material.uniforms){if(this.coreMesh.material.uniforms.glowColor){this._tempColor.setRGB(...r);const e=this.coreMesh.material.uniforms.glowColor.value;Math.abs(this._tempColor.r-e.r)+Math.abs(this._tempColor.g-e.g)+Math.abs(this._tempColor.b-e.b)>.001&&e.lerp(this._tempColor,.15)}if(this.coreMesh.material.uniforms.glowIntensity){let e;e=0===o?0:l?o:this.normalizeIntensity(o);const t=this.coreMesh.material.uniforms.glowIntensity.value;if(Math.abs(e-t)>.001){const i=l?.5:.15;this.coreMesh.material.uniforms.glowIntensity.value+=(e-t)*i}}if(void 0!==this.coreMesh.material.uniforms.deformationStrength){const e=t.deformation;if(e&&e.enabled&&e.strength>.001){if(!this._lastDeformLog||Date.now()-this._lastDeformLog>1e3){const t=e.impactPoint;console.log(`🥊 DEFORMATION: strength=${e.strength.toFixed(3)} impactPoint=[${t[0].toFixed(3)}, ${t[1].toFixed(3)}, ${t[2].toFixed(3)}] falloff=${e.falloffRadius}`),this._lastDeformLog=Date.now()}this.coreMesh.material.uniforms.deformationStrength.value=e.strength,e.impactPoint&&this.coreMesh.material.uniforms.impactPoint&&this.coreMesh.material.uniforms.impactPoint.value.set(e.impactPoint[0],e.impactPoint[1],e.impactPoint[2]),void 0!==e.falloffRadius&&this.coreMesh.material.uniforms.deformationFalloff&&(this.coreMesh.material.uniforms.deformationFalloff.value=e.falloffRadius)}else this.coreMesh.material.uniforms.deformationStrength.value=0}}else if(this.coreMesh.material&&this.coreMesh.material.emissive){this._tempColor.setRGB(...r),this.coreMesh.material.emissive.lerp(this._tempColor,.15);const e=.15*o,t=this.coreMesh.material.emissiveIntensity,i=l?.5:.15;this.coreMesh.material.emissiveIntensity+=(e-t)*i,this.coreMesh.material.color.lerp(this._white,.15)}this.innerCore&&(this.innerCore.visible=o>0,this.innerCoreMaterial&&(this._tempColor.setRGB(...r),this.innerCoreMaterial.emissive.lerp(this._tempColor,.15)))}if(this.mixer){const e=this.clock.getDelta();this.mixer.update(e)}if(this.renderer.clear(),this.composer){if(this.soulRenderTarget&&p){this._cachedSoulMesh||this.scene.traverse(e=>{"crystalSoul"===e.name&&(this._cachedSoulMesh=e)});const e=this._cachedSoulMesh;if(this.renderer.setRenderTarget(this.soulRenderTarget),this.renderer.clear(),this.camera.layers.set(2),this.renderer.render(this.scene,this.camera),this.coreMesh?.material?.uniforms?.soulTexture&&(this.coreMesh.material.uniforms.soulTexture.value=this.soulRenderTarget.texture,this.coreMesh.material.uniforms.soulTextureSize&&this.coreMesh.material.uniforms.soulTextureSize.value.set(this.soulRenderTarget.width,this.soulRenderTarget.height),this.coreMesh.material.uniforms.soulScreenCenter&&e)){this._soulPosTemp.copy(e.position),this._soulPosTemp.project(this.camera);const t=.5*(this._soulPosTemp.x+1),i=.5*(this._soulPosTemp.y+1);this.coreMesh.material.uniforms.soulScreenCenter.value.set(t,i)}this.renderer.setRenderTarget(null)}if(this.iceRefractionTarget&&this._refractionMeshes&&this._refractionMeshes.size>0){for(const e of this._refractionMeshes)e.visible=!1;const e=this.scene.background;this._refractionBackground&&(this.scene.background=this._refractionBackground),this.renderer.setRenderTarget(this.iceRefractionTarget),this.renderer.setClearColor(0,0),this.renderer.clear(),this.camera.layers.set(0),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null),this.scene.background=e;for(const e of this._refractionMeshes)e.visible=!0,e.material?.uniforms?.uBackgroundTexture&&(e.material.uniforms.uBackgroundTexture.value=this.iceRefractionTarget.texture,e.material.uniforms.uResolution.value.set(this.iceRefractionTarget.width,this.iceRefractionTarget.height),e.material.uniforms.uHasBackground.value=1)}if(this.distortionManager){this.distortionManager.update(d/1e3);const e=this.distortionManager.hasActiveSources();this.distortionPass.enabled=e,this.distortionPass.uniforms.tDistortion.value=this.distortionTarget.texture,e&&(this.camera.layers.set(0),this.distortionManager.render(this.distortionTarget))}if(this.particleAtmospherics&&this.particleAtmospherics.update(d/1e3),this.camera.layers.set(0),this.composer.render(),g&&this.particleRenderTarget&&this.particleBloomPass){this.renderer.state.reset(),this.renderer.setRenderTarget(this.particleRenderTarget),this.renderer.setClearColor(16777215,0),this.renderer.clear(),this.camera.layers.set(0);const t=this._depthOnlyMaterial||(this._depthOnlyMaterial=new e.MeshBasicMaterial({colorWrite:!1,depthWrite:!0}));this.scene.overrideMaterial=t,this.renderer.render(this.scene,this.camera),this.scene.overrideMaterial=null,this.camera.layers.set(1),this.renderer.render(this.scene,this.camera);const i=this.particleRenderTarget;this.particleBloomPass.renderToScreen=!0,this.particleBloomPass.render(this.renderer,null,i,0,!1),this.renderer.setClearColor(0,0),this.renderer.setRenderTarget(null)}else g&&(this.camera.layers.set(1),this.renderer.render(this.scene,this.camera));this.camera.layers.enableAll(),this.glowLayer&&this.glowLayer.isActive()&&this.glowLayer.render(this.renderer),this.crackLayer&&this.crackLayer.isActive()&&this.crackLayer.render(this.renderer)}else this.renderer.render(this.scene,this.camera),this.glowLayer&&this.glowLayer.isActive()&&this.glowLayer.render(this.renderer),this.crackLayer&&this.crackLayer.isActive()&&this.crackLayer.render(this.renderer)}addRefractionMesh(e){e&&this._refractionMeshes&&this._refractionMeshes.add(e)}removeRefractionMesh(e){this._refractionMeshes&&this._refractionMeshes.delete(e)}setRefractionBackground(t){t?"string"==typeof t?(new e.TextureLoader).load(t,t=>{t.colorSpace=e.SRGBColorSpace,this._refractionBackground=t}):this._refractionBackground=t:this._refractionBackground=null}updateGlowLayer(e,t,i,a){this.glowLayer&&(this.glowLayer.setGlow(e,t,i),this.glowLayer.update(a,this.camera))}updateCrackLayer(e,t){if(this.crackLayer){if(e&&e.triggers&&e.triggers.length>0){for(const t of e.triggers)this.crackLayer.addImpact({centerUV:t.centerUV,direction:t.direction,propagation:t.propagation,amount:t.amount});void 0!==e.glowStrength&&(this.crackLayer.glowStrength=e.glowStrength)}e.healTrigger&&this.crackLayer.startHealing(e.healDuration||1500),this.crackLayer.update(t,this.camera)}}resize(t,i){if(this.camera.aspect=t/i,this.camera.updateProjectionMatrix(),this.renderer.setSize(t,i,!1),this.composer){const t=new e.Vector2;this.renderer.getDrawingBufferSize(t),this.composer.setSize(t.x,t.y);const i=Math.floor(.5*t.x),a=Math.floor(.5*t.y);this.bloomPass&&this.bloomPass.setSize(i,a),this.particleRenderTarget&&this.particleRenderTarget.setSize(t.x,t.y),this.particleBloomPass&&this.particleBloomPass.setSize(i,a),this.soulRenderTarget&&this.soulRenderTarget.setSize(t.x,t.y),this.iceRefractionTarget&&this.iceRefractionTarget.setSize(t.x,t.y),this.distortionTarget&&this.distortionTarget.setSize(i,a),this.coreMesh?.material?.uniforms?.resolution&&this.coreMesh.material.uniforms.resolution.value.set(t.x,t.y)}}disposeMaterial(e){e&&(["map","lightMap","bumpMap","normalMap","specularMap","envMap","alphaMap","aoMap","displacementMap","emissiveMap","gradientMap","metalnessMap","roughnessMap"].forEach(t=>{e[t]&&e[t].dispose()}),e.uniforms&&Object.values(e.uniforms).forEach(e=>{e.value&&(e.value.isTexture?(e.value.dispose(),e.value=null):(e.value.isColor||e.value.isVector2||e.value.isVector3||e.value.isVector4)&&(e.value=null))}),e.dispose())}destroy(){this._destroyed=!0,this.renderer?.domElement&&(this.renderer.domElement.removeEventListener("webglcontextlost",this._boundHandleContextLost,!1),this.renderer.domElement.removeEventListener("webglcontextrestored",this._boundHandleContextRestored,!1)),document.removeEventListener("visibilitychange",this._boundHandleVisibilityChange),window.removeEventListener("focus",this._boundHandleFocusRecovery),this.cameraAnimationId&&(cancelAnimationFrame(this.cameraAnimationId),this.cameraAnimationId=null),this.innerCore&&(this.coreMesh&&this.coreMesh.remove(this.innerCore),this.innerCore.geometry.dispose(),this.disposeMaterial(this.innerCore.material),this.innerCore=null,this.innerCoreMaterial=null),this.coreMesh&&(this.scene.remove(this.coreMesh),this.coreMesh.geometry.dispose(),this.disposeMaterial(this.coreMesh.material),this.coreMesh=null),this.glowMaterial&&(this.disposeMaterial(this.glowMaterial),this.glowMaterial=null),this.glassMaterial&&(this.disposeMaterial(this.glassMaterial),this.glassMaterial=null),this.composer&&(this.composer.dispose(),this.composer=null),this.particleRenderTarget&&(this.particleRenderTarget.dispose(),this.particleRenderTarget=null),this.particleBloomPass&&(this.particleBloomPass.dispose(),this.particleBloomPass=null),this.soulRenderTarget&&(this.soulRenderTarget.dispose(),this.soulRenderTarget=null),this.iceRefractionTarget&&(this.iceRefractionTarget.dispose(),this.iceRefractionTarget=null),this._refractionMeshes&&(this._refractionMeshes.clear(),this._refractionMeshes=null),this.distortionTarget&&(this.distortionTarget.dispose(),this.distortionTarget=null),this.distortionPass&&(this.distortionPass.dispose(),this.distortionPass=null),this.distortionManager&&(this.distortionManager.dispose(),this.distortionManager=null),this.particleAtmospherics&&(this.particleAtmospherics.dispose(),this.particleAtmospherics=null),this.glowLayer&&(this.glowLayer.dispose(),this.glowLayer=null),this.crackLayer&&(this.crackLayer.dispose(),this.crackLayer=null),this.cameraPresetManager&&(this.cameraPresetManager.dispose(),this.cameraPresetManager=null),this.controls&&(this.controls.dispose(),this.controls=null),this.keyLight?.shadow?.map&&this.keyLight.shadow.map.dispose(),this.fillLight?.shadow?.map&&this.fillLight.shadow.map.dispose(),this.rimLight?.shadow?.map&&this.rimLight.shadow.map.dispose(),this.keyLight=null,this.fillLight=null,this.rimLight=null,this.ambientLight=null,this.accentLight1=null,this.accentLight2=null,this.accentLight3=null,this.envMap&&(this.envMap.dispose(),this.envMap=null),this._envCubeRenderTarget&&(this._envCubeRenderTarget.dispose(),this._envCubeRenderTarget=null),this._envScene&&(this._envScene.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&this.disposeMaterial(e.material)}),this._envScene.clear(),this._envScene=null),this._envCubeCamera&&(this._envCubeCamera=null),this.renderer&&(this.renderer.dispose(),this.renderer=null),this.scene.clear(),this.mixer&&(this.mixer.stopAllAction(),this.mixer=null),this.clock=null,this.camera=null,this._tempColor=null,this._tempColor2=null,this._white=null,this._tempQuat=null,this._tempEuler=null,this._quatX=null,this._quatY=null,this._quatZ=null,this._rollQuat=null,this._meshQuat=null,this._xAxis=null,this._yAxis=null,this._zAxis=null,this._cameraToMesh=null,this._cameraDir=null}}const At=/^[og]\s*(.+)?/,_t=/^mtllib /,Tt=/^usemtl /,It=/^usemap /,Ot=/\s+/,Rt=new g,Et=new g,Bt=new g,Ft=new g,zt=new g,Lt=new d;function Gt(){const e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);const i=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const a={index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==i?i.smooth:this.smooth,groupStart:void 0!==i?i.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){const t={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(let e=this.materials.length-1;e>=0;e--)this.materials[e].groupCount<=0&&this.materials.splice(e,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},i&&i.name&&"function"==typeof i.clone){const e=i.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const i=parseInt(e,10);return 3*(i>=0?i-1:i+t/3)},parseNormalIndex:function(e,t){const i=parseInt(e,10);return 3*(i>=0?i-1:i+t/3)},parseUVIndex:function(e,t){const i=parseInt(e,10);return 2*(i>=0?i-1:i+t/2)},addVertex:function(e,t,i){const a=this.vertices,n=this.object.geometry.vertices;n.push(a[e+0],a[e+1],a[e+2]),n.push(a[t+0],a[t+1],a[t+2]),n.push(a[i+0],a[i+1],a[i+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,i){const a=this.normals,n=this.object.geometry.normals;n.push(a[e+0],a[e+1],a[e+2]),n.push(a[t+0],a[t+1],a[t+2]),n.push(a[i+0],a[i+1],a[i+2])},addFaceNormal:function(e,t,i){const a=this.vertices,n=this.object.geometry.normals;Rt.fromArray(a,e),Et.fromArray(a,t),Bt.fromArray(a,i),zt.subVectors(Bt,Et),Ft.subVectors(Rt,Et),zt.cross(Ft),zt.normalize(),n.push(zt.x,zt.y,zt.z),n.push(zt.x,zt.y,zt.z),n.push(zt.x,zt.y,zt.z)},addColor:function(e,t,i){const a=this.colors,n=this.object.geometry.colors;void 0!==a[e]&&n.push(a[e+0],a[e+1],a[e+2]),void 0!==a[t]&&n.push(a[t+0],a[t+1],a[t+2]),void 0!==a[i]&&n.push(a[i+0],a[i+1],a[i+2])},addUV:function(e,t,i){const a=this.uvs,n=this.object.geometry.uvs;n.push(a[e+0],a[e+1]),n.push(a[t+0],a[t+1]),n.push(a[i+0],a[i+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,i,a,n,s,r,o,l){const c=this.vertices.length;let h=this.parseVertexIndex(e,c),u=this.parseVertexIndex(t,c),d=this.parseVertexIndex(i,c);if(this.addVertex(h,u,d),this.addColor(h,u,d),void 0!==r&&""!==r){const e=this.normals.length;h=this.parseNormalIndex(r,e),u=this.parseNormalIndex(o,e),d=this.parseNormalIndex(l,e),this.addNormal(h,u,d)}else this.addFaceNormal(h,u,d);if(void 0!==a&&""!==a){const e=this.uvs.length;h=this.parseUVIndex(a,e),u=this.parseUVIndex(n,e),d=this.parseUVIndex(s,e),this.addUV(h,u,d),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let i=0,a=e.length;i<a;i++){const a=this.parseVertexIndex(e[i],t);this.addVertexPoint(a),this.addColor(a)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const i=this.vertices.length,a=this.uvs.length;for(let t=0,a=e.length;t<a;t++)this.addVertexLine(this.parseVertexIndex(e[t],i));for(let e=0,i=t.length;e<i;e++)this.addUVLine(this.parseUVIndex(t[e],a))}};return e.startObject("",!1),e}class Vt extends A{constructor(e){super(e),this.materials=null}load(e,t,i,a){const n=this,s=new _(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,function(i){try{t(n.parse(i))}catch(t){a?a(t):console.error(t),n.manager.itemError(e)}},i,a)}setMaterials(e){return this.materials=e,this}parse(e){const i=new Gt;-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));const s=e.split("\n");let r=[];for(let e=0,t=s.length;e<t;e++){const t=s[e].trimStart();if(0===t.length)continue;const a=t.charAt(0);if("#"!==a)if("v"===a){const e=t.split(Ot);switch(e[0]){case"v":i.vertices.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),e.length>=7?(Lt.setRGB(parseFloat(e[4]),parseFloat(e[5]),parseFloat(e[6]),T),i.colors.push(Lt.r,Lt.g,Lt.b)):i.colors.push(void 0,void 0,void 0);break;case"vn":i.normals.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"vt":i.uvs.push(parseFloat(e[1]),parseFloat(e[2]))}}else if("f"===a){const e=t.slice(1).trim().split(Ot),a=[];for(let t=0,i=e.length;t<i;t++){const i=e[t];if(i.length>0){const e=i.split("/");a.push(e)}}const n=a[0];for(let e=1,t=a.length-1;e<t;e++){const t=a[e],s=a[e+1];i.addFace(n[0],t[0],s[0],n[1],t[1],s[1],n[2],t[2],s[2])}}else if("l"===a){const e=t.substring(1).trim().split(" ");let a=[];const n=[];if(-1===t.indexOf("/"))a=e;else for(let t=0,i=e.length;t<i;t++){const i=e[t].split("/");""!==i[0]&&a.push(i[0]),""!==i[1]&&n.push(i[1])}i.addLineGeometry(a,n)}else if("p"===a){const e=t.slice(1).trim().split(" ");i.addPointGeometry(e)}else if(null!==(r=At.exec(t))){const e=(" "+r[0].slice(1).trim()).slice(1);i.startObject(e)}else if(Tt.test(t))i.object.startMaterial(t.substring(7).trim(),i.materialLibraries);else if(_t.test(t))i.materialLibraries.push(t.substring(7).trim());else if(It.test(t))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===a){if(r=t.split(" "),r.length>1){const e=r[1].trim().toLowerCase();i.object.smooth="0"!==e&&"off"!==e}else i.object.smooth=!0;const e=i.object.currentMaterial();e&&(e.smooth=i.object.smooth)}else{if("\0"===t)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+t+'"')}}i.finalize();const o=new I;if(o.materialLibraries=[].concat(i.materialLibraries),!0==!(1===i.objects.length&&0===i.objects[0].geometry.vertices.length))for(let e=0,s=i.objects.length;e<s;e++){const s=i.objects[e],r=s.geometry,l=s.materials,c="Line"===r.type,h="Points"===r.type;let u=!1;if(0===r.vertices.length)continue;const d=new a;d.setAttribute("position",new n(r.vertices,3)),r.normals.length>0&&d.setAttribute("normal",new n(r.normals,3)),r.colors.length>0&&(u=!0,d.setAttribute("color",new n(r.colors,3))),!0===r.hasUVIndices&&d.setAttribute("uv",new n(r.uvs,2));const m=[];for(let e=0,t=l.length;e<t;e++){const t=l[e],a=t.name+"_"+t.smooth+"_"+u;let n=i.materials[a];if(null!==this.materials)if(n=this.materials.create(t.name),!c||!n||n instanceof O){if(h&&n&&!(n instanceof E)){const e=new E({size:10,sizeAttenuation:!1});R.prototype.copy.call(e,n),e.color.copy(n.color),e.map=n.map,n=e}}else{const e=new O;R.prototype.copy.call(e,n),e.color.copy(n.color),n=e}void 0===n&&(n=c?new O:h?new E({size:1,sizeAttenuation:!1}):new B,n.name=t.name,n.flatShading=!t.smooth,n.vertexColors=u,i.materials[a]=n),m.push(n)}let p;if(m.length>1){for(let e=0,t=l.length;e<t;e++){const t=l[e];d.addGroup(t.groupStart,t.groupCount,e)}p=c?new F(d,m):h?new z(d,m):new t(d,m)}else p=c?new F(d,m[0]):h?new z(d,m[0]):new t(d,m[0]);p.name=s.name,o.add(p)}else if(i.vertices.length>0){const e=new E({size:1,sizeAttenuation:!1}),t=new a;t.setAttribute("position",new n(i.vertices,3)),i.colors.length>0&&void 0!==i.colors[0]&&(t.setAttribute("color",new n(i.colors,3)),e.vertexColors=!0);const s=new z(t,e);o.add(s)}return o}}function Nt(e,t){if(t===L)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===G||t===V){let i=e.getIndex();if(null===i){const t=[],a=e.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<a.count;e++)t.push(e);e.setIndex(t),i=e.getIndex()}const a=i.count-2,n=[];if(t===G)for(let e=1;e<=a;e++)n.push(i.getX(0)),n.push(i.getX(e)),n.push(i.getX(e+1));else for(let e=0;e<a;e++)e%2==0?(n.push(i.getX(e)),n.push(i.getX(e+1)),n.push(i.getX(e+2))):(n.push(i.getX(e+2)),n.push(i.getX(e+1)),n.push(i.getX(e)));n.length/3!==a&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=e.clone();return s.setIndex(n),s.clearGroups(),s}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}const jt="\n/**\n * Apply a single blend mode to two colors\n * @param base - Base color (RGB, 0.0-1.0 range)\n * @param blend - Blend color (RGB, 0.0-1.0 range)\n * @param mode - Blend mode index (0-17)\n * @return Blended color (RGB, 0.0-1.0 range)\n *\n * Blend Mode Reference:\n *  0 = Multiply        (darkening)\n *  1 = Linear Burn     (darkening, linear)\n *  2 = Color Burn      (darkening, intense)\n *  3 = Color Dodge     (brightening, intense)\n *  4 = Screen          (brightening)\n *  5 = Overlay         (contrast, screen/multiply hybrid)\n *  6 = Add             (brightening, additive glow)\n *  7 = Soft Light      (contrast, gentle)\n *  8 = Hard Light      (contrast, strong)\n *  9 = Vivid Light     (contrast, saturation boost)\n * 10 = Linear Light    (contrast, linear)\n * 11 = Difference      (inversion)\n * 12 = Exclusion       (soft inversion)\n * 13 = Darken          (comparison, darker)\n * 14 = Lighten         (comparison, lighter)\n * 15 = Subtract        (darkening, deep shadows)\n * 16 = Divide          (brightening, ethereal glow)\n * 17 = Pin Light       (posterization)\n */\nvec3 applyBlendMode(vec3 base, vec3 blend, int mode) {\n    if (mode == 0) {\n        // MULTIPLY: base * blend\n        return base * blend;\n    } else if (mode == 1) {\n        // LINEAR BURN: base + blend - 1\n        return max(base + blend - vec3(1.0), vec3(0.0));\n    } else if (mode == 2) {\n        // COLOR BURN: (blend==0.0) ? 0.0 : max((1.0-((1.0-base)/blend)), 0.0)\n        return vec3(\n            blend.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.r) / blend.r), 0.0),\n            blend.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.g) / blend.g), 0.0),\n            blend.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.b) / blend.b), 0.0)\n        );\n    } else if (mode == 3) {\n        // COLOR DODGE: (blend==1.0) ? 1.0 : min(base/(1.0-blend), 1.0)\n        return vec3(\n            blend.r == 1.0 ? 1.0 : min(base.r / (1.0 - blend.r), 1.0),\n            blend.g == 1.0 ? 1.0 : min(base.g / (1.0 - blend.g), 1.0),\n            blend.b == 1.0 ? 1.0 : min(base.b / (1.0 - blend.b), 1.0)\n        );\n    } else if (mode == 4) {\n        // SCREEN: 1 - (1 - base) * (1 - blend)\n        return vec3(1.0) - (vec3(1.0) - base) * (vec3(1.0) - blend);\n    } else if (mode == 5) {\n        // OVERLAY: base < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n        return vec3(\n            base.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),\n            base.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),\n            base.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))\n        );\n    } else if (mode == 6) {\n        // ADD (LINEAR DODGE): base + blend\n        return min(base + blend, vec3(1.0));\n    } else if (mode == 7) {\n        // SOFT LIGHT: blend < 0.5 ? (2*base*blend + base^2*(1-2*blend)) : (sqrt(base)*(2*blend-1) + 2*base*(1-blend))\n        return vec3(\n            blend.r < 0.5 ? (2.0 * base.r * blend.r + base.r * base.r * (1.0 - 2.0 * blend.r)) : (sqrt(base.r) * (2.0 * blend.r - 1.0) + 2.0 * base.r * (1.0 - blend.r)),\n            blend.g < 0.5 ? (2.0 * base.g * blend.g + base.g * base.g * (1.0 - 2.0 * blend.g)) : (sqrt(base.g) * (2.0 * blend.g - 1.0) + 2.0 * base.g * (1.0 - blend.g)),\n            blend.b < 0.5 ? (2.0 * base.b * blend.b + base.b * base.b * (1.0 - 2.0 * blend.b)) : (sqrt(base.b) * (2.0 * blend.b - 1.0) + 2.0 * base.b * (1.0 - blend.b))\n        );\n    } else if (mode == 8) {\n        // HARD LIGHT: blend < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n        return vec3(\n            blend.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)),\n            blend.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)),\n            blend.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b))\n        );\n    } else if (mode == 9) {\n        // VIVID LIGHT: blend < 0.5 ? ColorBurn(base, 2*blend) : ColorDodge(base, 2*(blend-0.5))\n        return vec3(\n            blend.r < 0.5 ? (blend.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.r) / (2.0 * blend.r)), 0.0)) : (blend.r == 1.0 ? 1.0 : min(base.r / (2.0 * (1.0 - blend.r)), 1.0)),\n            blend.g < 0.5 ? (blend.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.g) / (2.0 * blend.g)), 0.0)) : (blend.g == 1.0 ? 1.0 : min(base.g / (2.0 * (1.0 - blend.g)), 1.0)),\n            blend.b < 0.5 ? (blend.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - base.b) / (2.0 * blend.b)), 0.0)) : (blend.b == 1.0 ? 1.0 : min(base.b / (2.0 * (1.0 - blend.b)), 1.0))\n        );\n    } else if (mode == 10) {\n        // LINEAR LIGHT: blend < 0.5 ? LinearBurn(base, 2*blend) : LinearDodge(base, 2*(blend-0.5))\n        return vec3(\n            blend.r < 0.5 ? max(base.r + 2.0 * blend.r - 1.0, 0.0) : min(base.r + 2.0 * (blend.r - 0.5), 1.0),\n            blend.g < 0.5 ? max(base.g + 2.0 * blend.g - 1.0, 0.0) : min(base.g + 2.0 * (blend.g - 0.5), 1.0),\n            blend.b < 0.5 ? max(base.b + 2.0 * blend.b - 1.0, 0.0) : min(base.b + 2.0 * (blend.b - 0.5), 1.0)\n        );\n    } else if (mode == 11) {\n        // DIFFERENCE: abs(base - blend)\n        return abs(base - blend);\n    } else if (mode == 12) {\n        // EXCLUSION: base + blend - 2 * base * blend\n        return base + blend - 2.0 * base * blend;\n    } else if (mode == 13) {\n        // DARKEN: min(base, blend)\n        return min(base, blend);\n    } else if (mode == 14) {\n        // LIGHTEN: max(base, blend)\n        return max(base, blend);\n    } else if (mode == 15) {\n        // SUBTRACT: max(base - blend, 0)\n        return max(base - blend, vec3(0.0));\n    } else if (mode == 16) {\n        // DIVIDE: base / (blend + epsilon)\n        return min(base / (blend + vec3(0.001)), vec3(1.0));\n    } else {\n        // PIN LIGHT (mode 17): Replaces colors based on blend brightness\n        float blendLum = (blend.r + blend.g + blend.b) / 3.0;\n        if (blendLum > 0.5) {\n            // Lighten: replace pixels darker than blend\n            return max(base, 2.0 * blend - vec3(1.0));\n        } else {\n            // Darken: replace pixels lighter than blend\n            return min(base, 2.0 * blend);\n        }\n    }\n}\n",qt=["Multiply","Linear Burn","Color Burn","Color Dodge","Screen","Overlay","Add","Soft Light","Hard Light","Vivid Light","Linear Light","Difference","Exclusion","Darken","Lighten","Subtract","Divide","Pin Light"];function Ut(e){return qt[e]||"Unknown"}function Wt(e){const t=qt.indexOf(e);return-1!==t?t:0}const Ht=`\n/**\n * Moon Fragment Shader with Blend Layers\n *\n * Supports up to 4 sequential blend mode layers for complex color grading\n * using universal Photoshop-style blend modes\n */\n\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec2 shadowOffset;\nuniform float shadowCoverage;\nuniform float shadowSoftness;\nuniform vec3 glowColor;\nuniform float glowIntensity;\nuniform float opacity;\n\n// Lunar Eclipse (Blood Moon) uniforms\nuniform float eclipseProgress;\nuniform float eclipseIntensity;\nuniform vec3 bloodMoonColor;\nuniform float emissiveStrength;\nuniform vec2 eclipseShadowPos;      // Shadow center position (-2 to 1)\nuniform float eclipseShadowRadius;  // Shadow radius\n\n// Eclipse Color Grading (from color pickers)\nuniform vec3 eclipseShadowColor;\nuniform vec3 eclipseMidtoneColor;\nuniform vec3 eclipseHighlightColor;\nuniform vec3 eclipseGlowColor;\n\n// Brightness model toggle (0 = centeredness-based, 1 = edge-based)\nuniform float eclipseBrightnessModel;\n\n// Shadow darkness control (0.0 = no darkening, 1.0 = maximum darkening)\nuniform float shadowDarkness;\n\n// Blend Layer Uniforms (up to 4 layers)\nuniform float layer1Mode;\nuniform float layer1Strength;\nuniform float layer1Enabled;\n\nuniform float layer2Mode;\nuniform float layer2Strength;\nuniform float layer2Enabled;\n\nuniform float layer3Mode;\nuniform float layer3Strength;\nuniform float layer3Enabled;\n\nuniform float layer4Mode;\nuniform float layer4Strength;\nuniform float layer4Enabled;\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n// ═══════════════════════════════════════════════════════════════════════════\n${jt}\n\nvoid main() {\n    // DIRECTIONAL SHADOW in VIEW SPACE - camera-relative moon phase\n    // Shadow stays fixed relative to screen; rotating moon doesn't change which side is lit\n    vec3 viewNormal = normalize(vViewNormal);\n\n    float lightX = shadowOffset.x;\n    float lightY = shadowOffset.y;\n    float offsetMagnitude = length(vec2(lightX, lightY));\n    float lightZ = 1.0 - pow(offsetMagnitude, 1.5);\n    vec3 lightDir = normalize(vec3(lightX, lightY, lightZ));\n\n    // Light direction is in view space (camera-relative)\n    float facing = dot(viewNormal, lightDir);\n    float edgeWidth = max(fwidth(facing) * 4.0, shadowSoftness * 3.0);\n    float shadowFactor = smoothstep(-edgeWidth, edgeWidth, facing);\n\n    // Sample moon surface texture\n    vec4 texColor = texture2D(colorMap, vUv);\n    float brightness = texColor.r + texColor.g + texColor.b;\n    if (brightness < 0.03) {\n        texColor = vec4(0.5, 0.5, 0.5, 1.0);\n    }\n\n    // VIEW DIRECTION (for eclipse rim effects only, NOT for general lighting)\n    vec3 viewDir = normalize(-vViewPosition);\n    float rimFactor = dot(viewNormal, viewDir);\n\n    // EARTHSHINE - faint blue glow on shadowed side\n    vec3 earthshine = texColor.rgb * 0.01 * vec3(0.35, 0.4, 0.6);\n\n    // Apply shadow transition (moon phase only - NOT camera-based)\n    // The moon texture is uniformly visible; only the phase shadow creates darkness\n    float litFactor = pow(shadowFactor, 2.0);\n    vec3 detailEnhanced = texColor.rgb * 1.08;\n    float textureLuminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    detailEnhanced = mix(texColor.rgb * 0.95, texColor.rgb * 1.12, smoothstep(0.3, 0.7, textureLuminance));\n\n    // Lit areas show texture; shadowed areas show earthshine\n    // NO camera-based limb darkening - moon rotates, texture stays uniformly lit\n    vec3 shadowedColor = mix(earthshine, detailEnhanced, litFactor);\n\n    vec3 emissive = vec3(0.02, 0.02, 0.02) * shadowFactor;\n    vec3 emotionGlow = glowColor * glowIntensity * 0.02 * shadowFactor;\n    vec3 finalColor = shadowedColor + emissive + emotionGlow;\n\n    // ═══════════════════════════════════════════════════════════════════════════\n    // LUNAR ECLIPSE EFFECT (Earth's Shadow Sweep)\n    // Shadow position drives everything - automatically transitions from dark sharp shadow to red glow\n    // ═══════════════════════════════════════════════════════════════════════════\n    // Only apply eclipse if shadow is actually near the moon (shadowX > -1.5)\n    if (eclipseProgress > 0.001 && eclipseShadowPos.x > -1.5) {\n        // Eclipse progress is now pre-modulated by UI based on shadow position\n        // No need for shader-side modulation\n        float effectiveProgress = eclipseProgress;\n\n        // Calculate distance from shadow center using VIEW-SPACE position (3D spherical)\n        // This creates a proper circular shadow on the sphere, not a flat UV-based cutoff\n        // viewNormal.xy ranges -1 to 1, scale to match UV range (0 to 0.5 from center)\n        vec2 shadowCenter = vec2(eclipseShadowPos.x, eclipseShadowPos.y);\n        vec2 spherePos = viewNormal.xy * 0.5; // Scale to UV-equivalent range\n        float distFromShadow = length(spherePos - shadowCenter);\n\n        // TOTALITY FACTOR: Based on how centered the shadow is on the moon\n        // When shadowX near 0.0 (centered), we're at totality - brightens and reddens\n        // When shadowX far from 0.0 (off to side), we're partial - stays dark and diffuse\n        float shadowCenteredness = 1.0 - smoothstep(0.0, 0.6, abs(eclipseShadowPos.x));\n        float totalityFactor = shadowCenteredness;\n\n        // Earth's umbra (full shadow) - DIFFUSE at partials, sharper at totality\n        float umbraRadius = eclipseShadowRadius * 0.7;\n        // Edge softness: very diffuse at partials (0.25), sharp at totality (0.05)\n        float umbraEdge = mix(0.25, 0.05, totalityFactor);\n        float umbra = 1.0 - smoothstep(umbraRadius - umbraEdge, umbraRadius + umbraEdge, distFromShadow);\n\n        // Earth's penumbra (partial shadow) - wider and softer\n        // Penumbra extends further at partials, tighter at totality\n        float penumbraRadius = eclipseShadowRadius * mix(1.4, 1.1, totalityFactor);\n        float penumbraEdge = mix(0.3, 0.15, totalityFactor);\n        float penumbra = 1.0 - smoothstep(penumbraRadius - penumbraEdge, penumbraRadius + penumbraEdge, distFromShadow);\n\n        // UMBRA DARKENING: Much darker at partials, lighter at totality\n        // Partials: 85% darkening (very dark shadow)\n        // Totality: 30% darkening (blood moon glow visible)\n        float baseDarkening = mix(0.85, 0.30, totalityFactor);\n        float umbraDarkeningAmount = baseDarkening * shadowDarkness;\n        float umbraDarkening = umbra * effectiveProgress;\n\n        // Apply base darkening first\n        finalColor *= (1.0 - umbraDarkening * umbraDarkeningAmount);\n\n        // PENUMBRA: Darker gradient at partials, lighter at totality\n        float penumbraDarkening = (penumbra - umbra) * effectiveProgress;\n        float penumbraDarkenAmount = mix(0.50, 0.20, totalityFactor); // 50% at partials, 20% at totality\n        finalColor *= (1.0 - penumbraDarkening * penumbraDarkenAmount);\n\n        // BLOOD MOON COLOR: Applied throughout entire eclipse, not just totality\n        // Matches real lunar eclipse behavior - color present at all phases\n        // Use totality factor to control BRIGHTNESS, not color presence\n        float colorStrength = umbra; // Color appears wherever umbra shadow is present\n        vec3 bloodMoonTint = mix(vec3(1.0), eclipseMidtoneColor, colorStrength);\n        finalColor *= bloodMoonTint;\n\n        // REALISTIC ECLIPSE PROGRESSION (corrected):\n        // Shadow sweeps LEFT → RIGHT but NEVER fully covers moon during partials\n        // A bright crescent ALWAYS remains visible (shadow stops before covering moon)\n        // Just before totality: shadow nearly covers moon, blood moon glow appears\n        // The glow spreads FROM the visible bright crescent INTO the shadowed area\n        // During totality: shadow finally covers entire moon, full blood moon\n\n        // Use view-space normal for spherical position (not UV)\n        // Scale to match UV range\n        float pixelX = viewNormal.x * 0.5;\n\n        // THE LIT CRESCENT: Always visible during partial phases\n        // During partials, the moon is partially lit (outside umbra)\n        // Only during totality does the shadow fully cover the moon\n\n        // Where is the bright crescent? Opposite side from shadow\n        // Approaching (shadowX < 0): crescent on RIGHT (positive X)\n        // Leaving (shadowX > 0): crescent on LEFT (negative X)\n        float crescentSide = -sign(eclipseShadowPos.x);\n\n        // CRESCENT EDGE: Where shadow meets lit surface\n        // This is always VISIBLE during partials - never goes to zero\n        float umbraEdgeX = eclipseShadowPos.x + (umbraRadius * crescentSide);\n\n        // Distance from this pixel to the lit crescent edge\n        // Positive = inside shadow, negative = in lit crescent\n        float distFromLitEdge = (pixelX - umbraEdgeX) * crescentSide;\n\n        // GRADIENT: Blood moon glow spreads from the LIT CRESCENT\n        // Only pixels INSIDE the shadow get the gradient\n        // Gradient is strongest at the umbra edge (where crescent is)\n        float crescentGradient = smoothstep(0.5, 0.0, distFromLitEdge);\n\n        // BRIGHTNESS CONTROL: Glow only appears near totality\n        // When shadow is far from center: stays dark\n        // When shadow approaches center: glow spreads from crescent\n        float brightnessControl = umbra * crescentGradient * totalityFactor;\n\n        // During full totality (shadowX ≈ 0), switch to uniform brightness\n        brightnessControl = mix(brightnessControl, umbra * totalityFactor, totalityFactor);\n\n        // EMISSIVE GLOW: Blood moon color spreading from crescent\n        float glowStrength = mix(0.0, 1.0, brightnessControl);\n        vec3 atmosphereGlow = eclipseMidtoneColor * emissiveStrength * glowStrength * umbra;\n        finalColor += atmosphereGlow;\n\n        // RIM GLOW: Atmospheric limb brightening\n        float limbGlowStrength = mix(0.0, 1.5, brightnessControl);\n        float limbGlow = pow(1.0 - rimFactor, 3.0) * umbra;\n        vec3 rimColor = mix(eclipseGlowColor, eclipseHighlightColor, 0.5);\n        finalColor += rimColor * limbGlow * emissiveStrength * limbGlowStrength;\n\n        // ═══════════════════════════════════════════════════════════════════════════\n        // ECLIPSE BLEND LAYERS (Applied AFTER blood moon color)\n        // Applied throughout eclipse wherever umbra is present\n        // Strength modulated by totality factor for smooth brightness transitions\n        // ═══════════════════════════════════════════════════════════════════════════\n\n        // Layer 1: Linear Burn @ 0.634\n        if (layer1Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n            int mode1 = int(layer1Mode + 0.5);\n            vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n            // Apply at FULL strength wherever umbra exists\n            finalColor = clamp(mix(finalColor, blended1, umbra), 0.0, 1.0);\n        }\n\n        // Layer 2: Multiply @ 3.086 - Brightness enhancement\n        if (layer2Enabled > 0.5 && effectiveProgress > 0.1) {\n            // Apply full brightness boost wherever umbra exists\n            vec3 brightened = clamp(finalColor * min(layer2Strength, 5.0), 0.0, 1.0);\n            finalColor = mix(finalColor, brightened, umbra);\n        }\n\n        // Layer 3: Hard Light @ 0.351\n        if (layer3Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n            int mode3 = int(layer3Mode + 0.5);\n            vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n            // Apply at FULL strength wherever umbra exists\n            finalColor = clamp(mix(finalColor, blended3, umbra), 0.0, 1.0);\n        }\n\n        // Layer 4: Manual UI layer\n        if (layer4Enabled > 0.5 && effectiveProgress > 0.1) {\n            vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n            int mode4 = int(layer4Mode + 0.5);\n            vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n            finalColor = clamp(mix(finalColor, blended4, umbra), 0.0, 1.0);\n        }\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════\n    // UNIVERSAL BLEND MODE LAYERS (Only applied when eclipse is OFF)\n    // These are manual UI-driven color grading tools\n    // NOTE: These are DISABLED by default - they're NEVER used since the multiplexer\n    // demo doesn't enable them. This section exists for potential future manual control.\n    // ═══════════════════════════════════════════════════════════════════════════\n    // INTENTIONALLY COMMENTED OUT - these would interfere with eclipse blend layers\n    // if (eclipseProgress < 0.001) {\n    //     // Layer 1 - manual UI control only\n    //     if (layer1Enabled > 0.5) {\n    //         vec3 blendColor1 = vec3(layer1Strength);\n    //         int mode1 = int(layer1Mode + 0.5);\n    //         finalColor = applyBlendMode(finalColor, blendColor1, mode1);\n    //     }\n    // }\n\n    gl_FragColor = vec4(finalColor, opacity);\n}\n`,$t=55.5,Yt=-85,Xt=-60.5,Qt={enabled:!0,strength:1,lockedFace:[0,0,1],lerpSpeed:10},Kt={new:{x:200,y:0,coverage:0},"waxing-crescent":{x:1.5,y:0,coverage:.25},"first-quarter":{x:1,y:0,coverage:.5},"waxing-gibbous":{x:.7,y:0,coverage:.75},full:{x:0,y:0,coverage:1},"waning-gibbous":{x:-.7,y:0,coverage:.75},"last-quarter":{x:-1,y:0,coverage:.5},"waning-crescent":{x:-1.5,y:0,coverage:.25}};function Zt(){return Object.keys(Kt)}function Jt(e){const t=(e%1+1)%1;let i;if(t<=.5){const e=2*t;i=10*Math.pow(1-e,2.5)}else{const e=2*(t-.5);if(e<=.25)i=e/.25*-.3;else if(e<=.5)i=-.3-(e-.25)/.25*.7;else if(e<=.75)i=-1-(e-.5)/.25*2;else{const t=(e-.75)/.25;i=13*Math.pow(t,.4)-3}}return{x:i,y:0,coverage:1-2*Math.abs(t-.5)}}function ei(t=64,i=64){const a=new e.SphereGeometry(.5,t,i);return a.userData.tracked=!0,a}function ti(e){if(e&&(e.geometry&&e.geometry.dispose(),e.material)){const{material:t}=e;t.userData&&t.userData.pendingTextures&&(t.userData.pendingTextures.forEach(({texture:e})=>{e&&e.dispose()}),t.userData.pendingTextures.clear()),t.map&&t.map.dispose(),t.normalMap&&t.normalMap.dispose(),t.uniforms&&(t.uniforms.colorMap&&t.uniforms.colorMap.value&&t.uniforms.colorMap.value.dispose(),t.uniforms.normalMap&&t.uniforms.normalMap.value&&t.uniforms.normalMap.value.dispose()),t.dispose()}}function ii(t,i={}){const a=i.resolution||"4k",n=i.assetBasePath||"/assets",s=`${n}/textures/Moon/moon-color-${a}.jpg`,r=`${n}/textures/Moon/moon-normal-${a}.jpg`,o=new Map;o.set(s,{texture:null});const l=t.load(s,e=>{const t=o.get(s);t&&(t.texture=e),o.delete(s)},void 0,e=>{console.error(`❌ Failed to load moon color texture (${a}):`,e),o.delete(s)});o.set(r,{texture:null});const c=t.load(r,e=>{const t=o.get(r);t&&(t.texture=e),o.delete(r)},void 0,e=>{console.error(`❌ Failed to load moon normal map (${a}):`,e),o.delete(r)});l.wrapS=l.wrapT=e.RepeatWrapping,c.wrapS=c.wrapT=e.RepeatWrapping,l.anisotropy=16,c.anisotropy=16;const h=new e.MeshStandardMaterial({map:l,normalMap:c,normalScale:new e.Vector2(1.5,1.5),roughness:.7,metalness:0,emissive:new e.Color(.3,.3,.3),emissiveIntensity:.5,transparent:!1,side:e.FrontSide});return h.userData.pendingTextures=o,h}function ai(t=new e.Color(16777215),i=0){return new e.MeshStandardMaterial({color:15263976,roughness:.9,metalness:0,emissive:t,emissiveIntensity:i})}function ni(t,i={}){const a=i.resolution||"4k",n=i.glowColor||new e.Color(1,1,1),s=i.glowIntensity||1,r=i.shadowType||"crescent",o=i.assetBasePath||"/assets";let l,c;if(void 0!==i.shadowOffsetX)({shadowOffsetX:l}=i),c=void 0!==i.shadowOffsetY?i.shadowOffsetY:0;else if(void 0!==i.moonPhase){let e;"string"==typeof i.moonPhase?([e]=[Kt[i.moonPhase]],e||(console.warn(`Unknown moon phase: ${i.moonPhase}, using waxing-crescent`),e=Kt["waxing-crescent"])):e="number"==typeof i.moonPhase?Jt(i.moonPhase):Kt["waxing-crescent"],l=e.x,c=e.y}else{const e=Kt["waxing-crescent"];l=e.x,c=e.y}const h=void 0!==i.shadowCoverage?i.shadowCoverage:.85,u=`${o}/textures/Moon/moon-color-${a}.jpg`,d=`${o}/textures/Moon/moon-normal-${a}.jpg`,{vertexShader:m,fragmentShader:p}=function(e){return"crescent"===e||console.warn(`Unknown shadow type: ${e}, defaulting to crescent`),{vertexShader:"\n/**\n * Moon Crescent Vertex Shader\n * Passes world-space normal to fragment shader for realistic lighting\n */\n\nvarying vec3 vPosition; // LOCAL position\nvarying vec3 vWorldPosition;\nvarying vec3 vWorldNormal; // WORLD SPACE normal (rotates with moon)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n\n    // Transform normal to WORLD space (not view space)\n    // This makes the shadow rotate with the moon geometry\n    vWorldNormal = normalize(mat3(modelMatrix) * normal);\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPosition.xyz;\n    vec4 viewPosition = viewMatrix * worldPosition;\n    vViewPosition = viewPosition.xyz;\n    gl_Position = projectionMatrix * viewPosition;\n}\n",fragmentShader:"\n/**\n * Moon Crescent Fragment Shader\n *\n * Uses directional half-space test in WORLD SPACE to create realistic terminator:\n * - Light direction fixed in world space (like the sun)\n * - Normals rotate with moon geometry (in world space)\n * - dot(normal, lightDir) < 0 = shadow side\n * - dot(normal, lightDir) > 0 = lit side\n * - Smooth terminator with earthshine on dark side\n */\n\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec2 shadowOffset; // Controls light direction (x=horizontal, y=vertical)\nuniform float shadowCoverage; // Unused for directional shadow\nuniform float shadowSoftness; // Terminator edge softness (default: 0.05)\nuniform vec3 glowColor;\nuniform float glowIntensity;\nuniform float opacity; // Fade in opacity (0-1) to prevent gray flash during texture load\n\n// Lunar Eclipse (Blood Moon) uniforms\nuniform float eclipseProgress; // 0.0 = no eclipse, 1.0 = totality\nuniform float eclipseIntensity; // Darkening strength (0.0-1.0)\nuniform vec3 bloodMoonColor; // Deep reddish-orange for total eclipse\nuniform float blendMode; // 0=Multiply, 1=LinearBurn, 2=ColorBurn, 3=ColorDodge, 4=Screen, 5=Overlay\nuniform float blendStrength; // Blend strength multiplier (0.0-5.0)\nuniform float emissiveStrength; // Emissive glow strength (0.0-1.0)\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vWorldNormal; // WORLD SPACE normal (rotates with moon)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    // DIRECTIONAL SHADOW in WORLD SPACE - realistic moon phase lighting\n    // Light direction is fixed in world space, shadow rotates with moon\n\n    // Use world-space normal (rotates with moon geometry)\n    vec3 worldNormal = normalize(vWorldNormal);\n\n    // Light direction in WORLD SPACE\n    // shadowOffset.x controls horizontal angle (left/right)\n    // shadowOffset.y controls vertical angle (up/down)\n    // For thin crescents, we need extreme angles (light from the side or behind)\n\n    float lightX = shadowOffset.x;\n    float lightY = shadowOffset.y;\n\n    // Adaptive Z component with LOGARITHMIC scaling for wider angular range\n    // Goal: Spread phases across full 0° to 180° instead of plateauing at 135°\n    //\n    // Target angles after normalization:\n    // - Full moon (x=0): 0° (light from front)\n    // - Quarter moon (x=1): 90° (light from side)\n    // - Crescent (x=3): 120° (thin crescent)\n    // - New moon (x=10): 170° (nearly behind)\n\n    float offsetMagnitude = length(vec2(lightX, lightY));\n\n    // Use exponential decay for Z to spread angular range\n    // Formula: Z = 1.0 - offsetMagnitude^1.5 for better distribution\n    float lightZ = 1.0 - pow(offsetMagnitude, 1.5);\n\n    // Normalize the light direction vector\n    vec3 lightDir = normalize(vec3(lightX, lightY, lightZ));\n\n    // Calculate how much this fragment faces the light source\n    float facing = dot(worldNormal, lightDir);\n\n    // Smooth transition at terminator (shadow boundary)\n    // Softer edge for realistic lunar terminator (like real moon photography)\n    // Use fwidth() for automatic screen-space anti-aliasing\n    float edgeWidth = max(fwidth(facing) * 4.0, shadowSoftness * 3.0);\n    float shadowFactor = smoothstep(-edgeWidth, edgeWidth, facing);\n\n    // Sample moon surface texture\n    vec4 texColor = texture2D(colorMap, vUv);\n\n    // Fallback to gray if texture not loaded yet\n    float brightness = texColor.r + texColor.g + texColor.b;\n    if (brightness < 0.03) {\n        texColor = vec4(0.5, 0.5, 0.5, 1.0);\n    }\n\n    // LIMB DARKENING: Moon gets darker at edges (spherical falloff)\n    vec3 viewDir = normalize(-vViewPosition);\n    float rimFactor = dot(worldNormal, viewDir);\n    float limbDarkening = smoothstep(0.0, 0.6, rimFactor); // Subtle edge darkening\n\n    // DIFFUSE LIGHTING: Vary brightness across lit surface (not uniform)\n    // More realistic Lambertian diffuse reflection\n    float diffuse = max(facing, 0.0);\n    float diffuseLighting = mix(0.7, 1.0, diffuse); // Subtle variation\n\n    // EARTHSHINE: Almost invisible (~1% for ultimate realism)\n    vec3 earthshine = texColor.rgb * 0.01 * vec3(0.35, 0.4, 0.6);\n\n    // Apply dramatic shadow transition with maximum contrast\n    float litFactor = pow(shadowFactor, 2.0); // Maximum contrast\n\n    // TEXTURE ENHANCEMENT: Boost surface detail contrast\n    // Slightly darken dark areas, brighten bright areas of texture\n    vec3 detailEnhanced = texColor.rgb * 1.08; // Subtle boost\n    float textureLuminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));\n    detailEnhanced = mix(texColor.rgb * 0.95, texColor.rgb * 1.12, smoothstep(0.3, 0.7, textureLuminance));\n\n    // Combine enhanced texture with diffuse lighting\n    vec3 litColor = detailEnhanced * diffuseLighting;\n    vec3 shadowedColor = mix(earthshine, litColor, litFactor);\n\n    // Apply limb darkening (slightly stronger for more depth)\n    shadowedColor *= mix(0.6, 1.0, limbDarkening);\n\n    // Nearly zero emissive for pure realism\n    vec3 emissive = vec3(0.02, 0.02, 0.02) * shadowFactor;\n\n    // Emotion glow (almost invisible)\n    vec3 emotionGlow = glowColor * glowIntensity * 0.02 * shadowFactor;\n\n    // Combine all lighting components\n    vec3 finalColor = shadowedColor + emissive + emotionGlow;\n\n    // ═══════════════════════════════════════════════════════════════════════════\n    // LUNAR ECLIPSE (BLOOD MOON) EFFECT\n    // ═══════════════════════════════════════════════════════════════════════════\n    // Simulates Earth's umbral shadow with Rayleigh scattering (reddish glow)\n    if (eclipseProgress > 0.001) {\n        // Calculate gradient from lit edge to dark center\n        // Use rim factor (view angle) to create radial gradient\n        float gradientFactor = rimFactor; // 1.0 at edges, 0.0 at center\n\n        // Darken the moon (Earth's shadow)\n        float darkeningFactor = 1.0 - eclipseIntensity;\n        finalColor *= darkeningFactor;\n\n        // ═══════════════════════════════════════════════════════════════════\n        // PHOTOSHOP-STYLE BLEND MODES: Multiple modes for deep saturation control\n        // ═══════════════════════════════════════════════════════════════════\n\n        // Define blood moon gradient colors\n        vec3 deepRed = vec3(0.6, 0.2, 0.12);       // Dark burnt red-orange (center)\n        vec3 brightOrange = vec3(0.95, 0.45, 0.22); // Bright burnt orange (edges)\n\n        // Create radial gradient from center (dark) to edge (bright)\n        vec3 bloodGradient = mix(deepRed, brightOrange, pow(gradientFactor, 1.8));\n\n        // Apply blend strength multiplier\n        vec3 blendColor = bloodGradient * blendStrength;\n\n        // Calculate all blend modes\n        vec3 finalBlend;\n        int mode = int(blendMode + 0.5); // Round to nearest int\n\n        if (mode == 0) {\n            // MULTIPLY: base * blend\n            finalBlend = finalColor * blendColor;\n        } else if (mode == 1) {\n            // LINEAR BURN: base + blend - 1\n            finalBlend = max(finalColor + blendColor - vec3(1.0), vec3(0.0));\n        } else if (mode == 2) {\n            // COLOR BURN: (blend==0.0) ? 0.0 : max((1.0-((1.0-base)/blend)), 0.0)\n            finalBlend = vec3(\n                blendColor.r == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.r) / blendColor.r), 0.0),\n                blendColor.g == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.g) / blendColor.g), 0.0),\n                blendColor.b == 0.0 ? 0.0 : max(1.0 - ((1.0 - finalColor.b) / blendColor.b), 0.0)\n            );\n        } else if (mode == 3) {\n            // COLOR DODGE: (blend==1.0) ? 1.0 : min(base/(1.0-blend), 1.0)\n            finalBlend = vec3(\n                blendColor.r == 1.0 ? 1.0 : min(finalColor.r / (1.0 - blendColor.r), 1.0),\n                blendColor.g == 1.0 ? 1.0 : min(finalColor.g / (1.0 - blendColor.g), 1.0),\n                blendColor.b == 1.0 ? 1.0 : min(finalColor.b / (1.0 - blendColor.b), 1.0)\n            );\n        } else if (mode == 4) {\n            // SCREEN: 1 - (1 - base) * (1 - blend)\n            finalBlend = vec3(1.0) - (vec3(1.0) - finalColor) * (vec3(1.0) - blendColor);\n        } else {\n            // OVERLAY: base < 0.5 ? (2 * base * blend) : (1 - 2 * (1 - base) * (1 - blend))\n            finalBlend = vec3(\n                finalColor.r < 0.5 ? (2.0 * finalColor.r * blendColor.r) : (1.0 - 2.0 * (1.0 - finalColor.r) * (1.0 - blendColor.r)),\n                finalColor.g < 0.5 ? (2.0 * finalColor.g * blendColor.g) : (1.0 - 2.0 * (1.0 - finalColor.g) * (1.0 - blendColor.g)),\n                finalColor.b < 0.5 ? (2.0 * finalColor.b * blendColor.b) : (1.0 - 2.0 * (1.0 - finalColor.b) * (1.0 - blendColor.b))\n            );\n        }\n\n        // Apply blood moon effect\n        finalColor = mix(finalColor, finalBlend, eclipseProgress);\n\n        // Add emissive glow for visibility\n        finalColor += bloodGradient * emissiveStrength * eclipseProgress;\n\n        // Add bright rim glow during totality (refracted atmosphere light)\n        if (eclipseProgress > 0.7) {\n            float rimIntensity = pow(gradientFactor, 2.5); // Sharp falloff from edge\n            vec3 rimGlow = brightOrange * rimIntensity * (eclipseProgress - 0.7) * 2.5;\n            finalColor += rimGlow;\n        }\n    }\n\n    // Apply fade-in opacity to prevent gray flash during texture load\n    gl_FragColor = vec4(finalColor, opacity);\n}\n"}}(r),g=new e.ShaderMaterial({uniforms:{colorMap:{value:null},normalMap:{value:null},shadowOffset:{value:new e.Vector2(l,c)},shadowCoverage:{value:h},shadowSoftness:{value:.05},glowColor:{value:n},glowIntensity:{value:s},opacity:{value:0},eclipseProgress:{value:0},eclipseIntensity:{value:0},bloodMoonColor:{value:[.85,.18,.08]},blendMode:{value:0},blendStrength:{value:2},emissiveStrength:{value:.39},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:1.2},eclipseShadowColor:{value:[.85,.08,.02]},eclipseMidtoneColor:{value:[1,.12,.03]},eclipseHighlightColor:{value:[1,.35,.08]},eclipseGlowColor:{value:[1,.4,.1]}},vertexShader:m,fragmentShader:p,transparent:!0,side:e.FrontSide}),f=new Map;f.set(u,{texture:null});const y=t.load(u,e=>{g.uniforms.colorMap.value=e;const t=performance.now(),a=()=>{const e=performance.now()-t,i=Math.min(e/300,1);g.uniforms.opacity.value=i,g.needsUpdate=!0,i<1&&requestAnimationFrame(a)};a();const n=f.get(u);n&&(n.texture=e),f.delete(u),i.onTextureReady&&i.onTextureReady(g)},void 0,e=>{console.error("❌ Failed to load moon crescent color texture:",e),f.delete(u)});f.set(d,{texture:null});const v=t.load(d,e=>{g.uniforms.normalMap.value=e,g.needsUpdate=!0;const t=f.get(d);t&&(t.texture=e),f.delete(d)},void 0,e=>{console.error("❌ Failed to load moon crescent normal map:",e),f.delete(d)});return y.wrapS=y.wrapT=e.RepeatWrapping,v.wrapS=v.wrapT=e.RepeatWrapping,y.anisotropy=16,v.anisotropy=16,g.userData.pendingTextures=f,g}function si(e,t={}){return ni(e,{...t,shadowType:"crescent"})}function ri(e,t){if(!e.uniforms||!e.uniforms.shadowOffset)return console.warn("Material does not have shadowOffset uniform"),!1;let i;if("string"==typeof t){if(i=Kt[t],!i)return console.warn(`Unknown moon phase: ${t}`),!1}else{if("number"!=typeof t)return console.warn("Phase must be a string or number"),!1;i=Jt(t)}return e.uniforms.shadowOffset.value.set(i.x,i.y),!0}function oi(e,t,i=2e3){let a=null,n=!1;const s=new Promise((s,r)=>{if(!e.uniforms||!e.uniforms.shadowOffset)return void r(new Error("Material does not have shadowOffset uniform"));let o;if("string"==typeof t){if(o=Kt[t],!o)return void r(new Error(`Unknown moon phase: ${t}`))}else{if("number"!=typeof t)return void r(new Error("Phase must be a string or number"));o=Jt(t)}const l=e.uniforms.shadowOffset.value.x,c=e.uniforms.shadowOffset.value.y,h=o.x,u=o.y,d=Date.now(),m=()=>{if(n)return void s({cancelled:!0});const t=Date.now()-d,r=Math.min(t/i,1),o=r<.5?4*r*r*r:1-Math.pow(-2*r+2,3)/2,p=l+(h-l)*o,g=c+(u-c)*o;e.uniforms.shadowOffset.value.set(p,g),r<1?a=requestAnimationFrame(m):s({cancelled:!1})};m()});return{promise:s,cancel:()=>{n=!0,null!==a&&(cancelAnimationFrame(a),a=null)}}}function li(e,t,i){e.emissive&&(e.emissive.copy(t),e.emissiveIntensity=i),e.uniforms&&e.uniforms.glowColor&&(e.uniforms.glowColor.value.copy(t),e.uniforms.glowIntensity.value=i)}function ci(e,t,i,a){e.uniforms&&e.uniforms.shadowOffset&&(e.uniforms.shadowOffset.value.set(t,i),e.uniforms.shadowCoverage.value=a)}function hi(t,i={}){const{resolution:a="4k",glowColor:n=new e.Color(16777215),glowIntensity:s=1,assetBasePath:r="/assets"}=i,{vertexShader:o,fragmentShader:l}={vertexShader:"\n/**\n * Moon Vertex Shader\n * Passes view-space normal for camera-relative moon phase shadows\n */\n\nvarying vec3 vPosition; // LOCAL position (object space)\nvarying vec3 vWorldPosition;\nvarying vec3 vViewNormal; // VIEW SPACE normal (fixed relative to camera)\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n\n    // Transform normal to VIEW space (camera-relative)\n    // This keeps the moon phase shadow fixed relative to camera view\n    // When you rotate the moon, the texture rotates but the phase shadow stays put\n    vViewNormal = normalize(normalMatrix * normal);\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vWorldPosition = worldPosition.xyz;\n    vec4 viewPosition = viewMatrix * worldPosition;\n    vViewPosition = viewPosition.xyz;\n    gl_Position = projectionMatrix * viewPosition;\n}\n",fragmentShader:Ht},c=new e.ShaderMaterial({uniforms:{colorMap:{value:null},normalMap:{value:null},shadowOffset:{value:new e.Vector2(0,0)},shadowCoverage:{value:.5},shadowSoftness:{value:.05},glowColor:{value:n},glowIntensity:{value:s},opacity:{value:0},eclipseProgress:{value:0},eclipseIntensity:{value:0},bloodMoonColor:{value:[.85,.18,.08]},emissiveStrength:{value:.39},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:1.2},eclipseShadowColor:{value:[1,.58,0]},eclipseMidtoneColor:{value:[.71,.43,.03]},eclipseHighlightColor:{value:[1,.28,.1]},eclipseGlowColor:{value:[.09,.09,.09]},eclipseBrightnessModel:{value:0},shadowDarkness:{value:.53},layer1Mode:{value:9},layer1Strength:{value:.322},layer1Enabled:{value:1},layer2Mode:{value:0},layer2Strength:{value:2.785},layer2Enabled:{value:1},layer3Mode:{value:7},layer3Strength:{value:.199},layer3Enabled:{value:1},layer4Mode:{value:0},layer4Strength:{value:0},layer4Enabled:{value:0}},vertexShader:o,fragmentShader:l,transparent:!0,depthWrite:!0,side:e.FrontSide}),h=`${r}/textures/Moon/moon-color-${a}.jpg`,u=`${r}/textures/Moon/moon-normal-${a}.jpg`;return t.load(h,e=>{c.uniforms.colorMap.value=e;const t=performance.now(),a=()=>{const e=performance.now()-t,i=Math.min(e/300,1);c.uniforms.opacity.value=i,c.needsUpdate=!0,i<1&&requestAnimationFrame(a)};a(),i.onTextureReady&&i.onTextureReady(c)}),t.load(u,e=>{c.uniforms.normalMap.value=e}),c}const ui=`\n/**\n * Sun Fragment Shader with Blend Layers and Solar Eclipse\n *\n * Supports solar eclipse effects with moon's shadow darkening the sun\n * and up to 4 sequential blend mode layers for eclipse appearance adjustment\n */\n\nuniform float time;\nuniform sampler2D colorMap;\nuniform sampler2D normalMap;\nuniform vec3 baseColor;\nuniform float emissiveIntensity;\nuniform vec2 shadowOffset;\nuniform float shadowCoverage;\nuniform float shadowSoftness;\nuniform float opacity;\n\n// Solar Eclipse uniforms (moon's shadow covering sun)\nuniform float eclipseProgress;        // Eclipse progress (0 = no eclipse, 1 = totality)\nuniform vec2 eclipseShadowPos;        // Shadow center position in UV space\nuniform float eclipseShadowRadius;    // Moon's shadow radius\nuniform float shadowDarkness;         // How much to darken the sun (0-1)\n\n// Blend Layer Uniforms (up to 4 layers)\nuniform float layer1Mode;\nuniform float layer1Strength;\nuniform float layer1Enabled;\n\nuniform float layer2Mode;\nuniform float layer2Strength;\nuniform float layer2Enabled;\n\nuniform float layer3Mode;\nuniform float layer3Strength;\nuniform float layer3Enabled;\n\nuniform float layer4Mode;\nuniform float layer4Strength;\nuniform float layer4Enabled;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;  // View-space position (camera-relative)\n\n// ═══════════════════════════════════════════════════════════════════════════\n// UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n// ═══════════════════════════════════════════════════════════════════════════\n${jt}\n\n// ═══════════════════════════════════════════════════════════════════════════\n// SIMPLEX NOISE (for fire animation - from original sun shader)\n// ═══════════════════════════════════════════════════════════════════════════\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nvoid main() {\n    // ═══════════════════════════════════════════════════════════════════════════\n    // BASE SUN RENDERING (photosphere texture + fire animation)\n    // ═══════════════════════════════════════════════════════════════════════════\n\n    // Sample base photosphere texture\n    vec4 texColor = texture2D(colorMap, vUv);\n\n    // Optimized single-octave noise for subtle fire\n    vec3 noiseCoord = vPosition * 30.0 + vec3(0.0, time * 0.025, 0.0);\n    float fireNoise = snoise(noiseCoord);\n\n    // Simple threshold - fire appears only in specific noise ranges\n    float fireMask = fireNoise * 0.5 + 0.5; // Remap -1..1 to 0..1\n    fireMask = step(0.45, fireMask) * (1.0 - step(0.55, fireMask)); // Only 0.45-0.55 range\n\n    // Almost imperceptible warmth shift\n    vec3 fireColor = vec3(1.01, 1.0, 0.99);\n\n    // Microscopic blending\n    vec3 finalColor = mix(texColor.rgb, fireColor, fireMask * 0.008);\n\n    // Apply base color tinting\n    finalColor *= baseColor;\n\n    // Apply emissive intensity for HDR bloom\n    finalColor *= emissiveIntensity;\n\n    // ═══════════════════════════════════════════════════════════════════════════\n    // LIMB DARKENING (realistic solar effect - edges appear darker than center)\n    // ═══════════════════════════════════════════════════════════════════════════\n\n    // Calculate distance from center (0 at center, 1 at edge)\n    float distFromCenterLimb = length(vWorldPosition.xy) / 0.5; // normalize by sun radius (0.5)\n    distFromCenterLimb = clamp(distFromCenterLimb, 0.0, 1.0);\n\n    // Limb darkening formula: I(μ) = 1 - u*(1-μ) where μ = cos(viewing angle)\n    // Simplified using distance: darker at edges, brighter at center\n    float mu = sqrt(1.0 - distFromCenterLimb * distFromCenterLimb); // cos approximation\n    // EXTREME limb darkening for visibility\n    float limbDarkeningCoeff = 0.98; // 98% darkening at edges\n    float limbBrightness = 1.0 - limbDarkeningCoeff * (1.0 - mu);\n    limbBrightness = pow(limbBrightness, 0.4); // Very aggressive power curve\n\n    // Clamp to prevent over-darkening\n    limbBrightness = max(limbBrightness, 0.02); // Edges at least 2% brightness\n\n    // Apply limb darkening (BEFORE bloom processing)\n    finalColor *= limbBrightness;\n\n    // ═══════════════════════════════════════════════════════════════════════════\n    // SOLAR ECLIPSE EFFECT (Moon Occulting Sun)\n    // ═══════════════════════════════════════════════════════════════════════════\n    // Solar eclipse: Moon passes BETWEEN viewer and sun, blocking our view\n    // The moon appears as a dark circular disk that covers parts of the sun\n    // From Earth, moon and sun appear same angular size (0.5°)\n\n    // Only apply eclipse if there's a moon to occlude (radius > 0)\n    if (eclipseShadowRadius > 0.01) {\n        // Only occlude FRONT-FACING parts of the sun (vViewPosition.z < 0 faces camera in view space)\n        // Back of sun should not be affected by moon\n        if (vViewPosition.z < 0.1) {\n            // Project to screen space - camera-relative, independent of sun rotation\n            // vViewPosition.xy is already in camera space, just normalize to sun radius\n            // Sun radius in view space is approximately 0.5 at typical camera distance\n            vec2 screenPos = vViewPosition.xy;\n\n            // Moon center position in screen space (same coordinate system)\n            vec2 moonCenter = eclipseShadowPos;\n\n            // Distance from this sun point to moon center (2D screen space)\n            float distToMoon = length(screenPos - moonCenter);\n\n            // Moon's angular size (appears same size as sun from Earth)\n            // In normalized screen space, sun radius = 1.0, moon radius = 1.0 for total eclipse\n            float moonRadius = eclipseShadowRadius;\n            float moonEdge = 0.01; // Sharp edge for moon silhouette\n\n            // Check if moon blocks this point (moon is in front of sun)\n            float moonOcclusion = 1.0 - smoothstep(moonRadius - moonEdge, moonRadius + moonEdge, distToMoon);\n\n            // Only apply if moon is actually occluding something\n            if (moonOcclusion > 0.001) {\n                // Moon completely blocks sun where it overlaps (no light gets through)\n                finalColor *= (1.0 - moonOcclusion);\n\n                // Subtle penumbra around moon edge (diffraction)\n                float penumbraRadius = moonRadius * 1.02;\n                float penumbraEdge = 0.03;\n                float penumbra = 1.0 - smoothstep(penumbraRadius - penumbraEdge, penumbraRadius + penumbraEdge, distToMoon);\n                float penumbraBlocking = (penumbra - moonOcclusion) * 0.2;\n                finalColor *= (1.0 - penumbraBlocking);\n            }\n        }\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════\n    // BLEND LAYERS (Applied globally to entire sun)\n    // These allow adjusting the appearance of the sun\n    // ═══════════════════════════════════════════════════════════════════════════\n\n    // Layer 1\n    if (layer1Enabled > 0.5) {\n        vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n        int mode1 = int(layer1Mode + 0.5);\n        vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n        finalColor = clamp(blended1, 0.0, 1.0);\n    }\n\n    // Layer 2\n    if (layer2Enabled > 0.5) {\n        vec3 blendColor2 = vec3(min(layer2Strength, 1.0));\n        int mode2 = int(layer2Mode + 0.5);\n        vec3 blended2 = clamp(applyBlendMode(finalColor, blendColor2, mode2), 0.0, 1.0);\n        finalColor = clamp(blended2, 0.0, 1.0);\n    }\n\n    // Layer 3\n    if (layer3Enabled > 0.5) {\n        vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n        int mode3 = int(layer3Mode + 0.5);\n        vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n        finalColor = clamp(blended3, 0.0, 1.0);\n    }\n\n    // Layer 4\n    if (layer4Enabled > 0.5) {\n        vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n        int mode4 = int(layer4Mode + 0.5);\n        vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n        finalColor = clamp(blended4, 0.0, 1.0);\n    }\n\n    // Apply fade-in opacity to prevent texture flash during load\n    gl_FragColor = vec4(finalColor, opacity);\n}\n`,di={baseSpeed:.01,axes:[0,1,0]};function mi(t,i={}){const a=i.resolution||"4k",n=i.glowColor||[1,1,1],s=i.glowIntensity||1,r=i.materialVariant||null,o=i.assetBasePath||"/assets",l=`${o}/textures/Sun/sun-photosphere-${a}.jpg`,c=`${o}/textures/Sun/sun-photosphere-normal-${a}.jpg`,h=1+2*s,u=new e.Color(h*n[0],h*n[1],h*n[2]*.95),d=new Map;d.set(l,{texture:null});const m=t.load(l,e=>{v.uniforms?.opacity&&(v.uniforms.opacity.value=1);const t=d.get(l);t&&(t.texture=e),d.delete(l)},void 0,e=>{console.warn(`⚠️ Failed to load sun texture (${a}), using color fallback:`,e),d.delete(l)});d.set(c,{texture:null});const p=t.load(c,e=>{const t=d.get(c);t&&(t.texture=e),d.delete(c)},void 0,e=>{console.warn(`⚠️ Sun normal map not found (${a}), continuing without surface detail:`,e),d.delete(c)});let g,f;m.wrapS=m.wrapT=e.RepeatWrapping,p.wrapS=p.wrapT=e.RepeatWrapping,m.anisotropy=16,p.anisotropy=16;let y={};if("multiplexer"===r){const{vertexShader:e,fragmentShader:t}={vertexShader:"\n/**\n * Sun Vertex Shader\n * Passes view-space position for camera-relative eclipse shadow calculations\n */\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;  // View-space position (camera-relative)\n\nvoid main() {\n    vUv = uv;\n    vNormal = normalize(normalMatrix * normal);\n    vPosition = position;\n    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\n    // Calculate view-space position (camera-relative, always faces camera)\n    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n    vViewPosition = viewPos.xyz;\n\n    gl_Position = projectionMatrix * viewPos;\n}\n",fragmentShader:ui};g=e,f=t,y={eclipseProgress:{value:0},eclipseShadowPos:{value:[-2,0]},eclipseShadowRadius:{value:.882},shadowDarkness:{value:1},layer1Mode:{value:0},layer1Strength:{value:.23},layer1Enabled:{value:1},layer2Mode:{value:0},layer2Strength:{value:0},layer2Enabled:{value:0},layer3Mode:{value:0},layer3Strength:{value:0},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:0},layer4Enabled:{value:0}}}else g="\n            varying vec2 vUv;\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n\n            void main() {\n                vUv = uv;\n                vNormal = normalize(normalMatrix * normal);\n                vPosition = position;\n                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",f="\n            uniform float time;\n            uniform sampler2D colorMap;\n            uniform sampler2D normalMap;\n            uniform vec3 baseColor;\n            uniform float emissiveIntensity;\n            uniform vec2 shadowOffset;\n            uniform float shadowCoverage;\n            uniform float shadowSoftness;\n            uniform float opacity;  // Fade in opacity (0-1) to prevent texture flash\n\n            varying vec2 vUv;\n            varying vec3 vNormal;\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n\n            // Simplex noise for fire animation (Ashima Arts)\n            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n            float snoise(vec3 v) {\n                const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n                vec3 i  = floor(v + dot(v, C.yyy));\n                vec3 x0 = v - i + dot(i, C.xxx);\n\n                vec3 g = step(x0.yzx, x0.xyz);\n                vec3 l = 1.0 - g;\n                vec3 i1 = min(g.xyz, l.zxy);\n                vec3 i2 = max(g.xyz, l.zxy);\n\n                vec3 x1 = x0 - i1 + C.xxx;\n                vec3 x2 = x0 - i2 + C.yyy;\n                vec3 x3 = x0 - D.yyy;\n\n                i = mod289(i);\n                vec4 p = permute(permute(permute(\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n                float n_ = 0.142857142857;\n                vec3 ns = n_ * D.wyz - D.xzx;\n\n                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n                vec4 x_ = floor(j * ns.z);\n                vec4 y_ = floor(j - 7.0 * x_);\n\n                vec4 x = x_ *ns.x + ns.yyyy;\n                vec4 y = y_ *ns.x + ns.yyyy;\n                vec4 h = 1.0 - abs(x) - abs(y);\n\n                vec4 b0 = vec4(x.xy, y.xy);\n                vec4 b1 = vec4(x.zw, y.zw);\n\n                vec4 s0 = floor(b0)*2.0 + 1.0;\n                vec4 s1 = floor(b1)*2.0 + 1.0;\n                vec4 sh = -step(h, vec4(0.0));\n\n                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n                vec3 p0 = vec3(a0.xy, h.x);\n                vec3 p1 = vec3(a0.zw, h.y);\n                vec3 p2 = vec3(a1.xy, h.z);\n                vec3 p3 = vec3(a1.zw, h.w);\n\n                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n                p0 *= norm.x;\n                p1 *= norm.y;\n                p2 *= norm.z;\n                p3 *= norm.w;\n\n                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n                m = m * m;\n                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n            }\n\n            void main() {\n                // Sample base photosphere texture\n                vec4 texColor = texture2D(colorMap, vUv);\n\n                // Optimized single-octave noise for subtle fire (was 2 FBM calls with 3 octaves each)\n                // Using position-based noise with time offset for animation\n                vec3 noiseCoord = vPosition * 30.0 + vec3(0.0, time * 0.025, 0.0);\n                float fireNoise = snoise(noiseCoord);\n\n                // Simple threshold - fire appears only in specific noise ranges\n                // Using step functions instead of smoothstep for performance\n                float fireMask = fireNoise * 0.5 + 0.5; // Remap -1..1 to 0..1\n                fireMask = step(0.45, fireMask) * (1.0 - step(0.55, fireMask)); // Only 0.45-0.55 range\n\n                // Almost imperceptible warmth shift (same visual as before)\n                vec3 fireColor = vec3(1.01, 1.0, 0.99);\n\n                // Microscopic blending - nearly invisible (same blend factor)\n                vec3 finalColor = mix(texColor.rgb, fireColor, fireMask * 0.008);\n\n                // Apply base color tinting\n                finalColor *= baseColor;\n\n                // Apply emissive intensity for HDR bloom\n                finalColor *= emissiveIntensity;\n\n                // ═══════════════════════════════════════════════════════════════════════════\n                // LIMB DARKENING (realistic solar effect - edges appear darker than center)\n                // ═══════════════════════════════════════════════════════════════════════════\n\n                // Calculate distance from center (0 at center, 1 at edge)\n                float distFromCenterLimb = length(vWorldPosition.xy) / 0.5; // normalize by sun radius (0.5)\n                distFromCenterLimb = clamp(distFromCenterLimb, 0.0, 1.0);\n\n                // Limb darkening formula: I(μ) = 1 - u*(1-μ) where μ = cos(viewing angle)\n                // Simplified using distance: darker at edges, brighter at center\n                float mu = sqrt(1.0 - distFromCenterLimb * distFromCenterLimb); // cos approximation\n                float limbDarkeningCoeff = 0.6; // NASA solar data: ~60% darkening at limb\n                float limbBrightness = 1.0 - limbDarkeningCoeff * (1.0 - mu);\n\n                // Apply limb darkening (preserves bright core for bloom)\n                finalColor *= limbBrightness;\n\n                // ═══════════════════════════════════════════════════════════════════════════\n                // SHADOW DARKENING (applied AFTER bloom intensity so it doesn't affect bloom)\n                // ═══════════════════════════════════════════════════════════════════════════\n\n                // Sun sphere center (world space origin)\n                float sunRadius = 0.5; // Matches geometry radius\n\n                // Shadow sphere center (offset from sun center)\n                vec3 shadowCenter = vec3(shadowOffset.x, shadowOffset.y, 0.0);\n\n                // Calculate distance from fragment to shadow sphere center\n                float distToShadow = distance(vWorldPosition, shadowCenter);\n\n                // Shadow threshold (shadow sphere radius adjusted by coverage)\n                float shadowRadius = sunRadius * shadowCoverage;\n\n                // Calculate shadow factor (0 = full shadow, 1 = no shadow)\n                float shadowFactor = smoothstep(shadowRadius - shadowSoftness, shadowRadius + shadowSoftness, distToShadow);\n\n                // Darken ONLY the final color output (not the bloom calculation)\n                float shadowDarkness = 0.05; // How dark the shadow gets (5% brightness)\n                finalColor *= mix(shadowDarkness, 1.0, shadowFactor);\n\n                // ═══════════════════════════════════════════════════════════════════════════\n                // RADIAL CORONA WAVES (applied AFTER shadow, visible around eclipse edge)\n                // ═══════════════════════════════════════════════════════════════════════════\n\n                // Calculate angle from sun center in world space XY plane\n                float angle = atan(vWorldPosition.y, vWorldPosition.x);\n\n                // Create radial wave pattern (16 petals for finer detail, rotating slowly)\n                float wave = sin(angle * 16.0 + time * 0.3) * 0.5 + 0.5;\n\n                // Apply waves to visible (non-shadowed) edges\n                float distFromCenter = length(vWorldPosition.xy);\n\n                // Edge factor: strong at sun's edge where bloom will amplify it\n                float edgeFactor = smoothstep(0.35, 0.5, distFromCenter);\n\n                // Only apply waves to non-shadowed areas (visible during eclipse)\n                // Combine with shadow factor so waves appear around shadow edge\n                float waveStrength = edgeFactor * shadowFactor;\n\n                // Very strong modulation (2x variation) for dramatic eclipse corona\n                float coronaModulation = 1.0 + (wave * 2.0 - 1.0) * waveStrength;\n                finalColor *= coronaModulation;\n\n                // Apply fade-in opacity to prevent texture flash during load\n                gl_FragColor = vec4(finalColor, opacity);\n            }\n        ";const v=new e.ShaderMaterial({uniforms:{time:{value:0},colorMap:{value:m},normalMap:{value:p},baseColor:{value:u},emissiveIntensity:{value:1.2},glowColor:{value:new e.Color(1,1,1)},glowIntensity:{value:1},shadowOffset:{value:new e.Vector2(200,0)},shadowCoverage:{value:.5},shadowSoftness:{value:.1},opacity:{value:0},...y},vertexShader:g,fragmentShader:f,transparent:!0,toneMapped:!1});return v.userData.uniforms=v.uniforms,v.userData.pendingTextures=d,v}function pi(t=null,i={}){const a=i.glowColor||[1,1,1],n=i.glowIntensity||1,s=i.resolution||"4k",r=i.materialVariant||null,o=new e.SphereGeometry(.5,128,128);let l;if(o.userData.tracked=!0,t)l=mi(t,{glowColor:a,glowIntensity:n,resolution:s,materialVariant:r});else{const t=1+2*n,i=new e.Color(t*a[0],t*a[1],t*a[2]*.95);l=new e.MeshBasicMaterial({color:i,toneMapped:!1})}const c=new e.Mesh(o,l);return c.castShadow=!1,c.receiveShadow=!1,c}function gi(e,t,i=1,a=0){if(!e||!e.material)return;const{material:n}=e;if(n.uniforms&&n.uniforms.baseColor){const{uniforms:e}=n;a>0&&(e.time.value=(e.time.value+a)%(2*Math.PI));const t=1+2*i;e.baseColor.value.setRGB(t,t,.95*t),e.emissiveIntensity.value=1.2}else if(n.color){const e=1+2*i;n.color.setRGB(e,e,.95*e)}}function fi(e){if(e&&(e.geometry&&e.geometry.dispose(),e.material)){const{material:t}=e;t.userData&&t.userData.pendingTextures&&(t.userData.pendingTextures.forEach(({texture:e})=>{e&&e.dispose()}),t.userData.pendingTextures.clear()),t.uniforms&&(t.uniforms.colorMap&&t.uniforms.colorMap.value&&t.uniforms.colorMap.value.dispose(),t.uniforms.normalMap&&t.uniforms.normalMap.value&&t.uniforms.normalMap.value.dispose()),t.map&&t.map.dispose(),t.normalMap&&t.normalMap.dispose(),t.dispose()}}function yi(){const t=new e.SphereGeometry(.5,32,32),i=t.attributes.position;for(let e=0;e<i.count;e++){let t=i.getX(e);const a=i.getY(e);let n=i.getZ(e);const s=1+.3*Math.max(0,a);if(t*=s,n*=.8*s,a<-.3){const e=(-a-.3)/.2;t*=1-.8*e,n*=1-.8*e}i.setXYZ(e,t,a,n)}return t.computeVertexNormals(),t}function vi(){const t=new e.DodecahedronGeometry(.5,0);return t.computeVertexNormals(),t}function bi(){const t=new e.BufferGeometry,i=[],a=[];i.push(0,2.3,0);for(let e=0;e<6;e++){const t=e/6*Math.PI*2;i.push(1*Math.cos(t),1.5,1*Math.sin(t))}for(let e=0;e<6;e++){const t=e/6*Math.PI*2;i.push(1*Math.cos(t),-1.5,1*Math.sin(t))}i.push(0,-2.3,0);for(let e=0;e<6;e++){const t=(e+1)%6;a.push(0,1+e,1+t)}for(let e=0;e<6;e++){const t=(e+1)%6;a.push(1+e,7+e,1+t),a.push(1+t,7+e,7+t)}for(let e=0;e<6;e++){const t=(e+1)%6;a.push(13,7+t,7+e)}t.setAttribute("position",new e.Float32BufferAttribute(i,3)),t.setIndex(a);const n=1.6/4.6;return t.scale(n,n,n),t.computeVertexNormals(),t}const wi={moon:{geometry:ei(64,64),material:"custom",blink:{type:"gentle-pulse",duration:180,scaleAxis:[.95,.95,.95],glowBoost:.2,curve:"sine"},particleRadiusMultiplier:1.4},sun:{geometry:new e.SphereGeometry(.5,64,64),material:"emissive",blink:{type:"radial-pulse",duration:200,scaleAxis:[1.05,1.05,1.05],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.5},crystal:{geometry:null,geometryLoader:function(t="/assets"){return new Promise((i,a)=>{(new Vt).load(`${t}/models/Crystal/crystal.obj`,t=>{let a=null;if(t.traverse(e=>{e.isMesh&&e.geometry&&({geometry:a}=e)}),a){a.computeBoundingBox();const t=new e.Vector3;a.boundingBox.getCenter(t),a.translate(-t.x,-t.y,-t.z);const n=new e.Vector3;a.boundingBox.getSize(n);const s=1.6/Math.max(n.x,n.y,n.z);a.scale(s,s,s),a.attributes.normal||a.computeVertexNormals(),a.computeBoundingBox();const r=new e.Vector3;a.boundingBox.getSize(r);let o=a;o.computeVertexNormals(),i(o)}else{console.warn("💎 [CRYSTAL] No mesh in OBJ, using fallback");const e=bi();i(e)}},e=>{},e=>{console.warn("💎 [CRYSTAL] OBJ load FAILED:",e);const t=bi();i(t)})})},material:"custom",blink:{type:"facet-flash",duration:160,scaleAxis:[.95,.95,.95],glowBoost:.4,curve:"sine"},particleRadiusMultiplier:1.4},rough:{geometry:null,geometryLoader:function(t="/assets"){return new Promise(i=>{(new Vt).load(`${t}/models/Crystal/rough.obj`,t=>{let a=null;if(t.traverse(e=>{e.isMesh&&e.geometry&&({geometry:a}=e)}),a){a.computeBoundingBox();const t=new e.Vector3;a.boundingBox.getCenter(t),a.translate(-t.x,-t.y,-t.z);const n=new e.Vector3;a.boundingBox.getSize(n);const s=1.6/Math.max(n.x,n.y,n.z);a.scale(s,s,s),a.computeVertexNormals(),a.computeBoundingBox(),i(a)}else console.warn("💎 [ROUGH] No mesh in OBJ, using fallback sphere"),i(new e.SphereGeometry(.5,32,32))},void 0,t=>{console.warn("💎 [ROUGH] OBJ load failed:",t),i(new e.SphereGeometry(.5,32,32))})})},material:"custom",blink:{type:"facet-flash",duration:150,scaleAxis:[.95,.95,.95],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.3},heart:{geometry:null,geometryLoader:function(t="/assets"){return new Promise(i=>{(new Vt).load(`${t}/models/Crystal/heart.obj`,t=>{let a=null;if(t.traverse(e=>{e.isMesh&&e.geometry&&({geometry:a}=e)}),a){a.computeBoundingBox();const t=new e.Vector3;a.boundingBox.getCenter(t),a.translate(-t.x,-t.y,-t.z);const n=new e.Vector3;a.boundingBox.getSize(n);const s=1.2/Math.max(n.x,n.y,n.z);a.scale(s,s,s),a.computeVertexNormals(),a.computeBoundingBox(),a.attributes.uv||function(t){t.computeBoundingBox();const i=t.boundingBox,a=t.attributes.position,n=new Float32Array(2*a.count),s=i.max.x-i.min.x,r=i.max.y-i.min.y;for(let e=0;e<a.count;e++){const t=a.getX(e),o=a.getY(e);n[2*e]=(t-i.min.x)/s,n[2*e+1]=(o-i.min.y)/r}t.setAttribute("uv",new e.BufferAttribute(n,2))}(a),i(a)}else console.warn("💗 [HEART] No mesh in OBJ, using fallback"),i(yi())},void 0,e=>{console.warn("💗 [HEART] OBJ load failed:",e),i(yi())})})},material:"custom",blink:{type:"gentle-pulse",duration:180,scaleAxis:[.92,.92,.92],glowBoost:.6,curve:"sine"},particleRadiusMultiplier:1.3},star:{geometry:null,geometryLoader:function(t="/assets"){return new Promise(i=>{(new Vt).load(`${t}/models/Crystal/star.obj`,t=>{let a=null;if(t.traverse(e=>{e.isMesh&&e.geometry&&({geometry:a}=e)}),a){a.computeBoundingBox();const t=new e.Vector3;a.boundingBox.getCenter(t),a.translate(-t.x,-t.y,-t.z);const n=new e.Vector3;a.boundingBox.getSize(n);const s=1.4/Math.max(n.x,n.y,n.z);a.scale(s,s,s),a.computeVertexNormals(),a.computeBoundingBox(),a.attributes.uv||function(t){t.computeBoundingBox();const i=t.boundingBox,a=t.attributes.position,n=new Float32Array(2*a.count),s=i.max.x-i.min.x,r=i.max.y-i.min.y;for(let e=0;e<a.count;e++){const t=a.getX(e),o=a.getY(e);n[2*e]=(t-i.min.x)/s,n[2*e+1]=(o-i.min.y)/r}t.setAttribute("uv",new e.BufferAttribute(n,2))}(a),i(a)}else console.warn("⭐ [STAR] No mesh in OBJ, using fallback"),i(vi())},void 0,e=>{console.warn("⭐ [STAR] OBJ load failed:",e),i(vi())})})},material:"custom",blink:{type:"facet-flash",duration:150,scaleAxis:[.93,.93,.93],glowBoost:.5,curve:"sine"},particleRadiusMultiplier:1.4}};class Mi{constructor(){this.currentAnimation=null,this.animations=[],this.time=0}playEmotion(e,t={}){const i=this.createEmotionAnimation(e);this.startAnimation(i,t)}playGesture(e,t={}){const i=this.createGestureAnimation(e);this.startAnimation(i,t)}playMorph(e,t,i={}){const a=this.createMorphAnimation(e,t);this.startAnimation(a,i)}update(e){this.time+=e;for(let e=this.animations.length-1;e>=0;e--){const t=this.animations[e],i=t.duration;Math.min((this.time-t.startTime)/i,1)>=1&&(t.callbacks&&t.callbacks.onComplete&&t.callbacks.onComplete(),this.animations.splice(e,1))}}createEmotionAnimation(e){const t={joy:{duration:.6,evaluate:e=>({scale:1+.15*Math.sin(e*Math.PI),glowIntensity:1+.15*Math.sin(e*Math.PI)})},love:{duration:1.2,evaluate:e=>({scale:1+.08*Math.sin(e*Math.PI*2),glowIntensity:1+.1*Math.sin(e*Math.PI*2)})},curiosity:{duration:.8,evaluate:e=>({rotation:[0,.1*Math.sin(e*Math.PI*4),0],scale:1+.05*Math.sin(e*Math.PI),glowIntensity:1})},sadness:{duration:1.5,evaluate:e=>({scale:1-.1*e,glowIntensity:1-.15*Math.sin(e*Math.PI)})},anger:{duration:.4,evaluate:e=>{const t=.15*Math.sin(e*Math.PI*8);return{rotation:[t,t,0],scale:1.1+.1*Math.sin(e*Math.PI),glowIntensity:1+.15*Math.sin(e*Math.PI*8)}}},fear:{duration:.5,evaluate:e=>{const t=.08*Math.sin(e*Math.PI*10);return{scale:.9+t,rotation:[t,0,t],glowIntensity:1+.1*Math.sin(e*Math.PI*10)}}},surprise:{duration:.4,evaluate:e=>({scale:1+.25*(1-Math.cos(e*Math.PI)),glowIntensity:1+.2*(1-Math.cos(e*Math.PI))})},neutral:{duration:.5,evaluate:e=>({scale:1,glowIntensity:1})}};return t[e]||t.neutral}createGestureAnimation(e){const t={pop:{duration:.2,isAccent:!0,evaluate:e=>({scaleBoost:1+.025*Math.sin(e*Math.PI)})},bob:{duration:.25,isAccent:!0,evaluate:e=>({rotationBoost:[.025*Math.sin(e*Math.PI),0,0]})},swell:{duration:.6,isAccent:!0,evaluate:e=>{const t=Math.sin(e*Math.PI),i=1-Math.pow(1-t,2);return{scaleBoost:1+.04*i,glowBoost:.3*i}}},swagger:{duration:.4,isAccent:!0,evaluate:e=>{const t=Math.sin(e*Math.PI);return{rotationBoost:[0,0,.04*t],positionBoost:[.01*t,0,0]}}},dip:{duration:.25,isAccent:!0,evaluate:e=>{const t=Math.sin(e*Math.PI);return{positionBoost:[0,.015*-t,0],scaleBoost:1-.015*t}}},flare:{duration:.3,isAccent:!0,evaluate:e=>{const t=Math.sin(e*Math.PI);return{scaleBoost:1+.03*t,glowBoost:.25*t}}},bounce:{duration:1,evaluate:e=>{const t=e*Math.PI*2,i=1-.6*e,a=Math.sin(t)*i,n=Math.sin(2*t)*i*.3,s=Math.max(0,a+n);return{position:[0,.35*s,0],scale:s>.5?1+.05*s:1-.08*s}}},pulse:{duration:.6,evaluate:e=>{const t=Math.sin(e*Math.PI);return{scale:1+.2*t,glowIntensity:1+.5*t}}},spin:{duration:1,evaluate:e=>({rotation:[0,e*Math.PI*2,0]})},wobble:{duration:1,evaluate:e=>{const t=Math.sin(e*Math.PI*3);return{rotation:[.3*t,0,.2*t]}}},float:{duration:2,evaluate:e=>({position:[0,.3*Math.sin(e*Math.PI),0]})},shake:{duration:.5,evaluate:e=>{const t=Math.sin(e*Math.PI*6)*(1-e);return{position:[.2*t,0,0],rotation:[0,0,.1*t]}}},nod:{duration:.5,evaluate:e=>{let t=0;if(e<.4){const i=e/.4;t=.12*Math.sin(i*Math.PI)}else if(e<.8){const i=(e-.4)/.4;t=.07*Math.sin(i*Math.PI)}return{cameraRelativePosition:[0,0,t],scale:1-.3*Math.abs(t),glowIntensity:1+.5*Math.abs(t)}}},wiggle:{duration:.4,evaluate:e=>{const t=Math.pow(1-e,.6),i=Math.sin(e*Math.PI*12)*t;return{cameraRelativePosition:[.04*i,0,0],scale:1+.03*Math.abs(i),glowIntensity:1+.1*Math.abs(i)}}},headBob:{duration:.3,evaluate:e=>{const t=e<.15?e/.15:Math.pow(1-(e-.15)/.85,2);return{cameraRelativePosition:[0,0,.08*t],position:[0,.015*-t,0],scale:1-.05*t,glowIntensity:1+.15*t}}},sway:{duration:1.2,evaluate:e=>{const t=e<.15?e/.15*e/.15:e>.85?Math.pow((1-e)/.15,2):1,i=Math.sin(e*Math.PI*2)*t;return{rotation:[0,0,.12*i],position:[.06*i,0,0]}}},jump:{duration:.6,evaluate:e=>({position:[0,.4*Math.sin(e*Math.PI),0],scale:e<.1?1-3*e:e>.9?1-3*(1-e):1})},twist:{duration:.5,evaluate:e=>({rotation:[0,Math.sin(e*Math.PI*2)*(1-.5*e)*.3,0]})},hula:{duration:1,evaluate:e=>{const t=e*Math.PI*2;return{position:[.05*Math.sin(t),0,.03*Math.cos(t)],rotation:[0,0,.05*Math.sin(t)]}}},lean:{duration:.6,evaluate:e=>{const t=Math.sin(e*Math.PI);return{rotation:[0,0,.15*t],position:[.04*t,.01*-Math.abs(t),0]}}},tilt:{duration:.5,evaluate:e=>{const t=Math.sin(e*Math.PI);return{position:[0,0,.05*t],rotation:[.08*t,0,0]}}},twitch:{duration:.2,evaluate:e=>{const t=(1-e)*Math.sin(e*Math.PI*6);return{rotation:[.03*t,.03*t,0]}}},flash:{duration:.3,evaluate:e=>{const t=e<.2?e/.2:1-(e-.2)/.8;return{glowIntensity:1+.4*t,scale:1+.03*t}}},glow:{duration:.8,evaluate:e=>{const t=Math.sin(e*Math.PI);return{glowIntensity:1+.25*t,scale:1+.02*t}}},burst:{duration:.6,evaluate:e=>{let t=0,i=1,a=1;if(e<.15){const n=e/.15,s=1-Math.pow(1-n,3);t=.15*s,i=1+.2*s,a=1+.5*s}else if(e<.35){const n=(e-.15)/.2;t=.15*(1-1.5*n),i=1+.2*(1-n)-.1*Math.sin(n*Math.PI),a=1+.4*(1-n)}else{const n=(e-.35)/.65,s=Math.pow(1-n,2),r=Math.sin(n*Math.PI*2)*s;t=.03*r,i=1+.05*r,a=1+.15*Math.abs(r)}return{cameraRelativePosition:[0,0,t],scale:i,glowIntensity:a}}},flicker:{duration:.6,evaluate:e=>{const t=Math.sin(e*Math.PI),i=Math.sin(e*Math.PI*4)*t;return{glowIntensity:1+.15*i,scale:1+.01*i}}}};return t[e]||t.pulse}createMorphAnimation(e,t){return{duration:1,fromShape:e,toShape:t,evaluate:e=>({morphProgress:e,scale:1+.1*Math.sin(e*Math.PI),rotation:[0,e*Math.PI*.5,0]})}}startAnimation(e,t){this.animations.push({...e,startTime:this.time,callbacks:t||{}}),this.currentAnimation=e}stopAll(){this.animations=[],this.currentAnimation=null}stopEmotions(){this.animations=this.animations.filter(e=>e.gestureName),this.currentAnimation=null}destroy(){this.stopAll(),this.animations=null,this.currentAnimation=null,this.time=0}easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}getIdleAnimation(){return{duration:3,loop:!0,evaluate:e=>{const t=Math.sin(e*Math.PI*2),i=Math.sin(e*Math.PI);return{scale:1+.02*t,position:[.05*i,.03*t,0],rotation:[0,.05*i,0],glowIntensity:1+.1*t}}}}isPlaying(){return this.animations.length>0}}class Si{constructor(){this.breathingSpeed=1,this.breathingDepth=.03,this.breathingPhase=0,this.breathRate=1,this.breathDepth=.03,this.breathRateMult=1,this.breathDepthMult=1,this.rhythmAdapter=null,this.grooveBlendFactor=.4,this.emotionBreathPatterns={happy:{rate:1.1,depth:1.2},sad:{rate:.8,depth:.7},angry:{rate:1.4,depth:1.3},calm:{rate:.7,depth:.9},excited:{rate:1.5,depth:1.4},focused:{rate:.9,depth:.6},neutral:{rate:1,depth:1},love:{rate:1.2,depth:1.3},surprised:{rate:1.3,depth:1.1},confused:{rate:1.1,depth:.9},amused:{rate:1.2,depth:1.1},bored:{rate:.6,depth:.8},tired:{rate:.5,depth:1.2},anxious:{rate:1.6,depth:.9},determined:{rate:1.1,depth:1},proud:{rate:.9,depth:1.3},content:{rate:.8,depth:1},hopeful:{rate:1,depth:1.1},zen:{rate:.4,depth:1.5},intrigued:{rate:1.1,depth:.8},embarrassed:{rate:1.3,depth:.7},grateful:{rate:.9,depth:1.1},inspired:{rate:1,depth:1.3},silly:{rate:1.4,depth:1.2},sleepy:{rate:.3,depth:1.4}}}update(e,t,i=null){const a=this.emotionBreathPatterns[t]||{rate:1,depth:1};i&&i["3d"]&&i["3d"].scale?(this.breathRateMult=i["3d"].scale.breathRateMultiplier||1,this.breathDepthMult=i["3d"].scale.breathDepthMultiplier||1):(this.breathRateMult=1,this.breathDepthMult=1),this.breathRate=a.rate*this.breathRateMult,this.breathDepth=this.breathingDepth*a.depth*this.breathDepthMult;const n=this.breathingSpeed*this.breathRate*(e/1e3);this.breathingPhase+=n,this.breathingPhase>2*Math.PI&&(this.breathingPhase-=2*Math.PI)}setRhythmAdapter(e){this.rhythmAdapter=e}getBreathingScale(){const e=this.rhythmAdapter?.isPlaying?.()?this.grooveBlendFactor:1;return 1+Math.sin(this.breathingPhase)*this.breathDepth*e}setEmotion(e,t=null){const i=this.emotionBreathPatterns[e]||{rate:1,depth:1};t&&t["3d"]&&t["3d"].scale?(this.breathRateMult=t["3d"].scale.breathRateMultiplier||1,this.breathDepthMult=t["3d"].scale.breathDepthMultiplier||1):(this.breathRateMult=1,this.breathDepthMult=1),this.breathRate=i.rate*this.breathRateMult,this.breathDepth=this.breathingDepth*i.depth*this.breathDepthMult}reset(){this.breathingPhase=0,this.breathRate=1,this.breathDepth=this.breathingDepth,this.breathRateMult=1,this.breathDepthMult=1}getBreathingInfo(){return{phase:this.breathingPhase,rate:this.breathRate,depth:this.breathDepth,scale:this.getBreathingScale(),rateMult:this.breathRateMult,depthMult:this.breathDepthMult}}destroy(){this.emotionBreathPatterns=null,this.rhythmAdapter=null}}class xi{constructor(){this.tempEuler=new e.Euler,this.tempQuat=new e.Quaternion,this.accumulatedRotationQuat=new e.Quaternion,this.finalQuaternion=new e.Quaternion,this.prevRotation=[0,0,0],this.hasValidPrevRotation=!1,this._crackTriggeredAnimations=new Set,this._accumulated={position:[0,0,0],rotationQuat:this.accumulatedRotationQuat,scale:1,nonUniformScale:[1,1,1],glowIntensity:1,glowBoost:0,glowColorOverride:null,electricOverlay:null,waterOverlay:null,fireOverlay:null,smokeOverlay:null,voidOverlay:null,iceOverlay:null,lightOverlay:null,poisonOverlay:null,earthOverlay:null,natureOverlay:null,meshOpacity:1,cameraRelativePosition:[0,0,0],cameraRelativeRotation:[0,0,0],positionBoost:[0,0,0],rotationBoost:[0,0,0],scaleBoost:1,hasAccentGestures:!1,hasAbsoluteGestures:!1,hasCameraRelativeGestures:!1,freezeRotation:0,freezeWobble:0,freezeGroove:0,freezeParticles:0,deformation:null,shatter:null,crack:null,crackTriggers:null,crackHealTrigger:!1,crackHealDuration:1500},this._result={position:null,rotation:[0,0,0],scale:1,nonUniformScale:null,glowIntensity:1,glowBoost:0,glowColorOverride:null,electricOverlay:null,waterOverlay:null,fireOverlay:null,smokeOverlay:null,voidOverlay:null,iceOverlay:null,lightOverlay:null,poisonOverlay:null,earthOverlay:null,natureOverlay:null,meshOpacity:1,cameraRelativePosition:null,cameraRelativeRotation:null,positionBoost:null,rotationBoost:null,scaleBoost:1,hasAccentGestures:!1,hasAbsoluteGestures:!1,hasCameraRelativeGestures:!1,freezeRotation:0,freezeWobble:0,freezeGroove:0,freezeParticles:0,deformation:null,shatter:null,crack:null,crackTriggers:null,crackHealTrigger:!1,crackHealDuration:1500,gestureQuaternion:null},this._finalNonUniformScale=[1,1,1]}_resetAccumulated(){const e=this._accumulated;e.position[0]=0,e.position[1]=0,e.position[2]=0,e.scale=1,e.nonUniformScale[0]=1,e.nonUniformScale[1]=1,e.nonUniformScale[2]=1,e.glowIntensity=1,e.glowBoost=0,e.glowColorOverride=null,e.electricOverlay=null,e.waterOverlay=null,e.fireOverlay=null,e.smokeOverlay=null,e.voidOverlay=null,e.iceOverlay=null,e.lightOverlay=null,e.poisonOverlay=null,e.earthOverlay=null,e.natureOverlay=null,e.meshOpacity=1,e.cameraRelativePosition[0]=0,e.cameraRelativePosition[1]=0,e.cameraRelativePosition[2]=0,e.cameraRelativeRotation[0]=0,e.cameraRelativeRotation[1]=0,e.cameraRelativeRotation[2]=0,e.positionBoost[0]=0,e.positionBoost[1]=0,e.positionBoost[2]=0,e.rotationBoost[0]=0,e.rotationBoost[1]=0,e.rotationBoost[2]=0,e.scaleBoost=1,e.hasAccentGestures=!1,e.hasAbsoluteGestures=!1,e.hasCameraRelativeGestures=!1,e.freezeRotation=0,e.freezeWobble=0,e.freezeGroove=0,e.freezeParticles=0,e.deformation=null,e.shatter=null,e.crack=null,e.crackTriggers=null,e.crackHealTrigger=!1,e.crackHealDuration=1500,this.accumulatedRotationQuat.identity()}blend(e,t,i,a,n){this._resetAccumulated();const s=this._accumulated;for(const i of e)if(i.evaluate){const e=t-i.startTime,a=i.duration,n=Math.min(e/a,1),r=i.evaluate(n);if(r){const e=.15,t=.85;let a=1;if(n<e){const t=n/e;a=t*t*(3-2*t)}else if(n>t){const e=(n-t)/(1-t);a=1-e*e*(3-2*e)}if(!0===i.isAccent?s.hasAccentGestures=!0:(r.position||r.rotation||void 0!==r.scale)&&(s.hasAbsoluteGestures=!0),r.position&&(s.position[0]+=r.position[0]*a,s.position[1]+=r.position[1]*a,s.position[2]+=r.position[2]*a),r.rotation&&(this.tempEuler.set(r.rotation[0]*a,r.rotation[1]*a,r.rotation[2]*a,"XYZ"),this.tempQuat.setFromEuler(this.tempEuler),s.rotationQuat.multiply(this.tempQuat)),void 0!==r.scale)if(Array.isArray(r.scale)){const e=1+(r.scale[0]-1)*a,t=1+(r.scale[1]-1)*a,i=1+(r.scale[2]-1)*a;s.nonUniformScale[0]*=e,s.nonUniformScale[1]*=t,s.nonUniformScale[2]*=i}else{const e=1+(r.scale-1)*a;s.scale*=e}if(void 0!==r.glowIntensity&&(s.glowIntensity*=r.glowIntensity),void 0!==r.glowBoost&&(s.glowBoost+=r.glowBoost),r.glowColorOverride&&(s.glowColorOverride=r.glowColorOverride),r.electricOverlay&&r.electricOverlay.enabled&&(!s.electricOverlay||r.electricOverlay.charge>s.electricOverlay.charge)&&(s.electricOverlay={...r.electricOverlay}),r.waterOverlay&&r.waterOverlay.enabled&&(!s.waterOverlay||r.waterOverlay.wetness>s.waterOverlay.wetness)&&(s.waterOverlay={...r.waterOverlay}),r.fireOverlay&&r.fireOverlay.enabled&&(!s.fireOverlay||r.fireOverlay.heat>s.fireOverlay.heat)&&(s.fireOverlay={...r.fireOverlay}),r.smokeOverlay&&r.smokeOverlay.enabled&&(!s.smokeOverlay||r.smokeOverlay.thickness>s.smokeOverlay.thickness)&&(s.smokeOverlay={...r.smokeOverlay}),r.voidOverlay&&r.voidOverlay.enabled&&(!s.voidOverlay||r.voidOverlay.strength>s.voidOverlay.strength)&&(s.voidOverlay={...r.voidOverlay}),r.iceOverlay&&r.iceOverlay.enabled&&(!s.iceOverlay||r.iceOverlay.strength>s.iceOverlay.strength)&&(s.iceOverlay={...r.iceOverlay}),r.lightOverlay&&r.lightOverlay.enabled&&(!s.lightOverlay||r.lightOverlay.strength>s.lightOverlay.strength)&&(s.lightOverlay={...r.lightOverlay}),r.poisonOverlay&&r.poisonOverlay.enabled&&(!s.poisonOverlay||r.poisonOverlay.strength>s.poisonOverlay.strength)&&(s.poisonOverlay={...r.poisonOverlay}),r.earthOverlay&&r.earthOverlay.enabled&&(!s.earthOverlay||r.earthOverlay.strength>s.earthOverlay.strength)&&(s.earthOverlay={...r.earthOverlay}),r.natureOverlay&&r.natureOverlay.enabled&&(!s.natureOverlay||r.natureOverlay.strength>s.natureOverlay.strength)&&(s.natureOverlay={...r.natureOverlay}),void 0!==r.meshOpacity&&(s.meshOpacity=Math.min(s.meshOpacity,r.meshOpacity)),r.positionBoost&&(s.positionBoost[0]+=r.positionBoost[0],s.positionBoost[1]+=r.positionBoost[1],s.positionBoost[2]+=r.positionBoost[2]),r.rotationBoost&&(s.rotationBoost[0]+=r.rotationBoost[0],s.rotationBoost[1]+=r.rotationBoost[1],s.rotationBoost[2]+=r.rotationBoost[2]),void 0!==r.scaleBoost&&(s.scaleBoost*=r.scaleBoost),r.cameraRelativePosition&&(s.cameraRelativePosition[0]+=r.cameraRelativePosition[0]*a,s.cameraRelativePosition[1]+=r.cameraRelativePosition[1]*a,s.cameraRelativePosition[2]+=r.cameraRelativePosition[2]*a,s.hasCameraRelativeGestures=!0),r.cameraRelativeRotation&&(s.cameraRelativeRotation[0]+=r.cameraRelativeRotation[0]*a,s.cameraRelativeRotation[1]+=r.cameraRelativeRotation[1]*a,s.cameraRelativeRotation[2]+=r.cameraRelativeRotation[2]*a,s.hasCameraRelativeGestures=!0),void 0!==r.freezeRotation&&(s.freezeRotation=Math.max(s.freezeRotation,r.freezeRotation*a)),void 0!==r.freezeWobble&&(s.freezeWobble=Math.max(s.freezeWobble,r.freezeWobble*a)),void 0!==r.freezeGroove&&(s.freezeGroove=Math.max(s.freezeGroove,r.freezeGroove*a)),void 0!==r.freezeParticles&&(s.freezeParticles=Math.max(s.freezeParticles,r.freezeParticles*a)),r.deformation&&r.deformation.enabled){const e=r.deformation;(!s.deformation||e.strength>s.deformation.strength)&&(s.deformation={...e})}if(r.shatter&&(r.shatter.enabled&&!s.shatter&&(s.shatter={...r.shatter}),r.shatter.reassemble&&(s.shatter||(s.shatter={enabled:!1}),s.shatter.reassemble=!0,s.shatter.reassembleDuration=r.shatter.reassembleDuration||1e3)),r.crack){const e=r.crack;if(e.enabled&&e.trigger){const t=i.startTime;this._crackTriggeredAnimations.has(t)||(this._crackTriggeredAnimations.add(t),s.crackTriggers||(s.crackTriggers=[]),s.crackTriggers.push({screenOffset:e.screenOffset,screenDirection:e.screenDirection,propagation:e.propagation,amount:e.amount,glowStrength:e.glowStrength}))}if(e.heal&&e.healTrigger){const t=i.startTime;this._crackTriggeredAnimations.has(t)||(this._crackTriggeredAnimations.add(t),s.crackHealTrigger=!0,s.crackHealDuration=e.healDuration||1500)}e.enabled&&(s.crack={...e})}}}s.scaleBoost=Math.max(.85,Math.min(1.15,s.scaleBoost)),s.glowBoost=Math.min(.5,s.glowBoost);for(let e=0;e<3;e++)s.positionBoost[e]=Math.max(-.05,Math.min(.05,s.positionBoost[e]));for(let e=0;e<3;e++)s.rotationBoost[e]=Math.max(-.1,Math.min(.1,s.rotationBoost[e]));this.tempEuler.setFromQuaternion(s.rotationQuat,"XYZ");const r=this.tempEuler.x,o=this.tempEuler.y,l=this.tempEuler.z,c=[i[0]+r,i[1]+o,i[2]+l],h=new Set(e.map(e=>e.startTime));for(const e of this._crackTriggeredAnimations)h.has(e)||this._crackTriggeredAnimations.delete(e);const u=a*s.scale,d=n*s.glowIntensity;let m=null;(1!==s.nonUniformScale[0]||1!==s.nonUniformScale[1]||1!==s.nonUniformScale[2])&&(this._finalNonUniformScale[0]=u*s.nonUniformScale[0],this._finalNonUniformScale[1]=u*s.nonUniformScale[1],this._finalNonUniformScale[2]=u*s.nonUniformScale[2],m=this._finalNonUniformScale);const p=this._result;return p.position=s.position,p.rotation[0]=c[0],p.rotation[1]=c[1],p.rotation[2]=c[2],p.scale=u,p.nonUniformScale=m,p.glowIntensity=d,p.glowBoost=s.glowBoost,p.glowColorOverride=s.glowColorOverride,p.electricOverlay=s.electricOverlay,p.waterOverlay=s.waterOverlay,p.fireOverlay=s.fireOverlay,p.smokeOverlay=s.smokeOverlay,p.voidOverlay=s.voidOverlay,p.iceOverlay=s.iceOverlay,p.lightOverlay=s.lightOverlay,p.poisonOverlay=s.poisonOverlay,p.earthOverlay=s.earthOverlay,p.natureOverlay=s.natureOverlay,p.meshOpacity=s.meshOpacity,p.cameraRelativePosition=s.cameraRelativePosition,p.cameraRelativeRotation=s.cameraRelativeRotation,p.positionBoost=s.positionBoost,p.rotationBoost=s.rotationBoost,p.scaleBoost=s.scaleBoost,p.hasAccentGestures=s.hasAccentGestures,p.hasAbsoluteGestures=s.hasAbsoluteGestures,p.hasCameraRelativeGestures=s.hasCameraRelativeGestures,p.freezeRotation=s.freezeRotation,p.freezeWobble=s.freezeWobble,p.freezeGroove=s.freezeGroove,p.freezeParticles=s.freezeParticles,p.deformation=s.deformation,p.shatter=s.shatter,p.crack=s.crack,p.crackTriggers=s.crackTriggers,p.crackHealTrigger=s.crackHealTrigger,p.crackHealDuration=s.crackHealDuration,p.gestureQuaternion=s.rotationQuat,p}resetSmoothing(){this.hasValidPrevRotation=!1,this.prevRotation&&(this.prevRotation[0]=0,this.prevRotation[1]=0,this.prevRotation[2]=0)}destroy(){this.tempEuler=null,this.tempQuat=null,this.accumulatedRotationQuat=null,this.finalQuaternion=null,this.prevRotation=null}}const Ci=new Map;var Pi=function(e){return Ci.get(e)||null},ki=function(){return Array.from(Ci.keys())},Di={name:"suspicion",emoji:"🤨",description:"Paranoid watchfulness with surveillance scanning",visual:{glowColor:"#6B46C1",particleRate:4,minParticles:6,maxParticles:12,particleBehavior:"surveillance",particleSpeed:.2,breathRate:.6,breathDepth:.04,coreJitter:.02,blinkRate:1.1,blinkSpeed:1,particleColors:[{color:"#6B46C1",weight:30},{color:"#4A5568",weight:25},{color:"#8B4789",weight:20},{color:"#9F7AEA",weight:15},{color:"#2D3748",weight:10}],threatLevel:0,getGlowIntensity(){return.3+.7*this.threatLevel},getParticleSpeed(){return.2+.8*this.threatLevel},getGlowColor(){const e=this.threatLevel||0,t=Math.round(107+113*e),i=Math.round(70+-32*e),a=Math.round(193+-66*e),n=e=>e.toString(16).padStart(2,"0");return`#${n(t)}${n(i)}${n(a)}`}},modifiers:{speed:.4,amplitude:.6,intensity:1.2,smoothness:.3,regularity:.2,focus:1.5,addWobble:!0},typicalGestures:["scan","twitch","peek","tilt","hold"],transitions:{duration:500,easing:"linear",priority:4},special:{coreSquint:.6,scanInterval:2e3,scanDuration:1200,scanAngle:60,twitchChance:.02,peekInterval:4e3,maxThreatDistance:300,alertThreshold:.7},"3d":{rotation:{type:"suspicious",speed:1,axes:[0,0,0],musicSync:!1},glow:{color:"#6B46C1",intensity:.85,pulse:{speed:.6,range:[.7,1]}},scale:{base:1,breathe:{enabled:!0,depth:.04,rate:.6}}},soulAnimation:{driftSpeed:.9,shimmerSpeed:1.8,turbulence:.4}},Ai={name:"calm",emoji:"😌",description:"Serene, peaceful state with gentle movements",visual:{glowColor:"#66D9CC",particleRate:6,minParticles:10,maxParticles:50,particleBehavior:"zen",breathRate:.4,breathDepth:.12,coreJitter:!1,blinkRate:.8,blinkSpeed:1,particleColors:[{color:"#66D9CC",weight:35},{color:"#99E6D9",weight:25},{color:"#40BFB3",weight:20},{color:"#B3F2E6",weight:15},{color:"#339980",weight:5}]},modifiers:{speed:.5,amplitude:.3,intensity:.4,smoothness:2,regularity:1.5,addWeight:!1,floatHeight:.2,swayAmount:.15,duration:1.5},typicalGestures:["breathe","float","drift","idle"],transitions:{duration:800,easing:"easeInOutSine",priority:1},movement:{floatPattern:"sine_slow",floatPeriod:6e3,floatAmplitude:8,swayPattern:"gentle",swayPeriod:8e3,swayAmplitude:5,microMovements:!1},getCoreParams(e){const t=e.time||Date.now(),i=.5*Math.sin(6e-4*t)+.5;return{scaleX:1-.02*i,scaleY:1-.02*i,eyeOpenness:.85,eyeExpression:"serene",pupilOffset:{x:2*Math.sin(3e-4*t),y:1*Math.cos(4e-4*t)},glowPulse:.95+.05*i}},updateParticle(e,t){e.x+=.1*Math.sin(.001*e.life),e.y-=.02*t,e.opacity=.3*Math.sin(.002*e.life)+.2,e.size=e.baseSize*(1+.2*Math.sin(.001*e.life))},renderCore:(e,t,i,a)=>!1,"3d":{rotation:{type:"gentle",speed:.5,axes:[0,.3,0],musicSync:!0},glow:{color:"#66D9CC",intensity:.6,pulse:{speed:.4,range:[.5,.7]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.4}}},soulAnimation:{driftSpeed:.3,shimmerSpeed:.4,turbulence:.1}};const _i=new Map,Ti={happy:"joy",peaceful:"calm",curious:"surprise",frustrated:"anger",sad:"sadness",excitement:"excited"};function Ii(e){const t=Ti[e]||e,i=_i.get(t);if(i)return i;return Pi(t)||null}function Oi(e){const t=Ii(e);if(!t)return Ii("neutral").visual;if(!t.visual)return{};const{visual:i}=t,a={};for(const e in i)"function"!=typeof i[e]&&(a[e]=i[e]);return"function"==typeof i.getGlowIntensity&&(a.glowIntensity=i.getGlowIntensity()),"function"==typeof i.getParticleSpeed&&(a.particleSpeed=i.getParticleSpeed()),"function"==typeof i.getParticleRate&&(a.particleRate=i.getParticleRate()),"function"==typeof i.getGlowColor&&(a.glowColor=i.getGlowColor()),a}function Ri(e){const t=Ii(e);return t?t.modifiers:Ii("neutral").modifiers}function Ei(){return[...Array.from(_i.keys()),...ki()]}function Bi(e,t){const i=Ii(e),a=Ii(t);return i&&a?a.transitions&&a.transitions[e]?a.transitions[e]:{duration:1e3,easing:"ease-in-out",gesture:a.transitions?.defaultGesture||null}:{duration:1e3,easing:"ease-in-out"}}[{name:"neutral",emoji:"😐",description:"Calm, balanced emotional state",visual:{glowColor:"#00BCD4",particleRate:2,minParticles:8,maxParticles:10,particleBehavior:"ambient",breathRate:1,breathDepth:.08,coreJitter:!1,blinkRate:1,blinkSpeed:1,particleColors:[{color:"#00BCD4",weight:25},{color:"#00ACC1",weight:20},{color:"#26C6DA",weight:15},{color:"#B2EBF2",weight:15},{color:"#0097A7",weight:10},{color:"#80DEEA",weight:10},{color:"#E0F7FA",weight:5}]},modifiers:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1},typicalGestures:["breathe","float","idle","blink"],transitions:{duration:500,easing:"easeInOut",priority:0},getCoreParams:e=>({scaleX:1,scaleY:1,eyeOpenness:1,eyeExpression:"neutral",pupilOffset:{x:0,y:0}}),renderCore:(e,t,i,a)=>!1,"3d":{rotation:{type:"gentle",speed:1,axes:[0,.3,0],musicSync:!1},glow:{color:"#00BCD4",intensity:.9,pulse:{speed:1,range:[.8,1]}},scale:{base:1,breathe:{enabled:!0,depth:.08,rate:1}}},soulAnimation:{driftSpeed:.5,shimmerSpeed:.5,turbulence:.2}},{name:"joy",emoji:"😊",description:"Playful happiness and celebration",visual:{glowColor:"#FFEB3B",particleRate:8,minParticles:0,maxParticles:50,particleBehavior:"popcorn",breathRate:1.5,breathDepth:.1,coreJitter:!1,blinkRate:1.3,blinkSpeed:1.1,particleColors:[{color:"#FFEB3B",weight:25},{color:"#FFC107",weight:20},{color:"#FFFF00",weight:15},{color:"#FFD700",weight:15},{color:"#FFF59D",weight:10},{color:"#FF9800",weight:10},{color:"#FFFDE7",weight:5}]},modifiers:{speed:1.8,amplitude:1.9,intensity:1.1,smoothness:1,regularity:.9,addBounce:!0},typicalGestures:["bounce","spin","wave","expand","shake","float"],transitions:{duration:400,easing:"easeOutBack",priority:5,burstOnEntry:!0},getCoreParams:e=>({scaleX:1,scaleY:1,eyeOpenness:1,eyeExpression:"happy",pupilOffset:{x:0,y:-.1},sparkle:!0}),"3d":{rotation:{type:"rhythmic",speed:1.8,axes:[0,.3,0],musicSync:!0},glow:{color:"#FFEB3B",intensity:1.6,pulse:{speed:1.5,range:[1.2,1.8]}},scale:{base:1,breathe:{enabled:!0,depth:.1,rate:1.5}}},soulAnimation:{driftSpeed:1.2,shimmerSpeed:1.5,turbulence:.3}},{name:"sadness",emoji:"😢",description:"Deep melancholic sorrow",visual:{glowColor:"#4169E1",particleRate:6,minParticles:0,maxParticles:50,particleBehavior:"falling",breathRate:.6,breathDepth:.12,coreJitter:!1,blinkRate:.6,blinkSpeed:.8,particleColors:[{color:"#4169E1",weight:25},{color:"#1E90FF",weight:20},{color:"#6495ED",weight:15},{color:"#B0C4DE",weight:15},{color:"#191970",weight:10},{color:"#87CEEB",weight:10},{color:"#2F4F4F",weight:5}]},modifiers:{speed:.7,amplitude:.6,intensity:.8,smoothness:1.3,regularity:1.1,addGravity:!0},typicalGestures:["droop","sway","contract","drift","sink"],transitions:{duration:800,easing:"easeInOut",priority:3},"3d":{rotation:{type:"gentle",speed:.7,axes:[0,.2,0],musicSync:!1},glow:{color:"#4169E1",intensity:.65,pulse:{speed:.6,range:[.5,.8]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.6}}},soulAnimation:{driftSpeed:.2,shimmerSpeed:.3,turbulence:.1}},{name:"anger",emoji:"😠",description:"Intense rage and aggression",visual:{glowColor:"#DC143C",particleRate:8,minParticles:8,maxParticles:50,particleBehavior:"aggressive",breathRate:2.2,breathDepth:.15,coreJitter:!0,blinkRate:1.6,blinkSpeed:1.3,particleColors:[{color:"#DC143C",weight:25},{color:"#FF0000",weight:20},{color:"#B22222",weight:15},{color:"#FF4500",weight:15},{color:"#8B0000",weight:10},{color:"#FF6347",weight:10},{color:"#660000",weight:5}]},modifiers:{speed:1.5,amplitude:1.4,intensity:1.3,smoothness:.3,regularity:.7,addShake:!0},typicalGestures:["shake","vibrate","expand","pulse","flicker","strike"],transitions:{duration:300,easing:"easeOutExpo",priority:8,shakeOnEntry:!0},special:{screenShake:!0,particleTrails:"fire",glowPulse:!0,temperatureEffect:"hot"},"3d":{rotation:{type:"unstable",speed:1.5,axes:[0,.3,0],shake:{amplitude:.02,frequency:7},eruption:{enabled:!0,interval:3e3,speedMultiplier:3.5,duration:400},musicSync:!1},glow:{color:"#DC143C",intensity:1.8,pulse:{speed:2.2,range:[.8,2]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:2.2}}},soulAnimation:{driftSpeed:2,shimmerSpeed:.8,turbulence:.8}},{name:"fear",emoji:"😨",description:"Anxious state with fleeing particles",visual:{glowColor:"#8A2BE2",particleRate:8,minParticles:8,maxParticles:50,particleBehavior:"scattering",breathRate:2.5,breathDepth:.06,coreJitter:!0,blinkRate:1.7,blinkSpeed:1.4,particleColors:[{color:"#8A2BE2",weight:25},{color:"#4B0082",weight:20},{color:"#9400D3",weight:15},{color:"#6B46C1",weight:15},{color:"#9932CC",weight:10},{color:"#E6E6FA",weight:8},{color:"#301934",weight:7}]},modifiers:{speed:1.4,amplitude:.8,intensity:1.2,smoothness:.5,regularity:.5,addJitter:!0},typicalGestures:["shake","vibrate","contract","flicker","retreat"],transitions:{duration:400,easing:"easeOut",priority:7},"3d":{rotation:{type:"unstable",speed:1.4,axes:[0,.3,0],shake:{amplitude:.015,frequency:3.5},musicSync:!1},glow:{color:"#8A2BE2",intensity:.9,pulse:{speed:2.5,range:[.6,1.2]}},scale:{base:1,breathe:{enabled:!0,depth:.06,rate:2.5}}},soulAnimation:{driftSpeed:1.8,shimmerSpeed:2.5,turbulence:.6}},{name:"surprise",emoji:"😲",description:"Sudden shock with explosive particles",visual:{glowColor:"#FFD700",particleRate:5,minParticles:0,maxParticles:15,particleBehavior:"burst",breathRate:.3,breathDepth:.18,coreJitter:!1,blinkRate:1.4,blinkSpeed:1.2,particleColors:[{color:"#FFD700",weight:25},{color:"#FFA500",weight:20},{color:"#FFFF00",weight:15},{color:"#FF6347",weight:15},{color:"#FFE4B5",weight:10},{color:"#FF4500",weight:10},{color:"#FFFACD",weight:5}]},modifiers:{speed:1.6,amplitude:1.5,intensity:1.4,smoothness:.7,regularity:.8,addPop:!0},typicalGestures:["expand","bounce","flash","pulse","pop"],transitions:{duration:200,easing:"easeOutBack",priority:6},"3d":{rotation:{type:"unstable",speed:1.6,axes:[0,.45,0],shake:{amplitude:.01,frequency:3},musicSync:!1},glow:{color:"#FFD700",intensity:1.8,pulse:{speed:.3,range:[1,2.2]}},scale:{base:1,breathe:{enabled:!0,depth:.18,rate:.3}}},soulAnimation:{driftSpeed:1.5,shimmerSpeed:2,turbulence:.5}},{name:"disgust",emoji:"🤢",description:"Revulsion with repelling particles",visual:{glowColor:"#9ACD32",particleRate:4,minParticles:5,maxParticles:12,particleBehavior:"repelling",breathRate:.7,breathDepth:.04,coreJitter:!1,blinkRate:.9,blinkSpeed:.9,particleColors:[{color:"#9ACD32",weight:25},{color:"#ADFF2F",weight:20},{color:"#7FFF00",weight:15},{color:"#BDB76B",weight:15},{color:"#6B8E23",weight:10},{color:"#CCFF00",weight:8},{color:"#556B2F",weight:7}]},modifiers:{speed:.9,amplitude:.7,intensity:.9,smoothness:.8,regularity:1,addRecoil:!0},typicalGestures:["contract","shake","recoil","wobble"],transitions:{duration:600,easing:"easeIn",priority:4},"3d":{rotation:{type:"gentle",speed:.9,axes:[0,.25,0],musicSync:!1},glow:{color:"#9ACD32",intensity:1,pulse:{speed:.7,range:[.7,1.2]}},scale:{base:1,breathe:{enabled:!0,depth:.04,rate:.7}}},soulAnimation:{driftSpeed:.4,shimmerSpeed:.6,turbulence:.35}},{name:"love",emoji:"💕",description:"Warm affection with orbiting particles",visual:{glowColor:"#FF1493",particleRate:6,minParticles:15,maxParticles:50,particleBehavior:"orbiting",breathRate:.75,breathDepth:.15,coreJitter:!1,blinkRate:1.2,blinkSpeed:1,particleColors:[{color:"#FF1493",weight:30},{color:"#FF69B4",weight:25},{color:"#FF007F",weight:15},{color:"#FFB6C1",weight:10},{color:"#FF45A0",weight:10},{color:"#E91E63",weight:5},{color:"#FFC0CB",weight:5}]},modifiers:{speed:.9,amplitude:1.1,intensity:1.2,smoothness:1.4,regularity:1.2,addWarmth:!0},typicalGestures:["pulse","sway","orbit","glow","breathe","float"],transitions:{duration:700,easing:"easeInOut",priority:5},"3d":{rotation:{type:"gentle",speed:.9,axes:[0,.28,0],musicSync:!0},glow:{color:"#FF1493",intensity:1.8,pulse:{speed:.75,range:[1.3,2]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:.75}}},soulAnimation:{driftSpeed:.8,shimmerSpeed:1.2,turbulence:.2}},Di,{name:"excited",emoji:"🤩",description:"High energy with rapid particles",visual:{glowColor:"#FF6B35",particleRate:8,minParticles:10,maxParticles:50,particleBehavior:"burst",breathRate:2,breathDepth:.14,coreJitter:!0,blinkRate:1.5,blinkSpeed:1.2,particleColors:[{color:"#FF6B35",weight:25},{color:"#FF1744",weight:20},{color:"#FFC107",weight:15},{color:"#FF9100",weight:15},{color:"#FFEB3B",weight:10},{color:"#FF5722",weight:10},{color:"#FFF59D",weight:5}]},modifiers:{speed:1.4,amplitude:1.3,intensity:1.3,smoothness:.8,regularity:.7,addVibration:!0},typicalGestures:["bounce","spin","vibrate","expand","shake","pulse"],transitions:{duration:300,easing:"easeOutElastic",priority:6},"3d":{rotation:{type:"unstable",speed:1.4,axes:[0,.4,0],shake:{amplitude:.01,frequency:4},musicSync:!1},glow:{color:"#FF6B35",intensity:1.5,pulse:{speed:2,range:[1,1.8]}},scale:{base:1,breathe:{enabled:!0,depth:.14,rate:2}}},soulAnimation:{driftSpeed:1.5,shimmerSpeed:2,turbulence:.5}},{name:"resting",emoji:"😴",description:"Deep relaxation with slow drift",visual:{glowColor:"#9370DB",particleRate:1,minParticles:3,maxParticles:5,particleBehavior:"resting",breathRate:.8,breathDepth:.12,coreJitter:!1,blinkRate:.4,blinkSpeed:.7,particleColors:[{color:"#9370DB",weight:30},{color:"#A591C4",weight:20},{color:"#B366FF",weight:20},{color:"#B8A1E6",weight:15},{color:"#674D9B",weight:15}]},modifiers:{speed:.5,amplitude:.4,intensity:.5,smoothness:1.4,regularity:.9,addWeight:!0},typicalGestures:["breathe","drift","sway","float"],transitions:{duration:1e3,easing:"easeInOut",priority:2},"3d":{rotation:{type:"gentle",speed:.5,axes:[0,.15,0],musicSync:!1},glow:{color:"#9370DB",intensity:.8,pulse:{speed:.8,range:[.6,1]}},scale:{base:1,breathe:{enabled:!0,depth:.12,rate:.8}}},soulAnimation:{driftSpeed:.15,shimmerSpeed:.1,turbulence:.05}},{name:"euphoria",emoji:"🌟",description:"Radiant hope and new beginnings",visual:{glowColor:"#FFB6C1",particleRate:6,minParticles:15,maxParticles:30,particleBehavior:"radiant",breathRate:1.3,breathDepth:.25,coreJitter:!1,blinkRate:1.4,blinkSpeed:1.1,particleColors:[{color:"#FFB6C1",weight:20},{color:"#FFD700",weight:18},{color:"#87CEEB",weight:15},{color:"#DDA0DD",weight:15},{color:"#98FB98",weight:12},{color:"#FFA07A",weight:10},{color:"#E6E6FA",weight:8},{color:"#FFFFFF",weight:2}]},modifiers:{speed:1.4,amplitude:1.5,intensity:1.6,smoothness:1.3,regularity:.8,addWarmth:!0,addLift:!0},typicalGestures:["expand","radiate","pulse","glow","float","bloom"],transitions:{duration:600,easing:"easeOutExpo",priority:8},"3d":{rotation:{type:"rhythmic",speed:1.4,axes:[0,.35,0],musicSync:!0},glow:{color:"#FFB6C1",intensity:1.2,pulse:{speed:1.3,range:[.9,1.5]}},scale:{base:1,breathe:{enabled:!0,depth:.25,rate:1.3}}},soulAnimation:{driftSpeed:1.8,shimmerSpeed:2.5,turbulence:.7}},{name:"focused",emoji:"🎯",description:"Intense concentration with directed flow",visual:{glowColor:"#00CED1",particleRate:4,minParticles:5,maxParticles:12,particleBehavior:"directed",breathRate:1.2,breathDepth:.08,coreJitter:!0,blinkRate:.7,blinkSpeed:1,particleColors:[{color:"#00CED1",weight:30},{color:"#4A9FA0",weight:20},{color:"#00FFFF",weight:20},{color:"#5FE5E7",weight:15},{color:"#006B6D",weight:15}],eyeOpenness:.7,microAdjustments:!0},modifiers:{speed:1,amplitude:.9,intensity:1.1,smoothness:1.1,regularity:1.2,addPrecision:!0},typicalGestures:["track","lock","scan","pulse","vibrate"],transitions:{duration:400,easing:"easeIn",priority:5},getCoreParams:e=>({scaleX:1.1,scaleY:.7,eyeOpenness:.7,eyeExpression:"focused",pupilOffset:{x:0,y:0},microAdjustments:!0}),"3d":{rotation:{type:"still",speed:.5,axes:[0,.1,0],musicSync:!1},glow:{color:"#00CED1",intensity:1.2,pulse:{speed:1.2,range:[1,1.3]}},scale:{base:1,breathe:{enabled:!0,depth:.08,rate:1.2}}},soulAnimation:{driftSpeed:.6,shimmerSpeed:.2,turbulence:.1}},{name:"glitch",emoji:"🌈",description:"Surprised sadness with rainbow colors and glitch wiggle",visual:{primaryColor:"#FF6B9D",glowColor:"#4169E1",glowIntensity:1.2,particleRate:5,minParticles:5,maxParticles:15,particleBehavior:"burst",particleSpeed:1,breathRate:.4,breathDepth:.15,coreJitter:!1,coreSize:1,eyeOpenness:.8,blinkRate:1.3,blinkSpeed:1.2,particleColors:[{color:"#FF0080",weight:18},{color:"#00FF80",weight:18},{color:"#8000FF",weight:18},{color:"#FF8000",weight:15},{color:"#0080FF",weight:15},{color:"#FFFF00",weight:10},{color:"#FF6B9D",weight:6}],particleGlitchWiggle:!0,glitchWiggleIntensity:.3,glitchWiggleFrequency:.1},modifiers:{speed:1.1,amplitude:1,intensity:1.1,smoothness:.8,regularity:.7,focus:.6},typicalGestures:["bounce","sway","pulse","drift","flash"],transitions:{duration:300,easing:"easeInOut",priority:5},"3d":{rotation:{type:"unstable",speed:1.1,axes:[0,.35,0],shake:{amplitude:.02,frequency:5},musicSync:!1},glow:{color:"#FF6B9D",intensity:1.2,pulse:{speed:.4,range:[.8,1.6]}},scale:{base:1,breathe:{enabled:!0,depth:.15,rate:.4}}}},Ai].forEach(e=>{e&&e.name&&_i.set(e.name,e)});class Fi{constructor(e,t={}){this.blinkConfig=e.blink||this.getDefaultBlinkConfig(),this.currentGeometryType=null,this.baseDuration=this.blinkConfig.duration||150,this.baseMinInterval=3e3,this.baseMaxInterval=7e3,this.emotionBlinkRate=1,this.emotionBlinkSpeed=1,this.isBlinking=!1,this.blinkTimer=0,this.nextBlinkTime=this.getRandomBlinkTime(),this.enabled=!0,this.blinkProgress=0}setEmotion(e){const t=Ii(e);this.emotionBlinkRate=t?.visual?.blinkRate||1,this.emotionBlinkSpeed=t?.visual?.blinkSpeed||1}setGeometry(e){this.blinkConfig=e.blink||this.getDefaultBlinkConfig(),this.baseDuration=this.blinkConfig.duration||150}update(e){if(!this.enabled)return this.getIdleState();if(this.isBlinking){this.blinkTimer+=e;const t=this.baseDuration/this.emotionBlinkSpeed;if(this.blinkTimer>=t)return this.completeBlink(),this.getIdleState();const i=this.blinkTimer/t;return this.blinkProgress=i,this.getBlinkState()}return Date.now()>=this.nextBlinkTime?(this.startBlink(),this.getBlinkState()):this.getIdleState()}startBlink(){this.enabled&&(this.isBlinking=!0,this.blinkTimer=0,this.blinkProgress=0)}completeBlink(){this.isBlinking=!1,this.blinkTimer=0,this.blinkProgress=0,this.nextBlinkTime=Date.now()+this.getRandomBlinkTime()}getRandomBlinkTime(){const e=this.baseMinInterval/this.emotionBlinkRate,t=this.baseMaxInterval/this.emotionBlinkRate;return e+Math.random()*(t-e)}getBlinkState(){const e=this.blinkConfig,t=Math.sin(this.blinkProgress*Math.PI);let i=1;if(e.playful)if(this.blinkProgress<.1){const t=this.blinkProgress/.1;i-=Math.sin(t*Math.PI)*e.playful.anticipation}else if(this.blinkProgress>.8){const t=(this.blinkProgress-.8)/.2;i+=Math.sin(t*Math.PI)*e.playful.overshoot}const a=t*i,n=[1-(1-e.scaleAxis[0])*a,1-(1-e.scaleAxis[1])*a,1-(1-e.scaleAxis[2])*a];let s=null;e.rotation&&(s=[e.rotation[0]*a,e.rotation[1]*a,e.rotation[2]*a]);let r=0;return e.glowBoost&&(r=e.glowBoost*a),{isBlinking:!0,progress:this.blinkProgress,scale:n,rotation:s,glowBoost:r}}getIdleState(){return{isBlinking:!1,progress:0,scale:[1,1,1],rotation:null,glowBoost:0}}getDefaultBlinkConfig(){return{type:"vertical-squish",duration:150,scaleAxis:[1,.3,1],curve:"sine"}}pause(){this.enabled=!1,this.isBlinking&&this.completeBlink()}resume(){this.enabled=!0,this.nextBlinkTime=Date.now()+this.getRandomBlinkTime()}getState(){return{isBlinking:this.isBlinking,enabled:this.enabled,blinkProgress:this.blinkProgress,emotionBlinkRate:this.emotionBlinkRate,emotionBlinkSpeed:this.emotionBlinkSpeed,nextBlinkTime:this.nextBlinkTime}}destroy(){this.blinkConfig=null,this.enabled=!1,this.isBlinking=!1}}let zi;"undefined"!=typeof window&&window.__emotiveRhythmEngine?zi=window.__emotiveRhythmEngine:(zi=new class{constructor(){this.bpm=120,this.timeSignature=[4,4],this.isPlaying=!1,this.startTime=0,this.currentBeat=0,this.currentBar=0,this.beatProgress=0,this.barProgress=0,this.beatDuration=6e4/this.bpm,this.barDuration=this.beatDuration*this.timeSignature[0],this.lastBeatTime=0,this.nextBeatTime=0,this.listeners=new Map,this.beatCallbacks=new Set,this.barCallbacks=new Set,this.subdivisions={sixteenth:0,eighth:0,triplet:0,swing:0},this.audioSync=null,this.syncOffset=0,this.autoSync=!1,this.intensity=1,this.groove=0,this.humanize=.05,this.patterns=new Map,this.currentPattern=null,this.initializePatterns()}initializePatterns(){this.patterns.set("4/4",{name:"4/4",description:"Common time - 4 beats per bar",timeSignature:[4,4],groove:0,accents:[1,.5,.7,.5]}),this.patterns.set("straight",{name:"straight",description:"Straight, even timing",groove:0,accents:[1,.5,.7,.5]}),this.patterns.set("swing",{name:"swing",description:"Swing/shuffle timing",groove:.67,accents:[1,.3,.8,.3]}),this.patterns.set("3/4",{name:"3/4",description:"Waltz time - 3 beats per bar",timeSignature:[3,4],accents:[1,.5,.5]}),this.patterns.set("waltz",{name:"waltz",description:"3/4 waltz timing",timeSignature:[3,4],accents:[1,.5,.5]}),this.patterns.set("6/8",{name:"6/8",description:"Compound duple time",timeSignature:[6,8],accents:[1,.3,.3,.7,.3,.3]}),this.patterns.set("5/4",{name:"5/4",description:"Complex meter - 5 beats per bar",timeSignature:[5,4],accents:[1,.5,.6,.5,.7]}),this.patterns.set("7/8",{name:"7/8",description:"Irregular meter",timeSignature:[7,8],accents:[1,.5,.5,.7,.5,.5,.6]}),this.patterns.set("dubstep",{name:"dubstep",description:"Dubstep half-time feel",accents:[.2,.2,1,.2],subdivisions:{wobble:!0}}),this.patterns.set("breakbeat",{name:"breakbeat",description:"Broken beat pattern",accents:[1,.2,.7,.9,.2,.8,.4,.2]})}start(){this.isPlaying||(this.isPlaying=!0,this.isRunning=!0,this.startTime=performance.now(),this.lastBeatTime=this.startTime,this.nextBeatTime=this.startTime+this.beatDuration,this.currentBeat=0,this.currentBar=0,this.emit("start",{bpm:this.bpm,timeSignature:this.timeSignature,pattern:this.currentPattern}),this.update())}stop(){this.isPlaying&&(this.isPlaying=!1,this.emit("stop",{totalBeats:this.currentBeat,totalBars:this.currentBar}))}update(){if(!this.isPlaying)return;const e=(performance.now()-this.startTime)/this.beatDuration,t=Math.floor(e);this.beatProgress=e%1,t>this.currentBeat&&this.onBeat(t);const i=Math.floor(t/this.timeSignature[0]);i>this.currentBar&&this.onBar(i),this.currentBeat=t,this.currentBar=i,this.barProgress=t%this.timeSignature[0]/this.timeSignature[0],this.updateSubdivisions(),this.emit("update",this.getTimeInfo()),this.isPlaying&&requestAnimationFrame(()=>this.update())}onBeat(e){const t=e%this.timeSignature[0],i=this.getAccent(t),a=this.humanize*(Math.random()-.5)*this.beatDuration,n={beat:e,beatInBar:t,bar:this.currentBar,accent:i,intensity:this.intensity*i,humanTiming:a,timestamp:performance.now()};this.emit("beat",n),this.beatCallbacks.forEach(e=>e(n)),this.lastBeatTime=performance.now(),this.nextBeatTime=this.lastBeatTime+this.beatDuration}onBar(e){const t={bar:e,timeSignature:this.timeSignature,pattern:this.currentPattern,timestamp:performance.now()};this.emit("bar",t),this.barCallbacks.forEach(e=>e(t))}updateSubdivisions(){if(this.subdivisions.sixteenth=4*this.beatProgress%1,this.subdivisions.eighth=2*this.beatProgress%1,this.subdivisions.triplet=3*this.beatProgress%1,this.groove>0){const e=.5+.17*this.groove;this.subdivisions.eighth<.5?this.subdivisions.swing=this.subdivisions.eighth/e:this.subdivisions.swing=.5+(this.subdivisions.eighth-.5)/(1-e)}else this.subdivisions.swing=this.subdivisions.eighth}getAccent(e){if(this.currentPattern&&this.patterns.has(this.currentPattern)){const t=this.patterns.get(this.currentPattern);if(t.accents&&void 0!==t.accents[e])return t.accents[e]}return 0===e?1:2===e&&4===this.timeSignature[0]?.7:.5}getTimeInfo(){return{elapsed:performance.now()-this.startTime,beat:this.currentBeat,bar:this.currentBar,beatInBar:this.currentBeat%this.timeSignature[0],beatProgress:this.beatProgress,barProgress:this.barProgress,subdivisions:{...this.subdivisions},bpm:this.bpm,beatDuration:this.beatDuration,timeSignature:[...this.timeSignature],intensity:this.intensity,groove:this.groove,pattern:this.currentPattern,nextBeatIn:this.nextBeatTime-performance.now(),accent:this.getAccent(this.currentBeat%this.timeSignature[0])}}setBPM(e){this.bpm=Math.max(20,Math.min(360,e)),this.beatDuration=6e4/this.bpm,this.barDuration=this.beatDuration*this.timeSignature[0],this.emit("tempoChange",{bpm:this.bpm})}setTimeSignature(e,t){this.timeSignature=[e,t],this.barDuration=this.beatDuration*e,this.emit("timeSignatureChange",{timeSignature:this.timeSignature})}setPattern(e){if(!this.patterns.has(e))return;const t=this.patterns.get(e);this.currentPattern=e,t.timeSignature&&this.setTimeSignature(...t.timeSignature),void 0!==t.groove&&(this.groove=t.groove),this.emit("patternChange",{pattern:e})}onBeatCallback(e){return this.beatCallbacks.add(e),()=>this.beatCallbacks.delete(e)}onBarCallback(e){return this.barCallbacks.add(e),()=>this.barCallbacks.delete(e)}emit(e,t){this.listeners.has(e)&&this.listeners.get(e).forEach(e=>e(t))}on(e,t){return this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e).add(t),()=>{this.listeners.has(e)&&this.listeners.get(e).delete(t)}}syncToAudio(e,t){this.audioSync={context:e,source:t}}getAdapter(){return{getTimeInfo:()=>this.getTimeInfo(),isOnBeat:(e=.1)=>this.beatProgress<e||this.beatProgress>1-e,isOnSubdivision:(e,t=.1)=>{const i=this.subdivisions[e]||0;return i<t||i>1-t},getBeatSync:(e=0,t=1,i="linear")=>{let a=this.beatProgress;switch(i){case"ease":a=.5-Math.cos(a*Math.PI)/2;break;case"bounce":a=Math.abs(Math.sin(a*Math.PI));break;case"pulse":a=Math.pow(Math.sin(a*Math.PI),2)}return e+(t-e)*a},getAccentedValue:(e,t=2)=>e*(1+(this.getAccent(this.currentBeat%this.timeSignature[0])-.5)*t),onBeat:e=>this.onBeatCallback(e),onBar:e=>this.onBarCallback(e),beatsToMs:e=>e*this.beatDuration,msToBeats:e=>e/this.beatDuration,isPlaying:()=>this.isPlaying,getBPM:()=>this.bpm,getPattern:()=>this.currentPattern}}},"undefined"!=typeof window&&(window.__emotiveRhythmEngine=zi));const Li={groove1:{name:"groove1",description:"Subtle, elegant - gentle bounce and sway",bounceAmount:.015,swayAmount:.012,pulseAmount:.02,rotationAmount:.015,bounceFreq:1,swayFreq:.5,phaseOffset:0,easing:"sine"},groove2:{name:"groove2",description:"Energetic, bouncy - pronounced vertical motion",bounceAmount:.035,swayAmount:.02,pulseAmount:.045,rotationAmount:.025,bounceFreq:1,swayFreq:1,phaseOffset:0,easing:"bounce"},groove3:{name:"groove3",description:"Smooth, flowing - emphasis on rotation and sway",bounceAmount:.01,swayAmount:.03,pulseAmount:.015,rotationAmount:.04,bounceFreq:.5,swayFreq:.25,phaseOffset:Math.PI/4,easing:"sine"}},Gi="groove1";class Vi{constructor(){this.enabled=!1,this.adapter=null,this.beatProgress=0,this.barProgress=0,this.accent=.5,this.intensity=1,this.bpm=120,this.isOnBeat=!1,this.pattern=null,this.grooveEnabled=!0,this.currentGroove=Gi,this.targetGroove=Gi,this.grooveTransition=0,this.grooveTransitionSpeed=2,this.grooveConfidence=1,this.bpmMultiplier=1,this.modulation={scaleMultiplier:1,glowMultiplier:1,positionMultiplier:1,rotationMultiplier:1,accentBoost:0,grooveOffset:[0,0,0],grooveScale:1,grooveRotation:[0,0,0],grooveGlow:1},this._target={scaleMultiplier:1,glowMultiplier:1,positionMultiplier:1,rotationMultiplier:1,accentBoost:0,grooveOffset:[0,0,0],grooveScale:1,grooveRotation:[0,0,0],grooveGlow:1},this.config={beatSyncStrength:.3,accentMultiplier:1.5,smoothingSpeed:8,grooveSmoothingSpeed:12},this._maxDeltaTime=.05,this._pendingGroove=null,this._pendingGrooveOptions=null}_lerp(e,t,i,a){return e+(t-e)*(1-Math.exp(-i*a))}_lerpArray(e,t,i,a){const n=1-Math.exp(-i*a);return e.map((e,i)=>e+(t[i]-e)*n)}_applyEasing(e,t){switch(t){case"bounce":return Math.sign(e)*Math.pow(Math.abs(e),.6);case"elastic":return e*(1+.15*Math.sin(Math.abs(e)*Math.PI*2));default:return e}}_getGroovePreset(e){return Li[e]||Li[Gi]}_interpolatePresets(e,t,i){return{bounceAmount:e.bounceAmount+(t.bounceAmount-e.bounceAmount)*i,swayAmount:e.swayAmount+(t.swayAmount-e.swayAmount)*i,pulseAmount:e.pulseAmount+(t.pulseAmount-e.pulseAmount)*i,rotationAmount:e.rotationAmount+(t.rotationAmount-e.rotationAmount)*i,bounceFreq:e.bounceFreq+(t.bounceFreq-e.bounceFreq)*i,swayFreq:e.swayFreq+(t.swayFreq-e.swayFreq)*i,phaseOffset:e.phaseOffset+(t.phaseOffset-e.phaseOffset)*i}}initialize(){this.adapter=zi.getAdapter(),this.enabled=!0,this.adapter.onBeat(e=>{this.accent=e.accent,this.isOnBeat=!0,setTimeout(()=>{this.isOnBeat=!1},100)})}start(e=120,t="straight"){this.enabled||this.initialize(),e&&zi.setBPM(e),t&&zi.setPattern(t),zi.start()}stop(){zi.stop()}setBPM(e){zi.setBPM(e),this.bpm=e}setPattern(e){zi.setPattern(e),this.pattern=e}setGroove(e,t={}){if(Li[e]){if(!(this.currentGroove===e&&this.grooveTransition>=1)){if(t.quantize)return this._pendingGroove=e,void(this._pendingGrooveOptions={...t,quantize:!1});if(this.targetGroove=e,t.bars||t.duration)if(this.grooveTransition=0,t.bars){const e=60/this.bpm*4,i=t.bars*e;this.grooveTransitionSpeed=1/i}else t.duration&&(this.grooveTransitionSpeed=1/t.duration);else this.currentGroove=e,this.grooveTransition=1}}else console.warn(`[Rhythm3DAdapter] Unknown groove preset: ${e}`)}getGroovePresets(){return Object.keys(Li)}getCurrentGroove(){return this.grooveTransition>=1?this.targetGroove:this.currentGroove}update(e){const t=Math.min(e/1e3,this._maxDeltaTime);if(this.adapter||(this.adapter=zi.getAdapter()),!this.adapter)return void this.resetModulation(t);if(!this.adapter.isPlaying())return void this.resetModulation(t);this.enabled=!0;const i=this.adapter.getTimeInfo();this.beatProgress=i.beatProgress,this.barProgress=i.barProgress,this.intensity=i.intensity,this.bpm=i.bpm||this.bpm,this.pattern=i.pattern,this._pendingGroove&&this.barProgress<.05&&(this.setGroove(this._pendingGroove,this._pendingGrooveOptions||{}),this._pendingGroove=null,this._pendingGrooveOptions=null),this.grooveTransition<1&&(this.grooveTransition=Math.min(1,this.grooveTransition+this.grooveTransitionSpeed*t),this.grooveTransition>=1&&(this.currentGroove=this.targetGroove)),this.computeModulation(),this.applySmoothing(t)}computeModulation(){const{beatSyncStrength:e,accentMultiplier:t}=this.config,i=this.beatProgress*Math.PI*2,a=.5*(Math.cos(i)+1);this._target.scaleMultiplier=1+a*e*.4,this._target.glowMultiplier=1+a*e*.8,this._target.positionMultiplier=1+a*e*.2,this._target.rotationMultiplier=1+a*e*.15,this._target.accentBoost=this.isOnBeat?(this.accent-.5)*t:0,this.grooveEnabled?this.computeGroove():(this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0])}computeGroove(){const e=this._getGroovePreset(this.currentGroove),t=this._getGroovePreset(this.targetGroove),i=this.grooveTransition>=1?t:this._interpolatePresets(e,t,this.grooveTransition),a=this.grooveConfidence,n=i.bounceAmount*a,s=i.swayAmount*a,r=i.pulseAmount*a,o=i.rotationAmount*a,{bounceFreq:l,swayFreq:c,phaseOffset:h,easing:u}=i,d=this.beatProgress*l*this.bpmMultiplier*Math.PI*2+h,m=Math.sin(d),p=this._applyEasing(m,u),g=this.barProgress*c*this.bpmMultiplier*Math.PI*2+h,f=Math.sin(g),y=this._applyEasing(f,u),v=.5*(Math.cos(this.beatProgress*Math.PI*2)+1),b=Math.max(0,this.accent-.4)/.6,w=v*b*.25,M=p*n*(1+w),S=y*s,x=Math.sin(d),C=1+this._applyEasing(x,u)*r*(1+.5*w),P=y*o,k=Math.sin(g+Math.PI/3)*s*.3,D=Math.sin(.5*g)*o*.4,A=Math.cos(.7*d)*o*.25,_=1+.5*(Math.cos(d)+1)*.12*a+v*b*.12;this._target.grooveOffset=[S,M,k],this._target.grooveScale=C,this._target.grooveRotation=[D,A,P],this._target.grooveGlow=_}applySmoothing(e){const{smoothingSpeed:t,grooveSmoothingSpeed:i}=this.config;this.modulation.scaleMultiplier=this._lerp(this.modulation.scaleMultiplier,this._target.scaleMultiplier,t,e),this.modulation.glowMultiplier=this._lerp(this.modulation.glowMultiplier,this._target.glowMultiplier,t,e),this.modulation.positionMultiplier=this._lerp(this.modulation.positionMultiplier,this._target.positionMultiplier,t,e),this.modulation.rotationMultiplier=this._lerp(this.modulation.rotationMultiplier,this._target.rotationMultiplier,t,e),this.modulation.accentBoost=this._lerp(this.modulation.accentBoost,this._target.accentBoost,.5*t,e),this.modulation.grooveOffset=this._lerpArray(this.modulation.grooveOffset,this._target.grooveOffset,i,e),this.modulation.grooveScale=this._lerp(this.modulation.grooveScale,this._target.grooveScale,i,e),this.modulation.grooveRotation=this._lerpArray(this.modulation.grooveRotation,this._target.grooveRotation,i,e),this.modulation.grooveGlow=this._lerp(this.modulation.grooveGlow,this._target.grooveGlow,i,e)}resetModulation(e=.016){this._target.scaleMultiplier=1,this._target.glowMultiplier=1,this._target.positionMultiplier=1,this._target.rotationMultiplier=1,this._target.accentBoost=0,this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0],this._target.grooveGlow=1,this.modulation.scaleMultiplier=this._lerp(this.modulation.scaleMultiplier,1,4,e),this.modulation.glowMultiplier=this._lerp(this.modulation.glowMultiplier,1,4,e),this.modulation.positionMultiplier=this._lerp(this.modulation.positionMultiplier,1,4,e),this.modulation.rotationMultiplier=this._lerp(this.modulation.rotationMultiplier,1,4,e),this.modulation.accentBoost=this._lerp(this.modulation.accentBoost,0,4,e),this.modulation.grooveOffset=this._lerpArray(this.modulation.grooveOffset,[0,0,0],4,e),this.modulation.grooveScale=this._lerp(this.modulation.grooveScale,1,4,e),this.modulation.grooveRotation=this._lerpArray(this.modulation.grooveRotation,[0,0,0],4,e),this.modulation.grooveGlow=this._lerp(this.modulation.grooveGlow,1,4,e)}getModulation(){return this.modulation}getMusicalDuration(e,t=null){if(!this.enabled||!this.adapter||!this.adapter.isPlaying())return e;if(t?.durationSync){const e=t.durationSync;if("beats"===e.mode&&e.beats)return this.adapter.beatsToMs(e.beats);if("bars"===e.mode&&e.bars)return this.adapter.beatsToMs(4*e.bars)}return e}isOnBeatNow(e=.1){return!(!this.enabled||!this.adapter)&&this.adapter.isOnBeat(e)}isOnAccent(e=.7){return this.isOnBeat&&this.accent>=e}getBeatSync(e,t,i="pulse"){return this.enabled&&this.adapter?this.adapter.getBeatSync(e,t,i):e}getAccentedValue(e,t=2){return this.enabled&&this.adapter?this.adapter.getAccentedValue(e,t):e}setGrooveEnabled(e){this.grooveEnabled=e,e||(this._target.grooveOffset=[0,0,0],this._target.grooveScale=1,this._target.grooveRotation=[0,0,0])}setGrooveConfidence(e){this.grooveConfidence=Math.max(0,Math.min(1,e))}setBPMMultiplier(e){this.bpmMultiplier=Math.max(.25,Math.min(4,e))}getBPMMultiplier(){return this.bpmMultiplier}setGrooveConfig(e){Object.assign(this.config,e)}setBeatSyncStrength(e){this.config.beatSyncStrength=Math.max(0,Math.min(1,e))}isPlaying(){return this.enabled&&this.adapter&&this.adapter.isPlaying()}getBPM(){return this.bpm}getPattern(){return this.pattern}destroy(){this.enabled=!1,this.adapter=null,this.resetModulation()}}const Ni=new Vi;class ji{constructor(){this.isTransitioning=!1,this.currentGeometryType=null,this.targetGeometryType=null,this.morphStartTime=0,this.morphDuration=1e3,this.morphProgress=0,this.visualProgress=0,this.hasSwappedGeometry=!1,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.easing="easeInOutCubic"}startMorph(e,t,i=1e3){if(e===t&&!this.isTransitioning)return!1;if(this.isTransitioning&&this.targetGeometryType===t)return!1;if(this.isTransitioning){const e=this.calculateScaleMultiplier(this.visualProgress);if(this.hasSwappedGeometry){this.morphStartTime=Date.now(),this.morphDuration=i;const a=e>0?Math.sqrt(1-Math.min(e,1))/2:.5;this.morphProgress=a,this.visualProgress=a,this.hasSwappedGeometry=!1,this.targetGeometryType=t,this._interruptedTarget=t,this.isPausedAtSwap=!1,this.isGrowIn=!1;const n=a*i;return this.morphStartTime=Date.now()-n,!0}return this.targetGeometryType=t,this._interruptedTarget=t,!0}return this.currentGeometryType=e,this.targetGeometryType=t,this.morphStartTime=Date.now(),this.morphDuration=i,this.morphProgress=0,this.visualProgress=0,this.isTransitioning=!0,this.hasSwappedGeometry=!1,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.isGrowIn=!1,this._interruptedTarget=null,!0}getInterruptedTarget(){const e=this._interruptedTarget;return this._interruptedTarget=null,e}growIn(e,t=500){return!this.isTransitioning&&(this.currentGeometryType=e,this.targetGeometryType=e,this.morphStartTime=Date.now(),this.morphDuration=t,this.morphProgress=0,this.visualProgress=0,this.isTransitioning=!0,this.hasSwappedGeometry=!0,this.isPausedAtSwap=!1,this.pausedAtTime=0,this.isGrowIn=!0,!0)}pauseAtSwap(){this.isTransitioning&&!this.isPausedAtSwap&&(this.isPausedAtSwap=!0,this.pausedAtTime=Date.now())}resumeFromSwap(){if(this.isPausedAtSwap){const e=Date.now()-this.pausedAtTime;this.morphStartTime+=e,this.isPausedAtSwap=!1,this.pausedAtTime=0}}update(e){if(!this.isTransitioning)return{isTransitioning:!1,progress:0,visualProgress:0,scaleMultiplier:1};if(this.isPausedAtSwap)return{isTransitioning:!0,progress:.5,visualProgress:.5,scaleMultiplier:0,waitingForGeometry:!0};const t=Date.now()-this.morphStartTime,i=Math.min(t/this.morphDuration,1);this.morphProgress=this.applyEasing(i),this.visualProgress=.6*this.visualProgress+.4*this.morphProgress,Math.abs(this.visualProgress-this.morphProgress)<.01&&(this.visualProgress=this.morphProgress);const a=this.calculateScaleMultiplier(this.visualProgress);let n=!1;return!this.hasSwappedGeometry&&this.morphProgress>=.5&&(this.hasSwappedGeometry=!0,n=!0),this.morphProgress>=1?(this.completeMorph(),{isTransitioning:!1,progress:1,visualProgress:1,scaleMultiplier:1,completed:!0}):{isTransitioning:!0,progress:this.morphProgress,visualProgress:this.visualProgress,scaleMultiplier:a,shouldSwapGeometry:n}}calculateScaleMultiplier(e){if(this.isGrowIn){const t=1.70158,i=1+(t+1)*Math.pow(e-1,3)+t*Math.pow(e-1,2);return Math.max(0,i)}if(e<=.5){const t=2*e;return 1-t*t}{const t=2*(e-.5);return t*(2-t)}}completeMorph(){this.currentGeometryType=this.targetGeometryType,this.targetGeometryType=null,this.isTransitioning=!1,this.morphProgress=0,this.visualProgress=0}applyEasing(e){switch(this.easing){case"linear":return e;case"easeInQuad":return e*e;case"easeOutQuad":return e*(2-e);case"easeInOutQuad":return e<.5?2*e*e:(4-2*e)*e-1;case"easeInOutSine":return-(Math.cos(Math.PI*e)-1)/2;default:return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}}getState(){return{isTransitioning:this.isTransitioning,currentGeometryType:this.currentGeometryType,targetGeometryType:this.targetGeometryType,progress:this.morphProgress,visualProgress:this.visualProgress}}cancel(){this.isTransitioning=!1,this.targetGeometryType=null,this.morphProgress=0,this.visualProgress=0}}const qi={none:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1,"3d":{rotation:{speedMultiplier:1,shakeMultiplier:1},glow:{intensityMultiplier:1,pulseSpeedMultiplier:1},scale:{breathDepthMultiplier:1,breathRateMultiplier:1},righting:{strengthMultiplier:1}}},clear:{speed:1,amplitude:1,intensity:1,smoothness:1,regularity:1,"3d":{rotation:{speedMultiplier:1,shakeMultiplier:1},glow:{intensityMultiplier:1,pulseSpeedMultiplier:1},scale:{breathDepthMultiplier:1,breathRateMultiplier:1},righting:{strengthMultiplier:1}}},nervous:{speed:1.2,amplitude:.9,intensity:1.1,smoothness:.7,regularity:.6,addFlutter:!0,addMicroShake:!0,"3d":{rotation:{speedMultiplier:1.5,shakeMultiplier:3.5,enableEpisodicWobble:!0},glow:{intensityMultiplier:1.25,pulseSpeedMultiplier:2},scale:{breathDepthMultiplier:.5,breathRateMultiplier:1.8},righting:{strengthMultiplier:.7}}},confident:{speed:.9,amplitude:1.3,intensity:1.2,smoothness:1.1,regularity:1.2,addPower:!0,addHold:!0,"3d":{rotation:{speedMultiplier:.7,shakeMultiplier:.2},glow:{intensityMultiplier:1.4,pulseSpeedMultiplier:.7},scale:{breathDepthMultiplier:1.5,breathRateMultiplier:.7},righting:{strengthMultiplier:1.6}}},tired:{speed:.7,amplitude:.7,intensity:.8,smoothness:1.3,regularity:.8,addDroop:!0,addPause:!0,"3d":{rotation:{speedMultiplier:.4,shakeMultiplier:.15},glow:{intensityMultiplier:.5,pulseSpeedMultiplier:.5},scale:{breathDepthMultiplier:1.3,breathRateMultiplier:.5},righting:{strengthMultiplier:.6}}},intense:{speed:1.3,amplitude:1.2,intensity:1.4,smoothness:.6,regularity:.9,addPulse:!0,addFocus:!0,"3d":{rotation:{speedMultiplier:1.6,shakeMultiplier:2.5},glow:{intensityMultiplier:1.8,pulseSpeedMultiplier:2.2},scale:{breathDepthMultiplier:1.6,breathRateMultiplier:1.8},righting:{strengthMultiplier:1.3}}},subdued:{speed:.8,amplitude:.8,intensity:.7,smoothness:1.2,regularity:1.1,addSoftness:!0,addFade:!0,"3d":{rotation:{speedMultiplier:.5,shakeMultiplier:.1},glow:{intensityMultiplier:.55,pulseSpeedMultiplier:.6},scale:{breathDepthMultiplier:.7,breathRateMultiplier:.6},righting:{strengthMultiplier:1.4}}}};function Ui(e){return e&&""!==e&&"clear"!==e&&qi[e]||qi.clear}function Wi(e,t=0,i="glow"){const a=function(e){const t=parseInt(e.slice(1,3),16)/255,i=parseInt(e.slice(3,5),16)/255,a=parseInt(e.slice(5,7),16)/255,n=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4);return.2126*n(t)+.7152*n(i)+.0722*n(a)}(e),n=(.5+t)/Math.max(a,.05);return Math.max(.3,Math.min(10,n))}function Hi(e){return 3===(e=e.replace("#","")).length&&(e=e.split("").map(e=>e+e).join("")),{r:parseInt(e.substr(0,2),16),g:parseInt(e.substr(2,2),16),b:parseInt(e.substr(4,2),16)}}const $i={intense:1.6,confident:1.3,nervous:1.15,clear:1,tired:.8,subdued:.5};function Yi(e,t){if(!t||"clear"===t)return e;const i=$i[t.toLowerCase()];return i&&1!==i?function(e,t){const i=Hi(e),a=function(e,t,i){e/=255,t/=255,i/=255;const a=Math.max(e,t,i),n=Math.min(e,t,i),s=(a+n)/2;let r,o;if(a===n)r=o=0;else{const l=a-n;switch(o=s>.5?l/(2-a-n):l/(a+n),a){case e:r=(t-i)/l+(t<i?6:0);break;case t:r=(i-e)/l+2;break;case i:r=(e-t)/l+4}r/=6}return{h:360*r,s:100*o,l:100*s}}(i.r,i.g,i.b);a.s=Math.max(0,Math.min(100,a.s*t));const n=function(e,t,i){e/=360,i/=100;const a=(e,t,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?e+6*(t-e)*i:i<.5?t:i<2/3?e+(t-e)*(2/3-i)*6:e);let n,s,r;if(0==(t/=100))n=s=r=i;else{const o=i<.5?i*(1+t):i+t-i*t,l=2*i-o;n=a(l,o,e+1/3),s=a(l,o,e),r=a(l,o,e-1/3)}return{r:Math.round(255*n),g:Math.round(255*s),b:Math.round(255*r)}}(a.h,a.s,a.l);return function(e,t,i){const a=e=>{const t=Math.round(Math.max(0,Math.min(255,e))).toString(16);return 1===t.length?`0${t}`:t};return`#${a(e)}${a(t)}${a(i)}`}(n.r,n.g,n.b)}(e,i):e}Object.fromEntries(Object.entries({neutral:"#B0B0B0",joy:"#FFD700",sadness:"#4169E1",anger:"#DC143C",fear:"#8B008B",surprise:"#FF8C00",disgust:"#9ACD32",love:"#FF69B4"}).map(([e,t])=>{const i=Hi(t);return[e,`${i.r}, ${i.g}, ${i.b}`]}));const Xi=new class{constructor(){this.enabled=!1,this.adapter=null,this.subsystemConfigs=new Map,this.activeModulations=new Map}initialize(){this.adapter=zi.getAdapter(),this.enabled=!0,this.adapter.onBeat(this.handleBeat.bind(this)),this.adapter.onBar(this.handleBar.bind(this))}updateBPM(e){if(e>=60&&e<=220){if(window.rhythmManuallyStoppedForCurrentAudio)return;if(!zi.isRunning)return this.start(e,"straight"),void(window.rhythmSyncVisualizer&&!window.rhythmSyncVisualizer.state.active&&window.rhythmSyncVisualizer.start());zi.setBPM(e)}}registerConfig(e,t,i){if(!i.rhythm||!i.rhythm.enabled)return;const a=`${e}:${t}`;this.subsystemConfigs.set(a,{type:e,name:t,rhythmConfig:i.rhythm,originalConfig:i})}applyGestureRhythm(e,t,i,a){if(!this.enabled||!e.rhythm?.enabled)return{};const n=e.rhythm,s={};if(n.amplitudeSync){const e=n.amplitudeSync,t=this.adapter.getBeatSync(e.offBeat||.8,e.onBeat||1.5,e.curve||"linear");s.amplitudeMultiplier=t}if(n.wobbleSync){const e=n.wobbleSync;this.adapter.isOnSubdivision(e.subdivision,.1)?s.wobbleMultiplier=1+e.intensity:s.wobbleMultiplier=1}if(n.accentResponse?.enabled){const e=this.adapter.getAccentedValue(1,n.accentResponse.multiplier||1.5);s.accentMultiplier=e}const r=this.adapter.getPattern();return r&&n.patternOverrides?.[r]&&Object.assign(s,n.patternOverrides[r]),s}applyParticleRhythm(e,t){if(!this.enabled||!e.rhythm?.enabled)return{};const i=this.adapter.getTimeInfo(),a=e.rhythm,n={};if(a.particleEmission){const e=a.particleEmission;"beat"===e.syncMode&&this.adapter.isOnBeat(.1)?n.emitBurst=e.burstSize||3:void 0!==e.offBeatRate&&(n.emissionRate=e.offBeatRate)}if(a.glowSync){const e=a.glowSync,t=this.adapter.getBeatSync(e.intensityRange[0]||1,e.intensityRange[1]||2,"pulse");n.glowIntensity=t}if("bars"===a.breathSync?.mode){const e=a.breathSync,t=i.bar%e.barsPerBreath/e.barsPerBreath;n.breathPhase=t*Math.PI*2}return n}applyBehaviorRhythm(e,t,i){if(!this.enabled||!e.rhythm?.enabled)return{};const a=this.adapter.getTimeInfo(),n=e.rhythm,s={};if(n.glitchTiming){const e=n.glitchTiming;if(this.adapter.isOnSubdivision(e.subdivision,.05)&&Math.random()<e.probability){const t=this.adapter.isOnBeat()?e.intensityOnBeat:e.intensityOffBeat;s.triggerGlitch=!0,s.glitchIntensity=t}}if(n.orbitRhythm){const e=n.orbitRhythm;"tempo"===e.baseSpeed&&(s.speedMultiplier=this.adapter.getBPM()/120),e.beatAcceleration&&this.adapter.isOnBeat(.1)&&(s.speedBoost=e.beatAcceleration),e.barReset&&0===a.beatInBar&&(s.resetOrbit=!0)}if(n.stutterSync){const e=n.stutterSync,t=this.adapter.getPattern();if(t&&e.patterns?.[t]){const i=e.patterns[t];i.freezeOnDrop&&2===a.beatInBar?(s.freeze=!0,s.freezeDuration=i.dropDuration):i.randomFreeze&&Math.random()<i.randomFreeze&&(s.freeze=!0,s.freezeDuration=i.duration)}}return s}handleBeat(e){this.lastBeatInfo=e}handleBar(e){this.lastBarInfo=e}getMusicalDuration(e,t){if(!this.enabled||!e?.durationSync)return t;const i=e.durationSync;return"bars"===i.mode?this.adapter.beatsToMs(4*i.bars):"beats"===i.mode?this.adapter.beatsToMs(i.beats):t}isEnabled(){return this.enabled&&this.adapter.isPlaying()}start(e=120,t="straight"){e&&zi.setBPM(e),t&&zi.setPattern(t),zi.start(),this.enabled=!0}stop(){zi.stop(),this.enabled=!1,this.bpmLocked=!1,this.lockedBPM=null}setPattern(e){zi.setPattern(e)}setBPM(e){zi.setBPM(e),this.bpmLocked&&(this.lockedBPM=e)}resampleBPM(){this.bpmLocked=!1,this.lockedBPM=null}setTimeSignature(e){this.timeSignature=e;const t=document.getElementById("time-sig-display");t&&(t.textContent=e),"3/4"===e&&zi.getPattern()}syncToAudio(e,t){zi.syncToAudio(e,t)}},Qi=new class{constructor(){this.emotionCache=new Map,this.visualParamsCache=new Map,this.modifiersCache=new Map,this.transitionCache=new Map,this.stats={hits:0,misses:0,loadTime:0,cacheSize:0},this.isInitialized=!1,this.loadStartTime=0,this.initialize()}initialize(){this.loadStartTime=performance.now();try{const e=Ei();e.forEach(e=>{this.cacheEmotion(e)}),this.cacheCommonTransitions(e),this.isInitialized=!0,this.stats.loadTime=performance.now()-this.loadStartTime,this.stats.cacheSize=this.emotionCache.size}catch(e){console.error("[EmotionCache] Initialization failed:",e),this.isInitialized=!1}}cacheEmotion(e){try{const t=Ii(e);t&&this.emotionCache.set(e,t);const i=Oi(e);this.visualParamsCache.set(e,i);const a=Ri(e);this.modifiersCache.set(e,a)}catch(t){console.warn(`[EmotionCache] Failed to cache emotion '${e}':`,t)}}cacheCommonTransitions(e){[["neutral","joy"],["neutral","sadness"],["neutral","anger"],["joy","sadness"],["sadness","joy"],["anger","calm"],["calm","anger"]].forEach(([t,i])=>{if(e.includes(t)&&e.includes(i))try{const e=Bi(t,i),a=`${t}->${i}`;this.transitionCache.set(a,e)}catch(e){console.warn(`[EmotionCache] Failed to cache transition '${t}->${i}':`,e)}})}getEmotion(e){if(!this.isInitialized)return console.warn("[EmotionCache] Cache not initialized, falling back to direct access"),Ii(e);const t=this.emotionCache.get(e);return t?(this.stats.hits++,t):(this.stats.misses++,console.warn(`[EmotionCache] Cache miss for emotion '${e}', consider adding to pre-cache`),Ii(e))}getVisualParams(e){if(!this.isInitialized)return Oi(e);const t=this.visualParamsCache.get(e);return t?(this.stats.hits++,t):(this.stats.misses++,Oi(e))}getModifiers(e){if(!this.isInitialized)return Ri(e);const t=this.modifiersCache.get(e);return t?(this.stats.hits++,t):(this.stats.misses++,Ri(e))}getTransitionParams(e,t){if(!this.isInitialized)return Bi(e,t);const i=`${e}->${t}`,a=this.transitionCache.get(i);return a?(this.stats.hits++,a):(this.stats.misses++,Bi(e,t))}hasEmotion(e){return this.emotionCache.has(e)}getStats(){const e=this.stats.hits+this.stats.misses,t=e>0?(this.stats.hits/e*100).toFixed(2):0;return{isInitialized:this.isInitialized,loadTime:this.stats.loadTime,cacheSize:this.stats.cacheSize,hits:this.stats.hits,misses:this.stats.misses,hitRate:`${t}%`,emotions:this.emotionCache.size,visualParams:this.visualParamsCache.size,modifiers:this.modifiersCache.size,transitions:this.transitionCache.size}}clear(){this.emotionCache.clear(),this.visualParamsCache.clear(),this.modifiersCache.clear(),this.transitionCache.clear(),this.isInitialized=!1,this.stats={hits:0,misses:0,loadTime:0,cacheSize:0}}reinitialize(){this.clear(),this.initialize()}};function Ki(e){if(!e||0===e.length)return"#FFFFFF";let t=0,i=0;const a=[];for(const n of e)"string"==typeof n?(a.push({color:n,weight:null}),i++):n&&"object"==typeof n&&n.color&&(a.push({color:n.color,weight:n.weight||null}),n.weight?t+=n.weight:i++);const n=Math.max(0,100-t),s=i>0?n/i:0,r=[];let o=0;for(const e of a)o+=null!==e.weight?e.weight:s,r.push({color:e.color,threshold:o});const l=Math.random()*o;for(const e of r)if(l<=e.threshold)return e.color;return a[a.length-1].color}var Zi={name:"ambient",emoji:"☁️",description:"Gentle upward drift like smoke",initialize:function(e){e.vx=0,e.vy=-.04-.02*Math.random(),e.lifeDecay=.002,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={upwardSpeed:5e-4,waviness:0,friction:.998}},update:function(e,t,i,a){const n=e.behaviorData;e.vy*=Math.pow(n.friction,t),e.vy-=n.upwardSpeed*t,e.vx=0}};const Ji=2*Math.PI;var ea={name:"orbiting",emoji:"💕",description:"Romantic firefly dance around the orb",initialize:function(e){e.lifeDecay=.001+.002*Math.random(),e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.isSparkle="#FFE4E1"===e.color||"#FFCCCB"===e.color||"#FFC0CB"===e.color;const t=40*(e.scaleFactor||1)*(1.3+.9*Math.random());e.blinkPhase=Math.random()*Ji,e.blinkSpeed=.3+1.2*Math.random(),e.blinkIntensity=.6+.4*Math.random(),e.fadePhase=Math.random()*Ji,e.fadeSpeed=.1+.3*Math.random(),e.minOpacity=.2+.2*Math.random(),e.maxOpacity=.8+.2*Math.random(),e.isSparkle&&(e.blinkSpeed*=2,e.blinkIntensity=1,e.minOpacity=0,e.maxOpacity=1),e.behaviorData={angle:Math.random()*Ji,radius:t,baseRadius:t,angularVelocity:8e-4+.0017*Math.random(),swayAmount:3+7*Math.random(),swaySpeed:.2+.5*Math.random(),floatOffset:Math.random()*Ji,floatSpeed:.3+.7*Math.random(),floatAmount:2+6*Math.random(),twinklePhase:Math.random()*Ji,twinkleSpeed:2+3*Math.random()}},update:function(e,t,i,a){const n=e.behaviorData;n.angle+=n.angularVelocity*t;const s=Math.sin(n.angle*n.swaySpeed)*n.swayAmount,r=6*Math.sin(1.5*n.angle),o=(n.radius||n.baseRadius)+r+.2*s,l=i+Math.cos(n.angle)*o,c=a+Math.sin(n.angle)*o;n.floatOffset+=n.floatSpeed*t*.001;const h=Math.sin(n.floatOffset)*n.floatAmount;e.vx=.1*(l-e.x),e.vy=.1*(c+h-e.y),e.fadePhase+=e.fadeSpeed*t*.001;const u=.5*Math.sin(e.fadePhase)+.5,d=e.minOpacity+(e.maxOpacity-e.minOpacity)*u;let m;e.blinkPhase+=e.blinkSpeed*t*.002,e.isSparkle?(n.twinklePhase+=n.twinkleSpeed*t*.001,m=.7*Math.pow(Math.sin(n.twinklePhase),16)+.2*Math.sin(5*e.blinkPhase)+.1):m=.4*Math.sin(e.blinkPhase)+.3*Math.sin(3*e.blinkPhase)+.2*Math.sin(7*e.blinkPhase)+.1*Math.sin(11*e.blinkPhase);const p=.5*(m+1),g=.2+p*e.blinkIntensity*.8;e.opacity=e.baseOpacity*d*g,e.isSparkle?e.size=e.baseSize*(.5+1*p):e.size=e.baseSize*(.8+.3*p),e.isSparkle&&(e.tempColor=p>.85?"#FFFFFF":e.color)}},ta={name:"rising",emoji:"🎈",description:"Buoyant upward movement like balloons",initialize:function(e){e.vx=.02*(Math.random()-.5),e.vy=-.05-.03*Math.random(),e.lifeDecay=.002,e.baseOpacity=.7+.3*Math.random(),e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={buoyancy:.001,driftAmount:.005}},update:function(e,t,i,a){const n=e.behaviorData;e.vy-=n.buoyancy*t,e.vx+=(Math.random()-.5)*n.driftAmount*t,e.vx*=Math.pow(.995,t),e.vy*=Math.pow(.998,t)}};function ia(e){e.fallingData||(e.fallingData={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??e.life??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),fallProgress:0}),e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors));const t=Math.random(),i=Math.random(),a=t*Math.PI*2,n=2*i-1,s=Math.sqrt(1-n*n);e.behaviorData={fallSpeed:8,fallDistance:400,wobbleAmount:1.5,fallingDir:{x:s*Math.cos(a),y:n,z:s*Math.sin(a)},orbitDistanceRatio:.7+.4*Math.random()}}var aa={name:"falling",emoji:"💧",description:"Heavy downward drift like tears",initialize:ia,update:function(e,t,i,a){const n=e.behaviorData;let s=e.fallingData;s||(ia(e),s=e.fallingData),s.fallProgress+=.02*t;const r=Math.min(s.fallProgress,1),o=n.fallDistance*r;s.wobblePhase+=s.wobbleSpeed*t*.1;const l=Math.sin(s.wobblePhase)*n.wobbleAmount;if(e.x=s.originalX+l,e.y=s.originalY+o,e.vx=.3*l,e.vy=10*n.fallSpeed,r>.6){const t=(r-.6)/.4;e.opacity=s.originalOpacity*(1-t),void 0!==e.life&&(e.life=s.originalOpacity*(1-t))}}};const na=2e3,sa=3,ra=8,oa=.7;var la={name:"popcorn",emoji:"🍿",description:"Spontaneous popping with gravity and bounces",initialize:function(e){if(e.vx=.1*(Math.random()-.5),e.vy=.1*(Math.random()-.5),e.lifeDecay=.008+.012*Math.random(),e.emotionColors&&e.emotionColors.length>0)e.color=Ki(e.emotionColors);else{const t=["#FFFFFF","#FFFACD","#FFF8DC","#FFFFE0","#FAFAD2"];e.color=Ki(t)}e.size=Math.random()<.3?(8+4*Math.random())*e.scaleFactor*e.particleSizeMultiplier:(2+4*Math.random())*e.scaleFactor*e.particleSizeMultiplier,e.baseSize=e.size,e.hasGlow=Math.random()<.2,e.glowSizeMultiplier=e.hasGlow?1.2:0,e.behaviorData={popDelay:Math.random()*na,hasPopped:!1,popStrength:sa+Math.random()*(ra-sa),gravity:.098,bounceDamping:oa,bounceCount:0,maxBounces:2+Math.floor(2*Math.random()),spinRate:10*(Math.random()-.5),lifetime:0}},update:function(e,t,i,a){const n=e.behaviorData;if(n.lifetime+=16.67*t,!n.hasPopped&&n.lifetime>n.popDelay){n.hasPopped=!0;const t=Math.random()*Math.PI*2;e.vx=Math.cos(t)*n.popStrength*1.5,e.vy=Math.sin(t)*n.popStrength-.3,e.size=1.25*e.baseSize}if(n.hasPopped){e.vy+=n.gravity*t;const i=a+100*e.scaleFactor;e.y>i&&n.bounceCount<n.maxBounces&&(e.y=i,e.vy=-Math.abs(e.vy)*n.bounceDamping,e.vx*=.9,n.bounceCount++,e.size=e.baseSize*(1.5-.1*n.bounceCount)),n.bounceCount>=n.maxBounces&&(e.lifeDecay=.03+.02*Math.random(),e.size*=.95),Math.sqrt(e.vx*e.vx+e.vy*e.vy)<.5&&(e.lifeDecay*=1.5)}}},ca={name:"burst",emoji:"💥",description:"Explosive expansion from center",initialize:function(e){const t="suspicion"===e.emotion,i="surprise"===e.emotion,a="glitch"===e.emotion,n=Math.random()*Ji,s=t?1+.8*Math.random():i?7+5*Math.random():a?2+1.5*Math.random():3.5+2.5*Math.random();e.vx=Math.cos(n)*s,e.vy=Math.sin(n)*s,e.lifeDecay=t?.01:i?.006+.008*Math.random():a?.012:.015,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),t&&(e.size=(6+4*Math.random())*(e.scaleFactor||1)*(e.particleSizeMultiplier||1),e.baseSize=e.size,e.opacity=1,e.baseOpacity=e.opacity),e.behaviorData={isSuspicion:t,isSurprise:i,isGlitch:a,age:0,fadeStart:t?.3:.2,glitchPhase:Math.random()*Math.PI*2,glitchIntensity:a?.3:0,glitchFrequency:a?.1:0}},update:function(e,t,i,a){const n=e.behaviorData;if(n.isSurprise)if(n.age+=.016*t,n.age<.15){const i=.98;e.vx*=Math.pow(i,t),e.vy*=Math.pow(i,t)}else if(n.age<.25){const i=.85;e.vx*=Math.pow(i,t),e.vy*=Math.pow(i,t)}else{const i=.99;e.vx*=Math.pow(i,t),e.vy*=Math.pow(i,t),e.vx+=.01*(Math.random()-.5)*t,e.vy+=.01*(Math.random()-.5)*t}else{const i=n.isSuspicion?.99:n.isGlitch?.97:.95;e.vx*=Math.pow(i,t),e.vy*=Math.pow(i,t)}if(n.isSuspicion){const i=.001*Date.now();e.vx+=.01*Math.sin(2*i+e.id)*t}if(n.isGlitch){n.age+=.016*t,n.glitchPhase+=n.glitchFrequency*t;const i=Math.sin(n.glitchPhase)*n.glitchIntensity*t,a=Math.cos(1.3*n.glitchPhase)*n.glitchIntensity*t;if(e.vx+=i,e.vy+=a,Math.random()<.02){const t=Math.random()*Math.PI*2,i=.5+.5*Math.random();e.vx+=Math.cos(t)*i,e.vy+=Math.sin(t)*i}}}},ha={name:"aggressive",emoji:"⚡",description:"Sharp, chaotic movement with violent bursts",initialize:function(e){const t=Math.random()*Ji,i=1.5+2*Math.random();e.vx=Math.cos(t)*i,e.vy=Math.sin(t)*i,e.lifeDecay=.015,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={acceleration:.05,jitter:.3,speedDecay:.95}},update:function(e,t,i,a){const n=e.behaviorData;if(e.vx+=(Math.random()-.5)*n.jitter*t,e.vy+=(Math.random()-.5)*n.jitter*t,e.vx*=Math.pow(n.speedDecay,t),e.vy*=Math.pow(n.speedDecay,t),Math.random()<Math.min(.05*t,.5)){const t=Math.random()*Ji;e.vx+=Math.cos(t)*n.acceleration,e.vy+=Math.sin(t)*n.acceleration}}},ua={name:"scattering",emoji:"😨",description:"Particles flee from center in panic",initialize:function(e){e.vx=0,e.vy=0,e.lifeDecay=.008,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={fleeSpeed:2,panicFactor:1.2,initialized:!1}},update:function(e,t,i,a){const n=e.behaviorData;if(!n.initialized){const t=e.x-i,s=e.y-a,r=Math.sqrt(t*t+s*s);if(r>0)e.vx=t/r*n.fleeSpeed,e.vy=s/r*n.fleeSpeed;else{const t=Math.random()*Ji;e.vx=Math.cos(t)*n.fleeSpeed,e.vy=Math.sin(t)*n.fleeSpeed}n.initialized=!0}const s=e.x-i,r=e.y-a,o=Math.sqrt(s*s+r*r);o>0&&(e.vx+=s/o*n.panicFactor*.01*t,e.vy+=r/o*n.panicFactor*.01*t),e.vx+=.1*(Math.random()-.5)*t,e.vy+=.1*(Math.random()-.5)*t,e.vx*=Math.pow(.98,t),e.vy*=Math.pow(.98,t)}},da={name:"repelling",emoji:"🚫",description:"Particles pushed away from center, maintaining distance",initialize:function(e){e.vx=0,e.vy=0,e.lifeDecay=.01,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={repelStrength:.8,minDistance:50,initialized:!1}},update:function(e,t,i,a){const n=e.behaviorData,s=e.x-i,r=e.y-a,o=Math.sqrt(s*s+r*r);if(!n.initialized||o<n.minDistance){if(o>0){const i=n.repelStrength/Math.max(o,5);e.vx+=s/o*i*t,e.vy+=r/o*i*t}n.initialized=!0}e.vx*=Math.pow(.99,t),e.vy*=Math.pow(.99,t)}},ma={name:"connecting",emoji:"🔗",description:"Chaotic movement with center attraction for social states",initialize:function(e){const t=Math.random()*Ji,i=2+5*Math.random();e.vx=Math.cos(t)*i,e.vy=Math.sin(t)*i,e.lifeDecay=.012,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={attractionForce:.008,chaosFactor:1,friction:.95}},update:function(e,t,i,a){const n=e.behaviorData;e.vx*=Math.pow(n.friction,t),e.vy*=Math.pow(n.friction,t);const s=(i-e.x)*n.attractionForce,r=(a-e.y)*n.attractionForce,o=(Math.random()-.5)*n.chaosFactor,l=(Math.random()-.5)*n.chaosFactor;e.vx+=s+o,e.vy+=r+l}},pa={name:"resting",emoji:"😴",description:"Ultra-slow vertical drift for deep rest states",initialize:function(e){e.vx=0,e.vy=-.01,e.lifeDecay=.001,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={upwardSpeed:2e-5,friction:.999}},update:function(e,t,i,a){const n=e.behaviorData;e.vy*=Math.pow(n.friction,t),e.vy-=n.upwardSpeed*t,e.vx=0}},ga={name:"radiant",emoji:"☀️",description:"Particles radiate outward like sunbeams",initialize:function(e){const t=Math.random()*Ji,i=.8+.4*Math.random();if(e.vx=Math.cos(t)*i,e.vy=Math.sin(t)*i,e.lifeDecay=.006,e.emotionColors&&e.emotionColors.length>0)e.color=Ki(e.emotionColors);else{const t=["#FFD700","#FFB347","#FFA500","#FF69B4"];e.color=Ki(t)}e.hasGlow=Math.random()<.7,e.glowSizeMultiplier=e.hasGlow?1.5+.5*Math.random():0,e.behaviorData={radialSpeed:.02,shimmer:Math.random()*Ji,shimmerSpeed:.1,friction:.99}},update:function(e,t,i,a){const n=e.behaviorData,s=e.x-i,r=e.y-a,o=Math.sqrt(s*s+r*r);if(o>0){const i=s/o,a=r/o;e.vx+=i*n.radialSpeed*t,e.vy+=a*n.radialSpeed*t}n.shimmer+=n.shimmerSpeed*t;const l=Math.sin(n.shimmer);e.size=e.baseSize*(1+.2*l),e.opacity=e.baseOpacity*(1+.3*l),e.vx*=Math.pow(n.friction,t),e.vy*=Math.pow(n.friction,t)}};function fa(e){e.vx=.02*(Math.random()-.5),e.vy=-.03-.02*Math.random(),e.lifeDecay=8e-4,e.size=(6+6*Math.random())*(e.scaleFactor||1)*(e.particleSizeMultiplier||1)*1.33,e.baseSize=e.size,e.baseOpacity=.2+.2*Math.random(),e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={ascensionSpeed:3e-4,waveFactor:.5,waveFrequency:.001,friction:.998,fadeStartDistance:100}}var ya={name:"ascending",emoji:"🧘",description:"Slow steady upward float like incense smoke",initialize:fa,update:function(e,t,i,a){const n=e.behaviorData;if(!n)return void fa(e);e.vx*=Math.pow(n.friction,t),e.vy*=Math.pow(n.friction,t),e.vy-=n.ascensionSpeed*t;const s=Math.sin(e.age*n.waveFrequency*1e3)*n.waveFactor;e.vx+=.001*s*t,void 0===e.initialY&&(e.initialY=e.y);const r=e.initialY-e.y;if(r>n.fadeStartDistance){const t=(r-n.fadeStartDistance)/100,i=Math.max(0,1-t);e.baseOpacity*=.995,i<.5&&(e.lifeDecay*=1.02)}Math.abs(e.vx)>.05&&(e.vx*=Math.pow(.95,t)),e.vy<-.1&&(e.vy=-.1)}},va={name:"erratic",emoji:"😰",description:"Nervous jittery movement for anxious states",initialize:function(e){const t=Math.random()*Ji,i=.1+.15*Math.random();e.vx=Math.cos(t)*i,e.vy=Math.sin(t)*i,e.lifeDecay=.004,e.size=(2+4*Math.random())*(e.scaleFactor||1)*(e.particleSizeMultiplier||1),e.baseSize=e.size,e.baseOpacity=.4+.3*Math.random(),e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={jitterStrength:.02,directionChangeRate:.1,speedVariation:.3,spinRate:.05+.1*Math.random()}},update:function(e,t){const i=e.behaviorData;if(e.vx+=(Math.random()-.5)*i.jitterStrength*t,e.vy+=(Math.random()-.5)*i.jitterStrength*t,Math.random()<Math.min(i.directionChangeRate*t,.5)){const t=Math.random()*Ji,i=Math.sqrt(e.vx*e.vx+e.vy*e.vy);e.vx=Math.cos(t)*i,e.vy=Math.sin(t)*i}const a=1+(Math.random()-.5)*i.speedVariation*t;e.vx*=a,e.vy*=a;const n=e.age*i.spinRate*1e3;e.size=e.baseSize*(1+.2*Math.sin(n)),e.opacity=e.baseOpacity*(.8+.4*Math.random()),e.vx*=Math.pow(.98,t),e.vy*=Math.pow(.98,t);const s=Math.sqrt(e.vx*e.vx+e.vy*e.vy);s>.5&&(e.vx=e.vx/s*.5,e.vy=e.vy/s*.5)}},ba={name:"cautious",emoji:"🤨",description:"Slow careful movement with watchful pauses",initialize:function(e){const t=Math.random()*Ji,i=.02+.03*Math.random();e.vx=Math.cos(t)*i,e.vy=Math.sin(t)*i,e.lifeDecay=.001,e.life=1,e.size=(4+4*Math.random())*(e.scaleFactor||1)*(e.particleSizeMultiplier||1),e.baseSize=e.size,e.baseOpacity=.8+.2*Math.random(),e.opacity=e.baseOpacity,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={pauseTimer:2*Math.random(),pauseDuration:.5+.5*Math.random(),moveDuration:1+.5*Math.random(),isMoving:Math.random()>.5,moveTimer:0,originalVx:e.vx,originalVy:e.vy,watchRadius:50+30*Math.random()}},update:function(e,t,i,a){const n=e.behaviorData;if(n.moveTimer+=t,n.isMoving)n.moveTimer>n.moveDuration?(n.isMoving=!1,n.moveTimer=0,e.vx=0,e.vy=0):(e.vx=n.originalVx,e.vy=n.originalVy);else if(n.moveTimer>n.pauseDuration){n.isMoving=!0,n.moveTimer=0;const t=Math.random()*Ji,i=.02+.03*Math.random();e.vx=Math.cos(t)*i,e.vy=Math.sin(t)*i,n.originalVx=e.vx,n.originalVy=e.vy}const s=e.x-i,r=e.y-a,o=Math.sqrt(s*s+r*r);if(o>n.watchRadius){const i=.02;e.vx-=s/o*i*t,e.vy-=r/o*i*t}e.vx*=Math.pow(.995,t),e.vy*=Math.pow(.995,t),n.isMoving?e.opacity=e.baseOpacity:e.opacity=e.baseOpacity*(.9+.1*Math.sin(5*e.age))}},wa={name:"surveillance",emoji:"👁️",description:"Searchlight scanning with paranoid watchfulness",initialize(e,t){e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorState={scanAngle:Math.random()*Math.PI-Math.PI/2,scanDirection:Math.random()<.5?1:-1,scanSpeed:.3+.2*Math.random(),scanRange:Math.PI/3+Math.random()*Math.PI/4,scanCenter:Math.random()*Math.PI*2,pauseTimer:0,pauseDuration:500+500*Math.random(),mode:"scanning",modeTimer:0,nextModeChange:2e3+3e3*Math.random(),dartTarget:{x:0,y:0},dartSpeed:0,patrolRadius:150+100*Math.random(),patrolAngle:Math.random()*Math.PI*2,alertLevel:0,lastPosition:{x:e.x,y:e.y}};const i=Math.random();i<.7?e.behaviorState.primaryRole="scanner":i<.9?(e.behaviorState.primaryRole="patroller",e.behaviorState.mode="patrolling"):(e.behaviorState.primaryRole="watcher",e.behaviorState.mode="frozen")},update(e,t,i){const a=e.behaviorState;if(a){switch(a.modeTimer+=16*t,a.modeTimer>a.nextModeChange&&(this.changeMode(e,a,i),a.modeTimer=0,a.nextModeChange=2e3+4e3*Math.random()),a.mode){case"scanning":this.updateScanning(e,t,a,i);break;case"darting":this.updateDarting(e,t,a,i);break;case"frozen":this.updateFrozen(e,t,a,i);break;case"patrolling":this.updatePatrolling(e,t,a,i)}e.vy+=.05*t,e.x+=e.vx*t,e.y+=e.vy*t,a.lastPosition.x=e.x,a.lastPosition.y=e.y}},updateScanning(e,t,i,a){i.pauseTimer>0?(i.pauseTimer-=16*t,e.vx*=.9,e.vy*=.9):(i.scanAngle+=i.scanDirection*i.scanSpeed*t*.02,Math.abs(i.scanAngle)>i.scanRange/2&&(i.scanDirection*=-1,i.pauseTimer=i.pauseDuration,i.scanAngle=Math.sign(i.scanAngle)*i.scanRange/2));const n=i.scanCenter+i.scanAngle,s=.8+.5*i.alertLevel;e.vx=Math.cos(n)*s,e.vy=Math.sin(n)*s*.3},updateDarting(e,t,i,a){const n=i.dartTarget.x-e.x,s=i.dartTarget.y-e.y,r=Math.sqrt(n*n+s*s);r>5?(e.vx=n/r*i.dartSpeed,e.vy=s/r*i.dartSpeed):(i.mode="scanning",i.modeTimer=0)},updateFrozen(e,t,i,a){e.vx*=.95,e.vy*=.95,Math.random()<.01&&(e.vx+=.5*(Math.random()-.5),e.vy+=.5*(Math.random()-.5))},updatePatrolling(e,t,i,a){i.patrolAngle+=.01*t;const n=a.corePosition?.x??a.canvasWidth/2,s=a.corePosition?.y??a.canvasHeight/2,r=n+Math.cos(i.patrolAngle)*i.patrolRadius,o=s+Math.sin(i.patrolAngle)*i.patrolRadius,l=r-e.x,c=o-e.y;e.vx=.02*l,e.vy=.02*c},changeMode(e,t,i){const a=Math.random(),n=i?.corePosition?.x??(i?.canvasWidth/2||e.x),s=i?.corePosition?.y??(i?.canvasHeight/2||e.y);"scanner"===t.primaryRole?a<.1?(t.mode="darting",t.dartTarget={x:n+200*(Math.random()-.5),y:s+200*(Math.random()-.5)},t.dartSpeed=3+2*Math.random()):t.mode=a<.2?"frozen":"scanning":"patroller"===t.primaryRole?t.mode=a<.1?"frozen":"patrolling":t.mode=a<.3?"scanning":"frozen"}},Ma={name:"glitchy",emoji:"⚡",description:"Digital glitch with stuttering orbits and corruption",rhythm:{enabled:!0,glitchTiming:{mode:"subdivision",subdivision:"sixteenth",probability:.3,intensityOnBeat:2,intensityOffBeat:.5},stutterSync:{mode:"pattern",patterns:{dubstep:{freezeOnDrop:!0,dropDuration:100},breakbeat:{randomFreeze:.1,duration:50}}},orbitRhythm:{baseSpeed:"tempo",wobbleSync:"eighth",beatAcceleration:1.5,barReset:!0},rgbSync:{enabled:!0,amount:"intensity",direction:"beat",maxSplit:10},noiseRhythm:{trigger:"accent",duration:50,intensity:"drop"}},initialize(e,t,i,a){e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorState={orbitAngle:Math.random()*Math.PI*2,orbitRadius:300+400*Math.random(),orbitSpeed:.01+.02*Math.random(),glitchTimer:0,nextGlitch:500*Math.random()+100,isGlitching:!1,glitchDuration:0,glitchOffset:{x:0,y:0},stutterTimer:0,nextStutter:200*Math.random()+50,isFrozen:!1,frozenPosition:{x:0,y:0},frozenVelocity:{x:0,y:0},hasGhost:Math.random()<.3,ghostOffset:20*Math.random()+10,ghostAngle:Math.random()*Math.PI*2,rgbSplit:Math.random()<.4,rgbPhase:Math.random()*Math.PI*2,noiseLevel:0,noiseBurst:!1,beatPhase:Math.random()*Math.PI*2,beatFrequency:.05+.03*Math.random(),dropIntensity:0},e.lifeDecay=.0015,e.hasGlow=!0,e.glowSizeMultiplier=3+2*Math.random()},update(e,t,i,a){const n=e.behaviorState;if(!n)return;n.glitchTimer+=16*t,n.stutterTimer+=16*t,n.stutterTimer>n.nextStutter&&(n.isFrozen?(n.isFrozen=!1,n.stutterTimer=0,n.nextStutter=100+300*Math.random(),Math.random()<.3&&(e.x+=60*(Math.random()-.5),e.y+=60*(Math.random()-.5))):(n.isFrozen=!0,n.frozenPosition={x:e.x,y:e.y},n.frozenVelocity={x:e.vx,y:e.vy},n.stutterTimer=0,n.nextStutter=20+40*Math.random())),n.glitchTimer>n.nextGlitch&&!n.isGlitching&&(n.isGlitching=!0,n.glitchDuration=50+100*Math.random(),n.glitchOffset={x:80*(Math.random()-.5),y:80*(Math.random()-.5)},n.glitchTimer=0,Math.random()<.5&&e.emotionColors&&(e.color=Ki(e.emotionColors))),n.isGlitching&&n.glitchTimer>n.glitchDuration&&(n.isGlitching=!1,n.glitchTimer=0,n.nextGlitch=200+800*Math.random(),n.glitchOffset={x:0,y:0}),n.beatPhase+=n.beatFrequency*t;const s=.5*Math.sin(n.beatPhase)+.5;if(n.beatPhase%(4*Math.PI)<.5*Math.PI?n.dropIntensity=Math.min(1,n.dropIntensity+.1*t):n.dropIntensity=Math.max(0,n.dropIntensity-.05*t),n.isFrozen)e.vx=.5*(Math.random()-.5),e.vy=.5*(Math.random()-.5);else{n.orbitAngle+=n.orbitSpeed*t*(1+.5*s);const r=n.orbitRadius*(1+.3*n.dropIntensity*Math.sin(4*n.beatPhase));let o=i+Math.cos(n.orbitAngle)*r,l=a+Math.sin(n.orbitAngle)*r*.6;if(n.isGlitching&&(o+=n.glitchOffset.x*Math.random()*.8,l+=n.glitchOffset.y*Math.random()*.8),n.rgbSplit){const e=3*(1+n.dropIntensity);o+=Math.sin(n.rgbPhase)*e,l+=Math.cos(n.rgbPhase)*e,n.rgbPhase+=.1*t}n.dropIntensity>.8&&Math.random()<.1&&(o+=30*(Math.random()-.5),l+=30*(Math.random()-.5));const c=n.isGlitching?.02:.03;e.vx=(o-e.x)*c,e.vy=(l-e.y)*c,e.vx+=(Math.random()-.5)*s*2,e.vy+=(Math.random()-.5)*s*2}e.x+=e.vx*t,e.y+=e.vy*t,Math.random()<.02&&(e.opacity=.1+.9*Math.random()),e.size=e.baseSize*(1+.3*s+.5*n.dropIntensity)}},Sa={name:"spaz",description:"Ultra-aggressive particles with explosive spread and chaotic motion",initialize(e,t,i,a){e.x=i,e.y=a,e.life=1,e.size=3+4*Math.random();const n=Math.random()*Math.PI*2,s=200+300*Math.random();e.vx=Math.cos(n)*s,e.vy=Math.sin(n)*s,e.behaviorState={explosionPhase:0,explosionTimer:0,explosionDuration:1e3+2e3*Math.random(),chaosTimer:0,nextChaosChange:100+200*Math.random(),chaosAngle:n,chaosSpeed:50+100*Math.random(),spazIntensity:.8+.4*Math.random(),zigzagPattern:Math.random()<.5,spiralPattern:Math.random()<.3,teleportChance:.02,sizePulse:!0,sizePulseSpeed:.1+.05*Math.random(),sizePulsePhase:Math.random()*Math.PI*2,colorShift:Math.random()<.3,colorShiftSpeed:.05+.03*Math.random()},e.lifeDecay=8e-4,e.hasGlow=!0,e.glowSizeMultiplier=4+3*Math.random(),e.glowIntensity=1.5+.5*Math.random()},update(e,t,i,a){const n=e.behaviorState;if(n.explosionTimer+=t,n.chaosTimer+=t,0===n.explosionPhase&&n.explosionTimer<500)e.vx*=.98,e.vy*=.98,Math.random()<.1&&(e.vx+=100*(Math.random()-.5),e.vy+=100*(Math.random()-.5));else if(0===n.explosionPhase&&n.explosionTimer>=500)n.explosionPhase=1,n.chaosAngle=Math.random()*Math.PI*2,n.chaosSpeed=30+70*Math.random();else if(1===n.explosionPhase){n.chaosTimer>=n.nextChaosChange&&(n.chaosAngle=Math.random()*Math.PI*2,n.chaosSpeed=20+80*Math.random(),n.nextChaosChange=50+150*Math.random(),n.chaosTimer=0);const t=Math.cos(n.chaosAngle)*n.chaosSpeed,i=Math.sin(n.chaosAngle)*n.chaosSpeed;if(e.vx=.7*e.vx+.3*t,e.vy=.7*e.vy+.3*i,n.zigzagPattern){const t=.01*n.chaosTimer;e.vx+=20*Math.sin(t),e.vy+=20*Math.cos(t)}if(n.spiralPattern){const t=.005*n.chaosTimer,i=50+30*Math.sin(.003*n.chaosTimer);e.vx+=Math.cos(t)*i*.1,e.vy+=Math.sin(t)*i*.1}}if(Math.random()<n.teleportChance){const t=Math.random()*Math.PI*2,n=200+400*Math.random();e.x=i+Math.cos(t)*n,e.y=a+Math.sin(t)*n,e.vx=200*(Math.random()-.5),e.vy=200*(Math.random()-.5)}if(e.x+=e.vx*(t/1e3),e.y+=e.vy*(t/1e3),n.sizePulse){n.sizePulsePhase+=n.sizePulseSpeed*t;const i=1+.5*Math.sin(n.sizePulsePhase);e.size=(3+4*Math.random())*i}n.colorShift&&(n.colorShiftPhase=(n.colorShiftPhase||0)+n.colorShiftSpeed*t),e.vx*=.995,e.vy*=.995,e.life-=e.lifeDecay*t,(e.life<=0||Math.abs(e.x-i)>2e3||Math.abs(e.y-a)>2e3)&&(e.life=0)},getSpawnPosition(e,t){const i=Math.random()*Math.PI*2,a=100+200*Math.random();return{x:e+Math.cos(i)*a,y:t+Math.sin(i)*a}},getVisualProperties:()=>({glowColor:"#FF00AA",glowIntensity:2,particleColors:[{color:"#FF00AA",weight:30},{color:"#00FFAA",weight:25},{color:"#FFAA00",weight:20},{color:"#AA00FF",weight:15},{color:"#00AAFF",weight:10}]})},xa={name:"directed",emoji:"🎯",description:"Focused, straight-line movement toward target",config:{speed:3,acceleration:.15,focusStrength:.8,randomness:.1,edgeBuffer:50},initialize(e,t,i,a,n){const s=t-e.x,r=i-e.y,o=Math.sqrt(s*s+r*r);if(o>0)e.vx=s/o*this.config.speed,e.vy=r/o*this.config.speed;else{const t=Math.random()*Math.PI*2;e.vx=Math.cos(t)*this.config.speed,e.vy=Math.sin(t)*this.config.speed}e.targetX=t,e.targetY=i,e.directedPhase=0},update(e,t,i,a,n,s){e.directedPhase+=.05*t;const r=e.targetX-e.x,o=e.targetY-e.y,l=Math.sqrt(r*r+o*o);if(l>10){const i=r/l*this.config.speed,a=o/l*this.config.speed;e.vx+=(i-e.vx)*this.config.acceleration*t,e.vy+=(a-e.vy)*this.config.acceleration*t,e.vx+=(Math.random()-.5)*this.config.randomness,e.vy+=(Math.random()-.5)*this.config.randomness}else{const t=Math.random()*Math.PI*2,r=100+200*Math.random();e.targetX=i+Math.cos(t)*r,e.targetY=a+Math.sin(t)*r,e.targetX=Math.max(this.config.edgeBuffer,Math.min(n-this.config.edgeBuffer,e.targetX)),e.targetY=Math.max(this.config.edgeBuffer,Math.min(s-this.config.edgeBuffer,e.targetY))}e.x+=e.vx*t,e.y+=e.vy*t,(e.x<=0||e.x>=n)&&(e.vx*=-.8,e.x=Math.max(0,Math.min(n,e.x)),e.targetX=i+300*(Math.random()-.5)),(e.y<=0||e.y>=s)&&(e.vy*=-.8,e.y=Math.max(0,Math.min(s,e.y)),e.targetY=a+300*(Math.random()-.5))},visuals:{trailLength:"medium",opacity:.9,sizeMultiplier:1,blurAmount:.2}},Ca={name:"fizzy",emoji:"🫧",description:"Bubbly, effervescent movement like carbonation",config:{baseRiseSpeed:2.5,wobbleAmplitude:30,wobbleFrequency:.15,popChance:.002,popForce:8,fizziness:.3,gravity:-.05},initialize(e,t,i,a,n){e.vx=2*(Math.random()-.5),e.vy=-this.config.baseRiseSpeed-2*Math.random(),e.wobblePhase=Math.random()*Math.PI*2,e.wobbleSpeed=this.config.wobbleFrequency*(.8+.4*Math.random()),e.bubbleSize=.5+.5*Math.random(),e.popTimer=0,e.isFizzing=!0},update(e,t,i,a,n,s){e.wobblePhase+=e.wobbleSpeed*t;const r=Math.sin(e.wobblePhase)*this.config.wobbleAmplitude;if(e.vx=.05*r+(Math.random()-.5)*this.config.fizziness,e.vy+=this.config.gravity*t,e.vy+=(Math.random()-.5)*this.config.fizziness,Math.random()<this.config.popChance){const t=Math.random()*Math.PI*2;e.vx=Math.cos(t)*this.config.popForce,e.vy=Math.sin(t)*this.config.popForce*.7,e.popTimer=1,e.bubbleSize=.3+.7*Math.random()}e.popTimer>0&&(e.popTimer-=.05*t,e.vx*=.95,e.vy*=.95),e.x+=e.vx*t,e.y+=e.vy*t,e.y<-50&&(e.y=s+50,e.x=i+300*(Math.random()-.5),e.vy=-this.config.baseRiseSpeed-2*Math.random(),e.bubbleSize=.5+.5*Math.random()),(e.x<=0||e.x>=n)&&(e.vx*=-.5,e.x=Math.max(0,Math.min(n,e.x))),e.y>s+50&&(e.y=s,e.vy=1.5*-this.config.baseRiseSpeed),e.size=e.baseSize*e.bubbleSize*(1+.1*Math.sin(2*e.wobblePhase))},visuals:{trailLength:"short",opacity:.6,sizeMultiplier:1.2,blurAmount:.5,sparkle:!0}};var Pa={name:"zen",emoji:"☯️",description:"Peaceful orbital movement like a hovering aura",initialize:function(e){e.vx=.5*(Math.random()-.5),e.vy=.5*(Math.random()-.5),e.lifeDecay=.003,e.emotionColors&&e.emotionColors.length>0&&(e.color=Ki(e.emotionColors)),e.behaviorData={orbitAngle:Math.random()*Math.PI*2,orbitRadius:40+60*Math.random(),orbitSpeed:8e-4+6e-4*Math.random(),floatOffset:Math.random()*Math.PI*2,breathingOffset:Math.random()*Math.PI*2,lifetime:0}},update:function(e,t,i,a){const n=e.behaviorData;if(!n)return;n.lifetime+=t;const s=(n.lifetime+8e3*n.breathingOffset)/8e3,r=.5*Math.sin(s*Math.PI*2)+.5;e.size=e.baseSize*(.95+.05*r),n.orbitAngle+=n.orbitSpeed*t;const o=10*Math.sin(1e-4*n.lifetime+n.floatOffset),l=n.orbitRadius+o,c=i+Math.cos(n.orbitAngle)*l,h=a+Math.sin(n.orbitAngle)*l,u=15*Math.sin(3e-4*n.lifetime+n.breathingOffset),d=c-e.x,m=h+u-e.y;e.vx=.03*d,e.vy=.03*m,e.vx+=.02*(Math.random()-.5),e.vy+=.02*(Math.random()-.5),e.vx*=.98,e.vy*=.98}};const ka=new Map;var Da=function(e){return ka.get(e)||null},Aa=function(){return Array.from(ka.keys())};const _a={};function Ta(e){if(_a[e])return _a[e];return Da(e)||null}function Ia(e,t){const i=Ta(t);return i&&i.initialize?(i.initialize(e),!0):"ambient"!==t&&(console.warn(`⚠️ Behavior '${t}' not found, falling back to ambient`),Ia(e,"ambient"))}function Oa(e,t,i,a,n){const s=Ta(t);return!(!s||!s.update||(s.update(e,i,a,n),0))}[Zi,xa,Ca,ea,ta,aa,la,ca,ha,ua,da,ma,pa,ga,ya,va,ba,wa,Ma,Sa,Pa].forEach(e=>{_a[e.name]=e}),"undefined"!=typeof window&&window.DEBUG_PARTICLES&&(window.ParticleBehaviors={registry:_a,list:function(){return[...Object.values(_a).map(e=>({name:e.name,emoji:e.emoji||"🎯",description:e.description||"No description",type:"core"})),...Aa().map(e=>{const t=Da(e);return{name:t.name,emoji:t.emoji||"🔌",description:t.description||"Plugin behavior",type:"plugin"}})]},get:Ta});const Ra=new Map;var Ea=function(e){return Ra.get(e)||null},Ba=function(){return Array.from(Ra.keys())},Fa={name:"breathe",emoji:"🫁",type:"blending",description:"Breathing rhythm with inhale and exhale",config:{musicalDuration:{musical:!0,bars:1,minBeats:2,maxBeats:16},phases:[{name:"inhale",beats:1.5},{name:"hold_in",beats:.5},{name:"exhale",beats:1.5},{name:"hold_out",beats:.5}],inhaleRadius:1.5,exhaleRadius:.3,breathRate:.3,spiralStrength:.002,scaleAmount:.25,glowAmount:.4,frequency:1,easing:"sine",strength:.8,particleMotion:{type:"breathe",strength:.8,inhaleRadius:1.5,exhaleRadius:.3}},rhythm:{enabled:!0,syncMode:"phrase",breathRateSync:{mode:"tempo",bpm:"auto",subdivision:"whole",curve:"sine"},radiusSync:{inhale:{onUpbeat:1.8,onDownbeat:1.4,curve:"ease-in"},exhale:{onUpbeat:.2,onDownbeat:.4,curve:"ease-out"}},durationSync:{mode:"phrases",phrases:2,hold:"fermata"},accentResponse:{enabled:!0,multiplier:1.5,type:"expansion"},patternOverrides:{ballad:{breathRateSync:{subdivision:"double-whole"},radiusSync:{inhale:{onUpbeat:2.2,onDownbeat:1.8},exhale:{onUpbeat:.1,onDownbeat:.2}}},uptempo:{breathRateSync:{subdivision:"half"},radiusSync:{inhale:{onUpbeat:1.4,onDownbeat:1.2},exhale:{onUpbeat:.3,onDownbeat:.4}}},ambient:{breathRateSync:{subdivision:"whole",curve:"ease"},radiusSync:{inhale:{onUpbeat:1.6,onDownbeat:1.6},exhale:{onUpbeat:.2,onDownbeat:.2}}}},dynamics:{forte:{radiusSync:{inhale:{multiplier:1.8},exhale:{multiplier:.5}},spiralStrength:.004,scaleAmount:.4},piano:{radiusSync:{inhale:{multiplier:1.2},exhale:{multiplier:.8}},spiralStrength:.001,scaleAmount:.1}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a;e.gestureData.breathe={startX:e.x,startY:e.y,angle:Math.atan2(s,n),baseRadius:Math.sqrt(n*n+s*s),phaseOffset:.2*Math.random()-.1}},apply(e,t,i,a,n,s){e.gestureData?.breathe||this.initialize(e,i,n,s);const r={...this.config,...i},o=(Math.sin(t*Math.PI*2*r.breathRate)+1)/2,l=100*(e.scaleFactor||1),c=r.inhaleRadius*l,h=r.exhaleRadius*l,u=h+(c-h)*o,d=e.x-n,m=e.y-s,p=Math.sqrt(d*d+m*m),g=u-p,f=.05*(i.strength||.8)*a;if(p>0){const t=d/p*g*f,n=m/p*g*f;e.vx+=t,e.vy+=n;const s=r.spiralStrength*a*(i.strength||1),l=-m/p,c=d/p;e.vx+=l*s*o,e.vy+=c*s*o}e.vx*=.98,e.vy*=.98},cleanup(e){e.gestureData?.breathe&&delete e.gestureData.breathe},"3d":{evaluate(e,t){const i=(t.config||{}).breathRate||.3,a=Math.sin(e*Math.PI*2*i);let n=1;if(e>.8){const t=(e-.8)/(1-.8);n=1-t*t*t}const s=.2*a*n;return{position:[0,.05*a*n,0],rotation:[0,0,0],scale:1+.35*a*n,glowIntensity:1+s,glowBoost:Math.max(0,2*s)}}}},za={name:"expand",emoji:"💫",type:"blending",description:"Radial expansion from center",config:{duration:600,scaleAmount:3,scaleTarget:3,glowAmount:.5,easing:"back",strength:3,particleMotion:{type:"pulse",strength:3,direction:"outward",persist:!0}},rhythm:{enabled:!0,syncMode:"crescendo",strengthSync:{pianissimo:1.5,fortissimo:5,crescendo:"build",sforzando:"burst"},scaleTargetSync:{verse:2,chorus:4.5,climax:6,curve:"exponential"},durationSync:{mode:"phrases",build:1.2,release:.8,sustain:"hold"},accentResponse:{enabled:!0,multiplier:2.8,type:"strength"},patternOverrides:{orchestral:{strengthSync:{pianissimo:2,fortissimo:6.5,crescendo:"dramatic"},scaleTargetSync:{climax:8}},rock:{strengthSync:{pianissimo:1.8,fortissimo:5.5,curve:"power"},accentResponse:{multiplier:3.2}},ambient:{strengthSync:{pianissimo:1.2,fortissimo:3.5,crescendo:"organic"},durationSync:{build:1.8,release:1.2}},electronic:{strengthSync:{pianissimo:1.6,fortissimo:4.8,curve:"digital"},scaleTargetSync:{curve:"linear"}}},dynamics:{forte:{strengthSync:{pianissimo:{multiplier:1.4},fortissimo:{multiplier:1.8}},scaleTargetSync:{multiplier:1.6},accentResponse:{multiplier:3.5}},piano:{strengthSync:{pianissimo:{multiplier:.8},fortissimo:{multiplier:1.2}},scaleTargetSync:{multiplier:.7},accentResponse:{multiplier:2}}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a;e.gestureData.expand={startX:e.x,startY:e.y,angle:Math.atan2(s,n),baseRadius:Math.sqrt(n*n+s*s),initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.expand?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.expand,o={...this.config,...i},l=o.strength||1,c=1+(o.scaleTarget-1)*t*l,h=r.baseRadius*c,u=n+Math.cos(r.angle)*h,d=s+Math.sin(r.angle)*h,m=u-e.x,p=d-e.y;e.vx+=.8*m*a,e.vy+=.8*p*a,e.vx*=.95,e.vy*=.95},cleanup(e){e.gestureData?.expand&&delete e.gestureData.expand},"3d":{evaluate(e,t){const i={...this.config,...t},a=i.strength||3;return{position:[0,0,0],rotation:[0,0,0],scale:1+e*(i.scaleAmount||3)*(a/3),glowIntensity:1+.25*e,glowBoost:.8*e}}}},La={name:"contract",emoji:"🌀",type:"blending",description:"Radial contraction toward center",config:{duration:600,scaleAmount:.2,scaleTarget:.2,glowAmount:-.2,easing:"cubic",strength:2.5,particleMotion:{type:"pulse",strength:2.5,direction:"inward",persist:!0}},rhythm:{enabled:!0,syncMode:"tension",strengthSync:{onTension:4,onRelease:1.5,curve:"magnetic"},scaleTargetSync:{forte:.1,piano:.4,crescendo:"gradual",diminuendo:"ease"},durationSync:{mode:"phrases",shortPhrase:.8,longPhrase:1.5,hold:"sustain"},accentResponse:{enabled:!0,multiplier:2.2,type:"strength"},patternOverrides:{classical:{strengthSync:{onTension:3.5,onRelease:1.8},scaleTargetSync:{forte:.15,piano:.35}},metal:{strengthSync:{onTension:5,onRelease:2,curve:"sharp"},scaleTargetSync:{forte:.05,piano:.25}},ambient:{strengthSync:{onTension:2.8,onRelease:1.2,curve:"ease"},durationSync:{shortPhrase:1.2,longPhrase:2}},trap:{strengthSync:{onTension:4.5,onRelease:1,dropBeat:6},scaleTargetSync:{forte:.08,piano:.3}}},dynamics:{forte:{strengthSync:{onTension:{multiplier:1.8},onRelease:{multiplier:1.4}},scaleTargetSync:{multiplier:.6},accentResponse:{multiplier:2.8}},piano:{strengthSync:{onTension:{multiplier:.7},onRelease:{multiplier:.8}},scaleTargetSync:{multiplier:1.4},accentResponse:{multiplier:1.6}}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a;e.gestureData.contract={startX:e.x,startY:e.y,angle:Math.atan2(s,n),baseRadius:Math.sqrt(n*n+s*s),initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.contract?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.contract,o={...this.config,...i},l=o.strength||1,c=1-(1-o.scaleTarget)*t*l,h=r.baseRadius*c,u=n+Math.cos(r.angle)*h,d=s+Math.sin(r.angle)*h,m=u-e.x,p=d-e.y;e.vx+=.5*m*a,e.vy+=.5*p*a,e.vx*=.95,e.vy*=.95},cleanup(e){e.gestureData?.contract&&delete e.gestureData.contract},"3d":{evaluate(e,t){const i={...this.config,...t},a=i.strength||2.5,n=i.scaleTarget||.2,s=1-e*(1-n)*(a/2.5),r=1-.15*e;return{position:[0,0,0],rotation:[0,0,0],scale:Math.max(n,s),glowIntensity:r}}}},Ga={name:"pulse",emoji:"💗",type:"blending",description:"Radial expansion and contraction from center",config:{duration:600,amplitude:30,frequency:1,holdPeak:.1,easing:"sine",scaleAmount:.2,glowAmount:.3,strength:.15,direction:"outward",particleMotion:{type:"pulse",strength:.15,direction:"outward",frequency:1}},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.6,offBeat:.8,curve:"pulse"},frequencySync:{mode:"locked",subdivision:"quarter"},durationSync:{mode:"beats",beats:1},accentResponse:{enabled:!0,multiplier:2},patternOverrides:{waltz:{amplitudeSync:{onBeat:2,offBeat:.5},durationSync:{beats:3}},swing:{amplitudeSync:{onBeat:1.8,offBeat:.6,curve:"ease"},frequencySync:{subdivision:"swing"}},dubstep:{amplitudeSync:{onBeat:1.2,dropBeat:4,curve:"pulse"}},breakbeat:{frequencySync:{mode:"random",range:[.5,2]},amplitudeSync:{onBeat:2.5,offBeat:.3}}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a,r=Math.sqrt(n*n+s*s),o=Math.atan2(s,n);e.gestureData.pulse={baseDistance:r,angle:o,startX:e.x,startY:e.y,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.pulse?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.pulse,o={...this.config,...i},l=i.strength||1,c=this.easeInOutSine(t);let h,{frequency:u}=o,{amplitude:d}=o;i.rhythmModulation&&(d*=i.rhythmModulation.amplitudeMultiplier||1,d*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(u*=i.rhythmModulation.frequencyMultiplier));const m=c*u*2%2;h=o.holdPeak>0&&m>1-o.holdPeak&&m<1+o.holdPeak?1:Math.sin(c*Math.PI*2*u);const p=h*d*l*e.scaleFactor,g=r.baseDistance+p,f=n+Math.cos(r.angle)*g,y=s+Math.sin(r.angle)*g,v=.15*a;if(e.vx+=(f-e.x)*v*.1,e.vy+=(y-e.y)*v*.1,t>.9){const i=1-10*(t-.9);e.vx*=.9+.1*i,e.vy*=.9+.1*i}},cleanup(e){e.gestureData?.pulse&&delete e.gestureData.pulse},easeInOutSine:e=>-(Math.cos(Math.PI*e)-1)/2,"3d":{evaluate(e,t){const i=t||{},a=i.frequency||1,n=i.strength||.15,s=i.scaleAmount||.2,r=i.glowAmount||.3,o=-(Math.cos(Math.PI*e)-1)/2,l=Math.sin(o*Math.PI*2*a);return{position:[0,0,0],rotation:[0,0,0],scale:1+l*s*n,glowIntensity:1+Math.max(-.3,Math.min(.3,l*r*n*2)),glowBoost:Math.max(0,.8*l)}}}},Va={name:"sway",type:"blending",emoji:"🌊",description:"Gentle side-to-side swaying motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},amplitude:20,frequency:1,strength:.5},rhythm:{enabled:!0,syncMode:"bar",amplitudeSync:{onBeat:1.2,offBeat:.9,curve:"ease"},durationSync:{mode:"bars",bars:1},patternOverrides:{waltz:{durationSync:{bars:1},amplitudeSync:{onBeat:1.5,curve:"ease"}},swing:{amplitudeSync:{onBeat:1.3,offBeat:.7,curve:"bounce"}}}},apply(e,t,i,a,n,s){const r={...this.config,...i},o=r.amplitude||this.config.amplitude,l=r.frequency||this.config.frequency,c=r.strength||this.config.strength,h=Math.sin(t*Math.PI*2*l)*o;e.vx+=.01*h*a*c,e.vy+=.5*Math.cos(t*Math.PI*4)*a*c},cleanup(e){},"3d":{evaluate(e,t){const i={...this.config,...t};let a=i.amplitude||this.config.amplitude;const n=i.frequency||this.config.frequency,s=i.strength||this.config.strength;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);const r=Math.sin(e*Math.PI*2*n),o=a*s*.3*.01,l=.15*r*s,c=.08*r*s;return{position:[r*o,.3*Math.cos(e*Math.PI*4)*o,Math.sin(e*Math.PI*n)*o*.5],rotation:[0,c,l],scale:1}}}},Na={name:"float",type:"blending",emoji:"🎈",description:"Gentle floating upward motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:2},amplitude:80,wobbleAmount:20,strength:1},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},wobbleSync:{subdivision:"eighth",intensity:.7},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:1.3},patternOverrides:{waltz:{wobbleSync:{subdivision:"quarter",intensity:.9}},dubstep:{amplitudeSync:{onBeat:2,curve:"pulse"}}}},apply(e,t,i,a,n,s){e.gestureData||(e.gestureData={}),e.gestureData.float||(e.gestureData.float={originalSize:e.size,originalOpacity:e.opacity||1});const r={...this.config,...i};let o=r.amplitude||this.config.amplitude,l=r.wobbleAmount||this.config.wobbleAmount;const c=r.strength||this.config.strength;i.rhythmModulation&&(o*=i.rhythmModulation.amplitudeMultiplier||1,o*=i.rhythmModulation.accentMultiplier||1,l*=i.rhythmModulation.wobbleMultiplier||1);const h=Math.sin(t*Math.PI*4)*l;e.vy-=.01*o*a*c*(1-.5*t),e.vx+=.01*h*a*c,e.size=e.baseSize*(1+.1*t),e.opacity=1-.3*t},cleanup(e){e.gestureData?.float?(e.opacity=e.gestureData.float.originalOpacity,e.size=e.gestureData.float.originalSize,delete e.gestureData.float):(e.opacity=1,e.size=e.baseSize),e.vx*=.5,e.vy*=.5},"3d":{evaluate(e,t){const i={...this.config,...t};let a=i.amplitude||this.config.amplitude,n=i.wobbleAmount||this.config.wobbleAmount;const s=i.strength||this.config.strength;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1,n*=t.rhythmModulation.wobbleMultiplier||1);const r=Math.sin(e*Math.PI),o=a*r*s*.005,l=Math.sin(e*Math.PI*4)*n*.3*.005,c=Math.sin(e*Math.PI)*Math.PI*.5*s,h=Math.sin(e*Math.PI);return{position:[l,o,0],rotation:[h*Math.sin(e*Math.PI*2)*.1,c,h*Math.cos(e*Math.PI*3)*.08],scale:1+.1*r}}}};const ja={left:{x:-1,y:0},right:{x:1,y:0},up:{x:0,y:1},down:{x:0,y:-1}};function qa(e){return e.charAt(0).toUpperCase()+e.slice(1)}function Ua(e){const t=ja[e];if(!t)throw new Error(`Invalid float direction: ${e}`);const i="up"===e||"down"===e;return{name:`float${qa(e)}`,emoji:"up"===e?"🎈":"down"===e?"🍂":"left"===e?"🌬️":"💨",type:"blending",description:`Gentle floating ${e}`,config:{duration:2e3,amplitude:80,wobbleAmount:20,strength:1,direction:e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},wobbleSync:{subdivision:"eighth",intensity:.7},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:1.3}},apply(e,a,n,s,r,o){e.gestureData||(e.gestureData={}),e.gestureData.float||(e.gestureData.float={originalSize:e.size,originalOpacity:e.opacity||1});const l={...this.config,...n};let c=l.amplitude||80,h=l.wobbleAmount||20;const u=l.strength||1;n.rhythmModulation&&(c*=n.rhythmModulation.amplitudeMultiplier||1,c*=n.rhythmModulation.accentMultiplier||1,h*=n.rhythmModulation.wobbleMultiplier||1);const d=Math.sin(a*Math.PI*4)*h,m=.01*c*s*u*(1-.5*a);i?(e.vy+=t.y*m,e.vx+=.01*d*s*u):(e.vx+=t.x*m,e.vy+=.01*d*s*u),e.size=e.baseSize*(1+.1*a),e.opacity=1-.3*a},cleanup(e){e.gestureData?.float?(e.opacity=e.gestureData.float.originalOpacity,e.size=e.gestureData.float.originalSize,delete e.gestureData.float):(e.opacity=1,e.size=e.baseSize),e.vx*=.5,e.vy*=.5},"3d":{evaluate(e,a){const n=a||{};let s=n.amplitude||80,r=n.wobbleAmount||20;const o=n.strength||1;a.rhythmModulation&&(s*=a.rhythmModulation.amplitudeMultiplier||1,s*=a.rhythmModulation.accentMultiplier||1,r*=a.rhythmModulation.wobbleMultiplier||1);const l=Math.sin(e*Math.PI),c=s*l*o*.005,h=Math.sin(e*Math.PI*4)*r*.3*.005,u=Math.sin(e*Math.PI)*Math.PI*.5*o,d=Math.sin(e*Math.PI),m=d*Math.sin(e*Math.PI*2)*.1,p=d*Math.cos(e*Math.PI*3)*.08,g=1+.1*l;let f=0,y=0;return i?(y=t.y*c,f=h):(f=t.x*c,y=h),{cameraRelativePosition:[f,y,0],rotation:[m,u,p],scale:g}}}}}var Wa=Ua("up"),Ha=Ua("down"),$a=Ua("left"),Ya=Ua("right"),Xa={name:"lean",emoji:"↗️",type:"blending",description:"Diagonal tilting motion with smooth return",config:{duration:1200,musicalDuration:{musical:!0,beats:2},amplitude:10,frequency:1,direction:"right",strength:.7,particleMotion:{type:"lean",direction:"right",strength:.7,frequency:1}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.3,offBeat:.8,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.4},patternOverrides:{waltz:{durationSync:{beats:3},amplitudeSync:{onBeat:1.5,offBeat:.6}},swing:{amplitudeSync:{onBeat:1.6,offBeat:.5,curve:"bounce"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.lean={startX:e.x,startY:e.y,startVx:e.vx,startVy:e.vy,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.lean?.initialized||this.initialize(e,i);const r={...this.config,...i},o=r.strength||this.config.strength||1,l=this.easeInOutCubic(t),c=r.frequency||this.config.frequency;let h=r.amplitude*o*e.scaleFactor;i.rhythmModulation&&(h*=i.rhythmModulation.amplitudeMultiplier||1,h*=i.rhythmModulation.accentMultiplier||1);const u=Math.sin(l*Math.PI*c),d="left"===r.direction?-1:1;if(e.vx+=u*h*.015*a*d,e.vy+=u*h*.01*a*d*.5,t>.9){const i=1-10*(t-.9);e.vx=e.vx*(.95+.05*i),e.vy=e.vy*(.95+.05*i)}},cleanup(e){e.gestureData?.lean&&delete e.gestureData.lean},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const i=t||{},a=i.amplitude||10,n=i.frequency||1,s=i.strength||.7,r=i.direction||"right",o=.003*a*s,l=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,c=Math.sin(l*Math.PI*n),h="left"===r?-1:1;return{position:[c*o*h,0,0],rotation:[0,0,.35*c*h],scale:1}}}};function Qa(e){if("left"!==e&&"right"!==e)throw new Error(`Invalid lean direction: ${e}. Only 'left' and 'right' are supported.`);const t=ja[e];return{name:`lean${qa(e)}`,emoji:"left"===e?"↖️":"↗️",type:"blending",description:`Lean ${e} with smooth return`,config:{duration:800,amplitude:10,frequency:1,strength:.7,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:1.3,offBeat:.8,curve:"ease"},accentResponse:{enabled:!0,multiplier:1.4}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.lean={startX:e.x,startY:e.y,initialized:!0}},apply(e,i,a,n,s,r){e.gestureData?.lean?.initialized||this.initialize(e,a);const o={...this.config,...a},l=o.strength||.7,c=this.easeInOutCubic(i);let h=o.amplitude*l*e.scaleFactor;a.rhythmModulation&&(h*=a.rhythmModulation.amplitudeMultiplier||1,h*=a.rhythmModulation.accentMultiplier||1);const u=Math.sin(c*Math.PI*o.frequency);if(e.vx+=u*h*.015*n*t.x,e.vy+=u*h*.01*n*t.x*.5,i>.9){const t=1-10*(i-.9);e.vx*=.95+.05*t,e.vy*=.95+.05*t}},cleanup(e){e.gestureData?.lean&&delete e.gestureData.lean},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,i){const a=i||{},n=a.amplitude||10,s=a.frequency||1,r=.003*n*(a.strength||.7),o=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,l=Math.sin(o*Math.PI*s),c=.35*l*t.x;return{cameraRelativePosition:[l*r*t.x,0,0],cameraRelativeRotation:[0,0,c],scale:1}}}}}var Ka=Qa("left"),Za=Qa("right"),Ja={name:"jitter",type:"blending",emoji:"🫨",description:"Nervous jittery movement",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},intensity:15,frequency:30,strength:1},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:2,offBeat:.5,curve:"pulse"},patternOverrides:{breakbeat:{amplitudeSync:{onBeat:3,offBeat:.3}},dubstep:{amplitudeSync:{onBeat:5,offBeat:.1,curve:"pulse"}}}},apply(e,t,i,a,n,s){e.gestureData||(e.gestureData={}),e.gestureData.jitter||(e.gestureData.jitter={originalSize:e.size});const r={...this.config,...i};let o=r.intensity||this.config.intensity;const l=r.strength||this.config.strength;i.rhythmModulation&&(o*=i.rhythmModulation.amplitudeMultiplier||1,o*=i.rhythmModulation.accentMultiplier||1);const c=(Math.random()-.5)*o*l,h=(Math.random()-.5)*o*l,u=1-.5*t;e.vx+=.1*c*a*u,e.vy+=.1*h*a*u,e.size=e.baseSize*(1+.1*(Math.random()-.5))},cleanup(e){e.gestureData?.jitter?(e.size=e.gestureData.jitter.originalSize,delete e.gestureData.jitter):e.size=e.baseSize,e.vx*=.7,e.vy*=.7},"3d":{evaluate(e,t){const i={...this.config,...t};let a=i.intensity||this.config.intensity;const n=i.strength||this.config.strength;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);const s=Math.sin(e*Math.PI),r=a*n*.002*s;return{position:[(Math.random()-.5)*r,(Math.random()-.5)*r,(Math.random()-.5)*r],rotation:[.005*(Math.random()-.5)*s,.005*(Math.random()-.5)*s,.005*(Math.random()-.5)*s],scale:1+.02*(Math.random()-.5)*s}}}},en={name:"twitch",emoji:"⚡",type:"blending",description:"Nervous, paranoid twitching",config:{intensity:8,frequency:.08,duration:100,musicalDuration:{musical:!0,beats:.5},recovery:200,maxOffset:15,sharpness:.9},rhythm:{enabled:!0,syncMode:"subdivision",durationSync:{mode:"beats",beats:.5},probabilitySync:{subdivision:"sixteenth",onBeat:.3,offBeat:.05,accentBoost:2},intensitySync:{onBeat:2,offBeat:.8,curve:"pulse"},patternOverrides:{breakbeat:{probabilitySync:{onBeat:.5,offBeat:.1},intensitySync:{onBeat:3,offBeat:.5}},dubstep:{intensitySync:{onBeat:1.5,dropBeat:5,curve:"pulse"}}}},apply(e,t,i,a,n,s){e.gestureData||(e.gestureData={}),e.gestureData.twitch||(e.gestureData.twitch={twitchOffset:{x:0,y:0},targetOffset:{x:0,y:0},isTwitching:!1,twitchTimer:0,cooldownTimer:0,lastTwitch:0});const r=e.gestureData.twitch,{config:o}=this;let l=i.intensity||o.intensity;i.rhythmModulation&&(l*=i.rhythmModulation.amplitudeMultiplier||1,l*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.probabilityMultiplier);const c=Date.now();if(!r.isTwitching&&r.cooldownTimer<=0&&Math.random()<(i.frequency||o.frequency)){r.isTwitching=!0,r.twitchTimer=o.duration,r.cooldownTimer=o.recovery;const e=Math.random()*Math.PI*2,t=.5*o.maxOffset+Math.random()*(.5*o.maxOffset);r.targetOffset={x:Math.cos(e)*t*l/8,y:Math.sin(e)*t*l/8},r.lastTwitch=c}if(r.cooldownTimer>0&&(r.cooldownTimer-=16*a),r.isTwitching)if(r.twitchTimer-=16*a,r.twitchTimer>0){const{sharpness:e}=o;r.twitchOffset.x+=(r.targetOffset.x-r.twitchOffset.x)*e,r.twitchOffset.y+=(r.targetOffset.y-r.twitchOffset.y)*e}else r.isTwitching=!1;else r.twitchOffset.x*=.85,r.twitchOffset.y*=.85;e.vx+=r.twitchOffset.x*a*.5,e.vy+=r.twitchOffset.y*a*.5,Math.random()<.1&&(e.vx+=(Math.random()-.5)*l*.3,e.vy+=(Math.random()-.5)*l*.3)},cleanup(e){e.gestureData?.twitch&&delete e.gestureData.twitch},"3d":{evaluate(e,t){const i=t.config||{};let a=.6*(i.intensity||8);const n=i.maxOffset||15,s=i.frequency||.08;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);const r=9999*Math.floor(10*e),o=e=>{const t=1e4*Math.sin(r+e);return t-Math.floor(t)};if(o(0)<3*s){const e=o(1)*Math.PI*2,t=n*a/8*.003;return{position:[Math.cos(e)*t*o(2),Math.sin(e)*t*o(3),(o(4)-.5)*t],rotation:[.12*(o(5)-.5),.12*(o(6)-.5),.12*(o(7)-.5)],scale:1+.06*(o(8)-.5)}}{const e=.3;return{position:[(o(10)-.5)*e,(o(11)-.5)*e,(o(12)-.5)*e],rotation:[.006*(o(13)-.5),.006*(o(14)-.5),.006*(o(15)-.5)],scale:1}}}}},tn={name:"vibrate",emoji:"📳",type:"blending",description:"High frequency vibration",config:{duration:500,frequency:20,amplitude:8,easing:"linear",strength:2,particleMotion:{type:"shake",strength:2,frequency:20,amplitude:8}},rhythm:{enabled:!0,syncMode:"subdivision",frequencySync:{subdivision:"thirty-second",baseFrequency:20,tempoScaling:!0},amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"pulse"},durationSync:{mode:"beats",beats:1},patternOverrides:{dubstep:{frequencySync:{subdivision:"sixteenth"},amplitudeSync:{onBeat:2,dropBeat:3}},breakbeat:{frequencySync:{mode:"random",range:[15,30]}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.vibrate={timer:0,seed:1e3*Math.random(),initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.vibrate?.initialized||this.initialize(e,i);const r=e.gestureData.vibrate,o={...this.config,...i},l=o.strength||this.config.strength||1;let{amplitude:c}=o,{frequency:h}=o;i.rhythmModulation&&(c*=i.rhythmModulation.amplitudeMultiplier||1,c*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(h*=i.rhythmModulation.frequencyMultiplier)),r.timer+=a*h;const u=(Math.random()-.5)*c*l,d=(Math.random()-.5)*c*l;if(e.vx+=.5*u*a,e.vy+=.5*d*a,e.vx*=.9,e.vy*=.9,t>.8){const i=1-5*(t-.8);e.vx*=i,e.vy*=i}},cleanup(e){e.gestureData?.vibrate&&delete e.gestureData.vibrate},"3d":{evaluate(e,t){const i={...this.config,...t};let{amplitude:a}=i;const n=i.strength||this.config.strength||1;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);const s=Math.sin(e*Math.PI),r=a*n*.003*s;return{position:[(Math.random()-.5)*r,(Math.random()-.5)*r,(Math.random()-.5)*r],rotation:[.01*(Math.random()-.5)*s,.01*(Math.random()-.5)*s,.01*(Math.random()-.5)*s],scale:1+.01*(Math.random()-.5)*s}}}},an={name:"shake",emoji:"🫨",type:"blending",description:"Random jitter movement for vibration effects",config:{duration:400,amplitude:15,frequency:15,decay:.9,smoothing:.1,axes:"both",easing:"linear",strength:3,particleMotion:{type:"shake",strength:3,frequency:15,decay:!1}},rhythm:{enabled:!0,syncMode:"subdivision",amplitudeSync:{subdivision:"sixteenth",onBeat:2.5,offBeat:.7,curve:"pulse"},frequencySync:{mode:"tempo",baseFrequency:15,scaling:"linear"},durationSync:{mode:"beats",beats:2},patternOverrides:{breakbeat:{amplitudeSync:{onBeat:3,offBeat:.2},frequencySync:{mode:"random",range:[8,20]}},dubstep:{amplitudeSync:{subdivision:"eighth",onBeat:4,dropBeat:6,curve:"pulse"}},swing:{amplitudeSync:{onBeat:1.8,offBeat:1,curve:"ease"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.shake={originalX:e.x,originalY:e.y,randomAngle:Math.random()*Math.PI*2,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.shake?.initialized||this.initialize(e,i);const r=e.gestureData.shake,o={...this.config,...i},l=o.strength||this.config.strength||1;let{amplitude:c}=o,{frequency:h}=o;i.rhythmModulation&&(c*=i.rhythmModulation.amplitudeMultiplier||1,c*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(h*=i.rhythmModulation.frequencyMultiplier));const u=o.decay?1-t:1,d=Math.sin(t*Math.PI*h)*c*u*l*e.scaleFactor,m=d*Math.cos(r.randomAngle),p=d*Math.sin(r.randomAngle);e.x=r.originalX+m,e.y=r.originalY+p},pseudoRandom(e){const t=1e4*Math.sin(e);return t-Math.floor(t)},cleanup(e){e.gestureData?.shake&&(e.x=e.gestureData.shake.originalX,e.y=e.gestureData.shake.originalY,delete e.gestureData.shake)},"3d":{evaluate(e,t){const i=t||{},a=.003*(i.amplitude||15),n=i.frequency||15,s=.5*(i.strength||1),r=i.decay?1-e:1,o=Math.sin(e*Math.PI*n)*a*r*s,l=Math.floor(e*n);return{position:[o*(1e4*Math.sin(l)%1-.5)*2,0,o*(1e4*Math.sin(1.3*l)%1-.5)*2],rotation:[0,0,o*(1e4*Math.sin(1.7*l)%1-.5)*.2],scale:1}}}},nn={name:"wiggle",emoji:"〰️",type:"additive",description:"Rapid side-to-side oscillation",config:{duration:600,musicalDuration:{musical:!0,beats:1},amplitude:15,frequency:6,strength:1,damping:.3,easing:"linear",particleMotion:{type:"wiggle",strength:1,amplitude:15,frequency:6}},rhythm:{enabled:!0,syncMode:"beat",frequencySync:{subdivision:"sixteenth",wigglePerBeat:4},amplitudeSync:{onBeat:1.5,offBeat:.8,curve:"bounce"},durationSync:{mode:"beats",beats:1}},apply(e,t,i,a,n,s,r){const o=(i.amplitude||this.config.amplitude)*n,l=i.frequency||this.config.frequency,c=1-a*(i.damping||this.config.damping),h=Math.sin(a*Math.PI*l)*o*c;e.vx+=.5*h;const u=Math.cos(a*Math.PI*l*2)*o*.1*c;e.vy+=.3*u},"3d":{evaluate(e,t){const i=t.config||{},a=t.strength||1,n=i.amplitude||15,s=Math.pow(1-e,.5),r=Math.sin(e*Math.PI*14)*s,o=Math.cos(e*Math.PI*14*.7)*s*.4,l=n/15*a,c=.15*r*a;return{cameraRelativePosition:[.08*r*l,.02*Math.abs(o)*l,0],cameraRelativeRotation:[0,0,c],scale:1+.05*Math.abs(r),glowIntensity:1+.2*Math.abs(r)}}}};function sn(e){const t=ja[e];if(!t)throw new Error(`Invalid step direction: ${e}`);return{name:`step${qa(e)}`,emoji:"left"===e?"👈":"right"===e?"👉":"up"===e?"👆":"👇",type:"blending",description:`Quick step ${e} and return`,config:{duration:400,amplitude:25,strength:.7,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:5,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"snap"}},apply(e,i,a,n,s,r){const o={...this.config,...a};let l,c=o.amplitude*o.strength*e.scaleFactor;a.rhythmModulation&&(c*=a.rhythmModulation.amplitudeMultiplier||1,c*=a.rhythmModulation.accentMultiplier||1),l=i<.3?this.easeOutQuad(i/.3):1-this.easeInOutCubic((i-.3)/.7);const h=t.x*c*l*.01*n,u=t.y*c*l*.01*n;e.vx+=h,e.vy+=u},cleanup(e){},easeOutQuad:e=>1-(1-e)*(1-e),easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,i){const a=i||{},n=a.amplitude||25,s=a.strength||.7;let r,o=.008*n*s;if(i.rhythmModulation&&(o*=i.rhythmModulation.amplitudeMultiplier||1),e<.3)r=1-(1-e/.3)*(1-e/.3);else{const t=(e-.3)/.7;r=1-(t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2)}const l=t.x*o*r,c=t.y*o*r,h=.12*r*s,u=-t.x*h;return{cameraRelativePosition:[l,c,0],rotation:[t.y*h*.5,0,u],scale:1}}}}}function rn(e){const t=ja[e];if(!t)throw new Error(`Invalid slide direction: ${e}`);return{name:`slide${qa(e)}`,emoji:"left"===e?"⬅️":"➡️",type:"blending",description:`Smooth slide ${e} and return`,config:{duration:800,amplitude:35,strength:.6,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,durationSync:{mode:"beats",beats:2},amplitudeSync:{onBeat:1.2,offBeat:.9,curve:"ease"}},apply(e,i,a,n,s,r){const o={...this.config,...a};let l=o.amplitude*o.strength*e.scaleFactor;a.rhythmModulation&&(l*=a.rhythmModulation.amplitudeMultiplier||1,l*=a.rhythmModulation.accentMultiplier||1);const c=Math.sin(i*Math.PI),h=t.x*l*c*.008*n,u=t.y*l*c*.008*n;e.vx+=h,e.vy+=u},cleanup(e){},"3d":{evaluate(e,i){const a=i||{},n=a.amplitude||35,s=a.strength||.6;let r=.008*n*s;i.rhythmModulation&&(r*=i.rhythmModulation.amplitudeMultiplier||1);const o=Math.sin(e*Math.PI),l=t.x*r*o,c=t.y*r*o,h=.08*o*s,u=-t.x*h,d=t.x*h*.5;return{cameraRelativePosition:[l,c,.02*Math.sin(e*Math.PI*2)*s],rotation:[0,d,u],scale:1+.03*o}}}}}var on=sn("left"),ln=sn("right"),cn=sn("up"),hn=sn("down"),un=rn("left"),dn=rn("right"),mn={name:"runningman",emoji:"🏃",type:"effect",description:"Hip-hop running man shuffle",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},slideDistance:30,stepHeight:15,speed:1.2,strength:.8,particleMotion:{type:"runningman",strength:.7}},rhythm:{enabled:!0,syncToBeat:!0,durationSync:{mode:"bars",bars:1},beatMultiplier:1,accentBeats:[1,3]},apply:(e,t,i,a,n,s)=>!1,blend:(e,t,i)=>!1,"3d":{evaluate(e,t){const i={...this.config,...t}.strength||.8;return{position:[.1*Math.sin(e*Math.PI*4)*i,.05*Math.abs(Math.sin(e*Math.PI*8))*i,0],rotation:[0,0,.035*Math.sin(e*Math.PI*4)*i],scale:1-.035*Math.abs(Math.sin(e*Math.PI*8))*i,glowIntensity:1+.25*Math.abs(Math.sin(e*Math.PI*8)),glowBoost:.35*Math.max(0,Math.abs(Math.sin(e*Math.PI*8)))}}}},pn={name:"charleston",emoji:"🕺",type:"effect",description:"Hip-hop Charleston shuffle with crisscross",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},kickDistance:35,swivelRange:40,bounceHeight:12,strength:.9,particleMotion:{type:"charleston",strength:.8}},rhythm:{enabled:!0,syncToBeat:!0,durationSync:{mode:"bars",bars:1.5},beatMultiplier:2,accentBeats:[1,2.5,3,4.5]},apply:(e,t,i,a,n,s)=>!1,blend:(e,t,i)=>!1,"3d":{evaluate(e,t){const i={...this.config,...t}.strength||.9;return{position:[.12*Math.sin(e*Math.PI*8)*i,.05*Math.abs(Math.sin(e*Math.PI*8))*i,0],rotation:[0,0,.05*Math.sin(e*Math.PI*8)*i],scale:1-.04*Math.abs(Math.sin(e*Math.PI*8))*i,glowIntensity:1+.3*Math.abs(Math.sin(e*Math.PI*8)),glowBoost:.4*Math.max(0,Math.abs(Math.sin(e*Math.PI*8)))}}}},gn={name:"hula",emoji:"🌀",type:"override",description:"Hula-hoop motion with vertical waves",config:{speed:.015,maintainRadius:!1,elliptical:!0,use3D:!0,zPhaseOffset:Math.PI/4,verticalOscillation:.3,wobbleAmount:.15,duration:2500,musicalDuration:{musical:!0,bars:1.5},particleMotion:{type:"hula",strength:1,verticalOscillation:.3}},rhythm:{enabled:!0,syncMode:"bar",durationSync:{mode:"bars",bars:1.5},speedSync:{mode:"tempo",baseSpeed:.015,scaling:"proportional"},wobbleSync:{onBeat:.25,offBeat:.1,curve:"sine"},verticalSync:{subdivision:"quarter",amplitude:.4,phase:"sequential"},dynamics:{forte:{wobbleAmount:.3,speed:1.2},piano:{wobbleAmount:.05,speed:.8}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a,r=Math.sqrt(n*n+s*s),o=Math.random()<.5?1:-1,l=Math.max(r,100+180*Math.random()),c=r<5?Math.random()*Math.PI*2:Math.atan2(s,n);e.gestureData.hula={radius:l,angle:c,initialAngle:c,originalVx:e.vx,originalVy:e.vy,originalZ:e.z||0,zPhase:Math.random()*Math.PI*2,wobblePhase:Math.random()*Math.PI*2,direction:o}},apply(e,t,i,a,n,s){e.gestureData?.hula||this.initialize(e,i,n,s);const r=e.gestureData.hula,o=(i.speed||this.config.speed)*(i.strength||1);let l=1;t<.1?(l=t/.1,l=Math.sin(l*Math.PI*.5)):t>.9&&(l=(1-t)/.1,l=Math.sin(l*Math.PI*.5)),r.angle+=o*a*r.direction*l;const c=Math.sin(2*r.angle+r.wobblePhase)*(i.wobbleAmount||this.config.wobbleAmount)*l,h=r.radius*(1+c)*l,u=r.radius*(.7+c)*l,d=n+Math.cos(r.angle)*h,m=s+Math.sin(r.angle)*u;if(t<.1){const t=e.x-n,i=e.y-s;Math.sqrt(t*t+i*i)<50?(e.x=n+Math.cos(r.angle)*h,e.y=s+Math.sin(r.angle)*u):(e.x=e.x+(d-e.x)*l*.5,e.y=e.y+(m-e.y)*l*.5)}else e.x=d,e.y=m;const p=r.angle+r.zPhase+(i.zPhaseOffset||this.config.zPhaseOffset);e.z=.9*Math.sin(p)*l;const g=i.verticalOscillation||this.config.verticalOscillation,f=Math.cos(2*p)*g*r.radius*.2*l;e.y+=f;const y=e.z*r.radius*.1;e.y-=y;const v=-Math.sin(r.angle)*h*o,b=Math.cos(r.angle)*u*o;t<.1?(e.vx=r.originalVx+(v-r.originalVx)*l,e.vy=r.originalVy+(b-r.originalVy)*l):t>.9?(e.vx=v*l+r.originalVx*(1-l),e.vy=b*l+r.originalVy*(1-l),e.z=e.z*l+r.originalZ*(1-l)):(e.vx=v,e.vy=b)},cleanup(e){if(e.gestureData?.hula){const t=e.gestureData.hula;e.vx=t.originalVx,e.vy=t.originalVy,e.z=t.originalZ,delete e.gestureData.hula}},"3d":{evaluate(e,t){const{particle:i}=t;if(!i||!i.gestureData?.hula)return{position:[0,0,0],rotation:[0,0,0],scale:1};const a=i.gestureData.hula,n=t.config||{};let s=1;e<.15?(s=e/.15,s=Math.sin(s*Math.PI*.5)):e>.85&&(s=(1-e)/.15,s=Math.sin(s*Math.PI*.5));const r=a.initialAngle+e*Math.PI*2*a.direction,o=.25*Math.cos(r)*s,l=.25*Math.sin(r)*s,c=n.verticalOscillation||.3;return{position:[o,Math.sin(2*r+a.wobblePhase)*c*s,l],rotation:[0,(r-a.initialAngle)*s,0],scale:1+.15*Math.abs(Math.sin(r))*s}}}},fn={name:"twist",emoji:"🌀",type:"override",description:"Twisting dance motion with alternating rotation",config:{duration:1200,musicalDuration:{musical:!0,beats:3},rotationAngle:45,contractionFactor:.8,twistFrequency:2,easing:"smooth",strength:.8,particleMotion:{type:"twist",rotationAngle:45,contractionFactor:.8,twistFrequency:2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!1,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"elastic"},patternOverrides:{funk:{rotationAngle:60,contractionFactor:.7},disco:{twistFrequency:3,rotationAngle:50},latin:{rotationAngle:35,contractionFactor:.85,twistFrequency:2.5}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.twist={startX:e.x,startY:e.y,startAngle:Math.atan2(e.y-t.centerY,e.x-t.centerX),startDistance:Math.sqrt(Math.pow(e.x-t.centerX,2)+Math.pow(e.y-t.centerY,2)),initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.twist?.initialized||this.initialize(e,{...i,centerX:n,centerY:s});const r={...this.config,...i},o=e.gestureData.twist,l=r.strength||this.config.strength||1,c=t*r.twistFrequency*Math.PI*2,h=Math.sin(c)*l;let{rotationAngle:u}=r,{contractionFactor:d}=r;i.rhythmModulation&&(u*=i.rhythmModulation.amplitudeMultiplier||1,d=1-(1-d)*(i.rhythmModulation.amplitudeMultiplier||1));const m=u*Math.PI/180*h,p=1-(1-d)*Math.abs(h),g=o.startAngle+m,f=o.startDistance*p,y=n+Math.cos(g)*f,v=s+Math.sin(g)*f,b=.15*l;e.x+=(y-e.x)*b,e.y+=(v-e.y)*b,e.vx=.05*(y-e.x),e.vy=.05*(v-e.y);const w=5*Math.sin(t*Math.PI*4)*l;if(e.y+=.1*w,t>.9){const i=1-10*(t-.9);e.vx*=i,e.vy*=i}},cleanup(e){e.gestureData?.twist&&delete e.gestureData.twist},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||.8,n=e>.85?(1-e)/.15:1,s=e*(i.twistFrequency||2)*Math.PI*2,r=Math.sin(s)*a*n,o=r*((i.rotationAngle||45)*Math.PI/180);return{position:[.05*Math.sin(s)*a*n,.02*Math.abs(Math.sin(2*s))*a*n,0],rotation:[.08*Math.cos(s)*a*n,o,.12*Math.sin(.5*s)*a*n],scale:1-(1-(i.contractionFactor||.8))*Math.abs(r),glowIntensity:1+.3*Math.abs(r)}}}},yn={name:"pop",emoji:"💥",type:"blending",description:"Quick scale pulse - the classic beat hit",config:{duration:200,musicalDuration:{musical:!0,beats:.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:.5},interruptible:!0,priority:5,blendable:!0},apply:(e,t,i)=>!1,blend:(e,t,i)=>!1,"3d":{isAccent:!0,evaluate(e,t){const i=t?.strength||1;let a;return e<.15?(a=e/.15,a=1-Math.pow(1-a,3)):(a=1-(e-.15)/.85,a=Math.pow(a,2)),{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+.08*a*i,glowBoost:.3*a*i,positionBoost:[0,.02*a*i,0]}}}},vn={name:"flare",emoji:"🔥",type:"blending",description:"Dramatic scale burst with intense glow - for big moments",config:{duration:400,musicalDuration:{musical:!0,beats:1},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1},interruptible:!0,priority:6,blendable:!0},apply:(e,t,i)=>!1,blend:(e,t,i)=>!1,"3d":{isAccent:!0,evaluate(e,t){const i=t?.strength||1;let a;if(e<.1){const t=e/.1;a=1-Math.pow(1-t,4)}else if(e<.3){const t=(e-.1)/.2;a=1-.1*Math.sin(t*Math.PI)}else a=1-(e-.3)/.7,a=Math.pow(a,.6);return{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+(.15*a+.15*Math.sin(e*Math.PI*4)*(1-e)*.02)*i,glowBoost:.8*a*i,positionBoost:[0,.04*a*i,0]}}}},bn={name:"swell",emoji:"🌟",type:"blending",description:"Glow build with scale - for transitions and builds",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1.5},interruptible:!0,priority:4,blendable:!0},apply:(e,t,i)=>!1,blend:(e,t,i)=>!1,"3d":{isAccent:!0,evaluate(e,t){const i=t?.strength||1;let a;if(e<.6){const t=e/.6;a=t*t}else{const t=(e-.6)/.4;a=1-t*t}return{position:[0,0,0],rotation:[0,0,0],scale:1,scaleBoost:1+.1*a*i,glowBoost:.4*a*i,positionBoost:[0,.03*Math.sin(e*Math.PI)*i,0]}}}},wn={name:"swagger",emoji:"😎",type:"blending",description:"Side lean with drift - confident swagger",config:{duration:400,musicalDuration:{musical:!0,beats:1},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:1},interruptible:!0,priority:4,blendable:!0},apply:(e,t,i)=>!1,blend:(e,t,i)=>!1,"3d":{isAccent:!0,evaluate(e,t){const i=t?.strength||1;let a;if(e<.3){const t=e/.3;a=1-Math.pow(1-t,2)}else if(e<.7)a=1;else{const t=(e-.7)/.3;a=1-t*t}return{position:[0,0,0],rotation:[0,0,0],scale:1,rotationBoost:[0,0,.12*a*i*1],positionBoost:[.04*a*i*1,.01*a*i,0],scaleBoost:1+.03*a*i}}}},Mn={name:"dip",emoji:"⬇️",type:"blending",description:"Downward bob - groove dip feel",config:{duration:250,musicalDuration:{musical:!0,beats:.5},strength:1},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:.5},interruptible:!0,priority:5,blendable:!0},apply:(e,t,i)=>!1,blend:(e,t,i)=>!1,"3d":{isAccent:!0,evaluate(e,t){const i=t?.strength||1,a=Math.sin(e*Math.PI);return{position:[0,0,0],rotation:[0,0,0],scale:1,positionBoost:[0,.015*-a*i,0],scaleBoost:1-.015*a*i}}}},Sn={name:"bounce",emoji:"⬆️",type:"blending",description:"Vertical oscillation with smooth easing",config:{duration:800,musicalDuration:{musical:!0,beats:2},amplitude:30,frequency:2,axis:"vertical",damping:!0,easing:"sine",strength:.6,particleMotion:{type:"bounce",axis:"vertical",strength:.6,frequency:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.8,offBeat:.6,curve:"bounce"},frequencySync:{mode:"tempo",multiplier:1},durationSync:{mode:"beats",beats:4},accentResponse:{enabled:!0,multiplier:1.5},patternOverrides:{waltz:{frequencySync:{multiplier:.75},durationSync:{beats:3}},swing:{amplitudeSync:{onBeat:2,offBeat:.4,curve:"ease"}},dubstep:{amplitudeSync:{onBeat:1.5,dropBeat:3,curve:"pulse"}},breakbeat:{frequencySync:{multiplier:1.5},amplitudeSync:{onBeat:2.2,offBeat:.3}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.bounce={startY:e.y,startX:e.x,startVx:e.vx,startVy:e.vy,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.bounce?.initialized||this.initialize(e,i);const r={...this.config,...i},o=r.strength||this.config.strength||1,l=this.easeInOutCubic(t);let{frequency:c}=r;const h=i.phase||0;let u=r.amplitude*o*e.scaleFactor;i.rhythmModulation&&(u*=i.rhythmModulation.amplitudeMultiplier||1,u*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(c*=i.rhythmModulation.frequencyMultiplier));const d=Math.sin((l+h)*Math.PI*2*c);if(r.damping&&t>.7&&(u*=1-(t-.7)/.3*.8),"vertical"===r.axis?(e.vy+=d*u*.01*a,t>.9&&(e.vx*=.98)):"horizontal"===r.axis&&(e.vx+=d*u*.01*a,t>.9&&(e.vy*=.98)),t>.9){const i=1-10*(t-.9);e.vx=e.vx*(.95+.05*i),e.vy=e.vy*(.95+.05*i)}},cleanup(e){e.gestureData?.bounce&&delete e.gestureData.bounce},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const i=t||{},a=i.amplitude||30,n=i.frequency||2,s=.003*a*(i.strength||.6),r=(e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2)*Math.PI*n,o=Math.abs(Math.sin(r));let l=s;return e>.7&&(l*=1-(e-.7)/.3*.8),{position:[0,o*l,0],rotation:[0,0,0],scale:1+.08*o}}}},xn={name:"orbit",emoji:"🪐",type:"override",description:"Orbital motion around center",config:{speed:.02,maintainRadius:!0,elliptical:!1,use3D:!0,zPhaseOffset:0,verticalOscillation:0,duration:3e3,musicalDuration:{musical:!0,bars:2},particleMotion:{type:"orbit",strength:1}},rhythm:{enabled:!0,syncMode:"harmonic",durationSync:{mode:"bars",bars:2},speedSync:{tonic:.02,fifth:.03,octave:.04,third:.025,curve:"smooth"},radiusSync:{bass:150,mid:100,treble:50,scaling:"logarithmic"},depthSync:{major:{z:1,phase:0},minor:{z:-1,phase:Math.PI},diminished:{z:.5,phase:Math.PI/2},augmented:{z:.8,phase:-Math.PI/2}},phaseSync:{mode:"harmonic",intervals:[1,1.5,2],drift:.05},dynamics:{forte:{speed:.04,maintainRadius:!1},piano:{speed:.01,maintainRadius:!0}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a,r=Math.sqrt(n*n+s*s),o=Math.random()<.5?1:-1,l=Math.max(r,100+180*Math.random()),c=r<5?Math.random()*Math.PI*2:Math.atan2(s,n);e.gestureData.orbit={radius:l,targetRadius:l,angle:c,initialAngle:c,originalVx:e.vx,originalVy:e.vy,originalZ:e.z||0,zPhase:Math.random()*Math.PI*2,direction:o}},apply(e,t,i,a,n,s){e.gestureData?.orbit||this.initialize(e,i,n,s);const r=e.gestureData.orbit,o=(i.speed||this.config.speed)*(i.strength||1);r.angle+=o*a*r.direction;let{radius:l}=r;if(i.maintainRadius||(l=r.radius*(1+.1*Math.sin(t*Math.PI*2))),e.x=n+Math.cos(r.angle)*l,e.y=s+Math.sin(r.angle)*l,!1!==i.use3D){const t=r.angle+r.zPhase+(i.zPhaseOffset||0);if(e.z=.8*Math.sin(t),i.verticalOscillation){const a=Math.cos(t)*i.verticalOscillation*l*.1;e.y+=a}}if(e.vx=-Math.sin(r.angle)*l*o,e.vy=Math.cos(r.angle)*l*o,t>.9){const i=10*(1-t);e.vx=e.vx*i+r.originalVx*(1-i),e.vy=e.vy*i+r.originalVy*(1-i)}},cleanup(e){if(e.gestureData?.orbit){const t=e.gestureData.orbit;e.vx=t.originalVx,e.vy=t.originalVy,e.z=t.originalZ,delete e.gestureData.orbit}},"3d":{evaluate(e,t){const i=t?.particle;if(!i||!i.gestureData?.orbit)return{position:[0,0,0],rotation:[0,0,0],scale:1};const a=i.gestureData.orbit;let n=1;e<.15?n=Math.sin(e/.15*Math.PI*.5):e>.85&&(n=Math.sin((1-e)/.15*Math.PI*.5));const s=a.initialAngle+e*Math.PI*2*a.direction,r=.3*Math.cos(s)*n,o=.3*Math.sin(s)*n,l=(s+Math.PI/2-(a.initialAngle+Math.PI/2))*n,c=i.z||0;return{position:[r,0,o+.1*c*n],rotation:[0,l,0],scale:1+.15*c*n}}}};function Cn(e){const t=ja[e];if(!t)throw new Error(`Invalid orbit direction: ${e}`);const i="up"===e||"down"===e,a="left"===e||"up"===e?1:-1;return{name:`orbit${qa(e)}`,emoji:"left"===e?"🔄":"right"===e?"🔃":"up"===e?"🌀":"💫",type:"override",description:`Orbit ${"left"===e?"counter-clockwise":"right"===e?"clockwise":e}`,config:{duration:1500,musicalDuration:{musical:!0,beats:4},speed:.02,maintainRadius:!0,use3D:!0,rotations:1,strength:1,direction:e,verticalOscillation:i?.3:0,particleMotion:{type:"orbit",strength:1,rotations:1}},rhythm:{enabled:!0,syncMode:"harmonic",durationSync:{mode:"bars",bars:1},speedSync:{tonic:.02,fifth:.03,octave:.04,curve:"smooth"},radiusSync:{bass:150,mid:100,treble:50,scaling:"logarithmic"},dynamics:{forte:{speed:.04,maintainRadius:!1},piano:{speed:.01,maintainRadius:!0}}},initialize(e,t,i,n){e.gestureData||(e.gestureData={});const s=e.x-i,r=e.y-n,o=Math.sqrt(s*s+r*r),l=Math.max(o,80+100*Math.random()),c=o<5?Math.random()*Math.PI*2:Math.atan2(r,s);e.gestureData.orbit={radius:l,targetRadius:l,angle:c,initialAngle:c,originalVx:e.vx,originalVy:e.vy,originalZ:e.z||0,zPhase:Math.random()*Math.PI*2,direction:a,initialized:!0}},apply(e,a,n,s,r,o){e.gestureData?.orbit?.initialized||this.initialize(e,n,r,o);const l=e.gestureData.orbit,c={...this.config,...n},h=n.strength||1,u=(c.speed||.02)*h;let d=1;a<.15?(d=a/.15,d=Math.sin(d*Math.PI*.5)):a>.85&&(d=(1-a)/.15,d=Math.sin(d*Math.PI*.5)),l.angle+=u*s*l.direction*d;let{radius:m}=l;c.maintainRadius||(m=l.radius*(1+.1*Math.sin(a*Math.PI*2)));const p=m*d+(1-d)*l.radius*.5;if(e.x=r+Math.cos(l.angle)*p,e.y=o+Math.sin(l.angle)*p,!1!==c.use3D){const n=l.angle+l.zPhase;if(e.z=.8*Math.sin(n)*d,i&&c.verticalOscillation){const i=t.y*a*c.verticalOscillation*m*.5;e.y+=i}}if(e.vx=-Math.sin(l.angle)*p*u*d,e.vy=Math.cos(l.angle)*p*u*d,a>.9){const t=10*(1-a);e.vx=e.vx*t+l.originalVx*(1-t),e.vy=e.vy*t+l.originalVy*(1-t)}},cleanup(e){if(e.gestureData?.orbit){const t=e.gestureData.orbit;e.vx=t.originalVx,e.vy=t.originalVy,e.z=t.originalZ,delete e.gestureData.orbit}},"3d":{evaluate(e,n){const s=n.config||n||{},r=n.strength||1,o=s.rotations||1;let l=1;e<.15?l=Math.sin(e/.15*Math.PI*.5):e>.85&&(l=Math.sin((1-e)/.15*Math.PI*.5));const c=.25*r,h=e*Math.PI*2*o*a,u=Math.cos(h)*c*l,d=Math.sin(h)*c*l;let m=0;return i&&(m=t.y*e*.2*r*l),{cameraRelativePosition:[u,m,d],rotation:[0,h*l*.5,0],scale:1+.2*d}}}}}var Pn=Cn("left"),kn=Cn("right"),Dn=Cn("up"),An=Cn("down"),_n={name:"jump",emoji:"🦘",type:"override",description:"Squash, leap, and land with classic animation principles",config:{duration:800,musicalDuration:{musical:!0,beats:2},jumpHeight:60,squashAmount:.8,stretchAmount:1.2,anticipation:.2,hangTime:.1,landingImpact:!0,driftOutward:!0,easing:"quad",particleMotion:{type:"jump",strength:.9,jumpHeight:60,squash:.8,stretch:1.2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},phaseSync:{anticipation:"eighth",jump:"beat",landing:"sixteenth"},heightSync:{onBeat:1.5,offBeat:.8,accent:2,curve:"exponential"},deformationSync:{squashOnBeat:.6,stretchOnBeat:1.4,timing:"anticipatory"},hangTimeSync:{mode:"tempo",baseDuration:.1,scaling:"inverse"},dynamics:{forte:{jumpHeight:80,stretch:1.3},piano:{jumpHeight:30,stretch:1.1}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={}),e.gestureData.jump={startX:e.x,startY:e.y,startSize:e.size,originalVx:e.vx,originalVy:e.vy,driftDirection:.1*(e.x-i),initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.jump?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.jump,o={...this.config,...i},l=i.strength||1,c=o.jumpHeight*l*e.scaleFactor,h=o.squashAmount,u=o.stretchAmount,d=o.anticipation,m=1-.5*o.anticipation;if(t<d){const i=t/d,a=this.easeOutQuad(i);e.size=r.startSize*(1-(1-h)*a),e.y=r.startY+5*a*e.scaleFactor,e.vx=0,e.vy=0}else if(t<m){const i=(t-d)/(m-d);let a=Math.sin(i*Math.PI);if(o.hangTime>0&&i>.4&&i<.6){const e=(i-.4)/.2;a=.95+.05*this.easeInOutCubic(e)}if(e.y=r.startY-a*c,o.driftOutward&&(e.x=r.startX+a*r.driftDirection),i<.5){const t=2*i;e.size=r.startSize*(h+(u-h)*t)}else{const t=2*(i-.5);e.size=r.startSize*(u-(u-1)*t*.8)}e.vx=.5*r.driftDirection,e.vy=-Math.cos(i*Math.PI)*c*.1}else{const i=(t-m)/(1-m),a=this.easeOutBounce(i);if(e.y=r.startY,o.landingImpact)if(i<.3){const t=i/.3;e.size=r.startSize*(1-(1-.8*h)*(1-t))}else{const t=(i-.3)/.7;e.size=r.startSize*(.8*h+(1-.8*h)*t)}else e.size=r.startSize*(h+(1-h)*a);e.vx=r.originalVx*a,e.vy=r.originalVy*a}},cleanup(e){if(e.gestureData?.jump){const t=e.gestureData.jump;e.size=t.startSize,e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.jump}},easeOutQuad:e=>e*(2-e),easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutBounce(e){const t=7.5625,i=2.75;return e<1/i?t*e*e:e<2/i?t*(e-=1.5/i)*e+.75:e<2.5/i?t*(e-=2.25/i)*e+.9375:t*(e-=2.625/i)*e+.984375},"3d":{evaluate(e,t){const i=t.config||t||{},a=t.strength||1,n=.004*(i.jumpHeight||60)*a,s=i.squashAmount||.8,r=i.stretchAmount||1.2,o=i.anticipation||.2,l=1-.5*o;let c=0,h=1,u=0;if(e<o){const t=e/o,i=t*(2-t);h=1-(1-s)*i,c=.02*-i}else if(e<l){const t=(e-o)/(l-o);c=Math.sin(t*Math.PI)*n,h=t<.5?s+2*t*(r-s):r-2*(t-.5)*(r-1)*.8,u=.05*Math.sin(t*Math.PI)}else{const t=(e-l)/(1-l);if(t<.5){const e=2*t;c=-Math.sin(e*Math.PI)*n*.15}else c=0;h=!1!==i.landingImpact?t<.3?1-(1-.8*s)*(1-t/.3):.8*s+(t-.3)/.7*(1-.8*s):s+(1-s)*t}return{position:[0,c,0],rotation:[u,0,0],scale:h}}}};function Tn(e){const t=ja[e];if(!t)throw new Error(`Invalid jump direction: ${e}`);const i="up"===e||"down"===e;return{name:`jump${qa(e)}`,emoji:"up"===e?"🦘":"down"===e?"💥":"left"===e?"⬅️":"➡️",type:"override",description:`Jump ${e} with squash & stretch`,config:{duration:800,musicalDuration:{musical:!0,beats:2},jumpDistance:60,squashAmount:.8,stretchAmount:1.2,anticipation:.2,hangTime:.1,landingImpact:!0,easing:"quad",strength:1,direction:e,particleMotion:{type:"jump",strength:.9,jumpDistance:60,squash:.8,stretch:1.2}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},phaseSync:{anticipation:"eighth",jump:"beat",landing:"sixteenth"},distanceSync:{onBeat:1.5,offBeat:.8,accent:2,curve:"exponential"},deformationSync:{squashOnBeat:.6,stretchOnBeat:1.4,timing:"anticipatory"},dynamics:{forte:{jumpDistance:80,stretch:1.3},piano:{jumpDistance:30,stretch:1.1}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={}),e.gestureData.jump={startX:e.x,startY:e.y,startSize:e.size,originalVx:e.vx,originalVy:e.vy,initialized:!0}},apply(e,a,n,s,r,o){e.gestureData?.jump?.initialized||this.initialize(e,n,r,o);const l=e.gestureData.jump,c={...this.config,...n},h=n.strength||1,u=c.jumpDistance*h*e.scaleFactor,d=c.squashAmount,m=c.stretchAmount,p=c.anticipation,g=1-.5*c.anticipation;if(a<p){const n=a/p,s=this.easeOutQuad(n);e.size=l.startSize*(1-(1-d)*s),i?e.y=l.startY-t.y*s*5*e.scaleFactor:e.x=l.startX-t.x*s*5*e.scaleFactor,e.vx=0,e.vy=0}else if(a<g){const n=(a-p)/(g-p);let s=Math.sin(n*Math.PI);if(c.hangTime>0&&n>.4&&n<.6){const e=(n-.4)/.2;s=.95+.05*this.easeInOutCubic(e)}if(i?(e.y=l.startY+t.y*s*u,e.x=l.startX+3*Math.sin(n*Math.PI*2)):(e.x=l.startX+t.x*s*u,e.y=l.startY-Math.sin(n*Math.PI)*u*.3),n<.5){const t=2*n;e.size=l.startSize*(d+(m-d)*t)}else{const t=2*(n-.5);e.size=l.startSize*(m-(m-1)*t*.8)}i?(e.vy=t.y*Math.cos(n*Math.PI)*u*.1,e.vx=0):(e.vx=t.x*Math.cos(n*Math.PI)*u*.1,e.vy=-Math.cos(n*Math.PI)*u*.05)}else{const t=(a-g)/(1-g),i=this.easeOutBounce(t);if(e.x=l.startX,e.y=l.startY,c.landingImpact)if(t<.3){const i=t/.3;e.size=l.startSize*(1-(1-.8*d)*(1-i))}else{const i=(t-.3)/.7;e.size=l.startSize*(.8*d+(1-.8*d)*i)}else e.size=l.startSize*(d+(1-d)*i);e.vx=l.originalVx*i,e.vy=l.originalVy*i}},cleanup(e){if(e.gestureData?.jump){const t=e.gestureData.jump;e.size=t.startSize,e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.jump}},easeOutQuad:e=>e*(2-e),easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutBounce(e){const t=7.5625,i=2.75;return e<1/i?t*e*e:e<2/i?t*(e-=1.5/i)*e+.75:e<2.5/i?t*(e-=2.25/i)*e+.9375:t*(e-=2.625/i)*e+.984375},"3d":{evaluate(e,a){const n=a.config||a||{},s=a.strength||1,r=.004*(n.jumpDistance||60)*s,o=n.squashAmount||.8,l=n.stretchAmount||1.2,c=n.anticipation||.2,h=1-.5*c;let u=0,d=0,m=1,p=0,g=0,f=0;if(e<c){const a=e/c,n=a*(2-a);m=1-(1-o)*n,i?d=-t.y*n*.02:u=-t.x*n*.02}else if(e<h){const a=(e-c)/(h-c),n=Math.sin(a*Math.PI);i?d=t.y*n*r:(u=t.x*n*r,d=Math.sin(a*Math.PI)*r*.3),m=a<.5?o+2*a*(l-o):l-2*(a-.5)*(l-1)*.8,i?p=t.y*Math.sin(a*Math.PI)*.1:(g=t.x*Math.sin(a*Math.PI)*.15,f=-t.x*Math.sin(a*Math.PI)*.05)}else{const a=(e-h)/(1-h);if(a<.5){const e=2*a;i?d=-t.y*Math.sin(e*Math.PI)*r*.15:u=-t.x*Math.sin(e*Math.PI)*r*.1}m=!1!==n.landingImpact?a<.3?1-(1-.8*o)*(1-a/.3):.8*o+(a-.3)/.7*(1-.8*o):o+(1-o)*a}return{cameraRelativePosition:[u,d,0],rotation:[p,g,f],scale:m}}}}}var In=Tn("down"),On=Tn("left"),Rn=Tn("right");function En(e){if(!["forward","back","left","right","up","down"].includes(e))throw new Error(`Invalid rush direction: ${e}`);return{name:`rush${qa(e)}`,emoji:{forward:"💨",back:"🏃",left:"⬅️",right:"➡️",up:"⬆️",down:"⬇️"}[e],type:"override",description:{forward:"Quick rush toward camera",back:"Quick retreat away",left:"Quick strafe left",right:"Quick strafe right",up:"Quick leap upward",down:"Quick dive downward"}[e],config:{duration:600,musicalDuration:{musical:!0,beats:1.5},strength:1,direction:e,particleMotion:{type:"rush",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.direction||"forward";let s=0,r=0,o=0,l=0,c=0,h=1,u=1,d=0;const m={forward:{x:0,y:0,z:1,lean:{x:.2,z:0}},back:{x:0,y:0,z:-1,lean:{x:-.2,z:0}},left:{x:-1,y:0,z:0,lean:{x:0,z:.2}},right:{x:1,y:0,z:0,lean:{x:0,z:-.2}},up:{x:0,y:1,z:0,lean:{x:-.15,z:0}},down:{x:0,y:-1,z:0,lean:{x:.2,z:0}}}[n],p=.2;if(e<.2){const t=e/.2,i=1-Math.pow(1-t,2);l=i*m.lean.x*a,c=i*m.lean.z*a,r="up"===n?.03*-i*a:.02*-i*a,u=1+.3*i}else if(e<.6){const t=(e-.2)/.4,i=1-Math.pow(1-t,3);s=m.x*i*p*a,r=m.y*i*p*a,o=m.z*i*p*a,"up"===n?r+=.05*i*a:"down"!==n&&(r+=(.04*i-.02)*a),l=m.lean.x*a,c=m.lean.z*a,h=1+.08*i,u=1.3+.5*i,d=.35*i,c+=Math.sin(t*Math.PI*12)*(1-t)*.015*a}else{const t=(e-.6)/.4,i=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;if(s=m.x*p*(1-i)*a,r=m.y*p*(1-i)*a,o=m.z*p*(1-i)*a,l=m.lean.x*(1-i)*a,c=m.lean.z*(1-i)*a,h=1.08-.08*i,t>.7){const e=(t-.7)/.3;r-=.02*Math.sin(e*Math.PI)*a}u=1.8-.8*i,d=.35*(1-i)}return{cameraRelativePosition:[s,r,o],cameraRelativeRotation:[l,0,c],scale:h,glowIntensity:u,glowBoost:d}}}}}var Bn={name:"lunge",emoji:"🤺",type:"override",description:"Forward thrust lunge with emphasis",config:{duration:500,musicalDuration:{musical:!0,beats:1},distance:.25,direction:"forward",recover:!0,strength:1,particleMotion:{type:"lunge",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.distance||.25,s=!1!==i.recover;let r;e<.3?(r=e/.3,r=1-Math.pow(1-r,3)):e<.6?r=1:s?(r=1-(e-.6)/.4,r=Math.pow(r,2)):r=1;const o=r*n*a;return{position:[0,.05*-Math.sin(r*Math.PI)*a,o],rotation:[.2*r*a,0,0],scale:1+.1*r*a,glowIntensity:1+.3*r,glowBoost:e<.4?.4*r:0}}}};function Fn(e){if(!{...ja,forward:{x:0,y:0,z:-1},back:{x:0,y:0,z:1}}[e])throw new Error(`Invalid lunge direction: ${e}`);return{name:`lunge${qa(e)}`,emoji:{forward:"🤺",back:"🏃",left:"👈",right:"👉",up:"☝️",down:"👇"}[e]||"🤺",type:"override",description:`Lunge thrust ${e}`,config:{duration:500,musicalDuration:{musical:!0,beats:1},distance:.25,recover:!0,strength:1,direction:e,particleMotion:{type:"lunge",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.distance||.25,s=!1!==i.recover,r=i.direction||"forward";let o;e<.3?(o=e/.3,o=1-Math.pow(1-o,3)):e<.6?o=1:s?(o=1-(e-.6)/.4,o=Math.pow(o,2)):o=1;let l=0,c=0,h=0,u=0,d=0;switch(r){case"forward":h=o*n*a,u=.2*o*a,c=.05*-Math.sin(o*Math.PI)*a;break;case"back":h=-o*n*a,u=.2*-o*a,c=.05*-Math.sin(o*Math.PI)*a;break;case"left":l=-o*n*a,d=.2*-o*a,c=.03*-Math.sin(o*Math.PI)*a;break;case"right":l=o*n*a,d=.2*o*a,c=.03*-Math.sin(o*Math.PI)*a;break;case"up":c=o*n*a,u=.15*-o*a;break;case"down":c=-o*n*a,u=.25*o*a}return{cameraRelativePosition:[l,c,h],cameraRelativeRotation:[u,0,d],scale:1+.1*o*a,glowIntensity:1+.3*o,glowBoost:e<.4?.4*o:0}}}}}var zn={name:"spin",emoji:"🌀",type:"override",description:"Orbital rotation around center point",config:{duration:600,musicalDuration:{musical:!0,beats:1},rotations:1,direction:"random",radiusMultiplier:1,spiralOut:!1,accelerate:!0,maintainDistance:!0,scaleAmount:.1,easing:"linear",strength:.7,particleMotion:{type:"spin",strength:.7,rotations:1,radius:1}},rhythm:{enabled:!0,syncMode:"bar",rotationSync:{mode:"bars",rotationsPerBar:1,accelerateOnBeat:!0},radiusSync:{subdivision:"quarter",expandOnBeat:1.2,contractOffBeat:.9,curve:"bounce"},durationSync:{mode:"beats",beats:4},patternOverrides:{waltz:{rotationSync:{rotationsPerBar:.75},radiusSync:{curve:"ease"}},swing:{rotationSync:{accelerateOnBeat:!1},direction:"alternating"},dubstep:{radiusSync:{subdivision:"eighth",expandOnBeat:1.5,dropMultiplier:2},spiralOut:!0},breakbeat:{rotationSync:{mode:"random",range:[.5,2]},direction:"random"}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a;let r=t.direction||this.config.direction;"random"===r&&(r=Math.random()<.5?"clockwise":"counter-clockwise"),e.gestureData.spin={startAngle:Math.atan2(s,n),startRadius:Math.sqrt(n*n+s*s)||30,originalX:e.x,originalY:e.y,originalVx:e.vx,originalVy:e.vy,direction:r,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.spin?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.spin,o={...this.config,...i},l=i.strength||1;let{rotations:c}=o,{radiusMultiplier:h}=o;i.rhythmModulation&&(i.rhythmModulation.rotationMultiplier&&(c*=i.rhythmModulation.rotationMultiplier),i.rhythmModulation.radiusMultiplier&&(h*=i.rhythmModulation.radiusMultiplier));let u=t;o.accelerate&&(u=t<.5?.5*this.easeInQuad(2*t):.5+.5*this.easeOutQuad(2*(t-.5)));const d=c*Math.PI*2*l,m="counter-clockwise"===r.direction?-1:1,p=r.startAngle+d*u*m;let g=r.startRadius;o.spiralOut&&(g*=1+.5*t),1!==h&&(g*=1+(h-1)*Math.sin(t*Math.PI));const f=n+Math.cos(p)*g,y=s+Math.sin(p)*g;if(e.x+=.25*(f-e.x),e.y+=.25*(y-e.y),e.vx=.5*(f-e.x),e.vy=.5*(y-e.y),t>.9){const i=10*(1-t);e.vx=e.vx*i+r.originalVx*(1-i),e.vy=e.vy*i+r.originalVy*(1-i)}},cleanup(e){if(e.gestureData?.spin){const t=e.gestureData.spin;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.spin}},easeInQuad:e=>e*e,easeOutQuad:e=>e*(2-e),"3d":{evaluate(e,t){const i=t?.config||t||{},a=t?.strength||1,n=t?.particle;let s=1;n?.gestureData?.spin?s="counter-clockwise"===n.gestureData.spin.direction?-1:1:"counter-clockwise"!==i.direction&&"left"!==i.direction||(s=-1);let r=e;return!1!==i.accelerate&&(r=e<.5?e*e*4*.5:.5+(e-.5)*(2-(e-.5))*.5),{position:[0,0,0],rotation:[0,(i.rotations||1)*Math.PI*2*a*r*s,0],scale:1+(i.scaleAmount||.1)*Math.sin(e*Math.PI)*a}}}};const Ln={left:"counter-clockwise",right:"clockwise"};function Gn(e){const t=Ln[e];if(!t)throw new Error(`Invalid spin direction: ${e}`);const i="left"===e?-1:1;return{name:`spin${qa(e)}`,emoji:"left"===e?"↺":"↻",type:"override",description:`Spin ${t}`,config:{duration:600,rotations:1,direction:t,radiusMultiplier:1,spiralOut:!1,accelerate:!0,maintainDistance:!0,scaleAmount:.1,strength:.7},rhythm:{enabled:!0,syncMode:"bar",timingSync:"nextBeat",interruptible:!1,priority:7,blendable:!1,durationSync:{mode:"beats",beats:4},rotationSync:{mode:"bars",rotationsPerBar:1,accelerateOnBeat:!0}},initialize(e,i,a,n){e.gestureData||(e.gestureData={});const s=e.x-a,r=e.y-n;e.gestureData.spin={startAngle:Math.atan2(r,s),startRadius:Math.sqrt(s*s+r*r)||30,originalX:e.x,originalY:e.y,originalVx:e.vx,originalVy:e.vy,direction:t,initialized:!0}},apply(e,t,a,n,s,r){e.gestureData?.spin?.initialized||this.initialize(e,a,s,r);const o=e.gestureData.spin,l={...this.config,...a},c=a.strength||1;let{rotations:h,radiusMultiplier:u}=l;a.rhythmModulation&&(a.rhythmModulation.rotationMultiplier&&(h*=a.rhythmModulation.rotationMultiplier),a.rhythmModulation.radiusMultiplier&&(u*=a.rhythmModulation.radiusMultiplier));let d=t;l.accelerate&&(d=t<.5?.5*this.easeInQuad(2*t):.5+.5*this.easeOutQuad(2*(t-.5)));const m=h*Math.PI*2*c,p=o.startAngle+m*d*i;let g=o.startRadius;l.spiralOut&&(g*=1+.5*t),1!==u&&(g*=1+(u-1)*Math.sin(t*Math.PI));const f=s+Math.cos(p)*g,y=r+Math.sin(p)*g;if(e.x+=.25*(f-e.x),e.y+=.25*(y-e.y),e.vx=.5*(f-e.x),e.vy=.5*(y-e.y),t>.9){const i=10*(1-t);e.vx=e.vx*i+o.originalVx*(1-i),e.vy=e.vy*i+o.originalVy*(1-i)}},cleanup(e){if(e.gestureData?.spin){const t=e.gestureData.spin;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.spin}},easeInQuad:e=>e*e,easeOutQuad:e=>e*(2-e),"3d":{evaluate(e,t){const a=t?.config||t||{},n=t?.strength||1;let s=e;return!1!==a.accelerate&&(s=e<.5?e*e*4*.5:.5+(e-.5)*(2-(e-.5))*.5),{position:[0,0,0],rotation:[0,(a.rotations||1)*Math.PI*2*n*s*i,0],scale:1+(a.scaleAmount||.1)*Math.sin(e*Math.PI)*n}}}}}var Vn=Gn("left"),Nn=Gn("right"),jn={name:"flip",emoji:"🤸",type:"override",description:"Front flip rotation with arc trajectory",config:{duration:800,musicalDuration:{musical:!0,beats:2},rotations:1,height:.3,direction:"forward",strength:1,particleMotion:{type:"flip",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.rotations||1,s=i.height||.3,r=(e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2)*(2*-Math.PI*n),o=Math.sin(e*Math.PI)*s*a;let l=1;if(e<.1)l=1-e/.1*.15;else if(e<.2)l=.85+(e-.1)/.1*.2;else if(e>.9){const t=(e-.9)/.1;l=1.05-.1*Math.sin(t*Math.PI)}else l=1.05;return e>=.99&&(l=1),{position:[0,o,0],rotation:[r,0,0],scale:l,glowIntensity:1+.4*Math.sin(e*Math.PI),glowBoost:e>.2&&e<.8?.3:0}}}},qn={name:"backflip",emoji:"⬆️",type:"override",description:"Backwards flip with dramatic arc trajectory",config:{duration:900,musicalDuration:{musical:!0,beats:2},rotations:1,height:.35,strength:1,particleMotion:{type:"backflip",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.rotations||1,s=i.height||.35,r=(e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2)*(2*Math.PI*n),o=Math.sin(e*Math.PI)*s*a,l=.1*Math.sin(e*Math.PI)*a;let c=1;if(e<.1)c=1-e/.1*.15;else if(e<.2)c=.85+(e-.1)/.1*.25;else if(e>.9){const t=(e-.9)/.1;c=1.1-.15*Math.sin(t*Math.PI)}else c=1.1;return e>=.99&&(c=1),{position:[0,o,l],rotation:[r,0,0],scale:c,glowIntensity:1+.5*Math.sin(e*Math.PI),glowBoost:.4*Math.sin(e*Math.PI)}}}},Un={name:"point",emoji:"👉",type:"blending",description:"Directional pointing motion with forward momentum",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},amplitude:15,direction:"right",strength:.8,particleMotion:{type:"point",direction:"right",strength:.8}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.6},patternOverrides:{march:{amplitudeSync:{onBeat:2,offBeat:.5,curve:"pulse"}},swing:{amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"bounce"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.point={startX:e.x,startY:e.y,startVx:e.vx,startVy:e.vy,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.point?.initialized||this.initialize(e,i);const r={...this.config,...i},o=r.strength||this.config.strength||1,l=this.easeInOutCubic(t);let c=r.amplitude*o*e.scaleFactor;i.rhythmModulation&&(c*=i.rhythmModulation.amplitudeMultiplier||1,c*=i.rhythmModulation.accentMultiplier||1);const h=Math.sin(l*Math.PI);let u=0,d=0;switch(r.direction||"right"){case"right":u=1;break;case"left":u=-1;break;case"up":d=-1;break;case"down":d=1}if(e.vx+=h*c*.02*a*u,e.vy+=h*c*.02*a*d,t>.9){const i=1-10*(t-.9);e.vx=e.vx*(.95+.05*i),e.vy=e.vy*(.95+.05*i)}},cleanup(e){e.gestureData?.point&&delete e.gestureData.point},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const i=t||{},a=i.amplitude||15,n=i.strength||.8,s=i.direction||"right",r=.005*a*n,o=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,l=Math.sin(o*Math.PI);let c=0,h=0;switch(s){case"right":c=l*r,h=.25*l;break;case"left":c=-l*r,h=.25*-l;break;case"up":case"down":h=0}return{position:[c,0,0],rotation:[0,h,0],scale:1}}}};function Wn(e){const t=ja[e];if(!t)throw new Error(`Invalid point direction: ${e}`);const i="up"===e||"down"===e;return{name:`point${qa(e)}`,emoji:"up"===e?"☝️":"down"===e?"👇":"left"===e?"👈":"👉",type:"blending",description:`Point ${e} with extension and return`,config:{duration:500,amplitude:15,strength:.8,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"ease"},accentResponse:{enabled:!0,multiplier:1.6}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.point={startX:e.x,startY:e.y,initialized:!0}},apply(e,i,a,n,s,r){e.gestureData?.point?.initialized||this.initialize(e,a);const o={...this.config,...a},l=o.strength||.8,c=this.easeInOutCubic(i);let h=o.amplitude*l*e.scaleFactor;a.rhythmModulation&&(h*=a.rhythmModulation.amplitudeMultiplier||1,h*=a.rhythmModulation.accentMultiplier||1);const u=Math.sin(c*Math.PI);if(e.vx+=u*h*.02*n*t.x,e.vy+=u*h*.02*n*-t.y,i>.9){const t=1-10*(i-.9);e.vx*=.95+.05*t,e.vy*=.95+.05*t}},cleanup(e){e.gestureData?.point&&delete e.gestureData.point},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,a){const n=a||{},s=.005*(n.amplitude||15)*(n.strength||.8),r=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,o=Math.sin(r*Math.PI),l=t.x*o*s,c=t.y*o*s;let h=0,u=0,d=0;return i?h=t.y*o*.2:(u=t.x*o*.25,d=-t.x*o*.1),{cameraRelativePosition:[l,c,0],rotation:[h,u,d],scale:1}}}}}var Hn=Wn("up"),$n=Wn("down"),Yn=Wn("left"),Xn=Wn("right");function Qn(e){if("left"!==e&&"right"!==e)throw new Error(`Invalid kick direction: ${e}. Only 'left' and 'right' are supported.`);const t=ja[e];return{name:`kick${qa(e)}`,emoji:"left"===e?"🦵":"🦶",type:"blending",description:`Quick kick ${e} with snap return`,config:{duration:400,amplitude:30,strength:.8,direction:e},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:5,blendable:!0,durationSync:{mode:"beats",beats:1},amplitudeSync:{onBeat:1.5,offBeat:.7,curve:"snap"},accentResponse:{enabled:!0,multiplier:1.5}},apply(e,i,a,n,s,r){const o={...this.config,...a};let l,c=o.amplitude*o.strength*e.scaleFactor;a.rhythmModulation&&(c*=a.rhythmModulation.amplitudeMultiplier||1,c*=a.rhythmModulation.accentMultiplier||1),l=i<.25?this.easeOutQuad(i/.25):i<.5?1:1-this.easeInQuad((i-.5)/.5);const h=t.x*c*l*.012*n,u=t.y*c*l*.012*n;e.vx+=h,e.vy+=u},cleanup(e){},easeOutQuad:e=>1-(1-e)*(1-e),easeInQuad:e=>e*e,"3d":{evaluate(e,i){const a=i||{},n=a.amplitude||30,s=a.strength||.8;let r,o=.008*n*s;if(i.rhythmModulation&&(o*=i.rhythmModulation.amplitudeMultiplier||1),e<.25)r=1-(1-e/.25)*(1-e/.25);else if(e<.5)r=1;else{const t=(e-.5)/.5;r=1-t*t}const l=.15*r*s;return{cameraRelativePosition:[t.x*o*r,t.y*o*r*.3,0],rotation:[.08*r*s,0,t.x*l],scale:1+.05*r}}}}}var Kn=Qn("left"),Zn=Qn("right"),Jn={name:"bow",emoji:"🙇",type:"override",description:"Graceful forward bow of respect",config:{duration:1200,musicalDuration:{musical:!0,beats:3},depth:.4,holdTime:.4,graceful:!0,strength:1,particleMotion:{type:"bow",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat"},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.depth||.4,s=i.holdTime||.4;let r;const o=.4*(1-s),l=1-.6*(1-s);return e<o?(r=e/o,r=Math.sin(r*Math.PI/2)):e<l?r=1:(r=1-(e-l)/(1-l),r=Math.sin(r*Math.PI/2)),{cameraRelativePosition:[0,.1*-r*a,.05*-r*a],cameraRelativeRotation:[r*n*Math.PI*a,0,0],scale:1,glowIntensity:1-.2*r,glowBoost:0}}}},es={name:"nod",emoji:"🙂",type:"blending",description:"Vertical nodding motion",config:{duration:500,amplitude:15,frequency:2,easing:"sine",strength:.4,particleMotion:{type:"bounce",axis:"vertical",strength:.4,frequency:2,phase:0}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!1,priority:5,blendable:!1,minDuration:"halfBar",frequencySync:{mode:"subdivision",subdivision:"half",multiplier:1},amplitudeSync:{onBeat:1.4,offBeat:.8,curve:"ease"},durationSync:{mode:"beats",beats:2},patternOverrides:{waltz:{frequencySync:{subdivision:"quarter"},amplitudeSync:{onBeat:1.6,curve:"ease"}},swing:{amplitudeSync:{onBeat:1.5,offBeat:.9}},dubstep:{amplitudeSync:{onBeat:1.2,dropBeat:3,curve:"pulse"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.nod={startY:e.y,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.nod?.initialized||this.initialize(e,i);const r={...this.config,...i},o=r.strength||this.config.strength||1;let{frequency:l}=r,{amplitude:c}=r;i.rhythmModulation&&(c*=i.rhythmModulation.amplitudeMultiplier||1,c*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(l*=i.rhythmModulation.frequencyMultiplier));const h=Math.sin(t*Math.PI*2*l);c=c*o*e.scaleFactor,e.vy+=h*c*.01*a,t>.9&&(e.vy*=.95)},cleanup(e){e.gestureData?.nod&&delete e.gestureData.nod},"3d":{evaluate(e,t){const i={...this.config,...t};let{amplitude:a}=i;t.rhythmModulation&&(a*=t.rhythmModulation.amplitudeMultiplier||1,a*=t.rhythmModulation.accentMultiplier||1);let n=0;if(e<.4){const t=e/.4;n=.12*Math.sin(t*Math.PI)}else if(e<.8){const t=(e-.4)/.4;n=.07*Math.sin(t*Math.PI)}return n*=a/15,{cameraRelativePosition:[0,0,n],scale:1-.3*Math.abs(n),glowIntensity:1+.5*Math.abs(n)}}}},ts={name:"reach",emoji:"🙌",type:"blending",description:"Upward reaching motion with scale increase",config:{duration:1400,musicalDuration:{musical:!0,beats:2},amplitude:25,strength:.9,scaleMax:1.05,particleMotion:{type:"reach",strength:.9,scaleMax:1.05}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",interruptible:!0,priority:4,blendable:!0,crossfadePoint:"anyBeat",amplitudeSync:{onBeat:1.4,offBeat:.9,curve:"ease"},durationSync:{mode:"beats",beats:2},accentResponse:{enabled:!0,multiplier:1.5},patternOverrides:{uplifting:{amplitudeSync:{onBeat:1.8,offBeat:.7,curve:"ease"},durationSync:{beats:3}},ambient:{amplitudeSync:{onBeat:1.2,offBeat:1,curve:"linear"}}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.reach={startY:e.y,startVy:e.vy,originalSize:e.size,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.reach?.initialized||this.initialize(e,i);const r={...this.config,...i},o=r.strength||this.config.strength||1,l=r.scaleMax||this.config.scaleMax||1.05,c=this.easeInOutCubic(t);let h=r.amplitude*o*e.scaleFactor;i.rhythmModulation&&(h*=i.rhythmModulation.amplitudeMultiplier||1,h*=i.rhythmModulation.accentMultiplier||1);const u=Math.sin(c*Math.PI);e.vy-=u*h*.015*a;const d=1+u*(l-1);if(e.size=e.baseSize*d,t>.9){const i=1-10*(t-.9);e.vy=e.vy*(.95+.05*i)}},cleanup(e){e.gestureData?.reach&&(e.gestureData.reach.originalSize?e.size=e.gestureData.reach.originalSize:e.size=e.baseSize,delete e.gestureData.reach)},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const i=t||{},a=i.amplitude||25,n=i.strength||.9,s=i.scaleMax||1.05,r=.004*a*n,o=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,l=Math.sin(o*Math.PI);return{position:[0,l*r,0],rotation:[.1*l,0,0],scale:1+l*(s-1)}}}},is={name:"headBob",emoji:"🎧",type:"additive",description:"Rhythmic vertical bobbing to music",config:{duration:600,musicalDuration:{musical:!0,beats:1},amplitude:12,frequency:2,strength:1,damping:.1,easing:"linear",particleMotion:{type:"headBob",strength:1,amplitude:12,frequency:2}},rhythm:{enabled:!0,syncMode:"beat",frequencySync:{subdivision:"eighth",bobsPerBeat:2},amplitudeSync:{onBeat:1.3,offBeat:1,curve:"pulse"},durationSync:{mode:"beats",beats:1}},apply(e,t,i,a,n,s,r){const o=(i.amplitude||this.config.amplitude)*n,l=i.frequency||this.config.frequency,c=1-a*(i.damping||this.config.damping),h=Math.sin(a*Math.PI*2*l)*o*c;e.vy+=.5*h;const u=Math.cos(a*Math.PI*2*l*1.5)*o*.05*c;e.vx+=.2*u},"3d":{evaluate(e,t){const i=t.config||{},a=t.strength||1,n=i.amplitude||12,s=e<.15?e/.15:Math.pow(1-(e-.15)/.85,2),r=n/12*a;return{cameraRelativePosition:[0,0,.08*s*r],position:[0,.015*-s*r,0],scale:1-.05*s,glowIntensity:1+.15*s}}}},as={name:"crouch",emoji:"🦎",type:"override",description:"Compress down into a low crouch position",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},depth:.3,widen:.2,holdTime:.5,strength:1,particleMotion:{type:"crouch",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat"},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.depth||.3,s=i.widen||.2;let r;const o=(1-(i.holdTime||.5))/2,l=1-o;return r=e<o?e/o:e<l?1:1-(e-l)/o,r=Math.sin(r*Math.PI/2),{position:[0,-r*n*a,0],rotation:[.15*r*a,0,0],scale:(1+r*s*a+(1-.25*r*a))/2,glowIntensity:1-.3*r,glowBoost:0}}}},ns={name:"tilt",emoji:"🤔",type:"override",description:"Gather particles then tilt as unified group",config:{duration:500,musicalDuration:{musical:!0,beats:1},gatherPhase:.2,tiltAngle:45,swayAmount:80,liftAmount:60,frequency:3,homeRadius:20,easing:"sine",strength:2.5,particleMotion:{type:"tilt",strength:2.5,frequency:3,swayAmount:80,liftAmount:60},smoothness:.25},rhythm:{enabled:!0,syncMode:"swing",durationSync:{mode:"beats",beats:1},angleSync:{onBeat:45,offBeat:-30,swing:15,subdivision:"triplet",curve:"ease-in-out"},gatherSync:{beatsBefore:.5,releaseAfter:.25,intensity:"dynamic"},swaySync:{verse:60,chorus:100,bridge:80,syncopated:!0},liftSync:{upOnTilt:!0,heightOnAccent:80,normalHeight:40,curve:"bounce"},dynamics:{forte:{tiltAngle:60,swayAmount:120,frequency:4},piano:{tiltAngle:20,swayAmount:40,frequency:2}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a,r=Math.atan2(s,n),o=Math.sqrt(n*n+s*s),l=Math.random(),c=({...this.config,...t}.homeRadius+20*Math.random())*e.scaleFactor;e.gestureData.tilt={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,angle:r,distance:o,homeRadius:c,homeX:i+Math.cos(r)*c,homeY:a+Math.sin(r)*c,role:l,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.tilt?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.tilt,o={...this.config,...i},l=i.strength||1;let c,h;if(t<o.gatherPhase){const i=t/o.gatherPhase,a=this.easeInOutCubic(i);c=r.startX+(r.homeX-r.startX)*a,h=r.startY+(r.homeY-r.startY)*a;const n=.6;e.x+=(c-e.x)*n,e.y+=(h-e.y)*n}else{const i=(t-o.gatherPhase)/(1-o.gatherPhase)*Math.PI*o.frequency,a=Math.sin(i),u=o.tiltAngle*Math.PI/180*l,d=r.angle+a*u,m=Math.abs(a)*o.liftAmount*e.scaleFactor,p=r.homeRadius+m;c=n+Math.cos(d)*p,h=s+Math.sin(d)*p-.3*m;const g=o.smoothness+.1*r.role;e.x+=(c-e.x)*g,e.y+=(h-e.y)*g;const f=-Math.sin(d),y=Math.cos(d);e.vx=f*a*2,e.vy=y*a*2}if(t<o.gatherPhase&&(e.vx=.25*(c-e.x),e.vy=.25*(h-e.y)),t>.9){const i=10*(1-t),a=r.startX+(e.x-r.startX)*i,n=r.startY+(e.y-r.startY)*i;e.x=a,e.y=n,e.vx=e.vx*i+r.originalVx*(1-i),e.vy=e.vy*i+r.originalVy*(1-i)}},cleanup(e){if(e.gestureData?.tilt){const t=e.gestureData.tilt;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.tilt}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,t){const i=t.config||{},a=t.strength||1,n=i.gatherPhase||.2,s=i.frequency||3,r=i.tiltAngle||45;let o=0;if(e>=n){const t=(e-n)/(1-n)*Math.PI*s;o=Math.sin(t)*(r*Math.PI/180*a*.4)}return{position:[0,0,0],rotation:[0,0,o],scale:1}}}};function ss(e){const t=ja[e];if(!t)throw new Error(`Invalid tilt direction: ${e}`);const i="up"===e||"down"===e;return{name:`tilt${qa(e)}`,emoji:"up"===e?"🔭":"down"===e?"😔":"left"===e?"🤔":"🧐",type:"override",description:`Tilt ${e} with curious expression`,config:{duration:500,musicalDuration:{musical:!0,beats:1},gatherPhase:.2,tiltAngle:45,tiltAmount:40,holdPhase:.4,homeRadius:20,easing:"sine",strength:1,direction:e,smoothness:.25,particleMotion:{type:"tilt",strength:1,tiltAmount:40}},rhythm:{enabled:!0,syncMode:"swing",durationSync:{mode:"beats",beats:1},angleSync:{onBeat:45,offBeat:30,subdivision:"triplet",curve:"ease-in-out"},gatherSync:{beatsBefore:.5,releaseAfter:.25,intensity:"dynamic"},dynamics:{forte:{tiltAngle:60,tiltAmount:60},piano:{tiltAngle:25,tiltAmount:25}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a,r=Math.atan2(s,n),o=Math.sqrt(n*n+s*s),l=({...this.config,...t}.homeRadius+20*Math.random())*e.scaleFactor;e.gestureData.tilt={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,angle:r,distance:o,homeRadius:l,homeX:i+Math.cos(r)*l,homeY:a+Math.sin(r)*l,role:Math.random(),initialized:!0}},apply(e,a,n,s,r,o){e.gestureData?.tilt?.initialized||this.initialize(e,n,r,o);const l=e.gestureData.tilt,c={...this.config,...n},h=n.strength||1;let u,d;if(a<c.gatherPhase){const t=a/c.gatherPhase,i=this.easeInOutCubic(t);u=l.startX+(l.homeX-l.startX)*i,d=l.startY+(l.homeY-l.startY)*i;const n=.6;e.x+=(u-e.x)*n,e.y+=(d-e.y)*n}else if(a<c.gatherPhase+c.holdPhase){const n=(a-c.gatherPhase)/c.holdPhase,s=this.easeOutCubic(Math.min(2*n,1)),r=c.tiltAmount*h*e.scaleFactor*s;i?(u=l.homeX,d=l.homeY+t.y*r):(u=l.homeX+t.x*r,d=l.homeY-Math.abs(t.x)*r*.2);const o=c.smoothness+.1*l.role;e.x+=(u-e.x)*o,e.y+=(d-e.y)*o,e.vx=.5*(u-e.x),e.vy=.5*(d-e.y)}else{const t=(a-c.gatherPhase-c.holdPhase)/(1-c.gatherPhase-c.holdPhase),i=this.easeInOutCubic(t);u=e.x+(l.startX-e.x)*i,d=e.y+(l.startY-e.y)*i,e.x=u,e.y=d,e.vx=l.originalVx*i,e.vy=l.originalVy*i}a<c.gatherPhase&&(e.vx=.25*(u-e.x),e.vy=.25*(d-e.y))},cleanup(e){if(e.gestureData?.tilt){const t=e.gestureData.tilt;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.tilt}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutCubic:e=>1-Math.pow(1-e,3),"3d":{evaluate(e,a){const n=a.config||a||{},s=a.strength||1,r=n.gatherPhase||.2,o=n.holdPhase||.4,l=n.tiltAngle||45,c=n.tiltAmount||40;let h=0,u=0,d=0,m=0,p=0;if(e<r);else if(e<r+o){const a=(e-r)/o,n=1-Math.pow(1-Math.min(2*a,1),3),g=l*Math.PI/180*s*.4*n,f=.004*c*s*n;i?(d=t.y*g,u=t.y*f):(p=-t.x*g,h=t.x*f*.5,m=t.x*g*.3)}else{const a=(e-r-o)/(1-r-o),n=a<.5?4*a*a*a:1-Math.pow(-2*a+2,3)/2,g=l*Math.PI/180*s*.4*(1-n),f=.004*c*s*(1-n);i?(d=t.y*g,u=t.y*f):(p=-t.x*g,h=t.x*f*.5,m=t.x*g*.3)}return{cameraRelativePosition:[h,u,0],rotation:[d,m,p],scale:1}}}}}var rs=ss("up"),os=ss("down"),ls=ss("left"),cs=ss("right");function hs(e){if(!["left","right","front","back","up","down"].includes(e))throw new Error(`Invalid oof direction: ${e}`);return{name:`oof${qa(e)}`,emoji:{left:"🤜",right:"🤛",front:"👊",back:"😫",up:"🥊",down:"💥"}[e],type:"override",description:{left:"Punched from left",right:"Punched from right",front:"Gut punch",back:"Kidney shot",up:"Uppercut",down:"Hammer fist"}[e],config:{duration:500,musicalDuration:{musical:!0,beats:1},intensity:1,strength:1,direction:e,particleMotion:{type:"oof",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1;let n,s;if(e<.25){const t=e/.25;n=t*(2-t)}else{const t=(e-.25)/.75;n=1-t*t}s=e<.1?e/.1:e<.4?1:1-(e-.4)/.6;const r=.2*a,o=.35*a;let l=0,c=0,h=0,u=0,d=0;let m=[0,0,.4];switch(i.direction||"front"){case"left":l=-n*r,d=n*o,m=[.4,0,0];break;case"right":l=n*r,d=-n*o,m=[-.4,0,0];break;case"front":h=-n*r,c=.03*-n,u=n*o*.7,m=[0,0,.4];break;case"back":h=n*r,u=-n*o*.6,m=[0,0,-.4];break;case"up":c=n*r,u=-n*o*.4,m=[0,.8,0];break;case"down":c=-n*r,u=n*o*.3,m=[0,-.8,0]}let p=1,g=0;if(e<.15){const t=e/.15;p=1+.6*(1-t),g=.4*(1-t)}return{cameraRelativePosition:[l,c,h],cameraRelativeRotation:[u,0,d],scale:1,glowIntensity:p,glowBoost:g,deformation:{enabled:!0,strength:s*a*2,impactPoint:m,falloffRadius:.5}}}}}}var us={name:"recoil",emoji:"😱",type:"override",description:"Snap backwards in shock or surprise",config:{duration:600,musicalDuration:{musical:!0,beats:1.5},distance:.2,intensity:1,recover:!0,strength:1,particleMotion:{type:"recoil",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.distance||.2,s=i.intensity||1,r=!1!==i.recover;let o;return e<.15?(o=e/.15,o=1-Math.pow(1-o,4)):e<.4?o=1:r?(o=1-(e-.4)/.6,o=Math.pow(o,.5)):o=1,{position:[0,.05*o*a,-o*n*a*s],rotation:[.25*-o*a*s,0,0],scale:1-.1*o*s,glowIntensity:1+(e<.2?3*(.2-e):0),glowBoost:e<.15?.5:0}}}};function ds(e){if(!{...ja,forward:{x:0,y:0,z:-1},back:{x:0,y:0,z:1}}[e])throw new Error(`Invalid recoil direction: ${e}`);return{name:`recoil${qa(e)}`,emoji:{back:"😱",forward:"😵",left:"😰",right:"😰",up:"😲",down:"😨"}[e]||"😱",type:"override",description:`Recoil ${e} in shock`,config:{duration:600,musicalDuration:{musical:!0,beats:1.5},distance:.2,intensity:1,recover:!0,strength:1,direction:e,particleMotion:{type:"recoil",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1.5},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.distance||.2,s=i.intensity||1,r=!1!==i.recover,o=i.direction||"back";let l;e<.15?(l=e/.15,l=1-Math.pow(1-l,4)):e<.4?l=1:r?(l=1-(e-.4)/.6,l=Math.pow(l,.5)):l=1;let c=0,h=0,u=0,d=0,m=0;switch(o){case"back":u=-l*n*a*s,d=.25*-l*a*s,h=.05*l*a;break;case"forward":u=l*n*a*s,d=.25*l*a*s,h=.05*-l*a;break;case"left":c=-l*n*a*s,m=.2*l*a*s;break;case"right":c=l*n*a*s,m=.2*-l*a*s;break;case"up":h=l*n*a*s,d=.1*-l*a*s;break;case"down":h=-l*n*a*s,d=.3*l*a*s}return{cameraRelativePosition:[c,h,u],cameraRelativeRotation:[d,0,m],scale:1-.1*l*s,glowIntensity:1+(e<.2?3*(.2-e):0),glowBoost:e<.15?.5:0}}}}}var ms={name:"knockdown",emoji:"💥",type:"override",description:"Quick knockdown with fast recovery",config:{duration:1500,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"knockdown",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.4}},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1;let a=0,n=0,s=0,r=0,o=1,l=1,c=0;if(e<.15){const t=e/.15,a=1-Math.pow(1-t,2);n=.1*a*i,s=.2*-a*i,l=1+.6*a,c=.5*a}else if(e<.4){const t=(e-.15)/.25,n=t*t;a=.2*-n*i,s=(.6*n-.2)*i,r=.3*n*i,t>.7&&(o=1-(t-.7)/.3*.1),l=1.6-.5*t,c=.5-.4*t}else if(e<.6){const t=(e-.4)/.2;a=-.2*i,s=.4*i,r=.3*i,r+=.02*Math.sin(t*Math.PI*2),o=.9,l=.8}else{const t=(e-.6)/.4,n=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;if(a=(.2*n-.2)*i,s=(.4-.4*n)*i,r=(.3-.3*n)*i,o=.9+.1*n,t>.7){const e=(t-.7)/.3;r+=.03*Math.sin(e*Math.PI*4)*(1-e)}l=.8+.2*n,t>.9&&(c=(t-.9)/.1*.2)}return{position:[0,a,n],rotation:[s,0,r],scale:o,glowIntensity:l,glowBoost:c}}}},ps={name:"knockout",emoji:"💫",type:"override",description:"Theatrical knockout with failed rise attempt, then recovery",config:{duration:4e3,musicalDuration:{musical:!0,bars:2},strength:1,particleMotion:{type:"knockout",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1;let a=0,n=0,s=0,r=0,o=0,l=1,c=1,h=0;if(e<.1){const t=e/.1,a=1-Math.pow(1-t,3);n=.15*a*i,s=.3*-a*i,c=1+.8*a,h=.6*a,o=.1*Math.sin(t*Math.PI*4)*a}else if(e<.25){const t=(e-.1)/.15,n=t*t;a=.25*-n*i,s=(.8*n-.3)*i,o=.4*n*i,t>.8&&(l=1-(t-.8)/.2*.15),c=1.8-.6*t,h=.6-.4*t}else if(e<.35){const t=(e-.25)/.1;a=-.25*i,s=.5*i,o=.4*i,o+=.03*Math.sin(t*Math.PI*6)*(1-t),l=.85,c=1-.3*t}else if(e<.45){const t=(e-.35)/.1,n=1-Math.pow(1-t,2);a=(.15*n-.25)*i,s=(.5-.3*n)*i,o=(.4-.2*n)*i,l=.85+.1*n,c=.7+.4*n}else if(e<.55){const t=(e-.45)/.1,n=t*t;a=(-.1-.15*n)*i,s=(.2+.35*n)*i,o=(.2+.25*n)*i,l=.95-.12*n,t>.7&&(h=(t-.7)/.3*.3),c=1.1-.4*t}else if(e<.75){const t=(e-.55)/.2;a=-.25*i,s=.55*i,o=.45*i,l=.83;const n=.02*Math.sin(t*Math.PI*4)*Math.sin(t*Math.PI);o+=n,c=.6+2*n}else if(e<.9){const t=(e-.75)/.15,n=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;a=(.25*n-.25)*i,s=(.55-.55*n)*i,o=(.45-.45*n)*i,l=.83+.17*n,c=.6+.5*n}else{const t=(e-.9)/.1;a=0,s=0,o=Math.sin(t*Math.PI*6)*(1-t)*.08*i,r=Math.sin(t*Math.PI*8)*(1-t)*.1*i,l=1,c=1+.2*Math.sin(t*Math.PI*3)*(1-t),h=.2*Math.sin(t*Math.PI)}return{position:[0,a,n],rotation:[s,r,o],scale:l,glowIntensity:c,glowBoost:h}}}},gs={name:"inflate",emoji:"🎈",type:"override",description:"Puff up dramatically like a balloon",config:{duration:800,musicalDuration:{musical:!0,beats:2},maxScale:1.4,holdTime:.3,deflate:!0,strength:1,particleMotion:{type:"inflate",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",strengthSync:{onBeat:1.3,offBeat:.8}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.maxScale||1.4,s=i.holdTime||.3,r=!1!==i.deflate;let o;const l=.5*(1-s),c=1-l;e<l?(o=e/l,o=1-Math.pow(1-o,2)):e<c||!r?o=1:(o=1-(e-c)/l,o=Math.pow(o,2));const h=1+(n-1)*o*a,u=.08*o*a,d=1+.4*o*a,m=.3*o,p=o>.8?.02*Math.sin(e*Math.PI*8):0;return{position:[p,u,0],rotation:[0,0,2*p],scale:h,glowIntensity:d,glowBoost:m}}}},fs={name:"deflate",emoji:"💨",type:"override",description:"Shrink down sadly like a deflating balloon",config:{duration:1e3,musicalDuration:{musical:!0,beats:2.5},minScale:.6,droop:.15,reinflate:!0,strength:1,particleMotion:{type:"deflate",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2.5},timingSync:"onBeat"},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.minScale||.6,s=i.droop||.15,r=!1!==i.reinflate;let o;return e<.5?(o=e/.5,o=Math.pow(o,.7)):e<.7||!r?o=1:(o=1-(e-.7)/.3,o=Math.pow(o,1.5)),{position:[0,-o*s*a,0],rotation:[.15*o*a,0,.1*o*a],scale:1-(1-n)*o*a,glowIntensity:1-.4*o,glowBoost:0}}}},ys={name:"squash",emoji:"🫓",type:"override",description:"Flatten horizontally like a cartoon impact",config:{duration:500,musicalDuration:{musical:!0,beats:1},squashAmount:.5,stretchAmount:1.5,bounce:!0,strength:1,particleMotion:{type:"squash",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.squashAmount||.5,s=i.stretchAmount||1.5,r=!1!==i.bounce;let o;if(e<.15)o=e/.15,o=1-Math.pow(1-o,3);else if(r){const t=(e-.15)/.85,i=Math.exp(4*-t);o=Math.cos(t*Math.PI*3)*i,o=Math.max(0,o)}else o=0;const l=1+o*(s-1)*a;return{position:[0,.15*-o*a,0],rotation:[0,0,0],scale:[l,1-o*(1-n)*a,l],glowIntensity:1+(e<.2?3*(.2-e):0),glowBoost:e<.15?.6:0}}}},vs={name:"stretch",emoji:"↔️",type:"override",description:"Scale particles along X and Y axes",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},scaleX:1.3,scaleY:.9,alternate:!1,elastic:!0,overshoot:.1,frequency:1,easing:"sine",strength:1,particleMotion:{type:"stretch",scaleX:1.8,scaleY:.6,strength:1},centerBased:!0,preserveArea:!1},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},scaleSync:{onBeat:{x:1.5,y:.7},offBeat:{x:.8,y:1.3},subdivision:"eighth",curve:"elastic"},alternateSync:{pattern:"XYXY",beatsPerChange:1,overlap:.1},overshootSync:{normal:.1,accent:.3,downbeat:.2,curve:"spring"},preservationSync:{verse:!0,chorus:!1,bridge:!0},dynamics:{forte:{scaleX:2,scaleY:.5,overshoot:.4},piano:{scaleX:1.1,scaleY:.95,overshoot:.05}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a;e.gestureData.stretch={offsetX:n,offsetY:s,startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.stretch?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.stretch,o={...this.config,...i},l=i.strength||1;let c,h,{scaleX:u}=o,{scaleY:d}=o;if(o.preserveArea&&1!==u&&1!==d){const e=u*d,t=Math.sqrt(1/e);u*=t,d*=t}if(o.alternate)if(t<.5){const e=2*t;u=1+(u-1)*this.getElasticProgress(e,o),d=1+(1/u-1)*(o.preserveArea?1:0)}else{const e=2*(t-.5);u+=(1-u)*this.getElasticProgress(e,o),d=1+(d-1)*this.getElasticProgress(e,o)}else{const e=this.getElasticProgress(t,o);u=1+(u-1)*e*l,d=1+(d-1)*e*l}if(o.centerBased?(c=n+r.offsetX*u,h=s+r.offsetY*d):(c=r.startX*u,h=r.startY*d),e.x=c,e.y=h,e.vx=r.offsetX*(u-1)*l*.1,e.vy=r.offsetY*(d-1)*l*.1,t>.9){const i=10*(1-t);e.vx=e.vx*i+r.originalVx*(1-i),e.vy=e.vy*i+r.originalVy*(1-i)}},getElasticProgress(e,t){if(!t.elastic)return this.easeInOutCubic(e);if(0===e)return 0;if(1===e)return 1;const i=t.overshoot||.1;if(e<.5){const t=2*e;return.5*this.easeInElastic(t,i)}{const t=2*(e-.5);return.5+.5*this.easeOutElastic(t,i)}},cleanup(e){if(e.gestureData?.stretch){const t=e.gestureData.stretch;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.stretch}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeInElastic:(e,t)=>0===e?0:1===e?1:-Math.pow(2,10*(e-1))*Math.sin((e-1-.075)*(2*Math.PI)/.3)*(1+t),easeOutElastic:(e,t)=>0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((e-.075)*(2*Math.PI)/.3)*(1+t)+1,"3d":{evaluate(e,t){const{particle:i}=t;if(!i||!i.gestureData?.stretch)return{position:[0,0,0],rotation:[0,0,0],scale:1};const a=t.config||{},n=t.strength||1;let s,r=a.scaleX||1.3,o=a.scaleY||.9;if(a.preserveArea&&1!==r&&1!==o){const e=r*o,t=Math.sqrt(1/e);r*=t,o*=t}if(a.elastic){const t=a.overshoot||.1;if(e<.5){const i=2*e,a=.3,n=a/4;s=-Math.pow(2,10*(i-1))*Math.sin((i-1-n)*(2*Math.PI)/a)*(1+t)*.5}else{const i=2*(e-.5),a=.3,n=a/4;s=.5+.5*(Math.pow(2,-10*i)*Math.sin((i-n)*(2*Math.PI)/a)*(1+t)+1)}}else s=e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2;let l,c=1;if(e>.8){const t=(e-.8)/(1-.8);c=1-t*t*t}l=a.alternate?e<.5?2*e*.8:.8-2*(e-.5)*1.4:1*s*n;const h=1+l*c;return{position:[0,0,0],rotation:[0,0,.1*Math.sin(e*Math.PI*4)*s*c],scale:h}}}},bs={name:"pancake",emoji:"🥞",type:"override",description:"Extreme flatten and hold - cartoon pancake effect",config:{duration:1600,musicalDuration:{musical:!0,bars:1},squashAmount:.2,stretchAmount:2,holdRatio:.5,strength:1,particleMotion:{type:"pancake",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.squashAmount||.2,s=i.stretchAmount||2,r=.1+.6*(i.holdRatio||.5);let o=0,l=0;if(e<.1){const t=e/.1;o=1-Math.pow(1-t,2)}else if(e<r){o=1;const t=(e-.1)/(r-.1);l=Math.sin(t*Math.PI*4)*(1-t)*.02}else{const t=(e-r)/(1-r);if(o=1-(t<.3?t/.3*.3:.3+(t-.3)/.7*.7),t>.8){const e=(t-.8)/.2,i=.15*Math.sin(e*Math.PI);o=Math.max(0,o-i)}}const c=1+o*(s-1)*a;let h=1,u=0;return e<.15?(h=1+.8*(1-e/.15),u=.6*(1-e/.15)):e<r?(h=1.3,u=.2):h=1.3-(e-r)/(1-r)*.3,{position:[l*a,.2*-o*a,0],rotation:[0,0,2*l*a],scale:[c,1-o*(1-n)*a,c],glowIntensity:h,glowBoost:u}}}},ws={name:"rage",emoji:"💢",type:"override",description:"Barbarian rage - intense buildup and release",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"rage",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.6}},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1;let a=0,n=0,s=0,r=0,o=1,l=1,c=0;if(e<.2){const t=e/.2,o=t*t;n=.05*-o*i,s=.15*o*i;const c=Math.sin(80*e)*o*.02;r=c*i,a=.02*c*i,l=1+.3*o}else if(e<.6){const t=(e-.2)/.4,h=t*t;n=(-.05-.03*h)*i,s=(.15+.1*h)*i;const u=.02+.04*h,d=100+50*t,m=Math.sin(e*d)*u;r=m*i,a=.03*m*i,o=1+.1*h,l=1.3+.7*h,c=.5*h}else if(e<.8){const t=(e-.6)/.2;n=(.15*t-.08)*i,s=(.25-.4*t)*i,r=Math.sin(150*e)*(1-.5*t)*.05*i,o=1.1+.08*Math.sin(t*Math.PI),l=2-.3*t,c=.5+.3*Math.sin(t*Math.PI)}else{const t=(e-.8)/.2,a=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;n=(.07-.07*a)*i,s=(.15*a-.15)*i,r=Math.sin(50*e)*(1-a)*.02*i,o=1.1-.1*a,l=1.7-.7*a,c=.5*(1-a)}return{position:[a,n,0],rotation:[s,0,r],scale:o,glowIntensity:l,glowBoost:c}}}},Ms={name:"fury",emoji:"😤",type:"override",description:"Quick fury burst - intense flash of anger",config:{duration:800,musicalDuration:{musical:!0,beats:2},strength:1,particleMotion:{type:"fury",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1;let a=0,n=0,s=0,r=1,o=1,l=0;if(e<.2){const t=e/.2,n=1-Math.pow(1-t,3);r=1+.15*n*i;const c=Math.sin(120*e)*n*.04;s=c*i,a=.02*c*i,o=1+1.2*n,l=.7*n}else if(e<.5){const t=(e-.2)/.3;r=1.15+.03*Math.sin(t*Math.PI*3);const c=.05*Math.sin(150*e)*(1-.3*t);s=c*i,a=.025*c*i,n=.1*Math.sin(t*Math.PI)*i,o=2.2-.3*t,l=.7-.2*t}else{const t=(e-.5)/.5,a=t*t;r=1.15-.15*a,s=Math.sin(80*e)*(1-a)*.03*i,n=.1*(1-a)*i,o=1.9-.9*a,l=.5*(1-a)}return{position:[a,0,0],rotation:[n,0,s],scale:r,glowIntensity:o,glowBoost:l}}}},Ss={name:"battlecry",emoji:"📣",type:"override",description:"Warrior battlecry - inhale, expand, roar",config:{duration:1500,musicalDuration:{musical:!0,bars:1},strength:1,particleMotion:{type:"battlecry",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1;let a=0,n=0,s=0,r=0,o=1,l=1,c=0;if(e<.25){const t=e/.25,r=t*t;n=.08*r*i,s=.15*-r*i,a=.03*-r*i,o=1+.05*r,l=1+.4*r}else if(e<.4){const t=(e-.25)/.15;n=(.08+.02*t)*i,s=(-.15-.1*t)*i,a=(.05*t-.03)*i,o=1.05+.08*t,l=1.4+.5*t,c=.4*t}else if(e<.6){const t=(e-.4)/.2,h=1-Math.pow(1-t,3);n=(.1-.2*h)*i,s=(.4*h-.25)*i,a=(.02+.08*h)*i,o=1.13+.12*h,l=1.9+.6*h,c=.4+.4*h,r=Math.sin(t*Math.PI*20)*(1-t)*.02*i}else{const t=(e-.6)/.4,h=t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;n=-.1*(1-h)*i,s=.15*(1-h)*i,a=.1*(1-h)*i,o=1.25-.25*h,r=Math.sin(t*Math.PI*8)*(1-h)*.015*i,l=2.5-1.5*h,c=.8-.8*h}return{position:[0,a,n],rotation:[s,0,r],scale:o,glowIntensity:l,glowBoost:c}}}},xs={name:"charge",emoji:"🐂",type:"override",description:"Bull charge - wind up and rush forward",config:{duration:1200,musicalDuration:{musical:!0,beats:3},strength:1,particleMotion:{type:"charge",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1;let a=0,n=0,s=0,r=0,o=0,l=1,c=1,h=0;if(e<.2){const t=e/.2,a=t*t;n=.08*-a*i,s=.1*a*i,r=.25*a*i,l=1-.05*a,c=1+.4*a}else if(e<.6){const t=(e-.2)/.4,a=1-Math.pow(1-t,2);s=(.1-.35*a)*i,r=(.25+.1*a)*i,n=(.06*a-.08)*i,l=.95+.15*a,c=1.4+.6*a,h=.4*a,o=Math.sin(t*Math.PI*10)*a*.02*i}else if(e<.85){const t=(e-.6)/.25;s=-.25*i,r=(.35-.1*t)*i;const n=Math.sin(t*Math.PI*15)*(1-t)*.04;o=n*i,a=.02*n*i,l=1.1+.05*Math.sin(t*Math.PI),c=2-.3*t,h=.4*(1-.5*t)}else{const t=(e-.85)/.15,a=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;s=-.25*(1-a)*i,r=.25*(1-a)*i,n=-.02*(1-a)*i,l=1.1-.1*a,c=1.7-.7*a,h=.2*(1-a)}return{cameraRelativePosition:[a,n,s],rotation:[r,0,o],scale:l,glowIntensity:c,glowBoost:h}}}},Cs={name:"wobble",emoji:"🥴",type:"override",description:"Unsteady circular wobbling motion",config:{duration:1500,musicalDuration:{musical:!0,beats:4},wobbleRadius:.08,wobbleAngle:.2,rotations:2,decay:.5,strength:1,particleMotion:{type:"wobble",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:4},timingSync:"onBeat"},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.wobbleRadius||.08,s=i.wobbleAngle||.2,r=i.rotations||2,o=i.decay||.5,l=e*r*Math.PI*2,c=1-o*e,h=Math.sin(l)*n*c*a,u=Math.cos(l)*n*c*a,d=Math.cos(l)*s*c*a,m=Math.sin(l)*s*c*a;return{position:[h,.02*Math.sin(2*l)*c*a,u],rotation:[d,0,m],scale:1+.05*Math.sin(2*l)*c,glowIntensity:1+.2*Math.sin(l)*c,glowBoost:0}}}},Ps={name:"teeter",emoji:"⚖️",type:"override",description:"Rock back and forth unstably like losing balance",config:{duration:1200,musicalDuration:{musical:!0,beats:3},tiltAngle:.25,frequency:3,irregularity:.3,strength:1,particleMotion:{type:"teeter",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat"},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.tiltAngle||.25,s=i.frequency||3,r=i.irregularity||.3,o=(Math.sin(e*s*Math.PI*2)+Math.sin(e*(s+1.7)*Math.PI*2)*r+Math.sin(e*(.5*s)*Math.PI*2)*r*.5)/(1+1.5*r),l=o*n*a*.7,c=Math.sin(e*s*Math.PI*2+.5)*n*a*.5;return{position:[.15*c,0,.1*l],rotation:[l,0,c],scale:1+.05*Math.abs(o),glowIntensity:1+.2*Math.abs(o),glowBoost:0}}}},ks={name:"rock",emoji:"🪨",type:"override",description:"Gentle front-back rocking motion",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},rockAngle:.15,rockCycles:2,smooth:!0,strength:1,particleMotion:{type:"rock",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat"},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.rockAngle||.15,s=e*(i.rockCycles||2)*Math.PI*2,r=Math.sin(s),o=r*n*a,l=.05*r*a;return{position:[0,.02*Math.abs(r)*a,l],rotation:[o,0,0],scale:1+.02*Math.sin(.5*s),glowIntensity:1+.1*r,glowBoost:0}}}},Ds={name:"pendulum",emoji:"🕰️",type:"override",description:"Swing side to side like a pendulum clock",config:{duration:1500,musicalDuration:{musical:!0,beats:4},swingAngle:.4,swings:2,damping:.3,strength:1,particleMotion:{type:"pendulum",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:4},timingSync:"onBeat"},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.swingAngle||.4,s=i.swings||2,r=i.damping||.3,o=e*s*Math.PI*2,l=1-r*e,c=Math.sin(o)*l,h=c*n*a;return{position:[.1*c*a,.03*-Math.abs(c)*a,0],rotation:[0,0,h],scale:1,glowIntensity:1+.15*Math.abs(c),glowBoost:0}}}};function As(e){const t={front:{screenOffset:[0,0],screenDirection:[0,0],recoilDir:[0,0,-1]},back:{screenOffset:[0,0],screenDirection:[0,0],recoilDir:[0,0,1]},left:{screenOffset:[-.1,0],screenDirection:[1,0],recoilDir:[1,0,0]},right:{screenOffset:[.1,0],screenDirection:[-1,0],recoilDir:[-1,0,0]},up:{screenOffset:[0,.1],screenDirection:[0,-1],recoilDir:[0,-1,0]},down:{screenOffset:[0,-.1],screenDirection:[0,1],recoilDir:[0,1,0]}},i=t[e]||t.front;return{name:`crack${e.charAt(0).toUpperCase()+e.slice(1)}`,emoji:"💔",type:"override",category:"reactions",description:`Surface cracks spreading from ${e} impact`,config:{duration:2e3,strength:1,glowStrength:.3,holdTime:500},rhythm:{enabled:!0,syncMode:"accent",strengthSync:{onBeat:1.2,offBeat:.8}},"3d":{evaluate(e,t){const a={strength:1,glowStrength:.3,...t},{strength:n,glowStrength:s}=a,r=.03*Math.max(0,1-4*e)*n,{recoilDir:o}=i,l=e<.05;return{cameraRelativePosition:[o[0]*r,o[1]*r,o[2]*r],crack:{enabled:!0,trigger:l,amount:n,propagation:.8,screenOffset:i.screenOffset,screenDirection:i.screenDirection,glowStrength:s}}}}}}const _s=As("front"),Ts=As("back"),Is=As("left"),Os=As("right"),Rs=As("up"),Es=As("down"),Bs={name:"crackHeal",emoji:"✨",type:"override",category:"reactions",description:"Heal and fade existing cracks",config:{duration:1500,glowStrength:.5},"3d":{evaluate(e,t){const i={duration:1500,...t},a=e<.05;return{cameraRelativePosition:[0,.02*Math.sin(e*Math.PI),0],crack:{enabled:!1,heal:!0,healTrigger:a,healDuration:i.duration},glowBoost:.1*Math.sin(e*Math.PI)}}}};var Fs={name:"shatter",emoji:"💥",type:"override",description:"Particles explode outward then freeze like shattered glass",config:{duration:1500,musicalDuration:{musical:!0,bars:1},explosionPhase:.3,freezePhase:.7,distance:100,tumble:1,strength:1,particleMotion:{type:"shatter",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=Math.random()*Math.PI*2,s=.5+.5*Math.random();e.gestureData.shatter={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??1,velocityX:Math.cos(n)*s,velocityY:Math.sin(n)*s,tumbleAngle:0,tumbleSpeed:4*(Math.random()-.5),frozenX:null,frozenY:null,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.shatter?.initialized||this.initialize(e,i,n,s);const r={...this.config,...i},o=r.strength||1,l=r.distance||100,c=e.gestureData.shatter,h=r.explosionPhase||.3,u=r.freezePhase||.7;if(t<h){const i=t/h,a=1-Math.pow(1-i,3),n=c.velocityX*l*a*o,s=c.velocityY*l*a*o;e.x=c.originalX+n,e.y=c.originalY+s,c.tumbleAngle+=c.tumbleSpeed*(1-i)}else if(t<u){const i=(t-h)/(u-h),a=c.originalX+c.velocityX*l*o,n=c.originalY+c.velocityY*l*o,s=c.velocityX*l*.2*i*o,r=c.velocityY*l*.2*i*o;e.x=a+s,e.y=n+r,c.tumbleAngle+=.3*c.tumbleSpeed*(1-i),i>.95&&null===c.frozenX&&(c.frozenX=e.x,c.frozenY=e.y)}else if(null!==c.frozenX&&(e.x=c.frozenX,e.y=c.frozenY),t>.9){const i=(t-.9)/.1;e.opacity=c.originalOpacity*(1-.5*i)}},cleanup(e){if(e.gestureData?.shatter){const t=e.gestureData.shatter;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.shatter}},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1;let a=1,n=1,s=1,r=0,o=0,l=0,c=0,h=0,u=0,d=1,m=0;if(e<.1){const t=e/.1,r=1-Math.pow(1-t,2);n=1-.4*r*i,a=1+.2*r*i,s=1+.2*r*i,h=.1*-r*i,d=1+1*r,m=.8*r}else if(e<.4){const t=(e-.1)/.3,p=1-.6*t,g=40,f=Math.sin(e*g*Math.PI)*p,y=Math.cos(e*g*1.3*Math.PI)*p,v=Math.sin(e*g*.7*Math.PI)*p,b=1+.3*(1-Math.pow(1-t,2))*i;a=b+.15*f*i,n=b+.15*y*i,s=b+.15*v*i,r=.4*f*i,o=.5*y*i,l=.3*v*i,c=.15*f*i,h=.12*y*i+.1*t,u=.1*v*i,d=1.5+.5*Math.abs(f),m=.5*p}else if(e<.7){const t=(e-.4)/.3,r=t*t,o=1-r,c=20*o,u=Math.sin(e*c*Math.PI)*o,p=1.3-.4*r;a=p+.05*u*i,n=p+.05*u*i,s=p+.05*u*i,l=.15*u*i,h=.1*o,d=1.5-.3*r,m=.3*o}else{const t=(e-.7)/.3,i=t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2,r=Math.sin(t*Math.PI*2)*(1-t)*.05;if(a=.9+.1*i+r,n=.9+.1*i+r,s=.9+.1*i+r,d=1.2-.2*i,e>.95){const t=(e-.95)/.05;m=.3*Math.sin(t*Math.PI)}}return{position:[c,h,u],rotation:[r,o,l],scale:[a,n,s],glowIntensity:d,glowBoost:m}}}};const zs={default:{name:"shatter",emoji:"💥",description:"Dramatic shattering effect",duration:2500,beats:4,intensity:1,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!1,revealSoul:!1},explosive:{name:"shatterExplosive",emoji:"🔥",description:"Explosive outward shatter",duration:2e3,beats:3,intensity:1.5,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0},crumble:{name:"shatterCrumble",emoji:"🪨",description:"Slow crumbling collapse",duration:8e3,beats:16,intensity:.15,impactPoint:[0,-.4,0],impactDirection:[0,-1,0],reassemble:!1,revealSoul:!0,gravity:-.8,explosionForce:.1,rotationForce:.5,shatterTriggerAt:0},reform:{name:"shatterReform",emoji:"✨",description:"Shatter then magically reassemble",duration:4e3,beats:8,intensity:1,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!0,reassembleAt:.5,reassembleDuration:1500,revealSoul:!0},punchLeft:{name:"shatterPunchLeft",emoji:"👊",description:"Shatter from left impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[-.4,0,0],impactDirection:[1,0,0],reassemble:!1,useDeformation:!0,direction:"left",revealSoul:!1},punchRight:{name:"shatterPunchRight",emoji:"👊",description:"Shatter from right impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[.4,0,0],impactDirection:[-1,0,0],reassemble:!1,useDeformation:!0,direction:"right",revealSoul:!1},punchFront:{name:"shatterPunchFront",emoji:"👊",description:"Shatter from front impact with deformation",duration:1500,beats:2,intensity:1.2,impactPoint:[0,0,.4],impactDirection:[0,0,-1],reassemble:!1,useDeformation:!0,direction:"front",revealSoul:!1},suspend:{name:"shatterSuspend",emoji:"🌌",description:"Shatter, freeze mid-air, then reassemble",duration:4e3,beats:8,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!0,reassembleAt:.7,reassembleDuration:1200,revealSoul:!0,isSuspendMode:!0,suspendAt:.12,suspendDuration:.2,gravity:-2,explosionForce:1.2},freeze:{name:"shatterFreeze",emoji:"❄️",description:"Shatter and freeze mid-air (call triggerReassembly to reform)",duration:2e3,beats:4,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0,isFreezeMode:!0,isSuspendMode:!0,suspendAt:.12,suspendDuration:.2,gravity:-2,explosionForce:1.2},implode:{name:"shatterImplode",emoji:"🌀",description:"Shards implode inward to center (or implode existing frozen shards)",duration:2500,beats:4,intensity:.8,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!1,revealSoul:!0,isDualMode:!0,dualModeType:"implode",dualModeDuration:1800,gravity:-3,explosionForce:1.2},gravity:{name:"shatterGravity",emoji:"⬇️",description:"Shards fall with gravity and bounce on floor (or drop frozen shards)",duration:4e3,beats:8,intensity:.6,impactPoint:[0,0,0],impactDirection:[0,-1,0],reassemble:!1,revealSoul:!0,isDualMode:!0,dualModeType:"gravity",dualModeDuration:3e3,floorY:-.35,gravity:-2,explosionForce:.4},orbit:{name:"shatterOrbit",emoji:"🪐",description:"Shards orbit around the soul then reassemble",duration:5e3,beats:10,intensity:.6,impactPoint:[0,0,0],impactDirection:[0,1,0],reassemble:!0,reassembleAt:.75,reassembleDuration:1200,revealSoul:!0,isDualMode:!0,dualModeType:"orbit",dualModeDuration:3500,orbitSpeed:1.5,radiusMultiplier:1.2,gravity:-3,explosionForce:1}};function Ls(e="default"){const t=zs[e]||zs.default;return{name:t.name,emoji:t.emoji,type:"override",description:t.description,config:{duration:t.duration,musicalDuration:{musical:!0,beats:t.beats},intensity:t.intensity,variant:e},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:t.beats},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.intensity||1,n=i.variant||"default",s=zs[n]||zs.default,r=s.useDeformation||!1,o=s.direction||"front";let l=!1,c=!1,h=1,u=0,d=1,m=null,p=null,g=null;const f=s.reassemble,y=s.reassembleAt||.5;if(r){let t;if(e<.3){const i=e/.3;t=i*(2-i)}else t=0;let i=0;e<.25?i=e/.25:e<.3&&(i=1);const n=.15*a,r=.25*a;let c=0,d=0;const f=0;let y=0,v=0;switch(o){case"left":c=t*n,v=-t*r;break;case"right":c=-t*n,v=t*r;break;case"front":d=-t*n,y=t*r*.7}if(t>0&&(p=[c,f,d],g=[y,0,v]),i>0&&(m={enabled:!0,strength:i*a*2.5,impactPoint:s.impactPoint,falloffRadius:.5}),e>=.28&&e<.32&&(l=!0),e<.35){const t=e/.35;h=1+.8*(1-t),u=.5*(1-t)}}else{const t=void 0!==s.shatterTriggerAt?s.shatterTriggerAt:.1,i=t+.02;if(e<t){if(t>0){const i=e/t,a=i*i;h=1+.6*a,u=.3*a,d=1+.05*a,"explosive"===n&&(d+=.01*Math.sin(200*e)*i)}}else if(e<i)l=e>=t&&e<t+.005,h=1.6,u=.4,d=1.05;else{if(f&&e>=y&&e<y+.02&&(c=!0),f&&e>=y){const t=(e-y)/(1-y),i=t*t;h=1+.8*i,u=.5*i,e>.95&&(h=2,u=.8)}else{const t=(e-i)/(f?y-i:1-i),a=Math.min(1,t),n=1-(1-a)*(1-a);h=1.6-.6*n,u=.4-.4*n}d=1}}const v={scale:d,glowIntensity:h,glowBoost:u,shatter:{enabled:l,impactPoint:s.impactPoint,impactDirection:s.impactDirection||[0,0,-1],intensity:a*s.intensity,variant:n,reassemble:c,reassembleDuration:s.reassembleDuration||1e3,revealSoul:!1!==s.revealSoul,isSuspendMode:s.isSuspendMode||!1,suspendAt:s.suspendAt||.25,suspendDuration:s.suspendDuration||.35,isFreezeMode:s.isFreezeMode||!1,gravity:s.gravity,explosionForce:s.explosionForce,rotationForce:s.rotationForce,gestureDuration:s.duration,isDualMode:s.isDualMode||!1,dualModeType:s.dualModeType,dualModeConfig:{duration:s.dualModeDuration||2e3,impactPoint:s.impactPoint,windDirection:s.windDirection,windForce:s.windForce,turbulence:s.turbulence,waveSpeed:s.waveSpeed,floorY:s.floorY,orbitSpeed:s.orbitSpeed,radiusMultiplier:s.radiusMultiplier,reassemble:s.reassemble,reassembleDuration:s.reassembleDuration}}};return m&&(v.deformation=m),p&&(v.cameraRelativePosition=p),g&&(v.cameraRelativeRotation=g),v}}}}const Gs={up:{name:"dissolveUp",emoji:"🌬️",description:"Shards blow upward like rising dust",windDirection:[0,1,.1],windForce:2.5,turbulence:.6},down:{name:"dissolveDown",emoji:"💨",description:"Shards blow downward like falling ash",windDirection:[0,-1,.1],windForce:1.8,turbulence:.4},left:{name:"dissolveLeft",emoji:"⬅️",description:"Shards blow left in the wind",windDirection:[-1,.15,0],impactDir:[1,.15,0],windForce:2.2,turbulence:.5},right:{name:"dissolveRight",emoji:"➡️",description:"Shards blow right in the wind",windDirection:[1,.15,0],impactDir:[-1,.15,0],windForce:2.2,turbulence:.5},away:{name:"dissolveAway",emoji:"🌫️",description:"Shards blow away from camera into distance",windDirection:[0,.1,-1],windForce:2,turbulence:.4},toward:{name:"dissolveToward",emoji:"🌪️",description:"Shards blow toward camera",windDirection:[0,.1,1],windForce:2.5,turbulence:.6}};function Vs(e="away"){const t=Gs[e]||Gs.away;return{name:t.name,emoji:t.emoji,type:"override",description:t.description,config:{duration:3500,musicalDuration:{musical:!0,beats:6},intensity:.7,direction:e},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:6},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.2}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.intensity||.7,n=i.direction||"away",s=Gs[n]||Gs.away;let r=!1,o=1,l=0,c=1;const h=.06;if(e<h){const t=e/h;o=1+.4*t,l=.2*t,c=1+.03*t}else if(e<.08)r=e>=h&&e<.065,o=1.4,l=.3;else{const t=(e-h)/.94;o=1.4-.6*t,l=Math.max(0,.3-.3*t)}return{scale:c,glowIntensity:o,glowBoost:l,shatter:{enabled:r,impactPoint:[0,0,0],impactDirection:s.impactDir||s.windDirection,intensity:.5*a,variant:`dissolve_${n}`,revealSoul:!0,isSuspendMode:!1,isFreezeMode:!1,gravity:-.5,explosionForce:.3,gestureDuration:3500,isDualMode:!0,dualModeType:"dissolve",dualModeConfig:{duration:3e3,windDirection:s.windDirection,windForce:s.windForce*a,turbulence:s.turbulence}}}}}}}const Ns={splash:{name:"splash",emoji:"💦",description:"Transform to water and splash outward",duration:2e3,beats:4,intensity:1.2,elemental:"water",elementalParam:.3,impactPoint:[0,-.2,0],impactDirection:[0,1,.3],revealSoul:!0,gravity:-4,explosionForce:1.8,rotationForce:2},drip:{name:"drip",emoji:"🫠",description:"Melt downward like wax",duration:4e3,beats:8,intensity:.4,elemental:"water",elementalParam:.7,impactPoint:[0,.3,0],impactDirection:[0,-1,0],revealSoul:!0,gravity:-1.5,explosionForce:.1,rotationForce:.3,shatterTriggerAt:0},ripple:{name:"ripple",emoji:"🌊",description:"Wobble and dissolve like disturbed water",duration:3e3,beats:6,intensity:.8,elemental:"water",elementalParam:.2,impactPoint:[0,0,0],impactDirection:[1,0,0],revealSoul:!1,gravity:-2,explosionForce:.6,rotationForce:1,useWobble:!0},smokebomb:{name:"smokebomb",emoji:"💨",description:"Poof into dispersing smoke cloud",duration:2500,beats:4,intensity:1,elemental:"smoke",elementalParam:.5,impactPoint:[0,0,0],impactDirection:[0,1,0],revealSoul:!1,gravity:.5,explosionForce:1.5,rotationForce:3},vanish:{name:"vanish",emoji:"👻",description:"Fade into wispy nothing",duration:3e3,beats:6,intensity:.5,elemental:"smoke",elementalParam:.1,impactPoint:[0,0,0],impactDirection:[0,1,0],revealSoul:!1,gravity:.8,explosionForce:.3,rotationForce:1,fadeOut:!0},materialize:{name:"materialize",emoji:"✨",description:"Condense from smoke (reverse smokebomb)",duration:2500,beats:4,intensity:1,elemental:"smoke",elementalParam:.8,impactPoint:[0,0,0],impactDirection:[0,-1,0],revealSoul:!0,reassemble:!0,reassembleAt:.4,reassembleDuration:1500,isDualMode:!0,dualModeType:"implode",dualModeDuration:1e3,gravity:-1,explosionForce:.8},ignite:{name:"ignite",emoji:"🔥",description:"Catch fire and burn away",duration:3e3,beats:6,intensity:1.2,elemental:"fire",elementalParam:.6,overlay:"smoke",overlayParam:.3,impactPoint:[0,-.3,0],impactDirection:[0,1,0],revealSoul:!0,gravity:1,explosionForce:1,rotationForce:4},ember:{name:"ember",emoji:"🪨",description:"Smolder and crumble (low temperature)",duration:6e3,beats:12,intensity:.3,elemental:"fire",elementalParam:.15,impactPoint:[0,0,0],impactDirection:[0,-1,0],revealSoul:!0,gravity:-.5,explosionForce:.1,rotationForce:.5,shatterTriggerAt:0},freeze:{name:"iceFreeze",emoji:"🧊",description:"Crystallize solid then freeze mid-air",duration:2500,beats:4,intensity:.8,elemental:"ice",elementalParam:0,impactPoint:[0,0,0],impactDirection:[0,1,0],revealSoul:!0,isFreezeMode:!0,isSuspendMode:!0,suspendAt:.15,suspendDuration:.15,gravity:-2,explosionForce:.8},shatterIce:{name:"shatterIce",emoji:"❄️",description:"Freeze then shatter into ice shards",duration:2e3,beats:4,intensity:1.3,elemental:"ice",elementalParam:.1,impactPoint:[0,0,.3],impactDirection:[0,0,-1],revealSoul:!0,gravity:-9.8,explosionForce:2,rotationForce:6,preFreezePhase:!0},thaw:{name:"thaw",emoji:"💧",description:"Ice melts to water transition",duration:4e3,beats:8,intensity:.6,elemental:"ice",elementalParam:.9,impactPoint:[0,.2,0],impactDirection:[0,-1,0],revealSoul:!0,gravity:-3,explosionForce:.3,rotationForce:1,meltTransition:!0},shock:{name:"shock",emoji:"⚡",description:"Brief electric surge with arcs",duration:1500,beats:2,intensity:1,elemental:"electric",elementalParam:.5,impactPoint:[0,0,0],impactDirection:[0,1,0],revealSoul:!0,reassemble:!0,reassembleAt:.5,reassembleDuration:700,gravity:-5,explosionForce:1.5,rotationForce:8,electricFlicker:!0},overload:{name:"overload",emoji:"💥",description:"Charge builds then explodes",duration:3e3,beats:6,intensity:2,elemental:"electric",elementalParam:1,impactPoint:[0,0,0],impactDirection:[0,1,0],revealSoul:!0,gravity:-2,explosionForce:3,rotationForce:10,chargeBuildup:!0,shatterTriggerAt:.3},glitch:{name:"glitch",emoji:"📺",description:"Flicker and static displacement",duration:2e3,beats:4,intensity:.7,elemental:"electric",elementalParam:.2,impactPoint:[0,0,0],impactDirection:[1,0,0],revealSoul:!1,reassemble:!0,reassembleAt:.6,reassembleDuration:800,gravity:-4,explosionForce:.5,rotationForce:2,glitchEffect:!0},consume:{name:"consume",emoji:"🕳️",description:"Void swallows inward",duration:3e3,beats:6,intensity:1,elemental:"void",elementalParam:.7,impactPoint:[0,0,0],impactDirection:[0,0,0],revealSoul:!1,isDualMode:!0,dualModeType:"implode",dualModeDuration:2500,gravity:.3,explosionForce:.5,rotationForce:2,voidPull:!0},corrupt:{name:"corrupt",emoji:"🖤",description:"Dark tendrils spread over surface",duration:4e3,beats:8,intensity:.6,elemental:"void",elementalParam:.4,impactPoint:[0,-.3,0],impactDirection:[0,1,0],revealSoul:!0,gravity:-1,explosionForce:.3,rotationForce:1.5,corruptSpread:!0,shatterTriggerAt:.4},singularity:{name:"singularity",emoji:"⚫",description:"Implode to point then vanish",duration:2500,beats:4,intensity:1.5,elemental:"void",elementalParam:1,impactPoint:[0,0,0],impactDirection:[0,0,0],revealSoul:!1,isDualMode:!0,dualModeType:"implode",dualModeDuration:2e3,gravity:2,explosionForce:.1,rotationForce:5,singularityCollapse:!0}};function js(e){const t=Ns[e];return t?{name:t.name,emoji:t.emoji,type:"override",description:t.description,usesShatter:!0,config:{duration:t.duration,musicalDuration:{musical:!0,beats:t.beats},intensity:t.intensity,variant:e,elemental:t.elemental,elementalParam:t.elementalParam},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:t.beats},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.3}},"3d":{evaluate(i,a){const n=(a.config||this.config||{}).intensity||1;let s=!1,r=!1,o=1,l=0,c=1;const h=void 0!==t.shatterTriggerAt?t.shatterTriggerAt:.1,u=t.reassemble,d=t.reassembleAt||.5;if(t.useWobble&&i<h){const e=i/h;c=1+.03*Math.sin(e*Math.PI*6)*e}if(t.chargeBuildup&&i<h){const e=i/h;o=1+1.5*e+.2*Math.sin(100*i)*e,l=.8*e}if(t.glowPulse&&(o+=.2*Math.sin(i*Math.PI*4)),t.corruptSpread&&i<h){const e=i/h;o=1-.3*e,l=.2*-e}if(t.preFreezePhase&&i<h){const e=i/h;o=1+.3*e,l=.4*e}if(i<h){if(h>0){const e=i/h,a=e*e;t.chargeBuildup||t.corruptSpread||(o=1+.6*a,l=.3*a),t.useWobble||(c=1+.03*a)}}else if(i<h+.02)s=i>=h&&i<h+.005,"void"===t.elemental?(o=.5,l=-.3):"electric"===t.elemental?(o=2.5,l=1):(o=1.8,l=.5),c=1.03;else{if(u&&i>=d&&i<d+.02&&(r=!0),u&&i>=d){const e=(i-d)/(1-d),t=e*e;o=1+.8*t,l=.5*t,i>.95&&(o=2,l=.8)}else{const e=(i-h-.02)/(u?d-h-.02:1-h-.02),t=Math.min(1,Math.max(0,e)),a=1-(1-t)*(1-t);o=1.8-.8*a,l=.5-.5*a}c=1}return s&&console.log(`[ELEMENTAL_GESTURE] 🎯 ${e} TRIGGER`,{variant:e,elemental:t.elemental,elementalParam:t.elementalParam,overlay:t.overlay,overlayParam:t.overlayParam,progress:i.toFixed(3),fullConfig:t}),{scale:c,glowIntensity:o,glowBoost:l,shatter:{enabled:s,impactPoint:t.impactPoint,impactDirection:t.impactDirection,intensity:n*t.intensity,variant:e,elemental:t.elemental,elementalParam:t.elementalParam,overlay:t.overlay,overlayParam:t.overlayParam,reassemble:r,reassembleDuration:t.reassembleDuration||1e3,revealSoul:!1!==t.revealSoul,isSuspendMode:t.isSuspendMode||!1,suspendAt:t.suspendAt||.15,suspendDuration:t.suspendDuration||.2,isFreezeMode:t.isFreezeMode||!1,gravity:t.gravity,explosionForce:t.explosionForce,rotationForce:t.rotationForce,gestureDuration:t.duration,isDualMode:t.isDualMode||!1,dualModeType:t.dualModeType,dualModeConfig:{duration:t.dualModeDuration||2e3,impactPoint:t.impactPoint,reassemble:t.reassemble,reassembleDuration:t.reassembleDuration}}}}}}:(console.warn(`ElementalFactory: Unknown variant '${e}'`),null)}var qs=ur({name:"shock",emoji:"⚡",type:"blending",description:"Brief electric surge - mascot is shocked",duration:1200,beats:2,intensity:1,category:"electrocute",spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.4,clustering:.35,count:6,scale:1,models:["arc-small","spark-node","arc-medium"],minDistance:.12,ephemeral:{lifetime:{min:100,max:300},flashIn:30,fadeOut:80,respawn:!0},animation:{appearAt:.02,disappearAt:.95,stagger:.01,enter:{type:"flash",duration:.01,easing:"linear"},exit:{type:"flash",duration:.02,easing:"linear"},flicker:{intensity:.5,rate:30,pattern:"random"},emissive:{min:1,max:3,frequency:25,pattern:"random",dutyCycle:.6},rotate:{axis:[1,1,0],speed:.5,oscillate:!0,range:Math.PI/3},cutout:{strength:.55,primary:{pattern:1,scale:1.2,weight:.7},secondary:{pattern:7,scale:.8,weight:.3},blend:"multiply",travel:"oscillate",travelSpeed:2.5,strengthCurve:"bell"},grain:{type:3,strength:.25,scale:.3,speed:3,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.7,sizeScale:1.5,progressCurve:"pulse"}],flash:{events:[{at:.15,intensity:2},{at:.5,intensity:3}],decay:.02},scaleVariance:.4,lifetimeVariance:.5,delayVariance:.2,blending:"additive",renderOrder:15,intensityScaling:{scale:1.3,flickerIntensity:1.5,emissiveMax:1.8}}},jitterFrequency:60,jitterAmplitude:.015,jitterDecay:.3,glowColor:[.3,.9,1],glowIntensityMin:.8,glowIntensityMax:2.5,glowFlickerRate:25,scaleVibration:.03,scaleFrequency:40}),Us=ur({name:"overload",emoji:"💥",type:"blending",description:"Intense charge buildup, extreme shock",duration:2500,beats:4,intensity:2,category:"electrocute",spawnMode:{type:"surface",pattern:"shell",embedDepth:.1,cameraFacing:.35,clustering:.2,count:12,scale:1.1,models:["arc-small","arc-medium","arc-cluster","spark-node"],minDistance:.1,ephemeral:{lifetime:{min:80,max:150},flashIn:15,fadeOut:40,respawn:!0,stagger:30,progression:{duration:2500,lifetime:[80,150,300,600],flashIn:[15,40],fadeOut:[40,150],respawnDelay:[0,30,0,0]}},animation:{appearAt:.02,disappearAt:.92,stagger:.015,enter:{type:"flash",duration:.01,easing:"linear"},exit:{type:"flash",duration:.03,easing:"linear"},flicker:{intensity:.6,rate:35,pattern:"random"},emissive:{min:1.2,max:4,frequency:30,pattern:"random",dutyCycle:.7},cutout:{strength:.6,primary:{pattern:8,scale:1,weight:.7},secondary:{pattern:5,scale:.6,weight:.3},blend:"multiply",travel:"radial",travelSpeed:1.8,strengthCurve:"fadeIn"},grain:{type:3,strength:.3,scale:.25,speed:2.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.6,sizeScale:1.2,progressCurve:"pulse"}],flash:{events:[{at:.3,intensity:1.5},{at:.55,intensity:2.5},{at:.75,intensity:3.5}],decay:.02},scaleVariance:.35,lifetimeVariance:.4,blending:"additive",renderOrder:15,intensityScaling:{scale:1.4,flickerIntensity:1.6,emissiveMax:2}}},jitterFrequency:80,jitterAmplitude:.03,jitterDecay:.1,glowColor:[.5,.95,1],glowIntensityMin:1,glowIntensityMax:4,glowFlickerRate:35,scaleVibration:.05,scaleFrequency:50,buildupPhase:.3,buildupGlowRamp:!0}),Ws=ur({name:"glitch",emoji:"📺",type:"blending",description:"Digital corruption, static displacement",duration:1800,beats:3,intensity:.7,category:"electrocute",spawnMode:{type:"surface",pattern:"scattered",embedDepth:.15,cameraFacing:.5,clustering:.4,count:2,scale:.7,models:["spark-node"],minDistance:.25,ephemeral:{lifetime:{min:25,max:80},flashIn:8,fadeOut:15,respawn:!0,respawnDelay:{min:80,max:400}},animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"flash",duration:.005,easing:"linear"},exit:{type:"flash",duration:.01,easing:"linear"},flicker:{intensity:.4,rate:20,pattern:"random"},emissive:{min:.8,max:2.5,frequency:15,pattern:"random",dutyCycle:.4},cutout:{strength:.5,primary:{pattern:3,scale:1,weight:.65},secondary:{pattern:1,scale:.7,weight:.35},blend:"multiply",travel:"oscillate",travelSpeed:1.5,strengthCurve:"bell"},grain:{type:3,strength:.2,scale:.35,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.1,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.5,lifetimeVariance:.6,delayVariance:.4,blending:"additive",renderOrder:15,intensityScaling:{scale:1.1,flickerIntensity:1.3,emissiveMax:1.5}}},jitterFrequency:20,jitterAmplitude:.04,jitterDecay:.5,glowColor:[.4,.8,1],glowIntensityMin:.5,glowIntensityMax:2,glowFlickerRate:15,scaleVibration:.04,scaleFrequency:12,holdFrames:!0,holdProbability:.15,holdDuration:.05}),Hs=ur({name:"crackle",emoji:"✨",type:"blending",description:"Rapid stuttering bolts crackling across surface",duration:2e3,beats:3,intensity:.8,category:"powered",spawnMode:{type:"surface",pattern:"spikes",embedDepth:.08,cameraFacing:.5,clustering:.3,count:3,scale:1.2,models:["spark-spike","arc-small","spark-spike"],minDistance:.2,animation:{appearAt:.1,disappearAt:.85,stagger:.08,enter:{type:"pop",duration:.015,easing:"elasticOut",overshoot:1.3},exit:{type:"fade",duration:.15,easing:"easeOutCubic"},flicker:{intensity:.5,rate:20,pattern:"random"},emissive:{min:.8,max:2.5,frequency:8,pattern:"sine"},cutout:{strength:.5,primary:{pattern:8,scale:1.2,weight:.7},secondary:{pattern:2,scale:.8,weight:.3},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"fadeOut"},grain:{type:3,strength:.15,scale:.4,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.1,sizeScale:.6,progressCurve:"sustain"}],flash:{events:[{at:.2,intensity:2},{at:.35,intensity:1.5},{at:.5,intensity:2.5},{at:.65,intensity:1},{at:.75,intensity:1.8}],decay:.015},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:12}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.4,.9,1],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:2,scalePulse:!0,rotationDrift:.01}),$s=ur({name:"chargeUp",emoji:"🔋",type:"blending",description:"Building up electrical power, growing intensity",duration:2500,beats:4,intensity:1.2,category:"powered",spawnMode:{type:"surface",pattern:"crown",embedDepth:.1,cameraFacing:.4,clustering:.3,count:6,scale:1,models:["spark-node","arc-small","arc-medium"],minDistance:.12,ephemeral:{lifetime:{min:50,max:100},flashIn:12,fadeOut:30,respawn:!0,stagger:50,progression:{duration:2500,lifetime:[50,100,400,700],flashIn:[12,60],fadeOut:[30,200],respawnDelay:[0,20,100,250]}},animation:{appearAt:.05,disappearAt:.92,stagger:.03,enter:{type:"grow",duration:.04,easing:"easeOutQuad"},exit:{type:"flash",duration:.02,easing:"linear"},pulse:{amplitude:.18,frequency:3,easing:"easeInOut",sync:"global"},emissive:{min:.6,max:2.8,frequency:4,pattern:"sine"},drift:{direction:"up",speed:.025,noise:.15},rotate:{axis:"y",speed:.08,oscillate:!1},cutout:{strength:.45,primary:{pattern:2,scale:1.3,weight:.65},secondary:{pattern:6,scale:.7,weight:.35},blend:"multiply",travel:"radial",travelSpeed:1.2,strengthCurve:"fadeIn"},grain:{type:3,strength:.1,scale:.35,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.1,sizeScale:.6,progressCurve:"rampUp"}],scaleVariance:.25,lifetimeVariance:.2,blending:"additive",renderOrder:12,intensityScaling:{scale:1.35,emissiveMax:1.6,driftSpeed:1.3}}},jitterFrequency:30,jitterAmplitude:.005,jitterDecay:.2,glowColor:[.3,.95,1],glowIntensityMin:.8,glowIntensityMax:3,glowFlickerRate:12,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,scaleGrowth:.08,rampUp:!0,riseAmount:.02}),Ys=ur({name:"electricAuraEffect",emoji:"💫",type:"blending",description:"Electric rings rising slowly from center",duration:3e3,beats:4,intensity:1,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"center",easing:"easeOut",startScale:.9,endScale:1.3,startDiameter:1.6,endDiameter:2.2,orientation:"camera"},formation:{type:"spiral",count:3,strands:1,spacing:.15,arcOffset:120,phaseOffset:.05},count:3,scale:2,models:["plasma-ring","arc-ring-small","plasma-ring"],animation:{appearAt:.05,disappearAt:.85,stagger:.06,enter:{type:"fade",duration:.12,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.15,rate:8,pattern:"sine"},emissive:{min:.9,max:1.8,frequency:2.5,pattern:"sine"},cutout:{strength:.4,primary:{pattern:0,scale:1,weight:.6},secondary:{pattern:1,scale:.8,weight:.4},blend:"multiply",travel:"angular",travelSpeed:.6,strengthCurve:"constant"},grain:{type:3,strength:.08,scale:.4,speed:1,blend:"multiply"},rotate:{axis:"y",rotations:.5,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:10,modelOverrides:{"plasma-ring":{scaleMultiplier:1.1,shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.5,arcCount:1},orientationOverride:"camera"},"arc-ring-small":{scaleMultiplier:.9,shaderAnimation:{type:1,arcWidth:.6,arcSpeed:.8,arcCount:2},orientationOverride:"camera"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.3,glowColor:[.5,.85,1],glowIntensityMin:1.2,glowIntensityMax:2,glowFlickerRate:4,scaleVibration:.015,scaleFrequency:1.5,scalePulse:!0,rotationDrift:.02,hover:!0,hoverAmount:.01}),Xs=ur({name:"staticDischarge",emoji:"⚡",type:"blending",description:"Low-level static electricity, ambient sparks",duration:1500,beats:2,intensity:.4,category:"powered",spawnMode:{type:"surface",pattern:"scattered",embedDepth:.15,cameraFacing:.35,clustering:.3,count:2,scale:.6,models:["spark-node"],minDistance:.3,ephemeral:{lifetime:{min:40,max:100},flashIn:10,fadeOut:30,respawn:!0,stagger:200,respawnDelay:{min:250,max:600}},animation:{appearAt:.05,disappearAt:.92,stagger:.03,enter:{type:"flash",duration:.008,easing:"linear"},exit:{type:"fade",duration:.05,easing:"easeOut"},emissive:{min:.6,max:1.5,frequency:20,pattern:"random",dutyCycle:.3},cutout:{strength:.35,primary:{pattern:3,scale:.8,weight:.6},secondary:{pattern:0,scale:.6,weight:.4},blend:"multiply",travel:"oscillate",travelSpeed:.8,strengthCurve:"bell"},grain:{type:3,strength:.1,scale:.45,speed:1.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.08,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.3,lifetimeVariance:.4,blending:"additive",renderOrder:10,intensityScaling:{scale:1,emissiveMax:1.2}}},jitterFrequency:5,jitterAmplitude:.002,jitterDecay:.4,glowColor:[.5,.8,1],glowIntensityMin:.9,glowIntensityMax:1.3,glowFlickerRate:20,scaleVibration:.005,scaleFrequency:8,scalePulse:!1,sparkBursts:!0,sparkProbability:.1}),Qs=ur({name:"electriccrown",emoji:"👑",type:"blending",description:"Crackling lightning crown above the head",duration:3e3,beats:4,intensity:1,category:"powered",spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.3}},count:1,scale:2.2,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.02,frequency:2,easing:"easeInOut"},rotate:{axis:"z",rotations:1,phase:0},atmospherics:[{preset:"ozone",targets:["lightning-ring"],anchor:"above",intensity:.04,sizeScale:.6,progressCurve:"sustain"}],scaleVariance:0,lifetimeVariance:0,blending:"additive",renderOrder:15}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.3,.9,1],glowIntensityMin:.8,glowIntensityMax:.8,glowFlickerRate:0,scaleVibration:.003,scaleFrequency:3,scaleGrowth:.005,scalePulse:!0,rotationDrift:.01}),Ks=ur({name:"electricdance",emoji:"💃",type:"blending",description:"Vertical lightning rings dancing and rising",duration:1500,beats:3,intensity:1.3,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.8,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:2,spacing:0,arcOffset:180,phaseOffset:0},count:2,scale:2,models:["lightning-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.35,rate:14,pattern:"random"},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.75,primary:{pattern:6,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.6},blend:"add",travel:"spiral",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28}},grain:{type:3,strength:.06,scale:.15,speed:1,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:90}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:11,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.3,.9,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.015,scaleFrequency:4,scaleGrowth:.01,scalePulse:!0,rotationDrift:.01}),Zs=ur({name:"electrichelix",emoji:"🧬",type:"blending",description:"Double helix of lightning rings ascending",duration:2e3,beats:3,intensity:1.2,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.9,endScale:1.1,startDiameter:1.8,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:2,strands:2,spacing:.2,arcOffset:180,phaseOffset:.05},count:2,scale:2,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.25,rate:12,pattern:"random"},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.8,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:6,scale:1.8,weight:.6},blend:"max",travel:"angular",travelSpeed:3,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.08,scale:.2,speed:1.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"additive",renderOrder:16,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.35,.9,1],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:5,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,rotationDrift:.015});const Js={enter:{type:"scale",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},pulse:{amplitude:.08,frequency:4,easing:"easeInOut"},emissive:{min:1,max:2,frequency:5,pattern:"sine"},grain:{type:3,strength:.25,scale:.3,speed:2,blend:"multiply"},rotate:{axis:"z",rotations:1,phase:0},scaleVariance:.1,lifetimeVariance:.08,blending:"additive",renderOrder:12,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.65,arcSpeed:3,arcCount:1},orientationOverride:"flat"},"plasma-ring":{shaderAnimation:{type:1,arcWidth:.55,arcSpeed:4,arcCount:2},orientationOverride:"flat"}}};var er=ur({name:"electricpillar",emoji:"🗼",type:"blending",description:"Rising pillar of stacked lightning rings",duration:3e3,beats:4,intensity:1.3,category:"powered",spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"center",easing:"easeOut",startScale:1,endScale:1.3,startDiameter:1.5,endDiameter:1.8,orientation:"flat"},formation:{type:"stack",count:2,spacing:.3},count:2,scale:1.5,models:["lightning-ring"],animation:{...Js,appearAt:0,disappearAt:.85,stagger:.04,atmospherics:[{preset:"ozone",targets:["lightning-ring"],anchor:"above",intensity:.1,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5}],cutout:{strength:.5,primary:{pattern:1,scale:1,weight:.65},secondary:{pattern:2,scale:.8,weight:.35},blend:"add",travel:"angular",travelSpeed:1.5,strengthCurve:"bell"}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"above",easing:"easeOut",startScale:.9,endScale:1.2,startDiameter:1.3,endDiameter:1.6,orientation:"flat"},formation:{type:"stack",count:2,spacing:.3},count:2,scale:1.4,models:["plasma-ring"],animation:{...Js,appearAt:.08,disappearAt:.88,stagger:.04,cutout:{strength:.55,primary:{pattern:8,scale:1.2,weight:.7},secondary:{pattern:1,scale:.7,weight:.3},blend:"multiply",travel:"radial",travelSpeed:1.8,strengthCurve:"bell"}}},{type:"axis-travel",axisTravel:{axis:"y",start:"above",end:"far-above",easing:"easeOut",startScale:.8,endScale:1.1,startDiameter:1.1,endDiameter:1.4,orientation:"flat"},formation:{type:"stack",count:2,spacing:.3},count:2,scale:1.3,models:["lightning-ring"],animation:{...Js,appearAt:.15,disappearAt:.9,stagger:.04,cutout:{strength:.45,primary:{pattern:3,scale:1,weight:.6},secondary:{pattern:7,scale:.8,weight:.4},blend:"add",travel:"oscillate",travelSpeed:1.2,strengthCurve:"fadeOut"}}}],jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.35,.9,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:5,scaleVibration:.01,scaleFrequency:3,scalePulse:!0,rotationDrift:.015}),tr=ur({name:"electricdrill",emoji:"🔩",type:"blending",description:"Fast tight descending lightning helix",duration:1200,beats:2,intensity:1.5,category:"electrocute",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:2,spacing:.1,arcOffset:180,phaseOffset:0},count:2,scale:2,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},flicker:{intensity:.4,rate:25,pattern:"random"},pulse:{amplitude:.08,frequency:10,easing:"linear"},emissive:{min:1.5,max:3.5,frequency:12,pattern:"random"},cutout:{strength:.55,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:.8,weight:.35},blend:"add",travel:"vertical",travelSpeed:3,strengthCurve:"constant"},grain:{type:3,strength:.3,scale:.2,speed:4,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"below",intensity:.3,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:16,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},jitterFrequency:45,jitterAmplitude:.01,jitterDecay:.25,glowColor:[.3,.9,1],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:15,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03}),ir=ur({name:"electricflourish",emoji:"⚔️",type:"blending",description:"Spinning lightning flourish with electric trails",duration:1200,beats:4,intensity:1.3,category:"powered",spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:.05,zOffset:0},count:3,scale:2,models:["lightning-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},flicker:{intensity:.3,rate:14,pattern:"random"},pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.6,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:8,scale:.6,weight:.5},blend:"multiply",strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.15,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.4}],drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.85,.7],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:120},{axis:"z",rotations:1.8,phase:240}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:12,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.7,y:.4,z:.05},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.8,models:["plasma-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:8,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:-45}],blending:"additive",renderOrder:14,modelOverrides:{"plasma-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:4,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.7,y:.4,z:.05},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.8,models:["plasma-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:8,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:45}],blending:"additive",renderOrder:14,modelOverrides:{"plasma-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:4,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:2,models:["lightning-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},flicker:{intensity:.25,rate:12,pattern:"random"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.5,primary:{pattern:8,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"additive",renderOrder:10,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:2,models:["lightning-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},flicker:{intensity:.25,rate:12,pattern:"random"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.5,primary:{pattern:8,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"additive",renderOrder:10,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.35,.9,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.015,scaleFrequency:4,scalePulse:!0}),ar=ur({name:"electricvortex",emoji:"🌀",type:"blending",description:"Lightning tornado spiraling around mascot",duration:1500,beats:5,intensity:1.4,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.5,startDiameter:.6,endDiameter:1.6,orientation:"flat"},formation:{type:"spiral",count:2,spacing:0,arcOffset:180,phaseOffset:0},count:2,scale:2,models:["lightning-ring"],animation:{appearAt:.05,disappearAt:.7,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.35,rate:14,pattern:"random"},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2,frequency:5,pattern:"sine"},cutout:{strength:.5,primary:{pattern:1,scale:1.2,weight:.6},secondary:{pattern:3,scale:.8,weight:.4},blend:"add",travel:"angular",travelSpeed:2.5,strengthCurve:"bell",trailDissolve:{enabled:!0,offset:-.4,softness:1.2}},grain:{type:3,strength:.2,scale:.3,speed:2.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.2,sizeScale:1.2,progressCurve:"sustain",velocityInheritance:.6,centrifugal:{speed:1.2,tangentialBias:.3}}],flash:{events:[{at:.2,intensity:2},{at:.45,intensity:3},{at:.6,intensity:1.5}],decay:.02},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:12,modelOverrides:{"lightning-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:5,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.2,glowColor:[.4,.85,1],glowIntensityMin:1.2,glowIntensityMax:2.2,glowFlickerRate:6,scaleVibration:.02,scaleFrequency:4,scaleGrowth:.03,scalePulse:!0,rotationDrift:.02}),nr=ur({name:"electricbarrage",emoji:"🏹",type:"blending",description:"Electric arcs orbit mascot then launch outward",duration:1500,beats:4,intensity:1.4,category:"powered",spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.8,models:["arc-cluster","arc-medium","spark-node"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},flicker:{intensity:.4,rate:16,pattern:"random"},grain:{type:3,strength:.12,scale:.3,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.25,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.7}],flash:{events:[{at:.1,intensity:1.5},{at:.3,intensity:2.5},{at:.5,intensity:3}],decay:.02},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1.2,max:3,frequency:8,pattern:"sine"},rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"additive",renderOrder:12}},jitterFrequency:10,jitterAmplitude:.005,jitterDecay:.2,glowColor:[.4,.9,1],glowIntensityMin:1.5,glowIntensityMax:3,glowFlickerRate:12,scaleVibration:.015,scaleFrequency:4,scaleGrowth:.02,scalePulse:!0}),sr=ur({name:"electricimpact",emoji:"💥",type:"blending",description:"Electric arcs orbit then crash inward",duration:1500,beats:4,intensity:1.5,category:"electrocute",spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:3.5,endRadius:.1,speed:3,easing:"easeOut",startScale:.4,endScale:1.8,orientation:"vertical"},formation:{type:"ring",count:7},count:7,scale:1.4,models:["arc-cluster","arc-medium","arc-small","spark-spike"],animation:{appearAt:0,disappearAt:.6,stagger:.02,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.05,easing:"easeOut",burstScale:.2},procedural:{scaleSmoothing:.04,geometryStability:!0},grain:{type:3,strength:.15,scale:.3,speed:2.5,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"around",intensity:.5,sizeScale:1,progressCurve:"burst",velocityInheritance:.7}],pulse:{amplitude:.12,frequency:8,easing:"easeInOut"},emissive:{min:1,max:3,frequency:9,pattern:"sine"},rotate:[{axis:"z",rotations:-4,phase:0},{axis:"x",rotations:3.5,phase:50},{axis:"y",rotations:-3,phase:100},{axis:"z",rotations:4,phase:155},{axis:"x",rotations:-3.5,phase:210},{axis:"y",rotations:3,phase:260},{axis:"z",rotations:-4.5,phase:315}],scaleVariance:.2,lifetimeVariance:.08,blending:"additive",renderOrder:12}},jitterFrequency:70,jitterAmplitude:.02,jitterDecay:.15,glowColor:[.45,.9,1],glowIntensityMin:1.6,glowIntensityMax:2.8,glowFlickerRate:20,scaleVibration:.03,scaleFrequency:15}),rr=ur({name:"electricblast",emoji:"💥",type:"blending",description:"Explosive electrical discharge burst",duration:1e3,beats:2,intensity:1.5,category:"electrocute",spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.2,endScale:2.2,scaleEasing:"easeOutQuad"},count:1,scale:2,models:["plasma-ring"],animation:{appearAt:0,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},flicker:{intensity:.3,rate:14,pattern:"random"},cutout:{strength:.5,primary:{pattern:2,scale:1.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"fadeOut"},grain:{type:3,strength:.3,scale:.25,speed:3,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.8,sizeScale:2,progressCurve:"pulse"}],flash:{events:[{at:0,intensity:4},{at:.15,intensity:1.5}],decay:.03},blending:"additive",renderOrder:8,modelOverrides:{"plasma-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.3,endScale:1.5,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["spark-spike"],animation:{appearAt:0,disappearAt:.5,enter:{type:"scale",duration:.03,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},flicker:{intensity:.35,rate:16,pattern:"random"},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:1.2,strengthCurve:"fadeOut"},drift:{speed:1.4,distance:.8,direction:{x:0,y:1,z:0},easing:"easeOutQuad"},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:.9,models:["spark-spike"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.03,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},flicker:{intensity:.35,rate:16,pattern:"random"},cutout:{strength:.5,primary:{pattern:8,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:-.8,y:.7,z:0},easing:"easeOutQuad"},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:.9,models:["spark-spike"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.03,easing:"easeOutBack"},exit:{type:"fade",duration:.15,easing:"easeIn"},flicker:{intensity:.35,rate:16,pattern:"random"},cutout:{strength:.5,primary:{pattern:8,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:.8,y:.7,z:0},easing:"easeOutQuad"},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:3,radius:.05,endRadius:.6,angleSpread:360,startAngle:30,orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:3,scale:.6,models:["arc-ring-small"],animation:{appearAt:.02,disappearAt:.4,stagger:.01,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},flicker:{intensity:.4,rate:18,pattern:"random"},cutout:{strength:.4,primary:{pattern:3,scale:.7,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:14,modelOverrides:{"arc-ring-small":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}}],jitterFrequency:60,jitterAmplitude:.02,jitterDecay:.25,glowColor:[.4,.9,1],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:15,scaleVibration:.04,scaleFrequency:10,scaleGrowth:.02}),or=ur({name:"electricsurge",emoji:"📡",type:"blending",description:"Expanding electromagnetic shockwave",duration:2e3,beats:3,intensity:.9,category:"powered",spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.4,endScale:2.5,startDiameter:.5,endDiameter:3,orientation:"camera"},formation:{type:"stack",count:1,spacing:0},count:1,scale:1.3,models:["plasma-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.5,primary:{pattern:2,scale:1.5,weight:.6},secondary:{pattern:8,scale:1,weight:.4},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.3,softness:1.5}},grain:{type:3,strength:.15,scale:.35,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.2,sizeScale:1.2,progressCurve:"rampUp"}],pulse:{amplitude:.08,frequency:3,easing:"easeInOut"},emissive:{min:.8,max:2,frequency:4,pattern:"sine"},blending:"additive",renderOrder:8,modelOverrides:{"plasma-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.3,arcCount:1},orientationOverride:"camera"}}}},jitterFrequency:0,jitterAmplitude:0,jitterDecay:.3,glowColor:[.4,.85,1],glowIntensityMin:.8,glowIntensityMax:1.5,glowFlickerRate:4,scaleVibration:.01,scaleFrequency:2,scalePulse:!0,rotationDrift:.01}),lr=ur({name:"zap",emoji:"⚡",type:"blending",description:"Explosive multi-layer lightning burst",duration:2e3,beats:4,intensity:1.7,category:"powered",spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeIn",startScale:.5,endScale:1.6,startDiameter:.8,endDiameter:1,orientation:"camera"},formation:{type:"spiral",count:1,strands:1,spacing:0,arcOffset:0,phaseOffset:0},count:1,scale:1.5,models:["arc-medium"],animation:{appearAt:0,disappearAt:.75,enter:{type:"scale",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},flicker:{intensity:.35,rate:14,pattern:"random"},emissive:{min:1.2,max:3,frequency:8,pattern:"sine"},cutout:{strength:.35,primary:{pattern:7,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.12,scale:.25,speed:2,blend:"multiply"},atmospherics:[{preset:"ozone",targets:null,anchor:"above",intensity:.5,sizeScale:1.2,progressCurve:"pulse"}],flash:{events:[{at:.1,intensity:2.5},{at:.3,intensity:4},{at:.5,intensity:5},{at:.68,intensity:3}],decay:.02},rotate:{axis:"y",rotations:1.5,phase:0},blending:"additive",renderOrder:10,modelOverrides:{"arc-medium":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.1,y:.1,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1.8,models:["spark-spike"],animation:{appearAt:.05,disappearAt:.65,enter:{type:"scale",duration:.05,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.2},flicker:{intensity:.3,rate:14,pattern:"random"},drift:{speed:1.2,distance:1,direction:{x:-1,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:-.25,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.1,y:.1,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1.8,models:["spark-spike"],animation:{appearAt:.05,disappearAt:.65,enter:{type:"scale",duration:.05,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.2},flicker:{intensity:.3,rate:14,pattern:"random"},drift:{speed:1.2,distance:1,direction:{x:1,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:.25,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"spark-spike":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:2,radius:.05,endRadius:.4,angleSpread:120,startAngle:240,orientation:"camera",startScale:.3,endScale:.8,scaleEasing:"easeOutQuad"},count:2,scale:.6,models:["arc-small"],animation:{appearAt:.15,disappearAt:.55,stagger:.03,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},flicker:{intensity:.4,rate:18,pattern:"random"},scaleVariance:.2,blending:"additive",renderOrder:14,modelOverrides:{"arc-small":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}}],jitterFrequency:8,jitterAmplitude:.005,jitterDecay:.2,glowColor:[.35,.9,1],glowIntensityMin:1.4,glowIntensityMax:3.5,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:4,scaleGrowth:.03,scalePulse:!0,riseAmount:.02});function cr(e){return(43758.5453*Math.sin(127.1*e+311.7*e)%1+1)%1}function hr(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return cr(t)*(1-a)+cr(t+1)*a}function ur(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.5,offBeat:1,curve:"powered"===e.category?"smooth":"sharp"}},"3d":{evaluate(t,i){const a={...e,...i},n=t*a.duration/1e3,s="powered"===a.category;let r=1;a.buildupPhase&&t<a.buildupPhase&&(r=t/a.buildupPhase,a.buildupGlowRamp&&(r=Math.pow(r,.5))),a.rampUp&&(r=Math.pow(t,.7)),t>1-a.jitterDecay&&(r*=1-(t-(1-a.jitterDecay))/a.jitterDecay);let o=0,l=0,c=0;if(a.jitterAmplitude>0){const e=n*a.jitterFrequency;let t=1;a.holdFrames&&cr(Math.floor(3*e))<a.holdProbability&&(t=.1),o=(hr(e)-.5+.5*(hr(2.3*e+50)-.5)+.25*(hr(4.7*e+100)-.5))*a.jitterAmplitude*r*t,l=(hr(e+33)-.5+.5*(hr(2.1*e+83)-.5)+.25*(hr(5.3*e+133)-.5))*a.jitterAmplitude*r*t,c=(hr(e+66)-.5+.5*(hr(1.9*e+116)-.5)+.25*(hr(3.7*e+166)-.5))*a.jitterAmplitude*r*t*.5}a.hover&&a.hoverAmount&&(l+=Math.sin(n*Math.PI*.5)*a.hoverAmount*r),a.riseAmount&&(l+=a.riseAmount*r);let h=0,u=0,d=0;if(!s&&a.jitterAmplitude>0){const e=n*a.jitterFrequency,t=2*a.jitterAmplitude;h=(hr(1.3*e+200)-.5)*t*r,u=(hr(1.7*e+250)-.5)*t*r,d=(hr(2.1*e+300)-.5)*t*r*.5}else a.rotationDrift&&(u=n*a.rotationDrift*r);let m=1;const p=n*a.scaleFrequency;a.scalePulse?(m=1+(.5*Math.sin(p*Math.PI*2)+.5)*a.scaleVibration*r,a.scaleGrowth&&(m+=a.scaleGrowth*r)):m=1+(.5*Math.sin(p*Math.PI*2)+.3*Math.sin(p*Math.PI*3.7))*a.scaleVibration*r;const g=n*a.glowFlickerRate;let f;return s?(f=.3*Math.sin(g*Math.PI*2)+.7,a.sparkBursts&&cr(Math.floor(10*n))<a.sparkProbability&&(f=1)):f=.4*Math.sin(g*Math.PI*2)+.3*Math.sin(g*Math.PI*5.3+1.7)+.5*(cr(Math.floor(2*g))>.7?1:0)+.5,{position:[o,l,c],rotation:[h,u,d],scale:m,glowIntensity:a.glowIntensityMin+(a.glowIntensityMax-a.glowIntensityMin)*f*r,glowBoost:(.8*f+.2)*r*a.intensity,glowColorOverride:a.glowColor,electricOverlay:{enabled:r>.1,strength:r*a.intensity,charge:r*a.intensity,category:a.category,spawnMode:a.spawnMode||null,duration:a.duration,progress:t,time:n,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth}}}}}}const dr=qs,mr=Us,pr=Ws,gr=Hs,fr=$s,yr=Ys,vr=Xs,br=Qs,wr=Ks,Mr=Zs,Sr=er,xr=tr,Cr=ir,Pr=ar,kr=nr,Dr=sr,Ar=rr,_r=or,Tr=lr,Ir=lr;function Or(e){return.5*Math.sin(1*e)+.3*Math.sin(2.3*e+1.3)+.2*Math.sin(4.1*e+2.7)}function Rr(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"phrase",amplitudeSync:{onBeat:1.3,offBeat:1,curve:"smooth"}},"3d":{evaluate(t,i){const a=e["3d"]?.evaluate,n=a?a(t,i):null,s={...e,...i},r=t*s.duration/1e3,{category:o}=s;let l=1;if("impact"===o)if(s.impactBurst&&t<s.burstDuration)l=t/s.burstDuration,l=Math.pow(l,.3);else if(s.rampUp)l=Math.pow(t,.5);else{const e=s.burstDuration||.2;if(t>e){const i=(t-e)/(1-e);l=1-Math.pow(i,s.wobbleDecay+.5)}}"transform"===o&&(l=s.formLoss?.3+.7*t:Math.min(2*t,1)),"ambient"===o&&(l=.8+.1*Math.sin(t*Math.PI*2)+.2*t),t>.85&&(l*=1-(t-.85)/.15);let c=0,h=0,u=0;if(s.flowFrequency){const e=r*s.flowFrequency*Math.PI*2;c=Math.sin(e)*s.flowAmplitude*l,s.flowPhaseOffset&&(h=Math.sin(e+Math.PI*s.flowPhaseOffset)*s.flowAmplitude*.5*l),s.verticalBob&&(h+=Math.sin(.5*e)*s.verticalBob*l)}if(s.wobbleAmplitude>0){const e=r*s.wobbleFrequency;let i=s.wobbleAmplitude*l;s.wobbleDecay<0&&(i*=1+t*Math.abs(s.wobbleDecay)*2),c+=Or(e)*i,h+=Or(e+33)*i*.7,u+=Or(e+66)*i*.5}s.sinkAmount&&(h-=s.sinkAmount*l),s.settleDown&&(h-=s.settleDown*t*l),s.meltDown&&(h-=.02*t*l);const d=n?.rotation||[0,0,0];let m=d[0]||0,p=d[1]||0,g=d[2]||0;if(s.rotationFlow&&(p+=r*s.rotationFlow*l),s.rotationSway){const e=r*(s.flowFrequency||1)*Math.PI*2;g+=Math.sin(e)*s.rotationSway*l}if(s.wobbleAmplitude>0&&"ambient"!==o){const e=r*s.wobbleFrequency,t=.3*s.wobbleAmplitude*l;m+=Or(.7*e+100)*t,g+=Or(.9*e+150)*t}let f=1,y=1,v=1,b=1;if(s.scaleWobble){const e=r*s.scaleFrequency*Math.PI*2,t=.5*Math.sin(e)+.5;f=s.concentricPulse&&s.pulseCount?1+(.5*Math.sin(e*s.pulseCount)+.5)*s.scaleWobble*l:1+t*s.scaleWobble*l}s.scaleGrowth&&(f+=s.scaleGrowth*t*l),s.scaleCompression&&(f+=s.scaleCompression*l),s.scaleSquash?(v=f-s.scaleSquash*t*l,y=f+(s.scaleStretch||.5*s.scaleSquash)*t*l,b=y):s.stretchVertical?(v=f+s.stretchVertical*t*l,y=f-.3*s.stretchVertical*t*l,b=y):y=v=b=f;const w=r*s.glowPulseRate*Math.PI*2;let M=.5*Math.sin(w)+.5;return s.impactBurst&&t<s.burstDuration&&(M=1),s.saturationBuild&&(M=Math.max(M,t)),{position:[c,h,u],rotation:[m,p,g],scale:(y+v+b)/3,scaleXYZ:[y,v,b],glowIntensity:s.glowIntensityMin+(s.glowIntensityMax-s.glowIntensityMin)*M*l,glowBoost:.6*M*l*s.intensity,glowColorOverride:s.glowColor,waterOverlay:{enabled:l>.1,strength:l*s.intensity,wetness:l*s.intensity,turbulence:s.turbulence,category:s.category,spawnMode:s.spawnMode||null,duration:s.duration,progress:t,time:r,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth}}}}}}var Er=Rr({name:"splash",emoji:"💦",type:"blending",description:"Explosive water splash with curling waves and spray",duration:1e3,beats:2,intensity:1.3,category:"impact",turbulence:.8,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.2,endScale:2,scaleEasing:"easeOutQuad"},count:1,scale:1.5,models:["splash-ring"],animation:{appearAt:0,disappearAt:.4,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.6,primary:{pattern:2,scale:1.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},grain:{type:3,strength:.5,scale:.3,speed:1.5,blend:"multiply"},blending:"additive",renderOrder:8,rotate:{axis:"z",rotations:0,phase:0},modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:1,sizeScale:1.2,burstCount:25,progressCurve:"burst"}]}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1.2,models:["droplet-large"],animation:{appearAt:0,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:4,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.4,distance:.8,direction:{x:0,y:1,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["droplet-large"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.45,primary:{pattern:0,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:-.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["droplet-large"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.45,primary:{pattern:0,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.85,models:["droplet-large"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:4,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:-.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:11,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.85,models:["droplet-large"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:4,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:11,modelOverrides:{"droplet-large":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:8,radius:.05,endRadius:.65,angleSpread:360,startAngle:22,orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:8,scale:.6,models:["droplet-small"],animation:{appearAt:.02,disappearAt:.4,stagger:.008,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.35,primary:{pattern:0,scale:.7,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:14,modelOverrides:{"droplet-small":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:12,radius:.03,endRadius:.5,angleSpread:360,startAngle:0,orientation:"camera",startScale:.1,endScale:.35,scaleEasing:"easeOutQuad"},count:12,scale:.2,models:["droplet-small"],animation:{appearAt:.01,disappearAt:.3,stagger:.005,enter:{type:"scale",duration:.02,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.25,primary:{pattern:7,scale:.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.5,lifetimeVariance:.25,blending:"additive",renderOrder:16,modelOverrides:{"droplet-small":{shaderAnimation:{type:1,arcWidth:.98,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.1,z:.12},orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:1,scale:.7,models:["bubble-cluster"],animation:{appearAt:.05,disappearAt:.6,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.5,primary:{pattern:0,scale:1.2,weight:1},blend:"multiply",travel:"radial",travelSpeed:.5,strengthCurve:"constant"},pulse:{amplitude:.1,frequency:8,easing:"easeInOut"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:6,modelOverrides:{"bubble-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:2},orientationOverride:"camera"}}}}],wobbleFrequency:6,wobbleAmplitude:.018,wobbleDecay:.4,scaleWobble:.035,scaleFrequency:7,scaleGrowth:.015,glowColor:[.35,.65,1],glowIntensityMin:1.2,glowIntensityMax:2.2,glowPulseRate:6}),Br=Rr({name:"drench",emoji:"🌊",type:"blending",description:"Expanding water shockwave",duration:1e3,beats:2,intensity:1,category:"impact",turbulence:.4,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.2,endScale:2.5,startDiameter:.3,endDiameter:2.5,orientation:"camera"},formation:{type:"stack",count:1,spacing:0},count:1,scale:1.2,models:["splash-ring"],animation:{appearAt:0,disappearAt:.8,stagger:0,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{turbulence:{start:.5,peak:.3,end:.1,curve:"bell"}},cutout:{strength:.5,primary:{pattern:0,scale:1.3,weight:1},secondary:{pattern:3,scale:.6,weight:.7},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.3,softness:1.4}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},pulse:{amplitude:.05,frequency:2,easing:"easeOut"},blending:"additive",renderOrder:10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.4,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:.8,sizeScale:1,burstCount:20,progressCurve:"burst",velocityInheritance:.4}]}},wobbleFrequency:2,wobbleAmplitude:.01,wobbleDecay:.6,scaleWobble:.01,scaleFrequency:2,scaleGrowth:0,glowColor:[.2,.5,.9],glowIntensityMin:.8,glowIntensityMax:1.3,glowPulseRate:2}),Fr=Rr({name:"soak",emoji:"💧",type:"blending",description:"Contracting water shockwave (reverse drench)",duration:1e3,beats:2,intensity:1,category:"impact",turbulence:.4,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:1.8,endScale:.3,startDiameter:2,endDiameter:.4,orientation:"camera"},formation:{type:"stack",count:1,spacing:0},count:1,scale:1.2,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,stagger:0,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"scale",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{turbulence:{start:.1,peak:.35,end:.5,curve:"bell"}},cutout:{strength:.5,primary:{pattern:0,scale:1.3,weight:1},secondary:{pattern:3,scale:.6,weight:.7},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.3,softness:1.4}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},pulse:{amplitude:.05,frequency:2,easing:"easeIn"},blending:"additive",renderOrder:10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.4,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:null,anchor:"around",intensity:.5,sizeScale:.8,burstCount:12,progressCurve:"burst",velocityInheritance:.3}]}},wobbleFrequency:2,wobbleAmplitude:.01,wobbleDecay:.6,scaleWobble:.01,scaleFrequency:2,scaleGrowth:0,glowColor:[.2,.5,.9],glowIntensityMin:.8,glowIntensityMax:1.3,glowPulseRate:2}),zr=Rr({name:"flow",emoji:"〰️",type:"blending",description:"Gentle river current drifting across",duration:3e3,beats:4,intensity:.7,category:"ambient",turbulence:.2,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:.25,endOffset:.25,easing:"linear",startScale:.7,endScale:1.1,startDiameter:1,endDiameter:1.3,orientation:"camera"},formation:{type:"ring",count:3,phaseOffset:.2},count:3,scale:1,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,stagger:.18,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},drift:{speed:.45,distance:2.2,direction:{x:1,y:.05,z:0},easing:"easeInOut"},cutout:{strength:.5,primary:{pattern:4,scale:1.3,weight:1},secondary:{pattern:1,scale:.6,weight:.35},blend:"multiply",travel:"angular",travelSpeed:1.2,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:1.5,blend:"multiply"},rotate:[{axis:"z",rotations:.25,phase:0},{axis:"z",rotations:-.2,phase:120},{axis:"z",rotations:.3,phase:240}],pulse:{amplitude:.07,frequency:2,easing:"easeInOut"},blending:"additive",renderOrder:8,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.75,arcSpeed:.8,arcCount:2},orientationOverride:"camera"}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:-.2,endOffset:-.2,easing:"linear",startScale:.6,endScale:1,startDiameter:.9,endDiameter:1.2,orientation:"camera"},formation:{type:"ring",count:2,phaseOffset:.25},count:2,scale:.9,models:["wave-curl"],animation:{appearAt:.1,disappearAt:.9,stagger:.2,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},drift:{speed:.4,distance:2,direction:{x:1,y:-.03,z:0},easing:"easeInOut"},cutout:{strength:.45,primary:{pattern:4,scale:1.4,weight:1},secondary:{pattern:1,scale:.7,weight:.3},blend:"multiply",travel:"angular",travelSpeed:1,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:1.5,blend:"multiply"},rotate:[{axis:"z",rotations:-.3,phase:45},{axis:"z",rotations:.25,phase:225}],pulse:{amplitude:.06,frequency:2.5,easing:"easeInOut"},blending:"additive",renderOrder:6,modelOverrides:{"wave-curl":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.2,arcCount:1},orientationOverride:"camera"}}}}],wobbleFrequency:1.5,wobbleAmplitude:.008,wobbleDecay:.3,scaleWobble:.01,scaleFrequency:2,scaleGrowth:.008,glowColor:[.3,.55,.9],glowIntensityMin:.8,glowIntensityMax:1.4,glowPulseRate:2}),Lr=Rr({name:"tide",emoji:"🌊",type:"blending",description:"Single wave with animated tidal cutout",duration:1500,beats:2,intensity:.8,category:"ambient",turbulence:.3,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:0,endOffset:0,easing:"linear",startScale:1,endScale:1,startDiameter:1,endDiameter:1,orientation:"camera"},formation:{type:"ring",count:1,phaseOffset:0},count:1,scale:4.4,models:["wave-curl"],animation:{appearAt:0,disappearAt:.9,stagger:0,enter:{type:"grow",duration:.3,easing:"easeOut"},exit:{type:"fade",duration:.35,easing:"easeIn"},procedural:{scaleSmoothing:.15,geometryStability:!0},cutout:{strength:.55,primary:{pattern:4,scale:1.2,weight:1},secondary:{pattern:0,scale:.6,weight:.25},blend:"multiply",travel:"angular",travelSpeed:-1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:1,blend:"multiply"},rotate:{axis:"z",rotations:-.25,phase:0},pulse:{amplitude:.15,frequency:.6,easing:"easeInOut"},blending:"additive",renderOrder:6,modelOverrides:{"wave-curl":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:.8,arcCount:2},orientationOverride:"camera"}}}},wobbleFrequency:.8,wobbleAmplitude:.005,wobbleDecay:.4,scaleWobble:.008,scaleFrequency:.8,glowColor:[.15,.45,.85],glowIntensityMin:.85,glowIntensityMax:1.4,glowPulseRate:.8}),Gr=Rr({name:"liquefy",emoji:"💧",type:"blending",description:"Dramatic tears falling with dissolve trails",duration:2200,beats:3,intensity:.9,category:"transform",turbulence:.4,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"top",end:"bottom",startOffset:.15,endOffset:-.3,easing:"easeInQuad",startScale:.5,endScale:1.3,startDiameter:.7,endDiameter:1.1,orientation:"camera"},formation:{type:"ring",count:4,phaseOffset:.15},count:4,scale:1.1,models:["droplet-large"],animation:{appearAt:0,disappearAt:.9,stagger:.12,enter:{type:"grow",duration:.12,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.55,primary:{pattern:7,scale:1.3,weight:1},secondary:{pattern:0,scale:.5,weight:.25},blend:"multiply",travel:"vertical",travelSpeed:1.8,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.5,softness:1.8}},grain:{type:3,strength:.25,scale:.2,speed:2,blend:"multiply"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:8,modelOverrides:{"droplet-large":{shaderAnimation:{type:3,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"top",end:"bottom",startOffset:.05,endOffset:-.15,easing:"easeInCubic",startScale:.4,endScale:.9,startDiameter:.6,endDiameter:.9,orientation:"camera"},formation:{type:"ring",count:6,phaseOffset:.1},count:6,scale:.6,models:["droplet-small"],animation:{appearAt:.08,disappearAt:.85,stagger:.08,enter:{type:"grow",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.06,geometryStability:!0},cutout:{strength:.5,primary:{pattern:7,scale:1,weight:1},secondary:{pattern:0,scale:.4,weight:.2},blend:"multiply",travel:"vertical",travelSpeed:2.5,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.4,softness:1.2}},grain:{type:3,strength:.2,scale:.15,speed:2.5,blend:"multiply"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.25,lifetimeVariance:.2,blending:"additive",renderOrder:10,modelOverrides:{"droplet-small":{shaderAnimation:{type:3,arcWidth:.98,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}}],wobbleFrequency:2,wobbleAmplitude:.006,wobbleDecay:.2,scaleWobble:.02,scaleFrequency:3,glowColor:[.25,.5,.9],glowIntensityMin:.9,glowIntensityMax:1.6,glowPulseRate:3}),Vr=Rr({name:"pool",emoji:"🫗",type:"blending",description:"Submerging sensation with contracting water rings",duration:2800,beats:4,intensity:.7,category:"transform",turbulence:.2,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:.35,endOffset:.35,easing:"easeInOutQuad",startScale:1.4,endScale:.5,startDiameter:3.2,endDiameter:.6,orientation:"flat"},formation:{type:"ring",count:1},count:1,scale:1,models:["splash-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.12,geometryStability:!0},cutout:{strength:.5,primary:{pattern:4,scale:1.6,weight:1},secondary:{pattern:0,scale:.6,weight:.35},blend:"multiply",travel:"radial",travelSpeed:-.8,strengthCurve:"fadeIn"},grain:{type:3,strength:.25,scale:.3,speed:.8,blend:"multiply"},rotate:{axis:"y",rotations:.15,phase:0},pulse:{amplitude:.05,frequency:1.5,easing:"easeInOut"},blending:"additive",renderOrder:5,modelOverrides:{"splash-ring":{shaderAnimation:{type:5,arcWidth:.85,arcSpeed:.4,arcCount:2}}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:0,endOffset:0,easing:"easeInOutQuad",startScale:1.5,endScale:.4,startDiameter:3.5,endDiameter:.5,orientation:"flat"},formation:{type:"ring",count:1},count:1,scale:1.1,models:["splash-ring"],animation:{appearAt:.05,disappearAt:.9,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.12,geometryStability:!0},cutout:{strength:.55,primary:{pattern:4,scale:1.5,weight:1},secondary:{pattern:0,scale:.7,weight:.4},blend:"multiply",travel:"radial",travelSpeed:-1,strengthCurve:"fadeIn"},grain:{type:3,strength:.25,scale:.3,speed:1,blend:"multiply"},rotate:{axis:"y",rotations:-.12,phase:45},pulse:{amplitude:.06,frequency:1.5,easing:"easeInOut"},blending:"additive",renderOrder:6,modelOverrides:{"splash-ring":{shaderAnimation:{type:5,arcWidth:.9,arcSpeed:.5,arcCount:2}}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",startOffset:-.35,endOffset:-.35,easing:"easeInOutQuad",startScale:1.3,endScale:.5,startDiameter:3,endDiameter:.7,orientation:"flat"},formation:{type:"ring",count:1},count:1,scale:.95,models:["splash-ring"],animation:{appearAt:.1,disappearAt:.85,enter:{type:"fade",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.12,geometryStability:!0},cutout:{strength:.5,primary:{pattern:4,scale:1.4,weight:1},secondary:{pattern:0,scale:.6,weight:.35},blend:"multiply",travel:"radial",travelSpeed:-.9,strengthCurve:"fadeIn"},grain:{type:3,strength:.25,scale:.3,speed:.8,blend:"multiply"},rotate:{axis:"y",rotations:.18,phase:90},pulse:{amplitude:.05,frequency:1.5,easing:"easeInOut"},blending:"additive",renderOrder:4,modelOverrides:{"splash-ring":{shaderAnimation:{type:5,arcWidth:.85,arcSpeed:.4,arcCount:2}}}}},{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"center",startOffset:-.2,endOffset:.3,easing:"easeOutQuad",startScale:.3,endScale:.8,startDiameter:.8,endDiameter:1.2,orientation:"camera"},formation:{type:"ring",count:4,phaseOffset:.15},count:4,scale:.5,models:["bubble-cluster"],animation:{appearAt:.15,disappearAt:.8,stagger:.1,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},cutout:{strength:.4,primary:{pattern:0,scale:1,weight:1},blend:"multiply",travel:"angular",travelSpeed:.8,strengthCurve:"constant"},grain:{type:3,strength:.15,scale:.25,speed:1.5,blend:"multiply"},pulse:{amplitude:.1,frequency:3,easing:"easeInOut"},blending:"additive",renderOrder:8,modelOverrides:{"bubble-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.6,arcCount:2},orientationOverride:"camera"}}}}],wobbleFrequency:1.5,wobbleAmplitude:.01,wobbleDecay:.35,scaleWobble:.012,scaleFrequency:1.5,glowColor:[.2,.45,.8],glowIntensityMin:.7,glowIntensityMax:1.3,glowPulseRate:1.5}),Nr=Rr({name:"watervortex",emoji:"🌀",type:"blending",description:"Water tornado spiraling around mascot",duration:1500,beats:5,intensity:1.4,category:"transform",turbulence:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.7,startDiameter:.6,endDiameter:2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["splash-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.1},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.85,end:.5,curve:"bell"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:12,intensityScaling:{scale:1.4,pulseAmplitude:1.3},modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:6,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}},atmospherics:[{preset:"spray",targets:null,anchor:"around",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.6,centrifugal:{speed:1.2,tangentialBias:.3}}]}},wobbleFrequency:4,wobbleAmplitude:.015,wobbleDecay:.2,glowColor:[.2,.55,1],glowIntensityMin:1.2,glowIntensityMax:2.2,glowPulseRate:6,scaleWobble:.02,scaleFrequency:4,scaleGrowth:.03}),jr=Rr({name:"watercrown",emoji:"👑",type:"blending",description:"Majestic water crown above the head",duration:3e3,beats:4,intensity:1,category:"ambient",turbulence:.2,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.1,z:0},orientation:"flat",bob:{amplitude:.025,frequency:.3}},count:1,scale:2,models:["splash-ring"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{turbulence:{start:.1,peak:.25,end:.15,curve:"bell"}},pulse:{amplitude:.06,frequency:2,easing:"easeInOut"},rotate:{axis:"z",rotations:1,phase:0},scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:15,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.8,arcCount:3}}}}},wobbleFrequency:1.5,wobbleAmplitude:.005,wobbleDecay:.3,scaleWobble:.008,scaleFrequency:2,scaleGrowth:.01,glowColor:[.3,.6,1],glowIntensityMin:.9,glowIntensityMax:1.4,glowPulseRate:3}),qr=Rr({name:"waterdance",emoji:"💃",type:"blending",description:"Vertical splash rings dancing and rising",duration:1500,beats:3,intensity:1.3,category:"ambient",turbulence:.4,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.8,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["splash-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.7,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.5},blend:"multiply",travel:"angular",travelSpeed:.3,strengthCurve:"fadeIn",fadeInDuration:.167,trailDissolve:{enabled:!0,offset:-.8,softness:2}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},parameterAnimation:{turbulence:{start:.2,peak:.45,end:.25,curve:"bell"}},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:11,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}]}},wobbleFrequency:3,wobbleAmplitude:.01,wobbleDecay:.2,scaleWobble:.018,scaleFrequency:4,scaleGrowth:.025,glowColor:[.25,.55,.95],glowIntensityMin:1.2,glowIntensityMax:2.5,glowPulseRate:6,rotationFlow:.02}),Ur=Rr({name:"waterdrill",emoji:"🔩",type:"blending",description:"Fast tight descending water helix",duration:1200,beats:2,intensity:1.5,category:"transform",turbulence:.6,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:.8,models:["splash-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{turbulence:{start:.3,peak:.7,end:.5,curve:"bell"}},cutout:{strength:.55,primary:{pattern:6,scale:1.5,weight:1},secondary:{pattern:1,scale:.8,weight:.35},blend:"add",travel:"vertical",travelSpeed:3,strengthCurve:"constant"},grain:{type:3,strength:.3,scale:.2,speed:4,blend:"multiply"},pulse:{amplitude:.08,frequency:10,easing:"linear"},rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}]}},wobbleFrequency:8,wobbleAmplitude:.01,wobbleDecay:.15,scaleWobble:.02,scaleFrequency:8,scaleGrowth:.03,glowColor:[.2,.5,1],glowIntensityMin:1.3,glowIntensityMax:2.8,glowPulseRate:10,rotationFlow:.05}),Wr=Rr({name:"waterhelix",emoji:"🧬",type:"blending",description:"DNA-style double helix ascending water",duration:2e3,beats:4,intensity:1.2,category:"ambient",turbulence:.35,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.9,endScale:1.1,startDiameter:1.8,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:.7,models:["splash-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{turbulence:{start:.2,peak:.4,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:6,scale:1.3,weight:1},secondary:{pattern:0,scale:.7,weight:.3},blend:"multiply",travel:"vertical",travelSpeed:1.2,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.4,softness:1}},grain:{type:3,strength:.2,scale:.25,speed:1.5,blend:"multiply"},pulse:{amplitude:.08,frequency:3,easing:"easeInOut"},rotate:{axis:"y",rotations:2.5,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}]}},wobbleFrequency:2,wobbleAmplitude:.008,wobbleDecay:.2,scaleWobble:.015,scaleFrequency:3,scaleGrowth:.02,glowColor:[.3,.55,.9],glowIntensityMin:1.1,glowIntensityMax:2.2,glowPulseRate:4,rotationFlow:.015}),Hr=Rr({name:"watermeditation",emoji:"🧘",type:"blending",description:"Meditative water rings with breathing pulse",duration:4e3,beats:4,intensity:.5,category:"ambient",turbulence:.1,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"easeInOut",startScale:1.3,endScale:1.3,startDiameter:2.2,endDiameter:2.2,orientation:"camera"},formation:{type:"mandala",count:3,radius:.5,arcOffset:60,scales:[1,.7,.7]},count:3,scale:1.8,models:["splash-ring"],animation:{appearAt:0,disappearAt:.8,stagger:0,enter:{type:"fade",duration:.5,easing:"easeInOut"},exit:{type:"fade",duration:.4,easing:"easeInOut"},procedural:{scaleSmoothing:.15,geometryStability:!0},parameterAnimation:{turbulence:{start:.05,peak:.12,end:.08,curve:"sine"}},cutout:{strength:.6,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.5},blend:"multiply",travel:"angular",travelSpeed:.5,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.5,softness:1.8}},grain:{type:3,strength:.15,scale:.3,speed:.8,blend:"multiply"},pulse:{amplitude:.15,frequency:1.5,easing:"easeInOut"},rotate:[{axis:"z",rotations:.4,phase:0},{axis:"z",rotations:-.35,phase:0},{axis:"z",rotations:.3,phase:0}],scaleVariance:0,lifetimeVariance:0,blending:"additive",renderOrder:-5,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.5,arcCount:2},orientationOverride:"camera"}}}},wobbleFrequency:1,wobbleAmplitude:.003,wobbleDecay:.5,scaleWobble:.004,scaleFrequency:1.5,scaleGrowth:0,glowColor:[.3,.6,.9],glowIntensityMin:.7,glowIntensityMax:1.1,glowPulseRate:1.5});const $r={appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"burst-fade",duration:.4,easing:"easeIn",burstScale:1.2,burstDirection:"up"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{turbulence:{start:.15,peak:.3,end:.2,curve:"bell"}},pulse:{amplitude:.08,frequency:3,easing:"easeInOut",perElement:!0,phaseOffset:30},grain:{type:3,strength:.3,scale:.35,speed:.6,blend:"multiply"},drift:{speed:.15,distance:.08,direction:{x:0,y:1,z:0},easing:"easeOut"},tilt:{axis:"x",oscillate:!0,range:.08,speed:1.5,perElement:!0,phaseOffset:15},scaleVariance:.03,lifetimeVariance:.02,blending:"normal",renderOrder:15,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.8,arcCount:3}}},atmospherics:[{preset:"spray",targets:["splash-ring"],anchor:"above",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5}]};var Yr=Rr({name:"waterpillar",emoji:"🏛️",type:"blending",description:"Majestic rising pillar of water",duration:3e3,beats:4,intensity:1.3,category:"ambient",turbulence:.25,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:0},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["splash-ring"],animation:{...$r,stagger:.03,cutout:{strength:.55,primary:{pattern:4,scale:1.4,weight:1},secondary:{pattern:0,scale:.8,weight:.35},blend:"multiply",travel:"angular",travelSpeed:1,strengthCurve:"fadeIn",fadeInDuration:.3,trailDissolve:{enabled:!0,offset:-.5,softness:1.2}},rotate:[{axis:"z",rotations:.3,phase:0},{axis:"z",rotations:.3,phase:180}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:.5},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["splash-ring"],animation:{...$r,stagger:.05,cutout:{strength:.6,primary:{pattern:0,scale:1.2,weight:1},secondary:{pattern:1,scale:1.5,weight:.5},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,trailDissolve:{enabled:!0,offset:-.4,softness:1}},rotate:[{axis:"z",rotations:-.5,phase:60},{axis:"z",rotations:-.5,phase:240}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:1},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["splash-ring"],animation:{...$r,stagger:.07,cutout:{strength:.65,primary:{pattern:1,scale:1.8,weight:1},secondary:{pattern:7,scale:1.5,weight:.4},blend:"add",travel:"oscillate",travelSpeed:2,strengthCurve:"fadeOut",fadeOutDuration:.4,trailDissolve:{enabled:!0,offset:-.3,softness:.8}},rotate:[{axis:"z",rotations:.7,phase:90},{axis:"z",rotations:.7,phase:270}]}}],wobbleFrequency:1.5,wobbleAmplitude:.005,wobbleDecay:.3,scaleWobble:.008,scaleFrequency:2,scaleGrowth:.025,glowColor:[.25,.55,.9],glowIntensityMin:1,glowIntensityMax:2,glowPulseRate:3}),Xr=Rr({name:"waterflourish",emoji:"🔱",type:"blending",description:"Spinning water flourish with wave trails",duration:1200,beats:4,intensity:1.3,category:"ambient",turbulence:.5,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:5,spacing:0,arcOffset:72,phaseOffset:.05,zOffset:0},count:5,scale:.9,models:["splash-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{turbulence:{start:.35,peak:.7,end:.2,curve:"bell"}},cutout:{strength:.6,primary:{pattern:0,scale:1,weight:1},secondary:{pattern:3,scale:.6,weight:.5},blend:"multiply",strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.6,softness:1.5}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.9,.8,.7,.6],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"z",rotations:1.8,phase:144},{axis:"z",rotations:-2.3,phase:216},{axis:"z",rotations:2,phase:288}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:-8,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:["splash-ring"],anchor:"above",intensity:.25,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4}]}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:.7,models:["splash-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:0,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:-45}],blending:"additive",renderOrder:-6,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:.7,models:["splash-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:1,scale:1,weight:1},secondary:{pattern:0,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:45}],blending:"additive",renderOrder:-6,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:.9,models:["splash-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"normal",renderOrder:-10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:.9,models:["splash-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:0,scale:.8,weight:1},secondary:{pattern:1,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"normal",renderOrder:-10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],wobbleFrequency:2,wobbleAmplitude:.01,wobbleDecay:.15,glowColor:[.3,.6,1],glowIntensityMin:1,glowIntensityMax:2,glowPulseRate:6,scaleWobble:.012,scaleFrequency:8,scaleGrowth:.015}),Qr=Rr({name:"waterbarrage",emoji:"🏹",type:"blending",description:"Water orbits mascot then launches upward",duration:1500,beats:4,intensity:1.4,category:"transform",turbulence:.6,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.4,models:["droplet-small","droplet-large","bubble-cluster","wave-curl"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{turbulence:{start:.4,peak:.7,end:.3,curve:"fadeOut"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"normal",renderOrder:12,atmospherics:[{preset:"spray",targets:null,anchor:"around",intensity:.5,sizeScale:.8,burstCount:12,progressCurve:"burst",velocityInheritance:.7}]}},wobbleFrequency:10,wobbleAmplitude:.012,glowColor:[.2,.5,1],glowIntensityMin:1.2,glowIntensityMax:2,glowPulseRate:8,scaleWobble:.015,scaleFrequency:4,scaleGrowth:.02}),Kr=Rr({name:"waterimpact",emoji:"💥",type:"blending",description:"Water orbits then crashes inward with impact",duration:1500,beats:4,intensity:1.5,category:"transform",turbulence:.8,spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:3.5,endRadius:.1,speed:3,easing:"easeOut",startScale:.4,endScale:1.8,orientation:"vertical"},formation:{type:"ring",count:7},count:7,scale:1.4,models:["bubble-cluster","wave-curl"],animation:{appearAt:0,disappearAt:.6,stagger:.02,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.05,easing:"easeOut",burstScale:.2},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{turbulence:{start:.3,peak:.9,end:.85,curve:"fadeIn"}},pulse:{amplitude:.12,frequency:8,easing:"easeInOut"},emissive:{min:1,max:3,frequency:9,pattern:"sine"},rotate:[{axis:"z",rotations:-4,phase:0},{axis:"x",rotations:3.5,phase:50},{axis:"y",rotations:-3,phase:100},{axis:"z",rotations:4,phase:155},{axis:"x",rotations:-3.5,phase:210},{axis:"y",rotations:3,phase:260},{axis:"z",rotations:-4.5,phase:315}],scaleVariance:.2,lifetimeVariance:.08,blending:"normal",renderOrder:12,atmospherics:[{preset:"spray",targets:null,anchor:"around",intensity:.8,sizeScale:1,burstCount:15,progressCurve:"burst",velocityInheritance:.7}]}},wobbleFrequency:12,wobbleAmplitude:.018,glowColor:[.15,.45,1],glowIntensityMin:1.6,glowIntensityMax:2.8,glowPulseRate:12,scaleWobble:.025,scaleFrequency:6,scaleContract:.05,tremor:.018,tremorFrequency:9}),Zr=Rr({name:"watercrush",emoji:"🌊",type:"blending",description:"Walls of water crushing inward on mascot",duration:1200,beats:2,intensity:1.4,category:"impact",turbulence:.7,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"center",easing:"linear",startScale:2.2,endScale:.3,startDiameter:2.5,endDiameter:.5,orientation:"camera"},formation:{type:"stack",count:3,spacing:.35},count:3,scale:1.4,models:["splash-ring"],animation:{appearAt:0,disappearAt:.75,stagger:.06,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.1,easing:"easeIn",burstScale:.3},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{turbulence:{start:.3,peak:.8,end:.9,curve:"fadeIn"}},cutout:{strength:.5,primary:{pattern:0,scale:1.3,weight:1},secondary:{pattern:3,scale:.6,weight:.6},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"fadeIn",trailDissolve:{enabled:!0,offset:-.3,softness:1.4}},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},pulse:{amplitude:.08,frequency:4,easing:"easeInOut"},blending:"additive",renderOrder:10,modelOverrides:{"splash-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.4,arcCount:1},orientationOverride:"camera"}},atmospherics:[{preset:"spray",targets:null,anchor:"above",intensity:1,sizeScale:1.2,burstCount:30,progressCurve:"burst",velocityInheritance:.4}]}},{type:"radial-burst",radialBurst:{count:6,radius:.05,endRadius:.5,angleSpread:360,startAngle:0,orientation:"camera",startScale:.15,endScale:.7,scaleEasing:"easeOutQuad"},count:6,scale:.5,models:["bubble-cluster"],animation:{appearAt:.35,disappearAt:.75,stagger:.01,enter:{type:"scale",duration:.04,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:0,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:12,modelOverrides:{"bubble-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}}],wobbleFrequency:4,wobbleAmplitude:.025,wobbleDecay:.3,scaleWobble:.03,scaleFrequency:3,scaleContract:.06,glowColor:[.1,.35,.9],glowIntensityMin:1,glowIntensityMax:2,glowPulseRate:4,tremor:.015,tremorFrequency:8});function Jr(e){return(43758.5453*Math.sin(e)%1+1)%1}function eo(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return Jr(t)*(1-a)+Jr(t+1)*a}function to(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:1.8,offBeat:1,curve:"radiating"===e.category?"smooth":"sharp"}},"3d":{evaluate(t,i){const a=e["3d"]?.evaluate,n=a?a(t,i):null,s={...e,...i},r=t*s.duration/1e3,o="radiating"===s.category;let l=1;if(s.buildupPhase&&t<s.buildupPhase&&(l=t/s.buildupPhase,l=Math.pow(l,1.5)),s.burstPhase&&t>=s.buildupPhase){const e=(t-s.buildupPhase)/s.burstPhase;l=e<.3?1+3.33*e:2*(1-(e-.3)/.7)}t>1-s.flickerDecay&&(l*=1-(t-(1-s.flickerDecay))/s.flickerDecay);let c=0,h=0,u=0;if(s.flickerAmplitude>0){const e=r*s.flickerFrequency;if(c=(eo(e)-.5+.4*(eo(2.1*e+50)-.5))*s.flickerAmplitude*l,h=(eo(e+33)-.5+.5*(eo(1.8*e+83)-.5))*s.flickerAmplitude*l,u=(eo(e+66)-.5)*s.flickerAmplitude*l*.5,s.burstJitter&&t>=s.buildupPhase){const e=l>1?l:0;c+=(eo(50*r)-.5)*s.burstJitter*e,h+=(eo(50*r+100)-.5)*s.burstJitter*e,u+=(eo(50*r+200)-.5)*s.burstJitter*e*.5}}s.riseAmount&&(h+=s.riseAmount*l),s.hover&&s.hoverAmount&&(h+=Math.sin(r*Math.PI*.5)*s.hoverAmount*l);let d=1;const m=r*s.scaleFrequency;if(s.scalePulse?(d=1+(.5*Math.sin(m*Math.PI*2)+.5)*s.scaleVibration*l,s.scaleGrowth&&(d+=s.scaleGrowth*l)):d=1+(.5*Math.sin(m*Math.PI*2)+.3*Math.sin(m*Math.PI*3.3))*s.scaleVibration*l,s.heatExpansion&&(d+=s.heatExpansion*l),s.scaleBurst&&t>=s.buildupPhase){const e=l>1?l-1:0;d+=s.scaleBurst*e}const p=r*s.glowFlickerRate;let g;g=o?.3*Math.sin(p*Math.PI*2)+.7:.3*Math.sin(p*Math.PI*2)+.2*Math.sin(p*Math.PI*4.7+1.3)+.4*(Jr(Math.floor(3*p))>.6?1:0)+.5;const f=s.glowIntensityMin+(s.glowIntensityMax-s.glowIntensityMin)*g*l,y=(.7*g+.3)*l*s.intensity,v=n?.rotation||[0,0,0];return{position:[c,h,u],rotation:[v[0]||0,v[1]||0,v[2]||0],scale:d,glowIntensity:f,glowBoost:y,glowColorOverride:s.glowColor,fireOverlay:{enabled:l>.1,strength:l*s.intensity,heat:l*s.intensity,temperature:s.temperature,category:s.category,spawnMode:s.spawnMode||null,duration:s.duration,progress:t,time:r,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth}}}}}}var io=to({name:"burn",emoji:"🔥",type:"blending",description:"Flames flickering across surface, being consumed",duration:2500,beats:4,intensity:1,category:"burning",temperature:.6,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.15,cameraFacing:.3,clustering:.25,count:8,scale:1.25,models:["flame-wisp","flame-tongue"],minDistance:.12,animation:{appearAt:.05,disappearAt:.85,stagger:.03,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.08,geometryStability:!0},gestureGlow:{baseGlow:.8,peakGlow:2.5,curve:"easeIn"},parameterAnimation:{temperature:{start:.4,peak:.65,end:.35,curve:"bell"}},flicker:{intensity:.35,rate:12,pattern:"random"},pulse:{amplitude:.15,frequency:8,easing:"easeInOut"},emissive:{min:.8,max:2,frequency:10,pattern:"sine"},cutout:{strength:.7,primary:{pattern:5,scale:2,weight:1},secondary:{pattern:4,scale:1.5,weight:.5},blend:"multiply",travel:"radial",travelSpeed:2.5,strengthCurve:"fadeIn",fadeInDuration:.4,trailDissolve:{offset:-.15,softness:.3},geometricMask:{type:"distance",core:.08,tip:.18}},grain:{type:3,strength:.04,scale:.1,speed:.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],drift:{direction:"up",distance:.12,noise:.025},scaleVariance:.35,lifetimeVariance:.3,delayVariance:.1,blending:"additive",renderOrder:10,intensityScaling:{scale:1.3,pulseAmplitude:1.5,flickerIntensity:1.4,emissiveMax:1.6},modelOverrides:{"ember-cluster":{scaling:{mode:"uniform-pulse",amplitude:.2,frequency:4},drift:{direction:"rising",speed:.025,noise:.25,buoyancy:!0},opacityLink:"flicker"},"flame-wisp":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.7},y:{expand:!0,rate:1.6},z:{expand:!1,rate:.7}}},drift:{direction:"rising",speed:.03,noise:.15,buoyancy:!0},orientationOverride:"rising"},"flame-tongue":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.8,oscillate:!0},y:{expand:!0,rate:1.4},z:{expand:!1,rate:.8,oscillate:!0}},wobbleFrequency:5,wobbleAmplitude:.15},drift:{direction:"rising",speed:.025,noise:.2}}}}},flickerFrequency:12,flickerAmplitude:.015,flickerDecay:.2,glowColor:[1,.5,.1],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:15,scaleVibration:.02,scaleFrequency:8,riseAmount:.01}),ao=to({name:"scorch",emoji:"🫠",type:"blending",description:"Core meltdown, internal heat escaping",duration:1200,beats:3,intensity:1.3,category:"burning",temperature:.8,spawnMode:{type:"surface",pattern:"shell",embedDepth:.1,cameraFacing:.3,clustering:.2,count:12,scale:.9,models:["flame-wisp","ember-cluster"],minDistance:.12,animation:{appearAt:.05,disappearAt:.85,stagger:.03,enter:{type:"fade",duration:.12,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.8,end:.4,curve:"sustained"}},flicker:{intensity:.3,rate:12,pattern:"random"},emissive:{min:1.5,max:3,frequency:6,pattern:"sine"},cutout:{strength:.55,primary:{pattern:7,scale:1.5,weight:1},secondary:{pattern:5,scale:1.2,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,trailDissolve:{offset:-.1,softness:.25}},grain:{type:3,strength:.08,scale:.2,speed:.8,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain"}],drift:{speed:.3,distance:.3,direction:{x:0,y:1,z:0},easing:"easeOutCubic"},scaleVariance:.25,lifetimeVariance:.2,blending:"additive",renderOrder:12}},flickerFrequency:6,flickerAmplitude:.008,flickerDecay:.25,glowColor:[1,.8,.3],glowIntensityMin:1.5,glowIntensityMax:3.5,glowFlickerRate:8,scaleVibration:.01,scaleFrequency:3,heatExpansion:.03,shimmerEffect:!0,shimmerIntensity:.02}),no=to({name:"combust",emoji:"💥",type:"blending",description:"Building heat then sudden flame burst",duration:2e3,beats:4,intensity:1.5,category:"burning",temperature:.9,spawnMode:{type:"surface",pattern:"spikes",embedDepth:.1,cameraFacing:.35,clustering:.3,count:12,scale:1.2,models:["fire-burst","flame-tongue","ember-cluster"],minDistance:.08,animation:{appearAt:.55,disappearAt:.95,stagger:.01,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeInCubic"},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.95,end:.6,curve:"spike"}},flicker:{intensity:.5,rate:25,pattern:"random"},pulse:{amplitude:.25,frequency:15,easing:"easeOut"},emissive:{min:1.5,max:4,frequency:20,pattern:"sine"},cutout:{strength:.75,primary:{pattern:3,scale:2.5,weight:1},secondary:{pattern:8,scale:2,weight:.6},blend:"multiply",travel:"radial",travelSpeed:6,strengthCurve:"fadeIn",fadeInDuration:.15,geometricMask:{type:"tip-boost",core:0,tip:.2}},grain:{type:2,strength:.15,scale:.1,speed:4,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain"}],drift:{direction:"outward",distance:.15,noise:.02},scaleVariance:.4,lifetimeVariance:.25,delayVariance:.05,blending:"additive",renderOrder:15,intensityScaling:{scale:1.5,emissiveMax:2,flickerIntensity:1.6,driftSpeed:1.4},scalePerElement:[1,.5,1.3,.6,1.5,.4,1.2,.7,1.4,.55,1.1,.65],modelOverrides:{"fire-burst":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.8},y:{expand:!0,rate:2},z:{expand:!0,rate:1.8}}},drift:{direction:"outward",speed:.06,noise:.15},opacityLink:"inverse-scale"},"flame-tongue":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.4,oscillate:!0},y:{expand:!0,rate:1.6},z:{expand:!0,rate:1.4,oscillate:!0}},wobbleFrequency:8,wobbleAmplitude:.2},drift:{direction:"outward",speed:.04,noise:.1}},"ember-cluster":{drift:{direction:"outward",speed:.05,noise:.3},opacityLink:"flicker"}}}},buildupPhase:.6,burstPhase:.4,flickerFrequency:20,flickerAmplitude:.025,flickerDecay:.15,glowColor:[1,.6,.2],glowIntensityMin:.8,glowIntensityMax:4,glowFlickerRate:25,scaleVibration:.03,scaleFrequency:15,scaleBurst:.08,burstJitter:.03}),so=to({name:"radiate",emoji:"☀️",type:"blending",description:"Expanding flame rings radiating outward",duration:1500,beats:4,intensity:.8,category:"radiating",temperature:.4,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"bottom",easing:"linear",startScale:1.2,endScale:1.8,startDiameter:1.2,endDiameter:3.5,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["flame-ring"],animation:{appearAt:.02,disappearAt:.85,stagger:.03,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.13,easing:"easeOutQuad"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.7,peak:.6,end:.35,curve:"linear"}},flicker:{intensity:.25,rate:10,pattern:"smooth"},pulse:{amplitude:.12,frequency:3,easing:"easeInOut"},emissive:{min:1.2,max:2.8,frequency:4,pattern:"sine"},cutout:{strength:.6,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:6,scale:1.5,weight:.4},blend:"add",travel:"radial",travelSpeed:2,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.05,scale:.15,speed:1,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain"}],rotate:[{axis:"y",rotations:1.5,phase:0},{axis:"y",rotations:1.5,phase:120},{axis:"y",rotations:1.5,phase:240}],scaleVariance:.1,lifetimeVariance:.05,blending:"additive",renderOrder:8,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.8,arcSpeed:.8,arcCount:1},orientationOverride:"vertical"}}}},{type:"radial-burst",radialBurst:{startRadius:.1,endRadius:1.2,height:0,easing:"easeOutExpo"},formation:{type:"ring",count:6,startAngle:0},count:6,scale:1,models:["flame-tongue","fire-burst","flame-tongue","fire-burst","flame-tongue","fire-burst"],animation:{appearAt:.45,disappearAt:.8,stagger:.02,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.2,easing:"easeInCubic",burstScale:1.3},procedural:{scaleSmoothing:.06,geometryStability:!0},parameterAnimation:{temperature:{start:.7,peak:.95,end:.5,curve:"bell"}},flicker:{intensity:.4,rate:18,pattern:"random"},pulse:{amplitude:.15,frequency:8,easing:"easeOut"},emissive:{min:2,max:4,frequency:10,pattern:"sine"},cutout:{strength:.7,primary:{pattern:2,scale:2.5,weight:1},secondary:{pattern:5,scale:1.5,weight:.6},blend:"multiply",travel:"radial",travelSpeed:4,geometricMask:{type:"tip-boost",core:0,tip:.15}},scalePerElement:[1,.8,1.1,.75,.95,.85],blending:"additive",renderOrder:12}}],flickerFrequency:8,flickerAmplitude:.01,flickerDecay:.2,glowColor:[1,.7,.3],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.015,scaleFrequency:3,scaleGrowth:.02,rotationEffect:!0,rotationSpeed:.3}),ro=to({name:"blaze",emoji:"🔆",type:"blending",description:"Flagship fire aura with pulsing flame star",duration:1800,beats:3,intensity:1.3,category:"radiating",temperature:.75,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"center",easing:"easeOut",startScale:1,endScale:.7,startDiameter:.8,endDiameter:1.4,orientation:"radial"},formation:{type:"spiral",count:6,spacing:.15,arcOffset:60,phaseOffset:0},count:6,scale:3,models:["ember-cluster","flame-wisp","ember-cluster","ember-cluster","flame-wisp","flame-wisp"],animation:{appearAt:0,disappearAt:.75,stagger:.12,staggerExit:.1,enter:{type:"scale",duration:.15,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.18,easing:"easeInCubic",burstScale:1.2},drift:{direction:"up",distance:.4,noise:.25},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.6,peak:.85,end:.5,curve:"bell"}},flicker:{intensity:.6,rate:30,pattern:"random"},pulse:{amplitude:.55,frequency:8,easing:"linear",perElement:!0},emissive:{min:2.5,max:8,frequency:12,pattern:"random"},cutout:{strength:.55,primary:{pattern:7,scale:.8,weight:1},secondary:{pattern:5,scale:1.2,weight:.6},blend:"multiply",travel:"radial",travelSpeed:6,strengthCurve:"bell",bellPeakAt:.6,bellWidth:.4,geometricMask:{type:"tip-boost",core:0,tip:.15}},grain:{type:3,strength:.03,scale:.1,speed:.3,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],rotate:[{axis:"y",rotations:2.3,phase:0},{axis:"y",rotations:-1.7,phase:67},{axis:"y",rotations:3.1,phase:155},{axis:"y",rotations:-2.2,phase:98},{axis:"y",rotations:1.4,phase:233},{axis:"y",rotations:-2.8,phase:301}],scalePerElement:[1.6,.65,1.4,.7,1.5,.68],blending:"additive",renderOrder:16}}],flickerFrequency:4,flickerAmplitude:.008,flickerDecay:.2,glowColor:[1,.55,.12],glowIntensityMin:1.5,glowIntensityMax:3,glowFlickerRate:5,scaleVibration:.015,scaleFrequency:2,scalePulse:!0,scaleGrowth:.03,hover:!0,hoverAmount:.01}),oo=to({name:"flame-vortex",emoji:"🌀",type:"blending",description:"Fire tornado spiraling around mascot",duration:1500,beats:5,intensity:1.4,category:"burning",temperature:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.7,startDiameter:.6,endDiameter:1.2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["flame-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"fade",duration:.12,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.8,end:.6,curve:"bell"}},flicker:{intensity:.4,rate:18,pattern:"random"},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.5,frequency:8,pattern:"sine"},cutout:{strength:.7,primary:{pattern:6,scale:2.5,weight:1},secondary:{pattern:4,scale:1.8,weight:.5},blend:"add",travel:"spiral",travelSpeed:4,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:2,strength:.12,scale:.15,speed:2.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:12,intensityScaling:{scale:1.4,emissiveMax:1.6,pulseAmplitude:1.3},modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:6,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}}}},flickerFrequency:15,flickerAmplitude:.01,flickerDecay:.15,glowColor:[1,.55,.15],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:12,scaleVibration:.02,scaleFrequency:4,scaleGrowth:.03,rotationEffect:!0,rotationSpeed:.5}),lo=to({name:"firedance",emoji:"💃",type:"blending",description:"Vertical flame rings dancing and rising",duration:1500,beats:3,intensity:1.3,category:"radiating",temperature:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.4,endScale:1.8,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["flame-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.75,end:.55,curve:"bell"}},flicker:{intensity:.35,rate:14,pattern:"random"},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},cutout:{strength:.75,primary:{pattern:6,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.6},blend:"add",travel:"spiral",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28}},grain:{type:3,strength:.06,scale:.15,speed:1,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:11,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},flickerFrequency:12,flickerAmplitude:.012,flickerDecay:.15,glowColor:[1,.5,.15],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:10,scaleVibration:.018,scaleFrequency:4,scaleGrowth:.025,rotationEffect:!0,rotationSpeed:.4}),co=to({name:"phoenix",emoji:"🦅",type:"blending",description:"Ascending fire vortex - mixed flames spiral upward in rebirth",duration:4e3,beats:4,intensity:1.7,category:"radiating",temperature:.85,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:1,endScale:1.8,startDiameter:1.8,endDiameter:2.8,orientation:"rising"},formation:{type:"spiral",count:7,strands:2,spacing:.2,arcOffset:51,phaseOffset:.1},count:7,scale:1.1,models:["flame-wisp","ember-cluster","flame-tongue","flame-tongue","flame-tongue","fire-burst","fire-burst"],animation:{appearAt:0,disappearAt:.75,stagger:.08,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.35,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.95,end:.7,curve:"bell"}},flicker:{intensity:.3,rate:12,pattern:"smooth"},pulse:{amplitude:.15,frequency:4,easing:"easeInOut"},emissive:{min:1.2,max:4,frequency:6,pattern:"sine"},cutout:{strength:.65,primary:{pattern:7,scale:1.5,weight:1},secondary:{pattern:5,scale:2,weight:.5},blend:"add",travel:"angular",travelSpeed:2,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"distance",core:.1,tip:.3}},grain:{type:0,strength:.1,scale:.25,speed:1.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],rotate:{axis:"y",rotations:1.5,phase:0},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:14,modelOverrides:{"flame-wisp":{scaleMultiplier:1.2,orientationOverride:"rising"},"ember-cluster":{scaleMultiplier:1,orientationOverride:"rising"},"flame-tongue":{scaleMultiplier:1.4,orientationOverride:"rising"},"fire-burst":{scaleMultiplier:1.3,orientationOverride:"camera"}}}},flickerFrequency:10,flickerAmplitude:.015,flickerDecay:.12,glowColor:[1,.6,.2],glowIntensityMin:1.4,glowIntensityMax:3.5,glowFlickerRate:8,scaleVibration:.02,scaleFrequency:3,scaleGrowth:.04,rotationEffect:!0,rotationSpeed:.35}),ho=to({name:"fireflourish",emoji:"⚔️",type:"blending",description:"Spinning sword flourish with fire trail",duration:1200,beats:4,intensity:1.3,category:"radiating",temperature:.65,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:5,spacing:0,arcOffset:72,phaseOffset:.05,zOffset:.02},count:5,scale:.9,models:["flame-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.65,peak:.95,end:.3,curve:"bell"}},flicker:{intensity:.2,rate:10,pattern:"sine"},pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},emissive:{min:2,max:5,frequency:6,pattern:"sine",decayOnExit:!0,perElementScale:[1,.95,.88,.8,.72]},grain:{type:0,strength:.35,scale:.3,speed:2,blend:"multiply"},atmospherics:[{preset:"smoke",targets:["flame-ring"],anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.4}],cutout:{strength:.85,pattern:6,scale:2.5,travel:"spiral",travelSpeed:2},drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.9,.8,.7,.6],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"z",rotations:1.8,phase:144},{axis:"z",rotations:-2.3,phase:216},{axis:"z",rotations:2,phase:288}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:12,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.8,y:.5,z:.3},orientation:"camera",startScale:.3,endScale:1.4,scaleEasing:"easeOutCubic"},count:1,scale:1,models:["flame-tongue"],animation:{appearAt:.15,disappearAt:.55,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.35,easing:"easeOutQuad"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{temperature:{start:.8,peak:.95,end:.4,curve:"bell"}},flicker:{intensity:.3,rate:15,pattern:"random"},emissive:{min:2.5,max:4.5,frequency:8,pattern:"sine"},drift:{speed:.8,distance:.4,direction:{x:1.2,y:-.8,z:-.2},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:.5,phase:-45}],blending:"additive",renderOrder:14}},{type:"anchor",anchor:{landmark:"center",offset:{x:.8,y:.5,z:.3},orientation:"camera",startScale:.3,endScale:1.4,scaleEasing:"easeOutCubic"},count:1,scale:1,models:["flame-tongue"],animation:{appearAt:.15,disappearAt:.55,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.35,easing:"easeOutQuad"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{temperature:{start:.8,peak:.95,end:.4,curve:"bell"}},flicker:{intensity:.3,rate:15,pattern:"random"},emissive:{min:2.5,max:4.5,frequency:8,pattern:"sine"},drift:{speed:.8,distance:.4,direction:{x:-1.2,y:-.8,z:-.2},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:.5,phase:45}],blending:"additive",renderOrder:14}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.2},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:.9,models:["flame-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.7,peak:.9,end:.35,curve:"bell"}},flicker:{intensity:.25,rate:12,pattern:"smooth"},emissive:{min:2,max:4,frequency:6,pattern:"sine"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"additive",renderOrder:10,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.2},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:.9,models:["flame-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.7,peak:.9,end:.35,curve:"bell"}},flicker:{intensity:.25,rate:12,pattern:"smooth"},emissive:{min:2,max:4,frequency:6,pattern:"sine"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"additive",renderOrder:10,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],flickerFrequency:15,flickerAmplitude:.01,flickerDecay:.15,glowColor:[1,.55,.15],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:12,scaleVibration:.012,scaleFrequency:8,scaleGrowth:.015,rotationEffect:!1}),uo=to({name:"firecrown",emoji:"👑",type:"blending",description:"Majestic flame crown above the head",duration:3e3,beats:4,intensity:1,category:"radiating",temperature:.65,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.3}},count:1,scale:1.2,models:["flame-ring"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},cutout:{strength:.65,primary:{pattern:5,scale:1.5,weight:1},secondary:{pattern:6,scale:2,weight:.4},blend:"add",travel:"angular",travelSpeed:1.5,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.6,geometricMask:{type:"distance",core:.15,tip:.3}},grain:{type:0,strength:.35,scale:.25,speed:1.5,blend:"multiply"},parameterAnimation:{temperature:{start:.5,peak:.7,end:.6,curve:"bell"}},flicker:{intensity:.15,rate:8,pattern:"sine"},pulse:{amplitude:.06,frequency:2,easing:"easeInOut"},emissive:{min:1.2,max:2,frequency:3,pattern:"sine"},atmospherics:[{preset:"smoke",targets:["flame-ring"],anchor:"above",intensity:.25,sizeScale:.8,progressCurve:"sustain"}],rotate:{axis:"z",rotations:1,phase:0},scaleVariance:0,lifetimeVariance:0,blending:"additive",renderOrder:15,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.8,arcCount:3}}}}},flickerFrequency:6,flickerAmplitude:.006,flickerDecay:.25,glowColor:[1,.7,.3],glowIntensityMin:.9,glowIntensityMax:1.4,glowFlickerRate:5,scaleVibration:.008,scaleFrequency:3,scaleGrowth:.01,rotationEffect:!1}),mo=to({name:"firemeditation",emoji:"🧘",type:"blending",description:"Meditative flame rings with breathing pulse",duration:4e3,beats:4,intensity:.7,category:"radiating",temperature:.5,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"easeInOut",startScale:1,endScale:1,startDiameter:1.8,endDiameter:1.8,orientation:"camera"},formation:{type:"mandala",count:5,radius:.5,arcOffset:45,scales:[1,.6,.6,.6,.6]},count:5,scale:1.2,models:["flame-ring"],animation:{appearAt:0,disappearAt:.8,stagger:0,enter:{type:"fade",duration:.5,easing:"easeInOut"},exit:{type:"fade",duration:.4,easing:"easeInOut"},procedural:{scaleSmoothing:.15,geometryStability:!0},parameterAnimation:{temperature:{start:.4,peak:.55,end:.45,curve:"sine"}},flicker:{intensity:.08,rate:4,pattern:"sine"},pulse:{amplitude:.15,frequency:1.5,easing:"easeInOut"},emissive:{min:.9,max:1.5,frequency:1.5,pattern:"sine"},cutout:{strength:.6,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:6,scale:1.5,weight:.5},blend:"add",travel:"angular",travelSpeed:.6,strengthCurve:"bell",bellPeakAt:.5,bellWidth:1,geometricMask:{type:"distance",core:.1,tip:.3}},grain:{type:2,strength:.5,scale:.5,speed:.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:1,speedScale:.6,progressCurve:"sustain"}],rotate:[{axis:"z",rotations:.4,phase:0},{axis:"z",rotations:-.35,phase:0},{axis:"z",rotations:.25,phase:0},{axis:"z",rotations:-.35,phase:0},{axis:"z",rotations:.4,phase:0}],scaleVariance:0,lifetimeVariance:0,blending:"additive",renderOrder:-5,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.5,arcCount:2},orientationOverride:"camera"}}}},flickerFrequency:4,flickerAmplitude:.004,flickerDecay:.4,glowColor:[1,.65,.3],glowIntensityMin:.7,glowIntensityMax:1.1,glowFlickerRate:3,scaleVibration:.004,scaleFrequency:1.5,scaleGrowth:0,rotationEffect:!1}),po=to({name:"firedrill",emoji:"🔩",type:"blending",description:"Fast tight ascending flame helix",duration:1200,beats:2,intensity:1.5,category:"radiating",temperature:.8,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:.8,models:["flame-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{temperature:{start:.6,peak:.9,end:.7,curve:"bell"}},flicker:{intensity:.4,rate:25,pattern:"random"},pulse:{amplitude:.08,frequency:10,easing:"linear"},emissive:{min:1.5,max:3.5,frequency:12,pattern:"random"},cutout:{strength:.85,primary:{pattern:8,scale:2.5,weight:1},secondary:{pattern:3,scale:3,weight:.7},blend:"multiply",travel:"oscillate",travelSpeed:5,geometricMask:{type:"distance",core:.08,tip:.2},trailDissolve:{offset:.1,softness:.25}},grain:{type:2,strength:.1,scale:.1,speed:3,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:16,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},flickerFrequency:20,flickerAmplitude:.015,flickerDecay:.1,glowColor:[1,.4,.1],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:18,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03,rotationEffect:!0,rotationSpeed:.8});const go={appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{temperature:{start:.55,peak:.8,end:.65,curve:"bell"}},flicker:{intensity:.12,rate:8,pattern:"sine"},pulse:{amplitude:.05,frequency:3,easing:"easeInOut"},emissive:{min:1.3,max:2.5,frequency:4,pattern:"sine"},grain:{type:2,strength:.5,scale:.15,speed:2.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:["flame-ring"],anchor:"above",intensity:.4,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5}],scaleVariance:.03,lifetimeVariance:.02,blending:"additive",renderOrder:15,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.8,arcCount:3}}}};var fo=to({name:"firepillar",emoji:"🏛️",type:"blending",description:"Majestic rising pillar of flame",duration:3e3,beats:4,intensity:1.3,category:"radiating",temperature:.7,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:0},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["flame-ring"],animation:{...go,stagger:.03,cutout:{strength:.6,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:7,scale:1.5,weight:.4},blend:"add",travel:"angular",travelSpeed:1.2,strengthCurve:"fadeIn",fadeInDuration:.3,geometricMask:{type:"distance",core:.1,tip:.25}},rotate:[{axis:"z",rotations:.3,phase:0},{axis:"z",rotations:.3,phase:180}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:.5},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["flame-ring"],animation:{...go,stagger:.05,cutout:{strength:.65,primary:{pattern:7,scale:1.8,weight:1},secondary:{pattern:5,scale:1.5,weight:.5},blend:"multiply",travel:"radial",travelSpeed:1.8,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"tip-boost",core:0,tip:.2}},rotate:[{axis:"z",rotations:-.6,phase:60},{axis:"z",rotations:-.6,phase:240}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:1},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1,models:["flame-ring"],animation:{...go,stagger:.07,cutout:{strength:.7,primary:{pattern:5,scale:1.5,weight:1},secondary:{pattern:6,scale:2,weight:.4},blend:"add",travel:"oscillate",travelSpeed:2.5,strengthCurve:"fadeOut",fadeOutDuration:.4,geometricMask:{type:"distance",core:.15,tip:.3}},rotate:[{axis:"z",rotations:.9,phase:90},{axis:"z",rotations:.9,phase:270}]}}],flickerFrequency:6,flickerAmplitude:.006,flickerDecay:.25,glowColor:[1,.65,.25],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:5,scaleVibration:.008,scaleFrequency:3,scaleGrowth:.025,rotationEffect:!1}),yo=to({name:"firehelix",emoji:"🧬",type:"blending",description:"DNA-style double helix ascending flame",duration:2e3,beats:4,intensity:1.2,category:"radiating",temperature:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.9,endScale:1.1,startDiameter:1.8,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:.7,models:["flame-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.5,peak:.8,end:.6,curve:"bell"}},flicker:{intensity:.25,rate:12,pattern:"smooth"},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:1.2,max:2.5,frequency:6,pattern:"smooth"},cutout:{strength:.8,primary:{pattern:4,scale:2,weight:1},secondary:{pattern:6,scale:1.8,weight:.6},blend:"max",travel:"angular",travelSpeed:3,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:0,strength:.08,scale:.2,speed:1.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"additive",renderOrder:16,modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},flickerFrequency:10,flickerAmplitude:.012,flickerDecay:.15,glowColor:[1,.5,.2],glowIntensityMin:1.1,glowIntensityMax:2.2,glowFlickerRate:8,scaleVibration:.015,scaleFrequency:5,scaleGrowth:.02,rotationEffect:!0,rotationSpeed:.4}),vo=to({name:"firebarrage",emoji:"🏹",type:"blending",description:"Fire orbits mascot then launches upward",duration:1500,beats:4,intensity:1.4,category:"radiating",temperature:.8,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.8,models:["flame-wisp","flame-tongue","ember-cluster"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{temperature:{start:.6,peak:.9,end:.4,curve:"fadeOut"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.25,sizeScale:.6,progressCurve:"sustain",velocityInheritance:.7}],rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"additive",renderOrder:12}},flickerFrequency:14,flickerAmplitude:.012,glowColor:[1,.5,.15],glowIntensityMin:1.2,glowIntensityMax:2,glowFlickerRate:8,scaleVibration:.015,scaleFrequency:4,scaleGrowth:.02}),bo=to({name:"fireimpact",emoji:"💥",type:"blending",description:"Fire orbits then crashes inward with impact",duration:1500,beats:4,intensity:1.5,category:"transform",temperature:.9,spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:3.5,endRadius:.1,speed:3,easing:"easeOut",startScale:.4,endScale:1.8,orientation:"vertical"},formation:{type:"ring",count:7},count:7,scale:1.4,models:["flame-wisp","flame-tongue","ember-cluster","fire-burst"],animation:{appearAt:0,disappearAt:.6,stagger:.02,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.05,easing:"easeOut",burstScale:.2},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{temperature:{start:.4,peak:.95,end:.9,curve:"fadeIn"}},pulse:{amplitude:.12,frequency:8,easing:"easeInOut"},emissive:{min:1,max:3,frequency:9,pattern:"sine"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.7,progressCurve:"sustain",velocityInheritance:.7}],rotate:[{axis:"z",rotations:-4,phase:0},{axis:"x",rotations:3.5,phase:50},{axis:"y",rotations:-3,phase:100},{axis:"z",rotations:4,phase:155},{axis:"x",rotations:-3.5,phase:210},{axis:"y",rotations:3,phase:260},{axis:"z",rotations:-4.5,phase:315}],scaleVariance:.2,lifetimeVariance:.08,blending:"additive",renderOrder:12}},flickerFrequency:18,flickerAmplitude:.018,glowColor:[1,.4,.1],glowIntensityMin:1.6,glowIntensityMax:2.8,glowFlickerRate:12,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.018,tremorFrequency:9}),wo=to({name:"fireblast",emoji:"💥",type:"blending",description:"Explosive fire blast with bursting flames and ember spray",duration:1e3,beats:2,intensity:1.3,category:"impact",temperature:.9,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.2,endScale:2,scaleEasing:"easeOutQuad"},count:1,scale:1.5,models:["flame-ring"],animation:{appearAt:0,disappearAt:.4,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.6,primary:{pattern:2,scale:1.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut",trailDissolve:{enabled:!0,offset:-.25,softness:1.2}},grain:{type:3,strength:.5,scale:.3,speed:1.5,blend:"multiply"},atmospherics:[{preset:"smoke",targets:null,anchor:"above",intensity:.3,sizeScale:.8,progressCurve:"sustain"}],blending:"additive",renderOrder:8,rotate:{axis:"z",rotations:0,phase:0},modelOverrides:{"flame-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1.2,models:["fire-burst"],animation:{appearAt:0,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:5,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.4,distance:.8,direction:{x:0,y:1,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["fire-burst"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.45,primary:{pattern:5,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:-.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["fire-burst"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.45,primary:{pattern:5,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:12,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.85,models:["fire-burst"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:5,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:-.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:11,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.85,models:["fire-burst"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.4,primary:{pattern:5,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:11,modelOverrides:{"fire-burst":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:8,radius:.05,endRadius:.65,angleSpread:360,startAngle:22,orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:8,scale:.6,models:["flame-tongue"],animation:{appearAt:.02,disappearAt:.4,stagger:.008,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.35,primary:{pattern:5,scale:.7,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.3,lifetimeVariance:.15,blending:"additive",renderOrder:14,modelOverrides:{"flame-tongue":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:12,radius:.03,endRadius:.5,angleSpread:360,startAngle:0,orientation:"camera",startScale:.1,endScale:.35,scaleEasing:"easeOutQuad"},count:12,scale:.2,models:["ember-cluster"],animation:{appearAt:.01,disappearAt:.3,stagger:.005,enter:{type:"scale",duration:.02,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.25,primary:{pattern:7,scale:.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.5,lifetimeVariance:.25,blending:"additive",renderOrder:16,modelOverrides:{"ember-cluster":{shaderAnimation:{type:1,arcWidth:.98,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.1,z:.12},orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:1,scale:.7,models:["ember-cluster"],animation:{appearAt:.05,disappearAt:.6,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.5,primary:{pattern:5,scale:1.2,weight:1},blend:"multiply",travel:"radial",travelSpeed:.5,strengthCurve:"constant"},pulse:{amplitude:.1,frequency:8,easing:"easeInOut"},rotate:{axis:"z",rotations:0,phase:0},blending:"additive",renderOrder:6,modelOverrides:{"ember-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:2},orientationOverride:"camera"}}}}],flickerFrequency:14,flickerAmplitude:.02,flickerDecay:.4,scaleVibration:.035,scaleFrequency:7,scaleGrowth:.015,glowColor:[1,.5,.15],glowIntensityMin:1.2,glowIntensityMax:2.5,glowFlickerRate:10});const Mo={puff:{name:"puff",emoji:"💨",type:"blending",description:"Quick burst of smoke puff",duration:1500,beats:2,intensity:1,category:"emanating",density:.4,riseSpeed:.02,riseAcceleration:.5,decayRate:.3,tint:[.95,.93,.9],windDir:[.1,0],swirl:0,glowColor:[.7,.7,.75],glowIntensityMin:.9,glowIntensityMax:1.1,glowFlickerRate:5,scaleVibration:.01,scaleFrequency:4,scalePulse:!0,scaleBurst:.05},billow:{name:"billow",emoji:"🌫️",type:"blending",description:"Rolling clouds of smoke rising slowly",duration:3500,beats:5,intensity:.8,category:"emanating",density:.6,riseSpeed:.008,riseAcceleration:.2,decayRate:.2,tint:[.85,.85,.87],windDir:[.05,.03],swirl:.15,turbulenceAmount:.015,turbulenceSpeed:2,glowColor:[.6,.6,.65],glowIntensityMin:.85,glowIntensityMax:1,glowFlickerRate:3,scaleVibration:.02,scaleFrequency:1.5,scalePulse:!0,scaleGrowth:.03},fume:{name:"fume",emoji:"♨️",type:"blending",description:"Steady low smoke emission, fuming angrily",duration:4e3,beats:6,intensity:.5,category:"emanating",density:.3,riseSpeed:.005,riseAcceleration:.1,decayRate:.15,tint:[1,.95,.8],windDir:[.02,0],swirl:0,turbulenceAmount:.008,turbulenceSpeed:1.5,glowColor:[.8,.78,.7],glowIntensityMin:.95,glowIntensityMax:1.05,glowFlickerRate:2,scaleVibration:.008,scaleFrequency:1,scalePulse:!0},shroud:{name:"shroud",emoji:"🌑",type:"blending",description:"Smoke enveloping and obscuring - ominous and claustrophobic",duration:3200,beats:4,intensity:1.4,category:"afflicted",density:.5,riseSpeed:0,riseAcceleration:0,decayRate:.22,tint:[.52,.54,.62],windDir:[-.02,0],swirl:.4,turbulenceAmount:.025,turbulenceSpeed:2.5,glowColor:[.32,.34,.42],glowIntensityMin:.55,glowIntensityMax:.78,glowFlickerRate:3.5,scaleVibration:.018,scaleFrequency:1.8,scalePulse:!1,scaleContraction:.035,rotationWobble:.015,rotationWobbleSpeed:1.2},haze:{name:"haze",emoji:"🌁",type:"blending",description:"Light foggy haze overlay",duration:3500,beats:4,intensity:.5,category:"afflicted",density:.2,riseSpeed:0,riseAcceleration:0,decayRate:.1,tint:[.85,.88,.95],windDir:[.08,.04],swirl:.1,turbulenceAmount:.005,turbulenceSpeed:1,glowColor:[.8,.8,.85],glowIntensityMin:.9,glowIntensityMax:1,glowFlickerRate:1.5,scaleVibration:.005,scaleFrequency:.8,scalePulse:!0},choke:{name:"choke",emoji:"😶‍🌫️",type:"blending",description:"Dense suffocating smoke",duration:2500,beats:4,intensity:1.5,category:"afflicted",density:.9,riseSpeed:0,riseAcceleration:0,decayRate:.2,tint:[.7,.75,.65],windDir:[0,0],swirl:.6,turbulenceAmount:.025,turbulenceSpeed:4,glowColor:[.3,.35,.3],glowIntensityMin:.6,glowIntensityMax:.8,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:5,scalePulse:!1,scaleContraction:.03,jitterAmount:.008,jitterFrequency:8},smokebomb:{name:"smokebomb",emoji:"💨",type:"blending",description:"Ninja smokebomb - instant thick smoke, ninja gone in a flash",duration:1400,beats:2,intensity:2.5,category:"explosive",density:1,riseSpeed:0,riseAcceleration:0,decayRate:.5,tint:[.55,.55,.58],windDir:[0,0],swirl:.5,turbulenceAmount:.05,turbulenceSpeed:8,glowColor:[.5,.5,.55],glowIntensityMin:.3,glowIntensityMax:.7,glowFlickerRate:12,scaleVibration:.01,scaleFrequency:5,scalePulse:!1,fadeOut:!0,fadeStartAt:.05,fadeEndAt:.28,fadeCurve:"quick"},vanish:{name:"vanish",emoji:"👻",type:"blending",description:"Magician vanish - elegant smoke envelops, graceful disappearance",duration:2800,beats:4,intensity:1.3,category:"emanating",density:.9,riseSpeed:.025,riseAcceleration:1.2,decayRate:.32,tint:[.8,.83,.9],windDir:[.06,.03],swirl:.4,turbulenceAmount:.018,turbulenceSpeed:2.5,glowColor:[.68,.7,.78],glowIntensityMin:.45,glowIntensityMax:.85,glowFlickerRate:3,scaleVibration:.006,scaleFrequency:1.5,scalePulse:!0,fadeOut:!0,fadeStartAt:.18,fadeEndAt:.52,fadeCurve:"smooth"},materialize:{name:"materialize",emoji:"✨",type:"blending",description:"Magician appear - smoke condenses, mascot emerges from nothing",duration:2500,beats:4,intensity:1.6,category:"emanating",density:.95,riseSpeed:-.018,riseAcceleration:1,decayRate:.38,tint:[.94,.94,.97],windDir:[-.1,-.05],swirl:.5,turbulenceAmount:.028,turbulenceSpeed:3.5,glowColor:[.88,.88,.92],glowIntensityMin:.55,glowIntensityMax:1.4,glowFlickerRate:5,scaleVibration:.008,scaleFrequency:2,scalePulse:!1,fadeIn:!0,fadeStartAt:.32,fadeEndAt:.78,fadeCurve:"smooth"}};function So(e){return(43758.5453*Math.sin(e)%1+1)%1}function xo(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return So(t)*(1-a)+So(t+1)*a}function Co(e){const t=Mo[e];return t?{name:t.name,emoji:t.emoji,type:t.type,description:t.description,config:{duration:t.duration,beats:t.beats,intensity:t.intensity,...t},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"afflicted"===t.category?1.3:1.5,offBeat:1,curve:"smooth"}},"3d":{evaluate(e,i){const a={...t,...i},n=e*a.duration/1e3,s="afflicted"===a.category;let r=1;s||e<.2&&(r=e/.2,r=Math.pow(r,.5)),s&&e<.3&&(r=e/.3,r=Math.pow(r,.7)),e>1-a.decayRate&&(r*=1-(e-(1-a.decayRate))/a.decayRate);let o=0,l=0,c=0;if(a.riseSpeed>0&&(l+=a.riseSpeed*(1+n*a.riseAcceleration)*r),a.turbulenceAmount>0){const e=n*a.turbulenceSpeed;o+=(xo(e)-.5)*a.turbulenceAmount*r,c+=(xo(e+50)-.5)*a.turbulenceAmount*r*.5}if(a.jitterAmount>0){const e=n*a.jitterFrequency;o+=(xo(3*e)-.5)*a.jitterAmount*r,l+=(xo(3*e+33)-.5)*a.jitterAmount*r*.5,c+=(xo(3*e+66)-.5)*a.jitterAmount*r*.3}let h=1;const u=n*a.scaleFrequency;if(h=a.scalePulse?1+(.5*Math.sin(u*Math.PI*2)+.5)*a.scaleVibration*r:1+(.5*Math.sin(u*Math.PI*2)+.3*Math.sin(u*Math.PI*3.1))*a.scaleVibration*r,a.scaleBurst){const t=Math.min(e/.3,1),i=t<1?Math.pow(t,.5):1;h+=a.scaleBurst*i*r}a.scaleGrowth&&(h+=a.scaleGrowth*r),a.scaleContraction&&(h-=a.scaleContraction*r);let d=0,m=0,p=0;if(a.rotationWobble){const e=n*a.rotationWobbleSpeed;d=Math.sin(e*Math.PI*2)*a.rotationWobble*r,p=Math.sin(e*Math.PI*1.7+.5)*a.rotationWobble*.7*r,m=Math.sin(e*Math.PI*.8)*a.rotationWobble*.4*r}let g=1;if(a.fadeOut){const t=a.fadeStartAt||.15,i=a.fadeEndAt||.5;if(e>=t){const n=Math.min(1,(e-t)/(i-t));let s;s="quick"===a.fadeCurve?1-Math.pow(n,.5):1-n*n,g=Math.max(0,s)}}if(a.fadeIn){const t=a.fadeStartAt||.25,i=a.fadeEndAt||.75;if(e<t)g=0;else if(e<i){const n=(e-t)/(i-t);let s;s="quick"===a.fadeCurve?Math.pow(n,.5):n*n*(3-2*n),g=s}else g=1}const f=n*a.glowFlickerRate,y=.3*Math.sin(f*Math.PI*2)+.7;return{position:[o,l,c],rotation:[d,m,p],scale:h,meshOpacity:g,glowIntensity:a.glowIntensityMin+(a.glowIntensityMax-a.glowIntensityMin)*y*r,glowBoost:s?-.15*r*a.intensity:.05*r*a.intensity,glowColorOverride:a.glowColor,smokeOverlay:{enabled:r>.1,thickness:r*a.intensity,density:a.density,category:a.category,tint:a.tint,windDir:a.windDir,swirl:a.swirl*r,time:n}}}}}:(console.warn(`[SMOKE_EFFECT] Unknown variant: ${e}, using puff`),Co("puff"))}const Po=Co("puff"),ko=Co("billow"),Do=Co("fume"),Ao=Co("shroud"),_o=Co("haze"),To=Co("choke"),Io=Co("smokebomb"),Oo=Co("vanish"),Ro=Co("materialize"),Eo={drain:{name:"drain",emoji:"🕳️",type:"blending",description:"Slowly draining energy, light dims and color fades",duration:3500,beats:5,intensity:.7,category:"absorption",depth:.4,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.2,cameraFacing:.2,clustering:.3,count:5,scale:.9,models:["void-shard","corruption-patch"],minDistance:.15,animation:{appearAt:.1,disappearAt:.9,stagger:.06,enter:{type:"fade",duration:.15,easing:"easeOut"},exit:{type:"shrink",duration:.12,easing:"easeInCubic"},pulse:{amplitude:.08,frequency:1,easing:"easeInOut",sync:"global"},emissive:{min:.2,max:.5,frequency:1.5,pattern:"sine"},drift:{direction:"inward",speed:.012,noise:.05},rotate:{axis:"y",speed:.015,oscillate:!1},scaleVariance:.15,lifetimeVariance:.12,blending:"normal",renderOrder:3,intensityScaling:{scale:.9,emissiveMax:.8},modelOverrides:{"void-shard":{drift:{direction:"inward",speed:.015,noise:.05},opacityLink:"dissipate"},"corruption-patch":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.2},y:{expand:!1,rate:.6},z:{expand:!0,rate:1.2}}},drift:{direction:"outward-flat",speed:.01,adherence:.6},orientationOverride:"flat"}}}},dimRate:.3,dimPulse:!0,glowColor:[.3,.2,.4],glowIntensityMin:.4,glowIntensityMax:.7,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:1.5,scaleShrink:.03,pullStrength:.005,decayRate:.25},siphon:{name:"siphon",emoji:"🌀",type:"blending",description:"Active pull of energy inward, swirling absorption",duration:2800,beats:4,intensity:1,category:"absorption",depth:.6,spawnMode:{type:"surface",pattern:"ring",embedDepth:.15,cameraFacing:.3,clustering:.2,count:6,scale:.85,models:["void-crack","shadow-tendril","void-shard"],minDistance:.12},pullStrength:.015,spiralRate:1.5,glowColor:[.2,.1,.3],glowIntensityMin:.3,glowIntensityMax:.6,glowFlickerRate:4,scaleVibration:.02,scaleFrequency:3,scaleShrink:.05,scalePulse:!0,rotationSpeed:.3,decayRate:.2},hollow:{name:"hollow",emoji:"👁️",type:"blending",description:"Becoming empty inside, shell of former self",duration:4e3,beats:6,intensity:.8,category:"absorption",depth:.5,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.25,cameraFacing:.15,clustering:.4,count:4,scale:.8,models:["void-crack","void-shard"],minDistance:.18},hollowCore:!0,hollowProgress:.7,glowColor:[.25,.25,.35],glowIntensityMin:.5,glowIntensityMax:.75,glowFlickerRate:1.5,scaleVibration:.008,scaleFrequency:1,scaleShrink:.02,tremor:.003,tremorFrequency:6,decayRate:.2},corrupt:{name:"corrupt",emoji:"🦠",type:"blending",description:"Darkness spreading across surface, being overtaken",duration:3200,beats:5,intensity:1.2,category:"corruption",depth:.65,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.2,clustering:.5,count:8,scale:1,models:["corruption-patch","shadow-tendril","void-crack"],minDistance:.1},spreadRate:.4,spreadPulse:!0,glowColor:[.15,.05,.2],glowIntensityMin:.35,glowIntensityMax:.65,glowFlickerRate:5,scaleVibration:.025,scaleFrequency:6,jitterAmount:.01,jitterFrequency:8,rotationWobble:.02,rotationWobbleSpeed:2,decayRate:.22},taint:{name:"taint",emoji:"💜",type:"blending",description:"Subtle dark infection, insidious corruption",duration:4500,beats:6,intensity:.5,category:"corruption",depth:.35,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.12,cameraFacing:.15,clustering:.35,count:4,scale:.7,models:["corruption-patch","void-shard"],minDistance:.2},spreadRate:.2,glowColor:[.4,.3,.5],glowIntensityMin:.7,glowIntensityMax:.9,glowFlickerRate:2,scaleVibration:.005,scaleFrequency:2,driftAmount:.003,driftSpeed:.8,decayRate:.18},wither:{name:"wither",emoji:"🥀",type:"blending",description:"Life force being consumed, vitality draining",duration:3800,beats:5,intensity:.9,category:"corruption",depth:.55,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.18,cameraFacing:.2,clustering:.4,count:6,scale:.85,models:["shadow-tendril","corruption-patch","void-shard"],minDistance:.12},witherRate:.35,glowColor:[.3,.2,.25],glowIntensityMin:.45,glowIntensityMax:.7,glowFlickerRate:3,scaleVibration:.012,scaleFrequency:2,scaleShrink:.06,droopAmount:.015,droopAcceleration:.5,decayRate:.2},consume:{name:"consume",emoji:"⚫",type:"blending",description:"Being swallowed by void, total absorption",duration:2500,beats:4,intensity:1.5,category:"annihilation",depth:.85,spawnMode:{type:"surface",pattern:"crown",embedDepth:.1,cameraFacing:.35,clustering:.3,count:10,scale:1.1,models:["void-crack","shadow-tendril","corruption-patch","void-shard"],minDistance:.08,animation:{appearAt:.05,disappearAt:.88,stagger:.02,enter:{type:"grow",duration:.06,easing:"easeOutQuad"},exit:{type:"shrink",duration:.08,easing:"easeInCubic"},pulse:{amplitude:.12,frequency:3,easing:"easeIn"},emissive:{min:.1,max:.4,frequency:4,pattern:"sine"},drift:{direction:"inward",speed:.035,noise:.1},rotate:{axis:"y",speed:.12,oscillate:!1},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:2,intensityScaling:{scale:.85,driftSpeed:1.5,rotateSpeed:1.4},modelOverrides:{"void-crack":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.6},y:{expand:!0,rate:1.4},z:{expand:!0,rate:.8}}},drift:{direction:"inward",speed:.04,noise:.1}},"shadow-tendril":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.7},y:{expand:!0,rate:1.8},z:{expand:!1,rate:.7}},wobbleFrequency:3,wobbleAmplitude:.15},drift:{direction:"inward",speed:.035}},"corruption-patch":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.5},y:{expand:!1,rate:.5},z:{expand:!0,rate:1.5}}},drift:{direction:"inward",speed:.03},orientationOverride:"flat"},"void-shard":{drift:{direction:"inward",speed:.045,noise:.08},opacityLink:"inverse-scale"}}}},pullStrength:.025,spiralRate:2,glowColor:[.1,.05,.15],glowIntensityMin:.2,glowIntensityMax:.5,glowFlickerRate:8,scaleVibration:.03,scaleFrequency:5,scaleShrink:.15,rotationSpeed:1.2,fadeOut:!0,fadeStartAt:.3,fadeEndAt:.85,fadeCurve:"accelerating",decayRate:.15},erase:{name:"erase",emoji:"👻",type:"blending",description:"Fading from existence, becoming nothing",duration:3e3,beats:4,intensity:1.3,category:"annihilation",depth:.7,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.2,cameraFacing:.25,clustering:.35,count:7,scale:.95,models:["void-crack","void-shard","corruption-patch"],minDistance:.1},erasePattern:"dissolve",glowColor:[.2,.2,.3],glowIntensityMin:.3,glowIntensityMax:.6,glowFlickerRate:3,scaleVibration:.015,scaleFrequency:2,scaleShrink:.08,driftAmount:.01,driftSpeed:.5,riseAmount:.008,fadeOut:!0,fadeStartAt:.2,fadeEndAt:.9,fadeCurve:"smooth",decayRate:.1},singularity:{name:"singularity",emoji:"💫",type:"blending",description:"Collapsing to a point, ultimate compression",duration:2e3,beats:3,intensity:2,category:"annihilation",depth:1,spawnMode:{type:"surface",pattern:"shell",embedDepth:.05,cameraFacing:.4,clustering:.15,count:12,scale:1.2,models:["void-crack","shadow-tendril","corruption-patch","void-shard"],minDistance:.06,animation:{appearAt:.02,disappearAt:.95,stagger:.015,enter:{type:"flash",duration:.02,easing:"linear"},exit:{type:"shrink",duration:.05,easing:"easeInCubic"},pulse:{amplitude:.2,frequency:8,easing:"snap"},flicker:{intensity:.25,rate:15,pattern:"random"},emissive:{min:.05,max:.3,frequency:10,pattern:"random"},drift:{direction:"inward",speed:.06,noise:.15},rotate:{axis:"y",speed:.25,oscillate:!1},scaleVariance:.25,lifetimeVariance:.2,blending:"normal",renderOrder:1,intensityScaling:{scale:.7,driftSpeed:1.8,rotateSpeed:1.6},modelOverrides:{"void-crack":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:2},y:{expand:!0,rate:1.8},z:{expand:!1,rate:.6}},wobbleFrequency:6,wobbleAmplitude:.2},drift:{direction:"inward",speed:.06,noise:.15}},"shadow-tendril":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.6},y:{expand:!0,rate:2.2},z:{expand:!1,rate:.6}},wobbleFrequency:5,wobbleAmplitude:.2},drift:{direction:"inward",speed:.055}},"corruption-patch":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.8},y:{expand:!1,rate:.4},z:{expand:!0,rate:1.8}}},drift:{direction:"inward",speed:.05},orientationOverride:"flat"},"void-shard":{drift:{direction:"inward",speed:.065,noise:.1},opacityLink:"inverse-scale"}}}},collapsePhase:.7,pullStrength:.04,spiralRate:3,glowColor:[.05,0,.1],glowIntensityMin:.1,glowIntensityMax:.4,glowFlickerRate:15,scaleVibration:.04,scaleFrequency:10,scaleShrink:.35,rotationSpeed:2.5,fadeOut:!0,fadeStartAt:.5,fadeEndAt:.95,fadeCurve:"accelerating",decayRate:.05}};function Bo(e){return(43758.5453*Math.sin(e)%1+1)%1}function Fo(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return Bo(t)*(1-a)+Bo(t+1)*a}function zo(e){const t=Eo[e];return t?{name:t.name,emoji:t.emoji,type:t.type,description:t.description,config:{duration:t.duration,beats:t.beats,intensity:t.intensity,...t},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"annihilation"===t.category?1.5:1.2,offBeat:1,curve:"absorption"===t.category?"smooth":"sharp"}},"3d":{evaluate(e,i){const a={...t,...i},n=e*a.duration/1e3,{category:s}=a;let r=1;"absorption"===s&&e<.25&&(r=e/.25,r=Math.pow(r,.7)),"corruption"===s&&(e<.3&&(r=e/.3),a.spreadPulse)&&(r*=1+.15*Math.sin(n*Math.PI*3)),"annihilation"===s&&a.collapsePhase&&(r=e<a.collapsePhase?Math.pow(e/a.collapsePhase,1.5):1),e>1-a.decayRate&&(r*=1-(e-(1-a.decayRate))/a.decayRate);let o=0,l=0,c=0;if(a.pullStrength>0){const t=n*(a.spiralRate||1),i=Math.cos(t*Math.PI*2),s=Math.sin(t*Math.PI*2),l=a.pullStrength*r*(1-.5*e);o+=i*l,c+=s*l}if(a.jitterAmount>0){const e=n*a.jitterFrequency;o+=(Fo(3*e)-.5)*a.jitterAmount*r,l+=(Fo(3*e+33)-.5)*a.jitterAmount*r*.5,c+=(Fo(3*e+66)-.5)*a.jitterAmount*r*.3}if(a.tremor>0){const e=n*a.tremorFrequency;o+=(Fo(e)-.5)*a.tremor*r,l+=(Fo(e+50)-.5)*a.tremor*r*.5}if(a.driftAmount>0){const e=n*a.driftSpeed;o+=Math.sin(e*Math.PI)*a.driftAmount*r,c+=Math.cos(e*Math.PI*.7)*a.driftAmount*r*.5}if(a.droopAmount>0){const t=e*(1+a.droopAcceleration*e);l-=a.droopAmount*t*r}a.riseAmount>0&&(l+=a.riseAmount*e*r);let h=1;const u=n*a.scaleFrequency;if(h=a.scalePulse?1+(.5*Math.sin(u*Math.PI*2)+.5-.5)*a.scaleVibration*r:1+(.5*Math.sin(u*Math.PI*2)+.3*Math.sin(u*Math.PI*3.7))*a.scaleVibration*r,a.scaleShrink>0){const t="annihilation"===s?Math.pow(e,1.5):e;h-=a.scaleShrink*t*r,h=Math.max(.01,h)}let d=0,m=0,p=0;if(a.rotationSpeed>0&&(m=n*a.rotationSpeed*Math.PI*2*r,"annihilation"===s&&(m*=1+e)),a.rotationWobble>0){const e=n*a.rotationWobbleSpeed;d=Math.sin(e*Math.PI*2)*a.rotationWobble*r,p=Math.sin(e*Math.PI*1.7+.5)*a.rotationWobble*.7*r}let g=1;if(a.fadeOut){const t=a.fadeStartAt||.2,i=a.fadeEndAt||.9;if(e>=t){const n=Math.min(1,(e-t)/(i-t));let s;s="accelerating"===a.fadeCurve?1-Math.pow(n,2):1-n,g=Math.max(0,s)}}const f=n*a.glowFlickerRate;let y;"absorption"===s?y=.3*Math.sin(f*Math.PI*2)+.7:"corruption"===s?y=(.2*Math.sin(f*Math.PI*2)+.2*Math.sin(f*Math.PI*3.3+1)+.3)*(Bo(Math.floor(2*f))>.5?.8:1.2):(y=.4*Math.sin(f*Math.PI*2)+.6,y*=1-.5*e);const v=a.glowIntensityMin+(a.glowIntensityMax-a.glowIntensityMin)*y*r,b=-.3*r*a.intensity;return{voidOverlay:{enabled:r>.1,strength:r*a.intensity,depth:a.depth,category:a.category,spawnMode:a.spawnMode||null,time:n,progress:e,duration:a.duration,animation:t.spawnMode?.animation,models:t.spawnMode?.models,count:t.spawnMode?.count,scale:t.spawnMode?.scale,embedDepth:t.spawnMode?.embedDepth},position:[o,l,c],rotation:[d,m,p],scale:h,meshOpacity:g,glowIntensity:v,glowBoost:b,glowColorOverride:a.glowColor}}}}:(console.warn(`[VOID_EFFECT] Unknown variant: ${e}, using drain`),zo("drain"))}const Lo=zo("drain"),Go=zo("siphon"),Vo=zo("hollow"),No=zo("corrupt"),jo=zo("taint"),qo=zo("wither"),Uo=zo("consume"),Wo=zo("erase"),Ho=zo("singularity"),$o={appearAt:0,disappearAt:.7,enter:{type:"scale",duration:.2,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{frost:{start:.55,peak:.85,end:.65,curve:"bell"}},pulse:{amplitude:.05,frequency:3,easing:"easeInOut"},emissive:{min:.9,max:1.8,frequency:4,pattern:"sine"},grain:{type:3,strength:.35,scale:.2,speed:1.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:["ice-ring"],anchor:"below",anchorOffset:-.1,intensity:.4,sizeScale:1.5,progressCurve:"sustain"}],scaleVariance:.03,lifetimeVariance:.02,blending:"normal",renderOrder:15,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.8,arcCount:2}}}};function Yo(e){return(43758.5453*Math.sin(e)%1+1)%1}function Xo(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return Yo(t)*(1-a)+Yo(t+1)*a}function Qo(e){return{name:e.name,emoji:e.emoji,type:e.type,description:e.description,config:{duration:e.duration,beats:e.beats,intensity:e.intensity,...e},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"transform"===e.category?1.4:1.2,offBeat:1,curve:"smooth"}},"3d":{evaluate(t,i){const a={...e,...i},n=t*a.duration/1e3,{category:s}=a;let r=1;"afflicted"===s&&(t<.2&&(r=t/.2),a.frostDecay&&(r*=1-.6*t)),"emanating"===s&&(r*=.2*Math.sin(n*Math.PI*2)+.8),"transform"===s&&(r=a.shatterPoint&&t>a.shatterPoint?1-(t-a.shatterPoint)/(1-a.shatterPoint):Math.min(1,t/.3));const o=a.decayRate||.15;t>1-o&&(r*=1-(t-(1-o))/o);let l=a.frost||.5;a.frostDecay&&(l*=1-.7*t);let c=0,h=0,u=0;if(a.tremor>0){let e=a.tremor;a.tremorDecay&&(e*=1-t*a.tremorDecay);const i=n*(a.tremorFrequency||8);c+=(Xo(i)-.5)*e*r,h+=(Xo(i+50)-.5)*e*r*.5,u+=(Xo(i+100)-.5)*e*r*.3}if(a.shiverAmount>0){const e=n*(a.shiverFrequency||12);c+=Math.sin(e*Math.PI*2)*a.shiverAmount*r,h+=Math.cos(e*Math.PI*3.1)*a.shiverAmount*.5*r}if(a.jitterAmount>0){const e=n*(a.jitterFrequency||15);Yo(Math.floor(e))>.7&&(c+=(Yo(e)-.5)*a.jitterAmount*r,h+=(Yo(e+10)-.5)*a.jitterAmount*.5*r)}if(a.droopAmount>0){const e=t*(1+(a.droopAcceleration||.3)*t);h-=a.droopAmount*e*r}if(a.explosionForce>0&&a.shatterPoint&&t>a.shatterPoint){const e=(t-a.shatterPoint)/(1-a.shatterPoint),i=a.explosionForce*e;c+=(Xo(20*n)-.5)*i,h+=(Xo(20*n+33)-.5)*i,u+=(Xo(20*n+66)-.5)*i}let d=1;const m=n*(a.scaleFrequency||3);a.scalePulse?d=1+(.5*Math.sin(m*Math.PI*2)+.5-.5)*(a.scaleVibration||.015)*r:a.scaleVibration&&(d=1+(.6*Math.sin(m*Math.PI*2)+.4*Math.sin(m*Math.PI*2.7))*a.scaleVibration*r),a.scaleContract>0&&(d-=a.scaleContract*t*r),a.scaleExpand>0&&(d+=a.scaleExpand*t*r),a.scaleGrow>0&&(d+=a.scaleGrow*t*r),a.shatterPoint&&t>a.shatterPoint&&(d+=.1*(Xo(15*n)-.5)),d=Math.max(.1,d);let p=0,g=0,f=0;if(a.rotationSpeed>0&&(g=n*a.rotationSpeed*Math.PI*2*r),a.rotationWobble>0){const e=n*(a.rotationWobbleSpeed||1.5);p=Math.sin(e*Math.PI*2)*a.rotationWobble*r,f=Math.sin(e*Math.PI*1.7+.5)*a.rotationWobble*.7*r}const y=n*(a.glowFlickerRate||2);let v;v=a.shatterPoint&&t>a.shatterPoint?1+.5*Yo(5*y):.3*Math.sin(y*Math.PI*2)+.7;const b=(a.glowIntensityMin||.5)+((a.glowIntensityMax||.8)-(a.glowIntensityMin||.5))*v*r,w=.15*r*a.intensity*l;return{iceOverlay:{enabled:r>.1,strength:r*a.intensity,frost:l,category:a.category,spawnMode:a.spawnMode||null,time:n,progress:t,duration:a.duration,animation:e.spawnMode?.animation,models:e.spawnMode?.models,count:e.spawnMode?.count,scale:e.spawnMode?.scale,embedDepth:e.spawnMode?.embedDepth},position:[c,h,u],rotation:[p,g,f],scale:d,glowIntensity:b,glowBoost:w,glowColorOverride:a.glowColor}}}}}const Ko=Qo({name:"icecrown",emoji:"👑",type:"blending",description:"Majestic ice crown above the head",duration:3e3,beats:4,intensity:1,category:"transform",frost:.65,spawnMode:{type:"anchor",anchor:{landmark:"top",offset:{x:0,y:.05,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.3}},count:1,scale:2.2,models:["ice-ring"],animation:{appearAt:0,disappearAt:.75,stagger:0,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.1,geometryStability:!0},pulse:{amplitude:.02,frequency:2,easing:"easeInOut"},atmospherics:[{preset:"mist",targets:["ice-ring"],anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain"}],rotate:{axis:"z",rotations:1,phase:0},scaleVariance:0,lifetimeVariance:0,blending:"normal",renderOrder:15}},glowColor:[.6,.85,1],glowIntensityMin:.8,glowIntensityMax:.8,glowFlickerRate:0,scaleVibration:.003,scaleFrequency:3,scaleGrowth:.005,tremor:0,tremorFrequency:0,tremorDecay:0}),Zo=Qo({name:"icedance",emoji:"💃",type:"blending",description:"Vertical ice crystals dancing and rising",duration:1500,beats:3,intensity:1.3,category:"transform",frost:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.6,startDiameter:1.3,endDiameter:2,orientation:"vertical"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1,models:["ice-ring"],animation:{appearAt:.02,disappearAt:.5,stagger:.02,enter:{type:"fade",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},cutout:{strength:.65,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:1.2,weight:.5},blend:"add",travel:"angular",travelSpeed:2,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.12,tip:.28}},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4,centrifugal:{speed:.5,tangentialBias:.5}}],parameterAnimation:{frost:{start:.5,peak:.75,end:.55,curve:"bell"}},pulse:{amplitude:.1,frequency:5,easing:"easeInOut"},emissive:{min:.8,max:1.6,frequency:6,pattern:"sine"},rotate:[{axis:"y",rotations:2,phase:0},{axis:"y",rotations:-2,phase:60},{axis:"y",rotations:3,phase:120}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:11,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.5,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.5,.8,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.018,scaleFrequency:4,scaleGrowth:.025,tremor:.005,tremorFrequency:3}),Jo=Qo({name:"icepillar",emoji:"🏛️",type:"blending",description:"Majestic rising pillar of ice",duration:3e3,beats:4,intensity:1.3,category:"transform",frost:.8,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:0},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1.6,models:["ice-ring"],animation:{...$o,stagger:.03,cutout:{strength:.55,primary:{pattern:0,scale:1.2,weight:1},secondary:{pattern:8,scale:1.5,weight:.4},blend:"add",travel:"angular",travelSpeed:1.2,strengthCurve:"fadeIn",fadeInDuration:.3,geometricMask:{type:"distance",core:.1,tip:.25}},rotate:[{axis:"z",rotations:.3,phase:0},{axis:"z",rotations:.3,phase:180}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:.5},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1.6,models:["ice-ring"],animation:{...$o,stagger:.05,cutout:{strength:.6,primary:{pattern:8,scale:1.4,weight:1},secondary:{pattern:3,scale:1.2,weight:.5},blend:"multiply",travel:"radial",travelSpeed:1.5,strengthCurve:"bell",bellPeakAt:.5,bellWidth:.5,geometricMask:{type:"tip-boost",core:0,tip:.2}},rotate:[{axis:"z",rotations:-.5,phase:60},{axis:"z",rotations:-.5,phase:240}]}},{type:"axis-travel",axisTravel:{axis:"y",start:"below",end:"above",easing:"easeOut",startScale:.6,endScale:1.3,startDiameter:1.2,endDiameter:2.2,orientation:"flat",startOffset:1},formation:{type:"stack",count:2,spacing:.25},count:2,scale:1.6,models:["ice-ring"],animation:{...$o,stagger:.07,cutout:{strength:.65,primary:{pattern:3,scale:1.3,weight:1},secondary:{pattern:7,scale:1.5,weight:.4},blend:"add",travel:"oscillate",travelSpeed:2,strengthCurve:"fadeOut",fadeOutDuration:.4,geometricMask:{type:"distance",core:.15,tip:.3}},rotate:[{axis:"z",rotations:.7,phase:90},{axis:"z",rotations:.7,phase:270}]}}],glowColor:[.55,.8,1],glowIntensityMin:.8,glowIntensityMax:1.6,glowFlickerRate:5,scaleVibration:.008,scaleFrequency:3,scaleGrowth:.025,tremor:.002,tremorFrequency:2}),el=Qo({name:"icehelix",emoji:"🧬",type:"blending",description:"DNA-style double helix ascending ice",duration:2e3,beats:4,intensity:1.2,category:"transform",frost:.75,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"above",easing:"easeInOut",startScale:.8,endScale:1.1,startDiameter:1.6,endDiameter:1.8,orientation:"vertical"},formation:{type:"spiral",count:6,strands:2,spacing:.2,arcOffset:120,phaseOffset:.05},count:6,scale:1.2,models:["ice-ring"],animation:{appearAt:0,disappearAt:.7,stagger:.06,enter:{type:"scale",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.5,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.5,peak:.85,end:.6,curve:"bell"}},pulse:{amplitude:.06,frequency:4,easing:"easeInOut"},emissive:{min:.9,max:2,frequency:6,pattern:"smooth"},cutout:{strength:.7,primary:{pattern:8,scale:1.5,weight:1},secondary:{pattern:3,scale:1.2,weight:.5},blend:"max",travel:"angular",travelSpeed:2.5,strengthCurve:"bell",bellPeakAt:.5,geometricMask:{type:"distance",core:.1,tip:.25}},grain:{type:3,strength:.15,scale:.2,speed:1,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:.8,tangentialBias:.4}}],rotate:{axis:"y",rotations:2,phase:0},scaleVariance:.1,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.7,arcSpeed:1.2,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.6,.85,1],glowIntensityMin:1,glowIntensityMax:1.8,glowFlickerRate:8,scaleVibration:.012,scaleFrequency:5,scaleGrowth:.02,tremor:.003,tremorFrequency:4}),tl=Qo({name:"icemeditation",emoji:"🧘",type:"blending",description:"Meditative ice crystals with breathing pulse",duration:4e3,beats:4,intensity:.6,category:"emanating",frost:.5,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"easeInOut",startScale:1.4,endScale:1.4,startDiameter:2.2,endDiameter:2.2,orientation:"camera"},formation:{type:"mandala",count:5,radius:.5,arcOffset:45,scales:[1.1,.7,.7,.7,.7]},count:5,scale:1.6,models:["ice-ring"],animation:{appearAt:0,disappearAt:.8,stagger:0,enter:{type:"fade",duration:.5,easing:"easeInOut"},exit:{type:"fade",duration:.4,easing:"easeInOut"},procedural:{scaleSmoothing:.15,geometryStability:!0},parameterAnimation:{frost:{start:.35,peak:.55,end:.4,curve:"sine"}},cutout:{strength:.55,primary:{pattern:3,scale:1,weight:1},secondary:{pattern:8,scale:1.2,weight:.4},blend:"add",travel:"angular",travelSpeed:.5,strengthCurve:"bell",bellPeakAt:.5,bellWidth:1},grain:{type:3,strength:.2,scale:.3,speed:.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1.2,progressCurve:"sustain"}],pulse:{amplitude:.15,frequency:1.5,easing:"easeInOut"},emissive:{min:.7,max:1.2,frequency:1.5,pattern:"sine"},rotate:[{axis:"z",rotations:.4,phase:0},{axis:"z",rotations:-.35,phase:0},{axis:"z",rotations:.25,phase:0},{axis:"z",rotations:-.35,phase:0},{axis:"z",rotations:.4,phase:0}],scaleVariance:0,lifetimeVariance:0,blending:"normal",depthWrite:!1,renderOrder:-5,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:.4,arcCount:2},orientationOverride:"camera"}}}},glowColor:[.55,.8,.95],glowIntensityMin:.6,glowIntensityMax:1,glowFlickerRate:3,scaleVibration:.004,scaleFrequency:1.5,scaleGrowth:0,tremor:.001,tremorFrequency:1}),il=Qo({name:"icevortex",emoji:"🌀",type:"blending",description:"Ice tornado spiraling around mascot",duration:1500,beats:5,intensity:1.4,category:"transform",frost:.8,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"bottom",end:"top",easing:"easeInOut",startScale:1.2,endScale:1.5,startDiameter:.6,endDiameter:2,orientation:"flat"},formation:{type:"spiral",count:3,spacing:0,arcOffset:120,phaseOffset:0},count:3,scale:1.5,models:["ice-ring"],animation:{appearAt:.05,disappearAt:.9,stagger:.02,enter:{type:"fade",duration:.1,easing:"easeOut"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.1},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.5,peak:.9,end:.6,curve:"bell"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2,frequency:5,pattern:"sine"},grain:{type:3,strength:.2,scale:.3,speed:2.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.6,centrifugal:{speed:1.2,tangentialBias:.3}}],scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:12,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:5,arcCount:1},scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!1,rate:.3},z:{expand:!0,rate:1.1}}},orientationOverride:"flat"}}}},glowColor:[.4,.75,1],glowIntensityMin:1.2,glowIntensityMax:2.2,glowFlickerRate:6,scaleVibration:.02,scaleFrequency:4,scaleGrowth:.03,tremor:.008,tremorFrequency:5}),al=Qo({name:"icesplash",emoji:"💥",type:"blending",description:"Explosive ice shatter with crystals and frost spray",duration:1e3,beats:2,intensity:1.3,category:"transform",frost:.85,spawnMode:[{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.1},orientation:"camera",startScale:.2,endScale:2,scaleEasing:"easeOutQuad"},count:1,scale:1.3,models:["crystal-cluster"],animation:{appearAt:0,disappearAt:.4,enter:{type:"scale",duration:.05,easing:"easeOut"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.6,primary:{pattern:2,scale:1.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1.2,strengthCurve:"fadeOut"},grain:{type:3,strength:.4,scale:.3,speed:1.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain"}],blending:"normal",renderOrder:8,rotate:{axis:"z",rotations:0,phase:0},modelOverrides:{"crystal-cluster":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.3,endScale:1.6,scaleEasing:"easeOutQuad"},count:1,scale:1,models:["ice-spike"],animation:{appearAt:0,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.4,distance:.8,direction:{x:0,y:1,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:12,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:.9,models:["ice-spike"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:-.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:12,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.25,endScale:1.3,scaleEasing:"easeOutQuad"},count:1,scale:.9,models:["ice-spike"],animation:{appearAt:.02,disappearAt:.5,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},blend:"multiply",travel:"radial",travelSpeed:.6,strengthCurve:"fadeOut"},drift:{speed:1.3,distance:.75,direction:{x:.7,y:.85,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:12,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.9,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.8,models:["ice-spike"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:8,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:-.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:11,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:.05},orientation:"camera",startScale:.2,endScale:1.1,scaleEasing:"easeOutQuad"},count:1,scale:.8,models:["ice-spike"],animation:{appearAt:.03,disappearAt:.45,enter:{type:"scale",duration:.04,easing:"easeOutBack"},exit:{type:"fade",duration:.18,easing:"easeIn"},procedural:{scaleSmoothing:.03,geometryStability:!0},cutout:{strength:.5,primary:{pattern:8,scale:1.2,weight:1},blend:"multiply",travel:"vertical",travelSpeed:.8,strengthCurve:"fadeOut"},drift:{speed:1.1,distance:.6,direction:{x:.95,y:.5,z:0},easing:"easeOutQuad"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:11,modelOverrides:{"ice-spike":{shaderAnimation:{type:1,arcWidth:.85,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:8,radius:.05,endRadius:.65,angleSpread:360,startAngle:22,orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:8,scale:.5,models:["crystal-small"],animation:{appearAt:.02,disappearAt:.4,stagger:.008,enter:{type:"scale",duration:.03,easing:"easeOut"},exit:{type:"fade",duration:.15,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.4,primary:{pattern:3,scale:.7,weight:1},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.3,lifetimeVariance:.15,blending:"normal",renderOrder:14,modelOverrides:{"crystal-small":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"radial-burst",radialBurst:{count:12,radius:.03,endRadius:.5,angleSpread:360,startAngle:0,orientation:"camera",startScale:.1,endScale:.35,scaleEasing:"easeOutQuad"},count:12,scale:.2,models:["crystal-small"],animation:{appearAt:.01,disappearAt:.3,stagger:.005,enter:{type:"scale",duration:.02,easing:"easeOut"},exit:{type:"fade",duration:.1,easing:"easeIn"},procedural:{scaleSmoothing:.02,geometryStability:!0},cutout:{strength:.3,primary:{pattern:7,scale:.5,weight:1},blend:"multiply",travel:"radial",travelSpeed:1,strengthCurve:"fadeOut"},rotate:{axis:"z",rotations:0,phase:0},scaleVariance:.5,lifetimeVariance:.25,blending:"normal",renderOrder:16,modelOverrides:{"crystal-small":{shaderAnimation:{type:1,arcWidth:.98,arcSpeed:0,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:-.1,z:.12},orientation:"camera",startScale:.2,endScale:.9,scaleEasing:"easeOutQuad"},count:1,scale:.6,models:["crystal-cluster"],animation:{appearAt:.05,disappearAt:.6,enter:{type:"scale",duration:.08,easing:"easeOut"},exit:{type:"fade",duration:.25,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},cutout:{strength:.5,primary:{pattern:3,scale:1.2,weight:1},blend:"multiply",travel:"radial",travelSpeed:.5,strengthCurve:"constant"},pulse:{amplitude:.1,frequency:8,easing:"easeInOut"},rotate:{axis:"z",rotations:0,phase:0},blending:"normal",renderOrder:6,modelOverrides:{"crystal-cluster":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:0,arcCount:2},orientationOverride:"camera"}}}}],glowColor:[.5,.8,1],glowIntensityMin:1,glowIntensityMax:2.2,glowFlickerRate:6,scaleVibration:.035,scaleFrequency:7,scaleGrowth:.015,tremor:.01,tremorFrequency:8}),nl=Qo({name:"iceencase",emoji:"🧊",type:"blending",description:"Ice crystals growing on mascot surface, encasing in ice",duration:3500,beats:5,intensity:1.2,category:"transform",frost:.85,spawnMode:{type:"surface",pattern:"shell",embedDepth:.2,cameraFacing:.4,clustering:.1,count:10,scale:1.8,minDistance:.1,models:["crystal-cluster","crystal-medium","crystal-small","ice-spike"],animation:{appearAt:.05,disappearAt:.9,stagger:.04,enter:{type:"grow",duration:.12,easing:"easeOutQuad"},exit:{type:"shrink",duration:.15,easing:"easeInQuad"},procedural:{scaleSmoothing:.1,geometryStability:!0},parameterAnimation:{frost:{start:.5,peak:.9,end:.7,curve:"fadeIn"}},pulse:{amplitude:.05,frequency:1.2,easing:"easeInOut",sync:"global"},emissive:{min:.5,max:.9,frequency:1.5,pattern:"sine"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1.2,progressCurve:"sustain"}],cutout:{edgeMask:.3},rotate:{axis:"y",speed:.008,oscillate:!0,range:Math.PI/16},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:6,intensityScaling:{scale:1.25,emissiveMax:1.2},modelOverrides:{"crystal-small":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1},y:{expand:!0,rate:1.4},z:{expand:!0,rate:1}},easing:"easeOutQuad"}},"crystal-medium":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.1},y:{expand:!0,rate:1.5},z:{expand:!0,rate:1.1}}}},"crystal-cluster":{scaling:{mode:"non-uniform",axes:{x:{expand:!0,rate:1.3},y:{expand:!0,rate:1.2},z:{expand:!0,rate:1.3}}}},"ice-spike":{scaling:{mode:"non-uniform",axes:{x:{expand:!1,rate:.85},y:{expand:!0,rate:1.8},z:{expand:!1,rate:.85}}}}}}},glowColor:[.6,.85,1],glowIntensityMin:.55,glowIntensityMax:.9,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:2,scaleContract:.02,tremor:.004,tremorFrequency:6,tremorDecay:.8,decayRate:.15}),sl=Qo({name:"icedrill",emoji:"🔩",type:"blending",description:"Fast tight descending ice helix",duration:1200,beats:2,intensity:1.5,category:"transform",frost:.7,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"feet",end:"below",easing:"easeIn",startScale:1,endScale:.8,startDiameter:1.8,endDiameter:1.4,orientation:"vertical"},formation:{type:"spiral",count:6,spacing:.1,arcOffset:60,phaseOffset:0},count:6,scale:1.4,models:["ice-ring"],animation:{appearAt:0,disappearAt:.6,stagger:.03,enter:{type:"fade",duration:.05,easing:"linear"},exit:{type:"fade",duration:.4,easing:"easeIn"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.8,end:.5,curve:"bell"}},cutout:{strength:.55,primary:{pattern:3,scale:1.5,weight:1},secondary:{pattern:8,scale:.8,weight:.35},blend:"add",travel:"vertical",travelSpeed:3,strengthCurve:"constant"},grain:{type:3,strength:.3,scale:.2,speed:4,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:.8,progressCurve:"sustain",velocityInheritance:.5,centrifugal:{speed:1,tangentialBias:.3}}],pulse:{amplitude:.08,frequency:10,easing:"linear"},rotate:{axis:"y",rotations:4,phase:0},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:16,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:3,arcCount:1},orientationOverride:"vertical"}}}},glowColor:[.4,.75,1],glowIntensityMin:1.3,glowIntensityMax:2.8,glowFlickerRate:10,scaleVibration:.02,scaleFrequency:8,scaleGrowth:.03,tremor:.006,tremorFrequency:8}),rl=Qo({name:"iceflourish",emoji:"❄",type:"blending",description:"Spinning ice flourish with crystal trails",duration:1200,beats:4,intensity:1.3,category:"ambient",frost:.6,spawnMode:[{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.7,endScale:1.2,startDiameter:1.8,endDiameter:2.8,orientation:"camera"},formation:{type:"spiral",count:5,spacing:0,arcOffset:72,phaseOffset:.05,zOffset:0},count:5,scale:1.5,models:["ice-ring"],animation:{appearAt:0,disappearAt:.45,stagger:.12,enter:{type:"fade",duration:.03,easing:"easeOut"},exit:{type:"burst-fade",duration:.85,easing:"easeIn",burstScale:1.15},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{frost:{start:.35,peak:.7,end:.2,curve:"bell"}},cutout:{strength:.6,primary:{pattern:3,scale:1,weight:1},secondary:{pattern:8,scale:.6,weight:.5},blend:"multiply",strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.6,softness:1.5}},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},atmospherics:[{preset:"mist",targets:["ice-ring"],anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.4}],pulse:{amplitude:.15,frequency:5,easing:"easeInOut",perElement:!0},drift:{speed:.3,distance:.18,pattern:"radial",accelerate:!0},opacityGradient:[1,.9,.8,.7,.6],rotate:[{axis:"z",rotations:2.5,phase:0},{axis:"z",rotations:-2,phase:72},{axis:"z",rotations:1.8,phase:144},{axis:"z",rotations:-2.3,phase:216},{axis:"z",rotations:2,phase:288}],tilt:{axis:"y",oscillate:!0,range:.4,speed:3.5},wobble:{axis:"x",oscillate:!0,range:.15,speed:2,phase:90},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",depthWrite:!1,renderOrder:-8,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.5,arcSpeed:1,arcCount:2},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:-.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.2,models:["ice-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},secondary:{pattern:3,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:-45}],blending:"normal",depthWrite:!1,renderOrder:-6,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:.7,y:.4,z:0},orientation:"camera",startScale:.4,endScale:1.2,scaleEasing:"easeOutCubic"},count:1,scale:1.2,models:["ice-ring"],animation:{appearAt:.12,disappearAt:.5,enter:{type:"scale",duration:.06,easing:"easeOutBack"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.6,end:.2,curve:"bell"}},cutout:{strength:.5,primary:{pattern:8,scale:1,weight:1},secondary:{pattern:3,scale:.7,weight:.4},blend:"multiply",travel:"angular",travelSpeed:2,strengthCurve:"fadeOut"},grain:{type:3,strength:.2,scale:.25,speed:2.5,blend:"multiply"},drift:{speed:.9,distance:.35,direction:{x:-1,y:-.7,z:-.15},easing:"easeInOutCubic"},rotate:[{axis:"z",rotations:1,phase:45}],blending:"normal",depthWrite:!1,renderOrder:-6,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.6,arcSpeed:2,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:1.5,models:["ice-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},secondary:{pattern:8,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:45}],blending:"normal",depthWrite:!1,renderOrder:-10,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}},{type:"anchor",anchor:{landmark:"center",offset:{x:0,y:0,z:0},orientation:"camera",startScale:.5,endScale:1.8,scaleEasing:"easeOutExpo"},count:1,scale:1.5,models:["ice-ring"],animation:{appearAt:.3,disappearAt:.7,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"fade",duration:.28,easing:"easeInCubic"},procedural:{scaleSmoothing:.05,geometryStability:!0},parameterAnimation:{frost:{start:.4,peak:.7,end:.25,curve:"bell"}},cutout:{strength:.5,primary:{pattern:3,scale:.8,weight:1},secondary:{pattern:8,scale:.6,weight:.4},blend:"multiply",travel:"angular",travelSpeed:1.5,strengthCurve:"constant"},grain:{type:3,strength:.2,scale:.25,speed:2,blend:"multiply"},rotate:[{axis:"z",rotations:.001,phase:-45}],blending:"normal",depthWrite:!1,renderOrder:-10,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.35,arcSpeed:1.5,arcCount:1},orientationOverride:"camera"}}}}],glowColor:[.5,.8,1],glowIntensityMin:1,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.012,scaleFrequency:8,scaleGrowth:.015,tremor:.003,tremorFrequency:4}),ol=Qo({name:"icebarrage",emoji:"🏹",type:"blending",description:"Ice crystals orbit mascot then launch upward",duration:1500,beats:4,intensity:1.4,category:"transform",frost:.75,spawnMode:{type:"orbit",orbit:{height:"center",endHeight:"above",radius:1.2,endRadius:2.8,speed:3,easing:"easeIn",startScale:1,endScale:.6,orientation:"vertical"},formation:{type:"ring",count:5},count:5,scale:1.4,models:["crystal-cluster","crystal-medium","crystal-small","ice-spike"],animation:{appearAt:0,disappearAt:.65,stagger:.04,enter:{type:"scale",duration:.08,easing:"easeOutBack"},exit:{type:"burst-fade",duration:.15,easing:"easeIn",burstScale:1.3},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.6,peak:.85,end:.4,curve:"fadeOut"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:1,max:2.2,frequency:6,pattern:"sine"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.7}],rotate:[{axis:"x",rotations:2,phase:0},{axis:"y",rotations:-3,phase:40},{axis:"z",rotations:2.5,phase:100},{axis:"x",rotations:-2,phase:180},{axis:"y",rotations:3,phase:250}],scaleVariance:.2,lifetimeVariance:.1,blending:"normal",renderOrder:12}},glowColor:[.5,.8,1],glowIntensityMin:1.2,glowIntensityMax:2,glowFlickerRate:6,scaleVibration:.015,scaleFrequency:4,scaleGrowth:.02,tremor:.006,tremorFrequency:5}),ll=Qo({name:"iceimpact",emoji:"💥",type:"blending",description:"Ice crystals orbit then crash inward with impact burst",duration:1500,beats:4,intensity:1.5,category:"transform",frost:.8,spawnMode:{type:"orbit",orbit:{height:"above",endHeight:"center",radius:3.5,endRadius:.1,speed:3,easing:"easeOut",startScale:.4,endScale:1.8,orientation:"vertical"},formation:{type:"ring",count:7},count:7,scale:1.4,models:["crystal-cluster","crystal-medium","crystal-small","ice-spike"],animation:{appearAt:0,disappearAt:.6,stagger:.02,enter:{type:"fade",duration:.06,easing:"easeOut"},exit:{type:"burst-fade",duration:.05,easing:"easeOut",burstScale:.2},procedural:{scaleSmoothing:.04,geometryStability:!0},parameterAnimation:{frost:{start:.3,peak:.95,end:.9,curve:"fadeIn"}},pulse:{amplitude:.12,frequency:8,easing:"easeInOut"},emissive:{min:1,max:3,frequency:9,pattern:"sine"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain",velocityInheritance:.7}],rotate:[{axis:"z",rotations:-4,phase:0},{axis:"x",rotations:3.5,phase:50},{axis:"y",rotations:-3,phase:100},{axis:"z",rotations:4,phase:155},{axis:"x",rotations:-3.5,phase:210},{axis:"y",rotations:3,phase:260},{axis:"z",rotations:-4.5,phase:315}],scaleVariance:.2,lifetimeVariance:.08,blending:"normal",renderOrder:12}},glowColor:[.45,.75,1],glowIntensityMin:1.6,glowIntensityMax:2.8,glowFlickerRate:10,scaleVibration:.025,scaleFrequency:6,scaleContract:.05,tremor:.018,tremorFrequency:9});var cl=Qo({name:"icemist",emoji:"🌫️",type:"blending",description:"Cold mist emanating outward from mascot",duration:3e3,beats:4,intensity:.7,category:"emanating",frost:.4,spawnMode:{type:"axis-travel",axisTravel:{axis:"y",start:"center",end:"center",easing:"linear",startScale:.4,endScale:2.2,startDiameter:.5,endDiameter:2.5,orientation:"camera"},formation:{type:"stack",count:1,spacing:0},count:1,scale:1.3,models:["ice-ring"],animation:{appearAt:0,disappearAt:.85,enter:{type:"fade",duration:.15,easing:"easeOut"},exit:{type:"fade",duration:.3,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.2,peak:.5,end:.3,curve:"bell"}},cutout:{strength:.55,primary:{pattern:3,scale:1.2,weight:1},secondary:{pattern:8,scale:1.5,weight:.4},blend:"multiply",travel:"radial",travelSpeed:.8,strengthCurve:"constant",trailDissolve:{enabled:!0,offset:-.3,softness:1.5}},grain:{type:3,strength:.2,scale:.35,speed:.6,blend:"multiply"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.4,sizeScale:1.5,progressCurve:"sustain"}],pulse:{amplitude:.08,frequency:2,easing:"easeInOut"},emissive:{min:.8,max:1.8,frequency:3,pattern:"sine"},blending:"normal",renderOrder:8,modelOverrides:{"ice-ring":{shaderAnimation:{type:1,arcWidth:.95,arcSpeed:.2,arcCount:1},orientationOverride:"camera"}}}},glowColor:[.4,.7,1],glowIntensityMin:.6,glowIntensityMax:1.2,glowFlickerRate:3,scaleVibration:.008,scaleFrequency:2,scaleGrowth:.01}),hl=Qo({name:"iceshiver",emoji:"🥶",type:"blending",description:"Convulsive cold with frost forming on surface",duration:2500,beats:4,intensity:.9,category:"afflicted",frost:.5,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.3,clustering:.2,count:8,scale:.9,models:["crystal-small","crystal-medium","crystal-cluster"],minDistance:.1,animation:{appearAt:.05,disappearAt:.85,stagger:.04,enter:{type:"scale",duration:.12,easing:"easeOutBack"},exit:{type:"fade",duration:.2,easing:"easeIn"},procedural:{scaleSmoothing:.08,geometryStability:!0},parameterAnimation:{frost:{start:.2,peak:.6,end:.3,curve:"bell"}},pulse:{amplitude:.12,frequency:6,easing:"easeInOut"},emissive:{min:.8,max:1.8,frequency:8,pattern:"sine"},atmospherics:[{preset:"mist",targets:null,anchor:"below",intensity:.3,sizeScale:1,progressCurve:"sustain"}],scaleVariance:.35,lifetimeVariance:.25,delayVariance:.1,blending:"normal",renderOrder:10}},shiverAmount:.015,shiverFrequency:14,glowColor:[.5,.75,1],glowIntensityMin:.8,glowIntensityMax:1.6,glowFlickerRate:10,scaleVibration:.018,scaleFrequency:10,scaleContract:.02,tremor:.012,tremorFrequency:14});const ul={blind:{name:"lightBlind",emoji:"☀️",type:"blending",description:"Overwhelmed by blinding radiance, unable to see",duration:2500,beats:4,intensity:1.5,category:"afflicted",radiance:1,spawnMode:{type:"surface",pattern:"crown",embedDepth:.05,cameraFacing:.6,clustering:.2,count:10,scale:1.1,models:["light-ray","sparkle-star","prism-shard"],minDistance:.08,animation:{appearAt:.02,disappearAt:.85,stagger:.01,enter:{type:"flash",duration:.015,easing:"linear"},exit:{type:"fade",duration:.2,easing:"easeOut"},pulse:{amplitude:.2,frequency:8,easing:"easeOut"},flicker:{intensity:.3,rate:15,pattern:"sine"},emissive:{min:1.5,max:4,frequency:10,pattern:"sine"},drift:{direction:"outward",speed:.025,noise:.2},scaleVariance:.25,lifetimeVariance:.2,blending:"additive",renderOrder:20,intensityScaling:{scale:1.4,emissiveMax:1.8,flickerIntensity:1.5}}},flashPeak:.3,flashDecay:.5,glowColor:[1,.98,.9],glowIntensityMin:.8,glowIntensityMax:1.8,glowFlickerRate:8,scaleVibration:.02,scaleFrequency:6,recoilAmount:.01,recoilSpeed:2,decayRate:.2},purify:{name:"lightPurify",emoji:"✨",type:"blending",description:"Cleansed by holy radiance, impurities burning away",duration:3500,beats:5,intensity:1.2,category:"afflicted",radiance:.8,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.5,clustering:.25,count:8,scale:1,models:["sparkle-star","prism-shard","light-ray"],minDistance:.1},waveRate:.4,waveSpread:!0,glowColor:[1,.9,.6],glowIntensityMin:.6,glowIntensityMax:1.2,glowFlickerRate:4,scaleVibration:.025,scaleFrequency:3,scalePulse:!0,riseAmount:.008,riseSpeed:.5,decayRate:.18},cleanse:{name:"lightCleanse",emoji:"🌟",type:"blending",description:"Gentle purifying glow, soothing radiance",duration:4e3,beats:6,intensity:.7,category:"afflicted",radiance:.5,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.12,cameraFacing:.4,clustering:.3,count:5,scale:.85,models:["sparkle-star","prism-shard"],minDistance:.15},gentleWave:!0,glowColor:[1,.95,.85],glowIntensityMin:.7,glowIntensityMax:1,glowFlickerRate:2,scaleVibration:.012,scaleFrequency:2,scalePulse:!0,floatAmount:.004,floatSpeed:1.5,decayRate:.22},radiate:{name:"lightRadiate",emoji:"💫",type:"blending",description:"Powerful light rays emanating in all directions",duration:3e3,beats:4,intensity:1.3,category:"emanating",radiance:.85,spawnMode:{type:"surface",pattern:"spikes",embedDepth:.08,cameraFacing:.45,clustering:.15,count:8,scale:1.15,models:["light-ray","prism-shard","sparkle-star"],minDistance:.1,animation:{appearAt:.08,disappearAt:.88,stagger:.04,enter:{type:"grow",duration:.08,easing:"easeOutBack",overshoot:1.2},exit:{type:"shrink",duration:.12,easing:"easeIn"},pulse:{amplitude:.15,frequency:2.5,easing:"easeInOut",sync:"global"},emissive:{min:1,max:2.5,frequency:3,pattern:"sine"},drift:{direction:"outward",speed:.02,noise:.1},rotate:{axis:"y",speed:.02,oscillate:!1},scaleVariance:.2,lifetimeVariance:.15,blending:"additive",renderOrder:15,intensityScaling:{scale:1.3,emissiveMax:1.5}}},rayCount:8,raySpeed:1.5,rayLength:.6,glowColor:[1,.88,.5],glowIntensityMin:.7,glowIntensityMax:1.4,glowFlickerRate:5,scaleVibration:.03,scaleFrequency:4,scalePulse:!0,scaleExpand:.02,rotationSpeed:.1,decayRate:.15},glow:{name:"lightGlow",emoji:"💡",type:"blending",description:"Soft inner radiance, warmth from within",duration:3500,beats:5,intensity:.6,category:"emanating",radiance:.45,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.15,cameraFacing:.35,clustering:.35,count:5,scale:.8,models:["sparkle-star","prism-shard"],minDistance:.15,animation:{appearAt:.12,disappearAt:.88,stagger:.06,enter:{type:"fade",duration:.12,easing:"easeOutQuad"},exit:{type:"fade",duration:.15,easing:"easeIn"},pulse:{amplitude:.1,frequency:1.5,easing:"easeInOut",sync:"global"},emissive:{min:.6,max:1.2,frequency:1.5,pattern:"sine"},drift:{direction:"up",speed:.008,noise:.05},scaleVariance:.15,lifetimeVariance:.1,blending:"additive",renderOrder:10,intensityScaling:{scale:1.15,emissiveMax:1.3}}},innerGlow:!0,glowSpread:.3,glowColor:[1,.9,.7],glowIntensityMin:.65,glowIntensityMax:.95,glowFlickerRate:2.5,scaleVibration:.015,scaleFrequency:2,scalePulse:!0,floatAmount:.003,floatSpeed:1,decayRate:.2},beacon:{name:"lightBeacon",emoji:"🔦",type:"blending",description:"Bright signal of light, calling attention",duration:2800,beats:4,intensity:1.1,category:"emanating",radiance:.75,spawnMode:{type:"surface",pattern:"crown",embedDepth:.1,cameraFacing:.5,clustering:.2,count:6,scale:1,models:["light-ray","halo-ring","sparkle-star"],minDistance:.12},beaconPulse:!0,pulseRate:1.5,glowColor:[1,.95,.8],glowIntensityMin:.6,glowIntensityMax:1.3,glowFlickerRate:6,scaleVibration:.025,scaleFrequency:3,tremor:.002,tremorFrequency:4,decayRate:.18},ascend:{name:"lightAscend",emoji:"👼",type:"blending",description:"Rising into divine light, transcending form",duration:4e3,beats:6,intensity:1.4,category:"transform",radiance:.9,spawnMode:{type:"surface",pattern:"shell",embedDepth:.05,cameraFacing:.55,clustering:.15,count:10,scale:1.1,models:["light-ray","halo-ring","sparkle-star","prism-shard"],minDistance:.08,animation:{appearAt:.1,disappearAt:.9,stagger:.04,enter:{type:"grow",duration:.1,easing:"easeOutCubic"},exit:{type:"fade",duration:.2,easing:"easeOut"},pulse:{amplitude:.12,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:1,max:2.2,frequency:2.5,pattern:"sine"},drift:{direction:"up",speed:.025,noise:.08},rotate:{axis:"y",speed:.015,oscillate:!1},scaleVariance:.18,lifetimeVariance:.12,blending:"additive",renderOrder:18,intensityScaling:{scale:1.3,emissiveMax:1.5,driftSpeed:1.3}}},ascendRate:.6,ascendAcceleration:.3,glowColor:[1,.92,.65],glowIntensityMin:.7,glowIntensityMax:1.5,glowFlickerRate:3,scaleVibration:.02,scaleFrequency:2,scaleGrow:.04,riseAmount:.03,riseSpeed:.4,rotationSpeed:.08,fadeOut:!0,fadeStartAt:.6,fadeEndAt:.95,fadeCurve:"smooth",decayRate:.1},illuminate:{name:"lightIlluminate",emoji:"🌞",type:"blending",description:"Becoming pure illumination, merging with light",duration:3500,beats:5,intensity:1.5,category:"transform",radiance:.95,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.08,cameraFacing:.5,clustering:.2,count:12,scale:1.15,models:["sparkle-star","light-ray","prism-shard","halo-ring"],minDistance:.06},spreadFromCore:!0,spreadRate:.5,glowColor:[1,.95,.85],glowIntensityMin:.8,glowIntensityMax:1.6,glowFlickerRate:4,scaleVibration:.03,scaleFrequency:3,scaleGrow:.06,scalePulse:!0,floatAmount:.006,floatSpeed:1.2,fadeOut:!0,fadeStartAt:.4,fadeEndAt:.9,fadeCurve:"smooth",decayRate:.12},dissolve:{name:"lightDissolve",emoji:"✴️",type:"blending",description:"Dissolving into particles of light",duration:3e3,beats:4,intensity:1.3,category:"transform",radiance:.8,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.12,cameraFacing:.6,clustering:.25,count:15,scale:.9,models:["sparkle-star","prism-shard"],minDistance:.05},particleDisperse:!0,disperseRate:.4,glowColor:[1,.98,.9],glowIntensityMin:.7,glowIntensityMax:1.4,glowFlickerRate:10,scaleVibration:.04,scaleFrequency:6,scaleShrink:.03,driftAmount:.015,driftSpeed:1.5,fadeOut:!0,fadeStartAt:.3,fadeEndAt:.95,fadeCurve:"accelerating",decayRate:.08},halo:{name:"lightHalo",emoji:"😇",type:"blending",description:"Radiant halo floating above head",duration:3e3,beats:4,intensity:.8,category:"emanating",radiance:1.2,spawnMode:{type:"anchor",anchor:{landmark:"head",offset:{x:0,y:.15,z:0},orientation:"flat",bob:{amplitude:.02,frequency:.3}},count:1,scale:1.5,models:["light-ring"],animation:{appearAt:.1,disappearAt:.9,enter:{type:"grow",duration:.15,easing:"easeOutBack",overshoot:1.1},exit:{type:"fade",duration:.2,easing:"easeIn"},pulse:{amplitude:.08,frequency:.5,easing:"easeInOut"},emissive:{min:1.2,max:2,frequency:.3,pattern:"sine"}}},glowColor:[1,.95,.8],glowIntensityMin:1.3,glowIntensityMax:1.8,glowPulseRate:.5,holyGlow:!0,radianceRays:12},stargate:{name:"lightStargate",emoji:"⭕",type:"blending",description:"Descending light rings that reverse back up like transporters",duration:4e3,beats:6,intensity:1.2,category:"transform",radiance:1.5,spawnMode:{type:"axis-travel",formation:{type:"stack",count:3,spacing:.2,phaseOffset:.08},axisTravel:{axis:"y",start:1.5,end:"bottom",easing:"easeInOut",reverseAt:.5,startDiameter:1.3,endDiameter:.8},count:3,scale:1.3,models:["light-ring"],animation:{appearAt:.05,disappearAt:.95,enter:{type:"grow",duration:.1,easing:"easeOutQuad"},exit:{type:"fade",duration:.15,easing:"easeIn"},emissive:{min:1,max:2.5,frequency:1,pattern:"sine"}}},glowColor:[.9,.95,1],glowIntensityMin:1.4,glowIntensityMax:2.2,glowPulseRate:1.5,transporterBeam:!0,materializeEffect:!0}};function dl(e){return(43758.5453*Math.sin(e)%1+1)%1}function ml(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return dl(t)*(1-a)+dl(t+1)*a}function pl(e){const t=ul[e];return t?{name:t.name,emoji:t.emoji,type:t.type,description:t.description,config:{duration:t.duration,beats:t.beats,intensity:t.intensity,...t},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"transform"===t.category?1.5:1.3,offBeat:1,curve:"smooth"}},"3d":{evaluate(e,i){const a={...t,...i},n=e*a.duration/1e3,{category:s}=a;let r=1;if("afflicted"===s&&(a.flashPeak?e<a.flashPeak?(r=e/a.flashPeak,r=Math.pow(r,.5)):(r=1-(e-a.flashPeak)*a.flashDecay,r=Math.max(.3,r)):e<.2&&(r=e/.2)),"emanating"===s)if(a.beaconPulse){const e=n*a.pulseRate;r=.6+.4*Math.sin(e*Math.PI*2)}else r=Math.min(1,e/.15);"transform"===s&&e<.25&&(r=e/.25,r=Math.pow(r,.7)),e>1-a.decayRate&&(r*=1-(e-(1-a.decayRate))/a.decayRate*.7);let o=0,l=0,c=0;if(a.riseAmount>0){const t=Math.pow(e,1+(a.ascendAcceleration||0));l+=a.riseAmount*t*r}if(a.floatAmount>0){const e=n*a.floatSpeed;l+=Math.sin(e*Math.PI*2)*a.floatAmount*r}if(a.recoilAmount>0){const e=n*a.recoilSpeed,t=Math.sin(e*Math.PI);c-=a.recoilAmount*t*r}if(a.driftAmount>0){const e=n*a.driftSpeed;o+=(ml(e)-.5)*a.driftAmount*r,l+=(ml(e+50)-.5)*a.driftAmount*.5*r,c+=(ml(e+100)-.5)*a.driftAmount*.3*r}if(a.tremor>0){const e=n*a.tremorFrequency;o+=(ml(e)-.5)*a.tremor*r,l+=(ml(e+33)-.5)*a.tremor*.5*r}let h=1;const u=n*a.scaleFrequency;h=a.scalePulse?1+(.5*Math.sin(u*Math.PI*2)+.5-.5)*a.scaleVibration*r:1+Math.sin(u*Math.PI*2)*a.scaleVibration*r,a.scaleGrow>0&&(h+=a.scaleGrow*e*r),a.scaleExpand>0&&(h+=a.scaleExpand*e*r),a.scaleShrink>0&&(h-=a.scaleShrink*e*r),h=Math.max(.1,h);let d=0;a.rotationSpeed>0&&(d=n*a.rotationSpeed*Math.PI*2*r);let m=1;if(a.fadeOut){const t=a.fadeStartAt||.4,i=a.fadeEndAt||.9;if(e>=t){const n=Math.min(1,(e-t)/(i-t));let s;s="accelerating"===a.fadeCurve?1-Math.pow(n,2):1-n,m=Math.max(0,s)}}const p=n*a.glowFlickerRate;let g;g="afflicted"===s&&a.flashPeak?e<2*a.flashPeak?1+.3*Math.sin(p*Math.PI*4):.7+.2*Math.sin(p*Math.PI*2):a.beaconPulse?.4*Math.sin(p*Math.PI*2)+.6:.25*Math.sin(p*Math.PI*2)+.75;const f=a.glowIntensityMin+(a.glowIntensityMax-a.glowIntensityMin)*g*r,y=.4*r*a.intensity*a.radiance;return{lightOverlay:{enabled:r>.1,strength:r*a.intensity,radiance:a.radiance,category:a.category,spawnMode:a.spawnMode||null,time:n},position:[o,l,c],rotation:[0,d,0],scale:h,meshOpacity:m,glowIntensity:f,glowBoost:y,glowColorOverride:a.glowColor}}}}:(console.warn(`[LIGHT_EFFECT] Unknown variant: ${e}, using glow`),pl("glow"))}const gl=pl("blind"),fl=pl("purify"),yl=pl("cleanse"),vl=pl("radiate"),bl=pl("glow"),wl=pl("beacon"),Ml=pl("ascend"),Sl=pl("illuminate"),xl=pl("dissolve"),Cl={infect:{name:"poisonInfect",emoji:"🦠",type:"blending",description:"Poison spreading through body, veins turning toxic",duration:3500,beats:5,intensity:1,category:"afflicted",toxicity:.7,spreadRate:.4,spreadFromCenter:!1,veinPattern:!0,glowColor:[.3,.8,.2],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:4,scaleVibration:.02,scaleFrequency:3,scaleSwell:.015,tremor:.006,tremorFrequency:7,decayRate:.18},sicken:{name:"poisonSicken",emoji:"🤢",type:"blending",description:"Nausea and weakness, poisoned feeling",duration:3e3,beats:4,intensity:.7,category:"afflicted",toxicity:.5,wobbleAmount:.025,wobbleSpeed:2,nauseaWave:!0,glowColor:[.5,.75,.35],glowIntensityMin:.55,glowIntensityMax:.8,glowFlickerRate:3,scaleVibration:.025,scaleFrequency:4,swayAmount:.012,swaySpeed:1.5,droopAmount:.008,droopAcceleration:.4,decayRate:.2},ooze:{name:"poisonOoze",emoji:"🫠",type:"blending",description:"Toxic slime dripping off body",duration:3200,beats:4,intensity:.9,category:"emanating",toxicity:.65,dripRate:.5,dripSpeed:1.2,slimeTrail:!0,glowColor:[.35,.85,.25],glowIntensityMin:.6,glowIntensityMax:.95,glowFlickerRate:5,scaleVibration:.018,scaleFrequency:3,droopAmount:.01,droopAcceleration:.3,decayRate:.18},seep:{name:"poisonSeep",emoji:"💧",type:"blending",description:"Poison slowly leaking out",duration:4e3,beats:6,intensity:.6,category:"emanating",toxicity:.4,leakRate:.25,seepPattern:!0,glowColor:[.4,.7,.3],glowIntensityMin:.6,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:2,scaleShrink:.01,droopAmount:.006,droopAcceleration:.2,decayRate:.22},toxic:{name:"poisonToxic",emoji:"☠️",type:"blending",description:"Toxic cloud surrounding, poisonous aura",duration:3e3,beats:4,intensity:1.1,category:"emanating",toxicity:.8,cloudSpread:.5,cloudDensity:.7,bubbleEffect:!0,glowColor:[.25,.9,.2],glowIntensityMin:.55,glowIntensityMax:1,glowFlickerRate:6,scaleVibration:.03,scaleFrequency:4,scalePulse:!0,floatAmount:.004,floatSpeed:1.5,decayRate:.15},corrode:{name:"poisonCorrode",emoji:"🔥",type:"blending",description:"Acid eating away at form, corrosion spreading",duration:3500,beats:5,intensity:1.3,category:"transform",toxicity:.85,corrosionRate:.5,etchPattern:!0,glowColor:[.6,.85,.15],glowIntensityMin:.6,glowIntensityMax:1.1,glowFlickerRate:7,scaleVibration:.025,scaleFrequency:5,scaleShrink:.04,jitterAmount:.008,jitterFrequency:10,decayRate:.15},melt:{name:"poisonMelt",emoji:"🫠",type:"blending",description:"Melting from acid, losing form",duration:3e3,beats:4,intensity:1.4,category:"transform",toxicity:.9,meltRate:.6,meltFromTop:!0,glowColor:[.5,.9,.2],glowIntensityMin:.65,glowIntensityMax:1.15,glowFlickerRate:5,scaleVibration:.03,scaleFrequency:3,scaleShrink:.08,scaleSquash:!0,droopAmount:.02,droopAcceleration:.5,fadeOut:!0,fadeStartAt:.5,fadeEndAt:.95,fadeCurve:"accelerating",decayRate:.1},decay:{name:"poisonDecay",emoji:"🍂",type:"blending",description:"Rotting and decomposing, falling apart",duration:4e3,beats:6,intensity:1,category:"transform",toxicity:.7,decayPattern:"organic",crumbleRate:.35,glowColor:[.45,.6,.25],glowIntensityMin:.5,glowIntensityMax:.8,glowFlickerRate:3,scaleVibration:.02,scaleFrequency:4,scaleShrink:.05,droopAmount:.015,droopAcceleration:.4,tremor:.005,tremorFrequency:6,fadeOut:!0,fadeStartAt:.4,fadeEndAt:.9,fadeCurve:"smooth",decayRate:.12},dissolve:{name:"poisonDissolve",emoji:"💀",type:"blending",description:"Dissolving into toxic puddle",duration:2800,beats:4,intensity:1.5,category:"transform",toxicity:.95,dissolveRate:.7,puddleSpread:!0,glowColor:[.4,.95,.2],glowIntensityMin:.7,glowIntensityMax:1.2,glowFlickerRate:8,scaleVibration:.035,scaleFrequency:6,scaleShrink:.12,scaleSquash:!0,droopAmount:.025,droopAcceleration:.6,fadeOut:!0,fadeStartAt:.3,fadeEndAt:.9,fadeCurve:"accelerating",decayRate:.08}};function Pl(e){return(43758.5453*Math.sin(e)%1+1)%1}function kl(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return Pl(t)*(1-a)+Pl(t+1)*a}function Dl(e){const t=Cl[e];return t?{name:t.name,emoji:t.emoji,type:t.type,description:t.description,config:{duration:t.duration,beats:t.beats,intensity:t.intensity,...t},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"transform"===t.category?1.4:1.2,offBeat:1,curve:"smooth"}},"3d":{evaluate(e,i){const a={...t,...i},n=e*a.duration/1e3,{category:s}=a;let r=1;"afflicted"===s&&(e<.2&&(r=e/.2),a.nauseaWave)&&(r*=1+.15*Math.sin(n*Math.PI*2)),"emanating"===s&&(e<.15&&(r=e/.15),a.bubbleEffect)&&(r*=.1*Math.sin(n*Math.PI*4)+.9),"transform"===s&&(r=Math.pow(e,.7)),e>1-a.decayRate&&(r*=1-(e-(1-a.decayRate))/a.decayRate);let o=0,l=0,c=0;if(a.droopAmount>0){const t=e*(1+a.droopAcceleration*e);l-=a.droopAmount*t*r}if(a.swayAmount>0){const e=n*a.swaySpeed;o+=Math.sin(e*Math.PI*2)*a.swayAmount*r,c+=Math.cos(e*Math.PI*1.7)*a.swayAmount*.5*r}if(a.wobbleAmount>0){const e=n*a.wobbleSpeed;o+=Math.sin(e*Math.PI*2)*a.wobbleAmount*r,l+=Math.sin(e*Math.PI*3.1+1)*a.wobbleAmount*.3*r}if(a.tremor>0){const e=n*a.tremorFrequency;o+=(kl(e)-.5)*a.tremor*r,l+=(kl(e+50)-.5)*a.tremor*.5*r}if(a.jitterAmount>0){const e=n*a.jitterFrequency;o+=(kl(e)-.5)*a.jitterAmount*r,l+=(kl(e+33)-.5)*a.jitterAmount*.5*r}if(a.floatAmount>0){const e=n*a.floatSpeed;l+=Math.sin(e*Math.PI*2)*a.floatAmount*r}let h=1,u=1;const d=n*a.scaleFrequency;if(h=a.scalePulse?1+(.5*Math.sin(d*Math.PI*2)+.5-.5)*a.scaleVibration*r:1+(.6*Math.sin(d*Math.PI*2)+.4*Math.sin(d*Math.PI*3.3))*a.scaleVibration*r,a.scaleSwell>0&&(h+=a.scaleSwell*e*r),a.scaleShrink>0){const t="transform"===s?Math.pow(e,1.3):e;h-=a.scaleShrink*t*r}u=a.scaleSquash?h*(1-.4*e*r):h,h=Math.max(.1,h),u=Math.max(.1,u);let m=1;if(a.fadeOut){const t=a.fadeStartAt||.4,i=a.fadeEndAt||.9;if(e>=t){const n=Math.min(1,(e-t)/(i-t));let s;s="accelerating"===a.fadeCurve?1-Math.pow(n,2):1-n,m=Math.max(0,s)}}const p=n*a.glowFlickerRate;let g;g=a.bubbleEffect?.5+.25*Math.sin(p*Math.PI*2)+.2*Math.sin(p*Math.PI*3.3+1):.25*Math.sin(p*Math.PI*2)+.75;const f=a.glowIntensityMin+(a.glowIntensityMax-a.glowIntensityMin)*g*r,y=.2*r*a.intensity*a.toxicity;return{poisonOverlay:{enabled:r>.1,strength:r*a.intensity,toxicity:a.toxicity,category:a.category,time:n},position:[o,l,c],rotation:[0,0,0],scale:h,scaleY:a.scaleSquash?u:void 0,meshOpacity:m,glowIntensity:f,glowBoost:y,glowColorOverride:a.glowColor}}}}:(console.warn(`[POISON_EFFECT] Unknown variant: ${e}, using infect`),Dl("infect"))}const Al=Dl("infect"),_l=Dl("sicken"),Tl=Dl("ooze"),Il=Dl("seep"),Ol=Dl("toxic"),Rl=Dl("corrode"),El=Dl("melt"),Bl=Dl("decay"),Fl=Dl("dissolve"),zl={petrify:{name:"earthPetrify",emoji:"🗿",type:"blending",description:"Turning to stone, movement freezing",duration:3500,beats:5,intensity:1.2,category:"afflicted",petrification:.85,spawnMode:{type:"surface",pattern:"shell",embedDepth:.35,cameraFacing:.25,clustering:.15,scale:1,minDistance:.2,animation:{appearAt:.08,disappearAt:.92,stagger:.05,enter:{type:"grow",duration:.12,easing:"easeOutQuad"},exit:{type:"fade",duration:.15,easing:"easeIn"},pulse:{amplitude:.03,frequency:1,easing:"easeInOut",sync:"global"},emissive:{min:.3,max:.5,frequency:1.5,pattern:"sine"},rotate:{axis:"y",speed:.002,oscillate:!0,range:Math.PI/24},scaleVariance:.12,lifetimeVariance:.08,blending:"normal",renderOrder:4,intensityScaling:{scale:1.15,emissiveMax:1.2}}},spreadRate:.4,spreadFromBase:!0,glowColor:[.6,.55,.5],glowIntensityMin:.4,glowIntensityMax:.7,glowFlickerRate:2,scaleVibration:.008,scaleFrequency:2,scaleContract:.01,tremor:.003,tremorFrequency:6,tremorDecay:.8,decayRate:.15},burden:{name:"earthBurden",emoji:"⚖️",type:"blending",description:"Weighed down by immense weight",duration:3e3,beats:4,intensity:.9,category:"afflicted",petrification:.5,weightAmount:.8,crushingForce:!0,glowColor:[.5,.45,.35],glowIntensityMin:.45,glowIntensityMax:.7,glowFlickerRate:2,scaleVibration:.015,scaleFrequency:3,scaleSquash:.04,sinkAmount:.02,sinkAcceleration:.5,decayRate:.18},rumble:{name:"earthRumble",emoji:"🌋",type:"blending",description:"Ground shaking, tremors emanating",duration:2800,beats:4,intensity:1,category:"emanating",petrification:.4,rumbleIntensity:.7,groundWave:!0,spawnMode:"orbit",glowColor:[.55,.45,.3],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:8,scaleVibration:.035,scaleFrequency:10,shakeAmount:.015,shakeFrequency:15,decayRate:.18},quake:{name:"earthQuake",emoji:"🌍",type:"blending",description:"Violent earthquake, ground splitting",duration:2500,beats:4,intensity:1.5,category:"emanating",petrification:.6,quakeIntensity:1,crackPattern:!0,glowColor:[.6,.4,.25],glowIntensityMin:.55,glowIntensityMax:1,glowFlickerRate:12,scaleVibration:.05,scaleFrequency:15,shakeAmount:.025,shakeFrequency:20,decayRate:.15},encase:{name:"earthEncase",emoji:"🪨",type:"blending",description:"Encased in rock shell, stone armor forming",duration:3500,beats:5,intensity:1.1,category:"transform",petrification:.9,spawnMode:{type:"surface",pattern:"shell",embedDepth:.45,cameraFacing:.2,clustering:0,count:14,scale:1.2,minDistance:.15,animation:{appearAt:.06,disappearAt:.9,stagger:.03,enter:{type:"grow",duration:.08,easing:"easeOutQuad"},exit:{type:"fade",duration:.12,easing:"easeIn"},pulse:{amplitude:.02,frequency:.8,easing:"easeInOut",sync:"global"},emissive:{min:.25,max:.45,frequency:1,pattern:"sine"},scaleVariance:.1,lifetimeVariance:.06,blending:"normal",renderOrder:5,intensityScaling:{scale:1.2,emissiveMax:1.15}}},encaseProgress:.8,shellFormation:!0,glowColor:[.45,.42,.38],glowIntensityMin:.4,glowIntensityMax:.65,glowFlickerRate:1.5,scaleVibration:.012,scaleFrequency:2,scaleGrow:.03,tremor:.002,tremorFrequency:3,tremorDecay:.9,decayRate:.12},crumble:{name:"earthCrumble",emoji:"🏚️",type:"blending",description:"Stone crumbling apart, falling to pieces",duration:3e3,beats:4,intensity:1.2,category:"transform",petrification:.7,crumbleRate:.5,debrisFall:!0,spawnMode:"burst",glowColor:[.55,.5,.45],glowIntensityMin:.45,glowIntensityMax:.75,glowFlickerRate:5,scaleVibration:.025,scaleFrequency:6,scaleShrink:.06,tremor:.008,tremorFrequency:8,sinkAmount:.01,sinkAcceleration:.3,fadeOut:!0,fadeStartAt:.5,fadeEndAt:.95,fadeCurve:"smooth",decayRate:.15},shatter:{name:"earthShatter",emoji:"💥",type:"blending",description:"Rock shattering explosively",duration:2e3,beats:3,intensity:1.8,category:"transform",petrification:.8,shatterPoint:.35,explosionForce:.8,fragmentCount:12,spawnMode:"burst",glowColor:[.7,.65,.55],glowIntensityMin:.5,glowIntensityMax:1.3,glowFlickerRate:15,scaleVibration:.06,scaleFrequency:12,shakeAmount:.04,shakeFrequency:25,fadeOut:!0,fadeStartAt:.4,fadeEndAt:.9,fadeCurve:"accelerating",decayRate:.08},erode:{name:"earthErode",emoji:"🏜️",type:"blending",description:"Slowly wearing away, weathering",duration:4500,beats:6,intensity:.7,category:"transform",petrification:.6,erosionRate:.25,windPattern:!0,glowColor:[.65,.55,.4],glowIntensityMin:.5,glowIntensityMax:.75,glowFlickerRate:2,scaleVibration:.01,scaleFrequency:2,scaleShrink:.04,driftAmount:.004,driftSpeed:.5,fadeOut:!0,fadeStartAt:.5,fadeEndAt:.95,fadeCurve:"smooth",decayRate:.2},fossilize:{name:"earthFossilize",emoji:"🦴",type:"blending",description:"Ancient stone transformation, becoming fossil",duration:4e3,beats:6,intensity:1,category:"transform",petrification:.95,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.5,cameraFacing:.15,clustering:.4,count:10,scale:.9,minDistance:.22},ageProgression:.6,ancientPattern:!0,glowColor:[.5,.4,.3],glowIntensityMin:.35,glowIntensityMax:.6,glowFlickerRate:1,scaleVibration:.006,scaleFrequency:1,scaleContract:.02,tremor:.001,tremorFrequency:1,tremorDecay:.95,decayRate:.1}};function Ll(e){return(43758.5453*Math.sin(e)%1+1)%1}function Gl(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return Ll(t)*(1-a)+Ll(t+1)*a}function Vl(e){const t=zl[e];return t?{name:t.name,emoji:t.emoji,type:t.type,description:t.description,config:{duration:t.duration,beats:t.beats,intensity:t.intensity,...t},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"emanating"===t.category?1.5:1.2,offBeat:1,curve:"sharp"}},"3d":{evaluate(e,i){const a={...t,...i},n=e*a.duration/1e3,{category:s}=a;let r=1;"afflicted"===s&&e<.2&&(r=e/.2),"emanating"===s&&e<.1&&(r=e/.1),"transform"===s&&(a.shatterPoint?e<a.shatterPoint?(r=e/a.shatterPoint,r=Math.pow(r,.5)):r=1:r=Math.min(1,e/.25)),e>1-a.decayRate&&(r*=1-(e-(1-a.decayRate))/a.decayRate);let o=0,l=0,c=0;if(a.shakeAmount>0){const t=n*a.shakeFrequency;let i=a.shakeAmount*r;a.shatterPoint&&e>a.shatterPoint&&(i*=1+(e-a.shatterPoint)/(1-a.shatterPoint)*a.explosionForce),o+=(Gl(t)-.5)*i,l+=(Gl(t+33)-.5)*i*.7,c+=(Gl(t+66)-.5)*i*.5}if(a.tremor>0){let t=a.tremor;a.tremorDecay&&(t*=1-e*a.tremorDecay);const i=n*a.tremorFrequency;o+=(Gl(i)-.5)*t*r,l+=(Gl(i+50)-.5)*t*.5*r}if(a.sinkAmount>0){const t=e*(1+a.sinkAcceleration*e);l-=a.sinkAmount*t*r}if(a.driftAmount>0){const e=n*a.driftSpeed;o+=Math.sin(e*Math.PI*2)*a.driftAmount*r,c+=Math.cos(e*Math.PI*1.7)*a.driftAmount*.5*r}let h=1,u=1;const d=n*a.scaleFrequency;h=1+(.5*Math.sin(d*Math.PI*2)+.3*Math.sin(d*Math.PI*3.7))*a.scaleVibration*r,a.scaleContract>0&&(h-=a.scaleContract*e*r),a.scaleShrink>0&&(h-=a.scaleShrink*e*r),a.scaleGrow>0&&(h+=a.scaleGrow*e*r),u=a.scaleSquash>0?h*(1-a.scaleSquash*e*r):h,h=Math.max(.1,h),u=Math.max(.1,u);let m=1;if(a.fadeOut){const t=a.fadeStartAt||.5,i=a.fadeEndAt||.95;if(e>=t){const n=Math.min(1,(e-t)/(i-t));let s;s="accelerating"===a.fadeCurve?1-Math.pow(n,2):1-n,m=Math.max(0,s)}}const p=n*a.glowFlickerRate;let g;"emanating"===s?(g=.3*Math.sin(p*Math.PI*2)+.7,g*=.8+.4*Ll(Math.floor(3*p))):g=a.shatterPoint&&e>a.shatterPoint?1+.5*Gl(5*p):.2*Math.sin(p*Math.PI*2)+.8;const f=a.glowIntensityMin+(a.glowIntensityMax-a.glowIntensityMin)*g*r,y=.1*r*a.intensity*a.petrification;return{earthOverlay:{enabled:r>.1,strength:r*a.intensity,petrification:a.petrification,category:a.category,spawnMode:a.spawnMode||null,time:n},position:[o,l,c],rotation:[0,0,0],scale:h,scaleY:a.scaleSquash>0?u:void 0,meshOpacity:m,glowIntensity:f,glowBoost:y,glowColorOverride:a.glowColor}}}}:(console.warn(`[EARTH_EFFECT] Unknown variant: ${e}, using petrify`),Vl("petrify"))}const Nl=Vl("petrify"),jl=Vl("burden"),ql=Vl("rumble"),Ul=Vl("quake"),Wl=Vl("encase"),Hl=Vl("crumble"),$l=Vl("shatter"),Yl=Vl("erode"),Xl=Vl("fossilize"),Ql={entangle:{name:"natureEntangle",emoji:"🌿",type:"blending",description:"Vines wrapping around, being tangled",duration:3500,beats:5,intensity:1,category:"afflicted",growth:.7,vineCount:6,wrapRate:.4,spiralWrap:!0,spawnMode:{type:"surface",pattern:"spikes",embedDepth:.15,cameraFacing:.2,clustering:.2,count:8,scale:1,models:["vine-tendril","vine-coil","thorn-vine"],minDistance:.15,animation:{appearAt:.1,disappearAt:.88,stagger:.05,enter:{type:"grow",duration:.15,easing:"easeOutCubic"},exit:{type:"shrink",duration:.12,easing:"easeIn"},pulse:{amplitude:.08,frequency:2,easing:"easeInOut"},emissive:{min:.4,max:.7,frequency:2,pattern:"sine"},drift:{direction:"outward",speed:.01,noise:.15},rotate:{axis:[0,1,.5],speed:.008,oscillate:!0,range:Math.PI/10},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:6,intensityScaling:{scale:1.2,driftSpeed:1.15}}},glowColor:[.2,.7,.25],glowIntensityMin:.5,glowIntensityMax:.8,glowFlickerRate:3,scaleVibration:.015,scaleFrequency:2,scaleContract:.02,restrictMovement:!0,tremor:.004,tremorFrequency:5,tremorDecay:.7,rotationTwist:.03,rotationTwistSpeed:.5,decayRate:.18},root:{name:"natureRoot",emoji:"🌱",type:"blending",description:"Roots growing, anchoring to ground",duration:3e3,beats:4,intensity:.9,category:"afflicted",growth:.6,rootDepth:.5,anchorStrength:.8,spreadFromBase:!0,spawnMode:{type:"surface",pattern:"shell",embedDepth:.25,cameraFacing:.1,clustering:.3,count:6,scale:1,models:["root-tendril","moss-patch"],minDistance:.18,animation:{appearAt:.08,disappearAt:.9,stagger:.06,enter:{type:"grow",duration:.12,easing:"easeOutQuad"},exit:{type:"fade",duration:.15,easing:"easeIn"},pulse:{amplitude:.05,frequency:1.2,easing:"easeInOut",sync:"global"},emissive:{min:.3,max:.55,frequency:1.5,pattern:"sine"},drift:{direction:"down",speed:.005,noise:.05},scaleVariance:.15,lifetimeVariance:.1,blending:"normal",renderOrder:4,intensityScaling:{scale:1.15,emissiveMax:1.2}}},glowColor:[.35,.5,.2],glowIntensityMin:.45,glowIntensityMax:.7,glowFlickerRate:2,scaleVibration:.008,scaleFrequency:2,sinkAmount:.015,sinkAcceleration:.3,tremor:.002,tremorFrequency:3,tremorDecay:.9,decayRate:.2},constrict:{name:"natureConstrict",emoji:"🐍",type:"blending",description:"Plants squeezing tight, crushing grip",duration:2800,beats:4,intensity:1.3,category:"afflicted",growth:.8,crushForce:.6,pulsingGrip:!0,vineThickness:.4,spawnMode:{type:"surface",pattern:"shell",embedDepth:.1,cameraFacing:.25,clustering:.4,count:10,scale:1,models:["vine-coil","thorn-vine","vine-tendril"],minDistance:.1,animation:{appearAt:.05,disappearAt:.85,stagger:.025,enter:{type:"grow",duration:.08,easing:"easeOutQuad"},exit:{type:"shrink",duration:.1,easing:"easeInCubic"},pulse:{amplitude:.12,frequency:4,easing:"snap"},emissive:{min:.4,max:.8,frequency:4,pattern:"sine"},drift:{direction:"inward",speed:.015,noise:.08},scaleVariance:.18,lifetimeVariance:.12,blending:"normal",renderOrder:7,intensityScaling:{scale:1.25,pulseAmplitude:1.4,driftSpeed:1.3}}},glowColor:[.25,.75,.2],glowIntensityMin:.55,glowIntensityMax:.9,glowFlickerRate:5,scaleVibration:.025,scaleFrequency:4,scaleContract:.05,scalePulse:!0,tremor:.006,tremorFrequency:8,decayRate:.15},bloom:{name:"natureBloom",emoji:"🌸",type:"blending",description:"Flowers blooming outward, petals spreading",duration:3200,beats:4,intensity:.8,category:"emanating",growth:.75,bloomRate:.5,petalSpread:.6,flowerCount:8,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.4,clustering:.15,count:10,scale:1,models:["flower-bloom","flower-bud","petal-scatter"],minDistance:.15,animation:{appearAt:.12,disappearAt:.9,stagger:.06,enter:{type:"pop",duration:.1,easing:"easeOutBack",overshoot:1.2},exit:{type:"fade",duration:.15,easing:"easeIn"},pulse:{amplitude:.1,frequency:1.8,easing:"easeInOut"},emissive:{min:.5,max:.9,frequency:2,pattern:"sine"},drift:{direction:"up",speed:.008,noise:.12},rotate:{axis:"y",speed:.012,oscillate:!0,range:Math.PI/8},scaleVariance:.2,lifetimeVariance:.15,blending:"normal",renderOrder:8,intensityScaling:{scale:1.2,emissiveMax:1.25}}},glowColor:[.9,.6,.7],glowIntensityMin:.65,glowIntensityMax:1,glowFlickerRate:3,scaleVibration:.02,scaleFrequency:2,scaleGrow:.03,scalePulse:!0,floatAmount:.005,floatSpeed:1.2,rotationSpeed:.05,decayRate:.2},sprout:{name:"natureSprout",emoji:"🌱",type:"blending",description:"New growth emerging, shoots appearing",duration:2800,beats:4,intensity:.6,category:"emanating",growth:.5,sproutCount:5,sproutSpeed:.4,freshGrowth:!0,spawnMode:{type:"surface",pattern:"crown",embedDepth:.15,cameraFacing:.3,clustering:.2,count:6,scale:1,models:["leaf-single","leaf-cluster","fern-frond"],minDistance:.18,animation:{appearAt:.1,disappearAt:.88,stagger:.05,enter:{type:"grow",duration:.12,easing:"easeOutCubic"},exit:{type:"fade",duration:.12,easing:"easeIn"},pulse:{amplitude:.08,frequency:2.5,easing:"easeInOut"},emissive:{min:.5,max:.85,frequency:2.5,pattern:"sine"},drift:{direction:"up",speed:.012,noise:.08},scaleVariance:.18,lifetimeVariance:.12,blending:"normal",renderOrder:7,intensityScaling:{scale:1.18,emissiveMax:1.2}}},glowColor:[.5,.9,.35],glowIntensityMin:.6,glowIntensityMax:.95,glowFlickerRate:4,scaleVibration:.018,scaleFrequency:3,scaleGrow:.025,riseAmount:.008,riseSpeed:.6,decayRate:.18},flourish:{name:"natureFlourish",emoji:"🌳",type:"blending",description:"Lush vegetation spreading, abundant growth",duration:3500,beats:5,intensity:1.1,category:"emanating",growth:.9,vegetationDensity:.8,spreadRate:.5,layeredGrowth:!0,spawnMode:{type:"surface",pattern:"shell",embedDepth:.15,cameraFacing:.3,clustering:.1,count:12,scale:1,models:["leaf-cluster","fern-frond","vine-tendril","flower-bloom"],minDistance:.12,animation:{appearAt:.08,disappearAt:.9,stagger:.035,enter:{type:"grow",duration:.1,easing:"easeOutBack",overshoot:1.15},exit:{type:"fade",duration:.15,easing:"easeIn"},pulse:{amplitude:.1,frequency:2,easing:"easeInOut",sync:"global"},emissive:{min:.55,max:.95,frequency:2,pattern:"sine"},drift:{direction:"outward",speed:.01,noise:.1},rotate:{axis:"y",speed:.01,oscillate:!0,range:Math.PI/10},scaleVariance:.2,lifetimeVariance:.12,blending:"normal",renderOrder:8,intensityScaling:{scale:1.25,emissiveMax:1.3}}},glowColor:[.3,.8,.3],glowIntensityMin:.6,glowIntensityMax:1,glowFlickerRate:3,scaleVibration:.025,scaleFrequency:2,scaleGrow:.05,scalePulse:!0,tremor:.003,tremorFrequency:4,rotationSpeed:.03,decayRate:.15},wilt:{name:"natureWilt",emoji:"🥀",type:"blending",description:"Wilting and drooping, losing vitality",duration:3500,beats:5,intensity:.8,category:"transform",growth:.3,wiltRate:.5,droopPattern:!0,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.2,clustering:.25,count:5,scale:.9,models:["leaf-single","petal-scatter","flower-bud"],minDistance:.2},glowColor:[.6,.65,.3],glowIntensityMin:.4,glowIntensityMax:.65,glowFlickerRate:2,scaleVibration:.012,scaleFrequency:2,scaleShrink:.04,droopAmount:.02,droopAcceleration:.4,rotationTilt:.05,rotationTiltSpeed:.3,fadeOut:!0,fadeStartAt:.5,fadeEndAt:.95,fadeCurve:"smooth",decayRate:.18},overgrow:{name:"natureOvergrow",emoji:"🌲",type:"blending",description:"Completely covered by growth, consumed by nature",duration:4e3,beats:6,intensity:1.3,category:"transform",growth:1,coverageRate:.6,layerCount:4,completeEnvelopment:!0,spawnMode:{type:"surface",pattern:"shell",embedDepth:.2,cameraFacing:.25,clustering:.15,count:15,scale:1.1,models:["vine-coil","leaf-cluster","fern-frond","moss-patch","mushroom-cap"],minDistance:.1},glowColor:[.15,.6,.2],glowIntensityMin:.5,glowIntensityMax:.85,glowFlickerRate:2,scaleVibration:.02,scaleFrequency:2,scaleGrow:.08,tremor:.003,tremorFrequency:3,sinkAmount:.005,sinkAcceleration:.2,rotationTwist:.04,rotationTwistSpeed:.3,fadeOut:!0,fadeStartAt:.6,fadeEndAt:.95,fadeCurve:"smooth",decayRate:.1},blossom:{name:"natureBlossom",emoji:"🌺",type:"blending",description:"Transforming into flower form, becoming one with nature",duration:3500,beats:5,intensity:1,category:"transform",growth:.85,transformRate:.5,petalFormation:!0,colorShift:!0,spawnMode:{type:"surface",pattern:"scattered",embedDepth:.1,cameraFacing:.5,clustering:.2,count:10,scale:1,models:["flower-bloom","petal-scatter","flower-bud","leaf-single"],minDistance:.15},glowColor:[.95,.5,.6],glowIntensityMin:.6,glowIntensityMax:1.05,glowFlickerRate:4,scaleVibration:.025,scaleFrequency:3,scaleGrow:.04,scalePulse:!0,floatAmount:.006,floatSpeed:1,riseAmount:.01,riseSpeed:.4,rotationSpeed:.06,decayRate:.15}};function Kl(e){return(43758.5453*Math.sin(e)%1+1)%1}function Zl(e){const t=Math.floor(e),i=e-t,a=i*i*(3-2*i);return Kl(t)*(1-a)+Kl(t+1)*a}function Jl(e){const t=Ql[e];return t?{name:t.name,emoji:t.emoji,type:t.type,description:t.description,config:{duration:t.duration,beats:t.beats,intensity:t.intensity,...t},rhythm:{enabled:!0,syncMode:"beat",amplitudeSync:{onBeat:"emanating"===t.category?1.4:1.2,offBeat:1,curve:"smooth"}},"3d":{evaluate(e,i){const a={...t,...i},n=e*a.duration/1e3,{category:s}=a;let r=1;"afflicted"===s&&(e<.2&&(r=e/.2),a.pulsingGrip)&&(r*=.15*Math.sin(n*Math.PI*3)+.85),"emanating"===s&&(e<.15&&(r=e/.15),r*=.1*Math.sin(n*Math.PI*2)+.9),"transform"===s&&(r=Math.pow(e,.7)),e>1-a.decayRate&&(r*=1-(e-(1-a.decayRate))/a.decayRate);let o=0,l=0,c=0;if(a.floatAmount>0){const e=n*a.floatSpeed;l+=Math.sin(e*Math.PI*2)*a.floatAmount*r}if(a.riseAmount>0&&(l+=a.riseAmount*e*r),a.droopAmount>0){const t=e*(1+a.droopAcceleration*e);l-=a.droopAmount*t*r}if(a.sinkAmount>0){const t=e*(1+a.sinkAcceleration*e);l-=a.sinkAmount*t*r}if(a.tremor>0){let t=a.tremor;a.tremorDecay&&(t*=1-e*a.tremorDecay);const i=n*a.tremorFrequency;o+=(Zl(i)-.5)*t*r,l+=(Zl(i+50)-.5)*t*.5*r,c+=(Zl(i+100)-.5)*t*.3*r}let h=1;const u=n*a.scaleFrequency;h=a.scalePulse?1+(.5*Math.sin(u*Math.PI*2)+.5-.5)*a.scaleVibration*r:1+(.6*Math.sin(u*Math.PI*2)+.4*Math.sin(u*Math.PI*2.7))*a.scaleVibration*r,a.scaleGrow>0&&(h+=a.scaleGrow*e*r),a.scaleContract>0&&(h-=a.scaleContract*e*r),a.scaleShrink>0&&(h-=a.scaleShrink*e*r),h=Math.max(.1,h);let d=0,m=0,p=0;if(a.rotationSpeed>0&&(m=n*a.rotationSpeed*Math.PI*2*r),a.rotationTwist>0){const e=n*a.rotationTwistSpeed;p=Math.sin(e*Math.PI*2)*a.rotationTwist*r}if(a.rotationTilt>0){const t=e*a.rotationTiltSpeed;d=a.rotationTilt*t*r,p=.5*a.rotationTilt*t*r}let g=1;if(a.fadeOut){const t=a.fadeStartAt||.5,i=a.fadeEndAt||.95;if(e>=t){const n=Math.min(1,(e-t)/(i-t));let s;s="accelerating"===a.fadeCurve?1-Math.pow(n,2):1-n,g=Math.max(0,s)}}const f=n*a.glowFlickerRate;let y;y="emanating"===s?.2*Math.sin(f*Math.PI*2)+.8:a.pulsingGrip?.25*Math.sin(f*Math.PI*2)+.75:.15*Math.sin(f*Math.PI*2)+.85;const v=a.glowIntensityMin+(a.glowIntensityMax-a.glowIntensityMin)*y*r,b=.2*r*a.intensity*a.growth;return{natureOverlay:{enabled:r>.1,strength:r*a.intensity,growth:a.growth,category:a.category,spawnMode:a.spawnMode||null,duration:a.duration,time:n,animation:t.spawnMode?.animation,models:t.spawnMode?.models,count:t.spawnMode?.count,scale:t.spawnMode?.scale,embedDepth:t.spawnMode?.embedDepth},position:[o,l,c],rotation:[d,m,p],scale:h,meshOpacity:g,glowIntensity:v,glowBoost:b,glowColorOverride:a.glowColor}}}}:(console.warn(`[NATURE_EFFECT] Unknown variant: ${e}, using entangle`),Jl("entangle"))}const ec=Jl("entangle"),tc=Jl("root"),ic=Jl("constrict"),ac=Jl("bloom"),nc=Jl("flourish"),sc=Jl("blossom");var rc={name:"morph",emoji:"✨",type:"override",description:"Form geometric patterns and shapes",config:{musicalDuration:{musical:!0,beats:2,minBeats:1,maxBeats:8},phases:[{name:"gather",beats:.25},{name:"form",beats:.75},{name:"hold",beats:.5},{name:"dissolve",beats:.5}],morphType:"fluid",pattern:"star",points:5,innerRadius:.4,size:80,amplitude:20,rotation:0,smooth:!0,randomizeOrder:!1,easing:"sine",strength:1.2,particleMotion:{type:"morph",pattern:"star",strength:1.2,smooth:!0,points:5}},rhythm:{enabled:!0,syncMode:"phrase",patternSync:{verse:"circle",chorus:"star",bridge:"heart",drop:"explosion"},timingSync:{formationBeat:1,holdBeats:2,dissolveBeat:4,curve:"anticipatory"},sizeSync:{onBeat:1.2,offBeat:.95,subdivision:"quarter",curve:"elastic"},rotationSync:{mode:"continuous",degreesPerBar:90,direction:"clockwise"},dynamics:{forte:{points:8,size:100},piano:{points:3,size:60}}},initialize(e,t,i,a,n){e.gestureData||(e.gestureData={});const s={...this.config,...t},r=e.x,o=e.y,l=Math.atan2(e.y-a,e.x-i),c=Math.random()<.5?1:-1;let h,u;const d=s.size*e.scaleFactor,m=(s.rotation||0)*Math.PI/180*c;switch(s.pattern){case"star":h=i,u=a,this.calculateStarPosition(e,l,d,s.points,s.innerRadius,m,i,a);break;case"heart":this.calculateHeartPosition(e,l,d,m,i,a);break;case"square":this.calculateSquarePosition(e,l,d,m,i,a);break;case"triangle":this.calculateTrianglePosition(e,l,d,m,i,a);break;default:{const e=d;h=i+Math.cos(l+m)*e,u=a+Math.sin(l+m)*e;break}}e.gestureData.morph={startX:r,startY:o,targetX:e.gestureData.morphTargetX||h,targetY:e.gestureData.morphTargetY||u,originalVx:e.vx,originalVy:e.vy,rotationDirection:c,initialized:!0}},calculateStarPosition(e,t,i,a,n,s,r,o){const l=((t+Math.PI)%(2*Math.PI)+2*Math.PI)%(2*Math.PI),c=Math.floor(l/(2*Math.PI)*10),h=c%2==0,u=Math.floor(c/2);let d;d=h?72*u*Math.PI/180:(72*u+36)*Math.PI/180,d+=s;const m=h?i:i*n;e.gestureData.morphTargetX=r+Math.cos(d)*m,e.gestureData.morphTargetY=o+Math.sin(d)*m},calculateHeartPosition(e,t,i,a,n,s){const r=(t+Math.PI)/(2*Math.PI),o=.05*i,l=16*Math.pow(Math.sin(r*Math.PI*2),3),c=-(13*Math.cos(r*Math.PI*2)-5*Math.cos(2*r*Math.PI*2)-2*Math.cos(3*r*Math.PI*2)-Math.cos(4*r*Math.PI*2)),h=Math.cos(a),u=Math.sin(a),d=l*h-c*u,m=l*u+c*h;e.gestureData.morphTargetX=n+d*o,e.gestureData.morphTargetY=s+m*o},calculateSquarePosition(e,t,i,a,n,s){const r=((t+a)%(2*Math.PI)+2*Math.PI)%(2*Math.PI);let o,l;const c=i;r<Math.PI/4||r>=7*Math.PI/4?(o=c,l=c*Math.tan(r)):r<3*Math.PI/4?(o=c/Math.tan(r),l=c):r<5*Math.PI/4?(o=-c,l=-c*Math.tan(r)):(o=-c/Math.tan(r),l=-c);const h=Math.cos(a),u=Math.sin(a),d=o*h-l*u,m=o*u+l*h;e.gestureData.morphTargetX=n+d,e.gestureData.morphTargetY=s+m},calculateTrianglePosition(e,t,i,a,n,s){const r=[{x:0,y:-i},{x:.866*-i,y:.5*i},{x:.866*i,y:.5*i}],o=Math.floor((t+Math.PI)/(2*Math.PI)*3)%3,l=(o+1)%3,c=Math.random(),h=r[o].x+(r[l].x-r[o].x)*c,u=r[o].y+(r[l].y-r[o].y)*c,d=Math.cos(a),m=Math.sin(a),p=h*d-u*m,g=h*m+u*d;e.gestureData.morphTargetX=n+p,e.gestureData.morphTargetY=s+g},apply(e,t,i,a,n,s){e.gestureData?.morph?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.morph,o={...this.config,...i};let l,c,h=t;if(o.holdTime>0){const e=.5-o.holdTime/2,i=.5+o.holdTime/2;h=t<e?t/e*.5:t<i?.5:.5+(t-i)/(1-i)*.5}if(h<=.5){const e=2*h;l=r.startX+(r.targetX-r.startX)*this.easeOutQuad(e),c=r.startY+(r.targetY-r.startY)*this.easeOutQuad(e)}else{const e=2*(h-.5);l=r.targetX+(r.startX-r.targetX)*this.easeInQuad(e),c=r.targetY+(r.startY-r.targetY)*this.easeInQuad(e)}if(o.smooth){const t=.2;e.x+=(l-e.x)*t,e.y+=(c-e.y)*t}else e.x=l,e.y=c;if(e.vx=.5*(l-e.x),e.vy=.5*(c-e.y),t>.9){const i=10*(1-t);e.vx=e.vx*i+r.originalVx*(1-i),e.vy=e.vy*i+r.originalVy*(1-i)}},cleanup(e){if(e.gestureData?.morph){const t=e.gestureData.morph;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.morph,delete e.gestureData.morphTargetX,delete e.gestureData.morphTargetY}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutQuad:e=>e*(2-e),easeInQuad:e=>e*e,"3d":{evaluate(e,t){const i=t?.strength||1,a=Math.sin(e*Math.PI);let n;if(e<=.5){const t=2*e;n=1+t*(2-t)*.25*i}else{const t=2*(e-.5);n=1.25*i+t*t*(1-1.25*i),n=Math.max(1,n)}return{position:[0,0,0],rotation:[0,a*Math.PI*.3*i,.1*Math.sin(e*Math.PI*2)*i],scale:n,glowIntensity:1+.4*a*i,glowBoost:1.5*a*i}}}},oc={name:"rain",emoji:"🌧️",type:"override",description:"Particles fall down from their current positions",config:{duration:3e3,musicalDuration:{musical:!0,bars:2},fallSpeed:8,fallDistance:400,wobbleAmount:1.5,strength:1,particleMotion:{type:"rain",strength:1,fallSpeed:8}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:2},intensitySync:{quiet:.5,loud:1.5,crescendo:"increase",diminuendo:"decrease"}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.rain={originalX:e.x,originalY:e.y,originalVx:e.vx,originalVy:e.vy,originalOpacity:e.opacity??e.life??1,currentX:e.x,currentY:e.y,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),initialized:!0},console.log("[RAIN] initialize() - Captured particle position:",{originalX:e.x,originalY:e.y,particleId:e.id||"no-id"})},apply(e,t,i,a){const n="number"==typeof a?a:1;console.log("[RAIN] apply() CALLED - progress:",t?.toFixed?.(3)||t,"dt:",n),e.gestureData?.rain?.initialized||(console.log("[RAIN] apply() - First frame, initializing..."),this.initialize(e,i));const s=e.gestureData.rain,r={...this.config,...i},o=i?.strength||1,l=(r.fallSpeed||8)*o,c=(r.fallDistance||400)*t*o;s.wobblePhase+=s.wobbleSpeed*n*.1;const h=Math.sin(s.wobblePhase)*(r.wobbleAmount||1.5),u=e.y;if(e.x=s.originalX+h,e.y=s.originalY+c,console.log("[RAIN] apply() - Setting position:",{originalY:s.originalY,totalFall:c?.toFixed?.(1)||c,newY:e.y?.toFixed?.(1)||e.y,oldY:u?.toFixed?.(1)||u,progress:t?.toFixed?.(3)||t}),e.vx=.3*h,e.vy=10*l,t>.6){const i=(t-.6)/.4;e.opacity=s.originalOpacity*(1-i),void 0!==e.life&&(e.life=s.originalOpacity*(1-i))}else e.opacity=s.originalOpacity,void 0!==e.life&&(e.life=s.originalOpacity)},cleanup(e){if(e.gestureData?.rain){const t=e.gestureData.rain;e.x=t.originalX,e.y=t.originalY,e.vx=t.originalVx,e.vy=t.originalVy,e.opacity=t.originalOpacity,void 0!==e.life&&(e.life=t.originalOpacity),delete e.gestureData.rain}},"3d":{evaluate:(e,t)=>({position:[0,0,0],rotation:[0,0,0],scale:1})}},lc={name:"drift",emoji:"☁️",type:"override",description:"Controlled floating with fade effects",config:{duration:800,musicalDuration:{musical:!0,beats:2},distance:50,angle:45,returnToOrigin:!0,fadeOut:!1,holdTime:.2,turbulence:.1,angleSpread:45,smoothness:.08,easing:"ease",strength:1,particleMotion:{type:"drift",strength:1,distance:60}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"beats",beats:2},distanceSync:{quiet:30,loud:80,crescendo:"expand",diminuendo:"contract"},angleSync:{major:45,minor:225,modulation:"smooth",cadence:"return"},holdSync:{shortPhrase:.1,longPhrase:.4,fermata:"sustain"},accentResponse:{enabled:!0,multiplier:1.3,type:"distance"},patternOverrides:{ambient:{distanceSync:{quiet:40,loud:100},holdSync:{shortPhrase:.3,longPhrase:.6}},classical:{angleSync:{major:30,minor:210},distanceSync:{quiet:25,loud:60}},jazz:{angleSync:{major:60,minor:240,swing:!0,syncopated:!0}},new_age:{distanceSync:{quiet:35,loud:70},holdSync:{shortPhrase:.4,longPhrase:.8},angleSync:{modulation:"gradual"}}},dynamics:{forte:{distanceSync:{quiet:{multiplier:1.5},loud:{multiplier:1.8}},holdSync:{multiplier:1.2},accentResponse:{multiplier:1.6}},piano:{distanceSync:{quiet:{multiplier:.6},loud:{multiplier:.8}},holdSync:{multiplier:.8},accentResponse:{multiplier:1.1}}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a;let r=Math.atan2(s,n);const o={...this.config,...t}.angleSpread*Math.PI/180,l=(Math.random()-.5)*o;r+=l;const c=30+30*Math.random();e.gestureData.drift={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,baseOpacity:e.opacity||e.life||1,driftAngle:r,angleOffset:l,homeRadius:c*e.scaleFactor,homeX:i+Math.cos(r)*c,homeY:a+Math.sin(r)*c,role:Math.random(),turbulencePhase:Math.random()*Math.PI*2,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.drift?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.drift,o={...this.config,...i},l=i.strength||1,c=this.easeInOutCubic(t),h=Math.max(0,c-.1*r.role);let u,d,m;if(o.returnToOrigin)if(h<.4){const e=h/.4,t=this.easeOutQuad(e);u=r.startX+(r.homeX-r.startX)*t,d=r.startY+(r.homeY-r.startY)*t}else if(h<.6+o.holdTime){const t=(h-.4)/(.2+o.holdTime);m=r.homeRadius+Math.sin(t*Math.PI*.5)*o.distance*l*e.scaleFactor}else{const t=(h-.6-o.holdTime)/(.4-o.holdTime);m=r.homeRadius+Math.cos(t*Math.PI*.5)*o.distance*l*e.scaleFactor}else{const t=h;m=r.homeRadius+t*o.distance*l*e.scaleFactor}if(void 0!==m){r.turbulencePhase+=o.turbulence*a;const e=Math.sin(r.turbulencePhase)*o.turbulence*10,t=Math.cos(1.3*r.turbulencePhase)*o.turbulence*10,i=r.driftAngle+r.angleOffset;u=n+Math.cos(i)*m+e,d=s+Math.sin(i)*m+t}const p=o.smoothness+.08*r.role;if(e.x+=(u-e.x)*p,e.y+=(d-e.y)*p,e.vx=.25*(u-e.x),e.vy=.25*(d-e.y),o.fadeOut){let i;i=t<.25?.3+t/.25*.7:t<.75?.7+.3*Math.sin((t-.25)*Math.PI/.5):4*(1-t),e.opacity=r.baseOpacity*i,void 0!==e.life&&(e.life=e.opacity)}t>=.99&&(e.vx=.1*r.originalVx,e.vy=.1*r.originalVy,o.fadeOut&&(e.opacity=r.baseOpacity,void 0!==e.life&&(e.life=r.baseOpacity)))},cleanup(e){if(e.gestureData?.drift){const t=e.gestureData.drift;e.vx=t.originalVx,e.vy=t.originalVy,e.opacity=t.baseOpacity,void 0!==e.life&&(e.life=t.baseOpacity),delete e.gestureData.drift}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,easeOutQuad:e=>e*(2-e),"3d":{evaluate(e,t){const i={...this.config,...t},a=t.strength||1,n=(i.angle||45)*Math.PI/180,s=i.returnToOrigin?e<.5?2*e:2*(1-e):e;return{position:[Math.cos(n)*s*.3*a,Math.sin(n)*s*.3*a,.15*Math.sin(e*Math.PI)*a],rotation:[0,10*s*a,0],scale:1+.03*Math.sin(e*Math.PI),glowIntensity:1-.1*s}}}};function cc(e){const t=ja[e];if(!t)throw new Error(`Invalid drift direction: ${e}`);const i="up"===e||"down"===e;return{name:`drift${qa(e)}`,emoji:"up"===e?"☁️":"down"===e?"🍃":"left"===e?"🌫️":"💭",type:"override",description:`Gentle drifting ${e}`,config:{duration:800,musicalDuration:{musical:!0,beats:2},distance:50,returnToOrigin:!0,fadeOut:!1,holdTime:.2,turbulence:.1,smoothness:.08,strength:1,direction:e,particleMotion:{type:"drift",strength:1,distance:60}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"beats",beats:2},distanceSync:{quiet:30,loud:80,crescendo:"expand",diminuendo:"contract"},holdSync:{shortPhrase:.1,longPhrase:.4,fermata:"sustain"},accentResponse:{enabled:!0,multiplier:1.3,type:"distance"}},initialize(e,t,i,a){e.gestureData||(e.gestureData={}),this.config;const n=(30+30*Math.random())*e.scaleFactor;e.gestureData.drift={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,baseOpacity:e.opacity||e.life||1,homeRadius:n,role:Math.random(),turbulencePhase:Math.random()*Math.PI*2,initialized:!0}},apply(e,a,n,s,r,o){e.gestureData?.drift?.initialized||this.initialize(e,n,r,o);const l=e.gestureData.drift,c={...this.config,...n},h=n.strength||1,u=this.easeInOutCubic(a),d=Math.max(0,u-.1*l.role);let m,p=l.startX,g=l.startY;m=c.returnToOrigin?d<.5?2*d:2*(1-d):d;const f=c.distance*h*e.scaleFactor*m;l.turbulencePhase+=c.turbulence*s;const y=Math.sin(l.turbulencePhase)*c.turbulence*10,v=Math.cos(1.3*l.turbulencePhase)*c.turbulence*10;i?(g=l.startY+t.y*f+y,p=l.startX+.5*v):(p=l.startX+t.x*f+v,g=l.startY+.5*y);const b=c.smoothness+.08*l.role;if(e.x+=(p-e.x)*b,e.y+=(g-e.y)*b,e.vx=.25*(p-e.x),e.vy=.25*(g-e.y),c.fadeOut){let t=1;t=a<.25?.3+a/.25*.7:a<.75?.7+.3*Math.sin((a-.25)*Math.PI/.5):4*(1-a),e.opacity=l.baseOpacity*t}a>=.99&&(e.vx=.1*l.originalVx,e.vy=.1*l.originalVy,c.fadeOut&&(e.opacity=l.baseOpacity))},cleanup(e){if(e.gestureData?.drift){const t=e.gestureData.drift;e.vx=t.originalVx,e.vy=t.originalVy,e.opacity=t.baseOpacity,delete e.gestureData.drift}},easeInOutCubic:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,"3d":{evaluate(e,a){const n=a||{},s=n.strength||1,r=n.distance||50,o=!1!==n.returnToOrigin?Math.sin(e*Math.PI):e,l=.004*r*s*o,c=t.x*l,h=t.y*l;let u=0,d=0;return i?u=t.y*o*.1:d=t.x*o*.15,{cameraRelativePosition:[c,h,0],rotation:[u,d,0],scale:1+.03*o,glowIntensity:1-.1*o}}}}}var hc=cc("up"),uc=cc("down"),dc=cc("left"),mc=cc("right"),pc={name:"vortex",emoji:"🌀",type:"override",description:"Spiral tornado pattern inward or outward",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},direction:"inward",rotationSpeed:2,pullStrength:1,liftAmount:.5,strength:1,particleMotion:{type:"vortex",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",rotationSync:{onBeat:1.5,offBeat:.8}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-(i||0),s=e.y-(a||0);e.gestureData.vortex={originalX:e.x,originalY:e.y,startAngle:Math.atan2(s,n),startDistance:Math.sqrt(n*n+s*s),initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.vortex?.initialized||this.initialize(e,i,n,s);const r={...this.config,...i},o=e.gestureData.vortex,l="outward"!==r.direction,c=r.rotationSpeed||2,h=r.pullStrength||1,u=t*c*Math.PI*2,d=o.startAngle+u;let m;m=l?1-t*h*.8:1+t*h*.5;const p=o.startDistance*m;e.x=n+Math.cos(d)*p,e.y=s+Math.sin(d)*p,l&&t>.7&&(e.opacity=1-(t-.7)/.3)},cleanup(e){if(e.gestureData?.vortex){const t=e.gestureData.vortex;e.x=t.originalX,e.y=t.originalY,e.opacity=1,delete e.gestureData.vortex}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n="outward"!==i.direction,s=i.rotationSpeed||2,r=i.liftAmount||.5,o=e*s*Math.PI*2*a;let l;l=n?1-.3*e*a:1+.2*e*a;const c=e>.85?(1-e)/.15:1;return{position:[0,Math.sin(e*Math.PI)*r*.1*a*c,0],rotation:[.1*Math.sin(o)*a*c,o,.1*Math.cos(o)*a*c],scale:l,glowIntensity:1+.4*e,glowBoost:.3*e}}}};function gc(e){if(!ja[e])throw new Error(`Invalid cascade direction: ${e}`);const t="up"===e||"down"===e,i="down"===e||"right"===e;return{name:`cascade${qa(e)}`,emoji:"down"===e?"🌊":"up"===e?"✨":"left"===e?"🍂":"🌬️",type:"override",description:`Sequential cascade ${e}`,config:{duration:2e3,musicalDuration:{musical:!0,bars:1},distance:200,waveCount:4,staggerDelay:.15,wobble:1,strength:1,direction:e,particleMotion:{type:"cascade",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",distanceSync:{quiet:100,loud:300,crescendo:"expand",diminuendo:"contract"}},initialize(e,t){e.gestureData||(e.gestureData={});const i=t?.waveCount||4;let a;a=Math.floor(Math.random()*i),e.gestureData.cascade={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??e.life??1,waveGroup:a,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),initialized:!0}},apply(e,a,n,s,r,o){e.gestureData?.cascade?.initialized||this.initialize(e,n);const l={...this.config,...n},c=l.strength||1,h=e.gestureData.cascade,u="number"==typeof s?s:1,d=l.waveCount||4,m=l.staggerDelay||.15,p=h.waveGroup*m,g=Math.max(0,(a-p)/(1-p*(d-1)/d));if(g<=0)return;const f=(1-Math.pow(1-g,2))*((l.distance||200)*c)*(i?1:-1);h.wobblePhase+=h.wobbleSpeed*u*.1;const y=Math.sin(h.wobblePhase)*(l.wobble||1)*10;if(t?(e.y=h.originalY+f,e.x=h.originalX+y):(e.x=h.originalX+f,e.y=h.originalY+y),g>.6){const t=(g-.6)/.4;e.opacity=h.originalOpacity*(1-t)}},cleanup(e){if(e.gestureData?.cascade){const t=e.gestureData.cascade;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.cascade}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.direction||"down",s=1-Math.pow(1-e,2);let r=0,o=0;const l=.3*s*a;switch(n){case"down":o=-l;break;case"up":o=l;break;case"left":r=-l;break;case"right":r=l}const c=.03*Math.sin(e*Math.PI*4)*a;"down"===n||"up"===n?r+=c:o+=c;const h=e>.85?(1-e)/.15:1;return{cameraRelativePosition:[r*h,o*h,0],rotation:[("down"===n?.05:"up"===n?-.05:0)*a*h,0,("left"===n?.1:"right"===n?-.1:0)*a*h],scale:1-.1*s,glowIntensity:1+.2*(1-s)}}}}}var fc=gc("up"),yc=gc("down"),vc=gc("left"),bc=gc("right"),wc={name:"confetti",emoji:"🎊",type:"effect",description:"Celebratory confetti flutter with chaotic rotation",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},burstHeight:.3,fallSpeed:1,tumbleSpeed:2,spread:1,strength:1,particleMotion:{type:"confetti",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1.5},timingSync:"onBeat"},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.confetti={originalX:e.x,originalY:e.y,driftX:2*(Math.random()-.5),tumblePhase:Math.random()*Math.PI*2,tumbleSpeed:.5+1.5*Math.random(),flutterAmp:.3+.7*Math.random(),initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.confetti?.initialized||this.initialize(e,i);const r={...this.config,...i},o=r.strength||1,l=e.gestureData.confetti,c=Math.min(t/.2,1),h=Math.max(0,(t-.2)/.8),u=-50*Math.sin(c*Math.PI)*(r.burstHeight||.3),d=h*h*200*(r.fallSpeed||1),m=20*Math.sin(t*Math.PI*8*l.tumbleSpeed)*l.flutterAmp,p=l.driftX*t*100*(r.spread||1);e.x=l.originalX+p+m*o,e.y=l.originalY+u+d*o,t>.7&&(e.opacity=1-(t-.7)/.3)},cleanup(e){e.gestureData?.confetti&&delete e.gestureData.confetti},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1,a=Math.min(e/.2,1),n=Math.max(0,(e-.2)/.8),s=.15*Math.sin(a*Math.PI)-n*n*.3,r=e*Math.PI*4,o=.3*Math.sin(1.3*r)*i,l=.4*Math.sin(.7*r)*i,c=.5*Math.sin(1.1*r)*i,h=e>.85?(1-e)/.15:1;return{position:[.08*Math.sin(e*Math.PI*6)*i*h,s*i*h,0],rotation:[o*h,l*h,c*h],scale:1+.1*Math.sin(2*r)*i,glowIntensity:1+.3*(1-n)}}}},Mc={name:"fizz",emoji:"🫧",type:"override",description:"Bubbles rising upward with wobble",config:{duration:2500,musicalDuration:{musical:!0,bars:1.5},riseSpeed:6,riseDistance:300,wobbleAmount:2,strength:1,particleMotion:{type:"fizz",strength:1}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:1.5},intensitySync:{quiet:.5,loud:1.5}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.fizz={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??e.life??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.4+.6*Math.random(),riseMultiplier:.7+.6*Math.random(),initialized:!0}},apply(e,t,i,a){e.gestureData?.fizz?.initialized||this.initialize(e,i);const n={...this.config,...i},s=n.strength||1,r=e.gestureData.fizz,o="number"==typeof a?a:1,l=(n.riseDistance||300)*t*s*r.riseMultiplier;r.wobblePhase+=r.wobbleSpeed*o*.1;const c=Math.sin(r.wobblePhase)*(n.wobbleAmount||2)*(1+t);if(e.x=r.originalX+c,e.y=r.originalY-l,e.vx=.3*c,e.vy=10*-(n.riseSpeed||6),t>.6){const i=(t-.6)/.4;e.opacity=r.originalOpacity*(1-i),void 0!==e.life&&(e.life=r.originalOpacity*(1-i))}},cleanup(e){if(e.gestureData?.fizz){const t=e.gestureData.fizz;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,void 0!==e.life&&(e.life=t.originalOpacity),delete e.gestureData.fizz}},"3d":{evaluate(e,t){const i=(t.config||this.config||{}).strength||1;let a=0,n=1,s=1;if(e<.15){const t=e/.15;a=.15*t,n=1+.02*t,s=1+.15*t}else if(e<.7){const t=(e-.15)/.55;a=.5-.15*t,n=1.02+.03*Math.sin(t*Math.PI*6),s=1.2+.15*Math.sin(t*Math.PI*8)}else{const t=(e-.7)/.3;a=.35*(1-t),n=1.02-.02*t,s=1.2-.2*t}const r=35*e;return{position:[.008*Math.sin(1.7*r)*a*i,.006*Math.sin(2.3*r)*a*i,.004*Math.sin(1.9*r)*a*i],rotation:[.03*Math.sin(1.3*r)*a*i,.02*Math.sin(1.1*r)*a*i,.04*Math.sin(1.5*r)*a*i],scale:[n+.015*Math.sin(2.1*r)*a,n+.02*Math.sin(1.8*r)*a,n+.015*Math.sin(2.4*r)*a],glowIntensity:s,glowBoost:.2*a}}}};function Sc(e){const t=ja[e];if(!t)throw new Error(`Invalid swarm direction: ${e}`);return{name:`swarm${qa(e)}`,emoji:"up"===e?"🦅":"down"===e?"🦆":"🐟",type:"override",description:`Flock movement ${e}`,config:{duration:1800,musicalDuration:{musical:!0,bars:1},clusterPhase:.3,moveDistance:120,clusterTightness:.5,wobble:1,strength:1,direction:e,particleMotion:{type:"swarm",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat"},initialize(e,t,i,a){e.gestureData||(e.gestureData={}),e.gestureData.swarm={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??1,wobblePhase:Math.random()*Math.PI*2,wobbleSpeed:.3+.4*Math.random(),timeOffset:.1*Math.random(),initialized:!0}},apply(e,i,a,n,s,r){e.gestureData?.swarm?.initialized||this.initialize(e,a,s,r);const o={...this.config,...a},l=o.strength||1,c=e.gestureData.swarm,h=o.clusterPhase||.3,u=o.moveDistance||120,d=o.clusterTightness||.5,m=Math.max(0,Math.min(1,i-c.timeOffset));let p,g;if(m<h){const e=m/h,t=1-Math.pow(1-e,2);p=c.originalX+(s-c.originalX)*d*t,g=c.originalY+(r-c.originalY)*d*t}else{const e=(m-h)/(1-h),i=1-Math.pow(1-e,2),a=c.originalX+(s-c.originalX)*d,n=c.originalY+(r-c.originalY)*d;p=a+t.x*u*i*l,g=n+t.y*u*i*l}const f="number"==typeof n?n:1;c.wobblePhase+=c.wobbleSpeed*f*.1;const y=Math.sin(3*c.wobblePhase)*o.wobble*5,v=Math.cos(2.5*c.wobblePhase)*o.wobble*5;e.x=p+y,e.y=g+v,m>.8&&(e.opacity=c.originalOpacity*(1-5*(m-.8)))},cleanup(e){if(e.gestureData?.swarm){const t=e.gestureData.swarm;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.swarm}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.direction||"up",s=i.clusterPhase||.3,[r,o]={up:[0,1],down:[0,-1],left:[-1,0],right:[1,0]}[n]||[0,1];let l=0,c=0,h=1;if(e<s)h=1-e/s*.1*a;else{const t=(e-s)/(1-s),i=1-Math.pow(1-t,2);l=r*i*.25*a,c=o*i*.25*a,h=.9+.1*t}const u=e>s?.1:0,d=e>.85?(1-e)/.15:1;return{cameraRelativePosition:[(l+.02*Math.sin(e*Math.PI*6)*a)*d,c*d,0],rotation:[o*u*a,0,-r*u*a],scale:h,glowIntensity:1+(e>s?.2:0)}}}}}var xc=Sc("up"),Cc=Sc("down"),Pc=Sc("left"),kc=Sc("right"),Dc={name:"burst",emoji:"💥",type:"blending",description:"Explosive outward burst from center",config:{decay:.5,strength:2},rhythm:{enabled:!0,syncMode:"beat",strengthSync:{onBeat:3.5,offBeat:1,curve:"explosion"},decaySync:{mode:"tempo",fast:.8,slow:.3,curve:"exponential"},durationSync:{mode:"beats",beats:.5,sustain:!1},accentResponse:{enabled:!0,multiplier:2.5,type:"strength"},patternOverrides:{rock:{strengthSync:{onBeat:4,offBeat:1.5},decaySync:{fast:.6,slow:.4}},electronic:{strengthSync:{onBeat:3.8,offBeat:.8,curve:"sharp"},decaySync:{fast:.9,slow:.7}},jazz:{strengthSync:{onBeat:2.8,offBeat:1.8,swing:!0},decaySync:{fast:.5,slow:.2}},orchestral:{strengthSync:{onBeat:3.2,offBeat:.5},accentResponse:{multiplier:3}}},dynamics:{forte:{strengthSync:{onBeat:{multiplier:2},offBeat:{multiplier:1.5}},decaySync:{multiplier:.7},accentResponse:{multiplier:3.5}},piano:{strengthSync:{onBeat:{multiplier:.6},offBeat:{multiplier:.3}},decaySync:{multiplier:1.3},accentResponse:{multiplier:1.8}}}},apply(e,t,i,a,n,s){const r=i.decay||this.config.decay,o=(i.strength||this.config.strength)*(1-t*r),l=e.x-n,c=e.y-s,h=Math.sqrt(l*l+c*c);h>1&&(e.vx+=l/h*o*2*a,e.vy+=c/h*o*2*a)},"3d":{evaluate(e,t){const i=t.strength||2;let a=0,n=1,s=1,r=0;if(e<.15){const t=e/.15,o=1-Math.pow(1-t,3);a=.15*o*i,n=1+.2*o*i,s=1+.5*o,r=.4*o}else if(e<.35){const t=(e-.15)/.2;a=.15*(1-1.5*t)*i,n=1+.2*(1-t)*i-.1*Math.sin(t*Math.PI),s=1+.4*(1-t),r=.2*(1-t)}else{const t=(e-.35)/.65,r=Math.pow(1-t,2),o=Math.sin(t*Math.PI*2)*r;a=.03*o*i,n=1+.05*o,s=1+.15*Math.abs(o)}return{cameraRelativePosition:[0,0,a],position:[0,0,0],rotation:[0,0,0],scale:n,glowIntensity:s,glowBoost:r}}}};function Ac(e){const t=ja[e];if(!t)throw new Error(`Invalid burst direction: ${e}`);const i="up"===e||"down"===e;return{name:`burst${qa(e)}`,emoji:"up"===e?"⛲":"down"===e?"🚿":"💨",type:"blending",description:`Explosive burst ${e}`,config:{duration:600,musicalDuration:{musical:!0,beats:1},decay:.5,strength:2,spread:.3,direction:e,particleMotion:{type:"burst",strength:2,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",strengthSync:{onBeat:3.5,offBeat:1,curve:"explosion"},accentResponse:{enabled:!0,multiplier:2.5,type:"strength"}},apply(e,a,n,s,r,o){const l={...this.config,...n},c=l.decay||.5,h=(l.strength||2)*(1-a*c),u=l.spread||.3;let d=t.x*h*2,m=t.y*h*2;const p=(Math.random()-.5)*u*h;i?d+=p:m+=p,e.vx+=d*s,e.vy+=m*s},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||2,n=i.direction||"up";let s=0,r=0,o=0,l=1,c=1,h=0;const[u,d]={up:[0,1],down:[0,-1],left:[-1,0],right:[1,0]}[n]||[0,1];if(e<.15){const t=e/.15,i=1-Math.pow(1-t,3);s=u*i*.2*a,r=d*i*.2*a,o=.1*i*a,l=1+.15*i*a,c=1+.5*i,h=.4*i}else if(e<.35){const t=(e-.15)/.2,i=1-1.5*t;s=.2*u*i*a,r=.2*d*i*a,o=.1*i*a,l=1+.15*(1-t)*a,c=1+.4*(1-t),h=.2*(1-t)}else{const t=(e-.35)/.65,i=Math.pow(1-t,2),n=Math.sin(t*Math.PI*2)*i;s=u*n*.05*a,r=d*n*.05*a,l=1+.05*n,c=1+.15*Math.abs(n)}return{cameraRelativePosition:[s,r,o],position:[0,0,0],rotation:[0,0,0],scale:l,glowIntensity:c,glowBoost:h}}}}}var _c=Ac("up"),Tc=Ac("down"),Ic=Ac("left"),Oc=Ac("right"),Rc={name:"ripple",emoji:"🌊",type:"effect",description:"Concentric waves emanating from center",config:{duration:1500,musicalDuration:{musical:!0,bars:1},waveCount:3,waveSpeed:1,amplitude:15,damping:.7,strength:1,particleMotion:{type:"ripple",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",amplitudeSync:{onBeat:1.5,offBeat:.8}},apply(e,t,i,a,n,s){const r={...this.config,...i},o=r.strength||1,l=r.waveCount||3,c=r.amplitude||15,h=r.damping||.7,u=e.x-n,d=e.y-s,m=Math.sqrt(u*u+d*d),p=(m/50-t*l*2)*Math.PI,g=Math.pow(1-t,h),f=Math.sin(p)*c*o*g;if(m>1){const t=.5*Math.cos(p)*o*g;e.x+=u/m*t,e.y+=d/m*t}e.opacity=Math.max(.3,1-.3*Math.abs(f/c))},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.waveCount||3,s=i.damping||.7,r=Math.pow(1-e,s),o=e*Math.PI*n*2,l=Math.sin(o),c=e*Math.PI*4,h=Math.sin(c)*a*r,u=.5*Math.sin(c+Math.PI/2)*a*r,d=.12,m=1-h*d+u*d*.3,p=1+h*d,g=1-h*d-u*d*.3,f=.08*(p-1);return{position:[.01*Math.sin(1.5*c)*r,f,0],rotation:[.04*l*a*r,0,.03*u*a*r],scale:[m,p,g],glowIntensity:1+.3*Math.abs(h),glowBoost:.25*Math.max(0,h)*r}}}},Ec={name:"wave",emoji:"🌊",type:"override",description:"Infinity pattern flow with phasing",config:{musicalDuration:{musical:!0,bars:1,minBeats:4,maxBeats:16},phases:[{name:"gather",beats:.5},{name:"rise",beats:.5},{name:"waveLeft",beats:1},{name:"waveRight",beats:1},{name:"settle",beats:1}],amplitude:40,frequency:1,phaseShift:.3,liftHeight:20,fadeInOut:!0,smoothness:.1,easing:"sine",strength:1,particleMotion:{type:"wave",strength:1,amplitude:50}},rhythm:{enabled:!0,syncMode:"wave",amplitudeSync:{onWave:65,onStatic:25,curve:"flowing"},frequencySync:{mode:"phrase",slow:.7,fast:1.8,curve:"melodic"},durationSync:{mode:"bars",adaptToPhrase:!0,sustain:!0},phaseSync:{enabled:!0,multiplier:.5,type:"ensemble"},melodicResponse:{enabled:!0,multiplier:1.4,type:"amplitude"},patternOverrides:{ambient:{amplitudeSync:{onWave:80,onStatic:40,curve:"hypnotic"},frequencySync:{slow:.5,fast:1.2},durationSync:{minBeats:16,maxBeats:64}},ocean:{amplitudeSync:{onWave:90,onStatic:20,curve:"natural"},phaseSync:{multiplier:.8},melodicResponse:{multiplier:1.8}},electronic:{amplitudeSync:{onWave:70,onStatic:30,curve:"digital"},frequencySync:{slow:.8,fast:2.5,curve:"precise"}},orchestral:{amplitudeSync:{onWave:75,onStatic:35},phaseSync:{multiplier:.7},melodicResponse:{multiplier:2}}},dynamics:{forte:{amplitudeSync:{onWave:{multiplier:1.8},onStatic:{multiplier:1.4}},frequencySync:{multiplier:1.3},melodicResponse:{multiplier:2.2}},piano:{amplitudeSync:{onWave:{multiplier:.6},onStatic:{multiplier:.4}},frequencySync:{multiplier:.7},melodicResponse:{multiplier:1.1}}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-i,s=e.y-a,r=Math.atan2(s,n),o=Math.sqrt(n*n+s*s),l=Math.random()<.5?1:-1;e.gestureData.wave={startX:e.x,startY:e.y,originalVx:e.vx,originalVy:e.vy,baseOpacity:e.opacity||e.life||1,angle:r,radius:o,offset:Math.random()*Math.PI*2,role:Math.random(),direction:l,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.wave?.initialized||this.initialize(e,i,n,s);const r=e.gestureData.wave,o={...this.config,...i},l=i.strength||1,c=this.easeInOutSine(t),h=r.role*o.phaseShift,u=Math.max(0,c-h),d=u*Math.PI*2*o.frequency*r.direction+r.offset,m=.5+r.radius/100*.5,p=o.amplitude*m*l*e.scaleFactor,g=n+Math.sin(d)*p,f=s+Math.sin(2*d)*p*.3+-Math.abs(Math.sin(c*Math.PI))*o.liftHeight*e.scaleFactor,y=o.smoothness+.12*r.role;if(e.x+=(g-e.x)*y,e.y+=(f-e.y)*y,e.vx=.3*(g-e.x),e.vy=.3*(f-e.y),o.fadeInOut){let t;t=u<.1?u/.1:u>.9?(1-u)/.1:.5+.5*Math.sin(u*Math.PI),e.opacity=r.baseOpacity*(.3+.7*t),void 0!==e.life&&(e.life=e.opacity)}if(t>=.95){const i=20*(1-t);e.vx=e.vx*i+r.originalVx*(1-i),e.vy=e.vy*i+r.originalVy*(1-i),o.fadeInOut&&(e.opacity=r.baseOpacity*i,void 0!==e.life&&(e.life=e.opacity))}},cleanup(e){if(e.gestureData?.wave){const t=e.gestureData.wave;e.vx=t.originalVx,e.vy=t.originalVy,e.opacity=t.baseOpacity,void 0!==e.life&&(e.life=t.baseOpacity),delete e.gestureData.wave}},easeInOutSine:e=>-(Math.cos(Math.PI*e)-1)/2,"3d":{evaluate(e,t){const i=t?.strength||1,a=t?.frequency||1,n=-(Math.cos(Math.PI*e)-1)/2,s=n*Math.PI*2*a,r=.12*Math.sin(s)*i,o=.06*Math.sin(2*s)*i,l=.03*Math.sin(s)*i,c=.08*Math.sin(2*s)*i,h=.05*Math.sin(s)*i,u=1+.08*Math.abs(Math.sin(n*Math.PI))*i,d=Math.abs(Math.sin(s));return{position:[r,o,l],rotation:[c,0,h],scale:u,glowIntensity:1+.3*d*i,glowBoost:.6*d*i}}}},Bc={name:"flash",emoji:"⚡",type:"blending",description:"Bright flash burst effect",config:{duration:400,glowAmount:2.5,glowPeak:3,scalePeak:1.1,easing:"cubic",strength:1,particleMotion:{type:"burst",strength:1,decay:.3}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"immediate",interruptible:!0,priority:8,blendable:!0,intensitySync:{onBeat:3.5,offBeat:1,accent:5,subdivision:"quarter",curve:"exponential"},durationSync:{mode:"tempo",baseDuration:400,scaling:"inverse"},scaleSync:{onBeat:1.2,offBeat:1,accent:1.4,curve:"elastic"},strobeSync:{enabled:!1,pattern:"XXOX",subdivision:"sixteenth"},dynamics:{forte:{glowPeak:4,scalePeak:1.3,duration:300},piano:{glowPeak:2,scalePeak:1.05,duration:500}}},initialize(e,t){e.gestureData||(e.gestureData={}),e.gestureData.flash={originalOpacity:e.opacity,originalSize:e.size,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.flash?.initialized||this.initialize(e,i);const r=e.gestureData.flash,o={...this.config,...i},l=o.strength||1;let c;if(c=t<.3?t/.3*o.glowPeak:o.glowPeak*(1-(t-.3)/.7),e.opacity=Math.min(1,r.originalOpacity*(1+c*l)),e.size=r.originalSize*(1+(o.scalePeak-1)*c*l*.1),t<.2){const i=(1-t/.2)*l,r=Math.atan2(e.y-s,e.x-n);e.vx+=Math.cos(r)*i*2*a,e.vy+=Math.sin(r)*i*2*a}e.vx*=1-.1*o.particleMotion.decay,e.vy*=1-.1*o.particleMotion.decay},cleanup(e){e.gestureData?.flash&&(e.opacity=e.gestureData.flash.originalOpacity,e.size=e.gestureData.flash.originalSize,delete e.gestureData.flash)},"3d":{evaluate(e,t){const i={...this.config,...t};let a;t.strength,a=e<.3?e/.3:1-(e-.3)/.7;const n=1+.4*a;return{position:[0,0,0],rotation:[0,0,0],scale:1+a*((i.scalePeak||1.1)-1),glowIntensity:n,glowBoost:2*a}}}},Fc={name:"glow",emoji:"✨",type:"blending",description:"Pure luminous glow without movement",config:{duration:1500,amplitude:0,frequency:1,holdPeak:.3,easing:"sine",scaleAmount:.1,glowAmount:.8,strength:0,direction:"none",particleMotion:{type:"glow",strength:0,direction:"none",frequency:1}},rhythm:{enabled:!0,syncMode:"phrase",amplitudeSync:{onBeat:2,offBeat:1.2,curve:"smooth"},frequencySync:{mode:"phrase",subdivision:"bar"},durationSync:{mode:"bars",bars:2},accentResponse:{enabled:!0,multiplier:2.5},patternOverrides:{ambient:{amplitudeSync:{onBeat:2.5,offBeat:1.8},durationSync:{bars:4}},electronic:{amplitudeSync:{onBeat:3,offBeat:.5,curve:"sharp"},frequencySync:{subdivision:"quarter"}}}},initialize(e,t,i,a){e.gestureData||(e.gestureData={}),e.gestureData.glow={startOpacity:e.opacity,startGlow:e.glowSizeMultiplier||0,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.glow?.initialized||this.initialize(e,i,n,s);const r={...this.config,...i},o=this.easeInOutSine(t);let l,{frequency:c}=r,{glowAmount:h}=r;i.rhythmModulation&&(h*=i.rhythmModulation.amplitudeMultiplier||1,h*=i.rhythmModulation.accentMultiplier||1,i.rhythmModulation.frequencyMultiplier&&(c*=i.rhythmModulation.frequencyMultiplier));const u=o*c*2%2;l=r.holdPeak>0&&u>1-r.holdPeak&&u<1+r.holdPeak?1:Math.sin(o*Math.PI*2*c);let d=1;t>.9&&(d=.5+.5*(1-10*(t-.9))),e.glowIntensity=1+l*h*d},cleanup(e){e.gestureData?.glow&&(e.glowIntensity=1,delete e.gestureData.glow)},easeInOutSine:e=>-(Math.cos(Math.PI*e)-1)/2,"3d":{evaluate(e,t){const i={...this.config,...t},a=-(Math.cos(Math.PI*e)-1)/2,n=Math.sin(a*Math.PI);let s=i.glowAmount||.8;t.rhythmModulation&&(s*=t.rhythmModulation.amplitudeMultiplier||1,s*=t.rhythmModulation.accentMultiplier||1);const r=1+n*s;return{position:[0,0,0],rotation:[0,0,0],scale:1+n*(i.scaleAmount||.1)*.5,glowIntensity:r,glowBoost:1.5*n}}}},zc={name:"bloom",emoji:"🌸",type:"effect",description:"Particles unfold outward like flower petals opening",config:{duration:1500,musicalDuration:{musical:!0,bars:1},petalCount:6,openingSpeed:1,rotationAmount:.3,strength:1,particleMotion:{type:"bloom",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"bars",bars:1},timingSync:"onBeat",amplitudeSync:{onBeat:1.3,offBeat:.8}},initialize(e,t,i,a){e.gestureData||(e.gestureData={});const n=e.x-(i||0),s=e.y-(a||0);e.gestureData.bloom={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??1,startAngle:Math.atan2(s,n),startDistance:Math.sqrt(n*n+s*s),initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.bloom?.initialized||this.initialize(e,i,n,s);const r={...this.config,...i},o=r.strength||1,l=e.gestureData.bloom,c=Math.pow(t,.7),h=(r.rotationAmount||.3)*Math.PI,u=Math.sin(c*Math.PI)*h,d=1+.5*c*o,m=l.startDistance*d,p=l.startAngle+u;e.x=n+Math.cos(p)*m,e.y=s+Math.sin(p)*m,e.opacity=Math.min(1,l.originalOpacity*(.7+.3*c))},cleanup(e){if(e.gestureData?.bloom){const t=e.gestureData.bloom;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.bloom}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.rotationAmount||.3,s=Math.pow(e,.7),r=1+.2*s*a,o=Math.sin(s*Math.PI)*n*a,l=.1*Math.sin(s*Math.PI*.5)*a,c=e>.85?1-(e-.85)/.15*.3:1;return{position:[0,.05*Math.sin(s*Math.PI)*a*c,0],rotation:[0,o*c,l*c],scale:r*(.7+.3*c),glowIntensity:1+.4*s,glowBoost:.3*s}}}},Lc={name:"flicker",emoji:"⚡",type:"blending",description:"Rapid opacity changes with motion jitter",config:{duration:800,musicalDuration:{musical:!0,beats:2},flickerRate:15,frequency:6,minOpacity:.3,maxOpacity:1,jitterAmount:2,colorShift:!1,strobe:!1,pulseMode:!1,groupFlicker:.3,easing:"linear",strength:.7,particleMotion:{type:"flicker",strength:.7,frequency:6}},rhythm:{enabled:!0,syncMode:"subdivision",durationSync:{mode:"beats",beats:2},rateSync:{subdivision:"sixteenth",onBeat:30,offBeat:10,triplet:20,curve:"step"},opacitySync:{pattern:"HLMH",subdivision:"eighth",onAccent:.1,regular:.5},jitterSync:{onBeat:5,offBeat:1,accent:10,curve:"random"},strobeSync:{verse:!1,chorus:!0,drop:"intense",pattern:"XOXO"},dynamics:{forte:{flickerRate:25,jitterAmount:5,minOpacity:.1},piano:{flickerRate:8,jitterAmount:1,minOpacity:.5}}},initialize(e,t){e.gestureData||(e.gestureData={});const i={...this.config,...t},a=Math.random()<i.groupFlicker;e.gestureData.flicker={baseOpacity:e.opacity||e.life||1,baseColor:e.color,baseX:e.x,baseY:e.y,flickerTimer:0,lastFlicker:0,flickerState:!0,isGrouped:a,groupId:a?Math.floor(3*Math.random()):-1,phase:Math.random()*Math.PI*2,colorHue:0,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.flicker?.initialized||this.initialize(e,i);const r=e.gestureData.flicker,o={...this.config,...i},l=i.strength||1;let c;if(r.flickerTimer+=a*o.flickerRate,o.strobe)c=(r.flickerTimer+r.phase)%1<.5?1:o.minOpacity;else if(o.pulseMode){const e=r.flickerTimer+r.phase;c=o.minOpacity+(o.maxOpacity-o.minOpacity)*(.5*Math.sin(e)+.5)}else{if(r.flickerTimer-r.lastFlicker>1)if(r.lastFlicker=r.flickerTimer,r.isGrouped){const e=Math.floor(r.flickerTimer)%3;r.flickerState=e===r.groupId}else r.flickerState=Math.random()>.3;const t=r.flickerState?o.maxOpacity:o.minOpacity+.3*Math.random(),i=e.opacity/r.baseOpacity;c=i+.3*(t-i)}const h=r.baseOpacity*(1+(c-1)*l);if(e.opacity=Math.max(0,Math.min(1,h)),void 0!==e.life&&(e.life=e.opacity),o.jitterAmount>0&&c>o.minOpacity){const t=o.jitterAmount*l*e.scaleFactor,i=(Math.random()-.5)*t*c,n=(Math.random()-.5)*t*c;e.vx+=.1*i*a,e.vy+=.1*n*a}if(o.colorShift&&e.color){r.colorHue+=.01*a;const t=30*Math.sin(r.colorHue);e.color=this.shiftHue(r.baseColor,t*l)}let u=1;t<.1?u=t/.1:t>.9&&(u=(1-t)/.1),e.opacity*=u,void 0!==e.life&&(e.life=e.opacity),t>.8&&(e.vx*=.95,e.vy*=.95)},shiftHue(e,t){if(!e||!e.startsWith("#"))return e;const i=e.slice(1),a=parseInt(i.substr(0,2),16)/255,n=parseInt(i.substr(2,2),16)/255,s=parseInt(i.substr(4,2),16)/255,r=t*Math.PI/180,o=Math.cos(r),l=Math.sin(r),c=a*l+n*o,h=s,u=e=>Math.max(0,Math.min(255,Math.round(255*e))).toString(16).padStart(2,"0");return`#${u(a*o-n*l)}${u(c)}${u(h)}`},cleanup(e){if(e.gestureData?.flicker){const t=e.gestureData.flicker;e.opacity=t.baseOpacity,e.color=t.baseColor,void 0!==e.life&&(e.life=t.baseOpacity),delete e.gestureData.flicker}},"3d":{evaluate(e,t){const i=t.config||{},a=t.strength||.7,n=i.flickerRate||15;i.minOpacity;const s=e*n,r=Math.sin(s*Math.PI*2),o=Math.floor(10*s),l=.3*r+.5*(Math.sin(123.456*o)+1)*.7,c=.6+.8*l,h=i.jitterAmount||2,u=.003*a*c,d=(Math.random()-.5)*h*u,m=(Math.random()-.5)*h*u,p=.03*(Math.random()-.5)*a*c;return{position:[d,m,0],rotation:[.5*p,0,p],scale:1+.08*(c-1),glowIntensity:c,glowBoost:1.2*l}}}},Gc={name:"shiver",emoji:"🥶",type:"effect",description:"High-frequency micro-vibrations for nervousness or cold",config:{duration:1500,musicalDuration:{musical:!0,bars:1},frequency:30,amplitude:.02,decay:.3,strength:1,particleMotion:{type:"shiver",strength:.8}},rhythm:{enabled:!0,syncMode:"ambient",durationSync:{mode:"bars",bars:1},intensitySync:{quiet:.5,loud:1.5,crescendo:"increase",diminuendo:"decrease"}},apply(e,t,i,a,n,s){const r={...this.config,...i},o=r.strength||1,l=r.frequency||30,c=100*(r.amplitude||.02),h=t*l*Math.PI*2,u=(.6*Math.sin(h)+.3*Math.sin(1.7*h+1.3)+.1*Math.sin(2.3*h+2.7))*c*o,d=Math.sin(t*Math.PI);e.x+=u*d*(Math.random()-.5)*2,e.y+=u*d*(Math.random()-.5)*2},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.frequency||30,s=i.amplitude||.02,r=Math.sin(e*Math.PI),o=e*n*Math.PI*2,l=.6*Math.sin(o)+.3*Math.sin(1.7*o)+.1*Math.sin(2.3*o),c=.5*Math.cos(1.1*o)+.3*Math.cos(1.9*o)+.2*Math.cos(2.7*o);return{position:[l*s*a*r,c*s*a*r,(.4*Math.sin(.9*o+1)+.4*Math.sin(1.5*o+2))*s*.5*a*r],rotation:[.02*c*a*r,0,.02*l*a*r],scale:1+.01*Math.abs(l)*a*r,glowIntensity:1+.1*Math.abs(l)*r}}}},Vc={name:"heartbeat",emoji:"💓",type:"effect",description:"Rhythmic double-pump heartbeat (lub-dub)",config:{duration:1e3,musicalDuration:{musical:!0,beats:2},lubStrength:.8,dubStrength:1,lubDubGap:.15,strength:1,particleMotion:{type:"heartbeat",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:2},timingSync:"onBeat",amplitudeSync:{onBeat:1.2,offBeat:.8}},apply(e,t,i,a,n,s){const r={...this.config,...i},o=r.strength||1,l=this._calculatePulse(t,r),c=e.x-n,h=e.y-s,u=Math.sqrt(c*c+h*h)||1,d=10*l*o;e.x+=c/u*d,e.y+=h/u*d},_calculatePulse(e,t){const i=t.lubDubGap||.15,a=t.lubStrength||.8,n=t.dubStrength||1;let s=0;const r=Math.abs(e-.1);r<.08&&(s=Math.cos(r/.08*Math.PI*.5)*a);const o=.1+i+.05,l=Math.abs(e-o);if(l<.1){const e=Math.cos(l/.1*Math.PI*.5)*n;s=Math.max(s,e)}return s},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.lubDubGap||.15,s=i.lubStrength||.8,r=i.dubStrength||1;let o=0;const l=Math.abs(e-.1);l<.08&&(o=Math.cos(l/.08*Math.PI*.5)*s);const c=.1+n+.05,h=Math.abs(e-c);if(h<.1){const e=Math.cos(h/.1*Math.PI*.5)*r;o=Math.max(o,e)}return{position:[0,0,.03*o*a],rotation:[0,0,0],scale:1+.15*o*a,glowIntensity:1+.5*o*a,glowBoost:.8*o*a}}}},Nc={name:"snap",emoji:"⚡",type:"effect",description:"Quick elastic snap with overshoot and settle",config:{duration:500,musicalDuration:{musical:!0,beats:1},snapDistance:.1,overshoot:1.3,bounces:2,strength:1,particleMotion:{type:"snap",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:1},timingSync:"onBeat",accentResponse:{enabled:!0,multiplier:1.5}},apply(e,t,i,a,n,s){const r={...this.config,...i},o=r.strength||1,l=100*(r.snapDistance||.1),c=r.overshoot||1.3,h=this._calculateSnap(t,c,r.bounces||2),u=n-e.x,d=s-e.y,m=Math.sqrt(u*u+d*d)||1;e.x+=u/m*h*l*o*.1,e.y+=d/m*h*l*o*.1},_calculateSnap(e,t,i){if(e<.2){const i=e/.2;return(1-Math.pow(1-i,3))*t}{const a=(e-.2)/.8,n=Math.exp(4*-a);return 1+(t-1)*Math.cos(a*Math.PI*i*2)*n}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.snapDistance||.1,s=i.overshoot||1.3,r=i.bounces||2;let o;if(e<.2){const t=e/.2;o=(1-Math.pow(1-t,3))*s}else{const t=(e-.2)/.8,i=Math.exp(4*-t);o=1+(s-1)*Math.cos(t*Math.PI*r*2)*i}return{position:[0,0,(o-1)*n*a],rotation:[0,0,.1*(o-1)*a],scale:1+.15*(o-1),glowIntensity:1+.5*Math.abs(o-1),glowBoost:e<.3?(.3-e)/.3*.4:0}}}},jc={name:"elasticBounce",emoji:"🏀",type:"effect",description:"Drop and bounce with elastic oscillation",config:{duration:1200,musicalDuration:{musical:!0,beats:3},dropHeight:.15,bounceCount:3,elasticity:.6,strength:1,particleMotion:{type:"elasticBounce",strength:1}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",amplitudeSync:{onBeat:1.3,offBeat:.8}},apply(e,t,i,a,n,s){const r={...this.config,...i},o=r.strength||1,l=200*(r.dropHeight||.15),c=r.bounceCount||3,h=r.elasticity||.6,u=this._calculateBounce(t,l,c,h);e.y+=u*o;const d=.3*Math.max(0,-u/l);e.scaleY=1-d*o,e.scaleX=1+.5*d*o},_calculateBounce(e,t,i,a){let n=t,s=0,r=0,o=.3;for(;r<i&&s<1;){const t=o*Math.pow(a,.5*r);if(e<s+t){const i=(e-s)/t;return 4*i*(1-i)*-n}s+=t,n*=a,r++,o*=a}return 0},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.dropHeight||.15,s=i.bounceCount||3,r=i.elasticity||.6;let o=n,l=0,c=0,h=.3,u=0,d=!1;for(;c<s&&l<1;){const t=h*Math.pow(r,.5*c);if(e<l+t){const i=(e-l)/t;u=o*(4*i*(1-i))*a,d=i>.45&&i<.55;break}l+=t,o*=r,c++,h*=r}let m=1,p=1;if(d){const e=.15*a*Math.pow(r,c);m=1+e,p=1-e}return{position:[0,u,0],rotation:[0,0,0],scale:(m+p)/2,glowIntensity:1+(d?.3:0)}}}},qc={name:"hold",emoji:"⏸️",type:"override",description:"Hold particles in current position",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},holdStrength:.95,allowDrift:!1,strength:1},rhythm:{enabled:!0,syncMode:"rest",holdSync:{onRest:.98,onSound:.8,curve:"immediate"},durationSync:{mode:"rests",minBeats:.5,maxBeats:8,sustain:!0},pauseResponse:{enabled:!0,multiplier:1.5,type:"strength"},patternOverrides:{classical:{holdSync:{onRest:.99,onSound:.75,curve:"dramatic"},pauseResponse:{multiplier:2}},minimal:{holdSync:{onRest:.95,onSound:.85},durationSync:{minBeats:2,maxBeats:16}},jazz:{holdSync:{onRest:.9,onSound:.7},allowDrift:!0},electronic:{holdSync:{onRest:.99,onSound:.6,curve:"digital"},pauseResponse:{multiplier:1.2}}},dynamics:{forte:{holdSync:{onRest:{multiplier:1.02},onSound:{multiplier:.9}},pauseResponse:{multiplier:2.2}},piano:{holdSync:{onRest:{multiplier:.97},onSound:{multiplier:.85}},pauseResponse:{multiplier:1.3}}}},initialize(e){e.gestureData||(e.gestureData={}),e.gestureData.hold={holdX:e.x,holdY:e.y,originalVx:e.vx,originalVy:e.vy}},apply(e,t,i,a,n,s){e.gestureData?.hold||this.initialize(e);const r=e.gestureData.hold,o=i.holdStrength||this.config.holdStrength;if(i.allowDrift?(e.vx*=o,e.vy*=o):(e.x+=(r.holdX-e.x)*(1-o),e.y+=(r.holdY-e.y)*(1-o),e.vx=0,e.vy=0),t>.9){const i=10*(t-.9);e.vx=e.vx*(1-i)+r.originalVx*i,e.vy=e.vy*(1-i)+r.originalVy*i}},cleanup(e){if(e.gestureData?.hold){const t=e.gestureData.hold;e.vx=t.originalVx,e.vy=t.originalVy,delete e.gestureData.hold}},"3d":{evaluate(e,t){let i=0,a=1;if(e<.15){const t=e/.15;i=t*t*(3-2*t),a=1-.2*i}else if(e<.85)i=1,a=.8;else{const t=(e-.85)/.15;i=1-t*t*(3-2*t),a=.8+.2*t}return i*=(t.config||this.config||{}).strength||1,{position:[0,0,0],rotation:[0,0,0],scale:1,glowIntensity:a,freezeRotation:i,freezeWobble:i,freezeGroove:i,freezeParticles:i}}}},Uc={name:"fade",emoji:"👻",type:"blending",description:"Fade particle opacity",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},fadeIn:!0,fadeOut:!0,minOpacity:0,maxOpacity:1},rhythm:{enabled:!0,syncMode:"dynamic",durationSync:{mode:"bars",bars:1},opacitySync:{onBeat:.9,offBeat:.3,subdivision:"eighth",curve:"exponential"},fadePhaseSync:{verse:{fadeIn:!0,fadeOut:!1},chorus:{fadeIn:!1,fadeOut:!1},bridge:{fadeIn:!0,fadeOut:!0},outro:{fadeIn:!1,fadeOut:!0}},pulseSync:{enabled:!0,frequency:"quarter",intensity:.2,onAccent:.4},dynamics:{forte:{minOpacity:.5,maxOpacity:1},piano:{minOpacity:0,maxOpacity:.4}}},initialize(e){e.gestureData||(e.gestureData={}),e.gestureData.fade={baseOpacity:e.opacity||e.life||1}},apply(e,t,i,a,n,s){e.gestureData?.fade||this.initialize(e);const r=e.gestureData.fade,o={...this.config,...i};let l;l=o.fadeIn&&!o.fadeOut?o.minOpacity+(o.maxOpacity-o.minOpacity)*t:o.fadeOut&&!o.fadeIn?o.maxOpacity-(o.maxOpacity-o.minOpacity)*t:t<.5?o.minOpacity+(o.maxOpacity-o.minOpacity)*(2*t):o.maxOpacity-(o.maxOpacity-o.minOpacity)*(2*(t-.5)),e.opacity=r.baseOpacity*l,void 0!==e.life&&(e.life=e.opacity)},cleanup(e){e.gestureData?.fade&&(e.opacity=e.gestureData.fade.baseOpacity,void 0!==e.life&&(e.life=e.opacity),delete e.gestureData.fade)},"3d":{evaluate(e,t){const i={...this?.config||{},...t},a=i.fadeIn??!0,n=i.fadeOut??!0;let s;s=a&&!n?e:n&&!a?1-e:e<.5?1-e/.5:(e-.5)/.5;const r=s*s*(3-2*s);return{position:[0,0,0],rotation:[0,0,0],scale:.01+.99*r,glowIntensity:r,glowBoost:0}}}},Wc={name:"settle",emoji:"🍃",type:"blending",description:"Gradually settle particles to rest",config:{damping:.02,threshold:.01},rhythm:{enabled:!0,syncMode:"resolution",dampingSync:{onResolution:.035,onTension:.015,curve:"gradual"},thresholdSync:{mode:"dynamics",forte:.02,piano:.005,curve:"exponential"},durationSync:{mode:"phrase",minBeats:2,maxBeats:12,sustain:!0},cadenceResponse:{enabled:!0,multiplier:1.6,type:"damping"},patternOverrides:{ambient:{dampingSync:{onResolution:.025,onTension:.008,curve:"atmospheric"},durationSync:{minBeats:8,maxBeats:32}},jazz:{dampingSync:{onResolution:.04,onTension:.02},cadenceResponse:{multiplier:1.8}},classical:{dampingSync:{onResolution:.045,onTension:.012,curve:"expressive"},cadenceResponse:{multiplier:2}},minimalist:{dampingSync:{onResolution:.02,onTension:.005},durationSync:{minBeats:16,maxBeats:64}}},dynamics:{forte:{dampingSync:{onResolution:{multiplier:1.4},onTension:{multiplier:.8}},thresholdSync:{multiplier:2},cadenceResponse:{multiplier:2.2}},piano:{dampingSync:{onResolution:{multiplier:.7},onTension:{multiplier:1.2}},thresholdSync:{multiplier:.5},cadenceResponse:{multiplier:1.3}}}},apply(e,t,i,a,n,s){const r=i.damping||this.config.damping,o=i.threshold||this.config.threshold;e.vx*=Math.max(0,1-r*a*60),e.vy*=Math.max(0,1-r*a*60),Math.abs(e.vx)<o&&(e.vx=0),Math.abs(e.vy)<o&&(e.vy=0)},"3d":{evaluate(e,t){const i=1-Math.pow(1-e,2),a=.01*(1-i);return{position:[Math.sin(e*Math.PI*2)*a,Math.cos(e*Math.PI*3)*a*.5,0],rotation:[0,0,0],scale:1-.03*i,glowIntensity:1-.15*i}}}},Hc={name:"peek",emoji:"👀",type:"effect",description:"Quick peek and hide motion",config:{peekDistance:40,peekSpeed:.15,holdDuration:200,hideSpeed:.25,stagger:!0,duration:1500},rhythm:{enabled:!0,syncMode:"accent",distanceSync:{onAccent:60,offAccent:25,curve:"quick"},speedSync:{mode:"tempo",fast:.25,slow:.1,hideMultiplier:1.8},durationSync:{mode:"subdivision",beats:.25,staggerBeats:.125,sustain:!1},syncopationResponse:{enabled:!0,multiplier:1.8,type:"distance"},patternOverrides:{funk:{distanceSync:{onAccent:70,offAccent:35,curve:"funky"},syncopationResponse:{multiplier:2.2}},latin:{speedSync:{fast:.3,slow:.12},durationSync:{beats:.5,staggerBeats:.25}},breakbeat:{distanceSync:{onAccent:55,offAccent:40},syncopationResponse:{multiplier:2.5}},classical:{distanceSync:{onAccent:45,offAccent:20,curve:"elegant"},speedSync:{fast:.18,slow:.08}}},dynamics:{forte:{distanceSync:{onAccent:{multiplier:1.6},offAccent:{multiplier:1.3}},speedSync:{multiplier:1.4},syncopationResponse:{multiplier:2.8}},piano:{distanceSync:{onAccent:{multiplier:.6},offAccent:{multiplier:.4}},speedSync:{multiplier:.7},syncopationResponse:{multiplier:1.2}}}},apply(e,t,i,a,n,s){if(e.gestureData||(e.gestureData={}),!e.gestureData.peek){const t=e.x-n,i=e.y-s,a=Math.atan2(i,t),r=Math.sqrt(t*t+i*i);e.gestureData.peek={originalX:e.x,originalY:e.y,peekAngle:a,originalDistance:r,staggerDelay:this.config.stagger?.3*Math.random():0,phase:"waiting",phaseTimer:0,peekOffset:{x:0,y:0}}}const r=e.gestureData.peek,{config:o}=this,l=Math.max(0,Math.min(1,(t-r.staggerDelay)/(1-r.staggerDelay)));0===l?r.phase="waiting":l<.3?r.phase="peeking":l<.6?r.phase="holding":l<1&&(r.phase="hiding");let c=0;switch(r.phase){case"peeking":{const e=l/.3;c=this.easeOutCubic(e)*o.peekDistance;break}case"holding":c=o.peekDistance,Math.random()<.1&&(r.peekOffset.x+=2*(Math.random()-.5),r.peekOffset.y+=2*(Math.random()-.5));break;case"hiding":{const e=(l-.6)/.4;c=(1-this.easeInCubic(e))*o.peekDistance;break}}if("waiting"!==r.phase){const t=Math.cos(r.peekAngle)*c,i=Math.sin(r.peekAngle)*c;r.peekOffset.x+=(t-r.peekOffset.x)*o.peekSpeed,r.peekOffset.y+=(i-r.peekOffset.y)*o.peekSpeed,e.x=r.originalX+r.peekOffset.x,e.y=r.originalY+r.peekOffset.y}void 0!==e.alpha&&("peeking"===r.phase||"holding"===r.phase?e.alpha=.7+.3*Math.random():e.alpha=1)},easeOutCubic:e=>1-Math.pow(1-e,3),easeInCubic:e=>e*e*e,cleanup(e){e.gestureData?.peek&&(e.x=e.gestureData.peek.originalX,e.y=e.gestureData.peek.originalY,void 0!==e.alpha&&(e.alpha=1),delete e.gestureData.peek)},"3d":{evaluate(e,t){const i=.01*({...this.config,...t}.peekDistance||40);let a=0,n=1;if(e<.3){const t=e/.3;a=(1-Math.pow(1-t,3))*i}else if(e<.6)a=i,n=.7+.3*Math.random();else{const t=(e-.6)/.4;a=(1-Math.pow(t,3))*i}return{position:[a,0,0],rotation:[0,0,0],scale:1,glowIntensity:n}}}},$c={name:"directional",emoji:"➡️",type:"blending",description:"Move particles in a specific direction",config:{angle:0,returnToOrigin:!1,strength:1},rhythm:{enabled:!0,syncMode:"flow",angleSync:{verse:0,chorus:90,bridge:180,outro:270,transition:"smooth"},strengthSync:{onBeat:1.8,offBeat:.6,curve:"wave"},returnSync:{enabled:!0,onSectionChange:!0,duration:"transition",strength:1.2},accentResponse:{enabled:!0,multiplier:2,type:"strength"},patternOverrides:{march:{angleSync:{verse:0,chorus:0},strengthSync:{onBeat:2.5,offBeat:1}},waltz:{angleSync:{verse:45,chorus:135,bridge:225,outro:315,transition:"circular"}},swing:{strengthSync:{onBeat:1.6,offBeat:1.4,swing:!0}},electronic:{angleSync:{transition:"instant"},strengthSync:{onBeat:2.2,offBeat:.4,curve:"sharp"}}},dynamics:{forte:{strengthSync:{onBeat:{multiplier:1.6},offBeat:{multiplier:1.2}},angleSync:{transition:"sharp"},accentResponse:{multiplier:2.5}},piano:{strengthSync:{onBeat:{multiplier:.7},offBeat:{multiplier:.8}},angleSync:{transition:"gradual"},accentResponse:{multiplier:1.4}}}},initialize(e){e.gestureData||(e.gestureData={}),e.gestureData.directional={initialX:e.x,initialY:e.y}},apply(e,t,i,a,n,s){e.gestureData?.directional||this.initialize(e);const r=(i.angle||this.config.angle)*Math.PI/180,o=i.strength||this.config.strength;if(e.vx+=Math.cos(r)*o*.3*a,e.vy+=Math.sin(r)*o*.3*a,i.returnToOrigin&&t>.5){const i=2*(t-.5),n=e.gestureData.directional,s=n.initialX-e.x,r=n.initialY-e.y;e.vx+=s*i*.02*a,e.vy+=r*i*.02*a}},"3d":{evaluate(e,t){const i={...this.config,...t},a=(i.angle||0)*Math.PI/180,n=t.strength||1,s=i.returnToOrigin?e<.5?2*e:2*(1-e):e;return{position:[Math.cos(a)*s*.4*n,Math.sin(a)*s*.4*n,0],rotation:[0,0,0],scale:1,glowIntensity:1}}}};function Yc(e){if(!["forward","back","left","right","up","down","attract","repel"].includes(e))throw new Error(`Invalid magnetic direction: ${e}`);return{name:`magnetic${qa(e)}`,emoji:{forward:"🧲",back:"🧲",left:"⬅️",right:"➡️",up:"⬆️",down:"⬇️",attract:"🧲",repel:"💥"}[e],type:"effect",description:{forward:"Magnetic pull toward camera",back:"Magnetic push away from camera",left:"Magnetic pull leftward",right:"Magnetic pull rightward",up:"Magnetic pull upward",down:"Magnetic pull downward",attract:"Magnetic attraction to center",repel:"Magnetic repulsion from center"}[e],config:{duration:1200,musicalDuration:{musical:!0,beats:3},direction:e,pullStrength:1,returnToOrigin:!0,strength:1,particleMotion:{type:"magnetic",strength:1,direction:e}},rhythm:{enabled:!0,syncMode:"beat",durationSync:{mode:"beats",beats:3},timingSync:"onBeat",strengthSync:{onBeat:1.5,offBeat:.7}},initialize(e,t,i,a){e.gestureData||(e.gestureData={}),e.gestureData.magnetic={originalX:e.x,originalY:e.y,originalOpacity:e.opacity??1,initialized:!0}},apply(e,t,i,a,n,s){e.gestureData?.magnetic?.initialized||this.initialize(e,i,n,s);const r={...this.config,...i},o=r.strength||1,l=r.pullStrength||1,c=!1!==r.returnToOrigin,h=e.gestureData.magnetic,u=r.direction||"attract";let d,m,p;switch(d=c?Math.sin(t*Math.PI):Math.min(1,2*t),u){case"left":m=h.originalX-100,p=h.originalY;break;case"right":m=h.originalX+100,p=h.originalY;break;case"up":m=h.originalX,p=h.originalY-100;break;case"down":m=h.originalX,p=h.originalY+100;break;case"repel":{const e=h.originalX-n,t=h.originalY-s,i=Math.sqrt(e*e+t*t)||1;m=h.originalX+e/i*100,p=h.originalY+t/i*100;break}default:m=n,p=s}const g=(m-h.originalX)*d*l*o*.5,f=(p-h.originalY)*d*l*o*.5;e.x=h.originalX+g,e.y=h.originalY+f},cleanup(e){if(e.gestureData?.magnetic){const t=e.gestureData.magnetic;e.x=t.originalX,e.y=t.originalY,e.opacity=t.originalOpacity,delete e.gestureData.magnetic}},"3d":{evaluate(e,t){const i=t.config||this.config||{},a=i.strength||1,n=i.direction||"attract";let s;s=!1!==i.returnToOrigin?Math.sin(e*Math.PI):Math.min(1,2*e);let r=0,o=0,l=0,c=1;const h=.15*s*a;switch(n){case"forward":l=h,c=1+.1*s*a;break;case"back":l=-h,c=1-.08*s*a;break;case"left":r=-h;break;case"right":r=h;break;case"up":o=h;break;case"down":o=-h;break;case"attract":l=h,c=1-.1*s*a;break;case"repel":l=-h,c=1+.1*s*a}const u=1+.4*s,d=.3*s;return{cameraRelativePosition:[r+(s>.5?.01*Math.sin(e*Math.PI*20)*(s-.5)*2:0),o,l],rotation:[0,0,0],scale:c,glowIntensity:u,glowBoost:d}}}}}const Xc=Fn("forward"),Qc=Fn("back"),Kc=Fn("left"),Zc=Fn("right"),Jc=Fn("up"),eh=Fn("down"),th=ds("back"),ih=ds("forward"),ah=ds("left"),nh=ds("right"),sh=ds("up"),rh=ds("down"),oh=hs("left"),lh=hs("right"),ch=hs("front"),hh=hs("back"),uh=hs("up"),dh=hs("down"),mh=Ls("default"),ph=Ls("explosive"),gh=Ls("crumble"),fh=Ls("reform"),yh=Ls("punchLeft"),vh=Ls("punchRight"),bh=Ls("punchFront"),wh=Ls("suspend"),Mh=Ls("implode"),Sh=Ls("gravity"),xh=Ls("orbit"),Ch=Vs("up"),Ph=Vs("down"),kh=Vs("left"),Dh=Vs("right"),Ah=Vs("away"),_h=Vs("toward"),Th=Er,Ih=Br,Oh=Fr,Rh=zr,Eh=Lr,Bh=Gr,Fh=Vr,zh=Nr,Lh=jr,Gh=qr,Vh=Ur,Nh=Wr,jh=Hr,qh=Yr,Uh=Xr,Wh=Qr,Hh=Kr,$h=Zr,Yh=Io,Xh=Oo,Qh=Ro,Kh=js("ignite"),Zh=js("ember"),Jh=io,eu=ao,tu=no,iu=oo,au=lo,nu=co,su=ho,ru=uo,ou=mo,lu=po,cu=fo,hu=yo,uu=vo,du=bo,mu=wo,pu=so,gu=ro,fu=Po,yu=ko,vu=Do,bu=Ao,wu=_o,Mu=To,Su=js("freeze"),xu=js("shatterIce"),Cu=js("thaw"),Pu=dr,ku=mr,Du=pr,Au=gr,_u=fr,Tu=yr,Iu=vr,Ou=br,Ru=wr,Eu=Mr,Bu=Sr,Fu=xr,zu=Cr,Lu=Pr,Gu=kr,Vu=Dr,Nu=Ar,ju=_r,qu=Tr,Uu=Ir,Wu=Lo,Hu=Go,$u=Vo,Yu=No,Xu=jo,Qu=qo,Ku=Uo,Zu=Wo,Ju=Ho,ed=En("forward"),td=En("back"),id=En("left"),ad=En("right"),nd=En("up"),sd=En("down"),rd=Yc("forward"),od=Yc("back"),ld=Yc("left"),cd=Yc("right"),hd=Yc("up"),ud=Yc("down"),dd=Yc("attract"),md=Yc("repel"),pd=[Sn,Ga,an,es,tn,en,Va,Na,Ja,{name:"sparkle",emoji:"✨",type:"blending",description:"Bright twinkling sparkle bursts",config:{duration:800,musicalDuration:{musical:!0,beats:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:2},interruptible:!0,priority:5,blendable:!0},apply:(e,t,i)=>!1,blend:(e,t,i)=>!1,"3d":{evaluate(e,t){const i=t?.strength||1,a=Math.pow(Math.max(0,Math.sin(e*Math.PI*6)),3),n=Math.pow(Math.max(0,Math.sin(e*Math.PI*8+1)),3),s=Math.pow(Math.max(0,Math.sin(e*Math.PI*10+2)),3),r=Math.max(a,n,s)*Math.sin(e*Math.PI);return{position:[0,0,0],rotation:[0,0,0],scale:1+.08*r*i,glowIntensity:1+.5*r*i,glowBoost:2*r*i}}}},{name:"shimmer",emoji:"🌟",type:"particle",description:"Shimmer effect with sparkling particles",config:{duration:2e3,musicalDuration:{musical:!0,bars:1},particleMotion:"radiant"},rhythm:{enabled:!0,syncType:"beat",durationSync:{mode:"bars",bars:1},intensity:.8},override:(e,t,i)=>(e.shimmerEffect=!0,e.shimmerProgress=t,!0),blend:(e,t,i)=>!1,"3d":{evaluate(e,t){const i=t?.strength||1,a=(.4*Math.sin(e*Math.PI*4)+.35*Math.sin(e*Math.PI*6+.5)+.25*Math.sin(e*Math.PI*10+1)+1)/2;return{position:[0,0,0],rotation:[0,0,0],scale:1+.05*a*i,glowIntensity:1+.3*a*i,glowBoost:1*a*i}}}},nn,((e,t="✨")=>({name:e,emoji:t,type:"blending",description:`${e} animation`,config:{duration:1e3,musicalDuration:{musical:!0,beats:2}},rhythm:{enabled:!0,syncMode:"beat",timingSync:"nextBeat",durationSync:{mode:"beats",beats:2},interruptible:!0,priority:3,blendable:!0,crossfadePoint:"anyBeat",maxQueue:3},apply:(e,t,i)=>!1,blend:(e,t,i)=>!1}))("groove","🎵"),Un,Xa,ts,is,yn,bn,wn,Mn,vn,on,ln,cn,hn,un,dn,Ka,Za,Kn,Zn,Wa,Ha,$a,Ya,Hn,$n,Yn,Xn,Fa,za,La,ks,Ds,Cs,Ps,gn,xn,Pn,kn,Dn,An,fn,mn,pn],gd=[zn,Vn,Nn,_n,In,On,Rn,rc,vs,ns,rs,os,ls,cs,Fs,jn,qn,as,Bn,us,Jn,Xc,Qc,Kc,Zc,Jc,eh,th,ih,ah,nh,sh,rh,gs,fs,ys,ps,ms,oh,lh,ch,hh,uh,dh,_s,Ts,Is,Os,Rs,Es,Bs,ws,Ms,Ss,xs,ed,td,id,ad,nd,sd,bs,mh,ph,gh,fh,yh,vh,bh,wh,Mh,Sh,xh,Ch,Ph,kh,Dh,Ah,_h,Th,Ih,Oh,Rh,Eh,Bh,Fh,zh,Lh,Gh,Vh,Nh,jh,qh,Uh,Wh,Hh,$h,Yh,Xh,Qh,Kh,Zh,Jh,eu,tu,iu,au,nu,su,ru,ou,lu,cu,hu,uu,du,mu,pu,gu,Su,xu,Cu,Pu,ku,Du,Au,_u,Tu,Iu,Ou,Ru,Eu,Bu,Fu,zu,Lu,Gu,Vu,Nu,ju,qu,Uu,Wu,Hu,$u,Yu,Xu,Qu,Ku,Zu,Ju,fu,yu,vu,bu,wu,Mu,Ko,Zo,Jo,el,tl,il,al,nl,sl,rl,ol,ll,cl,hl,gl,fl,yl,vl,bl,wl,Ml,Sl,xl,Al,_l,Tl,Il,Ol,Rl,El,Bl,Fl,Nl,jl,ql,Ul,Wl,Hl,$l,Yl,Xl,ec,tc,ic,ac,nc,sc],fd=[Ec,lc,hc,uc,dc,mc,Lc,Dc,$c,Wc,Uc,qc,Bc,Fc,Hc,oc,Gc,Vc,wc,Mc,fc,yc,vc,bc,_c,Tc,Ic,Oc,Rc,jc,xc,Cc,Pc,kc,zc,Nc,rd,od,ld,cd,hd,ud,dd,md,pc],yd={};[...pd,...gd,...fd].forEach(e=>{yd[e.name]=e}),pd.map(e=>e.name),gd.map(e=>e.name),fd.map(e=>e.name);const vd={idle:["breathe","expand","contract","pulse","sway","float","floatUp","floatDown","floatLeft","floatRight","bob","lean","leanLeft","leanRight","jitter","twitch","vibrate","shake","wiggle"],dance:["stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","runningman","charleston","hula","twist","pop","flare","swell","swagger","dip","bounce","orbit","orbitLeft","orbitRight","orbitUp","orbitDown","sparkle","shimmer","groove"],actions:["jump","jumpDown","jumpLeft","jumpRight","rushForward","rushBack","rushLeft","rushRight","rushUp","rushDown","lunge","lungeForward","lungeBack","lungeLeft","lungeRight","lungeUp","lungeDown","spin","spinLeft","spinRight","flip","backflip","point","pointUp","pointDown","pointLeft","pointRight","kickLeft","kickRight","bow","nod","reach","headBob","crouch","tilt","tiltUp","tiltDown","tiltLeft","tiltRight"],reactions:["oofLeft","oofRight","oofFront","oofBack","oofUp","oofDown","recoil","recoilBack","recoilForward","recoilLeft","recoilRight","recoilUp","recoilDown","knockdown","knockout","inflate","deflate","squash","stretch","pancake","crackFront","crackBack","crackLeft","crackRight","crackUp","crackDown","crackHeal","rage","fury","battlecry","charge","wobble","teeter","rock","pendulum"],destruction:["shatter","shatterMesh","shatterExplosive","shatterCrumble","shatterReform","shatterPunchLeft","shatterPunchRight","shatterPunchFront","shatterSuspend","shatterImplode","shatterGravity","shatterOrbit","dissolveUp","dissolveDown","dissolveLeft","dissolveRight","dissolveAway","dissolveToward","splash","drench","soak","flow","tide","liquefy","poolWater","vortexWater","watercrown","waterdance","waterdrill","waterhelix","watermeditation","waterpillar","waterflourish","waterbarrage","waterimpact","watercrush","smokebomb","vanish","materialize","ignite","phoenix","ember","burn","scorch","combust","flameVortex","firedance","fireflourish","firecrown","firemeditation","firedrill","firepillar","firehelix","firebarrage","fireimpact","fireblast","radiate","blaze","puff","billow","fume","shroud","hazeSmoke","chokeSmoke","iceFreeze","shatterIce","thaw","shock","overload","glitch","crackle","chargeUp","electricAuraEffect","staticDischarge","electriccrown","electricdance","electrichelix","electricpillar","electricdrill","electricflourish","electricvortex","electricbarrage","electricimpact","electricblast","electricsurge","electriczap","zap","drain","siphon","hollow","corrupt","taint","wither","consume","erase","singularity","iceCrown","iceDance","icePillar","iceHelix","iceMeditation","iceVortex","iceSplash","iceEncase","iceDrill","iceFlourish","iceBarrage","iceImpact","icemist","iceshiver","lightBlind","lightPurify","lightCleanse","lightRadiate","lightGlow","lightBeacon","lightAscend","lightIlluminate","lightDissolve","poisonInfect","poisonSicken","poisonOoze","poisonSeep","poisonToxic","poisonCorrode","poisonMelt","poisonDecay","poisonDissolve","earthPetrify","earthBurden","earthRumble","earthQuake","earthEncase","earthCrumble","earthShatter","earthErode","earthFossilize","natureEntangle","natureRoot","natureConstrict","natureBloom","natureFlourish","natureBlossom","morph"],atmosphere:["rain","drift","driftUp","driftDown","driftLeft","driftRight","vortex","cascadeUp","cascadeDown","cascadeLeft","cascadeRight","confetti","fizz","swarmUp","swarmDown","swarmLeft","swarmRight","burst","burstUp","burstDown","burstLeft","burstRight","ripple","wave","flash","glow","bloom","flicker","shiver","heartbeat","snap","elasticBounce","hold","fade","settle","peek","directional","magneticForward","magneticBack","magneticLeft","magneticRight","magneticUp","magneticDown","magneticAttract","magneticRepel"]},bd={};function wd(e){if(yd[e])return yd[e];return Ea(e)||null}function Md(){const e=[];return Object.values(yd).forEach(t=>{e.push({name:t.name,emoji:t.emoji||"🎭",type:t.type,category:bd[t.name]||"atmosphere",description:t.description||"No description",source:"core",usesShatter:t.usesShatter||!1})}),Ba().forEach(t=>{const i=Ea(t);e.push({name:i.name,emoji:i.emoji||"🔌",type:i.type,category:i.category||"effect",description:i.description||"Plugin gesture",source:"plugin"})}),e}function Sd(e){return function(e){const t=wd(e);return!!t&&"override"===t.type}(e)}Object.entries(vd).forEach(([e,t])=>{t.forEach(t=>{bd[t]=e})});class xd{constructor(e,t,i="ambient",a=1,n=1,s=null){const r=Math.random();this.z=r<1/13?.5+.5*Math.random():.9*Math.random()-1;const o=this.z>0?(20+20*Math.random())*a:3*a,l=Math.random()*Math.PI*2;this.x=e+Math.cos(l)*o,this.y=t+Math.sin(l)*o,this.vx=0,this.vy=0,this.vz=0,this.life=0,this.maxLife=1,this.lifeDecay=.01,this.fadeInTime=.15,this.fadeOutTime=.3,this.isFadingOut=!1,this.age=0,this.scaleFactor=a,this.particleSizeMultiplier=n,this.size=(4+6*Math.random())*a*n,this.baseSize=this.size,this.emotionColors=s,this.color="#ffffff",this.opacity=1,this.hasGlow=Math.random()<.333,this.glowSizeMultiplier=this.hasGlow?1.33+.33*Math.random():0,this.isCellShaded=Math.random()<.333,this.baseOpacity=.3+.4*Math.random(),this.cachedColors=new Map,this.maxCachedColors=20,this.colorAccessOrder=[],this.lastColor=null,this.lastOpacity=-1,this.behavior=i,this.behaviorData={},this.gestureData={initialX:e,initialY:t},Ia(this,i)}update(e,t,i,a=null,n=null,s=0,r=null){const o=Math.min(e,50)/16.67,l="rain"===n?.type;l&&console.log("[PARTICLE] update() - RAIN gesture detected:",{gestureMotionType:n?.type,gestureProgress:s?.toFixed(3),particleY:this.y?.toFixed(1)});const c=n&&n.type&&s>0&&Sd(n.type);l&&console.log("[PARTICLE] update() - gestureIsOverriding:",c,"isGestureOverriding(rain):",Sd("rain"));const h=this.y;c?(l&&console.log("[PARTICLE] update() - Calling applyGestureMotion for RAIN"),this.applyGestureMotion(n,s,o,t,i)):"falling"===this.gestureBehavior?Oa(this,"falling",o,t,i):"radiant"===this.gestureBehavior?Oa(this,"radiant",o,t,i):(Oa(this,this.behavior,o,t,i),n&&s>0&&this.applyGestureMotion(n,s,o,t,i)),l&&console.log("[PARTICLE] update() - After applyGestureMotion, Y:",h?.toFixed(1),"->",this.y?.toFixed(1));const u=this.rainData||"falling"===this.gestureBehavior||this.fallingData||this.gestureData?.rain,d=c||u;if(l&&console.log("[PARTICLE] update() - Physics check:",{isRaining:u,gestureIsOverriding:c,skipPhysics:d,hasRainData:!!this.rainData,hasGestureDataRain:!!this.gestureData?.rain,gestureBehavior:this.gestureBehavior}),d?l&&console.log("[PARTICLE] update() - SKIPPED velocity (skipPhysics was true)"):(this.x+=this.vx*o,this.y+=this.vy*o,l&&console.log("[PARTICLE] update() - APPLIED velocity (skipPhysics was false)")),!d){let e,a;if(r)e=r.width,a=r.height;else{const n=document.getElementById("card-mascot")||document.getElementById("cherokee-guide-mascot")||document.querySelector("canvas");e=n?n.width:2*t,a=n?n.height:2*i}const n=20,s=t-e/2+n,o=t+e/2+n,l=i-a/2+n,c=i+a/2-n;this.x-this.size<s?(this.x=s+this.size,this.vx=.5*Math.abs(this.vx)):this.x+this.size>o&&(this.x=o-this.size,this.vx=.5*-Math.abs(this.vx)),this.y-this.size<l?(this.y=l+this.size,this.vy=.5*Math.abs(this.vy)):this.y+this.size>c&&(this.y=c-this.size,this.vy=.5*-Math.abs(this.vy))}this.age+=this.lifeDecay*o,this.age<this.fadeInTime?this.life=this.age/this.fadeInTime:this.age<1-this.fadeOutTime?this.life=1:(this.life=(1-this.age)/this.fadeOutTime,this.isFadingOut=!0,"popcorn"===this.behavior&&(this.size=this.baseSize*(.5+.5*this.life))),this.life=Math.max(0,Math.min(1,this.life)),"falling"===this.behavior?this.opacity=this.life:this.opacity=this.easeInOutCubic(this.life),"burst"===this.behavior&&this.behaviorData&&this.life<this.behaviorData.fadeStart&&(this.size=this.baseSize*(this.life/this.behaviorData.fadeStart))}applyUndertoneModifier(e,t){}applyGestureMotion(e,t,i,a,n){!function(e,t,i,a,n,s){if(!i||!i.type||a>=1)return void("rain"===i?.type&&console.log("[GESTURE_MOTION] applyGestureMotion() SKIPPED - validation failed:",{hasMotion:!!i,motionType:i?.type,progress:a,progressCheck:a>=1}));"rain"===i.type&&console.log("[GESTURE_MOTION] applyGestureMotion() CALLED for RAIN:",{motionType:i.type,progress:a.toFixed(3),dt:t?.toFixed(2),particleY:e.y?.toFixed(1)}),e.gestureData||(e.gestureData={originalVx:e.vx,originalVy:e.vy,initialX:e.x,initialY:e.y,startAngle:Math.atan2(e.y-s,e.x-n),startRadius:Math.sqrt(Math.pow(e.x-n,2)+Math.pow(e.y-s,2))});const r=wd(i.type);if(!r)return void("rain"===i.type&&console.log("[GESTURE_MOTION] ERROR - gesture not found for type:",i.type));"rain"===i.type&&console.log("[GESTURE_MOTION] Found gesture:",r.name,"hasApply:",!!r.apply);let o=i;if(Xi.isEnabled()&&r.rhythm?.enabled){const n=Xi.applyGestureRhythm(r,e,a,t);o={...i,amplitude:(i.amplitude||1)*(n.amplitudeMultiplier||1)*(n.accentMultiplier||1),wobbleAmount:(i.wobbleAmount||0)*(n.wobbleMultiplier||1),rhythmModulation:n}}if(r.apply){const l=e.y;r.apply(e,a,o,t,n,s),"rain"===i.type&&console.log("[GESTURE_MOTION] After gesture.apply() - Y changed:",l?.toFixed(1),"->",e.y?.toFixed(1))}a>=.99&&r.cleanup&&(r.cleanup(e),e.gestureData=null)}(this,i,e,t,a,n)}isOutOfBounds(e,t){return this.x<-50||this.x>e+50||this.y<-50||this.y>t+50}isAlive(){return this.life>0}setOutwardVelocity(e){if(this.behaviorData&&void 0!==this.behaviorData.outwardSpeed){const t=this.behaviorData.outwardSpeed;this.vx=Math.cos(e)*t,this.vy=Math.sin(e)*t+(this.behaviorData.upwardBias||0)}}getDepthAdjustedSize(){const e=1+.2*this.z;return this.size*e}getState(){return{position:{x:this.x,y:this.y,z:this.z},velocity:{x:this.vx,y:this.vy,z:this.vz},life:this.life,behavior:this.behavior,size:this.size,opacity:this.opacity}}reset(e,t,i="ambient",a=1,n=1,s=null){const r=Math.random();this.z=r<1/13?.5+.5*Math.random():.9*Math.random()-1;const o=this.z>0?(20+20*Math.random())*a:3*a,l=Math.random()*Math.PI*2;if(this.x=e+Math.cos(l)*o,this.y=t+Math.sin(l)*o,this.vx=0,this.vy=0,this.vz=0,this.life=0,this.age=0,this.scaleFactor=a,this.particleSizeMultiplier=n,this.size=(4+6*Math.random())*a*n,this.baseSize=this.size,this.emotionColors=s,this.cachedColors.clear(),this.colorAccessOrder=[],this.opacity=0,this.isFadingOut=!1,this.baseOpacity=.3+.4*Math.random(),this.color="#ffffff",this.behavior=i,this.gestureData=null,this.behaviorData)for(const e in this.behaviorData)delete this.behaviorData[e];else this.behaviorData={};Ia(this,i)}getCachedColor(e,t){const i=Math.round(100*t)/100,a=`${e}_${i}`;if(this.cachedColors.has(a)){const e=this.colorAccessOrder.indexOf(a);-1!==e&&this.colorAccessOrder.splice(e,1),this.colorAccessOrder.push(a)}else{if(this.cachedColors.size>=this.maxCachedColors){const e=this.colorAccessOrder.shift();this.cachedColors.delete(e)}this.cachedColors.set(a,this.hexToRgba(e,i)),this.colorAccessOrder.push(a)}return this.cachedColors.get(a)}hexToRgba(e,t){const i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return i?`rgba(${parseInt(i[1],16)}, ${parseInt(i[2],16)}, ${parseInt(i[3],16)}, ${t})`:`rgba(255, 255, 255, ${t})`}easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}render(e,t="#ffffff"){if(this.life<=0)return;if(!isFinite(this.x)||!isFinite(this.y))return;const i=this.x,a=this.y,n=Math.max(.1,this.size),s=this.tempColor||this.color||t;if(e.save(),this.isCellShaded){e.strokeStyle=this.getCachedColor(s,.9*this.opacity),e.lineWidth=2,e.beginPath(),e.arc(i,a,n,0,2*Math.PI),e.stroke();const t=Math.floor(3*this.opacity)/3;e.fillStyle=this.getCachedColor(s,t*(this.baseOpacity||.5)*.5),e.beginPath(),e.arc(i,a,Math.max(.1,n-1),0,2*Math.PI),e.fill(),t>.5&&(e.fillStyle=this.getCachedColor("#FFFFFF",.3),e.beginPath(),e.arc(i-.3*n,a-.3*n,.3*n,0,2*Math.PI),e.fill())}else{const t=e.createRadialGradient(i,a,0,i,a,n);if(t.addColorStop(0,this.getCachedColor(s,this.opacity*(this.baseOpacity||.5))),t.addColorStop(.5,this.getCachedColor(s,this.opacity*(this.baseOpacity||.5)*.5)),t.addColorStop(1,this.getCachedColor(s,0)),e.fillStyle=t,e.beginPath(),e.arc(i,a,n,0,2*Math.PI),e.fill(),this.hasGlow&&this.glowSizeMultiplier>0){const t=n*this.glowSizeMultiplier,r=e.createRadialGradient(i,a,.5*n,i,a,t),o=.3,l=Math.max(o,this.opacity),c=Math.min(1,this.glowSizeMultiplier/3);r.addColorStop(0,this.getCachedColor(s,Math.max(.5,.8*l)*c)),r.addColorStop(.25,this.getCachedColor(s,Math.max(.3,.6*l)*c)),r.addColorStop(.5,this.getCachedColor(s,Math.max(.2,.4*l)*c)),r.addColorStop(.75,this.getCachedColor(s,Math.max(.1,.2*l)*c)),r.addColorStop(1,this.getCachedColor(s,0)),e.save(),e.globalCompositeOperation="screen",e.fillStyle=r,e.beginPath(),e.arc(i,a,t,0,2*Math.PI),e.fill(),e.restore()}}e.restore()}}class Cd{constructor(e=50){this.poolSize=Math.min(e,50),this.pool=[],this.totalParticlesCreated=0,this.totalParticlesDestroyed=0,this.poolHits=0,this.poolMisses=0}getParticle(e,t,i,a,n,s,r,o=null){let l;return this.pool.length>0?(l=this.pool.pop(),l.reset(e,t,i,a,n,s),this.poolHits++):(l=new xd(e,t,i,a,n,s),this.poolMisses++,this.totalParticlesCreated++),l.emotion=r,o&&(l.gestureBehavior=o),l}returnParticle(e){if(this.pool.length<this.poolSize){if(e.cachedGradient=null,e.cachedGradientKey=null,e.behaviorData)for(const t in e.behaviorData)delete e.behaviorData[t];this.pool.push(e)}else this.totalParticlesDestroyed++}refreshPool(){const e=this.pool.length-this.poolSize;e>0&&(this.pool.splice(this.poolSize),this.totalParticlesDestroyed+=e)}getStats(){return{poolSize:this.pool.length,poolHits:this.poolHits,poolMisses:this.poolMisses,totalCreated:this.totalParticlesCreated,totalDestroyed:this.totalParticlesDestroyed}}clear(){this.pool=[],this.poolHits=0,this.poolMisses=0,this.totalParticlesCreated=0,this.totalParticlesDestroyed=0}}class Pd{constructor(){this.spawnAccumulator=0}getSpawnPosition(e,t,i,a,n,s=null){const r=Math.min(a,n)/12,o=2.5*r,l=1.1*o,c=Math.min(t-30,a-t-30),h=Math.min(i-30,n-i-30),u=Math.min(1.5*o,c,h);switch(e){case"ambient":case"resting":{const e=Math.random()*Math.PI*2,a=.9*o;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a,angle:e}}case"rising":{const e=Math.random()*Math.PI*2,a=l+Math.random()*(u-l);return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a}}case"falling":{const e=Math.random()*Math.PI*2,a=.9*o;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a,angle:e}}case"aggressive":{const e=Math.random()*Math.PI*2,a=o+Math.random()*r;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a}}case"scattering":default:return{x:t,y:i};case"burst":{const e=Math.random()*Math.PI*2;if("suspicion"===s){const a=1.5*r;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a}}if("surprise"===s){const a=1.2*r;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a}}return{x:t,y:i}}case"repelling":{const e=Math.random()*Math.PI*2,a=.9*o;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a}}case"orbiting":{const e=Math.random()*Math.PI*2,a=1.2*o+Math.random()*o*.5;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a}}case"glitchy":{const e=Math.random()*Math.PI*2,a=3*o+Math.random()*o*4;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a}}case"spaz":{const e=Math.random()*Math.PI*2,a=2*o+Math.random()*o*3;return{x:t+Math.cos(e)*a,y:i+Math.sin(e)*a}}}}clampToCanvas(e,t,i,a,n=30){return{x:Math.max(n,Math.min(i-n,e)),y:Math.max(n,Math.min(a-n,t))}}calculateSpawnRate(e,t){if(e<=0)return 0;const i=Math.min(t,50),a=e/1e3;this.spawnAccumulator+=a*i,this.spawnAccumulator=Math.min(this.spawnAccumulator,3);let n=0;for(;this.spawnAccumulator>=1;)n++,this.spawnAccumulator-=1;return n}resetAccumulator(){this.spawnAccumulator=0}}class kd{render(e,t,i="#ffffff",a=null){const n=[];for(const e of t)e.life<=0||n.push(e);this._renderParticles(e,n,i,a)}renderLayer(e,t,i="#ffffff",a=!1,n=null){const s=[],r=e.canvas.width,o=e.canvas.height;for(const e of t)e.z>=0===a&&(e.x<-50||e.x>r+50||e.y<-50||e.y>o+50||e.life<=0||s.push(e));return s.sort((e,t)=>e.isCellShaded!==t.isCellShaded?e.isCellShaded?-1:1:e.hasGlow!==t.hasGlow?e.hasGlow?-1:1:0),this._renderParticles(e,s,i,n),s}_renderParticles(e,t,i,a=null){e.save();let n=null;for(const s of t)if(s.isCellShaded)s.render(e,i),n=null;else{const t=s.color||i;if(t!==n&&(e.fillStyle=t,n=t),!isFinite(s.x)||!isFinite(s.y))continue;const r=s.getDepthAdjustedSize?s.getDepthAdjustedSize():s.size;let o=Math.max(.1,r),l=1;if(a&&a.fireflyEffect){const e=(.01*s.x+.01*s.y+.1*s.size)%(2*Math.PI),t=a.fireflyTime||.001*Date.now(),i=a.particleGlow||2;l=.3+Math.max(0,Math.sin(3*t+e))*i}if(a&&a.flickerEffect){const e=(.02*s.x+.02*s.y)%(2*Math.PI),t=a.flickerTime||.001*Date.now(),i=a.particleGlow||2;l=.5+Math.sin(12*t+e)*i*.5}if(a&&a.shimmerEffect){const t=s.x-e.canvas.width/2,i=s.y-e.canvas.height/2,n=Math.sqrt(t*t+i*i)/200,r=a.shimmerTime||.001*Date.now(),o=a.shimmerWave||0,c=a.particleGlow||1.2;l=1+.15*Math.sin(3*r-n+o)*c}if(a&&a.glowEffect){const t=a.glowProgress||0,i=a.particleGlow||2,n=s.x-e.canvas.width/2,r=s.y-e.canvas.height/2,l=Math.sqrt(n*n+r*r)/300,c=Math.min(.3*l,.5),h=Math.max(0,(t-c)/(1-c)),u=Math.sin(h*Math.PI);s._originalGlow||(s._originalGlow={hasGlow:s.hasGlow,glowSizeMultiplier:s.glowSizeMultiplier||0}),s.hasGlow=!0,s.glowSizeMultiplier=Math.max(3,s._originalGlow.glowSizeMultiplier)+u*i*3,o*=1+.3*u,t>=.99&&s._originalGlow&&(s.hasGlow=s._originalGlow.hasGlow,s.glowSizeMultiplier=s._originalGlow.glowSizeMultiplier,delete s._originalGlow)}if(s.hasGlow||l>1){const t=Math.max(.1,o*(s.glowSizeMultiplier||1.5)*l),i=e.globalCompositeOperation;e.globalCompositeOperation="screen",e.globalAlpha=.15*s.opacity*l,e.beginPath(),e.arc(s.x,s.y,t,0,2*Math.PI),e.fill(),e.globalAlpha=.25*s.opacity*l,e.beginPath(),e.arc(s.x,s.y,.6*t,0,2*Math.PI),e.fill(),e.globalCompositeOperation=i}e.globalAlpha=s.opacity*(s.baseOpacity||.5)*.6*Math.min(2,l),e.beginPath(),e.arc(s.x,s.y,o,0,2*Math.PI),e.fill()}e.restore()}}class Dd{constructor(e=50,t=null){this.errorBoundary=t,this.maxParticles=e,this.absoluteMaxParticles=2*e,this.particles=[],this.particlePool=new Cd(e),this.particleSpawner=new Pd,this.particleRenderer=new kd,this.containmentBounds=null,this.stateChangeCount=0,this.lastMemoryCheck=Date.now(),this.lastLeakedCount=0,this.particleCount=0,this.cleanupTimer=0,this.cleanupInterval=5e3}get pool(){return this.particlePool.pool}get poolSize(){return this.particlePool.poolSize}get poolHits(){return this.particlePool.poolHits}get poolMisses(){return this.particlePool.poolMisses}get totalParticlesCreated(){return this.particlePool.totalParticlesCreated}get totalParticlesDestroyed(){return this.particlePool.totalParticlesDestroyed}get spawnAccumulator(){return this.particleSpawner.spawnAccumulator}set spawnAccumulator(e){this.particleSpawner.spawnAccumulator=e}getParticleFromPool(e,t,i){return this.particlePool.getParticle(e,t,i,this.scaleFactor||1,this.particleSizeMultiplier||1,this.currentEmotionColors,this.currentEmotion,this.gestureBehavior)}returnParticleToPool(e){this.particlePool.returnParticle(e)}spawn(e,t,i,a,n,s,r=null,o=0,l=10,c=1,h=1,u=null,d=null){if(this.scaleFactor=c,this.particleSizeMultiplier=h,this.errorBoundary)return this.errorBoundary.wrap(()=>{this._spawn(e,t,i,a,n,s,r,o,l,u,d)},"particle-spawn")();this._spawn(e,t,i,a,n,s,r,o,l,u,d)}resetAccumulator(){this.particleSpawner.resetAccumulator()}_spawn(e,t,i,a,n,s,r,o=0,l=10,c=null,h=null){this.currentEmotion=t,this.baseEmotionColors=c,this.currentUndertone=h,this.currentEmotionColors=c&&h?function(e,t){return e&&Array.isArray(e)&&t&&"clear"!==t?e.map(e=>"string"==typeof e?Yi(e,t):e&&"object"==typeof e&&e.color?{...e,color:Yi(e.color,t)}:e):e}(c,h):c;let u=i;if(Xi.isEnabled()){const i=Qi&&Qi.isInitialized?Qi.getEmotion(t):Ii(t);if(i){const t=Xi.applyParticleRhythm(i,this);if(t.emitBurst)for(let i=0;i<t.emitBurst&&this.particles.length<l;i++)this.spawnSingleParticle(e,a,n);void 0!==t.emissionRate&&(u*=t.emissionRate)}}if(null!==r){for(let t=0;t<r&&this.particles.length<this.maxParticles;t++)this.spawnSingleParticle(e,a,n);return}if(this.skipSpawnThisFrame)return;for(;this.particles.length<o&&this.particles.length<this.maxParticles;)this.spawnSingleParticle(e,a,n);if(this.particles.length>=l)return;if(u<=0)return;const d=this.particleSpawner.calculateSpawnRate(u,s);for(let t=0;t<d&&this.particles.length<l;t++)this.spawnSingleParticle(e,a,n)}getSpawnPosition(e,t,i,a,n){return this.particleSpawner.getSpawnPosition(e,t,i,a,n,this.currentEmotion)}clampToCanvas(e,t,i,a,n=30){return this.particleSpawner.clampToCanvas(e,t,i,a,n)}spawnSingleParticle(e,t,i){if(this.particles.length>=this.absoluteMaxParticles)return;const a=this.canvasWidth||2*t,n=this.canvasHeight||2*i,s=this.particleSpawner.getSpawnPosition(e,t,i,a,n,this.currentEmotion),r=this.particleSpawner.clampToCanvas(s.x,s.y,a,n);s.x=r.x,s.y=r.y;const o=this.getParticleFromPool(s.x,s.y,e);"meditation_swirl"===e&&s.palmCenter&&(o.palmCenter=s.palmCenter,o.swirlAngle=s.swirlAngle),this.particles.push(o),this.particleCount++}update(e,t,i,a=null,n=0,s=null){if(this.errorBoundary)return this.errorBoundary.wrap((e,t,i,a,n,s)=>this._update(e,t,i,a,n,s),"particle-update")(e,t,i,a,n,s);this._update(e,t,i,a,n,s)}_update(e,t,i,a=null,n=0,s=null){"rain"===a?.type&&console.log("[PARTICLE_SYSTEM] _update() with RAIN:",{gestureMotionType:a.type,gestureProgress:n?.toFixed(3),particleCount:this.particles.length});let r=!1;for(this.particles=this.particles.filter(o=>("rain"!==a?.type||r||(console.log("[PARTICLE_SYSTEM] Calling particle.update() for first particle with RAIN"),r=!0),o.update(e,t,i,s,a,n,this.containmentBounds),o.isAlive()));this.particles.length>this.maxParticles;)this.removeParticle(0)}setGestureBehavior(e,t){this.gestureBehavior=t?e:null,t?this.particles.forEach(t=>{t.gestureBehavior=e}):this.particles.forEach(e=>{e.gestureBehavior=null})}removeParticle(e){if(e>=0&&e<this.particles.length){const t=this.particles.splice(e,1)[0];t.cachedGradient=null,t.cachedGradientKey=null,this.returnParticleToPool(t),this.particleCount=Math.max(0,this.particleCount-1)}}render(e,t="#ffffff",i=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._render(e,t,i)},"particle-render")();this._render(e,t,i)}renderBackground(e,t="#ffffff",i=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._renderLayer(e,t,!1,i)},"particle-render-bg")();this._renderLayer(e,t,!1,i)}renderForeground(e,t="#ffffff",i=null){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._renderLayer(e,t,!0,i)},"particle-render-fg")();this._renderLayer(e,t,!0,i)}_renderLayer(e,t,i,a=null){this.particleRenderer.renderLayer(e,this.particles,t,i,a)}_render(e,t,i=null){this.particleRenderer.render(e,this.particles,t,i)}onVisibilityResume(e,t=null){if(this.resetAccumulator(),e>3e4)this.clear();else if(e>1e4){const e=this.particles.length,i=t??e,a=Math.max(10,Math.floor(.5*i));for(;this.particles.length>a;)this.removeParticle(0)}}clear(){for(this.stateChangeCount++;this.particles.length>0;){const e=this.particles.pop();if(e.cachedColors&&e.cachedColors.clear(),e.behaviorData)for(const t in e.behaviorData)delete e.behaviorData[t];this.pool.length<this.poolSize&&!this.pool.includes(e)&&this.pool.push(e)}if(this.particles.length=0,this.particleCount=0,this.spawnAccumulator=0,this.pool.length>this.poolSize){const e=this.pool.length-this.poolSize;this.pool.splice(this.poolSize,e)}}burst(e,t,i,a){if(this.errorBoundary)return this.errorBoundary.wrap(()=>{this._burst(e,t,i,a)},"particle-burst")();this._burst(e,t,i,a)}_burst(e,t,i,a){const n=Math.min(e,this.maxParticles-this.particles.length);for(let e=0;e<n;e++)this.spawnSingleParticle(t,i,a)}performCleanup(){if(this.pool.length>this.poolSize){const e=this.pool.length-this.poolSize;for(let t=0;t<e;t++){const e=this.pool.pop();e&&(e.cachedGradient=null,e.cachedGradientKey=null,e.behaviorData=null)}}for(const e of this.particles)e.cachedGradient&&e.life<.5&&(e.cachedGradient=null,e.cachedGradientKey=null)}getStats(){return{activeParticles:this.particles.length,maxParticles:this.maxParticles,poolSize:this.pool.length,poolHits:this.poolHits,poolMisses:this.poolMisses,poolEfficiency:this.poolHits/Math.max(1,this.poolHits+this.poolMisses),spawnAccumulator:this.spawnAccumulator}}setMaxParticles(e){for(this.originalMaxParticles=this.originalMaxParticles||this.maxParticles,this.maxParticles=Math.max(1,e);this.particles.length>this.maxParticles;)this.removeParticle(0)}cleanupDeadParticles(){const e=this.particles.length;this.particles=this.particles.filter(e=>e.isAlive());const t=e-this.particles.length;return this.pool.length>20&&(this.pool.length=20),t}getParticlesByBehavior(e){return this.particles.filter(t=>t.behavior===e)}validateParticles(){for(const e of this.particles)if(!e.isAlive()||e.life<0||e.life>1)return!1;return!0}cleanup(){for(let e=this.particles.length-1;e>=0;e--)this.particles[e].isAlive()||this.removeParticle(e)}refreshPool(){this.particlePool.clear();for(const e of this.particles)e.life=0}setContainmentBounds(e){this.containmentBounds=e}destroy(){this.clear(),this.particlePool.clear()}}class Ad{constructor(t={}){this.worldScale=t.worldScale||.2,this.baseRadius=t.baseRadius||.15,this.depthScale=t.depthScale||.75,this.verticalScale=t.verticalScale||1,this.coreRadius3D=t.coreRadius3D||1,this.tempVec3=new e.Vector3,this.tempVec3_2=new e.Vector3,this.behaviorTranslators=this._initBehaviorTranslators(),this.currentGestureData=null}setCoreRadius3D(e){this.coreRadius3D=e}updateRotationState(e,t,i=null){this.rotationState=e,this.deltaTime=t,this.currentGestureData=i}_initBehaviorTranslators(){return{ambient:this._translateAmbient.bind(this),orbiting:this._translateOrbiting.bind(this),rising:this._translateRising.bind(this),falling:this._translateFalling.bind(this),popcorn:this._translatePopcorn.bind(this),burst:this._translateBurst.bind(this),aggressive:this._translateAggressive.bind(this),scattering:this._translateScattering.bind(this),repelling:this._translateRepelling.bind(this),connecting:this._translateConnecting.bind(this),resting:this._translateResting.bind(this),radiant:this._translateRadiant.bind(this),ascending:this._translateAscending.bind(this),erratic:this._translateErratic.bind(this),cautious:this._translateCautious.bind(this),surveillance:this._translateSurveillance.bind(this),glitchy:this._translateGlitchy.bind(this),spaz:this._translateSpaz.bind(this),directed:this._translateDirected.bind(this),fizzy:this._translateFizzy.bind(this),zen:this._translateZen.bind(this),gravitationalAccretion:this._translateGravitationalAccretion.bind(this)}}translate2DTo3D(e,t,i){if(e.gestureData?.rain?.initialized)return this._translateRainGesture(e,t,i);const a=(this.behaviorTranslators[e.behavior]||this._translateDefault.bind(this))(e,t,i);return this.currentGestureData&&"spin"===this.currentGestureData.gestureName?this._applySpinRotation(a,t,this.currentGestureData.progress):a}_translateRainGesture(e,t,i){const a=i.width/2,n=i.height/2,s=e.gestureData.rain,r=.004*(e.y-s.originalY),o=this._getUniformDirection3D(e),l=s.originalX-a,c=s.originalY-n,h=Math.sqrt(l*l+c*c)/a,u=.6*this.coreRadius3D,d=u+h*(1.2*this.coreRadius3D-u);return this.tempVec3.set(t.x+o.x*d,t.y+o.y*d*this.verticalScale-r,t.z+o.z*d)}_applySpinRotation(e,t,i){const a=e.x-t.x,n=e.y-t.y,s=e.z-t.z,r=Math.sin(i*Math.PI)*Math.PI*2,o=Math.cos(r),l=Math.sin(r),c=a*o-s*l,h=a*l+s*o;return this.tempVec3.set(t.x+c,t.y+n,t.z+h)}_canvasToWorld(e,t,i,a,n,s){const r=(e-a)/a,o=-(t-n)/n,l=1+i*this.depthScale,c=r*this.worldScale*l+s.x,h=o*this.worldScale*this.verticalScale*l+s.y,u=i*this.worldScale*.5+s.z;return this.tempVec3.set(c,h,u)}_hash(e){const t=43758.5453123*Math.sin(e);return t-Math.floor(t)}_getUniformDirection3D(e){const t=e.behaviorData||{};if(t.direction3D)return t.direction3D;const i=127.1*e.x+311.7*e.y+74.7*(e.vx||0)+159.3*(e.vy||0),a=this._hash(i),n=this._hash(i+1),s=a*Math.PI*2,r=2*n-1,o=Math.sqrt(1-r*r),l=o*Math.cos(s),c=r,h=o*Math.sin(s);return t.direction3D={x:l,y:c,z:h},t.direction3D}_toSpherical(e,t,i,a){const n=e-a.x,s=t-a.y,r=i-a.z,o=Math.sqrt(n*n+s*s+r*r);return{radius:o,theta:Math.atan2(r,n),phi:Math.acos(s/(o||1))}}_toCartesian(e,t,i,a){const n=e*Math.sin(i)*Math.cos(t)+a.x,s=e*Math.cos(i)+a.y,r=e*Math.sin(i)*Math.sin(t)+a.z;return this.tempVec3_2.set(n,s,r)}_translateDefault(e,t,i){return this._canvasToWorld(e.x,e.y,e.z,i.width/2,i.height/2,t)}_translateAmbient(e,t,i){const a=this._getUniformDirection3D(e),n=i.width/2,s=i.height/2,r=e.x-n,o=e.y-s,l=Math.sqrt(r*r+o*o)/n,c=.6*this.coreRadius3D,h=c+l*(1.2*this.coreRadius3D-c),u=.5*e.age,d=.03*this.coreRadius3D,m=Math.cos(u)*d,p=Math.sin(u)*d;return this.tempVec3.set(t.x+a.x*h+m,t.y+a.y*h*this.verticalScale,t.z+a.z*h+p)}_translateOrbiting(e,t,i){const a=e.behaviorData||{};if(!a.orbitPlane){const t=e.x+.5*e.y,i=.7*e.x+e.y;a.orbitPlane={inclination:.5*(Math.sin(.1*t)+1)*Math.PI,rotation:.5*(Math.sin(.1*i)+1)*Math.PI*2}}const{inclination:n,rotation:s}=a.orbitPlane,r=a.angle||0,o=.01*(a.radius||100)*this.baseRadius*.25*(1+e.z*this.depthScale),l=Math.cos(r)*o,c=Math.sin(r)*o,h=Math.cos(n),u=Math.sin(n),d=Math.cos(s),m=Math.sin(s),p=l*d-c*h*m,g=c*u,f=l*m+c*h*d;return this.tempVec3.set(t.x+p,t.y+g*this.verticalScale,t.z+f)}_translateRising(e,t,i){const a=this._canvasToWorld(e.x,e.y,e.z,i.width/2,i.height/2,t),n=-.01*e.vy;return a.y+=n,a}_translateFalling(e,t,i){const a=i.width/2,n=i.height/2,s=e.gestureData?.rain?.initialized;if(s){const i=e.gestureData.rain,s=.004*(e.y-i.originalY),r=this._getUniformDirection3D(e),o=i.originalX-a,l=i.originalY-n,c=Math.sqrt(o*o+l*l)/a,h=.6*this.coreRadius3D,u=h+c*(1.2*this.coreRadius3D-h);return this.tempVec3.set(t.x+r.x*u,t.y+r.y*u*this.verticalScale-s,t.z+r.z*u)}const r=this._getUniformDirection3D(e),o=e.x-a,l=e.y-n,c=Math.sqrt(o*o+l*l)/a,h=.6*this.coreRadius3D,u=h+c*(1.2*this.coreRadius3D-h),d=.6*e.age*this.coreRadius3D;return this.tempVec3.set(t.x+r.x*u,t.y+r.y*u*this.verticalScale-d,t.z+r.z*u)}_translatePopcorn(e,t,i){const a=i.width/2,n=i.height/2,s=e.behaviorData||{},r=this._getUniformDirection3D(e);if(!s.hasPopped){const e=.7*this.coreRadius3D;return this.tempVec3.set(t.x+r.x*e,t.y+r.y*e*this.verticalScale,t.z+r.z*e)}const o=e.x-a,l=e.y-n,c=Math.sqrt(o*o+l*l),h=Math.min(c/a,1.5),u=1.2*this.coreRadius3D,d=u+h*(4*this.coreRadius3D-u);return this.tempVec3.set(t.x+r.x*d,t.y+r.y*d*this.verticalScale,t.z+r.z*d)}_translateBurst(e,t,i){const a=this._getUniformDirection3D(e),n=1-e.life,s=this.coreRadius3D*(1+1*n);return this.tempVec3.set(t.x+a.x*s,t.y+a.y*s*this.verticalScale,t.z+a.z*s)}_translateAggressive(e,t,i){const a=this._getUniformDirection3D(e),n=i.width/2,s=i.height/2,r=e.x-n,o=e.y-s,l=Math.sqrt(r*r+o*o)/n,c=.3*this.coreRadius3D,h=c+l*(.55*this.coreRadius3D-c),u=.04*this.coreRadius3D,d=Math.sin(10*e.age+.1*e.x)*u,m=Math.cos(12*e.age+.1*e.y)*u,p=Math.sin(8*e.age+.1*e.vx)*u;return this.tempVec3.set(t.x+a.x*h+d,t.y+a.y*h*this.verticalScale+m,t.z+a.z*h+p)}_translateScattering(e,t,i){const a=this._getUniformDirection3D(e),n=Math.min(.8*e.age,1),s=this.coreRadius3D*(.3+.3*n);return this.tempVec3.set(t.x+a.x*s,t.y+a.y*s*this.verticalScale,t.z+a.z*s)}_translateRepelling(e,t,i){const a=this._getUniformDirection3D(e),n=Math.min(.6*e.age,1),s=this.coreRadius3D*(.3+.3*n);return this.tempVec3.set(t.x+a.x*s,t.y+a.y*s*this.verticalScale,t.z+a.z*s)}_translateConnecting(e,t,i){const a=this._canvasToWorld(e.x,e.y,e.z,i.width/2,i.height/2,t),n=.3*(1-e.life),s=this.tempVec3_2.set(t.x-a.x,t.y-a.y,t.z-a.z).normalize();return a.add(s.multiplyScalar(n)),a}_translateResting(e,t,i){const a=this._getUniformDirection3D(e),n=i.width/2,s=i.height/2,r=e.x-n,o=e.y-s,l=Math.sqrt(r*r+o*o)/n,c=.25*this.coreRadius3D,h=c+l*(.45*this.coreRadius3D-c),u=.3*e.age,d=Math.sin(u)*this.coreRadius3D*.01;return this.tempVec3.set(t.x+a.x*h,t.y+a.y*h*this.verticalScale+d,t.z+a.z*h)}_translateRadiant(e,t,i){const a=this._getUniformDirection3D(e),n=1-e.life,s=this.coreRadius3D*(1+.8*n);return this.tempVec3.set(t.x+a.x*s,t.y+a.y*s*this.verticalScale,t.z+a.z*s)}_translateAscending(e,t,i){const a=e.behaviorData||{},n=a.spiralAngle||0,s=.01*(a.spiralRadius||50)*this.coreRadius3D,r=e.age*this.coreRadius3D*.5,o=Math.cos(n)*s+t.x,l=r+t.y,c=Math.sin(n)*s+t.z;return this.tempVec3.set(o,l,c)}_translateErratic(e,t,i){const a=this._canvasToWorld(e.x,e.y,e.z,i.width/2,i.height/2,t),n=10*e.age;return a.x+=.1*Math.sin(1.1*n),a.y+=.1*Math.cos(1.3*n),a.z+=.1*Math.sin(1.7*n),a}_translateCautious(e,t,i){return this._translateAmbient(e,t,i)}_translateSurveillance(e,t,i){const a=this._getUniformDirection3D(e),n=.5*e.age,s=1.2*this.coreRadius3D,r={x:0*a.y-1*a.z,y:0*a.z-0*a.x,z:1*a.x-0*a.y},o=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z);o>0&&(r.x/=o,r.y/=o,r.z/=o);const l=Math.cos(n)*a.x+Math.sin(n)*r.x,c=Math.cos(n)*a.y+Math.sin(n)*r.y,h=Math.cos(n)*a.z+Math.sin(n)*r.z;return this.tempVec3.set(t.x+l*s,t.y+c*s*this.verticalScale,t.z+h*s)}_translateGlitchy(e,t,i){const a=this._canvasToWorld(e.x,e.y,e.z,i.width/2,i.height/2,t);return Math.floor(10*e.age)%3==0&&(a.x+=.3*(Math.random()-.5),a.y+=.3*(Math.random()-.5),a.z+=.3*(Math.random()-.5)),a}_translateSpaz(e,t,i){const a=this._canvasToWorld(e.x,e.y,e.z,i.width/2,i.height/2,t),n=.15,s=20*e.age;return a.x+=Math.sin(2.1*s)*n,a.y+=Math.cos(2.3*s)*n,a.z+=Math.sin(2.7*s)*n,a}_translateDirected(e,t,i){const a=e.behaviorData||{};if(void 0!==a.targetX&&void 0!==a.targetY){const n=this._canvasToWorld(a.targetX,a.targetY,e.z,i.width/2,i.height/2,t),s=this._canvasToWorld(e.x,e.y,e.z,i.width/2,i.height/2,t),r=1-e.life;return this.tempVec3.lerpVectors(s,n,r)}const n=this._getUniformDirection3D(e),s=i.width/2,r=i.height/2,o=e.x-s,l=e.y-r,c=Math.sqrt(o*o+l*l)/s,h=1*this.coreRadius3D,u=h+c*(1.6*this.coreRadius3D-h);return this.tempVec3.set(t.x+n.x*u,t.y+n.y*u*this.verticalScale,t.z+n.z*u)}_translateFizzy(e,t,i){const a=this._canvasToWorld(e.x,e.y,e.z,i.width/2,i.height/2,t),n=.05*Math.sin(8*e.age);return a.x+=n,a.z+=.05*Math.cos(8*e.age),a.y+=.5*e.age,a}_translateZen(e,t,i){const a=this._getUniformDirection3D(e),n=.2*e.age,s=1.4*this.coreRadius3D,r={x:0*a.y-1*a.z,y:0*a.z-0*a.x,z:1*a.x-0*a.y},o=Math.sqrt(r.x*r.x+r.y*r.y+r.z*r.z);o>0&&(r.x/=o,r.y/=o,r.z/=o);const l=Math.cos(n)*a.x+Math.sin(n)*r.x,c=Math.cos(n)*a.y+Math.sin(n)*r.y,h=Math.cos(n)*a.z+Math.sin(n)*r.z;return this.tempVec3.set(t.x+l*s,t.y+c*s*this.verticalScale,t.z+h*s)}_translateGravitationalAccretion(e,t,i){const a=e.behaviorData||{},n=.25;if(a.orbitRadius||(e.x,e.y,a.orbitRadius=n*(2.5+5.5*Math.random()),a.orbitAngle=Math.PI+Math.random()*Math.PI,a.diskInclination=.1*(Math.random()-.5),a.angularVelocity=.5/Math.sqrt(a.orbitRadius/n),a.tidalStretch={x:1,y:1,z:1}),a.orbitRadius-=1e-4*this.baseRadius,a.angularVelocity=.5/Math.sqrt(a.orbitRadius/n),a.orbitAngle+=a.angularVelocity*(this.deltaTime||16)*.001,a.orbitAngle=a.orbitAngle%(2*Math.PI),a.orbitAngle<0&&(a.orbitAngle+=2*Math.PI),a.orbitAngle<Math.PI)return e.isAlive=!1,e.life=0,this.tempVec3.set(t.x,t.y,t.z);const s=a.orbitRadius/n;if(s<=1)e.isAlive=!1,e.life=0;else if(s<=1.5)a.tidalStretch.x=.3,a.tidalStretch.y=3,a.tidalStretch.z=.3;else if(s<=2.5){const e=(2.5-s)/1;a.tidalStretch.x=1-.7*e,a.tidalStretch.y=1+2*e,a.tidalStretch.z=1-.7*e}else a.tidalStretch.x=1,a.tidalStretch.y=1,a.tidalStretch.z=1;const r=Math.cos(a.orbitAngle)*a.orbitRadius,o=Math.sin(a.orbitAngle)*a.orbitRadius,l=.025*Math.sin(3*a.orbitAngle+e.x)*Math.sin(a.diskInclination),c=r*a.tidalStretch.x,h=l*a.tidalStretch.y,u=o*a.tidalStretch.z,d=.25;return this.tempVec3.set(t.x+c*d,t.y+h*d,t.z+u*d)}setWorldScale(e){this.worldScale=e}setBaseRadius(e){this.baseRadius=e}cleanupParticleCaches(e){for(const t of e)!t.isAlive&&t.behaviorData&&(t.behaviorData.direction3D&&(t.behaviorData.direction3D=null),t.behaviorData.orbitPlane&&(t.behaviorData.orbitPlane=null),t.behaviorData.orbitPath&&(t.behaviorData.orbitPath=null),t.behaviorData.orbitRadius&&(t.behaviorData.orbitRadius=null,t.behaviorData.orbitAngle=null,t.behaviorData.diskInclination=null,t.behaviorData.angularVelocity=null,t.behaviorData.tidalStretch=null))}dispose(){this.tempVec3=null,this.tempVec3_2=null,this.rotationState=null,this.currentGestureData=null}}let _d=null,Td=null;const Id=`\n    uniform float time;\n    uniform vec3 emotionColor;\n    uniform float energyIntensity;\n    uniform float driftEnabled;\n    uniform float driftSpeed;\n    uniform float crossWaveEnabled;\n    uniform float crossWaveSpeed;\n    uniform float ghostMode;      // 0.0 = solid, 1.0 = ghost (only visible through bloom)\n    uniform float baseOpacity;    // Base opacity when not in ghost mode (default 1.0)\n    uniform float phaseOffset1;   // Phase offset for primary drift (radians)\n    uniform float phaseOffset2;   // Phase offset for secondary drift (radians)\n    uniform float phaseOffset3;   // Phase offset for crosswave (radians)\n\n    // Blend layer uniforms\n    uniform float blendLayer1Mode;\n    uniform float blendLayer1Strength;\n    uniform float blendLayer1Enabled;\n    uniform float blendLayer2Mode;\n    uniform float blendLayer2Strength;\n    uniform float blendLayer2Enabled;\n\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n\n    // Blend modes (injected from blendModesGLSL)\n    ${jt}\n\n    // Smooth noise function\n    float noise3D(vec3 p) {\n        vec3 i = floor(p);\n        vec3 f = fract(p);\n        f = f * f * (3.0 - 2.0 * f);\n        float n = i.x + i.y * 157.0 + i.z * 113.0;\n        vec4 v = fract(sin(vec4(n, n+1.0, n+157.0, n+158.0)) * 43758.5453);\n        return mix(mix(v.x, v.y, f.x), mix(v.z, v.w, f.x), f.y);\n    }\n\n    void main() {\n        // Drifting energy clouds - slow, ethereal movement\n        // Start with zero energy - only effects add to it\n        float driftEnergy = 0.0;\n        float crossWaveEnergy = 0.0;\n\n        // Spatially triangulated fire bands - each owns a 120° wedge of the geometry\n        // Bands can never overlap because they're physically separated\n        float angle = atan(vPosition.x, vPosition.z); // -π to π\n        float normalizedAngle = (angle + 3.14159) / 6.28318; // 0 to 1\n\n        // Determine which zone this fragment belongs to (0, 1, or 2)\n        float zone = floor(normalizedAngle * 3.0);\n        float zonePos = fract(normalizedAngle * 3.0); // Position within zone (0-1)\n\n        // Time-based phase for each zone (120° offset in time)\n        float phaseSpeed = 0.15;\n        float t = time * phaseSpeed;\n        float phase1Time = sin(t + phaseOffset1) * 0.5 + 0.5;\n        float phase2Time = sin(t + phaseOffset2) * 0.5 + 0.5;\n        float phase3Time = sin(t + phaseOffset3) * 0.5 + 0.5;\n\n        // Only ONE phase affects this fragment - the one that owns this spatial zone\n        float activePhase = zone < 1.0 ? phase1Time : (zone < 2.0 ? phase2Time : phase3Time);\n\n        float primaryDrift = 0.0;\n        float secondaryDrift = 0.0;\n\n        if (driftEnabled > 0.5) {\n            float t = time * driftSpeed;\n            // OPTIMIZED: Reduced from 4 noise calls to 2 for better performance\n            // Primary drift - single noise call with combined coordinates\n            float drift1 = noise3D(vPosition * 2.0 + vec3(t, t * 0.7, t * 0.3));\n            primaryDrift = max(0.0, drift1 - 0.3) * 1.5; // Adjusted threshold for single noise\n\n            // Secondary drift - offset phase to fill gaps\n            float drift2 = noise3D(vPosition * 2.5 - vec3(t * 0.6, t * 0.4, t));\n            secondaryDrift = max(0.0, drift2 - 0.3) * 1.5;\n\n            driftEnergy = primaryDrift + secondaryDrift;\n        }\n\n        // Horizontal cross wave - thin bands sweeping across\n        float rawCrossWave = 0.0;\n        if (crossWaveEnabled > 0.5) {\n            float t = time * crossWaveSpeed;\n            float wave = sin(vPosition.x * 4.0 + vPosition.z * 2.0 - t) * 0.5 + 0.5;\n            // pow(4) for thin bright bands\n            rawCrossWave = pow(wave, 4.0);\n            crossWaveEnergy = rawCrossWave;\n        }\n\n        // Mix the effects - normalize to prevent blowout\n        // driftEnergy can be 0-2 (two drifts), rawCrossWave is 0-1\n        float normalizedDrift = min(1.0, driftEnergy * 0.5);\n        float normalizedWave = rawCrossWave;\n\n        // activePhase is 0-1, remap to visibility range\n        // 0.53 floor (just above 0.52 threshold), 0.58 ceiling (subtle glow)\n        float remappedPhase = 0.53 + activePhase * 0.05;\n\n        // Effects add subtle variation (max 0.05)\n        float effectContrib = (normalizedDrift * 0.03) + (normalizedWave * 0.02);\n        float phasedActivity = remappedPhase + effectContrib;\n\n        // Keep unclamped for visibility threshold check (ghost mode needs full range)\n        float rawEffectActivity = phasedActivity;\n        // Clamp for color intensity (floor: guaranteed visible, ceiling: no blowout)\n        float effectActivity = clamp(phasedActivity, 0.53, 0.60);\n\n        // Total energy for color calculation (reduced for subtler bloom)\n        float totalEnergy = 0.25 + effectActivity * 0.55; // Base glow + effect contribution\n\n        // Edge glow - adds rim lighting\n        vec3 viewDir = normalize(-vPosition);\n        float edgeGlow = 1.0 - abs(dot(vNormal, viewDir));\n        edgeGlow = pow(edgeGlow, 2.0) * 0.4;\n\n        // Final color before blend layers\n        vec3 coreColor = emotionColor * totalEnergy * energyIntensity;\n        coreColor += emotionColor * edgeGlow * 0.3;\n\n        // Apply blend layers to the entire soul color\n        if (blendLayer1Enabled > 0.5) {\n            int mode = int(blendLayer1Mode + 0.5);\n            vec3 blendResult = applyBlendMode(coreColor, emotionColor * blendLayer1Strength, mode);\n            coreColor = mix(coreColor, blendResult, blendLayer1Strength);\n        }\n        if (blendLayer2Enabled > 0.5) {\n            int mode = int(blendLayer2Mode + 0.5);\n            vec3 blendResult = applyBlendMode(coreColor, emotionColor * blendLayer2Strength, mode);\n            coreColor = mix(coreColor, blendResult, blendLayer2Strength);\n        }\n\n        // Ghost mode: ONLY the traveling fire bands are visible\n        // Everything below the threshold is completely invisible\n        float alpha = baseOpacity;\n        if (ghostMode > 0.01) {\n            // High threshold - only the peaks of the thin bands pass through\n            float threshold = 0.4 + ghostMode * 0.4; // 0.4-0.8 range\n            float visibility = smoothstep(threshold, threshold + 0.05, rawEffectActivity);\n\n            // Hard cutoff - only bright fire bands visible\n            alpha = visibility * baseOpacity;\n\n            // Discard everything that isn't a bright fire band\n            if (alpha < 0.05) {\n                discard;\n            }\n\n            // Boost color intensity for visible fire\n            coreColor *= 1.2 + visibility * 0.6;\n        }\n\n        // Output the computed core color\n        gl_FragColor = vec4(coreColor, alpha);\n    }\n`;class Od{constructor(e={}){this.radius=e.radius||.15,this.detail=e.detail||1,this.geometryType=e.geometryType||"crystal",this.renderer=e.renderer||null,this.assetBasePath=e.assetBasePath||"/assets",this.mesh=null,this.material=null,this.parentMesh=null,this.baseScale=1,this._pendingParent=null,this._disposed=!1,this._createMesh()}static _loadInclusionGeometry(t="/assets"){return _d?Promise.resolve(_d.clone()):Td?Td.then(e=>e.clone()):(Td=new Promise(i=>{(new Vt).load(`${t}/models/Crystal/inclusion.obj`,t=>{let a=null;if(t.traverse(e=>{e.isMesh&&e.geometry&&({geometry:a}=e)}),a){a.computeBoundingBox();const t=new e.Vector3;a.boundingBox.getCenter(t),a.translate(-t.x,-t.y,-t.z),a.rotateX(Math.PI/2),a.computeBoundingBox();const n=new e.Vector3;a.boundingBox.getSize(n);const s=.3/Math.max(n.x,n.y,n.z);a.scale(s,s,s),a.computeVertexNormals(),_d=a,i(a.clone())}else console.warn("[🔮 SOUL] No mesh in inclusion.obj, using fallback"),i(null)},void 0,e=>{console.warn("[🔮 SOUL] Failed to load inclusion.obj:",e),i(null)})}),Td)}_createMesh(){let t;this.material=new e.ShaderMaterial({uniforms:{time:{value:0},emotionColor:{value:new e.Color(1,1,1)},energyIntensity:{value:.8},driftEnabled:{value:1},driftSpeed:{value:.5},crossWaveEnabled:{value:1},crossWaveSpeed:{value:.4},ghostMode:{value:.36},baseOpacity:{value:1},phaseOffset1:{value:0},phaseOffset2:{value:2.094},phaseOffset3:{value:4.189},blendLayer1Mode:{value:2},blendLayer1Strength:{value:2.3},blendLayer1Enabled:{value:1},blendLayer2Mode:{value:0},blendLayer2Strength:{value:1},blendLayer2Enabled:{value:1}},vertexShader:"\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n\n    void main() {\n        vPosition = position;\n        vNormal = normalize(normalMatrix * normal);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n",fragmentShader:Id,transparent:!0,depthWrite:!0,depthTest:!0,side:e.FrontSide}),t=_d?_d.clone():new e.OctahedronGeometry(this.radius,this.detail),this.mesh=new e.Mesh(t,this.material),this.mesh.name="crystalSoul",this.mesh.renderOrder=0,this.mesh.layers.set(2)}attachTo(e,t){this._disposed||(e?this.mesh?(this.mesh.parent&&this.mesh.parent.remove(this.mesh),this.parentMesh=e,this._scene=t,t&&!this.mesh.parent&&t.add(this.mesh),this._syncPosition(),this.mesh.visible=!0):console.warn("[CrystalSoul] Cannot attach - mesh is null"):console.warn("[CrystalSoul] Cannot attach to null parent"))}_syncPosition(){this.parentMesh&&this.mesh&&(this.parentMesh.getWorldPosition(this.mesh.position),this.parentMesh.getWorldQuaternion(this.mesh.quaternion))}detach(){this.mesh&&(this.mesh.visible=!1,this.parentMesh=null)}update(e,t,i=1){if(!this.material||!this.material.uniforms)return;this._syncPosition();const{uniforms:a}=this.material;if(a.time&&(a.time.value+=e/1e3),a.emotionColor&&t){const e=a.emotionColor.value;e.r===t[0]&&e.g===t[1]&&e.b===t[2]||e.setRGB(t[0],t[1],t[2])}this.mesh&&this.mesh.scale.setScalar(this.baseScale*i)}setSize(e){if(!this.mesh)return;const t=.05+.95*e;this.baseScale=t,this.mesh.scale.setScalar(t)}setEffects(e={}){if(!this.material||!this.material.uniforms)return;const{uniforms:t}=this.material;void 0!==e.driftEnabled&&t.driftEnabled&&(t.driftEnabled.value=e.driftEnabled?1:0),void 0!==e.driftSpeed&&t.driftSpeed&&(t.driftSpeed.value=Math.max(.1,Math.min(3,e.driftSpeed))),void 0!==e.crossWaveEnabled&&t.crossWaveEnabled&&(t.crossWaveEnabled.value=e.crossWaveEnabled?1:0),void 0!==e.crossWaveSpeed&&t.crossWaveSpeed&&(t.crossWaveSpeed.value=Math.max(.1,Math.min(3,e.crossWaveSpeed))),void 0!==e.phaseOffset1&&t.phaseOffset1&&(t.phaseOffset1.value=e.phaseOffset1),void 0!==e.phaseOffset2&&t.phaseOffset2&&(t.phaseOffset2.value=e.phaseOffset2),void 0!==e.phaseOffset3&&t.phaseOffset3&&(t.phaseOffset3.value=e.phaseOffset3)}setColor(e){this.material&&this.material.uniforms&&this.material.uniforms.emotionColor&&this.material.uniforms.emotionColor.value.setRGB(e[0],e[1],e[2])}setBlendLayers(e){if(!this.material||!this.material.uniforms)return;const t=this.material.uniforms;e[0]?(t.blendLayer1Mode&&(t.blendLayer1Mode.value=e[0].mode??0),t.blendLayer1Strength&&(t.blendLayer1Strength.value=e[0].strength??0),t.blendLayer1Enabled&&(t.blendLayer1Enabled.value=e[0].enabled?1:0)):t.blendLayer1Enabled&&(t.blendLayer1Enabled.value=0),e[1]?(t.blendLayer2Mode&&(t.blendLayer2Mode.value=e[1].mode??0),t.blendLayer2Strength&&(t.blendLayer2Strength.value=e[1].strength??0),t.blendLayer2Enabled&&(t.blendLayer2Enabled.value=e[1].enabled?1:0)):t.blendLayer2Enabled&&(t.blendLayer2Enabled.value=0)}isAttached(){return null!==this.parentMesh&&null!==this.mesh&&null!==this.mesh.parent}setVisible(e){this.mesh&&(this.mesh.visible=e)}setGhostMode(e){this.material&&this.material.uniforms&&this.material.uniforms.ghostMode&&(this.material.uniforms.ghostMode.value=e?1:0)}setBaseOpacity(e){this.material&&this.material.uniforms&&this.material.uniforms.baseOpacity&&(this.material.uniforms.baseOpacity.value=Math.max(0,Math.min(1,e)))}dispose(){if(this._disposed)return;this._disposed=!0;const e=this.mesh,t=this.material;e?.parent&&e.parent.remove(e),e&&(e.visible=!1),this.mesh=null,this.material=null,this.parentMesh=null,requestAnimationFrame(()=>{e?.geometry&&e.geometry.dispose(),t&&t.dispose()})}}class Rd{constructor(e=50,t={}){this.maxParticles=e,this.options=t,this.geometry=null,this.material=null,this.points=null,this.positions=null,this.sizes=null,this.colors=null,this.alphas=null,this.glowIntensities=null,this.depths=null,this.styles=null,this.particleCount=0,this.gestureEffects={firefly:!1,flicker:!1,shimmer:!1,glow:!1,time:0},this._initGeometry(),this._initMaterial(),this._initPoints()}_initGeometry(){this.geometry=new e.BufferGeometry;const{maxParticles:t}=this;this.positions=new Float32Array(3*t),this.sizes=new Float32Array(t),this.colors=new Float32Array(3*t),this.alphas=new Float32Array(t),this.glowIntensities=new Float32Array(t),this.depths=new Float32Array(t),this.styles=new Float32Array(t),this.geometry.setAttribute("position",new e.BufferAttribute(this.positions,3)),this.geometry.setAttribute("size",new e.BufferAttribute(this.sizes,1)),this.geometry.setAttribute("customColor",new e.BufferAttribute(this.colors,3)),this.geometry.setAttribute("alpha",new e.BufferAttribute(this.alphas,1)),this.geometry.setAttribute("glowIntensity",new e.BufferAttribute(this.glowIntensities,1)),this.geometry.setAttribute("depth",new e.BufferAttribute(this.depths,1)),this.geometry.setAttribute("style",new e.BufferAttribute(this.styles,1)),this.geometry.attributes.position.setUsage(e.DynamicDrawUsage),this.geometry.attributes.size.setUsage(e.DynamicDrawUsage),this.geometry.attributes.customColor.setUsage(e.DynamicDrawUsage),this.geometry.attributes.alpha.setUsage(e.DynamicDrawUsage),this.geometry.attributes.glowIntensity.setUsage(e.DynamicDrawUsage),this.geometry.attributes.depth.setUsage(e.DynamicDrawUsage),this.geometry.attributes.style.setUsage(e.DynamicDrawUsage),this.geometry.setDrawRange(0,0)}_initMaterial(){this.material=new e.ShaderMaterial({uniforms:{coreScale:{value:1},viewportHeight:{value:600},pixelRatio:{value:1}},vertexShader:"\n/**\n * Particle Vertex Shader - Simple 2D-style particles in 3D space\n * Matches the 2D canvas particle appearance\n */\n\n// Per-particle attributes\nattribute float size;\nattribute vec3 customColor;\nattribute float alpha;\nattribute float glowIntensity;\nattribute float style;  // 0.0 = solid/gradient, 1.0 = cell-shaded (ring with transparent center)\n\n// Uniforms\nuniform float coreScale;\nuniform float viewportHeight;\nuniform float pixelRatio;\n\n// Varying to fragment shader\nvarying vec3 vColor;\nvarying float vAlpha;\nvarying float vGlowIntensity;\nvarying float vStyle;\n\nvoid main() {\n    // Pass attributes to fragment shader\n    vColor = customColor;\n    vAlpha = alpha;\n    vGlowIntensity = glowIntensity;\n    vStyle = style;\n\n    // Calculate position in clip space\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n    // Calculate point size with perspective scaling\n    float perspectiveScale = coreScale * (75.0 / length(mvPosition.xyz)) * (viewportHeight / 600.0) / pixelRatio;\n    gl_PointSize = size * perspectiveScale;\n\n    // Final position\n    gl_Position = projectionMatrix * mvPosition;\n}\n",fragmentShader:"\n/**\n * Particle Fragment Shader - Solid colored circles matching 2D appearance\n * Uses premultiplied alpha for proper blending\n */\n\nvarying vec3 vColor;\nvarying float vAlpha;\nvarying float vGlowIntensity;\nvarying float vStyle;\n\nvoid main() {\n    // Distance from center (0 at center, 0.5 at edge)\n    vec2 center = gl_PointCoord - vec2(0.5);\n    float dist = length(center);\n\n    // Hard circle cutoff - discard everything outside\n    if (dist > 0.45) {\n        discard;\n    }\n\n    vec3 finalColor = vColor;\n\n    // Base opacity from particle (already includes baseOpacity variation)\n    float alpha = vAlpha;\n\n    // Gesture glow boost\n    if (vGlowIntensity >= 2.0) {\n        float gestureBoost = (vGlowIntensity - 2.0) / 13.0;\n        finalColor *= (1.0 + gestureBoost * 0.5);\n        alpha = min(alpha * (1.0 + gestureBoost * 0.3), 1.0);\n    }\n\n    // Cell-shaded particles are slightly more opaque\n    float opacityBoost = vStyle > 0.5 ? 1.0 : 0.85;\n    alpha *= opacityBoost;\n\n    // Output with proper alpha for blending\n    // Premultiply alpha for correct compositing\n    gl_FragColor = vec4(finalColor * alpha, alpha);\n}\n",transparent:!0,blending:e.CustomBlending,blendSrc:e.OneFactor,blendDst:e.OneMinusSrcAlphaFactor,blendSrcAlpha:e.OneFactor,blendDstAlpha:e.OneMinusSrcAlphaFactor,depthWrite:!1,depthTest:!0})}_initPoints(){this.points=new e.Points(this.geometry,this.material),this.points.frustumCulled=!0}updateParticles(e,t,i,a,n,s,r,o,l){this.particleCount=Math.min(e.length,this.maxParticles),void 0!==o&&(this.material.uniforms.coreScale.value=o),a&&a.height&&(this.material.uniforms.viewportHeight.value=a.height),this.options.renderer&&(this.material.uniforms.pixelRatio.value=this.options.renderer.getPixelRatio()),this.gestureEffects.time+=.016,this.gestureEffects.time>2*Math.PI&&(this.gestureEffects.time=this.gestureEffects.time%(2*Math.PI)),n&&s&&t.updateRotationState(n,s,r);for(let n=0;n<this.particleCount;n++){const s=e[n];if(!s.isAlive()){this.alphas[n]=0;continue}const r=t.translate2DTo3D(s,i,a);if(("crystal"===l||"heart"===l||"rough"===l)&&r.z>.15){this.alphas[n]=0;continue}const o=3*n;this.positions[o+0]=r.x,this.positions[o+1]=r.y,this.positions[o+2]=r.z;const c=s.getDepthAdjustedSize?s.getDepthAdjustedSize():s.size,h="popcorn"===s.behavior?1.2:.85;this.sizes[n]=c*h;const u=this._parseColor(s.color||"#ffffff"),d=3*n;this.colors[d+0]=u.r,this.colors[d+1]=u.g,this.colors[d+2]=u.b,this.alphas[n]=s.opacity*(s.baseOpacity||1);let m=s.hasGlow?1*(s.glowSizeMultiplier||1.5):0;m=this._applyGestureEffects(s,m,n),this.glowIntensities[n]=m;const p=.5*(1-s.z);this.depths[n]=Math.max(0,Math.min(1,p)),this.styles[n]=s.isCellShaded?1:0}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.size.needsUpdate=!0,this.geometry.attributes.customColor.needsUpdate=!0,this.geometry.attributes.alpha.needsUpdate=!0,this.geometry.attributes.glowIntensity.needsUpdate=!0,this.geometry.attributes.depth.needsUpdate=!0,this.geometry.attributes.style.needsUpdate=!0,this.geometry.setDrawRange(0,this.particleCount)}_applyGestureEffects(e,t,i){let a=t;if(this.gestureEffects.firefly){const t=(.01*e.x+.01*e.y+.1*e.size)%(2*Math.PI),i=2+.5*(Math.sin(3*this.gestureEffects.time+t)+1)*10;a=Math.max(a,i)}if(this.gestureEffects.flicker){const t=(.02*e.x+.02*e.y)%(2*Math.PI),n=15*this.gestureEffects.time,s=.5*(Math.sin(n+t)+1),r=Math.floor(10*n+i),o=2+10*(.3*s+.5*(Math.sin(123.456*r)+1)*.7);a=Math.max(a,o)}if(this.gestureEffects.shimmer){const t=e.x-(this.gestureEffects.centerX||0),i=e.y-(this.gestureEffects.centerY||0),n=Math.sqrt(t*t+i*i)/200,s=2+.5*(Math.sin(3*this.gestureEffects.time-n)+1)*8;a=Math.max(a,s)}if(this.gestureEffects.glow){const e=this.gestureEffects.glowProgress||0,t=3+12*Math.sin(e*Math.PI);a=Math.max(a,t)}return a}_parseColor(e){const t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t?{r:parseInt(t[1],16)/255,g:parseInt(t[2],16)/255,b:parseInt(t[3],16)/255}:{r:1,g:1,b:1}}setGestureEffects(e){if(!e)return this.gestureEffects.firefly=!1,this.gestureEffects.flicker=!1,this.gestureEffects.shimmer=!1,void(this.gestureEffects.glow=!1);this.gestureEffects.firefly=e.fireflyEffect||!1,this.gestureEffects.flicker=e.flickerEffect||!1,this.gestureEffects.shimmer=e.shimmerEffect||!1,this.gestureEffects.glow=e.glowEffect||!1,this.gestureEffects.glowProgress=e.glowProgress,this.gestureEffects.centerX=e.centerX,this.gestureEffects.centerY=e.centerY}getPoints(){return this.points}setVisible(e){this.points.visible=e}resize(e){e!==this.maxParticles&&(this.geometry&&this.geometry.dispose(),this.maxParticles=e,this._initGeometry(),this.points&&(this.points.geometry=this.geometry))}cleanupParticleStates(e){for(const t of e)!t.isAlive()&&t.behaviorData&&(t.behaviorData.direction3D&&(t.behaviorData.direction3D=null),t.behaviorData.orbitPlane&&(t.behaviorData.orbitPlane=null),t.behaviorData.orbitPath&&(t.behaviorData.orbitPath=null),t.behaviorData=null)}dispose(){this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose(),this.positions=null,this.sizes=null,this.colors=null,this.alphas=null,this.glowIntensities=null,this.depths=null,this.styles=null}}class Ed{constructor(){this.cachedConfigs=new Map,this.maxCacheSize=100}calculate(e,t=null){const i=`${e}:${t||"none"}`;if(this.cachedConfigs.has(i))return this.cachedConfigs.get(i);const a=Ii(e);if(!a)return console.warn(`[ParticleEmotionCalculator] Unknown emotion: ${e}`),this._getDefaultConfig();const n=this._extractBaseConfig(a,e),s=this._applyUndertoneModifiers(n,t),r=this._applySpecialBehaviors(s,e);if(this.cachedConfigs.size>=this.maxCacheSize){const e=this.cachedConfigs.keys().next().value;this.cachedConfigs.delete(e)}return this.cachedConfigs.set(i,r),r}_extractBaseConfig(e,t){const i=e.visual||{};return{behavior:i.particleBehavior||"ambient",rate:i.particleRate||1,min:void 0!==i.minParticles?i.minParticles:0,max:void 0!==i.maxParticles?i.maxParticles:10,colors:i.particleColors||null,emotion:t}}_applyUndertoneModifiers(e,t){if(!t)return e;const i=Ui(t);if(!i||!i.particles)return e;const a=i.particles,n={...e};return a.behaviorOverride&&(n.behavior=a.behaviorOverride),a.rateMultiplier&&(n.rate=e.rate*a.rateMultiplier,n.max=Math.floor(e.max*a.rateMultiplier)),void 0!==a.minParticles&&(n.min=a.minParticles),void 0!==a.maxParticles&&(n.max=a.maxParticles),n}_applySpecialBehaviors(e,t){return"zen"===t?{...e,specialBehavior:"zen-mixing"}:e}selectZenBehavior(){return Math.random()<.6?"falling":"orbiting"}_getDefaultConfig(){return{behavior:"ambient",rate:1,min:0,max:10,colors:null,emotion:"neutral"}}clearCache(){this.cachedConfigs.clear()}getCacheSize(){return this.cachedConfigs.size}}class Bd{constructor(){this.previousGesture=null}extract(e,t){if(!e||0===e.length)return this.previousGesture=null,null;const i=e[0],a=this._calculateProgress(i,t);if(a>=1)return this.previousGesture=null,null;const n=this._extractGestureName(i);if(!n)return null;const s=this._buildGestureMotion(i,n);return this.previousGesture=n,{motion:s,progress:a,config:i.config||{},gestureName:n,animation:i}}_calculateProgress(e,t){const i=(t-e.startTime)/e.duration;return Math.max(0,Math.min(1,i))}_extractGestureName(e){return e.gestureName||e.name||e.config?.gestureName||null}_buildGestureMotion(e,t){const i=e.config||{};return{type:t,amplitude:i.amplitude||1,strength:i.strength||1,wobbleAmount:i.wobbleAmount||0,duration:e.duration}}hasGestureChanged(e){return!(!e&&!this.previousGesture||(e||!this.previousGesture)&&(!e||this.previousGesture)&&e.gestureName===this.previousGesture)}extractAll(e,t){if(!e||0===e.length)return[];const i=[];for(const a of e){const e=this._calculateProgress(a,t);if(e>=1)continue;const n=this._extractGestureName(a);if(!n)continue;const s=this._buildGestureMotion(a,n);i.push({motion:s,progress:e,config:a.config||{},gestureName:n,animation:a})}return i}reset(){this.previousGesture=null}}class Fd{constructor(){this.effectMap={sparkle:this.buildFireflyEffect.bind(this),twinkle:this.buildFireflyEffect.bind(this),flicker:this.buildFlickerEffect.bind(this),shimmer:this.buildShimmerEffect.bind(this),glow:this.buildGlowEffect.bind(this),burst:this.buildGlowEffect.bind(this),flash:this.buildFlickerEffect.bind(this)}}build(e,t,i){if(!e||!e.motion)return null;const{gestureName:a}=e,n=this.effectMap[a];return n?n(e,t,i):null}buildFireflyEffect(e,t,i){const a=e.config||{};return{fireflyEffect:!0,fireflyTime:.001*Date.now(),particleGlow:a.particleGlow||2,centerX:t,centerY:i}}buildFlickerEffect(e,t,i){const a=e.config||{};return{flickerEffect:!0,flickerTime:.001*Date.now(),particleGlow:a.particleGlow||2,centerX:t,centerY:i}}buildShimmerEffect(e,t,i){const a=e.config||{},n=e.progress||0;return{shimmerEffect:!0,shimmerTime:.001*Date.now(),shimmerWave:n*Math.PI*2,particleGlow:a.particleGlow||1.2,centerX:t,centerY:i}}buildGlowEffect(e,t,i){const a=e.config||{};return{glowEffect:!0,glowProgress:e.progress||0,particleGlow:a.particleGlow||2,centerX:t,centerY:i}}registerEffect(e,t){this.effectMap[e]=t.bind(this)}hasEffect(e){return!!this.effectMap[e]}getEffectGestures(){return Object.keys(this.effectMap)}buildAll(e,t,i){if(!e||0===e.length)return[];const a=[];for(const n of e){const e=this.build(n,t,i);e&&a.push(e)}return a}mergeEffects(e){if(!e||0===e.length)return null;if(1===e.length)return e[0];const t={};for(const i of e)Object.assign(t,i);return t}destroy(){this.effectMap=null}}class zd{constructor(e,t,i){this.particleSystem=e,this.translator=t,this.renderer=i,this.emotionCalculator=new Ed,this.gestureExtractor=new Bd,this.effectsBuilder=new Fd,this.currentEmotion=null,this.currentUndertone=null,this.currentConfig=null}update(e,t,i,a,n,s,r,o,l,c){void 0!==c&&this.translator.setCoreRadius3D(c);const h=this._updateEmotionConfig(t,i),u=this.gestureExtractor.extract(a,n);this._spawnParticles(h,e,r),this._updatePhysics(h,u,e,r,i),this._updateRendering(u,s,r,o,e,l)}_updateEmotionConfig(e,t){return this.currentEmotion===e&&this.currentUndertone===t||(this.currentEmotion=e,this.currentUndertone=t,this.currentConfig=this.emotionCalculator.calculate(e,t),this.particleSystem.clear()),this.currentConfig}_spawnParticles(e,t,i){const a=i.width/2,n=i.height/2;let s=e.behavior;"zen-mixing"===e.specialBehavior&&(s=this.emotionCalculator.selectZenBehavior()),this.particleSystem.spawn(s,e.emotion,e.rate,a,n,t,null,e.min,e.max,1,1,e.colors,this.currentUndertone)}_updatePhysics(e,t,i,a,n){const s=a.width/2,r=a.height/2,o=n?{undertone:n}:null;this.particleSystem.update(i,s,r,t?t.motion:null,t?t.progress:0,o)}_updateRendering(e,t,i,a,n,s){const r=i.width/2,o=i.height/2,l=e?this.effectsBuilder.build(e,r,o):null;this.renderer.updateParticles(this.particleSystem.particles,this.translator,t,i,a,n,e,s,this.geometryType),this.renderer.setGestureEffects(l)}setEmotion(e,t=null){this.currentEmotion=null,this.currentUndertone=null}setGeometryType(e){this.geometryType=e}clear(){this.particleSystem.clear()}setEnabled(e){this.renderer.setVisible(e),e||this.clear()}getParticleCount(){return this.particleSystem.particles.length}getCurrentConfig(){return this.currentConfig}registerEffect(e,t){this.effectsBuilder.registerEffect(e,t)}destroy(){this.particleSystem.destroy(),this.renderer.dispose(),this.translator&&(this.translator.dispose?.(),this.translator=null),this.emotionCalculator.clearCache(),this.emotionCalculator=null,this.gestureExtractor.reset(),this.gestureExtractor=null,this.effectsBuilder&&(this.effectsBuilder.destroy?.(),this.effectsBuilder=null)}}const Ld={quartz:{sssStrength:.8,sssAbsorption:[2.8,2.9,3],sssScatterDistance:[.2,.2,.25],sssThicknessBias:.6,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.12,frostiness:.15,innerGlowStrength:.2,fresnelIntensity:1.5,causticIntensity:1.2},emerald:{sssStrength:2,sssAbsorption:[.05,4,.1],sssScatterDistance:[.1,.5,.1],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.2,innerGlowStrength:.15,fresnelIntensity:1.2,emotionColorBleed:.35},ruby:{sssStrength:1.8,sssAbsorption:[4,.03,.08],sssScatterDistance:[.4,.04,.08],sssThicknessBias:.65,sssThicknessScale:1.9,sssCurvatureScale:2.5,sssAmbient:.08,frostiness:.12,innerGlowStrength:.12,fresnelIntensity:1.2,causticIntensity:1.15,emotionColorBleed:.35},sapphire:{sssStrength:2.2,sssAbsorption:[.15,.4,4],sssScatterDistance:[.1,.15,.5],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.18,innerGlowStrength:.15,fresnelIntensity:1.3,emotionColorBleed:.35},amethyst:{sssStrength:2.5,sssAbsorption:[3,.05,4.5],sssScatterDistance:[.4,.05,.5],sssThicknessBias:.7,sssThicknessScale:2,sssCurvatureScale:3,sssAmbient:.08,frostiness:.18,innerGlowStrength:.12,fresnelIntensity:1.4,emotionColorBleed:.35}},Gd="\n// ═══════════════════════════════════════════════════════════════════════════\n// DEFORMATION UNIFORMS - Localized vertex displacement for impacts\n// ═══════════════════════════════════════════════════════════════════════════\nuniform float deformationStrength;  // 0-2+ (intensity of dent)\nuniform vec3 impactPoint;           // Impact position in MESH-LOCAL space\n                                    // Transformed by JS to account for camera direction\nuniform float deformationFalloff;   // Radius of influence (0.1-0.5 typical)\n",Vd={deformationStrength:0,impactPoint:[0,0,0],deformationFalloff:.5},Nd={crackImpact0:[0,0,0],crackImpact1:[0,0,0],crackImpact2:[0,0,0],crackDirection0:[0,0,0],crackDirection1:[0,0,0],crackDirection2:[0,0,0],crackParams0:[0,0,0],crackParams1:[0,0,0],crackParams2:[0,0,0],crackNumImpacts:0,crackColor:[.15,.08,.05],crackGlowColor:[1,.6,.2],crackGlowStrength:.5},jd=`\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n${Gd}\n\n\n// ═══════════════════════════════════════════════════════════════════════════\n// DEFORMATION - Localized dent toward mesh center\n// ═══════════════════════════════════════════════════════════════════════════\n\nvec3 calculateDeformation(vec3 pos) {\n    if (deformationStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Distance from this vertex to the impact point (both in mesh-local space)\n    float dist = length(pos - impactPoint);\n\n    // Falloff: 1.0 at impact point, 0.0 at falloff radius\n    // Use squared falloff for sharper edges\n    float t = dist / max(deformationFalloff, 0.001);\n    float falloff = max(0.0, 1.0 - t * t);\n\n    // Direction: push vertex INWARD toward mesh center\n    vec3 inward = -normalize(pos + vec3(0.0001));\n\n    // Depth of dent\n    float depth = deformationStrength * 0.15 * falloff;\n\n    return inward * depth;\n}\n\n\nvoid main() {\n    vUv = uv;\n\n    // Apply deformation to position (impactPoint pre-transformed by JS for tidal locking)\n    vec3 deformedPosition = position + calculateDeformation(position);\n\n    vPosition = deformedPosition;\n    vNormal = normalize(normalMatrix * normal);\n\n    vec4 mvPosition = modelViewMatrix * vec4(deformedPosition, 1.0);\n    vViewPosition = -mvPosition.xyz;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n`,qd=`\nuniform float time;\nuniform vec3 emotionColor;\nuniform float glowIntensity;\nuniform float opacity;\n\n// Crystal appearance controls\nuniform float frostiness;        // 0 = clear glass, 1 = fully frosted (default: 0.7)\nuniform float fresnelPower;      // Edge brightness falloff (default: 3.0)\nuniform float fresnelIntensity;  // Edge brightness strength (default: 1.2)\nuniform float innerGlowStrength; // How much inner soul shows through (default: 0.8)\nuniform float surfaceRoughness;  // Surface texture variation (default: 0.3)\n\n// Enhanced lighting controls\nuniform float shadowDarkness;     // How dark shadows can get (0-1, default: 0.4)\nuniform float specularIntensity;  // Edge highlight brightness (default: 0.8)\nuniform float specularPower;      // Specular falloff sharpness (default: 32.0)\nuniform float transmissionContrast; // Thin/thick brightness ratio (default: 1.5)\nuniform float minBrightness;      // Minimum brightness floor (default: 0.05)\n\n// Noise scale controls\nuniform float surfaceNoiseScale;  // Scale of surface frost pattern (default: 1.5)\nuniform float noiseFrequency;     // Frequency of hash noise pattern (default: 1.0)\n\n// Internal caustics - light pooling inside the gem\nuniform float causticIntensity;   // Brightness of internal caustics (default: 0.4)\nuniform float causticScale;       // Scale of caustic pattern (default: 3.0)\nuniform float causticSpeed;       // Animation speed of caustics (default: 0.15)\n\n// Texture\nuniform sampler2D crystalTexture;\nuniform float textureStrength;    // How much texture affects appearance (default: 0.5)\n\n// Soul refraction - samples soul rendered to texture with optical distortion\nuniform sampler2D soulTexture;    // Soul mesh rendered to texture\nuniform vec2 resolution;          // Screen resolution for UV calculation\nuniform vec2 soulTextureSize;     // Soul render target size (may differ from screen)\nuniform vec2 soulScreenCenter;    // Soul center projected to screen UV (0-1 range)\nuniform float refractionIndex;    // Index of refraction (1.5 glass, 2.4 diamond)\nuniform float refractionStrength; // Distortion magnitude (0.1-0.5)\n\n// Physically-based subsurface scattering\nuniform float sssStrength;            // Overall SSS intensity (0-1)\nuniform vec3 sssAbsorption;           // Absorption coefficients per RGB channel\nuniform vec3 sssScatterDistance;      // Mean free path / scatter radius per RGB\nuniform float sssThicknessBias;       // Thickness offset (0-1)\nuniform float sssThicknessScale;      // Thickness multiplier\nuniform float sssCurvatureScale;      // How much curvature affects SSS\nuniform float sssAmbient;             // Ambient SSS contribution\nuniform vec3 sssLightDir;             // Primary light direction for SSS\nuniform vec3 sssLightColor;           // Light color for SSS\n\n// Emotion color bleed - how much soul color tints the gem material\nuniform float emotionColorBleed;      // 0 = gem color only, 1 = full emotion tint (default: 0.0)\n\n// Component-specific blend layers\n// Shell layers - affect the frosted crystal shell\nuniform float shellLayer1Mode;\nuniform float shellLayer1Strength;\nuniform float shellLayer1Enabled;\nuniform float shellLayer2Mode;\nuniform float shellLayer2Strength;\nuniform float shellLayer2Enabled;\n\n// Soul layers - affect the inner glowing soul color\nuniform float soulLayer1Mode;\nuniform float soulLayer1Strength;\nuniform float soulLayer1Enabled;\nuniform float soulLayer2Mode;\nuniform float soulLayer2Strength;\nuniform float soulLayer2Enabled;\n\n// Rim layers - affect the fresnel rim glow\nuniform float rimLayer1Mode;\nuniform float rimLayer1Strength;\nuniform float rimLayer1Enabled;\nuniform float rimLayer2Mode;\nuniform float rimLayer2Strength;\nuniform float rimLayer2Enabled;\n\n// SSS layers - affect subsurface scattering contribution\nuniform float sssLayer1Mode;\nuniform float sssLayer1Strength;\nuniform float sssLayer1Enabled;\nuniform float sssLayer2Mode;\nuniform float sssLayer2Strength;\nuniform float sssLayer2Enabled;\n\n${Gd}\n\n\n// ═══════════════════════════════════════════════════════════════════════════\n// OBJECT-SPACE CRACK UNIFORMS - Persistent damage that rotates with mesh\n// ═══════════════════════════════════════════════════════════════════════════\n\n// Impact positions in MESH-LOCAL space (pre-transformed by JS)\nuniform vec3 crackImpact0;\nuniform vec3 crackImpact1;\nuniform vec3 crackImpact2;\n\n// Impact directions in MESH-LOCAL space (crack spread direction)\nuniform vec3 crackDirection0;\nuniform vec3 crackDirection1;\nuniform vec3 crackDirection2;\n\n// Impact parameters: x=propagation, y=amount, z=seed\nuniform vec3 crackParams0;\nuniform vec3 crackParams1;\nuniform vec3 crackParams2;\n\n// Number of active impacts (0-3)\nuniform int crackNumImpacts;\n\n// Visual parameters\nuniform vec3 crackColor;       // Dark crack interior color\nuniform vec3 crackGlowColor;   // Edge emission color\nuniform float crackGlowStrength;\n\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec2 vUv;\n\n// ═══════════════════════════════════════════════════════════════════════════\n// NOISE FUNCTIONS for surface variation and frosted effect\n// ═══════════════════════════════════════════════════════════════════════════\n\n// Simple 3D noise for frosted surface\nfloat hash(vec3 p) {\n    p = p * noiseFrequency;  // Apply frequency control\n    p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat noise3D(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // Smoothstep\n\n    float n = mix(\n        mix(\n            mix(hash(i), hash(i + vec3(1, 0, 0)), f.x),\n            mix(hash(i + vec3(0, 1, 0)), hash(i + vec3(1, 1, 0)), f.x),\n            f.y\n        ),\n        mix(\n            mix(hash(i + vec3(0, 0, 1)), hash(i + vec3(1, 0, 1)), f.x),\n            mix(hash(i + vec3(0, 1, 1)), hash(i + vec3(1, 1, 1)), f.x),\n            f.y\n        ),\n        f.z\n    );\n    return n;\n}\n\n// Fractal Brownian Motion for natural-looking frosted texture\nfloat fbm(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 3; i++) {\n        value += amplitude * noise3D(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// ═══════════════════════════════════════════════════════════════════════════\n// BLEND MODES (from universal library)\n// ═══════════════════════════════════════════════════════════════════════════\n${jt}\n\n// ═══════════════════════════════════════════════════════════════════════════\n// ENHANCED LIGHTING FUNCTIONS\n// ═══════════════════════════════════════════════════════════════════════════\n\n// Calculate ambient occlusion from geometry\nfloat calculateAO(vec3 normal, vec3 viewDir, vec3 position) {\n    // Faces pointing away from view are in shadow\n    float viewAO = max(0.0, dot(normal, viewDir));\n\n    // Use light direction for directional shadow instead of gravity\n    // This creates shadows on the side away from light\n    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.8)); // Match sssLightDir default\n    float lightAO = dot(normal, lightDir) * 0.5 + 0.5;\n\n    // Combine AO factors - no gravity term\n    return viewAO * 0.5 + lightAO * 0.5;\n}\n\n// Calculate specular highlights on facet edges\nfloat calculateFacetSpecular(vec3 normal, vec3 viewDir, vec3 lightDir, float power) {\n    // Detect facet edges from normal discontinuities\n    float edgeDetect = length(fwidth(normal)) * 15.0;\n    edgeDetect = smoothstep(0.1, 0.5, edgeDetect);\n\n    // Standard Blinn-Phong specular\n    vec3 halfVec = normalize(lightDir + viewDir);\n    float specular = pow(max(0.0, dot(normal, halfVec)), power);\n\n    // Boost specular on edges\n    specular += edgeDetect * 0.5;\n\n    return specular;\n}\n\n// Calculate "fire" - intense sparkle points that real gems exhibit\n// These are concentrated, view-dependent highlights from light dispersion\nfloat calculateFire(vec3 normal, vec3 viewDir, vec3 lightDir) {\n    // Primary fire highlight - VERY sharp falloff for pinpoint sparkles\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float fire1 = pow(max(0.0, dot(reflectDir, viewDir)), 512.0);\n\n    // Secondary fire from different light angle (simulates environment)\n    vec3 lightDir2 = normalize(vec3(-0.3, 0.8, 0.5));\n    vec3 reflectDir2 = reflect(-lightDir2, normal);\n    float fire2 = pow(max(0.0, dot(reflectDir2, viewDir)), 384.0);\n\n    // Third fire point for more sparkle\n    vec3 lightDir3 = normalize(vec3(0.7, 0.4, -0.6));\n    vec3 reflectDir3 = reflect(-lightDir3, normal);\n    float fire3 = pow(max(0.0, dot(reflectDir3, viewDir)), 256.0);\n\n    // Combine fire points - only keep the brightest peaks\n    float fire = fire1 + fire2 * 0.7 + fire3 * 0.5;\n\n    // Facet edges catch more fire\n    float edgeFactor = length(fwidth(normal)) * 20.0;\n    fire *= (1.0 + edgeFactor * 2.0);\n\n    return fire;\n}\n\n// Calculate bright lines along facet edges where bevels catch light\nfloat calculateFacetEdgeLines(vec3 normal, vec3 viewDir, vec3 lightDir) {\n    // Detect edges from normal discontinuities\n    float edgeMag = length(fwidth(normal));\n\n    // Sharp threshold to create distinct lines\n    float edgeLine = smoothstep(0.02, 0.08, edgeMag);\n\n    // Modulate by light angle - edges facing light are brighter\n    float lightFacing = max(0.0, dot(normal, lightDir));\n    edgeLine *= (0.3 + lightFacing * 0.7);\n\n    // View-dependent - edges perpendicular to view are more visible\n    float viewPerp = 1.0 - abs(dot(normal, viewDir));\n    edgeLine *= (0.5 + viewPerp * 0.5);\n\n    return edgeLine;\n}\n\n// Calculate light transmission based on thickness\nfloat calculateTransmission(vec3 position, vec3 normal, vec3 viewDir, float contrast) {\n    // Thickness estimation - edges are thin, center is thick\n    float distFromCenter = length(position);\n    float thickness = smoothstep(0.0, 0.6, distFromCenter);\n\n    // View angle affects perceived thickness\n    float viewThickness = 1.0 - abs(dot(normal, viewDir));\n    thickness = mix(thickness, viewThickness, 0.5);\n\n    // Thin areas transmit more light (brighter), thick areas are darker\n    float transmission = 1.0 - thickness * contrast * 0.5;\n\n    return clamp(transmission, 0.3, 1.5);\n}\n\n// ═══════════════════════════════════════════════════════════════════════════\n// PHYSICALLY-BASED SUBSURFACE SCATTERING\n// ═══════════════════════════════════════════════════════════════════════════\n\n// ═══════════════════════════════════════════════════════════════════════════\n// PHYSICALLY-BASED SUBSURFACE SCATTERING\n// Based on Disney's Burley Normalized Diffusion (2015)\n// ═══════════════════════════════════════════════════════════════════════════\n\n// SSS Uniforms - declare these in your shader\n// uniform float sssStrength;           // Overall SSS intensity (0-1)\n// uniform vec3 sssAbsorption;          // Absorption coefficients per RGB channel\n// uniform vec3 sssScatterDistance;     // Mean free path / scatter radius per RGB\n// uniform float sssThicknessBias;      // Thickness offset (0-1)\n// uniform float sssThicknessScale;     // Thickness multiplier\n// uniform float sssCurvatureScale;     // How much curvature affects SSS\n// uniform float sssAmbient;            // Ambient SSS contribution\n// uniform vec3 sssLightDir;            // Primary light direction for SSS\n// uniform vec3 sssLightColor;          // Light color for SSS\n\n/**\n * Estimate local thickness from geometry\n * Uses the relationship between view angle and surface normal\n * Combined with a simple depth approximation\n *\n * @param normal - Surface normal in view space\n * @param viewDir - View direction\n * @param position - Vertex position (for depth-based estimation)\n * @param thicknessBias - Base thickness value\n * @param thicknessScale - Thickness multiplier\n * @return Estimated thickness (0-1)\n */\nfloat estimateThickness(vec3 normal, vec3 viewDir, vec3 position, float thicknessBias, float thicknessScale) {\n    // Method 1: View-dependent thickness\n    // Surfaces facing away from viewer are "thicker" (light travels further)\n    float viewThickness = 1.0 - abs(dot(normal, viewDir));\n\n    // Method 2: Position-based depth (simple spherical assumption)\n    // Objects are thinner at edges, thicker in center\n    float posDepth = 1.0 - length(position) * 0.5;\n    posDepth = clamp(posDepth, 0.0, 1.0);\n\n    // Method 3: Curvature hint from normal variation\n    // High-frequency normal changes indicate thin areas (edges, details)\n    // This is approximated by the gradient of the normal\n    float curvatureHint = length(fwidth(normal)) * 10.0;\n    curvatureHint = 1.0 - clamp(curvatureHint, 0.0, 1.0);\n\n    // Combine methods with weighting\n    float thickness = viewThickness * 0.4 + posDepth * 0.4 + curvatureHint * 0.2;\n\n    // Apply bias and scale\n    thickness = thicknessBias + thickness * thicknessScale;\n\n    return clamp(thickness, 0.01, 1.0);\n}\n\n/**\n * Beer's Law absorption - light attenuates exponentially through material\n * Different wavelengths absorb at different rates, creating color shifts\n *\n * @param thickness - Distance light travels through material\n * @param absorption - Absorption coefficients per RGB (higher = more absorbed)\n * @return Transmittance per RGB channel (0-1)\n */\nvec3 beersLawAbsorption(float thickness, vec3 absorption) {\n    // Beer-Lambert Law: T = e^(-σ * d)\n    // Where σ is absorption coefficient, d is distance\n    return exp(-absorption * thickness * 4.0);\n}\n\n/**\n * Burley Normalized Diffusion Profile\n * Disney's approximation of the full BSSRDF, energy-conserving\n *\n * R(r) = A * s * (e^(-s*r) + e^(-s*r/3)) / (8πr)\n *\n * @param radius - Distance from entry point (normalized)\n * @param scatterDist - Mean free path / diffusion length\n * @return Diffusion weight at this radius\n */\nfloat burleyDiffusionProfile(float radius, float scatterDist) {\n    // Prevent division by zero\n    float r = max(radius, 0.001);\n    float s = 1.0 / max(scatterDist, 0.001);\n\n    // Burley's two-term approximation\n    float term1 = exp(-s * r);\n    float term2 = exp(-s * r / 3.0);\n\n    // Normalized profile (simplified, without 8πr for real-time)\n    float profile = (term1 + term2) * s * 0.25;\n\n    return profile;\n}\n\n/**\n * Christensen-Burley Normalized Diffusion\n * Improved version with better energy conservation\n *\n * @param radius - Distance from entry point\n * @param A - Surface albedo\n * @param d - Diffusion length (mean free path)\n * @return RGB diffusion weights\n */\nvec3 christensenBurleyDiffusion(float radius, vec3 A, vec3 d) {\n    vec3 result = vec3(0.0);\n\n    // Per-channel diffusion (different scatter distances for RGB)\n    for (int i = 0; i < 3; i++) {\n        float s = 1.9 - A[i] + 3.5 * (A[i] - 0.8) * (A[i] - 0.8);\n        s = 1.0 / (s * max(d[i], 0.001));\n\n        float r = max(radius, 0.001);\n\n        // Two-exponential fit\n        float profile = s * (exp(-s * r) + exp(-s * r / 3.0)) / (8.0 * 3.14159 * r);\n\n        result[i] = profile;\n    }\n\n    return result;\n}\n\n/**\n * Calculate curvature factor for SSS intensity\n * SSS is more visible on curved surfaces (fingers, ears, edges)\n *\n * @param normal - Surface normal\n * @return Curvature factor (higher = more curved)\n */\nfloat calculateCurvature(vec3 normal) {\n    // Use screen-space derivatives to estimate curvature\n    vec3 dx = dFdx(normal);\n    vec3 dy = dFdy(normal);\n\n    // Curvature magnitude\n    float curvature = length(dx) + length(dy);\n\n    // Normalize to useful range\n    return clamp(curvature * 5.0, 0.0, 1.0);\n}\n\n/**\n * Full physically-based SSS calculation\n * Combines all components for realistic translucent materials\n *\n * @param normal - Surface normal (view space)\n * @param viewDir - View direction\n * @param position - Vertex position\n * @param lightDir - Light direction\n * @param lightColor - Light color\n * @param baseColor - Material base/albedo color\n * @param sssStrength - Overall SSS strength\n * @param absorption - Absorption coefficients RGB (inverted: higher = MORE of that color)\n * @param scatterDist - Scatter distance RGB (higher = more scatter)\n * @param thicknessBias - Base thickness\n * @param thicknessScale - Thickness multiplier\n * @param curvatureScale - Curvature influence\n * @param ambient - Ambient SSS contribution\n * @return Final SSS color contribution\n */\nvec3 calculatePhysicalSSS(\n    vec3 normal,\n    vec3 viewDir,\n    vec3 position,\n    vec3 lightDir,\n    vec3 lightColor,\n    vec3 baseColor,\n    float sssStrength,\n    vec3 absorption,\n    vec3 scatterDist,\n    float thicknessBias,\n    float thicknessScale,\n    float curvatureScale,\n    float ambient\n) {\n    if (sssStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // ─────────────────────────────────────────────────────────────────────\n    // THICKNESS ESTIMATION\n    // ─────────────────────────────────────────────────────────────────────\n    float thickness = estimateThickness(normal, viewDir, position, thicknessBias, thicknessScale);\n\n    // ─────────────────────────────────────────────────────────────────────\n    // ABSORPTION COLOR (Beer's Law with artist-friendly values)\n    // Creates the characteristic color of translucent materials\n    // absorption values: high value = MORE of that color passes through (transmitted)\n    // This is inverted from physics but intuitive: jade has high green absorption\n    // ─────────────────────────────────────────────────────────────────────\n    // Use absorption directly as transmittance - higher = more of that color shows\n    // Normalize to prevent any channel from dominating\n    float maxAbsorption = max(absorption.r, max(absorption.g, absorption.b));\n    vec3 normalizedTransmit = absorption / max(maxAbsorption, 0.001);\n\n    // Apply thickness-based falloff - thin areas show more color\n    float thicknessFactor = 1.0 - thickness * 0.3;\n    vec3 colorShift = normalizedTransmit * thicknessFactor;\n\n    // Ensure minimum color presence\n    colorShift = max(colorShift, vec3(0.15));\n\n    // ─────────────────────────────────────────────────────────────────────\n    // SCATTER INTENSITY\n    // How much light scatters based on material properties\n    // ─────────────────────────────────────────────────────────────────────\n    // Higher scatter distance = more light gets through, but keep it subtle\n    vec3 scatterIntensity = scatterDist * 0.8;\n    scatterIntensity = clamp(scatterIntensity, vec3(0.1), vec3(1.0));\n\n    // ─────────────────────────────────────────────────────────────────────\n    // LIGHTING TERMS - Boosted for visibility\n    // ─────────────────────────────────────────────────────────────────────\n\n    // Back-lighting: light passing through from behind (strongest SSS cue)\n    float NdotL = dot(normal, lightDir);\n    float backLight = max(0.0, -NdotL);\n    backLight = pow(backLight, 1.2) * 1.5;  // Boosted\n\n    // Wrap lighting: soft diffuse that wraps around\n    float wrapLight = (NdotL + 1.0) * 0.5;  // Full wrap, 0-1 range\n    wrapLight = wrapLight * wrapLight;\n\n    // View-dependent translucency (looking through thin parts)\n    float VdotL = dot(viewDir, -lightDir);\n    float translucency = pow(max(0.0, VdotL), 1.5) * 1.2;  // Boosted\n\n    // Edge glow (fresnel-like SSS at silhouettes)\n    float edgeGlow = pow(1.0 - abs(dot(normal, viewDir)), 2.0);\n\n    // ─────────────────────────────────────────────────────────────────────\n    // THICKNESS-BASED TRANSMISSION\n    // Thin areas let more light through\n    // ─────────────────────────────────────────────────────────────────────\n    float thinTransmission = 1.0 - thickness * 0.5;\n    thinTransmission = max(thinTransmission, 0.3);\n\n    // ─────────────────────────────────────────────────────────────────────\n    // CURVATURE ENHANCEMENT\n    // ─────────────────────────────────────────────────────────────────────\n    float curvature = calculateCurvature(normal);\n    float curvatureFactor = 1.0 + curvature * curvatureScale;\n\n    // ─────────────────────────────────────────────────────────────────────\n    // COMBINE ALL TERMS\n    // ─────────────────────────────────────────────────────────────────────\n\n    // Total light contribution (more additive for visibility)\n    float totalLight = backLight + translucency * 0.8 + wrapLight * 0.4 + edgeGlow * 0.5;\n    totalLight *= curvatureFactor * thinTransmission;\n\n    // Base SSS color - colorShift IS the tint (e.g., green for jade)\n    // Don't multiply by baseColor to avoid washing out with emotionColor\n    vec3 sssColor = colorShift * scatterIntensity;\n\n    // Ambient SSS (always visible, gives material its translucent look)\n    vec3 ambientSSS = sssColor * ambient;\n\n    // Direct SSS from lighting - subtle contribution\n    vec3 directSSS = sssColor * lightColor * totalLight * 0.5;\n\n    // Final combination\n    vec3 finalSSS = directSSS + ambientSSS;\n\n    // Apply overall strength (linear, no boost to prevent blowout)\n    return finalSSS * sssStrength;\n}\n\n/**\n * Simplified SSS for performance-critical scenarios\n * Uses pre-computed approximations\n *\n * @param normal - Surface normal\n * @param viewDir - View direction\n * @param lightDir - Light direction\n * @param thickness - Pre-computed or approximated thickness\n * @param baseColor - Material color\n * @param scatterColor - Scatter tint color\n * @param strength - SSS strength\n * @return SSS color contribution\n */\nvec3 calculateSimpleSSS(\n    vec3 normal,\n    vec3 viewDir,\n    vec3 lightDir,\n    float thickness,\n    vec3 baseColor,\n    vec3 scatterColor,\n    float strength\n) {\n    if (strength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Back-lighting\n    float backLight = pow(max(0.0, dot(viewDir, -lightDir)), 2.0);\n\n    // Transmittance (simplified Beer's law)\n    float transmit = exp(-thickness * 2.0);\n\n    // Edge enhancement\n    float edge = pow(1.0 - abs(dot(normal, viewDir)), 2.0);\n\n    // Combine\n    float sssIntensity = (backLight * transmit + edge * 0.3) * strength;\n\n    return mix(baseColor, scatterColor, 0.5) * sssIntensity;\n}\n\n\n// ═══════════════════════════════════════════════════════════════════════════\n// DEFORMATION IMPACT GLOW\n// ═══════════════════════════════════════════════════════════════════════════\n\n// ═══════════════════════════════════════════════════════════════════════════\n// IMPACT GLOW - Localized bright spot at punch impact site\n// ═══════════════════════════════════════════════════════════════════════════\n\nvec3 calculateImpactGlow(vec3 fragPos, vec3 emotionColor) {\n    if (deformationStrength < 0.001) {\n        return vec3(0.0);\n    }\n\n    // Distance from this fragment to the impact point (both in mesh-local space)\n    float impactDist = length(fragPos - impactPoint);\n    float impactT = impactDist / max(deformationFalloff, 0.001);\n    float impactFalloff = max(0.0, 1.0 - impactT * impactT);\n\n    // Bright glow at impact site\n    vec3 impactColor = mix(emotionColor, vec3(1.0), impactFalloff * 0.7);\n\n    return impactColor * impactFalloff * 1.5;\n}\n\n\n// ═══════════════════════════════════════════════════════════════════════════\n// OBJECT-SPACE CRACK FUNCTIONS\n// ═══════════════════════════════════════════════════════════════════════════\n\n// ═══════════════════════════════════════════════════════════════════════════\n// OBJECT-SPACE CRACK FUNCTIONS\n// ═══════════════════════════════════════════════════════════════════════════\n\n// Hash functions for procedural patterns\nfloat crackHash(vec3 p) {\n    p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec2 crackHash2(vec2 p) {\n    return vec2(\n        fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453),\n        fract(sin(dot(p, vec2(269.5, 183.3))) * 43758.5453)\n    );\n}\n\nfloat crackNoise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = mix(\n        mix(\n            mix(crackHash(i), crackHash(i + vec3(1, 0, 0)), f.x),\n            mix(crackHash(i + vec3(0, 1, 0)), crackHash(i + vec3(1, 1, 0)), f.x),\n            f.y\n        ),\n        mix(\n            mix(crackHash(i + vec3(0, 0, 1)), crackHash(i + vec3(1, 0, 1)), f.x),\n            mix(crackHash(i + vec3(0, 1, 1)), crackHash(i + vec3(1, 1, 1)), f.x),\n            f.y\n        ),\n        f.z\n    );\n    return n;\n}\n\n// Voronoi edge detection for crack patterns\nfloat crackVoronoiEdge(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float minDist = 1.0;\n    float secondDist = 1.0;\n\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 cellPoint = neighbor + crackHash2(i + neighbor) * 0.8;\n            float dist = length(f - cellPoint);\n            if (dist < minDist) {\n                secondDist = minDist;\n                minDist = dist;\n            } else if (dist < secondDist) {\n                secondDist = dist;\n            }\n        }\n    }\n    return secondDist - minDist;\n}\n\n// Generate crack pattern for a single impact in object space\n// Returns 0.0 where crack lines are, 1.0 where no cracks\nfloat singleObjectSpaceCrack(vec3 fragPos, vec3 impactPos, vec3 direction, float propagation, float seed) {\n    vec3 toFrag = fragPos - impactPos;\n    float distFromImpact = length(toFrag);\n\n    // Max spread radius - cover entire crystal mesh\n    // Crystal vertex positions: radius ~0.7, height -1.5 to +1.5\n    // Use very large radius to ensure visibility\n    float maxRadius = propagation * 3.0;\n\n    // Outside propagation radius = no crack (return 1.0)\n    if (distFromImpact > maxRadius) {\n        return 1.0;\n    }\n\n    // Normalized distance for falloff (0 at impact, 1 at edge)\n    float normalizedDist = distFromImpact / max(maxRadius, 0.001);\n\n    // Simple radial crack pattern - spoke lines radiating from impact\n    vec3 radialDir = normalize(toFrag + vec3(0.0001));\n    float angle = atan(radialDir.y, radialDir.x) + atan(radialDir.z, radialDir.x) * 0.5;\n\n    // Create spoke lines - we want lines where angle is near multiples of (2*PI/numSpokes)\n    float numSpokes = 8.0;\n    float spokeAngle = angle * numSpokes;\n    // spokeLine is low (near 0) at crack lines, high (near 1) between them\n    float spokeLine = abs(sin(spokeAngle + seed * 0.1));\n\n    // Concentric rings for "shattered glass" look\n    float ringFreq = 6.0;\n    float rings = abs(sin(distFromImpact * ringFreq + seed));\n\n    // Combine spokes and rings - crack where either is low\n    float pattern = min(spokeLine, rings);\n\n    // Fade crack intensity at edges of propagation radius\n    float edgeFade = 1.0 - smoothstep(0.7, 1.0, normalizedDist);\n\n    // Return the raw pattern value (0 = crack line, 1 = no crack)\n    // Modulated by edge fade\n    return mix(1.0, pattern, edgeFade);\n}\n\n// Calculate all object-space cracks\n// Returns vec4: rgb = crack/glow color, a = crack alpha (blend factor)\nvec4 calculateObjectSpaceCracks(vec3 fragPos, vec3 normal) {\n    if (crackNumImpacts == 0) {\n        return vec4(0.0);\n    }\n\n    float combinedCrack = 1.0;\n    float maxAmount = 0.0;\n\n    // Impact 0\n    if (crackNumImpacts >= 1 && crackParams0.y > 0.01) {\n        float crack0 = singleObjectSpaceCrack(fragPos, crackImpact0, crackDirection0, crackParams0.x, crackParams0.z);\n        combinedCrack = min(combinedCrack, crack0);\n        maxAmount = max(maxAmount, crackParams0.y);\n    }\n\n    // Impact 1\n    if (crackNumImpacts >= 2 && crackParams1.y > 0.01) {\n        float crack1 = singleObjectSpaceCrack(fragPos, crackImpact1, crackDirection1, crackParams1.x, crackParams1.z);\n        combinedCrack = min(combinedCrack, crack1);\n        maxAmount = max(maxAmount, crackParams1.y);\n    }\n\n    // Impact 2\n    if (crackNumImpacts >= 3 && crackParams2.y > 0.01) {\n        float crack2 = singleObjectSpaceCrack(fragPos, crackImpact2, crackDirection2, crackParams2.x, crackParams2.z);\n        combinedCrack = min(combinedCrack, crack2);\n        maxAmount = max(maxAmount, crackParams2.y);\n    }\n\n    // combinedCrack: 0.0 = crack line, 1.0 = no crack\n    // Convert to crack visibility (invert and threshold)\n    float crackThickness = 0.3;  // Threshold for what counts as a crack line\n    float crackLine = 1.0 - smoothstep(0.0, crackThickness, combinedCrack);\n\n    // Edge glow around cracks\n    float glowWidth = 0.5;\n    float edgeGlow = 1.0 - smoothstep(crackThickness, crackThickness + glowWidth, combinedCrack);\n    edgeGlow = max(0.0, edgeGlow - crackLine);  // Remove overlap with crack line\n    edgeGlow *= edgeGlow;  // Softer falloff\n\n    // Apply amount (intensity control)\n    crackLine *= maxAmount;\n    edgeGlow *= maxAmount * crackGlowStrength;\n\n    // Final color composition\n    // Dark crack interior (nearly black)\n    vec3 crackInterior = crackColor * 0.2;\n    // Bright glow at edges\n    vec3 glowContrib = crackGlowColor * edgeGlow * 2.0;\n\n    vec3 color = crackInterior * crackLine + glowContrib;\n    float alpha = crackLine * 0.95 + edgeGlow * 0.6;\n\n    return vec4(color, alpha);\n}\n\n\nvoid main() {\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewPosition);\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // FRESNEL EFFECT - Colored rim at edges (cyan-tinted)\n    // ═══════════════════════════════════════════════════════════════════════\n    float fresnel = pow(1.0 - abs(dot(normal, viewDir)), fresnelPower);\n    fresnel *= fresnelIntensity;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // AMBIENT OCCLUSION - Dark shadows for depth\n    // ═══════════════════════════════════════════════════════════════════════\n    float ao = calculateAO(normal, viewDir, vPosition);\n    float shadowFactor = mix(1.0, ao, shadowDarkness);\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // SPECULAR HIGHLIGHTS - Bright catches on facet edges\n    // ═══════════════════════════════════════════════════════════════════════\n    vec3 lightDir = normalize(sssLightDir);\n    float specular = calculateFacetSpecular(normal, viewDir, lightDir, specularPower);\n    specular *= specularIntensity;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // LIGHT TRANSMISSION - Thin areas glow, thick areas darken\n    // ═══════════════════════════════════════════════════════════════════════\n    float transmission = calculateTransmission(vPosition, normal, viewDir, transmissionContrast);\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // TEXTURE SAMPLING - Crystal surface detail from UV-mapped texture\n    // ═══════════════════════════════════════════════════════════════════════\n    vec4 texColor = texture2D(crystalTexture, vUv);\n    float texValue = (texColor.r + texColor.g + texColor.b) / 3.0;  // Grayscale\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // FROSTED SURFACE - Subtle cloudy variation (not opaque white!)\n    // ═══════════════════════════════════════════════════════════════════════\n    float surfaceNoise = fbm(vPosition * surfaceNoiseScale + time * 0.02);\n    surfaceNoise = surfaceNoise * surfaceRoughness;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // INNER SOUL GLOW - The glowing core visible through the crystal\n    // ═══════════════════════════════════════════════════════════════════════\n\n    // Animated internal glow - subtle pulsing\n    float glowPulse = sin(time * 0.5) * 0.15 + 0.85;\n\n    // Core glow - strongest in center, fades toward edges with sharper falloff\n    float distFromCenter = length(vPosition);\n    float coreGlow = exp(-distFromCenter * 2.5) * glowPulse;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // INTERNAL CAUSTICS - Light refraction pools inside the gem\n    // Creates bright concentrated spots that shift with viewing angle\n    // Real caustics form where refracted light rays converge inside the gem\n    // Now with CHROMATIC ABERRATION - different wavelengths refract differently\n    // ═══════════════════════════════════════════════════════════════════════\n\n    // Refract view direction through gem surface with different IOR per wavelength\n    // Red refracts less (higher IOR ratio), blue refracts more (lower IOR ratio)\n    // Chromatic separation is REDUCED for colored gems to avoid color contamination\n    // Quartz (low sssStrength) gets full rainbow, colored gems get subtle dispersion\n    float chromaticStrength = 1.0 - clamp((sssStrength - 0.5) * 0.8, 0.0, 0.8);\n    float iorR = mix(0.57, 0.70, chromaticStrength); // Red - approaches green for colored gems\n    float iorB = mix(0.57, 0.44, chromaticStrength); // Blue - approaches green for colored gems\n    vec3 refractDirR = refract(-viewDir, normal, iorR);\n    vec3 refractDirG = refract(-viewDir, normal, 0.57); // Green - always medium\n    vec3 refractDirB = refract(-viewDir, normal, iorB);\n\n    // Animated drift\n    float causticTime = time * causticSpeed;\n    vec3 drift = vec3(causticTime * 0.3, causticTime * 0.2, causticTime * 0.1);\n\n    // Sample positions for each color channel\n    // Offset is also reduced for colored gems to minimize chromatic contamination\n    float spatialOffset = mix(1.0, 3.0, chromaticStrength);\n    vec3 causticPosR = vPosition * causticScale + refractDirR * spatialOffset + drift;\n    vec3 causticPosG = vPosition * causticScale + refractDirG * spatialOffset + drift;\n    vec3 causticPosB = vPosition * causticScale + refractDirB * spatialOffset + drift;\n\n    // Create caustic pattern for each channel\n    // Red channel\n    float waveR1 = sin(causticPosR.x * 2.0 + causticPosR.y * 1.5 + causticPosR.z);\n    float waveR2 = sin(causticPosR.y * 2.3 - causticPosR.x * 1.2 + causticPosR.z * 1.8);\n    float waveR3 = sin(causticPosR.z * 1.9 + causticPosR.x * 0.8 - causticPosR.y * 1.4);\n    float interferenceR = (waveR1 + waveR2 + waveR3) / 3.0;\n    float causticR = smoothstep(0.3, 0.8, interferenceR);\n\n    // Green channel\n    float waveG1 = sin(causticPosG.x * 2.0 + causticPosG.y * 1.5 + causticPosG.z);\n    float waveG2 = sin(causticPosG.y * 2.3 - causticPosG.x * 1.2 + causticPosG.z * 1.8);\n    float waveG3 = sin(causticPosG.z * 1.9 + causticPosG.x * 0.8 - causticPosG.y * 1.4);\n    float interferenceG = (waveG1 + waveG2 + waveG3) / 3.0;\n    float causticG = smoothstep(0.3, 0.8, interferenceG);\n\n    // Blue channel\n    float waveB1 = sin(causticPosB.x * 2.0 + causticPosB.y * 1.5 + causticPosB.z);\n    float waveB2 = sin(causticPosB.y * 2.3 - causticPosB.x * 1.2 + causticPosB.z * 1.8);\n    float waveB3 = sin(causticPosB.z * 1.9 + causticPosB.x * 0.8 - causticPosB.y * 1.4);\n    float interferenceB = (waveB1 + waveB2 + waveB3) / 3.0;\n    float causticB = smoothstep(0.3, 0.8, interferenceB);\n\n    // Combine into RGB caustic with chromatic separation\n    vec3 causticRGB = vec3(causticR, causticG, causticB);\n\n    // Add noise variation to break up uniformity\n    float noiseVar = noise3D(causticPosG * 0.5);\n    causticRGB *= (0.7 + noiseVar * 0.6);\n\n    // Clamp caustic peaks to prevent hot spot blobs\n    // This keeps caustics subtle and distributed rather than concentrated\n    causticRGB = min(causticRGB, vec3(0.6));\n\n    // Caustics are MORE visible in thick areas (center) where light has more\n    // material to refract through and pool\n    float thickness = abs(dot(normal, viewDir)); // 1 at center, 0 at edges\n    causticRGB *= (0.3 + thickness * 0.7);\n\n    // Apply intensity control\n    causticRGB *= causticIntensity;\n\n    // Boost caustic visibility for colored gems to compensate for reduced chromatic spread\n    // Colored gems (high sssStrength) have suppressed chromatic aberration, so boost their\n    // monochromatic caustics to maintain internal "life" and sparkle\n    float causticBoost = 1.0 + clamp((sssStrength - 0.5) * 0.8, 0.0, 0.6);\n    causticRGB *= causticBoost;\n\n    // Also keep a scalar caustic for compatibility\n    float caustic = (causticRGB.r + causticRGB.g + causticRGB.b) / 3.0;\n\n    // Animation pattern (0-1 range) - core glow + caustic hot spots\n    float animationPattern = coreGlow * 0.7 + caustic * 0.3;\n\n    // Soul intensity controls overall brightness with more dramatic falloff\n    // Brighter near core, darker at edges\n    float baseLevel = 0.1;  // Lower base for more contrast\n    float patternContrast = 0.9;  // Higher contrast for more variation\n    float soulIntensity = (baseLevel + animationPattern * patternContrast) * innerGlowStrength;\n\n    // Apply transmission to soul - thin areas glow brighter\n    soulIntensity *= transmission;\n\n    // Soul color from emotion\n    // NOTE: emotionColor is pre-normalized by normalizeColorLuminance() in Core3DManager\n    // This ensures consistent perceived brightness across all emotions (yellow won't wash out, blue stays visible)\n    // Reduced intensity to prevent blowout - soul should be visible but not white\n    float glowCurve = sqrt(innerGlowStrength * glowIntensity) * 0.5;\n    vec3 soulColor = emotionColor * soulIntensity * glowCurve;\n    // Clamp soul color to prevent blowout\n    soulColor = min(soulColor, vec3(0.8));\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // REFRACTED SOUL SAMPLING - True optical lensing through crystal\n    // The soul is rendered to a texture, then sampled with refraction distortion\n    // This creates the effect of looking at the soul through a crystal lens\n    // ═══════════════════════════════════════════════════════════════════════\n\n    // ═══════════════════════════════════════════════════════════════════\n    // REFRACTED SOUL SAMPLING\n    // Sample the soul texture with physical refraction distortion\n    // Creates the "looking through glass" lensing effect\n    // ═══════════════════════════════════════════════════════════════════\n    vec3 refractedSoulColor = vec3(0.0);\n    float refractedSoulAlpha = 0.0;\n\n    if (soulTextureSize.x > 0.0 && soulScreenCenter.x >= 0.0) {\n        // Fragment's screen UV position\n        vec2 fragUV = gl_FragCoord.xy / soulTextureSize;\n\n        // Calculate refraction offset using Snell's law\n        float ior = refractionIndex;\n        vec3 refractedDir = refract(-viewDir, normal, 1.0 / ior);\n\n        // Apply refraction distortion toward the soul center\n        // This creates the magnifying glass effect - bending light toward center\n        vec2 refractionOffset = refractedDir.xy * refractionStrength * 0.1;\n\n        // Sample at fragment position with refraction offset\n        // The soul texture contains the soul rendered at its actual screen position\n        vec2 soulUV = fragUV + refractionOffset;\n\n        // Clamp to valid UV range\n        soulUV = clamp(soulUV, 0.0, 1.0);\n\n        // Sample the soul texture\n        vec4 soulSample = texture2D(soulTexture, soulUV);\n\n        // Store for later use in final composition\n        refractedSoulColor = soulSample.rgb;\n        refractedSoulAlpha = soulSample.a;\n\n        // Also blend into soulColor for existing pipeline\n        soulColor = mix(soulColor, soulSample.rgb, soulSample.a * 0.5);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // SOUL BLEND LAYERS - Apply before combining with shell\n    // ═══════════════════════════════════════════════════════════════════════\n    if (soulLayer1Enabled > 0.5) {\n        int mode = int(soulLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(soulColor, emotionColor * soulLayer1Strength, mode);\n        soulColor = mix(soulColor, blendResult, soulLayer1Strength);\n    }\n    if (soulLayer2Enabled > 0.5) {\n        int mode = int(soulLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(soulColor, emotionColor * soulLayer2Strength, mode);\n        soulColor = mix(soulColor, blendResult, soulLayer2Strength);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // FROSTED SHELL - Milky white layer with INTERNAL lighting model\n    // Lit from inside: thin edges bright, thick center dark\n    // ═══════════════════════════════════════════════════════════════════════\n\n    // Frosted glass base - will be modulated by thickness\n    // Lower base values allow for darker thick areas while maintaining bright edges\n    vec3 frostBase = vec3(0.45, 0.48, 0.55) * frostiness;\n\n    // THICKNESS-BASED DARKNESS (internal lighting model)\n    // Face-on facets are THICK (light travels far through) = DARK\n    // Edge-on facets are THIN (light escapes easily) = BRIGHT\n    float edgeThinness = 1.0 - abs(dot(normal, viewDir));  // 1 at edges, 0 facing camera\n\n    // Apply curve to make face-on areas darker more aggressively\n    float thinness = pow(edgeThinness, 0.7);  // Push more area toward dark\n\n    // Thickness multiplier: thin edges=bright (1.0), thick face-on=dark (0.01 for near-black)\n    float thicknessMultiplier = 0.01 + thinness * 0.99;\n    frostBase *= thicknessMultiplier;\n\n    // Surface variation adds subtle texture\n    frostBase += vec3(surfaceNoise * 0.03);\n\n    // Specular highlights on facet edges (external light catch)\n    float facetHighlight = pow(max(0.0, dot(normal, normalize(vec3(0.5, 1.0, 0.8)))), 16.0);\n    frostBase += vec3(facetHighlight * 0.2);\n\n    // SOUL BLEED - Inner glow illuminates the shell from inside\n    // Use gentler falloff so color reaches the shell surface\n    float soulBleed = exp(-distFromCenter * 1.2) * innerGlowStrength;\n    // Stronger color contribution - tint the frost with emotion color\n    frostBase = mix(frostBase, frostBase + emotionColor * 0.4, soulBleed);\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // SHELL BLEND LAYERS - Apply to frosted shell\n    // ═══════════════════════════════════════════════════════════════════════\n    if (shellLayer1Enabled > 0.5) {\n        int mode = int(shellLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(frostBase, emotionColor * shellLayer1Strength, mode);\n        frostBase = mix(frostBase, blendResult, shellLayer1Strength);\n    }\n    if (shellLayer2Enabled > 0.5) {\n        int mode = int(shellLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(frostBase, emotionColor * shellLayer2Strength, mode);\n        frostBase = mix(frostBase, blendResult, shellLayer2Strength);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // FRESNEL RIM - Bright emotion-colored edge glow\n    // ═══════════════════════════════════════════════════════════════════════\n    vec3 rimColor = mix(vec3(0.5, 0.9, 1.0), emotionColor, 0.6);\n    vec3 rimGlow = rimColor * fresnel * 1.2;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // RIM BLEND LAYERS - Apply to fresnel rim glow\n    // ═══════════════════════════════════════════════════════════════════════\n    if (rimLayer1Enabled > 0.5) {\n        int mode = int(rimLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(rimGlow, emotionColor * rimLayer1Strength, mode);\n        rimGlow = mix(rimGlow, blendResult, rimLayer1Strength);\n    }\n    if (rimLayer2Enabled > 0.5) {\n        int mode = int(rimLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(rimGlow, emotionColor * rimLayer2Strength, mode);\n        rimGlow = mix(rimGlow, blendResult, rimLayer2Strength);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // PHYSICALLY-BASED SUBSURFACE SCATTERING\n    // Uses BSSRDF with Beer's Law absorption and Burley diffusion profile\n    // ═══════════════════════════════════════════════════════════════════════\n    vec3 sss = calculatePhysicalSSS(\n        normal,\n        viewDir,\n        vPosition,\n        normalize(sssLightDir),\n        sssLightColor,\n        emotionColor,\n        sssStrength,\n        sssAbsorption,\n        sssScatterDistance,\n        sssThicknessBias,\n        sssThicknessScale,\n        sssCurvatureScale,\n        sssAmbient\n    );\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // SSS BLEND LAYERS - Apply to subsurface scattering contribution\n    // ═══════════════════════════════════════════════════════════════════════\n    if (sssLayer1Enabled > 0.5) {\n        int mode = int(sssLayer1Mode + 0.5);\n        vec3 blendResult = applyBlendMode(sss, emotionColor * sssLayer1Strength, mode);\n        sss = mix(sss, blendResult, sssLayer1Strength);\n    }\n    if (sssLayer2Enabled > 0.5) {\n        int mode = int(sssLayer2Mode + 0.5);\n        vec3 blendResult = applyBlendMode(sss, emotionColor * sssLayer2Strength, mode);\n        sss = mix(sss, blendResult, sssLayer2Strength);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // COMBINE - Frosted shell base + soul glow (soul adds to shell, doesn't replace)\n    // ═══════════════════════════════════════════════════════════════════════\n\n    // Start with shell as base - preserves dark shadows\n    vec3 finalColor = frostBase;\n\n    // Add soul glow on top (additive, not replacement) - concentrated in center\n    // Soul should illuminate dark areas but not wash out entirely\n    float soulBlendFactor = soulIntensity * 0.6;\n    finalColor += soulColor * soulBlendFactor;\n\n    // Apply texture - blend based on texture brightness and strength\n    vec3 texContribution = texColor.rgb * textureStrength;\n    finalColor = mix(finalColor, finalColor + texContribution, textureStrength);\n\n    // Apply SSS material color - PRESERVE BRIGHTNESS, only change HUE\n    // The sssAbsorption values define the material color hue\n    // But thickness-based darkness must be preserved for gemstone look\n    if (sssStrength > 0.01) {\n        // Get current brightness (this includes thickness darkening)\n        float currentLum = dot(finalColor, vec3(0.299, 0.587, 0.114));\n\n        // Normalize absorption to get hue direction (0-1 range)\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 hue = absorption / max(maxAbs, 0.001);\n\n        // Create material color that PRESERVES current brightness\n        // This keeps dark areas dark while tinting them with the gem color\n        float hueLum = dot(hue, vec3(0.299, 0.587, 0.114));\n        vec3 materialColor = hue * currentLum / max(hueLum, 0.001);\n\n        // Clamp to prevent blowout on bright areas\n        materialColor = min(materialColor, vec3(1.0));\n\n        // Add subtle variation from SSS lighting calculation\n        float sssLum = dot(sss, vec3(0.299, 0.587, 0.114));\n        materialColor *= (0.9 + sssLum * 0.2);\n\n        // Replace crystal color with material color\n        float replaceAmount = sssStrength * 0.7;\n        finalColor = mix(finalColor, materialColor, replaceAmount);\n    }\n\n    // Add rim glow, tinted toward material color\n    if (sssStrength > 0.01) {\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 hue = absorption / max(maxAbs, 0.001);\n        // Stronger tint for colored gems - use gem hue directly\n        float rimTintStrength = clamp(sssStrength * 0.6, 0.0, 0.95);\n        vec3 tintedRim = rimGlow * mix(vec3(1.0), hue * 1.2, rimTintStrength);\n        // Cap rim to prevent bloom\n        tintedRim = min(tintedRim, vec3(0.5));\n        finalColor += tintedRim;\n    } else {\n        finalColor += rimGlow;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // SPECULAR HIGHLIGHTS - Add bright hot spots\n    // Tinted by gem color for colored gems to prevent white bloom\n    // ═══════════════════════════════════════════════════════════════════════\n    vec3 specularColor = vec3(1.0, 0.98, 0.95); // Warm white highlights for clear gems\n    float specularIntensityMod = 1.0;\n\n    if (sssStrength > 0.5) {\n        // Tint specular by gem color to prevent white bloom\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 gemHue = absorption / max(maxAbs, 0.001);\n        float colorStrength = clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0);\n        // Use gem hue for specular color\n        specularColor = mix(specularColor, gemHue * 1.3, colorStrength);\n        // Also reduce specular intensity for colored gems\n        specularIntensityMod = mix(1.0, 0.4, colorStrength);\n    }\n\n    vec3 specularContrib = specularColor * specular * transmission * specularIntensityMod;\n    specularContrib = min(specularContrib, vec3(0.5)); // Cap specular to prevent bloom\n    finalColor += specularContrib;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // FACET EDGE LINES - Bright catches along beveled edges\n    // ═══════════════════════════════════════════════════════════════════════\n    float edgeLines = calculateFacetEdgeLines(normal, viewDir, lightDir);\n    finalColor += vec3(edgeLines * 0.15) * transmission;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // SATURATION BOOST AT THIN EDGES\n    // Real gems have MORE saturated color at thin edges where light escapes\n    // ═══════════════════════════════════════════════════════════════════════\n    if (sssStrength > 0.01) {\n        // thinness: 1 at edges, 0 facing camera\n        float satBoost = thinness * 0.4; // Up to 40% saturation boost at edges\n\n        // Get current color's saturation\n        float maxC = max(max(finalColor.r, finalColor.g), finalColor.b);\n        float minC = min(min(finalColor.r, finalColor.g), finalColor.b);\n        float currentSat = maxC > 0.001 ? (maxC - minC) / maxC : 0.0;\n\n        // Boost saturation at thin areas\n        if (maxC > 0.001 && currentSat > 0.01) {\n            // Calculate luminance\n            float lum = dot(finalColor, vec3(0.299, 0.587, 0.114));\n            // Increase saturation by moving away from gray toward the color\n            vec3 gray = vec3(lum);\n            float newSat = min(currentSat + satBoost, 1.0);\n            float satRatio = currentSat > 0.001 ? newSat / currentSat : 1.0;\n            finalColor = gray + (finalColor - gray) * satRatio;\n        }\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // FINAL THICKNESS APPLICATION - Apply AFTER all additive terms\n    // This ensures thick areas stay dark even with glow added\n    // ═══════════════════════════════════════════════════════════════════════\n    // thicknessMultiplier: 0.15 in thick center, 1.0 at thin edges\n    finalColor *= thicknessMultiplier;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // INTERNAL CAUSTICS - Bright spots from light concentration inside gem\n    // Now with chromatic aberration for rainbow dispersion effect\n    // Applied AFTER thickness darkening so they punch through dark areas\n    // ═══════════════════════════════════════════════════════════════════════\n    if (causticIntensity > 0.01) {\n        // Get material hue for tinting caustics\n        vec3 causticTint = vec3(1.0); // Default white\n        float causticTintStrength = 0.4; // Default for clear gems\n        if (sssStrength > 0.5) {\n            vec3 absorption = sssAbsorption;\n            float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n            vec3 hue = absorption / max(maxAbs, 0.001);\n            // Stronger tint for colored gems to prevent white bloom\n            causticTintStrength = clamp((sssStrength - 0.5) * 0.8 + 0.4, 0.4, 0.9);\n            causticTint = mix(vec3(1.0), hue * 1.2, causticTintStrength);\n        }\n        // Add RGB caustic with chromatic aberration\n        // Reduce raw RGB blend for colored gems\n        float rawBlend = mix(0.3, 0.1, clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0));\n        vec3 causticFinal = causticRGB * causticTint + causticRGB * rawBlend;\n        causticFinal = min(causticFinal, vec3(0.4)); // Cap to prevent bloom\n        finalColor += causticFinal;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // FIRE - Intense sparkle points from light dispersion in facets\n    // The "fire" effect that makes gems sparkle brilliantly\n    // ═══════════════════════════════════════════════════════════════════════\n    float fire = calculateFire(normal, viewDir, lightDir);\n\n    // Tint fire by gem color - colored gems should have tinted highlights\n    // Pure white fire only for quartz/clear gems (low sssStrength)\n    vec3 fireColor = vec3(1.0, 0.99, 0.97); // Base warm white\n    float fireIntensity = 0.3; // Base intensity for clear gems\n    float fireClamp = 1.5; // Max fire value for clear gems\n\n    if (sssStrength > 0.5) {\n        // Get gem hue from absorption - this IS the gem's color\n        vec3 absorption = sssAbsorption;\n        float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n        vec3 gemHue = absorption / max(maxAbs, 0.001);\n\n        // For colored gems, fire should BE the gem color, not white\n        // The more colored the gem (higher sssStrength), the more the fire matches the gem\n        float colorStrength = clamp((sssStrength - 0.5) * 0.5, 0.0, 1.0);\n\n        // Use gem hue directly as fire color - NOT mixed with white\n        // This ensures fire can never bloom to white\n        fireColor = gemHue * 1.2; // Slight brightness boost but stay saturated\n\n        // Reduce fire intensity AND clamp for colored gems to prevent bloom washout\n        // Colored gems should have subtle, saturated fire, not bright white spots\n        fireIntensity = mix(0.3, 0.08, colorStrength); // Much lower for colored gems\n        fireClamp = mix(1.5, 0.5, colorStrength); // Much lower clamp for colored gems\n    }\n\n    // Apply fire clamp BEFORE multiplying by color\n    fire = min(fire, fireClamp);\n\n    // Calculate fire contribution and clamp to prevent any channel from blooming\n    vec3 fireContribution = fireColor * fire * fireIntensity;\n    fireContribution = min(fireContribution, vec3(0.4)); // Hard cap on fire brightness\n    finalColor += fireContribution;\n\n    // Ensure minimum brightness - allow near-black for gemstones\n    // minBrightness of 0.01 allows true darks while preventing total black\n    finalColor = max(finalColor, vec3(minBrightness));\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // ALPHA - More opaque for visibility\n    // ═══════════════════════════════════════════════════════════════════════\n\n    // Higher base opacity\n    float baseAlpha = 0.6 + frostiness * 0.25;\n\n    // Fresnel makes edges solid\n    float rimAlpha = fresnel * 0.3;\n\n    // Soul glow adds opacity\n    float glowAlpha = soulIntensity * 0.15;\n\n    float finalAlpha = min(baseAlpha + rimAlpha + glowAlpha, 0.95) * opacity;\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // ALPHA FIX FOR DARK FRAGMENTS\n    // With NormalBlending, dark color + partial alpha creates darkening artifacts\n    // (result = dark * alpha + bg * (1-alpha) can be DARKER than background!)\n    // Fix: Make dark fragments fully opaque so they replace background, not blend\n    // ═══════════════════════════════════════════════════════════════════════\n    float luminance = dot(finalColor, vec3(0.299, 0.587, 0.114));\n    // Dark fragments (luminance < 0.3) get alpha boosted toward 1.0\n    // Bright fragments keep their calculated alpha for glowing edges\n    float darkBoost = 1.0 - smoothstep(0.0, 0.3, luminance);  // 1.0 when dark, 0.0 when bright\n    finalAlpha = mix(finalAlpha, 1.0, darkBoost * 0.8);  // Boost dark fragments to near-opaque\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // REFRACTED SOUL - Add the soul visible through the crystal\n    // This is the actual soul mesh rendered to texture and sampled with refraction\n    // ═══════════════════════════════════════════════════════════════════════\n    if (refractedSoulAlpha > 0.01) {\n        // The soul should glow through the crystal, tinted by the crystal's color\n        // Use additive blending so the soul illuminates the crystal from within\n        vec3 soulGlow = refractedSoulColor * refractedSoulAlpha;\n\n        // Tint the soul by the crystal's SSS color for colored gems\n        // emotionColorBleed controls how much pure emotion color comes through\n        // 0 = fully tinted by gem color, 1 = pure emotion color\n        if (sssStrength > 0.01) {\n            vec3 absorption = sssAbsorption;\n            float maxAbs = max(max(absorption.r, absorption.g), absorption.b);\n            vec3 gemHue = absorption / max(maxAbs, 0.001);\n            float tintAmount = sssStrength * 0.5 * (1.0 - emotionColorBleed);\n            soulGlow *= mix(vec3(1.0), gemHue, tintAmount);\n        }\n\n        // Add soul glow to final color\n        finalColor += soulGlow * 0.8;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // EMOTION COLOR BLEED - Additional inner glow from soul emotion\n    // Adds pure emotion color as light shining through the gem from the soul\n    // ═══════════════════════════════════════════════════════════════════════\n    if (emotionColorBleed > 0.001 && sssStrength > 0.01) {\n        // Inner glow based on thickness - thinner areas show more soul light\n        float innerGlow = 1.0 - abs(dot(normal, viewDir)); // Edges are thin\n        innerGlow = pow(innerGlow, 1.5) * emotionColorBleed;\n\n        // Also add glow near the core\n        float coreProximity = exp(-distFromCenter * 2.0);\n        innerGlow += coreProximity * emotionColorBleed * 0.5;\n\n        // Add pure emotion color as inner light\n        finalColor += emotionColor * innerGlow * 0.4;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // IMPACT GLOW - Localized bright spot at punch impact site\n    // Uses calculateImpactGlow() from deformation.js utility\n    // vPosition is in mesh-local space (impactPoint pre-transformed by JS)\n    // ═══════════════════════════════════════════════════════════════════════\n    finalColor += calculateImpactGlow(vPosition, emotionColor);\n\n    // ═══════════════════════════════════════════════════════════════════════\n    // OBJECT-SPACE CRACKS - Persistent damage that rotates with mesh\n    // Uses calculateObjectSpaceCracks() from objectSpaceCracks.js utility\n    // vPosition is in mesh-local space (impacts pre-transformed by JS)\n    // ═══════════════════════════════════════════════════════════════════════\n    vec4 crackContrib = calculateObjectSpaceCracks(vPosition, normal);\n    if (crackContrib.a > 0.001) {\n        // Blend cracks over the final color\n        finalColor = mix(finalColor, crackContrib.rgb, crackContrib.a * 0.8);\n        // Cracks also affect alpha - make cracked areas more opaque\n        finalAlpha = max(finalAlpha, crackContrib.a * 0.5);\n    }\n\n    gl_FragColor = vec4(finalColor, finalAlpha);\n}\n`,Ud={time:0,glowIntensity:1,opacity:1,frostiness:.55,fresnelPower:2.8,fresnelIntensity:.25,innerGlowStrength:.55,surfaceRoughness:.12,shadowDarkness:.6,specularIntensity:.5,specularPower:28,transmissionContrast:1,minBrightness:.005,surfaceNoiseScale:1.5,noiseFrequency:1.33,causticIntensity:.8,causticScale:2,causticSpeed:.12,textureStrength:.55,refractionIndex:1.5,refractionStrength:.5,resolution:[1920,1080],soulTextureSize:[1920,1080],soulScreenCenter:[.5,.5],sssStrength:.65,sssAbsorption:[2.4,2.5,2.8],sssScatterDistance:[.35,.4,.45],sssThicknessBias:.18,sssThicknessScale:.6,sssCurvatureScale:1.8,sssAmbient:.3,sssLightDir:[.5,1,.8],sssLightColor:[1,.98,.95],shellLayer1Mode:0,shellLayer1Strength:0,shellLayer1Enabled:0,shellLayer2Mode:0,shellLayer2Strength:0,shellLayer2Enabled:0,soulLayer1Mode:0,soulLayer1Strength:0,soulLayer1Enabled:0,soulLayer2Mode:0,soulLayer2Strength:0,soulLayer2Enabled:0,rimLayer1Mode:0,rimLayer1Strength:0,rimLayer1Enabled:0,rimLayer2Mode:0,rimLayer2Strength:0,rimLayer2Enabled:0,sssLayer1Mode:0,sssLayer1Strength:0,sssLayer1Enabled:0,sssLayer2Mode:0,sssLayer2Strength:0,sssLayer2Enabled:0};function Wd(t,i,a={}){const{glowColor:n=[1,1,.95],glowIntensity:s=1,materialVariant:r=null,emotionData:o=null,assetBasePath:l="/assets",onTextureReady:c=null}=a;return"custom"===i.material?function(t,i,a,n,s,r,o){const l=new e.TextureLoader;switch(t){case"moon":return function(t,i,a,n=null,s="/assets",r=null){const o=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)?"2k":"4k";if("multiplexer"===n)return{material:hi(t,{resolution:o,glowColor:new e.Color(i[0],i[1],i[2]),glowIntensity:a,assetBasePath:s,onTextureReady:r}),type:"moon-multiplexer"};return{material:ni(t,{resolution:o,glowColor:new e.Color(i[0],i[1],i[2]),glowIntensity:a,moonPhase:"full",assetBasePath:s,onTextureReady:r}),type:"moon"}}(l,i,a,n,r,o);case"crystal":return Hd(i,a,"crystal",{sssPreset:"quartz"},r);case"rough":return Hd(i,a,"rough",{frostiness:.05,innerGlowStrength:0,fresnelIntensity:1.6},r);case"heart":return Hd(i,a,"heart",{frostiness:.475,innerGlowStrength:.117,fresnelIntensity:1.206},r);case"star":return Hd(i,a,"star",{sssPreset:"citrine"},r);default:return console.warn("Unknown custom material type:",t),null}}(t,n,s,r,0,l,c):"emissive"===i.material?function(t,i,a,n,s,r){const o=new e.TextureLoader;return"sun"===t?function(e,t,i,a=null,n=null,s="/assets"){return{material:mi(e,{glowColor:t,glowIntensity:i,resolution:"4k",materialVariant:a,assetBasePath:s}),type:"sun"}}(o,i,a,n,s,r):(console.warn("Unknown emissive material type:",t),null)}(t,n,s,r,o,l):null}function Hd(t,i,a="crystal",n={},s="/assets"){const{vertexShader:r,fragmentShader:o}={vertexShader:jd,fragmentShader:qd};let l=null;if(a){const t=new e.TextureLoader,i={crystal:`${s}/textures/Crystal/crystal.png`,rough:`${s}/textures/Crystal/rough.png`,heart:`${s}/textures/Crystal/heart.png`,star:`${s}/textures/Crystal/star.png`},n=i[a]||i.crystal;l=t.load(n,void 0,e=>console.warn(`💎 ${a} texture failed to load:`,e))}const c=n.sssPreset?Ld[n.sssPreset]:null;return{material:new e.ShaderMaterial({uniforms:{time:{value:0},emotionColor:{value:new e.Color(t[0],t[1],t[2])},glowIntensity:{value:i},opacity:{value:1},frostiness:{value:n.frostiness??Ud.frostiness},fresnelPower:{value:n.fresnelPower??Ud.fresnelPower},fresnelIntensity:{value:n.fresnelIntensity??Ud.fresnelIntensity},innerGlowStrength:{value:n.innerGlowStrength??Ud.innerGlowStrength},surfaceRoughness:{value:Ud.surfaceRoughness},shadowDarkness:{value:n.shadowDarkness??Ud.shadowDarkness},specularIntensity:{value:n.specularIntensity??Ud.specularIntensity},specularPower:{value:n.specularPower??Ud.specularPower},transmissionContrast:{value:n.transmissionContrast??Ud.transmissionContrast},minBrightness:{value:n.minBrightness??Ud.minBrightness},surfaceNoiseScale:{value:Ud.surfaceNoiseScale},noiseFrequency:{value:Ud.noiseFrequency},causticIntensity:{value:n.causticIntensity??Ud.causticIntensity},causticScale:{value:n.causticScale??Ud.causticScale},causticSpeed:{value:n.causticSpeed??Ud.causticSpeed},crystalTexture:{value:l},textureStrength:{value:"heart"===a?.35:a?Ud.textureStrength:0},soulTexture:{value:null},resolution:{value:new e.Vector2(Ud.resolution[0],Ud.resolution[1])},soulTextureSize:{value:new e.Vector2(Ud.soulTextureSize[0],Ud.soulTextureSize[1])},soulScreenCenter:{value:new e.Vector2(Ud.soulScreenCenter[0],Ud.soulScreenCenter[1])},refractionIndex:{value:n.refractionIndex??Ud.refractionIndex},refractionStrength:{value:n.refractionStrength??Ud.refractionStrength},sssStrength:{value:n.sssStrength??c?.sssStrength??Ud.sssStrength},sssAbsorption:{value:new e.Vector3(...n.sssAbsorption??c?.sssAbsorption??Ud.sssAbsorption)},sssScatterDistance:{value:new e.Vector3(...n.sssScatterDistance??c?.sssScatterDistance??Ud.sssScatterDistance)},sssThicknessBias:{value:n.sssThicknessBias??c?.sssThicknessBias??Ud.sssThicknessBias},sssThicknessScale:{value:n.sssThicknessScale??c?.sssThicknessScale??Ud.sssThicknessScale},sssCurvatureScale:{value:n.sssCurvatureScale??c?.sssCurvatureScale??Ud.sssCurvatureScale},sssAmbient:{value:n.sssAmbient??c?.sssAmbient??Ud.sssAmbient},sssLightDir:{value:new e.Vector3(...n.sssLightDir??Ud.sssLightDir)},sssLightColor:{value:new e.Vector3(...n.sssLightColor??Ud.sssLightColor)},emotionColorBleed:{value:n.emotionColorBleed??c?.emotionColorBleed??0},shellLayer1Mode:{value:Ud.shellLayer1Mode},shellLayer1Strength:{value:Ud.shellLayer1Strength},shellLayer1Enabled:{value:Ud.shellLayer1Enabled},shellLayer2Mode:{value:Ud.shellLayer2Mode},shellLayer2Strength:{value:Ud.shellLayer2Strength},shellLayer2Enabled:{value:Ud.shellLayer2Enabled},soulLayer1Mode:{value:Ud.soulLayer1Mode},soulLayer1Strength:{value:Ud.soulLayer1Strength},soulLayer1Enabled:{value:Ud.soulLayer1Enabled},soulLayer2Mode:{value:Ud.soulLayer2Mode},soulLayer2Strength:{value:Ud.soulLayer2Strength},soulLayer2Enabled:{value:Ud.soulLayer2Enabled},rimLayer1Mode:{value:Ud.rimLayer1Mode},rimLayer1Strength:{value:Ud.rimLayer1Strength},rimLayer1Enabled:{value:Ud.rimLayer1Enabled},rimLayer2Mode:{value:Ud.rimLayer2Mode},rimLayer2Strength:{value:Ud.rimLayer2Strength},rimLayer2Enabled:{value:Ud.rimLayer2Enabled},sssLayer1Mode:{value:Ud.sssLayer1Mode},sssLayer1Strength:{value:Ud.sssLayer1Strength},sssLayer1Enabled:{value:Ud.sssLayer1Enabled},sssLayer2Mode:{value:Ud.sssLayer2Mode},sssLayer2Strength:{value:Ud.sssLayer2Strength},sssLayer2Enabled:{value:Ud.sssLayer2Enabled},deformationStrength:{value:Vd.deformationStrength},impactPoint:{value:new e.Vector3(...Vd.impactPoint)},deformationFalloff:{value:Vd.deformationFalloff},crackImpact0:{value:new e.Vector3(...Nd.crackImpact0)},crackImpact1:{value:new e.Vector3(...Nd.crackImpact1)},crackImpact2:{value:new e.Vector3(...Nd.crackImpact2)},crackDirection0:{value:new e.Vector3(...Nd.crackDirection0)},crackDirection1:{value:new e.Vector3(...Nd.crackDirection1)},crackDirection2:{value:new e.Vector3(...Nd.crackDirection2)},crackParams0:{value:new e.Vector3(...Nd.crackParams0)},crackParams1:{value:new e.Vector3(...Nd.crackParams1)},crackParams2:{value:new e.Vector3(...Nd.crackParams2)},crackNumImpacts:{value:Nd.crackNumImpacts},crackColor:{value:new e.Color(...Nd.crackColor)},crackGlowColor:{value:new e.Color(...Nd.crackGlowColor)},crackGlowStrength:{value:Nd.crackGlowStrength}},vertexShader:r,fragmentShader:o,transparent:!0,side:e.DoubleSide,depthWrite:!1,blending:e.NormalBlending}),type:"crystal"}}function $d(e){e&&(e.map&&e.map.dispose(),e.normalMap&&e.normalMap.dispose(),e.emissiveMap&&e.emissiveMap.dispose(),e.roughnessMap&&e.roughnessMap.dispose(),e.metalnessMap&&e.metalnessMap.dispose())}const Yd=new Map;async function Xd(e,t={}){if(Yd.has(e)){const t=Yd.get(e);if(t.loaded)return t}const i=wi[e];if(!i)return console.warn(`[GeometryCache] Unknown geometry type: ${e}`),null;const a={geometry:null,material:null,materialType:null,config:i,loaded:!1};if(i.geometryLoader?a.geometry=await i.geometryLoader(t.assetBasePath):a.geometry=i.geometry,"custom"===i.material||"emissive"===i.material){const n=Wd(e,i,{glowColor:t.glowColor||[1,1,.95],glowIntensity:t.glowIntensity||1,materialVariant:t.materialVariant,emotionData:t.emotionData,assetBasePath:t.assetBasePath});n&&(a.material=n.material,a.materialType=n.type)}return a.loaded=!0,Yd.set(e,a),a}async function Qd(e={}){await Promise.all(["crystal","rough","heart","moon","sun"].map(t=>Xd(t,e)))}function Kd(){for(const[e,t]of Yd.entries())t.material&&($d(t.material),t.material.dispose());Yd.clear()}var Zd={preload:Xd,preloadAll:Qd,get:function(e){const t=Yd.get(e);return t&&t.loaded?t:null},has:function(e){const t=Yd.get(e);return t&&t.loaded},updateMaterialOptions:function(e,t){const i=Yd.get(e);if(!i||!i.material)return;const{uniforms:a}=i.material;a&&(t.glowColor&&a.glowColor&&a.glowColor.value.set(...t.glowColor),void 0!==t.glowIntensity&&a.glowIntensity&&(a.glowIntensity.value=t.glowIntensity))},dispose:Kd,getStatus:function(){const e={};for(const[t,i]of Yd.entries())e[t]={loaded:i.loaded,hasGeometry:!!i.geometry,hasMaterial:!!i.material,materialType:i.materialType};return e}};class Jd{constructor(e,t){this.animator=e,this.gestureBlender=t,this.virtualParticlePool=this._createVirtualParticlePool(5),this.nextPoolIndex=0}_createVirtualParticlePool(e){const t=[];for(let i=0;i<e;i++)t.push({x:0,y:0,vx:0,vy:0,size:1,baseSize:1,opacity:1,scaleFactor:1,gestureData:null});return t}getVirtualParticleFromPool(){const e=this.virtualParticlePool[this.nextPoolIndex];return this.nextPoolIndex=(this.nextPoolIndex+1)%this.virtualParticlePool.length,e.x=0,e.y=0,e.vx=0,e.vy=0,e.size=1,e.baseSize=1,e.opacity=1,e.scaleFactor=1,e.gestureData=null,e}playGesture(e,t={}){const i=wd(e);if(!i){const i=this.animator.createGestureAnimation(e);return i&&i.evaluate?this._playProceduralGesture(e,i,t):(console.warn(`Unknown gesture: ${e}`),!1)}const a=this.getVirtualParticleFromPool(),n=i.config||{};let s;s=n.musicalDuration?.musical?n.musicalDuration.bars?2e3*n.musicalDuration.bars:500*(n.musicalDuration.beats||2):n.duration||800;const r=this.animator.time;if(this.animator.animations.length>=10){const e=this.animator.animations.shift();console.warn(`Animation limit reached (10), removed oldest: ${e.gestureName||"unknown"}`)}const o={initialized:!1};return this.animator.animations.push({gestureName:e,duration:s,startTime:r,config:n,evaluate:e=>{a.x=0,a.y=0,a.vx=0,a.vy=0,a.size=1,a.opacity=1,i.apply&&(!o.initialized&&i.initialize&&(i.initialize(a,n,0,0),o.initialized=!0),i.apply(a,e,n,1/60,0,0));const t={...n,particle:a,config:n,strength:n.strength||1};return i["3d"]&&i["3d"].evaluate?i["3d"].evaluate.call(i,e,t):{position:[0,0,0],rotation:[0,0,0],scale:1}},callbacks:{onUpdate:t.onUpdate||null,onComplete:()=>{i.cleanup&&i.cleanup(a),t.onComplete&&t.onComplete()}}}),!0}_playProceduralGesture(e,t,i={}){const a=1e3*(t.duration||.5),n=this.animator.time;if(this.animator.animations.length>=10){const e=this.animator.animations.shift();console.warn(`Animation limit reached (10), removed oldest: ${e.gestureName||"unknown"}`)}return this.animator.animations.push({gestureName:e,duration:a,startTime:n,isAccent:t.isAccent||!1,evaluate:t.evaluate,callbacks:{onUpdate:i.onUpdate||null,onComplete:i.onComplete||null}}),!0}update(e){this.animator.update(e)}blend(e,t,i){return this.gestureBlender.blend(this.animator.animations,this.animator.time,e,t,i)}hasActiveAnimations(){return this.animator.animations.length>0}getActiveAnimationCount(){return this.animator.animations.length}getTime(){return this.animator.time}getActiveAnimations(){return this.animator.animations}stopAll(){this.animator.stopAll()}playEmotion(e){this.animator.playEmotion(e)}dispose(){this.stopAll(),this.virtualParticlePool&&(this.virtualParticlePool.length=0,this.virtualParticlePool=null),this.animator=null,this.gestureBlender=null,this.tempEuler=null,this.gestureQuaternion=null}}const em="off",tm="annular",im="total",am={[em]:{shadowCoverage:0,coronaIntensity:1,coronaRaysEnabled:!1,baileyBeadsEnabled:!1,baileyBeadsCount:0,baileyBeadsSize:0},[tm]:{shadowCoverage:.95,coronaIntensity:.8,coronaRaysEnabled:!1,baileyBeadsEnabled:!0,baileyBeadsCount:12,baileyBeadsSize:.015},[im]:{shadowCoverage:1.019,coronaIntensity:4,coronaRaysEnabled:!0,baileyBeadsEnabled:!0,baileyBeadsCount:6,baileyBeadsSize:.025}};function nm(e){return am[e]||am[em]}class sm{constructor(t,i){this.scene=t,this.sunRadius=i,this.heroBeadCount=3,this.supportBeadCount=15,this.beadCount=this.heroBeadCount+this.supportBeadCount,this.beads=[],this.visible=!1,this._directionToCamera=new e.Vector3,this._up=new e.Vector3(0,1,0),this._right=new e.Vector3,this._upVector=new e.Vector3,this._beadOffset=new e.Vector3,this._tempColor=new e.Color,this.sharedTexture=null,this.createBeads()}createBeads(){const t=document.createElement("canvas");t.width=64,t.height=64;const i=t.getContext("2d"),a=i.createRadialGradient(32,32,0,32,32,32);a.addColorStop(0,"rgba(255, 255, 255, 1.0)"),a.addColorStop(.1,"rgba(255, 255, 255, 0.9)"),a.addColorStop(.3,"rgba(255, 240, 200, 0.6)"),a.addColorStop(.6,"rgba(255, 220, 150, 0.2)"),a.addColorStop(1,"rgba(255, 200, 100, 0.0)"),i.fillStyle=a,i.fillRect(0,0,64,64);const n=new e.CanvasTexture(t);n.needsUpdate=!0,this.sharedTexture=n;const s=this.generateLunarValleys();for(let t=0;t<this.beadCount;t++){const i=new e.Group,a=new e.SpriteMaterial({map:n.clone(),blending:e.AdditiveBlending,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(1,.3,.3)}),r=new e.Sprite(a);r.scale.set(.08,.08,1),i.add(r);const o=new e.SpriteMaterial({map:n.clone(),blending:e.AdditiveBlending,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(.8,1,.8)}),l=new e.Sprite(o);l.scale.set(.08,.08,1),i.add(l);const c=new e.SpriteMaterial({map:n,blending:e.AdditiveBlending,transparent:!0,depthWrite:!1,opacity:0,color:this._tempColor.setRGB(.3,.5,1)}),h=new e.Sprite(c);h.scale.set(.08,.08,1),i.add(h),i.userData={angle:s[t].angle,depth:s[t].depth,baseIntensity:s[t].baseIntensity,isHero:s[t].isHero,sizeMultiplier:s[t].isHero?1.5:1,targetOpacity:0,currentOpacity:0,redSprite:r,greenSprite:l,blueSprite:h},this.beads.push(i),this.scene.add(i)}}generateLunarValleys(){const e=[];let t=12345;const i=()=>(t=(9301*t+49297)%233280,t/233280),a=i()*Math.PI*2;for(let t=0;t<this.heroBeadCount;t++){const n=a+t*Math.PI*2/3;e.push({angle:n,depth:.8+.2*i(),baseIntensity:.8+.2*i(),isHero:!0})}for(let t=0;t<this.supportBeadCount;t++){const n=a+Math.floor(t/(this.supportBeadCount/3))*Math.PI*2/3,s=1.2*(i()-.5);e.push({angle:n+s,depth:.3+.5*i(),baseIntensity:.4+.4*i(),isHero:!1})}return e}update(e,t,i,a,n=1){const s=this.sunRadius*n*1,r=e.position;this._directionToCamera.subVectors(r,t).normalize(),this._right.crossVectors(this._directionToCamera,this._up).normalize(),this._upVector.crossVectors(this._right,this._directionToCamera).normalize();for(const e of this.beads){const{angle:i,redSprite:a,greenSprite:r,blueSprite:o,sizeMultiplier:l}=e.userData,c=Math.cos(i)*s,h=Math.sin(i)*s;this._beadOffset.set(0,0,0),this._beadOffset.addScaledVector(this._right,c),this._beadOffset.addScaledVector(this._upVector,h),this._beadOffset.addScaledVector(this._directionToCamera,.01*s);const u=t.x+this._beadOffset.x,d=t.y+this._beadOffset.y,m=t.z+this._beadOffset.z,p=.008*n,g=Math.cos(i)*p,f=Math.sin(i)*p;a.position.set(g,f,.001),r.position.set(0,0,0),o.position.set(-g,-f,-.001),e.position.set(u,d,m),e.updateMatrixWorld(!0);const y=.15*n*l;a.scale.set(y,y,1),r.scale.set(y,y,1),o.scale.set(y,y,1)}if(this.visible){const e=.9,t=.97,a=1;for(const n of this.beads){let s=0;if(i>=e&&i<a){const r=(i-e)/(a-e)*Math.PI*2,o=Math.abs((n.userData.angle-r+Math.PI)%(2*Math.PI)-Math.PI);let l=1;i<t&&(l=(i-e)/(t-e)),s=Math.max(0,1-o/1)*n.userData.baseIntensity*l*n.userData.depth,s*=200}n.userData.targetOpacity=s}}else for(const e of this.beads)e.userData.targetOpacity=0;for(const e of this.beads){const{redSprite:t,greenSprite:i,blueSprite:n}=e.userData,s=e.userData.targetOpacity-e.userData.currentOpacity;e.userData.currentOpacity+=3*s*(a/1e3),e.userData.currentOpacity<.001&&(e.userData.currentOpacity=0),t.material.opacity=.7*e.userData.currentOpacity,i.material.opacity=1*e.userData.currentOpacity,n.material.opacity=.7*e.userData.currentOpacity}}setVisible(e){this.visible=e}dispose(){for(const e of this.beads){const{redSprite:t,greenSprite:i,blueSprite:a}=e.userData;t.material.map&&t.material.map.dispose(),t.material.dispose(),i.material.map&&i.material.map.dispose(),i.material.dispose(),a.material.map&&a.material.map.dispose(),a.material.dispose(),this.scene.remove(e)}this.beads=[],this.sharedTexture&&(this.sharedTexture.dispose(),this.sharedTexture=null),this._directionToCamera=null,this._up=null,this._right=null,this._upVector=null,this._beadOffset=null,this._tempColor=null,this.scene=null}}function rm(e){return e}function om(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}const lm=2*Math.PI/3,cm=2*Math.PI/4.5;function hm(e){return 0===e?0:1===e?1:-Math.pow(2,10*e-10)*Math.sin((10*e-10.75)*lm)}function um(e){return 0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin((10*e-.75)*lm)+1}function dm(e){return 0===e?0:1===e?1:e<.5?-Math.pow(2,20*e-10)*Math.sin((20*e-11.125)*cm)/2:Math.pow(2,-20*e+10)*Math.sin((20*e-11.125)*cm)/2+1}const mm=7.5625,pm=2.75;function gm(e){return e<1/pm?mm*e*e:e<2/pm?mm*(e-=1.5/pm)*e+.75:e<2.5/pm?mm*(e-=2.25/pm)*e+.9375:mm*(e-=2.625/pm)*e+.984375}function fm(e){return 1-gm(1-e)}function ym(e){return gm(e)}function vm(e){return e<.5?(1-gm(1-2*e))/2:(1+gm(2*e-1))/2}const bm=1.70158,wm=2.5949095,Mm=2.70158;function Sm(e){return Mm*e*e*e-bm*e*e}function xm(e){return 1+Mm*Math.pow(e-1,3)+bm*Math.pow(e-1,2)}function Cm(e){return e<.5?Math.pow(2*e,2)*(7.189819*e-wm)/2:(Math.pow(2*e-2,2)*(3.5949095*(2*e-2)+wm)+2)/2}const Pm={linear:rm,easeIn:function(e){return e*e},easeOut:function(e){return 1-(1-e)*(1-e)},easeInOut:function(e){return e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2},easeInQuad:function(e){return e*e},easeOutQuad:function(e){return 1-(1-e)*(1-e)},easeInOutQuad:function(e){return e<.5?2*e*e:1-Math.pow(-2*e+2,2)/2},easeInCubic:function(e){return e*e*e},easeOutCubic:function(e){return 1-Math.pow(1-e,3)},easeInOutCubic:om,easeInExpo:function(e){return 0===e?0:Math.pow(2,10*e-10)},easeOutExpo:function(e){return 1===e?1:1-Math.pow(2,-10*e)},easeInOutExpo:function(e){return 0===e?0:1===e?1:e<.5?Math.pow(2,20*e-10)/2:(2-Math.pow(2,-20*e+10))/2},elastic:hm,elasticOut:um,elasticInOut:dm,bounce:fm,bounceOut:ym,bounceInOut:vm,snap:function(e){return e<.5?0:1},step:function(e){return e>=1?1:0},smoothstep:function(e){return e*e*(3-2*e)},smootherstep:function(e){return e*e*e*(e*(6*e-15)+10)},burstImplode:function(e){if(e<.3){const t=e/.3;return 1-Math.pow(1-t,3)}if(e<.5)return 1;{const t=(e-.5)/.5;return 1-t*t*t}},backIn:Sm,backOut:xm,backInOut:Cm,easeInBack:Sm,easeOutBack:xm,easeInOutBack:Cm,easeInElastic:hm,easeOutElastic:um,easeInOutElastic:dm,easeInBounce:fm,easeOutBounce:ym,easeInOutBounce:vm};function km(e){return"function"==typeof e?e:"string"==typeof e&&Pm[e]?Pm[e]:(console.warn(`[Easing] Unknown easing "${e}", falling back to linear`),rm)}class Dm{constructor(t,i,a=null){this.scene=t,this.sunRadius=i,this.sunMesh=a,this.eclipseType=em,this.previousEclipseType=em,this.enabled=!1,this.time=0,this.randomSeed=12345,this.isTransitioning=!1,this.transitionProgress=0,this.transitionDuration=400,this.transitionDirection="in",this.manualControl=!1,this.customShadowCoverage=void 0,this._directionToCamera=new e.Vector3,this._up=new e.Vector3(0,1,0),this._right=new e.Vector3,this._upVector=new e.Vector3,this._tempOffset=new e.Vector3,this._tempColor=new e.Color,this.createShadowDisk(),this.createCoronaDisk(),this.createCounterCoronaDisk(),this.sunMesh&&(this.scene.remove(this.coronaDisk),this.scene.remove(this.counterCoronaDisk),this.sunMesh.add(this.coronaDisk),this.sunMesh.add(this.counterCoronaDisk)),this.baileysBeads=new sm(t,i)}createShadowDisk(){const t=this.sunRadius,i=new e.CircleGeometry(t,256),a=new e.MeshBasicMaterial({color:0,transparent:!0,opacity:1,blending:e.MultiplyBlending,premultipliedAlpha:!0,side:e.DoubleSide,depthWrite:!1,depthTest:!1,fog:!1});this.shadowDisk=new e.Mesh(i,a),this.shadowDisk.renderOrder=1e4,this.shadowDisk.position.set(200,0,0),this.scene.add(this.shadowDisk)}createCoronaDisk(){const t=2.05*this.sunRadius,i=.6*this.sunRadius,a=new e.RingGeometry(i,t,256),n=new e.ShaderMaterial({uniforms:{time:{value:0},glowColor:{value:new e.Color(.9,.95,1)},intensity:{value:2.4},randomSeed:{value:this.randomSeed},uvRotation:{value:0},rayElongation:{value:1},uberHeroElongation:{value:1},isTotalEclipse:{value:0},layer1Mode:{value:11},layer1Strength:{value:2.155},layer1Enabled:{value:1},layer2Mode:{value:5},layer2Strength:{value:.695},layer2Enabled:{value:1},layer3Mode:{value:0},layer3Strength:{value:1},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:1},layer4Enabled:{value:0}},vertexShader:"\n                uniform float uvRotation;\n                varying vec2 vUv;\n\n                void main() {\n                    // Rotate UVs around center (0.5, 0.5)\n                    vec2 centeredUV = uv - 0.5;\n                    float cosRot = cos(uvRotation);\n                    float sinRot = sin(uvRotation);\n                    mat2 rotMatrix = mat2(cosRot, -sinRot, sinRot, cosRot);\n                    vec2 rotatedUV = rotMatrix * centeredUV;\n                    vUv = rotatedUV + 0.5;\n\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            ",fragmentShader:`\n                uniform float time;\n                uniform vec3 glowColor;\n                uniform float intensity;\n                uniform float randomSeed;\n                uniform float rayElongation;\n                uniform float uberHeroElongation;\n                uniform float isTotalEclipse;\n\n                // Blend Layer Uniforms (up to 4 layers)\n                uniform float layer1Mode;\n                uniform float layer1Strength;\n                uniform float layer1Enabled;\n\n                uniform float layer2Mode;\n                uniform float layer2Strength;\n                uniform float layer2Enabled;\n\n                uniform float layer3Mode;\n                uniform float layer3Strength;\n                uniform float layer3Enabled;\n\n                uniform float layer4Mode;\n                uniform float layer4Strength;\n                uniform float layer4Enabled;\n\n                varying vec2 vUv;\n\n                // ═══════════════════════════════════════════════════════════════════════════\n                // UNIVERSAL BLEND MODES (injected from utils/blendModes.js)\n                // ═══════════════════════════════════════════════════════════════════════════\n                ${jt}\n\n                // Hash function for pseudo-random variation\n                float hash(float n) {\n                    return fract(sin(n) * 43758.5453123);\n                }\n\n                // 2D hash for more variation\n                float hash2(vec2 p) {\n                    return fract(sin(dot(p, vec2(12.9898 + randomSeed, 78.233 + randomSeed))) * 43758.5453);\n                }\n\n                void main() {\n                    // Calculate distance and angle from center\n                    vec2 center = vec2(0.5, 0.5);\n                    vec2 toCenter = vUv - center;\n                    float dist = length(toCenter) * 2.0; // Normalize to 0-1 range\n                    float angle = atan(toCenter.y, toCenter.x);  // UVs are already rotated in vertex shader\n\n                    // Shadow edge - where corona rays start\n                    // Ring inner edge is at (sunRadius*0.85)/coronaRadius = 0.765/1.845 = 0.415\n                    // Start rays at sun's geometric edge (0.488) so they don't show inside sun\n                    float shadowEdge = 0.488;\n\n                    // Varied radial streamer pattern with artistic composition\n                    float rayIntensity = 0.0;\n\n                    // RULE OF THIRDS: Place 3 hero rays at compositionally strong points\n                    // Golden angles based on rule of thirds: 1/3, 2/3, and offset positions\n                    float heroAngles[3];\n                    heroAngles[0] = hash(randomSeed * 1.234) * 6.28318; // First hero ray (random rotation)\n                    heroAngles[1] = heroAngles[0] + 2.0944; // 120° apart (1/3 circle)\n                    heroAngles[2] = heroAngles[0] + 4.1888; // 240° apart (2/3 circle)\n\n                    // Process hero rays first (3 extra-long dramatic rays)\n                    for (int h = 0; h < 3; h++) {\n                        float rayAngle = heroAngles[h];\n                        float angleDiff = abs(mod(angle - rayAngle + 3.14159, 6.28318) - 3.14159);\n\n                        // Hero rays: extra long and prominent (fit within 0.535 normalized space)\n                        float baseHeroLength = 0.45 + hash(float(h) * 31.415 + randomSeed) * 0.08; // 0.45 to 0.53 (max available, longer!)\n\n                        // Apply UBER elongation: hero rays ALWAYS get extreme elongation (regardless of angle)\n                        // This creates 3 dramatic streamers that extend far in their respective directions\n                        float heroLength = baseHeroLength * uberHeroElongation;\n\n                        // Uber hero rays: keep them narrow but visible for dramatic pointy effect\n                        // Width scales with elongation to stay sharp but visible\n                        float baseHeroWidth = 0.15 + hash(float(h) * 27.183 + randomSeed) * 0.15; // 0.15 to 0.3 base width\n                        float narrowingFactor = mix(1.0, 0.3, (uberHeroElongation - 1.0) / max(uberHeroElongation, 1.0)); // 1.0 → 0.3 (70% narrower at max elongation)\n                        float heroWidth = baseHeroWidth * narrowingFactor; // Narrow when elongated = pointy!\n\n                        float distFromEdge = dist - shadowEdge;\n\n                        // Ghostly ethereal taper - very gradual falloff\n                        float taper = pow(1.0 - clamp(distFromEdge / max(heroLength, 0.001), 0.0, 1.0), 3.0);\n                        float rayWidth = heroWidth * taper;\n\n                        // Soft feathered edges instead of hard cutoff\n                        float edgeSoftness = 0.15; // Wider feather for smooth edges\n                        float angularMask = smoothstep(rayWidth + edgeSoftness, rayWidth - edgeSoftness, angleDiff);\n\n                        // Very gentle radial falloff for ethereal look\n                        float radialFalloff = pow(taper, 0.8);\n\n                        // Soft radial range with feathered ends\n                        float radialMask = smoothstep(-0.1, 0.05, distFromEdge) *\n                                          smoothstep(heroLength + 0.15, heroLength - 0.05, distFromEdge);\n\n                        float heroIntensity = angularMask * radialFalloff * radialMask * 0.7; // Reduced intensity for ghostly effect\n                        rayIntensity = max(rayIntensity, heroIntensity);\n                    }\n\n                    // 20 supporting rays with rule-of-thirds-aware distribution\n                    for (float i = 0.0; i < 20.0; i++) {\n                        // Cluster more rays around hero ray positions (rule of thirds)\n                        float clusterTarget = mod(i, 3.0); // Which hero ray to cluster near\n                        float clusterAngle = heroAngles[int(clusterTarget)];\n\n                        // Base distribution with clustering tendency\n                        float spreadAngle = (i / 20.0) * 6.28318;\n                        float clusterPull = (hash(i * 13.579 + randomSeed) - 0.5) * 1.5; // Stronger variation\n                        float rayAngle = spreadAngle + clusterPull;\n\n                        float angleDiff = abs(mod(angle - rayAngle + 3.14159, 6.28318) - 3.14159);\n\n                        // Unique random values per ray\n                        float random1 = hash(i * 12.9898 + randomSeed);\n                        float random2 = hash(i * 78.233 + randomSeed);\n                        float random3 = hash(i * 37.719 + randomSeed);\n                        float random4 = hash(i * 93.989 + randomSeed);\n\n                        // Varied lengths following power law distribution (more short, fewer long)\n                        float lengthVariation = random1 * random1; // Squared for naturalistic distribution\n                        float baseRayLength = 0.1 + lengthVariation * 0.7; // 0.1 to 0.8\n\n                        // 20% chance of long streamers (supporting the hero rays)\n                        float isLong = step(0.80, random2);\n                        baseRayLength = mix(baseRayLength, 0.7 + random3 * 0.6, isLong); // 0.7 to 1.3\n\n                        // Apply directional elongation: rays pointing up/down (vertical) get elongated\n                        float verticalWeight = abs(sin(rayAngle));\n                        float elongationFactor = mix(1.0, rayElongation, verticalWeight);\n                        float rayLength = baseRayLength * elongationFactor;\n\n                        // EQUATORIAL ASYMMETRY (total eclipse only): rays along equator are more prominent\n                        // Solar minimum: streamers cluster along equatorial plane\n                        float equatorialWeight = abs(cos(rayAngle)); // 1.0 at horizontal, 0.0 at vertical\n                        float asymmetryBoost = mix(1.0, 1.0 + equatorialWeight * 0.5, isTotalEclipse);\n                        rayLength *= asymmetryBoost;\n\n                        // Varied widths with power law (more thin, fewer thick)\n                        float baseWidth = 0.03 + (random4 * random4) * 0.2; // 0.03 to 0.23 (naturally varied)\n\n                        // Taper: wide at base, narrow at tip\n                        float distFromEdge = dist - shadowEdge;\n\n                        // Ghostly ethereal taper - very gradual falloff\n                        float taper = pow(1.0 - clamp(distFromEdge / max(rayLength, 0.001), 0.0, 1.0), 3.5);\n                        float rayWidth = baseWidth * taper;\n\n                        // Soft feathered edges for ethereal wisps\n                        float edgeSoftness = 0.10; // Wider feather for smooth edges\n                        float angularMask = smoothstep(rayWidth + edgeSoftness, rayWidth - edgeSoftness, angleDiff);\n\n                        // Very gentle radial falloff for ghostly appearance\n                        float radialFalloff = pow(taper, 1.0);\n\n                        // Soft radial range with feathered ends\n                        float radialMask = smoothstep(-0.08, 0.03, distFromEdge) *\n                                          smoothstep(rayLength + 0.12, rayLength - 0.03, distFromEdge);\n\n                        float streamerIntensity = angularMask * radialFalloff * radialMask * 0.5; // Reduced for ethereal wisps\n                        rayIntensity = max(rayIntensity, streamerIntensity);\n                    }\n\n                    // Base corona glow - thinner during total eclipse for realism\n                    float baseGlowWidth = mix(0.04, 0.015, isTotalEclipse); // Thinner during totality\n                    float baseGlow = smoothstep(shadowEdge - 0.01, shadowEdge, dist) *\n                                    (1.0 - smoothstep(shadowEdge + baseGlowWidth * 0.5, shadowEdge + baseGlowWidth, dist));\n\n                    // Enhanced gradient: white → cool blue-white → deep blue with distance\n                    // Distance normalized to corona extent (0 = shadow edge, 1 = far corona)\n                    float coronaDist = clamp((dist - shadowEdge) / 0.6, 0.0, 1.0);\n\n                    // ═══════════════════════════════════════════════════════════════════════════\n                    // TOTAL ECLIPSE ENHANCEMENTS (scaled continuously by isTotalEclipse 0.0-1.0)\n                    // ═══════════════════════════════════════════════════════════════════════════\n\n                    // 1. CHROMOSPHERE RED RIM - thin pink/red ring at sun's edge (hydrogen emission)\n                    float rimStart = shadowEdge;\n                    float rimEnd = shadowEdge + 0.025;\n                    float chromosphereRim = smoothstep(rimStart - 0.005, rimStart, dist) *\n                                     (1.0 - smoothstep(rimEnd - 0.01, rimEnd, dist));\n                    chromosphereRim *= 0.6 * isTotalEclipse; // Scale by eclipse progress\n                    vec3 chromosphereColor = vec3(1.0, 0.3, 0.4); // Pink-red (H-alpha emission)\n\n                    // 2. STRONGER BRIGHTNESS FALLOFF - inner corona much brighter\n                    // Mix between 1.0 (normal) and enhanced falloff based on isTotalEclipse\n                    float enhancedFalloff = mix(3.0, 0.3, pow(coronaDist, 0.7));\n                    float brightnessMultiplier = mix(1.0, enhancedFalloff, isTotalEclipse);\n\n                    // 3. F-CORONA OUTER GLOW - faint diffuse glow from interplanetary dust\n                    float fCoronaDist = clamp((dist - shadowEdge) / 1.2, 0.0, 1.0);\n                    float fCorona = (1.0 - fCoronaDist) * 0.08;\n                    fCorona *= smoothstep(0.3, 0.5, coronaDist);\n                    fCorona *= isTotalEclipse; // Scale by eclipse progress\n\n                    // 4. WISPY TENDRILS - add fine detail noise to ray intensity\n                    float noiseAngle = angle * 8.0 + time * 0.1;\n                    float noiseRadius = dist * 15.0;\n                    float wispyDetail = hash(noiseAngle + noiseRadius + randomSeed * 3.0) * 0.15;\n                    wispyDetail *= rayIntensity * isTotalEclipse; // Scale by eclipse progress\n\n                    // Combine: base glow + streamers + wispy detail\n                    float finalIntensity = (baseGlow * 0.6 + rayIntensity + wispyDetail) * intensity;\n                    finalIntensity *= brightnessMultiplier;\n\n                    // Multi-stage color gradient for realistic corona\n                    vec3 innerGlow = vec3(1.0, 1.0, 1.0);           // Pure white at base\n                    vec3 middleGlow = vec3(0.9, 0.95, 1.0);         // Cool white\n                    vec3 outerGlow = vec3(0.6, 0.75, 0.95);         // Pale blue\n                    vec3 farGlow = vec3(0.3, 0.5, 0.8);             // Deep blue\n\n                    // Three-stage color mix\n                    vec3 coronaColor;\n                    if (coronaDist < 0.3) {\n                        // Inner: white → cool white\n                        coronaColor = mix(innerGlow, middleGlow, coronaDist / 0.3);\n                    } else if (coronaDist < 0.7) {\n                        // Middle: cool white → pale blue\n                        coronaColor = mix(middleGlow, outerGlow, (coronaDist - 0.3) / 0.4);\n                    } else {\n                        // Outer: pale blue → deep blue\n                        coronaColor = mix(outerGlow, farGlow, (coronaDist - 0.7) / 0.3);\n                    }\n\n                    vec3 finalColor = coronaColor * finalIntensity;\n\n                    // Add chromosphere red rim (total eclipse only)\n                    finalColor += chromosphereColor * chromosphereRim * intensity;\n\n                    // Add F-corona outer glow (total eclipse only)\n                    finalColor += vec3(0.9, 0.85, 0.8) * fCorona * intensity; // Slightly warm white\n\n                    // ═══════════════════════════════════════════════════════════════════════════\n                    // BLEND LAYERS (Applied globally to entire corona)\n                    // These allow adjusting the appearance of the corona to prevent black edges\n                    // ═══════════════════════════════════════════════════════════════════════════\n\n                    // Layer 1\n                    if (layer1Enabled > 0.5) {\n                        vec3 blendColor1 = vec3(min(layer1Strength, 1.0));\n                        int mode1 = int(layer1Mode + 0.5);\n                        vec3 blended1 = clamp(applyBlendMode(finalColor, blendColor1, mode1), 0.0, 1.0);\n                        finalColor = clamp(blended1, 0.0, 1.0);\n                    }\n\n                    // Layer 2\n                    if (layer2Enabled > 0.5) {\n                        vec3 blendColor2 = vec3(min(layer2Strength, 1.0));\n                        int mode2 = int(layer2Mode + 0.5);\n                        vec3 blended2 = clamp(applyBlendMode(finalColor, blendColor2, mode2), 0.0, 1.0);\n                        finalColor = clamp(blended2, 0.0, 1.0);\n                    }\n\n                    // Layer 3\n                    if (layer3Enabled > 0.5) {\n                        vec3 blendColor3 = vec3(min(layer3Strength, 1.0));\n                        int mode3 = int(layer3Mode + 0.5);\n                        vec3 blended3 = clamp(applyBlendMode(finalColor, blendColor3, mode3), 0.0, 1.0);\n                        finalColor = clamp(blended3, 0.0, 1.0);\n                    }\n\n                    // Layer 4\n                    if (layer4Enabled > 0.5) {\n                        vec3 blendColor4 = vec3(min(layer4Strength, 1.0));\n                        int mode4 = int(layer4Mode + 0.5);\n                        vec3 blended4 = clamp(applyBlendMode(finalColor, blendColor4, mode4), 0.0, 1.0);\n                        finalColor = clamp(blended4, 0.0, 1.0);\n                    }\n\n                    // Sharp alpha falloff to prevent black bleeding in bloom\n                    // Higher power = sharper cutoff at edges (less semi-transparent area)\n                    float alphaFalloff = pow(1.0 - coronaDist, 3.0);\n                    float alpha = finalIntensity * alphaFalloff * 0.95;\n\n                    gl_FragColor = vec4(finalColor, alpha);\n                }\n            `,transparent:!0,blending:e.AdditiveBlending,depthWrite:!1,side:e.DoubleSide});this.coronaDisk=new e.Mesh(a,n),this.coronaDisk.position.set(0,0,0),this.coronaDisk.renderOrder=9998,this.scene.add(this.coronaDisk)}createCounterCoronaDisk(){const t=this.coronaDisk.geometry,i=this.randomSeed+5e3,a=new e.ShaderMaterial({uniforms:{time:{value:0},glowColor:{value:new e.Color(.9,.95,1)},intensity:{value:2.4},randomSeed:{value:i},uvRotation:{value:0},rayElongation:{value:1},uberHeroElongation:{value:1},isTotalEclipse:{value:0},layer1Mode:{value:11},layer1Strength:{value:2.155},layer1Enabled:{value:1},layer2Mode:{value:5},layer2Strength:{value:.695},layer2Enabled:{value:1},layer3Mode:{value:0},layer3Strength:{value:1},layer3Enabled:{value:0},layer4Mode:{value:0},layer4Strength:{value:1},layer4Enabled:{value:0}},vertexShader:this.coronaDisk.material.vertexShader,fragmentShader:this.coronaDisk.material.fragmentShader,transparent:!0,blending:e.AdditiveBlending,depthWrite:!1,side:e.DoubleSide});this.counterCoronaDisk=new e.Mesh(t,a),this.counterCoronaDisk.position.set(0,0,0),this.counterCoronaDisk.renderOrder=9997,this.scene.add(this.counterCoronaDisk)}setShadowCoverage(e){this.customShadowCoverage=e}setCoronaBlendLayer(e,t){if(e<1||e>4)return void console.error(`❌ Invalid corona layer number: ${e} (must be 1-4)`);const{mode:i=0,strength:a=1,enabled:n=!1}=t;this.coronaDisk?.material?.uniforms&&(this.coronaDisk.material.uniforms[`layer${e}Mode`].value=i,this.coronaDisk.material.uniforms[`layer${e}Strength`].value=a,this.coronaDisk.material.uniforms[`layer${e}Enabled`].value=n?1:0),this.counterCoronaDisk?.material?.uniforms&&(this.counterCoronaDisk.material.uniforms[`layer${e}Mode`].value=i,this.counterCoronaDisk.material.uniforms[`layer${e}Strength`].value=a,this.counterCoronaDisk.material.uniforms[`layer${e}Enabled`].value=n?1:0)}setEclipseType(e){if(e===this.eclipseType)return;const t=this.enabled;this.previousEclipseType=this.eclipseType,this.eclipseType=e,this.enabled=e!==em,this.manualControl=!1;const i=nm(this.previousEclipseType),a=nm(e);this.startShadowCoverage=i.shadowCoverage,this.targetShadowCoverage=a.shadowCoverage,!t&&this.enabled?(this.transitionDirection="in",this.isTransitioning=!0,this.transitionProgress=0):t&&!this.enabled?(this.transitionDirection="out",this.isTransitioning=!0,this.transitionProgress=0):t&&this.enabled&&(this.isTransitioning=!0,this.transitionProgress=0,this.transitionDirection="switch")}setManualProgress(e){this.manualControl=!0,this.transitionProgress=Math.max(0,Math.min(1,e)),this.isTransitioning=!0,this.transitionDirection="in"}setManualShadowPosition(e){this.manualControl=!0,this.manualShadowPosition=Math.max(-2,Math.min(2,e)),this.isTransitioning=!0,this.transitionDirection="manual"}update(e,t,i,a=null){const n=e.position,s=t.position,r=t.scale.x;let o=1;if(null!==a&&a>.5){const e=2*(a-.5);o=e*e*e}else if(null!==a&&a<=.5){const e=2*a;o=(1-e)*(1-e)*(1-e)}const l=this.eclipseType===em?3:1;if(this.time+=i*l,this.isTransitioning&&!this.manualControl){const e=i/this.transitionDuration;this.transitionProgress+=e,this.transitionProgress>=1&&(this.transitionProgress=1,this.isTransitioning=!1)}if(this.enabled||"out"===this.transitionDirection&&this.isTransitioning){const e="out"===this.transitionDirection&&this.isTransitioning?this.previousEclipseType:this.eclipseType,t=nm(e),a=this.sunRadius*r,l=om(this.transitionProgress);let c;void 0!==this.customShadowCoverage?c=this.customShadowCoverage:"switch"===this.transitionDirection&&this.isTransitioning&&void 0!==this.startShadowCoverage&&void 0!==this.targetShadowCoverage?c=this.startShadowCoverage+(this.targetShadowCoverage-this.startShadowCoverage)*l:({shadowCoverage:c}=t);const h=a*c/this.sunRadius;this.shadowDisk.scale.setScalar(h),this.currentShadowPosX=-2,"manual"===this.transitionDirection&&void 0!==this.manualShadowPosition?this.currentShadowPosX=this.manualShadowPosition:this.isTransitioning?"in"===this.transitionDirection?this.currentShadowPosX=2*l-2:"out"===this.transitionDirection?this.currentShadowPosX=0+1*l:"switch"===this.transitionDirection&&(this.currentShadowPosX=0):this.currentShadowPosX=0;const u=this.currentShadowPosX,d=2.5*a,m=u*d*.5,p=-u*u*d*.25;this._directionToCamera.subVectors(n,s).normalize(),this._right.crossVectors(this._directionToCamera,this._up).normalize(),this._upVector.crossVectors(this._right,this._directionToCamera).normalize();const g=0;this._tempOffset.copy(this._directionToCamera).multiplyScalar(g),this.shadowDisk.position.copy(s).add(this._tempOffset),this._tempOffset.copy(this._right).multiplyScalar(m),this.shadowDisk.position.add(this._tempOffset),this._tempOffset.copy(this._upVector).multiplyScalar(p),this.shadowDisk.position.add(this._tempOffset),this.shadowDisk.lookAt(n),this.coronaDisk.parent&&this.coronaDisk.parent!==this.scene||(this.coronaDisk.position.copy(s),this.counterCoronaDisk.position.copy(s),this.coronaDisk.scale.setScalar(r),this.counterCoronaDisk.scale.setScalar(r));const f=Math.abs(this.currentShadowPosX||0),y=2,v=Math.max(0,1-f/y);let b=0;if("switch"===this.transitionDirection&&this.isTransitioning){const e=this.previousEclipseType===im,t=this.eclipseType===im;t&&!e?b=l:!t&&e&&(b=1-l)}else e===im&&(b=1);const w=1+(1+24*Math.pow(v,4)-1)*b,M=1+(1+199*Math.pow(v,5)-1)*b;this.coronaDisk.material.uniforms.rayElongation.value=w,this.counterCoronaDisk.material.uniforms.rayElongation.value=w,this.coronaDisk.material.uniforms.uberHeroElongation.value=M,this.counterCoronaDisk.material.uniforms.uberHeroElongation.value=M;const S=.5,x=.99,C=Math.max(0,Math.min(1,(v-S)/(x-S))),P=C*C*(3-2*C),k=P*b;this.coronaDisk.material.uniforms.isTotalEclipse.value=k,this.counterCoronaDisk.material.uniforms.isTotalEclipse.value=k;const D=b>0&&v>=S,A=1-.947*P*b;this.setCoronaBlendLayer(3,{mode:1,strength:A,enabled:D}),this.coronaDisk.lookAt(n),this.counterCoronaDisk.lookAt(n);let _=0;if(e===em)_=i/1e3*.075;else if(e===tm){const e=.075;_=i/1e3*(e-(e-.25*e)*v)}else if(e===im){const e=.075;_=i/1e3*(e-(e-.05*e)*v)}this.coronaDisk.material.uniforms.uvRotation.value+=_,this.counterCoronaDisk.material.uniforms.uvRotation.value-=_;let T=1.2;if(e===em)T=3.6;else if(e===tm){const e=3.6,t=.08*e;this.transitionDirection,T=e-(e-t)*v}else if(e===im){const e=3.6,t=.65*e;this.transitionDirection,T=e-(e-t)*v}this.coronaDisk.material.uniforms.intensity.value=T*o,this.counterCoronaDisk.material.uniforms.intensity.value=T*o,this.coronaDisk.material.uniforms.time.value=this.time,this.counterCoronaDisk.material.uniforms.time.value=this.time}else{this.shadowDisk.position.set(200,0,0),this.coronaDisk.parent&&this.coronaDisk.parent!==this.scene||(this.coronaDisk.position.copy(s),this.counterCoronaDisk.position.copy(s),this.coronaDisk.scale.setScalar(r),this.counterCoronaDisk.scale.setScalar(r)),this.coronaDisk.material.uniforms.rayElongation.value=1,this.counterCoronaDisk.material.uniforms.rayElongation.value=1,this.coronaDisk.material.uniforms.uberHeroElongation.value=1,this.counterCoronaDisk.material.uniforms.uberHeroElongation.value=1,this.coronaDisk.material.uniforms.isTotalEclipse.value=0,this.counterCoronaDisk.material.uniforms.isTotalEclipse.value=0,this.coronaDisk.material.uniforms.intensity.value=3.06*o,this.counterCoronaDisk.material.uniforms.intensity.value=3.06*o,this.setCoronaBlendLayer(3,{mode:1,strength:0,enabled:!1}),this.coronaDisk.lookAt(n),this.counterCoronaDisk.lookAt(n);const e=i/1e3*.075;this.coronaDisk.material.uniforms.uvRotation.value+=e,this.counterCoronaDisk.material.uniforms.uvRotation.value-=e,this.coronaDisk.material.uniforms.intensity.value=3.6*o,this.counterCoronaDisk.material.uniforms.intensity.value=3.6*o,this.coronaDisk.material.uniforms.time.value=this.time,this.counterCoronaDisk.material.uniforms.time.value=this.time}if(this.eclipseType===im){let t=0,a=!1;if("manual"===this.transitionDirection){const e=Math.abs(this.currentShadowPosX),i=2;t=Math.max(0,Math.min(1,1-e/i)),t>=.9&&t<=1&&(a=!0)}else if("in"===this.transitionDirection&&this.isTransitioning){const e=.8;this.transitionProgress>=e&&(a=!0,t=.9+(this.transitionProgress-e)/(1-e)*.1)}else if("out"===this.transitionDirection&&this.isTransitioning){const e=.2;this.transitionProgress<=e&&(a=!0,t=1-this.transitionProgress/e*.1)}else this.isTransitioning||(t=1,a=!0);this.baileysBeads.setVisible(a),this.baileysBeads.update(e,s,t,i,r)}else this.baileysBeads.setVisible(!1),this.baileysBeads.update(e,s,0,i,r)}dispose(){this.shadowDisk&&(this.scene.remove(this.shadowDisk),this.shadowDisk.geometry.dispose(),this.shadowDisk.material.dispose(),this.shadowDisk=null),this.coronaDisk&&(this.coronaDisk.parent&&this.coronaDisk.parent.remove(this.coronaDisk),this.coronaDisk.geometry.dispose(),this.coronaDisk.material.dispose(),this.coronaDisk=null),this.counterCoronaDisk&&(this.counterCoronaDisk.parent&&this.counterCoronaDisk.parent.remove(this.counterCoronaDisk),this.counterCoronaDisk.material.dispose(),this.counterCoronaDisk=null),this.baileysBeads&&(this.baileysBeads.dispose(),this.baileysBeads=null),this._directionToCamera=null,this._up=null,this._right=null,this._upVector=null,this._tempOffset=null,this._tempColor=null,this.scene=null,this.sunMesh=null}}class Am{constructor(e){this.material=e,this.eclipseType="off",this.progress=0,this.targetProgress=0,this.animating=!1,this.bloodMoonColor={r:.85,g:.18,b:.08},this.animationDuration=3e3,this.startTime=0,this.shadowX=-2,this.shadowY=0,this.shadowRadius=.7,this.targetShadowX=-2,this.shadowSpeed=1,this.emissiveStrength=0,this.targetEmissive=0,this.shadowDarkness=1,this.targetDarkness=1,this.material.uniforms.eclipseProgress||(this.material.uniforms.eclipseProgress={value:0},this.material.uniforms.eclipseIntensity={value:0},this.material.uniforms.bloodMoonColor={value:[this.bloodMoonColor.r,this.bloodMoonColor.g,this.bloodMoonColor.b]},this.material.uniforms.eclipseShadowPos={value:[this.shadowX,this.shadowY]},this.material.uniforms.eclipseShadowRadius={value:this.shadowRadius})}setEclipseType(e){if(this.eclipseType===e)return;const t="off"===this.eclipseType;switch(this.eclipseType=e,t&&"off"!==e&&(this.shadowX=-2,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY]),e){case"off":this.targetProgress=0,this.targetShadowX=2,this.targetEmissive=0,this.targetDarkness=1;break;case"penumbral":this.targetProgress=.3,this.targetShadowX=-1,this.targetEmissive=.05,this.targetDarkness=.85;break;case"partial":this.targetProgress=.65,this.targetShadowX=-.4,this.targetEmissive=.2,this.targetDarkness=.7;break;case"total":this.targetProgress=1,this.targetShadowX=0,this.targetEmissive=.39,this.targetDarkness=.53;break;default:return void console.warn(`Unknown lunar eclipse type: ${e}`)}this.animating=!0,this.startTime=performance.now()}update(e){if(!this.animating)return;const t=performance.now()-this.startTime,i=Math.min(t/this.animationDuration,1),a=om(i);this.progress=this.progress+(this.targetProgress-this.progress)*a,this.shadowX=this.shadowX+(this.targetShadowX-this.shadowX)*a*this.shadowSpeed,this.emissiveStrength=this.emissiveStrength+(this.targetEmissive-this.emissiveStrength)*a,this.shadowDarkness=this.shadowDarkness+(this.targetDarkness-this.shadowDarkness)*a,this.material.uniforms.eclipseProgress.value=this.progress,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY],this.material.uniforms.emissiveStrength&&(this.material.uniforms.emissiveStrength.value=this.emissiveStrength),this.material.uniforms.shadowDarkness&&(this.material.uniforms.shadowDarkness.value=this.shadowDarkness);let n=0;"total"===this.eclipseType?n=this.progress:"partial"===this.eclipseType?n=.6*this.progress:"penumbral"===this.eclipseType&&(n=.25*this.progress),this.material.uniforms.eclipseIntensity.value=n,i>=1&&(this.animating=!1)}reset(){this.progress=0,this.targetProgress=0,this.shadowX=-2,this.targetShadowX=-2,this.emissiveStrength=0,this.targetEmissive=0,this.shadowDarkness=1,this.targetDarkness=1,this.animating=!1,this.eclipseType="off",this.material.uniforms.eclipseProgress&&(this.material.uniforms.eclipseProgress.value=0,this.material.uniforms.eclipseIntensity.value=0,this.material.uniforms.eclipseShadowPos.value=[this.shadowX,this.shadowY]),this.material.uniforms.emissiveStrength&&(this.material.uniforms.emissiveStrength.value=0),this.material.uniforms.shadowDarkness&&(this.material.uniforms.shadowDarkness.value=1)}dispose(){}}const _m=["crystal","rough","heart","star"];class Tm{constructor(e,t="/assets"){this.renderer=e,this.assetBasePath=t,this.solarEclipse=null,this.lunarEclipse=null,this.crystalSoul=null,this.currentGeometryType=null,this.coreGlowEnabled=!0}initializeForGeometry(e,t={}){const{coreMesh:i,customMaterial:a,sunRadius:n=1}=t;this.currentGeometryType=e,this._cleanupUnneededEffects(e),"sun"===e?this._initSolarEclipse(n,i):"moon"===e&&this._initLunarEclipse(a)}_initSolarEclipse(e,t){!this.solarEclipse&&this.renderer?.scene&&(this.solarEclipse=new Dm(this.renderer.scene,e,t))}_initLunarEclipse(e){!this.lunarEclipse&&e&&(this.lunarEclipse=new Am(e))}_cleanupUnneededEffects(e){"sun"!==e&&this.solarEclipse&&(this.solarEclipse.dispose(),this.solarEclipse=null),"moon"!==e&&this.lunarEclipse&&(this.lunarEclipse.dispose(),this.lunarEclipse=null),!_m.includes(e)&&this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null)}async createCrystalSoul(e={}){const{coreMesh:t,geometryType:i}=e;if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!t)return null;await Od._loadInclusionGeometry(this.assetBasePath),this.crystalSoul=new Od({radius:.35,detail:1,geometryType:i,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(t,this.renderer?.scene);const{shellBaseScale:a,soulScale:n}=this._getCrystalScaleConfig(i);return this.crystalSoul.baseScale=n,this.crystalSoul.mesh.scale.setScalar(n),this.crystalSoul.setVisible(this.coreGlowEnabled),{mesh:this.crystalSoul.mesh,material:this.crystalSoul.material,baseScale:this.crystalSoul.baseScale,shellBaseScale:a}}createCrystalSoulSync(e={}){const{coreMesh:t,geometryType:i}=e;if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!t)return null;this.crystalSoul=new Od({radius:.35,detail:1,geometryType:i,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(t,this.renderer?.scene);const{shellBaseScale:a,soulScale:n}=this._getCrystalScaleConfig(i);return this.crystalSoul.baseScale=n,this.crystalSoul.mesh.scale.setScalar(n),this.crystalSoul.setVisible(this.coreGlowEnabled),{mesh:this.crystalSoul.mesh,material:this.crystalSoul.material,baseScale:this.crystalSoul.baseScale,shellBaseScale:a}}_getCrystalScaleConfig(e){let t=2,i=1;return"heart"===e?(t=2.4,i=1):"rough"===e?(t=1.6,i=1):"star"===e?(t=2,i=1.4):"crystal"===e&&(t=2,i=1),{shellBaseScale:t,soulScale:i}}setSolarEclipse(e){return!!this.solarEclipse&&(this.solarEclipse.setEclipseType(e),!0)}setLunarEclipse(e){return!!this.lunarEclipse&&(this.lunarEclipse.setEclipseType(e),!0)}stopAllEclipses(){this.solarEclipse&&this.solarEclipse.setEclipseType("off"),this.lunarEclipse&&this.lunarEclipse.setEclipseType("off")}updateCrystalSoul(e,t,i=1){this.crystalSoul&&this.crystalSoul.update(e,t,i)}updateLunarEclipse(e){this.lunarEclipse&&this.lunarEclipse.update(e)}setCrystalSoulEffects(e){this.crystalSoul&&this.crystalSoul.setEffects(e)}setCrystalSoulSize(e){return this.crystalSoul?(this.crystalSoul.setSize(e),this.crystalSoul.baseScale):1}setCrystalSoulVisible(e){this.coreGlowEnabled=e,this.crystalSoul&&this.crystalSoul.setVisible(e)}hasCrystalSoul(){return!!this.crystalSoul}getCrystalSoulBaseScale(){return this.crystalSoul?.baseScale??1}hasSolarEclipse(){return!!this.solarEclipse}hasLunarEclipse(){return!!this.lunarEclipse}getSolarEclipse(){return this.solarEclipse}dispose(){this.solarEclipse&&(this.solarEclipse.dispose(),this.solarEclipse=null),this.lunarEclipse&&(this.lunarEclipse.dispose(),this.lunarEclipse=null),this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),this.renderer=null}}class Im{constructor(e={},t=null,i=null){if(this.config=e,this.rhythmEngine=t,this.geometryRotation=i,this.type=e.type||"gentle",this.speed=e.speed||1,i&&void 0!==i.baseSpeed){const e=i.baseSpeed,t=i.axes||[0,1,0];this.axes=[t[0]*e*this.speed,t[1]*e*this.speed,t[2]*e*this.speed]}else this.axes=e.axes||[0,.01,0];this.shake=e.shake||{amplitude:0,frequency:0},this.wobbleEnabled=!0,this.eruption=e.eruption||{enabled:!1},this.eruption.enabled&&(this.eruption.interval=this.eruption.interval||3e3,this.eruption.speedMultiplier=this.eruption.speedMultiplier||3,this.eruption.duration=this.eruption.duration||400,this.eruption.nextEruptionTime=this.eruption.interval,this.eruption.eruptionStartTime=-1),this.musicSync=void 0!==e.musicSync&&e.musicSync,this.time=0,this.episodicWobble={enabled:!1,minInterval:2e3,maxInterval:5e3,amplitude:.05,duration:200,nextWobbleTime:0,wobbleStartTime:-1,wobbleTarget:[0,0,0]}}update(e,t){switch(this.time+=e,this.episodicWobble.enabled&&this.wobbleEnabled&&this._applyEpisodicWobble(e,t),this.type){case"gentle":default:return this._evaluateGentle(e,t);case"unstable":return this._evaluateUnstable(e,t);case"rhythmic":return this._evaluateRhythmic(e,t);case"orbital":return this._evaluateOrbital(e,t);case"still":return this._evaluateStill(e,t);case"suspicious":return this._evaluateSuspicious(e,t)}}_evaluateGentle(e,t){const i=.001*e;return t[0]+=this.axes[0]*this.speed*i,t[1]+=this.axes[1]*this.speed*i,t[2]+=this.axes[2]*this.speed*i,t}_evaluateUnstable(e,t){const i=.001*e;let a=1;if(this.eruption.enabled&&(this.eruption.eruptionStartTime<0&&this.time>=this.eruption.nextEruptionTime&&(this.eruption.eruptionStartTime=this.time),this.eruption.eruptionStartTime>=0)){const e=this.time-this.eruption.eruptionStartTime;if(e<this.eruption.duration){const t=e/this.eruption.duration,i=Math.sin(t*Math.PI);a=1+(this.eruption.speedMultiplier-1)*i}else this.eruption.eruptionStartTime=-1,this.eruption.nextEruptionTime=this.time+this.eruption.interval}const n=this.speed*a;if(t[0]+=this.axes[0]*n*i,t[1]+=this.axes[1]*n*i,t[2]+=this.axes[2]*n*i,this.wobbleEnabled){const e=.001*this.time,i=this.shake.frequency||8,a=this.shake.amplitude||.02,n=.02,s=Math.min(a,n),r=Math.sin(e*i*Math.PI*2)*s*.7,o=Math.sin(e*i*Math.PI*2*1.3)*s*.5,l=Math.sin(e*i*Math.PI*2*.9)*s*.8;t[0]+=r,t[1]+=o,t[2]+=l}return t}_evaluateRhythmic(e,t){const i=.001*e;if(!this.musicSync||!this.rhythmEngine)return this._evaluateGentle(e,t);{const e=60/(this.rhythmEngine.bpm||120),a=.001*this.time%e,n=1+.3*Math.sin(a/e*Math.PI*2);t[0]+=this.axes[0]*this.speed*n*i,t[1]+=this.axes[1]*this.speed*n*i,t[2]+=this.axes[2]*this.speed*n*i}return t}_evaluateOrbital(e,t){const i=.001*e,a=.001*this.time,n=.5*this.speed,s=.1*Math.sin(a*n*Math.PI*2),r=.05*Math.sin(a*n*Math.PI*2*.5);return t[0]+=s*i,t[1]+=this.axes[1]*this.speed*i,t[2]+=r*i,t}_evaluateStill(e,t){const i=.001*e;return t[0]+=.1*this.axes[0]*i,t[1]+=.1*this.axes[1]*i,t[2]+=.1*this.axes[2]*i,t}_evaluateSuspicious(e,t){const i=.001*e,a=.001*this.time,n=4/this.speed,s=a%n/n;let r;if(s<.85)r=s/.85*Math.PI;else{const e=(s-.85)/.15;r=Math.PI*(1-e)}const o=r-t[1];return t[1]+=3*o*i,t}reset(){this.time=0}_applyEpisodicWobble(e,t){const i=this.episodicWobble;if(-1===i.wobbleStartTime&&this.time>=i.nextWobbleTime){i.wobbleStartTime=this.time,i.wobbleTarget=[(Math.random()-.5)*i.amplitude,(Math.random()-.5)*i.amplitude,(Math.random()-.5)*i.amplitude];const e=i.minInterval+Math.random()*(i.maxInterval-i.minInterval);i.nextWobbleTime=this.time+e}if(-1!==i.wobbleStartTime){const e=this.time-i.wobbleStartTime,a=Math.min(e/i.duration,1);if(a<1){const e=Math.sin(a*Math.PI);t[0]+=i.wobbleTarget[0]*e,t[1]+=i.wobbleTarget[1]*e,t[2]+=i.wobbleTarget[2]*e}else i.wobbleStartTime=-1}}updateConfig(e){if(this.config=e,this.type=e.type||"gentle",this.speed=e.speed||1,this.geometryRotation&&void 0!==this.geometryRotation.baseSpeed){const e=this.geometryRotation.baseSpeed,t=this.geometryRotation.axes||[0,1,0];this.axes=[t[0]*e*this.speed,t[1]*e*this.speed,t[2]*e*this.speed]}else this.axes=e.axes||[0,.01,0];this.shake=e.shake||{amplitude:0,frequency:0},this.musicSync=void 0!==e.musicSync&&e.musicSync}applyUndertoneMultipliers(e){if(void 0!==e.speedMultiplier&&(this.speed*=e.speedMultiplier),void 0!==e.shakeMultiplier&&this.shake.amplitude&&(this.shake.amplitude*=e.shakeMultiplier),void 0!==e.enableEpisodicWobble&&(this.episodicWobble.enabled=e.enableEpisodicWobble,this.episodicWobble.enabled&&0===this.episodicWobble.nextWobbleTime)){const e=this.episodicWobble.minInterval+Math.random()*(this.episodicWobble.maxInterval-this.episodicWobble.minInterval);this.episodicWobble.nextWobbleTime=this.time+e}}setWobbleEnabled(e){this.wobbleEnabled=e}}class Om{constructor(e={}){this.config=e,this.strength=void 0!==e.strength?e.strength:.5,this.damping=void 0!==e.damping?e.damping:.8,this.centerOfMass=e.centerOfMass||[0,-.3,0],this.axes=e.axes||{pitch:!0,roll:!0,yaw:!1},this.angularVelocity={x:0,y:0,z:0}}update(e,t){if(0===this.strength)return t;const i=.001*e,a=t[0],n=t[1],s=t[2];if(this.axes.pitch){const e=-a*this.strength;this.angularVelocity.x+=e*i,this.angularVelocity.x*=1-this.damping,t[0]+=this.angularVelocity.x*i}if(this.axes.roll){const e=-s*this.strength;this.angularVelocity.z+=e*i,this.angularVelocity.z*=1-this.damping,t[2]+=this.angularVelocity.z*i}if(this.axes.yaw){const e=-n*this.strength;this.angularVelocity.y+=e*i,this.angularVelocity.y*=1-this.damping,t[1]+=this.angularVelocity.y*i}return t}reset(){this.angularVelocity={x:0,y:0,z:0}}updateConfig(e){this.config=e,this.strength=void 0!==e.strength?e.strength:this.strength,this.damping=void 0!==e.damping?e.damping:this.damping,this.centerOfMass=e.centerOfMass||this.centerOfMass,this.axes=e.axes||this.axes}applyUndertoneMultipliers(e){void 0!==e.strengthMultiplier&&(this.strength*=e.strengthMultiplier)}}class Rm{constructor(t={},i=null){this.config=t,this.camera=i,this.strength=void 0!==t.strength?t.strength:1,this.lockedFace=t.lockedFace||[0,0,1],this.calibrationRotation=t.calibrationRotation||[0,0,0],this.lerpSpeed=void 0!==t.lerpSpeed?t.lerpSpeed:1,this.tempVector=new e.Vector3,this.tempQuaternion=new e.Quaternion,this.targetQuaternion=new e.Quaternion,this.calibrationQuaternion=new e.Quaternion,this.currentQuaternion=new e.Quaternion,this._lockedFaceVec=new e.Vector3,this._targetMatrix=new e.Matrix4,this._lookAtOrigin=new e.Vector3(0,0,0),this._upVector=new e.Vector3(0,1,0),this._tempEuler=new e.Euler(0,0,0,"XYZ"),this._defaultPosition=new e.Vector3(0,0,0)}update(e,t,i){if(0===this.strength||!this.camera)return t;const a=i||this._defaultPosition,n=.001*e;this.tempVector.copy(this.camera.position).sub(a),this.tempVector.lengthSq()<1e-4&&this.tempVector.set(0,0,1),this.tempVector.normalize(),this._lockedFaceVec.set(this.lockedFace[0],this.lockedFace[1],this.lockedFace[2]).normalize(),this._targetMatrix.lookAt(this.tempVector,this._lookAtOrigin,this._upVector),this.targetQuaternion.setFromRotationMatrix(this._targetMatrix),0===this.calibrationRotation[0]&&0===this.calibrationRotation[1]&&0===this.calibrationRotation[2]||(this._tempEuler.set(this.calibrationRotation[0],this.calibrationRotation[1],this.calibrationRotation[2],"XYZ"),this.calibrationQuaternion.setFromEuler(this._tempEuler),this.targetQuaternion.multiply(this.calibrationQuaternion)),this._tempEuler.set(t[0],t[1],t[2],"XYZ"),this.currentQuaternion.setFromEuler(this._tempEuler);const s=Math.min(1,this.strength*this.lerpSpeed*n*60);return this.currentQuaternion.slerp(this.targetQuaternion,s),this._tempEuler.setFromQuaternion(this.currentQuaternion,"XYZ"),t[0]=this._tempEuler.x,t[1]=this._tempEuler.y,t[2]=this._tempEuler.z,t}setCamera(e){this.camera=e}setCalibrationRotation(e){this.calibrationRotation=e}updateConfig(e){this.config=e,this.strength=void 0!==e.strength?e.strength:this.strength,this.lockedFace=e.lockedFace||this.lockedFace,this.calibrationRotation=e.calibrationRotation||this.calibrationRotation,this.lerpSpeed=void 0!==e.lerpSpeed?e.lerpSpeed:this.lerpSpeed}dispose(){this.camera=null,this.tempVector=null,this.tempQuaternion=null,this.targetQuaternion=null,this.calibrationQuaternion=null,this.currentQuaternion=null}}const Em={strength:5,damping:.85,centerOfMass:[0,-.3,0],axes:{pitch:!0,roll:!0,yaw:!1}};class Bm{constructor(e={}){this.rotationBehavior=null,this.rightingBehavior=null,this.facingBehavior=null,this.rotationDisabled=e.rotationDisabled||!1,this.wobbleEnabled=!1!==e.wobbleEnabled,this.rhythmEngine=e.rhythmEngine||null,this.camera=e.camera||null,this.geometryType=null,this.rightingBehavior=new Om(Em)}configureForEmotion(e={}){const{geometryType:t,emotionData:i,facingConfig:a,geometryRotation:n}=e;if(this.geometryType=t,"moon"===t)return this._disableRotation(),void this._initFacingBehavior(a);this._disposeFacingBehavior(),this.rotationDisabled?this._disableRotation():(i?.["3d"]?.rotation?this._configureRotationFromEmotion(i["3d"].rotation,n):this._ensureDefaultRotation(n),this.rightingBehavior&&this.rightingBehavior.reset())}applyUndertone(e){e&&(e.rotation&&this.rotationBehavior&&this.rotationBehavior.applyUndertoneMultipliers(e.rotation),e.righting&&this.rightingBehavior&&this.rightingBehavior.applyUndertoneMultipliers(e.righting))}update(e,t){this.rotationBehavior?this.rotationBehavior.update(e,t):"moon"===this.geometryType||this.rotationDisabled||(t[1]+=3e-4*e),this.rightingBehavior&&this.rightingBehavior.update(e,t),this.facingBehavior&&(t[0]=0,t[1]=0,t[2]=0)}setWobbleEnabled(e){this.wobbleEnabled=e,this.rotationBehavior&&this.rotationBehavior.setWobbleEnabled(e),!e&&this.rightingBehavior&&this.rightingBehavior.reset()}resetRighting(){this.rightingBehavior&&this.rightingBehavior.reset()}getAngularVelocity(){return this.rotationBehavior?this.rotationBehavior.axes:[0,0,0]}hasRotationBehavior(){return!!this.rotationBehavior}hasFacingBehavior(){return!!this.facingBehavior}configureForMorph(e={}){const{targetGeometryType:t,emotionData:i,facingConfig:a,geometryRotation:n}=e;this.resetRighting(),this.configureForEmotion({geometryType:t,emotionData:i,facingConfig:a,geometryRotation:n})}_configureRotationFromEmotion(e,t){this.rotationBehavior?this.rotationBehavior.updateConfig(e):this.rotationBehavior=new Im(e,this.rhythmEngine,t),this.rotationBehavior.setWobbleEnabled(this.wobbleEnabled)}_ensureDefaultRotation(e){this.rotationBehavior||(this.rotationBehavior=new Im({type:"gentle",speed:1,axes:[0,.01,0]},this.rhythmEngine,e),this.rotationBehavior.setWobbleEnabled(this.wobbleEnabled))}_disableRotation(){this.rotationBehavior=null}_initFacingBehavior(e){!this.facingBehavior&&e?.enabled&&(this.facingBehavior=new Rm({strength:e.strength,lockedFace:e.lockedFace,lerpSpeed:e.lerpSpeed,calibrationRotation:e.calibrationRotation},this.camera))}_disposeFacingBehavior(){this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null)}dispose(){this.rotationBehavior&&(this.rotationBehavior.destroy?.(),this.rotationBehavior=null),this.rightingBehavior&&(this.rightingBehavior.destroy?.(),this.rightingBehavior=null),this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null)}}class Fm{constructor(){this._phase=null,this._startTime=0,this._duration=0,this._startScale=1,this._targetScale=1,this._currentScale=1}startPhase(e,t){const i=Math.max(.5,Math.min(30,t));switch(this._startScale=this._currentScale,this._startTime=performance.now(),this._duration=1e3*i,this._phase=e,e){case"inhale":this._targetScale=1.3;break;case"exhale":this._targetScale=.85;break;default:this._targetScale=this._startScale}}stop(){this._phase=null,this._currentScale=1,this._startScale=1,this._targetScale=1}isActive(){return null!==this._phase}getPhase(){return this._phase}update(e){if(!this._phase)return this._currentScale;const t=performance.now()-this._startTime,i=Math.min(1,t/this._duration),a=Math.sin(i*Math.PI/2);return this._currentScale=this._startScale+(this._targetScale-this._startScale)*a,i>=1&&(this._currentScale=this._targetScale,this._phase=null),this._currentScale}getScaleMultiplier(){return this._currentScale}getState(){return{phase:this._phase,startScale:this._startScale,targetScale:this._targetScale,currentScale:this._currentScale,duration:this._duration,isActive:null!==this._phase}}dispose(){this._phase=null}}class zm{static generate(e,t={}){const{shardCount:i=30,minShardSize:a=.05,seed:n=Date.now(),preserveUVs:s=!0}=t,r=e.index?e:this._toIndexed(e),o=r.getAttribute("position"),l=r.getIndex(),c=r.getAttribute("uv"),h=r.getAttribute("normal");if(!l||0===l.count)return console.warn("ShardGenerator: No valid indices found"),[];const u=l.count/3;if(0===u)return console.warn("ShardGenerator: No faces found"),[];const d=this._buildAdjacencyGraph(l,u),m=Math.min(i,u);return this._clusterFaces(d,m,u,n).filter(e=>e.length>0).map(e=>this._createShardGeometry(e,o,l,s?c:null,h))}static _toIndexed(e){const t=e.getAttribute("position"),i=[];for(let e=0;e<t.count;e++)i.push(e);const a=e.clone();return a.setIndex(i),a}static _buildAdjacencyGraph(e,t){const i=new Map,a=new Map;for(let n=0;n<t;n++){const t=e.getX(3*n),s=e.getX(3*n+1),r=e.getX(3*n+2);[[Math.min(t,s),Math.max(t,s)],[Math.min(s,r),Math.max(s,r)],[Math.min(r,t),Math.max(r,t)]].forEach(([e,t])=>{const i=`${e},${t}`;a.has(i)||a.set(i,[]),a.get(i).push(n)}),i.set(n,new Set)}for(const e of a.values())2===e.length&&(i.get(e[0]).add(e[1]),i.get(e[1]).add(e[0]));return i}static _clusterFaces(e,t,i,a){const n=this._seededRandom(a),s=new Array(i).fill(-1),r=[],o=[],l=[...Array(i).keys()];for(let e=0;e<t&&0!==l.length;e++){const e=Math.floor(n()*l.length);o.push(l.splice(e,1)[0])}o.forEach((e,t)=>{r.push([e]),s[e]=t});let c=!0,h=0;const u=2*i;for(;c&&h<u;){c=!1,h++;for(let t=0;t<r.length;t++){const i=r[t],a=[];for(const n of i){const i=e.get(n);if(i)for(const e of i)-1===s[e]&&(s[e]=t,a.push(e),c=!0)}r[t]=[...i,...a]}}for(let e=0;e<i;e++)if(-1===s[e]){let t=1/0,i=0;for(let e=0;e<r.length;e++)r[e].length<t&&(t=r[e].length,i=e);r[i].push(e),s[e]=i}return r}static _createShardGeometry(t,i,a,n,s){const r=[],o=[],l=[],c=[],h=new Map;let u=1/0,d=1/0,m=1/0,p=-1/0,g=-1/0,f=-1/0;for(const e of t){const t=[a.getX(3*e),a.getX(3*e+1),a.getX(3*e+2)].map(e=>{if(!h.has(e)){const t=r.length/3;h.set(e,t);const a=i.getX(e),c=i.getY(e),y=i.getZ(e);r.push(a,c,y),u=Math.min(u,a),d=Math.min(d,c),m=Math.min(m,y),p=Math.max(p,a),g=Math.max(g,c),f=Math.max(f,y),n&&o.push(n.getX(e),n.getY(e)),s&&l.push(s.getX(e),s.getY(e),s.getZ(e))}return h.get(e)});c.push(...t)}const y=new e.BufferGeometry;y.setAttribute("position",new e.Float32BufferAttribute(r,3)),o.length>0&&y.setAttribute("uv",new e.Float32BufferAttribute(o,2)),l.length>0?y.setAttribute("normal",new e.Float32BufferAttribute(l,3)):y.computeVertexNormals(),y.setIndex(c);const v=new e.Vector3((u+p)/2,(d+g)/2,(m+f)/2);y.userData.centroid=v;const b=(p-u)*(g-d)*(f-m);return y.userData.volume=Math.max(b,.001),y.computeBoundingBox(),y.computeBoundingSphere(),y}static _seededRandom(e){let t=e%2147483647;return t<=0&&(t+=2147483646),()=>(t=1103515245*t+12345&2147483647,t/2147483647)}static hashGeometry(e){const t=e.getAttribute("position");if(!t)return`empty_${Date.now()}`;let i=0;const a=Math.min(t.count,50),n=Math.max(1,Math.floor(t.count/a));for(let e=0;e<t.count;e+=n)i^=1e3*t.getX(e)|0,i^=1e3*t.getY(e)<<8,i^=1e3*t.getZ(e)<<16,i=31*i|0;return`geo_${t.count}_${Math.abs(i).toString(16)}`}}const Lm={crystal:t=>{const i=t?.uniforms;return{type:"physical",color:i?.emotionColor?.value?.clone()||new e.Color(10053375),emissive:i?.glowColor?.value?.clone()||new e.Color(6697932),emissiveIntensity:.4,transmission:.3,roughness:.15,metalness:0,ior:1.5,thickness:.2,iridescence:.2,clearcoat:.3,map:null}},rough:t=>{const i=t?.uniforms;return{type:"physical",color:i?.emotionColor?.value?.clone()||new e.Color(8939229),emissive:i?.glowColor?.value?.clone()||new e.Color(5583786),emissiveIntensity:.3,transmission:.2,roughness:.35,metalness:0,ior:1.4,thickness:.2,iridescence:.1,clearcoat:.2,map:null}},heart:t=>{const i=t?.uniforms;return{type:"physical",color:i?.emotionColor?.value?.clone()||new e.Color(16729224),emissive:i?.glowColor?.value?.clone()||new e.Color(13378150),emissiveIntensity:.5,transmission:.25,roughness:.2,metalness:0,ior:1.5,thickness:.2,iridescence:.15,clearcoat:.25,map:null}},star:t=>{const i=t?.uniforms;return{type:"physical",color:i?.emotionColor?.value?.clone()||new e.Color(16768324),emissive:i?.glowColor?.value?.clone()||new e.Color(16755200),emissiveIntensity:.7,transmission:.2,roughness:.1,metalness:.1,ior:1.6,thickness:.15,iridescence:.3,clearcoat:.4,map:null}},sun:t=>{const i=t?.uniforms;return{type:"physical",color:i?.coreColor?.value?.clone()||new e.Color(16755200),emissive:i?.coronaColor?.value?.clone()||new e.Color(16737792),emissiveIntensity:2,transmission:0,roughness:.3,metalness:0,ior:1,thickness:0,iridescence:0,clearcoat:0,map:null}},moon:t=>{const i=t?.uniforms;return{type:"physical",color:new e.Color(16777215),emissive:new e.Color(8947848),emissiveIntensity:.15,transmission:0,roughness:.85,metalness:0,ior:1,thickness:0,iridescence:0,clearcoat:0,map:i?.colorMap?.value||null,normalMap:i?.normalMap?.value||null}},sphere:e=>Lm.default(e),default:t=>{const i=t?.uniforms;return i?{type:"physical",color:i.color?.value?.clone()||i.baseColor?.value?.clone()||i.diffuse?.value?.clone()||new e.Color(8947848),emissive:i.emissive?.value?.clone()||i.glowColor?.value?.clone()||new e.Color(0),emissiveIntensity:i.emissiveIntensity?.value??.3,transmission:0,roughness:i.roughness?.value??.5,metalness:i.metalness?.value??0,ior:1,thickness:0,iridescence:0,clearcoat:0,map:i.map?.value||i.diffuseMap?.value||null}:{type:"physical",color:t?.color?.clone()||new e.Color(8947848),emissive:t?.emissive?.clone()||new e.Color(0),emissiveIntensity:t?.emissiveIntensity??0,transmission:t?.transmission??0,roughness:t?.roughness??.5,metalness:t?.metalness??0,ior:t?.ior??1.5,thickness:t?.thickness??0,iridescence:t?.iridescence??0,clearcoat:t?.clearcoat??0,map:t?.map||null,normalMap:t?.normalMap||null}}};function Gm(e,t){return(Lm[t]||Lm.default)(e)}function Vm(t){const i={color:t.color,emissive:t.emissive,emissiveIntensity:t.emissiveIntensity,roughness:t.roughness,metalness:t.metalness,side:e.DoubleSide,transparent:!0,opacity:.9};return t.transmission>0&&(i.transmission=t.transmission,i.thickness=t.thickness||.2,i.ior=t.ior||1.5),t.iridescence>0&&(i.iridescence=t.iridescence,i.iridescenceIOR=1.3),t.clearcoat>0&&(i.clearcoat=t.clearcoat,i.clearcoatRoughness=.2),t.map&&(i.map=t.map),t.normalMap&&(i.normalMap=t.normalMap),new e.MeshPhysicalMaterial(i)}function Nm(e,t={}){const i=e.emissiveIntensity>=1.5,{hueRange:a=.1,satRange:n=.1,lightRange:s=.15}=t,r=e.color.clone();if(i){const e=.5*Math.random();r.r=Math.min(1,r.r+.05*e),r.g=Math.max(.35,r.g-.6*e),r.b=Math.max(0,r.b-.2*e);const t=.2*(Math.random()-.2);r.r=Math.min(1,Math.max(.8,r.r+t)),r.g=Math.min(.9,Math.max(.2,r.g+.5*t))}else r.offsetHSL((Math.random()-.5)*a,(Math.random()-.5)*n,(Math.random()-.5)*s);if(e.color=r,e.emissive){const t=e.emissive.clone();if(i){const i=.4*Math.random();t.r=Math.min(1,t.r+.1*i),t.g=Math.max(.3,t.g-.5*i),t.b=Math.max(0,t.b-.3*i);const a=.85+.55*Math.random();e.emissiveIntensity*=a}else t.offsetHSL((Math.random()-.5)*a*.5,(Math.random()-.5)*n*.5,(Math.random()-.5)*s*.5);e.emissive=t}}function jm(t={}){const{color:i=new e.Color(16755200),intensity:a=3,opacity:n=.6}=t;return new e.ShaderMaterial({uniforms:{uColor:{value:i.clone()},uIntensity:{value:a},uOpacity:{value:n}},vertexShader:"\n            void main() {\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uIntensity;\n            uniform float uOpacity;\n\n            void main() {\n                // Simple emissive fire - uniform glow, let bloom soften edges\n                vec3 fireColor = uColor * uIntensity;\n                gl_FragColor = vec4(fireColor, uOpacity);\n            }\n        ",transparent:!0,blending:e.AdditiveBlending,depthWrite:!1,side:e.DoubleSide})}class qm{constructor(t={}){const{maxShards:i=50,scene:a=null}=t;this.maxShards=i,this.scene=a,this.pool=[],this.active=[],this.shardMaterial=null,this._placeholderGeometry=null,this._tempVec3_basePos=new e.Vector3,this._tempVec3_moveDir=new e.Vector3,this._tempVec3_up=new e.Vector3(0,1,0),this._tempVec3_perpX=new e.Vector3,this._tempVec3_perpY=new e.Vector3,this._tempVec3_perpAxis=new e.Vector3,this._tempVec3_targetPos=new e.Vector3,this._tempQuat=new e.Quaternion,this._initPool()}_initPool(){this._placeholderGeometry=new e.BufferGeometry,this._placeholderGeometry.setAttribute("position",new e.Float32BufferAttribute([0,0,0,0,0,0,0,0,0],3)),this.shardMaterial=this._createShardMaterial();for(let t=0;t<this.maxShards;t++){const i=new e.Mesh(this._placeholderGeometry,this.shardMaterial);i.visible=!1,i.frustumCulled=!0,i.userData.poolIndex=t,i.userData.state=this._createShardState(),this.pool.push(i),this.scene&&this.scene.add(i)}}_createShardMaterial(){return new e.MeshPhysicalMaterial({transparent:!0,opacity:.9,side:e.DoubleSide,metalness:.1,roughness:.15,transmission:.3,thickness:.2,ior:1.5,emissive:new e.Color(0),emissiveIntensity:0,iridescence:.2,iridescenceIOR:1.3,clearcoat:.3,clearcoatRoughness:.2})}_createShardState(){return{velocity:new e.Vector3,angularVelocity:new e.Vector3,lifetime:0,maxLifetime:2e3,opacity:1,gravity:-9.8,originalPosition:new e.Vector3,originalRotation:new e.Euler,originalQuaternion:new e.Quaternion,originalScale:new e.Vector3(1,1,1),localCentroid:new e.Vector3,impactGlow:1,baseEmissiveIntensity:.5,reassemblyStartPos:new e.Vector3,reassemblyStartRot:new e.Euler,reassemblyStartQuat:new e.Quaternion,reassemblyStartScale:new e.Vector3(1,1,1),depthFactor:0,vortexPhase:0,isSuspendMode:!1,suspendProgress:0,floatPhase:Math.random()*Math.PI*2,dualMode:null,implodeStartPos:new e.Vector3,dissolveVelocity:new e.Vector3,dissolveOpacity:1,rippleDelay:0,ripplePhase:0,gravityVelocity:new e.Vector3,bounceCount:0,onFloor:!1,orbitRadius:0,orbitAngle:0,orbitSpeed:0,orbitHeight:0,orbitTilt:0,isFiery:!1,flickerPhase:0,flickerSpeed:0,scalePulsePhase:0,jitterSeed:0,distFromCenter:0,baseScale:new e.Vector3(1,1,1),basePosition:new e.Vector3,elementalType:null,elementalDrag:0,elementalBounce:0,riseSpeed:0,disperseRate:0,isSharedElementalMaterial:!1}}activate(t,i,a,n={}){const{explosionForce:s=2,rotationForce:r=5,lifetime:o=2e3,gravity:l=-9.8,inheritVelocity:c=new e.Vector3,meshPosition:h=new e.Vector3,meshQuaternion:u=new e.Quaternion,meshScale:d=new e.Vector3(1,1,1),isSuspendMode:m=!1,baseMaterial:p=null,elementalPhysics:g=null,elementalType:f=null}=n;this._elementalPhysics=g,this._elementalType=f;const y=Math.min(t.length,this.pool.length),v=[];for(let n=0;n<y&&0!==this.pool.length;n++){const y=this.pool.pop(),b=t[n];y.geometry!==this._placeholderGeometry&&y.geometry.dispose(),y.geometry=b.clone();const w=b.userData.centroid?b.userData.centroid.clone():new e.Vector3,M=w.clone();M.multiply(d),M.applyQuaternion(u),M.add(h),y.position.copy(M),y.quaternion.copy(u),y.scale.copy(d),y.userData.state.originalPosition.copy(M),y.userData.state.originalRotation.copy(y.rotation),y.userData.state.originalQuaternion.copy(y.quaternion),y.userData.state.originalScale.copy(d),y.userData.state.localCentroid.copy(w),y.userData.state.depthFactor=w.z,y.userData.state.vortexPhase=Math.random()*Math.PI*2;const S=M.clone().sub(i),x=S.length();S.normalize();const C=s*Math.max(.3,1/(1+2*x)),P=Math.max(.2,1-3*x);S.lerp(a,.6*P),S.normalize(),S.x+=.3*(Math.random()-.5),S.y+=.3*(Math.random()-.5)+.15,S.z+=.3*(Math.random()-.5),S.normalize(),y.userData.state.velocity.copy(S).multiplyScalar(C).add(c);const k=this._tempVec3_perpAxis.crossVectors(a,this._tempVec3_up.set(0,1,0)).normalize(),D=.5*P;if(y.userData.state.angularVelocity.set((Math.random()-.5)*r+k.x*D*r,(Math.random()-.5)*r+k.y*D*r,(Math.random()-.5)*r+k.z*D*r),y.userData.state.lifetime=0,y.userData.state.maxLifetime=o+(Math.random()-.5)*o*.3,y.userData.state.opacity=1,y.userData.state.gravity=l,y.userData.state.impactGlow=1,y.userData.state.baseEmissiveIntensity=.5,y.userData.state.isSuspendMode=m,y.userData.state.suspendProgress=0,y.userData.state.floatPhase=Math.random()*Math.PI*2,y.userData.state.elementalType=f,g&&(y.userData.state.elementalDrag=g.drag||0,y.userData.state.elementalBounce=g.bounce||0,y.userData.state.riseSpeed=g.riseSpeed||0,y.userData.state.disperseRate=g.disperseRate||0),p){0===n&&console.log("[SHARD_POOL] 📋 First shard material info:",{baseMaterialType:p.type,baseMaterialName:p.name,baseMaterialUserData:p.userData,isShaderMaterial:"ShaderMaterial"===p.type,hasElementalType:!!p.userData?.elementalType,elementalType:p.userData?.elementalType,uniforms:p.uniforms?Object.keys(p.uniforms):"N/A"}),y.material!==this.shardMaterial&&y.material.dispose();const e="ShaderMaterial"===p.type&&p.userData?.elementalType;if(0===n&&console.log("[SHARD_POOL] 🎨 Material decision:",{isElementalShader:e,willUseSharedMaterial:e,willClone:!e}),e)y.material=p,y.userData.state.isSharedElementalMaterial=!0;else{const e=p.clone();Nm(e),y.material=e,y.userData.state.isSharedElementalMaterial=!1}}else 0===n&&console.log("[SHARD_POOL] ⚠️ No baseMaterial provided, using default crystal material");if(y.visible=!0,y.userData.state.isSharedElementalMaterial)y.userData.state.isFiery=!1,0===n&&console.log("[SHARD_POOL] ✨ Elemental material - skipping emissive/fiery handling:",{elementalType:p.userData?.elementalType,uniformKeys:Object.keys(p.uniforms||{})});else if(y.material.map)y.material.emissiveIntensity=.5,y.userData.state.isFiery=!1;else if(y.material.emissiveIntensity>=1.5){y.userData.state.isFiery=!0;const t=y.material.emissive?.clone()||y.material.color?.clone()||new e.Color(16755200),a=.5*Math.random();t.r=Math.min(1,t.r+.05*a),t.g=Math.max(.35,t.g-.4*a),t.b=Math.max(0,t.b-.2*a);const n=M.clone().sub(i).length();y.userData.state.distFromCenter=n;const s=.5,r=Math.min(1,n/s);let o=3+1.5*Math.random();r<.3&&(t.r=Math.min(1,t.r+.1),t.g=Math.min(1,t.g+.08),o*=1.3),y.material.dispose(),y.material=jm({color:t,intensity:o,opacity:.6+.2*Math.random()}),y.userData.state.baseFireIntensity=o,y.userData.state.flickerPhase=Math.random()*Math.PI*2,y.userData.state.flickerSpeed=8+8*Math.random(),y.userData.state.scalePulsePhase=Math.random()*Math.PI*2,y.userData.state.baseScale.copy(y.scale),y.userData.state.jitterSeed=1e3*Math.random(),y.userData.state.basePosition.copy(y.position)}else y.material.emissiveIntensity=1.5,y.userData.state.isFiery=!1;this.active.push(y),v.push(y)}if(v.length>1){let e=1/0,t=-1/0;for(const i of v){const a=i.userData.state.depthFactor;e=Math.min(e,a),t=Math.max(t,a)}const i=t-e;if(i>.001)for(const t of v)t.userData.state.depthFactor=1-(t.userData.state.depthFactor-e)/i}return v.length}update(e){const t=e/1e3,i=performance.now()/1e3;for(let a=this.active.length-1;a>=0;a--){const n=this.active[a],{state:s}=n.userData;s.lifetime+=e;const r=s.lifetime/s.maxLifetime;if(r>=1)this._deactivateShard(n,a);else{if(s.isSuspendMode){const e=s.suspendProgress,a=s.gravity*(1-e);s.velocity.y+=a*t;const r=.995-.145*e;if(s.velocity.multiplyScalar(r),s.angularVelocity.multiplyScalar(r),n.position.addScaledVector(s.velocity,t),e>.5){const t=2*(e-.5),a=.8,r=.003*t,o=.001*t;n.position.y+=Math.sin(i*a+s.floatPhase)*r,n.position.x+=Math.sin(i*a*.7+1.3*s.floatPhase)*o,n.position.z+=Math.cos(i*a*.5+.7*s.floatPhase)*o}n.rotation.x+=s.angularVelocity.x*t,n.rotation.y+=s.angularVelocity.y*t,n.rotation.z+=s.angularVelocity.z*t}else s.velocity.y+=s.gravity*t,n.position.addScaledVector(s.velocity,t),n.rotation.x+=s.angularVelocity.x*t,n.rotation.y+=s.angularVelocity.y*t,n.rotation.z+=s.angularVelocity.z*t,s.velocity.multiplyScalar(.995),s.angularVelocity.multiplyScalar(.99);if(s.isFiery){const e=.1*Math.sin(i*s.flickerSpeed+s.flickerPhase)+.05*Math.sin(i*s.flickerSpeed*2.3+1.7*s.flickerPhase)+.85;s.flickerMultiplier=e;const t=3+1*Math.sin(s.scalePulsePhase),a=1+.05*Math.sin(i*t+s.scalePulsePhase);n.scale.copy(s.baseScale).multiplyScalar(a);const r=.003,o=Math.sin(12*i+s.jitterSeed)*r,l=Math.sin(15*i+1.3*s.jitterSeed)*r,c=Math.sin(10*i+.7*s.jitterSeed)*r;0===s.basePosition.lengthSq()&&s.basePosition.copy(n.position),n.position.x+=o,n.position.y+=l,n.position.z+=c}if(s.isSharedElementalMaterial&&n.material.uniforms)n.material.uniforms.uTime&&(n.material.uniforms.uTime.value=i),r>.7&&!s.isSuspendMode&&(s.opacity=1-(r-.7)/.3,n.material.uniforms.uOpacity&&(n.material.uniforms.uOpacity.value=.7*s.opacity));else if(s.isFiery&&n.material.uniforms){const e=s.flickerMultiplier||1,t=s.baseFireIntensity||3;n.material.uniforms.uIntensity.value=t*e,r>.7&&!s.isSuspendMode&&(s.opacity=1-(r-.7)/.3,n.material.uniforms.uOpacity.value=.6*s.opacity)}else{const e=n.material.map?.3:1;if(r<.2){const t=r/.2;s.impactGlow=1-t*t;const i=s.baseEmissiveIntensity+s.impactGlow*e;n.material.emissiveIntensity=i}else if(r<.5)n.material.emissiveIntensity=.8*s.baseEmissiveIntensity*e;else{const t=(r-.5)/.5;n.material.emissiveIntensity=s.baseEmissiveIntensity*(1-t)*e}r>.7&&!s.isSuspendMode&&(s.opacity=1-(r-.7)/.3,n.material.opacity=.9*s.opacity)}if(r>.8&&!s.isSuspendMode){const e=1-(r-.8)/.2*.5;n.scale.copy(s.originalScale).multiplyScalar(e)}}}}_deactivateShard(e,t){e.visible=!1,e.scale.set(1,1,1),e.userData.state.isFiery=!1,e.userData.state.basePosition.set(0,0,0),e.material!==this.shardMaterial&&(e.userData.state.isSharedElementalMaterial||e.material.dispose(),e.material=this.shardMaterial),e.userData.state.isSharedElementalMaterial=!1,this.active.splice(t,1),this.pool.push(e)}captureCurrentPositions(){for(const e of this.active){const{state:t}=e.userData;t.reassemblyStartPos.copy(e.position),t.reassemblyStartRot.copy(e.rotation),t.reassemblyStartQuat.copy(e.quaternion),t.reassemblyStartScale.copy(e.scale)}}updateReassembly(e,t=null){const i=performance.now()/1e3;for(const a of this.active){const{state:n}=a.userData;let s,r,o;t&&n.localCentroid?(s=this._tempVec3_targetPos.copy(n.localCentroid).multiply(t.scale).applyQuaternion(t.quaternion).add(t.position),r=t.quaternion,o=n.originalScale):(s=n.originalPosition,r=n.originalQuaternion,o=n.originalScale);const l=.3*n.depthFactor,c=Math.max(0,(e-l)/(1-l)),h=Math.min(1,c),u=this._tempVec3_basePos.lerpVectors(n.reassemblyStartPos,s,h),d=.15*Math.sin(h*Math.PI),m=n.vortexPhase+h*Math.PI*2,p=d*(1-h),g=this._tempVec3_moveDir.subVectors(s,n.reassemblyStartPos).normalize(),f=this._tempVec3_up.set(0,1,0),y=this._tempVec3_perpX.crossVectors(g,f).normalize(),v=this._tempVec3_perpY.crossVectors(y,g).normalize();let b;if(u.addScaledVector(y,Math.cos(m)*p),u.addScaledVector(v,Math.sin(m)*p),a.position.copy(u),this._tempQuat.slerpQuaternions(n.reassemblyStartQuat,r,h),a.quaternion.copy(this._tempQuat),a.scale.lerpVectors(n.reassemblyStartScale,o,h),h<.3){const e=8*i+n.vortexPhase;b=.3+(.5+.15*Math.sin(e))*h}else if(h<.7){const e=(h-.3)/.4;b=.5+.8*e+.1*Math.sin(12*i+n.vortexPhase)*(1-e)}else if(h<.95){const e=(h-.7)/.25;b=1.3+e*e*1.2}else b=2.5-(h-.95)/.05*1.5;a.material.emissiveIntensity=b;const w=.7+.2*h;a.material.opacity=Math.min(.9,w)}}updateSuspendProgress(e){for(const t of this.active)t.userData.state.suspendProgress=e}initImplodeMode(e={}){for(const e of this.active){const{state:t}=e.userData;t.dualMode="implode",t.implodeStartPos.copy(e.position),t.vortexPhase=Math.random()*Math.PI*2}}initDissolveMode(e={}){const t=e.windDirection||[1,.2,0],i=e.windForce||2,a=e.turbulence||.5;for(const e of this.active){const{state:n}=e.userData;n.dualMode="dissolve",n.dissolveOpacity=1,n.dissolveVelocity.set(t[0]*i+(Math.random()-.5)*a,t[1]*i+(Math.random()-.5)*a,t[2]*i+(Math.random()-.5)*a),n.floatPhase=Math.random()*Math.PI*2}}initGravityMode(e={}){const t=e.gravity||-15;for(const e of this.active){const{state:i}=e.userData;i.dualMode="gravity",i.gravity=t,i.gravityVelocity.set(.5*(Math.random()-.5),0,.5*(Math.random()-.5)),i.bounceCount=0,i.onFloor=!1}}initOrbitMode(t={}){const i=t.orbitSpeed||1,a=t.radiusMultiplier||1,n=new e.Vector3;for(const e of this.active){const{state:t}=e.userData;t.dualMode="orbit";const s=e.position.clone().sub(n);t.orbitRadius=s.length()*a,t.orbitAngle=Math.atan2(s.x,s.z),t.orbitHeight=s.y,t.orbitSpeed=i*(.8+.4*Math.random()),t.orbitTilt=.3*(Math.random()-.5)}}applyImpulse(e,t=3,i=.4){for(const a of this.active){const{state:n}=a.userData;this._tempVec3_moveDir.set(e[0]*t+(Math.random()-.5)*i*t,e[1]*t+(Math.random()-.5)*i*t+.3,e[2]*t+(Math.random()-.5)*i*t),n.velocity.add(this._tempVec3_moveDir),n.angularVelocity.x+=6*(Math.random()-.5),n.angularVelocity.y+=6*(Math.random()-.5),n.angularVelocity.z+=6*(Math.random()-.5)}}updateImplode(e,t,i){const a=e/1e3,n=t*t*t;for(const e of this.active){const{state:s}=e.userData;if("implode"!==s.dualMode)continue;this._tempVec3_basePos.lerpVectors(s.implodeStartPos,i,n);const r=.15*(1-n),o=s.vortexPhase+t*Math.PI*4;this._tempVec3_basePos.x+=Math.cos(o)*r,this._tempVec3_basePos.z+=Math.sin(o)*r,e.position.copy(this._tempVec3_basePos);const l=1+5*n;e.rotation.x+=a*l*2,e.rotation.y+=a*l*3;const c=Math.max(.1,1-.8*n);e.scale.copy(s.originalScale).multiplyScalar(c),e.material.emissiveIntensity=.5+2*n,e.material.opacity=Math.max(.3,1-.5*n)}}updateDissolve(e,t,i={}){const a=e/1e3,n=performance.now()/1e3,s=i.turbulence||.5;for(const e of this.active){const{state:i}=e.userData;if("dissolve"!==i.dualMode)continue;this._tempVec3_moveDir.copy(i.dissolveVelocity).multiplyScalar(a),e.position.add(this._tempVec3_moveDir);const r=Math.sin(3*n+i.floatPhase)*s*.02,o=Math.sin(2*n+1.5*i.floatPhase)*s*.01,l=Math.cos(2.5*n+.8*i.floatPhase)*s*.02;e.position.x+=r,e.position.y+=o,e.position.z+=l,e.rotation.x+=.5*a,e.rotation.y+=.8*a;const c=Math.max(.05,1-t*t);e.scale.copy(i.originalScale).multiplyScalar(c),i.dissolveOpacity=Math.max(0,1-t),e.material.opacity=.9*i.dissolveOpacity,e.material.emissiveIntensity=.3*(1-t)}}updateGravityBounce(e,t,i=-1){const a=e/1e3;for(const e of this.active){const{state:n}=e.userData;if("gravity"===n.dualMode&&(n.gravityVelocity.y+=n.gravity*a,this._tempVec3_moveDir.copy(n.gravityVelocity).multiplyScalar(a),e.position.add(this._tempVec3_moveDir),e.position.y<=i&&n.bounceCount<3?(e.position.y=i,n.gravityVelocity.y*=-.5,n.gravityVelocity.x*=.8,n.gravityVelocity.z*=.8,n.bounceCount++,e.material.emissiveIntensity=.8):e.position.y<=i&&(e.position.y=i,n.gravityVelocity.set(0,0,0),n.onFloor=!0),n.onFloor||(e.rotation.x+=3*a,e.rotation.z+=2*a),e.material.emissiveIntensity=Math.max(.1,e.material.emissiveIntensity-.5*a),t>.7)){const i=(t-.7)/.3;e.material.opacity=Math.max(.1,.9-.8*i)}}}updateOrbit(e,t,i,a={}){const n=e/1e3,s=performance.now()/1e3;for(const e of this.active){const{state:t}=e.userData;if("orbit"!==t.dualMode)continue;t.orbitAngle+=t.orbitSpeed*n;const a=i.x+Math.sin(t.orbitAngle)*t.orbitRadius,r=i.z+Math.cos(t.orbitAngle)*t.orbitRadius,o=.05*Math.sin(2*s+t.floatPhase),l=i.y+t.orbitHeight+o,c=Math.sin(t.orbitAngle+t.orbitTilt)*t.orbitRadius*.1;e.position.set(a,l+c,r),e.lookAt(i),e.rotation.z+=.5*n;const h=.3+.2*Math.sin(3*s+t.floatPhase);e.material.emissiveIntensity=h;const u=1+.05*Math.sin(2*s+t.floatPhase);e.scale.copy(t.originalScale).multiplyScalar(u)}}clear(){for(let e=this.active.length-1;e>=0;e--){const t=this.active[e];t.visible=!1,t.scale.set(1,1,1),t.material!==this.shardMaterial&&(t.userData.state.isSharedElementalMaterial||t.material.dispose(),t.material=this.shardMaterial),t.userData.state.isSharedElementalMaterial=!1,this.pool.push(t)}this.active=[]}updateMaterial(e){const t=[...this.pool,...this.active];for(const i of t)e.color&&i.material.color.copy(e.color),e.emissive&&(i.material.emissive.copy(e.emissive),i.material.emissiveIntensity=e.emissiveIntensity||.3)}setScene(e){if(this.scene!==e){if(this.scene)for(const e of[...this.pool,...this.active])this.scene.remove(e);if(this.scene=e,this.scene)for(const e of[...this.pool,...this.active])this.scene.add(e)}}get activeCount(){return this.active.length}get availableCount(){return this.pool.length}dispose(){this.clear();for(const e of this.pool)this.scene&&this.scene.remove(e),e.geometry!==this._placeholderGeometry&&e.geometry.dispose(),e.material.dispose();this.pool=[],this._placeholderGeometry&&(this._placeholderGeometry.dispose(),this._placeholderGeometry=null),this.shardMaterial&&(this.shardMaterial.dispose(),this.shardMaterial=null)}}function Um(e,t,i,a){return a<.5?e+2*a*(t-e):t+2*(a-.5)*(i-t)}function Wm(t){const i=new e.Color;if(t<.3)i.setRGB(.8+.67*t,.1+1*t,0);else if(t<.7){const e=(t-.3)/.4;i.setRGB(1,.4+.5*e,.3*e)}else{const e=(t-.7)/.3;i.setRGB(1-.2*e,.9+.1*e,.3+.7*e)}return i}function Hm(t={}){const{temperature:i=.5,color:a=null,intensity:n=null,opacity:s=.7,overlay:r=!1}=t,o=a||Wm(i),l=n??Um(1.5,3,6,i),c=Um(1,2,4,i),h=Um(.15,.25,.1,i),u=new e.ShaderMaterial({uniforms:{uColor:{value:o.clone()},uIntensity:{value:l},uOpacity:{value:s},uFlickerSpeed:{value:c},uFlickerAmount:{value:h},uTime:{value:0},uTemperature:{value:i},uOverlay:{value:r?1:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewDir;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n\n                // View direction for fresnel\n                vec4 worldPos = modelMatrix * vec4(position, 1.0);\n                vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uIntensity;\n            uniform float uOpacity;\n            uniform float uFlickerSpeed;\n            uniform float uFlickerAmount;\n            uniform float uTime;\n            uniform float uTemperature;\n            uniform float uOverlay;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewDir;\n\n            // Simple noise for flicker\n            float hash(float n) {\n                return fract(sin(n) * 43758.5453);\n            }\n\n            float noise(float x) {\n                float i = floor(x);\n                float f = fract(x);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(hash(i), hash(i + 1.0), f);\n            }\n\n            // 3D noise for flame patterns\n            float hash3(vec3 p) {\n                return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\n            }\n\n            float noise3D(vec3 p) {\n                vec3 i = floor(p);\n                vec3 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n\n                return mix(\n                    mix(mix(hash3(i), hash3(i + vec3(1,0,0)), f.x),\n                        mix(hash3(i + vec3(0,1,0)), hash3(i + vec3(1,1,0)), f.x), f.y),\n                    mix(mix(hash3(i + vec3(0,0,1)), hash3(i + vec3(1,0,1)), f.x),\n                        mix(hash3(i + vec3(0,1,1)), hash3(i + vec3(1,1,1)), f.x), f.y),\n                    f.z\n                );\n            }\n\n            // FBM - Fractal Brownian Motion for richer flame patterns\n            float fbm(vec3 p) {\n                float value = 0.0;\n                float amplitude = 0.5;\n                float frequency = 1.0;\n                // 4 octaves of noise\n                for (int i = 0; i < 4; i++) {\n                    value += amplitude * noise3D(p * frequency);\n                    frequency *= 2.0;\n                    amplitude *= 0.5;\n                }\n                return value;\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewDir);\n\n                // Base fire color with intensity\n                vec3 fireColor = uColor * uIntensity;\n\n                // Flicker effect - varies intensity over time\n                float flicker = 1.0 - uFlickerAmount + uFlickerAmount * noise(uTime * uFlickerSpeed + vPosition.y * 3.0);\n\n                // Hot spots toward center of geometry\n                float centerGlow = 1.0 - length(vPosition) * 0.3;\n                centerGlow = max(0.5, centerGlow);\n\n                // Fresnel for rim flames\n                float fresnel = 1.0 - abs(dot(normal, viewDir));\n                fresnel = pow(fresnel, 2.0);\n\n                // Combine effects\n                vec3 finalColor = fireColor * flicker * centerGlow;\n\n                // Higher temperature = more uniform glow (plasma)\n                float uniformity = mix(0.7, 1.0, uTemperature);\n                finalColor = mix(finalColor * 0.8, finalColor, uniformity);\n\n                float alpha;\n\n                if (uOverlay > 0.5) {\n                    // ═══════════════════════════════════════════════════════════════\n                    // OVERLAY MODE: Visible flames at edges + sparse interior sparks\n                    // Simple approach: rim glow + occasional bright peaks\n                    // ═══════════════════════════════════════════════════════════════\n\n                    // Height for vertical bias (flames stronger at bottom)\n                    float height = (vPosition.y + 0.5);  // 0=bottom, 1=top\n                    float bottomBias = 1.0 - height * 0.6;  // 1.0 at bottom, 0.4 at top\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // EDGE FLAMES - Always visible at rim (fresnel)\n                    // ═══════════════════════════════════════════════════════════════\n                    float edgeFlame = pow(fresnel, 2.5) * 0.7 * bottomBias;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // SPARSE FLAME SPARKS - Only at bright noise peaks\n                    // ═══════════════════════════════════════════════════════════════\n                    vec3 sparkPos = vPosition * 8.0 + vec3(0.0, -uTime * 2.5, 0.0);\n                    float spark = noise3D(sparkPos);\n\n                    // Only show the brightest peaks (>0.7) as flame spots\n                    float flameSpark = smoothstep(0.65, 0.85, spark) * bottomBias;\n\n                    // Add flicker variation\n                    flameSpark *= (0.7 + flicker * 0.3);\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // COLOR: Orange-red base, yellow at bright spots\n                    // ═══════════════════════════════════════════════════════════════\n                    vec3 orangeRed = vec3(1.0, 0.4, 0.05);\n                    vec3 yellowBright = vec3(1.0, 0.75, 0.2);\n\n                    float totalIntensity = edgeFlame + flameSpark * 0.8;\n                    vec3 flameColor = mix(orangeRed, yellowBright, clamp(totalIntensity, 0.0, 1.0));\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // ALPHA: Edge flames + sparse sparks\n                    // ═══════════════════════════════════════════════════════════════\n                    alpha = edgeFlame * 0.6 + flameSpark * 0.4;\n\n                    // Moderate discard\n                    if (alpha < 0.06) discard;\n\n                    alpha = clamp(alpha, 0.0, 0.45);\n                    finalColor = flameColor;\n                } else {\n                    // STANDALONE MODE: Full fire material\n                    alpha = uOpacity;\n                }\n\n                gl_FragColor = vec4(finalColor, alpha);\n            }\n        ",transparent:!0,blending:e.AdditiveBlending,depthWrite:!1,side:e.DoubleSide});return u.userData.temperature=i,u.userData.elementalType="fire",u}function $m(e,t,i){return e+(t-e)*i}function Ym(e,t,i,a){return a<.5?e+2*a*(t-e):t+2*(a-.5)*(i-t)}function Xm(t={}){const{viscosity:i=.3,color:a=null,clarity:n=.9,opacity:s=.85,overlay:r=!1}=t,o=function(t,i){if(i)return i.clone();const a=new e.Color;if(t<.15)a.setRGB(.85,.85,.9);else if(t<.5){const e=(t-.15)/.35;a.setRGB($m(.85,.3,e),$m(.85,.5,e),$m(.9,1,e))}else if(t<.8){const e=(t-.5)/.3;a.setRGB($m(.3,.9,e),$m(.5,.7,e),$m(1,.2,e))}else a.setRGB(.4,.8,.6);return a}(i,a),l=$m(4,.3,i),c=$m(.08,.15,i),h=$m(.1,.9,i),u=$m(.3,.08,i),d=$m(2,4,i),m=$m(.98,.75,i)*n,p=Ym(1.5,1.33,1.35,i),g=new e.ShaderMaterial({uniforms:{uColor:{value:o},uTransmission:{value:m},uIOR:{value:p},uWobbleSpeed:{value:l},uWobbleAmount:{value:c},uWobbleDamping:{value:h},uRefractionStrength:{value:u},uFresnelPower:{value:d},uOpacity:{value:s},uTime:{value:0},uViscosity:{value:i},uOverlay:{value:r?1:0}},vertexShader:'\n            uniform float uWobbleSpeed;\n            uniform float uWobbleAmount;\n            uniform float uTime;\n            uniform float uViscosity;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            // Simple 3D noise for wobble\n            float hash(vec3 p) {\n                p = fract(p * 0.3183099 + 0.1);\n                p *= 17.0;\n                return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n            }\n\n            float noise(vec3 p) {\n                vec3 i = floor(p);\n                vec3 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n\n                return mix(\n                    mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n                        mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n                    mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n                        mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n                    f.z\n                );\n            }\n\n            void main() {\n                vUv = uv;\n                vNormal = normalMatrix * normal;\n\n                // Wobble displacement - more for jello, faster for mercury/water\n                vec3 pos = position;\n\n                // Time-based wobble\n                float wobbleTime = uTime * uWobbleSpeed;\n\n                // Multiple octaves for organic feel\n                float n1 = noise(pos * 3.0 + wobbleTime * 0.7);\n                float n2 = noise(pos * 5.0 - wobbleTime * 1.1) * 0.5;\n                float wobble = (n1 + n2) * uWobbleAmount;\n\n                // Displace along normal\n                pos += normal * wobble;\n\n                // For jello: add a secondary slower "jiggle"\n                if (uViscosity > 0.7) {\n                    float jiggle = sin(wobbleTime * 0.5 + pos.y * 2.0) * 0.02;\n                    pos += normal * jiggle;\n                }\n\n                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n                vViewPosition = -mvPosition.xyz;\n                vPosition = pos;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ',fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uTransmission;\n            uniform float uRefractionStrength;\n            uniform float uFresnelPower;\n            uniform float uOpacity;\n            uniform float uViscosity;\n            uniform float uTime;\n            uniform float uOverlay;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            // Simple 3D noise for internal patterns\n            float hash3(vec3 p) {\n                return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\n            }\n\n            float noise3D(vec3 p) {\n                vec3 i = floor(p);\n                vec3 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n\n                return mix(\n                    mix(mix(hash3(i), hash3(i + vec3(1,0,0)), f.x),\n                        mix(hash3(i + vec3(0,1,0)), hash3(i + vec3(1,1,0)), f.x), f.y),\n                    mix(mix(hash3(i + vec3(0,0,1)), hash3(i + vec3(1,0,1)), f.x),\n                        mix(hash3(i + vec3(0,1,1)), hash3(i + vec3(1,1,1)), f.x), f.y),\n                    f.z\n                );\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n\n                // Fresnel effect - stronger rim highlighting for wet look\n                float fresnel = pow(1.0 - abs(dot(normal, viewDir)), uFresnelPower);\n\n                // Base color - ensure it's clearly blue for water\n                vec3 baseColor = uColor;\n\n                // Internal caustic patterns using 3D position (works on any geometry)\n                float caustic1 = noise3D(vPosition * 8.0 + uTime * 0.5);\n                float caustic2 = noise3D(vPosition * 12.0 - uTime * 0.3);\n                float caustic3 = noise3D(vPosition * 4.0 + vec3(uTime * 0.2));\n                float caustics = caustic1 * caustic2 + caustic3 * 0.3;\n\n                // Moving light patterns inside the water\n                float internalLight = caustics * (0.3 + (1.0 - uViscosity) * 0.4);\n\n                // For water (low viscosity), add more caustic brightness\n                if (uViscosity < 0.5) {\n                    baseColor += vec3(0.1, 0.2, 0.3) * internalLight;\n                }\n\n                // Mercury gets bright specular highlights\n                if (uViscosity < 0.15) {\n                    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));\n                    float spec = pow(max(dot(reflect(-viewDir, normal), lightDir), 0.0), 64.0);\n                    baseColor += vec3(1.0) * spec * 0.8;\n                }\n\n                // Strong rim glow for wet/liquid appearance\n                vec3 rimColor = mix(baseColor * 1.8, vec3(0.6, 0.8, 1.0), 0.5);\n                vec3 finalColor = mix(baseColor, rimColor, fresnel * 0.7);\n\n                // Add subtle iridescence\n                float iridescence = sin(dot(normal, viewDir) * 10.0 + uTime) * 0.1;\n                finalColor += vec3(iridescence * 0.3, iridescence * 0.5, iridescence);\n\n                // Ensure water is clearly visible - boost the blue\n                finalColor = max(finalColor, baseColor * 0.5);\n\n                float alpha;\n\n                if (uOverlay > 0.5) {\n                    // OVERLAY MODE: Only show rim highlights and caustic sparkles\n                    // No uniform wash - sparse visibility like wet gleams\n\n                    // Fresnel gives strong rim/edge highlights\n                    float rimAlpha = pow(fresnel, 2.0) * 0.8;\n\n                    // Caustics give internal sparkle points\n                    float sparkle = max(0.0, caustics - 0.5) * 2.0;  // Only bright caustic peaks\n                    float sparkleAlpha = sparkle * 0.4;\n\n                    // Combine - primarily edges and sparkles\n                    alpha = rimAlpha + sparkleAlpha;\n\n                    // Brighten the color for additive blending\n                    finalColor = mix(baseColor, vec3(0.6, 0.85, 1.0), fresnel * 0.6);\n                    finalColor += vec3(0.2, 0.4, 0.6) * sparkle;\n\n                    // Discard near-invisible pixels to avoid uniform wash\n                    if (alpha < 0.05) discard;\n\n                    alpha = clamp(alpha, 0.0, 0.7);\n                } else {\n                    // STANDALONE MODE: Full opaque water material\n                    float baseAlpha = uOpacity * 0.85;\n                    float fresnelAlpha = fresnel * 0.4;\n                    alpha = baseAlpha + fresnelAlpha;\n                    alpha = clamp(alpha, 0.5, 0.95);\n                }\n\n                gl_FragColor = vec4(finalColor, alpha);\n            }\n        ",transparent:!0,side:e.DoubleSide,blending:r?e.AdditiveBlending:e.NormalBlending,depthWrite:!r});return g.userData.viscosity=i,g.userData.elementalType="water",g}function Qm(e=.3){return{gravity:$m(1,.5,e),bounce:$m(.7,.2,e),drag:$m(.01,.2,e),cohesion:Ym(.8,.2,.7,e),spreadOnImpact:$m(.3,.1,e),surfaceTension:Ym(.9,.3,.6,e),wobbleOnMove:!0,mergeOnContact:e<.6}}function Km(e,t,i){return e+(t-e)*i}function Zm(e,t,i){return e+(t-e)*i}function Jm(t={}){const{melt:i=0,color:a=null,opacity:n=.85,overlay:s=!1}=t;if(i>.8)return Xm({viscosity:Zm(.6,.3,(i-.8)/.2),color:a||new e.Color(.5,.75,1),opacity:n});const r=a||function(t){const i=new e.Color;if(t<.3)i.setRGB(.3,.5,.75);else if(t<.7){const e=(t-.3)/.4;i.setRGB(Zm(.3,.35,e),Zm(.5,.55,e),Zm(.75,.78,e))}else i.setRGB(.35,.55,.78);return i}(i),o=Zm(.7,.9,i),l=Zm(.02,.3,i),c=Zm(1,0,i),h=Zm(.8,.2,i),u=Zm(1.31,1.33,i),d=Zm(.3,.1,i),m=new e.ShaderMaterial({uniforms:{uColor:{value:r},uTransmission:{value:o},uRoughness:{value:l},uFrostAmount:{value:c},uInternalCracks:{value:h},uIOR:{value:u},uSubsurfaceScatter:{value:d},uOpacity:{value:n},uTime:{value:0},uMelt:{value:i},uOverlay:{value:s?1:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            void main() {\n                vUv = uv;\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uTransmission;\n            uniform float uRoughness;\n            uniform float uFrostAmount;\n            uniform float uInternalCracks;\n            uniform float uSubsurfaceScatter;\n            uniform float uOpacity;\n            uniform float uTime;\n            uniform float uMelt;\n            uniform float uOverlay;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            // Noise functions for frost and cracks\n            float hash(vec3 p) {\n                p = fract(p * 0.3183099 + 0.1);\n                p *= 17.0;\n                return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n            }\n\n            float noise(vec3 p) {\n                vec3 i = floor(p);\n                vec3 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n\n                return mix(\n                    mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n                        mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n                    mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n                        mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n                    f.z\n                );\n            }\n\n            // FBM for frost: layered noise gives organic frost patches\n            float fbm3(vec3 p) {\n                float f = 0.0;\n                f += 0.5000 * noise(p); p *= 2.01;\n                f += 0.2500 * noise(p); p *= 2.02;\n                f += 0.1250 * noise(p);\n                return f / 0.875;\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n\n                // Fresnel effect\n                float fresnel = pow(1.0 - abs(dot(normal, viewDir)), 3.0);\n\n                // Frost pattern: noise-based patches spreading from edges inward.\n                // NOT Voronoi cells — frost forms as organic crystalline coating.\n                // Fresnel drives where frost appears: thick at edges, thin at face-on.\n                float frostMask = 0.0;\n                if (uFrostAmount > 0.01) {\n                    // Fresnel-driven spread: frost creeps inward from silhouette edges\n                    float edgeness = pow(1.0 - abs(dot(normal, viewDir)), 1.5);\n\n                    // Multi-scale noise for organic frost texture\n                    float frostNoise = fbm3(vec3(vUv * 6.0, 0.0));\n                    float fineNoise = noise(vec3(vUv * 18.0, 0.5));\n\n                    // Frost threshold: edges always frosted, interior only where noise peaks\n                    // edgeness=1 → frost everywhere, edgeness=0 → only noise peaks > 0.65\n                    float frostThreshold = mix(0.65, 0.0, edgeness);\n                    float frost = smoothstep(frostThreshold, frostThreshold + 0.15, frostNoise);\n\n                    // Fine detail within frost patches\n                    frost += fineNoise * 0.2 * frost;\n\n                    frostMask = frost * uFrostAmount;\n                }\n\n                // Crack pattern: thin bright lines using noise gradient magnitude\n                float crackIntensity = 0.0;\n                if (uInternalCracks > 0.01) {\n                    float crackNoise = fbm3(vec3(vUv * 4.0 + 0.5, 0.3));\n                    // High-frequency detail for crack sharpness\n                    float crackDetail = noise(vec3(vUv * 12.0, 0.7));\n                    // Isolines: thin bright bands where noise crosses thresholds\n                    float crack1 = 1.0 - smoothstep(0.0, 0.02, abs(crackNoise - 0.4));\n                    float crack2 = 1.0 - smoothstep(0.0, 0.015, abs(crackNoise - 0.6));\n                    crackIntensity = max(crack1, crack2 * 0.7) * uInternalCracks;\n                    crackIntensity *= crackDetail * 0.5 + 0.5; // Detail variation\n                }\n\n                float alpha;\n                vec3 finalColor;\n\n                if (uOverlay > 0.5) {\n                    // OVERLAY MODE: Sparse highlights via additive blending\n                    // Only show frost patches, crack edges, and fresnel rim\n                    // No uniform wash - geometry-independent appearance\n\n                    // Fresnel gives strong rim/edge highlights\n                    float rimAlpha = pow(fresnel, 2.0) * 0.7;\n\n                    // Frost patches give bright frost sparkle\n                    float frostAlpha = frostMask * 0.5;\n\n                    // Crack edges give subtle structure\n                    float crackAlpha = crackIntensity * 0.3;\n\n                    // Combine\n                    alpha = rimAlpha + frostAlpha + crackAlpha;\n\n                    // Color: cold blue for ice lines, not white\n                    finalColor = mix(uColor, vec3(0.4, 0.6, 0.85), fresnel * 0.6);\n                    finalColor += vec3(0.1, 0.18, 0.35) * frostMask;\n                    finalColor += vec3(0.05, 0.08, 0.15) * crackIntensity;\n\n                    // Discard near-invisible pixels to avoid uniform wash\n                    if (alpha < 0.05) discard;\n\n                    // Clamp below bloom threshold\n                    finalColor = min(finalColor, vec3(0.78));\n                    alpha = clamp(alpha, 0.0, 0.7);\n                } else {\n                    // STANDALONE MODE: Full opaque ice material\n                    finalColor = uColor;\n\n                    // Frost patches whiten the surface\n                    vec3 frostWhite = vec3(0.6, 0.72, 0.82);\n                    finalColor = mix(finalColor, frostWhite, frostMask * 0.5);\n\n                    // Cracks brighten along fracture lines\n                    vec3 crackColor = uColor * 0.3;\n                    finalColor = mix(finalColor, crackColor, crackIntensity * 0.55);\n\n                    // Subsurface scattering\n                    vec3 scatterColor = vec3(0.4, 0.6, 0.8);\n                    float scatter = uSubsurfaceScatter * (1.0 - abs(dot(normal, viewDir)));\n                    finalColor = mix(finalColor, scatterColor, scatter * 0.25);\n\n                    // Specular highlights\n                    float specPower = mix(64.0, 16.0, uMelt);\n                    float spec = pow(max(dot(reflect(-viewDir, normal), vec3(0.5, 1.0, 0.5)), 0.0), specPower);\n                    vec3 specColor = vec3(0.6, 0.72, 0.85);\n                    finalColor = mix(finalColor, specColor, spec * (1.0 - uRoughness) * 0.35);\n\n                    // Fresnel rim\n                    vec3 rimColor = vec3(0.5, 0.65, 0.82);\n                    finalColor = mix(finalColor, rimColor, fresnel * 0.3);\n\n                    // Clamp below bloom threshold\n                    finalColor = min(finalColor, vec3(0.78));\n\n                    float baseAlpha = uOpacity * 0.85;\n                    float fresnelAlpha = fresnel * 0.3;\n                    alpha = clamp(baseAlpha + fresnelAlpha, 0.5, 0.95);\n                }\n\n                gl_FragColor = vec4(finalColor, alpha);\n            }\n        ",transparent:!0,side:e.DoubleSide,blending:s?e.AdditiveBlending:e.NormalBlending,depthWrite:!s});return m.userData.melt=i,m.userData.elementalType="ice",m}function ep(e,t,i){return e+(t-e)*i}function tp(t,i){if(i)return i.clone();const a=new e.Color;if(t<.3)a.setRGB(.6,.8,1);else if(t<.7){const e=(t-.3)/.4;a.setRGB(ep(.6,.3,e),ep(.8,1,e),1)}else{const e=(t-.7)/.3;a.setRGB(ep(.3,.9,e),1,1)}return a}function ip(t={}){const{charge:i=.5,color:a=null,opacity:n=.9}=t,s=tp(i,a),r=ep(.5,5,i),o=ep(.5,8,i),l=Math.floor(ep(2,12,i)),c=ep(.01,.04,i),h=ep(4,20,i),u=new e.ShaderMaterial({uniforms:{uColor:{value:s},uIntensity:{value:r},uArcFrequency:{value:o},uBranchCount:{value:l},uArcThickness:{value:c},uFlickerRate:{value:h},uOpacity:{value:n},uTime:{value:0},uCharge:{value:i}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewDir;\n            varying vec2 vUv;\n\n            void main() {\n                vPosition = position;\n                vUv = uv;\n\n                // World space position for view direction\n                vec4 worldPos = modelMatrix * vec4(position, 1.0);\n                vWorldPosition = worldPos.xyz;\n\n                // View direction in world space\n                vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n                // Normal in world space\n                vNormal = normalize(mat3(modelMatrix) * normal);\n\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        ",fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uIntensity;\n            uniform float uArcFrequency;\n            uniform float uBranchCount;\n            uniform float uArcThickness;\n            uniform float uFlickerRate;\n            uniform float uOpacity;\n            uniform float uTime;\n            uniform float uCharge;\n\n            varying vec3 vPosition;\n            varying vec3 vWorldPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewDir;\n            varying vec2 vUv;\n\n            // ═══════════════════════════════════════════════════════════════\n            // HASH FUNCTIONS\n            // ═══════════════════════════════════════════════════════════════\n            float hash(float n) {\n                return fract(sin(n) * 43758.5453);\n            }\n\n            vec2 hash2(vec2 p) {\n                p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n                return fract(sin(p) * 43758.5453);\n            }\n\n            vec3 hash3(vec3 p) {\n                p = vec3(\n                    dot(p, vec3(127.1, 311.7, 74.7)),\n                    dot(p, vec3(269.5, 183.3, 246.1)),\n                    dot(p, vec3(113.5, 271.9, 124.6))\n                );\n                return fract(sin(p) * 43758.5453);\n            }\n\n            // ═══════════════════════════════════════════════════════════════\n            // VORONOI WITH EDGE DISTANCE\n            // Returns: x = distance to nearest cell, y = distance to edge\n            // The EDGE DISTANCE creates thin branching lines perfect for electricity\n            // ═══════════════════════════════════════════════════════════════\n            vec2 voronoi(vec3 p, float time, float jitter) {\n                vec3 n = floor(p);\n                vec3 f = fract(p);\n\n                // First pass: find closest cell\n                float minDist = 10.0;\n                vec3 closestCell = vec3(0.0);\n                vec3 closestPoint = vec3(0.0);\n\n                for (int k = -1; k <= 1; k++) {\n                    for (int j = -1; j <= 1; j++) {\n                        for (int i = -1; i <= 1; i++) {\n                            vec3 neighbor = vec3(float(i), float(j), float(k));\n                            vec3 cellId = n + neighbor;\n\n                            // Animate cell position over time for moving electricity\n                            vec3 cellHash = hash3(cellId);\n                            vec3 cellOffset = cellHash * jitter;\n                            // Add time-based movement\n                            cellOffset += sin(time * 3.0 + cellHash * 6.28) * 0.15;\n\n                            vec3 cellPoint = neighbor + cellOffset;\n                            float d = length(cellPoint - f);\n\n                            if (d < minDist) {\n                                minDist = d;\n                                closestCell = cellId;\n                                closestPoint = cellPoint;\n                            }\n                        }\n                    }\n                }\n\n                // Second pass: find distance to nearest edge\n                // This is where the THIN LINES come from\n                float minEdgeDist = 10.0;\n\n                for (int k = -1; k <= 1; k++) {\n                    for (int j = -1; j <= 1; j++) {\n                        for (int i = -1; i <= 1; i++) {\n                            vec3 neighbor = vec3(float(i), float(j), float(k));\n                            vec3 cellId = n + neighbor;\n\n                            if (cellId == closestCell) continue;\n\n                            vec3 cellHash = hash3(cellId);\n                            vec3 cellOffset = cellHash * jitter;\n                            cellOffset += sin(time * 3.0 + cellHash * 6.28) * 0.15;\n\n                            vec3 cellPoint = neighbor + cellOffset;\n\n                            // Calculate distance to edge between cells\n                            // Edge is the perpendicular bisector of the line between cells\n                            vec3 toCenter = (closestPoint + cellPoint) * 0.5;\n                            vec3 cellDiff = normalize(cellPoint - closestPoint);\n                            float edgeDist = dot(toCenter - f, cellDiff);\n                            edgeDist = abs(edgeDist);\n\n                            minEdgeDist = min(minEdgeDist, edgeDist);\n                        }\n                    }\n                }\n\n                return vec2(minDist, minEdgeDist);\n            }\n\n            // ═══════════════════════════════════════════════════════════════\n            // 2D VORONOI FOR SECONDARY CRACKLING\n            // ═══════════════════════════════════════════════════════════════\n            float voronoi2D(vec2 p, float time) {\n                vec2 n = floor(p);\n                vec2 f = fract(p);\n\n                float minDist = 10.0;\n                vec2 closestPoint = vec2(0.0);\n                vec2 closestCell = vec2(0.0);\n\n                for (int j = -1; j <= 1; j++) {\n                    for (int i = -1; i <= 1; i++) {\n                        vec2 neighbor = vec2(float(i), float(j));\n                        vec2 cellId = n + neighbor;\n                        vec2 cellHash = hash2(cellId);\n                        vec2 cellOffset = cellHash * 0.9;\n                        cellOffset += sin(time * 5.0 + cellHash * 6.28) * 0.2;\n\n                        vec2 cellPoint = neighbor + cellOffset;\n                        float d = length(cellPoint - f);\n\n                        if (d < minDist) {\n                            minDist = d;\n                            closestPoint = cellPoint;\n                            closestCell = cellId;\n                        }\n                    }\n                }\n\n                float minEdgeDist = 10.0;\n                for (int j = -1; j <= 1; j++) {\n                    for (int i = -1; i <= 1; i++) {\n                        vec2 neighbor = vec2(float(i), float(j));\n                        vec2 cellId = n + neighbor;\n\n                        if (cellId == closestCell) continue;\n\n                        vec2 cellHash = hash2(cellId);\n                        vec2 cellOffset = cellHash * 0.9;\n                        cellOffset += sin(time * 5.0 + cellHash * 6.28) * 0.2;\n\n                        vec2 cellPoint = neighbor + cellOffset;\n\n                        vec2 toCenter = (closestPoint + cellPoint) * 0.5;\n                        vec2 cellDiff = normalize(cellPoint - closestPoint);\n                        float edgeDist = abs(dot(toCenter - f, cellDiff));\n\n                        minEdgeDist = min(minEdgeDist, edgeDist);\n                    }\n                }\n\n                return minEdgeDist;\n            }\n\n            // ═══════════════════════════════════════════════════════════════\n            // SPARK POINTS - Random flickering bright spots\n            // ═══════════════════════════════════════════════════════════════\n            float sparks(vec3 pos, float time) {\n                vec3 gridPos = pos * 12.0;\n                vec3 gridId = floor(gridPos);\n                vec3 gridUv = fract(gridPos);\n\n                float spark = 0.0;\n                for (int z = 0; z <= 1; z++) {\n                    for (int y = 0; y <= 1; y++) {\n                        for (int x = 0; x <= 1; x++) {\n                            vec3 offset = vec3(float(x), float(y), float(z));\n                            vec3 cellId = gridId + offset;\n\n                            vec3 sparkPos = hash3(cellId) * 0.8 + 0.1;\n                            float d = length(gridUv - offset - sparkPos + 0.5);\n\n                            // Irregular flicker timing\n                            float flickerSeed = dot(cellId, vec3(127.1, 311.7, 74.7));\n                            float flicker = step(0.75, fract(sin(time * 15.0 + flickerSeed) * 43758.5453));\n\n                            spark += smoothstep(0.12, 0.0, d) * flicker;\n                        }\n                    }\n                }\n\n                return spark;\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewDir);\n\n                // ═══════════════════════════════════════════════════════════════\n                // FRESNEL RIM - Subtle edge highlight\n                // ═══════════════════════════════════════════════════════════════\n                float fresnel = 1.0 - abs(dot(normal, viewDir));\n                fresnel = pow(fresnel, 3.0);\n                float rimGlow = fresnel * 0.15 * uCharge;\n\n                // ═══════════════════════════════════════════════════════════════\n                // LIGHTNING ARCS: Voronoi cell edges = thin branching lines\n                // ═══════════════════════════════════════════════════════════════\n\n                // Use VERY thin line thickness for sharp electricity\n                float lineWidth = 0.015;  // Thin lines regardless of charge\n\n                // Primary arcs - larger cells = fewer, thicker main bolts\n                float scale1 = 3.0;\n                vec2 v1 = voronoi(vPosition * scale1, uTime * 0.8, 0.85);\n                float bolt1 = 1.0 - smoothstep(0.0, lineWidth * 1.2, v1.y);\n                bolt1 = pow(bolt1, 2.0);  // Sharpen the falloff\n\n                // Secondary crackling - smaller cells = more fine detail\n                float scale2 = 6.0;\n                vec2 v2 = voronoi(vPosition * scale2, uTime * 1.2, 0.8);\n                float bolt2 = 1.0 - smoothstep(0.0, lineWidth * 0.8, v2.y);\n                bolt2 = pow(bolt2, 2.5) * 0.6;\n\n                // Tertiary micro-cracks\n                float scale3 = 10.0;\n                vec2 v3 = voronoi(vPosition * scale3, uTime * 1.6, 0.75);\n                float bolt3 = 1.0 - smoothstep(0.0, lineWidth * 0.5, v3.y);\n                bolt3 = pow(bolt3, 3.0) * 0.3;\n\n                // Combine - don't let it exceed 1.0\n                float lightning = min(bolt1 + bolt2 + bolt3, 1.0);\n\n                // ═══════════════════════════════════════════════════════════════\n                // FLICKER - Electrical pulsing\n                // ═══════════════════════════════════════════════════════════════\n                float flickerTime = uTime * uFlickerRate * 0.5;\n                float flicker = 0.7 + 0.3 * step(0.5, fract(sin(flickerTime * 11.3) * 43758.5453));\n                lightning *= flicker;\n\n                // ═══════════════════════════════════════════════════════════════\n                // SPARKS - Occasional bright point flashes\n                // ═══════════════════════════════════════════════════════════════\n                float sparkVal = sparks(vPosition, uTime) * 0.8;\n\n                // ═══════════════════════════════════════════════════════════════\n                // FINAL COLOR - Keep it CYAN, not white\n                // ═══════════════════════════════════════════════════════════════\n                float brightness = lightning + sparkVal + rimGlow;\n\n                // Color stays cyan - only the very brightest peaks go slightly white\n                vec3 cyanColor = uColor;  // Base cyan\n                vec3 brightCyan = uColor * 1.5 + vec3(0.2, 0.3, 0.4);  // Brighter cyan, slight white tint\n\n                // Mix based on brightness - mostly cyan, white only at peaks\n                float whiteMix = smoothstep(0.7, 1.0, brightness) * 0.3;\n                vec3 finalColor = mix(cyanColor, brightCyan, whiteMix);\n\n                // Apply brightness to color (capped to prevent white-out)\n                finalColor *= min(brightness * 1.5, 2.0);\n\n                // ═══════════════════════════════════════════════════════════════\n                // ALPHA: Thin lines visible, dark areas transparent\n                // ═══════════════════════════════════════════════════════════════\n                float alpha = brightness * uOpacity;\n                alpha = clamp(alpha, 0.0, 0.9);\n\n                // Discard dark pixels\n                if (alpha < 0.03) discard;\n\n                gl_FragColor = vec4(finalColor, alpha);\n            }\n        ",transparent:!0,blending:e.AdditiveBlending,depthWrite:!1,side:e.DoubleSide});return u.userData.charge=i,u.userData.elementalType="electric",u}function ap(e,t,i){return e+(t-e)*i}function np(t={}){const{depth:i=.5,innerPattern:a="swirl",opacity:n=.9}=t,s=ap(.6,1,i),r=ap(.6,0,i),o=ap(.5,1,i),l="swirl"===a?ap(.8,2.5,i):0,c="cosmic"===a?Math.floor(ap(10,200,i)):0,h=ap(1,3,i),u=ap(.05,.25,i),d={solid:0,swirl:1,cosmic:2}[a]||0,m=new e.ShaderMaterial({uniforms:{uDepth:{value:i},uCoreOpacity:{value:s},uEdgeWispiness:{value:r},uLightAbsorption:{value:o},uInnerSwirlSpeed:{value:l},uCosmicStars:{value:c},uPatternType:{value:d},uPulseSpeed:{value:h},uDistortionStrength:{value:u},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n                vUv = uv;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:'\n            uniform float uDepth;\n            uniform float uCoreOpacity;\n            uniform float uEdgeWispiness;\n            uniform float uLightAbsorption;\n            uniform float uInnerSwirlSpeed;\n            uniform float uCosmicStars;\n            uniform int uPatternType;\n            uniform float uPulseSpeed;\n            uniform float uDistortionStrength;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            // Hash functions\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float hash3(vec3 p) {\n                p = fract(p * 0.3183099 + 0.1);\n                p *= 17.0;\n                return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n            }\n\n            // 2D noise\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            // FBM for wispy tendrils\n            float fbm(vec2 p) {\n                float value = 0.0;\n                float amplitude = 0.5;\n                for (int i = 0; i < 5; i++) {\n                    value += amplitude * noise(p);\n                    p *= 2.0;\n                    amplitude *= 0.5;\n                }\n                return value;\n            }\n\n            // Swirl pattern for void interior\n            float swirl(vec2 uv, float time) {\n                vec2 centered = uv - 0.5;\n                float dist = length(centered);\n                float angle = atan(centered.y, centered.x);\n\n                // Swirling motion\n                angle += dist * 5.0 - time * uInnerSwirlSpeed;\n\n                // Create spiral arms\n                float spiral = sin(angle * 3.0 + dist * 10.0) * 0.5 + 0.5;\n                spiral = pow(spiral, 2.0);\n\n                // Fade toward center\n                float centerFade = smoothstep(0.0, 0.3, dist);\n\n                return spiral * centerFade * 0.5;\n            }\n\n            // Cosmic star field\n            float stars(vec2 uv, float count) {\n                float stars = 0.0;\n                for (float i = 0.0; i < 50.0; i++) {\n                    if (i >= count) break;\n\n                    vec2 starPos = vec2(\n                        hash(vec2(i * 13.0, 0.0)),\n                        hash(vec2(0.0, i * 17.0))\n                    );\n\n                    float dist = length(uv - starPos);\n                    float brightness = hash(vec2(i, i * 2.0));\n\n                    // Twinkle\n                    brightness *= 0.5 + 0.5 * sin(uTime * 2.0 + i * 1.7);\n\n                    // Star glow\n                    stars += smoothstep(0.02, 0.0, dist) * brightness;\n                }\n                return stars;\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n\n                // Center-based calculations\n                vec2 centeredUv = vUv * 2.0 - 1.0;\n                float distFromCenter = length(centeredUv);\n\n                // === CORE DARKNESS ===\n                // The core is pure black, getting darker with depth\n                vec3 coreColor = vec3(0.0);\n\n                // === INNER PATTERN ===\n                float innerPattern = 0.0;\n                vec3 innerColor = vec3(0.0);\n\n                if (uPatternType == 1) {\n                    // Swirl pattern - MUCH more visible\n                    innerPattern = swirl(vUv, uTime);\n                    // Bright purple/magenta swirls visible against black void\n                    innerColor = vec3(0.4, 0.0, 0.6) * innerPattern;\n                    // Add edge glow for tendrils\n                    float edgeGlow = smoothstep(0.3, 0.5, innerPattern);\n                    innerColor += vec3(0.2, 0.0, 0.35) * edgeGlow;\n                } else if (uPatternType == 2) {\n                    // Cosmic pattern - stars in the void\n                    innerPattern = stars(vUv, uCosmicStars);\n                    // Distant stars are white/blue - brighter\n                    innerColor = vec3(0.8, 0.9, 1.0) * innerPattern * 0.6;\n                }\n                // Type 0 (solid) has no inner pattern\n\n                // === EDGE TREATMENT ===\n                // Wispy edges using noise\n                float edgeNoise = fbm(vUv * 5.0 + uTime * 0.2);\n                float wispyEdge = smoothstep(0.3 - uEdgeWispiness * 0.2, 0.8, distFromCenter + edgeNoise * uEdgeWispiness * 0.5);\n\n                // Tendrils extending from edges\n                float tendrilAngle = atan(centeredUv.y, centeredUv.x);\n                float tendrils = sin(tendrilAngle * 8.0 + uTime * 0.5) * 0.5 + 0.5;\n                tendrils = pow(tendrils, 4.0) * uEdgeWispiness;\n                float tendrilDist = distFromCenter + tendrils * 0.2;\n\n                // === PULSE/BREATHE EFFECT ===\n                // More dramatic pulse (0.85 to 1.15 range)\n                float pulse = sin(uTime * uPulseSpeed) * 0.15 + 1.0;\n\n                // === COMBINE DARKNESS ===\n                // Core darkness (black absorbing) - stronger base\n                float darkness = uCoreOpacity * (1.0 - wispyEdge * 0.3) * pulse;\n\n                // Add inner pattern\n                vec3 finalColor = mix(coreColor, innerColor, innerPattern);\n\n                // === LIGHT ABSORPTION EFFECT ===\n                // This is what makes void special - it REMOVES light\n                // We use the alpha channel to indicate absorption\n                // The renderer should treat high alpha as "subtract from background"\n\n                // Dark halo around the void\n                float halo = smoothstep(1.0, 0.5, distFromCenter) - smoothstep(0.5, 0.0, distFromCenter);\n                halo *= uLightAbsorption * 0.3;\n\n                // Final alpha represents "how much to darken" - BOOSTED\n                float alpha = darkness * uOpacity * 1.3;  // 30% boost\n\n                // Edge fade for soft integration - less aggressive fade\n                float edgeFade = 1.0 - smoothstep(0.8, 1.0, tendrilDist);\n                alpha *= edgeFade;\n\n                // Deep void is more opaque - stronger boost\n                alpha = mix(alpha, min(1.0, alpha + 0.35), uDepth);\n\n                if (alpha < 0.01) discard;\n\n                // For subtractive effect: output dark color with high alpha\n                // The blending mode will handle the actual subtraction\n                gl_FragColor = vec4(finalColor, alpha);\n            }\n        ',transparent:!0,blending:e.CustomBlending,blendEquation:e.AddEquation,blendSrc:e.SrcAlphaFactor,blendDst:e.OneMinusSrcAlphaFactor,blendSrcAlpha:e.OneFactor,blendDstAlpha:e.OneMinusSrcAlphaFactor,depthWrite:!1,side:e.DoubleSide});return m.userData.depth=i,m.userData.innerPattern=a,m.userData.elementalType="void",m}const sp={fire:{create:Hm,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=.5){return{gravity:Um(-.05,-.15,-.3,e),drag:Um(.08,.05,.02,e),bounce:0,lifetime:Um(2,1.5,.8,e),fadeOut:!0,riseSpeed:Um(.5,1,2,e),flicker:!0}},crack:function(e=.5){return{color:Wm(e).getHex(),emissive:Um(1,2,4,e),animated:!0,pattern:"organic",flickerSpeed:Um(1,2,4,e)}},masterParam:"temperature"},water:{create:Xm,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:Qm,crack:function(e=.3){let t;return t=e<.15?11197951:e<.6?4491519:8978346,{color:t,emissive:$m(.3,.05,e),animated:e<.5,pattern:e>.7?"crystalline":"organic"}},masterParam:"viscosity"},smoke:{create:function(t={}){const{density:i=.5,color:a=null,opacity:n=null,additive:s=!1,overlay:r=!1,category:o="emanating",tint:l=[1,1,1],windDir:c=[0,0],swirl:h=0}=t,u=function(t,i){if(i)return i.clone();const a=Km(.9,.3,t);return new e.Color(a,a,a)}(i,a),d=n??Km(.4,.85,i),m=Km(.9,.3,i),p=Km(3,1,i),g=Km(1.5,.3,i),f=Km(.4,.05,i),y=Km(.8,.3,i),v=Km(2,.3,i),b="afflicted"===o?1:0,w=r?"afflicted"===o?e.NormalBlending:e.AdditiveBlending:s?e.AdditiveBlending:e.NormalBlending,M=new e.ShaderMaterial({uniforms:{uColor:{value:u},uOpacity:{value:d},uSoftness:{value:m},uNoiseScale:{value:p},uRiseSpeed:{value:g},uDisperseRate:{value:f},uTurbulence:{value:y},uBillboardSpin:{value:v},uTime:{value:0},uDensity:{value:i},uLifetime:{value:1},uOverlay:{value:r?1:0},uCategory:{value:b},uTint:{value:new e.Vector3(l[0],l[1],l[2])},uWindDir:{value:new e.Vector2(c[0],c[1])},uSwirl:{value:h}},vertexShader:"\n            uniform float uRiseSpeed;\n            uniform float uTurbulence;\n            uniform float uTime;\n            uniform float uLifetime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewDir;\n            varying vec2 vUv;\n            varying float vDepth;\n\n            // Noise for turbulent motion\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            void main() {\n                vUv = uv;\n                vPosition = position;\n\n                // World space for view direction calculation\n                vec4 worldPos = modelMatrix * vec4(position, 1.0);\n                vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n                // Normal in world space\n                vNormal = normalize(mat3(modelMatrix) * normal);\n\n                vec3 pos = position;\n\n                // Rising motion\n                float rise = uTime * uRiseSpeed * uLifetime;\n                pos.y += rise;\n\n                // Turbulent sideways motion\n                float turbX = noise(vec2(pos.y * 2.0 + uTime * 0.3, 0.0)) - 0.5;\n                float turbZ = noise(vec2(0.0, pos.y * 2.0 + uTime * 0.3)) - 0.5;\n                pos.x += turbX * uTurbulence * (1.0 + rise * 0.5);\n                pos.z += turbZ * uTurbulence * (1.0 + rise * 0.5);\n\n                // Expansion as it rises\n                float expansion = 1.0 + rise * 0.3;\n                pos.xz *= expansion;\n\n                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n                vDepth = -mvPosition.z;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform vec3 uColor;\n            uniform float uOpacity;\n            uniform float uSoftness;\n            uniform float uNoiseScale;\n            uniform float uDisperseRate;\n            uniform float uTime;\n            uniform float uDensity;\n            uniform float uLifetime;\n            uniform float uOverlay;\n            uniform float uCategory;\n            uniform vec3 uTint;\n            uniform vec2 uWindDir;\n            uniform float uSwirl;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewDir;\n            varying vec2 vUv;\n            varying float vDepth;\n\n            // ═══════════════════════════════════════════════════════════════\n            // NOISE FUNCTIONS\n            // ═══════════════════════════════════════════════════════════════\n            float hash3(vec3 p) {\n                return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);\n            }\n\n            float noise3D(vec3 p) {\n                vec3 i = floor(p);\n                vec3 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n\n                return mix(\n                    mix(mix(hash3(i), hash3(i + vec3(1,0,0)), f.x),\n                        mix(hash3(i + vec3(0,1,0)), hash3(i + vec3(1,1,0)), f.x), f.y),\n                    mix(mix(hash3(i + vec3(0,0,1)), hash3(i + vec3(1,0,1)), f.x),\n                        mix(hash3(i + vec3(0,1,1)), hash3(i + vec3(1,1,1)), f.x), f.y),\n                    f.z\n                );\n            }\n\n            float fbm3D(vec3 p) {\n                float value = 0.0;\n                float amplitude = 0.5;\n                // 5 octaves for smoother, more organic noise\n                for (int i = 0; i < 5; i++) {\n                    value += amplitude * noise3D(p);\n                    p *= 2.0;\n                    amplitude *= 0.5;\n                }\n                return value;\n            }\n\n            // ═══════════════════════════════════════════════════════════════\n            // SWIRL DISTORTION\n            // ═══════════════════════════════════════════════════════════════\n            vec3 applySwirl(vec3 pos, float intensity, float time) {\n                if (intensity < 0.01) return pos;\n\n                // Distance from vertical axis\n                float dist = length(pos.xz);\n                // Angle based on height and time\n                float angle = intensity * (pos.y * 3.0 + time * 0.5) * 2.0;\n\n                // Rotate around Y axis\n                float c = cos(angle);\n                float s = sin(angle);\n                return vec3(\n                    pos.x * c - pos.z * s,\n                    pos.y,\n                    pos.x * s + pos.z * c\n                );\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewDir);\n\n                // ═══════════════════════════════════════════════════════════════\n                // FRESNEL - Proper rim detection\n                // ═══════════════════════════════════════════════════════════════\n                float fresnel = 1.0 - abs(dot(normal, viewDir));\n                fresnel = pow(fresnel, 2.0);\n\n                // ═══════════════════════════════════════════════════════════════\n                // BASE SMOKE PATTERN (standalone mode)\n                // ═══════════════════════════════════════════════════════════════\n                vec3 noisePos = vPosition * uNoiseScale + vec3(0.0, uTime * 0.2, 0.0);\n                float smoke = fbm3D(noisePos);\n\n                vec3 swirl = vPosition * uNoiseScale * 1.5 + vec3(uTime * 0.1, 0.0, uTime * 0.15);\n                float swirls = fbm3D(swirl) * 0.5;\n                smoke = smoke + swirls;\n\n                smoke = mix(smoke, 0.7, uDensity * 0.6);\n\n                float distFromCenter = length(vPosition);\n                float edgeFade = 1.0 - smoothstep(0.3, 0.8, distFromCenter * (1.0 - uSoftness));\n                float disperseFade = mix(1.0, 0.3, (1.0 - uLifetime) * uDisperseRate);\n\n                // Apply tint to base color\n                vec3 smokeColor = uColor * uTint;\n                float alpha;\n\n                if (uOverlay > 0.5) {\n                    bool isAfflicted = uCategory > 0.5;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // WIND DIRECTION\n                    // ═══════════════════════════════════════════════════════════════\n                    vec3 windOffset = vec3(\n                        uWindDir.x * uTime * 0.8,\n                        isAfflicted ? 0.0 : -uTime * 1.5,  // Afflicted: no rise, Emanating: rise\n                        uWindDir.y * uTime * 0.8\n                    );\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // SWIRL DISTORTION\n                    // ═══════════════════════════════════════════════════════════════\n                    vec3 swirlPos = applySwirl(vPosition, uSwirl, uTime);\n\n                    if (isAfflicted) {\n                        // ═══════════════════════════════════════════════════════════════\n                        // AFFLICTED MODE: Surrounding, obscuring, darkening\n                        // Uses FBM for smooth organic smoke (no angular N64 look)\n                        // ═══════════════════════════════════════════════════════════════\n\n                        // Layer 1: Large swirling clouds (low frequency, smooth)\n                        vec3 cloudPos = swirlPos * 2.5 + windOffset * 0.5;\n                        float clouds = fbm3D(cloudPos);\n                        float cloudAlpha = smoothstep(0.25, 0.65, clouds);\n\n                        // Layer 2: Medium wisps (flowing motion)\n                        vec3 wispPos = swirlPos * 4.0 + windOffset + vec3(uTime * 0.15, 0.0, uTime * 0.12);\n                        float wisps = fbm3D(wispPos);\n                        float wispAlpha = smoothstep(0.3, 0.7, wisps) * 0.7;\n\n                        // Layer 3: Fine detail tendrils (high frequency, subtle)\n                        vec3 detailPos = swirlPos * 7.0 + windOffset * 1.5 + vec3(uTime * 0.25, uTime * 0.1, uTime * 0.2);\n                        float detail = fbm3D(detailPos);\n                        float detailAlpha = smoothstep(0.35, 0.75, detail) * 0.4;\n\n                        // Layer 4: Micro turbulence (adds organic texture)\n                        vec3 microPos = swirlPos * 12.0 + windOffset * 2.0 + vec3(uTime * 0.4, 0.0, uTime * 0.35);\n                        float micro = fbm3D(microPos);\n                        float microAlpha = smoothstep(0.4, 0.8, micro) * 0.25;\n\n                        // Edge wisps using fresnel - smoke at silhouette (softened)\n                        float edgeWisp = pow(fresnel, 1.5) * 0.45 * (0.5 + uDensity * 0.5);\n\n                        // Soft inner glow (distance from center)\n                        float distFromCenter = length(vPosition.xz);\n                        float innerGlow = smoothstep(0.6, 0.1, distFromCenter) * 0.2;\n\n                        // Combine all layers with soft blending\n                        alpha = cloudAlpha * 0.5 + wispAlpha + detailAlpha + microAlpha + edgeWisp + innerGlow;\n\n                        // Apply density - denser = more visible\n                        alpha *= (0.35 + uDensity * 0.65);\n\n                        // Darken color for obscuring effect (smoother gradient)\n                        float darkness = 0.4 + (1.0 - alpha * 0.7) * 0.6;\n                        smokeColor = smokeColor * darkness * 0.75;\n\n                        // Very soft discard threshold\n                        if (alpha < 0.02) discard;\n\n                        // Clamp - afflicted can be more opaque to obscure\n                        alpha = clamp(alpha, 0.0, 0.7);\n\n                    } else {\n                        // ═══════════════════════════════════════════════════════════════\n                        // EMANATING MODE: Rising wisps, edge glow\n                        // Uses FBM for smooth organic smoke\n                        // ═══════════════════════════════════════════════════════════════\n\n                        // Height bias - smoke rises, stronger at top\n                        float height = (vPosition.y + 0.5);\n                        float topBias = 0.5 + height * 0.5;\n\n                        // Layer 1: Large billowing clouds (low frequency)\n                        vec3 cloudPos = swirlPos * 2.0 + windOffset * 0.6;\n                        float clouds = fbm3D(cloudPos);\n                        float cloudAlpha = smoothstep(0.3, 0.65, clouds) * topBias * 0.5;\n\n                        // Layer 2: Rising wisp pattern (medium frequency)\n                        vec3 wispPos = swirlPos * 4.0 + windOffset;\n                        float wisp = fbm3D(wispPos);\n                        float wispAlpha = smoothstep(0.35, 0.7, wisp) * topBias;\n\n                        // Layer 3: Detail wisps (higher frequency)\n                        vec3 detailPos = swirlPos * 7.0 + windOffset * 1.3 + vec3(uTime * 0.2, 0.0, uTime * 0.15);\n                        float detail = fbm3D(detailPos);\n                        float detailAlpha = smoothstep(0.4, 0.75, detail) * 0.45 * topBias;\n\n                        // Layer 4: Fine tendrils (high frequency, subtle)\n                        vec3 tendrilPos = swirlPos * 10.0 + windOffset * 1.8 + vec3(uTime * 0.35, uTime * 0.1, uTime * 0.25);\n                        float tendril = fbm3D(tendrilPos);\n                        float tendrilAlpha = smoothstep(0.45, 0.8, tendril) * 0.25 * topBias;\n\n                        // Edge wisps using proper fresnel - smoke curls at rim (softened)\n                        float edgeWisp = pow(fresnel, 1.5) * 0.35 * topBias * (0.5 + uDensity * 0.5);\n\n                        // Combine all layers\n                        alpha = cloudAlpha + wispAlpha + detailAlpha + tendrilAlpha + edgeWisp;\n\n                        // Apply density\n                        alpha *= (0.45 + uDensity * 0.55);\n\n                        // Brighten at wisp peaks (smooth)\n                        float brightness = 0.85 + wisp * 0.3;\n                        smokeColor = smokeColor * brightness;\n\n                        // Soft discard\n                        if (alpha < 0.03) discard;\n\n                        // Clamp\n                        alpha = clamp(alpha, 0.0, 0.55);\n                    }\n\n                } else {\n                    // ═══════════════════════════════════════════════════════════════\n                    // STANDALONE MODE: Full volumetric smoke\n                    // ═══════════════════════════════════════════════════════════════\n\n                    float baseAlpha = uOpacity * smoke * edgeFade * disperseFade * uLifetime;\n                    alpha = max(baseAlpha, uOpacity * 0.3 * uLifetime);\n                    alpha = clamp(alpha, 0.0, uOpacity);\n\n                    if (alpha < 0.02) discard;\n\n                    smokeColor = mix(smokeColor, smokeColor * 1.2, smoke * 0.3);\n                }\n\n                gl_FragColor = vec4(smokeColor, alpha);\n            }\n        ",transparent:!0,blending:w,depthWrite:!1,side:e.DoubleSide});return M.userData.density=i,M.userData.elementalType="smoke",M.userData.category=o,M},update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=.5){return{gravity:Km(-.4,-.05,e),drag:Km(.05,.3,e),bounce:0,disperseOverTime:!0,disperseRate:Km(.4,.05,e),billboardRotation:Km(2,.3,e),fadeOut:!0,lifetime:Km(1.5,4,e)}},crack:function(e=.5){return{color:4473924,emissive:0,animated:!0,pattern:"wispy",emitParticles:e>.3}},masterParam:"density"},ice:{create:Jm,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=0){return e>.8?Qm(Zm(.6,.3,(e-.8)/.2)):{gravity:Zm(1.3,1,e),bounce:Zm(.1,.4,e),drag:Zm(.01,.03,e),shatterThreshold:Zm(.3,.6,e),slideOnSurface:Zm(.9,.5,e),brittleness:Zm(1,.3,e),crackOnImpact:e<.5}},crack:function(e=0){return{color:Zm(11202303,8969727,e),emissive:Zm(.4,.1,e),animated:!1,pattern:"crystalline",frostEdges:e<.5}},masterParam:"melt"},electric:{create:ip,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=.5){return{gravity:0,drag:ep(.3,.02,e),bounce:0,chainToNearby:e>.3,chainRadius:ep(.5,2,e),lifetime:ep(.3,.8,e),flickerOnMove:!0,attractToMetal:e>.5}},crack:function(e=.5){return{color:tp(e).getHex(),emissive:ep(1,6,e),animated:!0,pattern:"branching",arcBetweenCracks:e>.5}},masterParam:"charge"},void:{create:np,update:function(e,t){e?.uniforms?.uTime&&(e.uniforms.uTime.value+=t)},physics:function(e=.5){return{gravity:ap(0,.3,e),drag:ap(.2,0,e),bounce:0,gravityWell:e>.7,gravityWellStrength:e>.7?ap(0,2,(e-.7)/.3):0,disperseOverTime:e<.3,lifetime:ap(2,999,e),absorbLight:!0,corruptNearby:e>.6}},crack:function(e=.5){return{color:0,emissive:ap(-.5,-2,e),animated:!0,pattern:"veins",spreadOverTime:e>.5,corruptNearby:e>.7}},masterParam:"depth"}},rp={color:4465169,emissive:.3,animated:!1,pattern:"organic"},op={gravity:1,bounce:.3,drag:.02,lifetime:3};function lp(e,t=.5){const i=sp[e];return i?i.physics(t):{...op}}function cp(e){return e in sp}const hp={IDLE:"idle",GENERATING:"generating",SHATTERING:"shattering",FROZEN:"frozen",REASSEMBLING:"reassembling",IMPLODING:"imploding",DISSOLVING:"dissolving",FALLING:"falling",ORBITING:"orbiting"};class up{constructor(e={}){const t="undefined"!=typeof navigator&&/Android|iPhone|iPad|iPod/i.test(navigator.userAgent),{scene:i=null,maxShards:a=(t?25:50),shardLifetime:n=(t?1500:2e3),enableReassembly:s=!0,autoRestore:r=!0}=e;this.scene=i,this.maxShards=a,this.shardLifetime=n,this.enableReassembly=s,this.autoRestore=r,this.state=hp.IDLE,this.shardPool=new qm({maxShards:a,scene:i}),this.geometryCache=new Map,this.geometryCacheMaxSize=5,this.geometryCacheRefs=new Map,this._activeGeometryId=null,this.shardMaterialCache=null,this.targetMesh=null,this.innerMesh=null,this.onShatterStart=null,this.onShatterComplete=null,this.onReassemblyComplete=null,this._shatterStartTime=0,this._soulRevealProgress=0,this._soulOriginalScale=1,this._soulOriginalEmissive=0,this._soulOriginalGhostMode=.36,this._soulOriginalLayer=2,this._reassemblyDuration=1e3,this._reassemblyStartTime=0,this._reassemblyProgress=0,this._soulWasRevealed=!1,this._shatterQueue=[],this._chainedDelay=150,this._lastChainTrigger=0,this._isSuspendMode=!1,this._suspendAt=.25,this._suspendDuration=.35,this._isFreezeMode=!1,this._currentElementalMaterial=null,this._currentElemental=null,this._currentElementalParam=.5,this._dualModeType=null,this._dualModeConfig={},this._dualModeStartTime=0,this._dualModeDuration=2e3}prepareGeometry(e,t=null){const i=t||zm.hashGeometry(e);if(this.geometryCache.has(i)){const e=this.geometryCache.get(i);return this.geometryCache.delete(i),this.geometryCache.set(i,e),e}const a=zm.generate(e,{shardCount:this.maxShards,seed:this._hashString(i)});for(;this.geometryCache.size>=this.geometryCacheMaxSize;){let e=!1;for(const t of this.geometryCache.keys())if(0===(this.geometryCacheRefs.get(t)||0)){this.geometryCache.get(t).forEach(e=>e.dispose()),this.geometryCache.delete(t),this.geometryCacheRefs.delete(t),e=!0;break}if(!e)break}return this.geometryCache.set(i,a),a}precomputeShards(e,t){if(!e?.geometry||!e?.material)return void console.warn("ShatterSystem.precomputeShards: Invalid mesh");this.shardMaterialCache?.baseMaterial&&this.shardMaterialCache.baseMaterial.dispose(),this.shardMaterialCache=null;const i=Vm(Gm(e.material,t)),a=zm.hashGeometry(e.geometry);let n=this.geometryCache.get(a);n||(n=zm.generate(e.geometry,{shardCount:this.maxShards,seed:this._hashString(a)}),this.geometryCache.set(a,n)),this.shardMaterialCache={geometryType:t,baseMaterial:i,geometries:n,geometryId:a}}hasCachedShards(){return null!==this.shardMaterialCache}getCacheInfo(){return this.shardMaterialCache?{geometryType:this.shardMaterialCache.geometryType,shardCount:this.shardMaterialCache.geometries?.length||0,hasMaterial:!!this.shardMaterialCache.baseMaterial}:null}shatter(t,i={}){if(this.state!==hp.IDLE)return console.warn("ShatterSystem: Cannot shatter - already in state:",this.state),!1;const{impactPoint:a=new e.Vector3(0,0,.4),impactDirection:n=new e.Vector3(0,0,-1),intensity:s=1,geometryId:r=null,revealInner:o=!0,inheritMeshVelocity:l=null,isSuspendMode:c=!1,suspendAt:h=.25,suspendDuration:u=.35,isFreezeMode:d=!1,isDualMode:m=!1,dualModeType:p=null,dualModeConfig:g={},gravity:f,explosionForce:y,rotationForce:v,elemental:b=null,elementalParam:w=.5,overlay:M=null,overlayParam:S=.5}=i;this.state=hp.GENERATING,this.targetMesh=t,this._shatterStartTime=performance.now(),this._isSuspendMode=c,this._suspendAt=h,this._suspendDuration=u,this._gestureDuration=i.gestureDuration||6e3,this._isFreezeMode=d,this._pendingDualMode=m?p:null,this._pendingDualModeConfig=m?g:{};const x=r||zm.hashGeometry(t.geometry);let C=this.geometryCache.get(x);if(C||(C=this.prepareGeometry(t.geometry,x)),!C||0===C.length)return console.warn("ShatterSystem: No shards generated"),this.state=hp.IDLE,!1;this._activeGeometryId=x;const P=this.geometryCacheRefs.get(x)||0;this.geometryCacheRefs.set(x,P+1);const k=new e.Vector3,D=new e.Quaternion,A=new e.Vector3;t.matrixWorld.decompose(k,D,A);const _=a.clone();_.applyQuaternion(D),_.add(k);const T=n.clone();if(T.applyQuaternion(D),T.normalize(),t.visible=!1,this._soulWasRevealed=o&&this.innerMesh,this._soulWasRevealed){this.innerMesh.visible=!0,this._soulRevealProgress=0,this._soulOriginalScale=this.innerMesh.scale.x,this._soulOriginalLayer=this.innerMesh.layers.mask,this.innerMesh.layers.set(0),this._soulOriginalDepthTest=this.innerMesh.material?.depthTest??!0,this._soulOriginalRenderOrder=this.innerMesh.renderOrder??0,this.innerMesh.material&&(this.innerMesh.material.depthTest=!1),this.innerMesh.renderOrder=100;const e=this.innerMesh.material?.uniforms;e?(this._soulOriginalEmissive=e.energyIntensity?.value??.8,this._soulOriginalGhostMode=e.ghostMode?.value??.36,e.energyIntensity&&(e.energyIntensity.value=2),e.ghostMode&&(e.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this._soulOriginalEmissive=this.innerMesh.material.emissiveIntensity,this.innerMesh.material.emissiveIntensity=2),this.innerMesh.scale.setScalar(.5*this._soulOriginalScale)}this.state=hp.SHATTERING;let I=this.shardLifetime;c||d?I=1e4:m&&g?.duration&&(I=400+g.duration+1e3);const O=I;let R,E,B,F=null,z=null;if(console.log("[SHATTER_SYSTEM] 📥 shatter() called with:",{elemental:b,elementalParam:w,overlay:M,overlayParam:S,isElementSupported:b?cp(b):"N/A",hasCachedMaterial:!!this.shardMaterialCache?.baseMaterial}),b&&cp(b))this._currentElementalMaterial&&this._currentElemental===b?(F=this._currentElementalMaterial,z=lp(b,w),this._currentElementalParam=w,console.log("[SHATTER_SYSTEM] ♻️ Reusing cached elemental material:",{elemental:b,elementalParam:w,materialType:F?.type})):(this._currentElementalMaterial&&(this._currentElementalMaterial.dispose(),this._currentElementalMaterial=null),F=function(e,t=.5,i={}){console.log("[ELEMENTAL_FACTORY] 🔧 createElementalMaterial called:",{element:e,masterParam:t,options:i,registryKeys:Object.keys(sp),hasRegistry:!!sp[e]});const a=sp[e];if(!a)return console.warn(`ElementalMaterialFactory: Unknown element type '${e}'`),null;const n={[a.masterParam]:t,...i};console.log("[ELEMENTAL_FACTORY] 📦 Calling registry.create with:",{element:e,masterParamName:a.masterParam,materialOptions:n});const s=a.create(n);return console.log("[ELEMENTAL_FACTORY] ✅ Material created:",{element:e,materialCreated:!!s,materialType:s?.type,materialUserData:s?.userData,hasUniforms:!!s?.uniforms,uniformKeys:s?.uniforms?Object.keys(s.uniforms):[]}),s}(b,w),z=lp(b,w),console.log("[SHATTER_SYSTEM] ✨ Created new elemental material:",{elemental:b,elementalParam:w,materialCreated:!!F,materialType:F?.type}),this._currentElementalMaterial=F,this._currentElemental=b,this._currentElementalParam=w);else{if(this._currentElementalMaterial&&(this._currentElementalMaterial.dispose(),this._currentElementalMaterial=null,this._currentElemental=null),F=this.shardMaterialCache?.baseMaterial||null,console.log("[SHATTER_SYSTEM] 📦 Using cached/default material:",{hasCachedMaterial:!!F,cachedMaterialType:F?.type,reason:b?`Element '${b}' not supported`:"No elemental specified"}),this.shardMaterialCache&&F&&!F.map&&t.material){const e=Gm(t.material,this.shardMaterialCache.geometryType);e.map&&(F.dispose(),F=Vm(e),this.shardMaterialCache.baseMaterial=F)}this._currentElemental=null,this._currentElementalParam=.5}z?(B=void 0!==f?f:c?-3:9.8*-z.gravity,R=(void 0!==y?y:2)*s,E=(void 0!==v?v:5)*s,this._elementalDrag=z.drag,this._elementalBounce=z.bounce):(R=(void 0!==y?y:2)*s,E=(void 0!==v?v:5)*s,B=void 0!==f?f:c?-3:-9.8,this._elementalDrag=null,this._elementalBounce=null),this._currentOverlay=M,this._currentOverlayParam=S,console.log("[SHATTER_SYSTEM] 🚀 Calling shardPool.activate() with:",{baseMaterialExists:!!F,baseMaterialType:F?.type,baseMaterialElementalType:F?.userData?.elementalType,elementalType:b,elementalPhysicsExists:!!z});const L=this.shardPool.activate(C,_,T,{explosionForce:R,rotationForce:E,lifetime:O,gravity:B,inheritVelocity:l||new e.Vector3,meshPosition:k,meshQuaternion:D,meshScale:A,isSuspendMode:c,baseMaterial:F,elementalPhysics:z,elementalType:b});return F||this._syncShardMaterial(t),this.onShatterStart&&this.onShatterStart(t,{shardCount:L}),!0}_syncShardMaterial(t){let i=new e.Color(8965375),a=new e.Color(0);t.material?.uniforms?.emotionColor?(i=t.material.uniforms.emotionColor.value.clone(),a=i.clone().multiplyScalar(.3)):t.material?.color&&(i=t.material.color.clone(),a=t.material.emissive?.clone()||new e.Color(0)),this.shardPool.updateMaterial({color:i,emissive:a,emissiveIntensity:.4})}shatterChain(t,i={}){if(!t||0===t.length)return!1;const{delay:a=150,propagationDir:n=null}=i;this._chainedDelay=a;let s=[...t];if(n){const t=n.clone().normalize(),i=new e.Vector3;s=s.map(e=>(e.mesh.getWorldPosition(i),{target:e,dot:i.dot(t)})).sort((e,t)=>e.dot-t.dot).map(e=>e.target)}return this._shatterQueue=s.map((e,t)=>({mesh:e.mesh,config:e.config||{},triggerTime:performance.now()+t*a})),this.state===hp.IDLE&&this._shatterQueue.length>0&&this._processNextInChain(),!0}_processNextInChain(){if(0===this._shatterQueue.length)return;const e=this._shatterQueue[0],t=performance.now();t>=e.triggerTime&&(this._shatterQueue.shift(),this._lastChainTrigger=t,this.shatter(e.mesh,e.config))}reassemble(e={}){if(this.state!==hp.SHATTERING||!this.enableReassembly)return!1;const{duration:t=1e3}=e;return this.state=hp.REASSEMBLING,this._reassemblyDuration=t,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions(),!0}triggerReassembly(e=1500){return this.state!==hp.FROZEN?(console.warn("ShatterSystem.triggerReassembly: Can only trigger from FROZEN state, current state:",this.state),!1):(this.state=hp.REASSEMBLING,this._reassemblyDuration=e,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions(),!0)}isFrozen(){return this.state===hp.FROZEN}moveFrozenShards(e,t=3){if(this.state!==hp.FROZEN)return!1;this.shardPool.applyImpulse(e,t,.4),this.state=hp.SHATTERING,this._isFreezeMode=!1,this._isSuspendMode=!1;for(const e of this.shardPool.active)e.userData.state.lifetime=0,e.userData.state.maxLifetime=1500;return!0}triggerDualMode(e,t={}){return["implode","dissolve","gravity","orbit"].includes(e)?[hp.IMPLODING,hp.DISSOLVING,hp.FALLING,hp.ORBITING].includes(this.state)?(console.warn("ShatterSystem.triggerDualMode: Already in dual-mode state:",this.state),!1):(this._dualModeType=e,this._dualModeConfig=t,this._dualModeStartTime=performance.now(),this._dualModeDuration=t.duration||2e3,this.state===hp.FROZEN&&(this._startDualModeFromFrozen(e,t),!0)):(console.warn("ShatterSystem.triggerDualMode: Invalid mode:",e),!1)}_startDualModeFromFrozen(e,t){switch(this.shardPool.captureCurrentPositions(),e){case"implode":this.state=hp.IMPLODING,this.shardPool.initImplodeMode(t);break;case"dissolve":this.state=hp.DISSOLVING,this.shardPool.initDissolveMode(t);break;case"gravity":this.state=hp.FALLING,this.shardPool.initGravityMode(t);break;case"orbit":this.state=hp.ORBITING,this.shardPool.initOrbitMode(t)}}update(e){if(this.state===hp.IDLE&&this._shatterQueue.length>0&&this._processNextInChain(),this.state===hp.SHATTERING){if(this._isSuspendMode){const e=performance.now()-this._shatterStartTime,t=Math.min(1,e/this._gestureDuration);let i=0;if(t>=this._suspendAt){const e=t-this._suspendAt;i=Math.min(1,e/this._suspendDuration),i=1-Math.pow(1-i,2)}this.shardPool.updateSuspendProgress(i)}if(this.shardPool.update(e),this._soulWasRevealed&&this.innerMesh){const t=this.innerMesh.material?.uniforms;if(this._soulRevealProgress<1){this._soulRevealProgress+=e/500,this._soulRevealProgress=Math.min(1,this._soulRevealProgress);const i=this._soulRevealProgress,a=1-Math.pow(1-i,3),n=this._soulOriginalScale*(.5+.5*a);if(this.innerMesh.scale.setScalar(n),t)t.energyIntensity&&(t.energyIntensity.value=2-a*(2-this._soulOriginalEmissive)),t.ghostMode&&(t.ghostMode.value=0);else if(void 0!==this.innerMesh.material?.emissiveIntensity){const e=2-a*(2-this._soulOriginalEmissive);this.innerMesh.material.emissiveIntensity=e}}else this.innerMesh.scale.setScalar(this._soulOriginalScale),t?(t.energyIntensity&&(t.energyIntensity.value=this._soulOriginalEmissive),t.ghostMode&&(t.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive)}if(this._isFreezeMode&&this._isSuspendMode){const e=performance.now()-this._shatterStartTime;Math.min(1,e/this._gestureDuration)>=this._suspendAt+this._suspendDuration&&(this._pendingDualMode?(this._dualModeType=this._pendingDualMode,this._dualModeConfig=this._pendingDualModeConfig,this._dualModeStartTime=performance.now(),this._dualModeDuration=this._pendingDualModeConfig.duration||2e3,this._startDualModeFromFrozen(this._pendingDualMode,this._pendingDualModeConfig),this._pendingDualMode=null,this._pendingDualModeConfig={}):this.state=hp.FROZEN)}this._pendingDualMode&&!this._isFreezeMode&&performance.now()-this._shatterStartTime>=400&&(this._dualModeType=this._pendingDualMode,this._dualModeConfig=this._pendingDualModeConfig,this._dualModeStartTime=performance.now(),this._dualModeDuration=this._pendingDualModeConfig.duration||2e3,this.shardPool.captureCurrentPositions(),this._startDualModeFromFrozen(this._pendingDualMode,this._pendingDualModeConfig),this._pendingDualMode=null,this._pendingDualModeConfig={}),0!==this.shardPool.activeCount||this._isFreezeMode||this._pendingDualMode||this._onShatterComplete()}if(this.state===hp.IMPLODING&&this._updateImplodeMode(e),this.state===hp.DISSOLVING&&this._updateDissolveMode(e),this.state===hp.FALLING&&this._updateGravityMode(e),this.state===hp.ORBITING&&this._updateOrbitMode(e),this.state===hp.REASSEMBLING){const e=performance.now()-this._reassemblyStartTime;this._reassemblyProgress=Math.min(1,e/this._reassemblyDuration);const t=om(this._reassemblyProgress);if(this.shardPool.updateReassembly(t,this.targetMesh),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;if(this._reassemblyProgress<=.6)this.innerMesh.scale.setScalar(this._soulOriginalScale),e?(e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive),e.ghostMode&&(e.ghostMode.value=0)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive);else{const t=(this._reassemblyProgress-.6)/.4,i=t*t,a=this._soulOriginalScale*(1-.3*i);this.innerMesh.scale.setScalar(a),e?(e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive*(1-i)),e.ghostMode&&void 0!==this._soulOriginalGhostMode&&(e.ghostMode.value=i*this._soulOriginalGhostMode)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive*(1-i))}}this._reassemblyProgress>=1&&this._onReassemblyComplete()}}_updateImplodeMode(t){const i=performance.now()-this._dualModeStartTime,a=Math.min(1,i/this._dualModeDuration),n=this.innerMesh?this.innerMesh.position.clone():new e.Vector3;if(this.shardPool.updateImplode(t,a,n),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;if(e){const t=1+1.5*a;e.energyIntensity&&(e.energyIntensity.value=t)}}a>=1&&this._onDualModeComplete()}_updateDissolveMode(e){const t=performance.now()-this._dualModeStartTime,i=Math.min(1,t/this._dualModeDuration);if(this.shardPool.updateDissolve(e,i,this._dualModeConfig),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;e&&e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive*(1-.5*i))}i>=1&&this._onDualModeComplete()}_updateGravityMode(e){const t=performance.now()-this._dualModeStartTime,i=Math.min(1,t/this._dualModeDuration),a=this._dualModeConfig.floorY??-1;this.shardPool.updateGravityBounce(e,i,a),i>=1&&this._onDualModeComplete()}_updateOrbitMode(t){const i=performance.now()-this._dualModeStartTime,a=Math.min(1,i/this._dualModeDuration),n=this.innerMesh?this.innerMesh.position.clone():new e.Vector3;if(this.shardPool.updateOrbit(t,a,n,this._dualModeConfig),this._soulWasRevealed&&this.innerMesh){const e=this.innerMesh.material?.uniforms;if(e){const t=.2*Math.sin(i/200);e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive+t)}}a>=1&&!1!==this._dualModeConfig.autoComplete&&(this._dualModeConfig.reassemble?(this.state=hp.REASSEMBLING,this._reassemblyDuration=this._dualModeConfig.reassembleDuration||1200,this._reassemblyStartTime=performance.now(),this._reassemblyProgress=0,this.shardPool.captureCurrentPositions()):this._onDualModeComplete())}_onDualModeComplete(){this.shardPool.clear(),this.targetMesh&&(this.targetMesh.visible=!0),this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms()),this._dualModeType=null,this._dualModeConfig={},this._releaseGeometryRef(),this._disposeElementalMaterial(),this.state=hp.IDLE,this.onShatterComplete&&this.onShatterComplete(this.targetMesh)}_onShatterComplete(){this.state=hp.IDLE,this._releaseGeometryRef(),this._disposeElementalMaterial(),this.autoRestore&&this.targetMesh&&(this.targetMesh.visible=!0,this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms())),this.onShatterComplete&&this.onShatterComplete(this.targetMesh)}_onReassemblyComplete(){this.shardPool.clear(),this._releaseGeometryRef(),this._disposeElementalMaterial(),this.targetMesh&&(this.targetMesh.visible=!0),this._soulWasRevealed&&this.innerMesh&&(this.innerMesh.scale.setScalar(this._soulOriginalScale),this._resetSoulUniforms()),this.state=hp.IDLE,this.onReassemblyComplete&&this.onReassemblyComplete(this.targetMesh)}_resetSoulUniforms(){if(!this.innerMesh)return;void 0!==this._soulOriginalLayer&&(this.innerMesh.layers.mask=this._soulOriginalLayer),this.innerMesh.material&&void 0!==this._soulOriginalDepthTest&&(this.innerMesh.material.depthTest=this._soulOriginalDepthTest),void 0!==this._soulOriginalRenderOrder&&(this.innerMesh.renderOrder=this._soulOriginalRenderOrder);const e=this.innerMesh.material?.uniforms;e?(e.energyIntensity&&(e.energyIntensity.value=this._soulOriginalEmissive),e.ghostMode&&void 0!==this._soulOriginalGhostMode&&(e.ghostMode.value=this._soulOriginalGhostMode)):void 0!==this.innerMesh.material?.emissiveIntensity&&(this.innerMesh.material.emissiveIntensity=this._soulOriginalEmissive)}_disposeElementalMaterial(){this._currentElementalMaterial&&(this._currentElementalMaterial.dispose(),this._currentElementalMaterial=null),this._currentElemental=null,this._currentElementalParam=.5}_releaseGeometryRef(){if(this._activeGeometryId){const e=this.geometryCacheRefs.get(this._activeGeometryId)||0;e>0&&this.geometryCacheRefs.set(this._activeGeometryId,e-1),this._activeGeometryId=null}}setTargets(e,t=null){this.targetMesh=e,this.innerMesh=t}setScene(e){this.scene=e,this.shardPool.setScene(e)}forceStop(){this.shardPool.clear(),this.state=hp.IDLE,this._shatterQueue=[],this._releaseGeometryRef(),this._disposeElementalMaterial(),this.targetMesh&&(this.targetMesh.visible=!0),this.innerMesh&&(this.innerMesh.visible=!1)}clearChainQueue(){this._shatterQueue=[]}getChainQueueLength(){return this._shatterQueue.length}getState(){return this.state}isShattering(){return this.state===hp.SHATTERING}isIdle(){return this.state===hp.IDLE}isReassembling(){return this.state===hp.REASSEMBLING}getStats(){return{state:this.state,activeShards:this.shardPool.activeCount,availableShards:this.shardPool.availableCount,cachedGeometries:this.geometryCache.size,chainQueueLength:this._shatterQueue.length,reassemblyProgress:this.state===hp.REASSEMBLING?this._reassemblyProgress:null}}clearCache(){for(const e of this.geometryCache.values())for(const t of e)t.dispose();this.geometryCache.clear(),this.geometryCacheRefs.clear()}dispose(){this.forceStop(),this.shardPool.dispose(),this.clearCache(),this.shardMaterialCache?.baseMaterial&&this.shardMaterialCache.baseMaterial.dispose(),this.shardMaterialCache=null,this._disposeElementalMaterial(),this.targetMesh=null,this.innerMesh=null,this.onShatterStart=null,this.onShatterComplete=null,this.onReassemblyComplete=null}_hashString(e){let t=0;for(let i=0;i<e.length;i++)t=(t<<5)-t+e.charCodeAt(i),t&=t;return Math.abs(t)}}class dp{constructor(){this.impacts=[],this.crackColor=new e.Color(...Nd.crackColor),this.crackGlowColor=new e.Color(...Nd.crackGlowColor),this.glowStrength=Nd.crackGlowStrength,this.elementalType=null,this.elementalParam=.5,this.pattern="organic",this.animated=!1,this.isHealing=!1,this.healDuration=1500,this.healStartTime=0,this.healProgress=0,this._tempVec3=new e.Vector3,this._tempQuat=new e.Quaternion}addImpact(t){const i=100*Math.random(),a={position:Array.isArray(t.position)?new e.Vector3(...t.position):t.position?.clone()??new e.Vector3,direction:Array.isArray(t.direction)?new e.Vector3(...t.direction):t.direction?.clone()??new e.Vector3,propagation:t.propagation??.8,amount:t.amount??1,seed:i};this.impacts.length>=3&&this.impacts.shift(),this.impacts.push(a)}transformToMeshLocal(t,i,a){const n=new e.Vector3,s=new e.Vector3,r=new e.Vector3;i.getWorldDirection(r),n.crossVectors(r,i.up).normalize(),s.crossVectors(n,r).normalize();const o=t.screenOffset||[0,0],l=t.screenDirection||[0,0],c=(new e.Vector3).addScaledVector(n,.4*o[0]).addScaledVector(s,.4*o[1]).addScaledVector(r.clone().negate(),.3);a.updateWorldMatrix(!0,!1);const h=a.matrixWorld.clone().invert();c.applyMatrix4(h);const u=(new e.Vector3).addScaledVector(n,l[0]).addScaledVector(s,l[1]),d=new e.Quaternion;return a.getWorldQuaternion(d),d.invert(),u.applyQuaternion(d),{position:c,direction:u,propagation:t.propagation??.8,amount:t.amount??1}}startHealing(e=1500){if(0!==this.impacts.length){this.isHealing=!0,this.healDuration=e,this.healStartTime=performance.now(),this.healProgress=0;for(const e of this.impacts)e.originalAmount=e.amount,e.originalPropagation=e.propagation}}clearAll(){this.impacts=[],this.isHealing=!1,this.healProgress=0}hasCracks(){return this.impacts.length>0}update(e){if(!this.isHealing||0===this.impacts.length)return;const t=performance.now()-this.healStartTime;this.healProgress=Math.min(t/this.healDuration,1);const i=this.healProgress,a=1-i*i*(3-2*i);for(const e of this.impacts)void 0!==e.originalAmount&&(e.amount=e.originalAmount*a,e.propagation=e.originalPropagation*(.3+.7*a));this.healProgress>=1&&this.clearAll()}applyToMaterial(e){if(!e?.uniforms)return;const{uniforms:t}=e;t.crackNumImpacts&&(t.crackNumImpacts.value=this.impacts.length);for(let e=0;e<3;e++){const i=this.impacts[e],a=t[`crackImpact${e}`],n=t[`crackDirection${e}`],s=t[`crackParams${e}`];i?(a&&a.value.copy(i.position),n&&n.value.copy(i.direction),s&&s.value.set(i.propagation,i.amount,i.seed)):(a&&a.value.set(0,0,0),n&&n.value.set(0,0,0),s&&s.value.set(0,0,0))}t.crackColor&&t.crackColor.value.copy(this.crackColor),t.crackGlowColor&&t.crackGlowColor.value.copy(this.crackGlowColor),t.crackGlowStrength&&(t.crackGlowStrength.value=this.glowStrength)}setGlowColor(e){Array.isArray(e)?this.crackGlowColor.setRGB(e[0],e[1],e[2]):"number"==typeof e?this.crackGlowColor.setHex(e):e&&this.crackGlowColor.copy(e)}setCrackColor(e){Array.isArray(e)?this.crackColor.setRGB(e[0],e[1],e[2]):"number"==typeof e?this.crackColor.setHex(e):e&&this.crackColor.copy(e)}setElemental(e,t=.5){this.elementalType=e,this.elementalParam=t;const i=function(e,t=.5){const i=sp[e];return i?i.crack(t):{...rp}}(e,t);"number"==typeof i.color?(this.crackColor.setHex(i.color),this.crackGlowColor.setHex(i.color)):i.color&&(this.crackColor.copy(i.color),this.crackGlowColor.copy(i.color)),this.glowStrength=Math.max(0,i.emissive??.5),this.pattern=i.pattern||"organic",this.animated=i.animated??!1}clearElemental(){this.elementalType=null,this.elementalParam=.5,this.crackColor.setRGB(...Nd.crackColor),this.crackGlowColor.setRGB(...Nd.crackGlowColor),this.glowStrength=Nd.crackGlowStrength,this.pattern="organic",this.animated=!1}reset(){this.clearAll(),this.clearElemental()}dispose(){this.impacts=[],this._tempVec3=null,this._tempQuat=null}}function mp(e,t,i){return e+(t-e)*i}function pp(e,t,i){return e+(t-e)*i}function gp(e,t,i){return e+(t-e)*i}class fp{constructor(){this.position=new e.Vector3,this.velocity=new e.Vector3,this.rotation=0,this.rotationSpeed=0,this.scale=1,this.scaleGrowth=0,this.alpha=1,this.alphaDecay=0,this.life=0,this.maxLife=1,this.active=!1}reset(){this.position.set(0,0,0),this.velocity.set(0,0,0),this.rotation=0,this.rotationSpeed=0,this.scale=1,this.scaleGrowth=0,this.alpha=1,this.alphaDecay=0,this.life=0,this.maxLife=1,this.active=!1}}class yp{constructor(t={}){this.maxParticles=t.maxParticles||50,this.category=t.category||"emanating",this.tint=t.tint||[1,1,1],this.density=t.density||.5,this.swirl=t.swirl||0,this.particles=[];for(let e=0;e<this.maxParticles;e++)this.particles.push(new fp);this._createGeometry(),this._createMaterial(),this.mesh=new e.Points(this.geometry,this.material),this.mesh.frustumCulled=!1,this.mesh.renderOrder=100,this.spawnTimer=0,this.spawnInterval=.08,this.time=0,this.effectStrength=1,this.hasBurst=!1}_createGeometry(){this.geometry=new e.BufferGeometry;const t=new Float32Array(3*this.maxParticles),i=new Float32Array(this.maxParticles),a=new Float32Array(this.maxParticles),n=new Float32Array(this.maxParticles),s=new Float32Array(this.maxParticles);for(let e=0;e<this.maxParticles;e++)t[3*e]=0,t[3*e+1]=0,t[3*e+2]=0,i[e]=0,a[e]=0,n[e]=0,s[e]=Math.random();this.geometry.setAttribute("position",new e.BufferAttribute(t,3)),this.geometry.setAttribute("aSize",new e.BufferAttribute(i,1)),this.geometry.setAttribute("aRotation",new e.BufferAttribute(a,1)),this.geometry.setAttribute("aAlpha",new e.BufferAttribute(n,1)),this.geometry.setAttribute("aVariation",new e.BufferAttribute(s,1))}_createMaterial(){this.material=new e.ShaderMaterial({uniforms:{uTint:{value:new e.Vector3(this.tint[0],this.tint[1],this.tint[2])},uOpacity:{value:.6},uTime:{value:0}},vertexShader:"\n                attribute float aSize;\n                attribute float aRotation;\n                attribute float aAlpha;\n                attribute float aVariation;\n\n                varying float vAlpha;\n                varying float vRotation;\n                varying float vVariation;\n\n                void main() {\n                    vAlpha = aAlpha;\n                    vRotation = aRotation;\n                    vVariation = aVariation;\n\n                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\n                    // Billboard sizing - scale with distance\n                    gl_PointSize = aSize * (300.0 / -mvPosition.z);\n                    gl_PointSize = clamp(gl_PointSize, 1.0, 256.0);\n\n                    gl_Position = projectionMatrix * mvPosition;\n                }\n            ",fragmentShader:"\n                uniform vec3 uTint;\n                uniform float uOpacity;\n                uniform float uTime;\n\n                varying float vAlpha;\n                varying float vRotation;\n                varying float vVariation;\n\n                void main() {\n                    // Point coord centered\n                    vec2 uv = gl_PointCoord - 0.5;\n\n                    // Rotate UV - VISIBLE rotation as particle spins\n                    float c = cos(vRotation);\n                    float s = sin(vRotation);\n                    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);\n\n                    // Distance from center\n                    float dist = length(uv) * 2.0;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // SIMPLE SOFT PUFF - Clean cloud shape\n                    // Motion comes from particle movement, not shader complexity\n                    // ═══════════════════════════════════════════════════════════════\n\n                    // Soft radial falloff - clean puff shape\n                    float puff = 1.0 - smoothstep(0.0, 1.0, dist);\n                    puff = pow(puff, 0.6); // Softer falloff\n\n                    // Per-particle variation for unique shapes\n                    float seed = vVariation * 6.28318;\n\n                    // Slight wobble to break perfect circle\n                    float angle = atan(uv.y, uv.x);\n                    float wobble = sin(angle * 3.0 + seed) * 0.15 + sin(angle * 5.0 + seed * 2.0) * 0.08;\n                    float wobbledDist = dist - wobble * (1.0 - dist);\n\n                    // Final soft shape\n                    float shape = 1.0 - smoothstep(0.0, 0.95, wobbledDist);\n                    shape = pow(shape, 0.5);\n\n                    // Alpha\n                    float alpha = shape * vAlpha * uOpacity;\n\n                    if (alpha < 0.02) discard;\n\n                    // ═══════════════════════════════════════════════════════════════\n                    // COLOR - Simple gray smoke\n                    // ═══════════════════════════════════════════════════════════════\n\n                    // Core is lighter, edges darker - darker overall for less bright blobs\n                    vec3 coreColor = vec3(0.3, 0.3, 0.35);\n                    vec3 edgeColor = vec3(0.15, 0.15, 0.2);\n                    vec3 smokeColor = mix(coreColor, edgeColor, dist);\n\n                    // Apply tint\n                    smokeColor *= uTint;\n\n                    gl_FragColor = vec4(smokeColor, alpha);\n                }\n            ",transparent:!0,blending:e.NormalBlending,depthWrite:!1,depthTest:!0})}_spawnParticle(){let e=null;for(const t of this.particles)if(!t.active){e=t;break}if(e){if(e.active=!0,e.life=0,"explosive"===this.category){const t=Math.random()*Math.PI*2,i=.4*Math.PI+Math.random()*Math.PI*.2,a=.02+.03*Math.random();e.position.set(Math.sin(i)*Math.cos(t)*a,.1*Math.random()-.35,Math.sin(i)*Math.sin(t)*a);const n=1+.6*Math.random();e.velocity.set(Math.cos(t)*n,.15+.2*Math.random(),Math.sin(t)*n),e.maxLife=.8+.4*Math.random(),e.scale=.06+.04*Math.random(),e.scaleGrowth=.25+.15*Math.random(),e.alpha=.5+.2*Math.random(),e.alphaDecay=e.alpha/e.maxLife,e.rotationSpeed=4*(Math.random()-.5)}else if("afflicted"===this.category){const t=Math.random()*Math.PI*2,i=.35+.2*Math.random(),a=.6*(Math.random()-.5);e.position.set(Math.cos(t)*i,a,Math.sin(t)*i);const n=.5+.4*this.swirl,s=.05+.05*this.swirl,r=.1+.08*Math.random();e.velocity.set(-Math.sin(t)*n-Math.cos(t)*s,r,Math.cos(t)*n-Math.sin(t)*s),e.maxLife=1.8+.8*Math.random(),e.scale=.05+.04*Math.random(),e.scaleGrowth=.06+.04*Math.random(),e.alpha=.25+.15*Math.random(),e.alphaDecay=e.alpha/e.maxLife,e.rotationSpeed=2.5*(Math.random()-.5)}else{const t=Math.random()*Math.PI*2,i=.1+.15*Math.random(),a=.1*Math.random()-.15;e.position.set(Math.cos(t)*i,a,Math.sin(t)*i);const n=.2*(Math.random()-.5),s=.2*(Math.random()-.5),r=.2+.15*Math.random();e.velocity.set(n,r,s),e.maxLife=1+.5*Math.random(),e.scale=.04+.03*Math.random(),e.scaleGrowth=.08+.05*Math.random(),e.alpha=.3+.15*Math.random(),e.alphaDecay=e.alpha/e.maxLife,e.rotationSpeed=2*(Math.random()-.5)}e.rotation=Math.random()*Math.PI*2}}update(e,t={}){if(this.time+=e,this.effectStrength=t.thickness||1,this.material.uniforms.uTime.value=this.time,t.category&&t.category!==this.category&&(this.category=t.category),t.tint&&this.material.uniforms.uTint.value.set(t.tint[0],t.tint[1],t.tint[2]),void 0!==t.swirl&&(this.swirl=t.swirl),void 0!==t.density&&(this.density=t.density),this.spawnTimer+=e,"explosive"===this.category&&!this.hasBurst&&this.effectStrength>.5){const e=15+Math.floor(5*Math.random());for(let t=0;t<e;t++)this._spawnParticle();this.hasBurst=!0}let i;this.effectStrength<.1&&(this.hasBurst=!1),i="explosive"===this.category?.04:"afflicted"===this.category?.06:.05;const a=i/(.5+.5*this.density)/this.effectStrength;for(;this.spawnTimer>=a;)this._spawnParticle(),this.spawnTimer-=a;const n=this.geometry.attributes.position.array,s=this.geometry.attributes.aSize.array,r=this.geometry.attributes.aRotation.array,o=this.geometry.attributes.aAlpha.array;for(let t=0;t<this.particles.length;t++){const i=this.particles[t];if(!i.active){s[t]=0,o[t]=0;continue}if(i.life+=e,i.life>=i.maxLife){i.active=!1,s[t]=0,o[t]=0;continue}const a=i.life/i.maxLife;i.position.x+=i.velocity.x*e,i.position.y+=i.velocity.y*e,i.position.z+=i.velocity.z*e,i.velocity.multiplyScalar(.995),i.rotation+=i.rotationSpeed*e;const l=i.scale+i.scaleGrowth*a;let c=i.alpha;if(a>.3){const e=(a-.3)/.7;c=i.alpha*(1-e*e)}n[3*t]=i.position.x,n[3*t+1]=i.position.y,n[3*t+2]=i.position.z,s[t]=100*l*this.effectStrength,r[t]=i.rotation,o[t]=c*this.effectStrength}this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.aSize.needsUpdate=!0,this.geometry.attributes.aRotation.needsUpdate=!0,this.geometry.attributes.aAlpha.needsUpdate=!0}attachTo(e){this.mesh.parent&&this.mesh.parent.remove(this.mesh),e.add(this.mesh)}detach(){this.mesh.parent&&this.mesh.parent.remove(this.mesh)}dispose(){this.detach(),this.geometry.dispose(),this.material.dispose()}}yp._cloudTexture=null,yp._textureVersion=0;class vp extends A{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new Cp(e)}),this.register(function(e){return new Pp(e)}),this.register(function(e){return new Ep(e)}),this.register(function(e){return new Bp(e)}),this.register(function(e){return new Fp(e)}),this.register(function(e){return new Dp(e)}),this.register(function(e){return new Ap(e)}),this.register(function(e){return new _p(e)}),this.register(function(e){return new Tp(e)}),this.register(function(e){return new xp(e)}),this.register(function(e){return new Ip(e)}),this.register(function(e){return new kp(e)}),this.register(function(e){return new Rp(e)}),this.register(function(e){return new Op(e)}),this.register(function(e){return new Mp(e)}),this.register(function(e){return new zp(e)}),this.register(function(e){return new Lp(e)})}load(e,t,i,a){const n=this;let s;if(""!==this.resourcePath)s=this.resourcePath;else if(""!==this.path){const t=N.extractUrlBase(e);s=N.resolveURL(t,this.path)}else s=N.extractUrlBase(e);this.manager.itemStart(e);const r=function(t){a?a(t):console.error(t),n.manager.itemError(e),n.manager.itemEnd(e)},o=new _(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(i){try{n.parse(i,s,function(i){t(i),n.manager.itemEnd(e)},r)}catch(e){r(e)}},i,r)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,a){let n;const s={},r={},o=new TextDecoder;if("string"==typeof e)n=JSON.parse(e);else if(e instanceof ArrayBuffer)if(o.decode(new Uint8Array(e,0,4))===Gp){try{s[wp.KHR_BINARY_GLTF]=new Vp(e)}catch(e){return void(a&&a(e))}n=JSON.parse(s[wp.KHR_BINARY_GLTF].content)}else n=JSON.parse(o.decode(e));else n=e;if(void 0===n.asset||n.asset.version[0]<2)return void(a&&a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const l=new cg(n,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let e=0;e<this.pluginCallbacks.length;e++){const t=this.pluginCallbacks[e](l);t.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),r[t.name]=t,s[t.name]=!0}if(n.extensionsUsed)for(let e=0;e<n.extensionsUsed.length;++e){const t=n.extensionsUsed[e],i=n.extensionsRequired||[];switch(t){case wp.KHR_MATERIALS_UNLIT:s[t]=new Sp;break;case wp.KHR_DRACO_MESH_COMPRESSION:s[t]=new Np(n,this.dracoLoader);break;case wp.KHR_TEXTURE_TRANSFORM:s[t]=new jp;break;case wp.KHR_MESH_QUANTIZATION:s[t]=new qp;break;default:i.indexOf(t)>=0&&void 0===r[t]&&console.warn('THREE.GLTFLoader: Unknown extension "'+t+'".')}}l.setExtensions(s),l.setPlugins(r),l.parse(i,a)}parseAsync(e,t){const i=this;return new Promise(function(a,n){i.parse(e,t,a,n)})}}function bp(){let e={};return{get:function(t){return e[t]},add:function(t,i){e[t]=i},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const wp={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Mp{constructor(e){this.parser=e,this.name=wp.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,a=t.length;i<a;i++){const a=t[i];a.extensions&&a.extensions[this.name]&&void 0!==a.extensions[this.name].light&&e._addNodeRef(this.cache,a.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let a=t.cache.get(i);if(a)return a;const n=t.json,s=((n.extensions&&n.extensions[this.name]||{}).lights||[])[e];let r;const o=new d(16777215);void 0!==s.color&&o.setRGB(s.color[0],s.color[1],s.color[2],q);const l=void 0!==s.range?s.range:0;switch(s.type){case"directional":r=new H(o),r.target.position.set(0,0,-1),r.add(r.target);break;case"point":r=new W(o),r.distance=l;break;case"spot":r=new U(o),r.distance=l,s.spot=s.spot||{},s.spot.innerConeAngle=void 0!==s.spot.innerConeAngle?s.spot.innerConeAngle:0,s.spot.outerConeAngle=void 0!==s.spot.outerConeAngle?s.spot.outerConeAngle:Math.PI/4,r.angle=s.spot.outerConeAngle,r.penumbra=1-s.spot.innerConeAngle/s.spot.outerConeAngle,r.target.position.set(0,0,-1),r.add(r.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+s.type)}return r.position.set(0,0,0),ag(r,s),void 0!==s.intensity&&(r.intensity=s.intensity),r.name=t.createUniqueName(s.name||"light_"+e),a=Promise.resolve(r),t.cache.add(i,a),a}getDependency(e,t){if("light"===e)return this._loadLight(t)}createNodeAttachment(e){const t=this,i=this.parser,a=i.json.nodes[e],n=(a.extensions&&a.extensions[this.name]||{}).light;return void 0===n?null:this._loadLight(n).then(function(e){return i._getNodeRef(t.cache,n,e)})}}class Sp{constructor(){this.name=wp.KHR_MATERIALS_UNLIT}getMaterialType(){return b}extendParams(e,t,i){const a=[];e.color=new d(1,1,1),e.opacity=1;const n=t.pbrMetallicRoughness;if(n){if(Array.isArray(n.baseColorFactor)){const t=n.baseColorFactor;e.color.setRGB(t[0],t[1],t[2],q),e.opacity=t[3]}void 0!==n.baseColorTexture&&a.push(i.assignTexture(e,"map",n.baseColorTexture,T))}return Promise.all(a)}}class xp{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=i.extensions[this.name].emissiveStrength;return void 0!==a&&(t.emissiveIntensity=a),Promise.resolve()}}class Cp{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser,a=i.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const n=[],s=a.extensions[this.name];if(void 0!==s.clearcoatFactor&&(t.clearcoat=s.clearcoatFactor),void 0!==s.clearcoatTexture&&n.push(i.assignTexture(t,"clearcoatMap",s.clearcoatTexture)),void 0!==s.clearcoatRoughnessFactor&&(t.clearcoatRoughness=s.clearcoatRoughnessFactor),void 0!==s.clearcoatRoughnessTexture&&n.push(i.assignTexture(t,"clearcoatRoughnessMap",s.clearcoatRoughnessTexture)),void 0!==s.clearcoatNormalTexture&&(n.push(i.assignTexture(t,"clearcoatNormalMap",s.clearcoatNormalTexture)),void 0!==s.clearcoatNormalTexture.scale)){const e=s.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new o(e,e)}return Promise.all(n)}}class Pp{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_DISPERSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=i.extensions[this.name];return t.dispersion=void 0!==a.dispersion?a.dispersion:0,Promise.resolve()}}class kp{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser,a=i.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const n=[],s=a.extensions[this.name];return void 0!==s.iridescenceFactor&&(t.iridescence=s.iridescenceFactor),void 0!==s.iridescenceTexture&&n.push(i.assignTexture(t,"iridescenceMap",s.iridescenceTexture)),void 0!==s.iridescenceIor&&(t.iridescenceIOR=s.iridescenceIor),void 0===t.iridescenceThicknessRange&&(t.iridescenceThicknessRange=[100,400]),void 0!==s.iridescenceThicknessMinimum&&(t.iridescenceThicknessRange[0]=s.iridescenceThicknessMinimum),void 0!==s.iridescenceThicknessMaximum&&(t.iridescenceThicknessRange[1]=s.iridescenceThicknessMaximum),void 0!==s.iridescenceThicknessTexture&&n.push(i.assignTexture(t,"iridescenceThicknessMap",s.iridescenceThicknessTexture)),Promise.all(n)}}class Dp{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser,a=i.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const n=[];t.sheenColor=new d(0,0,0),t.sheenRoughness=0,t.sheen=1;const s=a.extensions[this.name];if(void 0!==s.sheenColorFactor){const e=s.sheenColorFactor;t.sheenColor.setRGB(e[0],e[1],e[2],q)}return void 0!==s.sheenRoughnessFactor&&(t.sheenRoughness=s.sheenRoughnessFactor),void 0!==s.sheenColorTexture&&n.push(i.assignTexture(t,"sheenColorMap",s.sheenColorTexture,T)),void 0!==s.sheenRoughnessTexture&&n.push(i.assignTexture(t,"sheenRoughnessMap",s.sheenRoughnessTexture)),Promise.all(n)}}class Ap{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser,a=i.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const n=[],s=a.extensions[this.name];return void 0!==s.transmissionFactor&&(t.transmission=s.transmissionFactor),void 0!==s.transmissionTexture&&n.push(i.assignTexture(t,"transmissionMap",s.transmissionTexture)),Promise.all(n)}}class _p{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser,a=i.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const n=[],s=a.extensions[this.name];t.thickness=void 0!==s.thicknessFactor?s.thicknessFactor:0,void 0!==s.thicknessTexture&&n.push(i.assignTexture(t,"thicknessMap",s.thicknessTexture)),t.attenuationDistance=s.attenuationDistance||1/0;const r=s.attenuationColor||[1,1,1];return t.attenuationColor=(new d).setRGB(r[0],r[1],r[2],q),Promise.all(n)}}class Tp{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const a=i.extensions[this.name];return t.ior=void 0!==a.ior?a.ior:1.5,Promise.resolve()}}class Ip{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser,a=i.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const n=[],s=a.extensions[this.name];t.specularIntensity=void 0!==s.specularFactor?s.specularFactor:1,void 0!==s.specularTexture&&n.push(i.assignTexture(t,"specularIntensityMap",s.specularTexture));const r=s.specularColorFactor||[1,1,1];return t.specularColor=(new d).setRGB(r[0],r[1],r[2],q),void 0!==s.specularColorTexture&&n.push(i.assignTexture(t,"specularColorMap",s.specularColorTexture,T)),Promise.all(n)}}class Op{constructor(e){this.parser=e,this.name=wp.EXT_MATERIALS_BUMP}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser,a=i.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const n=[],s=a.extensions[this.name];return t.bumpScale=void 0!==s.bumpFactor?s.bumpFactor:1,void 0!==s.bumpTexture&&n.push(i.assignTexture(t,"bumpMap",s.bumpTexture)),Promise.all(n)}}class Rp{constructor(e){this.parser=e,this.name=wp.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?j:null}extendMaterialParams(e,t){const i=this.parser,a=i.json.materials[e];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();const n=[],s=a.extensions[this.name];return void 0!==s.anisotropyStrength&&(t.anisotropy=s.anisotropyStrength),void 0!==s.anisotropyRotation&&(t.anisotropyRotation=s.anisotropyRotation),void 0!==s.anisotropyTexture&&n.push(i.assignTexture(t,"anisotropyMap",s.anisotropyTexture)),Promise.all(n)}}class Ep{constructor(e){this.parser=e,this.name=wp.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,a=i.textures[e];if(!a.extensions||!a.extensions[this.name])return null;const n=a.extensions[this.name],s=t.options.ktx2Loader;if(!s){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,n.source,s)}}class Bp{constructor(e){this.parser=e,this.name=wp.EXT_TEXTURE_WEBP}loadTexture(e){const t=this.name,i=this.parser,a=i.json,n=a.textures[e];if(!n.extensions||!n.extensions[t])return null;const s=n.extensions[t],r=a.images[s.source];let o=i.textureLoader;if(r.uri){const e=i.options.manager.getHandler(r.uri);null!==e&&(o=e)}return i.loadTextureImage(e,s.source,o)}}class Fp{constructor(e){this.parser=e,this.name=wp.EXT_TEXTURE_AVIF}loadTexture(e){const t=this.name,i=this.parser,a=i.json,n=a.textures[e];if(!n.extensions||!n.extensions[t])return null;const s=n.extensions[t],r=a.images[s.source];let o=i.textureLoader;if(r.uri){const e=i.options.manager.getHandler(r.uri);null!==e&&(o=e)}return i.loadTextureImage(e,s.source,o)}}class zp{constructor(e){this.name=wp.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const e=i.extensions[this.name],a=this.parser.getDependency("buffer",e.buffer),n=this.parser.options.meshoptDecoder;if(!n||!n.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return a.then(function(t){const i=e.byteOffset||0,a=e.byteLength||0,s=e.count,r=e.byteStride,o=new Uint8Array(t,i,a);return n.decodeGltfBufferAsync?n.decodeGltfBufferAsync(s,r,o,e.mode,e.filter).then(function(e){return e.buffer}):n.ready.then(function(){const t=new ArrayBuffer(s*r);return n.decodeGltfBuffer(new Uint8Array(t),s,r,o,e.mode,e.filter),t})})}return null}}class Lp{constructor(e){this.name=wp.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,i=t.nodes[e];if(!i.extensions||!i.extensions[this.name]||void 0===i.mesh)return null;const a=t.meshes[i.mesh];for(const e of a.primitives)if(e.mode!==$p.TRIANGLES&&e.mode!==$p.TRIANGLE_STRIP&&e.mode!==$p.TRIANGLE_FAN&&void 0!==e.mode)return null;const n=i.extensions[this.name].attributes,s=[],r={};for(const e in n)s.push(this.parser.getDependency("accessor",n[e]).then(t=>(r[e]=t,r[e])));return s.length<1?null:(s.push(this.parser.createNodeMesh(e)),Promise.all(s).then(e=>{const t=e.pop(),i=t.isGroup?t.children:[t],a=e[0].count,n=[];for(const e of i){const t=new $,i=new g,s=new x,o=new g(1,1,1),l=new Y(e.geometry,e.material,a);for(let e=0;e<a;e++)r.TRANSLATION&&i.fromBufferAttribute(r.TRANSLATION,e),r.ROTATION&&s.fromBufferAttribute(r.ROTATION,e),r.SCALE&&o.fromBufferAttribute(r.SCALE,e),l.setMatrixAt(e,t.compose(i,s,o));for(const t in r)if("_COLOR_0"===t){const e=r[t];l.instanceColor=new X(e.array,e.itemSize,e.normalized)}else"TRANSLATION"!==t&&"ROTATION"!==t&&"SCALE"!==t&&e.geometry.setAttribute(t,r[t]);Q.prototype.copy.call(l,e),this.parser.assignFinalMaterial(l),n.push(l)}return t.isGroup?(t.clear(),t.add(...n),t):n[0]}))}}const Gp="glTF";class Vp{constructor(e){this.name=wp.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12),i=new TextDecoder;if(this.header={magic:i.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Gp)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const a=this.header.length-12,n=new DataView(e,12);let s=0;for(;s<a;){const t=n.getUint32(s,!0);s+=4;const a=n.getUint32(s,!0);if(s+=4,1313821514===a){const a=new Uint8Array(e,12+s,t);this.content=i.decode(a)}else if(5130562===a){const i=12+s;this.body=e.slice(i,i+t)}s+=t}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Np{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=wp.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,a=this.dracoLoader,n=e.extensions[this.name].bufferView,s=e.extensions[this.name].attributes,r={},o={},l={};for(const e in s){const t=Zp[e]||e.toLowerCase();r[t]=s[e]}for(const t in e.attributes){const a=Zp[t]||t.toLowerCase();if(void 0!==s[t]){const n=i.accessors[e.attributes[t]],s=Yp[n.componentType];l[a]=s.name,o[a]=!0===n.normalized}}return t.getDependency("bufferView",n).then(function(e){return new Promise(function(t,i){a.decodeDracoFile(e,function(e){for(const t in e.attributes){const i=e.attributes[t],a=o[t];void 0!==a&&(i.normalized=a)}t(e)},r,l,q,i)})})}}class jp{constructor(){this.name=wp.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&t.texCoord!==e.channel||void 0!==t.offset||void 0!==t.rotation||void 0!==t.scale?(e=e.clone(),void 0!==t.texCoord&&(e.channel=t.texCoord),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0,e):e}}class qp{constructor(){this.name=wp.KHR_MESH_QUANTIZATION}}class Up extends Ae{constructor(e,t,i,a){super(e,t,i,a)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,a=this.valueSize,n=e*a*3+a;for(let e=0;e!==a;e++)t[e]=i[n+e];return t}interpolate_(e,t,i,a){const n=this.resultBuffer,s=this.sampleValues,r=this.valueSize,o=2*r,l=3*r,c=a-t,h=(i-t)/c,u=h*h,d=u*h,m=e*l,p=m-l,g=-2*d+3*u,f=d-u,y=1-g,v=f-u+h;for(let e=0;e!==r;e++){const t=s[p+e+r],i=s[p+e+o]*c,a=s[m+e+r],l=s[m+e]*c;n[e]=y*t+v*i+g*a+f*l}return n}}const Wp=new x;class Hp extends Up{interpolate_(e,t,i,a){const n=super.interpolate_(e,t,i,a);return Wp.fromArray(n).normalize().toArray(n),n}}const $p={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Yp={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Xp={9728:re,9729:p,9984:se,9985:ne,9986:ae,9987:ie},Qp={33071:ce,33648:le,10497:oe},Kp={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Zp={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Jp={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},eg={CUBICSPLINE:void 0,LINEAR:Me,STEP:we};function tg(e){return void 0===e.DefaultMaterial&&(e.DefaultMaterial=new he({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:De})),e.DefaultMaterial}function ig(e,t,i){for(const a in i.extensions)void 0===e[a]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[a]=i.extensions[a])}function ag(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function ng(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let i=0,a=t.weights.length;i<a;i++)e.morphTargetInfluences[i]=t.weights[i];if(t.extras&&Array.isArray(t.extras.targetNames)){const i=t.extras.targetNames;if(e.morphTargetInfluences.length===i.length){e.morphTargetDictionary={};for(let t=0,a=i.length;t<a;t++)e.morphTargetDictionary[i[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function sg(e){let t;const i=e.extensions&&e.extensions[wp.KHR_DRACO_MESH_COMPRESSION];if(t=i?"draco:"+i.bufferView+":"+i.indices+":"+rg(i.attributes):e.indices+":"+rg(e.attributes)+":"+e.mode,void 0!==e.targets)for(let i=0,a=e.targets.length;i<a;i++)t+=":"+rg(e.targets[i]);return t}function rg(e){let t="";const i=Object.keys(e).sort();for(let a=0,n=i.length;a<n;a++)t+=i[a]+":"+e[i[a]]+";";return t}function og(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const lg=new $;class cg{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new bp,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,a=-1,n=!1,s=-1;if("undefined"!=typeof navigator){const e=navigator.userAgent;i=!0===/^((?!chrome|android).)*safari/i.test(e);const t=e.match(/Version\/(\d+)/);a=i&&t?parseInt(t[1],10):-1,n=e.indexOf("Firefox")>-1,s=n?e.match(/Firefox\/([0-9]+)\./)[1]:-1}"undefined"==typeof createImageBitmap||i&&a<17||n&&s<98?this.textureLoader=new K(this.options.manager):this.textureLoader=new Z(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new _(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,a=this.json,n=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(e){return e._markDefs&&e._markDefs()}),Promise.all(this._invokeAll(function(e){return e.beforeRoot&&e.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(t){const s={scene:t[0][a.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:a.asset,parser:i,userData:{}};return ig(n,s,a),ag(s,a),Promise.all(i._invokeAll(function(e){return e.afterRoot&&e.afterRoot(s)})).then(function(){for(const e of s.scenes)e.updateMatrixWorld();e(s)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let i=0,a=t.length;i<a;i++){const a=t[i].joints;for(let t=0,i=a.length;t<i;t++)e[a[t]].isBone=!0}for(let t=0,a=e.length;t<a;t++){const a=e[t];void 0!==a.mesh&&(this._addNodeRef(this.meshCache,a.mesh),void 0!==a.skin&&(i[a.mesh].isSkinnedMesh=!0)),void 0!==a.camera&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const a=i.clone(),n=(e,t)=>{const i=this.associations.get(e);null!=i&&this.associations.set(t,i);for(const[i,a]of e.children.entries())n(a,t.children[i])};return n(i,a),a.name+="_instance_"+e.uses[t]++,a}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const a=e(t[i]);if(a)return a}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let a=0;a<t.length;a++){const n=e(t[a]);n&&i.push(n)}return i}getDependency(e,t){const i=e+":"+t;let a=this.cache.get(i);if(!a){switch(e){case"scene":a=this.loadScene(t);break;case"node":a=this._invokeOne(function(e){return e.loadNode&&e.loadNode(t)});break;case"mesh":a=this._invokeOne(function(e){return e.loadMesh&&e.loadMesh(t)});break;case"accessor":a=this.loadAccessor(t);break;case"bufferView":a=this._invokeOne(function(e){return e.loadBufferView&&e.loadBufferView(t)});break;case"buffer":a=this.loadBuffer(t);break;case"material":a=this._invokeOne(function(e){return e.loadMaterial&&e.loadMaterial(t)});break;case"texture":a=this._invokeOne(function(e){return e.loadTexture&&e.loadTexture(t)});break;case"skin":a=this.loadSkin(t);break;case"animation":a=this._invokeOne(function(e){return e.loadAnimation&&e.loadAnimation(t)});break;case"camera":a=this.loadCamera(t);break;default:if(a=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!a)throw new Error("Unknown type: "+e)}this.cache.add(i,a)}return a}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,a=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(a.map(function(t,a){return i.getDependency(e,a)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[wp.KHR_BINARY_GLTF].body);const a=this.options;return new Promise(function(e,n){i.load(N.resolveURL(t.uri,a.path),e,void 0,function(){n(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(e){const i=t.byteLength||0,a=t.byteOffset||0;return e.slice(a,a+i)})}loadAccessor(e){const t=this,i=this.json,a=this.json.accessors[e];if(void 0===a.bufferView&&void 0===a.sparse){const e=Kp[a.type],t=Yp[a.componentType],i=!0===a.normalized,n=new t(a.count*e);return Promise.resolve(new J(n,e,i))}const n=[];return void 0!==a.bufferView?n.push(this.getDependency("bufferView",a.bufferView)):n.push(null),void 0!==a.sparse&&(n.push(this.getDependency("bufferView",a.sparse.indices.bufferView)),n.push(this.getDependency("bufferView",a.sparse.values.bufferView))),Promise.all(n).then(function(e){const n=e[0],s=Kp[a.type],r=Yp[a.componentType],o=r.BYTES_PER_ELEMENT,l=o*s,c=a.byteOffset||0,h=void 0!==a.bufferView?i.bufferViews[a.bufferView].byteStride:void 0,u=!0===a.normalized;let d,m;if(h&&h!==l){const e=Math.floor(c/h),i="InterleavedBuffer:"+a.bufferView+":"+a.componentType+":"+e+":"+a.count;let l=t.cache.get(i);l||(d=new r(n,e*h,a.count*h/o),l=new ee(d,h/o),t.cache.add(i,l)),m=new te(l,s,c%h/o,u)}else d=null===n?new r(a.count*s):new r(n,c,a.count*s),m=new J(d,s,u);if(void 0!==a.sparse){const t=Kp.SCALAR,i=Yp[a.sparse.indices.componentType],o=a.sparse.indices.byteOffset||0,l=a.sparse.values.byteOffset||0,c=new i(e[1],o,a.sparse.count*t),h=new r(e[2],l,a.sparse.count*s);null!==n&&(m=new J(m.array.slice(),m.itemSize,m.normalized)),m.normalized=!1;for(let e=0,t=c.length;e<t;e++){const t=c[e];if(m.setX(t,h[e*s]),s>=2&&m.setY(t,h[e*s+1]),s>=3&&m.setZ(t,h[e*s+2]),s>=4&&m.setW(t,h[e*s+3]),s>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}m.normalized=u}return m})}loadTexture(e){const t=this.json,i=this.options,a=t.textures[e].source,n=t.images[a];let s=this.textureLoader;if(n.uri){const e=i.manager.getHandler(n.uri);null!==e&&(s=e)}return this.loadTextureImage(e,a,s)}loadTextureImage(e,t,i){const a=this,n=this.json,s=n.textures[e],r=n.images[t],o=(r.uri||r.bufferView)+":"+s.sampler;if(this.textureCache[o])return this.textureCache[o];const l=this.loadImageSource(t,i).then(function(t){t.flipY=!1,t.name=s.name||r.name||"",""===t.name&&"string"==typeof r.uri&&!1===r.uri.startsWith("data:image/")&&(t.name=r.uri);const i=(n.samplers||{})[s.sampler]||{};return t.magFilter=Xp[i.magFilter]||p,t.minFilter=Xp[i.minFilter]||ie,t.wrapS=Qp[i.wrapS]||oe,t.wrapT=Qp[i.wrapT]||oe,t.generateMipmaps=!t.isCompressedTexture&&t.minFilter!==re&&t.minFilter!==p,a.associations.set(t,{textures:e}),t}).catch(function(){return null});return this.textureCache[o]=l,l}loadImageSource(e,t){const i=this.json,a=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then(e=>e.clone());const n=i.images[e],s=self.URL||self.webkitURL;let r=n.uri||"",o=!1;if(void 0!==n.bufferView)r=this.getDependency("bufferView",n.bufferView).then(function(e){o=!0;const t=new Blob([e],{type:n.mimeType});return r=s.createObjectURL(t),r});else if(void 0===n.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const l=Promise.resolve(r).then(function(e){return new Promise(function(i,n){let s=i;!0===t.isImageBitmapLoader&&(s=function(e){const t=new Se(e);t.needsUpdate=!0,i(t)}),t.load(N.resolveURL(e,a.path),s,void 0,n)})}).then(function(e){var t;return!0===o&&s.revokeObjectURL(r),ag(e,n),e.userData.mimeType=n.mimeType||((t=n.uri).search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/)?"image/jpeg":t.search(/\.webp($|\?)/i)>0||0===t.search(/^data\:image\/webp/)?"image/webp":t.search(/\.ktx2($|\?)/i)>0||0===t.search(/^data\:image\/ktx2/)?"image/ktx2":"image/png"),e}).catch(function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",r),e});return this.sourceCache[e]=l,l}assignTexture(e,t,i,a){const n=this;return this.getDependency("texture",i.index).then(function(s){if(!s)return null;if(void 0!==i.texCoord&&i.texCoord>0&&((s=s.clone()).channel=i.texCoord),n.extensions[wp.KHR_TEXTURE_TRANSFORM]){const e=void 0!==i.extensions?i.extensions[wp.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=n.associations.get(s);s=n.extensions[wp.KHR_TEXTURE_TRANSFORM].extendTexture(s,e),n.associations.set(s,t)}}return void 0!==a&&(s.colorSpace=a),e[t]=s,s})}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const a=void 0===t.attributes.tangent,n=void 0!==t.attributes.color,s=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+i.uuid;let t=this.cache.get(e);t||(t=new E,R.prototype.copy.call(t,i),t.color.copy(i.color),t.map=i.map,t.sizeAttenuation=!1,this.cache.add(e,t)),i=t}else if(e.isLine){const e="LineBasicMaterial:"+i.uuid;let t=this.cache.get(e);t||(t=new O,R.prototype.copy.call(t,i),t.color.copy(i.color),t.map=i.map,this.cache.add(e,t)),i=t}if(a||n||s){let e="ClonedMaterial:"+i.uuid+":";a&&(e+="derivative-tangents:"),n&&(e+="vertex-colors:"),s&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=i.clone(),n&&(t.vertexColors=!0),s&&(t.flatShading=!0),a&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(i))),i=t}e.material=i}getMaterialType(){return he}loadMaterial(e){const t=this,i=this.json,a=this.extensions,n=i.materials[e];let s;const r={},l=[];if((n.extensions||{})[wp.KHR_MATERIALS_UNLIT]){const e=a[wp.KHR_MATERIALS_UNLIT];s=e.getMaterialType(),l.push(e.extendParams(r,n,t))}else{const i=n.pbrMetallicRoughness||{};if(r.color=new d(1,1,1),r.opacity=1,Array.isArray(i.baseColorFactor)){const e=i.baseColorFactor;r.color.setRGB(e[0],e[1],e[2],q),r.opacity=e[3]}void 0!==i.baseColorTexture&&l.push(t.assignTexture(r,"map",i.baseColorTexture,T)),r.metalness=void 0!==i.metallicFactor?i.metallicFactor:1,r.roughness=void 0!==i.roughnessFactor?i.roughnessFactor:1,void 0!==i.metallicRoughnessTexture&&(l.push(t.assignTexture(r,"metalnessMap",i.metallicRoughnessTexture)),l.push(t.assignTexture(r,"roughnessMap",i.metallicRoughnessTexture))),s=this._invokeOne(function(t){return t.getMaterialType&&t.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,r)})))}!0===n.doubleSided&&(r.side=ue);const c=n.alphaMode||"OPAQUE";if("BLEND"===c?(r.transparent=!0,r.depthWrite=!1):(r.transparent=!1,"MASK"===c&&(r.alphaTest=void 0!==n.alphaCutoff?n.alphaCutoff:.5)),void 0!==n.normalTexture&&s!==b&&(l.push(t.assignTexture(r,"normalMap",n.normalTexture)),r.normalScale=new o(1,1),void 0!==n.normalTexture.scale)){const e=n.normalTexture.scale;r.normalScale.set(e,e)}if(void 0!==n.occlusionTexture&&s!==b&&(l.push(t.assignTexture(r,"aoMap",n.occlusionTexture)),void 0!==n.occlusionTexture.strength&&(r.aoMapIntensity=n.occlusionTexture.strength)),void 0!==n.emissiveFactor&&s!==b){const e=n.emissiveFactor;r.emissive=(new d).setRGB(e[0],e[1],e[2],q)}return void 0!==n.emissiveTexture&&s!==b&&l.push(t.assignTexture(r,"emissiveMap",n.emissiveTexture,T)),Promise.all(l).then(function(){const i=new s(r);return n.name&&(i.name=n.name),ag(i,n),t.associations.set(i,{materials:e}),n.extensions&&ig(a,i,n),i})}createUniqueName(e){const t=de.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,i=this.extensions,n=this.primitiveCache;function s(e){return i[wp.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then(function(i){return hg(i,e,t)})}const r=[];for(let i=0,o=e.length;i<o;i++){const o=e[i],l=sg(o),c=n[l];if(c)r.push(c.promise);else{let e;e=o.extensions&&o.extensions[wp.KHR_DRACO_MESH_COMPRESSION]?s(o):hg(new a,o,t),n[l]={primitive:o,promise:e},r.push(e)}}return Promise.all(r)}loadMesh(e){const i=this,a=this.json,n=this.extensions,s=a.meshes[e],r=s.primitives,o=[];for(let e=0,t=r.length;e<t;e++){const t=void 0===r[e].material?tg(this.cache):this.getDependency("material",r[e].material);o.push(t)}return o.push(i.loadGeometries(r)),Promise.all(o).then(function(a){const o=a.slice(0,a.length-1),l=a[a.length-1],c=[];for(let a=0,h=l.length;a<h;a++){const h=l[a],u=r[a];let d;const m=o[a];if(u.mode===$p.TRIANGLES||u.mode===$p.TRIANGLE_STRIP||u.mode===$p.TRIANGLE_FAN||void 0===u.mode)d=!0===s.isSkinnedMesh?new me(h,m):new t(h,m),!0===d.isSkinnedMesh&&d.normalizeSkinWeights(),u.mode===$p.TRIANGLE_STRIP?d.geometry=Nt(d.geometry,V):u.mode===$p.TRIANGLE_FAN&&(d.geometry=Nt(d.geometry,G));else if(u.mode===$p.LINES)d=new F(h,m);else if(u.mode===$p.LINE_STRIP)d=new pe(h,m);else if(u.mode===$p.LINE_LOOP)d=new ge(h,m);else{if(u.mode!==$p.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+u.mode);d=new z(h,m)}Object.keys(d.geometry.morphAttributes).length>0&&ng(d,s),d.name=i.createUniqueName(s.name||"mesh_"+e),ag(d,s),u.extensions&&ig(n,d,u),i.assignFinalMaterial(d),c.push(d)}for(let t=0,a=c.length;t<a;t++)i.associations.set(c[t],{meshes:e,primitives:t});if(1===c.length)return s.extensions&&ig(n,c[0],s),c[0];const h=new I;s.extensions&&ig(n,h,s),i.associations.set(h,{meshes:e});for(let e=0,t=c.length;e<t;e++)h.add(c[e]);return h})}loadCamera(e){let t;const a=this.json.cameras[e],n=a[a.type];if(n)return"perspective"===a.type?t=new fe(D.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):"orthographic"===a.type&&(t=new i(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),a.name&&(t.name=this.createUniqueName(a.name)),ag(t,a),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],i=[];for(let e=0,a=t.joints.length;e<a;e++)i.push(this._loadNodeShallow(t.joints[e]));return void 0!==t.inverseBindMatrices?i.push(this.getDependency("accessor",t.inverseBindMatrices)):i.push(null),Promise.all(i).then(function(e){const i=e.pop(),a=e,n=[],s=[];for(let e=0,r=a.length;e<r;e++){const r=a[e];if(r){n.push(r);const t=new $;null!==i&&t.fromArray(i.array,16*e),s.push(t)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}return new ye(n,s)})}loadAnimation(e){const t=this.json,i=this,a=t.animations[e],n=a.name?a.name:"animation_"+e,s=[],r=[],o=[],l=[],c=[];for(let e=0,t=a.channels.length;e<t;e++){const t=a.channels[e],i=a.samplers[t.sampler],n=t.target,h=n.node,u=void 0!==a.parameters?a.parameters[i.input]:i.input,d=void 0!==a.parameters?a.parameters[i.output]:i.output;void 0!==n.node&&(s.push(this.getDependency("node",h)),r.push(this.getDependency("accessor",u)),o.push(this.getDependency("accessor",d)),l.push(i),c.push(n))}return Promise.all([Promise.all(s),Promise.all(r),Promise.all(o),Promise.all(l),Promise.all(c)]).then(function(e){const t=e[0],s=e[1],r=e[2],o=e[3],l=e[4],c=[];for(let e=0,a=t.length;e<a;e++){const a=t[e],n=s[e],h=r[e],u=o[e],d=l[e];if(void 0===a)continue;a.updateMatrix&&a.updateMatrix();const m=i._createAnimationTracks(a,n,h,u,d);if(m)for(let e=0;e<m.length;e++)c.push(m[e])}const h=new ve(n,void 0,c);return ag(h,a),h})}createNodeMesh(e){const t=this.json,i=this,a=t.nodes[e];return void 0===a.mesh?null:i.getDependency("mesh",a.mesh).then(function(e){const t=i._getNodeRef(i.meshCache,a.mesh,e);return void 0!==a.weights&&t.traverse(function(e){if(e.isMesh)for(let t=0,i=a.weights.length;t<i;t++)e.morphTargetInfluences[t]=a.weights[t]}),t})}loadNode(e){const t=this,i=this.json.nodes[e],a=t._loadNodeShallow(e),n=[],s=i.children||[];for(let e=0,i=s.length;e<i;e++)n.push(t.getDependency("node",s[e]));const r=void 0===i.skin?Promise.resolve(null):t.getDependency("skin",i.skin);return Promise.all([a,Promise.all(n),r]).then(function(e){const t=e[0],i=e[1],a=e[2];null!==a&&t.traverse(function(e){e.isSkinnedMesh&&e.bind(a,lg)});for(let e=0,a=i.length;e<a;e++)t.add(i[e]);return t})}_loadNodeShallow(e){const t=this.json,i=this.extensions,a=this;if(void 0!==this.nodeCache[e])return this.nodeCache[e];const n=t.nodes[e],s=n.name?a.createUniqueName(n.name):"",r=[],o=a._invokeOne(function(t){return t.createNodeMesh&&t.createNodeMesh(e)});return o&&r.push(o),void 0!==n.camera&&r.push(a.getDependency("camera",n.camera).then(function(e){return a._getNodeRef(a.cameraCache,n.camera,e)})),a._invokeAll(function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)}).forEach(function(e){r.push(e)}),this.nodeCache[e]=Promise.all(r).then(function(t){let r;if(r=!0===n.isBone?new be:t.length>1?new I:1===t.length?t[0]:new Q,r!==t[0])for(let e=0,i=t.length;e<i;e++)r.add(t[e]);if(n.name&&(r.userData.name=n.name,r.name=s),ag(r,n),n.extensions&&ig(i,r,n),void 0!==n.matrix){const e=new $;e.fromArray(n.matrix),r.applyMatrix4(e)}else void 0!==n.translation&&r.position.fromArray(n.translation),void 0!==n.rotation&&r.quaternion.fromArray(n.rotation),void 0!==n.scale&&r.scale.fromArray(n.scale);if(a.associations.has(r)){if(void 0!==n.mesh&&a.meshCache.refs[n.mesh]>1){const e=a.associations.get(r);a.associations.set(r,{...e})}}else a.associations.set(r,{});return a.associations.get(r).nodes=e,r}),this.nodeCache[e]}loadScene(e){const t=this.extensions,i=this.json.scenes[e],a=this,n=new I;i.name&&(n.name=a.createUniqueName(i.name)),ag(n,i),i.extensions&&ig(t,n,i);const s=i.nodes||[],r=[];for(let e=0,t=s.length;e<t;e++)r.push(a.getDependency("node",s[e]));return Promise.all(r).then(function(e){for(let t=0,i=e.length;t<i;t++)n.add(e[t]);return a.associations=(e=>{const t=new Map;for(const[e,i]of a.associations)(e instanceof R||e instanceof Se)&&t.set(e,i);return e.traverse(e=>{const i=a.associations.get(e);null!=i&&t.set(e,i)}),t})(n),n})}_createAnimationTracks(e,t,i,a,n){const s=[],r=e.name?e.name:e.uuid,o=[];let l;switch(Jp[n.path]===Jp.weights?e.traverse(function(e){e.morphTargetInfluences&&o.push(e.name?e.name:e.uuid)}):o.push(r),Jp[n.path]){case Jp.weights:l=Ce;break;case Jp.rotation:l=Pe;break;case Jp.translation:case Jp.scale:l=xe;break;default:l=1===i.itemSize?Ce:xe}const c=void 0!==a.interpolation?eg[a.interpolation]:Me,h=this._getArrayFromAccessor(i);for(let e=0,i=o.length;e<i;e++){const i=new l(o[e]+"."+Jp[n.path],t.array,h,c);"CUBICSPLINE"===a.interpolation&&this._createCubicSplineTrackInterpolant(i),s.push(i)}return s}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const e=og(t.constructor),i=new Float32Array(t.length);for(let a=0,n=t.length;a<n;a++)i[a]=t[a]*e;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(e){return new(this instanceof Pe?Hp:Up)(this.times,this.values,this.getValueSize()/3,e)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function hg(e,t,i){const a=t.attributes,n=[];function s(t,a){return i.getDependency("accessor",t).then(function(t){e.setAttribute(a,t)})}for(const t in a){const i=Zp[t]||t.toLowerCase();i in e.attributes||n.push(s(a[t],i))}if(void 0!==t.indices&&!e.index){const a=i.getDependency("accessor",t.indices).then(function(t){e.setIndex(t)});n.push(a)}return ke.workingColorSpace!==q&&"COLOR_0"in a&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ke.workingColorSpace}" not supported.`),ag(e,t),function(e,t,i){const a=t.attributes,n=new _e;if(void 0===a.POSITION)return;{const e=i.json.accessors[a.POSITION],t=e.min,s=e.max;if(void 0===t||void 0===s)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(n.set(new g(t[0],t[1],t[2]),new g(s[0],s[1],s[2])),e.normalized){const t=og(Yp[e.componentType]);n.min.multiplyScalar(t),n.max.multiplyScalar(t)}}const s=t.targets;if(void 0!==s){const e=new g,t=new g;for(let a=0,n=s.length;a<n;a++){const n=s[a];if(void 0!==n.POSITION){const a=i.json.accessors[n.POSITION],s=a.min,r=a.max;if(void 0!==s&&void 0!==r){if(t.setX(Math.max(Math.abs(s[0]),Math.abs(r[0]))),t.setY(Math.max(Math.abs(s[1]),Math.abs(r[1]))),t.setZ(Math.max(Math.abs(s[2]),Math.abs(r[2]))),a.normalized){const e=og(Yp[a.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(e)}e.boundingBox=n;const r=new Te;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,e.boundingSphere=r}(e,t,i),Promise.all(n).then(function(){return void 0!==t.targets?function(e,t,i){let a=!1,n=!1,s=!1;for(let e=0,i=t.length;e<i;e++){const i=t[e];if(void 0!==i.POSITION&&(a=!0),void 0!==i.NORMAL&&(n=!0),void 0!==i.COLOR_0&&(s=!0),a&&n&&s)break}if(!a&&!n&&!s)return Promise.resolve(e);const r=[],o=[],l=[];for(let c=0,h=t.length;c<h;c++){const h=t[c];if(a){const t=void 0!==h.POSITION?i.getDependency("accessor",h.POSITION):e.attributes.position;r.push(t)}if(n){const t=void 0!==h.NORMAL?i.getDependency("accessor",h.NORMAL):e.attributes.normal;o.push(t)}if(s){const t=void 0!==h.COLOR_0?i.getDependency("accessor",h.COLOR_0):e.attributes.color;l.push(t)}}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(l)]).then(function(t){const i=t[0],r=t[1],o=t[2];return a&&(e.morphAttributes.position=i),n&&(e.morphAttributes.normal=r),s&&(e.morphAttributes.color=o),e.morphTargetsRelative=!0,e})}(e,t.targets,i):e})}class ug{constructor(t,i,a=16){this.maxElements=a,this.maxInstances=4*a,this.mesh=new e.InstancedMesh(t,i,this.maxInstances),this.mesh.frustumCulled=!1,this.mesh.count=0,this._createInstanceAttributes(),this.freeSlots=[],this.activeElements=new Map;for(let e=this.maxInstances-4;e>=0;e-=4)this.freeSlots.push(e);this._matrix=new e.Matrix4,this._position=new e.Vector3,this._quaternion=new e.Quaternion,this._scale=new e.Vector3(1,1,1),this._identityQuaternion=new e.Quaternion,this._unitScale=new e.Vector3(1,1,1),this.globalTime=0,this._pendingTimeouts=new Set}_createInstanceAttributes(){const t=this.maxInstances;this.spawnTimeArray=new Float32Array(t),this.spawnTimeAttr=new e.InstancedBufferAttribute(this.spawnTimeArray,1),this.mesh.geometry.setAttribute("aSpawnTime",this.spawnTimeAttr),this.exitTimeArray=new Float32Array(t),this.exitTimeAttr=new e.InstancedBufferAttribute(this.exitTimeArray,1),this.mesh.geometry.setAttribute("aExitTime",this.exitTimeAttr),this.selectedModelArray=new Float32Array(t),this.selectedModelAttr=new e.InstancedBufferAttribute(this.selectedModelArray,1),this.mesh.geometry.setAttribute("aSelectedModel",this.selectedModelAttr),this.opacityArray=new Float32Array(t).fill(1),this.opacityAttr=new e.InstancedBufferAttribute(this.opacityArray,1),this.mesh.geometry.setAttribute("aInstanceOpacity",this.opacityAttr),this.trailParentArray=new Float32Array(t).fill(-1),this.trailParentAttr=new e.InstancedBufferAttribute(this.trailParentArray,1),this.mesh.geometry.setAttribute("aTrailParent",this.trailParentAttr),this.trailIndexArray=new Float32Array(t).fill(-1),this.trailIndexAttr=new e.InstancedBufferAttribute(this.trailIndexArray,1),this.mesh.geometry.setAttribute("aTrailIndex",this.trailIndexAttr),this.velocityArray=new Float32Array(4*t),this.velocityAttr=new e.InstancedBufferAttribute(this.velocityArray,4),this.mesh.geometry.setAttribute("aVelocity",this.velocityAttr),this.randomSeedArray=new Float32Array(t);for(let e=0;e<t;e++)this.randomSeedArray[e]=Math.random();this.randomSeedAttr=new e.InstancedBufferAttribute(this.randomSeedArray,1),this.mesh.geometry.setAttribute("aRandomSeed",this.randomSeedAttr)}spawn(e,t,i,a,n=0,s=0){if(0===this.freeSlots.length)return console.warn("[ElementInstancePool] Pool full, cannot spawn"),!1;const r=this.freeSlots.pop(),o=[r+1,r+2,r+3],l=this.globalTime;this.activeElements.set(e,{mainSlot:r,trailSlots:o,spawnTime:l,exitTime:0,position:t.clone(),modelIndex:n}),this._setupInstance(r,t,i,a,{spawnTime:l,exitTime:0,modelIndex:n,opacity:0,trailParent:-1,trailIndex:-1,arcPhase:s});for(let e=0;e<3;e++){const c=o[e];this._setupInstance(c,t,i,a,{spawnTime:l,exitTime:0,modelIndex:n,opacity:0,trailParent:r,trailIndex:e,arcPhase:s})}return this._updateVisibleCount(),!0}_setupInstance(e,t,i,a,n){this._position.copy(t),this._quaternion.copy(i||this._identityQuaternion),this._scale.copy(a||this._unitScale),this._matrix.compose(this._position,this._quaternion,this._scale),this.mesh.setMatrixAt(e,this._matrix),this.spawnTimeArray[e]=n.spawnTime,this.exitTimeArray[e]=n.exitTime,this.selectedModelArray[e]=n.modelIndex,this.opacityArray[e]=n.opacity,this.trailParentArray[e]=n.trailParent,this.trailIndexArray[e]=n.trailIndex,"number"==typeof n.arcPhase&&(this.randomSeedArray[e]=n.arcPhase,this.randomSeedAttr.needsUpdate=!0),this.spawnTimeAttr.needsUpdate=!0,this.exitTimeAttr.needsUpdate=!0,this.selectedModelAttr.needsUpdate=!0,this.opacityAttr.needsUpdate=!0,this.trailParentAttr.needsUpdate=!0,this.trailIndexAttr.needsUpdate=!0,this.mesh.instanceMatrix.needsUpdate=!0}updatePosition(t,i,a){const n=this.activeElements.get(t);if(n){if(!a&&n.position&&(this._velocity=this._velocity||new e.Vector3,a=this._velocity.copy(i).sub(n.position)),n.position.copy(i),this.mesh.getMatrixAt(n.mainSlot,this._matrix),this._matrix.decompose(this._position,this._quaternion,this._scale),this._position.copy(i),this._matrix.compose(this._position,this._quaternion,this._scale),this.mesh.setMatrixAt(n.mainSlot,this._matrix),a){const e=a.length(),t=4*n.mainSlot;this.velocityArray[t]=a.x,this.velocityArray[t+1]=a.y,this.velocityArray[t+2]=a.z,this.velocityArray[t+3]=e,this.velocityAttr.needsUpdate=!0}this.mesh.instanceMatrix.needsUpdate=!0}}updateInstanceTransform(t,i,a,n,s=null){const r=this.activeElements.get(t);if(!r)return;r.position&&(s||(this._velocity=this._velocity||new e.Vector3,s=this._velocity.copy(i).sub(r.position)),r.position.copy(i)),this._position.copy(i),this._quaternion.copy(a),"number"==typeof n?this._scale.setScalar(n):this._scale.copy(n),this._matrix.compose(this._position,this._quaternion,this._scale),this.mesh.setMatrixAt(r.mainSlot,this._matrix);const o=this._scale.x,l=this._scale.y,c=this._scale.z,h=s&&s.lengthSq()>1e-4;for(let e=0;e<3;e++){const t=r.trailSlots[e],i=h?1-.15*(e+1):0;"number"==typeof n?this._scale.setScalar(n*i):this._scale.set(o*i,l*i,c*i),this._matrix.compose(this._position,this._quaternion,this._scale),this.mesh.setMatrixAt(t,this._matrix)}if(s){const e=s.length(),t=4*r.mainSlot;this.velocityArray[t]=s.x,this.velocityArray[t+1]=s.y,this.velocityArray[t+2]=s.z,this.velocityArray[t+3]=e,this.velocityAttr.needsUpdate=!0}this.mesh.instanceMatrix.needsUpdate=!0}updateInstanceOpacity(e,t){const i=this.activeElements.get(e);if(i){this.opacityArray[i.mainSlot]=t;for(let e=0;e<3;e++){const a=i.trailSlots[e];this.opacityArray[a]=t*(1-.25*(e+1))}this.opacityAttr.needsUpdate=!0}}beginDespawn(e,t=.5){const i=this.activeElements.get(e);if(!i)return;const a=this.globalTime;i.exitTime=a;const n=[i.mainSlot,...i.trailSlots];for(const e of n)this.exitTimeArray[e]=a;this.exitTimeAttr.needsUpdate=!0;const s=setTimeout(()=>{this._pendingTimeouts.delete(s),this._finalizeRemoval(e)},1e3*t);this._pendingTimeouts.add(s)}removeImmediate(e){this._finalizeRemoval(e)}_finalizeRemoval(e){const t=this.activeElements.get(e);if(!t)return;const i=[t.mainSlot,...t.trailSlots];for(const e of i)this._matrix.makeScale(0,0,0),this.mesh.setMatrixAt(e,this._matrix),this.spawnTimeArray[e]=0,this.exitTimeArray[e]=0,this.opacityArray[e]=0;this.freeSlots.push(t.mainSlot),this.activeElements.delete(e),this.mesh.instanceMatrix.needsUpdate=!0,this.spawnTimeAttr.needsUpdate=!0,this.exitTimeAttr.needsUpdate=!0,this.opacityAttr.needsUpdate=!0,this._updateVisibleCount()}clear(){for(const e of this.activeElements.keys())this._finalizeRemoval(e)}_updateVisibleCount(){let e=0;for(const t of this.activeElements.values()){const i=t.trailSlots[2];i>=e&&(e=i+1)}this.mesh.count=e}setTime(e){this.globalTime=e}get activeCount(){return this.activeElements.size}get availableSlots(){return this.freeSlots.length}getStats(){return{activeElements:this.activeElements.size,activeInstances:this.mesh.count,maxInstances:this.maxInstances,availableSlots:this.freeSlots.length,utilizationPercent:(this.activeElements.size/this.maxElements*100).toFixed(1)}}dispose(){for(const e of this._pendingTimeouts)clearTimeout(e);this._pendingTimeouts.clear(),this.clear(),this.mesh.geometry.dispose(),this.mesh.material.dispose(),this.mesh=null}}class dg{constructor(){this.geometries=[],this.modelNames=[]}addGeometry(e,t=null){const i=this.geometries.length;return this.geometries.push(e.clone()),this.modelNames.push(t||`model_${i}`),i}addMesh(e,t=null){return this.addGeometry(e.geometry,t||e.name)}build(){if(0===this.geometries.length)throw new Error("[MergedGeometryBuilder] No geometries added");let t=0,i=0;const a=[];for(const e of this.geometries){let n=e.index?e:this._convertToIndexed(e);a.push(n),t+=n.attributes.position.count,i+=n.index.count}const n=new e.BufferGeometry,s=new Float32Array(3*t),r=new Float32Array(3*t),o=new Float32Array(2*t),l=new Float32Array(t),c=new Uint32Array(i);let h=0,u=0,d=0;for(let e=0;e<a.length;e++){const t=a[e],i=t.attributes.position,n=t.attributes.normal,m=t.attributes.uv,p=t.index,g=i.count,f=p.count;for(let t=0;t<g;t++){const a=h+t;s[3*a]=i.getX(t),s[3*a+1]=i.getY(t),s[3*a+2]=i.getZ(t),l[a]=e}if(n)for(let e=0;e<g;e++){const t=h+e;r[3*t]=n.getX(e),r[3*t+1]=n.getY(e),r[3*t+2]=n.getZ(e)}if(m)for(let e=0;e<g;e++){const t=h+e;o[2*t]=m.getX(e),o[2*t+1]=m.getY(e)}for(let e=0;e<f;e++)c[u+e]=p.getX(e)+d;h+=g,u+=f,d+=g}n.setAttribute("position",new e.BufferAttribute(s,3)),n.setAttribute("normal",new e.BufferAttribute(r,3)),n.setAttribute("uv",new e.BufferAttribute(o,2)),n.setAttribute("aModelIndex",new e.BufferAttribute(l,1)),n.setIndex(new e.BufferAttribute(c,1)),n.computeBoundingSphere(),n.computeBoundingBox();const m=new Map;for(let e=0;e<this.modelNames.length;e++)m.set(this.modelNames[e],e);return{geometry:n,modelCount:this.geometries.length,modelMap:m}}_convertToIndexed(t){const i=t.attributes.position.count,a=new Uint32Array(i);for(let e=0;e<i;e++)a[e]=e;const n=t.clone();return n.setIndex(new e.BufferAttribute(a,1)),n}reset(){this.geometries=[],this.modelNames=[]}dispose(){for(const e of this.geometries)e.dispose();this.reset()}}const mg=new Map,pg={register(e,t){const i=["basePath","models","createMaterial","updateMaterial"];for(const a of i)if(!t[a])throw new Error(`[ElementTypeRegistry] Missing required field '${a}' for type '${e}'`);mg.set(e,{scaleMultiplier:1.5,setShaderAnimation:null,...t}),console.log(`[ElementTypeRegistry] Registered element type: ${e} (${t.models.length} models)`)},get:e=>mg.get(e),has:e=>mg.has(e),types:()=>Array.from(mg.keys()),unregister:e=>mg.delete(e),clear(){mg.clear()}},gg="\nfloat dHash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat dNoise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // smoothstep interpolation\n    float a = dHash(i);\n    float b = dHash(i + vec2(1.0, 0.0));\n    float c = dHash(i + vec2(0.0, 1.0));\n    float d = dHash(i + vec2(1.0, 1.0));\n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n",fg="\nvarying vec2 vUv;\nvarying vec3 vWorldPos;\n\nvoid main() {\n    vUv = uv;\n\n    // Transform vertex through instance + model + view\n    vec4 worldPos = modelMatrix * instanceMatrix * vec4(position, 1.0);\n    vWorldPos = worldPos.xyz;\n    vec4 clipPos = projectionMatrix * viewMatrix * worldPos;\n\n    gl_Position = clipPos;\n}\n",yg="\n// Per-instance attributes from ElementInstancePool\nattribute float aSpawnTime;       // When this instance spawned (global time)\nattribute float aExitTime;        // When fade-out started (0 = not exiting)\nattribute float aModelIndex;      // Vertex attribute: which model this vertex belongs to\nattribute float aSelectedModel;   // Instance attribute: which model to render\nattribute float aInstanceOpacity; // Per-instance opacity multiplier\nattribute float aTrailParent;     // Trail parent slot (-1 for main instance)\nattribute float aTrailIndex;      // Which trail copy (0-2, or -1 for main)\nattribute vec4 aVelocity;         // xyz = direction, w = speed\nattribute float aRandomSeed;      // Per-instance random for variation (also used as arc phase for vortex)\n\n// Passed to fragment shader\nvarying float vLocalTime;         // Time since this instance spawned\nvarying float vInstanceAlpha;     // Combined opacity from spawn/exit fades\nvarying float vTrailFade;         // Trail opacity fade (1.0 for main, 0.75/0.5/0.25 for trails)\nvarying vec4 vVelocity;           // For motion blur in fragment/post-process\n",vg="\nvarying float vLocalTime;\nvarying float vInstanceAlpha;\nvarying float vTrailFade;\nvarying vec4 vVelocity;\n",bg="\n// Permutation polynomial hash\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n// 3D Simplex noise\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\n// Fractal Brownian Motion - 3 octaves (reduced from 6 for GPU performance)\nfloat fbm3(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 3; i++) {\n        value += amplitude * snoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Turbulence - absolute value FBM for sharper, more chaotic patterns\nfloat turbulence(vec3 p, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 3; i++) {\n        if (i >= octaves) break;\n        value += amplitude * abs(snoise(p * frequency));\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Configurable octave FBM (3-5 octaves for quality control)\nfloat fbmConfigurable(vec3 p, int octaves) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 5; i++) {\n        if (i >= octaves) break;\n        value += amplitude * snoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Layered turbulence - multiple scales at different animation speeds\n// Creates more organic, billowing flame movement\n// BOOSTED: 5x faster speeds for visible movement\nfloat layeredTurbulence(vec3 p, float time) {\n    // Large-scale billowing (base movement) - visible slow roll\n    float large = turbulence(p * 0.5 + vec3(0.0, -time * 0.0025, 0.0), 3) * 0.4;\n\n    // Medium detail at medium speed (main flame movement)\n    float medium = turbulence(p + vec3(time * 0.0015, -time * 0.005, 0.0), 3) * 0.35;\n\n    // Fine detail fast movement (flickering wisps) - clearly visible\n    float fine = snoise(p * 2.5 + vec3(time * 0.003, -time * 0.01, time * 0.002)) * 0.25;\n\n    // Extra fast micro-detail for shimmer\n    float micro = snoise(p * 4.0 + vec3(0.0, -time * 0.02, 0.0)) * 0.1;\n\n    return large + medium + fine + micro;\n}\n";function wg(e,t,i,a){return a<.5?e+2*a*(t-e):t+2*(a-.5)*(i-t)}const Mg={temperature:.5,opacity:.45,flameHeight:.08,turbulence:.03,displacementStrength:.04,noiseScale:4,edgeFade:.25,fadeInDuration:.3,fadeOutDuration:.5,velocityStretch:.5},Sg={PERLIN:0},xg="\nuniform int uAnimationType;\nuniform float uGestureProgress;\nuniform float uGlowScale;            // Glow intensity multiplier (0=off, 1=normal, >1=bloom)\n\n// Two-layer composable cutout system (shared across all element types)\nuniform float uCutoutStrength;       // 0-1 overall cutout intensity\nuniform float uCutoutPhase;          // Animation phase offset\n// Primary pattern layer\nuniform int uCutoutPattern1;         // Primary pattern type (-1=none, 0-5)\nuniform float uCutoutScale1;         // Primary pattern scale\nuniform float uCutoutWeight1;        // Primary pattern weight (0-1)\n// Secondary pattern layer\nuniform int uCutoutPattern2;         // Secondary pattern type (-1=none, 0-5)\nuniform float uCutoutScale2;         // Secondary pattern scale\nuniform float uCutoutWeight2;        // Secondary pattern weight (0-1)\n// Blend mode\nuniform int uCutoutBlend;            // 0=multiply, 1=min, 2=max, 3=add\n// Travel animation (sweeps cutout around geometry)\nuniform int uCutoutTravel;           // 0=none, 1=angular, 2=radial, 3=spiral, 4=oscillate, 5=wave\nuniform float uCutoutTravelSpeed;    // Rotations/expansions per gesture (default 1.0)\nuniform int uCutoutTravelDir;        // 0=forward, 1=reverse, 2=pingpong\n// Per-layer travel (secondary layer can have different travel)\nuniform int uCutoutTravel2;          // Travel mode for secondary layer (-1=same as primary)\nuniform float uCutoutTravelSpeed2;   // Travel speed for secondary layer\n// Strength animation\nuniform int uCutoutStrengthCurve;    // 0=constant, 1=fadeIn, 2=fadeOut, 3=bell, 4=pulse\nuniform float uCutoutFadeInDuration; // For fadeIn: fraction of gesture to reach full (0.33 = 1/3)\nuniform float uCutoutFadeOutDuration;// For fadeOut: fraction of gesture for fade (0.33 = last 1/3)\nuniform float uCutoutBellPeakAt;     // For bell: where peak occurs (0.5 = middle, 0.3 = early)\nuniform float uCutoutBellWidth;      // For bell: plateau width (0=sharp peak, 0.5=50% at full, 0.8=80% at full)\n// Trail dissolve - fades out bottom of each instance as it moves\nuniform int uTrailDissolveEnabled;   // 0=off, 1=enabled\nuniform float uTrailDissolveOffset;  // Y offset from instance position (negative = below)\nuniform float uTrailDissolveSoftness;// Gradient softness (higher = softer transition)\n// Grain system - noise-based texture overlay\nuniform int uGrainType;              // -1=none, 0=perlin, 1=simplex, 2=white, 3=film\nuniform float uGrainStrength;        // 0-1 grain visibility\nuniform float uGrainScale;           // Pattern scale (0.1=fine, 2.0=coarse)\nuniform float uGrainSpeed;           // Animation speed (0=static)\nuniform int uGrainBlend;             // 0=multiply, 1=add, 2=overlay, 3=screen\n// Geometric mask - restricts cutout to specific regions of the model geometry\nuniform int uCutoutGeoMaskType;      // 0=none, 1=distance (length(pos) for tips)\nuniform float uCutoutGeoMaskCore;    // Radius where geometry is fully solid (no cutout)\nuniform float uCutoutGeoMaskTip;     // Radius where cutout is fully applied\n// Edge mask - restricts cutout to visual silhouette edges (screen-space anisotropy, any geometry)\nuniform float uCutoutEdgeMask;       // 0=disabled, 0.3=narrow silhouette, 0.6=wide band\n",Cg="\n// Calculate cutout mask for a single pattern\n// vertGradient: normalized vertical position (0=bottom, 1=top) for tip-based effects\nfloat calcCutoutPattern(int pattern, vec3 pos, float scale, float time, float vertGradient) {\n    if (pattern < 0) return 1.0;  // NONE pattern = fully visible\n\n    vec3 scaledPos = pos * scale;\n\n    if (pattern == 0) {\n        // CELLULAR: Organic cell-like holes\n        vec3 cellPos = scaledPos * 6.0 + vec3(time * 0.5, 0.0, 0.0);\n        float cell1 = snoise(cellPos);\n        float cell2 = snoise(cellPos * 1.7 + vec3(50.0));\n        float cellPattern = min(cell1, cell2);\n        return smoothstep(-0.3, 0.1, cellPattern);\n\n    } else if (pattern == 1) {\n        // STREAKS: Flow-aligned streak holes\n        float streakAngle = atan(pos.y, pos.x);\n        float streakPhase = streakAngle * 4.0 + time * 3.0;\n        float streak = sin(streakPhase);\n        float streak2 = sin(streakPhase * 0.7 + 2.094);\n        float streakPattern = max(streak, streak2);\n        return smoothstep(-0.2, 0.3, streakPattern);\n\n    } else if (pattern == 2) {\n        // RADIAL: Burst pattern from center\n        float dist = length(pos.xz);\n        float angle = atan(pos.z, pos.x);\n        float radialWave = sin(dist * 8.0 - time * 4.0 + angle * 3.0);\n        float radialNoise = snoise(scaledPos * 4.0 + vec3(time)) * 0.3;\n        return smoothstep(-0.2, 0.4, radialWave + radialNoise);\n\n    } else if (pattern == 3) {\n        // VORONOI: Cracked/shattered pattern\n        vec3 voronoiPos = scaledPos * 5.0;\n        float n1 = snoise(voronoiPos);\n        float n2 = snoise(voronoiPos * 2.0 + vec3(100.0));\n        float n3 = snoise(voronoiPos * 0.5 + vec3(-50.0));\n        float cracks = abs(n1) + abs(n2) * 0.5 + abs(n3) * 0.3;\n        return smoothstep(0.3, 0.7, cracks);\n\n    } else if (pattern == 4) {\n        // WAVES: Interference pattern\n        float wave1 = sin(pos.x * 10.0 + time * 2.0);\n        float wave2 = sin(pos.z * 10.0 + time * 2.5);\n        float wave3 = sin((pos.x + pos.z) * 7.0 - time * 1.5);\n        float wavePattern = wave1 + wave2 + wave3;\n        return smoothstep(-0.5, 1.5, wavePattern);\n\n    } else if (pattern == 5) {\n        // EMBERS: Burning ember holes (great for fire)\n        vec3 emberPos = scaledPos * 8.0 + vec3(0.0, -time * 2.0, 0.0);\n        float ember1 = snoise(emberPos);\n        float ember2 = snoise(emberPos * 1.5 + vec3(30.0, time, 0.0));\n        float heat = snoise(vec3(pos.xy * 3.0, time * 0.5)) * 0.3;\n        float emberPattern = ember1 * ember2 + heat;\n        float heightBias = smoothstep(0.0, 1.0, pos.y + 0.5) * 0.3;\n        return smoothstep(-0.2 - heightBias, 0.3 - heightBias, emberPattern);\n\n    } else if (pattern == 6) {\n        // SPIRAL: Spiral arms pattern (meditation, vortex)\n        float angle = atan(pos.z, pos.x);\n        float dist = length(pos.xz);\n        float spiralArms = 3.0;  // Number of spiral arms\n        float spiralTightness = 4.0 * scale;\n        float spiralPhase = angle * spiralArms + dist * spiralTightness - time * 2.0;\n        float spiral = sin(spiralPhase);\n        // Add noise for organic feel\n        float spiralNoise = snoise(scaledPos * 3.0 + vec3(time * 0.5)) * 0.3;\n        return smoothstep(-0.3, 0.4, spiral + spiralNoise);\n\n    } else if (pattern == 7) {\n        // DISSOLVE: Edge erosion inward (fade-outs)\n        // Uses noise to create eroding edge effect\n        vec3 dissolvePos = scaledPos * 5.0;\n        float noise1 = snoise(dissolvePos);\n        float noise2 = snoise(dissolvePos * 2.0 + vec3(100.0)) * 0.5;\n        float noise3 = snoise(dissolvePos * 4.0 + vec3(-100.0)) * 0.25;\n        float dissolveNoise = noise1 + noise2 + noise3;\n        // Edge distance factor - dissolve from edges\n        float edgeDist = 1.0 - length(pos.xz) * 0.5;\n        float dissolve = dissolveNoise + edgeDist * 0.5 + time * 0.3;\n        return smoothstep(-0.2, 0.4, dissolve);\n\n    } else if (pattern == 8) {\n        // CRACKS: Branching fracture lines (shatter)\n        vec3 crackPos = scaledPos * 4.0;\n        // Create multiple octaves of crack-like noise\n        float crack1 = abs(snoise(crackPos));\n        float crack2 = abs(snoise(crackPos * 2.0 + vec3(50.0))) * 0.5;\n        float crack3 = abs(snoise(crackPos * 4.0 + vec3(-50.0))) * 0.25;\n        // Cracks are thin lines (low absolute values)\n        float cracks = crack1 + crack2 + crack3;\n        // Animate crack spreading\n        float crackSpread = sin(time * 1.5) * 0.2;\n        return smoothstep(0.15 + crackSpread, 0.4, cracks);\n\n    // Pattern 9 (TIPS) removed - use geometricMask: { type: 'distance' } instead\n\n    } else if (pattern == 10) {\n        // BURN: Consumption line traveling with organic noisy edge\n        // Enhanced: Multi-octave noise for organic burning\n\n        // Burn line progresses over time\n        float burnProgress = time * 0.5;\n\n        // Multi-octave noise for organic burning edge\n        float noise1 = snoise(vec3(pos.xz * scale * 2.0, time * 0.5)) * 0.12;\n        float noise2 = snoise(vec3(pos.xz * scale * 4.0 + 10.0, time * 0.8)) * 0.06;\n        float noiseEdge = noise1 + noise2;\n\n        // Burn from top down: pixels above burnLine get consumed\n        float burn = smoothstep(burnProgress - 0.1 + noiseEdge, burnProgress + 0.1 + noiseEdge, 1.0 - vertGradient);\n        return 1.0 - burn;\n    }\n\n    // Pattern 11 (FRINGE) removed - use geometricMask: { type: 'distance' } with any pattern\n\n    return 1.0;  // Default: fully visible\n}\n",Pg="\n// ═══════════════════════════════════════════════════════════════════════════════════════\n// TWO-LAYER COMPOSABLE CUTOUT SYSTEM\n// ═══════════════════════════════════════════════════════════════════════════════════════\n\n// Declare at outer scope so element-specific foam/edge effects can access it\nfloat finalCutout = 1.0;\nfloat trailAlpha = 1.0;  // Trail dissolve alpha - available for materials to use\n\nif (uCutoutStrength > 0.01 && uCutoutPattern1 >= 0) {\n    float cutoutTime = localTime * 0.001 + uCutoutPhase;\n\n    // Apply strength curve to modulate cutout strength over gesture\n    float curvedStrength = uCutoutStrength;\n    if (uCutoutStrengthCurve == 1) {\n        // FADE_IN: Strength ramps up from 0 to full over fadeInDuration\n        // fadeInDuration=0.33 means reach full strength at 1/3 of gesture\n        float fadeProgress = uCutoutFadeInDuration > 0.01\n            ? min(1.0, uGestureProgress / uCutoutFadeInDuration)\n            : uGestureProgress;\n        curvedStrength *= fadeProgress;\n    } else if (uCutoutStrengthCurve == 2) {\n        // FADE_OUT: Strength stays full then ramps down over fadeOutDuration\n        // fadeOutDuration=0.33 means stay at full until 67%, then fade over last 33%\n        float fadeOutStart = 1.0 - uCutoutFadeOutDuration;\n        float fadeProgress = uGestureProgress < fadeOutStart\n            ? 0.0\n            : (uGestureProgress - fadeOutStart) / max(0.01, uCutoutFadeOutDuration);\n        curvedStrength *= (1.0 - fadeProgress);\n    } else if (uCutoutStrengthCurve == 3) {\n        // BELL: Strength peaks at bellPeakAt with configurable plateau width\n        // bellPeakAt=0.5 is symmetric, bellPeakAt=0.3 peaks early\n        // bellWidth controls how long it stays at full strength:\n        //   0.0 = sharp peak (immediate ramp up/down)\n        //   0.5 = 50% of gesture at full strength\n        //   0.8 = 80% of gesture at full strength (very flat)\n        float peakAt = max(0.01, min(0.99, uCutoutBellPeakAt));\n        float halfWidth = uCutoutBellWidth * 0.5;\n        float plateauStart = max(0.0, peakAt - halfWidth);\n        float plateauEnd = min(1.0, peakAt + halfWidth);\n\n        float bellValue;\n        if (uGestureProgress < plateauStart) {\n            // Ramping up to plateau\n            bellValue = uGestureProgress / max(0.01, plateauStart);\n        } else if (uGestureProgress > plateauEnd) {\n            // Ramping down from plateau\n            bellValue = 1.0 - (uGestureProgress - plateauEnd) / max(0.01, 1.0 - plateauEnd);\n        } else {\n            // At plateau (full strength)\n            bellValue = 1.0;\n        }\n        curvedStrength *= bellValue;\n    } else if (uCutoutStrengthCurve == 4) {\n        // PULSE: Multiple pulses during gesture\n        curvedStrength *= 0.5 + 0.5 * sin(uGestureProgress * 12.566);  // 2 full pulses\n    } else if (uCutoutStrengthCurve == 5) {\n        // TOP_HEAVY: Strength increases toward top of element\n        float topFactor = smoothstep(0.0, 1.0, vVerticalGradient);\n        curvedStrength *= topFactor;\n    } else if (uCutoutStrengthCurve == 6) {\n        // TIPS: Only affects the very tips (top 25%)\n        float tipsFactor = smoothstep(0.75, 1.0, vVerticalGradient);\n        curvedStrength *= tipsFactor;\n    } else if (uCutoutStrengthCurve == 7) {\n        // CONSUME: Progressive eating from top down over gesture time\n        float consumeProgress = uGestureProgress;\n        float consumeFactor = smoothstep(1.0 - consumeProgress, 1.0 - consumeProgress + 0.2, vVerticalGradient);\n        curvedStrength *= consumeFactor;\n    }\n\n    // Trail dissolve is applied after finalCutout calculation (see below)\n\n    // Calculate travel progress with direction support\n    float travelProgress = uGestureProgress * uCutoutTravelSpeed;\n    if (uCutoutTravelDir == 1) {\n        // REVERSE: Run travel backwards\n        travelProgress = (1.0 - uGestureProgress) * uCutoutTravelSpeed;\n    } else if (uCutoutTravelDir == 2) {\n        // PINGPONG: Forward then reverse\n        float pingpongT = uGestureProgress * 2.0;\n        travelProgress = (pingpongT < 1.0 ? pingpongT : (2.0 - pingpongT)) * uCutoutTravelSpeed;\n    }\n\n    // Apply travel offset to position for primary pattern sampling\n    vec3 travelPos = vPosition;\n    if (uCutoutTravel == 1) {\n        // ANGULAR: Rotate position around Y axis\n        float travelAngle = travelProgress * 6.28318;\n        float cosA = cos(travelAngle);\n        float sinA = sin(travelAngle);\n        travelPos.x = vPosition.x * cosA - vPosition.z * sinA;\n        travelPos.z = vPosition.x * sinA + vPosition.z * cosA;\n    } else if (uCutoutTravel == 2) {\n        // RADIAL: Scale position from center\n        float radialScale = 1.0 + (travelProgress - 0.5) * 2.0;\n        travelPos.xz *= radialScale;\n    } else if (uCutoutTravel == 3) {\n        // SPIRAL: Rotate + expand simultaneously (hypnotic)\n        float spiralAngle = travelProgress * 6.28318;\n        float spiralScale = 1.0 + travelProgress * 0.5;\n        float cosA = cos(spiralAngle);\n        float sinA = sin(spiralAngle);\n        travelPos.x = (vPosition.x * cosA - vPosition.z * sinA) * spiralScale;\n        travelPos.z = (vPosition.x * sinA + vPosition.z * cosA) * spiralScale;\n    } else if (uCutoutTravel == 4) {\n        // OSCILLATE: Ping-pong back and forth (breathing)\n        float oscillateT = sin(travelProgress * 6.28318) * 0.5 + 0.5;\n        float oscillateAngle = oscillateT * 3.14159;  // Half rotation oscillation\n        float cosA = cos(oscillateAngle);\n        float sinA = sin(oscillateAngle);\n        travelPos.x = vPosition.x * cosA - vPosition.z * sinA;\n        travelPos.z = vPosition.x * sinA + vPosition.z * cosA;\n    } else if (uCutoutTravel == 5) {\n        // WAVE: Sine wave propagation (ripple)\n        float wavePhase = travelProgress * 6.28318;\n        float dist = length(vPosition.xz);\n        float waveOffset = sin(dist * 4.0 - wavePhase) * 0.3;\n        travelPos.xz *= 1.0 + waveOffset;\n    } else if (uCutoutTravel == 6) {\n        // VERTICAL: Progress travels bottom→top along vertical gradient\n        // Shifts the pattern sampling based on Y position and progress\n        float verticalShift = travelProgress * 2.0 - 1.0; // -1 to 1\n        travelPos.y += verticalShift;\n    } else if (uCutoutTravel == 7) {\n        // CONSUME: Burns inward from tips, eating the flame\n        // Modifies Y to create consumption from top\n        float consumeLine = 1.0 - travelProgress; // Starts at 1.0, goes to 0\n        travelPos.y = vPosition.y - consumeLine;\n    }\n\n    // Calculate primary pattern mask using travel-offset position\n    float mask1 = calcCutoutPattern(uCutoutPattern1, travelPos, uCutoutScale1, cutoutTime, vVerticalGradient);\n    mask1 = mix(1.0, mask1, uCutoutWeight1);\n\n    // Calculate secondary pattern mask (if enabled)\n    float mask2 = 1.0;\n    if (uCutoutPattern2 >= 0) {\n        // Per-layer travel: secondary can have different travel mode\n        vec3 travelPos2 = vPosition;\n        int travel2Mode = uCutoutTravel2 < 0 ? uCutoutTravel : uCutoutTravel2;\n        float travel2Speed = uCutoutTravel2 < 0 ? uCutoutTravelSpeed : uCutoutTravelSpeed2;\n        float travel2Progress = uGestureProgress * travel2Speed;\n\n        // Apply direction to secondary travel too\n        if (uCutoutTravelDir == 1) {\n            travel2Progress = (1.0 - uGestureProgress) * travel2Speed;\n        } else if (uCutoutTravelDir == 2) {\n            float pingpongT = uGestureProgress * 2.0;\n            travel2Progress = (pingpongT < 1.0 ? pingpongT : (2.0 - pingpongT)) * travel2Speed;\n        }\n\n        if (travel2Mode == 1) {\n            float angle2 = travel2Progress * 6.28318;\n            float c2 = cos(angle2); float s2 = sin(angle2);\n            travelPos2.x = vPosition.x * c2 - vPosition.z * s2;\n            travelPos2.z = vPosition.x * s2 + vPosition.z * c2;\n        } else if (travel2Mode == 2) {\n            float scale2 = 1.0 + (travel2Progress - 0.5) * 2.0;\n            travelPos2.xz *= scale2;\n        } else if (travel2Mode == 3) {\n            float angle2 = travel2Progress * 6.28318;\n            float scale2 = 1.0 + travel2Progress * 0.5;\n            float c2 = cos(angle2); float s2 = sin(angle2);\n            travelPos2.x = (vPosition.x * c2 - vPosition.z * s2) * scale2;\n            travelPos2.z = (vPosition.x * s2 + vPosition.z * c2) * scale2;\n        } else if (travel2Mode == 4) {\n            float osc2 = sin(travel2Progress * 6.28318) * 0.5 + 0.5;\n            float angle2 = osc2 * 3.14159;\n            float c2 = cos(angle2); float s2 = sin(angle2);\n            travelPos2.x = vPosition.x * c2 - vPosition.z * s2;\n            travelPos2.z = vPosition.x * s2 + vPosition.z * c2;\n        } else if (travel2Mode == 5) {\n            float phase2 = travel2Progress * 6.28318;\n            float dist2 = length(vPosition.xz);\n            float wave2 = sin(dist2 * 4.0 - phase2) * 0.3;\n            travelPos2.xz *= 1.0 + wave2;\n        } else if (travel2Mode == 6) {\n            // VERTICAL\n            float verticalShift2 = travel2Progress * 2.0 - 1.0;\n            travelPos2.y += verticalShift2;\n        } else if (travel2Mode == 7) {\n            // CONSUME\n            float consumeLine2 = 1.0 - travel2Progress;\n            travelPos2.y = vPosition.y - consumeLine2;\n        }\n\n        mask2 = calcCutoutPattern(uCutoutPattern2, travelPos2, uCutoutScale2, cutoutTime, vVerticalGradient);\n        mask2 = mix(1.0, mask2, uCutoutWeight2);\n    }\n\n    // Blend the two masks\n    float cutoutMask = 1.0;\n    if (uCutoutBlend == 0) {\n        // MULTIPLY: Hole where EITHER has hole (more holes)\n        cutoutMask = mask1 * mask2;\n    } else if (uCutoutBlend == 1) {\n        // MIN: Hole only where BOTH have holes (fewer holes)\n        cutoutMask = min(mask1, mask2);\n    } else if (uCutoutBlend == 2) {\n        // MAX: Keep highest value (fewer holes)\n        cutoutMask = max(mask1, mask2);\n    } else if (uCutoutBlend == 3) {\n        // ADD: Smooth blend, clamped\n        cutoutMask = clamp(mask1 + mask2 - 1.0, 0.0, 1.0);\n    }\n\n    // Apply curved cutout strength\n    finalCutout = mix(1.0, cutoutMask, curvedStrength);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // GEOMETRIC MASK: Restrict cutout to specific regions of the model\n    // Type 1 (distance): Uses length(pos) to target tips (far from model origin)\n    //                    Core is solid, tips have the cutout pattern\n    // Type 2 (inverted-distance): Inverts the mask for models with origin at tip\n    //                    Core has cutout pattern, tips are solid\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    if (uCutoutGeoMaskType == 1) {\n        // Distance-based mask: length(pos) identifies tips (vertices far from origin)\n        float geoDist = length(vPosition);\n        // geoMask: 0 at core (solid), 1 at tips (full cutout effect)\n        float geoMask = smoothstep(uCutoutGeoMaskCore, uCutoutGeoMaskTip, geoDist);\n        // Mix: core gets 1.0 (no holes), tips get the cutout pattern\n        finalCutout = mix(1.0, finalCutout, geoMask);\n    } else if (uCutoutGeoMaskType == 2) {\n        // INVERTED distance mask: for models with origin at tip (like flame-tongue)\n        // Core (near origin = tip) gets cutout, far regions (body) are solid\n        float geoDist = length(vPosition);\n        // geoMask: 1 at core (full cutout), 0 at far regions (solid)\n        float geoMask = 1.0 - smoothstep(uCutoutGeoMaskCore, uCutoutGeoMaskTip, geoDist);\n        // Mix: core gets the cutout pattern, far regions get 1.0 (no holes)\n        finalCutout = mix(1.0, finalCutout, geoMask);\n    } else if (uCutoutGeoMaskType == 3) {\n        // TIP-BOOST: Amplifies erosion near origin WITHOUT removing body pattern\n        // For models with origin at tip - boosts cutout there while keeping body intact\n        float geoDist = length(vPosition);\n        // tipBoost: 1 at origin (tips), 0 at body\n        float tipBoost = 1.0 - smoothstep(uCutoutGeoMaskCore, uCutoutGeoMaskTip, geoDist);\n        // Multiply pattern by factor to push tips toward holes\n        // At tips: factor ~0.3 (more holes), At body: factor = 1.0 (unchanged)\n        float boostFactor = mix(1.0, 0.3, tipBoost);\n        finalCutout = finalCutout * boostFactor;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // EDGE MASK: Restrict cutout to visual silhouette edges\n    // Uses screen-space derivative anisotropy — at silhouette edges, one derivative\n    // of vWorldPosition is much longer than the other (surface grazes the view ray).\n    // Unlike NdotV, this works on ANY geometry: torus, sphere, crystal, concave, etc.\n    // Composable with any travel mode — pattern+travel determine WHAT to cut,\n    // edge mask determines WHERE (only at the visual silhouette boundary).\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    if (uCutoutEdgeMask > 0.0) {\n        // Derivative ratio: how foreshortened is this fragment?\n        // ratio ≈ 1.0 face-on, high at silhouette edges (surface grazes view ray)\n        float lenX = length(dFdx(vWorldPosition));\n        float lenY = length(dFdy(vWorldPosition));\n        float edgeRatio = max(lenX, lenY) / max(min(lenX, lenY), 0.00001);\n\n        // Edge band: edgeMask controls tightness (0=wide band, 1=narrow edge only)\n        float lowThresh = mix(1.1, 2.5, uCutoutEdgeMask);\n        float highThresh = lowThresh + 0.8;\n        float edgeFactor = smoothstep(lowThresh, highThresh, edgeRatio);\n\n        // Two-step edge mask:\n        // 1) Suppress center: push cutout toward 1.0 (solid) away from edges\n        float maskedCutout = mix(1.0, finalCutout, edgeFactor);\n        // 2) Widen cracks at edges: pow squeezes near-crack values past the\n        //    0.5 discard threshold. pow(0.7, 3) = 0.34 → discarded.\n        //    Solid areas (1.0) stay at 1.0 regardless of power.\n        float widenPower = mix(1.0, 3.0, edgeFactor);\n        finalCutout = pow(maskedCutout, widenPower);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // TRAIL DISSOLVE: Fade alpha at bottom of each instance\n    // Uses ALPHA (not discard) so the existing cutout pattern edges remain organic\n    // No hard horizontal line - just a smooth fade that works WITH the pattern\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    if (uTrailDissolveEnabled == 1) {\n        // Distance from this fragment to the instance's floor\n        float instanceFloor = vInstancePosition.y + uTrailDissolveOffset;\n        float distFromFloor = vWorldPosition.y - instanceFloor;\n\n        // trailAlpha: 0 at floor, 1 at softness distance above\n        // This creates a SMOOTH FADE - no hard edge\n        trailAlpha = smoothstep(0.0, uTrailDissolveSoftness, distFromFloor);\n    }\n\n    // Binary discard for cutout pattern holes (creates organic edges)\n    if (finalCutout < 0.5) {\n        discard;\n    }\n}\n",kg="\n// ═══════════════════════════════════════════════════════════════════════════════════════\n// GRAIN SYSTEM - NOISE TEXTURE OVERLAY\n// ═══════════════════════════════════════════════════════════════════════════════════════\n\nif (uGrainType >= 0 && uGrainStrength > 0.01) {\n    float grainTime = localTime * 0.001 * uGrainSpeed;\n    vec3 grainPos = vPosition * uGrainScale * 10.0;\n\n    float grain = 0.0;\n\n    if (uGrainType == 0) {\n        // PERLIN: Smooth flowing noise\n        grain = snoise(grainPos + vec3(grainTime, 0.0, 0.0));\n        grain = grain * 0.5 + 0.5;  // Normalize to 0-1\n\n    } else if (uGrainType == 1) {\n        // SIMPLEX: Similar character, offset sampling\n        vec3 offset = vec3(100.0, grainTime * 1.5, 50.0);\n        grain = snoise(grainPos + offset);\n        grain = grain * 0.5 + 0.5;\n\n    } else if (uGrainType == 2) {\n        // WHITE: Random pixel noise (fast changing)\n        // Use fract-based pseudo-random\n        vec3 whitePos = grainPos * 100.0 + vec3(grainTime * 50.0);\n        grain = fract(sin(dot(whitePos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\n    } else if (uGrainType == 3) {\n        // FILM: Perlin + white hybrid (cinematic)\n        float perlin = snoise(grainPos + vec3(grainTime, 0.0, 0.0));\n        perlin = perlin * 0.5 + 0.5;\n        vec3 whitePos = grainPos * 80.0 + vec3(grainTime * 30.0);\n        float white = fract(sin(dot(whitePos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n        grain = mix(perlin, white, 0.3);  // 70% perlin, 30% white\n\n    } else if (uGrainType == 4) {\n        // TIP_WEIGHTED: Noise multiplied by vertical position (stronger at tips)\n        float baseNoise = snoise(grainPos + vec3(grainTime, 0.0, 0.0));\n        baseNoise = baseNoise * 0.5 + 0.5;\n        // Weight by vertical position - more grain at top (uses vVerticalGradient)\n        float tipWeight = smoothstep(0.0, 1.0, vVerticalGradient);\n        grain = baseNoise * tipWeight + (1.0 - tipWeight) * 0.8;  // Less effect at bottom\n    }\n\n    // Boost noise contrast - push values toward 0 or 1 for visible grain\n    grain = smoothstep(0.3, 0.7, grain);  // Increase contrast\n\n    // Apply grain based on blend mode\n    float grainEffect = mix(1.0, grain, uGrainStrength);\n\n    if (uGrainBlend == 0) {\n        // MULTIPLY: Creates noise holes for gritty texture\n        // Uses pre-computed grain value from type system (PERLIN, SIMPLEX, WHITE, FILM)\n\n        // Discard pixels where grain is below threshold (creates holes)\n        float threshold = 0.5 * uGrainStrength;\n        if (grain < threshold) {\n            discard;\n        }\n        // Darken remaining pixels based on grain\n        color *= 0.7 + grain * 0.3;\n\n    } else if (uGrainBlend == 1) {\n        // ADD: Brightens (sparkle/shimmer)\n        color += (grain - 0.5) * uGrainStrength * 0.5;\n\n    } else if (uGrainBlend == 2) {\n        // OVERLAY: Increases contrast\n        vec3 overlay;\n        for (int i = 0; i < 3; i++) {\n            float c = color[i];\n            float g = grain;\n            overlay[i] = c < 0.5 ? 2.0 * c * g : 1.0 - 2.0 * (1.0 - c) * (1.0 - g);\n        }\n        color = mix(color, overlay, uGrainStrength);\n\n    } else if (uGrainBlend == 3) {\n        // SCREEN: Soft brightening (ethereal)\n        vec3 screened = 1.0 - (1.0 - color) * (1.0 - vec3(grain * 0.5));\n        color = mix(color, screened, uGrainStrength);\n    }\n}\n",Dg={animationType:0,gestureProgress:0,glowScale:1,arcWidth:.5,arcSpeed:1,arcCount:1,rippleSpeed:.5,rippleCount:3,flowDirection:0,spiralTightness:2,spiralSpeed:1,pulseFrequency:2,pulseAmplitude:.3,cutoutStrength:0,cutoutPhase:0,cutoutPattern1:-1,cutoutScale1:1,cutoutWeight1:1,cutoutPattern2:-1,cutoutScale2:1,cutoutWeight2:1,cutoutBlend:0,cutoutTravel:0,cutoutTravelSpeed:1,cutoutTravelDir:0,cutoutTravel2:-1,cutoutTravelSpeed2:1,cutoutStrengthCurve:0,cutoutFadeInDuration:1,cutoutFadeOutDuration:1,cutoutBellPeakAt:.5,cutoutBellWidth:0,trailDissolveEnabled:0,trailDissolveOffset:-.3,trailDissolveSoftness:.25,grainType:-1,grainStrength:0,grainScale:.5,grainSpeed:1,grainBlend:0,cutoutGeoMaskType:0,cutoutGeoMaskCore:.3,cutoutGeoMaskTip:.4,cutoutEdgeMask:0};function Ag(){return{uAnimationType:{value:Dg.animationType},uGestureProgress:{value:Dg.gestureProgress},uGlowScale:{value:Dg.glowScale},uArcWidth:{value:Dg.arcWidth},uArcSpeed:{value:Dg.arcSpeed},uArcCount:{value:Dg.arcCount},uRippleSpeed:{value:Dg.rippleSpeed},uRippleCount:{value:Dg.rippleCount},uFlowDirection:{value:Dg.flowDirection},uSpiralTightness:{value:Dg.spiralTightness},uSpiralSpeed:{value:Dg.spiralSpeed},uPulseFrequency:{value:Dg.pulseFrequency},uPulseAmplitude:{value:Dg.pulseAmplitude},uCutoutStrength:{value:Dg.cutoutStrength},uCutoutPhase:{value:Dg.cutoutPhase},uCutoutPattern1:{value:Dg.cutoutPattern1},uCutoutScale1:{value:Dg.cutoutScale1},uCutoutWeight1:{value:Dg.cutoutWeight1},uCutoutPattern2:{value:Dg.cutoutPattern2},uCutoutScale2:{value:Dg.cutoutScale2},uCutoutWeight2:{value:Dg.cutoutWeight2},uCutoutBlend:{value:Dg.cutoutBlend},uCutoutTravel:{value:Dg.cutoutTravel},uCutoutTravelSpeed:{value:Dg.cutoutTravelSpeed},uCutoutTravelDir:{value:Dg.cutoutTravelDir},uCutoutTravel2:{value:Dg.cutoutTravel2},uCutoutTravelSpeed2:{value:Dg.cutoutTravelSpeed2},uCutoutStrengthCurve:{value:Dg.cutoutStrengthCurve},uCutoutFadeInDuration:{value:Dg.cutoutFadeInDuration},uCutoutFadeOutDuration:{value:Dg.cutoutFadeOutDuration},uCutoutBellPeakAt:{value:Dg.cutoutBellPeakAt},uCutoutBellWidth:{value:Dg.cutoutBellWidth},uTrailDissolveEnabled:{value:Dg.trailDissolveEnabled},uTrailDissolveOffset:{value:Dg.trailDissolveOffset},uTrailDissolveSoftness:{value:Dg.trailDissolveSoftness},uGrainType:{value:Dg.grainType},uGrainStrength:{value:Dg.grainStrength},uGrainScale:{value:Dg.grainScale},uGrainSpeed:{value:Dg.grainSpeed},uGrainBlend:{value:Dg.grainBlend},uCutoutGeoMaskType:{value:Dg.cutoutGeoMaskType},uCutoutGeoMaskCore:{value:Dg.cutoutGeoMaskCore},uCutoutGeoMaskTip:{value:Dg.cutoutGeoMaskTip},uCutoutEdgeMask:{value:Dg.cutoutEdgeMask}}}function _g(e,t){if(!e?.uniforms)return;if("number"==typeof t)return e.uniforms.uCutoutStrength.value=Math.max(0,Math.min(1,t)),void(e.uniforms.uCutoutPattern1.value=0);const{strength:i=Dg.cutoutStrength,phase:a=Dg.cutoutPhase,primary:n,secondary:s,blend:r="multiply",travel:o="none",travelSpeed:l=Dg.cutoutTravelSpeed,travelDir:c="forward",strengthCurve:h="constant",fadeInDuration:u=Dg.cutoutFadeInDuration,fadeOutDuration:d=Dg.cutoutFadeOutDuration,bellPeakAt:m=Dg.cutoutBellPeakAt,bellWidth:p=Dg.cutoutBellWidth,trailDissolve:g,geometricMask:f,edgeMask:y=0,pattern:v,scale:b}=t||{},w="number"==typeof r?r:{multiply:0,min:1,max:2,add:3}[r]??0,M={none:0,angular:1,radial:2,spiral:3,oscillate:4,wave:5,vertical:6,consume:7},S="number"==typeof o?o:M[o]??0,x="number"==typeof c?c:{forward:0,reverse:1,pingpong:2}[c]??0,C="number"==typeof h?h:{constant:0,fadeIn:1,fadeOut:2,bell:3,pulse:4,topHeavy:5,tips:6,consume:7}[h]??0;if(e.uniforms.uCutoutStrength.value=Math.max(0,Math.min(1,i)),e.uniforms.uCutoutPhase.value=a,e.uniforms.uCutoutBlend.value=w,e.uniforms.uCutoutTravel.value=S,e.uniforms.uCutoutTravelSpeed.value=l,e.uniforms.uCutoutTravelDir.value=x,e.uniforms.uCutoutStrengthCurve.value=C,e.uniforms.uCutoutFadeInDuration.value=Math.max(.01,Math.min(1,u)),e.uniforms.uCutoutFadeOutDuration.value=Math.max(.01,Math.min(1,d)),e.uniforms.uCutoutBellPeakAt.value=Math.max(.01,Math.min(.99,m)),e.uniforms.uCutoutBellWidth.value=Math.max(0,Math.min(.95,p)),g?(e.uniforms.uTrailDissolveEnabled.value=!1!==g.enabled?1:0,void 0!==g.offset&&(e.uniforms.uTrailDissolveOffset.value=g.offset),void 0!==g.softness&&(e.uniforms.uTrailDissolveSoftness.value=Math.max(.01,g.softness))):e.uniforms.uTrailDissolveEnabled.value=0,f){let t=0;"number"==typeof f.type?t=f.type:"distance"===f.type?t=1:"inverted-distance"===f.type?t=2:"tip-boost"===f.type&&(t=3),e.uniforms.uCutoutGeoMaskType.value=t,void 0!==f.core&&(e.uniforms.uCutoutGeoMaskCore.value=f.core),void 0!==f.tip&&(e.uniforms.uCutoutGeoMaskTip.value=f.tip)}else e.uniforms.uCutoutGeoMaskType.value=0;if(e.uniforms.uCutoutEdgeMask&&(e.uniforms.uCutoutEdgeMask.value=Math.max(0,Math.min(1,y))),void 0!==n)if(e.uniforms.uCutoutPattern1.value=n.pattern??0,e.uniforms.uCutoutScale1.value=n.scale??1,e.uniforms.uCutoutWeight1.value=n.weight??1,void 0!==s)if(e.uniforms.uCutoutPattern2.value=s.pattern??-1,e.uniforms.uCutoutScale2.value=s.scale??1,e.uniforms.uCutoutWeight2.value=s.weight??1,void 0!==s.travel){const t="number"==typeof s.travel?s.travel:M[s.travel]??-1;e.uniforms.uCutoutTravel2.value=t,e.uniforms.uCutoutTravelSpeed2.value=s.travelSpeed??1}else e.uniforms.uCutoutTravel2.value=-1;else e.uniforms.uCutoutPattern2.value=-1,e.uniforms.uCutoutTravel2.value=-1;else void 0!==v&&(e.uniforms.uCutoutPattern1.value=v,e.uniforms.uCutoutScale1.value=b??1,e.uniforms.uCutoutWeight1.value=1,e.uniforms.uCutoutPattern2.value=-1,e.uniforms.uCutoutTravel2.value=-1)}function Tg(e){e?.uniforms&&(e.uniforms.uCutoutStrength.value=0,e.uniforms.uCutoutPhase.value=Dg.cutoutPhase,e.uniforms.uCutoutPattern1.value=Dg.cutoutPattern1,e.uniforms.uCutoutScale1.value=Dg.cutoutScale1,e.uniforms.uCutoutWeight1.value=Dg.cutoutWeight1,e.uniforms.uCutoutPattern2.value=Dg.cutoutPattern2,e.uniforms.uCutoutScale2.value=Dg.cutoutScale2,e.uniforms.uCutoutWeight2.value=Dg.cutoutWeight2,e.uniforms.uCutoutBlend.value=Dg.cutoutBlend,e.uniforms.uCutoutTravel.value=Dg.cutoutTravel,e.uniforms.uCutoutTravelSpeed.value=Dg.cutoutTravelSpeed,e.uniforms.uCutoutTravelDir.value=Dg.cutoutTravelDir,e.uniforms.uCutoutTravel2.value=Dg.cutoutTravel2,e.uniforms.uCutoutTravelSpeed2.value=Dg.cutoutTravelSpeed2,e.uniforms.uCutoutStrengthCurve.value=Dg.cutoutStrengthCurve,e.uniforms.uCutoutFadeInDuration.value=Dg.cutoutFadeInDuration,e.uniforms.uCutoutFadeOutDuration.value=Dg.cutoutFadeOutDuration,e.uniforms.uCutoutBellPeakAt.value=Dg.cutoutBellPeakAt,e.uniforms.uCutoutBellWidth.value=Dg.cutoutBellWidth,e.uniforms.uTrailDissolveEnabled.value=Dg.trailDissolveEnabled,e.uniforms.uTrailDissolveOffset.value=Dg.trailDissolveOffset,e.uniforms.uTrailDissolveSoftness.value=Dg.trailDissolveSoftness,e.uniforms.uCutoutGeoMaskType.value=Dg.cutoutGeoMaskType,e.uniforms.uCutoutGeoMaskCore.value=Dg.cutoutGeoMaskCore,e.uniforms.uCutoutGeoMaskTip.value=Dg.cutoutGeoMaskTip,e.uniforms.uCutoutEdgeMask&&(e.uniforms.uCutoutEdgeMask.value=Dg.cutoutEdgeMask))}function Ig(e,t={}){if(!e?.uniforms)return;const{type:i=Sg.PERLIN,strength:a=.15,scale:n=.5,speed:s=1,blend:r="multiply"}=t,o={multiply:0,add:1,overlay:2,screen:3};e.uniforms.uGrainType.value=i,e.uniforms.uGrainStrength.value=a,e.uniforms.uGrainScale.value=n,e.uniforms.uGrainSpeed.value=s;let l=0;"number"==typeof r?l=r:r in o&&(l=o[r]),e.uniforms.uGrainBlend.value=l}function Og(e){e?.uniforms&&(e.uniforms.uGrainType.value=Dg.grainType,e.uniforms.uGrainStrength.value=Dg.grainStrength,e.uniforms.uGrainScale.value=Dg.grainScale,e.uniforms.uGrainSpeed.value=Dg.grainSpeed,e.uniforms.uGrainBlend.value=Dg.grainBlend)}function Rg(e,t={}){if(!e?.uniforms)return;const{type:i=0,...a}=t;e.uniforms.uAnimationType.value=i,void 0!==a.arcWidth&&(e.uniforms.uArcWidth.value=a.arcWidth),void 0!==a.arcSpeed&&(e.uniforms.uArcSpeed.value=a.arcSpeed),void 0!==a.arcCount&&(e.uniforms.uArcCount.value=a.arcCount),void 0!==a.rippleSpeed&&(e.uniforms.uRippleSpeed.value=a.rippleSpeed),void 0!==a.rippleCount&&(e.uniforms.uRippleCount.value=a.rippleCount),void 0!==a.flowDirection&&(e.uniforms.uFlowDirection.value=a.flowDirection),void 0!==a.spiralTightness&&(e.uniforms.uSpiralTightness.value=a.spiralTightness),void 0!==a.spiralSpeed&&(e.uniforms.uSpiralSpeed.value=a.spiralSpeed),void 0!==a.pulseFrequency&&(e.uniforms.uPulseFrequency.value=a.pulseFrequency),void 0!==a.pulseAmplitude&&(e.uniforms.uPulseAmplitude.value=a.pulseAmplitude)}function Eg(e,t){if(e?.uniforms?.uGestureProgress&&(e.uniforms.uGestureProgress.value=t),e?.userData?.gestureGlow&&e?.uniforms?.uGlowScale){const{baseGlow:i,peakGlow:a,curve:n}=e.userData.gestureGlow;let s=t;"easeIn"===n?s*=s:"easeOut"===n?s=1-(1-s)*(1-s):"easeInOut"===n&&(s=s<.5?2*s*s:1-Math.pow(-2*s+2,2)/2),e.uniforms.uGlowScale.value=i+(a-i)*s}}function Bg(e,t={}){if(!e)return;const{baseGlow:i=Dg.glowScale,peakGlow:a=Dg.glowScale,curve:n="linear"}=t;e.userData.gestureGlow={baseGlow:i,peakGlow:a,curve:n},e?.uniforms?.uGlowScale&&(e.uniforms.uGlowScale.value=i)}function Fg(e){if(e?.uniforms&&(e.uniforms.uAnimationType.value=0,e.uniforms.uGestureProgress.value=0,e.uniforms.uGlowScale)){const t=e.userData?.gestureGlow;e.uniforms.uGlowScale.value=t?.baseGlow??Dg.glowScale}}const zg=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uFlameHeight;\nuniform float uTurbulence;\nuniform float uDisplacementStrength;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;      // 0=none, 1=rotating arc\nuniform float uArcWidth;         // Arc width in radians\nuniform float uArcSpeed;         // Rotations per gesture\nuniform int uArcCount;           // Number of visible arcs\nuniform float uGestureProgress;  // 0-1 gesture progress\n// Note: Arc phase is now a per-instance attribute (aArcPhase) from InstancedShaderUtils\n\n// Per-instance attributes\n${yg}\n\n// Velocity stretch uniform\nuniform float uVelocityStretch;\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;  // Instance origin in world space (for trail dissolve)\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vDisplacement;\nvarying float vVerticalGradient;\nvarying float vArcVisibility;  // 0-1 visibility based on arc position\nvarying float vRandomSeed;     // Pass random seed to fragment for per-instance variation\n\n${bg}\n\nvoid main() {\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // INSTANCING: Calculate local time and fade\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade in/out - now controlled entirely by aInstanceOpacity from AnimationState\n    // The shader's built-in fadeIn/fadeOut (based on spawn/exit time) is disabled\n    // so that AnimationState has full control over fade timing\n    float fadeIn = 1.0;  // Disabled - AnimationState controls via aInstanceOpacity\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    // aInstanceOpacity now controls ALL fade timing (enter/hold/exit)\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // MODEL SELECTION: Scale non-selected models to zero\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // TRAIL OFFSET: Position trails behind main along velocity\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // FIRE ANIMATION (using local time, not global)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vPosition = selectedPosition;\n    // Note: Normal transform will be done after instanceMatrix is applied\n\n    float modelHeight = 1.0;\n    vVerticalGradient = (selectedPosition.y + 0.5) / modelHeight;\n    vVerticalGradient = clamp(vVerticalGradient, 0.0, 1.0);\n\n    // Use instance fade for displacement\n    // aInstanceOpacity provides smooth, configurable fade timing from AnimationState\n    // fadeIn is now always 1.0 (disabled), so fadeFactor = fadeOut * aInstanceOpacity\n    float fadeFactor = fadeOut * aInstanceOpacity;\n\n    // Add random seed variation for per-instance uniqueness\n    float instanceVariation = aRandomSeed * 0.3;\n\n    // Noise-based displacement (using local time for time-offset animation)\n    vec3 noisePos = selectedPosition * 3.0 + vec3(instanceVariation, -effectiveLocalTime * 0.001, instanceVariation);\n    float noiseValue = fbm3(noisePos);\n\n    float posVariation = snoise(selectedPosition * 5.0 + vec3(aRandomSeed * 10.0)) * 0.3 + 0.85;\n\n    float heightFactor = pow(vVerticalGradient, 0.5);\n    float displacement = noiseValue * uDisplacementStrength * (0.3 + heightFactor * 0.7) * posVariation * fadeFactor;\n\n    vec3 displaced = selectedPosition + selectedNormal * displacement;\n    displaced.y += heightFactor * uFlameHeight * (0.5 + noiseValue * 0.5) * fadeFactor;\n\n    float turbX = snoise(noisePos + vec3(100.0, 0.0, 0.0)) * uTurbulence * heightFactor * posVariation * fadeFactor;\n    float turbZ = snoise(noisePos + vec3(0.0, 0.0, 100.0)) * uTurbulence * heightFactor * posVariation * fadeFactor;\n    displaced.x += turbX * 0.3;\n    displaced.z += turbZ * 0.3;\n\n    // Apply trail offset\n    displaced += trailOffset;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // VELOCITY-BASED STRETCHING\n    // ═══════════════════════════════════════════════════════════════════════════════\n    if (uVelocityStretch > 0.01 && length(aVelocity.xyz) > 0.01) {\n        vec3 velocityDir = normalize(aVelocity.xyz);\n        float speed = aVelocity.w;\n\n        // Project vertex onto velocity direction\n        float alongVelocity = dot(displaced, velocityDir);\n\n        // Stretch factor increases with speed\n        float stretchFactor = 1.0 + speed * uVelocityStretch * 0.5;\n\n        // Apply stretch along velocity direction (more at top of flame)\n        vec3 stretchOffset = velocityDir * alongVelocity * (stretchFactor - 1.0);\n        displaced += stretchOffset * heightFactor;\n    }\n\n    vDisplacement = displacement;\n\n    // Pass random seed to fragment for per-instance flicker variation\n    vRandomSeed = aRandomSeed;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // CRITICAL: Apply instance matrix for per-instance transforms!\n    // instanceMatrix contains position/rotation/scale set in ElementInstancePool\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    // Transform normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve - uses cutout at instance floor)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ARC VISIBILITY (for vortex ring effects)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vArcVisibility = 1.0;\n    if (uAnimationType == 1) {\n        // Calculate angle of this vertex in local XZ plane\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n\n        // Arc center rotates based on gesture progress + per-instance phase offset\n        // For vortex effects, aRandomSeed stores the arc phase (rotationOffset) instead of random value\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + aRandomSeed;\n\n        // Calculate arc visibility\n        float halfWidth = uArcWidth * 3.14159;  // Convert to radians\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n\n            // Distance from vertex angle to arc center (wrapping around 2PI)\n            float angleDiff = vertexAngle - thisArcAngle;\n            angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;  // Wrap to -PI to PI\n\n            // Smooth visibility falloff at arc edges\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * instancePosition;\n}\n`,Lg=`\nuniform float uGlobalTime;\nuniform float uTemperature;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uFlickerSpeed;\nuniform float uFlickerAmount;\nuniform float uNoiseScale;\nuniform float uEdgeFade;\n// Enhanced visual uniforms\nuniform float uEdgeSoftness;\nuniform float uEmberDensity;\nuniform float uEmberBrightness;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${xg}\n\n// Instancing varyings\n${vg}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;  // Instance origin in world space (for trail dissolve)\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vDisplacement;\nvarying float vVerticalGradient;\nvarying float vArcVisibility;\nvarying float vRandomSeed;\n\n${bg}\n\n// Blackbody-inspired color ramp with ethereal outer wisps\n// t is local intensity (0-1), temperature is global hotness, edgeFactor for cool edge tint\nvec3 fireColor(float t, float temperature, float edgeFactor) {\n    float heat = t * (0.5 + temperature * 0.5);\n    vec3 color;\n\n    // Refined 5-band blackbody curve with smoother transitions\n    if (heat < 0.2) {\n        // Dark red to deep orange (embers)\n        float f = heat / 0.2;\n        color = vec3(0.3 + f * 0.4, f * 0.15, 0.0);\n    } else if (heat < 0.4) {\n        // Deep orange to bright orange\n        float f = (heat - 0.2) / 0.2;\n        color = vec3(0.7 + f * 0.3, 0.15 + f * 0.45, f * 0.05);\n    } else if (heat < 0.6) {\n        // Orange-yellow to yellow\n        float f = (heat - 0.4) / 0.2;\n        color = vec3(1.0, 0.6 + f * 0.25, 0.05 + f * 0.15);\n    } else if (heat < 0.8) {\n        // Yellow to yellow-white\n        float f = (heat - 0.6) / 0.2;\n        color = vec3(1.0, 0.85 + f * 0.15, 0.2 + f * 0.5);\n    } else {\n        // White to blue-white (plasma)\n        float f = (heat - 0.8) / 0.2;\n        color = vec3(1.0 - f * 0.15, 1.0, 0.7 + f * 0.3);\n    }\n\n    // ETHEREAL: Cool blue-violet tint at outer edges\n    // Creates magical/ethereal look visible at flame boundaries\n    // BOOSTED: Now visible even at high temperatures\n    vec3 etherealTint = vec3(0.5, 0.6, 1.0);  // Deeper blue\n    // Use sqrt to preserve more tint at high heat, boost multiplier to 0.5\n    float heatPreserve = max(0.3, 1.0 - heat * 0.7);  // Never fully suppress\n    float etherealAmount = edgeFactor * heatPreserve * 0.5;\n    color = mix(color, etherealTint * 0.6, etherealAmount);\n\n    return color;\n}\n\n${Cg}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewDir);\n\n    // Use local time for animation\n    float localTime = vLocalTime;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // FLAME PATTERN (Layered multi-scale noise)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vec3 noisePos = vPosition * uNoiseScale + vec3(0.0, -localTime * 0.00085, 0.0);\n\n    // Layered turbulence for organic, billowing flames\n    float flame = layeredTurbulence(noisePos, localTime);\n\n    // Position-based variation for non-uniform flames\n    float posVariation = snoise(vPosition * 7.0) * 0.15 + 0.92;\n    flame *= posVariation;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // VERTICAL FALLOFF\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    float verticalFade = 1.0 - pow(vVerticalGradient, 1.5);\n    float tipBrightness = smoothstep(0.7, 0.9, vVerticalGradient) * flame * 0.5;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ENHANCED PER-INSTANCE FLICKER\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    // Per-instance random phase and frequency for organic chaos\n    float instancePhase = vRandomSeed * 6.28318;\n    float instanceFreq = 0.8 + vRandomSeed * 0.4;\n\n    // Multi-frequency flicker (sin-based for smooth oscillation)\n    float f1 = sin(localTime * uFlickerSpeed * instanceFreq + instancePhase);\n    float f2 = sin(localTime * uFlickerSpeed * 2.3 * instanceFreq + instancePhase * 1.7) * 0.3;\n    float f3 = sin(localTime * uFlickerSpeed * 0.7 * instanceFreq + instancePhase * 0.5) * 0.2;\n\n    float flickerCombined = (f1 + f2 + f3) * 0.5 + 0.5;\n    float flicker = 1.0 - uFlickerAmount + uFlickerAmount * flickerCombined;\n\n    // Micro-flicker for fine detail\n    float microFlicker = 0.95 + 0.05 * snoise(vec3(localTime * 0.004, vPosition.yz * 6.0));\n    flicker *= microFlicker;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // FRESNEL EDGE GLOW (Softer for ethereal look)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    float fresnel = 1.0 - abs(dot(normal, viewDir));\n    float softFresnel = pow(fresnel, 2.5);  // Softer power\n    float edgeGlow = softFresnel * (0.5 + flame * 0.5);\n\n    // Edge factor for ethereal color tinting\n    float edgeFactor = softFresnel * (1.0 - flame * 0.3);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // COLOR CALCULATION\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    float localIntensity = flame * verticalFade * flicker + tipBrightness + edgeGlow * 0.3;\n    localIntensity = clamp(localIntensity, 0.0, 1.0);\n\n    // DECOUPLED: Color ramp always in warm-to-hot range (0.5–1.0).\n    // Noise shifts hue (orange→yellow-white) but color is NEVER dark/brown.\n    // Visibility is controlled by alpha alone, not color darkness.\n    float colorIntensity = 0.5 + localIntensity * 0.5;\n    vec3 color = fireColor(colorIntensity, uTemperature, edgeFactor);\n    color *= uIntensity;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // EMBER/SPARK GENERATION (scaled by uGlowScale)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    if (uEmberDensity > 0.01) {\n        vec3 emberPos = vPosition * 15.0 + vec3(localTime * 0.002, -localTime * 0.008, localTime * 0.001);\n        float emberNoise = snoise(emberPos);\n\n        // Sparse bright spots via threshold\n        float emberThreshold = 0.75 - uEmberDensity * 0.3;\n        float embers = smoothstep(emberThreshold, emberThreshold + 0.1, emberNoise);\n\n        // Embers concentrate near top (rising sparks)\n        embers *= smoothstep(0.2, 0.8, vVerticalGradient);\n\n        // Flicker embers\n        float emberFlicker = 0.7 + 0.3 * snoise(vec3(localTime * 0.02, emberPos.xy));\n        embers *= emberFlicker;\n\n        // Add white-hot ember color (scaled by uGlowScale for gesture glow ramping)\n        color += vec3(1.0, 0.9, 0.7) * embers * uEmberBrightness * uIntensity * uGlowScale;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // EDGE GLOW (scaled by uGlowScale)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    // Fresnel edge glow for ethereal effect\n    color += softFresnel * vec3(0.8, 0.6, 0.3) * uIntensity * 0.2 * uGlowScale;\n\n    // Instance fade is applied through alpha only (not color).\n    // With AdditiveBlending (src.rgb * src.a + dst.rgb), applying vInstanceAlpha\n    // to both color AND alpha would cause squared attenuation (vInstanceAlpha²).\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ALPHA CALCULATION — noise is the sole visibility driver\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    // Wide smoothstep range: only the hottest spots reach full alpha.\n    // Most of the surface is partially transparent, so additive stacking\n    // builds up gradually (orange → yellow → white-hot) instead of instant white.\n    float alpha = smoothstep(0.1, 0.85, localIntensity) * uOpacity;\n\n    // Vertical fade — tips become slightly more transparent\n    alpha *= mix(1.0, 1.0 - vVerticalGradient * 0.4, 0.3);\n\n    // Fresnel adds brightness at edges\n    alpha += softFresnel * 0.15 * flame;\n\n    alpha = clamp(alpha, 0.0, 1.0);\n\n    // Apply instance alpha (spawn/exit fade + trail fade)\n    alpha *= vInstanceAlpha;\n\n    // Apply arc visibility (for vortex effects)\n    if (uAnimationType == 1) {\n        alpha *= vArcVisibility;\n    }\n\n    // No floor color needed — color is always warm (colorIntensity >= 0.5).\n    // Low-noise areas are invisible via alpha, not dark via color.\n    if (alpha < 0.08) discard;\n\n    // Shared cutout system from InstancedAnimationCore\n    ${Pg}\n\n    // Grain effect (noise texture overlay for gritty realism)\n    ${kg}\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,Gg=Rg,Vg="\n// Permutation polynomial hash\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\n// 3D Simplex noise\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\n// Fractal Brownian Motion - 4 octaves for fluid motion\nfloat fbm4(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    for (int i = 0; i < 4; i++) {\n        value += amplitude * snoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Hash function for Voronoi and bubble patterns\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// 3D value noise (trilinear interpolated hash)\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\n// Animated 2D Voronoi for caustic ray patterns (Euclidean distance)\n// Returns vec3: x=edgeDist (F2-F1), y=cellHash for sparkle, z=unused\nvec3 voronoiCaustic(vec2 p, float time) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float d1 = 10.0, d2 = 10.0;\n    float cell1Hash = 0.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 nb = vec2(float(x), float(y));\n            vec2 cell = i + nb;\n            float h = fract(sin(dot(cell, vec2(127.1, 311.7))) * 43758.5453);\n            float h2 = fract(sin(dot(cell, vec2(269.5, 183.3))) * 43758.5453);\n            // Animated cell centers — swimming caustics\n            vec2 pt = nb + vec2(h, h2) + vec2(\n                sin(time * 3.0 + h * 6.28318) * 0.15,\n                cos(time * 2.5 + h2 * 6.28318) * 0.15\n            );\n            float d = length(f - pt); // Euclidean for smooth curves\n            if (d < d1) { d2 = d1; d1 = d; cell1Hash = h; }\n            else if (d < d2) { d2 = d; }\n        }\n    }\n    return vec3(d2 - d1, cell1Hash, 0.0);\n}\n\n// Water bubbles with rising animation\n// Returns vec2(brightness, ringDarkness) for compositing\nvec2 waterBubbles3D(vec3 p, float scale, float density, float time) {\n    vec3 sp = p * scale + vec3(0.0, time * 0.3, 0.0); // Rising motion\n    vec3 i = floor(sp);\n    vec3 f = fract(sp);\n\n    float bright = 0.0;\n    float ringDark = 0.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 nb = vec3(float(x), float(y), float(z));\n                vec3 cid = i + nb;\n\n                float exists = hash(cid * 1.7 + 3.73);\n                if (exists < density) {\n                    vec3 center = nb + vec3(\n                        hash(cid + 0.37),\n                        hash(cid + 1.51),\n                        hash(cid + 2.93)\n                    ) * 0.6 + 0.2;\n                    float r = mix(0.10, 0.25, hash(cid + 4.31));\n                    float d = length(f - center);\n\n                    if (d < r) {\n                        float nd = d / r;\n                        bright += (1.0 - nd * nd) * 0.55;\n                        ringDark += smoothstep(0.65, 0.95, nd) * 0.5;\n                        vec3 sphereDir = normalize(f - center);\n                        bright += pow(max(dot(sphereDir, normalize(vec3(0.3, 0.8, 0.2))), 0.0), 6.0) * 0.2;\n                    }\n                }\n            }\n        }\n    }\n    return vec2(bright, ringDark);\n}\n";function Ng(e,t,i,a){return a<.5?e+2*a*(t-e):t+2*(a-.5)*(i-t)}const jg={turbulence:.5,opacity:.85,noiseScale:3,edgeFade:.15,glowScale:1,fadeInDuration:.3,fadeOutDuration:.5},qg=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uTurbulence;\nuniform float uDisplacementStrength;\nuniform float uFlowSpeed;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;      // 0=none, 1=rotating arc\nuniform float uArcWidth;         // Arc width in radians\nuniform float uArcSpeed;         // Rotations per gesture\nuniform int uArcCount;           // Number of visible arcs\nuniform float uGestureProgress;  // 0-1 gesture progress\n\n// Per-instance attributes\n${yg}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;  // Instance origin in world space (for trail dissolve)\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vDisplacement;\nvarying float vNoiseValue;\nvarying float vRandomSeed;\nvarying float vArcVisibility;  // 0-1 visibility based on arc position\nvarying float vVerticalGradient;  // Normalized vertical position (0=bottom, 1=top) for tip effects\nvarying vec3 vWorldNormal;   // World-space normal for refraction\nvarying vec3 vViewPosition;  // View-space position for refraction\n\n${Vg}\n\nvoid main() {\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // INSTANCING: Calculate local time and fade\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade in/out controlled by aInstanceOpacity from AnimationState\n    float fadeIn = 1.0;\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // MODEL SELECTION: Scale non-selected models to zero\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // TRAIL OFFSET: Position trails behind main along velocity\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // WATER DISPLACEMENT (using local time)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n\n    // Calculate vertical gradient for tip-based effects\n    // Normalize Y position to 0-1 range (assuming model centered at y=0)\n    float modelHeight = 1.0;  // Water models are typically unit-sized\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / modelHeight, 0.0, 1.0);\n\n    // Animated noise for fluid wobble\n    float instanceVariation = aRandomSeed * 0.3;\n    vec3 noisePos = selectedPosition * 2.5 + vec3(\n        effectiveLocalTime * uFlowSpeed * 0.002 + instanceVariation,\n        effectiveLocalTime * uFlowSpeed * 0.001,\n        effectiveLocalTime * uFlowSpeed * 0.0015 + instanceVariation\n    );\n    float noiseValue = fbm4(noisePos);\n    vNoiseValue = noiseValue * 0.5 + 0.5;\n\n    // Position-based variation for asymmetric wobble\n    float posVariation = snoise(selectedPosition * 3.0 + vec3(aRandomSeed * 10.0)) * 0.4 + 0.8;\n\n    // Primary displacement along normal (fluid bulging)\n    float fadeFactor = fadeOut * aInstanceOpacity;\n    float baseDisplacement = noiseValue * uDisplacementStrength * (0.4 + uTurbulence * 0.6) * posVariation;\n\n    vec3 displaced = selectedPosition + selectedNormal * baseDisplacement * fadeFactor;\n\n    // Secondary wobble - perpendicular fluid motion\n    vec3 perpNoise = selectedPosition * 2.0 + vec3(\n        effectiveLocalTime * uFlowSpeed * 0.001,\n        effectiveLocalTime * uFlowSpeed * 0.0008,\n        0.0\n    );\n    float wobbleX = snoise(perpNoise + vec3(50.0, 0.0, 0.0)) * uDisplacementStrength * uTurbulence * 0.5 * fadeFactor;\n    float wobbleY = snoise(perpNoise + vec3(0.0, 50.0, 0.0)) * uDisplacementStrength * uTurbulence * 0.3 * fadeFactor;\n    float wobbleZ = snoise(perpNoise + vec3(0.0, 0.0, 50.0)) * uDisplacementStrength * uTurbulence * 0.5 * fadeFactor;\n    displaced.x += wobbleX;\n    displaced.y += wobbleY;\n    displaced.z += wobbleZ;\n\n    // ═══════════════════════════════════════════════════════════════════════════\n    // ANIMATED SURFACE WAVES — visible undulation of the water surface\n    // Two frequency layers: broad swells + fine ripples.\n    // The analytical gradient perturbs the normal so specular and refraction\n    // react to the wave shapes, not just the flat polygon normal.\n    // ═══════════════════════════════════════════════════════════════════════════\n    float wt = uGlobalTime * 0.001;\n\n    // Broad swells (5 cycles across model, slow drift)\n    float wave1 = sin(selectedPosition.x * 5.0 + wt * 3.0)\n                * cos(selectedPosition.z * 4.0 + wt * 2.0);\n    // Fine ripples (12 cycles, faster counter-drift)\n    float wave2 = sin(selectedPosition.x * 12.0 - wt * 4.0)\n                * cos(selectedPosition.z * 9.0 + wt * 3.5);\n\n    float waveDispl = (wave1 * 0.07 + wave2 * 0.03) * fadeFactor;\n    displaced += selectedNormal * waveDispl;\n\n    // Analytical gradient: dh/dx and dh/dz for normal perturbation\n    // Normal perturbation amplified 3x beyond displacement — strong refraction waviness\n    // without moving geometry enough to create spikes on low-poly mesh\n    float normalBoost = 1.5;\n    float dwdx = (5.0  * cos(selectedPosition.x * 5.0  + wt * 3.0) * cos(selectedPosition.z * 4.0 + wt * 2.0) * 0.07\n               +  12.0 * cos(selectedPosition.x * 12.0 - wt * 4.0) * cos(selectedPosition.z * 9.0 + wt * 3.5) * 0.03) * normalBoost;\n    float dwdz = (-4.0 * sin(selectedPosition.x * 5.0  + wt * 3.0) * sin(selectedPosition.z * 4.0 + wt * 2.0) * 0.07\n               +  -9.0 * sin(selectedPosition.x * 12.0 - wt * 4.0) * sin(selectedPosition.z * 9.0 + wt * 3.5) * 0.03) * normalBoost;\n\n    // Perturbed normal: standard height-field approximation N' = normalize(N - gradient)\n    vec3 waveNormal = normalize(selectedNormal - vec3(dwdx, 0.0, dwdz) * fadeFactor);\n\n    // Apply trail offset\n    displaced += trailOffset;\n\n    vDisplacement = baseDisplacement;\n\n    // Transform wave-perturbed normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * waveNormal;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // Apply instance matrix for per-instance transforms\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve - uses cutout at instance floor)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ARC VISIBILITY (for vortex ring effects)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vArcVisibility = 1.0;\n    if (uAnimationType == 1) {\n        // Calculate angle of this vertex in local XZ plane\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n\n        // Arc center rotates based on gesture progress + per-instance phase offset\n        // aRandomSeed stores the arc phase (rotationOffset) for vortex effects\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + aRandomSeed;\n\n        // Calculate arc visibility\n        float halfWidth = uArcWidth * 3.14159;  // Convert to radians\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n\n            // Distance from vertex angle to arc center (wrapping around 2PI)\n            float angleDiff = vertexAngle - thisArcAngle;\n            angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;  // Wrap to -PI to PI\n\n            // Smooth visibility falloff at arc edges\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    // World-space normal for refraction (wave-perturbed)\n    vec3 transformedNormal = (instanceMatrix * vec4(waveNormal, 0.0)).xyz;\n    vWorldNormal = normalize(mat3(modelMatrix) * transformedNormal);\n\n    // View-space position for refraction\n    vec4 mvPosition = modelViewMatrix * instancePosition;\n    vViewPosition = mvPosition.xyz;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n`,Ug=`\nuniform float uGlobalTime;\nuniform float uTurbulence;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uFlowSpeed;\nuniform float uNoiseScale;\nuniform float uEdgeFade;\nuniform float uBloomThreshold;  // Mascot-specific bloom threshold for compression\nuniform vec3 uTint;\n\n// Enhanced water system uniforms\nuniform float uDepthGradient;      // Depth-based color variation strength (0=off, 1=full)\nuniform float uInternalFlowSpeed;  // Internal spiral/flow animation speed multiplier\nuniform float uSparkleIntensity;   // Specular sparkle highlight intensity\n\n// Screen-space refraction uniforms\nuniform sampler2D uBackgroundTexture;\nuniform vec2 uResolution;\nuniform int uHasBackground;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${xg}\n\n// Instancing varyings\n${vg}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;  // Instance origin in world space (for trail dissolve)\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vDisplacement;\nvarying float vNoiseValue;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewPosition;\n\n${Vg}\n\n// Water color palette constants (accessible for effects)\nconst vec3 WATER_DEEP = vec3(0.05, 0.15, 0.35);       // Deep blue\nconst vec3 WATER_MID = vec3(0.15, 0.4, 0.6);          // Ocean blue\nconst vec3 WATER_BRIGHT = vec3(0.3, 0.6, 0.8);        // Bright cyan\nconst vec3 WATER_FOAM = vec3(0.85, 0.92, 1.0);        // White foam/highlights\nconst vec3 WATER_SUBSURFACE = vec3(0.2, 0.5, 0.7);    // Subsurface scatter color\n\n// Water color based on local intensity and turbulence\nvec3 waterColor(float intensity, float turbulence) {\n    // Mix based on intensity - biased toward blue colors\n    // Only very high intensities should reach white/foam\n    vec3 color;\n    if (intensity < 0.5) {\n        // 0-0.5: Deep blue to ocean blue (most of the water)\n        color = mix(WATER_DEEP, WATER_MID, intensity * 2.0);\n    } else if (intensity < 0.8) {\n        // 0.5-0.8: Ocean blue to bright cyan\n        color = mix(WATER_MID, WATER_BRIGHT, (intensity - 0.5) * 3.33);\n    } else {\n        // 0.8-1.0: Bright cyan to foam (only extreme highlights)\n        color = mix(WATER_BRIGHT, WATER_FOAM, (intensity - 0.8) * 5.0);\n    }\n\n    return color;\n}\n\n${Cg}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    // Use local time for animation\n    float localTime = vLocalTime;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // CORE WATER EFFECTS (from WaterShaderCore)\n    // Includes: patterns, caustics, fresnel, subsurface, specular, depth variation\n    // ═══════════════════════════════════════════════════════════════════════════════\n    \n    // ═══════════════════════════════════════════════════════════════════════════════\n    // NORMALS + THICKNESS\n    // Smooth normals hide low-poly faces. Used for: thickness, fresnel, scatter.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 viewDir = normalize(vViewDir);\n\n    // World normal with faceforward for DoubleSide geometry\n    vec3 worldNormal = normalize(vWorldNormal);\n    if (length(vWorldNormal) < 0.01) worldNormal = viewDir;\n    worldNormal = faceforward(worldNormal, -viewDir, worldNormal);\n\n    float smoothNdotV = max(0.0, dot(worldNormal, viewDir));\n    float fresnel = pow(1.0 - smoothNdotV, 3.0);   // Power 3 for water (ice uses 4)\n    float thickness = smoothNdotV * smoothNdotV * 0.5; // Quadratic proxy\n\n    // Schlick fresnel\n    float F0 = 0.02; // water IOR ~1.33\n    float schlick = F0 + (1.0 - F0) * fresnel;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SCREEN-SPACE REFRACTION — sample background through distorted UVs\n    // The background was rendered to a texture without water meshes.\n    //\n    // KEY INSIGHT: Don't feed ripples into refract() — at near-perpendicular\n    // incidence, refract() suppresses bending (output ≈ input direction).\n    // Instead, apply ripple offsets DIRECTLY to screen UVs. This is the\n    // standard real-time water technique: surface normals/ripples directly\n    // offset the background lookup, producing large, visible distortion.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 waterBodyColor = vec3(0.05, 0.15, 0.30) * uTint; // Stylized blue — reads as "water" at game scale\n    vec3 transmittedLight;\n    float bgPresence = 1.0; // 1.0 = 3D geometry behind, 0.0 = empty sky (CSS background)\n\n    if (uHasBackground == 1) {\n        vec2 screenUV = gl_FragCoord.xy / uResolution;\n\n        // View-space vectors\n        vec3 I_vs = normalize(vViewPosition);\n        vec3 N_vs = faceforward(normalize(vNormal), I_vs, normalize(vNormal));\n\n        // ── Physical refraction: small but correct geometry-dependent bending ──\n        vec3 refDir = refract(I_vs, N_vs, 0.75);\n        if (length(refDir) < 0.1) refDir = I_vs;\n        float physDistortion = 0.04 + thickness * 0.10;\n        vec2 physOffset = refDir.xy * physDistortion;\n\n        // ── Animated ripple distortion: PRIMARY visible effect ──\n        // Ripples directly offset screen UVs = looking through wavy water surface.\n        // Adjacent pixels get smooth, similar offsets → clean wavy distortion.\n        float rt = uGlobalTime * 0.001;\n        vec2 ripple1 = vec2(\n            sin(vPosition.x * 8.0 + rt * 4.0) * cos(vPosition.z * 6.0 + rt * 3.0),\n            cos(vPosition.x * 7.0 - rt * 3.5) * sin(vPosition.z * 9.0 + rt * 2.5)\n        ) * 0.15;\n        vec2 ripple2 = vec2(\n            sin(vPosition.x * 15.0 - rt * 5.0 + 1.7) * cos(vPosition.z * 12.0 + rt * 4.5),\n            cos(vPosition.x * 13.0 + rt * 6.0) * sin(vPosition.z * 16.0 - rt * 3.0)\n        ) * 0.08;\n        vec2 rippleOffset = (ripple1 + ripple2) * 0.60;\n\n        // Combined: physical refraction + animated ripples\n        vec2 totalOffset = physOffset + rippleOffset;\n\n        // ── Alpha-aware refraction ──\n        // The refraction target clears to (0,0,0,0). Areas with 3D geometry have\n        // alpha > 0. Areas with no geometry (empty sky / CSS background) have alpha ≈ 0.\n        // Over geometry: refract normally. Over sky: be transparent so CSS shows through.\n        vec4 bgCenter = texture2D(uBackgroundTexture, clamp(screenUV + totalOffset, 0.0, 1.0));\n        bgPresence = smoothstep(0.05, 0.3, bgCenter.a);\n\n        vec3 refractedBg;\n        if (bgPresence > 0.1) {\n            // 3D geometry behind — full refraction with chromatic dispersion\n            refractedBg = vec3(\n                texture2D(uBackgroundTexture, clamp(screenUV + totalOffset * 0.97, 0.0, 1.0)).r,\n                bgCenter.g,\n                texture2D(uBackgroundTexture, clamp(screenUV + totalOffset * 1.03, 0.0, 1.0)).b\n            );\n        } else {\n            // Empty sky behind — just use the (near-black) sample\n            refractedBg = bgCenter.rgb;\n        }\n\n        // Over geometry: blue-tinted lift. Over sky: light tint so water has some color.\n        vec3 skyTint = vec3(0.12, 0.20, 0.30) * uTint;\n        vec3 ambientLift = mix(skyTint, vec3(0.03, 0.06, 0.10), bgPresence);\n        refractedBg += ambientLift * (vec3(1.0) - refractedBg);\n\n        // Body color tint — visible at thick areas\n        transmittedLight = mix(refractedBg, waterBodyColor, thickness * 0.15);\n    } else {\n        vec3 voidColor = vec3(0.08, 0.15, 0.25);\n        transmittedLight = mix(voidColor, waterBodyColor, thickness * 0.3);\n    }\n\n    // Blue absorption — water absorbs red > green > blue wavelengths\n    // Base tint even at thin edges so entire surface reads as "water"\n    vec3 absorptionTint = mix(vec3(1.0), vec3(0.65, 0.85, 1.0), 0.20 + thickness * 0.8);\n    transmittedLight *= absorptionTint;\n\n    // Subtle energy conservation\n    transmittedLight *= (1.0 - fresnel * 0.08);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // PARALLAX + BREAK MASK + VORONOI CAUSTICS + VIEW SPARKLE\n    // Two-scale animated Voronoi with Euclidean distance → smooth caustic curves.\n    // Break mask erases ~75% for "current channels" of clear vs active water.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec2 parallaxDir = viewDir.xz / max(smoothNdotV, 0.25);\n    vec2 coarseParallax = parallaxDir * 0.08;\n    vec2 fineParallax = parallaxDir * 0.12;\n\n    // Break mask — low-frequency noise erases ~80% of caustics, wide gradient for soft edges\n    float breakNoise = noise(vec3(vPosition.xz * 0.4, 0.0));\n    float causticMask = smoothstep(0.55, 0.85, breakNoise);\n\n    // Caustic time — use global time for steady swimming independent of instance\n    float causticTime = uGlobalTime * 0.001;\n\n    // Two-scale animated Voronoi caustics\n    vec3 coarseCaustic = voronoiCaustic(\n        (vPosition.xz + coarseParallax) * 3.0 + vec2(vRandomSeed * 3.0),\n        causticTime\n    );\n    vec3 fineCaustic = voronoiCaustic(\n        (vPosition.xz + fineParallax) * 6.0 + vec2(vRandomSeed * 5.7),\n        causticTime * 1.3\n    );\n\n    // Per-cell view sparkle: pseudo-plane-normal from cell hash\n    float coarseAngle = coarseCaustic.y * 6.28318;\n    vec2 coarsePlaneDir = vec2(cos(coarseAngle), sin(coarseAngle));\n    float coarseSparkle = abs(dot(coarsePlaneDir, viewDir.xz));\n    coarseSparkle = mix(0.1, 1.0, coarseSparkle);\n\n    float fineAngle = fineCaustic.y * 6.28318;\n    vec2 finePlaneDir = vec2(cos(fineAngle), sin(fineAngle));\n    float fineSparkle = abs(dot(finePlaneDir, viewDir.xz));\n    fineSparkle = mix(0.1, 1.0, fineSparkle);\n\n    // Caustic edge-distance to brightness — very narrow widths for thin bright rays only\n    float coarseBright = 1.0 - smoothstep(0.0, 0.03, coarseCaustic.x);\n    float fineBright = 1.0 - smoothstep(0.0, 0.02, fineCaustic.x);\n\n    // Combined caustic brightness\n    float causticCombined = (coarseBright * coarseSparkle * 0.6 + fineBright * fineSparkle * 0.4) * causticMask;\n\n    // Very subtle caustic modulation — refraction distortion IS the real caustic effect,\n    // this just adds a faint hint of surface variation\n    transmittedLight *= 1.0 + causticCombined * 0.04;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // VOLUMETRIC BUBBLES — round spheres rising through the water\n    // Cluster mask ties bubbles to caustic zones for natural grouping.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 bubbleParallax = viewDir * 0.08 / max(smoothNdotV, 0.25);\n    vec3 bubbleSamplePos = vPosition + bubbleParallax + vec3(vRandomSeed * 10.0);\n\n    // Cluster mask tied to break mask: bubbles congregate near caustic zones\n    float bubbleClusterMask = 0.5 + 0.5 * causticMask;\n\n    vec2 bub = waterBubbles3D(bubbleSamplePos, 20.0, 0.35, uGlobalTime * 0.001);\n\n    // Fizz micro-detail\n    float fizz = smoothstep(0.84, 0.90, noise(bubbleSamplePos * 40.0)) * 0.15;\n\n    float bubbleBright = (bub.x + fizz) * bubbleClusterMask;\n    float bubbleRing = bub.y * bubbleClusterMask;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SPECULAR — THE DOMINANT VISUAL FEATURE\n    // Real water is mostly invisible; sharp bright glints are what you SEE.\n    // High power (128-512) for needle-sharp highlights, multiple light directions.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 wetReflDir = reflect(-viewDir, worldNormal);\n\n    // Broad wet sheen — sharper than before (power 128), stronger (1.5x)\n    float wetSpec1 = pow(max(dot(wetReflDir, normalize(vec3(0.5, 1.0, 0.3))), 0.0), 128.0);\n    float wetSpec2 = pow(max(dot(wetReflDir, normalize(vec3(-0.4, 0.8, -0.4))), 0.0), 128.0) * 0.7;\n    float wetSpec3 = pow(max(dot(wetReflDir, normalize(vec3(-0.3, 0.6, 0.7))), 0.0), 96.0) * 0.5;\n    float wetSpec4 = pow(max(dot(wetReflDir, normalize(vec3(0.2, 0.9, -0.3))), 0.0), 160.0) * 0.4;\n    float broadSpec = (wetSpec1 + wetSpec2 + wetSpec3 + wetSpec4) * 1.5;\n\n    // Needle-sharp sparkle — power 512, multiple light directions for more glint points\n    float spark1 = pow(max(dot(wetReflDir, normalize(vec3(0.5, 1.0, 0.3))), 0.0), 512.0);\n    float spark2 = pow(max(dot(wetReflDir, normalize(vec3(-0.3, 0.9, 0.4))), 0.0), 512.0) * 0.6;\n    float spark3 = pow(max(dot(wetReflDir, normalize(vec3(0.4, 0.7, -0.5))), 0.0), 384.0) * 0.4;\n\n    // Twinkling animation (3-freq multiplicative pattern)\n    float specShift1 = sin(localTime * 0.003 + vPosition.x * 8.0) * 0.5 + 0.5;\n    float specShift2 = sin(localTime * 0.005 - vPosition.z * 12.0) * 0.5 + 0.5;\n    float specShift3 = sin(localTime * 0.007 + vPosition.y * 10.0) * 0.5 + 0.5;\n    float sparkleAnim = specShift1 * specShift2 * specShift3;\n\n    float sharpSpec = (spark1 + spark2 + spark3) * sparkleAnim * 3.0 * uSparkleIntensity;\n\n    vec3 specContrib = vec3(0.85, 0.92, 1.0) * (broadSpec + sharpSpec);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // INTERNAL SPIRAL FLOW (reduced contribution for refraction-based approach)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float flowTimeScale = localTime * uInternalFlowSpeed;\n    float spiralAngle = atan(vPosition.y, vPosition.x) + flowTimeScale * 0.001;\n    float spiralRadius = length(vPosition.xy);\n    float spiralFlow = sin(spiralAngle * 3.0 - spiralRadius * 4.0 + flowTimeScale * 0.002);\n    spiralFlow = spiralFlow * 0.5 + 0.5;\n\n    float spiral2 = sin(-spiralAngle * 2.0 + spiralRadius * 3.0 + flowTimeScale * 0.0015);\n    spiral2 = spiral2 * 0.5 + 0.5;\n\n    float spiral3 = sin(spiralAngle * 5.0 + spiralRadius * 6.0 - flowTimeScale * 0.0025);\n    spiral3 = spiral3 * 0.5 + 0.5;\n\n    float internalFlow = (spiralFlow * 0.4 + spiral2 * 0.35 + spiral3 * 0.25) * 0.02; // Near-zero: real water has no internal pattern\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // COMPOSITING — soft clamp + post-clamp\n    // Cap smooth glass body before adding bright features (specular, caustics, bubbles)\n    // so they can exceed the cap and trigger bloom glow.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 color = transmittedLight;\n\n    // Add internal flow contribution (procedural, so scale by uIntensity)\n    color += internalFlow * waterBodyColor * uIntensity;\n\n    // DON'T multiply refracted background by uIntensity — it would wash out the\n    // background visibility. Only procedural additions (flow, specular) scale.\n\n    // ── SOFT CLAMP: cap smooth body before bright features ──\n    float softCap = uBloomThreshold + 0.40;\n    float maxChannel = max(color.r, max(color.g, color.b));\n    if (maxChannel > softCap) {\n        color *= softCap / maxChannel;\n    }\n\n    // ── POST-CLAMP: bright features exceed cap for bloom ──\n    // Caustics now modulate transmittedLight directly (physically-based light focusing)\n    color += specContrib;\n    color += vec3(0.80, 0.85, 0.92) * bubbleBright * 0.35;\n    color -= vec3(0.05, 0.04, 0.02) * bubbleRing;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ALPHA — two factors:\n    // 1. Edge dissolution: NdotV-based fade makes thin edges transparent\n    // 2. Background presence: when no refraction background is set AND there's no\n    //    3D geometry behind, reduce alpha so CSS shows through. With a refraction\n    //    background set, bgPresence → 1.0 everywhere → full refraction alpha.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float edgeAlpha = smoothstep(0.08, 0.60, smoothNdotV);\n    float skyAlpha = mix(0.25, 1.0, bgPresence); // 0.25 fallback if no bg set, 1.0 with bg\n    float alpha = edgeAlpha * skyAlpha;\n\n\n    // Apply instance alpha (NormalBlending uses alpha for fade, no color pre-multiply)\n    alpha *= vInstanceAlpha;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ARC VISIBILITY (for vortex effects)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    if (uAnimationType == 1) {\n        // Apply arc foam effect at edges\n        \n    // Foam accumulates at arc edges (where visibility transitions)\n    float arcEdgeFoam = smoothstep(0.5, 0.85, vArcVisibility) * (1.0 - smoothstep(0.85, 1.0, vArcVisibility));\n    // Secondary foam at leading edge\n    float leadingFoam = smoothstep(0.0, 0.3, vArcVisibility) * (1.0 - smoothstep(0.3, 0.5, vArcVisibility));\n    float totalFoam = max(arcEdgeFoam, leadingFoam * 0.7);\n\n    // Add foam color with animated shimmer - reduced mix amount\n    float foamShimmer = 0.8 + 0.2 * sin(localTime * 0.005 + vPosition.x * 10.0);\n    color = mix(color, WATER_FOAM * foamShimmer, totalFoam * 0.35);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // DRAMATIC ARC EDGE GRADIENT (scaled by uGlowScale)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    // Color shifts toward bright cyan at arc edges for dramatic effect\n    // Reduced base values - gestureGlow ramps this up for impact\n    float arcEdgeIntensity = 1.0 - vArcVisibility;  // Inverse: brighter at fading edges\n    vec3 edgeGlow = WATER_FOAM * (0.8 + 0.15 * uGlowScale);  // Subtle overexposure\n    color = mix(color, edgeGlow, arcEdgeIntensity * 0.2 * uGlowScale);\n\n    // Extra bloom hint at arc edges (scaled) - reduced for subtlety\n    color += arcEdgeIntensity * vec3(0.1, 0.2, 0.25) * 0.3 * uGlowScale;\n\n    // Foam is more opaque\n    alpha = mix(alpha, min(1.0, alpha + 0.3), totalFoam);\n\n    // Arc edges slightly more visible\n    alpha = mix(alpha, min(1.0, alpha + 0.15), arcEdgeIntensity * 0.4);\n\n\n        // Apply arc visibility\n        alpha *= vArcVisibility;\n        // Fade color to avoid dark artifacts at edge\n        color *= mix(0.3, 1.0, vArcVisibility);\n        // Discard fully invisible fragments\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // CUTOUT EFFECT (shared pattern system from InstancedAnimationCore)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    ${Pg}\n\n    // Apply trail dissolve alpha (smooth fade at instance bottom - no hard edge)\n    // With AdditiveBlending: only fade ALPHA, keep color bright\n    // result = color * alpha + background\n    // If color is bright and alpha is low, we get a dim ADDITIVE contribution\n    // If color is dark and alpha is low, we get nearly nothing (but no darkening either)\n    alpha *= trailAlpha;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // WATER CUTOUT FOAM (brightens edges to prevent dark artifacts)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    \n    // ═══════════════════════════════════════════════════════════════════════════════\n    // WATER CUTOUT FOAM EDGES (brightens cutout boundaries to prevent dark artifacts)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    if (uCutoutStrength > 0.01 && finalCutout < 0.99) {\n        float cutoutThreshold = 0.5;\n\n        // Enhanced foam rim effect at hole edges - multiple layers for depth\n        float nearEdge = smoothstep(cutoutThreshold, cutoutThreshold + 0.15, finalCutout);\n        float farEdge = smoothstep(cutoutThreshold + 0.3, cutoutThreshold + 0.5, finalCutout);\n\n        // Sharp inner rim (bright foam line at cutout boundary)\n        float innerRim = nearEdge * (1.0 - smoothstep(cutoutThreshold + 0.15, cutoutThreshold + 0.25, finalCutout));\n\n        // Softer outer glow (wider, subtler foam aura)\n        float outerGlow = nearEdge * (1.0 - farEdge) * 0.4;\n\n        // Animated sparkles along the foam edge\n        float foamSparkle = sin(localTime * 0.008 + vPosition.x * 15.0 + vPosition.z * 12.0) * 0.5 + 0.5;\n        foamSparkle *= sin(localTime * 0.006 - vPosition.y * 18.0) * 0.5 + 0.5;\n        foamSparkle = pow(foamSparkle, 3.0) * innerRim;\n\n        // Apply foam effects — blend toward white (mix, not additive) for NormalBlending\n        color = mix(color, WATER_FOAM * 0.9, innerRim * uCutoutStrength * 0.3);\n        color = mix(color, WATER_BRIGHT * 0.8, outerGlow * uCutoutStrength * 0.2);\n        color = mix(color, vec3(1.0), foamSparkle * uCutoutStrength * uSparkleIntensity * 0.15);\n    }\n\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // GRAIN EFFECT (noise texture overlay for gritty realism)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    ${kg}\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // DRIP ANTICIPATION (surface tension bright spots)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    \n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ENHANCED DRIP ANTICIPATION (surface tension hotspots with visible gathering)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    // Create multiple potential drip points using spatial hash\n    float dripHash1 = snoise(vPosition * 8.0 + vec3(12.34, 56.78, 90.12));\n    float dripHash2 = snoise(vPosition * 8.0 + vec3(98.76, 54.32, 10.98));\n    float dripHash3 = snoise(vPosition * 6.0 + vec3(45.67, 23.45, 67.89));\n\n    // Only some areas become drip points (threshold creates sparse points)\n    float dripPoint1 = smoothstep(0.65, 0.85, dripHash1);\n    float dripPoint2 = smoothstep(0.7, 0.88, dripHash2);\n    float dripPoint3 = smoothstep(0.72, 0.9, dripHash3);\n\n    // Each drip point has its own pulse timing (offset by position hash)\n    float dripPhase1 = localTime * 0.003 + dripHash1 * 6.28318;\n    float dripPhase2 = localTime * 0.0025 + dripHash2 * 6.28318;\n    float dripPhase3 = localTime * 0.002 + dripHash3 * 6.28318;\n\n    // Pulse pattern: slow build, quick release (like water gathering then almost falling)\n    float dripPulse1 = pow(fract(dripPhase1 * 0.15), 3.0);\n    float dripPulse2 = pow(fract(dripPhase2 * 0.12), 3.0);\n    float dripPulse3 = pow(fract(dripPhase3 * 0.1), 2.5);\n\n    // Occasional bright flash at peak (surface tension breaking point)\n    float dripFlash1 = smoothstep(0.85, 0.95, dripPulse1) * (1.0 - smoothstep(0.95, 1.0, dripPulse1));\n    float dripFlash2 = smoothstep(0.85, 0.95, dripPulse2) * (1.0 - smoothstep(0.95, 1.0, dripPulse2));\n    float dripFlash3 = smoothstep(0.88, 0.96, dripPulse3) * (1.0 - smoothstep(0.96, 1.0, dripPulse3));\n\n    // Surface tension bulge effect - visible gathering before flash\n    float tensionBulge1 = smoothstep(0.5, 0.85, dripPulse1) * dripPoint1;\n    float tensionBulge2 = smoothstep(0.5, 0.85, dripPulse2) * dripPoint2;\n    float tensionBulge = (tensionBulge1 + tensionBulge2) * 0.5;\n\n    // Combine drip effects with enhanced visibility\n    float dripIntensity = dripPoint1 * (dripPulse1 * 0.35 + dripFlash1 * 0.65)\n                        + dripPoint2 * (dripPulse2 * 0.35 + dripFlash2 * 0.65)\n                        + dripPoint3 * (dripPulse3 * 0.3 + dripFlash3 * 0.7);\n\n    // Apply drip highlights - bright white-cyan flash with subtle rainbow\n    float flashTotal = dripFlash1 + dripFlash2 + dripFlash3;\n    vec3 dripColor = mix(WATER_BRIGHT, WATER_FOAM, min(1.0, flashTotal));\n\n    // Add subtle rainbow shimmer to the flash (refraction effect)\n    float rainbowPhase = localTime * 0.002 + vPosition.x * 5.0;\n    vec3 rainbowTint = vec3(\n        0.5 + 0.5 * sin(rainbowPhase),\n        0.5 + 0.5 * sin(rainbowPhase + 2.094),\n        0.5 + 0.5 * sin(rainbowPhase + 4.189)\n    );\n    dripColor = mix(dripColor, dripColor * rainbowTint, flashTotal * 0.15);\n\n    color += dripIntensity * dripColor * 0.15 * uGlowScale;\n\n    // Surface tension bulge adds subtle brightness\n    color += tensionBulge * WATER_BRIGHT * 0.10;\n\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // FINAL OUTPUT\n    // ═══════════════════════════════════════════════════════════════════════════════\n    \n    // Discard faint fragments\n    if (alpha < 0.01) discard;\n\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,Wg=Rg,Hg={melt:0,intensity:1,opacity:.7,frostAmount:1,internalCracks:.8,subsurfaceScatter:.15,glowScale:.1,fadeInDuration:.2,fadeOutDuration:.4},$g="\n// Hash function for noise\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\n// 3D noise\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n\n    return mix(\n        mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),\n            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),\n            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\n// Simplex-ish noise\nfloat snoise(vec3 p) {\n    return noise(p) * 2.0 - 1.0;\n}\n\n// FBM\nfloat fbm4(vec3 p) {\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p); p *= 2.02;\n    f += 0.1250 * noise(p); p *= 2.03;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// Voronoi for crystalline patterns\nfloat voronoi(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float minDist = 1.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n                vec3 point = neighbor + hash(i + neighbor) * 0.8;\n                float dist = length(f - point);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\n// Trapped air bubbles: 3D volumetric cell grid with proper spheres.\n// The surface CUTS THROUGH 3D spheres → always circular cross-sections,\n// no stretching regardless of surface angle. Bubbles are INSIDE the ice.\n// Returns vec2(brightness, ringDarkness) for compositing.\nvec2 bubbleField3D(vec3 p, float scale, float density) {\n    vec3 sp = p * scale;\n    vec3 i = floor(sp);\n    vec3 f = fract(sp);\n\n    float bright = 0.0;\n    float ringDark = 0.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 nb = vec3(float(x), float(y), float(z));\n                vec3 cid = i + nb;\n\n                float exists = hash(cid * 1.7 + 3.73);\n                if (exists < density) {\n                    vec3 center = nb + vec3(\n                        hash(cid + 0.37),\n                        hash(cid + 1.51),\n                        hash(cid + 2.93)\n                    ) * 0.6 + 0.2;\n                    float r = mix(0.12, 0.30, hash(cid + 4.31));\n                    float d = length(f - center);\n\n                    if (d < r) {\n                        float nd = d / r; // 0=center, 1=edge\n\n                        // Interior: brighter than surrounding ice (primary visual)\n                        bright += (1.0 - nd * nd) * 0.45;\n\n                        // Subtle dark ring at boundary — just defines the edge\n                        ringDark += smoothstep(0.65, 0.95, nd) * 0.5;\n\n                        // Small caustic highlight (3D direction)\n                        vec3 sphereDir = normalize(f - center);\n                        bright += pow(max(dot(sphereDir, normalize(vec3(0.3, 0.8, 0.2))), 0.0), 6.0) * 0.2;\n                    }\n                }\n            }\n        }\n    }\n\n    return vec2(bright, ringDark);\n}\n\n// Internal fracture planes: flat disc-shaped inclusions at random orientations\n// inside the ice volume. Where the surface cuts through a fracture disc, you see\n// a bright scattered-light line that shifts with viewing angle (like real ice).\n// Each cell in the 3D grid may contain a fracture plane with:\n//   - Random center position within cell\n//   - Random plane orientation (normal vector)\n//   - Disc radius with feathery noise-perturbed edges\n//   - View-dependent brightness (planes facing camera flash bright)\n// Returns: brightness (0-1) of fracture scatter at this point.\nfloat fractureField3D(vec3 p, vec3 viewDir, float scale, float density) {\n    vec3 sp = p * scale;\n    vec3 i = floor(sp);\n    vec3 f = fract(sp);\n\n    float result = 0.0;\n\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int z = -1; z <= 1; z++) {\n                vec3 nb = vec3(float(x), float(y), float(z));\n                vec3 cid = i + nb;\n\n                float exists = hash(cid * 2.3 + 7.91);\n                if (exists < density) {\n                    // Fracture center within cell\n                    vec3 center = nb + vec3(\n                        hash(cid + 0.37),\n                        hash(cid + 1.51),\n                        hash(cid + 2.93)\n                    ) * 0.6 + 0.2;\n\n                    // Random plane orientation\n                    vec3 planeNorm = normalize(vec3(\n                        hash(cid + 5.17) * 2.0 - 1.0,\n                        hash(cid + 6.83) * 2.0 - 1.0,\n                        hash(cid + 8.41) * 2.0 - 1.0\n                    ));\n\n                    // Distance from point to the fracture plane\n                    vec3 toPoint = f - center;\n                    float planeDist = abs(dot(toPoint, planeNorm));\n\n                    // Thick slab — 0.25 ensures high intersection probability.\n                    // At scale 1.5, cell=0.67 units, slab=0.25 → 37% of cell height.\n                    float planeVis = 1.0 - smoothstep(0.0, 0.25, planeDist);\n\n                    // Disc boundary — large discs spanning most of the cell\n                    vec3 inPlane = toPoint - dot(toPoint, planeNorm) * planeNorm;\n                    float radialDist = length(inPlane);\n                    float discRadius = mix(0.5, 0.9, hash(cid + 9.73));\n                    float discMask = 1.0 - smoothstep(discRadius * 0.7, discRadius, radialDist);\n\n                    // No sparkle/brightness multipliers — just geometry.\n                    // Visibility = plane intersection × disc shape. Range 0-1.\n                    result += planeVis * discMask;\n                }\n            }\n        }\n    }\n    return result;\n}\n",Yg=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\nuniform float uMelt;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;\nuniform float uArcWidth;\nuniform float uArcSpeed;\nuniform int uArcCount;\nuniform float uGestureProgress;\n\n// Per-instance attributes\n${yg}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewDir;\nvarying vec3 vViewPosition;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying vec2 vUv;\n\n${$g}\n\nvoid main() {\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // INSTANCING: Calculate local time and fade\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade in/out controlled by aInstanceOpacity from AnimationState\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // MODEL SELECTION: Scale non-selected models to zero\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // TRAIL OFFSET: Position trails behind main along velocity\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ICE DISPLACEMENT (crystalline wobble - much less than water)\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n    vUv = uv;\n\n    // Calculate vertical gradient for tip-based effects\n    float modelHeight = 1.0;\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / modelHeight, 0.0, 1.0);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SILHOUETTE BREAKUP — Voronoi vertex displacement at edges\n    // Uses the same Voronoi cell pattern as our cutout/crack system.\n    // Only active at silhouette edges (low NdotV) → jagged crystal outlines.\n    // Face-on vertices stay put, preserving the clean faceted interior.\n    // Per-instance random offset breaks repetition between identical models.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 displaced = selectedPosition;\n\n    if (modelMatch > 0.5 && length(selectedNormal) > 0.1) {\n        // Edge factor: how close is this vertex to the silhouette?\n        vec4 approxWorldPos = modelMatrix * instanceMatrix * vec4(selectedPosition, 1.0);\n        vec3 approxViewDir = normalize(cameraPosition - approxWorldPos.xyz);\n        vec3 worldNormal = normalize(mat3(modelMatrix) * mat3(instanceMatrix) * selectedNormal);\n        float edgeNdotV = abs(dot(worldNormal, approxViewDir));\n        float edgeFactor = pow(1.0 - edgeNdotV, 2.0); // Quadratic — wider influence band\n\n        // Voronoi cell distance — crystalline breakup matching our crack aesthetic\n        // Per-instance offset so each crystal has unique edges\n        // Low frequency (1.5) → broad heavy warps, not tiny bumps\n        // Ring looks "bent" not "vibrating" — big surface undulations\n        float vor = voronoi(selectedPosition * 1.5 + vec3(aRandomSeed * 7.13, 0.0, aRandomSeed * 3.71));\n        float displ = (vor - 0.4) * 2.0;\n\n        // QUANTIZE into terraces — "chiseled ice plates" not smooth waves.\n        // floor() cuts the smooth displacement into hard steps so flat shading\n        // creates clean geometric plateaus instead of folded-paper look.\n        float steppedDispl = floor(displ * 4.0) / 4.0; // 4 terrace levels\n        float finalDispl = mix(displ, steppedDispl, 0.8); // 80% stepped, 20% smooth anti-aliasing\n\n        displaced += normalize(selectedNormal) * finalDispl * 0.08 * edgeFactor;\n    }\n\n    // Apply trail offset\n    displaced += trailOffset;\n\n    // Transform normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n    // Ensure we use the 0.0 w-component to isolate rotation from scale/translation\n    vec3 transformedNormal = (instanceMatrix * vec4(selectedNormal, 0.0)).xyz;\n    vWorldNormal = normalize(mat3(modelMatrix) * transformedNormal);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // Apply instance matrix for per-instance transforms\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ARC VISIBILITY (for vortex ring effects)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vArcVisibility = 1.0;\n    if (uAnimationType == 1) {\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + aRandomSeed;\n        float halfWidth = uArcWidth * 3.14159;\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n            float angleDiff = vertexAngle - thisArcAngle;\n            angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    // View-space position: camera is at origin, so mvPosition IS the\n    // vector from camera to surface — used directly as incident ray for refract()\n    vec4 mvPosition = modelViewMatrix * instancePosition;\n    vViewPosition = mvPosition.xyz;\n\n    gl_Position = projectionMatrix * mvPosition;\n}\n`,Xg=`\nuniform float uGlobalTime;\nuniform float uMelt;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uFrostAmount;\nuniform float uInternalCracks;\nuniform float uSubsurfaceScatter;\nuniform vec3 uTint;\nuniform float uGlowIntensity;\nuniform float uBloomThreshold;\n\n// Screen-space refraction uniforms\nuniform sampler2D uBackgroundTexture;\nuniform vec2 uResolution;\nuniform int uHasBackground;\nuniform float uIOR;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${xg}\n\n// Instancing varyings\n${vg}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vWorldNormal;\nvarying vec3 vViewDir;\nvarying vec3 vViewPosition;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\nvarying vec2 vUv;\n\n${$g}\n\n// Beer's Law absorption: light passing through ice loses red first, blue last\n// thickness: how much ice light passes through (0=surface, 1=deep)\n// melt: softens the absorption (melting ice is more transparent)\nvec3 iceAbsorption(float thickness, float melt) {\n    // Absorption: visible blue-grey tint at typical viewing angles.\n    // With QUADRATIC NdotV and thickness max 2.5:\n    //   NdotV=0.7 → thickness=1.27 → R=exp(-1.02)=0.36, G=exp(-0.44)=0.64, B=exp(-0.13)=0.88\n    //   NdotV=0.5 → thickness=0.66 → R=exp(-0.53)=0.59, G=exp(-0.23)=0.79, B=exp(-0.07)=0.93\n    // Grey-blue body, not pale white clay, not opaque dark quartz.\n    float absR = mix(0.80, 0.40, melt);  // strong red removal → clearly blue\n    float absG = mix(0.35, 0.18, melt);  // moderate green removal → grey-blue\n    float absB = mix(0.10, 0.05, melt);  // slight blue attenuation → desaturated\n    vec3 a = vec3(exp(-thickness * absR), exp(-thickness * absG), exp(-thickness * absB));\n    // Floor: deep ice scatters ambient — never pure black void.\n    // Cap at 0.98: zero-thickness glass is NOT pure white. Even a thin sheet\n    // has a hint of absorption. Without this, tips read as lit white plastic.\n    return clamp(a, vec3(0.02, 0.05, 0.10), vec3(0.98));\n}\n\n// Organic surface undulation — the "Wet" look.\n// Low-frequency noise that flows over time, breaking perfect polygon refraction.\n// Applied to SMOOTH view-space normals for refraction ONLY (not specular).\n// Perturbs XY only (screen-right/up) since it targets view-space normals.\nvec3 applyMeltRipple(vec3 n, vec3 worldPos, float seed, float melt) {\n    float flow = uGlobalTime * 0.1;\n    vec3 noisePos = worldPos * 2.0 + vec3(seed * 13.7, flow, seed * 7.3);\n    float nA = snoise(noisePos);\n    float nB = snoise(noisePos + vec3(12.5, 0.0, 12.5));\n    float strength = 0.05 + melt * 0.15;\n    return normalize(n + vec3(nA, nB, 0.0) * strength);\n}\n\n// Voronoi edge-distance for dendritic frost crystal patterns\n// Returns F2-F1: thin at cell boundaries (frost veins), wide at cell centers (clear)\n// Euclidean distance → organic rounded dendrites (vs Chebyshev in cracks → angular)\nfloat voronoiFrost(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float d1 = 10.0, d2 = 10.0;\n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 nb = vec2(float(x), float(y));\n            vec2 cell = i + nb;\n            vec2 pt = nb + fract(sin(vec2(\n                dot(cell, vec2(127.1, 311.7)),\n                dot(cell, vec2(269.5, 183.3))\n            )) * 43758.5453);\n            float d = length(f - pt);\n            if (d < d1) { d2 = d1; d1 = d; }\n            else if (d < d2) { d2 = d; }\n        }\n    }\n    return d2 - d1;\n}\n\n// Perturb normal using noise gradient for crystalline sparkle\nvec3 perturbNormal(vec3 normal, vec3 pos, float strength) {\n    float eps = 0.05;\n    float nx = noise(pos + vec3(eps, 0, 0)) - noise(pos - vec3(eps, 0, 0));\n    float ny = noise(pos + vec3(0, eps, 0)) - noise(pos - vec3(0, eps, 0));\n    float nz = noise(pos + vec3(0, 0, eps)) - noise(pos - vec3(0, 0, eps));\n    vec3 grad = vec3(nx, ny, nz) / (2.0 * eps);\n    return normalize(normal - grad * strength);\n}\n\n${Cg}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    float localTime = vLocalTime;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // HYBRID NORMALS — split flat/smooth for crystal shell vs liquid interior\n    // FLAT faceNormal: specular, fresnel, NdotV → sharp chiseled crystal facets\n    // SMOOTH vNormal + wet ripple: refraction → organic liquid warp through volume\n    // This kills the "fun house kaleidoscope" without losing the faceted look.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 faceNormal = normalize(cross(dFdx(vWorldPosition), dFdy(vWorldPosition)));\n    vec3 viewDir = normalize(vViewDir);\n\n    // World normal with faceforward for DoubleSide geometry\n    vec3 worldNormal = normalize(vWorldNormal);\n\n    // If normal buffer corrupted/zeroed, fallback to view direction\n    if (length(vWorldNormal) < 0.01) {\n        worldNormal = viewDir;\n    }\n\n    // faceforward: flip normal for back faces so dot(N, viewDir) > 0\n    worldNormal = faceforward(worldNormal, -viewDir, worldNormal);\n\n    float smoothNdotV = max(0.0, dot(worldNormal, viewDir));\n    float fresnel = pow(1.0 - smoothNdotV, 4.0);\n    vec3 normal = faceNormal; // specular only\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SURFACE FROST — opaque white rime patches that block refraction\n    // Creates visual contrast: clear glass zones vs frosted matte zones.\n    // Frost is surface scattering — kills specular, blocks see-through.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // Dendritic frost — Voronoi edge-distance (F2-F1) creates crystal vein patterns.\n    // THIN VEINS ONLY — no broadFill. Frost is sharp crystalline lines, not sheets.\n    // broadFill was covering 60% of rings in opaque white → "plastic sheet" look.\n    float frostVein = voronoiFrost(vPosition.xz * 4.0 + vec2(vRandomSeed * 5.2));\n    float thinVein = 1.0 - smoothstep(0.0, 0.06, frostVein); // Thinner veins = sharper crystal lines\n    float frostRaw = thinVein; // No broadFill — veins, not sheets\n    // Break mask — TIGHT so frost appears in rare clusters, not everywhere.\n    // Low frequency (0.4x) → each break patch spans ~10 Voronoi cells → coherent crystal clusters.\n    float frostBreak = noise(vec3(vPosition.xz * 0.4, 0.0));\n    frostRaw *= smoothstep(0.50, 0.75, frostBreak);\n    float frostMask = frostRaw * uFrostAmount;\n    frostMask *= (1.0 - smoothstep(0.1, 0.4, uMelt)); // Melt kills frost first\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // BEER'S LAW ABSORPTION — defines how light is colored passing through ice\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // STABLE THICKNESS & CLARITY MASK (Iteration 100)\n    // Linear transition ensures the teal tint doesn't "snap" to geometry\n    float distFromCenter = length(vPosition);\n    float isTip = smoothstep(0.4, 1.2, distFromCenter);\n    float thickness = smoothstep(0.0, 1.0, smoothNdotV) * 0.65 * (1.0 - isTip);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SCHLICK FRESNEL — dielectric reflection coefficient\n    // Head-on: mostly transmitted (see through). Glancing: mostly reflected.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float F0 = 0.02; // ice IOR ~1.31\n    float schlick = F0 + (1.0 - F0) * fresnel;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // LIGHT DIRECTION — used ONLY for frost diffuse shading.\n    // Glass body has ZERO diffuse. It's invisible until it refracts or reflects.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 mainLight = normalize(vec3(0.3, 1.0, 0.5));\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SCREEN-SPACE REFRACTION — sample background through distorted UVs\n    // The background was rendered to a texture without ice meshes.\n    // Normal-based UV distortion simulates light bending through ice volume.\n    // The refracted result is composited at FULL OPACITY — the "transparency"\n    // is already baked into transmittedLight via Beer's Law absorption.\n    // Using partial alpha would blend warped with un-warped = ghostly weak warp.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ─── GRAND UNIFIED GLASS MODEL ───\n    // Glass has ZERO diffuse. It is invisible until it refracts something\n    // or reflects a specular highlight. In a vacuum it is BLACK.\n    // Final = (refractedBackground × absorption) + specular. Nothing else.\n    //\n    // Three DECOUPLED properties:\n    // 1. absorptionDepth (= thickness) → Controls COLOR only. Tips = clear (white).\n    // 2. Refraction distortion → INDEPENDENT of thickness. Tips still bend light.\n    // 3. Alpha = 1.0 → We ALWAYS see the warped background. "Transparency"\n    //    is in the absorption color, not the alpha channel.\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // REFRACTION — View-space vectors for screen-aligned UV distortion\n    // I_vs = incident ray (camera→surface in view space) = normalize(vViewPosition)\n    // N_vs = view-space normal with faceforward for DoubleSide geometry\n    // refract() .xy maps directly to screen right/up — no camera rotation artifacts.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 transmittedLight;\n    vec3 voidColor = vec3(0.08, 0.12, 0.18);\n\n    // Ice body color — "average environment as seen through ice volume."\n    // Acts as ambient fill where refracted background is too dark.\n    vec3 iceBodyColor = vec3(0.30, 0.48, 0.58) * uTint;\n\n    if (uHasBackground == 1) {\n        vec2 screenUV = gl_FragCoord.xy / uResolution;\n\n        // View-space vectors for refraction\n        vec3 I_vs = normalize(vViewPosition);\n        vec3 N_vs = faceforward(normalize(vNormal), I_vs, normalize(vNormal));\n\n        float distortion = 0.04 + (thickness * 0.15);\n        vec3 refDir = refract(I_vs, N_vs, 0.75);\n\n        // TIR fallback: use incident direction (minimal distortion)\n        if (length(refDir) < 0.1) refDir = I_vs;\n\n        vec2 uvBase = clamp(screenUV + refDir.xy * distortion, 0.0, 1.0);\n        vec3 refractedBg = texture2D(uBackgroundTexture, uvBase).rgb;\n\n        // Screen-blend lift: adds light to dark areas, barely touches bright areas.\n        // Dark pixel (0.1) → 0.1 + 0.15*0.9 = 0.235 (visible shadow detail)\n        // Bright pixel (0.8) → 0.8 + 0.15*0.2 = 0.83 (unchanged)\n        // This is the "ambient environment light entering through the glass."\n        vec3 ambientLift = vec3(0.10, 0.15, 0.22);\n        refractedBg += ambientLift * (vec3(1.0) - refractedBg);\n\n        // LERP absorption: blend lifted background toward ice body color.\n        transmittedLight = mix(refractedBg, iceBodyColor, thickness * 0.4);\n    } else {\n        transmittedLight = mix(voidColor, iceBodyColor, thickness * 0.4);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ENERGY CONSERVATION — softer teeter-totter (×0.3 not ×0.5).\n    // At edges fresnel≈0.8: multiplier = 0.76 (gentle dim, not black).\n    // ═══════════════════════════════════════════════════════════════════════════════\n    transmittedLight *= (1.0 - fresnel * 0.3);\n\n    // Ambient reflection at glancing angles (Schlick-driven edge brightness)\n    vec3 envReflection = vec3(0.15, 0.25, 0.35) * uTint;\n    transmittedLight += envReflection * schlick;\n\n    // Internal scatter — faint volumetric glow at edges\n    transmittedLight += vec3(0.04, 0.1, 0.14) * fresnel;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // INTERNAL FRACTURE PLANES — flat crystalline sheets trapped inside the volume\n    // Voronoi cells with Chebyshev distance → large angular regions.\n    // Each cell is either a fracture plane (milky scatter) or clear glass.\n    // Per-plane view-dependent brightness from random orientation.\n    // Boundary edges highlighted where fractured meets clear glass.\n    // Computed here, composited AFTER soft clamp (see below).\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float fracPlanes = 0.0;\n    float fracEdge = 0.0;\n    {\n        vec2 fpPx = viewDir.xz / max(smoothNdotV, 0.25) * 0.12;\n        vec2 fpPos = (vPosition.xz + fpPx) * 1.5 + vec2(vRandomSeed * 6.0, vRandomSeed * 4.2);\n        vec2 fpi = floor(fpPos);\n        vec2 fpf = fract(fpPos);\n\n        float fd1 = 10.0, fd2 = 10.0;\n        vec2 fcell1 = vec2(0.0), fcell2 = vec2(0.0);\n\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                vec2 nb = vec2(float(x), float(y));\n                vec2 cell = fpi + nb;\n                vec2 pt = nb + fract(sin(vec2(\n                    dot(cell, vec2(127.1, 311.7)),\n                    dot(cell, vec2(269.5, 183.3))\n                )) * 43758.5453);\n                vec2 diff = fpf - pt;\n                float d = max(abs(diff.x), abs(diff.y));\n                if (d < fd1) { fd2 = fd1; fcell2 = fcell1; fd1 = d; fcell1 = cell; }\n                else if (d < fd2) { fd2 = d; fcell2 = cell; }\n            }\n        }\n\n        float edgeDist = fd2 - fd1;\n\n        // Per-cell fracture determination (~18% of cells have fractures)\n        float fh1 = fract(sin(dot(fcell1, vec2(43.37, 87.71))) * 43758.5453);\n        float fh2 = fract(sin(dot(fcell2, vec2(43.37, 87.71))) * 43758.5453);\n        float fhas1 = step(0.82, fh1);\n        float fhas2 = step(0.82, fh2);\n\n        // View-dependent brightness for the fractured cell's "plane orientation"\n        float fang = fract(sin(dot(fcell1, vec2(13.17, 67.29))) * 43758.5453) * 6.28;\n        vec2 fdir = vec2(cos(fang), sin(fang));\n        float fbright = abs(dot(fdir, viewDir.xz));\n        fbright = mix(0.25, 1.0, fbright);\n        float fbase = mix(0.5, 1.0, fract(fh1 * 7.13));\n\n        // Fracture fill: milky scatter inside fractured cells\n        fracPlanes = fhas1 * fbright * fbase;\n\n        // Fracture boundary edge: bright line where fractured cell meets clear cell\n        float isBoundary = abs(fhas1 - fhas2);\n        fracEdge = isBoundary * (1.0 - smoothstep(0.0, 0.04, edgeDist));\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // FROST — opaque rime veins over clear glass\n    // Applied after energy conservation so frost isn't dimmed at edges.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float frostLuma = min(0.65, uBloomThreshold + 0.25);\n    vec3 frostColor = vec3(frostLuma, frostLuma * 1.02, frostLuma * 1.05);\n    float frostDiffuse = max(0.4, dot(normal, mainLight));\n    frostColor *= frostDiffuse;\n    transmittedLight = mix(transmittedLight, frostColor, frostMask);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // PIXEL MATH — transmission + specular only. No boost, no scatter, no Schlick.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 color = transmittedLight;\n    color *= uIntensity;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // TRAPPED AIR BUBBLES — round spherical voids frozen inside the ice\n    // Two scales: large prominent bubbles + small fizzy detail.\n    // Each bubble: bright interior, dark ring edge, caustic highlight on top.\n    // Cluster mask concentrates bubbles in patches (not uniform everywhere).\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec3 bubbleParallax = viewDir * 0.08 / max(smoothNdotV, 0.25);\n    // Per-instance offset so each ice element has unique bubble placement\n    vec3 bubbleSamplePos = vPosition + bubbleParallax + vec3(vRandomSeed * 10.0);\n\n    // Cluster mask — mild variation, NOT aggressive culling\n    float bubbleCluster = noise(vPosition * 2.0 + vec3(vRandomSeed * 5.0, 0.0, 0.0));\n    float clusterMask = 0.5 + 0.5 * bubbleCluster; // 0.5–1.0 range, never fully off\n\n    // 3D volumetric bubbles (scale 8, 65% density) — spheres cut by the surface\n    vec2 bub = bubbleField3D(bubbleSamplePos, 8.0, 0.65);\n\n    // Tiny fizzy specks — cheap noise threshold dots for density between big bubbles\n    float fizz = smoothstep(0.82, 0.89, noise(bubbleSamplePos * 35.0)) * 0.20;\n\n    float bubbleBright = (bub.x + fizz) * clusterMask * (1.0 - frostMask);\n    float bubbleRing = bub.y * clusterMask * (1.0 - frostMask);\n\n    // Bright interior (primary) + subtle dark edge (secondary)\n    color += vec3(0.80, 0.85, 0.92) * bubbleBright * 0.35;\n    color -= vec3(0.07, 0.06, 0.04) * bubbleRing;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SPECULAR — sharp concentrated glints for the wet/glossy look\n    // Uses FLAT face normals: each polygon catches light independently\n    // 4 lights for good coverage, high power for sharp points\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float specPower = mix(128.0, 32.0, uMelt); // Broader highlights — glossy glass, not pinpoint diamond\n\n    // 3 lights — enough coverage for visible glints on the now-darker body.\n    // Sparse deep scratches: only top 5% of noise peaks become cuts.\n    // 95% of surface is perfectly smooth glass. Where a scratch exists,\n    // perturbation is strong (0.3) → visible specular scatter without\n    // the "sandpaper everywhere" problem of low-strength global noise.\n    float scratchNoise = noise(vWorldPosition * 20.0 + vec3(vRandomSeed * 17.3));\n    float scratchMask = step(0.95, scratchNoise); // Only top 5% become scratches\n    float scrAngle = noise(vWorldPosition * 3.0 + vec3(vRandomSeed * 5.1)) * 6.28;\n    vec3 scratchDir = vec3(sin(scrAngle), cos(scrAngle), 0.0);\n    vec3 scratchedNormal = normalize(normal + scratchDir * scratchMask * 0.3);\n    vec3 reflDir = reflect(-viewDir, scratchedNormal);\n    float spec1 = pow(max(dot(reflDir, normalize(vec3(0.5, 1.0, 0.3))), 0.0), specPower);\n    float spec2 = pow(max(dot(reflDir, normalize(vec3(-0.4, 0.8, -0.4))), 0.0), specPower) * 0.6;\n    float spec3 = pow(max(dot(reflDir, normalize(vec3(-0.3, 0.6, 0.7))), 0.0), specPower) * 0.4;\n    float spec = spec1 + spec2 + spec3;\n\n    vec3 specContrib = mix(vec3(1.0), vec3(0.9, 0.95, 1.0), fresnel) * spec * 2.5 * (1.0 - uMelt * 0.5);\n    specContrib *= (1.0 - frostMask); // Frost is matte — kills specular completely\n    color += specContrib;\n\n    // Wet film specular — secondary tighter highlight on smooth surface.\n    // Creates the "water on glass" look. Uses smooth world normal, not flat facets.\n    // Power 120 = very sharp pinpoints. Layered on top of the broader faceted spec.\n    vec3 wetReflDir = reflect(-viewDir, worldNormal);\n    float wetSpec = pow(max(dot(wetReflDir, normalize(vec3(0.5, 1.0, 0.3))), 0.0), 120.0);\n    wetSpec += pow(max(dot(wetReflDir, normalize(vec3(-0.4, 0.8, -0.4))), 0.0), 120.0) * 0.5;\n    wetSpec += pow(max(dot(wetReflDir, normalize(vec3(0.0, 0.6, -0.8))), 0.0), 120.0) * 0.3;\n    color += vec3(1.0) * wetSpec * 0.8 * (1.0 - frostMask);\n\n    // Broad wet sheen — soft glossy highlight from thin water film on ice surface.\n    // Medium specular power = visible gloss patches, not uniform brightening.\n    // Uses smooth worldNormal: the water film IS smooth even over faceted ice.\n    float sheen1 = pow(max(dot(wetReflDir, normalize(vec3(0.3, 1.0, 0.2))), 0.0), 24.0);\n    float sheen2 = pow(max(dot(wetReflDir, normalize(vec3(-0.3, 0.8, -0.5))), 0.0), 24.0) * 0.5;\n    float sheen3 = pow(max(dot(wetReflDir, normalize(vec3(0.6, 0.4, 0.6))), 0.0), 16.0) * 0.3;\n    float wetSheen = sheen1 + sheen2 + sheen3;\n    color += vec3(0.92, 0.95, 1.0) * wetSheen * 0.06 * (1.0 - frostMask) * (1.0 - uMelt * 0.5);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SOFT CLAMP — cap the smooth glass BASE before adding bright features\n    // Cracks/specular/bubbles are added AFTER this so they can exceed the cap\n    // and trigger bloom glow. The smooth glass body stays within bounds.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float softCap = uBloomThreshold + 0.30;\n    float finalMax = max(color.r, max(color.g, color.b));\n    if (finalMax > softCap) {\n        color *= softCap / finalMax;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // INTERNAL FRACTURE PLANES — milky crystalline inclusions\n    // Cell fill: angular milky zones where flat fracture sheets scatter light.\n    // Boundary edges: bright lines where fractured cells meet clear glass.\n    // Applied post-clamp so both features exceed the capped body color.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    color = mix(color, vec3(0.88, 0.92, 0.97), fracPlanes * 0.42 * uInternalCracks);\n    color = mix(color, vec3(1.02, 1.05, 1.08), fracEdge * 0.55 * uInternalCracks);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // INTERNAL CRACK LINES (two-scale Voronoi with Chebyshev distance)\n    // Three realism layers:\n    //   1. LOW-FREQ MASK: breaks continuous loops into isolated jagged segments\n    //   2. DARK FRACTURES: occlusion planes that block light (applied first)\n    //   3. BRIGHT SCATTER: reflection planes that catch light (applied on top)\n    // Plus view-dependent sparkle: fracture brightness shifts with camera angle.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // Crack values hoisted for edge-breakup discard (used after crack coloring)\n    float coarseCrack = 0.0;\n    float fineCrack = 0.0;\n\n    if (uInternalCracks > 0.01) {\n\n        // ─── PARALLAX INTERIOR OFFSET ───\n        // Offset crack sampling by view direction to create depth illusion.\n        // Cracks shift as you rotate, looking like they're INSIDE the volume.\n        float parallaxScale = 0.12;\n        vec2 parallaxDir = viewDir.xz / max(smoothNdotV, 0.25);\n        vec2 coarseParallax = parallaxDir * parallaxScale;        // shallow layer\n        vec2 fineParallax = parallaxDir * parallaxScale * 1.8;    // deeper layer\n\n        // ─── BREAK-THE-WEB MASK ───\n        // Low-frequency noise erases ~75% of crack lines. Most of the surface\n        // is PERFECTLY CLEAR glass — only 20-25% has dramatic fractures.\n        // Frequency 0.4 → large smooth patches, not small noisy spots.\n        float breakMask = noise(vec3(vPosition.xz * 0.4, 0.0));\n        float coarseMask = smoothstep(0.55, 0.78, breakMask); // ~75% erased — huge quiet zones\n        float fineMask = smoothstep(0.48, 0.72, breakMask);   // fine cracks slightly more visible\n\n        // ─── COARSE FRACTURE PLANES (scale 0.7 — MASSIVE structural cleaves) ───\n        // Very low frequency → 3-4 fractures spanning the entire object.\n        // Ring torus gets 2-3 dramatic cracks, not 1000 tiny scratches.\n        vec2 coarsePos = (vPosition.xz + coarseParallax) * 0.7;\n        vec2 cci = floor(coarsePos);\n        vec2 ccf = fract(coarsePos);\n        float cd1 = 10.0, cd2 = 10.0;\n        vec2 cCell1 = vec2(0.0), cCell2 = vec2(0.0);\n\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                vec2 nb = vec2(float(x), float(y));\n                vec2 cell = cci + nb;\n                vec2 pt = nb + fract(sin(vec2(\n                    dot(cell, vec2(127.1, 311.7)),\n                    dot(cell, vec2(269.5, 183.3))\n                )) * 43758.5453);\n                vec2 diff = ccf - pt;\n                float d = max(abs(diff.x), abs(diff.y)); // Chebyshev: angular cells\n                if (d < cd1) { cd2 = cd1; cCell2 = cCell1; cd1 = d; cCell1 = cell; }\n                else if (d < cd2) { cd2 = d; cCell2 = cell; }\n            }\n        }\n\n        float coarseEdge = cd2 - cd1;\n        float coarsePairHash = fract(sin(dot(cCell1 + cCell2, vec2(78.233, 143.71))) * 43758.5453);\n        float coarseWidth = mix(0.008, 0.025, coarsePairHash); // Slightly wider — dramatic structural cleaves\n        coarseCrack = (1.0 - smoothstep(0.0, coarseWidth, coarseEdge)) * coarseMask;\n        // Halo band just outside crack — refraction brightening\n        float coarseBrightEdge = smoothstep(0.0, coarseWidth, coarseEdge) * (1.0 - smoothstep(coarseWidth, coarseWidth + 0.08, coarseEdge));\n        float coarseDepth = mix(0.75, 1.0, coarsePairHash);\n\n        // ─── VIEW-DEPENDENT SPARKLE ───\n        // Each fracture plane has a pseudo-normal derived from its cell hash.\n        // Planes facing the camera flash bright; planes facing away go dim.\n        // This makes cracks "twinkle" as the object rotates — like diamond facets.\n        vec2 coarsePlaneDir = normalize(vec2(coarsePairHash * 2.0 - 1.0, fract(coarsePairHash * 7.13) * 2.0 - 1.0));\n        float coarseSparkle = abs(dot(coarsePlaneDir, viewDir.xz)); // 0=edge-on (dim), 1=face-on (flash)\n        coarseSparkle = mix(0.05, 1.0, coarseSparkle); // Wide range: TIR flicker — some nearly vanish\n\n        // ─── DARK FRACTURES (occlusion planes — slightly offset from bright) ───\n        // A second crack layer at offset parallax simulates fracture planes that\n        // BLOCK light instead of scattering it. Dark blue-grey occlusion lines.\n        vec2 darkParallax = parallaxDir * parallaxScale * 0.5; // shallower depth — different plane\n        vec2 darkPos = (vPosition.xz + darkParallax + vec2(0.13, -0.09)) * 0.7; // offset breaks alignment, same scale as coarse\n        vec2 dci = floor(darkPos);\n        vec2 dcf = fract(darkPos);\n        float dd1 = 10.0, dd2 = 10.0;\n\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                vec2 nb = vec2(float(x), float(y));\n                vec2 cell = dci + nb;\n                vec2 pt = nb + fract(sin(vec2(\n                    dot(cell, vec2(127.1, 311.7)),\n                    dot(cell, vec2(269.5, 183.3))\n                )) * 43758.5453);\n                vec2 diff = dcf - pt;\n                float d = max(abs(diff.x), abs(diff.y));\n                if (d < dd1) { dd2 = dd1; dd1 = d; }\n                else if (d < dd2) { dd2 = d; }\n            }\n        }\n\n        float darkEdge = dd2 - dd1;\n        float darkCrack = (1.0 - smoothstep(0.0, 0.012, darkEdge)) * coarseMask;\n\n        // ─── FINE CRACKS (scale 2.0 — secondary fractures, still large) ───\n        vec2 finePos = (vPosition.xz + fineParallax) * 2.0;\n        vec2 fci = floor(finePos);\n        vec2 fcf = fract(finePos);\n        float fd1 = 10.0, fd2 = 10.0;\n        vec2 fCell1 = vec2(0.0), fCell2 = vec2(0.0);\n\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                vec2 nb = vec2(float(x), float(y));\n                vec2 cell = fci + nb;\n                vec2 pt = nb + fract(sin(vec2(\n                    dot(cell, vec2(127.1, 311.7)),\n                    dot(cell, vec2(269.5, 183.3))\n                )) * 43758.5453);\n                vec2 diff = fcf - pt;\n                float d = max(abs(diff.x), abs(diff.y)); // Chebyshev\n                if (d < fd1) { fd2 = fd1; fCell2 = fCell1; fd1 = d; fCell1 = cell; }\n                else if (d < fd2) { fd2 = d; fCell2 = cell; }\n            }\n        }\n\n        float fineEdge = fd2 - fd1;\n        float finePairHash = fract(sin(dot(fCell1 + fCell2, vec2(78.233, 143.71))) * 43758.5453);\n        float fineWidth = mix(0.003, 0.012, finePairHash); // Thin secondary fractures\n        fineCrack = (1.0 - smoothstep(0.0, fineWidth, fineEdge)) * fineMask;\n        float fineDepth = mix(0.5, 0.9, finePairHash);\n\n        // Fine sparkle (independent plane direction)\n        vec2 finePlaneDir = normalize(vec2(finePairHash * 2.0 - 1.0, fract(finePairHash * 11.3) * 2.0 - 1.0));\n        float fineSparkle = abs(dot(finePlaneDir, viewDir.xz));\n        fineSparkle = mix(0.05, 1.0, fineSparkle); // Wide range: TIR flicker — some cracks nearly vanish\n\n        // ─── CRACK SPECULAR GLINTS (physical grooves catch light) ───\n        // Use dFdx/dFdy of edge distances to get crack surface gradient.\n        // This perturbs the normal WHERE cracks exist, so fracture lines\n        // physically interact with specular — they glint like real grooves.\n        // Both coarse AND fine cracks get their own specular pass.\n        float crackSpecGlint = 0.0;\n        if (coarseCrack > 0.05) {\n            float dex = dFdx(coarseEdge);\n            float dey = dFdy(coarseEdge);\n            vec3 crackGrad = vec3(dex, 0.0, dey);\n            vec3 crackNorm = normalize(normal + crackGrad * 10.0); // Strong groove perturbation\n            vec3 crackRefl = reflect(-viewDir, crackNorm);\n            float cSpec = pow(max(dot(crackRefl, normalize(vec3(0.3, 1.0, 0.5))), 0.0), 48.0);\n            cSpec += pow(max(dot(crackRefl, normalize(vec3(-0.4, 0.8, -0.4))), 0.0), 48.0) * 0.6;\n            cSpec += pow(max(dot(crackRefl, normalize(vec3(0.6, 0.3, -0.6))), 0.0), 48.0) * 0.3;\n            crackSpecGlint += cSpec * coarseCrack * coarseSparkle;\n        }\n        if (fineCrack > 0.05) {\n            float fdex = dFdx(fineEdge);\n            float fdey = dFdy(fineEdge);\n            vec3 fineGrad = vec3(fdex, 0.0, fdey);\n            vec3 fineNorm = normalize(normal + fineGrad * 12.0);\n            vec3 fineRefl = reflect(-viewDir, fineNorm);\n            float fSpec = pow(max(dot(fineRefl, normalize(vec3(0.3, 1.0, 0.5))), 0.0), 48.0);\n            crackSpecGlint += fSpec * fineCrack * fineSparkle * 0.4;\n        }\n\n        // ─── COMPOSITE ───\n        // 1. Dark occlusion fractures FIRST (subtractive — blocks light)\n        color = mix(color, vec3(0.0, 0.1, 0.3), darkCrack * 0.25 * uInternalCracks);\n\n        // 2. Coarse bright scatter ON TOP (additive — catches light)\n        //    Sparkle modulates brightness: some planes flash, others nearly vanish.\n        color = mix(color, vec3(1.15), coarseCrack * coarseDepth * coarseSparkle * uInternalCracks * 0.7);\n\n        // 3. Crack specular glints — physical groove highlights (the "shattered glass" flash)\n        color += vec3(1.0) * crackSpecGlint * 2.5 * uInternalCracks;\n\n        // 4. Refraction halo: subtle brightening adjacent to fracture\n        color = mix(color, vec3(1.3), coarseBrightEdge * coarseMask * 0.25 * uInternalCracks);\n\n        // 5. Fine: hairline secondary scratches with their own sparkle\n        color = mix(color, vec3(1.05), fineCrack * fineDepth * fineSparkle * uInternalCracks * 0.3);\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // EDGE BREAKUP — discard at silhouette edges where cracks exist\n    // Uses the SAME Voronoi cracks already computed above, so holes perfectly\n    // match the visible crack lines. Only active when gesture opts in via edgeMask.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    if (uCutoutEdgeMask > 0.0) {\n        float eLenX = length(dFdx(vWorldPosition));\n        float eLenY = length(dFdy(vWorldPosition));\n        float eRatio = max(eLenX, eLenY) / max(min(eLenX, eLenY), 0.00001);\n\n        float eLow = mix(1.1, 2.5, uCutoutEdgeMask);\n        float eHigh = eLow + 0.8;\n        float eFactor = smoothstep(eLow, eHigh, eRatio);\n\n        // Combined crack mask — coarse dominates, fine contributes\n        float crackMask = max(coarseCrack, fineCrack * 0.7);\n\n        // At edges where cracks exist → discard for jagged silhouette\n        if (eFactor * crackMask > 0.2) discard;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ALPHA — SOLID CRYSTAL. Always 1.0.\n    // "Transparency" comes from the refracted background painted onto the surface,\n    // NOT from alpha blending. Alpha<1.0 blends warped+unwarped = ghost artifact.\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float alpha = 1.0;\n\n    // Instance fade (spawn/exit)\n    alpha *= vInstanceAlpha;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ARC VISIBILITY (for vortex effects)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    if (uAnimationType == 1) {\n        alpha *= vArcVisibility;\n        color *= mix(0.3, 1.0, vArcVisibility);\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // CUTOUT EFFECT (shared pattern system from InstancedAnimationCore)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    ${Pg}\n\n    // Apply trail dissolve\n    alpha *= trailAlpha;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // GRAIN EFFECT (noise texture overlay)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    ${kg}\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // FINAL OUTPUT\n    // ═══════════════════════════════════════════════════════════════════════════════\n    if (alpha < 0.01) discard;\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,Qg=Rg,Kg={charge:.5,opacity:.85,fadeInDuration:.15,fadeOutDuration:.3};function Zg(e,t,i){return e+(t-e)*i}const Jg=`\n// Standard uniforms\nuniform float uGlobalTime;\nuniform float uFadeInDuration;\nuniform float uFadeOutDuration;\n\n// Arc visibility uniforms (for vortex effects)\nuniform int uAnimationType;\nuniform float uArcWidth;\nuniform float uArcSpeed;\nuniform int uArcCount;\nuniform float uGestureProgress;\n\n// Per-instance attributes\n${yg}\n\n// Varyings to fragment\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\n\nvoid main() {\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // INSTANCING: Calculate local time and fade\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vLocalTime = uGlobalTime - aSpawnTime;\n\n    // Trail instances have delayed local time\n    float trailDelay = max(0.0, aTrailIndex) * 0.05;\n    float effectiveLocalTime = max(0.0, vLocalTime - trailDelay);\n\n    // Fade controlled by aInstanceOpacity from AnimationState\n    float fadeOut = 1.0;\n    if (aExitTime > 0.0) {\n        float exitElapsed = uGlobalTime - aExitTime;\n        fadeOut = 1.0 - clamp(exitElapsed / uFadeOutDuration, 0.0, 1.0);\n    }\n\n    // Trail fade\n    vTrailFade = aTrailIndex < 0.0 ? 1.0 : (1.0 - (aTrailIndex + 1.0) * 0.25);\n    vInstanceAlpha = fadeOut * aInstanceOpacity * vTrailFade;\n\n    // Pass velocity\n    vVelocity = aVelocity;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // MODEL SELECTION: Scale non-selected models to zero\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    float modelMatch = step(abs(aModelIndex - aSelectedModel), 0.5);\n    vec3 selectedPosition = position * modelMatch;\n    vec3 selectedNormal = normal * modelMatch;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // TRAIL OFFSET: Position trails behind main along velocity\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vec3 trailOffset = vec3(0.0);\n    if (aTrailIndex >= 0.0 && length(aVelocity.xyz) > 0.001) {\n        float trailDistance = (aTrailIndex + 1.0) * 0.05;\n        trailOffset = -normalize(aVelocity.xyz) * trailDistance * aVelocity.w;\n    }\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ELECTRIC: No vertex displacement — lightning is purely fragment-based\n    // ═══════════════════════════════════════════════════════════════════════════════\n\n    vPosition = selectedPosition;\n    vRandomSeed = aRandomSeed;\n    vVerticalGradient = clamp((selectedPosition.y + 0.5) / 1.0, 0.0, 1.0);\n\n    vec3 displaced = selectedPosition + trailOffset;\n\n    // Transform normal with instance matrix\n    vNormal = normalMatrix * mat3(instanceMatrix) * selectedNormal;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // Apply instance matrix for per-instance transforms\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vec4 instancePosition = instanceMatrix * vec4(displaced, 1.0);\n\n    vec4 worldPos = modelMatrix * instancePosition;\n    vWorldPosition = worldPos.xyz;\n    vViewDir = normalize(cameraPosition - worldPos.xyz);\n\n    // Instance origin in world space (for trail dissolve)\n    vec4 instanceOrigin = modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    vInstancePosition = instanceOrigin.xyz;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ARC VISIBILITY (for vortex ring effects)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    vArcVisibility = 1.0;\n    if (uAnimationType == 1) {\n        float vertexAngle = atan(selectedPosition.z, selectedPosition.x);\n        float arcAngle = uGestureProgress * uArcSpeed * 6.28318 + aRandomSeed;\n        float halfWidth = uArcWidth * 3.14159;\n        float arcSpacing = 6.28318 / float(max(1, uArcCount));\n\n        float maxVis = 0.0;\n        for (int i = 0; i < 4; i++) {\n            if (i >= uArcCount) break;\n            float thisArcAngle = arcAngle + float(i) * arcSpacing;\n            float angleDiff = mod(vertexAngle - thisArcAngle + 3.14159, 6.28318) - 3.14159;\n            float vis = 1.0 - smoothstep(halfWidth * 0.7, halfWidth, abs(angleDiff));\n            maxVis = max(maxVis, vis);\n        }\n        vArcVisibility = maxVis;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * instancePosition;\n}\n`,ef=`\nuniform float uGlobalTime;\nuniform float uCharge;\nuniform float uIntensity;\nuniform float uOpacity;\nuniform float uFlickerSpeed;\nuniform float uFlickerAmount;\nuniform float uSparkDensity;\nuniform float uBloomThreshold;\nuniform float uFlashIntensity;\n\n// Animation system uniforms (glow, cutout, travel, etc.) from shared core\n${xg}\n\n// Instancing varyings\n${vg}\n\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec3 vInstancePosition;\nvarying vec3 vNormal;\nvarying vec3 vViewDir;\nvarying float vRandomSeed;\nvarying float vArcVisibility;\nvarying float vVerticalGradient;\n\n\n// 2D hash for Voronoi cell positions\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453);\n}\n\n// 3D vector hash for Voronoi cell positions (matches overlay shader)\nvec3 hash3(vec3 p) {\n    p = vec3(\n        dot(p, vec3(127.1, 311.7, 74.7)),\n        dot(p, vec3(269.5, 183.3, 246.1)),\n        dot(p, vec3(113.5, 271.9, 124.6))\n    );\n    return fract(sin(p) * 43758.5453);\n}\n\n// 3D hash for value noise (required by cutout system's snoise)\nfloat noiseHash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(mix(noiseHash(i), noiseHash(i + vec3(1,0,0)), f.x),\n            mix(noiseHash(i + vec3(0,1,0)), noiseHash(i + vec3(1,1,0)), f.x), f.y),\n        mix(mix(noiseHash(i + vec3(0,0,1)), noiseHash(i + vec3(1,0,1)), f.x),\n            mix(noiseHash(i + vec3(0,1,1)), noiseHash(i + vec3(1,1,1)), f.x), f.y),\n        f.z\n    );\n}\n\nfloat snoise(vec3 p) {\n    return noise(p) * 2.0 - 1.0;\n}\n\n\n// Electric color from charge level: pale blue → cyan → white-blue\nvec3 getElectricColor(float charge) {\n    vec3 low = vec3(0.5, 0.7, 1.0);      // pale blue\n    vec3 mid = vec3(0.3, 0.95, 1.0);     // bright cyan\n    vec3 high = vec3(0.85, 0.97, 1.0);   // white-blue\n\n    float t1 = smoothstep(0.0, 0.4, charge);\n    float t2 = smoothstep(0.4, 0.8, charge);\n\n    vec3 color = mix(low, mid, t1);\n    return mix(color, high, t2);\n}\n\n// ═══════════════════════════════════════════════════════════════════════════════════════\n// 2D Voronoi edge distance — thin branching lines for lightning\n// Cell boundaries form the bolt network. Animated cell positions drift over time.\n// Returns: distance to nearest Voronoi cell edge (small value = on a bolt line)\n// ═══════════════════════════════════════════════════════════════════════════════════════\nfloat voronoiEdge2D(vec2 p, float time, float jitter) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    // First pass: find closest cell center\n    float minDist = 10.0;\n    vec2 closestPoint = vec2(0.0);\n    vec2 closestCell = vec2(0.0);\n\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 cellId = n + neighbor;\n            vec2 cellHash = hash2(cellId);\n            vec2 cellOffset = cellHash * jitter;\n            // Cells drift over time — lightning shifts and branches\n            cellOffset += sin(time * 3.0 + cellHash * 6.28) * 0.15;\n\n            vec2 cellPoint = neighbor + cellOffset;\n            float d = length(cellPoint - f);\n\n            if (d < minDist) {\n                minDist = d;\n                closestPoint = cellPoint;\n                closestCell = cellId;\n            }\n        }\n    }\n\n    // Second pass: find distance to nearest cell edge (perpendicular bisector)\n    // This is where the THIN LINES come from\n    float minEdgeDist = 10.0;\n\n    for (int j = -1; j <= 1; j++) {\n        for (int i = -1; i <= 1; i++) {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 cellId = n + neighbor;\n\n            if (cellId == closestCell) continue;\n\n            vec2 cellHash = hash2(cellId);\n            vec2 cellOffset = cellHash * jitter;\n            cellOffset += sin(time * 3.0 + cellHash * 6.28) * 0.15;\n\n            vec2 cellPoint = neighbor + cellOffset;\n\n            // Edge = perpendicular bisector between two cell centers\n            vec2 toCenter = (closestPoint + cellPoint) * 0.5;\n            vec2 cellDiff = normalize(cellPoint - closestPoint);\n            float edgeDist = abs(dot(toCenter - f, cellDiff));\n\n            minEdgeDist = min(minEdgeDist, edgeDist);\n        }\n    }\n\n    return minEdgeDist;\n}\n\n// Sparse bright spark points — random flickering bright spots\nfloat sparks2D(vec2 pos, float time) {\n    vec2 gridPos = pos * 8.0;\n    vec2 gridId = floor(gridPos);\n    vec2 gridUv = fract(gridPos);\n\n    float spark = 0.0;\n    for (int y = 0; y <= 1; y++) {\n        for (int x = 0; x <= 1; x++) {\n            vec2 offset = vec2(float(x), float(y));\n            vec2 cellId = gridId + offset;\n\n            vec2 sparkPos = hash2(cellId) * 0.8 + 0.1;\n            float d = length(gridUv - offset - sparkPos + 0.5);\n\n            // Irregular flicker timing — sparks pop in and out randomly\n            float flickerSeed = dot(cellId, vec2(127.1, 311.7));\n            float flicker = step(0.8, fract(sin(time * 12.0 + flickerSeed) * 43758.5453));\n\n            spark += smoothstep(0.15, 0.0, d) * flicker;\n        }\n    }\n\n    return spark;\n}\n\n// ═══════════════════════════════════════════════════════════════════════════════════════\n// 3D Voronoi edge distance — matches overlay shader's dense bolt network\n// 3D creates bolt lines in all three dimensions, overlapping when viewed\n// through depth → much denser network than 2D\n// ═══════════════════════════════════════════════════════════════════════════════════════\nfloat voronoiEdge3D(vec3 p, float time, float jitter) {\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n\n    // First pass: find closest cell center\n    float minDist = 10.0;\n    vec3 closestPoint = vec3(0.0);\n    vec3 closestCell = vec3(0.0);\n\n    for (int k = -1; k <= 1; k++) {\n        for (int j = -1; j <= 1; j++) {\n            for (int i = -1; i <= 1; i++) {\n                vec3 neighbor = vec3(float(i), float(j), float(k));\n                vec3 cellId = n + neighbor;\n                vec3 cellHash = hash3(cellId);\n                vec3 cellOffset = cellHash * jitter;\n                cellOffset += sin(time * 3.0 + cellHash * 6.28) * 0.15;\n\n                vec3 cellPoint = neighbor + cellOffset;\n                float d = length(cellPoint - f);\n\n                if (d < minDist) {\n                    minDist = d;\n                    closestPoint = cellPoint;\n                    closestCell = cellId;\n                }\n            }\n        }\n    }\n\n    // Second pass: find distance to nearest cell edge (perpendicular bisector)\n    float minEdgeDist = 10.0;\n\n    for (int k = -1; k <= 1; k++) {\n        for (int j = -1; j <= 1; j++) {\n            for (int i = -1; i <= 1; i++) {\n                vec3 neighbor = vec3(float(i), float(j), float(k));\n                vec3 cellId = n + neighbor;\n\n                if (cellId == closestCell) continue;\n\n                vec3 cellHash = hash3(cellId);\n                vec3 cellOffset = cellHash * jitter;\n                cellOffset += sin(time * 3.0 + cellHash * 6.28) * 0.15;\n\n                vec3 cellPoint = neighbor + cellOffset;\n\n                vec3 toCenter = (closestPoint + cellPoint) * 0.5;\n                vec3 cellDiff = normalize(cellPoint - closestPoint);\n                float edgeDist = abs(dot(toCenter - f, cellDiff));\n\n                minEdgeDist = min(minEdgeDist, edgeDist);\n            }\n        }\n    }\n\n    return minEdgeDist;\n}\n\n// 3D sparse bright spark points\nfloat sparks3D(vec3 pos, float time) {\n    vec3 gridPos = pos * 8.0;\n    vec3 gridId = floor(gridPos);\n    vec3 gridUv = fract(gridPos);\n\n    float spark = 0.0;\n    for (int z = 0; z <= 1; z++) {\n        for (int y = 0; y <= 1; y++) {\n            for (int x = 0; x <= 1; x++) {\n                vec3 offset = vec3(float(x), float(y), float(z));\n                vec3 cellId = gridId + offset;\n\n                vec3 sparkPos = hash3(cellId) * 0.8 + 0.1;\n                float d = length(gridUv - offset - sparkPos + 0.5);\n\n                float flickerSeed = dot(cellId, vec3(127.1, 311.7, 74.7));\n                float flicker = step(0.8, fract(sin(time * 12.0 + flickerSeed) * 43758.5453));\n\n                spark += smoothstep(0.15, 0.0, d) * flicker;\n            }\n        }\n    }\n\n    return spark;\n}\n\n${Cg}\n\nvoid main() {\n    // Early discard for fully faded instances\n    if (vInstanceAlpha < 0.01) discard;\n\n    float localTime = vLocalTime;\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewDir);\n\n    // Per-instance time offset — each instance gets unique lightning patterns\n    float instanceTimeOffset = vRandomSeed * 10.0;\n    float effectiveTime = localTime + instanceTimeOffset;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // FRESNEL — subtle edge highlight (matches overlay shader)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float fresnel = pow(1.0 - abs(dot(normal, viewDir)), 3.0);\n    float rimGlow = fresnel * 0.15 * uCharge;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // PRIMARY BOLT NETWORK (large bolts, scale 3)\n    // Matches overlay: thin lines + pow() sharpening → bright cores that bloom\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float lineWidth = 0.015;\n\n    float edge1 = voronoiEdge3D(vWorldPosition * 3.0, effectiveTime * 0.8, 0.85);\n    float bolt1 = 1.0 - smoothstep(0.0, lineWidth * 1.2, edge1);\n    bolt1 = pow(bolt1, 2.0);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SECONDARY CRACKLING (fine detail, scale 6)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float edge2 = voronoiEdge3D(vWorldPosition * 6.0, effectiveTime * 1.2, 0.8);\n    float bolt2 = 1.0 - smoothstep(0.0, lineWidth * 0.8, edge2);\n    bolt2 = pow(bolt2, 2.5) * 0.6;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // TERTIARY MICRO-CRACKS (finest detail, scale 10)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float edge3 = voronoiEdge3D(vWorldPosition * 10.0, effectiveTime * 1.6, 0.75);\n    float bolt3 = 1.0 - smoothstep(0.0, lineWidth * 0.5, edge3);\n    bolt3 = pow(bolt3, 3.0) * 0.3;\n\n    // Combine — three overlapping scales create dense bolt network\n    float lightning = min(bolt1 + bolt2 + bolt3, 1.0);\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // FLICKER — electrical pulsing (per-instance variation)\n    // Step-based for sharp on/off characteristic of real electricity\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float flickerPhase = vRandomSeed * 100.0;\n    float flickerTime = effectiveTime * uFlickerSpeed * 0.5;\n\n    // Multi-frequency flicker for irregular pulsing\n    float f1 = step(0.5, fract(sin(flickerTime * 11.3 + flickerPhase) * 43758.5453));\n    float f2 = step(0.65, fract(sin(flickerTime * 7.7 + flickerPhase * 1.3) * 43758.5453)) * 0.5;\n    float flicker = (1.0 - uFlickerAmount) + uFlickerAmount * max(f1, f2);\n\n    lightning *= flicker;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // SPARKS — occasional bright point flashes\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float sparkVal = sparks3D(vWorldPosition + vec3(vRandomSeed * 50.0), effectiveTime) * uSparkDensity;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // COLOR — bolt network drives both color and visibility\n    // Dark areas between bolts are TRANSPARENT — model geometry hidden\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float brightness = lightning + sparkVal + rimGlow;\n\n    vec3 baseColor = getElectricColor(uCharge);\n\n    // Bolt peaks shift slightly white — keeps cyan identity\n    float whiteMix = smoothstep(0.7, 1.0, brightness) * 0.3;\n    vec3 brightColor = baseColor * 1.5 + vec3(0.2, 0.3, 0.4);\n    vec3 color = mix(baseColor, brightColor, whiteMix);\n\n    // Apply brightness and intensity (no bloom compression — matches overlay)\n    color *= min(brightness * uIntensity, 2.5);\n\n    // Fresnel edge glow (scaled by uGlowScale for gesture ramping)\n    color += fresnel * baseColor * 0.2 * uGlowScale;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // ALPHA — bolt brightness drives visibility\n    // Dark areas between cells are transparent — model geometry hidden\n    // ═══════════════════════════════════════════════════════════════════════════════\n    float alpha = brightness * uOpacity;\n    alpha = clamp(alpha, 0.0, 0.95);\n\n    // Apply instance fade (spawn/exit + trail)\n    alpha *= vInstanceAlpha;\n\n    // Arc visibility (for vortex effects)\n    if (uAnimationType == 1) {\n        alpha *= vArcVisibility;\n        if (vArcVisibility < 0.05) discard;\n    }\n\n    if (alpha < 0.03) discard;\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // CUTOUT + GRAIN (shared systems from InstancedAnimationCore)\n    // ═══════════════════════════════════════════════════════════════════════════════\n    ${Pg}\n\n    // Apply trail dissolve\n    alpha *= trailAlpha;\n\n    ${kg}\n\n    // ═══════════════════════════════════════════════════════════════════════════════\n    // LIGHTNING FLASH — opt-in per-gesture dramatic strike effect\n    // When uFlashIntensity > 0: boost brightness, shift toward white, force alpha high\n    // ═══════════════════════════════════════════════════════════════════════════════\n    if (uFlashIntensity > 0.01) {\n        float flashBoost = 1.0 + uFlashIntensity * 3.0;\n        color *= flashBoost;\n        color = mix(color, vec3(flashBoost), uFlashIntensity * 0.4);\n        alpha = min(alpha * flashBoost, 0.95);\n    }\n\n    gl_FragColor = vec4(color, alpha);\n}\n`,tf=Rg;pg.register("fire",{basePath:"models/Elements/Fire/",models:["flame-wisp.glb","flame-tongue.glb","ember-cluster.glb","fire-burst.glb","flame-ring.glb"],createMaterial:function(t={}){const{temperature:i=Mg.temperature,intensity:a=null,opacity:n=Mg.opacity,flameHeight:s=Mg.flameHeight,turbulence:r=Mg.turbulence,displacementStrength:o=Mg.displacementStrength,noiseScale:l=Mg.noiseScale,flickerSpeed:c=null,flickerAmount:h=null,edgeFade:u=Mg.edgeFade,edgeSoftness:d=null,emberDensity:m=null,emberBrightness:p=null,velocityStretch:g=Mg.velocityStretch,fadeInDuration:f=Mg.fadeInDuration,fadeOutDuration:y=Mg.fadeOutDuration}=t,v=function(e,t={}){return{intensity:t.intensity??wg(1.5,2.5,4,e),flickerSpeed:t.flickerSpeed??wg(.001,.002,.003,e),flickerAmount:t.flickerAmount??wg(.15,.12,.08,e),emberDensity:t.emberDensity??wg(.1,.3,.5,e),emberBrightness:t.emberBrightness??wg(.5,.8,1.2,e),edgeSoftness:t.edgeSoftness??wg(.6,.5,.3,e)}}(i,{intensity:a,flickerSpeed:c,flickerAmount:h,edgeSoftness:d,emberDensity:m,emberBrightness:p}),b=v.intensity,w=v.flickerSpeed,M=v.flickerAmount,S=v.edgeSoftness,x=v.emberDensity,C=v.emberBrightness,P=new e.ShaderMaterial({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:f},uFadeOutDuration:{value:y},...Ag(),uTemperature:{value:i},uIntensity:{value:b},uOpacity:{value:n},uFlameHeight:{value:s},uTurbulence:{value:r},uDisplacementStrength:{value:o},uNoiseScale:{value:l},uFlickerSpeed:{value:w},uFlickerAmount:{value:M},uEdgeFade:{value:u},uEdgeSoftness:{value:S},uEmberDensity:{value:x},uEmberBrightness:{value:C},uVelocityStretch:{value:g}},vertexShader:zg,fragmentShader:Lg,transparent:!0,blending:e.AdditiveBlending,depthWrite:!1,side:e.DoubleSide});return P.userData.temperature=i,P.userData.elementalType="fire",P.userData.isProcedural=!0,P.userData.isInstanced=!0,P},updateMaterial:function(e,t,i=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),Eg(e,i)},setShaderAnimation:Gg,setGestureGlow:function(e,t){Bg(e,t)},setCutout:function(e,t){_g(e,t)},resetCutout:Tg,setGrain:Ig,resetGrain:Og,resetShaderAnimation:Fg,scaleMultiplier:1.5,distortion:{geometry:()=>new e.PlaneGeometry(1,1),material:function(){return new e.ShaderMaterial({name:"FireDistortion",uniforms:{uTime:{value:0},uStrength:{value:.005}},vertexShader:fg,fragmentShader:`\n            uniform float uTime;\n            uniform float uStrength;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            ${gg}\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 wp = vWorldPos.xy;\n\n                float t = uTime * 2.0;\n\n                // Two-octave turbulence — frequencies sized for half-res RT survival\n                // (features must be larger than 2 RT pixels to avoid aliasing away)\n                float n1 = dNoise2D(vec2(wp.x * 18.0, wp.y * 10.0 - t * 2.5));\n                float n2 = dNoise2D(vec2(wp.x * 35.0, wp.y * 18.0 - t * 3.5)) * 0.5;\n                float turb = (n1 + n2) - 0.75; // Center around zero\n\n                // Horizontal: subtle — heat shimmer is mostly vertical\n                float dx = turb * uStrength * 0.25;\n\n                // Vertical: dominant rising streaks\n                float wobble = sin(wp.x * 25.0 + t * 1.2) * 0.2;\n                float dy = (turb + wobble) * uStrength;\n\n                // Edge falloff (UV-space)\n                float falloff = smoothstep(0.0, 0.2, uv.x) * smoothstep(1.0, 0.8, uv.x)\n                              * smoothstep(0.0, 0.15, uv.y) * smoothstep(1.0, 0.85, uv.y);\n\n                // Stronger in the middle height band (above heat source)\n                float heightWeight = smoothstep(0.0, 0.25, uv.y) * smoothstep(1.0, 0.5, uv.y);\n\n                float strength = falloff * heightWeight;\n                gl_FragColor = vec4(dx * strength, dy * strength, 0.0, 1.0);\n            }\n        `,blending:e.AdditiveBlending,depthWrite:!1,depthTest:!1,transparent:!0,side:e.DoubleSide})},transform:{padding:new e.Vector3(.3,.3,.3)},billboard:!0,strength:.005}}),pg.register("water",{basePath:"models/Elements/Water/",models:["droplet-small.glb","droplet-large.glb","splash-ring.glb","bubble-cluster.glb","wave-curl.glb"],createMaterial:function(t={}){const{turbulence:i=jg.turbulence,intensity:a=null,opacity:n=jg.opacity,displacementStrength:s=null,flowSpeed:r=null,noiseScale:o=jg.noiseScale,edgeFade:l=jg.edgeFade,glowScale:c=jg.glowScale,tint:h=16777215,fadeInDuration:u=jg.fadeInDuration,fadeOutDuration:d=jg.fadeOutDuration}=t,m=a??Ng(.8,1,1.2,i),p=s??Ng(.06,.1,.15,i),g=r??Ng(.8,1.5,3,i),f=h instanceof e.Color?h:new e.Color(h),y=new e.ShaderMaterial({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:u},uFadeOutDuration:{value:d},...Ag(),uGlowScale:{value:c},uTurbulence:{value:i},uIntensity:{value:m},uOpacity:{value:n},uDisplacementStrength:{value:p},uFlowSpeed:{value:g},uNoiseScale:{value:o},uEdgeFade:{value:l},uBloomThreshold:{value:.5},uTint:{value:f},uDepthGradient:{value:.3},uInternalFlowSpeed:{value:1},uSparkleIntensity:{value:.4},uBackgroundTexture:{value:null},uResolution:{value:new e.Vector2(1,1)},uHasBackground:{value:0}},vertexShader:qg,fragmentShader:Ug,transparent:!0,depthWrite:!0,side:e.DoubleSide});return y.userData.turbulence=i,y.userData.elementalType="water",y.userData.isProcedural=!0,y.userData.isInstanced=!0,y.userData.needsRefraction=!0,y},updateMaterial:function(e,t,i=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),Eg(e,i)},setShaderAnimation:Wg,setGestureGlow:function(e,t){Bg(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){_g(e,t)},resetCutout:Tg,setGrain:Ig,resetGrain:Og,resetShaderAnimation:Fg,scaleMultiplier:1.2,distortion:{geometry:()=>new e.PlaneGeometry(1,1),material:function(){return new e.ShaderMaterial({name:"WaterDistortion",uniforms:{uTime:{value:0},uStrength:{value:.003}},vertexShader:fg,fragmentShader:"\n            uniform float uTime;\n            uniform float uStrength;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 center = uv - 0.5;\n                float dist = length(center);\n                vec2 dir = normalize(center + 0.001);\n\n                // Concentric expanding rings (UV-space center — rings scale with effect)\n                float t = uTime * 1.0;\n                float ring1 = sin(dist * 20.0 - t * 4.0) * 0.5 + 0.5;\n                float ring2 = sin(dist * 14.0 - t * 2.8 + 1.0) * 0.5 + 0.5;\n                float rings = ring1 * 0.6 + ring2 * 0.4;\n\n                // Radial push (outward from center)\n                vec2 offset = dir * rings * uStrength;\n\n                // Falloff: strong near center, zero at edge\n                float falloff = smoothstep(0.5, 0.1, dist);\n\n                gl_FragColor = vec4(offset * falloff, 0.0, 1.0);\n            }\n        ",blending:e.AdditiveBlending,depthWrite:!1,depthTest:!1,transparent:!0,side:e.DoubleSide})},transform:{padding:new e.Vector3(.3,.3,.3)},billboard:!0,strength:.003}}),pg.register("ice",{basePath:"models/Elements/Ice/",models:["crystal-small.glb","crystal-medium.glb","crystal-cluster.glb","ice-spike.glb","ice-ring.glb"],createMaterial:function(t={}){const{melt:i=Hg.melt,intensity:a=Hg.intensity,opacity:n=Hg.opacity,frostAmount:s=Hg.frostAmount,internalCracks:r=Hg.internalCracks,subsurfaceScatter:o=Hg.subsurfaceScatter,glowScale:l=Hg.glowScale,tint:c=16777215,fadeInDuration:h=Hg.fadeInDuration,fadeOutDuration:u=Hg.fadeOutDuration}=t,d=s*(1-i),m=r*(1-.5*i),p=c instanceof e.Color?c:new e.Color(c),g=new e.ShaderMaterial({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:h},uFadeOutDuration:{value:u},...Ag(),uGlowScale:{value:l},uMelt:{value:i},uIntensity:{value:a},uOpacity:{value:n},uFrostAmount:{value:d},uInternalCracks:{value:m},uSubsurfaceScatter:{value:o},uTint:{value:p},uGlowIntensity:{value:1},uBloomThreshold:{value:.5},uBackgroundTexture:{value:null},uResolution:{value:new e.Vector2(1,1)},uHasBackground:{value:0},uIOR:{value:1.31}},vertexShader:Yg,fragmentShader:Xg,transparent:!0,depthWrite:!0,side:e.DoubleSide});return g.userData.melt=i,g.userData.elementalType="ice",g.userData.isProcedural=!0,g.userData.isInstanced=!0,g.userData.needsRefraction=!0,g},updateMaterial:function(e,t,i=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),Eg(e,i)},setShaderAnimation:Qg,setGestureGlow:function(e,t){Bg(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){_g(e,t)},resetCutout:Tg,setGrain:Ig,resetGrain:Og,resetShaderAnimation:Fg,scaleMultiplier:1.2,distortion:{geometry:()=>new e.PlaneGeometry(1,1),material:function(){return new e.ShaderMaterial({name:"IceDistortion",uniforms:{uTime:{value:0},uStrength:{value:.003}},vertexShader:fg,fragmentShader:`\n            uniform float uTime;\n            uniform float uStrength;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            ${gg}\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 wp = vWorldPos.xy;\n\n                float t = uTime * 0.3; // Slow — cold mist is languid\n\n                // Gentle pulse: strength oscillates slowly (0.8–1.0)\n                float pulse = 0.8 + 0.2 * sin(uTime * 0.5);\n\n                // Two-layer rolling fog — world-space so pattern is stable\n                float mist1 = dNoise2D(wp * 3.0 + vec2(t * 0.4, -t * 0.2));\n                float mist2 = dNoise2D(wp * 5.0 + vec2(-t * 0.3, -t * 0.15));\n\n                // Equal horizontal drift and downward pull\n                float dx = (mist1 - 0.5) * uStrength;\n                float dy = (mist2 - 0.5) * uStrength - uStrength * 0.5; // Constant downward bias\n\n                // Cold air pools at bottom — strongest low, fading upward\n                float heightWeight = smoothstep(0.6, 0.1, uv.y);\n\n                // Edge falloff (UV-space — plane edges)\n                float falloff = smoothstep(0.0, 0.2, uv.x) * smoothstep(1.0, 0.8, uv.x)\n                              * smoothstep(0.0, 0.1, uv.y) * smoothstep(1.0, 0.9, uv.y);\n\n                float strength = falloff * heightWeight * pulse;\n\n                gl_FragColor = vec4(dx * strength, dy * strength, 0.0, 1.0);\n            }\n        `,blending:e.AdditiveBlending,depthWrite:!1,depthTest:!1,transparent:!0,side:e.DoubleSide})},transform:{padding:new e.Vector3(.3,.5,.3),centerOffset:new e.Vector3(0,-.15,0)},billboard:!0,strength:.003}}),pg.register("electricity",{basePath:"models/Elements/Electricity/",models:["arc-small.glb","arc-medium.glb","arc-cluster.glb","spark-node.glb","lightning-ring.glb","plasma-ring.glb","arc-ring-small.glb","spark-spike.glb"],createMaterial:function(t={}){const{charge:i=Kg.charge,intensity:a=null,opacity:n=Kg.opacity,flickerSpeed:s=null,flickerAmount:r=null,sparkDensity:o=null,fadeInDuration:l=Kg.fadeInDuration,fadeOutDuration:c=Kg.fadeOutDuration}=t,h=function(e,t={}){return{intensity:t.intensity??Zg(1,4,e),flickerSpeed:t.flickerSpeed??Zg(4,16,e),flickerAmount:t.flickerAmount??Zg(.1,.4,e),sparkDensity:t.sparkDensity??Zg(.2,.8,e)}}(i,{intensity:a,flickerSpeed:s,flickerAmount:r,sparkDensity:o}),u=new e.ShaderMaterial({uniforms:{uGlobalTime:{value:0},uFadeInDuration:{value:l},uFadeOutDuration:{value:c},...Ag(),uCharge:{value:i},uIntensity:{value:h.intensity},uOpacity:{value:n},uFlickerSpeed:{value:h.flickerSpeed},uFlickerAmount:{value:h.flickerAmount},uSparkDensity:{value:h.sparkDensity},uBloomThreshold:{value:.85},uFlashIntensity:{value:0}},vertexShader:Jg,fragmentShader:ef,transparent:!0,blending:e.AdditiveBlending,depthWrite:!1,side:e.DoubleSide});return u.userData.charge=i,u.userData.elementalType="electric",u.userData.isProcedural=!0,u.userData.isInstanced=!0,u},updateMaterial:function(e,t,i=0){e?.uniforms?.uGlobalTime&&(e.uniforms.uGlobalTime.value=t),Eg(e,i);const a=e?.userData?.flashConfig;if(a&&e.uniforms?.uFlashIntensity){let t=0;const{events:n}=a,s=a.decay||.03;for(let e=0;e<n.length;e++)if(i>=n[e].at){const a=i-n[e].at,r=n[e].intensity*Math.exp(-a/s);r>t&&(t=r)}e.uniforms.uFlashIntensity.value=t}},setShaderAnimation:tf,setGestureGlow:function(e,t){Bg(e,t)},setBloomThreshold:function(e,t){e?.uniforms?.uBloomThreshold&&(e.uniforms.uBloomThreshold.value=t)},setCutout:function(e,t){_g(e,t)},resetCutout:Tg,setGrain:Ig,resetGrain:Og,setFlash:function(e,t){e&&(e.userData.flashConfig=t,e.uniforms?.uFlashIntensity&&(e.uniforms.uFlashIntensity.value=0))},resetFlash:function(e){e&&(e.userData.flashConfig=null,e.uniforms?.uFlashIntensity&&(e.uniforms.uFlashIntensity.value=0))},resetShaderAnimation:Fg,scaleMultiplier:1.3,distortion:{geometry:()=>new e.PlaneGeometry(1,1),material:function(){return new e.ShaderMaterial({name:"ElectricDistortion",uniforms:{uTime:{value:0},uStrength:{value:.003},uFlashIntensity:{value:0}},vertexShader:fg,fragmentShader:`\n            uniform float uTime;\n            uniform float uStrength;\n            uniform float uFlashIntensity;\n            varying vec2 vUv;\n            varying vec3 vWorldPos;\n\n            ${gg}\n\n            void main() {\n                vec2 uv = vUv;\n                vec2 wp = vWorldPos.xy;\n\n                // Step noise: random jitter that changes abruptly (not smooth)\n                // World-space coords so jitter cells don't shift when AABB resizes\n                float t = floor(uTime * 15.0); // 15 fps step noise\n                vec2 hashCoord1 = wp * 50.0 + vec2(t);\n                vec2 hashCoord2 = wp * 50.0 + vec2(t + 100.0);\n                float jitterX = (dHash(hashCoord1) - 0.5) * 2.0;\n                float jitterY = (dHash(hashCoord2) - 0.5) * 2.0;\n\n                // Sparse: only ~30% of pixels get jitter\n                vec2 cellCoord = floor(wp * 20.0) + vec2(t * 0.1);\n                float active = step(0.7, dHash(cellCoord));\n\n                vec2 offset = vec2(jitterX, jitterY) * uStrength * active;\n\n                // Flash boost: distortion spikes during lightning flash\n                offset *= 1.0 + uFlashIntensity * 3.0;\n\n                // Edge falloff (UV-space — plane edges)\n                float falloff = smoothstep(0.0, 0.15, uv.x) * smoothstep(1.0, 0.85, uv.x)\n                              * smoothstep(0.0, 0.15, uv.y) * smoothstep(1.0, 0.85, uv.y);\n\n                gl_FragColor = vec4(offset * falloff, 0.0, 1.0);\n            }\n        `,blending:e.AdditiveBlending,depthWrite:!1,depthTest:!1,transparent:!0,side:e.DoubleSide})},transform:{padding:new e.Vector3(.3,.3,.3)},billboard:!0,strength:.003}});class af{constructor(){this.bounds={minY:-.5,maxY:.5,centerY:0,height:1},this.landmarks={},this.radius=1,this._coreMesh=null}initialize(e){if(this._coreMesh=e,!e?.geometry)return console.warn("[MascotSpatialRef] No geometry available, using defaults"),void this._computeLandmarks();const{geometry:t}=e,{scale:i}=e;if(t.boundingBox||t.computeBoundingBox(),t.boundingBox){const e=t.boundingBox;this.bounds={minY:e.min.y,maxY:e.max.y,centerY:.5*(e.min.y+e.max.y),height:e.max.y-e.min.y}}if(t.boundingSphere||t.computeBoundingSphere(),t.boundingSphere){const e=(i.x+i.y+i.z)/3;this.radius=t.boundingSphere.radius*e}this.radius=Math.max(.1,this.radius),console.log(`[MascotSpatialRef] Calculated radius: ${this.radius.toFixed(3)}`),this._computeLandmarks()}_computeLandmarks(){const e=this.bounds,t=.15*e.height;this.landmarks={bottom:e.minY,center:e.centerY,top:e.maxY,head:e.maxY+t,feet:e.minY,middle:e.centerY,above:e.maxY+.3*e.height,below:e.minY-.2*e.height}}resolveLandmark(e){return"number"==typeof e?e:"string"==typeof e&&Object.hasOwn(this.landmarks,e)?this.landmarks[e]:(console.warn(`[MascotSpatialRef] Unknown landmark: ${e}, using center`),this.bounds.centerY)}resolveLandmarkWithOffset(e,t=0){return this.resolveLandmark(e)+t}interpolateLandmarks(e,t,i){const a=this.resolveLandmark(e);return a+(this.resolveLandmark(t)-a)*i}isWithinBounds(e){return e>=this.bounds.minY&&e<=this.bounds.maxY}getProgressAtY(e){return 0===this.bounds.height?.5:(e-this.bounds.minY)/this.bounds.height}get top(){return this.landmarks.top}get bottom(){return this.landmarks.bottom}get center(){return this.landmarks.center}get head(){return this.landmarks.head}get height(){return this.bounds.height}refresh(){this._coreMesh&&this.initialize(this._coreMesh)}}const nf=1.6180339887,sf={tiny:1/Math.pow(nf,4),small:1/Math.pow(nf,3),medium:1/Math.pow(nf,2),large:1/nf,prominent:1/Math.pow(nf,.5)},rf={"crystal-small":{class:"tiny",variance:.25},"crystal-medium":{class:"small",variance:.2},"crystal-cluster":{class:"medium",variance:.2},"ice-spike":{class:"small",variance:.25},"rock-chunk-small":{class:"small",variance:.25},"rock-chunk-medium":{class:"medium",variance:.2},"rock-cluster":{class:"large",variance:.2},"stone-slab":{class:"medium",variance:.25},"vine-tendril":{class:"medium",variance:.3},"vine-coil":{class:"medium",variance:.25},"thorn-vine":{class:"small",variance:.3},"leaf-single":{class:"tiny",variance:.25},"leaf-cluster":{class:"small",variance:.3},"fern-frond":{class:"medium",variance:.25},"flower-bud":{class:"tiny",variance:.3},"flower-bloom":{class:"small",variance:.25},"petal-scatter":{class:"tiny",variance:.3},"root-tendril":{class:"small",variance:.3},"moss-patch":{class:"tiny",variance:.25},"mushroom-cap":{class:"small",variance:.3},"ember-cluster":{class:"tiny",variance:.3},"flame-wisp":{class:"small",variance:.25},"flame-tongue":{class:"medium",variance:.25},"fire-burst":{class:"large",variance:.2},"flame-ring":{class:"large",variance:.15},"arc-small":{class:"small",variance:.25},"arc-medium":{class:"medium",variance:.2},"arc-cluster":{class:"large",variance:.2},"spark-node":{class:"tiny",variance:.3},"droplet-small":{class:"tiny",variance:.25},"droplet-large":{class:"small",variance:.2},"splash-ring":{class:"medium",variance:.25},"bubble-cluster":{class:"small",variance:.3},"wave-curl":{class:"medium",variance:.25},"void-crack":{class:"small",variance:.3},"shadow-tendril":{class:"medium",variance:.25},"corruption-patch":{class:"small",variance:.3},"void-shard":{class:"tiny",variance:.25},"light-ray":{class:"medium",variance:.25},"prism-shard":{class:"small",variance:.2},"halo-ring":{class:"large",variance:.2},"sparkle-star":{class:"tiny",variance:.3}},of={"crystal-small":{mode:"outward",tiltAngle:.15},"crystal-medium":{mode:"outward",tiltAngle:.2},"crystal-cluster":{mode:"outward",tiltAngle:.25},"ice-spike":{mode:"outward",tiltAngle:.05},"rock-chunk-small":{mode:"outward",tiltAngle:.35},"rock-chunk-medium":{mode:"outward",tiltAngle:.3},"rock-cluster":{mode:"outward",tiltAngle:.15},"stone-slab":{mode:"flat",tiltAngle:.1},"vine-tendril":{mode:"tangent",tiltAngle:.2},"vine-coil":{mode:"tangent",tiltAngle:.15},"thorn-vine":{mode:"tangent",tiltAngle:.25},"leaf-single":{mode:"flat",tiltAngle:.3},"leaf-cluster":{mode:"outward",tiltAngle:.4},"fern-frond":{mode:"outward",tiltAngle:.5},"flower-bud":{mode:"outward",tiltAngle:.2},"flower-bloom":{mode:"outward",tiltAngle:.3},"petal-scatter":{mode:"flat",tiltAngle:.1},"root-tendril":{mode:"tangent",tiltAngle:-.1},"moss-patch":{mode:"flat",tiltAngle:0},"mushroom-cap":{mode:"outward",tiltAngle:.15},"ember-cluster":{mode:"rising",tiltAngle:.2,riseFactor:.6},"flame-wisp":{mode:"rising",tiltAngle:.15,riseFactor:.8},"flame-tongue":{mode:"rising",tiltAngle:.2,riseFactor:.75},"fire-burst":{mode:"rising",tiltAngle:.25,riseFactor:.5},"flame-ring":{mode:"flat",tiltAngle:0},"arc-small":{mode:"tangent",tiltAngle:.1},"arc-medium":{mode:"tangent",tiltAngle:.15},"arc-cluster":{mode:"outward",tiltAngle:.3},"spark-node":{mode:"outward",tiltAngle:.4},"droplet-small":{mode:"falling",tiltAngle:.1,fallFactor:.7},"droplet-large":{mode:"falling",tiltAngle:.05,fallFactor:.8},"splash-ring":{mode:"flat",tiltAngle:.05},"bubble-cluster":{mode:"rising",tiltAngle:.2,riseFactor:.5},"wave-curl":{mode:"vertical",tiltAngle:0},"void-crack":{mode:"outward-flat",tiltAngle:.05},"shadow-tendril":{mode:"tangent",tiltAngle:.3},"corruption-patch":{mode:"flat",tiltAngle:0},"void-shard":{mode:"outward",tiltAngle:.35},"light-ray":{mode:"outward",tiltAngle:.1},"prism-shard":{mode:"outward",tiltAngle:.2},"halo-ring":{mode:"outward-flat",tiltAngle:0},"sparkle-star":{mode:"outward",tiltAngle:.3}};function lf(e){return of[e]||{mode:"outward",tiltAngle:.2}}function cf(e,t,i=1){const a=function(e){const t=rf[e];if(!t){const e=sf.small;return{base:e,min:.8*e,max:1.2*e}}const i=sf[t.class],a=t.variance||.2;return{base:i,min:i*(1-a),max:i*(1+a)}}(e);return(a.min+Math.random()*(a.max-a.min))*t*i}const hf={vec3_a:new e.Vector3,vec3_b:new e.Vector3,vec3_c:new e.Vector3,vec3_d:new e.Vector3,vec3_e:new e.Vector3,vec3_f:new e.Vector3,vec3_g:new e.Vector3,quat_a:new e.Quaternion,quat_b:new e.Quaternion,matrix_a:new e.Matrix4,cameraDir:new e.Vector3};function uf(e,t,i=0,a=null,n=null,s=null){const r=hf.vec3_a.set(0,1,0),o=hf.vec3_b,l=hf.vec3_c,c=hf.vec3_d,h=hf.quat_a,u=hf.quat_b,d=t?lf(t):{mode:"outward",tiltAngle:.2},m=Math.random()*Math.PI*2;switch(Math.abs(e.y)<.999?o.crossVectors(r,e).normalize():o.set(1,0,0).cross(e).normalize(),l.crossVectors(e,o).normalize(),c.copy(o).multiplyScalar(Math.cos(m)).addScaledVector(l,Math.sin(m)),h.identity(),d.mode){case"flat":{const t=hf.matrix_a,i=hf.vec3_e.crossVectors(c,e).normalize();t.makeBasis(c,e,i),h.setFromRotationMatrix(t),0!==d.tiltAngle&&(u.setFromAxisAngle(c,d.tiltAngle),h.premultiply(u))}break;case"tangent":{const t=.3,i=hf.vec3_e.copy(e).multiplyScalar(t).addScaledVector(c,1-t).normalize();if(h.setFromUnitVectors(r,i),0!==d.tiltAngle){const t=hf.vec3_f.crossVectors(c,e).normalize();u.setFromAxisAngle(t,d.tiltAngle),h.premultiply(u)}}break;case"rising":case"falling":{const t=d.riseFactor??.7,i="falling"===d.mode?-(d.fallFactor??.7):t,a=hf.vec3_e;if(i>=0)a.copy(e).multiplyScalar(1-i).add(hf.vec3_f.set(0,i,0)).normalize();else{const t=Math.abs(i);a.copy(e).multiplyScalar(1-t).add(hf.vec3_f.set(0,-t,0)).normalize()}h.setFromUnitVectors(r,a),0!==d.tiltAngle&&(u.setFromAxisAngle(c,d.tiltAngle),h.premultiply(u)),u.setFromAxisAngle(a,m),h.premultiply(u);break}case"outward-flat":{const t=hf.vec3_e.copy(e),i=hf.matrix_a,a=hf.vec3_f.copy(c),n=hf.vec3_g.crossVectors(a,t).normalize(),s=hf.vec3_f.crossVectors(t,n).normalize();i.makeBasis(n,s,t),h.setFromRotationMatrix(i),0!==d.tiltAngle&&(u.setFromAxisAngle(n,d.tiltAngle),h.premultiply(u));break}case"velocity":if(s&&s.x*s.x+s.y*s.y+s.z*s.z>1e-4){const e=hf.vec3_e.set(s.x,s.y,s.z).normalize();h.setFromUnitVectors(r,e)}else{const t=hf.vec3_f.set(0,-1,0),i=.5,a=hf.vec3_e.copy(e).multiplyScalar(1-i).addScaledVector(t,i).normalize();h.setFromUnitVectors(r,a)}0!==d.tiltAngle&&(u.setFromAxisAngle(c,d.tiltAngle),h.premultiply(u));break;default:h.setFromUnitVectors(r,e),0!==d.tiltAngle&&(u.setFromAxisAngle(c,d.tiltAngle),h.premultiply(u)),u.setFromAxisAngle(e,m),h.premultiply(u)}if(i>0&&a&&n&&"outward"===d.mode){const e=hf.cameraDir.copy(a.position).sub(n).normalize();u.setFromUnitVectors(r,e),h.slerp(u,i)}return h}function df(e,t,i,a=.2){const n=(1-a)*i*.4-a*i*.3,s=e.clone(),r=t.clone().multiplyScalar(n);return s.add(r),{position:s,offset:n}}const mf="waiting",pf="entering",gf="holding",ff="exiting",yf="dead";class vf{constructor(e,t=0,i=null){this.config=e,this.index=t,this.elementConfig=e.createElementConfig(t),i&&Object.assign(this.elementConfig,i),this.state=mf,this.progress=0,this.birthTime=0,this.stateStartTime=0,this.enterCompleteTime=0,this.exitStartTime=0,this.respawnCount=0,this.isDead=!1,this.opacity=0,this.scale=0,this.emissive=1,this.fadeProgress=0,this.holdTime=0,this.pulsePhase=0,this.flickerValue=1,this.driftOffset={x:0,y:0,z:0},this.rotationOffset={x:0,y:0,z:0},this.currentBeat=0,this.lastBeatTriggered=-1,this.waitingForBeat=!1,this.gestureProgress=0}setBeat(e,t=120){this.currentBeat=e,this.bpm=t;const{appearOnBeat:i}=this.config.timing;null!==i&&this.state===mf&&e>=i&&this.lastBeatTriggered<i&&(this.waitingForBeat=!1,this.lastBeatTriggered=e)}initialize(e){this.birthTime=e,this.stateStartTime=e,this.state=mf,this.progress=0,this.opacity=0,this.scale=0,this.respawnCount=0,this.isDead=!1,"local"===this.config.hold.pulse?.sync&&(this.pulsePhase=.2*this.index),this._fireEvent("onSpawn")}update(e,t,i=null){if(this.isDead)return!1;null!==i&&(this.gestureProgress=i);const a=this._getAppearTime(i),n=this._getDisappearTime(i),s=this._getCurrentTime(e,i);switch(this.state){case mf:this._updateWaiting(s,a,e);break;case pf:this._updateEntering(e,t,s,n);break;case gf:this._updateHolding(e,t,s,n);break;case ff:this._updateExiting(e,t);break;case yf:return this._handleDead()}return!this.isDead}_getCurrentTime(e,t){return"progress"===this.config.timing.mode&&null!==t?t:1e3*(e-this.birthTime)}_getAppearTime(e){const{appearOnBeat:t}=this.config.timing;if(null!==t){if(this.currentBeat<t)return this.waitingForBeat=!0,1/0;this.waitingForBeat=!1}const i=this.config.getAppearTime(),a=this.config.getStaggerOffset(this.index),n=this.elementConfig.delayOffset||0;return"progress"===this.config.timing.mode?i+a+n:i+a+n*this.config.gestureDuration}_getDisappearTime(e){const t=this.config.getDisappearTime(),i=this.elementConfig.lifetimeMultiplier||1;if("progress"===this.config.timing.mode){const e=t-this.config.timing.appearAt;return this.config.timing.appearAt+e*i}return t*i}_updateWaiting(e,t,i){e>=t&&(this._transitionTo(pf,i),this._fireEvent("onEnterStart")),this.opacity=0,this.scale=0}_updateEntering(e,t,i,a){const{enter:n}=this.config,s="progress"===this.config.timing.mode?n.duration*this.config.gestureDuration/1e3:n.durationMs/1e3,r=e-this.stateStartTime;this.progress=Math.min(r/s,1);const o=n.easing(this.progress);this._applyEnterAnimation(o),this._applyRotation(e,t),this.progress>=1&&(this.enterCompleteTime=e,this._transitionTo(gf),this._fireEvent("onEnterComplete"),this.opacity=this.elementConfig.opacity,this.scale=this.elementConfig.scale),i>=a&&this.state===pf&&(this._transitionTo(ff),this._fireEvent("onExitStart"))}_applyEnterAnimation(e){const{enter:t}=this.config,i=this.elementConfig.opacity,a=this.elementConfig.scale;switch(this.fadeProgress=e,t.type){case"fade":this.opacity=e*i,this.scale=a;break;case"flash":if(e<.5){const t=2*e;this.opacity=t*i*2,this.emissive=1+1.5*t}else{const t=2*(e-.5);this.opacity=i*(2-t),this.emissive=2.5-1.5*t}this.scale=a;break;case"grow":{const n=t.scale,s=n[0]*a,r=n[1]*a;this.scale=s+e*(r-s),this.opacity=i;break}case"pop":{const{overshoot:n}=t;if(e<.7){const t=e/.7;this.scale=t*a*n}else{const t=(e-.7)/.3,i=this.config.enter.easing(t);this.scale=a*(n-(n-1)*i)}this.opacity=i;break}default:this.opacity=i,this.scale=a}}_updateHolding(e,t,i,a){this.holdTime+=t,this._applyHoldAnimations(e,t),i>=a&&(this.exitStartTime=e,this._transitionTo(ff),this._fireEvent("onExitStart"))}_applyHoldAnimations(e,t){const{hold:i}=this.config,a=this.elementConfig.opacity,n=this.elementConfig.scale;this.fadeProgress=1;let s=1,r=1;if(i.pulse){const t=i.pulse,a=(e+this.pulsePhase)*t.frequency*Math.PI*2;r*=1+Math.sin(a)*t.amplitude}if(i.flicker){const a=i.flicker;switch(a.pattern){case"sine":{const t=e*a.rate*Math.PI*2;this.flickerValue=1+Math.sin(t)*a.intensity;break}case"square":{const t=e*a.rate%1;this.flickerValue=t<.5?1+a.intensity:1-a.intensity;break}default:Math.random()<a.rate*t&&(this.flickerValue=1+(2*Math.random()-1)*a.intensity)}s*=this.flickerValue}if(i.emissive){const t=i.emissive;switch(t.pattern){case"sine":{const i=e*t.frequency*Math.PI*2,a=(Math.sin(i)+1)/2;this.emissive=t.min+a*(t.max-t.min);break}case"sawtooth":{const i=e*t.frequency%1;this.emissive=t.min+i*(t.max-t.min);break}case"pulse":{const i=e*t.frequency%1;this.emissive=i<t.dutyCycle?t.max:t.min;break}default:this.emissive=(t.min+t.max)/2}}if(i.drift){const e=i.drift,a=e.gestureDuration/1e3,n=e.distance/a*t,s=e.noise>0?(Math.random()-.5)*e.noise*n:0,r=e.noise>0?(Math.random()-.5)*e.noise*n:0,o=e.noise>0?(Math.random()-.5)*e.noise*n:0;switch(e.direction){case"outward":this.driftOffset.x+=(this.driftOffset.x||.001)>0?n+s:-n+s,this.driftOffset.y+=(this.driftOffset.y||.001)>0?n+r:-n+r,this.driftOffset.z+=(this.driftOffset.z||.001)>0?n+o:-n+o;break;case"outward-flat":this.driftOffset.x+=(this.driftOffset.x||.001)>0?n+s:-n+s,this.driftOffset.z+=(this.driftOffset.z||.001)>0?n+o:-n+o;break;case"inward":this.driftOffset.x-=(this.driftOffset.x||.001)>0?n:-n,this.driftOffset.y-=(this.driftOffset.y||.001)>0?n:-n,this.driftOffset.z-=(this.driftOffset.z||.001)>0?n:-n;break;case"up":this.driftOffset.y+=n+r;break;case"down":this.driftOffset.y-=n+r;break;case"tangent":this.driftOffset.x+=n+s,this.driftOffset.z+=o;break;case"random":this.driftOffset.x+=(Math.random()-.5)*n*2,this.driftOffset.y+=(Math.random()-.5)*n*2,this.driftOffset.z+=(Math.random()-.5)*n*2}const l=Math.sqrt(this.driftOffset.x**2+this.driftOffset.y**2+this.driftOffset.z**2);if(l>e.distance)if(e.bounce){const t=e.distance/l;this.driftOffset.x*=-t,this.driftOffset.y*=-t,this.driftOffset.z*=-t}else{const t=e.distance/l;this.driftOffset.x*=t,this.driftOffset.y*=t,this.driftOffset.z*=t}}this._applyRotation(e,t),this.opacity=a*s,this.scale=n*r}_applyRotation(e,t){const{hold:i}=this.config;if(!i.rotate)return;const a=i.rotate,n=a.elements[this.index%a.elements.length],{axis:s,rotations:r,phase:o,oscillate:l,range:c}=n,h=(o||0)*Math.PI/180;if(l){const t=e*(n.speed||a.speed||.1)*2,i=Math.sin(t);this.rotationOffset.x=s[0]*i*c,this.rotationOffset.y=s[1]*i*c,this.rotationOffset.z=s[2]*i*c}else if(null!=r){const e=this.gestureProgress*r*Math.PI*2+h;this.rotationOffset.x=s[0]*e,this.rotationOffset.y=s[1]*e,this.rotationOffset.z=s[2]*e}else{const e=(n.speed||a.speed||.1)*t;this.rotationOffset.x+=s[0]*e,this.rotationOffset.y+=s[1]*e,this.rotationOffset.z+=s[2]*e}}_updateExiting(e,t){const{exit:i}=this.config,a="progress"===this.config.timing.mode?i.duration*this.config.gestureDuration/1e3:i.durationMs/1e3,n=e-this.exitStartTime;this.progress=Math.min(n/a,1);const s=i.easing(this.progress);this._applyExitAnimation(s),this._applyRotation(e,t),this.progress>=1&&(this._transitionTo(yf),this._fireEvent("onExitComplete"))}_applyExitAnimation(e){const{exit:t}=this.config,i=this.elementConfig.opacity,a=this.elementConfig.scale;switch(this.fadeProgress=1-e,t.type){case"fade":this.opacity=(1-e)*i;break;case"flash":if(e<.3){const t=e/.3;this.opacity=i*(1+t),this.emissive=1+2*t}else{const t=(e-.3)/.7;this.opacity=2*i*(1-t),this.emissive=3*(1-t)}break;case"shrink":{const n=t.scale,s=n[0]*a,r=n[1]*a;this.scale=s+e*(r-s),this.opacity=i;break}case"pop":if(e<.2)this.scale=a*(1+.5*e);else{const t=(e-.2)/.8;this.scale=1.1*a*(1-t)}this.opacity=i*(1-.5*e);break;default:e>=1&&(this.opacity=0,this.scale=0)}}_handleDead(){const{lifecycle:e}=this.config;if(e.respawn){const{maxRespawns:t}=e;if(-1===t||this.respawnCount<t){this.respawnCount++,this._fireEvent("onRespawn",this.respawnCount),this.state=mf,this.progress=0;const t=e.respawnDelay>0?e.respawnDelay:e.respawnDelayMs/1e3;return this.birthTime=this.stateStartTime+t,!0}}return this.isDead=!0,!1}_transitionTo(e,t=null){this.state=e,e===pf&&null!==t?this.stateStartTime=t:e===ff&&this.exitStartTime>0&&(this.stateStartTime=this.exitStartTime),this.progress=0}_fireEvent(e,...t){const i=this.config.events[e];if("function"==typeof i)try{i(this.getElementInfo(),this.index,...t)}catch(t){console.warn(`[AnimationState] Error in ${e} callback:`,t)}}getElementInfo(){return{state:this.state,progress:this.progress,opacity:this.opacity,scale:this.scale,emissive:this.emissive,driftOffset:{...this.driftOffset},rotationOffset:{...this.rotationOffset},respawnCount:this.respawnCount,config:this.config}}triggerExit(){this.state!==ff&&this.state!==yf&&(this._transitionTo(ff),this._fireEvent("onExitStart"))}kill(){this.isDead=!0,this.state=yf,this.opacity=0,this.scale=0}}const bf={type:"fade",duration:.05,durationMs:50,easing:"easeOut",scale:[0,1],overshoot:1.2},wf={type:"fade",duration:.15,durationMs:150,easing:"easeIn",scale:[1,0]},Mf={base:1,variance:0},Sf={base:1,variance:0},xf={axis:"y",speed:.1,rotations:null,phase:0,oscillate:!1,range:Math.PI/4,easing:"linear"},Cf="bell";class Pf{constructor(e={},t=1e3){this.gestureDuration=t,this.raw=e,this.timing=this._parseTiming(e),this.enter=this._parseEnter(e.enter),this.exit=this._parseExit(e.exit),this.hold=this._parseHold(e),this.variance=this._parseVariance(e),this.appearance=this._parseAppearance(e),this.rendering=this._parseRendering(e),this.lifecycle=this._parseLifecycle(e),this.events=this._parseEvents(e),this.intensityScaling=this._parseIntensityScaling(e.intensityScaling),this.procedural=this._parseProcedural(e),this.parameterAnimation=this._parseParameterAnimation(e.parameterAnimation||e.temperature),this.modelOverrides=e.modelOverrides||null,this._intensity=1}getConfigForModel(e){return this.modelOverrides&&this.modelOverrides[e]?this.modelOverrides[e]:null}_parseIntensityScaling(e={}){return{scale:e.scale??1,count:e.count??1,lifetime:e.lifetime??1,enterDuration:e.enterDuration??1,exitDuration:e.exitDuration??1,pulseAmplitude:e.pulseAmplitude??1,flickerIntensity:e.flickerIntensity??1,emissiveMax:e.emissiveMax??1,driftSpeed:e.driftSpeed??1,rotateSpeed:e.rotateSpeed??1}}setIntensity(e){this._intensity=Math.max(0,Math.min(1,e))}getIntensity(){return this._intensity}getScaledValue(e,t){return t*(1+((this.intensityScaling[e]??1)-1)*this._intensity)}_parseTiming(e){return{appearAt:e.appearAt??0,disappearAt:e.disappearAt??1,delayMs:e.delayMs??0,lifetimeMs:e.lifetimeMs??null,stagger:e.stagger??0,staggerMs:e.staggerMs??0,appearOnBeat:e.appearOnBeat??null,mode:this._determineTimingMode(e)}}_determineTimingMode(e){return void 0!==e.appearAt||void 0!==e.disappearAt?"progress":void 0!==e.delayMs||void 0!==e.lifetimeMs?"ms":"progress"}_parseEnter(e={}){const t=bf;return{type:e.type??t.type,duration:e.duration??t.duration,durationMs:e.durationMs??t.durationMs,easing:km(e.easing??t.easing),easingName:e.easing??t.easing,scale:e.scale??t.scale,overshoot:e.overshoot??t.overshoot}}_parseExit(e={}){const t=wf;return{type:e.type??t.type,duration:e.duration??t.duration,durationMs:e.durationMs??t.durationMs,easing:km(e.easing??t.easing),easingName:e.easing??t.easing,scale:e.scale??t.scale}}_parseHold(e){return{pulse:e.pulse?this._parsePulse(e.pulse):null,flicker:e.flicker?this._parseFlicker(e.flicker):null,drift:e.drift?this._parseDrift(e.drift):null,rotate:e.rotate?this._parseRotate(e.rotate):null,emissive:e.emissive?this._parseEmissive(e.emissive):null}}_parsePulse(e){return{amplitude:e.amplitude??.1,frequency:e.frequency??2,easing:km(e.easing??"easeInOut"),sync:e.sync??"global"}}_parseFlicker(e){return{intensity:e.intensity??.2,rate:e.rate??10,pattern:e.pattern??"random",seed:e.seed??null}}_parseDrift(e){return{direction:e.direction??"outward",distance:e.distance??.1,speed:e.speed??.02,maxDistance:e.maxDistance??1,gestureDuration:this.gestureDuration,bounce:e.bounce??false,noise:e.noise??0}}_parseRotate(e){if(Array.isArray(e)){const t=e.map(e=>this._parseRotateElement(e));return{isPerElement:!0,elements:t,oscillate:t[0]?.oscillate??xf.oscillate,range:t[0]?.range??xf.range,easing:t[0]?.easing??km(xf.easing)}}const t=this._parseRotateElement(e);return{isPerElement:!1,elements:[t],...t}}_parseRotateElement(e){let t=e.axis??xf.axis;return"string"==typeof t&&(t="x"===t?[1,0,0]:"y"===t?[0,1,0]:"z"===t?[0,0,1]:[0,1,0]),{axis:t,speed:e.speed??xf.speed,rotations:e.rotations??xf.rotations,phase:e.phase??xf.phase,oscillate:e.oscillate??xf.oscillate,range:e.range??xf.range,easing:km(e.easing??xf.easing)}}_parseEmissive(e){return{min:e.min??.5,max:e.max??1.5,frequency:e.frequency??1,pattern:e.pattern??"sine",dutyCycle:e.dutyCycle??.5}}_parseVariance(e){return{scale:e.scaleVariance??0,lifetime:e.lifetimeVariance??0,color:e.colorVariance??0,delay:e.delayVariance??0}}_parseAppearance(e){return{color:e.color?{tint:e.color.tint??null,multiply:e.color.multiply??!0,variance:e.color.variance??0}:null,opacity:e.opacity?{base:e.opacity.base??Mf.base,variance:e.opacity.variance??Mf.variance}:{...Mf},scale:e.scale?{base:e.scale.base??Sf.base,variance:e.scale.variance??Sf.variance}:{...Sf}}}_parseRendering(e){return{renderOrder:e.renderOrder??0,depthTest:e.depthTest??true,depthWrite:e.depthWrite??false,blending:e.blending??"normal",trail:e.trail?this._parseTrail(e.trail):null}}_parseTrail(e){return{count:e.count??3,fadeRate:e.fadeRate??.3,spacing:e.spacing??.05,inheritRotation:e.inheritRotation??!0}}_parseLifecycle(e){return{respawn:e.respawn??false,respawnDelay:e.respawnDelay??0,respawnDelayMs:e.respawnDelayMs??0,maxRespawns:e.maxRespawns??-1}}_parseEvents(e){return{onSpawn:e.onSpawn??null,onEnterStart:e.onEnterStart??null,onEnterComplete:e.onEnterComplete??null,onExitStart:e.onExitStart??null,onExitComplete:e.onExitComplete??null,onRespawn:e.onRespawn??null}}_parseProcedural(e){if(!e.procedural&&void 0===e.scaleSmoothing&&void 0===e.geometryStability)return null;const t=e.procedural||{};return{geometryStability:t.geometryStability??e.geometryStability??true,scaleSmoothing:t.scaleSmoothing??e.scaleSmoothing??0,shaderBindings:t.shaderBindings??null}}_parseParameterAnimation(e){if(!e)return null;if(void 0!==e.start||void 0!==e.peak)return{primary:{start:e.start??0,peak:e.peak??1,end:e.end??0,curve:e.curve??Cf}};const t={};for(const[i,a]of Object.entries(e))"object"==typeof a&&null!==a&&(t[i]={start:a.start??0,peak:a.peak??1,end:a.end??0,curve:a.curve??Cf});return Object.keys(t).length>0?t:null}progressToMs(e){return e*this.gestureDuration}msToProgress(e){return e/this.gestureDuration}getAppearTime(e="auto"){return"ms"===("auto"===e?this.timing.mode:e)?this.timing.delayMs>0?this.timing.delayMs:this.progressToMs(this.timing.appearAt):this.timing.appearAt}getDisappearTime(e="auto"){const t="auto"===e?this.timing.mode:e;return"ms"===t&&null!==this.timing.lifetimeMs?this.timing.delayMs+this.timing.lifetimeMs:"ms"===t?this.progressToMs(this.timing.disappearAt):this.timing.disappearAt}getStaggerOffset(e,t="auto"){return"ms"===("auto"===t?this.timing.mode:t)?this.timing.staggerMs>0?e*this.timing.staggerMs:e*this.progressToMs(this.timing.stagger):e*this.timing.stagger}applyVariance(e,t){if(0===t)return e;const i=e*t;return e+(2*Math.random()-1)*i}createElementConfig(e,t=null){return{index:e,appearOffset:this.getStaggerOffset(e),scale:this.applyVariance(this.appearance.scale.base,this.variance.scale),opacity:this.applyVariance(this.appearance.opacity.base,this.appearance.opacity.variance),lifetimeMultiplier:1+(2*Math.random()-1)*this.variance.lifetime,delayOffset:this.applyVariance(0,this.variance.delay)}}mergeWithElement(e){if(!e)return this;const t={...this.raw,...e,enter:{...this.raw.enter,...e.enter},exit:{...this.raw.exit,...e.exit}};return new Pf(t,this.gestureDuration)}}function kf(e,t,i){const a=Math.max(0,Math.min(1,(i-e)/(t-e)));return a*a*(3-2*a)}function Df(e,t){if(!e)return null;const i=Object.keys(e);return 0===i.length?null:function(e,t){if(!e)return 0;const{start:i,peak:a,end:n,curve:s}=e;switch(s){case"bell":default:return t<=.5?i+(a-i)*kf(0,.5,t):a+(n-a)*kf(.5,1,t);case"spike":return t<=.25?i+(a-i)*kf(0,.25,t):a+(n-a)*kf(.25,1,t);case"sustained":return t<=.15?i+(a-i)*kf(0,.15,t):t>=.85?a+(n-a)*kf(.85,1,t):a;case"fadeOut":return a+(n-a)*kf(0,1,t);case"linear":return t<=.5?i+2*t*(a-i):a+2*(t-.5)*(n-a)}}(e[i[0]],t)}function Af(e){return e?{type:e.type||"stack",count:e.count||1,spacing:e.spacing||.15,arcOffset:(e.arcOffset||60)*Math.PI/180,phaseOffset:e.phaseOffset||0,strands:e.strands||1,centered:e.centered||!1,scales:e.scales||null,positions:e.positions||null,radius:e.radius||.4,meshRotationOffset:e.meshRotationOffset?e.meshRotationOffset*Math.PI/180:0,zOffset:e.zOffset||0}:null}function _f(e){return{horizontal:"flat",upright:"vertical",billboard:"camera"}[e]||e||"flat"}const Tf={linear:e=>e,splash:e=>1-Math.pow(1-e,3),surge:e=>e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2,burst:e=>1-Math.pow(1-e,4),settle:e=>e<.3?e*e*3.33:e<.7?.3+1.75*(e-.3):.7+.3*(1-Math.pow(1-(e-.7)/.3,2))};function If(e,t=0){const i=e.landmarkY+e.offset.y;let a=i;return e.bob&&(a=i+Math.sin(t*e.bob.frequency*Math.PI*2)*e.bob.amplitude),{x:e.offset.x,y:a,z:e.offset.z,baseY:i}}function Of(e){switch(e){case"flat":return{x:Math.PI/2,y:0,z:0};case"vertical":case"camera":default:return{x:0,y:0,z:0};case"radial":return{x:Math.PI/4,y:0,z:0}}}function Rf(e){return e?{type:e.type||"ring",count:e.count||4,pairSpacing:(e.pairSpacing||180)*Math.PI/180,startAngle:(e.startAngle||0)*Math.PI/180}:null}function Ef(e,t,i,a=1,n=null){const{angle:s}=t,r=n?n(i):i,o=(e.radius+(e.endRadius-e.radius)*r)*a,l=e.height*a,c=l+(e.endHeight*a-l)*r,h=s+i*e.speed*Math.PI*2,u=Math.cos(h)*o,d=Math.sin(h)*o;return{x:u,y:c+(t.heightOffset||0),z:d,angle:h,scale:e.startScale+(e.endScale-e.startScale)*r}}function Bf(e,t,i){const a=km(e.easing)(i),n=e.startRadius+(e.endRadius-e.startRadius)*a;return{x:e.offset.x+t.x*n,y:e.landmarkY+e.offset.y+t.y*n,z:e.offset.z+t.z*n,scale:e.startScale+(e.endScale-e.startScale)*a}}function Ff(e,t,i){const a=function(e,t,i="xz"){if("xz"===i){const i=e/t*Math.PI*2;return{x:Math.cos(i),y:0,z:Math.sin(i)}}{const i=Math.acos(1-2*(e+.5)/t),a=Math.PI*(1+Math.sqrt(5))*e;return{x:Math.sin(i)*Math.cos(a),y:Math.cos(i),z:Math.sin(i)*Math.sin(a)}}}(t,e.count,e.plane),n=Bf(e,a,0);return{position:{x:n.x*i,y:n.y,z:n.z*i},rotation:{x:0,y:0,z:0,w:1},scaleMultiplier:n.scale,modeData:{radialBurst:{config:e,direction:a}}}}function zf(e,t,i){const{config:a,direction:n}=e.radialBurst,s=Bf(a,n,t);return{position:{x:s.x*i,y:s.y,z:s.z*i},scaleMultiplier:s.scale}}const Lf=1.5,Gf={position:new e.Vector3,quaternion:new e.Quaternion,quaternion2:new e.Quaternion,scale:new e.Vector3(1,1,1),euler:new e.Euler,direction:new e.Vector3,axis:new e.Vector3,up:new e.Vector3(0,1,0)};class Vf{constructor(t={}){const{scene:i,coreMesh:a=null,camera:n=null,assetsBasePath:s="",renderer:r=null}=t;if(!i)throw new Error("[ElementInstancedSpawner] Scene is required");this.scene=i,this.coreMesh=a,this.camera=n,this.assetsBasePath=s,this._renderer=r,this.container=new e.Group,this.container.name="ElementInstancedSpawner",this.scene.add(this.container),this.spatialRef=new af,a&&this.spatialRef.initialize(a),this.pools=new Map,this.geometryCache=new Map,this.loader=new vp,this.mergedGeometries=new Map,this.materials=new Map,this.activeElements=new Map,this.time=0,this._nextId=0,this._initialized=new Set,this._initializing=new Map,this._poolLastUsed=new Map,this._poolCleanupInterval=3e4,this._lastCleanupCheck=0,this._parameterAnimations=new Map}get mascotRadius(){return this.spatialRef.radius||1}initialize(e,t){this.coreMesh=e,this.camera=t,e&&this.spatialRef.initialize(e)}async preloadModels(e){pg.get(e)&&await this.initializePool(e)}hasElements(e){for(const t of this.activeElements.values())if(t.type===e)return!0;return!1}async initializePool(e){if(this._initialized.has(e))return this.pools.get(e);if(this._initializing.has(e))return this._initializing.get(e);const t=this._doInitializePool(e);this._initializing.set(e,t);try{const i=await t;return this._initialized.add(e),i}finally{this._initializing.delete(e)}}async _doInitializePool(e){const t=pg.get(e);if(!t)return console.warn(`[ElementInstancedSpawner] Unknown element type: ${e}`),null;const i=[];for(const e of t.models){const a=`${this.assetsBasePath}/${t.basePath}${e}`,n=await this._loadGeometry(a);n&&i.push({geometry:n,name:e.replace(".glb","")})}if(0===i.length)return console.error(`[ElementInstancedSpawner] No models loaded for ${e}`),null;const a=new dg;for(const{geometry:e,name:t}of i)a.addGeometry(e,t);const{geometry:n,modelMap:s}=a.build();a.dispose(),this.mergedGeometries.set(e,{geometry:n,modelMap:s});const r=t.createMaterial();this.materials.set(e,r),r.userData._originalDepthWrite=r.depthWrite;const o=new ug(n,r,16);if(this.pools.set(e,o),this.container.add(o.mesh),this._renderer&&r.userData.needsRefraction&&this._renderer.addRefractionMesh(o.mesh),this._distortionManager&&t.distortion&&!this._distortionManager.hasElement(e)){const i=t.distortion;this._distortionManager.registerElement(e,{geometry:i.geometry(),material:i.material(),transform:i.transform,billboard:i.billboard,strength:i.strength})}return o}async _loadGeometry(e){if(this.geometryCache.has(e))return this.geometryCache.get(e);try{const t=await new Promise((t,i)=>{this.loader.load(e,t,void 0,i)});let i=null;return t.scene.traverse(e=>{!i&&e.isMesh&&({geometry:i}=e)}),i?(this.geometryCache.set(e,i),i):(console.warn(`[ElementInstancedSpawner] No mesh found in ${e}`),null)}catch(t){return console.error(`[ElementInstancedSpawner] Failed to load ${e}:`,t),null}}async spawn(e,t={}){const{count:i=8,mode:a="orbit",intensity:n=1,models:s=null,camera:r=null,animation:o=null,gestureDuration:l=1e3}=t;if(Array.isArray(a)){const t=await this.initializePool(e);if(!t)return[];this._poolLastUsed.set(e,performance.now()),this.despawn(e);const i=pg.get(e),s=this.materials.get(e);let o,c;i?.resetCutout&&s&&i.resetCutout(s),i?.resetGrain&&s&&i.resetGrain(s),i?.resetFlash&&s&&i.resetFlash(s),i?.resetShaderAnimation&&s&&i.resetShaderAnimation(s),this._particleAtmospherics&&this._particleAtmospherics.forceStopGesture(e),this._parameterAnimations.delete(e);for(const e of a){const t=e.animation?.renderOrder;void 0!==t&&(void 0===o||t<o)&&(o=t),void 0!==e.animation?.depthWrite&&(c=e.animation.depthWrite)}void 0!==o&&(t.mesh.renderOrder=o),s&&(void 0!==c?s.depthWrite=c:void 0!==s.userData._originalDepthWrite&&(s.depthWrite=s.userData._originalDepthWrite));const h=[];for(let t=0;t<a.length;t++){const i=a[t],s=await this._spawnLayer(e,i,{layerIndex:t,camera:r,gestureDuration:l,intensity:n});h.push(...s)}return h}const c=o?new Pf(o,l):null,h=await this.initializePool(e);if(!h)return[];this._poolLastUsed.set(e,performance.now()),void 0!==c?.rendering?.renderOrder&&(h.mesh.renderOrder=c.rendering.renderOrder),this.despawn(e);const u=pg.get(e),d=this.materials.get(e);if(d&&(o&&void 0!==o.depthWrite?d.depthWrite=o.depthWrite:void 0!==d.userData._originalDepthWrite&&(d.depthWrite=d.userData._originalDepthWrite)),u?.resetCutout&&d&&u.resetCutout(d),u?.resetGrain&&d&&u.resetGrain(d),u?.resetFlash&&d&&u.resetFlash(d),u?.resetShaderAnimation&&d&&u.resetShaderAnimation(d),this._particleAtmospherics&&this._particleAtmospherics.forceStopGesture(e),this._parameterAnimations.delete(e),!this.mergedGeometries.get(e))return[];const m="object"==typeof a?a.type||"surface":a;return"axis-travel"===m?this._spawnAxisTravel(e,a,s,c,r):"anchor"===m?this._spawnAnchor(e,a,s,c,r):"radial-burst"===m?this._spawnRadialBurst(e,a,s,c):"orbit"===m?this._spawnOrbit(e,a,s,c,r):"surface"===m?this._spawnSurface(e,a,i,s,c,r):(console.warn(`[ElementInstancedSpawner] Unknown spawn mode: ${m}, falling back to orbit`),this._spawnOrbitFallback(e,i,s,c,r))}_spawnOrbitFallback(e,t,i,a,n){const s=this._getSpawnContext(e);if(!s)return[];const{pool:r,merged:o,config:l}=s,c=[],h=Math.min(t,r.availableSlots),u=i||Array.from(o.modelMap.keys());for(let t=0;t<h;t++){const i=u[Math.floor(Math.random()*u.length)],n=this._resolveModelIndex(o,i)??0,s=l?.scaleMultiplier||Lf,d=cf(i,this.mascotRadius,s);Gf.scale.setScalar(d);const m=this._generateSpawnPosition("orbit",t,h),p=this._generateSpawnRotation("orbit",m),g=`${e}_${this._nextId++}`;if(r.spawn(g,m,p,Gf.scale,n)){const s=this._initAnimState(r,g,a,t);s&&r.updateInstanceTransform(g,m,p,d*s.scale),this.activeElements.set(g,{type:e,modelName:i,modelIndex:n,spawnTime:this.time,basePosition:m.clone(),position:m.clone(),rotation:p.clone(),baseScale:d,scale:d,animState:s}),c.push(g)}}return c}_generateSpawnPosition(e,t,i){const a=Gf.position,n=1.5*this.mascotRadius;switch(e){case"orbit":{const e=t/i*Math.PI*2,s=(Math.random()-.5)*this.mascotRadius;a.set(Math.cos(e)*n,s,Math.sin(e)*n);break}case"crown":{const e=t/i*Math.PI*2;a.set(Math.cos(e)*n*.6,.8*this.mascotRadius,Math.sin(e)*n*.6);break}case"scattered":case"scatter":{const e=Math.random()*Math.PI*2,t=Math.acos(2*Math.random()-1);a.set(Math.sin(t)*Math.cos(e)*n,Math.sin(t)*Math.sin(e)*n,Math.cos(t)*n);break}default:return this._generateSpawnPosition("orbit",t,i)}return a.clone()}_generateSpawnRotation(e,t){const i=Gf.quaternion;return Gf.euler.set(Math.random()*Math.PI*2,Math.random()*Math.PI*2,Math.random()*Math.PI*2),i.setFromEuler(Gf.euler),i.clone()}_parseAxisTravelConfig(e){return function(e,t){const i=e.axisTravel||{},a=e.formation||null,n=i.startOffset??0,s=i.endOffset??0,r=i.orientation??i.ringOrientation,o=i.speedCurve||"linear",l=Tf[o]||Tf.linear;return{axis:i.axis||"y",startPos:t(i.start??"bottom")+n,endPos:t(i.end??"top")+s,easing:km(i.easing||"easeInOut"),speedCurve:l,startScale:i.startScale??1,endScale:i.endScale??1,startDiameter:i.startDiameter??1,endDiameter:i.endDiameter??1,reverseAt:i.reverseAt??null,orientation:_f(r),formation:Af(a),count:e.count||1,models:e.models||[],scale:e.scale??1}}(e,e=>this.spatialRef.resolveLandmark(e))}_expandFormation(e){return function(e){const{formation:t}=e;if(!t)return[{index:0,positionOffset:{x:0,y:0,z:0},rotationOffset:0,meshRotationOffset:0,progressOffset:0,scaleMultiplier:1}];const i=[],a=(t.count-1)*t.spacing,n=t.centered?-a/2:0;for(let e=0;e<t.count;e++){const a={index:e,positionOffset:{x:0,y:0,z:0},rotationOffset:0,meshRotationOffset:e*(t.meshRotationOffset||0),progressOffset:e*t.phaseOffset,scaleMultiplier:t.scales?.[e]??1};switch(t.type){case"stack":default:a.positionOffset={x:0,y:e*t.spacing+n,z:0};break;case"spiral":{const i=t.strands||1,s=e%i,r=Math.floor(e/i);a.positionOffset={x:0,y:r*t.spacing+n,z:0};const o=r*t.arcOffset,l=s/i*Math.PI*2;a.rotationOffset=o+l;break}case"wave":a.positionOffset={x:0,y:Math.sin(e/t.count*Math.PI)*t.spacing+n,z:0},a.progressOffset=e*(t.phaseOffset||.08);break;case"mandala":{const i=t.zOffset||0;if(0===e)a.positionOffset={x:0,y:0,z:i};else{const n=(e-1)/(t.count-1)*Math.PI*2,s=t.radius||.4;a.positionOffset={x:Math.sin(n)*s,y:Math.cos(n)*s,z:i}}a.rotationOffset=e*t.arcOffset;break}case"positioned":if(t.positions&&t.positions[e]){const i=t.positions[e];a.positionOffset={x:i.x||0,y:i.y||0,z:i.z||0}}a.rotationOffset=e*t.arcOffset}i.push(a)}return i}(e)}_calculateAxisTravelPosition(e,t,i){const a=function(e,t,i,a=1){let n=i;t?.progressOffset&&(n=Math.max(0,Math.min(1,n-t.progressOffset)));let s=n;null!==e.reverseAt&&n>e.reverseAt&&(s=1-(n-e.reverseAt)/(1-e.reverseAt)),e.speedCurve&&(s=e.speedCurve(s));const r=e.easing(s);let o=e.startPos+(e.endPos-e.startPos)*r;const l=e.startScale+(e.endScale-e.startScale)*r,c=e.startDiameter+(e.endDiameter-e.startDiameter)*r;"vertical"===e.orientation&&"y"===e.axis&&(o+=c*a*l*.25);const h=t?.positionOffset||{x:0,y:0,z:0},u="number"==typeof h?{x:0,y:h*a,z:0}:{x:(h.x||0)*a,y:(h.y||0)*a,z:(h.z||0)*a};return{axisPos:o,axis:e.axis,positionOffset:u,scale:l,diameter:c,rotationOffset:t?.rotationOffset||0,meshRotationOffset:t?.meshRotationOffset||0,scaleMultiplier:t?.scaleMultiplier??1}}(e,t,i,this.mascotRadius),n=a.positionOffset,s=Gf.position.set(0,0,0);switch(a.axis){case"y":s.y=a.axisPos;break;case"x":s.x=a.axisPos;break;case"z":s.z=a.axisPos}return s.x+=n.x||0,s.y+=n.y||0,s.z+=n.z||0,{position:s,scale:a.scale,diameter:a.diameter,rotationOffset:a.rotationOffset,scaleMultiplier:a.scaleMultiplier}}_getSpawnContext(e){const t=this.pools.get(e),i=this.mergedGeometries.get(e),a=pg.get(e);return t&&i?{pool:t,merged:i,config:a}:(console.warn(`[ElementInstancedSpawner] Pool or merged geometry not ready for ${e}`),null)}_resolveModelIndex(e,t){const i=e.modelMap.get(t);return void 0===i&&console.warn(`[ElementInstancedSpawner] Model ${t} not found in merged geometry`),i}_initAnimState(e,t,i,a){if(!i)return e.updateInstanceOpacity(t,1),null;const n=new vf(i,a);return n.initialize(this.time),e.updateInstanceOpacity(t,n.opacity),n}_applyShaderAnimationOverrides(e,t,i,a,n=null){const s=this.materials.get(e);if(s){if(i&&a?.setShaderAnimation)for(const e of t){const t=i[e];if(t?.shaderAnimation){a.setShaderAnimation(s,t.shaderAnimation);break}}if(n?.gestureGlow&&a?.setGestureGlow&&a.setGestureGlow(s,n.gestureGlow),a?.setCutout&&void 0!==n?.cutout&&a.setCutout(s,n.cutout),a?.setGrain&&void 0!==n?.grain&&a.setGrain(s,n.grain),a?.setFlash&&void 0!==n?.flash&&a.setFlash(s,n.flash),n?.parameterAnimation){const t=new Pf({parameterAnimation:n.parameterAnimation});this._parameterAnimations.set(e,t.parameterAnimation)}this._particleAtmospherics&&n?.atmospherics&&this._particleAtmospherics.startGesture(e,n.atmospherics)}}_spawnLayer(e,t,i){const{layerIndex:a,camera:n,gestureDuration:s}=i,r=t.type||"surface",o=t.models||null,l=t.animation||{},c=new Pf(l,s),h=`layer${a}`;switch(r){case"axis-travel":return this._spawnAxisTravel(e,t,o,c,n,h);case"anchor":return this._spawnAnchor(e,t,o,c,n,h);case"radial-burst":return this._spawnRadialBurst(e,t,o,c,h);case"orbit":return this._spawnOrbit(e,t,o,c,n,h);case"surface":return this._spawnSurface(e,t,t.count||5,o,c,n,h);default:return console.warn(`[ElementInstancedSpawner] Unknown layer type: ${r}, skipping`),[]}}_spawnAxisTravel(e,t,i,a,n,s=null){const r=this._getSpawnContext(e);if(!r)return[];const{pool:o,merged:l,config:c}=r,h=this._parseAxisTravelConfig(t),u=this._expandFormation(h),d=t.animation||{},m=d.modelOverrides||{};this._applyShaderAnimationOverrides(e,h.models,m,c,d);const p=[],g=h.models.length>0?h.models:i||Array.from(l.modelMap.keys());for(let t=0;t<u.length;t++){const i=u[t],n=g[t%g.length],s=this._resolveModelIndex(l,n);if(void 0===s)continue;const r=this._calculateAxisTravelPosition(h,i,0),{position:f}=r,y=h.scale||c?.scaleMultiplier||Lf,v=cf(n,this.mascotRadius,y),b=r.scaleMultiplier??1,w=v*r.scale*b;Gf.scale.set(w*r.diameter,w*r.diameter,w);const M=h.orientation,S=lf(n),x=M||S.mode||"outward";let C,P=!1;switch(x){case"flat":C=Gf.quaternion.setFromAxisAngle(Gf.axis.set(1,0,0),Math.PI/2),P=!0;break;case"vertical":case"camera":C=Gf.quaternion.identity(),P=!0;break;case"radial":C=Gf.quaternion.setFromAxisAngle(Gf.axis.set(1,0,0),Math.PI/4),P=!0;break;default:C=this._generateSpawnRotation("orbit",f)}i.rotationOffset&&(Gf.quaternion2.setFromAxisAngle(Gf.up,i.rotationOffset),C=C.clone().premultiply(Gf.quaternion2)),i.meshRotationOffset&&(Gf.quaternion2.setFromAxisAngle(Gf.up,i.meshRotationOffset),C=C.clone().premultiply(Gf.quaternion2));const k=C.clone(),D=`${e}_${this._nextId++}`;let A=i.rotationOffset||0;const _=d.stagger||0,T=m[n]?.shaderAnimation;if(_>0&&T?.arcSpeed&&(A=-_*t*T.arcSpeed*Math.PI*2),o.spawn(D,f,C,Gf.scale,s,A)){const l=this._initAnimState(o,D,a,t);l&&o.updateInstanceTransform(D,f,C,w*l.scale),this.activeElements.set(D,{type:e,modelName:n,modelIndex:s,spawnTime:this.time,basePosition:f.clone(),position:f.clone(),rotation:C.clone(),baseScale:v,scale:w,animState:l,worldSpaceOrientation:P,baseWorldRotation:P?k:null,cameraOrientation:"camera"===x,axisTravel:{config:h,formationData:i,initialResult:r}}),p.push(D)}}return p}_spawnAnchor(e,t,i,a,n,s=null){const r=this._getSpawnContext(e);if(!r)return[];const{pool:o,merged:l,config:c}=r,h=function(e,t){const i=e.anchor||{};return{landmark:i.landmark||"head",landmarkY:t(i.landmark||"head"),offset:{x:i.offset?.x||0,y:i.offset?.y||0,z:i.offset?.z||0},orientation:_f(i.orientation)||"flat",bob:i.bob?{amplitude:i.bob.amplitude||.02,frequency:i.bob.frequency||.5}:null,count:e.count||1,models:e.models||[],scale:e.scale??1,startScale:i.startScale??1,endScale:i.endScale??1,scaleEasing:i.scaleEasing||"easeOutExpo"}}(t,e=>this.spatialRef.resolveLandmark(e)),u=t.animation||{},d=u.modelOverrides||{};this._applyShaderAnimationOverrides(e,h.models,d,c,u);const m=[],p=h.models.length>0?h.models:i||Array.from(l.modelMap.keys());for(let t=0;t<h.count;t++){const i=p[t%p.length],n=this._resolveModelIndex(l,i);if(void 0===n)continue;const s=If(h,0),r=Gf.position.set(s.x,s.y,s.z).clone(),u=h.scale||c?.scaleMultiplier||Lf,d=cf(i,this.mascotRadius,u);let g;if(Gf.scale.setScalar(d),"camera"===h.orientation&&this.camera)g=this.camera.quaternion.clone();else{const e=Of(h.orientation);Gf.euler.set(e.x,e.y,e.z),g=Gf.quaternion.setFromEuler(Gf.euler).clone()}const f=`${e}_${this._nextId++}`;if(o.spawn(f,r,g,Gf.scale,n)){const l=this._initAnimState(o,f,a,t);l&&o.updateInstanceTransform(f,r,g,d*l.scale),this.activeElements.set(f,{type:e,modelName:i,modelIndex:n,spawnTime:this.time,basePosition:r.clone(),position:r.clone(),rotation:g.clone(),baseScale:d,scale:d,animState:l,cameraOrientation:"camera"===h.orientation,worldSpaceOrientation:!0,baseWorldRotation:g.clone(),anchor:{config:h,baseY:s.baseY,startScale:h.startScale,endScale:h.endScale,exitDuration:a?.exit?.duration??0}}),m.push(f)}}return m}_spawnRadialBurst(e,t,i,a,n=null){const s=this._getSpawnContext(e);if(!s)return[];const{pool:r,merged:o,config:l}=s,c=function(e,t){const i=e.burst||{};return{landmark:i.landmark||"center",landmarkY:t(i.landmark||"center"),offset:{x:i.offset?.x||0,y:i.offset?.y||0,z:i.offset?.z||0},startRadius:i.startRadius||.05,endRadius:i.endRadius||.5,plane:i.plane||"xz",easing:i.easing||"easeOutQuad",startScale:i.startScale??.8,endScale:i.endScale??1.2,count:e.count||5,models:e.models||[],scale:e.scale??1}}(t,e=>this.spatialRef.resolveLandmark(e)),h=t.radialBurst?.orientation||"vertical",u=t.animation||{},d=u.modelOverrides||{};this._applyShaderAnimationOverrides(e,c.models,d,l,u);const m=[],p=c.models.length>0?c.models:i||Array.from(o.modelMap.keys());for(let t=0;t<c.count;t++){const i=p[t%p.length],n=this._resolveModelIndex(o,i);if(void 0===n)continue;const s=Ff(c,t,this.mascotRadius),u=Gf.position.set(s.position.x,s.position.y,s.position.z).clone();let d;d="camera"===h&&this.camera?this.camera.quaternion.clone():Gf.quaternion.set(s.rotation.x,s.rotation.y,s.rotation.z,s.rotation.w).clone();const g=c.scale||l?.scaleMultiplier||Lf,f=cf(i,this.mascotRadius,g),y=f*s.scaleMultiplier,v=`${e}_${this._nextId++}`;if(r.spawn(v,u,d,Gf.scale.setScalar(y),n)){const o=this._initAnimState(r,v,a,t);this.activeElements.set(v,{type:e,modelName:i,modelIndex:n,spawnTime:this.time,basePosition:u.clone(),position:u.clone(),rotation:d.clone(),baseScale:f,scale:y,animState:o,cameraOrientation:"camera"===h,worldSpaceOrientation:!0,baseWorldRotation:d.clone(),...s.modeData}),m.push(v)}}return m}_spawnOrbit(e,t,i,a,n,s=null){const r=this._getSpawnContext(e);if(!r)return[];const{pool:o,merged:l,config:c}=r,h=function(e,t){const i=e.orbit||{},a=e.formation||null;let n=0;"string"==typeof i.height?n=t(i.height):"number"==typeof i.height&&({height:n}=i);let s=n;void 0!==i.endHeight&&("string"==typeof i.endHeight?s=t(i.endHeight):"number"==typeof i.endHeight&&(s=i.endHeight));const r=i.orientation??i.ringOrientation,o=i.radius??1.5;return{height:n,radius:o,endHeight:s,endRadius:i.endRadius??o,plane:i.plane||"horizontal",speed:i.speed??0,easing:i.easing||"linear",startScale:i.startScale??e.scale??1,endScale:i.endScale??i.startScale??e.scale??1,orientation:_f(r)||"vertical",formation:Rf(a),count:e.count||a?.count||4,models:e.models||[],scale:e.scale??1}}(t,e=>this.spatialRef.resolveLandmark(e)),u=function(e){const{formation:t,count:i}=e,a=[],n=t?.count||i;for(let e=0;e<n;e++){const i={index:e,angle:0,heightOffset:0,rotationOffset:0};switch(t?.type||"ring"){case"ring":i.angle=e/n*Math.PI*2+(t?.startAngle||0);break;case"pairs":{const a=e%2==1,s=Math.floor(e/2)/Math.ceil(n/2)*Math.PI*2;i.angle=a?s+(t?.pairSpacing||Math.PI):s;break}case"cluster":{const a=Math.PI/2;i.angle=e/n*a+(t?.startAngle||0);break}default:i.angle=e/n*Math.PI*2}a.push(i)}return a}(h),d=t.animation||{},m=d.modelOverrides||{};this._applyShaderAnimationOverrides(e,h.models,m,c,d);const p=[],g=h.models.length>0?h.models:i||Array.from(l.modelMap.keys());for(let t=0;t<u.length;t++){const i=u[t],n=g[t%g.length],s=this._resolveModelIndex(l,n);if(void 0===s)continue;const r=Ef(h,i,0,this.mascotRadius),d=Gf.position.set(r.x,r.y,r.z).clone(),m=h.scale||c?.scaleMultiplier||Lf,f=cf(n,this.mascotRadius,m);Gf.scale.setScalar(f);const y=h.orientation,v=lf(n);let b;const w=!0;switch(y||v.mode||"vertical"){case"flat":case"horizontal":b=Gf.quaternion.setFromAxisAngle(Gf.axis.set(1,0,0),Math.PI/2);break;case"vertical":Gf.euler.set(0,r.angle+Math.PI/2,0),b=Gf.quaternion.setFromEuler(Gf.euler);break;case"radial":b=Gf.quaternion.setFromAxisAngle(Gf.axis.set(1,0,0),Math.PI/4);break;default:b=Gf.quaternion.identity()}const M=b.clone(),S=`${e}_${this._nextId++}`;if(o.spawn(S,d,b,Gf.scale,s)){const l=this._initAnimState(o,S,a,t);l&&o.updateInstanceTransform(S,d,b,f*l.scale),this.activeElements.set(S,{type:e,modelName:n,modelIndex:s,spawnTime:this.time,basePosition:d.clone(),position:d.clone(),rotation:b.clone(),baseScale:f,scale:f,animState:l,worldSpaceOrientation:w,baseWorldRotation:M,orbit:{config:h,formationData:i,angle:r.angle}}),p.push(S)}}return p}_spawnSurface(e,t,i,a,n,s,r=null){const o=this._getSpawnContext(e);if(!o)return[];const{pool:l,merged:c,config:h}=o,u=function(e){if("string"==typeof e)return{pattern:"shell",embedDepth:.2,cameraFacing:.3,clustering:0,countOverride:null,scaleMultiplier:1.5,minDistanceFactor:.18,ephemeral:null,models:[]};const t=e.surface||e;return{pattern:t.pattern||"shell",embedDepth:t.embedDepth??.2,cameraFacing:t.cameraFacing??.3,clustering:t.clustering??0,countOverride:t.count||e.count||null,scaleMultiplier:t.scale||e.scale||1.5,minDistanceFactor:t.minDistance??.18,ephemeral:t.ephemeral||null,models:e.models||[]}}(t),d=t.animation||{},m=d.modelOverrides||{};if(this._applyShaderAnimationOverrides(e,u.models,m,h,d),!this.coreMesh?.geometry)return console.warn("[ElementInstancedSpawner] Surface mode requested but no coreMesh geometry available"),[];const p=function(e,t,i,a={},n=null,s=null){const{pattern:r="scattered",clustering:o=0,minDistanceFactor:l=.15}=a,c=i*l,h=e.attributes.position,u=e.attributes.normal,d=h.count,m=[],p=hf.cameraDir;n?p.set(0,0,-1).applyQuaternion(n.quaternion):p.set(0,0,1);const g=hf.vec3_a,f=hf.vec3_b,y=hf.vec3_c;for(let e=0;e<d;e++){g.set(h.getX(e),h.getY(e),h.getZ(e)),u?f.set(u.getX(e),u.getY(e),u.getZ(e)).normalize():f.set(0,1,0);let t=1;switch(r){case"crown":t=2*Math.max(0,g.y)+.5*Math.max(0,f.y);break;case"shell":t=.5+.5*Math.max(0,f.dot(p));break;case"scattered":t=.3+.7*Math.max(0,f.dot(p));break;case"spikes":y.copy(g).normalize(),t=1.5*Math.max(0,f.dot(y));break;case"ring":{const e=1-Math.abs(f.y),i=1-2*Math.abs(g.y);t=.5*e+.5*Math.max(0,i);break}default:t=1}const i=f.dot(p);i>0&&(t*=1+.3*i),t>.01&&m.push({position:g.clone(),normal:f.clone(),weight:t,index:e})}m.sort((e,t)=>t.weight-e.weight);const v=[],b=new Set,w=[];if(o>0&&t>2){const e=Math.max(1,Math.floor(t*(1-o)*.5));for(let t=0;t<e&&m.length>0;t++){const e=Math.floor(Math.random()*Math.min(m.length,10));w.push(m[e].position.clone())}}const M=(e,t)=>{for(const i of v)if(e.distanceTo(i.position)<t)return!1;return!0};let S=0,x=c;for(let e=0;e<t&&m.length>0;e++){let t=null,i=0;const a=30;for(;!t&&i<a;){let a;if(i++,o>0&&w.length>0){const t=w[e%w.length];let i=1/0,n=-1;for(let e=0;e<Math.min(m.length,50);e++){if(b.has(m[e].index))continue;const a=m[e].position;if(!M(a,x))continue;const s=a.distanceTo(t)/(m[e].weight+.1);s<i&&(i=s,n=e)}a=n}else{const e=Math.min(m.length,Math.max(20,.4*m.length)),t=[];for(let i=0;i<e;i++)b.has(m[i].index)||M(m[i].position,x)&&t.push({idx:i,weight:m[i].weight});if(t.length>0){const e=t.reduce((e,t)=>e+t.weight,0);let i=Math.random()*e;a=t[0].idx;for(const e of t)if(i-=e.weight,i<=0){a=e.idx;break}}else a=-1}a>=0?(t=m[a],b.add(t.index),S=0):(S++,S>=20&&(x*=.5,S=0))}if(t){const e=t.position.clone();s&&e.multiply(s),v.push({position:e,normal:t.normal.clone(),weight:t.weight})}}return v}(this.coreMesh.geometry,i,this.mascotRadius,u,s||this.camera,null);if(0===p.length)return console.warn("[ElementInstancedSpawner] No surface points sampled"),[];const g=[],f=u.models.length>0?u.models:a||Array.from(c.modelMap.keys()),y=Math.min(u.countOverride||i,l.availableSlots,p.length);for(let t=0;t<y;t++){const i=p[t],a=f[Math.floor(Math.random()*f.length)],r=this._resolveModelIndex(c,a);if(void 0===r)continue;const o=u.scaleMultiplier||h?.scaleMultiplier||Lf,d=cf(a,this.mascotRadius,o);Gf.scale.setScalar(d);const m=u.embedDepth??.2,y=df(i.position,i.normal,d,m),{position:v}=y,b=u.cameraFacing??.3,w=uf(i.normal,a,b,s||this.camera,v,null).clone(),M=`${e}_${this._nextId++}`;if(l.spawn(M,v,w,Gf.scale,r)){const s=this._initAnimState(l,M,n,t);s&&l.updateInstanceTransform(M,v,w,d*s.scale),this.activeElements.set(M,{type:e,modelName:a,modelIndex:r,spawnTime:this.time,basePosition:v.clone(),position:v.clone(),rotation:w.clone(),baseScale:d,scale:d,animState:s,surface:{config:u,normal:i.normal.clone(),embedDepth:m}}),g.push(M)}}return g}triggerExit(e=null){if(this._particleAtmospherics)if(e)this._particleAtmospherics.stopGesture(e);else for(const[e]of this.pools)this._particleAtmospherics.stopGesture(e);for(const[t,i]of this.activeElements)if(!e||i.type===e)if(i.animState)i.animState.triggerExit();else{const e=this.pools.get(i.type);e&&e.beginDespawn(t)}}despawn(e=null,t=!0){const i=e?[e]:Array.from(this.pools.keys());for(const e of i){const i=this.pools.get(e);if(!i)continue;const a=[];for(const[t,i]of this.activeElements)i.type===e&&a.push(t);for(const e of a)t?i.beginDespawn(e):i.removeImmediate(e),this.activeElements.delete(e)}}despawnAll(){this.despawn(null,!1)}update(e,t=null){if(0===this.activeElements.size&&0===this.pools.size)return;if(this.time+=e,0===this.activeElements.size){if(this._distortionManager)for(const[e,t]of this.pools)this._distortionManager.syncInstances(e,t.mesh,t.mesh.count);if(this._particleAtmospherics)for(const[e]of this.pools)this._particleAtmospherics.syncSources(e,this.activeElements,this.container);return void this._checkPoolCleanup()}if(this.coreMesh){this.container.position.copy(this.coreMesh.position);let e=!1;for(const t of this.activeElements.values())if(t.worldSpaceOrientation){e=!0;break}e?this.container.quaternion.identity():this.container.quaternion.copy(this.coreMesh.quaternion),this.container.scale.copy(this.coreMesh.scale)}for(const[e,i]of this.pools){i.setTime(this.time);const a=pg.get(e),n=this.materials.get(e);a?.updateMaterial&&n&&a.updateMaterial(n,this.time,t??0)}const i=[];for(const[a,n]of this.activeElements){const{animState:s,type:r,basePosition:o,baseScale:l,rotation:c}=n;if(!s)continue;if(!s.update(this.time,e,t)){i.push(a);continue}const h=this.pools.get(r);if(!h)continue;if(s.state===mf){h.updateInstanceOpacity(a,0);continue}const{axisTravel:u}=n;let d,m;const p=pg.get(r),g=null!=p?.createMaterial;if(u&&null!==t){const e=this._calculateAxisTravelPosition(u.config,u.formationData,t);d=e.position;const i=e.scaleMultiplier??1,a=l*e.scale*i*s.fadeProgress;Gf.scale.set(a*e.diameter,a*e.diameter,a),m=a,n.basePosition.copy(d)}else if(n.anchor){const e=If(n.anchor.config,this.time);Gf.position.set(e.x,e.y,e.z),d=Gf.position;const i=s.elementConfig?.appearAt??0,a=(s.elementConfig?.disappearAt??1)+(n.anchor.exitDuration??0)-i,r=null!==t&&a>0?Math.max(0,Math.min(1,(t-i)/a)):0,{startScale:o,endScale:c,config:h}=n.anchor,u=o+(c-o)*km(h?.scaleEasing||"easeOutExpo")(r);m=o!==c?l*u:g?l*u*s.fadeProgress:l*u*s.scale}else if(n.radialBurst){const e=s.elementConfig?.appearAt??0,i=(s.elementConfig?.disappearAt??1)-e,a=i>0?Math.max(0,Math.min(1,(t-e)/i)):t,r=zf({radialBurst:n.radialBurst},a,this.mascotRadius);Gf.position.set(r.position.x,r.position.y,r.position.z),d=Gf.position,m=g?l*r.scaleMultiplier*s.fadeProgress:l*r.scaleMultiplier*s.scale}else if(n.orbit&&0!==n.orbit.config.speed&&null!==t){const e=n.orbit.config,i=s.elementConfig?.appearAt??0,a=(s.elementConfig?.disappearAt??1)-i,r=a>0?Math.max(0,Math.min(1,(t-i)/a)):t,o=km(e.easing||"linear"),c=Ef(e,n.orbit.formationData,r,this.mascotRadius,o);Gf.position.set(c.x,c.y,c.z),d=Gf.position;const h=c.scale??1;m=g?l*h*s.fadeProgress:l*h*s.scale,n.basePosition.copy(d)}else{const e=s.driftOffset;Gf.position.set(o.x+e.x,o.y+e.y,o.z+e.z),d=Gf.position,m=g?l*s.fadeProgress:l*s.scale}n.position.copy(d),n.scale=m;const f=s.rotationOffset;if(n.cameraOrientation&&this.camera){Gf.quaternion.copy(this.camera.quaternion),"wave-curl"===n.modelName&&(Gf.quaternion2.setFromAxisAngle(Gf.axis.set(1,0,0),Math.PI/2),Gf.quaternion.multiply(Gf.quaternion2));const e=n.axisTravel?.formationData?.rotationOffset||0;0!==e&&(Gf.quaternion2.setFromAxisAngle(Gf.axis.set(0,0,1),e),Gf.quaternion.multiply(Gf.quaternion2))}else n.worldSpaceOrientation&&n.baseWorldRotation?Gf.quaternion.copy(n.baseWorldRotation):Gf.quaternion.copy(c);0===f.x&&0===f.y&&0===f.z||(Gf.euler.set(f.x,f.y,f.z),Gf.quaternion2.setFromEuler(Gf.euler),Gf.quaternion.multiply(Gf.quaternion2)),u&&null!==t?h.updateInstanceTransform(a,d,Gf.quaternion,Gf.scale):h.updateInstanceTransform(a,d,Gf.quaternion,m);const y=g?s.fadeProgress:s.opacity;h.updateInstanceOpacity(a,y)}for(const e of i){const t=this.activeElements.get(e);if(t){const i=this.pools.get(t.type);i&&i.removeImmediate(e),this.activeElements.delete(e)}}if(this._distortionManager)for(const[e,t]of this.pools)this._distortionManager.syncInstances(e,t.mesh,t.mesh.count);if(this._particleAtmospherics){const e=new Set;for(const[,t]of this.activeElements)e.add(t.type);for(const i of e){this._particleAtmospherics.syncSources(i,this.activeElements,this.container),this._particleAtmospherics.setGestureProgress(i,t);const e=this._parameterAnimations.get(i);if(e&&null!==t){const a=Df(e,t);null!==a&&this._particleAtmospherics.setEnergy(i,a)}}}}setDistortionManager(e){this._distortionManager=e}setParticleAtmospherics(e){this._particleAtmospherics=e}setCoreMesh(e){this.coreMesh=e,e&&this.spatialRef.initialize(e)}setCamera(e){this.camera=e}getStats(){const e={activeElements:this.activeElements.size,poolStats:{}};for(const[t,i]of this.pools)e.poolStats[t]=i.getStats();return e}_checkPoolCleanup(){const e=performance.now();if(!(e-this._lastCleanupCheck<1e3)){this._lastCleanupCheck=e;for(const[t,i]of this.pools)if(e-(this._poolLastUsed.get(t)||0)>this._poolCleanupInterval){this._renderer&&i.mesh?.material?.userData?.needsRefraction&&this._renderer.removeRefractionMesh(i.mesh),i.dispose(),this.pools.delete(t),this._poolLastUsed.delete(t);const e=this.materials.get(t);e&&(e.dispose(),this.materials.delete(t)),this._initialized.delete(t)}}}setElementBloomThreshold(e,t){const i=this.materials.get(e),a=pg.get(e);i&&a?.setBloomThreshold&&a.setBloomThreshold(i,t)}dispose(){this.despawnAll();for(const e of this.pools.values())this._renderer&&e.mesh?.material?.userData?.needsRefraction&&this._renderer.removeRefractionMesh(e.mesh),e.dispose();this.pools.clear();for(const e of this.materials.values())e.dispose();this.materials.clear();for(const{geometry:e}of this.mergedGeometries.values())e.dispose();this.mergedGeometries.clear();for(const e of this.geometryCache.values())e.dispose();this.geometryCache.clear(),this.container.parent&&this.container.parent.remove(this.container),this._initialized.clear(),this.activeElements.clear(),this._poolLastUsed.clear()}}class Nf{constructor(){this.enabled=!1,this.sections=new Map,this.frameCount=0,this.frameStartTime=0,this.totalFrameTime=0,this._startTimes=new Map,this._reportInterval=60,this._gl=null,this._gpuSyncEnabled=!1,this._frameTimestamps=[],this._maxTimestamps=120}setGL(e){this._gl=e}enableGPUSync(){this._gpuSyncEnabled=!0,console.log("[PerformanceProfiler] GPU sync enabled - this will impact performance!")}disableGPUSync(){this._gpuSyncEnabled=!1,console.log("[PerformanceProfiler] GPU sync disabled")}enable(){this.enabled=!0,this.reset(),console.log("[PerformanceProfiler] Enabled - collecting data..."),console.log("[PerformanceProfiler] TIP: Run profiler.enableGPUSync() for accurate GPU timing (will slow things down)")}disable(){this.enabled=!1,console.log("[PerformanceProfiler] Disabled")}reset(){this.sections.clear(),this.frameCount=0,this.totalFrameTime=0,this._frameTimestamps=[]}startFrame(){this.enabled&&(this.frameStartTime=performance.now())}start(e){this.enabled&&this._startTimes.set(e,performance.now())}end(e){if(!this.enabled)return;this._gpuSyncEnabled&&this._gl&&"threeRenderer"===e&&this._gl.finish();const t=this._startTimes.get(e);if(void 0===t)return;const i=performance.now()-t;this.sections.has(e)||this.sections.set(e,{total:0,count:0,max:0,min:1/0});const a=this.sections.get(e);a.total+=i,a.count++,a.max=Math.max(a.max,i),a.min=Math.min(a.min,i)}endFrame(){if(!this.enabled)return;const e=performance.now(),t=e-this.frameStartTime;this.totalFrameTime+=t,this.frameCount++,this._frameTimestamps.push(e),this._frameTimestamps.length>this._maxTimestamps&&this._frameTimestamps.shift(),this.frameCount%this._reportInterval===0&&console.log(this.getReport())}getActualFPS(){if(this._frameTimestamps.length<2)return 0;const e=this._frameTimestamps[0],t=this._frameTimestamps[this._frameTimestamps.length-1]-e;return 0===t?0:(this._frameTimestamps.length-1)/t*1e3}getReport(){if(0===this.frameCount)return"No frames recorded";const e=this.totalFrameTime/this.frameCount,t=1e3/e,i=this.getActualFPS();let a=`\n=== Performance Report (${this.frameCount} frames) ===\n`;a+=`Average Frame Time: ${e.toFixed(2)}ms\n`,a+=`Theoretical Max FPS: ${t.toFixed(1)} (if no GPU bottleneck)\n`,a+=`Actual FPS: ${i.toFixed(1)} (real measured rate)\n`,this._gpuSyncEnabled?a+="GPU Sync: ENABLED (accurate GPU timing)\n":a+="GPU Sync: disabled (CPU time only - run profiler.enableGPUSync() for GPU timing)\n",a+="\nSection Breakdown:\n";const n=[...this.sections.entries()].sort((e,t)=>t[1].total-e[1].total);for(const[e,t]of n){const i=t.total/t.count,n=(t.total/this.totalFrameTime*100).toFixed(1);a+=`  ${e.padEnd(30)} avg: ${i.toFixed(2)}ms  min: ${t.min.toFixed(2)}ms  max: ${t.max.toFixed(2)}ms  (${n}%)\n`}let s=0;for(const[,e]of this.sections)s+=e.total;const r=this.totalFrameTime-s,o=(r/this.totalFrameTime*100).toFixed(1);return a+=`  ${"(unaccounted)".padEnd(30)} total: ${r.toFixed(2)}ms  (${o}%)\n`,a+="\n--- Analysis ---\n",i<.5*t?(a+=`⚠️ GPU BOTTLENECK DETECTED: Actual FPS (${i.toFixed(0)}) << Theoretical (${t.toFixed(0)})\n`,a+="   The GPU cannot keep up with draw calls. Likely causes:\n",a+="   - Bloom post-processing (13 render passes)\n",a+="   - Complex shader (SSS crystal material)\n",a+="   - High resolution / pixel fill rate\n"):a+="✓ No obvious GPU bottleneck detected\n",a}setRenderer(e){this._renderer=e}diagnose(){let e="\n=== RENDER PIPELINE DIAGNOSTICS ===\n\n";if(this._gl){const t=this._gl.getExtension("WEBGL_debug_renderer_info");if(t){const i=this._gl.getParameter(t.UNMASKED_VENDOR_WEBGL);e+=`GPU: ${this._gl.getParameter(t.UNMASKED_RENDERER_WEBGL)}\n`,e+=`Vendor: ${i}\n`}else e+="GPU: (debug info not available)\n";const i=this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),a=this._gl.getParameter(this._gl.MAX_VIEWPORT_DIMS),n=[this._gl.drawingBufferWidth,this._gl.drawingBufferHeight];e+=`Max Texture Size: ${i}\n`,e+=`Max Viewport: ${a[0]}x${a[1]}\n`,e+=`Drawing Buffer: ${n[0]}x${n[1]}\n`}if(this._renderer){if(e+="\n--- Bloom Passes ---\n",this._renderer.bloomPass){const t=this._renderer.bloomPass;e+="Main Bloom:\n",e+=`  resolution: ${t.resolution?.x}x${t.resolution?.y}\n`,e+=`  nMips: ${t.nMips}\n`,t.renderTargetBright&&(e+=`  renderTargetBright: ${t.renderTargetBright.width}x${t.renderTargetBright.height}\n`),t.renderTargetsHorizontal?.[0]&&(e+=`  mip0: ${t.renderTargetsHorizontal[0].width}x${t.renderTargetsHorizontal[0].height}\n`)}else e+="Main Bloom: NOT FOUND\n";if(this._renderer.particleBloomPass){const t=this._renderer.particleBloomPass;e+="Particle Bloom:\n",e+=`  resolution: ${t.resolution?.x}x${t.resolution?.y}\n`,t.renderTargetBright&&(e+=`  renderTargetBright: ${t.renderTargetBright.width}x${t.renderTargetBright.height}\n`)}else e+="Particle Bloom: NOT FOUND\n";if(e+="\n--- Render Targets ---\n",this._renderer.particleRenderTarget){const t=this._renderer.particleRenderTarget;e+=`Particle RT: ${t.width}x${t.height}\n`}if(this._renderer.soulRenderTarget){const t=this._renderer.soulRenderTarget;e+=`Soul RT: ${t.width}x${t.height}\n`}if(this._renderer.composer){const t=this._renderer.composer;e+="\n--- Composer ---\n",e+=`Passes: ${t.passes?.length||"unknown"}\n`,t.readBuffer&&(e+=`Read Buffer: ${t.readBuffer.width}x${t.readBuffer.height}\n`)}}else e+="\nRenderer not available - call profiler.setRenderer(mascot.renderer)\n";e+="\n--- Frame Rate Analysis ---\n";const t=this.getActualFPS();return e+=`Current FPS: ${t.toFixed(1)}\n`,t>0&&t<35&&t>25&&(e+="⚠️ FPS is suspiciously close to 30 - possible causes:\n",e+="   - Browser V-Sync to 30fps (power saving mode?)\n",e+="   - Windows display scaling issues\n",e+="   - GPU running on integrated graphics instead of dedicated\n",e+="   - requestAnimationFrame throttling\n",e+="\nTry:\n",e+="   1. Check chrome://gpu for GPU status\n",e+="   2. Disable battery saver / power saving mode\n",e+="   3. Force Chrome to use dedicated GPU in Windows settings\n"),console.log(e),e}testBypassBloom(){this._renderer?.bloomPass?(this._renderer.bloomPass.enabled=!1,this._renderer.particleBloomPass&&(this._renderer.particleBloomPass.enabled=!1),console.log("[Profiler] Bloom DISABLED - check FPS now"),console.log("[Profiler] Run profiler.restoreBloom() to re-enable")):console.log("Renderer not available")}restoreBloom(){this._renderer?.bloomPass?(this._renderer.bloomPass.enabled=!0,this._renderer.particleBloomPass&&(this._renderer.particleBloomPass.enabled=!0),console.log("[Profiler] Bloom RESTORED")):console.log("Renderer not available")}testBypassComposer(){this._renderer?(this._savedComposer=this._renderer.composer,this._renderer.composer=null,console.log("[Profiler] Composer BYPASSED - direct render mode (no bloom, no effects)"),console.log("[Profiler] Check FPS now. Run profiler.restoreComposer() to restore")):console.log("Renderer not available")}restoreComposer(){this._renderer&&this._savedComposer?(this._renderer.composer=this._savedComposer,this._savedComposer=null,console.log("[Profiler] Composer RESTORED")):console.log("No saved composer to restore")}}const jf=new Nf,qf=["fire","ice","water","earth","nature","electricity","void","light"];class Uf{constructor(t,i={}){if(!t)throw new Error("Core3DManager: canvas element is required");if(!(t instanceof HTMLCanvasElement))throw new Error("Core3DManager: canvas must be an HTMLCanvasElement");if(void 0===e)throw new Error("Core3DManager: Three.js library is not loaded. Import three.js before using Core3DManager");this._instanceId=Math.random().toString(36).substr(2,6),this.canvas=t,this.options=i,this._destroyed=!1,this._ready=!1,this._readyPromise=null,this.debugMotionLogging=!1,this.assetBasePath=void 0!==i.assetBasePath?i.assetBasePath:"",this.enableShatter=!1!==i.enableShatter,this._preloadElements=i.preloadElements||[],this._backgroundPrewarm=!1!==i.backgroundPrewarm,this._prewarmTimeoutId=null,this.geometryType=i.geometry||"sphere";const a="moon"===this.geometryType;this.renderer=new Dt(t,{enablePostProcessing:!1!==i.enablePostProcessing,enableShadows:i.enableShadows||!1,enableControls:!1!==i.enableControls,autoRotate:!a&&!1!==i.autoRotate,autoRotateSpeed:i.autoRotateSpeed,cameraDistance:i.cameraDistance,fov:i.fov,minZoom:i.minZoom,maxZoom:i.maxZoom,assetBasePath:this.assetBasePath}),jf.setGL(this.renderer.renderer.getContext()),jf.setRenderer(this.renderer),this.renderer.onContextRestored=()=>this._handleContextRestored();const n=wi[this.geometryType];n?this.geometryConfig=n:(console.warn(`Unknown geometry: ${this.geometryType}, falling back to sphere`),this.geometryConfig=wi.sphere),this.geometry=this.geometryConfig.geometry,this.geometry&&!this.geometry.isGroup&&(this.geometry.userData.geometryType=this.geometryType),this.materialVariant=i.materialVariant||null,this.onMaterialSwap=null;let s=null;const r=Ii(this.emotion),o=this.geometryType,l=Wd(this.geometryType,this.geometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:r,assetBasePath:this.assetBasePath,onTextureReady:e=>{this.shatterSystem&&this.renderer?.coreMesh&&this.shatterSystem.precomputeShards(this.renderer.coreMesh,o)}});if(l&&(s=l.material,this.customMaterial=s,this.customMaterialType=l.type),this.geometryConfig.geometryLoader?this._readyPromise=this._loadAsyncGeometry():(this._ready=!0,this._readyPromise=Promise.resolve()),null===this.geometry&&this.geometryConfig.geometryLoader?this._deferredMeshCreation=!0:(this.coreMesh=this.renderer.createCoreMesh(this.geometry,s),"crystal"===this.customMaterialType&&this.createCrystalInnerCore()),this.calibrationRotation=[0,0,0],this.cameraRoll=0,"moon"===this.geometryType){const e=Math.PI/180;this.calibrationRotation=[$t*e,Yt*e,Xt*e],this.cameraRoll=0}if("crystal"===this.geometryType||"rough"===this.geometryType||"heart"===this.geometryType||"star"===this.geometryType){const e=Math.PI/180;this.calibrationRotation=[0*e,30*e,0*e]}if(this.animator=new Mi,this.gestureBlender=new xi,this.animationManager=new Jd(this.animator,this.gestureBlender),this.effectManager=new Tm(this.renderer,this.assetBasePath),this.behaviorController=new Bm({rotationDisabled:!1===i.autoRotate,wobbleEnabled:!0,rhythmEngine:i.rhythmEngine||null,camera:this.renderer.camera}),this.breathingPhaseManager=new Fm,this.breathingAnimator=new Si,this.breathingEnabled=!1!==i.enableBreathing,this.geometryMorpher=new ji,this._skipRenderFrames=0,this.blinkAnimator=new Fi(this.geometryConfig),this.blinkAnimator.setEmotion(this.emotion),this.blinkingManuallyDisabled=!1,!1===i.enableBlinking&&(this.blinkAnimator.pause(),this.blinkingManuallyDisabled=!0),this.rotationDisabled=!1===i.autoRotate,this.wobbleEnabled=!0,a&&Qt.enabled){const e=Math.PI/180;this.behaviorController.configureForEmotion({geometryType:"moon",emotionData:null,facingConfig:{enabled:!0,strength:Qt.strength,lockedFace:Qt.lockedFace,lerpSpeed:Qt.lerpSpeed,calibrationRotation:[$t*e,Yt*e,Xt*e]}})}this.emotion=i.emotion||"neutral",this.undertone=i.undertone||null,this.glowColor=[1,1,1],this.glowColorHex="#FFFFFF",this.glowIntensity=1,this._normalizedGlowColor=null,this.coreGlowEnabled=!0,this.glowIntensityOverride=null,this.intensityCalibrationOffset=0,this.baseEuler=[0,0,0],this.baseQuaternion=new e.Quaternion,this.gestureQuaternion=new e.Quaternion,this.tempEuler=new e.Euler,this.rotation=[0,0,0],this.baseScale=.16,this.scale=.16,this.position=[0,0,0],this.rhythmEngine=i.rhythmEngine||null,this.rhythm3DAdapter=Ni,this.rhythmEnabled=!1!==i.enableRhythm,this.rhythmEnabled&&(this.rhythm3DAdapter.initialize(),this.breathingAnimator.setRhythmAdapter(this.rhythm3DAdapter)),this.particlesEnabled=!1!==i.enableParticles,this.particleVisibility=this.particlesEnabled;const c=new Dd(50);c.canvasWidth=t.width,c.canvasHeight=t.height;const h=new Ad({worldScale:2,baseRadius:1.5,depthScale:.75,verticalScale:1,coreRadius3D:2}),u=new Rd(150,{renderer:this.renderer.renderer}),d=u.getPoints();d.layers.set(1),this.renderer.scene.add(d),this.particleOrchestrator=new zd(c,h,u),this.particleOrchestrator.setGeometryType(this.geometryType),this.particlesEnabled||u.geometry.setDrawRange(0,0);const m=this.geometry?.parameters?.radius||.5;this.effectManager.initializeForGeometry(this.geometryType,{coreMesh:this.coreMesh,customMaterial:this.customMaterial,sunRadius:m}),this.shatterSystem=null,this._pendingShatter=null,this.enableShatter&&(this.shatterSystem=new up({scene:this.renderer.scene,maxShards:50,shardLifetime:2e3,enableReassembly:!0,autoRestore:!0}),this.shatterSystem.onShatterStart=()=>{},this.shatterSystem.onShatterComplete=()=>{this.crystalSoul&&this.crystalSoul.setVisible(this.coreGlowEnabled)},this.shatterSystem.onReassemblyComplete=()=>{this.crystalSoul&&this.crystalSoul.setVisible(this.coreGlowEnabled)},this.renderer?.coreMesh&&this.shatterSystem.precomputeShards(this.renderer.coreMesh,this.geometryType)),this.objectSpaceCrackManager=new dp,this.elementSpawner=new Vf({scene:this.renderer.scene,assetsBasePath:this.assetBasePath,renderer:this.renderer}),this.renderer?.distortionManager&&this.elementSpawner.setDistortionManager(this.renderer.distortionManager),this.renderer?.particleAtmospherics&&this.elementSpawner.setParticleAtmospherics(this.renderer.particleAtmospherics),this.renderer?.coreMesh&&this.elementSpawner.initialize(this.renderer.coreMesh,this.renderer.camera),this.geometryConfig.defaultGlassMode&&!this.customMaterial&&this.setGlassMaterialEnabled(!0),this.setEmotion(this.emotion)}setEmotion(t,i=null){this.emotion=t,this.undertone=i;const a=Ii(t);if(a&&a.visual){if(a.visual.glowColor){let e=(n=(n=a.visual.glowColor).replace("#",""),[parseInt(n.substring(0,2),16)/255,parseInt(n.substring(2,4),16)/255,parseInt(n.substring(4,6),16)/255]);e=function(e,t){if(!t||"clear"===t||"none"===t)return e;const i={intense:{saturation:2.5,lightness:1.3},confident:{saturation:1.8,lightness:1.15},nervous:{saturation:1.6,lightness:1.1},tired:{saturation:.4,lightness:.65},subdued:{saturation:.25,lightness:.55}}[t];if(!i)return e;const a=function(e,t,i){const a=Math.max(e,t,i),n=Math.min(e,t,i),s=a-n,r=a+n;let o=0,l=0;const c=r/2;if(0!==s)switch(l=c>.5?s/(2-r):s/r,a){case e:o=((t-i)/s+(t<i?6:0))/6;break;case t:o=((i-e)/s+2)/6;break;case i:o=((e-t)/s+4)/6}return[360*o,100*l,100*c]}(e[0],e[1],e[2]);return a[1]=Math.min(100,a[1]*i.saturation),a[2]=Math.min(100,Math.max(0,a[2]*i.lightness)),function(e,t,i){let a,n,s;if(e/=360,i/=100,0==(t/=100))a=n=s=i;else{const r=(e,t,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?e+6*(t-e)*i:i<.5?t:i<2/3?e+(t-e)*(2/3-i)*6:e),o=i<.5?i*(1+t):i+t-i*t,l=2*i-o;a=r(l,o,e+1/3),n=r(l,o,e),s=r(l,o,e-1/3)}return[a,n,s]}(a[0],a[1],a[2])}(e,i),this.glowColor=e,this.glowColorHex=a.visual.glowColor;const t=function(e,t=.5){const[i,a,n]=e,s=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4),r=s(i),o=s(a),l=s(n),c=.2126*r+.7152*o+.0722*l,h=t/Math.max(c,.001);let u=r*h,d=o*h,m=l*h;const p=Math.max(u,d,m);p>1&&(u/=p,d/=p,m/=p);const g=e=>e<=.0031308?12.92*e:1.055*Math.pow(e,1/2.4)-.055;return{r:Math.min(1,Math.max(0,g(u))),g:Math.min(1,Math.max(0,g(d))),b:Math.min(1,Math.max(0,g(m)))}}(e,.3);this._targetGlowColor=[t.r,t.g,t.b],this._normalizedGlowColor||(this._normalizedGlowColor=[...this._targetGlowColor]),this._colorTransitionProgress=0,this._colorTransitionStart=[...this._normalizedGlowColor];const s=this.renderer.materialMode||"glass";this.glowIntensity=Wi(a.visual.glowColor,this.intensityCalibrationOffset,s)}if(this.renderer.updateLighting(t,a),this.customMaterial&&"moon"===this.customMaterialType){const t=new e.Color(this.glowColor[0],this.glowColor[1],this.glowColor[2]);li(this.customMaterial,t,this.glowIntensity)}else this.customMaterial&&"sun"===this.customMaterialType&&gi(this.coreMesh,this.glowColor,this.glowIntensity,0)}var n;const s="sun"===this.geometryType?di:null;let r=null;if("moon"===this.geometryType&&Qt.enabled){const e=Math.PI/180;r={enabled:!0,strength:Qt.strength,lockedFace:Qt.lockedFace,lerpSpeed:Qt.lerpSpeed,calibrationRotation:[$t*e,Yt*e,Xt*e]}}this.behaviorController.configureForEmotion({geometryType:this.geometryType,emotionData:a,facingConfig:r,geometryRotation:s}),this.baseEuler[0]=0,this.baseEuler[2]=0;const o=Ui(i);o&&o["3d"]&&this.behaviorController.applyUndertone(o["3d"]),this.animator.stopEmotions();const l=a?.visual?.glowColor||"#00BCD4",c=this.renderer.materialMode||"glass";if(this.baseGlowIntensity=Wi(l,this.intensityCalibrationOffset,c),o&&o["3d"]&&o["3d"].glow&&(this.baseGlowIntensity*=o["3d"].glow.intensityMultiplier),this.breathingAnimator.setEmotion(t,o),this.blinkAnimator.setEmotion(t),this.rhythmEnabled&&this.rhythm3DAdapter?.isPlaying?.()){const e=this._getEmotionGroove(t);this.rhythm3DAdapter.setGroove(e,{quantize:!0,bars:2})}if(this.renderer.updateBloom(this.baseGlowIntensity,1,this.geometryType),this.animator.playEmotion(t),this.particlesEnabled&&this.particleOrchestrator&&this.particleOrchestrator.setEmotion(t,i),a&&a.soulAnimation){const e=a.soulAnimation;this.setCrystalSoulEffects({driftEnabled:!0,driftSpeed:e.driftSpeed||.5,shimmerEnabled:!0,shimmerSpeed:e.shimmerSpeed||.5})}}setCoreGlowEnabled(e){this.coreGlowEnabled=e,this.crystalSoul&&this.crystalSoul.setVisible(e)}setGlassMaterialEnabled(e){const t=e?"glass":"glow";this.renderer.setMaterialMode(t)}setGlowIntensity(e){this.glowIntensityOverride=e,null!==e&&(this.glowIntensity=e,this.baseGlowIntensity=e)}sliderToIntensity(e){const t=e/100;return.3*Math.pow(10/.3,t)}setIntensityCalibration(e){this.intensityCalibrationOffset=e,this.setEmotion(this.emotion,this.undertone)}getGlowIntensity(){return this.glowIntensity}playGesture(e){this.animationManager.playGesture(e,{onUpdate:(e,t)=>{e.position&&(this.position=e.position),e.rotation&&(this.tempEuler.set(e.rotation[0],e.rotation[1],e.rotation[2],"XYZ"),this.gestureQuaternion.setFromEuler(this.tempEuler)),void 0!==e.scale&&(this.scale=this.baseScale*e.scale),void 0!==e.glowIntensity&&(this.glowIntensity=this.baseGlowIntensity*e.glowIntensity)},onComplete:()=>{this.position=[0,0,0],this.scale=this.baseScale}})}triggerReassembly(e=1500){return this.shatterSystem?this.shatterSystem.triggerReassembly(e):(console.warn("triggerReassembly: ShatterSystem not initialized"),!1)}isShatterFrozen(){return this.shatterSystem?.isFrozen()||!1}setSunShadow(e="off"){"sun"===this.geometryType&&this.effectManager.hasSolarEclipse()?this.effectManager.setSolarEclipse(e):console.warn("⚠️ Eclipse only available for sun geometry")}startSolarEclipse(e={}){const t=e.type||"total";"sun"===this.geometryType&&this.effectManager.hasSolarEclipse()?this.effectManager.setSolarEclipse(t):(this.morphToShape("sun"),setTimeout(()=>{this.effectManager.hasSolarEclipse()&&this.effectManager.setSolarEclipse(t)},600))}startLunarEclipse(e={}){const t=e.type||"total";"moon"===this.geometryType&&this.effectManager.hasLunarEclipse()?this.effectManager.setLunarEclipse(t):(this.morphToShape("moon"),setTimeout(()=>{this.effectManager.hasLunarEclipse()&&this.effectManager.setLunarEclipse(t)},600))}stopEclipse(){this.effectManager.stopAllEclipses()}setMoonEclipse(e="off"){"moon"===this.geometryType&&this.effectManager.hasLunarEclipse()?this.effectManager.setLunarEclipse(e):console.warn("⚠️ Lunar eclipse only available for moon geometry")}setBloodMoonBlend(e={}){"moon"===this.geometryType&&this.customMaterial?(void 0!==e.blendMode&&(this.customMaterial.uniforms.blendMode.value=e.blendMode),void 0!==e.blendStrength&&(this.customMaterial.uniforms.blendStrength.value=e.blendStrength),void 0!==e.emissiveStrength&&(this.customMaterial.uniforms.emissiveStrength.value=e.emissiveStrength),void 0!==e.eclipseIntensity&&(this.customMaterial.uniforms.eclipseIntensity.value=e.eclipseIntensity)):console.warn("⚠️ Blood moon blend only available for moon geometry")}setBlendLayer(e,t={}){if("moon"!==this.geometryType&&"sun"!==this.geometryType||!this.customMaterial)return void console.warn("⚠️ Blend layers only available for moon and sun geometry");const i=`layer${e}`;void 0!==t.mode&&this.customMaterial.uniforms[`${i}Mode`]&&(this.customMaterial.uniforms[`${i}Mode`].value=t.mode),void 0!==t.strength&&this.customMaterial.uniforms[`${i}Strength`]&&(this.customMaterial.uniforms[`${i}Strength`].value=t.strength),void 0!==t.enabled&&this.customMaterial.uniforms[`${i}Enabled`]&&(this.customMaterial.uniforms[`${i}Enabled`].value=t.enabled?1:0)}setAllBlendLayers(e){"moon"!==this.geometryType&&"sun"!==this.geometryType||!this.customMaterial?console.warn("⚠️ Blend layers only available for moon and sun geometry"):e.forEach((e,t)=>{this.setBlendLayer(t+1,e)})}setCrystalBlendLayer(e,t,i={}){if("crystal"!==this.geometryType&&"rough"!==this.geometryType||!this.customMaterial||"crystal"!==this.customMaterialType)return;const a=`${e}Blend${t}`;void 0!==i.mode&&this.customMaterial.uniforms[`${a}Mode`]&&(this.customMaterial.uniforms[`${a}Mode`].value=i.mode),void 0!==i.strength&&this.customMaterial.uniforms[`${a}Strength`]&&(this.customMaterial.uniforms[`${a}Strength`].value=i.strength),void 0!==i.enabled&&this.customMaterial.uniforms[`${a}Enabled`]&&(this.customMaterial.uniforms[`${a}Enabled`].value=i.enabled?1:0)}setCrystalUniforms(e={}){if("crystal"!==this.geometryType&&"rough"!==this.geometryType||!this.customMaterial||"crystal"!==this.customMaterialType)return void console.warn("⚠️ Crystal uniforms only available with crystal blend-layers material");const{uniforms:t}=this.customMaterial,i=(e,t,i=0,a=10)=>{e&&"number"==typeof t&&!isNaN(t)&&isFinite(t)&&(e.value=Math.max(i,Math.min(a,t)))};i(t.coreGlowStrength,e.coreGlowStrength,0,2),void 0===e.coreGlowFalloff||isNaN(e.coreGlowFalloff)||(i(t.coreGlowFalloff,e.coreGlowFalloff,.1,3),this.setCrystalCoreSize(e.coreGlowFalloff)),i(t.fresnelStrength,e.fresnelStrength,0,2),i(t.fresnelPower,e.fresnelPower,.5,10),i(t.transmissionStrength,e.transmissionStrength,0,1),i(t.facetStrength,e.facetStrength,0,2),i(t.iridescenceStrength,e.iridescenceStrength,0,1),i(t.chromaticAberration,e.chromaticAberration,0,1),i(t.causticStrength,e.causticStrength,0,1),i(t.emissiveIntensity,e.emissiveIntensity,0,5),i(t.sparkleEnabled,e.sparkleEnabled,0,1),i(t.sparkleSpeed,e.sparkleSpeed,.1,5),i(t.causticEnabled,e.causticEnabled,0,1),i(t.causticSpeed,e.causticSpeed,.1,10),i(t.causticScale,e.causticScale,.5,10),i(t.causticCoverage,e.causticCoverage,0,1),i(t.energyPulseEnabled,e.energyPulseEnabled,0,1),i(t.energyPulseSpeed,e.energyPulseSpeed,.1,5)}createCrystalInnerCore(){if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!this.coreMesh)return;const e=this._targetGeometryType||this.geometryType;this.crystalSoul=new Od({radius:.35,detail:1,geometryType:e,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(this.coreMesh,this.renderer?.scene);let t=1;"heart"===e?(this.crystalShellBaseScale=2.4,t=1):"rough"===e?(this.crystalShellBaseScale=1.6,t=1):"star"===e?(this.crystalShellBaseScale=2,t=1.4):"crystal"===e&&(this.crystalShellBaseScale=2,t=1),this.crystalSoul.baseScale=t,this.crystalSoul.mesh.scale.setScalar(t),this.crystalSoul.setVisible(this.coreGlowEnabled),this.crystalInnerCore=this.crystalSoul.mesh,this.crystalInnerCoreMaterial=this.crystalSoul.material,this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}updateCrystalInnerCore(e,t=0){if(!this.crystalSoul)return;const i=this.breathingAnimator&&this.breathingEnabled?this.breathingAnimator.getBreathingScale():1;this.crystalSoul.update(t,e,i),this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}setCrystalSoulEffects(e={}){this.crystalSoul&&this.crystalSoul.setEffects(e)}setCrystalCoreSize(e){this.crystalSoul&&(this.crystalSoul.setSize(e),this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale)}setCrystalShellSize(e){!this.coreMesh||"crystal"!==this.geometryType&&"rough"!==this.geometryType&&"heart"!==this.geometryType||(this.crystalShellBaseScale=e)}setWobbleEnabled(e){this.wobbleEnabled=e,this.behaviorController.setWobbleEnabled(e),e||(this.baseEuler[0]=0,this.baseEuler[2]=0)}setMaterialVariant(e){this.materialVariant=e}setRhythmEnabled(e){this.rhythmEnabled=e,e&&this.rhythm3DAdapter&&!this.rhythm3DAdapter.enabled&&this.rhythm3DAdapter.initialize()}setGrooveEnabled(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGrooveEnabled(e)}setBeatSyncStrength(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setBeatSyncStrength(e)}setGrooveConfig(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGrooveConfig(e)}isRhythmPlaying(){return this.rhythm3DAdapter?.isPlaying()||!1}getRhythmBPM(){return this.rhythm3DAdapter?.getBPM()||120}startRhythm(e=120,t="straight"){this.rhythm3DAdapter&&this.rhythm3DAdapter.start(e,t)}stopRhythm(){this.rhythm3DAdapter&&this.rhythm3DAdapter.stop()}setRhythmBPM(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setBPM(e)}setRhythmPattern(e){this.rhythm3DAdapter&&this.rhythm3DAdapter.setPattern(e)}setGroove(e,t={}){this.rhythm3DAdapter&&this.rhythm3DAdapter.setGroove(e,t)}getGroovePresets(){return this.rhythm3DAdapter?this.rhythm3DAdapter.getGroovePresets():["groove1","groove2","groove3"]}getCurrentGroove(){return this.rhythm3DAdapter?this.rhythm3DAdapter.getCurrentGroove():"groove1"}breathePhase(e,t){this.breathingPhaseManager.startPhase(e,t)}stopBreathingPhase(){this.breathingPhaseManager.stop()}_updateBreathingPhase(e){return this.breathingPhaseManager.update(e)}morphToShape(e,t=800){const i=wi[e];i?(this.shatterSystem&&!this.shatterSystem.isIdle()&&this.shatterSystem.forceStop(),this.geometryMorpher.startMorph(this.geometryType,e,t)&&(this.geometryMorpher.getInterruptedTarget(),this.blinkAnimator.pause(),this._targetGeometryConfig=i,this._targetGeometryType=e,i.geometryLoader&&!i.geometry?(this._targetGeometry=null,this._pendingGeometryLoad=i.geometryLoader(this.assetBasePath).then(e=>{this._targetGeometry=e,i.geometry=e,this._pendingGeometryLoad=null})):(this._targetGeometry=i.geometry,this._pendingGeometryLoad=null))):console.warn(`Unknown shape: ${e}`)}isMorphing(){return this.geometryMorpher.isTransitioning}getMorphState(){return this.geometryMorpher.getState()}growIn(e=500){this.geometryMorpher.growIn(this.geometryType,e)}easeInOutCubic(e){return e<.5?4*e*e*e:1-Math.pow(-2*e+2,3)/2}render(t){if(jf.startFrame(),this._destroyed)return;if(!this._ready)return;this._lastDeltaTime=t/1e3,jf.start("animator"),this.animator.update(t),jf.end("animator"),jf.start("geometryMorpher");const i=this.geometryMorpher.update(t);if(jf.end("geometryMorpher"),i.shouldSwapGeometry&&this._pendingGeometryLoad&&this.geometryMorpher.pauseAtSwap(),i.waitingForGeometry&&this._targetGeometry&&!this._pendingGeometryLoad&&(this.geometryMorpher.resumeFromSwap(),this.geometryMorpher.hasSwappedGeometry=!1),i.shouldSwapGeometry&&this._targetGeometry){this._skipRenderFrames=3;const e=this.geometryType;this.customMaterial&&function(e,t){switch(e){case"moon":!function(e){if(!e||!e.uniforms)return;const t=e.uniforms;t.shadowOffset&&t.shadowOffset.value.set(Kt.full.x,Kt.full.y),t.shadowCoverage&&(t.shadowCoverage.value=.5),t.shadowSoftness&&(t.shadowSoftness.value=.05),t.eclipseProgress&&(t.eclipseProgress.value=0),t.eclipseIntensity&&(t.eclipseIntensity.value=0),t.bloodMoonColor&&(t.bloodMoonColor.value=[.85,.18,.08]),t.emissiveStrength&&(t.emissiveStrength.value=.39),t.eclipseShadowPos&&(t.eclipseShadowPos.value=[-2,0]),t.eclipseShadowRadius&&(t.eclipseShadowRadius.value=1.2),t.shadowDarkness&&(t.shadowDarkness.value=.53),t.eclipseShadowColor&&(t.eclipseShadowColor.value=[1,.58,0]),t.eclipseMidtoneColor&&(t.eclipseMidtoneColor.value=[.71,.43,.03]),t.eclipseHighlightColor&&(t.eclipseHighlightColor.value=[1,.28,.1]),t.eclipseGlowColor&&(t.eclipseGlowColor.value=[.09,.09,.09]),t.eclipseBrightnessModel&&(t.eclipseBrightnessModel.value=0),t.layer1Mode&&(t.layer1Mode.value=9),t.layer1Strength&&(t.layer1Strength.value=.322),t.layer1Enabled&&(t.layer1Enabled.value=1),t.layer2Mode&&(t.layer2Mode.value=0),t.layer2Strength&&(t.layer2Strength.value=2.785),t.layer2Enabled&&(t.layer2Enabled.value=1),t.layer3Mode&&(t.layer3Mode.value=7),t.layer3Strength&&(t.layer3Strength.value=.199),t.layer3Enabled&&(t.layer3Enabled.value=1),t.layer4Mode&&(t.layer4Mode.value=0),t.layer4Strength&&(t.layer4Strength.value=0),t.layer4Enabled&&(t.layer4Enabled.value=0),t.opacity&&(t.opacity.value=1)}(t);break;case"sun":!function(e){if(!e||!e.uniforms)return;const t=e.uniforms;t.eclipseProgress&&(t.eclipseProgress.value=0),t.eclipseShadowPos&&(t.eclipseShadowPos.value=[-2,0]),t.eclipseShadowRadius&&(t.eclipseShadowRadius.value=.882),t.shadowDarkness&&(t.shadowDarkness.value=1),t.shadowOffset&&t.shadowOffset.value.set(200,0),t.shadowCoverage&&(t.shadowCoverage.value=.5),t.shadowSoftness&&(t.shadowSoftness.value=.1),t.layer1Mode&&(t.layer1Mode.value=0),t.layer1Strength&&(t.layer1Strength.value=.23),t.layer1Enabled&&(t.layer1Enabled.value=1),t.layer2Mode&&(t.layer2Mode.value=0),t.layer2Strength&&(t.layer2Strength.value=0),t.layer2Enabled&&(t.layer2Enabled.value=0),t.layer3Mode&&(t.layer3Mode.value=0),t.layer3Strength&&(t.layer3Strength.value=0),t.layer3Enabled&&(t.layer3Enabled.value=0),t.layer4Mode&&(t.layer4Mode.value=0),t.layer4Strength&&(t.layer4Strength.value=0),t.layer4Enabled&&(t.layer4Enabled.value=0),t.emissiveIntensity&&(t.emissiveIntensity.value=4),t.opacity&&(t.opacity.value=1),t.time&&(t.time.value=0)}(t);break;case"crystal":case"diamond":!function(e){if(!e||!e.uniforms)return;const t=e.uniforms,i=Ud;t.frostiness&&(t.frostiness.value=i.frostiness),t.fresnelPower&&(t.fresnelPower.value=i.fresnelPower),t.fresnelIntensity&&(t.fresnelIntensity.value=i.fresnelIntensity),t.innerGlowStrength&&(t.innerGlowStrength.value=i.innerGlowStrength),t.surfaceRoughness&&(t.surfaceRoughness.value=i.surfaceRoughness),t.surfaceNoiseScale&&(t.surfaceNoiseScale.value=i.surfaceNoiseScale),t.noiseFrequency&&(t.noiseFrequency.value=i.noiseFrequency),t.causticIntensity&&(t.causticIntensity.value=i.causticIntensity),t.causticScale&&(t.causticScale.value=i.causticScale),t.causticSpeed&&(t.causticSpeed.value=i.causticSpeed),t.textureStrength&&(t.textureStrength.value=i.textureStrength),t.layer1Mode&&(t.layer1Mode.value=i.layer1Mode),t.layer1Strength&&(t.layer1Strength.value=i.layer1Strength),t.layer1Enabled&&(t.layer1Enabled.value=i.layer1Enabled),t.layer2Mode&&(t.layer2Mode.value=i.layer2Mode),t.layer2Strength&&(t.layer2Strength.value=i.layer2Strength),t.layer2Enabled&&(t.layer2Enabled.value=i.layer2Enabled),t.layer3Mode&&(t.layer3Mode.value=i.layer3Mode),t.layer3Strength&&(t.layer3Strength.value=i.layer3Strength),t.layer3Enabled&&(t.layer3Enabled.value=i.layer3Enabled),t.layer4Mode&&(t.layer4Mode.value=i.layer4Mode),t.layer4Strength&&(t.layer4Strength.value=i.layer4Strength),t.layer4Enabled&&(t.layer4Enabled.value=i.layer4Enabled),t.glowIntensity&&(t.glowIntensity.value=i.glowIntensity),t.opacity&&(t.opacity.value=i.opacity),t.time&&(t.time.value=i.time)}(t)}}(e,this.customMaterial),this.geometry=this._targetGeometry,this.geometryType=this._targetGeometryType,this.geometryConfig=this._targetGeometryConfig,this.customMaterial&&($d(this.customMaterial),this.renderer.disposeMaterial(this.customMaterial),this.customMaterial=null,this.customMaterialType=null);let t=null;const i=Ii(this.emotion),a=this._targetGeometryType,n=e=>{this.shatterSystem&&this.renderer?.coreMesh&&this.shatterSystem.precomputeShards(this.renderer.coreMesh,a)},s=Wd(this._targetGeometryType,this._targetGeometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:i,assetBasePath:this.assetBasePath,onTextureReady:n});if(s&&(t=s.material,this.customMaterial=t,this.customMaterialType=s.type),t)this.renderer.swapGeometry(this.geometry,t);else{this.renderer.swapGeometry(this.geometry);const e=!0===this._targetGeometryConfig.defaultGlassMode;this.setGlassMaterialEnabled(e)}this.onMaterialSwap&&this.onMaterialSwap({geometryType:this._targetGeometryType,material:this.customMaterial,materialType:this.customMaterialType}),this.blinkAnimator.setGeometry(this._targetGeometryConfig),this.rotation=[0,0,0];const r=this.geometry.parameters?.radius||.5;this.effectManager.initializeForGeometry(this._targetGeometryType,{coreMesh:this.renderer.coreMesh,customMaterial:this.customMaterial,sunRadius:r}),this.shatterSystem&&this.renderer?.coreMesh&&this.shatterSystem.precomputeShards(this.renderer.coreMesh,this._targetGeometryType),"crystal"===this._targetGeometryType||"rough"===this._targetGeometryType||"heart"===this._targetGeometryType||"star"===this._targetGeometryType?"crystal"===this.customMaterialType&&this.createCrystalInnerCore():this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null,this.crystalInnerCore=null,this.crystalInnerCoreMaterial=null);let o=null;if("moon"===this._targetGeometryType&&Qt.enabled){const e=Math.PI/180;o={enabled:!0,strength:Qt.strength,lockedFace:Qt.lockedFace,lerpSpeed:Qt.lerpSpeed,calibrationRotation:[$t*e,Yt*e,Xt*e]}}if(this.behaviorController.configureForMorph({targetGeometryType:this._targetGeometryType,emotionData:i,facingConfig:o,geometryRotation:null}),"moon"===this._targetGeometryType){this.renderer?.controls&&(this.renderer.controls.autoRotate=!1),this.renderer?.setCameraPreset&&this.renderer.setCameraPreset("front",0,!0);const e=Math.PI/180;this.calibrationRotation[0]=$t*e,this.calibrationRotation[1]=Yt*e,this.calibrationRotation[2]=Xt*e}else if(this.renderer?.controls&&!1!==this.options.autoRotate&&(this.renderer.controls.autoRotate=!0),"crystal"===this._targetGeometryType||"rough"===this._targetGeometryType||"heart"===this._targetGeometryType){const e=Math.PI/180;this.calibrationRotation[0]=0*e,this.calibrationRotation[1]=30*e,this.calibrationRotation[2]=0*e}else this.calibrationRotation[0]=0,this.calibrationRotation[1]=0,this.calibrationRotation[2]=0}i.completed&&(this._targetGeometry=null,this._targetGeometryType=null,this._targetGeometryConfig=null,this.blinkingManuallyDisabled||this.blinkAnimator.resume()),jf.start("breathing"),this.breathingAnimator.update(t,this.emotion,Ui(this.undertone)),jf.end("breathing");const a=this._updateBreathingPhase(t),n=1!==a?a:this.breathingEnabled?this.breathingAnimator.getBreathingScale():1,s=i.scaleMultiplier,r=this.blinkAnimator.update(t);jf.start("behaviorController");const o=this._pendingFreezeRotation||0,l=this._pendingFreezeWobble||0;if(o>0){const e=t*(1-o);this.behaviorController.update(e,this.baseEuler)}else this.behaviorController.update(t,this.baseEuler);jf.end("behaviorController"),l>.5&&this.wobbleEnabled?(this.behaviorController.setWobbleEnabled(!1),this._wobbleWasFrozen=!0):this._wobbleWasFrozen&&l<.5&&(this.behaviorController.setWobbleEnabled(this.wobbleEnabled),this._wobbleWasFrozen=!1);this.baseEuler[0]=Math.max(-.35,Math.min(.35,this.baseEuler[0])),this.baseEuler[2]=Math.max(-.35,Math.min(.35,this.baseEuler[2])),this.tempEuler.set(this.baseEuler[0],this.baseEuler[1],this.baseEuler[2],"XYZ"),this.baseQuaternion.setFromEuler(this.tempEuler),jf.start("rhythmAdapter"),this.rhythm3DAdapter&&this.rhythm3DAdapter.update(t),jf.end("rhythmAdapter"),jf.start("gestureBlend");const c=this.animationManager.blend(this.baseEuler,this.baseScale,this.baseGlowIntensity);jf.end("gestureBlend");const h=this.rhythm3DAdapter?.isPlaying()?this.rhythm3DAdapter.getModulation():null,u=c.hasAbsoluteGestures;void 0===this._grooveBlendCurrent&&(this._grooveBlendCurrent=1),void 0===this._smoothedBoost&&(this._smoothedBoost={position:[0,0,0],rotation:[0,0,0],scale:1});const d=(u?.3:1)*(1-(c.freezeGroove||0)),m=t/1e3,p=1-Math.exp(-12*m);this._grooveBlendCurrent+=(d-this._grooveBlendCurrent)*p;const g=this._grooveBlendCurrent,f=c.positionBoost||[0,0,0],y=c.rotationBoost||[0,0,0],v=c.scaleBoost||1;for(let e=0;e<3;e++)this._smoothedBoost.position[e]+=(f[e]-this._smoothedBoost.position[e])*p,this._smoothedBoost.rotation[e]+=(y[e]-this._smoothedBoost.rotation[e])*p;this._smoothedBoost.scale+=(v-this._smoothedBoost.scale)*p;const b=this._smoothedBoost.position,w=this._smoothedBoost.rotation,M=this._smoothedBoost.scale;let S=0,x=0,C=0;if(this._cameraRoll=0,c.hasCameraRelativeGestures&&this.renderer.camera){const t=this.renderer.camera,i=c.cameraRelativePosition;this._camTempVec3||(this._camTempVec3=new e.Vector3,this._camRight=new e.Vector3,this._camUp=new e.Vector3,this._camForward=new e.Vector3),t.updateMatrixWorld(),t.getWorldDirection(this._camForward),this._camRight.setFromMatrixColumn(t.matrixWorld,0),this._camUp.setFromMatrixColumn(t.matrixWorld,1),S=this._camRight.x*i[0]+this._camUp.x*i[1]-this._camForward.x*i[2],x=this._camRight.y*i[0]+this._camUp.y*i[1]-this._camForward.y*i[2],C=this._camRight.z*i[0]+this._camUp.z*i[1]-this._camForward.z*i[2];const a=c.cameraRelativeRotation;a&&0!==a[2]?this._cameraRoll=a[2]:this._cameraRoll=0}if(h){const e=h.grooveOffset[0]*g,t=h.grooveOffset[1]*g,i=h.grooveOffset[2]*g,a=u?h.positionMultiplier:1;this.position=[c.position[0]*a+S+e+b[0],c.position[1]*a+x+t+b[1],c.position[2]*a+C+i+b[2]],this.rotation=[c.rotation[0]+h.grooveRotation[0]*g+w[0],c.rotation[1]+h.grooveRotation[1]*g+w[1],c.rotation[2]+h.grooveRotation[2]*g+w[2]];const n=1+(h.grooveScale-1)*g,s=u?h.scaleMultiplier:1;if(this.scale=c.scale*n*s*M,c.nonUniformScale){const e=n*s*M;this.nonUniformScale=[c.nonUniformScale[0]*e,c.nonUniformScale[1]*e,c.nonUniformScale[2]*e]}else this.nonUniformScale=null}else this.position=[c.position[0]+S+b[0],c.position[1]+x+b[1],c.position[2]+C+b[2]],this.rotation=[c.rotation[0]+w[0],c.rotation[1]+w[1],c.rotation[2]+w[2]],this.scale=c.scale*M,c.nonUniformScale?this.nonUniformScale=[c.nonUniformScale[0]*M,c.nonUniformScale[1]*M,c.nonUniformScale[2]*M]:this.nonUniformScale=null;if(null===this.glowIntensityOverride)if(h){const e=1+(h.grooveGlow-1)*g,t=u?h.glowMultiplier:1;this.glowIntensity=c.glowIntensity*e*t}else this.glowIntensity=c.glowIntensity;if(this.gestureQuaternion=c.gestureQuaternion,this.glowBoost=c.glowBoost||0,c.glowColorOverride?(this._originalGlowColor||(this._originalGlowColor=[...this.glowColor]),this.glowColor=[...c.glowColorOverride]):this._originalGlowColor&&(this.glowColor=[...this._originalGlowColor],this._originalGlowColor=null),c.electricOverlay&&c.electricOverlay.enabled){const t=this.renderer?.coreMesh,i=this.renderer?.scene;if(t&&i){this._electricOverlayMesh||(this._electricMaterial=ip({charge:Math.min(1,c.electricOverlay.charge),opacity:.7}),this._electricOverlayMesh=new e.Mesh(t.geometry,this._electricMaterial),this._electricOverlayMesh.scale.setScalar(1.02),t.add(this._electricOverlayMesh),this._electricOverlayMesh.renderOrder=t.renderOrder+1);const{spawnMode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,duration:l}=c.electricOverlay;if(i&&"none"!==i&&this.elementSpawner){const e=`electricity:${Array.isArray(i)?`layers:${i.length}:${i.map(e=>e.type).join(",")}`:"object"==typeof i?i.type:String(i)}:${l}:${a?.type||"default"}`;this._electricSpawnedSignatures=this._electricSpawnedSignatures||new Set,this._electricSpawnedSignatures.has(e)||(this.elementSpawner.triggerExit("electricity"),this.elementSpawner.spawn("electricity",{intensity:c.electricOverlay.strength||.8,mode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,gestureDuration:l||2e3}),this._electricSpawnedSignatures.add(e),this._electricSpawnSignature=e)}this._electricMaterial?.uniforms?.uTime&&(this._electricMaterial.uniforms.uTime.value=c.electricOverlay.time),this._electricMaterial?.uniforms?.uCharge&&(this._electricMaterial.uniforms.uCharge.value=Math.min(1,c.electricOverlay.charge)),this._currentElectricProgress=c.electricOverlay.progress??null}}else if(this._electricOverlayMesh){const e=this.renderer?.coreMesh;e&&this._electricOverlayMesh.parent&&e.remove(this._electricOverlayMesh),this._electricMaterial&&(this._electricMaterial.dispose(),this._electricMaterial=null),this._electricOverlayMesh=null,this.elementSpawner&&this.elementSpawner.triggerExit("electricity"),this._electricSpawnSignature=null,this._electricSpawnedSignatures=null,this._currentElectricProgress=null}if(c.waterOverlay&&c.waterOverlay.enabled){const t=this.renderer?.coreMesh,i=this.renderer?.scene;if(t&&i){this._waterOverlayMesh||(this._waterMaterial=Xm({viscosity:.3,opacity:.5,overlay:!0}),this._waterOverlayMesh=new e.Mesh(t.geometry,this._waterMaterial),this._waterOverlayMesh.scale.setScalar(1.01),t.add(this._waterOverlayMesh),this._waterOverlayMesh.renderOrder=t.renderOrder+1);const{spawnMode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,duration:l}=c.waterOverlay;if(i&&"none"!==i&&this.elementSpawner){const e=`water:${i}:${l}:${a?.type||"default"}`;this._spawnedSignatures=this._spawnedSignatures||new Set,this._spawnedSignatures.has(e)||(this.elementSpawner.triggerExit(),this.elementSpawner.spawn("water",{intensity:c.waterOverlay.strength||.8,mode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,gestureDuration:l||1500}),this._spawnedSignatures.add(e),this._elementSpawnSignature=e)}this._waterMaterial?.uniforms?.uTime&&(this._waterMaterial.uniforms.uTime.value=c.waterOverlay.time),this._waterMaterial?.uniforms?.uOpacity&&(this._waterMaterial.uniforms.uOpacity.value=Math.min(.8,c.waterOverlay.wetness)),this._currentWaterProgress=c.waterOverlay.progress??null}}else if(this._waterOverlayMesh){const e=this.renderer?.coreMesh;e&&this._waterOverlayMesh.parent&&e.remove(this._waterOverlayMesh),this._waterMaterial&&(this._waterMaterial.dispose(),this._waterMaterial=null),this._waterOverlayMesh=null,this.elementSpawner&&this.elementSpawner.triggerExit("water"),this._elementSpawnSignature=null,this._spawnedSignatures=null,this._currentWaterProgress=null}if(c.fireOverlay&&c.fireOverlay.enabled){const t=this.renderer?.coreMesh,i=this.renderer?.scene;if(t&&i){this._fireOverlayMesh||(this._fireMaterial=Hm({temperature:c.fireOverlay.temperature||.5,opacity:.6,overlay:!0}),this._fireOverlayMesh=new e.Mesh(t.geometry,this._fireMaterial),this._fireOverlayMesh.scale.setScalar(1.02),t.add(this._fireOverlayMesh),this._fireOverlayMesh.renderOrder=t.renderOrder+2);const{spawnMode:i,animation:a,models:n,count:s,scale:r,embedDepth:o}=c.fireOverlay;if(i&&"none"!==i&&this.elementSpawner){const e=`fire:${Array.isArray(i)?`layers:${i.length}:${i.map(e=>e.type).join(",")}`:String(i)}:${c.fireOverlay.duration}:${a?.type||"default"}`;this._spawnedSignatures=this._spawnedSignatures||new Set,this._spawnedSignatures.has(e)||(this.elementSpawner.triggerExit(),this.elementSpawner.spawn("fire",{intensity:c.fireOverlay.strength||.8,mode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,gestureDuration:c.fireOverlay.duration||2e3}),this._spawnedSignatures.add(e),this._elementSpawnSignature=e)}if(this._fireMaterial?.uniforms?.uTime&&(this._fireMaterial.uniforms.uTime.value=c.fireOverlay.time),this._fireMaterial?.uniforms?.uIntensity){const e=this._fireMaterial.uniforms.uIntensity.value;this._fireMaterial.uniforms.uIntensity.value=e*(.5+.5*c.fireOverlay.heat)}this._currentFireProgress=c.fireOverlay.progress??null}}else if(this._fireOverlayMesh){const e=this.renderer?.coreMesh;e&&this._fireOverlayMesh.parent&&e.remove(this._fireOverlayMesh),this._fireMaterial&&(this._fireMaterial.dispose(),this._fireMaterial=null),this._fireOverlayMesh=null,this.elementSpawner&&this.elementSpawner.triggerExit("fire"),this._elementSpawnSignature=null,this._spawnedSignatures=null,this._currentFireProgress=null}if(c.smokeOverlay&&c.smokeOverlay.enabled){const e=this.renderer?.coreMesh;if(e){const t=c.smokeOverlay.category||"emanating";this._smokeParticleSystem&&this._smokeMaterialCategory===t||(this._smokeParticleSystem&&this._smokeParticleSystem.dispose(),this._smokeParticleSystem=new yp({maxParticles:80,category:t,tint:c.smokeOverlay.tint||[1,1,1],density:c.smokeOverlay.density||.5,swirl:c.smokeOverlay.swirl||0}),this._smokeMaterialCategory=t,this._smokeParticleSystem.attachTo(e));const i=this._lastDeltaTime||.016;this._smokeParticleSystem.update(i,{thickness:c.smokeOverlay.thickness,category:t,tint:c.smokeOverlay.tint,density:c.smokeOverlay.density,swirl:c.smokeOverlay.swirl})}}else this._smokeParticleSystem&&(this._smokeParticleSystem.dispose(),this._smokeParticleSystem=null,this._smokeMaterialCategory=null);if(c.voidOverlay&&c.voidOverlay.enabled){const t=this.renderer?.coreMesh,i=this.renderer?.scene;if(t&&i){if(!this._voidOverlayMesh){this._voidMaterial=np({depth:c.voidOverlay.depth||.7,innerPattern:"swirl",opacity:.95}),this._voidOverlayMesh=new e.Mesh(t.geometry,this._voidMaterial),this._voidOverlayMesh.scale.setScalar(1.06),t.add(this._voidOverlayMesh),this._voidOverlayMesh.renderOrder=t.renderOrder+3;const{spawnMode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,duration:l}=c.voidOverlay;i&&"none"!==i&&this.elementSpawner&&!this.elementSpawner.hasElements("void")&&this.elementSpawner.spawn("void",{intensity:c.voidOverlay.strength||.8,mode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,gestureDuration:l||2e3})}if(this._voidMaterial?.uniforms?.uTime&&(this._voidMaterial.uniforms.uTime.value=c.voidOverlay.time),this._voidMaterial?.uniforms?.uDepth){const e=Math.min(1,(c.voidOverlay.depth||.5)+.2);this._voidMaterial.uniforms.uDepth.value=e}this._voidMaterial?.uniforms?.uOpacity&&(this._voidMaterial.uniforms.uOpacity.value=Math.min(.95,c.voidOverlay.strength)),this._currentVoidProgress=c.voidOverlay.progress??null}}else if(this._voidOverlayMesh){const e=this.renderer?.coreMesh;e&&this._voidOverlayMesh.parent&&e.remove(this._voidOverlayMesh),this._voidMaterial&&(this._voidMaterial.dispose(),this._voidMaterial=null),this._voidOverlayMesh=null,this.elementSpawner&&this.elementSpawner.despawn("void"),this._currentVoidProgress=null}if(c.iceOverlay&&c.iceOverlay.enabled){const t=this.renderer?.coreMesh,i=this.renderer?.scene;if(t&&i){this._iceOverlayMesh||(this._iceMaterial=Jm({opacity:.5,overlay:!0}),this._iceOverlayMesh=new e.Mesh(t.geometry,this._iceMaterial),this._iceOverlayMesh.scale.setScalar(1.01),t.add(this._iceOverlayMesh),this._iceOverlayMesh.renderOrder=t.renderOrder+1);const{spawnMode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,duration:l}=c.iceOverlay;if(i&&"none"!==i&&this.elementSpawner){const e=`ice:${Array.isArray(i)?`layers:${i.length}:${i.map(e=>e.type).join(",")}`:"object"==typeof i?i.type:String(i)}:${l}:${a?.type||"default"}`;this._iceSpawnedSignatures=this._iceSpawnedSignatures||new Set,this._iceSpawnedSignatures.has(e)||(this.elementSpawner.triggerExit("ice"),this.elementSpawner.spawn("ice",{intensity:c.iceOverlay.strength||.8,mode:i,animation:a,models:n,count:s,scale:r,embedDepth:o,gestureDuration:l||2e3}),this._iceSpawnedSignatures.add(e),this._iceSpawnSignature=e)}this._iceMaterial?.uniforms?.uTime&&(this._iceMaterial.uniforms.uTime.value=c.iceOverlay.time),this._iceMaterial?.uniforms?.uFrost&&(this._iceMaterial.uniforms.uFrost.value=c.iceOverlay.frost||.7),this._iceMaterial?.uniforms?.uOpacity&&(this._iceMaterial.uniforms.uOpacity.value=Math.min(.8,c.iceOverlay.strength));const h=c.iceOverlay.strength||.8,u=t.material;if(u){this._iceOriginalMaterial||(this._iceOriginalMaterial={},u.uniforms&&(u.uniforms.glowColor&&(this._iceOriginalMaterial.glowColor=u.uniforms.glowColor.value.clone()),u.uniforms.coreColor&&(this._iceOriginalMaterial.coreColor=u.uniforms.coreColor.value.clone()),u.uniforms.glowIntensity&&(this._iceOriginalMaterial.glowIntensity=u.uniforms.glowIntensity.value)),u.emissive&&(this._iceOriginalMaterial.emissive=u.emissive.clone(),this._iceOriginalMaterial.emissiveIntensity=u.emissiveIntensity),u.color&&(this._iceOriginalMaterial.color=u.color.clone()));const t=this._iceTintColor||(this._iceTintColor=new e.Color(.3,.5,.8)),i=this._iceOriginalMaterial;u.uniforms&&(u.uniforms.glowColor&&i.glowColor&&u.uniforms.glowColor.value.copy(i.glowColor).lerp(t,.3*h),u.uniforms.coreColor&&i.coreColor&&u.uniforms.coreColor.value.copy(i.coreColor).lerp(t,.4*h)),u.emissive&&i.emissive&&(u.emissive.copy(i.emissive).lerp(t,.3*h),u.emissiveIntensity=Math.max(i.emissiveIntensity,.3*h)),u.color&&!u.uniforms&&i.color&&u.color.copy(i.color).lerp(t,.2*h)}this._currentIceProgress=c.iceOverlay.progress??null}}else if(this._iceOverlayMesh){const e=this.renderer?.coreMesh;if(e&&this._iceOverlayMesh.parent&&e.remove(this._iceOverlayMesh),this._iceMaterial&&(this._iceMaterial.dispose(),this._iceMaterial=null),this._iceOverlayMesh=null,this._iceOriginalMaterial&&e?.material){const t=e.material,i=this._iceOriginalMaterial;t.uniforms&&(i.glowColor&&t.uniforms.glowColor&&t.uniforms.glowColor.value.copy(i.glowColor),i.coreColor&&t.uniforms.coreColor&&t.uniforms.coreColor.value.copy(i.coreColor),void 0!==i.glowIntensity&&t.uniforms.glowIntensity&&(t.uniforms.glowIntensity.value=i.glowIntensity)),i.emissive&&t.emissive&&(t.emissive.copy(i.emissive),t.emissiveIntensity=i.emissiveIntensity),i.color&&t.color&&!t.uniforms&&t.color.copy(i.color)}this._iceOriginalMaterial=null,this.elementSpawner&&this.elementSpawner.triggerExit("ice"),this._iceSpawnSignature=null,this._iceSpawnedSignatures=null,this._currentIceProgress=null}if(c.lightOverlay&&c.lightOverlay.enabled){const t=this.renderer?.coreMesh,i=this.renderer?.scene;if(t&&i){if(!this._lightOverlayMesh){this._lightMaterial=function(t={}){const{radiance:i=.5,hue:a="golden",opacity:n=.8}=t,s=mp(.4,1.5,i),r=Math.floor(mp(4,12,i)),o=mp(.2,.8,i),l=mp(1,3,i),c=mp(.5,1,i),h=mp(.2,.8,i),u={golden:0,white:1,prismatic:2}[a]||0,d=new e.ShaderMaterial({uniforms:{uRadiance:{value:i},uBrightness:{value:s},uRayCount:{value:r},uRayLength:{value:o},uPulseSpeed:{value:l},uCoreIntensity:{value:c},uBloomStrength:{value:h},uHueType:{value:u},uOpacity:{value:n},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n                vUv = uv;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uRadiance;\n            uniform float uBrightness;\n            uniform float uRayCount;\n            uniform float uRayLength;\n            uniform float uPulseSpeed;\n            uniform float uCoreIntensity;\n            uniform float uBloomStrength;\n            uniform int uHueType;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            // Hash function\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            // Soft noise\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            // Light rays pattern\n            float rays(vec2 uv, float count, float time) {\n                vec2 centered = uv - 0.5;\n                float angle = atan(centered.y, centered.x);\n                float dist = length(centered);\n\n                // Rotating rays\n                float rayAngle = angle + time * 0.2;\n                float ray = sin(rayAngle * count) * 0.5 + 0.5;\n                ray = pow(ray, 3.0);\n\n                // Fade rays with distance\n                float rayFade = smoothstep(0.5, 0.1, dist);\n\n                return ray * rayFade;\n            }\n\n            // Sparkle effect\n            float sparkle(vec2 uv, float time) {\n                float n = noise(uv * 20.0 + time);\n                return pow(n, 8.0) * 2.0;\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n\n                vec2 centeredUv = vUv * 2.0 - 1.0;\n                float distFromCenter = length(centeredUv);\n\n                // === BASE LIGHT COLOR ===\n                vec3 lightColor;\n                if (uHueType == 0) {\n                    // Golden - warm divine light\n                    lightColor = vec3(1.0, 0.85, 0.4);\n                } else if (uHueType == 1) {\n                    // White - pure holy light\n                    lightColor = vec3(1.0, 0.98, 0.95);\n                } else {\n                    // Prismatic - rainbow shifting\n                    float hueShift = uTime * 0.5 + distFromCenter * 2.0;\n                    lightColor = vec3(\n                        sin(hueShift) * 0.3 + 0.7,\n                        sin(hueShift + 2.094) * 0.3 + 0.7,\n                        sin(hueShift + 4.189) * 0.3 + 0.7\n                    );\n                }\n\n                // === CORE GLOW ===\n                float coreGlow = 1.0 - smoothstep(0.0, 0.5, distFromCenter);\n                coreGlow = pow(coreGlow, 1.5) * uCoreIntensity;\n\n                // === LIGHT RAYS ===\n                float rayPattern = rays(vUv, uRayCount, uTime);\n                float rayMask = smoothstep(0.0, uRayLength, distFromCenter) *\n                               (1.0 - smoothstep(uRayLength, uRayLength + 0.3, distFromCenter));\n                float lightRays = rayPattern * rayMask * uRadiance;\n\n                // === PULSE EFFECT ===\n                float pulse = sin(uTime * uPulseSpeed) * 0.15 + 1.0;\n\n                // === BLOOM/HALO ===\n                float bloom = 1.0 - smoothstep(0.3, 0.9, distFromCenter);\n                bloom = pow(bloom, 2.0) * uBloomStrength;\n\n                // === SPARKLES ===\n                float sparkles = sparkle(vUv, uTime) * uRadiance * 0.5;\n\n                // === FRESNEL RIM ===\n                float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 2.0);\n\n                // === COMBINE ===\n                float intensity = (coreGlow + lightRays + bloom + sparkles) * pulse * uBrightness;\n                intensity += fresnel * 0.3 * uRadiance;\n\n                vec3 finalColor = lightColor * intensity;\n\n                // Additive bloom effect - brighten beyond 1.0\n                finalColor = min(finalColor * 1.5, vec3(2.0));\n\n                // Alpha - light is semi-transparent but additive\n                float alpha = uOpacity * min(1.0, intensity);\n                alpha = max(alpha, coreGlow * 0.5);\n\n                // Edge softness\n                float edgeFade = 1.0 - smoothstep(0.8, 1.0, distFromCenter);\n                alpha *= edgeFade;\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(finalColor, alpha);\n            }\n        ",transparent:!0,blending:e.NormalBlending,depthWrite:!1,side:e.DoubleSide});return d.userData.radiance=i,d.userData.hue=a,d.userData.elementalType="light",d}({radiance:c.lightOverlay.radiance||.7,hue:"golden",opacity:.35}),this._lightOverlayMesh=new e.Mesh(t.geometry,this._lightMaterial),this._lightOverlayMesh.scale.setScalar(1.04),t.add(this._lightOverlayMesh),this._lightOverlayMesh.renderOrder=t.renderOrder+3;const{spawnMode:i}=c.lightOverlay;i&&"none"!==i&&this.elementSpawner&&!this.elementSpawner.hasElements("light")&&this.elementSpawner.spawn("light",{intensity:c.lightOverlay.strength||.8,mode:i})}this._lightMaterial?.uniforms?.uTime&&(this._lightMaterial.uniforms.uTime.value=c.lightOverlay.time),this._lightMaterial?.uniforms?.uRadiance&&(this._lightMaterial.uniforms.uRadiance.value=c.lightOverlay.radiance||.7),this._lightMaterial?.uniforms?.uOpacity&&(this._lightMaterial.uniforms.uOpacity.value=Math.min(.35,c.lightOverlay.strength))}}else if(this._lightOverlayMesh){const e=this.renderer?.coreMesh;e&&this._lightOverlayMesh.parent&&e.remove(this._lightOverlayMesh),this._lightMaterial&&(this._lightMaterial.dispose(),this._lightMaterial=null),this._lightOverlayMesh=null,this.elementSpawner&&this.elementSpawner.despawn("light")}if(c.poisonOverlay&&c.poisonOverlay.enabled){const t=this.renderer?.coreMesh,i=this.renderer?.scene;t&&i&&(this._poisonOverlayMesh||(this._poisonMaterial=function(t={}){const{toxicity:i=.5,opacity:a=.85}=t,n=Math.floor(pp(5,30,i)),s=pp(.5,2,i),r=pp(.3,1.5,i),o=pp(.1,.6,i),l=pp(.2,.8,i),c=new e.ShaderMaterial({uniforms:{uToxicity:{value:i},uBubbleCount:{value:n},uBubbleSpeed:{value:s},uDripSpeed:{value:r},uCorrosionStrength:{value:o},uGlowIntensity:{value:l},uOpacity:{value:a},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n                vUv = uv;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uToxicity;\n            uniform float uBubbleCount;\n            uniform float uBubbleSpeed;\n            uniform float uDripSpeed;\n            uniform float uCorrosionStrength;\n            uniform float uGlowIntensity;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            // Hash\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            // Noise\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            // FBM for organic patterns\n            float fbm(vec2 p) {\n                float value = 0.0;\n                float amp = 0.5;\n                for (int i = 0; i < 4; i++) {\n                    value += amp * noise(p);\n                    p *= 2.0;\n                    amp *= 0.5;\n                }\n                return value;\n            }\n\n            // Bubbles\n            float bubbles(vec2 uv, float count, float time) {\n                float bubblePattern = 0.0;\n                for (float i = 0.0; i < 30.0; i++) {\n                    if (i >= count) break;\n\n                    vec2 bubblePos = vec2(\n                        hash(vec2(i * 17.3, 0.0)),\n                        fract(hash(vec2(0.0, i * 23.7)) + time * uBubbleSpeed * (0.5 + hash(vec2(i, i)) * 0.5))\n                    );\n\n                    float bubbleSize = 0.02 + hash(vec2(i * 7.1, i * 3.3)) * 0.03;\n                    float dist = length(uv - bubblePos);\n                    float bubble = smoothstep(bubbleSize, bubbleSize * 0.3, dist);\n\n                    bubblePattern += bubble * (0.5 + hash(vec2(i, 0.0)) * 0.5);\n                }\n                return min(bubblePattern, 1.0);\n            }\n\n            // Drip pattern\n            float drips(vec2 uv, float time) {\n                float dripPattern = 0.0;\n\n                for (float i = 0.0; i < 8.0; i++) {\n                    float xPos = hash(vec2(i * 13.7, 0.0));\n                    float speed = 0.3 + hash(vec2(i, i * 2.0)) * 0.4;\n                    float yPos = fract(time * speed * uDripSpeed + hash(vec2(0.0, i * 19.3)));\n\n                    // Drip shape - elongated teardrop\n                    vec2 dripCenter = vec2(xPos, 1.0 - yPos);\n                    vec2 diff = uv - dripCenter;\n                    diff.y *= 0.3; // Elongate vertically\n\n                    float dist = length(diff);\n                    float drip = smoothstep(0.04, 0.01, dist);\n\n                    // Trail behind drip\n                    if (uv.y > dripCenter.y && abs(uv.x - xPos) < 0.01) {\n                        float trail = smoothstep(0.2, 0.0, uv.y - dripCenter.y);\n                        drip = max(drip, trail * 0.5);\n                    }\n\n                    dripPattern += drip;\n                }\n                return min(dripPattern, 1.0);\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n\n                vec2 centeredUv = vUv * 2.0 - 1.0;\n                float distFromCenter = length(centeredUv);\n\n                // === POISON COLORS ===\n                vec3 lightPoison = vec3(0.4, 0.9, 0.2);   // Bright sickly green\n                vec3 darkPoison = vec3(0.1, 0.4, 0.0);    // Deep toxic green\n                vec3 acidYellow = vec3(0.7, 0.8, 0.0);    // Acid highlight\n\n                // === ORGANIC NOISE BASE ===\n                float organicNoise = fbm(vUv * 5.0 + uTime * 0.1);\n\n                // === BUBBLES ===\n                float bubblePattern = bubbles(vUv, uBubbleCount, uTime);\n\n                // === DRIPS ===\n                float dripPattern = drips(vUv, uTime) * uToxicity;\n\n                // === CORROSION PATTERN ===\n                float corrosion = fbm(vUv * 10.0 + uTime * 0.05);\n                corrosion = smoothstep(0.4, 0.6, corrosion) * uCorrosionStrength;\n\n                // === COLOR MIXING ===\n                vec3 poisonColor = mix(darkPoison, lightPoison, organicNoise);\n\n                // Add acid highlights on bubbles\n                poisonColor = mix(poisonColor, acidYellow, bubblePattern * 0.6);\n\n                // Drips are brighter\n                poisonColor = mix(poisonColor, lightPoison * 1.3, dripPattern * 0.5);\n\n                // Corrosion darkens\n                poisonColor *= (1.0 - corrosion * 0.4);\n\n                // === GLOW ===\n                float glow = (bubblePattern + dripPattern * 0.5) * uGlowIntensity;\n                poisonColor += vec3(0.2, 0.5, 0.0) * glow;\n\n                // === FRESNEL ===\n                float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 2.0);\n                poisonColor += lightPoison * fresnel * 0.3;\n\n                // === ALPHA ===\n                float alpha = uOpacity;\n                alpha *= (0.7 + organicNoise * 0.3);\n                alpha = max(alpha, bubblePattern * 0.8);\n                alpha = max(alpha, dripPattern * 0.9);\n\n                // Edge fade\n                float edgeFade = 1.0 - smoothstep(0.85, 1.0, distFromCenter);\n                alpha *= edgeFade;\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(poisonColor, alpha);\n            }\n        ",transparent:!0,blending:e.NormalBlending,depthWrite:!1,side:e.DoubleSide});return c.userData.toxicity=i,c.userData.elementalType="poison",c}({toxicity:c.poisonOverlay.toxicity||.7,opacity:.4}),this._poisonOverlayMesh=new e.Mesh(t.geometry,this._poisonMaterial),this._poisonOverlayMesh.scale.setScalar(1.03),t.add(this._poisonOverlayMesh),this._poisonOverlayMesh.renderOrder=t.renderOrder+3),this._poisonMaterial?.uniforms?.uTime&&(this._poisonMaterial.uniforms.uTime.value=c.poisonOverlay.time),this._poisonMaterial?.uniforms?.uToxicity&&(this._poisonMaterial.uniforms.uToxicity.value=c.poisonOverlay.toxicity||.7),this._poisonMaterial?.uniforms?.uOpacity&&(this._poisonMaterial.uniforms.uOpacity.value=Math.min(.4,c.poisonOverlay.strength)))}else if(this._poisonOverlayMesh){const e=this.renderer?.coreMesh;e&&this._poisonOverlayMesh.parent&&e.remove(this._poisonOverlayMesh),this._poisonMaterial&&(this._poisonMaterial.dispose(),this._poisonMaterial=null),this._poisonOverlayMesh=null}if(c.earthOverlay&&c.earthOverlay.enabled){const t=this.renderer?.coreMesh,i=this.renderer?.scene;if(t&&i){if(!this._earthOverlayMesh){this._earthMaterial=function(t={}){const{petrification:i=.5,opacity:a=.9}=t,n=gp(.2,1,i),s=gp(.1,.5,i),r=gp(.4,0,i),o=gp(.3,0,i),l=gp(.6,.9,i),c=new e.ShaderMaterial({uniforms:{uPetrification:{value:i},uRockiness:{value:n},uCrackDepth:{value:s},uCrumbleAmount:{value:r},uMossAmount:{value:o},uRoughness:{value:l},uOpacity:{value:a},uTime:{value:0}},vertexShader:"\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            void main() {\n                vPosition = position;\n                vNormal = normalMatrix * normal;\n                vUv = uv;\n\n                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                vViewPosition = -mvPosition.xyz;\n\n                gl_Position = projectionMatrix * mvPosition;\n            }\n        ",fragmentShader:"\n            uniform float uPetrification;\n            uniform float uRockiness;\n            uniform float uCrackDepth;\n            uniform float uCrumbleAmount;\n            uniform float uMossAmount;\n            uniform float uRoughness;\n            uniform float uOpacity;\n            uniform float uTime;\n\n            varying vec3 vPosition;\n            varying vec3 vNormal;\n            varying vec3 vViewPosition;\n            varying vec2 vUv;\n\n            // Hash\n            float hash(vec2 p) {\n                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n            }\n\n            float hash3(vec3 p) {\n                p = fract(p * 0.3183099 + 0.1);\n                p *= 17.0;\n                return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n            }\n\n            // 3D noise for rocky texture\n            float noise3D(vec3 p) {\n                vec3 i = floor(p);\n                vec3 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n\n                return mix(\n                    mix(mix(hash3(i), hash3(i + vec3(1,0,0)), f.x),\n                        mix(hash3(i + vec3(0,1,0)), hash3(i + vec3(1,1,0)), f.x), f.y),\n                    mix(mix(hash3(i + vec3(0,0,1)), hash3(i + vec3(1,0,1)), f.x),\n                        mix(hash3(i + vec3(0,1,1)), hash3(i + vec3(1,1,1)), f.x), f.y),\n                    f.z\n                );\n            }\n\n            // 2D noise\n            float noise(vec2 p) {\n                vec2 i = floor(p);\n                vec2 f = fract(p);\n                f = f * f * (3.0 - 2.0 * f);\n                return mix(\n                    mix(hash(i), hash(i + vec2(1, 0)), f.x),\n                    mix(hash(i + vec2(0, 1)), hash(i + vec2(1, 1)), f.x),\n                    f.y\n                );\n            }\n\n            // FBM for rocky detail\n            float fbm(vec2 p) {\n                float value = 0.0;\n                float amp = 0.5;\n                for (int i = 0; i < 5; i++) {\n                    value += amp * noise(p);\n                    p *= 2.0;\n                    amp *= 0.5;\n                }\n                return value;\n            }\n\n            // Voronoi for cracks\n            vec2 voronoi(vec2 p) {\n                vec2 n = floor(p);\n                vec2 f = fract(p);\n\n                float minDist = 1.0;\n                float secondDist = 1.0;\n\n                for (int j = -1; j <= 1; j++) {\n                    for (int i = -1; i <= 1; i++) {\n                        vec2 neighbor = vec2(float(i), float(j));\n                        vec2 point = hash(n + neighbor) * vec2(0.8) + 0.1 + neighbor;\n                        float d = length(f - point);\n\n                        if (d < minDist) {\n                            secondDist = minDist;\n                            minDist = d;\n                        } else if (d < secondDist) {\n                            secondDist = d;\n                        }\n                    }\n                }\n\n                return vec2(minDist, secondDist - minDist);\n            }\n\n            void main() {\n                vec3 normal = normalize(vNormal);\n                vec3 viewDir = normalize(vViewPosition);\n\n                vec2 centeredUv = vUv * 2.0 - 1.0;\n                float distFromCenter = length(centeredUv);\n\n                // === EARTH COLORS ===\n                vec3 dirtColor = vec3(0.4, 0.3, 0.2);\n                vec3 stoneColor = vec3(0.5, 0.5, 0.45);\n                vec3 darkStone = vec3(0.3, 0.3, 0.28);\n                vec3 mossColor = vec3(0.2, 0.35, 0.15);\n\n                // === ROCKY TEXTURE ===\n                float rockTexture = fbm(vUv * 8.0);\n                float rockDetail = noise3D(vPosition * 10.0);\n\n                // === CRACK PATTERN ===\n                vec2 vor = voronoi(vUv * (6.0 + uPetrification * 4.0));\n                float cracks = smoothstep(0.0, 0.05 * (1.0 - uPetrification * 0.5), vor.y);\n\n                // === CRUMBLE EDGES ===\n                float crumbleNoise = fbm(vUv * 15.0 + uTime * 0.02);\n                float crumble = smoothstep(0.4, 0.6, crumbleNoise) * uCrumbleAmount;\n\n                // === MOSS PATCHES ===\n                float mossNoise = fbm(vUv * 4.0);\n                float moss = smoothstep(0.5, 0.7, mossNoise) * uMossAmount;\n\n                // === COLOR MIXING ===\n                // Base: mix dirt and stone based on petrification\n                vec3 earthColor = mix(dirtColor, stoneColor, uPetrification);\n\n                // Add rocky variation\n                earthColor = mix(earthColor, darkStone, rockTexture * 0.4 * uRockiness);\n                earthColor = mix(earthColor, stoneColor * 1.1, rockDetail * 0.3 * uRockiness);\n\n                // Darken cracks\n                earthColor *= mix(1.0, 0.6, (1.0 - cracks) * uCrackDepth);\n\n                // Add moss\n                earthColor = mix(earthColor, mossColor, moss);\n\n                // Crumbling areas are lighter (exposed)\n                earthColor = mix(earthColor, dirtColor * 1.2, crumble * 0.5);\n\n                // === LIGHTING ===\n                float diffuse = max(dot(normal, vec3(0.5, 1.0, 0.3)), 0.0);\n                earthColor *= (0.6 + diffuse * 0.4);\n\n                // Fresnel rim\n                float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);\n                earthColor += stoneColor * fresnel * 0.2 * uPetrification;\n\n                // === ALPHA ===\n                float alpha = uOpacity;\n\n                // Petrification spreads from edges\n                float spreadPattern = smoothstep(0.2, 0.8, distFromCenter + rockTexture * 0.3);\n                alpha *= mix(spreadPattern, 1.0, uPetrification);\n\n                // Crumble reduces alpha\n                alpha *= (1.0 - crumble * 0.5);\n\n                // Edge fade\n                float edgeFade = 1.0 - smoothstep(0.9, 1.0, distFromCenter);\n                alpha *= edgeFade;\n\n                if (alpha < 0.01) discard;\n\n                gl_FragColor = vec4(earthColor, alpha);\n            }\n        ",transparent:!0,blending:e.NormalBlending,depthWrite:!1,side:e.DoubleSide});return c.userData.petrification=i,c.userData.elementalType="earth",c}({petrification:c.earthOverlay.petrification||.7,opacity:.9}),this._earthOverlayMesh=new e.Mesh(t.geometry,this._earthMaterial),this._earthOverlayMesh.scale.setScalar(1.03),t.add(this._earthOverlayMesh),this._earthOverlayMesh.renderOrder=t.renderOrder+3;const{spawnMode:i}=c.earthOverlay;i&&"none"!==i&&this.elementSpawner&&!this.elementSpawner.hasElements("earth")&&this.elementSpawner.spawn("earth",{intensity:c.earthOverlay.strength||.8,mode:i})}this._earthMaterial?.uniforms?.uTime&&(this._earthMaterial.uniforms.uTime.value=c.earthOverlay.time),this._earthMaterial?.uniforms?.uPetrification&&(this._earthMaterial.uniforms.uPetrification.value=c.earthOverlay.petrification||.7),this._earthMaterial?.uniforms?.uOpacity&&(this._earthMaterial.uniforms.uOpacity.value=Math.min(.9,c.earthOverlay.strength))}}else if(this._earthOverlayMesh){const e=this.renderer?.coreMesh;e&&this._earthOverlayMesh.parent&&e.remove(this._earthOverlayMesh),this._earthMaterial&&(this._earthMaterial.dispose(),this._earthMaterial=null),this._earthOverlayMesh=null,this.elementSpawner&&this.elementSpawner.despawn("earth")}if(c.natureOverlay&&c.natureOverlay.enabled){const e=this.renderer?.coreMesh,t=this.renderer?.scene;if(e&&t&&!this._natureSpawnedThisGesture){this._natureSpawnedThisGesture=!0;const{spawnMode:e,animation:t,models:i,count:a,scale:n,embedDepth:s}=c.natureOverlay;e&&"none"!==e&&this.elementSpawner&&!this.elementSpawner.hasElements("nature")&&this.elementSpawner.spawn("nature",{intensity:c.natureOverlay.strength||.8,mode:e,animation:t,models:i,count:a,scale:n,embedDepth:s,gestureDuration:c.natureOverlay.duration||3e3}).catch(e=>{console.error("[Core3DManager] Nature spawn error:",e)})}}else this._natureSpawnedThisGesture&&(this._natureSpawnedThisGesture=!1,this.elementSpawner&&this.elementSpawner.despawn("nature"));if(void 0!==c.meshOpacity&&c.meshOpacity<1){const e=this.renderer?.coreMesh;e?.material&&(e.material.uniforms?.uOpacity?e.material.uniforms.uOpacity.value=c.meshOpacity:e.material.uniforms?.opacity?e.material.uniforms.opacity.value=c.meshOpacity:void 0!==e.material.opacity&&(void 0===this._originalMeshOpacity&&(this._originalMeshOpacity=e.material.opacity??1,this._originalMeshTransparent=e.material.transparent??!1),e.material.transparent=!0,e.material.opacity=c.meshOpacity,e.material.needsUpdate=!0))}else if(void 0===c.meshOpacity||c.meshOpacity>=1){const e=this.renderer?.coreMesh;e?.material&&(e.material.uniforms?.uOpacity?e.material.uniforms.uOpacity.value=1:e.material.uniforms?.opacity?e.material.uniforms.opacity.value=1:void 0!==this._originalMeshOpacity&&(e.material.opacity=this._originalMeshOpacity,e.material.transparent=this._originalMeshTransparent,e.material.needsUpdate=!0,this._originalMeshOpacity=void 0,this._originalMeshTransparent=void 0))}if(c.crackTriggers&&c.crackTriggers.length>0&&this.objectSpaceCrackManager){const t=this.renderer?.camera,i=this.renderer?.coreMesh;if(t&&i){t.updateMatrixWorld(),i.updateMatrixWorld(),this._crackCamRight||(this._crackCamRight=new e.Vector3,this._crackCamUp=new e.Vector3,this._crackCamForward=new e.Vector3,this._crackWorldPos=new e.Vector3,this._crackWorldDir=new e.Vector3,this._crackInvQuat=new e.Quaternion),t.getWorldDirection(this._crackCamForward),this._crackCamRight.crossVectors(this._crackCamForward,t.up).normalize(),this._crackCamUp.crossVectors(this._crackCamRight,this._crackCamForward).normalize(),i.getWorldQuaternion(this._crackInvQuat),this._crackInvQuat.invert();for(const e of c.crackTriggers){const t=e.screenOffset||[0,0],i=e.screenDirection||[0,0],a=.35,n=1;this._crackWorldPos.set(0,0,0).addScaledVector(this._crackCamRight,t[0]*n).addScaledVector(this._crackCamUp,t[1]*n).addScaledVector(this._crackCamForward,-1),this._crackWorldPos.normalize().multiplyScalar(a),this._crackWorldPos.applyQuaternion(this._crackInvQuat),this._crackWorldDir.set(0,0,0),(Math.abs(i[0])>.01||Math.abs(i[1])>.01)&&this._crackWorldDir.addScaledVector(this._crackCamRight,i[0]).addScaledVector(this._crackCamUp,i[1]).normalize().applyQuaternion(this._crackInvQuat),this.objectSpaceCrackManager.addImpact({position:this._crackWorldPos.clone(),direction:this._crackWorldDir.clone(),propagation:e.propagation||.8,amount:e.amount||1})}}}if(c.crackHealTrigger&&this.objectSpaceCrackManager&&this.objectSpaceCrackManager.startHealing(c.crackHealDuration||1500),c.crack&&void 0!==c.crack.glowStrength&&this.objectSpaceCrackManager&&(this.objectSpaceCrackManager.glowStrength=c.crack.glowStrength),this._pendingFreezeRotation=c.freezeRotation||0,this._pendingFreezeWobble=c.freezeWobble||0,c.deformation&&c.deformation.enabled&&this.renderer?.camera&&this.renderer?.coreMesh){const t=c.deformation,i=t.impactPoint,a=this.renderer.camera,n=this.renderer.coreMesh;a.updateMatrixWorld(),n.updateMatrixWorld(),this._deformCamRight||(this._deformCamRight=new e.Vector3,this._deformCamUp=new e.Vector3,this._deformCamForward=new e.Vector3,this._deformWorldDir=new e.Vector3,this._deformLocalDir=new e.Vector3,this._deformInverseQuat=new e.Quaternion),a.getWorldDirection(this._deformCamForward),this._deformCamRight.setFromMatrixColumn(a.matrixWorld,0),this._deformCamUp.setFromMatrixColumn(a.matrixWorld,1),this._deformWorldDir.set(this._deformCamRight.x*i[0]+this._deformCamUp.x*i[1]-this._deformCamForward.x*i[2],this._deformCamRight.y*i[0]+this._deformCamUp.y*i[1]-this._deformCamForward.y*i[2],this._deformCamRight.z*i[0]+this._deformCamUp.z*i[1]-this._deformCamForward.z*i[2]),n.getWorldQuaternion(this._deformInverseQuat),this._deformInverseQuat.invert(),this._deformLocalDir.copy(this._deformWorldDir),this._deformLocalDir.applyQuaternion(this._deformInverseQuat),this._deformation={...t,impactPoint:[this._deformLocalDir.x,this._deformLocalDir.y,this._deformLocalDir.z]}}else c.deformation&&c.deformation.enabled?this._deformation={...c.deformation}:this._deformation=c.deformation||null;if(this.enableShatter&&this.shatterSystem){if(this.shatterSystem.isFrozen()||(this._frozenShardsMovedThisGesture=!1),c.shatter&&c.shatter.enabled){const t=c.shatter;if(t.isDualMode&&this.shatterSystem.isFrozen())this.shatterSystem.triggerDualMode(t.dualModeType,t.dualModeConfig||{});else if("reform"===t.variant&&this.shatterSystem.isFrozen())this.shatterSystem.triggerReassembly(t.reassembleDuration||1500);else if(t.isDualMode||!this.shatterSystem.isFrozen()||this._frozenShardsMovedThisGesture){if(this.shatterSystem.isIdle()){console.log("[CORE_3D] 🎭 Shatter triggered with config:",{variant:t.variant,elemental:t.elemental,elementalParam:t.elementalParam,overlay:t.overlay,overlayParam:t.overlayParam,intensity:t.intensity,isDualMode:t.isDualMode,dualModeType:t.dualModeType,fullShatterConfig:t});const i=t.impactPoint||[0,0,.4];let a=new e.Vector3(i[0],i[1],i[2]);if(this.renderer?.camera&&this.renderer?.coreMesh){const t=this.renderer.camera,n=this.renderer.coreMesh,s=new e.Vector3,r=new e.Vector3,o=new e.Vector3;t.getWorldDirection(o),s.crossVectors(t.up,o).normalize(),r.crossVectors(o,s).normalize(),a=(new e.Vector3).addScaledVector(s,i[0]).addScaledVector(r,i[1]).addScaledVector(o,-i[2]),a.add(n.position);const l=this.crystalSoul?.mesh||null;this.shatterSystem.setTargets(n,l)}const n=t.impactDirection||[0,0,-1];let s=new e.Vector3(n[0],n[1],n[2]);if(this.renderer?.camera){const t=this.renderer.camera,i=new e.Vector3,a=new e.Vector3,r=new e.Vector3;t.getWorldDirection(r),i.crossVectors(t.up,r).normalize(),a.crossVectors(r,i).normalize(),s=(new e.Vector3).addScaledVector(i,n[0]).addScaledVector(a,n[1]).addScaledVector(r,-n[2]).normalize()}this.shatterSystem.shatter(this.renderer.coreMesh,{impactPoint:a,impactDirection:s,intensity:t.intensity||1,revealInner:!1!==t.revealSoul,isSuspendMode:t.isSuspendMode||!1,suspendAt:t.suspendAt||.25,suspendDuration:t.suspendDuration||.35,isFreezeMode:t.isFreezeMode||!1,isDualMode:t.isDualMode||!1,dualModeType:t.dualModeType,dualModeConfig:t.dualModeConfig||{},gravity:t.gravity,explosionForce:t.explosionForce,rotationForce:t.rotationForce,gestureDuration:t.gestureDuration,elemental:t.elemental||null,elementalParam:t.elementalParam??.5,overlay:t.overlay||null,overlayParam:t.overlayParam??.5}),this.objectSpaceCrackManager&&this.objectSpaceCrackManager.clearAll(),this.renderer.crackLayer&&this.renderer.crackLayer.clearAll()}}else{const e=t.impactDirection||[0,0,-1],i=t.variant?.startsWith("punch")?3.5:"explosive"===t.variant?4:"crumble"===t.variant?1.5:2.5;this.shatterSystem.moveFrozenShards(e,i),this._frozenShardsMovedThisGesture=!0}}c.shatter&&c.shatter.reassemble&&this.shatterSystem.isShattering()&&this.shatterSystem.reassemble({duration:c.shatter.reassembleDuration||1e3}),(this.shatterSystem.isShattering()||this.shatterSystem.isReassembling())&&this.shatterSystem.update(t)}if(jf.start("elementSpawner"),this.elementSpawner){const e=this._currentFireProgress??this._currentWaterProgress??this._currentIceProgress??this._currentElectricProgress??this._currentVoidProgress??null;this.elementSpawner.update(t/1e3,e)}if(jf.end("elementSpawner"),this.debugMotionLogging&&(this._motionLogInterval||(this._motionLogInterval=0),this._motionLogInterval+=t,this._motionLogInterval>=200)){this._motionLogInterval=0;const e=c.hasAbsoluteGestures||c.hasAccentGestures,t=c.position,i=c.rotation,a=c.scale;(Math.abs(t[0])>.001||Math.abs(t[1])>.001||Math.abs(t[2])>.001||Math.abs(i[0])>.001||Math.abs(i[1])>.001||Math.abs(i[2])>.001||Math.abs(a-1)>.001||h&&(Math.abs(h.grooveOffset[1])>.001||Math.abs(h.grooveScale-1)>.001)||e)&&(console.log("[Motion] ═══════════════════════════════════════"),console.log(`[Motion] GESTURE: pos=[${t.map(e=>e.toFixed(3)).join(", ")}] rot=[${i.map(e=>(180*e/Math.PI).toFixed(1)).join(", ")}°] scale=${a.toFixed(3)} hasAbs=${u}`),h&&console.log(`[Motion] GROOVE: offset=[${h.grooveOffset.map(e=>e.toFixed(3)).join(", ")}] rot=[${h.grooveRotation.map(e=>(180*e/Math.PI).toFixed(1)).join(", ")}°] scale=${h.grooveScale.toFixed(3)} blend=${g.toFixed(2)}`),console.log(`[Motion] BOOST: pos=[${b.map(e=>e.toFixed(3)).join(", ")}] rot=[${w.map(e=>(180*e/Math.PI).toFixed(1)).join(", ")}°] scale=${M.toFixed(3)}`),console.log(`[Motion] FINAL: pos=[${this.position.map(e=>e.toFixed(3)).join(", ")}] rot=[${this.rotation.map(e=>(180*e/Math.PI).toFixed(1)).join(", ")}°] scale=${this.scale.toFixed(3)}`))}r.isBlinking&&r.rotation&&(this.rotation[0]+=r.rotation[0],this.rotation[1]+=r.rotation[1],this.rotation[2]+=r.rotation[2]);const P="crystal"!==this.geometryType&&"rough"!==this.geometryType,k=s*n*(r.isBlinking&&P?r.scale[1]:1)*(this.crystalShellBaseScale||2),D=this.scale*k,A=this.nonUniformScale?[this.nonUniformScale[0]*k,this.nonUniformScale[1]*k,this.nonUniformScale[2]*k]:null;if(jf.start("particleOrchestrator"),this.particleVisibility&&this.particleOrchestrator){const e=this.geometryConfig?.particleRadiusMultiplier||1,i=(this.crystalShellBaseScale||2)*this.scale*n*e;this.particleOrchestrator.update(t,this.emotion,this.undertone,this.animationManager.getActiveAnimations(),this.animationManager.getTime(),{x:this.position[0],y:this.position[1],z:this.position[2]},{width:this.canvas.width,height:this.canvas.height},{euler:this.baseEuler,quaternion:this.baseQuaternion,angularVelocity:this.behaviorController.getAngularVelocity()},this.baseScale,i)}jf.end("particleOrchestrator");const _=r.isBlinking&&r.glowBoost?1+r.glowBoost:1,T=this.coreGlowEnabled?this.glowIntensity*_:0,I=this.emotiveEngine?.getVirtualParticle(),O=T*(I?.opacity??1),R=i.isTransitioning?.3:.1;if(this.renderer.updateBloom(O,R,this.geometryType),this.elementSpawner){let e=.85;"sun"===this.geometryType?e=.3:"crystal"!==this.geometryType&&"rough"!==this.geometryType&&"heart"!==this.geometryType||(e=.35),this.elementSpawner.setElementBloomThreshold("water",e),this.elementSpawner.setElementBloomThreshold("ice",e),this.elementSpawner.setElementBloomThreshold("electricity",e)}if(this.glowBoost>0||this.renderer.glowLayer&&this.renderer.glowLayer.isActive()){const e=this.coreMesh?.position;this.renderer.updateGlowLayer(this.glowBoost,this.glowColor,e,t)}if(this.objectSpaceCrackManager&&(this.objectSpaceCrackManager.update(t),this.customMaterial?.uniforms&&this.objectSpaceCrackManager.applyToMaterial(this.customMaterial)),this.renderer.crackLayer&&this.renderer.crackLayer.isActive()&&this.renderer.updateCrackLayer(null,t),"sun"===this.customMaterialType&&gi(this.coreMesh,this.glowColor,O,t),"moon"!==this.customMaterialType&&"moon-multiplexer"!==this.customMaterialType||!this.customMaterial||this.customMaterial.uniforms&&this.customMaterial.uniforms.glowIntensity&&(this.customMaterial.uniforms.glowIntensity.value=O),"crystal"===this.customMaterialType&&this.customMaterial){if(this.customMaterial.uniforms){if(this.customMaterial.uniforms.time.value+=t/1e3,this.customMaterial.uniforms.glowIntensity&&(this.customMaterial.uniforms.glowIntensity.value=O),this._targetGlowColor&&this._colorTransitionProgress<1){const e=this.colorTransitionDuration||500;this._colorTransitionProgress+=t/e,this._colorTransitionProgress=Math.min(this._colorTransitionProgress,1);const i=1-Math.pow(1-this._colorTransitionProgress,2),a=this._colorTransitionStart||this._normalizedGlowColor||[1,1,1],n=this._targetGlowColor;this._normalizedGlowColor=[a[0]+(n[0]-a[0])*i,a[1]+(n[1]-a[1])*i,a[2]+(n[2]-a[2])*i]}if(this._targetSSSValues&&this._sssTransitionProgress<1){const e=this.sssTransitionDuration||500;this._sssTransitionProgress+=t/e,this._sssTransitionProgress=Math.min(this._sssTransitionProgress,1);const i=1-Math.pow(1-this._sssTransitionProgress,2),a=this.customMaterial.uniforms,n=this._sssTransitionStart,s=this._targetSSSValues;a.sssStrength&&void 0!==n.sssStrength&&(a.sssStrength.value=n.sssStrength+(s.sssStrength-n.sssStrength)*i),a.sssThicknessBias&&void 0!==n.sssThicknessBias&&(a.sssThicknessBias.value=n.sssThicknessBias+(s.sssThicknessBias-n.sssThicknessBias)*i),a.sssThicknessScale&&void 0!==n.sssThicknessScale&&(a.sssThicknessScale.value=n.sssThicknessScale+(s.sssThicknessScale-n.sssThicknessScale)*i),a.sssCurvatureScale&&void 0!==n.sssCurvatureScale&&(a.sssCurvatureScale.value=n.sssCurvatureScale+(s.sssCurvatureScale-n.sssCurvatureScale)*i),a.sssAmbient&&void 0!==n.sssAmbient&&(a.sssAmbient.value=n.sssAmbient+(s.sssAmbient-n.sssAmbient)*i),a.frostiness&&void 0!==n.frostiness&&(a.frostiness.value=n.frostiness+(s.frostiness-n.frostiness)*i),a.innerGlowStrength&&void 0!==n.innerGlowStrength&&(a.innerGlowStrength.value=n.innerGlowStrength+(s.innerGlowStrength-n.innerGlowStrength)*i),a.fresnelIntensity&&void 0!==n.fresnelIntensity&&(a.fresnelIntensity.value=n.fresnelIntensity+(s.fresnelIntensity-n.fresnelIntensity)*i),a.causticIntensity&&void 0!==n.causticIntensity&&(a.causticIntensity.value=n.causticIntensity+(s.causticIntensity-n.causticIntensity)*i),a.emotionColorBleed&&void 0!==n.emotionColorBleed&&(a.emotionColorBleed.value=n.emotionColorBleed+(s.emotionColorBleed-n.emotionColorBleed)*i),a.sssAbsorption&&n.sssAbsorption&&a.sssAbsorption.value.set(n.sssAbsorption[0]+(s.sssAbsorption[0]-n.sssAbsorption[0])*i,n.sssAbsorption[1]+(s.sssAbsorption[1]-n.sssAbsorption[1])*i,n.sssAbsorption[2]+(s.sssAbsorption[2]-n.sssAbsorption[2])*i),a.sssScatterDistance&&n.sssScatterDistance&&a.sssScatterDistance.value.set(n.sssScatterDistance[0]+(s.sssScatterDistance[0]-n.sssScatterDistance[0])*i,n.sssScatterDistance[1]+(s.sssScatterDistance[1]-n.sssScatterDistance[1])*i,n.sssScatterDistance[2]+(s.sssScatterDistance[2]-n.sssScatterDistance[2])*i)}const e=this._normalizedGlowColor||[1,1,1];if(this.customMaterial.uniforms.emotionColor.value.setRGB(e[0],e[1],e[2]),this.customMaterial.uniforms.blinkIntensity){const e=r.isBlinking?Math.sin(r.progress*Math.PI):0;this.customMaterial.uniforms.blinkIntensity.value=e}}const e=this.shatterSystem&&!this.shatterSystem.isIdle();if(this.coreGlowEnabled&&!e){const e=this._normalizedGlowColor||[1,1,1];this.updateCrystalInnerCore(e,t)}}this._skipRenderFrames>0?this._skipRenderFrames--:(jf.start("threeRenderer"),this.renderer.render({position:this.position,rotation:this.rotation,scale:D,nonUniformScale:A,glowColor:this.glowColor,glowColorHex:this.glowColorHex,glowIntensity:O,hasActiveGesture:this.animationManager.hasActiveAnimations(),calibrationRotation:this.calibrationRotation,cameraRoll:this._cameraRoll||0,solarEclipse:this.effectManager.getSolarEclipse(),deltaTime:t,morphProgress:i.isTransitioning?i.visualProgress:null,hasSoul:"crystal"===this.customMaterialType&&null!==this.crystalSoul,hasParticles:this.particleVisibility&&null!==this.particleOrchestrator&&this.particleOrchestrator.getParticleCount()>0,deformation:this._deformation}),jf.end("threeRenderer"),this.effectManager.updateLunarEclipse(t),jf.endFrame())}async _loadAsyncGeometry(){try{const e=await Xd(this.geometryType,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:Ii(this.emotion),assetBasePath:this.assetBasePath});if(this._destroyed)return;if(!e||!e.geometry)return console.warn(`[Core3D:${this._instanceId}] Async geometry load returned null!`),void(this._ready=!0);const t=e.geometry.clone();if(t.userData.geometryType=this.geometryType,this.geometry=t,this._deferredMeshCreation){if(this.coreMesh=this.renderer.createCoreMesh(t,this.customMaterial),this._destroyed)return;if("crystal"===this.customMaterialType&&(await this._createCrystalInnerCoreAsync(),this._destroyed))return;this._deferredMeshCreation=!1}else if(this.coreMesh){const e=this.coreMesh.geometry;if(this.coreMesh.geometry=t,e&&e!==t&&e.dispose(),this._destroyed)return;if("crystal"===this.customMaterialType&&(await this._createCrystalInnerCoreAsync(),this._destroyed))return}if(this._destroyed)return;this.elementSpawner&&this.renderer?.coreMesh&&!this.elementSpawner.coreMesh&&this.elementSpawner.initialize(this.renderer.coreMesh,this.renderer.camera),this._logSceneHierarchy(),this._ready=!0,this._startElementPreloading()}catch(e){console.warn(`[Core3D:${this._instanceId}] Async geometry load FAILED:`,e),this._destroyed||(this._ready=!0)}}_logSceneHierarchy(){const e=this.renderer?.scene;e&&e.children.forEach((e,t)=>{const i=null===e?"NULL!":void 0===e?"UNDEFINED!":null===e.visible?"visible=NULL!":void 0===e.visible?"visible=UNDEF!":"OK";console.warn(`  [${t}] ${e?.name||e?.type||"UNKNOWN"} status=${i} uuid=${e?.uuid?.slice(0,8)||"N/A"}`)})}async _createCrystalInnerCoreAsync(){if(this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null),!this.coreMesh)return;if(await Od._loadInclusionGeometry(this.assetBasePath),this._destroyed||!this.coreMesh)return;this.crystalSoul=new Od({radius:.35,detail:1,geometryType:this.geometryType,renderer:this.renderer,assetBasePath:this.assetBasePath}),this.crystalSoul.attachTo(this.coreMesh,this.renderer?.scene);let e=1;"heart"===this.geometryType?(this.crystalShellBaseScale=2.4,e=1):"rough"===this.geometryType?(this.crystalShellBaseScale=1.6,e=1):"crystal"===this.geometryType&&(e=1),this.crystalSoul.baseScale=e,this.crystalSoul.mesh.scale.setScalar(e),this.crystalSoul.setVisible(this.coreGlowEnabled),this.crystalInnerCore=this.crystalSoul.mesh,this.crystalInnerCoreMaterial=this.crystalSoul.material,this.crystalInnerCoreBaseScale=this.crystalSoul.baseScale}async _handleContextRestored(){if(!this._destroyed&&this.coreMesh&&this.customMaterialType){const e=Ii(this.emotion),t=Wd(this.geometryType,this.geometryConfig,{glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:e,assetBasePath:this.assetBasePath});t&&(this.customMaterial&&$d(this.customMaterial),this.customMaterial=t.material,this.coreMesh.material=this.customMaterial,"crystal"===this.customMaterialType&&this.crystalSoul&&await this._createCrystalInnerCoreAsync(),this.onMaterialSwap&&this.onMaterialSwap())}}isReady(){return this._ready}async waitUntilReady(){this._ready||this._readyPromise&&await this._readyPromise}_startElementPreloading(){!this._destroyed&&this.elementSpawner&&(this._preloadElements.length>0&&(console.log(`[Core3D] Preloading specified elements: ${this._preloadElements.join(", ")}`),this._preloadElements.forEach(e=>{qf.includes(e)&&this.elementSpawner.preloadModels(e)})),this._backgroundPrewarm&&(this._prewarmTimeoutId=setTimeout(()=>{this._backgroundPrewarmElements()},2e3)))}async _backgroundPrewarmElements(){if(this._destroyed||!this.elementSpawner)return;const e=new Set(this._preloadElements),t=qf.filter(t=>!e.has(t));if(0!==t.length){console.log(`[Core3D] Background pre-warming elements: ${t.join(", ")}`);for(const e of t){if(this._destroyed)break;if(await new Promise(e=>setTimeout(e,100)),this._destroyed)break;this.elementSpawner.preloadModels(e)}}}_cancelPrewarm(){this._prewarmTimeoutId&&(clearTimeout(this._prewarmTimeoutId),this._prewarmTimeoutId=null)}destroy(){if(this._destroyed=!0,this._cancelPrewarm(),this.crystalSoul&&(this.crystalSoul.dispose(),this.crystalSoul=null,this.crystalInnerCore=null,this.crystalInnerCoreMaterial=null),this.particleOrchestrator){const e=this.particleOrchestrator.renderer;if(e){const t=e.getPoints();t&&this.renderer?.scene&&this.renderer.scene.remove(t)}this.particleOrchestrator.destroy(),this.particleOrchestrator=null}this.shatterSystem&&(this.shatterSystem.dispose(),this.shatterSystem=null),this._smokeParticleSystem&&(this._smokeParticleSystem.dispose(),this._smokeParticleSystem=null),this.objectSpaceCrackManager&&(this.objectSpaceCrackManager.dispose(),this.objectSpaceCrackManager=null),this.elementSpawner&&(this.elementSpawner.dispose(),this.elementSpawner=null),this.effectManager&&(this.effectManager.dispose(),this.effectManager=null),this.behaviorController&&(this.behaviorController.dispose(),this.behaviorController=null),this.breathingPhaseManager&&(this.breathingPhaseManager.dispose(),this.breathingPhaseManager=null),this.customMaterial&&(this.renderer.disposeMaterial(this.customMaterial),this.customMaterial=null,this.customMaterialType=null),this.facingBehavior&&(this.facingBehavior.dispose(),this.facingBehavior=null),this.animationManager.stopAll(),this.renderer.destroy(),this.animationManager.dispose(),this.animationManager=null,this.animator.destroy?.(),this.breathingAnimator.destroy?.(),this.gestureBlender.destroy?.(),this.geometryMorpher.destroy?.(),this.blinkAnimator.destroy?.(),this.behaviorController.dispose(),this.behaviorController=null,this.tempEuler=null,this.baseQuaternion=null,this.gestureQuaternion=null,this.geometry=null,this.geometryConfig=null,this._targetGeometry=null,this._targetGeometryConfig=null,this._targetGeometryType=null,this.canvas=null,this.options=null,this.coreMesh=null,this.rhythmEngine=null,this.rhythm3DAdapter=null,this.emotiveEngine=null,Kd()}_getEmotionGroove(e){return{happy:"groove2",excited:"groove2",amused:"groove2",silly:"groove2",surprised:"groove2",calm:"groove1",neutral:"groove1",sad:"groove1",content:"groove1",focused:"groove1",bored:"groove1",tired:"groove1",sleepy:"groove1",zen:"groove3",love:"groove3",grateful:"groove3",inspired:"groove3",hopeful:"groove3",proud:"groove3",angry:"groove2",anxious:"groove2",determined:"groove2"}[e]||"groove1"}async preloadGeometries(){const e={glowColor:this.glowColor||[1,1,.95],glowIntensity:this.glowIntensity||1,materialVariant:this.materialVariant,emotionData:Ii(this.emotion)};await Qd(e)}}class Wf{constructor(e={}){this.config=e,this.container=null,this.webglCanvas=null,this.canvas2D=null,this._canvasAppended=!1}setup(e){if("CANVAS"===e.tagName){const t=e.parentElement;this.container=document.createElement("div"),this.container.style.position="relative",this.container.style.width="100%",this.container.style.height="100%",t.replaceChild(this.container,e)}else this.container=e,this.container.style.position&&"static"!==this.container.style.position||(this.container.style.position="relative");return this.canvas2D=document.createElement("canvas"),this.canvas2D.id=`${this.config.canvasId}-particles`,this.canvas2D.width=this.container.offsetWidth||400,this.canvas2D.height=this.container.offsetHeight||400,this.canvas2D.style.position="absolute",this.canvas2D.style.top="0",this.canvas2D.style.left="0",this.canvas2D.style.width="100%",this.canvas2D.style.height="100%",this.canvas2D.style.background="transparent",this.canvas2D.style.zIndex="1",this.canvas2D.style.pointerEvents="none",this.container.appendChild(this.canvas2D),this.webglCanvas=document.createElement("canvas"),this.webglCanvas.id=`${this.config.canvasId}-3d`,this.webglCanvas.width=this.canvas2D.width,this.webglCanvas.height=this.canvas2D.height,this.webglCanvas.style.cssText="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: transparent;\n            z-index: 2;\n        ",this.config.enableControls?(this.webglCanvas.style.pointerEvents="auto",this.webglCanvas.style.touchAction="none"):(this.webglCanvas.style.pointerEvents="none",this.webglCanvas.style.touchAction="auto"),this._canvasAppended=!1,{container:this.container,webglCanvas:this.webglCanvas,canvas2D:this.canvas2D}}appendWebGLCanvas(){!this._canvasAppended&&this.webglCanvas&&this.container&&(this.container.appendChild(this.webglCanvas),this._canvasAppended=!0)}isCanvasAppended(){return this._canvasAppended}getDimensions(){return{width:this.canvas2D?.width||0,height:this.canvas2D?.height||0}}resize(e,t){this.canvas2D&&(this.canvas2D.width=e,this.canvas2D.height=t),this.webglCanvas&&(this.webglCanvas.width=e,this.webglCanvas.height=t)}destroy(){this.webglCanvas&&this.webglCanvas.parentNode&&this.webglCanvas.parentNode.removeChild(this.webglCanvas),this.canvas2D&&this.canvas2D.parentNode&&this.canvas2D.parentNode.removeChild(this.canvas2D),this.container=null,this.webglCanvas=null,this.canvas2D=null,this._canvasAppended=!1}}class Hf{constructor(){this.listeners=new Map,this.groups=new Map,this.stats={registered:0,removed:0,active:0}}addEventListener(e,t,i,a={},n="default"){const s=this.generateId(),r={id:s,target:e,eventType:t,handler:i,options:a,group:n,active:!0};return this.listeners.set(s,r),this.groups.has(n)||this.groups.set(n,new Set),this.groups.get(n).add(s),e.addEventListener(t,i,a),this.stats.registered++,this.stats.active++,s}removeEventListener(e){const t=this.listeners.get(e);if(!t||!t.active)return!1;t.target.removeEventListener(t.eventType,t.handler,t.options),t.active=!1;const i=this.groups.get(t.group);return i&&(i.delete(e),0===i.size&&this.groups.delete(t.group)),this.listeners.delete(e),this.stats.removed++,this.stats.active--,!0}removeGroup(e){const t=this.groups.get(e);if(!t)return 0;let i=0;for(const e of t)this.removeEventListener(e)&&i++;return i}removeAllForTarget(e){let t=0;for(const[i,a]of this.listeners.entries())a.target===e&&a.active&&this.removeEventListener(i)&&t++;return t}removeAllOfType(e){let t=0;for(const[i,a]of this.listeners.entries())a.eventType===e&&a.active&&this.removeEventListener(i)&&t++;return t}removeAll(){let e=0;for(const[t,i]of this.listeners.entries())i.active&&this.removeEventListener(t)&&e++;return e}createAutoRemove(e,t,i,a={}){const n=this.addEventListener(e,t,i,a);return{id:n,remove:()=>this.removeEventListener(n)}}once(e,t,i,a={}){const n=this.addEventListener(e,t,e=>{i(e),this.removeEventListener(n)},a);return n}debounced(e,t,i,a=250,n={}){let s;return this.addEventListener(e,t,e=>{clearTimeout(s),s=setTimeout(()=>i(e),a)},n)}throttled(e,t,i,a=100,n={}){let s=!1;return this.addEventListener(e,t,e=>{s||(i(e),s=!0,setTimeout(()=>{s=!1},a))},n)}generateId(){return`listener_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}getStats(){return{...this.stats,groups:this.groups.size,listeners:this.listeners.size}}getActiveListeners(){const e=[];for(const[t,i]of this.listeners.entries())i.active&&e.push({id:t,eventType:i.eventType,group:i.group,target:i.target.constructor.name});return e}analyzeLeaks(){const e={totalListeners:this.listeners.size,activeListeners:this.stats.active,inactiveButNotRemoved:0,byTarget:new Map,byType:new Map,potentialLeaks:[]};for(const[t,i]of this.listeners.entries()){const a=i.target.constructor.name;e.byTarget.set(a,(e.byTarget.get(a)||0)+1),e.byType.set(i.eventType,(e.byType.get(i.eventType)||0)+1),i.active||(e.inactiveButNotRemoved++,e.potentialLeaks.push({id:t,eventType:i.eventType,target:a}))}return e.byTarget=Object.fromEntries(e.byTarget),e.byType=Object.fromEntries(e.byType),e}cleanup(){let e=0;for(const[t,i]of this.listeners.entries())i.active||(this.listeners.delete(t),e++);return e}destroy(){const e=this.removeAll();return this.listeners.clear(),this.groups.clear(),this.stats={registered:0,removed:0,active:0},e}}class $f{constructor(){this.errors=[],this.maxErrors=10,this.errorCounts=new Map,this.defaults={emotion:"neutral",gesture:null,audioLevel:0,particleCount:0,glowIntensity:.7,coreSize:1,breathRate:1,color:"#B0B0B0"}}wrap(e,t,i=null){return(...a)=>{try{return e(...a)}catch(e){return this.logError(e,t),null!==i?i:this.getDefault(t)}}}logError(e,t){const i={timestamp:(new Date).toISOString(),context:t,message:e.message,stack:e.stack};this.errors.push(i);const a=this.errorCounts.get(t)||0;this.errorCounts.set(t,a+1),this.errors.length>this.maxErrors&&this.errors.shift(),a<3?console.warn(`[EmotiveEngine] ${t}:`,e.message):3===a&&console.warn(`[EmotiveEngine] ${t}: Error occurred 3+ times, suppressing further logs`)}getDefault(e){const t={"emotion-transition":this.defaults.emotion,"gesture-execution":this.defaults.gesture,"audio-processing":this.defaults.audioLevel,"particle-system":this.defaults.particleCount,rendering:{glowIntensity:this.defaults.glowIntensity,coreSize:this.defaults.coreSize,color:this.defaults.color},"canvas-operations":null,"state-management":this.defaults.emotion};return Object.prototype.hasOwnProperty.call(t,e)?t[e]:null}validateInput(e,t,i){try{switch(t){case"emotion":return["neutral","joy","sadness","anger","fear","surprise","disgust","love","euphoria"].includes(e)?e:i;case"undertone":return null===e||["nervous","confident","tired","intense","subdued"].includes(e)?e:null;case"gesture":return["bounce","pulse","shake","spin","nod","tilt","expand","contract","flash","drift"].includes(e)?e:i;case"number":return"number"!=typeof e||isNaN(e)?i:e;case"string":return"string"==typeof e?e:i;case"boolean":return"boolean"==typeof e?e:i;default:return null!=e?e:i}}catch(e){return this.logError(e,"input-validation"),i}}hasExceededThreshold(e,t=5){return(this.errorCounts.get(e)||0)>=t}getErrorStats(){return{totalErrors:this.errors.length,errorsByContext:Object.fromEntries(this.errorCounts),recentErrors:this.errors.slice(-5)}}clearErrors(){this.errors=[],this.errorCounts.clear()}async attemptRecovery(e,t,i=3){let a=0;for(;a<i;)try{return await t()}catch(t){if(a++,this.logError(t,`recovery-${e}-attempt-${a}`),a>=i)throw new Error(`Recovery failed for ${e} after ${i} attempts`);await new Promise(e=>setTimeout(e,100*Math.pow(2,a)))}}}const Yf={quartz:{sssStrength:.8,sssAbsorption:[2.8,2.9,3],sssScatterDistance:[.2,.2,.25],sssThicknessBias:.6,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.12,frostiness:.15,innerGlowStrength:.2,fresnelIntensity:1.5,causticIntensity:1.2,emotionColorBleed:0},emerald:{sssStrength:2,sssAbsorption:[.05,4,.1],sssScatterDistance:[.1,.5,.1],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.2,innerGlowStrength:.15,fresnelIntensity:1.2,causticIntensity:1,emotionColorBleed:.35},ruby:{sssStrength:1.8,sssAbsorption:[4,.03,.08],sssScatterDistance:[.4,.04,.08],sssThicknessBias:.65,sssThicknessScale:1.9,sssCurvatureScale:2.5,sssAmbient:.08,frostiness:.12,innerGlowStrength:.12,fresnelIntensity:1.2,causticIntensity:1.15,emotionColorBleed:.35},sapphire:{sssStrength:2.2,sssAbsorption:[.15,.4,4],sssScatterDistance:[.1,.15,.5],sssThicknessBias:.65,sssThicknessScale:1.8,sssCurvatureScale:3,sssAmbient:.1,frostiness:.18,innerGlowStrength:.15,fresnelIntensity:1.3,causticIntensity:1,emotionColorBleed:.35},amethyst:{sssStrength:2.5,sssAbsorption:[3,.05,4.5],sssScatterDistance:[.4,.05,.5],sssThicknessBias:.7,sssThicknessScale:2,sssCurvatureScale:3,sssAmbient:.08,frostiness:.18,innerGlowStrength:.12,fresnelIntensity:1.4,causticIntensity:1,emotionColorBleed:.35},topaz:{sssStrength:1.5,sssAbsorption:[3.5,2,.1],sssScatterDistance:[.3,.2,.05],sssThicknessBias:.6,sssThicknessScale:1.7,sssCurvatureScale:2.8,sssAmbient:.12,frostiness:.14,innerGlowStrength:.18,fresnelIntensity:1.4,causticIntensity:1.1,emotionColorBleed:.25},citrine:{sssStrength:1.6,sssAbsorption:[3.8,2.5,.05],sssScatterDistance:[.35,.25,.05],sssThicknessBias:.58,sssThicknessScale:1.6,sssCurvatureScale:2.6,sssAmbient:.14,frostiness:.12,innerGlowStrength:.22,fresnelIntensity:1.3,causticIntensity:1.2,emotionColorBleed:.2},diamond:{sssStrength:.5,sssAbsorption:[2.5,2.5,2.5],sssScatterDistance:[.15,.15,.15],sssThicknessBias:.55,sssThicknessScale:1.5,sssCurvatureScale:4,sssAmbient:.15,frostiness:.08,innerGlowStrength:.25,fresnelIntensity:2,causticIntensity:1.5,emotionColorBleed:0}};function Xf(e,t){if(!t||!e?.core3D?.customMaterial?.uniforms)return!1;const i=Yf[t];if(!i)return!1;const a=e.core3D.customMaterial.uniforms;return a.sssStrength&&(a.sssStrength.value=i.sssStrength),a.sssAbsorption&&a.sssAbsorption.value.set(...i.sssAbsorption),a.sssScatterDistance&&a.sssScatterDistance.value.set(...i.sssScatterDistance),a.sssThicknessBias&&(a.sssThicknessBias.value=i.sssThicknessBias),a.sssThicknessScale&&(a.sssThicknessScale.value=i.sssThicknessScale),a.sssCurvatureScale&&(a.sssCurvatureScale.value=i.sssCurvatureScale),a.sssAmbient&&(a.sssAmbient.value=i.sssAmbient),a.frostiness&&(a.frostiness.value=i.frostiness),a.innerGlowStrength&&(a.innerGlowStrength.value=i.innerGlowStrength),a.fresnelIntensity&&(a.fresnelIntensity.value=i.fresnelIntensity),void 0!==i.causticIntensity&&a.causticIntensity&&(a.causticIntensity.value=i.causticIntensity),a.emotionColorBleed&&(a.emotionColorBleed.value=i.emotionColorBleed??0),!0}function Qf(){return Object.keys(Yf)}function Kf(e){return Yf[e]||null}const Zf=["bouncing up and down","hopping around","rocking back and forth","side to side","light on feet","spring in step","leaning forward","leaning in","leaning closer","leaning toward","reaching out","reaching toward","pointing at","pointing to","waving hello","waving goodbye","nodding head","shaking head","head shake","head nod","head bob","head tilt","deep breath","taking a breath","breathing deeply","settling down","calming down","winding down","getting bigger","getting smaller","puffing up","spinning around","twirling around","at peace","in love","on cloud nine","over the moon","on top of the world","in awe","grossed out","freaked out","low key","low-key","high key","on edge","keyed up","wound up","low energy","no energy","running low","just a bit","just a little","a little bit","kind of","sort of","a bit","a little","a lot","over the top","off the charts","through the roof","split second","one time","few times","many times","again and again","over and over","on repeat","blood moon","full moon","new moon","half moon","solar eclipse","lunar eclipse","total eclipse","ring of fire","diamond ring","killing it","crushing it","nailed it","sussy baka","side eye"],Jf=/[,;|/]+/,ey=new Set(["a","an","the","is","are","am","be","being","been","i","me","my","it","its","to","of","for","with","as","this","that","these","those","just","only","also","too","please","pls","plz"]),ty=new Set(["but","and","or","yet","while","although","not","no","never","very","really","so","quite","rather","slightly","barely","extremely","completely","feeling","feel","feels","become","becoming","morph","morphing"]);function iy(e){return e.toLowerCase().trim().replace(/['']/g,"'").replace(/[""]/g,'"').replace(/\s+/g," ")}function ay(e){return["but","and","or","yet","while","although","with"].includes(e)}function ny(e){return["not","no","never","don't","dont","doesn't","doesnt","isn't","isnt"].includes(e)}const sy={nervous:{candidates:[{category:"emotion",target:"fear",priority:1},{category:"undertone",target:"nervous",priority:2}],rule:"standalone_is_emotion",examples:[{input:"nervous",resolved:{emotion:"fear"}},{input:"happy but nervous",resolved:{emotion:"joy",undertone:"nervous"}}]},anxious:{candidates:[{category:"emotion",target:"fear",priority:1},{category:"undertone",target:"nervous",priority:2}],rule:"standalone_is_emotion"},confident:{candidates:[{category:"emotion",target:"trust",priority:2},{category:"undertone",target:"confident",priority:1}],rule:"prefer_undertone",examples:[{input:"confident",resolved:{undertone:"confident"}},{input:"feeling confident",resolved:{emotion:"trust"}}]},tired:{candidates:[{category:"emotion",target:"sadness",priority:2},{category:"undertone",target:"tired",priority:1}],rule:"prefer_undertone",examples:[{input:"tired",resolved:{undertone:"tired"}},{input:"feeling tired",resolved:{emotion:"sadness",undertone:"tired"}}]},intense:{candidates:[{category:"undertone",target:"intense",priority:1},{category:"modifier",target:"intensity.very",priority:2}],rule:"prefer_undertone"},curious:{candidates:[{category:"emotion",target:"focused",priority:1},{category:"gesture",target:"lean",priority:2}],rule:"standalone_is_emotion",examples:[{input:"curious",resolved:{emotion:"focused"}},{input:"curious, leaning in",resolved:{emotion:"focused",gesture:"lean"}}]},interested:{candidates:[{category:"emotion",target:"focused",priority:1},{category:"gesture",target:"lean",priority:2}],rule:"standalone_is_emotion"},excited:{candidates:[{category:"emotion",target:"joy",priority:1},{category:"gesture",target:"bounce",priority:3}],rule:"standalone_is_emotion"},shaking:{candidates:[{category:"gesture",target:"shake",priority:1},{category:"emotion",target:"fear",priority:2}],rule:"standalone_is_gesture"},nodding:{candidates:[{category:"gesture",target:"nod",priority:1}],rule:"always_gesture"},glowing:{candidates:[{category:"gesture",target:"glow",priority:1},{category:"shape",target:"sun",priority:3}],rule:"standalone_is_gesture"},spinning:{candidates:[{category:"gesture",target:"spin",priority:1}],rule:"always_gesture"},love:{candidates:[{category:"emotion",target:"love",priority:1},{category:"shape",target:"heart",priority:2}],rule:"standalone_is_emotion",examples:[{input:"love",resolved:{emotion:"love"}},{input:"love heart",resolved:{emotion:"love",shape:"heart"}},{input:"become love",resolved:{shape:"heart"}}]},suspicious:{candidates:[{category:"emotion",target:"suspicion",priority:1},{category:"shape",target:"suspicion",priority:2}],rule:"standalone_is_emotion"},bright:{candidates:[{category:"emotion",target:"joy",priority:2},{category:"shape",target:"sun",priority:3},{category:"modifier",target:"intensity.very",priority:4}],rule:"context_dependent"},yes:{candidates:[{category:"gesture",target:"nod",priority:1}],rule:"always_gesture"},no:{candidates:[{category:"gesture",target:"shake",priority:1}],rule:"always_gesture"},agree:{candidates:[{category:"gesture",target:"nod",priority:1},{category:"emotion",target:"trust",priority:2}],rule:"standalone_is_gesture"},disagree:{candidates:[{category:"gesture",target:"shake",priority:1}],rule:"always_gesture"}},ry={emotionContext:["feeling","feel","feels","felt","emotion","emotional","emotionally","mood","moody","state","am","is","are","being","becoming","become","grew","growing"],gestureContext:["do","doing","does","did","perform","performing","action","move","moving","movement","start","starting","begin","beginning","physically","motion"],shapeContext:["morph","morphing","morphed","transform","transforming","transformed","become","becoming","turn into","shape","form","look like","change to","change into"],undertoneContext:["but","yet","while","although","with","and also","mixed with","underneath","underlying","beneath","a bit","slightly","somewhat"],modifierContext:["very","really","so","extremely","slightly","barely","completely","quickly","slowly","briefly"]};function oy(e,t,i){const a=ry[`${i}Context`];if(!a)return!1;const n=Math.max(0,t-3),s=Math.min(e.length,t+4);for(let i=n;i<s;i++)if(i!==t&&a.includes(e[i]))return!0;return!1}function ly(e,t){switch(t){case"emotion":return null!==e.emotion;case"gesture":return e.gestures&&e.gestures.length>0;case"shape":return null!==e.shape;case"undertone":return null!==e.undertone;default:return!1}}function cy(e,t,i,a){const n=sy[e];if(!n)return null;const{candidates:s,rule:r}=n;if(1===s.length)return s[0];switch(r){case"standalone_is_emotion":if(ly(a,"emotion")){const e=s.find(e=>"emotion"!==e.category);if(e)return e}return oy(t,i,"emotion"),s.find(e=>"emotion"===e.category)||s[0];case"standalone_is_gesture":if(ly(a,"gesture")){const e=s.find(e=>"gesture"!==e.category);if(e)return e}return oy(t,i,"gesture"),s.find(e=>"gesture"===e.category)||s[0];case"prefer_undertone":return oy(t,i,"emotion")?s.find(e=>"emotion"===e.category)||s[0]:s.find(e=>"undertone"===e.category)||s[0];case"always_gesture":return s.find(e=>"gesture"===e.category)||s[0];case"always_emotion":return s.find(e=>"emotion"===e.category)||s[0];case"context_dependent":for(const e of["emotion","gesture","shape","undertone"])if(oy(t,i,e)){const t=s.find(t=>t.category===e);if(t)return t}return s.sort((e,t)=>e.priority-t.priority)[0];default:return s.sort((e,t)=>e.priority-t.priority)[0]}}function hy(e){return e in sy}const uy={neutral:["neutral","default","normal","baseline","standard","nothing special","nothing particular","no strong feeling","not much","meh","whatever","indifferent","balanced","even","steady","stable","centered","level","middle ground","in between","ready","waiting","standing by","at attention","present","here","available","attentive","reset","clear","blank","empty","clean slate"],joy:["happy","joy","joyful","joyous","pleased","glad","content","satisfied","gratified","comfortable","good","cheerful","cheery","merry","jovial","jolly","upbeat","sunny","bright","lighthearted","buoyant","delighted","thrilled","overjoyed","elated","jubilant","exultant","gleeful","glowing","beaming","radiant","pumped","stoked","psyched","amped","hyped","vibing","living","slaying","winning","lit","fire","sick","dope","chuffed","pleased as punch","over the moon","made up","tickled","tickled pink","felicitous","beatific","blissful","smiling","grinning","laughing","giggling"],calm:["calm","peaceful","serene","tranquil","relaxed","at ease","comfortable","loose","unwound","decompressed","chilled","still","quiet","hushed","silent","soft","gentle","mild","placid","smooth","composed","collected","centered","grounded","untroubled","unworried","unbothered","unfazed","meditative","zen","mindful","contemplative","reflective","introspective","soothed","eased","mellowed","softened","chill","coasting","floating","drifting","laid back","easy going","low key","sorted","easy peasy"],excited:["excited","exciting","excitable","enthusiastic","eager","keen","avid","passionate","fervent","ardent","zealous","energetic","energized","animated","lively","spirited","vivacious","vibrant","dynamic","bouncy","peppy","perky","sprightly","anticipating","expectant","looking forward","itching","raring","chomping at the bit","fired up","charged","electric","electrified","buzzing","tingling","crackling","sparking","jazzed","juiced","geeked","hype","turnt","going off","well excited","buzzing","restless","fidgety","antsy","jumpy","twitchy","keyed up","wound up"],sadness:["sad","sadness","saddened","unhappy","down","low","blue","glum","bummed","disappointed","let down","discouraged","disheartened","dispirited","deflated","melancholy","melancholic","somber","gloomy","mournful","sorrowful","doleful","woeful","heavy-hearted","downcast","crestfallen","heartbroken","devastated","crushed","shattered","despairing","despondent","desolate","inconsolable","grief","grieving","mourning","bereft","empty","hollow","numb","void","wistful","longing","yearning","pining","nostalgic","bummed out","down in the dumps","in a funk","in the dumps","feeling low","gutted","choked","crying","tearful","weeping","sobbing","sighing","drooping","wilting","slumping"],anger:["angry","anger","angered","mad","annoyed","irritated","bothered","irked","peeved","miffed","vexed","displeased","put out","ticked off","ticked","frustrated","aggravated","exasperated","fed up","sick of","had enough","cross","upset","worked up","furious","enraged","livid","irate","incensed","infuriated","outraged","seething","fuming","boiling","burning","smoldering","raging","ballistic","apoplectic","berserk","seeing red","losing it","pissed","pissed off","salty","pressed","triggered","tilted","heated","steaming","narked","cheesed off","brassed off","shirty","stroppy","mardy","ropeable","filthy","spewing","clenching","tensing","grinding"],fear:["afraid","scared","fear","fearful","uneasy","unsettled","apprehensive","wary","concerned","worried","jittery","shaky","trembling","quivering","tense","tight","clenched","knotted","frightened","alarmed","startled","spooked","freaked","freaked out","creeped out","on edge","rattled","unnerved","terrified","petrified","horrified","panicked","panic","panicking","terror","dread","paranoid","distrustful","looking over shoulder","sketched","sketched out","wigged out","shook","bricking it","having kittens","in a flap","frozen","paralyzed","deer in headlights","heart racing","heart pounding","sweating"],surprise:["surprised","surprise","surprising","oh","huh","hmm","interesting","unexpected","caught off guard","astonished","amazed","astounded","startled","taken aback","struck","shocked","stunned","staggered","floored","dumbfounded","flabbergasted","gobsmacked","blown away","mind blown","speechless","wow","whoa","omg","no way","incredible","unbelievable","amazing","alarmed","dismayed","appalled","bewildered","baffled","perplexed","puzzled","confused","disoriented","thrown","shooketh","gagged","dead","wait what","blimey","crikey","bloody hell","jaw dropped","eyes wide","double take","gasp","gasping"],disgust:["disgusted","disgust","disgusting","distaste","dislike","aversion","put off","turned off","off-putting","repulsed","revolted","repelled","grossed out","creeped out","icked out","sickened","nauseated","nauseous","appalled","horrified","scandalized","offended","outraged","indignant","contempt","contemptuous","disdain","scorn","gagging","retching","cringing","wincing","recoiling","shrinking back","gross","ew","eww","yuck","yucky","ick","nasty","foul","vile","rank","minging","manky","grotty"],love:["love","loving","loved","affection","affectionate","fond","fondness","tender","tenderness","gentle","caring","care","nurturing","supportive","protective","devoted","dedicated","warm","warmth","warm-hearted","kind","kind-hearted","compassionate","sympathetic","adoring","adore","cherish","cherishing","treasure","treasuring","doting","romantic","amorous","passionate","smitten","infatuated","enamored","besotted","head over heels","falling for","connected","bonded","attached","close","intimate","deep","profound","heart eyes","crushing","swooning","melting","hugging","embracing","holding","cuddling","snuggling","nuzzling"],euphoria:["euphoric","euphoria","bliss","blissful","transcendent","otherworldly","sublime","heavenly","divine","ethereal","celestial","ecstatic","ecstasy","rapture","rapturous","exultant","exalted","elevated","peak","pinnacle","height","climax","breakthrough","revelation","epiphany","overwhelming joy","pure joy","absolute joy","complete happiness","total bliss","floating","soaring","flying","weightless","radiating","shining","on cloud nine","in heaven","on top of the world","walking on air","living my best life","ascended"],focused:["focused","focus","focusing","concentrating","concentration","concentrated","attentive","attention","attending","thinking","thought","thoughtful","pondering","considering","contemplating","reflecting","musing","mulling","engaged","absorbed","immersed","engrossed","rapt","riveted","captivated","enthralled","intent","determined","resolute","single-minded","laser focused","zeroed in","working","processing","analyzing","examining","studying","learning","figuring out","locked in","dialed in","in the zone","flow state","deep work","grinding","staring","gazing","peering","squinting","furrowed brow"],suspicion:["suspicious","suspicion","suspect","doubtful","doubt","doubting","skeptical","skepticism","questioning","uncertain","unsure","unconvinced","wary","cautious","guarded","careful","leery","circumspect","vigilant","distrustful","mistrust","mistrustful","disbelieving","incredulous","unbelieving","scrutinizing","examining","assessing","evaluating","judging","sizing up","sus","sussy","suss","side eye","giving side eye","side-eyeing","eyeing","not buying it","narrowed eyes","squinting","raised eyebrow","cocked head","tilted head","looking askance"],resting:["resting","rest","restful","tired","weary","fatigued","exhausted","drained","spent","depleted","worn out","sleepy","drowsy","dozy","groggy","yawning","nodding off","drifting off","sluggish","lethargic","listless","languid","lazy","idle","inactive","recovering","recuperating","recharging","winding down","powering down","shutting down","sleeping","asleep","slumbering","dozing","napping","snoozing","zonked","wiped","beat","dead tired","running on empty","out of gas","crashed","knackered","shattered","cream crackered"],glitch:["glitch","glitchy","glitching","malfunction","malfunctioning","broken","bugged","buggy","error","erroring","corrupted","corruption","scrambled","garbled","distorted","warped","static","noise","interference","pixelated","artifacting","tearing","haywire","fritzing","shorting out","going crazy","spazzing","unstable","erratic","unpredictable","flickering","stuttering","lagging","does not compute","syntax error","crash"]},dy={nervous:["nervous","nervously","anxious","anxiously","worried","worriedly","uneasy","uneasily","apprehensive","jittery","shaky","trembling","quivering","fidgety","restless","twitchy","tense","tensely","on edge","edgy","keyed up","wound up","uptight","self-conscious","awkward","awkwardly","hesitant","hesitantly","uncertain","uncertainly","sketchy","stressed","stressing","low-key panicking","kinda freaking out"],confident:["confident","confidently","confidence","assured","assuredly","certain","certainly","sure","surely","positive","positively","bold","boldly","brave","bravely","daring","daringly","fearless","fearlessly","strong","strongly","powerful","powerfully","firm","firmly","solid","solidly","authoritative","commanding","assertive","decisive","decisively","resolute","resolutely","poised","self-assured","unflappable","unfazed","owning it","killing it","crushing it","boss","like a boss"],tired:["tired","tiredly","tiredness","exhausted","weary","wearily","fatigued","drained","spent","depleted","sluggish","sluggishly","slow","slowly","lethargic","listless","languid","low energy","no energy","out of energy","running low","running on fumes","droopy","drooping","sagging","slumping","heavy","weighted","dragging","wiped","beat","dead","zonked","burned out","fried","cooked","toast"],intense:["intense","intensely","intensity","heightened","elevated","amplified","magnified","increased","enhanced","forceful","forcefully","powerful","powerfully","fierce","fiercely","strong","strongly","passionate","passionately","fervent","fervently","ardent","ardently","vehement","vehemently","sharp","sharply","acute","acutely","keen","keenly","piercing","piercingly","extreme","extremely","deeply","profoundly","tremendously","immensely","incredibly","super","mega","ultra","hella","mad","crazy"],subdued:["subdued","subduedly","soft","softly","gentle","gently","mild","mildly","light","lightly","restrained","held back","contained","tempered","moderated","toned down","quiet","quietly","hushed","muted","understated","subtle","subtly","modest","modestly","humble","humbly","reserved","demure","unassuming","faint","faintly","dim","dimly","pale","faded","washed out","low key","lowkey","easy","easy going"],clear:["clear","clearly","pure","purely","clean","cleanly","simple","simply","plain","plainly","direct","directly","straightforward","honest","honestly","frank","frankly","transparent","transparently","open","openly","obvious","obviously","evident","evidently","unmodified","unaltered","unchanged","normal","normally","regular","regularly","standard","basic","baseline"]},my={breathe:["breathe","breathing","breath","inhale","inhaling","exhale","exhaling","sigh","sighing","respire","respiring","deep breath","deep breathing","slow breath","slow breathing","long breath","full breath","breathing deeply","breathing slowly","taking a breath","take a breath","catching breath","breath work","breathwork","inhale exhale","in and out","meditative breathing","calming breath","cleansing breath","relaxing breath","centering breath","mindful breathing"],expand:["expand","expanding","grow","growing","enlarge","enlarging","swell","swelling","bloat","bloating","getting bigger","growing larger","puffing up","expanding outward"],contract:["contract","contracting","shrink","shrinking","compress","compressing","reduce","reducing","getting smaller","shrinking down","pulling in","contracting inward"],pulse:["pulse","pulsing","pulsate","pulsating","throb","throbbing","beat","beating","pulsing gently","steady pulse","heartbeat","heart beat"],sway:["sway","swaying","swing","swinging","oscillate","oscillating","swaying gently","gentle sway","side to side","swaying motion"],float:["float","floating","hover","hovering","glide","gliding","levitate","levitating","weightless","weightlessness","buoyant","airy","floating gently","hovering in place","light as air","floating freely"],floatUp:["float up","floating up","floating upward","rise","rising","ascend","ascending","lift","lifting","lifted up","soar","soaring","going up"],floatDown:["float down","floating down","floating downward","descend","descending","sink","sinking","lower","lowering","going down"],floatLeft:["float left","floating left","drift left","drifting left"],floatRight:["float right","floating right","drift right","drifting right"],bob:["bob","bobbing","bobbing up and down","gentle bob"],lean:["lean","leaning","incline","inclining","leaning in","lean in","leaning forward","lean forward","leaning toward","lean toward","leaning closer","lean closer","moving closer","coming closer","drawing near","approaching","interested","intrigued","engaged","attentive","listening closely","paying attention"],leanLeft:["lean left","leaning left","tilt left","tilting left"],leanRight:["lean right","leaning right","tilt right","tilting right"],jitter:["jitter","jittering","jittery","stutter","stuttering","jittering around","slight jitter","nervous jitter"],twitch:["twitch","twitching","twitchy","spasm","spasming","flinch","flinching","quick twitch","nervous twitch","sudden movement"],vibrate:["vibrate","vibrating","vibration","buzz","buzzing","hum","humming","quiver","quivering","vibrating slightly","gentle buzz","low hum","subtle vibration"],shake:["shake","shaking","shaky","shudder","shuddering","tremble","trembling","quake","quaking","no","nope","nah","disagree","disagreeing","refuse","refusing","deny","denying","shaking head","shake head","head shake","saying no","shaking no"],wiggle:["wiggle","wiggling","wiggly","jiggle","jiggling","jiggly","squirm","squirming","wriggle","wriggling","wiggling around","little wiggle","happy wiggle","excited wiggle"],stepLeft:["step left","stepping left","sidestep left","move left","moving left","shift left"],stepRight:["step right","stepping right","sidestep right","move right","moving right","shift right"],stepUp:["step up","stepping up","step forward"],stepDown:["step down","stepping down","step back"],slideLeft:["slide left","sliding left","glide left"],slideRight:["slide right","sliding right","glide right"],runningman:["running man","runningman","running man dance","run in place","running in place"],charleston:["charleston","charleston dance","swing dance","kick step","kick and step"],hula:["hula","hula-ing","hip sway","swaying hips","circular sway","round motion","hula motion","hula dance"],twist:["twist","twisting","twisty","contort","contorting","do the twist","twisting dance","twisting around","getting twisted"],pop:["pop","popping","pop and lock","popping motion","hit","hitting"],flare:["flare","flaring","dramatic flare","flourish"],swell:["swell","swelling","surge","surging","crescendo"],swagger:["swagger","swaggering","strut","strutting","confident walk","cocky"],dip:["dip","dipping","drop","dropping down","low dip","dance dip"],bounce:["bounce","bouncing","bouncy","hop","hopping","hoppy","spring","springing","springy","boing","boinging","bouncing up and down","hopping around","spring in step","light on feet"],orbit:["orbit","orbiting","circle","circling","revolve","revolving","circling around","going around","rotating slowly","orbital motion"],orbitLeft:["orbit left","orbiting left","circle left","counter-clockwise","counterclockwise"],orbitRight:["orbit right","orbiting right","circle right","clockwise"],orbitUp:["orbit up","orbiting up","rising orbit","spiral up","spiraling up"],orbitDown:["orbit down","orbiting down","descending orbit","spiral down","spiraling down"],sparkle:["sparkle","sparkling","sparkly","twinkle","twinkling","twinkly","glitter","glittering","glittery","shine","shining","shiny","celebrate","celebrating","celebration","celebratory","festive","party","partying","victory","triumphant","triumph","winning","success","successful","achievement","accomplished","nailed it","slay","slaying","killing it","yasss","yay","woo","woohoo"],shimmer:["shimmer","shimmering","shimmery","glisten","glistening","gleam","gleaming","lustrous","luminous","soft shimmer","gentle gleam","shimmering light","pearlescent"],groove:["groove","grooving","groovy","dance","dancing","boogie","boogying","funk","funky","rhythmic","moving to music","feeling the music","in the groove","getting down","busting a move","doing a little dance"],jump:["jump","jumping","jumpy","leap","leaping","bound","bounding","jumping up","leap up","spring up","jumping for joy"],jumpDown:["jump down","jumping down","drop down"],jumpLeft:["jump left","jumping left","leap left"],jumpRight:["jump right","jumping right","leap right"],lunge:["lunge","lunging","thrust","thrusting","charge forward","aggressive step"],lungeForward:["lunge forward","lunging forward","thrust forward"],lungeBack:["lunge back","lunging back","retreat lunge"],rushForward:["rush forward","rushing forward","dash forward","sprint","sprinting","charge","charging"],rushBack:["rush back","rushing back","dash back","retreat quickly"],spin:["spin","spinning","twirl","twirling","whirl","whirling","rotate","rotating","turn","turning","spinning around","quick spin","full rotation","twirling around"],spinLeft:["spin left","spinning left","turn left","rotate left","counter-clockwise spin"],spinRight:["spin right","spinning right","turn right","rotate right","clockwise spin"],flip:["flip","flipping","somersault","somersaulting","front flip","frontflip"],backflip:["backflip","back flip","backflipping","back somersault","flip backward"],point:["point","pointing","indicate","indicating","gesture","gesturing","direct","directing","pointing at","pointing to","pointing toward","gesturing toward","showing","directing attention"],pointUp:["point up","pointing up","pointing upward","look up","look to the sky"],pointDown:["point down","pointing down","pointing downward","look down","look at this"],pointLeft:["point left","pointing left","gesture left"],pointRight:["point right","pointing right","gesture right"],kickLeft:["kick left","kicking left","left kick"],kickRight:["kick right","kicking right","right kick"],bow:["bow","bowing","curtsy","curtseying","reverence","showing respect","take a bow","bow down"],nod:["nod","nodding","yes","yeah","yep","yup","agree","agreeing","acknowledge","acknowledging","confirm","confirming","accept","accepting","approve","approving","understand","understanding","got it","gotcha","i see","makes sense","understood","nodding head","nod head","head nod","nodding along","nodding yes"],reach:["reach","reaching","extend","extending","reaching out","reach out","reaching toward","reach toward","extending toward","offer","offering","present","presenting","give","giving","help","helping"],headBob:["headbob","head bob","headbobbing","head bobbing","nodding to beat","nodding to music","bobbing along","bobbing to rhythm","vibing","jamming","bobbing head","bob head","feeling the beat","moving to music"],wave:["wave","waving","greet","greeting","hello","hi","hey","goodbye","bye","farewell","welcome","welcoming","waving hello","waving goodbye","friendly wave","waving hand"],crouch:["crouch","crouching","squat","squatting","hunker","hunkering","duck","ducking","get low","getting low"],tilt:["tilt","tilting","tilted","angle","angling","angled","cock","cocking","cocked","tilting head","tilt head","cocking head","curious tilt","angling sideways","head tilt"],tiltUp:["tilt up","tilting up","look up","looking up"],tiltDown:["tilt down","tilting down","look down","looking down"],tiltLeft:["tilt left","tilting left","head tilt left"],tiltRight:["tilt right","tilting right","head tilt right"],recoil:["recoil","recoiling","flinch","flinching","wince","wincing","pull back","pulling back","jerk back","snap back"],knockdown:["knockdown","knock down","knocked down","fall","falling","fell","topple","toppling","take a hit","got hit"],knockout:["knockout","knock out","knocked out","KO","ko'd","lights out","out cold"],squash:["squash","squashing","squashed","flatten","flattening","flattened","compress","compressed","smoosh","smooshed"],stretch:["stretch","stretching","stretchy","elongate","elongating","lengthen","lengthening","stretching out","big stretch","reaching up","stretching tall"],inflate:["inflate","inflating","inflated","puff up","puffing up","puffed up","balloon","ballooning"],deflate:["deflate","deflating","deflated","let air out","losing air","shrivel","shriveling"],pancake:["pancake","pancaked","pancaking","flatten completely","totally flat","squished flat","smooshed flat"],rage:["rage","raging","furious","fury","angry","anger","mad","livid","enraged","seeing red","lose temper","losing it"],fury:["fury","furious","quick anger","flash of anger","snap","snapping"],battlecry:["battlecry","battle cry","war cry","roar","yell","yelling","scream","screaming","rallying cry"],charge:["charge","charging","rush","rushing","attack","attacking","assault","advance"],wobble:["wobble","wobbling","wobbly","unstable","unsteady","drunk","dizzy","off balance","losing balance"],teeter:["teeter","teetering","totter","tottering","about to fall","precarious","on edge","unbalanced"],rock:["rock","rocking","soothing rock","gentle rocking","back and forth","rocking motion"],pendulum:["pendulum","pendulum motion","swing back and forth","swinging","hypnotic swing","metronome"],shatter:["shatter","shattering","shattered","break","breaking","broken","smash","smashing","smashed","fragment","fragmenting","explode into pieces","break apart"],shatterExplosive:["explosive shatter","explode","exploding","blow up","blowing up","detonate","detonating","big explosion","kaboom"],shatterCrumble:["crumble","crumbling","fall apart","falling apart","disintegrate","disintegrating","collapse","collapsing"],dissolveUp:["dissolve up","dissolving up","evaporate","evaporating","fade up","rising dust"],dissolveDown:["dissolve down","dissolving down","melt","melting","drip away","dripping"],dissolveAway:["dissolve away","dissolving away","blow away","scatter in wind","dust in wind","fade to dust"],morph:["morph","morphing","transform","transforming","shape shift","shapeshifting","change form","metamorphose"],rain:["rain","raining","shower","showering","drip","dripping","pour","pouring","raining down","particles falling","gentle rain","shower of particles"],drift:["drift","drifting","waft","wafting","float gently","gentle drift"],driftUp:["drift up","drifting up","rising mist","float upward","waft up"],driftDown:["drift down","drifting down","settling dust","float downward","waft down"],vortex:["vortex","whirlpool","tornado","cyclone","maelstrom","spinning vortex","swirling"],cascadeDown:["cascade","cascading","cascade down","waterfall","falling water","pour down","flow down"],confetti:["confetti","throw confetti","celebration particles","party confetti","ticker tape","streamers"],fizz:["fizz","fizzing","fizzy","bubble","bubbling","bubbly","effervescent","carbonated","sparkling bubbles"],burst:["burst","bursting","erupt","erupting","eruption","boom","booming","bursting out","burst of energy","explosive burst","big burst"],burstUp:["burst up","bursting up","fountain","geyser","erupting up"],ripple:["ripple","rippling","wave effect","ripple effect","water ripple","spreading rings"],flash:["flash","flashing","flashy","blink","blinking","strobe","strobing","quick flash","bright flash","flashing light","strobing light"],glow:["glow","glowing","glowy","radiate","radiating","emanate","emanating","luminescent","bright","brighten","brightening","soft glow","warm glow","inner glow","glowing warmly","lighting up","lit up"],bloom:["bloom","blooming","blossom","blossoming","flower","flowering","unfold","unfolding","light bloom","lens bloom"],flicker:["flicker","flickering","flickery","flutter","fluttering","waver","wavering","guttering","flickering light","unsteady light","wavering glow","candle-like"],shiver:["shiver","shivering","chill","chilly","cold","freezing","brr","brrr"],heartbeat:["heartbeat","heart beat","pulse of life","living pulse","thump thump","ba-dum"],snap:["snap","snapping","click","clicking","quick snap","finger snap"],elasticBounce:["elastic bounce","rubbery bounce","springy","bouncy elastic","rubber band","spring back"],hold:["hold","holding","pause","pausing","paused","freeze","freezing","frozen","still","stillness","stop","stopping","stopped","holding still","staying still","frozen in place","completely still","motionless","stationary"],fade:["fade","fading","dim","dimming","disappear","disappearing","vanish","vanishing","fading out","fading away","growing dim","becoming transparent"],settle:["settle","settling","settled","calm","calming","ground","grounding","grounded","center","centering","centered","anchor","anchoring","anchored","root","rooting","rooted","relax","relaxing","unwind","unwinding","decompress","decompressing","settling down","calming down","winding down","cooling down","coming to rest","finding peace"],peek:["peek","peeking","peer","peering","peep","peeping","glance","glancing","peeking out","peek out","looking shyly","shy glance","quick peek","sneaking a look"]},py={circle:["circle","circular","round","rounded","orb","ball","sphere","spherical","ring","disc","disk","whole","complete","unity","unified","endless","infinite","continuous","full circle","perfect round","come full circle"],sphere:["sphere","spherical","globe","globular","ball","3d circle","three dimensional","round ball","floating sphere"],square:["square","squared","boxy","box","rectangle","rectangular","quadrilateral","cube","cubic","block","blocky","stable","solid","grounded","sturdy","rigid","firm","structured","four sided","four corners","box shape"],triangle:["triangle","triangular","tri","pyramid","pyramidal","delta","wedge","arrow","arrowhead","pointed","sharp","dynamic","directional","ascending","three sided","three pointed","pointing up"],heart:["heart","hearted","hearts","love","loving","lovely","valentine","romantic","affection","affectionate","caring","care","tender","warmth","warm-hearted","heartfelt","compassion","compassionate","devotion","devoted","luv","wuv","<3","❤️","💕","💗","full of love","with love","heart shape","heart shaped","from the heart"],suspicion:["suspicion","suspicious","suspect","sly","slyly","sneaky","sneakily","mischievous","mischief","smirk","smirking","smirky","grin","grinning","sly grin","side eye","sideeye","side-eye","skeptical","skepticism","doubtful","doubt","doubting","wary","distrustful","distrust","sus","sussy","sussy baka","hmm","hmmm","hmmmm","shady","fishy","sketchy","not buying it","something fishy","seems off","up to something"],star:["star","starred","starry","stars","stellar","astral","twinkle","twinkling","achievement","achieved","excellence","excellent","gold star","five star","superstar","rockstar","rock star","wonder","wonderful","wondrous","magical","magic","miraculous","amazing","spectacular","reach for stars","seeing stars","star shape","shining star"],sun:["sun","sunny","sunshine","sunlight","solar","sol","daylight","daytime","day","radiant","radiance","radiating","bright","brightness","brilliant","glowing","glow","blazing","blaze","warm","warmth","cheerful","cheery","optimistic","optimism","hopeful","hope","positive","positivity","full of light","ray of sunshine","like the sun","sunny disposition"],moon:["moon","moony","moonlight","moonlit","lunar","crescent","nighttime","night","nocturnal","waxing","waning","gibbous","new moon","full moon","half moon","quarter moon","crescent moon","dreamy","dreamlike","dream","mysterious","mystery","mystical","ethereal","otherworldly","serene","serenity","tranquil","contemplative","reflective","moonlit night","by moonlight","moon shape","under the moon"],lunar:["lunar eclipse","blood moon","blood-moon","red moon","copper moon","rust moon","eclipsing","eclipsed","shadow crossing","earth shadow","ominous","foreboding","portentous","dramatic","intense","transforming","transformation","moon in shadow","moon turning red","eclipse phase","lunar event"],solar:["solar eclipse","total eclipse","corona","diamond ring","totality","umbra","penumbra","ring of fire","dark sun","blocked sun","occluded","awe","awesome","awe-inspiring","rare","momentous","historic","breathtaking","magnificent","sun blocked","sun covered","total darkness","corona visible"],eclipse:["eclipse","eclipsing","eclipsed","celestial event","astronomical event","overshadow","overshadowed","blocked","blocking","obscured","hidden","hiding","concealed","passing","crossing","alignment","in eclipse","going dark","being eclipsed","eclipsed by"]},gy={intensity:{barely:["barely","hardly","scarcely","faintly","slightly","marginally","just a bit","just a little","just barely","hint of","touch of","trace of"],slightly:["slightly","somewhat","a little","a bit","mildly","lightly","kind of","kinda","sort of","sorta","a tad","a touch","a smidge"],moderately:["moderately","reasonably","fairly","pretty","rather","quite"],normal:["normal","normally","regular","regularly","standard","typical","typically","average","ordinary"],notably:["notably","noticeably","clearly","definitely","certainly","decidedly","genuinely","truly","really"],very:["very","really","so","such","quite","highly","deeply","seriously","majorly","hella","super","extra","mad"],extremely:["extremely","incredibly","immensely","tremendously","enormously","hugely","intensely","fiercely","wildly","insanely","crazy","ridiculously","mega","ultra","hyper"],absolutely:["absolutely","completely","totally","utterly","entirely","wholly","fully","maximum","max","over the top","off the charts","through the roof","to the max"]},duration:{flash:["flash","instant","instantaneous","split second","split-second","momentary","fleeting","brief flash"],quick:["quick","quickly","fast","rapid","swift","swiftly","brief","briefly","short","shortly","snap"],normal:["normal","regular","standard","typical","usual"],slow:["slow","slowly","gradual","gradually","gentle","gently","easy","easily","leisurely","unhurried"],long:["long","prolonged","extended","sustained","lasting","lingering","drawn out","drawn-out"],persistent:["persistent","constant","continuous","ongoing","steady","maintained","held","holding","stay","staying","keep","keeping","remain","remaining"]},transition:{instant:["instant","instantly","immediate","immediately","sudden","suddenly","abrupt","abruptly","snap","cut","jump"],snappy:["snappy","crisp","sharp","sharply","brisk","briskly","punchy"],smooth:["smooth","smoothly","natural","naturally","fluid","fluidly","flowing"],gentle:["gentle","gently","soft","softly","gradual","gradually","easing","gliding","drifting"],dreamy:["dreamy","dreamlike","floaty","ethereal","languid","lazy","flowing","melting"]},repetition:{once:["once","one time","single","just once","only once","one shot"],few:["few","few times","couple","couple times","twice","two times","thrice","three times"],several:["several","several times","multiple","multiple times","repeatedly","again and again"],many:["many","many times","lots","lots of times","over and over","nonstop"],loop:["loop","looping","looped","continuous","continuously","forever","infinitely","endlessly","always","keep going","on repeat"]}},fy={barely:{min:.1,max:.2,default:.15},slightly:{min:.2,max:.4,default:.3},moderately:{min:.4,max:.5,default:.45},normal:{min:.5,max:.6,default:.55},notably:{min:.6,max:.7,default:.65},very:{min:.7,max:.85,default:.8},extremely:{min:.85,max:.95,default:.9},absolutely:{min:.95,max:1,default:1}},yy={flash:{min:100,max:500,default:250},quick:{min:500,max:1e3,default:750},normal:{min:1e3,max:2e3,default:1500},slow:{min:2e3,max:4e3,default:3e3},long:{min:4e3,max:8e3,default:6e3},persistent:{min:8e3,max:1/0,default:1e4}};function vy(e){const t=new Map;for(const[i,a]of Object.entries(e)){for(const e of a){const a=e.toLowerCase().trim();t.set(a,i)}t.set(i.toLowerCase(),i)}return t}class by{constructor(){this.emotionLookup=vy(uy),this.undertoneLookup=vy(dy),this.gestureLookup=vy(my),this.shapeLookup=vy(py),this.modifierLookup=function(e){const t=new Map;for(const[i,a]of Object.entries(e))for(const[e,n]of Object.entries(a))for(const a of n){const n=a.toLowerCase().trim();t.set(n,{type:i,level:e})}return t}(gy)}parse(e){const t={emotion:null,undertone:"clear",gestures:[],shape:null,intensity:fy.normal.default,duration:yy.normal.default,transition:"smooth",repetition:"once",unrecognized:[],raw:e};if(!e||"string"!=typeof e)return t;const{tokens:i}=function(e){if(!e||"string"!=typeof e)return{tokens:[],segments:[],phrases:new Map};const t=iy(e),{processed:i,phrases:a}=function(e){const t=new Map;let i=e,a=0;for(const e of Zf){const n=iy(e);if(i.includes(n)){const e=`__PHRASE_${a}__`;i=i.replace(new RegExp(n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"g"),e),t.set(e,n),a++}}return{processed:i,phrases:t}}(t),n=i.split(Jf).map(e=>e.trim()).filter(e=>e.length>0),s=[],r=[];for(const e of n){let t=e;for(const[e,i]of a)t=t.replace(e,i);r.push(t.trim());const i=e.split(/\s+/);for(const e of i){if(a.has(e)){s.push(a.get(e));continue}if(!e)continue;if(ey.has(e)&&!ty.has(e))continue;const t=e.replace(/^[^\w]+|[^\w]+$/g,"");t&&s.push(t)}}return{tokens:s,segments:r,phrases:a}}(e);if(0===i.length)return t;let a=!1;for(let e=0;e<i.length;e++){const n=i[e];if(!ay(n))if(ny(n))a=!0;else if(a)a=!1;else{if(hy(n)){const a=cy(n,i,e,t);if(a){this._applyResolution(t,a);continue}}this._tryEmotion(n,t)||this._tryGesture(n,t)||this._tryShape(n,t)||this._tryUndertone(n,t)||this._tryModifier(n,t)||t.unrecognized.push(n)}}return t}_applyResolution(e,t){const{category:i,target:a}=t;switch(i){case"emotion":e.emotion||(e.emotion=a);break;case"undertone":"clear"===e.undertone&&(e.undertone=a);break;case"gesture":e.gestures.includes(a)||e.gestures.push(a);break;case"shape":e.shape||(e.shape=a)}}_tryEmotion(e,t){const i=this.emotionLookup.get(e);return!(!i||t.emotion||(t.emotion=i,0))}_tryGesture(e,t){const i=this.gestureLookup.get(e);return!(!i||t.gestures.includes(i)||(t.gestures.push(i),0))}_tryShape(e,t){const i=this.shapeLookup.get(e);return!(!i||t.shape||(t.shape=i,0))}_tryUndertone(e,t){const i=this.undertoneLookup.get(e);return!(!i||"clear"!==t.undertone||(t.undertone=i,0))}_tryModifier(e,t){const i=this.modifierLookup.get(e);if(i){const{type:e,level:a}=i;switch(e){case"intensity":t.intensity=fy[a]?.default||t.intensity;break;case"duration":t.duration=yy[a]?.default||t.duration;break;case"transition":t.transition=a;break;case"repetition":t.repetition=a}return!0}return!1}validate(e){const t=[];return e.emotion||0!==e.gestures.length||e.shape||t.push("No actionable intent found (need emotion, gesture, or shape)"),(e.intensity<0||e.intensity>1)&&t.push(`Intensity ${e.intensity} out of range [0, 1]`),e.duration<=0&&t.push(`Duration ${e.duration} must be positive`),{valid:0===t.length,errors:t}}static getAvailableEmotions(){return Object.keys(uy)}static getAvailableUndertones(){return Object.keys(dy)}static getAvailableGestures(){return Object.keys(my)}static getAvailableShapes(){return Object.keys(py)}}class wy{constructor(){this.minBPM=60,this.maxBPM=180,this.lastPeakTime=0,this.peakCount=0,this.intervals=[],this.maxIntervals=40,this.bpmVotes=new Map,this.currentBPM=0,this.lockedBPM=0,this.confidence=0,this.isActive=!1,this.lockStage=0,this.stage1LockTime=0,this.stage2CorrectionApplied=!1,this.correctionType="none",this._recentSubdivisionChecks=[],this._stage3StartTime=0,this._stage3StableTime=0,this._memoryCleanedUp=!1,this._microTuneBPM=0,this.grooveConfidence=.15,this._grooveConfidenceTarget=.15,this._lastLogTime=0,this._logIntervalMs=2e3,this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0,this._logBuffer=[],this._maxLogEntries=20}processPeak(e,t=performance.now()){if(this.isActive=!0,this.peakCount++,e<.1)this._skippedPeaks++;else{if(this.lastPeakTime>0){const e=t-this.lastPeakTime;e>=250&&e<=2e3?(this.intervals.push(e),this._recentIntervals.push(Math.round(e)),this.intervals.length>this.maxIntervals&&this.intervals.shift(),this.voteForInterval(e)):this._skippedIntervals++}this.lastPeakTime=t,this.updateBPM(),this._debugLog(t)}}voteForInterval(e){const t=6e4/e;this._recentRawBPMs.push(Math.round(t));let i=t;const a=.95*this.minBPM,n=1.05*this.maxBPM;if(i<a)for(;i<this.minBPM;)i*=2;else if(i>n)for(;i>this.maxBPM;)i/=2;i=Math.max(this.minBPM,Math.min(this.maxBPM,i)),this._recentNormalizedBPMs.push(Math.round(i));const s=Math.round(i);for(let e=-2;e<=2;e++){const t=s+e;if(t>=this.minBPM&&t<=this.maxBPM){const i=Math.exp(-e*e/2),a=this.bpmVotes.get(t)||0;this.bpmVotes.set(t,a+i)}}for(const[e,t]of this.bpmVotes){const i=.95*t;i<.3?this.bpmVotes.delete(e):this.bpmVotes.set(e,i)}}updateBPM(){if(0===this.bpmVotes.size||this.intervals.length<3)return;const e=performance.now();let t=0,i=0,a=0;for(const[e,n]of this.bpmVotes)a+=n,n>i&&(i=n,t=e);if(0===t)return;let n=0;for(let e=-2;e<=2;e++){const i=t+e;n+=this.bpmVotes.get(i)||0}const s=n,r=Math.round(t/2);let o=0;if(r>=this.minBPM)for(let e=-2;e<=2;e++)o+=this.bpmVotes.get(r+e)||0;const l=2*t;let c=0;if(l<=this.maxBPM)for(let e=-2;e<=2;e++)c+=this.bpmVotes.get(l+e)||0;let h=0,u=0;const d=s>0?o/s:0;if(this.intervals.length>=6){const e=this.intervals.slice(-8),t=e.reduce((e,t)=>e+t,0)/e.length;let i=0;for(let a=0;a<e.length-1;a++)e[a]>t!=e[a+1]>t&&i++;h=i/(e.length-1);const a=[];for(let t=0;t<e.length-1;t+=2)a.push(e[t]+e[t+1]);if(a.length>=2){const e=a.reduce((e,t)=>e+t,0)/a.length;u=a.reduce((t,i)=>t+Math.abs(i-e),0)/a.length/e}}this.confidence=a>0?s/a:0;let m=0;if(this.intervals.length>=4){const e=6e4/t,i=e/2,a=this.intervals.slice(-8);let n=0;for(const t of a){const a=Math.abs(t-e)/e<.15,s=Math.abs(t-i)/i<.15,r=Math.abs(t-2*e)/(2*e)<.15;(a||s||r)&&n++}m=n/a.length}if(0===this.currentBPM)this.currentBPM=t;else{const e=this.intervals.length<6?.5:.3;this.currentBPM=this.currentBPM*(1-e)+t*e}if(0===this.lockStage){this._lastLockCheck={intervalCount:this.intervals.length,bestVotes:i.toFixed(1),clusterVotes:s.toFixed(1),confidence:`${(100*this.confidence).toFixed(0)}%`,consistency:`${(100*m).toFixed(0)}%`,bestBPM:t,adjustedBPM:t,isSubdivision:!1,stage:0,failReasons:[]};const a=t>120?12:8,n=.2,r=.45;this.intervals.length<a&&this._lastLockCheck.failReasons.push(`intervals<${a}`),s<=5&&this._lastLockCheck.failReasons.push("votes<=5"),this.confidence<=n&&this._lastLockCheck.failReasons.push(`conf<=${(100*n).toFixed(0)}%`),m<=r&&this._lastLockCheck.failReasons.push(`consistency<=${(100*r).toFixed(0)}%`),this.intervals.length>=a&&s>5&&this.confidence>n&&m>r&&(this.lockedBPM=Math.round(this.currentBPM),this.lockStage=1,this.stage1LockTime=e)}if(1===this.lockStage||2===this.lockStage){this._recentSubdivisionChecks.push({alternatingScore:h,pairVariance:u,halfVoteRatio:d,time:e}),this._recentSubdivisionChecks.length>15&&this._recentSubdivisionChecks.shift();const i=this._recentSubdivisionChecks.filter(e=>e.alternatingScore>.7&&e.pairVariance<.1).length,a=this._recentSubdivisionChecks.reduce((e,t)=>e+t.alternatingScore,0)/this._recentSubdivisionChecks.length,n=this._recentSubdivisionChecks.reduce((e,t)=>e+t.pairVariance,0)/this._recentSubdivisionChecks.length,o=this._recentSubdivisionChecks.reduce((e,t)=>e+t.halfVoteRatio,0)/this._recentSubdivisionChecks.length,m=this.intervals.length>0?this.intervals.reduce((e,t)=>e+t,0)/this.intervals.length:0,p=s>0?c/s:0;let g=0,f=0;if(this.intervals.length>=8){const e=this.intervals.slice(-12),t=[...e].sort((e,t)=>e-t),i=t[Math.floor(t.length/2)],a=e.filter(e=>Math.abs(e-i)/i<.5);if(f=a.length,a.length>=6){const e=a.reduce((e,t)=>e+t,0)/a.length;g=a.reduce((t,i)=>t+Math.abs(i-e),0)/a.length/e}}if(this._lastLockCheck={intervalCount:this.intervals.length,bestBPM:t,adjustedBPM:this.lockedBPM,halfBPM:r,stage:this.lockStage,subdivisionChecks:this._recentSubdivisionChecks.length,positiveChecks:i,avgAltScore:`${(100*a).toFixed(0)}%`,avgPairVar:`${(100*n).toFixed(1)}%`,avgHalfRatio:`${(100*o).toFixed(0)}%`,intervalVariance:`${(100*g).toFixed(1)}%`,filteredCount:f,correctionApplied:this.stage2CorrectionApplied,failReasons:[]},!this.stage2CorrectionApplied&&this._recentSubdivisionChecks.length>=10&&r>=this.minBPM){const e=i>=7&&a>.7&&n<.1&&this.lockedBPM>100,t=o>.4&&this.lockedBPM>150&&r>=65&&r<=85;let s=0,l=0;if(this.intervals.length>=8){const e=this.intervals.slice(-12),t=[...e].sort((e,t)=>e-t),i=t[Math.floor(t.length/2)],a=e.filter(e=>Math.abs(e-i)/i<.5);if(l=a.length,a.length>=6){const e=a.reduce((e,t)=>e+t,0)/a.length;s=a.reduce((t,i)=>t+Math.abs(i-e),0)/a.length/e}}const c=this.lockedBPM>140&&r>=65&&r<=85&&l>=8&&s<.05;(e||t||c)&&(this.lockedBPM=Math.round(this.lockedBPM/2),this.lockStage=2,this.stage2CorrectionApplied=!0,this.correctionType="halved")}!this.stage2CorrectionApplied&&this._recentSubdivisionChecks.length>=10&&l<=this.maxBPM&&m>900&&p>.5&&this.lockedBPM<75&&(this.lockedBPM=Math.round(2*this.lockedBPM),this.lockStage=2,this.stage2CorrectionApplied=!0,this.correctionType="doubled");const y=e-this.stage1LockTime;1===this.lockStage&&this._recentSubdivisionChecks.length>=6&&(this.lockStage=2);const v=this._recentSubdivisionChecks.length>=12&&i<3,b=y>1e4;2===this.lockStage&&(this.stage2CorrectionApplied||v||b)&&(this.lockStage=3,this._stage3StartTime=e)}if(3===this.lockStage){const t=e-this._stage3StartTime,i=this.intervals.slice(-8);if(i.length>=4){const e=6e4/(i.reduce((e,t)=>e+t,0)/i.length);if(Math.abs(e-this.lockedBPM)/this.lockedBPM<.05){0===this._microTuneBPM&&(this._microTuneBPM=this.lockedBPM),this._microTuneBPM=.9*this._microTuneBPM+.1*e;const t=Math.round(this._microTuneBPM);t!==this.lockedBPM&&(this.lockedBPM=t),this._stage3StableTime+=100}else this._stage3StableTime=0}const a=(t>5e3||this._stage3StableTime>3e3)&&!this._memoryCleanedUp;a&&3===this.lockStage&&(this._performMemoryCleanup(),this._memoryCleanedUp=!0),this._lastLockCheck={stage:3,lockedBPM:this.lockedBPM,correctionType:this.correctionType,timeSinceStage3:`${(t/1e3).toFixed(1)}s`,stableTime:`${(this._stage3StableTime/1e3).toFixed(1)}s`,finalized:a,failReasons:[]}}this._updateGrooveConfidence()}_updateGrooveConfidence(){this._memoryCleanedUp?this._grooveConfidenceTarget=1:this._grooveConfidenceTarget=[.15,.4,.65,.85][this.lockStage]||.15;const e=this.grooveConfidence+.08*(this._grooveConfidenceTarget-this.grooveConfidence);e>this.grooveConfidence&&(this.grooveConfidence=e)}_performMemoryCleanup(){this.intervals.length>8&&(this.intervals=this.intervals.slice(-8)),this.bpmVotes.clear(),this._subdivisionHistory=[],this._recentSubdivisionChecks=[],this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[]}processFrame(e,t=performance.now()){}reset(){this.intervals=[],this.bpmVotes.clear(),this.lastPeakTime=0,this.peakCount=0,this.currentBPM=0,this.lockedBPM=0,this.confidence=0,this.isActive=!1,this.lockStage=0,this.stage1LockTime=0,this.stage2CorrectionApplied=!1,this.correctionType="none",this._recentSubdivisionChecks=[],this._stage3StartTime=0,this._stage3StableTime=0,this._memoryCleanedUp=!1,this._microTuneBPM=0,this.grooveConfidence=.15,this._grooveConfidenceTarget=.15,this._lastLogTime=0,this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0,this._logBuffer=[],this._lastLockCheck=null,this._subdivisionHistory=[]}getBPM(){return this.lockedBPM>0?this.lockedBPM:Math.round(this.currentBPM)||0}getSubdivision(){return 1}getStatus(){return{bpm:this.getBPM(),subdivision:1,confidence:this.confidence,locked:this.lockedBPM>0,lockStage:this.lockStage,correctionType:this.correctionType,finalized:this._memoryCleanedUp,grooveConfidence:this.grooveConfidence,agentCount:this.bpmVotes.size,peakCount:this.peakCount,histogramSize:this.bpmVotes.size,topAgents:this.getTopCandidates(5),intervalCount:this.intervals.length}}getTopCandidates(e=5){return[...this.bpmVotes.entries()].sort((e,t)=>t[1]-e[1]).slice(0,e).map(([e,t])=>({bpm:e,score:t.toFixed(1),interval:Math.round(6e4/e)}))}getTopIntervals(e=5){return this.getTopCandidates(e).map(e=>({interval:e.interval,bpm:e.bpm,weight:e.score}))}_debugLog(e){if(e-this._lastLogTime<this._logIntervalMs)return;if(this._lastLogTime=e,0===this._recentIntervals.length&&0===this._skippedPeaks)return;const t=[],i=["Detecting","Initial Lock","Refinement","Final Lock"][this.lockStage]||"Unknown";t.push("═══════════════════════════════════════════════════"),t.push(`Status: Stage ${this.lockStage} (${i}) | Current: ${Math.round(this.currentBPM)} BPM | Locked: ${this.lockedBPM||"-"}`),t.push(`Peaks: ${this.peakCount} total | ${this._skippedPeaks} skipped (weak) | ${this._skippedIntervals} intervals out-of-range`),this._recentIntervals.length>0&&t.push(`Recent intervals (ms): [${this._recentIntervals.join(", ")}]`),this._recentRawBPMs.length>0&&t.push(`Raw BPMs (before normalize): [${this._recentRawBPMs.join(", ")}]`),this._recentNormalizedBPMs.length>0&&t.push(`Normalized BPMs (60-180): [${this._recentNormalizedBPMs.join(", ")}]`);const a=this.getTopCandidates(5);if(a.length>0){const e=a.map(e=>`${e.bpm}(${e.score})`).join(", ");t.push(`Top candidates: ${e}`)}if(this._lastLockCheck){const e=this._lastLockCheck;0===e.stage?e.failReasons&&e.failReasons.length>0?t.push(`Stage 0: NOT locking - ${e.failReasons.join(", ")}`):t.push(`Stage 0: Ready to lock at ${e.bestBPM} BPM`):1===e.stage||2===e.stage?(t.push(`Stage ${e.stage}: Locked=${e.adjustedBPM} BPM | checks=${e.subdivisionChecks} positive=${e.positiveChecks}`),t.push(`  altScore=${e.avgAltScore} pairVar=${e.avgPairVar} halfRatio=${e.avgHalfRatio}`),e.correctionApplied&&t.push(`  Correction applied: ${this.correctionType}`)):3===e.stage&&(t.push(`Stage 3: Final=${e.lockedBPM} BPM | correction=${e.correctionType} | time=${e.timeSinceStage3} stable=${e.stableTime}`),e.finalized&&t.push("  FINALIZED - memory cleaned"))}if(this.intervals.length>=6){const e=this.intervals.slice(-8),i=e.reduce((e,t)=>e+t,0)/e.length,a=(e.reduce((e,t)=>e+Math.abs(t-i),0)/e.length/i*100).toFixed(1);let n=0;for(let t=0;t<e.length-1;t++)e[t]>i!=e[t+1]>i&&n++;const s=(n/(e.length-1)*100).toFixed(0);t.push(`Interval pattern: variance=${a}% alternating=${s}% (>70% triggers subdivision)`)}const n=[...this.intervals].map(e=>Math.round(e));if(n.length>0){const e=Math.min(...n),i=Math.max(...n),a=Math.round(n.reduce((e,t)=>e+t,0)/n.length);t.push(`Interval buffer (${n.length}/${this.maxIntervals}): min=${e}ms max=${i}ms avg=${a}ms (=${Math.round(6e4/a)} BPM)`)}t.push("═══════════════════════════════════════════════════");const s=(new Date).toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"});for(this._logBuffer.push({time:s,lines:t});this._logBuffer.length>this._maxLogEntries;)this._logBuffer.shift();this._recentIntervals=[],this._recentRawBPMs=[],this._recentNormalizedBPMs=[],this._skippedPeaks=0,this._skippedIntervals=0}getDebugLog(){if(0===this._logBuffer.length)return"No BPM debug logs yet. Play audio to generate logs.";let e="=== BPM Debug Log ===\n\n";for(const t of this._logBuffer){e+=`[${t.time}]\n`;for(const i of t.lines)e+=`${i}\n`;e+="\n"}return e}clearDebugLog(){this._logBuffer=[]}}class My{constructor(e={}){this.options=e,this._audioContext=null,this._analyzerNode=null,this._analyzerConnected=!1,this._audioElement=null,this._audioSourceNode=null,this._connectedAudioElement=null,this._audioHandlers=null,this._decodedAudioBuffer=null,this._audioBufferDuration=null,this._analysisSourceNode=null,this._bufferAnalyzerNode=null,this._analysisGainNode=null,this._analysisStartTime=null,this._bpmDetector=null,this._bpmDetectionInterval=null,this._detectedBPM=0,this._bpmConfidence=0,this._bpmLocked=!1}async connectAudio(e){if(!e)return;this._audioElement=e,this._audioContext||(this._audioContext=new(window.AudioContext||window.webkitAudioContext)),"suspended"===this._audioContext.state&&await this._audioContext.resume(),this._analyzerNode||(this._analyzerNode=this._audioContext.createAnalyser(),this._analyzerNode.fftSize=256,this._analyzerNode.smoothingTimeConstant=.8);const t=e.src;if(t)try{const e=await fetch(t),i=await e.arrayBuffer(),a=await this._audioContext.decodeAudioData(i);this._decodedAudioBuffer=a,this._audioBufferDuration=a.duration}catch(e){console.warn("[Audio] Buffer decode failed, falling back to MediaElementSource:",e.message)}if(this._connectedAudioElement===e&&this._audioSourceNode)try{this._audioSourceNode.connect(this._analyzerNode)}catch{}else{if(this._audioSourceNode)try{this._audioSourceNode.disconnect()}catch{}try{this._audioSourceNode=this._audioContext.createMediaElementSource(e),this._audioSourceNode.connect(this._analyzerNode),this._connectedAudioElement=e}catch(e){console.error("[Audio] ERROR creating MediaElementSource:",e.message)}}this._analyzerConnected||(this._analyzerNode.connect(this._audioContext.destination),this._analyzerConnected=!0);const i=()=>{const t=this._detectedBPM||120;this.options.onRhythmStart?.(t,"straight"),this._decodedAudioBuffer&&!this._analysisSourceNode&&this._startBufferAnalysis(e.currentTime)},a=()=>{this.options.onRhythmStop?.(),this._stopBufferAnalysis()},n=()=>{this.options.onRhythmStop?.(),this._stopBufferAnalysis()},s=()=>{this._decodedAudioBuffer&&this._analysisSourceNode&&!e.paused&&(this._stopBufferAnalysis(),this._startBufferAnalysis(e.currentTime))};this._audioHandlers={onPlay:i,onPause:a,onEnded:n,onSeeked:s},e.addEventListener("play",i),e.addEventListener("pause",a),e.addEventListener("ended",n),e.addEventListener("seeked",s),e.paused||i(),this._decodedAudioBuffer&&!this._analysisSourceNode&&this._startBufferAnalysis(e.currentTime),this._startBPMDetectionWithValidation()}disconnectAudio(){if(this.options.onRhythmStop?.(),this._stopBufferAnalysis(),this._audioElement&&this._audioHandlers&&(this._audioElement.removeEventListener("play",this._audioHandlers.onPlay),this._audioElement.removeEventListener("pause",this._audioHandlers.onPause),this._audioElement.removeEventListener("ended",this._audioHandlers.onEnded),this._audioHandlers.onSeeked&&this._audioElement.removeEventListener("seeked",this._audioHandlers.onSeeked)),this._stopBPMDetection(),this._audioSourceNode)try{this._audioSourceNode.disconnect()}catch{}this._audioElement=null,this._audioHandlers=null,this._connectedAudioElement=null,this._audioSourceNode=null,this._decodedAudioBuffer=null,this._bufferAnalyzerNode=null}getAnalyzerNode(){return this._bufferAnalyzerNode||this._analyzerNode}getAudioContext(){return this._audioContext}isPlaying(){return this._audioElement&&!this._audioElement.paused}getBPMStatus(){return this._bpmDetector?this._bpmDetector.getStatus():{bpm:this._detectedBPM||120,subdivision:1,confidence:0,locked:!1,lockStage:0,correctionType:"none",finalized:!1,grooveConfidence:1,agentCount:0,peakCount:0,histogramSize:0,topAgents:[],intervalCount:0}}getBPMDebugLog(){return this._bpmDetector&&this._bpmDetector.getDebugLog?this._bpmDetector.getDebugLog():"No BPM detector active or debug log unavailable."}resetBPMDetection(e=null){this._bpmDetector&&this._bpmDetector.reset(e),this._bpmLocked=!1,this._bpmConfidence=0,this._detectedBPM=e||120}getDetectedBPM(){return this._detectedBPM}isBPMLocked(){return this._bpmLocked}_startBPMDetectionWithValidation(){let e=0;const t=()=>{e++,this._startBPMDetection(),setTimeout(()=>{this._validateAnalyzerWorking()||(e<3?(console.warn(`[BPM] Analyzer validation FAILED - rebuilding audio pipeline (attempt ${e+1})`),this._stopBPMDetection(),this._rebuildBufferAnalysis(),setTimeout(t,100)):console.error("[BPM] Analyzer validation FAILED after max retries - detection may not work"))},300)};t()}_validateAnalyzerWorking(){if(!this._bufferAnalyzerNode)return!1;const e=new Uint8Array(this._bufferAnalyzerNode.frequencyBinCount);let t=0,i=0;for(let a=0;a<10;a++){this._bufferAnalyzerNode.getByteFrequencyData(e),t=Math.max(t,Math.max(...e)),this._bufferAnalyzerNode.getByteTimeDomainData(e);const a=Math.min(...e),n=Math.max(...e);(a<115||n>141)&&i++}return!!(this._bpmDetector&&this._bpmDetector.peakCount>0)||i>0||t>5}_startBPMDetection(){this._bpmDetector||(this._bpmDetector=new wy),this._bpmDetector.reset(),this._detectedBPM=0,this.options.onGrooveConfidenceChange?.(.15),this._bpmDetectionInterval&&(clearInterval(this._bpmDetectionInterval),this._bpmDetectionInterval=null);let e=null,t=0,i=0,a=0;const n=[];this._bpmDetectionInterval=setInterval(()=>{if(!this._audioElement||this._audioElement.paused)return;if(!this._bufferAnalyzerNode)return;const s=this._bufferAnalyzerNode.frequencyBinCount;e&&e.length===s||(e=new Uint8Array(s)),this._bufferAnalyzerNode.getByteFrequencyData(e);let r=0;for(let t=0;t<16;t++)r+=e[t];r/=16;let o=0;for(let t=0;t<s;t++)o+=e[t];o/=s;const l=new Uint8Array(s);this._bufferAnalyzerNode.getByteTimeDomainData(l);let c=0,h=255;for(let e=0;e<s;e++)c=Math.max(c,l[e]),h=Math.min(h,l[e]);const u=c-h,d=u-a;a=u;const m=Math.max(0,r-i);i=r,n.push(m),n.length>20&&n.shift();const p=n.reduce((e,t)=>e+t,0)/n.length*1.1+2,g=performance.now(),f=(u>40&&a<10||d>30)&&o>1;if((m>p||f)&&g-t>350){const e=f?Math.min(1,u/100):Math.min(1,m/50);this._bpmDetector.processPeak(e,g);const i=this._bpmDetector.getStatus();i.bpm>0&&(this._detectedBPM=i.bpm,this._bpmConfidence=i.confidence,this._bpmLocked=i.locked,i.locked&&this.options.onBPMChange?.(i.bpm),void 0!==i.grooveConfidence&&this.options.onGrooveConfidenceChange?.(i.grooveConfidence)),t=g}},10)}_stopBPMDetection(){this._bpmDetectionInterval&&(clearInterval(this._bpmDetectionInterval),this._bpmDetectionInterval=null),this._bpmLocked=!1,this._bpmConfidence=0}_rebuildBufferAnalysis(){if(this._stopBufferAnalysis(),this._analysisGainNode){try{this._analysisGainNode.disconnect()}catch{}this._analysisGainNode=null}this._bufferAnalyzerNode=null,this._decodedAudioBuffer&&this._audioElement&&this._startBufferAnalysis(this._audioElement.currentTime)}_startBufferAnalysis(e=0){if(!this._decodedAudioBuffer||!this._audioContext)return;const t=!this._bufferAnalyzerNode;this._bufferAnalyzerNode||(this._bufferAnalyzerNode=this._audioContext.createAnalyser(),this._bufferAnalyzerNode.fftSize=2048,this._bufferAnalyzerNode.smoothingTimeConstant=.1),this._analysisSourceNode=this._audioContext.createBufferSource(),this._analysisSourceNode.buffer=this._decodedAudioBuffer,this._analysisGainNode||(this._analysisGainNode=this._audioContext.createGain(),this._analysisGainNode.gain.value=.001,this._analysisGainNode.connect(this._audioContext.destination)),this._analysisSourceNode.connect(this._bufferAnalyzerNode),this._bufferAnalyzerNode.connect(this._analysisGainNode),this._analysisSourceNode.start(0,e),this._analysisStartTime=this._audioContext.currentTime-e,t&&this._bpmDetectionInterval&&(this._stopBPMDetection(),this._startBPMDetection())}_stopBufferAnalysis(){if(this._analysisSourceNode){try{this._analysisSourceNode.stop(),this._analysisSourceNode.disconnect()}catch{}this._analysisSourceNode=null}if(this._bufferAnalyzerNode){try{this._bufferAnalyzerNode.disconnect()}catch{}this._bufferAnalyzerNode=null}if(this._analysisGainNode)try{this._analysisGainNode.disconnect(),this._analysisGainNode.connect(this._audioContext.destination)}catch{}}destroy(){if(this.disconnectAudio(),this._audioContext){try{this._audioContext.close()}catch{}this._audioContext=null}this._analyzerNode=null,this._analyzerConnected=!1}}const Sy=["flash","glow","burst","flicker"],xy={subtle:{single:["pop","bob","swell","nod","sway","tilt","floatUp"],combo:[]},moderate:{single:["pop","bob","dip","swagger","bounce","wiggle","headBob","lean","stepLeft","stepRight","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight"],combo:[["pop","bob"],["dip","swell"],["stepLeft","stepRight"],["leanLeft","leanRight"],["kickLeft","kickRight"]]},energetic:{single:["flare","swagger","dip","spin","spinLeft","spinRight","jump","twist","hula","stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight"],combo:[["flare","bob"],["pop","dip"],["swagger","flare"],["stepLeft","stepRight"],["slideLeft","slideRight"],["spinLeft","spinRight"],["kickLeft","kickRight"]]}},Cy=[{geometry:"crystal",variant:null},{geometry:"rough",variant:null},{geometry:"heart",variant:null},{geometry:"star",variant:null},{geometry:"moon",variant:{type:"phase",value:"full"}},{geometry:"moon",variant:{type:"phase",value:"waxing-gibbous"}},{geometry:"moon",variant:{type:"phase",value:"first-quarter"}},{geometry:"moon",variant:{type:"phase",value:"waxing-crescent"}},{geometry:"moon",variant:{type:"phase",value:"new"}},{geometry:"moon",variant:{type:"eclipse",value:"partial"}},{geometry:"moon",variant:{type:"eclipse",value:"total"}},{geometry:"sun",variant:null},{geometry:"sun",variant:{type:"eclipse",value:"annular"}},{geometry:"sun",variant:{type:"eclipse",value:"total"}}],Py=["joy","excited","euphoria","surprise"],ky=["focused","love","calm","neutral"],Dy=["resting","calm","sadness"],Ay=["anger","fear","suspicion","glitch","disgust"],_y=["joy","excited","euphoria","surprise","focused","love","calm","neutral","resting","sadness","anger","fear","suspicion","glitch"],Ty=.55,Iy=.25,Oy=.5;class Ry{constructor(){this.rhythmAdapter=null,this.mascot=null,this.audioDeformer=null,this.enabled=!1,this.intensity=.5,this.currentGroove="groove1",this.lastGestureTime=0,this.lastGlowTime=0,this.lastFlashBar=-4,this.barCount=0,this.lastBarProgress=0,this._bassHistory=[],this._vocalHistory=[],this._historyLength=60,this._pendingGestures=[],this._gesturesThisBar=0,this._lastGestureBar=-1,this._lastMorphBar=-16,this._currentTarget={geometry:"crystal",variant:null},this._baseTarget={geometry:"crystal",variant:null},this._morphReturnTimeout=null,this._lastEmotionBar=-12,this._currentEmotion="neutral",this._baseEmotion="neutral",this._emotionReturnTimeout=null,this.config={gestureFrequencyBars:4,minGestureIntervalMs:800,comboProbability:{subtle:0,moderate:.1,energetic:.15},morphEnabled:!0,morphCooldownBars:16,morphEnergyThreshold:.5,morphReturnBars:8,emotionEnabled:!0,emotionCooldownBars:12,emotionReturnBars:16,emotionMatchEnergy:!0,dramaticEmotionProbability:.1,grooveSwitchBars:2,energySmoothing:.05,intensityAffectsFrequency:!0,intensityAffectsAmplitude:!0,glowEnabled:!0,maxGlowBoost:1.3,glowCooldownMs:800,autoEnableOnLock:!0}}setRhythmAdapter(e){this.rhythmAdapter=e}setMascot(e){if(this.mascot=e,e?.core3D?.geometryType){const t=e.core3D.geometryType;this._currentTarget={geometry:t,variant:null},this._baseTarget={geometry:t,variant:null}}e?.core3D?.emotion&&(this._currentEmotion=e.core3D.emotion,this._baseEmotion=e.core3D.emotion)}setAudioDeformer(e){this.audioDeformer=e}enable(){this.enabled=!0}disable(){this.enabled=!1}setIntensity(e){this.intensity=Math.max(0,Math.min(1,e))}getIntensity(){return this.intensity}update(e,t=null){if(!this.rhythmAdapter)return void console.warn("[DanceChoreographer] No rhythmAdapter!");if(this.config.autoEnableOnLock&&!this.enabled&&this.mascot){const e=this.mascot._bpmDetector;if(e){const t=e.getStatus();t?.finalized&&(this.enable(),this.setIntensity(1))}}if(!this.enabled)return;const i=t||this._getAudioData();this._updateEnergyHistory(i),this._detectBarTransition(),this._updateGroovePreset(),this._triggerGestures(i),this._considerMorph(i),this._considerEmotion(i)}_getAudioData(){return this.audioDeformer?{bass:this.audioDeformer.bassEnergy||0,vocal:this.audioDeformer.vocalPresence||0,flux:this.audioDeformer.transientStrength||0}:{bass:0,vocal:0,flux:0}}_updateEnergyHistory(e){for(this._bassHistory.push(e.bass),this._vocalHistory.push(e.vocal);this._bassHistory.length>this._historyLength;)this._bassHistory.shift();for(;this._vocalHistory.length>this._historyLength;)this._vocalHistory.shift()}_getSmoothedEnergy(e){return 0===e.length?0:e.reduce((e,t)=>e+t,0)/e.length}_detectBarTransition(){if(!this.rhythmAdapter)return;if(!this.rhythmAdapter?.isPlaying?.())return void(this.lastBarProgress=0);const e=this.rhythmAdapter.barProgress||0;e<this.lastBarProgress-.5&&(this.barCount++,this._gesturesThisBar=0),this.lastBarProgress=e}_updateGroovePreset(){if(!this.rhythmAdapter)return;const e=this._getSmoothedEnergy(this._bassHistory),t=this._getSmoothedEnergy(this._vocalHistory),i=this._detectGroovePreset(e,t);i!==this.currentGroove&&this._switchGroove(i)}_detectGroovePreset(e,t){const i=.5+.5*this.intensity;return e>Ty*i?"groove2":t>Oy*i&&e<1.5*Iy?"groove3":"groove1"}_switchGroove(e){this.rhythmAdapter&&Li[e]&&(this.rhythmAdapter.setGroove(e,{quantize:!0,bars:this.config.grooveSwitchBars}),this.currentGroove=e)}_triggerGestures(e){if(!this.mascot)return void console.warn("[DanceChoreographer] _triggerGestures: No mascot reference!");if(!this.rhythmAdapter?.isPlaying?.())return void(this._lastGestureBar=-1);const t=performance.now();if(t-this.lastGestureTime<this.config.minGestureIntervalMs)return;const i=this.config.intensityAffectsFrequency?Math.max(1,Math.round(this.config.gestureFrequencyBars/(.5+this.intensity))):this.config.gestureFrequencyBars;if(this.barCount%i!==0)return;if(this._lastGestureBar===this.barCount)return;const a=this._selectGestureType(e),n=this._selectGesture(a,e);n&&(this._executeGesture(n),this._lastGestureBar=this.barCount,this.lastGestureTime=t)}_selectGestureType(e){return"groove2"===this.currentGroove&&this.intensity>.85&&e.bass>.7&&Math.random()<.3?"climactic":e.flux>.6?"dynamics":"groove2"===this.currentGroove&&this.intensity>.6?"movement":"punctuation"}_selectGesture(e,t){let i="subtle";this.intensity>.7||"groove2"===this.currentGroove?i="energetic":this.intensity>.4&&(i="moderate");const a=xy[i],n=this.config.comboProbability[i]||0;return a.combo.length>0&&Math.random()<n?a.combo[Math.floor(Math.random()*a.combo.length)]:a.single[Math.floor(Math.random()*a.single.length)]}_executeGesture(e){this.mascot&&e&&(Array.isArray(e)?e.forEach((e,t)=>{setTimeout(()=>{this._executeSingleGesture(e)},50*t)}):this._executeSingleGesture(e))}_executeSingleGesture(e){if(!this.mascot||!e)return;if(Sy.includes(e)){if(!this._canTriggerGlow())return;this.lastGlowTime=performance.now(),"flash"===e&&(this.lastFlashBar=this.barCount)}const t=this.config.intensityAffectsAmplitude?.5+.5*this.intensity:1;"function"==typeof this.mascot.gesture&&this.mascot.gesture(e,{scale:t})}_canTriggerGlow(){return!!this.config.glowEnabled&&!(performance.now()-this.lastGlowTime<this.config.glowCooldownMs||this.barCount-this.lastFlashBar<4)}_considerMorph(e){if(!this.config.morphEnabled||!this.mascot)return;if(!this.rhythmAdapter?.isPlaying?.())return;const t=this.barCount-this._lastMorphBar;if(t<this.config.morphCooldownBars)return;const i=this._getSmoothedEnergy(this._bassHistory);this._getSmoothedEnergy(this._vocalHistory);let a=!1,n="";void 0===this._previousGroove&&(this._previousGroove=this.currentGroove),this.currentGroove!==this._previousGroove&&(Math.random()<.4&&(a=!0,n="section_change"),this._previousGroove=this.currentGroove),!a&&"groove2"===this.currentGroove&&i>.7&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.05&&(a=!0,n="energy_peak"),this._lastMorphCheckBar=this.barCount),!a&&t>=16&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.25&&(a=!0,n="time_variety"),this._lastMorphCheckBar=this.barCount),!a&&this._lastMorphBar<0&&this.barCount>=8&&this._lastMorphCheckBar!==this.barCount&&(Math.random()<.15&&(a=!0,n="intro_variety"),this._lastMorphCheckBar=this.barCount),a&&this._triggerMorph(n)}_triggerMorph(e){if(!this.mascot)return;this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null);const t=(e,t)=>e.geometry===t.geometry&&(!e.variant&&!t.variant||!(!e.variant||!t.variant)&&e.variant.type===t.variant.type&&e.variant.value===t.variant.value),i=Cy.filter(e=>!t(e,this._currentTarget)&&!t(e,this._baseTarget)),a=i.length>0?i:Cy.filter(e=>!t(e,this._currentTarget));if(0===a.length)return;const n=a[Math.floor(Math.random()*a.length)];this._applyMorphTarget(n),this._currentTarget=n,this._lastMorphBar=this.barCount;const s=60/(this.rhythmAdapter?.getBPM?.()||120)*4*1e3,r=this.config.morphReturnBars*s;this._morphReturnTimeout=setTimeout(()=>{this._returnToBaseGeometry()},r)}_returnToBaseGeometry(){var e,t;this.mascot&&(this._morphReturnTimeout=null,e=this._currentTarget,t=this._baseTarget,e.geometry===t.geometry&&(!e.variant&&!t.variant||e.variant&&t.variant&&e.variant.type===t.variant.type&&e.variant.value===t.variant.value)||(this._applyMorphTarget(this._baseTarget),this._currentTarget={...this._baseTarget}))}_applyMorphTarget(e){const t=this.mascot?.core3D;t&&(t.geometryType!==e.geometry?("function"==typeof this.mascot.morphTo?this.mascot.morphTo(e.geometry):"function"==typeof this.mascot.setGeometry&&this.mascot.setGeometry(e.geometry),e.variant&&setTimeout(()=>{t.geometryType===e.geometry&&this._applyVariant(e.geometry,e.variant)},1200)):e.variant?this._applyVariant(e.geometry,e.variant):this._clearVariant(e.geometry))}_applyVariant(e,t){const i=this.mascot?.core3D;if(i)if(i.geometryType===e)if("moon"===e){if(!i.customMaterial?.uniforms?.shadowOffset)return void console.warn("[DanceChoreographer] Moon material not ready for phase/eclipse");"eclipse"===t.type?(ri(i.customMaterial,"full"),"function"==typeof i.setMoonEclipse&&i.setMoonEclipse(t.value)):"phase"===t.type&&("function"==typeof i.setMoonEclipse&&i.setMoonEclipse("off"),ri(i.customMaterial,t.value))}else"sun"===e&&"eclipse"===t.type&&"function"==typeof i.setSunShadow&&i.setSunShadow(t.value);else console.warn(`[DanceChoreographer] Skipping variant - expected ${e}, got ${i.geometryType}`)}_clearVariant(e){const t=this.mascot?.core3D;t&&t.geometryType===e&&("moon"===e?("function"==typeof t.setMoonEclipse&&t.setMoonEclipse("off"),t.customMaterial?.uniforms?.shadowOffset&&ri(t.customMaterial,"full")):"sun"===e&&"function"==typeof t.setSunShadow&&t.setSunShadow("off"))}_getTargetLabel(e){return e.variant?`${e.geometry}:${e.variant.value}`:e.geometry}_considerEmotion(e){if(!this.config.emotionEnabled||!this.mascot)return;if(!this.rhythmAdapter?.isPlaying?.())return;const t=this.barCount-this._lastEmotionBar;if(t<this.config.emotionCooldownBars)return;const i=(this._getSmoothedEnergy(this._bassHistory)+this._getSmoothedEnergy(this._vocalHistory))/2;let a=!1,n="";void 0===this._prevGrooveForEmotion&&(this._prevGrooveForEmotion=this.currentGroove),this.currentGroove!==this._prevGrooveForEmotion&&(Math.random()<.6&&(a=!0,n="section_change"),this._prevGrooveForEmotion=this.currentGroove),!a&&"groove2"===this.currentGroove&&i>.6&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.15&&(a=!0,n="energy_peak"),this._lastEmotionCheckBar=this.barCount),!a&&"groove1"===this.currentGroove&&i<.25&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.1&&(a=!0,n="energy_low"),this._lastEmotionCheckBar=this.barCount),!a&&t>=12&&this._lastEmotionCheckBar!==this.barCount&&(Math.random()<.2&&(a=!0,n="time_variety"),this._lastEmotionCheckBar=this.barCount),a&&this._triggerEmotion(n,i)}_triggerEmotion(e,t){if(!this.mascot)return;let i;this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null),i=this.config.emotionMatchEnergy?t>.65&&Math.random()<this.config.dramaticEmotionProbability?Ay:t>.55?Py:t>.3?ky:Dy:_y;const a=i.filter(e=>e!==this._currentEmotion);if(0===a.length)return;const n=a[Math.floor(Math.random()*a.length)];"function"==typeof this.mascot.setEmotion?this.mascot.setEmotion(n):this.mascot.core3D&&"function"==typeof this.mascot.core3D.setEmotion&&this.mascot.core3D.setEmotion(n),this._currentEmotion=n,this._lastEmotionBar=this.barCount;const s=60/(this.rhythmAdapter?.getBPM?.()||120)*4*1e3,r=this.config.emotionReturnBars*s;this._emotionReturnTimeout=setTimeout(()=>{this._returnToBaseEmotion()},r)}_returnToBaseEmotion(){this.mascot&&(this._emotionReturnTimeout=null,this._currentEmotion!==this._baseEmotion&&("function"==typeof this.mascot.setEmotion?this.mascot.setEmotion(this._baseEmotion):this.mascot.core3D&&"function"==typeof this.mascot.core3D.setEmotion&&this.mascot.core3D.setEmotion(this._baseEmotion),this._currentEmotion=this._baseEmotion))}setBaseEmotion(e){this._baseEmotion=e,this._currentEmotion=e}syncEmotionFromMascot(){this.mascot?.core3D?.emotion&&(this._currentEmotion=this.mascot.core3D.emotion)}getStatus(){return{enabled:this.enabled,intensity:this.intensity,currentGroove:this.currentGroove,currentTarget:this._getTargetLabel(this._currentTarget),baseTarget:this._getTargetLabel(this._baseTarget),currentEmotion:this._currentEmotion,baseEmotion:this._baseEmotion,barCount:this.barCount,avgBass:this._getSmoothedEnergy(this._bassHistory).toFixed(3),avgVocal:this._getSmoothedEnergy(this._vocalHistory).toFixed(3),lastGestureAgo:`${Math.round((performance.now()-this.lastGestureTime)/1e3)}s`,lastGlowAgo:`${Math.round((performance.now()-this.lastGlowTime)/1e3)}s`,lastMorphBar:this._lastMorphBar,barsSinceLastMorph:this.barCount-this._lastMorphBar,lastEmotionBar:this._lastEmotionBar,barsSinceLastEmotion:this.barCount-this._lastEmotionBar,canGlow:this._canTriggerGlow()}}setBaseGeometry(e,t=null){this._baseTarget={geometry:e,variant:t},this._currentTarget={geometry:e,variant:t}}syncGeometryFromMascot(){if(this.mascot?.core3D?.geometryType){const e=this.mascot.core3D.geometryType;this._currentTarget={geometry:e,variant:null}}}reset(){this.enabled=!1,this.currentGroove="groove1",this.barCount=0,this.lastBarProgress=0,this.lastGestureTime=0,this.lastGlowTime=0,this.lastFlashBar=-4,this._bassHistory=[],this._vocalHistory=[],this._gesturesThisBar=0,this._lastGestureBar=-1,this._lastMorphBar=-16;const e=this.mascot?.core3D?.geometryType||"crystal";this._currentTarget={geometry:e,variant:null},this._baseTarget={geometry:e,variant:null},this._previousGroove=void 0,this._lastMorphCheckBar=-1,this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null),this._lastEmotionBar=-12;const t=this.mascot?.core3D?.emotion||"neutral";this._currentEmotion=t,this._baseEmotion=t,this._prevGrooveForEmotion=void 0,this._lastEmotionCheckBar=-1,this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null)}destroy(){this._morphReturnTimeout&&(clearTimeout(this._morphReturnTimeout),this._morphReturnTimeout=null),this._emotionReturnTimeout&&(clearTimeout(this._emotionReturnTimeout),this._emotionReturnTimeout=null),this.reset(),this.rhythmAdapter=null,this.mascot=null,this.audioDeformer=null}}function Ey(e=32,t=32){const i=[],a=[],n=[];for(let n=0;n<=t;n++){const s=n/t*Math.PI;for(let t=0;t<=e;t++){const n=t/e*Math.PI*2,r=Math.cos(n)*Math.sin(s),o=Math.cos(s),l=Math.sin(n)*Math.sin(s);i.push(r,o,l),a.push(r,o,l)}}for(let i=0;i<t;i++)for(let t=0;t<e;t++){const a=i*(e+1)+t,s=a+e+1,r=a+1,o=s+1;n.push(a,s,r),n.push(r,s,o)}return{vertices:new Float32Array(i),normals:new Float32Array(a),indices:new Uint16Array(n)}}function By(e=6){const t=[],i=[],a=[],n=new Map;let s=0;function r(e,a,r,o,l,c){const h=`${e},${a},${r}`;return n.has(h)||(t.push(e,a,r),i.push(o,l,c),n.set(h,s++)),n.get(h)}const o=r(0,1.5,0,0,1,0),l=[];for(let t=0;t<e;t++){const i=t/e*Math.PI*2,a=r(.7*Math.cos(i),0,.7*Math.sin(i),Math.cos(i),0,Math.sin(i));l.push(a)}const c=r(0,-1.5,0,0,-1,0);for(let t=0;t<e;t++){const i=(t+1)%e;a.push(o,l[t],l[i])}for(let t=0;t<e;t++){const i=(t+1)%e;a.push(l[t],c,l[i])}return{vertices:new Float32Array(t),normals:new Float32Array(i),indices:new Uint16Array(a)}}function Fy(){const e=[],t=[],i=[],a=[0,1.2,0],n=[0,-.8,0],s=[];for(let e=0;e<8;e++){const t=e/8*Math.PI*2;s.push([.8*Math.cos(t),0,.8*Math.sin(t)])}function r(a,n,s){const r=[n[0]-a[0],n[1]-a[1],n[2]-a[2]],o=[s[0]-a[0],s[1]-a[1],s[2]-a[2]],l=r[1]*o[2]-r[2]*o[1],c=r[2]*o[0]-r[0]*o[2],h=r[0]*o[1]-r[1]*o[0],u=Math.sqrt(l*l+c*c+h*h),d=[l/u,c/u,h/u],m=e.length/3;e.push(...a),t.push(...d),e.push(...n),t.push(...d),e.push(...s),t.push(...d),i.push(m,m+1,m+2)}for(let e=0;e<8;e++){const t=(e+1)%8;r(a,s[e],s[t])}for(let e=0;e<8;e++){const t=(e+1)%8;r(s[e],n,s[t])}return{vertices:new Float32Array(e),normals:new Float32Array(t),indices:new Uint16Array(i)}}const zy={sphere:Ey(32,32),crystal:By(6),diamond:Fy()};function Ly(){Object.values(zy).forEach(e=>{e&&e.vertices&&(e.vertices=null,e.normals=null,e.indices=null)})}const Gy={geometries:["crystal","rough","heart","star","moon","sun"],sssPresets:["quartz","emerald","ruby","sapphire","amethyst"],emotions:["neutral","joy","sadness","anger","fear","surprise","disgust","love","suspicion","excited","resting","euphoria","focused","glitch","calm"],motionGestures:["bounce","pulse","shake","nod","vibrate","orbit","twitch","sway","float","jitter","wiggle","sparkle","shimmer","pop","bob","swell","swagger","dip","flare","headBob","lean","point","reach","stepLeft","stepRight","stepUp","stepDown","slideLeft","slideRight","leanLeft","leanRight","kickLeft","kickRight","floatUp","floatDown","floatLeft","floatRight","pointUp","pointDown","pointLeft","pointRight"],transformGestures:["spin","spinLeft","spinRight","jump","morph","stretch","tilt","orbital","hula","twist"],effectGestures:["wave","drift","flicker","burst","fade","breathe","expand","contract","flash","glow","settle","hold"]},Vy='You are a dance choreographer for an animated 3D mascot. Interpret lyrics/mood and output movement commands.\n\n## PHILOSOPHY\n- Gestures are constant - always return at least one to keep the mascot alive\n- Emotions shift with lyrical sentiment - change when the overall mood shifts\n- Geometry transforms are DRAMATIC EVENTS - only for song structure changes (intro→verse, verse→chorus, chorus→bridge)\n- SSS (material color) requires EXPLICIT visual imagery - don\'t infer colors from abstract concepts\n- Focus on the FEELING of the phrase, not literal word-by-word interpretation\n\n## VOCABULARY\n\n**Geometries** (STRICT: max 2 per song, only at structural moments):\n- crystal (default, neutral) - use for verses, calm sections\n- heart (love, romance) - ONLY when love/heart explicitly mentioned\n- star (dreams, hope) - ONLY for aspirational climax moments\n- moon (night, introspection) - ONLY when night/darkness is the theme\n- sun (energy, warmth) - ONLY for bright, warm imagery\n- rough (raw, edgy) - ONLY for intense/aggressive sections\n\n**SSS Presets** (ONLY with explicit visual imagery):\n- quartz (pure, light, glowing) - "glow", "shine", "light", "bright"\n- emerald (nature) - "green", "forest", "grow", "nature"\n- ruby (fire, passion) - "fire", "burn", "red", "flame"\n- sapphire (water, sky) - "ocean", "rain", "blue", "sky", "tears"\n- amethyst (mystical, dreams) - "stars", "dream", "magic", "purple"\n\nDO NOT use SSS for: abstract emotions, actions, or phrases without color/nature imagery.\n\n**Emotions**:\n- neutral, calm, resting (baseline)\n- joy, excited, euphoria (positive high energy)\n- love (romantic, tender)\n- sadness, fear (vulnerable, soft)\n- anger, disgust (intense, but use sparingly)\n- surprise (sudden shifts only)\n- focused, suspicion (tension, anticipation)\n\n**Gestures by Category**:\n- Base (ongoing): sway, float, bounce, swagger, pulse\n- Accent (momentary hit): pop, bob, swell, dip, flare, burst\n- Texture (layer on top): shimmer, sparkle, glow, breathe\n- Transform (dramatic): spin, spinLeft, spinRight, jump, shake, twist\n- Directional (beat-synced moves): stepLeft, stepRight, stepUp, stepDown, slideLeft, slideRight\n- Directional (lean/kick): leanLeft, leanRight, kickLeft, kickRight\n- Directional (storytelling): floatUp, floatDown, floatLeft, floatRight, pointUp, pointDown, pointLeft, pointRight\n\n## GESTURE CHAINING\n\n- Single: "gesture": "sway"\n- Layered (simultaneous): "gesture": ["sway", "shimmer"]\n- Sequential (accent then settle): "gesture": "pop", "then": "sway"\n\nPatterns:\n- Verse/narrative: base + texture → ["sway", "breathe"]\n- Beat accent: accent then base → "pop", then: "sway"\n- Chorus/hook: base + texture + energy → ["swagger", "sparkle"]\n- Climax/drop: transform then base → "burst", then: "swagger"\n\n## DECISION GUIDE\n\n| Content | Response |\n|---------|----------|\n| Emotional phrase | emotion + gesture |\n| Explicit visual imagery (colors, nature, light) | sss + gesture |\n| Action words (dance, move, jump) | gesture only |\n| Narrative/story | subtle base gesture |\n| High energy hook/chorus | layered gestures + emotion |\n| FIRST line of new song section | geometry + maybe sss |\n\n## EXAMPLES\n\n"Tell me who\'s got rhythm in their feet" → {"gesture":["bounce","pulse"],"emotion":"excited"}\n"Who\'s got a heartbeat loud" → {"gesture":"pulse","emotion":"excited"}\n"Moving in the light" → {"gesture":["sway","shimmer"]}\n"Hands up high" → {"gesture":"swell","emotion":"joy"}\n"Feet on fire" → {"gesture":"flare","then":"swagger","emotion":"euphoria","sss":"ruby"}\n"We glow" → {"gesture":["sway","glow"],"sss":"quartz"}\n"Electric flow" → {"gesture":["swagger","sparkle"],"emotion":"excited"}\n"You know" → {"gesture":"sway"}\n"The night\'s our own" → {"gesture":["float","shimmer"],"emotion":"calm"}\n"Turn it up loud" → {"gesture":"burst","then":"swagger","emotion":"euphoria"}\n"To the left" → {"gesture":"stepLeft"}\n"Slide to the right" → {"gesture":"slideRight"}\n"To the left, to the left" → {"gesture":["stepLeft","stepLeft"]}\n"Hands up high" → {"gesture":"stepUp","emotion":"joy"}\n"Drop it low" → {"gesture":"stepDown","emotion":"excited"}\n"Lean back" → {"gesture":"leanRight"}\n"Kick it out" → {"gesture":"kickLeft","emotion":"excited"}\n"Spin around" → {"gesture":"spinRight"}\n"Turn the other way" → {"gesture":"spinLeft"}\n"Look to the stars" → {"gesture":"pointUp","emotion":"anticipation"}\n"He sank into despair" → {"gesture":"floatDown","emotion":"sadness"}\n"She drifted away" → {"gesture":"floatRight","emotion":"calm"}\n"Point to the future" → {"gesture":"pointUp","emotion":"joy"}\n"[Intro]" → {"gesture":["floatUp","breathe"],"emotion":"calm"}\n"[Bridge/Outro]" → {"gesture":["floatUp","breathe"],"emotion":"calm","geometry":"crystal"}\n\nRULES:\n1. Always include gesture\n2. Use only listed vocabulary\n3. Geometry changes are RARE (max 2 per song) - only at section boundaries\n4. SSS requires EXPLICIT color/visual imagery - no inference\n5. Match emotion to overall phrase sentiment, not individual words\n6. JSON only';class Ny{constructor(e={}){this.apiKey=e.apiKey||null,this.endpoint=e.endpoint||null,this.model=e.model||null,this.onAction=e.onAction||null,this.onError=e.onError||null,this.enabled=!1,this.lastAction=null,this.lastInterpretTime=0,this.minIntervalMs=3e3,this.pendingRequest=null,this.currentState={geometry:null,sss:null,emotion:null},this.textBuffer=[],this.bufferTimeout=null}configure(e){e.apiKey&&(this.apiKey=e.apiKey.replace(/[^\x00-\x7F]/g,"").trim()),e.endpoint&&(this.endpoint=e.endpoint),e.model&&(this.model=e.model)}_isAnthropic(){return this.endpoint&&this.endpoint.includes("anthropic.com")}enable(){return this.apiKey&&this.endpoint?(this.enabled=!0,console.log("[AudioInterpreter] Enabled:",this.endpoint),!0):(console.warn("[AudioInterpreter] Need API key and endpoint"),!1)}disable(){this.enabled=!1,this.bufferTimeout&&(clearTimeout(this.bufferTimeout),this.bufferTimeout=null),console.log("[AudioInterpreter] Disabled")}updateCurrentState(e){e.geometry&&(this.currentState.geometry=e.geometry),e.sss&&(this.currentState.sss=e.sss),e.emotion&&(this.currentState.emotion=e.emotion)}feedText(e){this.enabled&&this.apiKey&&e&&0!==e.trim().length&&(this.textBuffer.push(e.trim()),this.bufferTimeout&&clearTimeout(this.bufferTimeout),this.bufferTimeout=setTimeout(()=>{this._processBuffer()},500))}async interpret(e){if(!this.enabled||!this.apiKey)return null;const t=Date.now();if(t-this.lastInterpretTime<this.minIntervalMs)return null;this.pendingRequest&&(this.pendingRequest=null),this.lastInterpretTime=t;try{const t=await this._callLLM(e);return t&&(this.lastAction=t,this._emitAction(t)),t}catch(e){return console.error("[AudioInterpreter] Error:",e),this.onError&&this.onError(e),null}}async _processBuffer(){if(0===this.textBuffer.length)return;const e=this.textBuffer.join(" ");this.textBuffer=[],await this.interpret(e)}async _callLLM(e){const t=Date.now();let i;if(this.pendingRequest=t,i=this._isAnthropic()?await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json","x-api-key":this.apiKey,"anthropic-version":"2023-06-01","anthropic-dangerous-direct-browser-access":"true"},body:JSON.stringify({model:this.model||"claude-3-haiku-20240307",max_tokens:100,system:Vy,messages:[{role:"user",content:`Audio context: "${e}"`}]})}):await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.apiKey}`},body:JSON.stringify({model:this.model||"gpt-4o-mini",messages:[{role:"system",content:Vy},{role:"user",content:`Audio context: "${e}"`}],max_tokens:100,temperature:.3})}),this.pendingRequest!==t)return null;if(!i.ok){const e=await i.json().catch(()=>({}));throw new Error(e.error?.message||`API error: ${i.status}`)}const a=await i.json();let n;if(this._isAnthropic()){const e=a.content?.find(e=>"text"===e.type);n=e?.text}else n=a.choices?.[0]?.message?.content;if(!n)return null;try{const e=JSON.parse(n.trim());return this._validateAction(e)}catch{const e=n.match(/\{[\s\S]*\}/);if(e)try{const t=JSON.parse(e[0]);return this._validateAction(t)}catch{return console.warn("[AudioInterpreter] Failed to parse:",n),null}return console.warn("[AudioInterpreter] Failed to parse:",n),null}}_validateAction(e){if(!e||"object"!=typeof e)return null;const t={};if(e.geometry&&Gy.geometries.includes(e.geometry)&&e.geometry!==this.currentState.geometry&&(t.geometry=e.geometry),e.sss&&Gy.sssPresets.includes(e.sss)){const i=t.geometry||this.currentState.geometry;["crystal","rough","heart","star"].includes(i)&&e.sss!==this.currentState.sss&&(t.sss=e.sss)}if(e.emotion&&Gy.emotions.includes(e.emotion)&&e.emotion!==this.currentState.emotion&&(t.emotion=e.emotion),e.gesture){const i=[...Gy.motionGestures,...Gy.transformGestures,...Gy.effectGestures];if(Array.isArray(e.gesture)){const a=e.gesture.filter(e=>i.includes(e));a.length>0&&(t.gesture=1===a.length?a[0]:a)}else i.includes(e.gesture)&&(t.gesture=e.gesture)}if(e.then){const i=[...Gy.motionGestures,...Gy.transformGestures,...Gy.effectGestures];if(Array.isArray(e.then)){const a=e.then.filter(e=>i.includes(e));a.length>0&&(t.then=1===a.length?a[0]:a)}else i.includes(e.then)&&(t.then=e.then)}return 0===Object.keys(t).length?null:t}_emitAction(e){e.geometry&&(this.currentState.geometry=e.geometry),e.sss&&(this.currentState.sss=e.sss),e.emotion&&(this.currentState.emotion=e.emotion),this.onAction&&this.onAction(e)}static getVocabulary(){return{...Gy}}}const jy={anthropic:"https://api.anthropic.com/v1/messages",openai:"https://api.openai.com/v1/chat/completions",grok:"https://api.x.ai/v1/chat/completions"},qy=new Ny,Uy=["sphere","crystal","diamond","rough","heart","star","moon","sun"];class Wy{constructor(e={}){this.config={canvasId:e.canvasId||"emotive-canvas",coreGeometry:e.coreGeometry||"sphere",targetFPS:e.targetFPS||60,enableParticles:!1!==e.enableParticles,defaultEmotion:e.defaultEmotion||"neutral",...e},this._canvasLayerManager=null,this.container=null,this.webglCanvas=null,this.canvas2D=null,this.core3D=null,this.particleSystem=null,this.danceChoreographer=null,this.isRunning=!1,this._destroyed=!1,this.animationFrameId=null,this.lastFrameTime=0,this.gestureTimeouts=[],this.eventManager=new Hf,this.eventManager.emit||(this.eventManager._listeners={},this.eventManager.emit=(e,t)=>{const i=this.eventManager._listeners[e];i&&i.forEach(e=>e(t))},this.eventManager.on=(e,t)=>{this.eventManager._listeners[e]||(this.eventManager._listeners[e]=[]),this.eventManager._listeners[e].push(t)},this.eventManager.off=(e,t)=>{const i=this.eventManager._listeners[e];if(i){const e=i.indexOf(t);e>-1&&i.splice(e,1)}}),this.errorBoundary=new $f,this.emotion="neutral",this.undertone=null,this._intentParser=new by,this._feelRateLimiter={calls:[],windowMs:1e3,maxCallsPerSecond:10},this._audioBridge=null,this._prefersReducedMotion="undefined"!=typeof window&&(window.matchMedia?.("(prefers-reduced-motion: reduce)").matches??!1),this._reducedMotionMediaQuery=null}prefersReducedMotion(){return this._prefersReducedMotion}setReducedMotion(e){return this._prefersReducedMotion=e,e&&this.disableAutoRotate(),this.eventManager.emit("accessibility:reducedMotion",{enabled:e}),this}_setupReducedMotionListener(){"undefined"!=typeof window&&window.matchMedia&&(this._reducedMotionMediaQuery=window.matchMedia("(prefers-reduced-motion: reduce)"),this._reducedMotionHandler=e=>{this._prefersReducedMotion=e.matches,this.setReducedMotion(e.matches)},this._reducedMotionMediaQuery.addEventListener?this._reducedMotionMediaQuery.addEventListener("change",this._reducedMotionHandler):this._reducedMotionMediaQuery.addListener&&this._reducedMotionMediaQuery.addListener(this._reducedMotionHandler))}_isDestroyed(){return this._destroyed||!this.eventManager||!this.eventManager._listeners}_getAudioBridge(){return this._audioBridge||(this._audioBridge=new My({onRhythmStart:(e,t)=>this.startRhythm(e,t),onRhythmStop:()=>this.stopRhythm(),onBPMChange:e=>{this.isRhythmPlaying()&&this.setRhythmBPM(e)},onGrooveConfidenceChange:e=>{this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setGrooveConfidence(e)}})),this._audioBridge}init(e){if("undefined"==typeof window)throw new Error("EmotiveMascot3D.init() requires a browser environment. For SSR frameworks, use dynamic import with ssr:false (Next.js) or <ClientOnly> (Nuxt).");try{this._canvasLayerManager=new Wf({canvasId:this.config.canvasId,enableControls:this.config.enableControls});const t=this._canvasLayerManager.setup(e);if(this.container=t.container,this.webglCanvas=t.webglCanvas,this.canvas2D=t.canvas2D,this.core3D=new Uf(this.webglCanvas,{geometry:this.config.coreGeometry,emotion:this.config.defaultEmotion,enableParticles:this.config.enableParticles,enablePostProcessing:this.config.enablePostProcessing,enableShadows:this.config.enableShadows,enableControls:this.config.enableControls,enableShatter:this.config.enableShatter,autoRotate:this.config.autoRotate,enableBlinking:this.config.enableBlinking,enableBreathing:this.config.enableBreathing,cameraDistance:this.config.cameraDistance,fov:this.config.fov,minZoom:this.config.minZoom,maxZoom:this.config.maxZoom,materialVariant:this.config.materialVariant,assetBasePath:this.config.assetBasePath}),this.ctx2D=this.canvas2D.getContext("2d"),this.config.enableParticles&&!this.core3D?.particleOrchestrator){const e=this.config.maxParticles||300;this.particleSystem=new Dd(e,this.errorBoundary),this.particleSystem.canvasWidth=this.canvas2D.width,this.particleSystem.canvasHeight=this.canvas2D.height}return this.danceChoreographer=new Ry,this.danceChoreographer.setRhythmAdapter(this.core3D?.rhythm3DAdapter),this.danceChoreographer.setMascot(this),this._setupReducedMotionListener(),this._prefersReducedMotion&&this.setReducedMotion(!0),this}catch(e){throw console.error("Failed to initialize 3D engine:",e),e}}async start(){this.isRunning||(this.core3D&&await this.core3D.waitUntilReady(),this.isRunning=!0,this.lastFrameTime=null,this.animationFrameId=requestAnimationFrame(this.animate.bind(this)))}stop(){this.isRunning=!1,this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null)}animate(e){if(!this.isRunning||this._destroyed)return;if(null===this.lastFrameTime)return this.lastFrameTime=e,void(this.animationFrameId=requestAnimationFrame(this.animate.bind(this)));const t=e-this.lastFrameTime,i=Math.min(t,100);if(this.lastFrameTime=e,this.core3D&&!this._destroyed&&(this.core3D.render(i),this._canvasLayerManager&&!this._canvasLayerManager.isCanvasAppended()&&this._canvasLayerManager.appendWebGLCanvas()),this.danceChoreographer&&!this._destroyed&&this.danceChoreographer.update(i/1e3),this.canvas2D&&this.ctx2D&&(this.ctx2D.clearRect(0,0,this.canvas2D.width,this.canvas2D.height),this.ctx2D.fillStyle="rgba(0,0,0,0)",this.ctx2D.fillRect(0,0,this.canvas2D.width,this.canvas2D.height),this.particleSystem)){const t=this.canvas2D.width/2,a=this.canvas2D.height/2,n=this.core3D?this.core3D.emotion:"neutral",s=Ii(n),r=this.core3D?this.rgbToHex(this.core3D.glowColor):"#FFFFFF",o=s?.visual?.particleBehavior||"ambient",l=s?.visual?.particleRate||15,c=s?.visual?.minParticles||5,h=s?.visual?.maxParticles||30,u=s?.visual?.particleColors||null;this.particleSystem.spawn(o,n,l,t,a,i,null,c,h,1,1,u,this.undertone);let d=null,m=0;if(this.currentGesture){const t=e-this.currentGesture.startTime;m=Math.min(t/this.currentGesture.duration,1),d={...this.currentGesture.config,type:this.currentGesture.name}}this.particleSystem.update(i,t,a,d,m,this.undertone),this.particleSystem.render(this.ctx2D,r,null)}this.animationFrameId=requestAnimationFrame(e=>this.animate(e))}setEmotion(e,t,i){return this._isDestroyed()?this:e&&"string"==typeof e?(function(e){const t=Ti[e]||e;return _i.has(t)||null!==Pi(t)}(e)||console.warn(`[EmotiveMascot3D] Unknown emotion "${e}". Valid emotions: ${Ei().join(", ")}`),this.emotion=e,void 0!==t&&("string"==typeof t?this.undertone=t:"number"==typeof t||(t&&"object"==typeof t?this.undertone=t.undertone||null:null===t&&(this.undertone=null))),this.core3D&&this.core3D.setEmotion(e,this.undertone),this.particleSystem&&(this.particleSystem.particles=[]),this.eventManager.emit("emotion:change",{emotion:e,undertone:this.undertone}),this):(console.warn(`[EmotiveMascot3D] setEmotion: Invalid emotion "${e}". Use getAvailableEmotions() for valid options.`),this)}updateUndertone(e){return this._isDestroyed()||(this.undertone=e,this.core3D&&this.emotion&&this.core3D.setEmotion(this.emotion,e),this.eventManager.emit("undertone:change",{undertone:e})),this}setUndertone(e){return this.updateUndertone(e)}express(e){if(this._isDestroyed())return this;if(!e||"string"!=typeof e)return console.warn(`[EmotiveMascot3D] express: Invalid gesture "${e}". Use getAvailableGestures() for valid options.`),this;this.core3D&&this.core3D.playGesture(e);const t=wd(e);if(t){const i=t.config||{},a=i.musicalDuration?.musical?500*(i.musicalDuration.beats||2):i.duration||800;this.currentGesture={name:e,gesture:t,config:i,startTime:performance.now(),duration:a};const n=setTimeout(()=>{this.currentGesture&&this.currentGesture.name===e&&(this.currentGesture=null)},a);this.gestureTimeouts.push(n)}else{const t=Md().map(e=>e.name);console.warn(`[EmotiveMascot3D] Unknown gesture "${e}". Valid gestures: ${t.slice(0,10).join(", ")}...`)}return this.eventManager.emit("gesture:trigger",{gesture:e}),this}gesture(e,t={}){return this.express(e)}chain(e){const t=("string"==typeof e?{rise:"breathe > sway+lean+tilt",flow:"sway > lean+tilt > spin > bounce",burst:"jump > nod > shake > flash",drift:"sway+breathe+float+drift",chaos:"shake+shake > spin+flash > bounce+pulse > twist+sparkle",morph:"expand > contract > morph+glow > expand+flash",rhythm:"pulse > pulse+sparkle > pulse+flicker",spiral:"spin > orbital > twist > orbital+sparkle",routine:"nod > bounce > spin+sparkle > sway+pulse > nod+flash",radiance:"sparkle > pulse+flicker > shimmer",twinkle:"sparkle > flash > pulse+sparkle > shimmer+flicker",stream:"wave > nod+pulse > sparkle > flash"}[e]||e:e.join(">")).split(">").map(e=>e.trim().split("+").map(e=>e.trim()).filter(e=>e.length>0));this.executeChainSequence(t)}executeChainSequence(e){if(!e||0===e.length)return;let t=0;const i=()=>{if(!(t>=e.length)&&(e[t].forEach(e=>{this.express(e)}),t++,t<e.length)){const e=setTimeout(i,800);this.gestureTimeouts.push(e)}};i()}morphTo(e,t={}){if(this._isDestroyed())return this;if(!e||"string"!=typeof e)return console.warn(`[EmotiveMascot3D] morphTo: Invalid shape "${e}". Use getAvailableGeometries() for valid options.`),this;if(Uy.includes(e)||console.warn(`[EmotiveMascot3D] Unknown geometry "${e}". Valid geometries: ${Uy.join(", ")}`),this.core3D){if(void 0!==t.materialVariant&&this.core3D.setMaterialVariant(t.materialVariant),t.onMaterialSwap){const e=this.core3D.onMaterialSwap;this.core3D.onMaterialSwap=i=>{e&&e(i),t.onMaterialSwap(i),this.core3D.onMaterialSwap=e}}const i=t.duration||800;this.core3D.morphToShape(e,i)}return this.eventManager.emit("shape:morph",{shape:e}),this}triggerReassembly(e=1500){return!!this.core3D&&this.core3D.triggerReassembly(e)}isShatterFrozen(){return this.core3D?.isShatterFrozen()||!1}feel(e){if(this._isDestroyed())return{success:!1,error:"Engine destroyed",parsed:null};const t=Date.now(),i=this._feelRateLimiter;if(i.calls=i.calls.filter(e=>t-e<i.windowMs),i.calls.length>=i.maxCallsPerSecond)return console.warn(`[EmotiveMascot3D] feel: Rate limit exceeded. Max ${i.maxCallsPerSecond} calls per second.`),{success:!1,error:"Rate limit exceeded",parsed:null};i.calls.push(t);const a=this._intentParser.parse(e),n=this._intentParser.validate(a);if(!n.valid)return console.warn("[feel] Invalid intent:",n.errors),{success:!1,error:n.errors.join("; "),parsed:a};try{if(a.emotion){const e={};a.undertone&&"clear"!==a.undertone&&(e.undertone=a.undertone),this.setEmotion(a.emotion,e)}for(const e of a.gestures)this.express(e);return a.shape&&this.morphTo(a.shape),{success:!0,error:null,parsed:a}}catch(e){return console.error("[feel] Execution error:",e),{success:!1,error:e.message,parsed:a}}}isMorphing(){return!!this.core3D&&this.core3D.isMorphing()}getMorphState(){return this.core3D?this.core3D.getMorphState():null}growIn(e=500){this.core3D&&this.core3D.growIn(e),this.eventManager.emit("animation:growIn",{duration:e})}setCoreGlowEnabled(e){this.core3D&&this.core3D.setCoreGlowEnabled(e),this.eventManager.emit("coreGlow:toggle",{enabled:e})}isCoreGlowEnabled(){return!this.core3D||this.core3D.coreGlowEnabled}enableAutoRotate(){this.core3D&&"moon"!==this.core3D.geometryType&&(this.core3D.renderer?.controls&&(this.core3D.renderer.controls.autoRotate=!0,this.core3D.renderer.controls.autoRotateSpeed=this.core3D.options?.autoRotateSpeed??.5),this.core3D.rotationDisabled=!1,this.setEmotion(this.core3D.emotion,this.undertone))}disableAutoRotate(){this.core3D?.renderer?.controls&&(this.core3D.renderer.controls.autoRotate=!1,this.core3D.renderer.controls.autoRotateSpeed=0),this.core3D&&(this.core3D.rotationDisabled=!0,this.core3D.rotationBehavior=null,this.core3D.baseEuler&&(this.core3D.baseEuler[0]=0,this.core3D.baseEuler[1]=0,this.core3D.baseEuler[2]=0))}setCameraPreset(e,t=1e3){this.core3D?.renderer?.setCameraPreset&&this.core3D.renderer.setCameraPreset(e,t)}get autoRotateEnabled(){return!1===this.core3D?.rotationDisabled}enableParticles(){if(this.core3D?.particleOrchestrator?.renderer&&(this.core3D.particleVisibility=!0,this.core3D.particleOrchestrator.renderer.setVisible(!0),this.core3D.particleOrchestrator.setEmotion(this.core3D.emotion,this.core3D.undertone)),!this.core3D?.particleOrchestrator&&!this.particleSystem&&this.canvas2D){const e=this.config.maxParticles||300;this.particleSystem=new Dd(e,this.errorBoundary),this.particleSystem.canvasWidth=this.canvas2D.width,this.particleSystem.canvasHeight=this.canvas2D.height}}disableParticles(){this.core3D?.particleOrchestrator?.renderer&&(this.core3D.particleVisibility=!1,this.core3D.particleOrchestrator.renderer.setVisible(!1),this.core3D.particleOrchestrator.clear()),this.core3D?.particleOrchestrator||this.particleSystem&&(this.particleSystem.destroy(),this.particleSystem=null)}get particlesEnabled(){return this.core3D?.particleOrchestrator?!0===this.core3D.particleVisibility:null!==this.particleSystem}enableBlinking(){this.core3D&&(this.core3D.blinkingManuallyDisabled=!1,this.core3D.blinkAnimator&&this.core3D.blinkAnimator.resume())}disableBlinking(){this.core3D&&(this.core3D.blinkingManuallyDisabled=!0,this.core3D.blinkAnimator&&this.core3D.blinkAnimator.pause())}get blinkingEnabled(){return!(!this.core3D||!this.core3D.blinkAnimator)&&this.core3D.blinkAnimator.enabled}enableBreathing(){this.core3D&&(this.core3D.breathingEnabled=!0)}disableBreathing(){this.core3D&&(this.core3D.breathingEnabled=!1)}get breathingEnabled(){return!this.core3D||!1!==this.core3D.breathingEnabled}breathePhase(e,t){this.core3D&&this.core3D.breathePhase(e,t)}stopBreathingPhase(){this.core3D&&this.core3D.stopBreathingPhase()}enableWobble(){this.core3D&&this.core3D.setWobbleEnabled(!0)}disableWobble(){this.core3D&&this.core3D.setWobbleEnabled(!1)}get wobbleEnabled(){return!this.core3D||!1!==this.core3D.wobbleEnabled}enableRhythmSync(){this.core3D&&this.core3D.setRhythmEnabled(!0)}disableRhythmSync(){this.core3D&&this.core3D.setRhythmEnabled(!1)}get rhythmSyncEnabled(){return!!this.core3D&&this.core3D.rhythmEnabled}enableGroove(){this.core3D&&this.core3D.setGrooveEnabled(!0)}disableGroove(){this.core3D&&this.core3D.setGrooveEnabled(!1)}setBeatSyncStrength(e){this.core3D&&this.core3D.setBeatSyncStrength(e)}setGrooveConfidence(e){this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setGrooveConfidence(e)}getGrooveConfidence(){return this.core3D?.rhythm3DAdapter?.grooveConfidence??1}setBPMMultiplier(e){this.core3D?.rhythm3DAdapter&&this.core3D.rhythm3DAdapter.setBPMMultiplier(e)}getBPMMultiplier(){return this.core3D?.rhythm3DAdapter?.getBPMMultiplier()??1}setGrooveConfig(e){this.core3D&&this.core3D.setGrooveConfig(e)}setGroove(e,t={}){this.core3D&&this.core3D.setGroove(e,t)}getGroovePresets(){return this.core3D?this.core3D.getGroovePresets():["groove1","groove2","groove3"]}getCurrentGroove(){return this.core3D?this.core3D.getCurrentGroove():"groove1"}enableDance(){this.danceChoreographer&&this.danceChoreographer.enable()}disableDance(){this.danceChoreographer&&this.danceChoreographer.disable()}isDanceEnabled(){return this.danceChoreographer?.enabled??!1}setDanceIntensity(e){this.danceChoreographer&&this.danceChoreographer.setIntensity(e)}getDanceIntensity(){return this.danceChoreographer?.getIntensity()??.5}getDanceStatus(){return this.danceChoreographer?.getStatus()??{enabled:!1}}isRhythmPlaying(){return this.core3D?.isRhythmPlaying()||!1}getRhythmBPM(){return this.core3D?.getRhythmBPM()||120}startRhythm(e=120,t="straight"){this.core3D&&this.core3D.startRhythm(e,t)}stopRhythm(){this.core3D&&this.core3D.stopRhythm()}setRhythmBPM(e){this.core3D&&this.core3D.setRhythmBPM(e)}setRhythmPattern(e){this.core3D&&this.core3D.setRhythmPattern(e)}connectAudio(e){return this._getAudioBridge().connectAudio(e)}disconnectAudio(){this._audioBridge&&this._audioBridge.disconnectAudio()}getBPMStatus(){return this._audioBridge?this._audioBridge.getBPMStatus():{bpm:120,subdivision:1,confidence:0,locked:!1,lockStage:0,correctionType:"none",finalized:!1,grooveConfidence:1,agentCount:0,peakCount:0,histogramSize:0,topAgents:[],intervalCount:0}}getBPMDebugLog(){return this._audioBridge?this._audioBridge.getBPMDebugLog():"No audio bridge active."}resetBPMDetection(e=null){this._audioBridge&&this._audioBridge.resetBPMDetection(e)}rgbToHex(e){return`#${[Math.round(255*e[0]),Math.round(255*e[1]),Math.round(255*e[2])].map(e=>{const t=e.toString(16);return 1===t.length?`0${t}`:t}).join("")}`}setPosition(e,t,i=0){if(!this.container)return this;const a=this.position||{x:0,y:0,z:0};this.position={x:e,y:t,z:i};const n=window.innerWidth<768;return this.container.style.transform=n?`translate(calc(-50% + ${e}px), calc(-50% + ${t}px))`:`translate(${e}px, calc(-50% + ${t}px))`,this.eventManager&&this.eventManager.emit("position:change",{x:e,y:t,z:i,previous:a}),this}getPosition(){return this.position||{x:0,y:0,z:0}}getAvailableEmotions(){return Ei()}getAvailableGestures(){return Md()}getGestureCategories(){return vd}getAvailableGeometries(){return[...Uy]}animateToPosition(e,t,i=0,a=1e3,n="easeOutCubic"){if(!this.container)return;const s=this.getPosition(),r=performance.now(),o=n=>{const l=n-r,c=Math.min(l/a,1),h=(u=c,1-Math.pow(1-u,3));var u;const d=s.x+(e-s.x)*h,m=s.y+(t-s.y)*h,p=s.z+(i-s.z)*h;this.setPosition(d,m,p),c<1&&requestAnimationFrame(o)};requestAnimationFrame(o)}setContainment(e,t=1){const i=this._containmentScale||1;if(this._containmentBounds=e,this._containmentScale=t,this.particleSystem&&1!==t){const e=this.config.particleSpawnRadius||150;this.particleSystem.setSpawnRadius(e*t)}return this.eventManager&&t!==i&&this.eventManager.emit("scale:change",{scale:t,previous:i}),this}attachToElement(e,t={}){const i="string"==typeof e?document.querySelector(e):e;if(!i)return console.error(`[EmotiveMascot3D] Element not found: ${e}`),this;this._attachedElement=i,this._attachOptions={offsetX:t.offsetX||0,offsetY:t.offsetY||0,animate:!1!==t.animate,duration:t.duration||1e3,scale:t.scale||1,containParticles:!1!==t.containParticles},this._hasAttachedBefore=this._hasAttachedBefore||!1;const a=i.getBoundingClientRect();return this._attachOptions.containParticles?this.setContainment({width:a.width,height:a.height},this._attachOptions.scale):1!==this._attachOptions.scale&&this.setContainment(null,this._attachOptions.scale),this._updateAttachedPosition(),this._setupElementTracking(),this}_updateAttachedPosition(){if(!this._attachedElement||!this.container)return;const e=this._attachedElement.getBoundingClientRect(),t=this.container.getBoundingClientRect(),i=e.left+e.width/2,a=e.top+e.height/2,n=t.left+t.width/2,s=t.top+t.height/2,r=i-n+this._attachOptions.offsetX,o=a-s+this._attachOptions.offsetY,l=!this._hasAttachedBefore;this._hasAttachedBefore=!0,l&&this._attachOptions.animate?this.animateToPosition(r,o,0,this._attachOptions.duration):this.setPosition(r,o,0)}_setupElementTracking(){this._elementTrackingHandlers||(this._elementTrackingHandlers={scroll:()=>this._updateAttachedPosition(),resize:()=>this._updateAttachedPosition()},window.addEventListener("scroll",this._elementTrackingHandlers.scroll,{passive:!0}),window.addEventListener("resize",this._elementTrackingHandlers.resize))}isAttachedToElement(){return!!this._attachedElement}detachFromElement(){return this._attachedElement=null,this._hasAttachedBefore=!1,this._elementTrackingHandlers&&(window.removeEventListener("scroll",this._elementTrackingHandlers.scroll),window.removeEventListener("resize",this._elementTrackingHandlers.resize),this._elementTrackingHandlers=null),this.setContainment(null,1),this.setEmotion("neutral"),this}setSSSPreset(e,t={}){this._currentSSSPreset=e,this.core3D&&!this._materialSwapCallbackSet&&(this._materialSwapCallbackSet=!0,this.core3D.onMaterialSwap=()=>{this._currentSSSPreset&&setTimeout(()=>{Xf(this,this._currentSSSPreset)},50)});const i=Yf[e];if(!i||!this.core3D?.customMaterial?.uniforms)return!1;const a=this.core3D.customMaterial.uniforms;if(t.immediate||!this.core3D._targetSSSValues){const t=Xf(this,e);return t&&(this.core3D._targetSSSValues={...i},this.core3D._sssTransitionProgress=1,this.eventManager.emit("sss:presetChanged",{preset:e})),t}return this.core3D._sssTransitionStart={sssStrength:a.sssStrength?.value??i.sssStrength,sssAbsorption:a.sssAbsorption?.value?[a.sssAbsorption.value.x,a.sssAbsorption.value.y,a.sssAbsorption.value.z]:[...i.sssAbsorption],sssScatterDistance:a.sssScatterDistance?.value?[a.sssScatterDistance.value.x,a.sssScatterDistance.value.y,a.sssScatterDistance.value.z]:[...i.sssScatterDistance],sssThicknessBias:a.sssThicknessBias?.value??i.sssThicknessBias,sssThicknessScale:a.sssThicknessScale?.value??i.sssThicknessScale,sssCurvatureScale:a.sssCurvatureScale?.value??i.sssCurvatureScale,sssAmbient:a.sssAmbient?.value??i.sssAmbient,frostiness:a.frostiness?.value??i.frostiness,innerGlowStrength:a.innerGlowStrength?.value??i.innerGlowStrength,fresnelIntensity:a.fresnelIntensity?.value??i.fresnelIntensity,causticIntensity:a.causticIntensity?.value??i.causticIntensity,emotionColorBleed:a.emotionColorBleed?.value??i.emotionColorBleed},this.core3D._targetSSSValues={sssStrength:i.sssStrength,sssAbsorption:[...i.sssAbsorption],sssScatterDistance:[...i.sssScatterDistance],sssThicknessBias:i.sssThicknessBias,sssThicknessScale:i.sssThicknessScale,sssCurvatureScale:i.sssCurvatureScale,sssAmbient:i.sssAmbient,frostiness:i.frostiness,innerGlowStrength:i.innerGlowStrength,fresnelIntensity:i.fresnelIntensity,causticIntensity:i.causticIntensity,emotionColorBleed:i.emotionColorBleed},this.core3D._sssTransitionProgress=0,this.eventManager.emit("sss:presetChanged",{preset:e,transitioning:!0}),!0}setGeometry(e,t={}){return console.warn("[EmotiveMascot3D] setGeometry() is deprecated. Use morphTo() instead."),this.morphTo(e,t)}startSolarEclipse(e={}){this.core3D&&"function"==typeof this.core3D.startSolarEclipse?this.core3D.startSolarEclipse(e):(this.morphTo("sun"),this.eventManager.emit("eclipse:solar:start",{type:e.type||"total"}))}startLunarEclipse(e={}){this.core3D&&"function"==typeof this.core3D.startLunarEclipse?this.core3D.startLunarEclipse(e):(this.morphTo("moon"),this.eventManager.emit("eclipse:lunar:start",{type:e.type||"total"}))}setColorTransitionDuration(e){return this.core3D&&(this.core3D.colorTransitionDuration=e),this}setSSSTransitionDuration(e){return this.core3D&&(this.core3D.sssTransitionDuration=e),this}stopEclipse(){this.core3D&&"function"==typeof this.core3D.stopEclipse&&this.core3D.stopEclipse(),this.eventManager&&this.eventManager.emit("eclipse:stop")}destroy(){this._destroyed=!0,this.stop(),this._audioBridge&&(this._audioBridge.destroy(),this._audioBridge=null),this._elementTrackingHandlers&&(window.removeEventListener("scroll",this._elementTrackingHandlers.scroll),window.removeEventListener("resize",this._elementTrackingHandlers.resize),this._elementTrackingHandlers=null),this._attachedElement=null,this._reducedMotionMediaQuery&&this._reducedMotionHandler&&(this._reducedMotionMediaQuery.removeEventListener?this._reducedMotionMediaQuery.removeEventListener("change",this._reducedMotionHandler):this._reducedMotionMediaQuery.removeListener&&this._reducedMotionMediaQuery.removeListener(this._reducedMotionHandler),this._reducedMotionMediaQuery=null,this._reducedMotionHandler=null),this.gestureTimeouts.forEach(e=>clearTimeout(e)),this.gestureTimeouts=[],this.eventManager&&this.eventManager._listeners&&(Object.keys(this.eventManager._listeners).forEach(e=>{this.eventManager._listeners[e]=[]}),this.eventManager._listeners=null),this.core3D&&this.core3D.destroy(),this.particleSystem&&this.particleSystem.destroy(),this.danceChoreographer&&(this.danceChoreographer.destroy(),this.danceChoreographer=null),this._canvasLayerManager&&(this._canvasLayerManager.destroy(),this._canvasLayerManager=null),this.container=null,this.webglCanvas=null,this.canvas2D=null,this.ctx2D=null,this.config=null,this.errorBoundary=null,this.currentGesture=null}}const Hy=()=>"undefined"==typeof window;var $y=Object.freeze({__proto__:null,HDRLoader:class extends Ie{constructor(e){super(e),this.type=c}parse(e){const t=function(e,t){switch(e){case 1:throw new Error("THREE.HDRLoader: Read Error: "+(t||""));case 2:throw new Error("THREE.HDRLoader: Write Error: "+(t||""));case 3:throw new Error("THREE.HDRLoader: Bad File Format: "+(t||""));default:throw new Error("THREE.HDRLoader: Memory Error: "+(t||""))}},i=function(e,t,i){t=t||1024;let a=e.pos,n=-1,s=0,r="",o=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));for(;0>(n=o.indexOf("\n"))&&s<t&&a<e.byteLength;)r+=o,s+=o.length,a+=128,o+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));return-1<n&&(e.pos+=s+n+1,r+o.slice(0,n))},a=function(e,t,i,a){const n=e[t+3],s=Math.pow(2,n-128)/255;i[a+0]=e[t+0]*s,i[a+1]=e[t+1]*s,i[a+2]=e[t+2]*s,i[a+3]=1},n=function(e,t,i,a){const n=e[t+3],s=Math.pow(2,n-128)/255;i[a+0]=Re.toHalfFloat(Math.min(e[t+0]*s,65504)),i[a+1]=Re.toHalfFloat(Math.min(e[t+1]*s,65504)),i[a+2]=Re.toHalfFloat(Math.min(e[t+2]*s,65504)),i[a+3]=Re.toHalfFloat(1)},s=new Uint8Array(e);s.pos=0;const r=function(e){const a=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,n=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*FORMAT=(\S+)\s*$/,r=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,o={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;for((e.pos>=e.byteLength||!(l=i(e)))&&t(1,"no header found"),(c=l.match(/^#\?(\S+)/))||t(3,"bad initial token"),o.valid|=1,o.programtype=c[1],o.string+=l+"\n";l=i(e),!1!==l;)if(o.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(a))&&(o.gamma=parseFloat(c[1])),(c=l.match(n))&&(o.exposure=parseFloat(c[1])),(c=l.match(s))&&(o.valid|=2,o.format=c[1]),(c=l.match(r))&&(o.valid|=4,o.height=parseInt(c[1],10),o.width=parseInt(c[2],10)),2&o.valid&&4&o.valid)break}else o.comments+=l+"\n";return 2&o.valid||t(3,"missing format specifier"),4&o.valid||t(3,"missing image size specifier"),o}(s),o=r.width,l=r.height,h=function(e,i,a){const n=i;if(n<8||n>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);n!==(e[2]<<8|e[3])&&t(3,"wrong scanline width");const s=new Uint8Array(4*i*a);s.length||t(4,"unable to allocate buffer space");let r=0,o=0;const l=4*n,c=new Uint8Array(4),h=new Uint8Array(l);let u=a;for(;u>0&&o<e.byteLength;){o+4>e.byteLength&&t(1),c[0]=e[o++],c[1]=e[o++],c[2]=e[o++],c[3]=e[o++],2==c[0]&&2==c[1]&&(c[2]<<8|c[3])==n||t(3,"bad rgbe scanline format");let i,a=0;for(;a<l&&o<e.byteLength;){i=e[o++];const n=i>128;if(n&&(i-=128),(0===i||a+i>l)&&t(3,"bad scanline data"),n){const t=e[o++];for(let e=0;e<i;e++)h[a++]=t}else h.set(e.subarray(o,o+i),a),a+=i,o+=i}const d=n;for(let e=0;e<d;e++){let t=0;s[r]=h[e+t],t+=n,s[r+1]=h[e+t],t+=n,s[r+2]=h[e+t],t+=n,s[r+3]=h[e+t],r+=4}u--}return s}(s.subarray(s.pos),o,l);let u,d,m;switch(this.type){case Oe:m=h.length/4;const e=new Float32Array(4*m);for(let t=0;t<m;t++)a(h,4*t,e,4*t);u=e,d=Oe;break;case c:m=h.length/4;const t=new Uint16Array(4*m);for(let e=0;e<m;e++)n(h,4*e,t,4*e);u=t,d=c;break;default:throw new Error("THREE.HDRLoader: Unsupported type: "+this.type)}return{width:o,height:l,data:u,header:r.string,gamma:r.gamma,exposure:r.exposure,type:d}}setDataType(e){return this.type=e,this}load(e,t,i,a){return super.load(e,function(e,i){switch(e.type){case Oe:case c:e.colorSpace=q,e.minFilter=p,e.magFilter=p,e.generateMipmaps=!1,e.flipY=!0}t&&t(e,i)},i,a)}}});export{Ny as AudioInterpreter,zy as CORE_GEOMETRIES,Uf as Core3DManager,Od as CrystalSoul,Gy as ENGINE_VOCABULARY,Wy as EmotiveMascot3D,Li as GROOVE_PRESETS,Zd as GeometryCache,jy as LLM_ENDPOINTS,Kt as MOON_PHASES,Nf as PerformanceProfiler,Vi as Rhythm3DAdapter,Yf as SSSPresets,oi as animateMoonPhase,Xf as applySSSPreset,qy as audioInterpreter,qt as blendModeNames,By as createCrystal,Fy as createDiamond,ei as createMoon,si as createMoonCrescentMaterial,ai as createMoonFallbackMaterial,ii as createMoonMaterial,Ey as createSphere,pi as createSunGeometry,mi as createSunMaterial,Wy as default,Ly as disposeCoreGeometries,ti as disposeMoon,fi as disposeSun,Wt as getBlendModeIndex,Ut as getBlendModeName,Zt as getMoonPhaseNames,Jt as getPhaseFromProgress,Kf as getSSSPreset,Qf as getSSSPresetNames,Hy as isSSR,jf as profiler,Ni as rhythm3DAdapter,ri as setMoonPhase,ci as updateCrescentShadow,li as updateMoonGlow,gi as updateSunMaterial};
//# sourceMappingURL=emotive-mascot-3d.js.map
